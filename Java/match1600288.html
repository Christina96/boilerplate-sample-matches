<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TransportSwapRelationsAction.java & SessionTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TransportSwapRelationsAction.java & SessionTest.java
      </h3>
      <h1 align="center">
        12.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TransportSwapRelationsAction.java (36.305733%)<TH>SessionTest.java (7.6510067%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1600288-0.html#0',2,'match1600288-1.html#0',3)" NAME="0">(22-50)<TD><A HREF="javascript:ZweiFrames('match1600288-0.html#0',2,'match1600288-1.html#0',3)" NAME="0">(22-52)</A><TD ALIGN=center><FONT COLOR="#ff0000">27</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1600288-0.html#1',2,'match1600288-1.html#1',3)" NAME="1">(128-132)<TD><A HREF="javascript:ZweiFrames('match1600288-0.html#1',2,'match1600288-1.html#1',3)" NAME="1">(203-207)</A><TD ALIGN=center><FONT COLOR="#670000">11</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1600288-0.html#2',2,'match1600288-1.html#2',3)" NAME="2">(105-107)<TD><A HREF="javascript:ZweiFrames('match1600288-0.html#2',2,'match1600288-1.html#2',3)" NAME="2">(211-216)</A><TD ALIGN=center><FONT COLOR="#5e0000">10</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1600288-0.html#3',2,'match1600288-1.html#3',3)" NAME="3">(78-84)<TD><A HREF="javascript:ZweiFrames('match1600288-0.html#3',2,'match1600288-1.html#3',3)" NAME="3">(526-532)</A><TD ALIGN=center><FONT COLOR="#550000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TransportSwapRelationsAction.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1600288-1.html#0',3,'match1600288-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.crate.execution.ddl;

import io.crate.execution.support.ActionListeners;
import io.crate.metadata.RelationName;
import io.crate.metadata.cluster.DDLClusterStateService;
import org.elasticsearch.action.ActionListener;
import org.elasticsearch.action.support.ActiveShardsObserver;
import org.elasticsearch.action.support.IndicesOptions;
import org.elasticsearch.action.support.master.AcknowledgedResponse;
import org.elasticsearch.action.support.master.TransportMasterNodeAction;
import org.elasticsearch.cluster.AckedClusterStateUpdateTask;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.block.ClusterBlockException;
import org.elasticsearch.cluster.block.ClusterBlockLevel;
import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
import org.elasticsearch.cluster.routing.allocation.AllocationService;
import org.elasticsearch.cluster.service.ClusterService;
import org.elasticsearch.common.Priority;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.threadpool.ThreadPool;
import org.elasticsearch.transport.TransportService;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import</B></FONT> java.util.concurrent.atomic.AtomicReference;

public final class TransportSwapRelationsAction extends TransportMasterNodeAction&lt;SwapRelationsRequest, AcknowledgedResponse&gt; {

    private final SwapRelationsOperation swapRelationsOperation;
    private final ActiveShardsObserver activeShardsObserver;

    @Inject
    public TransportSwapRelationsAction(Settings settings,
                                        TransportService transportService,
                                        ClusterService clusterService,
                                        ThreadPool threadPool,
                                        IndexNameExpressionResolver indexNameExpressionResolver,
                                        DDLClusterStateService ddlClusterStateService,
                                        AllocationService allocationService) {
        super(
            &quot;internal:crate:sql/alter/cluster/indices&quot;,
            transportService,
            clusterService,
            threadPool,
            SwapRelationsRequest::new,
            indexNameExpressionResolver
        );
        this.activeShardsObserver = new ActiveShardsObserver(clusterService, threadPool);
        this.swapRelationsOperation = new SwapRelationsOperation(
<A NAME="3"></A>            allocationService, ddlClusterStateService, indexNameExpressionResolver);
    }

    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1600288-1.html#3',3,'match1600288-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
    protected String executor() {
        return ThreadPool.Names.SAME;
    }

    @Override
    protected AcknowledgedResponse read(StreamInput in</B></FONT>) throws IOException {
        return new AcknowledgedResponse(in);
    }

    @Override
    protected void masterOperation(SwapRelationsRequest request,
                                   ClusterState state,
                                   ActionListener&lt;AcknowledgedResponse&gt; listener) throws Exception {
        AtomicReference&lt;String[]&gt; indexNamesAfterRelationSwap = new AtomicReference&lt;&gt;(null);
        ActionListener&lt;AcknowledgedResponse&gt; waitForShardsListener = ActionListeners.waitForShards(
            listener,
            activeShardsObserver,
            request.ackTimeout(),
            () -&gt; logger.info(&quot;Switched name of relations, but the operation timed out waiting for enough shards to be started&quot;),
            indexNamesAfterRelationSwap::get
        );
        AckedClusterStateUpdateTask&lt;AcknowledgedResponse&gt; updateTask =
            new AckedClusterStateUpdateTask&lt;AcknowledgedResponse&gt;(Priority.HIGH, request, waitForShardsListener) {
<A NAME="2"></A>
                @Override
                public ClusterState execute(ClusterState currentState) throws Exception {
                    if (logger.isInfoEnabled()) <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1600288-1.html#2',3,'match1600288-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
                        Iterable&lt;String&gt; swapActions = request.swapActions().stream()
                            .map(x -&gt; x.source().fqn() + &quot; &lt;-&gt; &quot; + x.target</B></FONT>().fqn())
                            ::iterator;
                        logger.info(&quot;Swapping tables [{}]&quot;, String.join(&quot;, &quot;, swapActions));
                    }
                    SwapRelationsOperation.UpdatedState newState = swapRelationsOperation.execute(currentState, request);
                    indexNamesAfterRelationSwap.set(newState.newIndices.toArray(new String[0]));
                    return newState.newState;
                }

                @Override
                protected AcknowledgedResponse newResponse(boolean acknowledged) {
                    return new AcknowledgedResponse(acknowledged);
                }
            };
        clusterService.submitStateUpdateTask(&quot;swap-relations&quot;, updateTask);
    }

    @Override
<A NAME="1"></A>    protected ClusterBlockException checkBlock(SwapRelationsRequest request, ClusterState state) {
        Set&lt;String&gt; affectedIndices = new HashSet&lt;&gt;();
        for (RelationNameSwap swapAction : request.swapActions()) {
            <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1600288-1.html#1',3,'match1600288-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
                state, IndicesOptions.LENIENT_EXPAND_OPEN, swapAction.source().indexNameOrAlias())));
            affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
                state, IndicesOptions.LENIENT_EXPAND_OPEN, swapAction.target().indexNameOrAlias())));
        }</B></FONT>
        for (RelationName dropRelation : request.dropRelations()) {
            affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
                state, IndicesOptions.LENIENT_EXPAND_OPEN, dropRelation.indexNameOrAlias())));
        }
        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, affectedIndices.toArray(new String[0]));
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SessionTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1600288-0.html#0',2,'match1600288-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.crate.action.sql;

import static java.util.concurrent.CompletableFuture.completedFuture;
import static org.hamcrest.Matchers.arrayContaining;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.nullValue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import org.elasticsearch.threadpool.ThreadPool;
import org.hamcrest.Matchers;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import org.mockito.Answers;
import org.mockito.Mockito;

import io.crate.analyze.AnalyzedStatement;
import io.crate.analyze.ParamTypeHints;
import</B></FONT> io.crate.analyze.Relations;
import io.crate.analyze.TableDefinitions;
import io.crate.auth.AccessControl;
import io.crate.data.Row;
import io.crate.data.RowConsumer;
import io.crate.execution.engine.collect.stats.JobsLogs;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.ParameterSymbol;
import io.crate.expression.symbol.Symbol;
import io.crate.planner.DependencyCarrier;
import io.crate.planner.Plan;
import io.crate.planner.Planner;
import io.crate.planner.PlannerContext;
import io.crate.planner.operators.SubQueryResults;
import io.crate.protocols.postgres.Portal;
import io.crate.sql.parser.SqlParser;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.types.DataType;
import io.crate.types.DataTypes;

public class SessionTest extends CrateDummyClusterServiceUnitTest {

    @Test
    public void testParameterTypeExtractorNotApplicable() {
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        assertThat(typeExtractor.getParameterTypes(s -&gt; {}).length, is(0));
    }

    @Test
    public void testParameterTypeExtractor() {
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        List&lt;Symbol&gt; symbolsToVisit = new ArrayList&lt;&gt;();
        symbolsToVisit.add(Literal.of(1));
        symbolsToVisit.add(Literal.of(&quot;foo&quot;));
        symbolsToVisit.add(new ParameterSymbol(1, DataTypes.LONG));
        symbolsToVisit.add(new ParameterSymbol(0, DataTypes.INTEGER));
        symbolsToVisit.add(new ParameterSymbol(3, DataTypes.STRING));
        symbolsToVisit.add(Literal.of(&quot;bar&quot;));
        symbolsToVisit.add(new ParameterSymbol(2, DataTypes.DOUBLE));
        symbolsToVisit.add(new ParameterSymbol(1, DataTypes.LONG));
        symbolsToVisit.add(new ParameterSymbol(0, DataTypes.INTEGER));
        symbolsToVisit.add(Literal.of(1.2));

        Consumer&lt;Consumer&lt;? super Symbol&gt;&gt; symbolVisitor = c -&gt; {
            for (Symbol symbol : symbolsToVisit) {
                c.accept(symbol);
            }
        };
        DataType[] parameterTypes = typeExtractor.getParameterTypes(symbolVisitor);
        assertThat(parameterTypes, equalTo(new DataType[] {
            DataTypes.INTEGER,
            DataTypes.LONG,
            DataTypes.DOUBLE,
            DataTypes.STRING,
        }));

        symbolsToVisit.add(new ParameterSymbol(4, DataTypes.BOOLEAN));
        parameterTypes = typeExtractor.getParameterTypes(symbolVisitor);
        assertThat(parameterTypes, equalTo(new DataType[] {
            DataTypes.INTEGER,
            DataTypes.LONG,
            DataTypes.DOUBLE,
            DataTypes.STRING,
            DataTypes.BOOLEAN
        }));

        expectedException.expect(IllegalStateException.class);
        expectedException.expectMessage(&quot;The assembled list of ParameterSymbols is invalid.&quot;);
        // remove the double parameter =&gt; make the input invalid
        symbolsToVisit.remove(6);
        typeExtractor.getParameterTypes(symbolVisitor);
    }

    @Test
    public void test_out_of_bounds_getParamType_fails() throws Exception {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            mock(DependencyCarrier.class),
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse(&quot;S_1&quot;, &quot;Select 1 + ? + ?;&quot;, Collections.emptyList());
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -&gt; session.getParamType(&quot;S_1&quot;, 3),
            &quot;foo&quot;
        );
    }

    @Test
    public void test_getParamType_returns_types_infered_from_statement() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        DependencyCarrier executor = mock(DependencyCarrier.class);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse(&quot;S_1&quot;, &quot;Select 1 + ? + ?;&quot;, Collections.emptyList());
        assertThat(session.getParamType(&quot;S_1&quot;, 0), is(DataTypes.INTEGER));
        assertThat(session.getParamType(&quot;S_1&quot;, 1), is(DataTypes.INTEGER));

        DescribeResult describe = session.describe('S', &quot;S_1&quot;);
        assertThat(describe.getParameters(), equalTo(new DataType[] { DataTypes.INTEGER, DataTypes.INTEGER }));

        assertThat(session.getParamType(&quot;S_1&quot;, 0), is(DataTypes.INTEGER));
        assertThat(session.getParamType(&quot;S_1&quot;, 1), is(DataTypes.INTEGER));
    }

    @Test
    public void test_select_query_executed_on_session_execute_method() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        Session session = Mockito.spy(new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            mock(DependencyCarrier.class),
            AccessControl.DISABLED,
            SessionContext.systemSessionContext())
        );

        var activeExecutionFuture = CompletableFuture.completedFuture(null);
        doReturn(activeExecutionFuture)
            .when(session)
            .singleExec(any(Portal.class), any(ResultReceiver.class), anyInt());

        session.parse(&quot;S_1&quot;, &quot;select name from sys.cluster;&quot;, List.of());
        session.bind(&quot;Portal&quot;, &quot;S_1&quot;, Collections.emptyList(), null);
        session.describe('S', &quot;S_1&quot;);
        session.execute(&quot;Portal&quot;, 1, new BaseResultReceiver());

        assertThat(session.portals.size(), is(1));
        assertThat(session.preparedStatements.size(), is(1));
        assertThat(session.deferredExecutionsByStmt.size(), is(0));
        assertThat(session.activeExecution, is(activeExecutionFuture));
<A NAME="1"></A>
        session.close();

        assertThat(session.portals.size(), <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1600288-0.html#1',2,'match1600288-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>is(0));
        assertThat(session.preparedStatements.size(), is(0));
        assertThat(session.deferredExecutionsByStmt.size(), is(0));
        assertThat(session.activeExecution, is(nullValue()));
    }</B></FONT>
<A NAME="2"></A>

    @Test
    public void test_flush_triggers_deferred_executions_and_sets_active_execution() throws Exception <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1600288-0.html#2',2,'match1600288-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (name text)&quot;)
            .build();
        DependencyCarrier dependencies = mock(DependencyCarrier.class);
        when(dependencies.clusterService</B></FONT>()).thenReturn(clusterService);
        Session session = Mockito.spy(new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            mock(Planner.class, Answers.RETURNS_MOCKS),
            new JobsLogs(() -&gt; false),
            false,
            dependencies,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext())
        );
        session.parse(&quot;&quot;, &quot;insert into users (name) values (?)&quot;, List.of());
        session.bind(&quot;&quot;, &quot;&quot;, List.of(&quot;Arthur&quot;), null);
        session.execute(&quot;&quot;, -1, new BaseResultReceiver());
        assertThat(session.deferredExecutionsByStmt.size(), is(1));
        session.flush();
        var activeExecution = session.activeExecution;
        assertThat(activeExecution, Matchers.notNullValue());

        CompletableFuture&lt;?&gt; sync = session.sync();
        assertThat(sync, Matchers.sameInstance(activeExecution));
    }

    @Test
    public void testExtractTypesFromDelete() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement(&quot;delete from users where name = ?&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[] { DataTypes.STRING }));
    }

    @Test
    public void testExtractTypesFromUpdate() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement(&quot;update users set name = ? || '_updated' where id = ?&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[] { DataTypes.STRING, DataTypes.LONG }));
    }

    @Test
    public void testExtractTypesFromInsertValues() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement(&quot;INSERT INTO users (id, name) values (?, ?)&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[] { DataTypes.LONG, DataTypes.STRING }));
    }

    @Test
    public void testExtractTypesFromInsertFromQuery() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .enableDefaultTables()
            .build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement(&quot;INSERT INTO users (id, name) (SELECT id, name FROM users_clustered_by_only &quot; +
                                      &quot;WHERE name = ?)&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[]{DataTypes.STRING}));
    }

    @Test
    public void testExtractTypesFromInsertWithOnDuplicateKey() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .enableDefaultTables()
            .build();
        AnalyzedStatement analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement(&quot;INSERT INTO users (id, name) values (?, ?) &quot; +
                                      &quot;ON CONFLICT (id) DO UPDATE SET name = ?&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[]{DataTypes.LONG, DataTypes.STRING, DataTypes.STRING}));

        analyzedStatement = e.analyzer.analyze(
            SqlParser.createStatement(&quot;INSERT INTO users (id, name) (SELECT id, name FROM users_clustered_by_only &quot; +
                                      &quot;WHERE name = ?) ON CONFLICT (id) DO UPDATE SET name = ?&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        typeExtractor = new ParameterTypeExtractor();
        parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);

        assertThat(parameterTypes, is(new DataType[]{DataTypes.STRING, DataTypes.STRING}));
    }

    @Test
    public void testTypesCanBeResolvedIfParametersAreInSubRelation() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService).build();

        AnalyzedStatement stmt = e.analyzer.analyze(
            SqlParser.createStatement(&quot;select * from (select $1::int + $2) t&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
            consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
        assertThat(parameterTypes, arrayContaining(is(DataTypes.INTEGER), is(DataTypes.INTEGER)));
    }

    @Test
    public void testTypesCanBeResolvedIfParametersAreInSubRelationOfInsertStatement() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table t (x int)&quot;)
            .build();

        AnalyzedStatement stmt = e.analyzer.analyze(
            SqlParser.createStatement(&quot;insert into t (x) (select * from (select $1::int + $2) t)&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
            consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
        assertThat(parameterTypes, arrayContaining(is(DataTypes.INTEGER), is(DataTypes.INTEGER)));
    }

    @Test
    public void testTypesCanBeResolvedIfParametersAreInSubQueryInDeleteStatement() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table t (x int)&quot;)
            .build();

        AnalyzedStatement stmt = e.analyzer.analyze(
            SqlParser.createStatement(&quot;delete from t where x = (select $1::long)&quot;),
            SessionContext.systemSessionContext(),
            ParamTypeHints.EMPTY
        );
        DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
            consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
        assertThat(parameterTypes, arrayContaining(is(DataTypes.LONG)));
    }

    @Test
    public void testProperCleanupOnSessionClose() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();

        DependencyCarrier executor = mock(DependencyCarrier.class);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse(&quot;S_1&quot;, &quot;select name from sys.cluster;&quot;, Collections.emptyList());
        session.bind(&quot;Portal&quot;, &quot;S_1&quot;, Collections.emptyList(), null);
        session.describe('S', &quot;S_1&quot;);

        session.parse(&quot;S_2&quot;, &quot;select id from sys.cluster&quot;, Collections.emptyList());
        session.bind(&quot;&quot;, &quot;S_2&quot;, Collections.emptyList(), null);
        session.describe('S', &quot;S_2&quot;);

        assertThat(session.portals.size(), is(2));
        assertThat(session.preparedStatements.size(), is(2));
        assertThat(session.deferredExecutionsByStmt.size(), is(0));

        session.close();

        assertThat(session.portals.size(), is(0));
        assertThat(session.preparedStatements.size(), is(0));
        assertThat(session.deferredExecutionsByStmt.size(), is(0));
        assertThat(session.activeExecution, is(nullValue()));
    }

    @Test
    public void testDeallocateAllClearsAllPortalsAndPreparedStatements() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();

        DependencyCarrier executor = mock(DependencyCarrier.class);
        when(executor.threadPool()).thenReturn(mock(ThreadPool.class));
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse(&quot;S_1&quot;, &quot;select * from sys.cluster;&quot;, Collections.emptyList());
        session.bind(&quot;Portal&quot;, &quot;S_1&quot;, Collections.emptyList(), null);
        session.describe('S', &quot;S_1&quot;);

        session.parse(&quot;S_2&quot;, &quot;DEALLOCATE ALL;&quot;, Collections.emptyList());
        session.bind(&quot;&quot;, &quot;S_2&quot;, Collections.emptyList(), null);
        session.execute(&quot;&quot;, 0, new BaseResultReceiver());

        assertThat(session.portals.size(), greaterThan(0));
        assertThat(session.preparedStatements.size(), is(0));
    }

    @Test
    public void testDeallocatePreparedStatementClearsPreparedStatement() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();

        DependencyCarrier executor = mock(DependencyCarrier.class);
        when(executor.threadPool()).thenReturn(mock(ThreadPool.class));
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse(&quot;test_prep_stmt&quot;, &quot;select * from sys.cluster;&quot;, Collections.emptyList());
        session.bind(&quot;Portal&quot;, &quot;test_prep_stmt&quot;, Collections.emptyList(), null);
        session.describe('S', &quot;test_prep_stmt&quot;);

        session.parse(&quot;stmt&quot;, &quot;DEALLOCATE test_prep_stmt;&quot;, Collections.emptyList());
        session.bind(&quot;&quot;, &quot;stmt&quot;, Collections.emptyList(), null);
        session.execute(&quot;&quot;, 0, new BaseResultReceiver());

        assertThat(session.portals.size(), greaterThan(0));
        assertThat(session.preparedStatements.size(), is(1));
        assertThat(session.preparedStatements.get(&quot;stmt&quot;).rawStatement(), is(&quot;DEALLOCATE test_prep_stmt;&quot;));
    }

    @Test
    public void test_closing_a_statement_closes_related_portals() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse(&quot;S_1&quot;, &quot;SELECT 1&quot;, List.of());
        session.bind(&quot;P_1&quot;, &quot;S_1&quot;, List.of(), null);

        assertThat(session.portals.size(), is(1));
        assertThat(session.preparedStatements.size(), is(1));

        session.close((byte) 'S', &quot;S_1&quot;);
        assertThat(session.portals.entrySet(), Matchers.empty());
        assertThat(session.preparedStatements.entrySet(), Matchers.empty());
    }

    @Test
    public void test_discard_all_discards_all_portals_and_prepared_statements() throws Exception {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
        DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            sqlExecutor.planner,
            new JobsLogs(() -&gt; false),
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse(&quot;S_1&quot;, &quot;SELECT 1&quot;, List.of());
        session.bind(&quot;P_1&quot;, &quot;S_1&quot;, List.of(), null);

        assertThat(session.portals.size(), is(1));
        assertThat(session.preparedStatements.size(), is(1));

        session.parse(&quot;stmt&quot;, &quot;DISCARD ALL&quot;, Collections.emptyList());
        session.bind(&quot;&quot;, &quot;stmt&quot;, Collections.emptyList(), null);
        session.execute(&quot;&quot;, 0, new BaseResultReceiver());

        assertThat(session.portals.entrySet(), Matchers.empty());
        assertThat(session.preparedStatements.entrySet(), Matchers.empty());
    }

    @Test
    public void test_bulk_operations_result_in_jobslog_entries() throws Exception {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table t1 (x int)&quot;)
            .build();
        DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
<A NAME="3"></A>        Planner planner = mock(Planner.class);
        when(planner.plan(any(AnalyzedStatement.class), any(PlannerContext.class)))
            .thenReturn(new Plan() {
                            <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1600288-0.html#3',2,'match1600288-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
                            public StatementType type() {
                                return StatementType.INSERT;
                            }

                            @Override
                            public void executeOrFail(DependencyCarrier dependencies</B></FONT>, PlannerContext plannerContext, RowConsumer consumer, Row params, SubQueryResults subQueryResults) throws Exception {

                            }

                            @Override
                            public List&lt;CompletableFuture&lt;Long&gt;&gt; executeBulk(DependencyCarrier executor, PlannerContext plannerContext, List&lt;Row&gt; bulkParams, SubQueryResults subQueryResults) {
                                return List.of(completedFuture(1L), completedFuture(1L));
                            }
                        }
            );
        JobsLogs jobsLogs = new JobsLogs(() -&gt; true);
        Session session = new Session(
            sqlExecutor.nodeCtx,
            sqlExecutor.analyzer,
            planner,
            jobsLogs,
            false,
            executor,
            AccessControl.DISABLED,
            SessionContext.systemSessionContext());

        session.parse(&quot;S_1&quot;, &quot;INSERT INTO t1 (x) VALUES (1)&quot;, List.of());
        session.bind(&quot;P_1&quot;, &quot;S_1&quot;, List.of(), null);
        session.execute(&quot;P_1&quot;, 0, new BaseResultReceiver());

        session.bind(&quot;P_1&quot;, &quot;S_1&quot;, List.of(), null);
        session.execute(&quot;P_1&quot;, 0, new BaseResultReceiver());

        session.sync().get(5, TimeUnit.SECONDS);
        assertThat(jobsLogs.metrics().iterator().next().totalCount(), is(1L));
    }


    @Test
    public void test_can_extract_parameters_from_match_predicate() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (name text, keywords text)&quot;)
            .build();
        AnalyzedStatement statement = e.analyze(
            &quot;select * from users where match(keywords, ?) using best_fields with (fuzziness= ?) and name = ?&quot;);
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(statement::visitSymbols);
        assertThat(parameterTypes, arrayContaining(DataTypes.STRING, DataTypes.UNDEFINED, DataTypes.STRING));
    }


    @Test
    public void test_can_extract_parameters_from_join_condition() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table subscriptions (id text primary key, name text not null)&quot;)
            .addTable(&quot;create table clusters (id text, subscription_id text)&quot;)
            .build();

        AnalyzedStatement stmt = e.analyze(&quot;&quot;&quot;
            select
                *
            from subscriptions
            join clusters on clusters.subscription_id = subscriptions.id
                AND subscriptions.name = ?
        &quot;&quot;&quot;);
        ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
        DataType[] parameterTypes = typeExtractor.getParameterTypes(stmt::visitSymbols);
        assertThat(parameterTypes, arrayContaining(DataTypes.STRING));
    }
}
</PRE>
</div>
  </div>
</body>
</html>
