<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TransportSwapRelationsAction.java &amp; SessionTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TransportSwapRelationsAction.java &amp; SessionTest.java
      </h3>
<h1 align="center">
        12.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TransportSwapRelationsAction.java (36.305733%)<th>SessionTest.java (7.6510067%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-50)<td><a href="#" name="0">(22-52)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(128-132)<td><a href="#" name="1">(203-207)</a><td align="center"><font color="#670000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(105-107)<td><a href="#" name="2">(211-216)</a><td align="center"><font color="#5e0000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(78-84)<td><a href="#" name="3">(526-532)</a><td align="center"><font color="#550000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TransportSwapRelationsAction.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19 <a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.execution.ddl;
22 import io.crate.execution.support.ActionListeners;
23 import io.crate.metadata.RelationName;
24 import io.crate.metadata.cluster.DDLClusterStateService;
25 import org.elasticsearch.action.ActionListener;
26 import org.elasticsearch.action.support.ActiveShardsObserver;
27 import org.elasticsearch.action.support.IndicesOptions;
28 import org.elasticsearch.action.support.master.AcknowledgedResponse;
29 import org.elasticsearch.action.support.master.TransportMasterNodeAction;
30 import org.elasticsearch.cluster.AckedClusterStateUpdateTask;
31 import org.elasticsearch.cluster.ClusterState;
32 import org.elasticsearch.cluster.block.ClusterBlockException;
33 import org.elasticsearch.cluster.block.ClusterBlockLevel;
34 import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
35 import org.elasticsearch.cluster.routing.allocation.AllocationService;
36 import org.elasticsearch.cluster.service.ClusterService;
37 import org.elasticsearch.common.Priority;
38 import org.elasticsearch.common.inject.Inject;
39 import org.elasticsearch.common.io.stream.StreamInput;
40 import org.elasticsearch.common.settings.Settings;
41 import org.elasticsearch.threadpool.ThreadPool;
42 import org.elasticsearch.transport.TransportService;
43 import java.io.IOException;
44 import java.util.Arrays;
45 import java.util.HashSet;
46 import java.util.Set;
47 import</b></font> java.util.concurrent.atomic.AtomicReference;
48 public final class TransportSwapRelationsAction extends TransportMasterNodeAction&lt;SwapRelationsRequest, AcknowledgedResponse&gt; {
49     private final SwapRelationsOperation swapRelationsOperation;
50     private final ActiveShardsObserver activeShardsObserver;
51     @Inject
52     public TransportSwapRelationsAction(Settings settings,
53                                         TransportService transportService,
54                                         ClusterService clusterService,
55                                         ThreadPool threadPool,
56                                         IndexNameExpressionResolver indexNameExpressionResolver,
57                                         DDLClusterStateService ddlClusterStateService,
58                                         AllocationService allocationService) {
59         super(
60             "internal:crate:sql/alter/cluster/indices",
61             transportService,
62             clusterService,
63             threadPool,
64             SwapRelationsRequest::new,
65             indexNameExpressionResolver
66         );
67         this.activeShardsObserver = new ActiveShardsObserver(clusterService, threadPool);
68         this.swapRelationsOperation = new SwapRelationsOperation(
69 <a name="3"></a>            allocationService, ddlClusterStateService, indexNameExpressionResolver);
70     }
71     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
72     protected String executor() {
73         return ThreadPool.Names.SAME;
74     }
75     @Override
76     protected AcknowledgedResponse read(StreamInput in</b></font>) throws IOException {
77         return new AcknowledgedResponse(in);
78     }
79     @Override
80     protected void masterOperation(SwapRelationsRequest request,
81                                    ClusterState state,
82                                    ActionListener&lt;AcknowledgedResponse&gt; listener) throws Exception {
83         AtomicReference&lt;String[]&gt; indexNamesAfterRelationSwap = new AtomicReference&lt;&gt;(null);
84         ActionListener&lt;AcknowledgedResponse&gt; waitForShardsListener = ActionListeners.waitForShards(
85             listener,
86             activeShardsObserver,
87             request.ackTimeout(),
88             () -&gt; logger.info("Switched name of relations, but the operation timed out waiting for enough shards to be started"),
89             indexNamesAfterRelationSwap::get
90         );
91         AckedClusterStateUpdateTask&lt;AcknowledgedResponse&gt; updateTask =
92             new AckedClusterStateUpdateTask&lt;AcknowledgedResponse&gt;(Priority.HIGH, request, waitForShardsListener) {
93 <a name="2"></a>
94                 @Override
95                 public ClusterState execute(ClusterState currentState) throws Exception {
96                     if (logger.isInfoEnabled()) <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
97                         Iterable&lt;String&gt; swapActions = request.swapActions().stream()
98                             .map(x -&gt; x.source().fqn() + " &lt;-&gt; " + x.target</b></font>().fqn())
99                             ::iterator;
100                         logger.info("Swapping tables [{}]", String.join(", ", swapActions));
101                     }
102                     SwapRelationsOperation.UpdatedState newState = swapRelationsOperation.execute(currentState, request);
103                     indexNamesAfterRelationSwap.set(newState.newIndices.toArray(new String[0]));
104                     return newState.newState;
105                 }
106                 @Override
107                 protected AcknowledgedResponse newResponse(boolean acknowledged) {
108                     return new AcknowledgedResponse(acknowledged);
109                 }
110             };
111         clusterService.submitStateUpdateTask("swap-relations", updateTask);
112     }
113     @Override
114 <a name="1"></a>    protected ClusterBlockException checkBlock(SwapRelationsRequest request, ClusterState state) {
115         Set&lt;String&gt; affectedIndices = new HashSet&lt;&gt;();
116         for (RelationNameSwap swapAction : request.swapActions()) {
117             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
118                 state, IndicesOptions.LENIENT_EXPAND_OPEN, swapAction.source().indexNameOrAlias())));
119             affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
120                 state, IndicesOptions.LENIENT_EXPAND_OPEN, swapAction.target().indexNameOrAlias())));
121         }</b></font>
122         for (RelationName dropRelation : request.dropRelations()) {
123             affectedIndices.addAll(Arrays.asList(indexNameExpressionResolver.concreteIndexNames(
124                 state, IndicesOptions.LENIENT_EXPAND_OPEN, dropRelation.indexNameOrAlias())));
125         }
126         return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, affectedIndices.toArray(new String[0]));
127     }
128 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SessionTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19 <a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.action.sql;
22 import static java.util.concurrent.CompletableFuture.completedFuture;
23 import static org.hamcrest.Matchers.arrayContaining;
24 import static org.hamcrest.Matchers.equalTo;
25 import static org.hamcrest.Matchers.greaterThan;
26 import static org.hamcrest.Matchers.is;
27 import static org.hamcrest.Matchers.nullValue;
28 import static org.mockito.ArgumentMatchers.any;
29 import static org.mockito.ArgumentMatchers.anyInt;
30 import static org.mockito.Mockito.doReturn;
31 import static org.mockito.Mockito.mock;
32 import static org.mockito.Mockito.when;
33 import java.util.ArrayList;
34 import java.util.Collections;
35 import java.util.List;
36 import java.util.concurrent.CompletableFuture;
37 import java.util.concurrent.TimeUnit;
38 import java.util.function.Consumer;
39 import org.elasticsearch.threadpool.ThreadPool;
40 import org.hamcrest.Matchers;
41 import org.junit.Test;
42 import org.junit.jupiter.api.Assertions;
43 import org.mockito.Answers;
44 import org.mockito.Mockito;
45 import io.crate.analyze.AnalyzedStatement;
46 import io.crate.analyze.ParamTypeHints;
47 import</b></font> io.crate.analyze.Relations;
48 import io.crate.analyze.TableDefinitions;
49 import io.crate.auth.AccessControl;
50 import io.crate.data.Row;
51 import io.crate.data.RowConsumer;
52 import io.crate.execution.engine.collect.stats.JobsLogs;
53 import io.crate.expression.symbol.Literal;
54 import io.crate.expression.symbol.ParameterSymbol;
55 import io.crate.expression.symbol.Symbol;
56 import io.crate.planner.DependencyCarrier;
57 import io.crate.planner.Plan;
58 import io.crate.planner.Planner;
59 import io.crate.planner.PlannerContext;
60 import io.crate.planner.operators.SubQueryResults;
61 import io.crate.protocols.postgres.Portal;
62 import io.crate.sql.parser.SqlParser;
63 import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
64 import io.crate.testing.SQLExecutor;
65 import io.crate.types.DataType;
66 import io.crate.types.DataTypes;
67 public class SessionTest extends CrateDummyClusterServiceUnitTest {
68     @Test
69     public void testParameterTypeExtractorNotApplicable() {
70         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
71         assertThat(typeExtractor.getParameterTypes(s -&gt; {}).length, is(0));
72     }
73     @Test
74     public void testParameterTypeExtractor() {
75         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
76         List&lt;Symbol&gt; symbolsToVisit = new ArrayList&lt;&gt;();
77         symbolsToVisit.add(Literal.of(1));
78         symbolsToVisit.add(Literal.of("foo"));
79         symbolsToVisit.add(new ParameterSymbol(1, DataTypes.LONG));
80         symbolsToVisit.add(new ParameterSymbol(0, DataTypes.INTEGER));
81         symbolsToVisit.add(new ParameterSymbol(3, DataTypes.STRING));
82         symbolsToVisit.add(Literal.of("bar"));
83         symbolsToVisit.add(new ParameterSymbol(2, DataTypes.DOUBLE));
84         symbolsToVisit.add(new ParameterSymbol(1, DataTypes.LONG));
85         symbolsToVisit.add(new ParameterSymbol(0, DataTypes.INTEGER));
86         symbolsToVisit.add(Literal.of(1.2));
87         Consumer&lt;Consumer&lt;? super Symbol&gt;&gt; symbolVisitor = c -&gt; {
88             for (Symbol symbol : symbolsToVisit) {
89                 c.accept(symbol);
90             }
91         };
92         DataType[] parameterTypes = typeExtractor.getParameterTypes(symbolVisitor);
93         assertThat(parameterTypes, equalTo(new DataType[] {
94             DataTypes.INTEGER,
95             DataTypes.LONG,
96             DataTypes.DOUBLE,
97             DataTypes.STRING,
98         }));
99         symbolsToVisit.add(new ParameterSymbol(4, DataTypes.BOOLEAN));
100         parameterTypes = typeExtractor.getParameterTypes(symbolVisitor);
101         assertThat(parameterTypes, equalTo(new DataType[] {
102             DataTypes.INTEGER,
103             DataTypes.LONG,
104             DataTypes.DOUBLE,
105             DataTypes.STRING,
106             DataTypes.BOOLEAN
107         }));
108         expectedException.expect(IllegalStateException.class);
109         expectedException.expectMessage("The assembled list of ParameterSymbols is invalid.");
110         symbolsToVisit.remove(6);
111         typeExtractor.getParameterTypes(symbolVisitor);
112     }
113     @Test
114     public void test_out_of_bounds_getParamType_fails() throws Exception {
115         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
116         Session session = new Session(
117             sqlExecutor.nodeCtx,
118             sqlExecutor.analyzer,
119             sqlExecutor.planner,
120             new JobsLogs(() -&gt; false),
121             false,
122             mock(DependencyCarrier.class),
123             AccessControl.DISABLED,
124             SessionContext.systemSessionContext());
125         session.parse("S_1", "Select 1 + ? + ?;", Collections.emptyList());
126         Assertions.assertThrows(
127             IllegalArgumentException.class,
128             () -&gt; session.getParamType("S_1", 3),
129             "foo"
130         );
131     }
132     @Test
133     public void test_getParamType_returns_types_infered_from_statement() {
134         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
135         DependencyCarrier executor = mock(DependencyCarrier.class);
136         Session session = new Session(
137             sqlExecutor.nodeCtx,
138             sqlExecutor.analyzer,
139             sqlExecutor.planner,
140             new JobsLogs(() -&gt; false),
141             false,
142             executor,
143             AccessControl.DISABLED,
144             SessionContext.systemSessionContext());
145         session.parse("S_1", "Select 1 + ? + ?;", Collections.emptyList());
146         assertThat(session.getParamType("S_1", 0), is(DataTypes.INTEGER));
147         assertThat(session.getParamType("S_1", 1), is(DataTypes.INTEGER));
148         DescribeResult describe = session.describe('S', "S_1");
149         assertThat(describe.getParameters(), equalTo(new DataType[] { DataTypes.INTEGER, DataTypes.INTEGER }));
150         assertThat(session.getParamType("S_1", 0), is(DataTypes.INTEGER));
151         assertThat(session.getParamType("S_1", 1), is(DataTypes.INTEGER));
152     }
153     @Test
154     public void test_select_query_executed_on_session_execute_method() {
155         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
156         Session session = Mockito.spy(new Session(
157             sqlExecutor.nodeCtx,
158             sqlExecutor.analyzer,
159             sqlExecutor.planner,
160             new JobsLogs(() -&gt; false),
161             false,
162             mock(DependencyCarrier.class),
163             AccessControl.DISABLED,
164             SessionContext.systemSessionContext())
165         );
166         var activeExecutionFuture = CompletableFuture.completedFuture(null);
167         doReturn(activeExecutionFuture)
168             .when(session)
169             .singleExec(any(Portal.class), any(ResultReceiver.class), anyInt());
170         session.parse("S_1", "select name from sys.cluster;", List.of());
171         session.bind("Portal", "S_1", Collections.emptyList(), null);
172         session.describe('S', "S_1");
173         session.execute("Portal", 1, new BaseResultReceiver());
174         assertThat(session.portals.size(), is(1));
175         assertThat(session.preparedStatements.size(), is(1));
176         assertThat(session.deferredExecutionsByStmt.size(), is(0));
177         assertThat(session.activeExecution, is(activeExecutionFuture));
178 <a name="1"></a>
179         session.close();
180         assertThat(session.portals.size(), <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>is(0));
181         assertThat(session.preparedStatements.size(), is(0));
182         assertThat(session.deferredExecutionsByStmt.size(), is(0));
183         assertThat(session.activeExecution, is(nullValue()));
184     }</b></font>
185 <a name="2"></a>
186     @Test
187     public void test_flush_triggers_deferred_executions_and_sets_active_execution() throws Exception <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
188         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService)
189             .addTable("create table users (name text)")
190             .build();
191         DependencyCarrier dependencies = mock(DependencyCarrier.class);
192         when(dependencies.clusterService</b></font>()).thenReturn(clusterService);
193         Session session = Mockito.spy(new Session(
194             sqlExecutor.nodeCtx,
195             sqlExecutor.analyzer,
196             mock(Planner.class, Answers.RETURNS_MOCKS),
197             new JobsLogs(() -&gt; false),
198             false,
199             dependencies,
200             AccessControl.DISABLED,
201             SessionContext.systemSessionContext())
202         );
203         session.parse("", "insert into users (name) values (?)", List.of());
204         session.bind("", "", List.of("Arthur"), null);
205         session.execute("", -1, new BaseResultReceiver());
206         assertThat(session.deferredExecutionsByStmt.size(), is(1));
207         session.flush();
208         var activeExecution = session.activeExecution;
209         assertThat(activeExecution, Matchers.notNullValue());
210         CompletableFuture&lt;?&gt; sync = session.sync();
211         assertThat(sync, Matchers.sameInstance(activeExecution));
212     }
213     @Test
214     public void testExtractTypesFromDelete() throws Exception {
215         SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
216         AnalyzedStatement analyzedStatement = e.analyzer.analyze(
217             SqlParser.createStatement("delete from users where name = ?"),
218             SessionContext.systemSessionContext(),
219             ParamTypeHints.EMPTY
220         );
221         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
222         DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);
223         assertThat(parameterTypes, is(new DataType[] { DataTypes.STRING }));
224     }
225     @Test
226     public void testExtractTypesFromUpdate() throws Exception {
227         SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
228         AnalyzedStatement analyzedStatement = e.analyzer.analyze(
229             SqlParser.createStatement("update users set name = ? || '_updated' where id = ?"),
230             SessionContext.systemSessionContext(),
231             ParamTypeHints.EMPTY
232         );
233         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
234         DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);
235         assertThat(parameterTypes, is(new DataType[] { DataTypes.STRING, DataTypes.LONG }));
236     }
237     @Test
238     public void testExtractTypesFromInsertValues() throws Exception {
239         SQLExecutor e = SQLExecutor.builder(clusterService).addTable(TableDefinitions.USER_TABLE_DEFINITION).build();
240         AnalyzedStatement analyzedStatement = e.analyzer.analyze(
241             SqlParser.createStatement("INSERT INTO users (id, name) values (?, ?)"),
242             SessionContext.systemSessionContext(),
243             ParamTypeHints.EMPTY
244         );
245         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
246         DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);
247         assertThat(parameterTypes, is(new DataType[] { DataTypes.LONG, DataTypes.STRING }));
248     }
249     @Test
250     public void testExtractTypesFromInsertFromQuery() throws Exception {
251         SQLExecutor e = SQLExecutor.builder(clusterService)
252             .enableDefaultTables()
253             .build();
254         AnalyzedStatement analyzedStatement = e.analyzer.analyze(
255             SqlParser.createStatement("INSERT INTO users (id, name) (SELECT id, name FROM users_clustered_by_only " +
256                                       "WHERE name = ?)"),
257             SessionContext.systemSessionContext(),
258             ParamTypeHints.EMPTY
259         );
260         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
261         DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);
262         assertThat(parameterTypes, is(new DataType[]{DataTypes.STRING}));
263     }
264     @Test
265     public void testExtractTypesFromInsertWithOnDuplicateKey() throws Exception {
266         SQLExecutor e = SQLExecutor.builder(clusterService)
267             .enableDefaultTables()
268             .build();
269         AnalyzedStatement analyzedStatement = e.analyzer.analyze(
270             SqlParser.createStatement("INSERT INTO users (id, name) values (?, ?) " +
271                                       "ON CONFLICT (id) DO UPDATE SET name = ?"),
272             SessionContext.systemSessionContext(),
273             ParamTypeHints.EMPTY
274         );
275         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
276         DataType[] parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);
277         assertThat(parameterTypes, is(new DataType[]{DataTypes.LONG, DataTypes.STRING, DataTypes.STRING}));
278         analyzedStatement = e.analyzer.analyze(
279             SqlParser.createStatement("INSERT INTO users (id, name) (SELECT id, name FROM users_clustered_by_only " +
280                                       "WHERE name = ?) ON CONFLICT (id) DO UPDATE SET name = ?"),
281             SessionContext.systemSessionContext(),
282             ParamTypeHints.EMPTY
283         );
284         typeExtractor = new ParameterTypeExtractor();
285         parameterTypes = typeExtractor.getParameterTypes(analyzedStatement::visitSymbols);
286         assertThat(parameterTypes, is(new DataType[]{DataTypes.STRING, DataTypes.STRING}));
287     }
288     @Test
289     public void testTypesCanBeResolvedIfParametersAreInSubRelation() throws Exception {
290         SQLExecutor e = SQLExecutor.builder(clusterService).build();
291         AnalyzedStatement stmt = e.analyzer.analyze(
292             SqlParser.createStatement("select * from (select $1::int + $2) t"),
293             SessionContext.systemSessionContext(),
294             ParamTypeHints.EMPTY
295         );
296         DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
297             consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
298         assertThat(parameterTypes, arrayContaining(is(DataTypes.INTEGER), is(DataTypes.INTEGER)));
299     }
300     @Test
301     public void testTypesCanBeResolvedIfParametersAreInSubRelationOfInsertStatement() throws Exception {
302         SQLExecutor e = SQLExecutor.builder(clusterService)
303             .addTable("create table t (x int)")
304             .build();
305         AnalyzedStatement stmt = e.analyzer.analyze(
306             SqlParser.createStatement("insert into t (x) (select * from (select $1::int + $2) t)"),
307             SessionContext.systemSessionContext(),
308             ParamTypeHints.EMPTY
309         );
310         DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
311             consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
312         assertThat(parameterTypes, arrayContaining(is(DataTypes.INTEGER), is(DataTypes.INTEGER)));
313     }
314     @Test
315     public void testTypesCanBeResolvedIfParametersAreInSubQueryInDeleteStatement() throws Exception {
316         SQLExecutor e = SQLExecutor.builder(clusterService)
317             .addTable("create table t (x int)")
318             .build();
319         AnalyzedStatement stmt = e.analyzer.analyze(
320             SqlParser.createStatement("delete from t where x = (select $1::long)"),
321             SessionContext.systemSessionContext(),
322             ParamTypeHints.EMPTY
323         );
324         DataType[] parameterTypes = new ParameterTypeExtractor().getParameterTypes(
325             consumer -&gt; Relations.traverseDeepSymbols(stmt, consumer));
326         assertThat(parameterTypes, arrayContaining(is(DataTypes.LONG)));
327     }
328     @Test
329     public void testProperCleanupOnSessionClose() {
330         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
331         DependencyCarrier executor = mock(DependencyCarrier.class);
332         Session session = new Session(
333             sqlExecutor.nodeCtx,
334             sqlExecutor.analyzer,
335             sqlExecutor.planner,
336             new JobsLogs(() -&gt; false),
337             false,
338             executor,
339             AccessControl.DISABLED,
340             SessionContext.systemSessionContext());
341         session.parse("S_1", "select name from sys.cluster;", Collections.emptyList());
342         session.bind("Portal", "S_1", Collections.emptyList(), null);
343         session.describe('S', "S_1");
344         session.parse("S_2", "select id from sys.cluster", Collections.emptyList());
345         session.bind("", "S_2", Collections.emptyList(), null);
346         session.describe('S', "S_2");
347         assertThat(session.portals.size(), is(2));
348         assertThat(session.preparedStatements.size(), is(2));
349         assertThat(session.deferredExecutionsByStmt.size(), is(0));
350         session.close();
351         assertThat(session.portals.size(), is(0));
352         assertThat(session.preparedStatements.size(), is(0));
353         assertThat(session.deferredExecutionsByStmt.size(), is(0));
354         assertThat(session.activeExecution, is(nullValue()));
355     }
356     @Test
357     public void testDeallocateAllClearsAllPortalsAndPreparedStatements() {
358         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
359         DependencyCarrier executor = mock(DependencyCarrier.class);
360         when(executor.threadPool()).thenReturn(mock(ThreadPool.class));
361         Session session = new Session(
362             sqlExecutor.nodeCtx,
363             sqlExecutor.analyzer,
364             sqlExecutor.planner,
365             new JobsLogs(() -&gt; false),
366             false,
367             executor,
368             AccessControl.DISABLED,
369             SessionContext.systemSessionContext());
370         session.parse("S_1", "select * from sys.cluster;", Collections.emptyList());
371         session.bind("Portal", "S_1", Collections.emptyList(), null);
372         session.describe('S', "S_1");
373         session.parse("S_2", "DEALLOCATE ALL;", Collections.emptyList());
374         session.bind("", "S_2", Collections.emptyList(), null);
375         session.execute("", 0, new BaseResultReceiver());
376         assertThat(session.portals.size(), greaterThan(0));
377         assertThat(session.preparedStatements.size(), is(0));
378     }
379     @Test
380     public void testDeallocatePreparedStatementClearsPreparedStatement() {
381         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
382         DependencyCarrier executor = mock(DependencyCarrier.class);
383         when(executor.threadPool()).thenReturn(mock(ThreadPool.class));
384         Session session = new Session(
385             sqlExecutor.nodeCtx,
386             sqlExecutor.analyzer,
387             sqlExecutor.planner,
388             new JobsLogs(() -&gt; false),
389             false,
390             executor,
391             AccessControl.DISABLED,
392             SessionContext.systemSessionContext());
393         session.parse("test_prep_stmt", "select * from sys.cluster;", Collections.emptyList());
394         session.bind("Portal", "test_prep_stmt", Collections.emptyList(), null);
395         session.describe('S', "test_prep_stmt");
396         session.parse("stmt", "DEALLOCATE test_prep_stmt;", Collections.emptyList());
397         session.bind("", "stmt", Collections.emptyList(), null);
398         session.execute("", 0, new BaseResultReceiver());
399         assertThat(session.portals.size(), greaterThan(0));
400         assertThat(session.preparedStatements.size(), is(1));
401         assertThat(session.preparedStatements.get("stmt").rawStatement(), is("DEALLOCATE test_prep_stmt;"));
402     }
403     @Test
404     public void test_closing_a_statement_closes_related_portals() {
405         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
406         DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
407         Session session = new Session(
408             sqlExecutor.nodeCtx,
409             sqlExecutor.analyzer,
410             sqlExecutor.planner,
411             new JobsLogs(() -&gt; false),
412             false,
413             executor,
414             AccessControl.DISABLED,
415             SessionContext.systemSessionContext());
416         session.parse("S_1", "SELECT 1", List.of());
417         session.bind("P_1", "S_1", List.of(), null);
418         assertThat(session.portals.size(), is(1));
419         assertThat(session.preparedStatements.size(), is(1));
420         session.close((byte) 'S', "S_1");
421         assertThat(session.portals.entrySet(), Matchers.empty());
422         assertThat(session.preparedStatements.entrySet(), Matchers.empty());
423     }
424     @Test
425     public void test_discard_all_discards_all_portals_and_prepared_statements() throws Exception {
426         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService).build();
427         DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
428         Session session = new Session(
429             sqlExecutor.nodeCtx,
430             sqlExecutor.analyzer,
431             sqlExecutor.planner,
432             new JobsLogs(() -&gt; false),
433             false,
434             executor,
435             AccessControl.DISABLED,
436             SessionContext.systemSessionContext());
437         session.parse("S_1", "SELECT 1", List.of());
438         session.bind("P_1", "S_1", List.of(), null);
439         assertThat(session.portals.size(), is(1));
440         assertThat(session.preparedStatements.size(), is(1));
441         session.parse("stmt", "DISCARD ALL", Collections.emptyList());
442         session.bind("", "stmt", Collections.emptyList(), null);
443         session.execute("", 0, new BaseResultReceiver());
444         assertThat(session.portals.entrySet(), Matchers.empty());
445         assertThat(session.preparedStatements.entrySet(), Matchers.empty());
446     }
447     @Test
448     public void test_bulk_operations_result_in_jobslog_entries() throws Exception {
449         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService)
450             .addTable("create table t1 (x int)")
451             .build();
452         DependencyCarrier executor = mock(DependencyCarrier.class, Answers.RETURNS_MOCKS);
453 <a name="3"></a>        Planner planner = mock(Planner.class);
454         when(planner.plan(any(AnalyzedStatement.class), any(PlannerContext.class)))
455             .thenReturn(new Plan() {
456                             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
457                             public StatementType type() {
458                                 return StatementType.INSERT;
459                             }
460                             @Override
461                             public void executeOrFail(DependencyCarrier dependencies</b></font>, PlannerContext plannerContext, RowConsumer consumer, Row params, SubQueryResults subQueryResults) throws Exception {
462                             }
463                             @Override
464                             public List&lt;CompletableFuture&lt;Long&gt;&gt; executeBulk(DependencyCarrier executor, PlannerContext plannerContext, List&lt;Row&gt; bulkParams, SubQueryResults subQueryResults) {
465                                 return List.of(completedFuture(1L), completedFuture(1L));
466                             }
467                         }
468             );
469         JobsLogs jobsLogs = new JobsLogs(() -&gt; true);
470         Session session = new Session(
471             sqlExecutor.nodeCtx,
472             sqlExecutor.analyzer,
473             planner,
474             jobsLogs,
475             false,
476             executor,
477             AccessControl.DISABLED,
478             SessionContext.systemSessionContext());
479         session.parse("S_1", "INSERT INTO t1 (x) VALUES (1)", List.of());
480         session.bind("P_1", "S_1", List.of(), null);
481         session.execute("P_1", 0, new BaseResultReceiver());
482         session.bind("P_1", "S_1", List.of(), null);
483         session.execute("P_1", 0, new BaseResultReceiver());
484         session.sync().get(5, TimeUnit.SECONDS);
485         assertThat(jobsLogs.metrics().iterator().next().totalCount(), is(1L));
486     }
487     @Test
488     public void test_can_extract_parameters_from_match_predicate() throws Exception {
489         SQLExecutor e = SQLExecutor.builder(clusterService)
490             .addTable("create table users (name text, keywords text)")
491             .build();
492         AnalyzedStatement statement = e.analyze(
493             "select * from users where match(keywords, ?) using best_fields with (fuzziness= ?) and name = ?");
494         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
495         DataType[] parameterTypes = typeExtractor.getParameterTypes(statement::visitSymbols);
496         assertThat(parameterTypes, arrayContaining(DataTypes.STRING, DataTypes.UNDEFINED, DataTypes.STRING));
497     }
498     @Test
499     public void test_can_extract_parameters_from_join_condition() throws Exception {
500         SQLExecutor e = SQLExecutor.builder(clusterService)
501             .addTable("create table subscriptions (id text primary key, name text not null)")
502             .addTable("create table clusters (id text, subscription_id text)")
503             .build();
504         AnalyzedStatement stmt = e.analyze("""
505             select
506                 *
507             from subscriptions
508             join clusters on clusters.subscription_id = subscriptions.id
509                 AND subscriptions.name = ?
510         """);
511         ParameterTypeExtractor typeExtractor = new ParameterTypeExtractor();
512         DataType[] parameterTypes = typeExtractor.getParameterTypes(stmt::visitSymbols);
513         assertThat(parameterTypes, arrayContaining(DataTypes.STRING));
514     }
515 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
