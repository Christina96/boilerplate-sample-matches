
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.0606060606060606%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-Economy_16.java</h3>
            <pre><code>1  package com.earth2me.essentials.api;
2  import com.earth2me.essentials.EssentialsConf;
3  import com.earth2me.essentials.EssentialsUserConf;
4  import static com.earth2me.essentials.I18n.tl;
5  import com.earth2me.essentials.Trade;
6  import com.earth2me.essentials.User;
7  import static com.earth2me.essentials.api.Economy.add;
8  import static com.earth2me.essentials.api.Economy.divide;
9  import static com.earth2me.essentials.api.Economy.format;
10  import static com.earth2me.essentials.api.Economy.getMoneyExact;
11  import static com.earth2me.essentials.api.Economy.hasEnough;
12  import static com.earth2me.essentials.api.Economy.hasLess;
13  import static com.earth2me.essentials.api.Economy.hasMore;
14  import static com.earth2me.essentials.api.Economy.multiply;
15  import static com.earth2me.essentials.api.Economy.setMoney;
16  import static com.earth2me.essentials.api.Economy.substract;
17  import com.earth2me.essentials.utils.NumberUtil;
18  import com.earth2me.essentials.utils.StringUtil;
19  import com.google.common.base.Charsets;
20  import java.io.File;
21  import java.math.BigDecimal;
22  import java.math.MathContext;
23  import java.util.UUID;
24  import java.util.logging.Level;
25  import java.util.logging.Logger;
26  import net.ess3.api.IEssentials;
27  import net.ess3.api.MaxMoneyException;
28  public class Economy
29  {
30  	public Economy()
31  	{
32  	}
33  	private static final Logger logger = Logger.getLogger("Essentials");
34  	private static IEssentials ess;
35  	private static final String noCallBeforeLoad = "Essentials API is called before Essentials is loaded.";
36  	public static final MathContext MATH_CONTEXT = MathContext.DECIMAL128;
37  	public static void setEss(IEssentials aEss)
38  	{
39  		ess = aEss;
40  	}
41  	private static void createNPCFile(String name)
42  	{
43  		File folder = new File(ess.getDataFolder(), "userdata");
44  		name = StringUtil.safeString(name);
45  		if (!folder.exists())
46  		{
47  			folder.mkdirs();
48  		}
49  		UUID npcUUID = UUID.nameUUIDFromBytes(("NPC:" + name).getBytes(Charsets.UTF_8));
<span onclick='openModal()' class='match'>50  		EssentialsUserConf npcConfig = new EssentialsUserConf(name, npcUUID, new File(folder, npcUUID.toString() + ".yml"));
51  		npcConfig.load();
52  		npcConfig.setProperty("npc", true);
53  		npcConfig.setProperty("lastAccountName", name);
54  		npcConfig.setProperty("money", ess.getSettings().getStartingBalance());
55  		npcConfig.forceSave();
56  		ess.getUserMap().trackUUID(npcUUID, name, false);
</span>57  	}
58  	private static void deleteNPC(String name)
59  	{
60  		User user = ess.getUser(name);
61  		user.reset();
62  	}
63  	private static User getUserByName(String name)
64  	{
65  		if (ess == null)
66  		{
67  			throw new RuntimeException(noCallBeforeLoad);
68  		}
69  		if (name == null)
70  		{
71  			throw new RuntimeException("Economy username cannot be null");
72  		}
73  		return ess.getUser(name);
74  	}
75  	@Deprecated
76  	public static double getMoney(String name) throws UserDoesNotExistException
77  	{
78  		return getMoneyExact(name).doubleValue();
79  	}
80  	public static BigDecimal getMoneyExact(String name) throws UserDoesNotExistException
81  	{
82  		User user = getUserByName(name);
83  		if (user == null)
84  		{
85  			throw new UserDoesNotExistException(name);
86  		}
87  		return user.getMoney();
88  	}
89  	@Deprecated
90  	public static void setMoney(String name, double balance) throws UserDoesNotExistException, NoLoanPermittedException
91  	{
92  		try
93  		{
94  			setMoney(name, BigDecimal.valueOf(balance));
95  		}
96  		catch (ArithmeticException e)
97  		{
98  			logger.log(Level.WARNING, "Failed to set balance of " + name + " to " + balance + ": " + e.getMessage(), e);
99  		}
100  	}
101  	public static void setMoney(String name, BigDecimal balance) throws UserDoesNotExistException, NoLoanPermittedException
102  	{
103  		User user = getUserByName(name);
104  		if (user == null)
105  		{
106  			throw new UserDoesNotExistException(name);
107  		}
108  		if (balance.compareTo(ess.getSettings().getMinMoney()) < 0)
109  		{
110  			throw new NoLoanPermittedException();
111  		}
112  		if (balance.signum() < 0 && !user.isAuthorized("essentials.eco.loan"))
113  		{
114  			throw new NoLoanPermittedException();
115  		}
116  		try
117  		{
118  			user.setMoney(balance);
119  		}
120  		catch (MaxMoneyException ex)
121  		{
122  		}
123  		Trade.log("API", "Set", "API", name, new Trade(balance, ess), null, null, null, ess);
124  	}
125  	@Deprecated
126  	public static void add(String name, double amount) throws UserDoesNotExistException, NoLoanPermittedException
127  	{
128  		try
129  		{
130  			add(name, BigDecimal.valueOf(amount));
131  		}
132  		catch (ArithmeticException e)
133  		{
134  			logger.log(Level.WARNING, "Failed to add " + amount + " to balance of " + name + ": " + e.getMessage(), e);
135  		}
136  	}
137  	public static void add(String name, BigDecimal amount) throws UserDoesNotExistException, NoLoanPermittedException, ArithmeticException
138  	{
139  		BigDecimal result = getMoneyExact(name).add(amount, MATH_CONTEXT);
140  		setMoney(name, result);
141  		Trade.log("API", "Add", "API", name, new Trade(amount, ess), null, null, null, ess);
142  	}
143  	@Deprecated
144  	public static void subtract(String name, double amount) throws UserDoesNotExistException, NoLoanPermittedException
145  	{
146  		try
147  		{
148  			substract(name, BigDecimal.valueOf(amount));
149  		}
150  		catch (ArithmeticException e)
151  		{
152  			logger.log(Level.WARNING, "Failed to substract " + amount + " of balance of " + name + ": " + e.getMessage(), e);
153  		}
154  	}
155  	public static void substract(String name, BigDecimal amount) throws UserDoesNotExistException, NoLoanPermittedException, ArithmeticException
156  	{
157  		BigDecimal result = getMoneyExact(name).subtract(amount, MATH_CONTEXT);
158  		setMoney(name, result);
159  		Trade.log("API", "Subtract", "API", name, new Trade(amount, ess), null, null, null, ess);
160  	}
161  	@Deprecated
162  	public static void divide(String name, double amount) throws UserDoesNotExistException, NoLoanPermittedException
163  	{
164  		try
165  		{
166  			divide(name, BigDecimal.valueOf(amount));
167  		}
168  		catch (ArithmeticException e)
169  		{
170  			logger.log(Level.WARNING, "Failed to divide balance of " + name + " by " + amount + ": " + e.getMessage(), e);
171  		}
172  	}
173  	public static void divide(String name, BigDecimal amount) throws UserDoesNotExistException, NoLoanPermittedException, ArithmeticException
174  	{
175  		BigDecimal result = getMoneyExact(name).divide(amount, MATH_CONTEXT);
176  		setMoney(name, result);
177  		Trade.log("API", "Divide", "API", name, new Trade(amount, ess), null, null, null, ess);
178  	}
179  	@Deprecated
180  	public static void multiply(String name, double amount) throws UserDoesNotExistException, NoLoanPermittedException
181  	{
182  		try
183  		{
184  			multiply(name, BigDecimal.valueOf(amount));
185  		}
186  		catch (ArithmeticException e)
187  		{
188  			logger.log(Level.WARNING, "Failed to multiply balance of " + name + " by " + amount + ": " + e.getMessage(), e);
189  		}
190  	}
191  	public static void multiply(String name, BigDecimal amount) throws UserDoesNotExistException, NoLoanPermittedException, ArithmeticException
192  	{
193  		BigDecimal result = getMoneyExact(name).multiply(amount, MATH_CONTEXT);
194  		setMoney(name, result);
195  		Trade.log("API", "Multiply", "API", name, new Trade(amount, ess), null, null, null, ess);
196  	}
197  	public static void resetBalance(String name) throws UserDoesNotExistException, NoLoanPermittedException
198  	{
199  		if (ess == null)
200  		{
201  			throw new RuntimeException(noCallBeforeLoad);
202  		}
203  		setMoney(name, ess.getSettings().getStartingBalance());
204  		Trade.log("API", "Reset", "API", name, new Trade(BigDecimal.ZERO, ess), null, null, null, ess);
205  	}
206  	@Deprecated
207  	public static boolean hasEnough(String name, double amount) throws UserDoesNotExistException
208  	{
209  		try
210  		{
211  			return hasEnough(name, BigDecimal.valueOf(amount));
212  		}
213  		catch (ArithmeticException e)
214  		{
215  			logger.log(Level.WARNING, "Failed to compare balance of " + name + " with " + amount + ": " + e.getMessage(), e);
216  			return false;
217  		}
218  	}
219  	public static boolean hasEnough(String name, BigDecimal amount) throws UserDoesNotExistException, ArithmeticException
220  	{
221  		return amount.compareTo(getMoneyExact(name)) <= 0;
222  	}
223  	@Deprecated
224  	public static boolean hasMore(String name, double amount) throws UserDoesNotExistException
225  	{
226  		try
227  		{
228  			return hasMore(name, BigDecimal.valueOf(amount));
229  		}
230  		catch (ArithmeticException e)
231  		{
232  			logger.log(Level.WARNING, "Failed to compare balance of " + name + " with " + amount + ": " + e.getMessage(), e);
233  			return false;
234  		}
235  	}
236  	public static boolean hasMore(String name, BigDecimal amount) throws UserDoesNotExistException, ArithmeticException
237  	{
238  		return amount.compareTo(getMoneyExact(name)) < 0;
239  	}
240  	@Deprecated
241  	public static boolean hasLess(String name, double amount) throws UserDoesNotExistException
242  	{
243  		try
244  		{
245  			return hasLess(name, BigDecimal.valueOf(amount));
246  		}
247  		catch (ArithmeticException e)
248  		{
249  			logger.log(Level.WARNING, "Failed to compare balance of " + name + " with " + amount + ": " + e.getMessage(), e);
250  			return false;
251  		}
252  	}
253  	public static boolean hasLess(String name, BigDecimal amount) throws UserDoesNotExistException, ArithmeticException
254  	{
255  		return amount.compareTo(getMoneyExact(name)) > 0;
256  	}
257  	public static boolean isNegative(String name) throws UserDoesNotExistException
258  	{
259  		return getMoneyExact(name).signum() < 0;
260  	}
261  	@Deprecated
262  	public static String format(double amount)
263  	{
264  		try
265  		{
266  			return format(BigDecimal.valueOf(amount));
267  		}
268  		catch (NumberFormatException e)
269  		{
270  			logger.log(Level.WARNING, "Failed to display " + amount + ": " + e.getMessage(), e);
271  			return "NaN";
272  		}
273  	}
274  	public static String format(BigDecimal amount)
275  	{
276  		if (ess == null)
277  		{
278  			throw new RuntimeException(noCallBeforeLoad);
279  		}
280  		return NumberUtil.displayCurrency(amount, ess);
281  	}
282  	public static boolean playerExists(String name)
283  	{
284  		return getUserByName(name) != null;
285  	}
286  	public static boolean isNPC(String name) throws UserDoesNotExistException
287  	{
288  		User user = getUserByName(name);
289  		if (user == null)
290  		{
291  			throw new UserDoesNotExistException(name);
292  		}
293  		return user.isNPC();
294  	}
295  	public static boolean createNPC(String name)
296  	{
297  		User user = getUserByName(name);
298  		if (user == null)
299  		{
300  			createNPCFile(name);
301  			return true;
302  		}
303  		return false;
304  	}
305  	public static void removeNPC(String name) throws UserDoesNotExistException
306  	{
307  		User user = getUserByName(name);
308  		if (user == null)
309  		{
310  			throw new UserDoesNotExistException(name);
311  		}
312  		deleteNPC(name);
313  	}
314  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ServerStats.java</h3>
            <pre><code>1  package com.netflix.loadbalancer;
2  import com.google.common.annotations.VisibleForTesting;
3  import com.netflix.client.config.CommonClientConfigKey;
4  import com.netflix.client.config.IClientConfigKey;
5  import com.netflix.client.config.Property;
6  import com.netflix.client.config.UnboxedIntProperty;
7  import com.netflix.servo.annotations.DataSourceType;
8  import com.netflix.servo.annotations.Monitor;
9  import com.netflix.stats.distribution.DataDistribution;
10  import com.netflix.stats.distribution.DataPublisher;
11  import com.netflix.stats.distribution.Distribution;
12  import com.netflix.util.MeasuredRate;
13  import java.util.Date;
14  import java.util.Random;
15  import java.util.concurrent.atomic.AtomicInteger;
16  import java.util.concurrent.atomic.AtomicLong;
17  public class ServerStats {
18      private static final int DEFAULT_PUBLISH_INTERVAL =  60 * 1000; 
19      private static final int DEFAULT_BUFFER_SIZE = 60 * 1000; 
20      private final UnboxedIntProperty connectionFailureThreshold;
21      private final UnboxedIntProperty circuitTrippedTimeoutFactor;
22      private final UnboxedIntProperty maxCircuitTrippedTimeout;
23      private final UnboxedIntProperty activeRequestsCountTimeout;
24      private static final double[] PERCENTS = makePercentValues();
25      private DataDistribution dataDist = new DataDistribution(1, PERCENTS); 
26      private DataPublisher publisher = null;
27      private final Distribution responseTimeDist = new Distribution();
28      int bufferSize = DEFAULT_BUFFER_SIZE;
29      int publishInterval = DEFAULT_PUBLISH_INTERVAL;
30      long failureCountSlidingWindowInterval = 1000; 
31      private MeasuredRate serverFailureCounts = new MeasuredRate(failureCountSlidingWindowInterval);
32      private MeasuredRate requestCountInWindow = new MeasuredRate(300000L);
33      Server server;
34      AtomicLong totalRequests = new AtomicLong();
35      @VisibleForTesting
36      AtomicInteger successiveConnectionFailureCount = new AtomicInteger(0);
37      @VisibleForTesting
38      AtomicInteger activeRequestsCount = new AtomicInteger(0);
39      @VisibleForTesting
40      AtomicInteger openConnectionsCount = new AtomicInteger(0);
41      private volatile long lastConnectionFailedTimestamp;
42      private volatile long lastActiveRequestsCountChangeTimestamp;
43      private AtomicLong totalCircuitBreakerBlackOutPeriod = new AtomicLong(0);
44      private volatile long lastAccessedTimestamp;
45      private volatile long firstConnectionTimestamp = 0;
46      public ServerStats() {
47          connectionFailureThreshold = new UnboxedIntProperty(Property.of(LoadBalancerStats.CONNECTION_FAILURE_COUNT_THRESHOLD.defaultValue()));
48          circuitTrippedTimeoutFactor = new UnboxedIntProperty(LoadBalancerStats.CIRCUIT_TRIP_TIMEOUT_FACTOR_SECONDS.defaultValue());
49          maxCircuitTrippedTimeout = new UnboxedIntProperty(LoadBalancerStats.CIRCUIT_TRIP_MAX_TIMEOUT_SECONDS.defaultValue());
50          activeRequestsCountTimeout = new UnboxedIntProperty(LoadBalancerStats.ACTIVE_REQUESTS_COUNT_TIMEOUT.defaultValue());
51      }
52      public ServerStats(LoadBalancerStats lbStats) {
53          maxCircuitTrippedTimeout = lbStats.getCircuitTripMaxTimeoutSeconds();
54          circuitTrippedTimeoutFactor = lbStats.getCircuitTrippedTimeoutFactor();
55          connectionFailureThreshold = lbStats.getConnectionFailureCountThreshold();
56          activeRequestsCountTimeout = lbStats.getActiveRequestsCountTimeout();
57      }
58      public void initialize(Server server) {
59          serverFailureCounts = new MeasuredRate(failureCountSlidingWindowInterval);
60          requestCountInWindow = new MeasuredRate(300000L);
61          if (publisher == null) {
62              dataDist = new DataDistribution(getBufferSize(), PERCENTS);
63              publisher = new DataPublisher(dataDist, getPublishIntervalMillis());
64              publisher.start();
65          }
66          this.server = server;
67      }
68      public void close() {
69          if (publisher != null)
70              publisher.stop();
71      }
72      public Server getServer() {
73          return server;
74      }
75      private int getBufferSize() {
76          return bufferSize;
77      }
78      private long getPublishIntervalMillis() {
79          return publishInterval;
80      }
81      public void setBufferSize(int bufferSize) {
82          this.bufferSize = bufferSize;
83      }
84      public void setPublishInterval(int publishInterval) {
85          this.publishInterval = publishInterval;
86      }
87      private static enum Percent {
88          TEN(10), TWENTY_FIVE(25), FIFTY(50), SEVENTY_FIVE(75), NINETY(90),
89          NINETY_FIVE(95), NINETY_EIGHT(98), NINETY_NINE(99), NINETY_NINE_POINT_FIVE(99.5);
90          private double val;
91          Percent(double val) {
92              this.val = val;
93          }
94          public double getValue() {
95              return val;
96          }
97      }
98      private static double[] makePercentValues() {
99          Percent[] percents = Percent.values();
100          double[] p = new double[percents.length];
101          for (int i = 0; i < percents.length; i++) {
102              p[i] = percents[i].getValue();
103          }
104          return p;
105      }
106      public long getFailureCountSlidingWindowInterval() {
107          return failureCountSlidingWindowInterval;
108      }
109      public void setFailureCountSlidingWindowInterval(
110              long failureCountSlidingWindowInterval) {
111          this.failureCountSlidingWindowInterval = failureCountSlidingWindowInterval;
112      }
113      public void addToFailureCount(){
114          serverFailureCounts.increment();
115      }
116      public long getFailureCount(){
117          return serverFailureCounts.getCurrentCount();
118      }
119      public void noteResponseTime(double msecs){
120          dataDist.noteValue(msecs);
121          responseTimeDist.noteValue(msecs);
122      }
123      public void incrementNumRequests(){
124          totalRequests.incrementAndGet();
125      }
126      public void incrementActiveRequestsCount() {        
127          activeRequestsCount.incrementAndGet();
128          requestCountInWindow.increment();
129          long currentTime = System.currentTimeMillis();
130          lastActiveRequestsCountChangeTimestamp = currentTime;
131          lastAccessedTimestamp = currentTime;
132          if (firstConnectionTimestamp == 0) {
133              firstConnectionTimestamp = currentTime;
134          }
135      }
136      public void incrementOpenConnectionsCount() {
137          openConnectionsCount.incrementAndGet();
138      }
139      public void decrementActiveRequestsCount() {
140          activeRequestsCount.getAndUpdate(current -> Math.max(0, current - 1));
141          lastActiveRequestsCountChangeTimestamp = System.currentTimeMillis();
142      }
143      public void decrementOpenConnectionsCount() {
144          openConnectionsCount.getAndUpdate(current -> Math.max(0, current - 1));
145      }
146      public int  getActiveRequestsCount() {
147          return getActiveRequestsCount(System.currentTimeMillis());
148      }
149      public int getActiveRequestsCount(long currentTime) {
150          int count = activeRequestsCount.get();
151          if (count == 0) {
152              return 0;
153          } else if (currentTime - lastActiveRequestsCountChangeTimestamp > activeRequestsCountTimeout.get() * 1000 || count < 0) {
154              activeRequestsCount.set(0);
155              return 0;            
156          } else {
157              return count;
158          }
159      }
160      public int getOpenConnectionsCount() {
161          return openConnectionsCount.get();
162      }
163      public long getMeasuredRequestsCount() {
164          return requestCountInWindow.getCount();
165      }
166      @Monitor(name="ActiveRequestsCount", type = DataSourceType.GAUGE)    
167      public int getMonitoredActiveRequestsCount() {
168          return activeRequestsCount.get();
169      }
170      @Monitor(name="CircuitBreakerTripped", type = DataSourceType.INFORMATIONAL)    
171      public boolean isCircuitBreakerTripped() {
172          return isCircuitBreakerTripped(System.currentTimeMillis());
173      }
174      public boolean isCircuitBreakerTripped(long currentTime) {
175          long circuitBreakerTimeout = getCircuitBreakerTimeout();
176          if (circuitBreakerTimeout <= 0) {
177              return false;
178          }
179          return circuitBreakerTimeout > currentTime;
180      }
181      private long getCircuitBreakerTimeout() {
182          long blackOutPeriod = getCircuitBreakerBlackoutPeriod();
183          if (blackOutPeriod <= 0) {
184              return 0;
185          }
186          return lastConnectionFailedTimestamp + blackOutPeriod;
187      }
188      private long getCircuitBreakerBlackoutPeriod() {
189          int failureCount = successiveConnectionFailureCount.get();
190          int threshold = connectionFailureThreshold.get();
191          if (failureCount < threshold) {
192              return 0;
193          }
194          int diff = Math.min(failureCount - threshold, 16);
195          int blackOutSeconds = (1 << diff) * circuitTrippedTimeoutFactor.get();
196          if (blackOutSeconds > maxCircuitTrippedTimeout.get()) {
197              blackOutSeconds = maxCircuitTrippedTimeout.get();
198          }
199          return blackOutSeconds * 1000L;
200      }
201      public void incrementSuccessiveConnectionFailureCount() {
202          lastConnectionFailedTimestamp = System.currentTimeMillis();
203          successiveConnectionFailureCount.incrementAndGet();
204          totalCircuitBreakerBlackOutPeriod.addAndGet(getCircuitBreakerBlackoutPeriod());
205      }
206      public void clearSuccessiveConnectionFailureCount() {
207          successiveConnectionFailureCount.set(0);
208      }
209      @Monitor(name="SuccessiveConnectionFailureCount", type = DataSourceType.GAUGE)
210      public int getSuccessiveConnectionFailureCount() {
211          return successiveConnectionFailureCount.get();
212      }
213      @Monitor(name = "OverallResponseTimeMillisAvg", type = DataSourceType.INFORMATIONAL,
214               description = "Average total time for a request, in milliseconds")
215      public double getResponseTimeAvg() {
216          return responseTimeDist.getMean();
217      }
218      @Monitor(name = "OverallResponseTimeMillisMax", type = DataSourceType.INFORMATIONAL,
219               description = "Max total time for a request, in milliseconds")
220      public double getResponseTimeMax() {
221          return responseTimeDist.getMaximum();
222      }
223      @Monitor(name = "OverallResponseTimeMillisMin", type = DataSourceType.INFORMATIONAL,
224               description = "Min total time for a request, in milliseconds")
225      public double getResponseTimeMin() {
226          return responseTimeDist.getMinimum();
227      }
228      @Monitor(name = "OverallResponseTimeMillisStdDev", type = DataSourceType.INFORMATIONAL,
229               description = "Standard Deviation in total time to handle a request, in milliseconds")
230      public double getResponseTimeStdDev() {
231          return responseTimeDist.getStdDev();
232      }
233      @Monitor(name = "ResponseTimePercentileNumValues", type = DataSourceType.GAUGE,
234               description = "The number of data points used to compute the currently reported percentile values")
235      public int getResponseTimePercentileNumValues() {
236          return dataDist.getSampleSize();
237      }
238      @Monitor(name = "ResponseTimePercentileWhen", type = DataSourceType.INFORMATIONAL,
239               description = "The time the percentile values were computed")
240      public String getResponseTimePercentileTime() {
241          return dataDist.getTimestamp();
242      }
243      @Monitor(name = "ResponseTimePercentileWhenMillis", type = DataSourceType.COUNTER,
244               description = "The time the percentile values were computed in milliseconds since the epoch")
245      public long getResponseTimePercentileTimeMillis() {
246          return dataDist.getTimestampMillis();
247      }
248      @Monitor(name = "ResponseTimeMillisAvg", type = DataSourceType.GAUGE,
249               description = "Average total time for a request in the recent time slice, in milliseconds")
250      public double getResponseTimeAvgRecent() {
251          return dataDist.getMean();
252      }
253      @Monitor(name = "ResponseTimeMillis10Percentile", type = DataSourceType.INFORMATIONAL,
254               description = "10th percentile in total time to handle a request, in milliseconds")
255      public double getResponseTime10thPercentile() {
256          return getResponseTimePercentile(Percent.TEN);
257      }
258      @Monitor(name = "ResponseTimeMillis25Percentile", type = DataSourceType.INFORMATIONAL,
259               description = "25th percentile in total time to handle a request, in milliseconds")
260      public double getResponseTime25thPercentile() {
261          return getResponseTimePercentile(Percent.TWENTY_FIVE);
262      }
263      @Monitor(name = "ResponseTimeMillis50Percentile", type = DataSourceType.INFORMATIONAL,
264               description = "50th percentile in total time to handle a request, in milliseconds")
265      public double getResponseTime50thPercentile() {
266          return getResponseTimePercentile(Percent.FIFTY);
267      }
268      @Monitor(name = "ResponseTimeMillis75Percentile", type = DataSourceType.INFORMATIONAL,
269               description = "75th percentile in total time to handle a request, in milliseconds")
270      public double getResponseTime75thPercentile() {
271          return getResponseTimePercentile(Percent.SEVENTY_FIVE);
272      }
273      @Monitor(name = "ResponseTimeMillis90Percentile", type = DataSourceType.INFORMATIONAL,
274               description = "90th percentile in total time to handle a request, in milliseconds")
275      public double getResponseTime90thPercentile() {
276          return getResponseTimePercentile(Percent.NINETY);
277      }
278      @Monitor(name = "ResponseTimeMillis95Percentile", type = DataSourceType.GAUGE,
279               description = "95th percentile in total time to handle a request, in milliseconds")
280      public double getResponseTime95thPercentile() {
281          return getResponseTimePercentile(Percent.NINETY_FIVE);
282      }
283      @Monitor(name = "ResponseTimeMillis98Percentile", type = DataSourceType.INFORMATIONAL,
284               description = "98th percentile in total time to handle a request, in milliseconds")
285      public double getResponseTime98thPercentile() {
286          return getResponseTimePercentile(Percent.NINETY_EIGHT);
287      }
288      @Monitor(name = "ResponseTimeMillis99Percentile", type = DataSourceType.GAUGE,
289               description = "99th percentile in total time to handle a request, in milliseconds")
290      public double getResponseTime99thPercentile() {
291          return getResponseTimePercentile(Percent.NINETY_NINE);
292      }
293      @Monitor(name = "ResponseTimeMillis99_5Percentile", type = DataSourceType.GAUGE,
294               description = "99.5th percentile in total time to handle a request, in milliseconds")
295      public double getResponseTime99point5thPercentile() {
296          return getResponseTimePercentile(Percent.NINETY_NINE_POINT_FIVE);
297      }
298      public long getTotalRequestsCount() {
299          return totalRequests.get();
300      }
301      private double getResponseTimePercentile(Percent p) {
302          return dataDist.getPercentiles()[p.ordinal()];
303      }
304      public String toString(){
305          StringBuilder sb = new StringBuilder();
306          sb.append("[Server:" + server + ";");
307          sb.append("\tZone:" + server.getZone() + ";");
308          sb.append("\tTotal Requests:" + totalRequests + ";");
309          sb.append("\tSuccessive connection failure:" + getSuccessiveConnectionFailureCount() + ";");
310          if (isCircuitBreakerTripped()) {
311              sb.append("\tBlackout until: " + new Date(getCircuitBreakerTimeout()) + ";");
312          }
313          sb.append("\tTotal blackout seconds:" + totalCircuitBreakerBlackOutPeriod.get() / 1000 + ";");
314          sb.append("\tLast connection made:" + new Date(lastAccessedTimestamp) + ";");
315          if (lastConnectionFailedTimestamp > 0) {
316              sb.append("\tLast connection failure: " + new Date(lastConnectionFailedTimestamp)  + ";");
317          }
<span onclick='openModal()' class='match'>318          sb.append("\tFirst connection made: " + new Date(firstConnectionTimestamp)  + ";");
319          sb.append("\tActive Connections:" + getMonitoredActiveRequestsCount()  + ";");
320          sb.append("\ttotal failure count in last (" + failureCountSlidingWindowInterval + ") msecs:" + getFailureCount()  + ";");
321          sb.append("\taverage resp time:" + getResponseTimeAvg()  + ";");
322          sb.append("\t90 percentile resp time:" + getResponseTime90thPercentile()  + ";");
323          sb.append("\t95 percentile resp time:" + getResponseTime95thPercentile()  + ";");
</span>324          sb.append("\tmin resp time:" + getResponseTimeMin()  + ";");
325          sb.append("\tmax resp time:" + getResponseTimeMax()  + ";");
326          sb.append("\tstddev resp time:" + getResponseTimeStdDev());
327          sb.append("]\n");
328          return sb.toString();
329      }
330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-Economy_16.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ServerStats.java</div>
                </div>
                <div class="column column_space"><pre><code>50  		EssentialsUserConf npcConfig = new EssentialsUserConf(name, npcUUID, new File(folder, npcUUID.toString() + ".yml"));
51  		npcConfig.load();
52  		npcConfig.setProperty("npc", true);
53  		npcConfig.setProperty("lastAccountName", name);
54  		npcConfig.setProperty("money", ess.getSettings().getStartingBalance());
55  		npcConfig.forceSave();
56  		ess.getUserMap().trackUUID(npcUUID, name, false);
</pre></code></div>
                <div class="column column_space"><pre><code>318          sb.append("\tFirst connection made: " + new Date(firstConnectionTimestamp)  + ";");
319          sb.append("\tActive Connections:" + getMonitoredActiveRequestsCount()  + ";");
320          sb.append("\ttotal failure count in last (" + failureCountSlidingWindowInterval + ") msecs:" + getFailureCount()  + ";");
321          sb.append("\taverage resp time:" + getResponseTimeAvg()  + ";");
322          sb.append("\t90 percentile resp time:" + getResponseTime90thPercentile()  + ";");
323          sb.append("\t95 percentile resp time:" + getResponseTime95thPercentile()  + ";");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    