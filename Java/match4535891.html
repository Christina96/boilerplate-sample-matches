<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for UnaryScalar.java & Joda.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for UnaryScalar.java & Joda.java
      </h3>
      <h1 align="center">
        1.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>UnaryScalar.java (15.384615%)<TH>Joda.java (0.8764242%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match4535891-0.html#0',2,'match4535891-1.html#0',3)" NAME="0">(59-66)<TD><A HREF="javascript:ZweiFrames('match4535891-0.html#0',2,'match4535891-1.html#0',3)" NAME="0">(304-311)</A><TD ALIGN=center><FONT COLOR="#ff0000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>UnaryScalar.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.expression.scalar;

import io.crate.data.Input;
import io.crate.metadata.NodeContext;
import io.crate.metadata.Scalar;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.functions.Signature;
import io.crate.types.DataType;

import java.util.function.Function;


/**
 * Scalar implementation that wraps another function: f(T) -&gt; R
 * &lt;br /&gt;
 * null values will result in null as output
 */
public class UnaryScalar&lt;R, T&gt; extends Scalar&lt;R, T&gt; {

    private final Function&lt;T, R&gt; func;
    private final Signature signature;
    private final Signature boundSignature;
    private final DataType&lt;T&gt; type;


    public UnaryScalar(Signature signature,
                       Signature boundSignature,
                       DataType&lt;T&gt; type,
                       Function&lt;T, R&gt; func) {
        assert boundSignature.getArgumentDataTypes().get(0).id() == type.id() :
            &quot;The bound argument type of the signature must match the type argument&quot;;
        this.signature = signature;
        this.boundSignature = boundSignature;
        this.type = type;
<A NAME="0"></A>        this.func = func;
    }

    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match4535891-1.html#0',3,'match4535891-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
    public Signature signature() {
        return signature;
    }

    @Override
    public Signature boundSignature() {
        return</B></FONT> boundSignature;
    }

    @SafeVarargs
    @Override
    public final R evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input&lt;T&gt;... args) {
        assert args.length == 1 : &quot;UnaryScalar expects exactly 1 argument, got: &quot; + args.length;
        T value = type.sanitizeValue(args[0].value());
        if (value == null) {
            return null;
        }
        return func.apply(value);
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Joda.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.common.joda;

import org.elasticsearch.common.Strings;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.DurationField;
import org.joda.time.DurationFieldType;
import org.joda.time.ReadablePartial;
import org.joda.time.field.DividedDateTimeField;
import org.joda.time.field.OffsetDateTimeField;
import org.joda.time.field.ScaledDurationField;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormatterBuilder;
import org.joda.time.format.DateTimeParser;
import org.joda.time.format.DateTimeParserBucket;
import org.joda.time.format.DateTimePrinter;
import org.joda.time.format.ISODateTimeFormat;
import org.joda.time.format.StrictISODateTimeFormat;

import java.io.IOException;
import java.io.Writer;
import java.math.BigDecimal;
import java.util.Locale;

public class Joda {

    public static FormatDateTimeFormatter forPattern(String input) {
        return forPattern(input, Locale.ROOT);
    }

    /**
     * Parses a joda based pattern, including some named ones (similar to the built in Joda ISO ones).
     */
    public static FormatDateTimeFormatter forPattern(String input, Locale locale) {
        if (Strings.hasLength(input)) {
            input = input.trim();
        }
        if (input == null || input.length() == 0) {
            throw new IllegalArgumentException(&quot;No date pattern provided&quot;);
        }

        DateTimeFormatter formatter;
        if (&quot;basicDate&quot;.equals(input) || &quot;basic_date&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicDate();
        } else if (&quot;basicDateTime&quot;.equals(input) || &quot;basic_date_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicDateTime();
        } else if (&quot;basicDateTimeNoMillis&quot;.equals(input) || &quot;basic_date_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicDateTimeNoMillis();
        } else if (&quot;basicOrdinalDate&quot;.equals(input) || &quot;basic_ordinal_date&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicOrdinalDate();
        } else if (&quot;basicOrdinalDateTime&quot;.equals(input) || &quot;basic_ordinal_date_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicOrdinalDateTime();
        } else if (&quot;basicOrdinalDateTimeNoMillis&quot;.equals(input) || &quot;basic_ordinal_date_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicOrdinalDateTimeNoMillis();
        } else if (&quot;basicTime&quot;.equals(input) || &quot;basic_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicTime();
        } else if (&quot;basicTimeNoMillis&quot;.equals(input) || &quot;basic_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicTimeNoMillis();
        } else if (&quot;basicTTime&quot;.equals(input) || &quot;basic_t_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicTTime();
        } else if (&quot;basicTTimeNoMillis&quot;.equals(input) || &quot;basic_t_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicTTimeNoMillis();
        } else if (&quot;basicWeekDate&quot;.equals(input) || &quot;basic_week_date&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicWeekDate();
        } else if (&quot;basicWeekDateTime&quot;.equals(input) || &quot;basic_week_date_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicWeekDateTime();
        } else if (&quot;basicWeekDateTimeNoMillis&quot;.equals(input) || &quot;basic_week_date_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.basicWeekDateTimeNoMillis();
        } else if (&quot;date&quot;.equals(input)) {
            formatter = ISODateTimeFormat.date();
        } else if (&quot;dateHour&quot;.equals(input) || &quot;date_hour&quot;.equals(input)) {
            formatter = ISODateTimeFormat.dateHour();
        } else if (&quot;dateHourMinute&quot;.equals(input) || &quot;date_hour_minute&quot;.equals(input)) {
            formatter = ISODateTimeFormat.dateHourMinute();
        } else if (&quot;dateHourMinuteSecond&quot;.equals(input) || &quot;date_hour_minute_second&quot;.equals(input)) {
            formatter = ISODateTimeFormat.dateHourMinuteSecond();
        } else if (&quot;dateHourMinuteSecondFraction&quot;.equals(input) || &quot;date_hour_minute_second_fraction&quot;.equals(input)) {
            formatter = ISODateTimeFormat.dateHourMinuteSecondFraction();
        } else if (&quot;dateHourMinuteSecondMillis&quot;.equals(input) || &quot;date_hour_minute_second_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.dateHourMinuteSecondMillis();
        } else if (&quot;dateOptionalTime&quot;.equals(input) || &quot;date_optional_time&quot;.equals(input)) {
            // in this case, we have a separate parser and printer since the dataOptionalTimeParser can't print
            // this sucks we should use the root local by default and not be dependent on the node
            return new FormatDateTimeFormatter(input,
                    ISODateTimeFormat.dateOptionalTimeParser().withZone(DateTimeZone.UTC),
                    ISODateTimeFormat.dateTime().withZone(DateTimeZone.UTC), locale);
        } else if (&quot;dateTime&quot;.equals(input) || &quot;date_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.dateTime();
        } else if (&quot;dateTimeNoMillis&quot;.equals(input) || &quot;date_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.dateTimeNoMillis();
        } else if (&quot;hour&quot;.equals(input)) {
            formatter = ISODateTimeFormat.hour();
        } else if (&quot;hourMinute&quot;.equals(input) || &quot;hour_minute&quot;.equals(input)) {
            formatter = ISODateTimeFormat.hourMinute();
        } else if (&quot;hourMinuteSecond&quot;.equals(input) || &quot;hour_minute_second&quot;.equals(input)) {
            formatter = ISODateTimeFormat.hourMinuteSecond();
        } else if (&quot;hourMinuteSecondFraction&quot;.equals(input) || &quot;hour_minute_second_fraction&quot;.equals(input)) {
            formatter = ISODateTimeFormat.hourMinuteSecondFraction();
        } else if (&quot;hourMinuteSecondMillis&quot;.equals(input) || &quot;hour_minute_second_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.hourMinuteSecondMillis();
        } else if (&quot;ordinalDate&quot;.equals(input) || &quot;ordinal_date&quot;.equals(input)) {
            formatter = ISODateTimeFormat.ordinalDate();
        } else if (&quot;ordinalDateTime&quot;.equals(input) || &quot;ordinal_date_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.ordinalDateTime();
        } else if (&quot;ordinalDateTimeNoMillis&quot;.equals(input) || &quot;ordinal_date_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.ordinalDateTimeNoMillis();
        } else if (&quot;time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.time();
        } else if (&quot;timeNoMillis&quot;.equals(input) || &quot;time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.timeNoMillis();
        } else if (&quot;tTime&quot;.equals(input) || &quot;t_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.tTime();
        } else if (&quot;tTimeNoMillis&quot;.equals(input) || &quot;t_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.tTimeNoMillis();
        } else if (&quot;weekDate&quot;.equals(input) || &quot;week_date&quot;.equals(input)) {
            formatter = ISODateTimeFormat.weekDate();
        } else if (&quot;weekDateTime&quot;.equals(input) || &quot;week_date_time&quot;.equals(input)) {
            formatter = ISODateTimeFormat.weekDateTime();
        } else if (&quot;weekDateTimeNoMillis&quot;.equals(input) || &quot;week_date_time_no_millis&quot;.equals(input)) {
            formatter = ISODateTimeFormat.weekDateTimeNoMillis();
        } else if (&quot;weekyear&quot;.equals(input) || &quot;week_year&quot;.equals(input)) {
            formatter = ISODateTimeFormat.weekyear();
        } else if (&quot;weekyearWeek&quot;.equals(input) || &quot;weekyear_week&quot;.equals(input)) {
            formatter = ISODateTimeFormat.weekyearWeek();
        } else if (&quot;weekyearWeekDay&quot;.equals(input) || &quot;weekyear_week_day&quot;.equals(input)) {
            formatter = ISODateTimeFormat.weekyearWeekDay();
        } else if (&quot;year&quot;.equals(input)) {
            formatter = ISODateTimeFormat.year();
        } else if (&quot;yearMonth&quot;.equals(input) || &quot;year_month&quot;.equals(input)) {
            formatter = ISODateTimeFormat.yearMonth();
        } else if (&quot;yearMonthDay&quot;.equals(input) || &quot;year_month_day&quot;.equals(input)) {
            formatter = ISODateTimeFormat.yearMonthDay();
        } else if (&quot;epoch_second&quot;.equals(input)) {
            formatter = new DateTimeFormatterBuilder().append(new EpochTimePrinter(false), new EpochTimeParser(false)).toFormatter();
        } else if (&quot;epoch_millis&quot;.equals(input)) {
            formatter = new DateTimeFormatterBuilder().append(new EpochTimePrinter(true), new EpochTimeParser(true)).toFormatter();
        // strict date formats here, must be at least 4 digits for year and two for months and two for day
        } else if (&quot;strictBasicWeekDate&quot;.equals(input) || &quot;strict_basic_week_date&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.basicWeekDate();
        } else if (&quot;strictBasicWeekDateTime&quot;.equals(input) || &quot;strict_basic_week_date_time&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.basicWeekDateTime();
        } else if (&quot;strictBasicWeekDateTimeNoMillis&quot;.equals(input) || &quot;strict_basic_week_date_time_no_millis&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.basicWeekDateTimeNoMillis();
        } else if (&quot;strictDate&quot;.equals(input) || &quot;strict_date&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.date();
        } else if (&quot;strictDateHour&quot;.equals(input) || &quot;strict_date_hour&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.dateHour();
        } else if (&quot;strictDateHourMinute&quot;.equals(input) || &quot;strict_date_hour_minute&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.dateHourMinute();
        } else if (&quot;strictDateHourMinuteSecond&quot;.equals(input) || &quot;strict_date_hour_minute_second&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.dateHourMinuteSecond();
        } else if (&quot;strictDateHourMinuteSecondFraction&quot;.equals(input) || &quot;strict_date_hour_minute_second_fraction&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.dateHourMinuteSecondFraction();
        } else if (&quot;strictDateHourMinuteSecondMillis&quot;.equals(input) || &quot;strict_date_hour_minute_second_millis&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.dateHourMinuteSecondMillis();
        } else if (&quot;strictDateOptionalTime&quot;.equals(input) || &quot;strict_date_optional_time&quot;.equals(input)) {
            // in this case, we have a separate parser and printer since the dataOptionalTimeParser can't print
            // this sucks we should use the root local by default and not be dependent on the node
            return new FormatDateTimeFormatter(input,
                    StrictISODateTimeFormat.dateOptionalTimeParser().withZone(DateTimeZone.UTC),
                    StrictISODateTimeFormat.dateTime().withZone(DateTimeZone.UTC), locale);
        } else if (&quot;strictDateTime&quot;.equals(input) || &quot;strict_date_time&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.dateTime();
        } else if (&quot;strictDateTimeNoMillis&quot;.equals(input) || &quot;strict_date_time_no_millis&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.dateTimeNoMillis();
        } else if (&quot;strictHour&quot;.equals(input) || &quot;strict_hour&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.hour();
        } else if (&quot;strictHourMinute&quot;.equals(input) || &quot;strict_hour_minute&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.hourMinute();
        } else if (&quot;strictHourMinuteSecond&quot;.equals(input) || &quot;strict_hour_minute_second&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.hourMinuteSecond();
        } else if (&quot;strictHourMinuteSecondFraction&quot;.equals(input) || &quot;strict_hour_minute_second_fraction&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.hourMinuteSecondFraction();
        } else if (&quot;strictHourMinuteSecondMillis&quot;.equals(input) || &quot;strict_hour_minute_second_millis&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.hourMinuteSecondMillis();
        } else if (&quot;strictOrdinalDate&quot;.equals(input) || &quot;strict_ordinal_date&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.ordinalDate();
        } else if (&quot;strictOrdinalDateTime&quot;.equals(input) || &quot;strict_ordinal_date_time&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.ordinalDateTime();
        } else if (&quot;strictOrdinalDateTimeNoMillis&quot;.equals(input) || &quot;strict_ordinal_date_time_no_millis&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.ordinalDateTimeNoMillis();
        } else if (&quot;strictTime&quot;.equals(input) || &quot;strict_time&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.time();
        } else if (&quot;strictTimeNoMillis&quot;.equals(input) || &quot;strict_time_no_millis&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.timeNoMillis();
        } else if (&quot;strictTTime&quot;.equals(input) || &quot;strict_t_time&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.tTime();
        } else if (&quot;strictTTimeNoMillis&quot;.equals(input) || &quot;strict_t_time_no_millis&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.tTimeNoMillis();
        } else if (&quot;strictWeekDate&quot;.equals(input) || &quot;strict_week_date&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.weekDate();
        } else if (&quot;strictWeekDateTime&quot;.equals(input) || &quot;strict_week_date_time&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.weekDateTime();
        } else if (&quot;strictWeekDateTimeNoMillis&quot;.equals(input) || &quot;strict_week_date_time_no_millis&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.weekDateTimeNoMillis();
        } else if (&quot;strictWeekyear&quot;.equals(input) || &quot;strict_weekyear&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.weekyear();
        } else if (&quot;strictWeekyearWeek&quot;.equals(input) || &quot;strict_weekyear_week&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.weekyearWeek();
        } else if (&quot;strictWeekyearWeekDay&quot;.equals(input) || &quot;strict_weekyear_week_day&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.weekyearWeekDay();
        } else if (&quot;strictYear&quot;.equals(input) || &quot;strict_year&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.year();
        } else if (&quot;strictYearMonth&quot;.equals(input) || &quot;strict_year_month&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.yearMonth();
        } else if (&quot;strictYearMonthDay&quot;.equals(input) || &quot;strict_year_month_day&quot;.equals(input)) {
            formatter = StrictISODateTimeFormat.yearMonthDay();
        } else if (Strings.hasLength(input) &amp;&amp; input.contains(&quot;||&quot;)) {
            String[] formats = Strings.delimitedListToStringArray(input, &quot;||&quot;);
            DateTimeParser[] parsers = new DateTimeParser[formats.length];

            if (formats.length == 1) {
                formatter = forPattern(input, locale).parser();
            } else {
                DateTimeFormatter dateTimeFormatter = null;
                for (int i = 0; i &lt; formats.length; i++) {
                    FormatDateTimeFormatter currentFormatter = forPattern(formats[i], locale);
                    DateTimeFormatter currentParser = currentFormatter.parser();
                    if (dateTimeFormatter == null) {
                        dateTimeFormatter = currentFormatter.printer();
                    }
                    parsers[i] = currentParser.getParser();
                }

                assert dateTimeFormatter != null;
                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder().append(dateTimeFormatter.withZone(DateTimeZone.UTC).getPrinter(), parsers);
                formatter = builder.toFormatter();
            }
        } else {
            try {
                formatter = DateTimeFormat.forPattern(input);
            } catch (IllegalArgumentException e) {
                throw new IllegalArgumentException(&quot;Invalid format: [&quot; + input + &quot;]: &quot; + e.getMessage(), e);
            }
        }

        return new FormatDateTimeFormatter(input, formatter.withZone(DateTimeZone.UTC), locale);
    }

    public static FormatDateTimeFormatter getStrictStandardDateFormatter() {
        // 2014/10/10
        DateTimeFormatter shortFormatter = new DateTimeFormatterBuilder()
                .appendFixedDecimal(DateTimeFieldType.year(), 4)
                .appendLiteral('/')
                .appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2)
                .appendLiteral('/')
                .appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2)
                .toFormatter()
                .withZoneUTC();

        // 2014/10/10 12:12:12
        DateTimeFormatter longFormatter = new DateTimeFormatterBuilder()
                .appendFixedDecimal(DateTimeFieldType.year(), 4)
                .appendLiteral('/')
                .appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2)
                .appendLiteral('/')
                .appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2)
                .appendLiteral(' ')
                .appendFixedSignedDecimal(DateTimeFieldType.hourOfDay(), 2)
                .appendLiteral(':')
                .appendFixedSignedDecimal(DateTimeFieldType.minuteOfHour(), 2)
                .appendLiteral(':')
                .appendFixedSignedDecimal(DateTimeFieldType.secondOfMinute(), 2)
                .toFormatter()
                .withZoneUTC();

        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder().append(longFormatter.withZone(DateTimeZone.UTC).getPrinter(), new DateTimeParser[]{longFormatter.getParser(), shortFormatter.getParser(), new EpochTimeParser(true)});

        return new FormatDateTimeFormatter(&quot;yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis&quot;, builder.toFormatter().withZone(DateTimeZone.UTC), Locale.ROOT);
    }


    public static final DurationFieldType QUARTERS = new DurationFieldType(&quot;quarters&quot;) {
        @Override
        public DurationField getField(Chronology chronology) {
            return new ScaledDurationField(chronology.months(), QUARTERS, 3);
        }
<A NAME="0"></A>    };

    public static final DateTimeFieldType QUARTER_OF_YEAR = new DateTimeFieldType(&quot;quarterOfYear&quot;) {
        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4535891-0.html#0',2,'match4535891-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
        public DurationFieldType getDurationType() {
            return QUARTERS;
        }

        @Override
        public DurationFieldType getRangeDurationType() {
            return</B></FONT> DurationFieldType.years();
        }

        @Override
        public DateTimeField getField(Chronology chronology) {
            return new OffsetDateTimeField(new DividedDateTimeField(new OffsetDateTimeField(chronology.monthOfYear(), -1), QUARTER_OF_YEAR, 3), 1);
        }
    };

    public static class EpochTimeParser implements DateTimeParser {

        private final boolean hasMilliSecondPrecision;

        public EpochTimeParser(boolean hasMilliSecondPrecision) {
            this.hasMilliSecondPrecision = hasMilliSecondPrecision;
        }

        @Override
        public int estimateParsedLength() {
            return hasMilliSecondPrecision ? 19 : 16;
        }

        @Override
        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
            boolean isPositive = text.startsWith(&quot;-&quot;) == false;
            int firstDotIndex = text.indexOf('.');
            boolean isTooLong = (firstDotIndex == -1 ? text.length() : firstDotIndex) &gt; estimateParsedLength();

            if (bucket.getZone() != DateTimeZone.UTC) {
                String format = hasMilliSecondPrecision ? &quot;epoch_millis&quot; : &quot;epoch_second&quot;;
                throw new IllegalArgumentException(&quot;time_zone must be UTC for format [&quot; + format + &quot;]&quot;);
            } else if (isPositive &amp;&amp; isTooLong) {
                return -1;
            }

            int factor = hasMilliSecondPrecision ? 1 : 1000;
            try {
                long millis = new BigDecimal(text).longValue() * factor;
                DateTime dt = new DateTime(millis, DateTimeZone.UTC);
                bucket.saveField(DateTimeFieldType.year(), dt.getYear());
                bucket.saveField(DateTimeFieldType.monthOfYear(), dt.getMonthOfYear());
                bucket.saveField(DateTimeFieldType.dayOfMonth(), dt.getDayOfMonth());
                bucket.saveField(DateTimeFieldType.hourOfDay(), dt.getHourOfDay());
                bucket.saveField(DateTimeFieldType.minuteOfHour(), dt.getMinuteOfHour());
                bucket.saveField(DateTimeFieldType.secondOfMinute(), dt.getSecondOfMinute());
                bucket.saveField(DateTimeFieldType.millisOfSecond(), dt.getMillisOfSecond());
                bucket.setZone(DateTimeZone.UTC);
            } catch (Exception e) {
                return -1;
            }
            return text.length();
        }
    }

    public static class EpochTimePrinter implements DateTimePrinter {

        private boolean hasMilliSecondPrecision;

        public EpochTimePrinter(boolean hasMilliSecondPrecision) {
            this.hasMilliSecondPrecision = hasMilliSecondPrecision;
        }

        @Override
        public int estimatePrintedLength() {
            return hasMilliSecondPrecision ? 19 : 16;
        }


        /**
         * We adjust the instant by displayOffset to adjust for the offset that might have been added in
         * {@link DateTimeFormatter#printTo(Appendable, long, Chronology)} when using a time zone.
         */
        @Override
        public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) {
            if (hasMilliSecondPrecision) {
                buf.append(instant - displayOffset);
            } else {
                buf.append((instant - displayOffset) / 1000);
            }
        }

        /**
         * We adjust the instant by displayOffset to adjust for the offset that might have been added in
         * {@link DateTimeFormatter#printTo(Appendable, long, Chronology)} when using a time zone.
         */
        @Override
        public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
            if (hasMilliSecondPrecision) {
                out.write(String.valueOf(instant - displayOffset));
            } else {
                out.append(String.valueOf((instant - displayOffset) / 1000));
            }
        }

        @Override
        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
            if (hasMilliSecondPrecision) {
                buf.append(String.valueOf(getDateTimeMillis(partial)));
            } else {
                buf.append(String.valueOf(getDateTimeMillis(partial) / 1000));
            }
        }

        @Override
        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
            if (hasMilliSecondPrecision) {
                out.append(String.valueOf(getDateTimeMillis(partial)));
            } else {
                out.append(String.valueOf(getDateTimeMillis(partial) / 1000));
            }
        }

        private long getDateTimeMillis(ReadablePartial partial) {
            int year = partial.get(DateTimeFieldType.year());
            int monthOfYear = partial.get(DateTimeFieldType.monthOfYear());
            int dayOfMonth = partial.get(DateTimeFieldType.dayOfMonth());
            int hourOfDay = partial.get(DateTimeFieldType.hourOfDay());
            int minuteOfHour = partial.get(DateTimeFieldType.minuteOfHour());
            int secondOfMinute = partial.get(DateTimeFieldType.secondOfMinute());
            int millisOfSecond = partial.get(DateTimeFieldType.millisOfSecond());
            return partial.getChronology().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
