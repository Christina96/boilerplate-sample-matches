<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for CombinedFuture_1.java & CycleDetectingLockFactoryTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for CombinedFuture_1.java & CycleDetectingLockFactoryTest.java
      </h3>
      <h1 align="center">
        5.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>CombinedFuture_1.java (10.869565%)<TH>CycleDetectingLockFactoryTest.java (3.894081%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1255060-0.html#0',2,'match1255060-1.html#0',3)" NAME="0">(15-32)<TD><A HREF="javascript:ZweiFrames('match1255060-0.html#0',2,'match1255060-1.html#0',3)" NAME="0">(17-38)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1255060-0.html#1',2,'match1255060-1.html#1',3)" NAME="1">(108-114)<TD><A HREF="javascript:ZweiFrames('match1255060-0.html#1',2,'match1255060-1.html#1',3)" NAME="1">(145-151)</A><TD ALIGN=center><FONT COLOR="#c80000">11</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CombinedFuture_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2015 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
<A NAME="0"></A> * the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1255060-1.html#0',3,'match1255060-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.util.concurrent;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.OUTPUT_FUTURE_DONE;

import com.google.common.annotations.GwtCompatible;
import com.google.common.collect.ImmutableCollection;
import com.google.j2objc.annotations.WeakOuter;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/** Aggregate future that computes its value by calling a callable. */
@GwtC</B></FONT>ompatible
@ElementTypesAreNonnullByDefault
final class CombinedFuture&lt;V extends @Nullable Object&gt;
    extends AggregateFuture&lt;@Nullable Object, V&gt; {
  @CheckForNull private CombinedFutureInterruptibleTask&lt;?&gt; task;

  CombinedFuture(
      ImmutableCollection&lt;? extends ListenableFuture&lt;?&gt;&gt; futures,
      boolean allMustSucceed,
      Executor listenerExecutor,
      AsyncCallable&lt;V&gt; callable) {
    super(futures, allMustSucceed, false);
    this.task = new AsyncCallableInterruptibleTask(callable, listenerExecutor);
    init();
  }

  CombinedFuture(
      ImmutableCollection&lt;? extends ListenableFuture&lt;?&gt;&gt; futures,
      boolean allMustSucceed,
      Executor listenerExecutor,
      Callable&lt;V&gt; callable) {
    super(futures, allMustSucceed, false);
    this.task = new CallableInterruptibleTask(callable, listenerExecutor);
    init();
  }

  @Override
  void collectOneValue(int index, @CheckForNull Object returnValue) {}

  @Override
  void handleAllCompleted() {
    CombinedFutureInterruptibleTask&lt;?&gt; localTask = task;
    if (localTask != null) {
      localTask.execute();
    }
  }

  @Override
  void releaseResources(ReleaseResourcesReason reason) {
    super.releaseResources(reason);
    /*
     * If the output future is done, then it won't need to interrupt the task later, so it can clear
     * its reference to it.
     *
     * If the output future is *not* done, then the task field will be cleared after the task runs
     * or after the output future is done, whichever comes first.
     */
    if (reason == OUTPUT_FUTURE_DONE) {
      this.task = null;
    }
  }

  @Override
  protected void interruptTask() {
    CombinedFutureInterruptibleTask&lt;?&gt; localTask = task;
    if (localTask != null) {
      localTask.interruptTask();
    }
  }

  @WeakOuter
  private abstract class CombinedFutureInterruptibleTask&lt;T extends @Nullable Object&gt;
      extends InterruptibleTask&lt;T&gt; {
    private final Executor listenerExecutor;

    CombinedFutureInterruptibleTask(Executor listenerExecutor) {
      this.listenerExecutor = checkNotNull(listenerExecutor);
    }

    @Override
    final boolean isDone() {
      return CombinedFuture.this.isDone();
    }
<A NAME="1"></A>
    final void execute() {
      try {
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1255060-1.html#1',3,'match1255060-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>listenerExecutor.execute(this);
      } catch (RejectedExecutionException e) {
        CombinedFuture.this.setException(e);
      }
    }

    @Override</B></FONT>
    final void afterRanInterruptiblySuccess(@ParametricNullness T result) {
      /*
       * The future no longer needs to interrupt this task, so it no longer needs a reference to it.
       *
       * TODO(cpovirk): It might be nice for our InterruptibleTask subclasses to null out their
       *  `callable` fields automatically. That would make it less important for us to null out the
       * reference to `task` here (though it's still nice to do so in case our reference to the
       * executor keeps it alive). Ideally, nulling out `callable` would be the responsibility of
       * InterruptibleTask itself so that its other subclasses also benefit. (Handling `callable` in
       * InterruptibleTask itself might also eliminate some of the existing boilerplate for, e.g.,
       * pendingToString().)
       */
      CombinedFuture.this.task = null;

      setValue(result);
    }

    @Override
    final void afterRanInterruptiblyFailure(Throwable error) {
      // See afterRanInterruptiblySuccess.
      CombinedFuture.this.task = null;

      if (error instanceof ExecutionException) {
        /*
         * Cast to ExecutionException to satisfy our nullness checker, which (unsoundly but
         * *usually* safely) assumes that getCause() returns non-null on an ExecutionException.
         */
        CombinedFuture.this.setException(((ExecutionException) error).getCause());
      } else if (error instanceof CancellationException) {
        cancel(false);
      } else {
        CombinedFuture.this.setException(error);
      }
    }

    abstract void setValue(@ParametricNullness T value);
  }

  @WeakOuter
  private final class AsyncCallableInterruptibleTask
      extends CombinedFutureInterruptibleTask&lt;ListenableFuture&lt;V&gt;&gt; {
    private final AsyncCallable&lt;V&gt; callable;

    AsyncCallableInterruptibleTask(AsyncCallable&lt;V&gt; callable, Executor listenerExecutor) {
      super(listenerExecutor);
      this.callable = checkNotNull(callable);
    }

    @Override
    ListenableFuture&lt;V&gt; runInterruptibly() throws Exception {
      ListenableFuture&lt;V&gt; result = callable.call();
      return checkNotNull(
          result,
          &quot;AsyncCallable.call returned null instead of a Future. &quot;
              + &quot;Did you mean to return immediateFuture(null)? %s&quot;,
          callable);
    }

    @Override
    void setValue(ListenableFuture&lt;V&gt; value) {
      CombinedFuture.this.setFuture(value);
    }

    @Override
    String toPendingString() {
      return callable.toString();
    }
  }

  @WeakOuter
  private final class CallableInterruptibleTask extends CombinedFutureInterruptibleTask&lt;V&gt; {
    private final Callable&lt;V&gt; callable;

    CallableInterruptibleTask(Callable&lt;V&gt; callable, Executor listenerExecutor) {
      super(listenerExecutor);
      this.callable = checkNotNull(callable);
    }

    @Override
    @ParametricNullness
    V runInterruptibly() throws Exception {
      return callable.call();
    }

    @Override
    void setValue(@ParametricNullness V value) {
      CombinedFuture.this.set(value);
    }

    @Override
    String toPendingString() {
      return callable.toString();
    }
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CycleDetectingLockFactoryTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="0"></A> * limitations under the License.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1255060-0.html#0',2,'match1255060-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.util.concurrent;


import com.google.common.base.Joiner;
import com.google.common.util.concurrent.CycleDetectingLockFactory.Policies;
import com.google.common.util.concurrent.CycleDetectingLockFactory.Policy;
import com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import junit.framework.TestCase;

/**
 * Unittests for {@link CycleDetectingLockFactory}.
 *
 * @author Darick Tong
 */
publi</B></FONT>c class CycleDetectingLockFactoryTest extends TestCase {

  private ReentrantLock lockA;
  private ReentrantLock lockB;
  private ReentrantLock lockC;
  private ReentrantReadWriteLock.ReadLock readLockA;
  private ReentrantReadWriteLock.ReadLock readLockB;
  private ReentrantReadWriteLock.ReadLock readLockC;
  private ReentrantReadWriteLock.WriteLock writeLockA;
  private ReentrantReadWriteLock.WriteLock writeLockB;
  private ReentrantReadWriteLock.WriteLock writeLockC;
  private ReentrantLock lock1;
  private ReentrantLock lock2;
  private ReentrantLock lock3;
  private ReentrantLock lock01;
  private ReentrantLock lock02;
  private ReentrantLock lock03;

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    CycleDetectingLockFactory factory = CycleDetectingLockFactory.newInstance(Policies.THROW);
    lockA = factory.newReentrantLock(&quot;LockA&quot;);
    lockB = factory.newReentrantLock(&quot;LockB&quot;);
    lockC = factory.newReentrantLock(&quot;LockC&quot;);
    ReentrantReadWriteLock readWriteLockA = factory.newReentrantReadWriteLock(&quot;ReadWriteA&quot;);
    ReentrantReadWriteLock readWriteLockB = factory.newReentrantReadWriteLock(&quot;ReadWriteB&quot;);
    ReentrantReadWriteLock readWriteLockC = factory.newReentrantReadWriteLock(&quot;ReadWriteC&quot;);
    readLockA = readWriteLockA.readLock();
    readLockB = readWriteLockB.readLock();
    readLockC = readWriteLockC.readLock();
    writeLockA = readWriteLockA.writeLock();
    writeLockB = readWriteLockB.writeLock();
    writeLockC = readWriteLockC.writeLock();

    CycleDetectingLockFactory.WithExplicitOrdering&lt;MyOrder&gt; factory2 =
        newInstanceWithExplicitOrdering(MyOrder.class, Policies.THROW);
    lock1 = factory2.newReentrantLock(MyOrder.FIRST);
    lock2 = factory2.newReentrantLock(MyOrder.SECOND);
    lock3 = factory2.newReentrantLock(MyOrder.THIRD);

    CycleDetectingLockFactory.WithExplicitOrdering&lt;OtherOrder&gt; factory3 =
        newInstanceWithExplicitOrdering(OtherOrder.class, Policies.THROW);
    lock01 = factory3.newReentrantLock(OtherOrder.FIRST);
    lock02 = factory3.newReentrantLock(OtherOrder.SECOND);
    lock03 = factory3.newReentrantLock(OtherOrder.THIRD);
  }

  // In the unittest, create each ordered factory with its own set of lock
  // graph nodes (as opposed to using the static per-Enum map) to avoid
  // conflicts across different test runs.
  private &lt;E extends Enum&lt;E&gt;&gt;
      CycleDetectingLockFactory.WithExplicitOrdering&lt;E&gt; newInstanceWithExplicitOrdering(
          Class&lt;E&gt; enumClass, Policy policy) {
    return new CycleDetectingLockFactory.WithExplicitOrdering&lt;E&gt;(
        policy, CycleDetectingLockFactory.createNodes(enumClass));
  }

  public void testDeadlock_twoLocks() {
    // Establish an acquisition order of lockA -&gt; lockB.
    lockA.lock();
    lockB.lock();
    lockA.unlock();
    lockB.unlock();

    // The opposite order should fail (Policies.THROW).
    PotentialDeadlockException firstException = null;
    lockB.lock();
    try {
      lockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; LockA&quot;, &quot;LockA -&gt; LockB&quot;);
      firstException = expected;
    }

    // Second time should also fail, with a cached causal chain.
    try {
      lockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; LockA&quot;, &quot;LockA -&gt; LockB&quot;);
      // The causal chain should be cached.
      assertSame(firstException.getCause(), expected.getCause());
    }

    // lockA should work after lockB is released.
    lockB.unlock();
    lockA.lock();
  }

  // Tests transitive deadlock detection.
  public void testDeadlock_threeLocks() {
    // Establish an ordering from lockA -&gt; lockB.
    lockA.lock();
    lockB.lock();
    lockB.unlock();
    lockA.unlock();

    // Establish an ordering from lockB -&gt; lockC.
    lockB.lock();
    lockC.lock();
    lockB.unlock();

<A NAME="1"></A>    // lockC -&gt; lockA should fail.
    try {
      lockA.lock();
      <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1255060-0.html#1',2,'match1255060-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockC -&gt; LockA&quot;, &quot;LockB -&gt; LockC&quot;, &quot;LockA -&gt; LockB&quot;);
    }
  }

  public void testReentranc</B></FONT>y_noDeadlock() {
    lockA.lock();
    lockB.lock();
    lockA.lock(); // Should not assert on lockB -&gt; reentrant(lockA)
  }

  public void testExplicitOrdering_noViolations() {
    lock1.lock();
    lock3.lock();
    lock3.unlock();
    lock2.lock();
    lock3.lock();
  }

  public void testExplicitOrdering_violations() {
    lock3.lock();
    try {
      lock2.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;MyOrder.THIRD -&gt; MyOrder.SECOND&quot;);
    }

    try {
      lock1.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;MyOrder.THIRD -&gt; MyOrder.FIRST&quot;);
    }

    lock3.unlock();
    lock2.lock();

    try {
      lock1.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;MyOrder.SECOND -&gt; MyOrder.FIRST&quot;);
    }
  }

  public void testDifferentOrderings_noViolations() {
    lock3.lock(); // MyOrder, ordinal() == 3
    lock01.lock(); // OtherOrder, ordinal() == 1
  }

  public void testExplicitOrderings_generalCycleDetection() {
    lock3.lock(); // MyOrder, ordinal() == 3
    lock01.lock(); // OtherOrder, ordinal() == 1

    lock3.unlock();
    try {
      lock3.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected, &quot;OtherOrder.FIRST -&gt; MyOrder.THIRD&quot;, &quot;MyOrder.THIRD -&gt; OtherOrder.FIRST&quot;);
    }

    lockA.lock();
    lock01.unlock();
    lockB.lock();
    lockA.unlock();

    try {
      lock01.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected, &quot;LockB -&gt; OtherOrder.FIRST&quot;, &quot;LockA -&gt; LockB&quot;, &quot;OtherOrder.FIRST -&gt; LockA&quot;);
    }
  }

  public void testExplicitOrdering_cycleWithUnorderedLock() {
    Lock myLock = CycleDetectingLockFactory.newInstance(Policies.THROW).newReentrantLock(&quot;MyLock&quot;);
    lock03.lock();
    myLock.lock();
    lock03.unlock();

    try {
      lock01.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected,
          &quot;MyLock -&gt; OtherOrder.FIRST&quot;,
          &quot;OtherOrder.THIRD -&gt; MyLock&quot;,
          &quot;OtherOrder.FIRST -&gt; OtherOrder.THIRD&quot;);
    }
  }

  public void testExplicitOrdering_reentrantAcquisition() {
    CycleDetectingLockFactory.WithExplicitOrdering&lt;OtherOrder&gt; factory =
        newInstanceWithExplicitOrdering(OtherOrder.class, Policies.THROW);
    Lock lockA = factory.newReentrantReadWriteLock(OtherOrder.FIRST).readLock();
    Lock lockB = factory.newReentrantLock(OtherOrder.SECOND);

    lockA.lock();
    lockA.lock();
    lockB.lock();
    lockB.lock();
    lockA.unlock();
    lockA.unlock();
    lockB.unlock();
    lockB.unlock();
  }

  public void testExplicitOrdering_acquiringMultipleLocksWithSameRank() {
    CycleDetectingLockFactory.WithExplicitOrdering&lt;OtherOrder&gt; factory =
        newInstanceWithExplicitOrdering(OtherOrder.class, Policies.THROW);
    Lock lockA = factory.newReentrantLock(OtherOrder.FIRST);
    Lock lockB = factory.newReentrantReadWriteLock(OtherOrder.FIRST).readLock();

    lockA.lock();
    try {
      lockB.lock();
      fail(&quot;Expected IllegalStateException&quot;);
    } catch (IllegalStateException expected) {
    }

    lockA.unlock();
    lockB.lock();
  }

  public void testReadLock_deadlock() {
    readLockA.lock(); // Establish an ordering from readLockA -&gt; lockB.
    lockB.lock();
    lockB.unlock();
    readLockA.unlock();

    lockB.lock();
    try {
      readLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; ReadWriteA&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }

  public void testReadLock_transitive() {
    readLockA.lock(); // Establish an ordering from readLockA -&gt; lockB.
    lockB.lock();
    lockB.unlock();
    readLockA.unlock();

    // Establish an ordering from lockB -&gt; readLockC.
    lockB.lock();
    readLockC.lock();
    lockB.unlock();
    readLockC.unlock();

    // readLockC -&gt; readLockA
    readLockC.lock();
    try {
      readLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected, &quot;ReadWriteC -&gt; ReadWriteA&quot;, &quot;LockB -&gt; ReadWriteC&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }

  public void testWriteLock_threeLockDeadLock() {
    // Establish an ordering from writeLockA -&gt; writeLockB.
    writeLockA.lock();
    writeLockB.lock();
    writeLockB.unlock();
    writeLockA.unlock();

    // Establish an ordering from writeLockB -&gt; writeLockC.
    writeLockB.lock();
    writeLockC.lock();
    writeLockB.unlock();

    // writeLockC -&gt; writeLockA should fail.
    try {
      writeLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected,
          &quot;ReadWriteC -&gt; ReadWriteA&quot;,
          &quot;ReadWriteB -&gt; ReadWriteC&quot;,
          &quot;ReadWriteA -&gt; ReadWriteB&quot;);
    }
  }

  public void testWriteToReadLockDowngrading() {
    writeLockA.lock(); // writeLockA downgrades to readLockA
    readLockA.lock();
    writeLockA.unlock();

    lockB.lock(); // readLockA -&gt; lockB
    readLockA.unlock();

    // lockB -&gt; writeLockA should fail
    try {
      writeLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; ReadWriteA&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }

  public void testReadWriteLockDeadlock() {
    writeLockA.lock(); // Establish an ordering from writeLockA -&gt; lockB
    lockB.lock();
    writeLockA.unlock();
    lockB.unlock();

    // lockB -&gt; readLockA should fail.
    lockB.lock();
    try {
      readLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockB -&gt; ReadWriteA&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }

  public void testReadWriteLockDeadlock_transitive() {
    readLockA.lock(); // Establish an ordering from readLockA -&gt; lockB
    lockB.lock();
    readLockA.unlock();
    lockB.unlock();

    // Establish an ordering from lockB -&gt; lockC
    lockB.lock();
    lockC.lock();
    lockB.unlock();
    lockC.unlock();

    // lockC -&gt; writeLockA should fail.
    lockC.lock();
    try {
      writeLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockC -&gt; ReadWriteA&quot;, &quot;LockB -&gt; LockC&quot;, &quot;ReadWriteA -&gt; LockB&quot;);
    }
  }

  public void testReadWriteLockDeadlock_treatedEquivalently() {
    readLockA.lock(); // readLockA -&gt; writeLockB
    writeLockB.lock();
    readLockA.unlock();
    writeLockB.unlock();

    // readLockB -&gt; writeLockA should fail.
    readLockB.lock();
    try {
      writeLockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;ReadWriteB -&gt; ReadWriteA&quot;, &quot;ReadWriteA -&gt; ReadWriteB&quot;);
    }
  }

  public void testDifferentLockFactories() {
    CycleDetectingLockFactory otherFactory = CycleDetectingLockFactory.newInstance(Policies.WARN);
    ReentrantLock lockD = otherFactory.newReentrantLock(&quot;LockD&quot;);

    // lockA -&gt; lockD
    lockA.lock();
    lockD.lock();
    lockA.unlock();
    lockD.unlock();

    // lockD -&gt; lockA should fail even though lockD is from a different factory.
    lockD.lock();
    try {
      lockA.lock();
      fail(&quot;Expected PotentialDeadlockException&quot;);
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, &quot;LockD -&gt; LockA&quot;, &quot;LockA -&gt; LockD&quot;);
    }
  }

  public void testDifferentLockFactories_policyExecution() {
    CycleDetectingLockFactory otherFactory = CycleDetectingLockFactory.newInstance(Policies.WARN);
    ReentrantLock lockD = otherFactory.newReentrantLock(&quot;LockD&quot;);

    // lockD -&gt; lockA
    lockD.lock();
    lockA.lock();
    lockA.unlock();
    lockD.unlock();

    // lockA -&gt; lockD should warn but otherwise succeed because lockD was
    // created by a factory with the WARN policy.
    lockA.lock();
    lockD.lock();
  }

  public void testReentrantLock_tryLock() throws Exception {
    LockingThread thread = new LockingThread(lockA);
    thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(lockA.tryLock());

    thread.releaseLockAndFinish();
    assertTrue(lockA.tryLock());
  }

  public void testReentrantWriteLock_tryLock() throws Exception {
    LockingThread thread = new LockingThread(writeLockA);
    thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(writeLockA.tryLock());
    assertFalse(readLockA.tryLock());

    thread.releaseLockAndFinish();
    assertTrue(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
  }

  public void testReentrantReadLock_tryLock() throws Exception {
    LockingThread thread = new LockingThread(readLockA);
    thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
    readLockA.unlock();

    thread.releaseLockAndFinish();
    assertTrue(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
  }

  private static class LockingThread extends Thread {
    final CountDownLatch locked = new CountDownLatch(1);
    final CountDownLatch finishLatch = new CountDownLatch(1);
    final Lock lock;

    LockingThread(Lock lock) {
      this.lock = lock;
    }

    @Override
    public void run() {
      lock.lock();
      try {
        locked.countDown();
        finishLatch.await(1, TimeUnit.MINUTES);
      } catch (InterruptedException e) {
        fail(e.toString());
      } finally {
        lock.unlock();
      }
    }

    void waitUntilHoldingLock() throws InterruptedException {
      locked.await(1, TimeUnit.MINUTES);
    }

    void releaseLockAndFinish() throws InterruptedException {
      finishLatch.countDown();
      this.join(10000);
      assertFalse(this.isAlive());
    }
  }

  public void testReentrantReadWriteLock_implDoesNotExposeShadowedLocks() {
    assertEquals(
        &quot;Unexpected number of public methods in ReentrantReadWriteLock. &quot;
            + &quot;The correctness of CycleDetectingReentrantReadWriteLock depends on &quot;
            + &quot;the fact that the shadowed ReadLock and WriteLock are never used or &quot;
            + &quot;exposed by the superclass implementation. If the implementation has &quot;
            + &quot;changed, the code must be re-inspected to ensure that the &quot;
            + &quot;assumption is still valid.&quot;,
        24,
        ReentrantReadWriteLock.class.getMethods().length);
  }

  private enum MyOrder {
    FIRST,
    SECOND,
    THIRD;
  }

  private enum OtherOrder {
    FIRST,
    SECOND,
    THIRD;
  }

  // Given a sequence of lock acquisition descriptions
  // (e.g. &quot;LockA -&gt; LockB&quot;, &quot;LockB -&gt; LockC&quot;, ...)
  // Checks that the exception.getMessage() matches a regex of the form:
  // &quot;LockA -&gt; LockB \b.*\b LockB -&gt; LockC \b.*\b LockC -&gt; LockA&quot;
  private void checkMessage(IllegalStateException exception, String... expectedLockCycle) {
    String regex = Joiner.on(&quot;\\b.*\\b&quot;).join(expectedLockCycle);
    assertContainsRegex(regex, exception.getMessage());
  }

  // TODO(cpovirk): consider adding support for regex to Truth
  private static void assertContainsRegex(String expectedRegex, String actual) {
    Pattern pattern = Pattern.compile(expectedRegex);
    Matcher matcher = pattern.matcher(actual);
    if (!matcher.find()) {
      String actualDesc = (actual == null) ? &quot;null&quot; : ('&lt;' + actual + '&gt;');
      fail(&quot;expected to contain regex:&lt;&quot; + expectedRegex + &quot;&gt; but was:&quot; + actualDesc);
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
