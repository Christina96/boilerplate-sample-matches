
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.483253588516746%, Tokens: 13</h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Query.java</h3>
            <pre><code>1  package redis.clients.jedis.search;
2  import java.util.HashMap;
3  import java.util.LinkedList;
4  import java.util.List;
5  import java.util.Map;
6  import redis.clients.jedis.CommandArguments;
7  import redis.clients.jedis.Protocol;
8  import redis.clients.jedis.params.IParams;
9  import redis.clients.jedis.search.SearchProtocol.SearchKeyword;
10  import redis.clients.jedis.util.LazyRawable;
11  import redis.clients.jedis.util.SafeEncoder;
12  public class Query implements IParams {
13    public abstract static class Filter implements IParams {
14      public final String property;
15      public Filter(String property) {
16        this.property = property;
17      }
18    }
19    public static class NumericFilter extends Filter {
20      private final double min;
21      private final boolean exclusiveMin;
22      private final double max;
23      private final boolean exclusiveMax;
24      public NumericFilter(String property, double min, boolean exclusiveMin, double max, boolean exclusiveMax) {
25        super(property);
26        this.min = min;
27        this.max = max;
28        this.exclusiveMax = exclusiveMax;
29        this.exclusiveMin = exclusiveMin;
30      }
31      public NumericFilter(String property, double min, double max) {
32        this(property, min, false, max, false);
33      }
34      private byte[] formatNum(double num, boolean exclude) {
35        return exclude ? SafeEncoder.encode("(" + num) : Protocol.toByteArray(num);
36      }
37      @Override
38      public void addParams(CommandArguments args) {
39        args.add(SearchKeyword.FILTER.getRaw());
40        args.add(SafeEncoder.encode(property));
41        args.add(formatNum(min, exclusiveMin));
42        args.add(formatNum(max, exclusiveMax));
43      }
44    }
45    public static class GeoFilter extends Filter {
46      public static final String KILOMETERS = "km";
47      public static final String METERS = "m";
48      public static final String FEET = "ft";
49      public static final String MILES = "mi";
50      private final double lon;
51      private final double lat;
52      private final double radius;
53      private final String unit;
54      public GeoFilter(String property, double lon, double lat, double radius, String unit) {
55        super(property);
56        this.lon = lon;
57        this.lat = lat;
58        this.radius = radius;
59        this.unit = unit;
60      }
61      @Override
62      public void addParams(CommandArguments args) {
63        args.add(SearchKeyword.GEOFILTER.getRaw());
64        args.add(SafeEncoder.encode(property));
65        args.add(Protocol.toByteArray(lon));
66        args.add(Protocol.toByteArray(lat));
67        args.add(Protocol.toByteArray(radius));
68        args.add(SafeEncoder.encode(unit));
69      }
70    }
71    public static class Paging {
72      int offset;
73      int num;
74      public Paging(int offset, int num) {
75        this.offset = offset;
76        this.num = num;
77      }
78    }
79    public static class HighlightTags {
80      private final String open;
81      private final String close;
82      public HighlightTags(String open, String close) {
83        this.open = open;
84        this.close = close;
85      }
86    }
87    private final List<Filter> _filters = new LinkedList<>();
88    private final String _queryString;
89    private final Paging _paging = new Paging(0, 10);
90    private boolean _verbatim = false;
91    private boolean _noContent = false;
92    private boolean _noStopwords = false;
93    private boolean _withScores = false;
94    private String _language = null;
95    private String[] _fields = null;
96    private String[] _keys = null;
97    private String[] _returnFields = null;
98    private FieldName[] returnFieldNames = null;
99    private String[] highlightFields = null;
100    private String[] summarizeFields = null;
101    private String[] highlightTags = null;
102    private String summarizeSeparator = null;
103    private int summarizeNumFragments = -1;
104    private int summarizeFragmentLen = -1;
105    private String _sortBy = null;
106    private boolean _sortAsc = true;
107    private boolean wantsHighlight = false;
108    private boolean wantsSummarize = false;
109    private String _scorer = null;
110    private Map<String, Object> _params = null;
111    private int _dialect = 0;
112    private int _slop = -1;
113    private long _timeout = -1;
114    private boolean _inOrder = false;
115    private String _expander = null;
116    public Query() {
117      this("*");
118    }
119    public Query(String queryString) {
120      _queryString = queryString;
121    }
122    @Override
123    public void addParams(CommandArguments args) {
124      args.add(SafeEncoder.encode(_queryString));
125      if (_verbatim) {
126        args.add(SearchKeyword.VERBATIM.getRaw());
127      }
128      if (_noContent) {
129        args.add(SearchKeyword.NOCONTENT.getRaw());
130      }
131      if (_noStopwords) {
132        args.add(SearchKeyword.NOSTOPWORDS.getRaw());
133      }
134      if (_withScores) {
135        args.add(SearchKeyword.WITHSCORES.getRaw());
136      }
137      if (_language != null) {
138        args.add(SearchKeyword.LANGUAGE.getRaw());
139        args.add(SafeEncoder.encode(_language));
140      }
141      if (_scorer != null) {
142        args.add(SearchKeyword.SCORER.getRaw());
143        args.add(SafeEncoder.encode(_scorer));
144      }
145      if (_fields != null && _fields.length > 0) {
146        args.add(SearchKeyword.INFIELDS.getRaw());
147        args.add(Protocol.toByteArray(_fields.length));
148        for (String f : _fields) {
149          args.add(SafeEncoder.encode(f));
150        }
151      }
152      if (_sortBy != null) {
153        args.add(SearchKeyword.SORTBY.getRaw());
154        args.add(SafeEncoder.encode(_sortBy));
155        args.add((_sortAsc ? SearchKeyword.ASC : SearchKeyword.DESC).getRaw());
156      }
157      if (_paging.offset != 0 || _paging.num != 10) {
158        args.add(SearchKeyword.LIMIT.getRaw()).add(Protocol.toByteArray(_paging.offset)).add(Protocol.toByteArray(_paging.num));
159      }
160      if (!_filters.isEmpty()) {
161        _filters.forEach(filter -> filter.addParams(args));
162      }
163      if (wantsHighlight) {
164        args.add(SearchKeyword.HIGHLIGHT.getRaw());
165        if (highlightFields != null) {
166          args.add(SearchKeyword.FIELDS.getRaw());
167          args.add(Protocol.toByteArray(highlightFields.length));
168          for (String s : highlightFields) {
169            args.add(SafeEncoder.encode(s));
170          }
171        }
172        if (highlightTags != null) {
173          args.add(SearchKeyword.TAGS.getRaw());
174          for (String t : highlightTags) {
175            args.add(SafeEncoder.encode(t));
176          }
177        }
178      }
179      if (wantsSummarize) {
180        args.add(SearchKeyword.SUMMARIZE.getRaw());
181        if (summarizeFields != null) {
182          args.add(SearchKeyword.FIELDS.getRaw());
183          args.add(Protocol.toByteArray(summarizeFields.length));
184          for (String s : summarizeFields) {
185            args.add(SafeEncoder.encode(s));
186          }
187        }
188        if (summarizeNumFragments != -1) {
189          args.add(SearchKeyword.FRAGS.getRaw());
190          args.add(Protocol.toByteArray(summarizeNumFragments));
191        }
192        if (summarizeFragmentLen != -1) {
193          args.add(SearchKeyword.LEN.getRaw());
194          args.add(Protocol.toByteArray(summarizeFragmentLen));
195        }
196        if (summarizeSeparator != null) {
197          args.add(SearchKeyword.SEPARATOR.getRaw());
198          args.add(SafeEncoder.encode(summarizeSeparator));
199        }
200      }
201      if (_keys != null && _keys.length > 0) {
202        args.add(SearchKeyword.INKEYS.getRaw());
203        args.add(Protocol.toByteArray(_keys.length));
204        for (String f : _keys) {
205          args.add(SafeEncoder.encode(f));
206        }
207      }
208      if (_returnFields != null && _returnFields.length > 0) {
209        args.add(SearchKeyword.RETURN.getRaw());
210        args.add(Protocol.toByteArray(_returnFields.length));
211        for (String f : _returnFields) {
212          args.add(SafeEncoder.encode(f));
213        }
214      } else if (returnFieldNames != null && returnFieldNames.length > 0) {
215        args.add(SearchKeyword.RETURN.getRaw());
216        LazyRawable returnCountObject = new LazyRawable();
217        args.add(returnCountObject); 
218        int returnCount = 0;
219        for (FieldName fn : returnFieldNames) {
220          returnCount += fn.addCommandArguments(args);
221        }
222        returnCountObject.setRaw(Protocol.toByteArray(returnCount));
223      }
224      if (_params != null && _params.size() > 0) {
225        args.add(SearchKeyword.PARAMS.getRaw());
226        args.add(_params.size() * 2);
227        for (Map.Entry<String, Object> entry : _params.entrySet()) {
228          args.add(entry.getKey());
229          args.add(entry.getValue());
230        }
231      }
232      if (_dialect != 0) {
233        args.add(SearchKeyword.DIALECT.getRaw());
234        args.add(_dialect);
235      }
236      if (_slop >= 0) {
237        args.add(SearchKeyword.SLOP.getRaw());
238        args.add(_slop);
239      }
240      if (_timeout >= 0) {
241        args.add(SearchKeyword.TIMEOUT.getRaw());
242        args.add(_timeout);
243      }
244      if (_inOrder) {
245        args.add(SearchKeyword.INORDER.getRaw());
246      }
247      if (_expander != null) {
248        args.add(SearchKeyword.EXPANDER.getRaw());
249        args.add(SafeEncoder.encode(_expander));
250      }
251    }
252    public Query limit(Integer offset, Integer limit) {
253      _paging.offset = offset;
254      _paging.num = limit;
255      return this;
256    }
257    public Query addFilter(Filter f) {
258      _filters.add(f);
259      return this;
260    }
261    public Query setVerbatim() {
262      this._verbatim = true;
263      return this;
264    }
265    public boolean getNoContent() {
266      return _noContent;
267    }
268    public Query setNoContent() {
269      this._noContent = true;
270      return this;
271    }
272    public Query setNoStopwords() {
273      this._noStopwords = true;
274      return this;
275    }
276    public boolean getWithScores() {
277      return _withScores;
278    }
279    public Query setWithScores() {
280      this._withScores = true;
281      return this;
282    }
283    public Query setLanguage(String language) {
284      this._language = language;
285      return this;
286    }
287    public Query setScorer(String scorer) {
288      this._scorer = scorer;
289      return this;
290    }
291    public Query limitFields(String... fields) {
292      this._fields = fields;
293      return this;
294    }
295    public Query limitKeys(String... keys) {
296      this._keys = keys;
297      return this;
298    }
299    public Query returnFields(String... fields) {
300      this._returnFields = fields;
301      this.returnFieldNames = null;
302      return this;
303    }
304    public Query returnFields(FieldName... fields) {
305      this.returnFieldNames = fields;
306      this._returnFields = null;
307      return this;
308    }
309    public Query highlightFields(HighlightTags tags, String... fields) {
310      if (fields == null || fields.length > 0) {
311        highlightFields = fields;
312      }
313      if (tags != null) {
314        highlightTags = new String[]{tags.open, tags.close};
315      } else {
316        highlightTags = null;
317      }
318      wantsHighlight = true;
319      return this;
320    }
321    public Query highlightFields(String... fields) {
322      return highlightFields(null, fields);
323    }
324    public Query summarizeFields(int contextLen, int fragmentCount, String separator, String... fields) {
325      if (fields == null || fields.length > 0) {
326        summarizeFields = fields;
327      }
328      summarizeFragmentLen = contextLen;
329      summarizeNumFragments = fragmentCount;
330      summarizeSeparator = separator;
331      wantsSummarize = true;
332      return this;
333    }
334    public Query summarizeFields(String... fields) {
335      return summarizeFields(-1, -1, null, fields);
336    }
337    public Query setSortBy(String field, boolean ascending) {
338      _sortBy = field;
339      _sortAsc = ascending;
340      return this;
341    }
342    public Query addParam(String name, Object value) {
343      if (_params == null) {
344        _params = new HashMap<>();
345      }
346      _params.put(name, value);
<span onclick='openModal()' class='match'>347      return this;
348    }
349    public Query dialect(int dialect) {
350      _dialect = dialect;
351      return this;
352    }
353    public Query slop(int slop) {
354      _slop = slop;
355      return this;
356    }
357    public Query timeout(long timeout) {
</span>358      _timeout = timeout;
359      return this;
360    }
361    public Query setInOrder() {
362      this._inOrder = true;
363      return this;
364    }
365    public Query setExpander(String field) {
366      _expander = field;
367      return this;
368    }
369  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-LoadBalancingHttpClient.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty.http;
2  import io.netty.buffer.ByteBufAllocator;
3  import io.netty.channel.ChannelOption;
4  import io.netty.handler.codec.http.HttpHeaders;
5  import io.netty.handler.codec.http.HttpMethod;
6  import io.reactivex.netty.client.ClientMetricsEvent;
7  import io.reactivex.netty.client.CompositePoolLimitDeterminationStrategy;
8  import io.reactivex.netty.client.RxClient;
9  import io.reactivex.netty.contexts.RxContexts;
10  import io.reactivex.netty.contexts.http.HttpRequestIdProvider;
11  import io.reactivex.netty.metrics.MetricEventsListener;
12  import io.reactivex.netty.pipeline.PipelineConfigurator;
13  import io.reactivex.netty.pipeline.ssl.DefaultFactories;
14  import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
15  import io.reactivex.netty.protocol.http.client.HttpClient;
16  import io.reactivex.netty.protocol.http.client.HttpClientBuilder;
17  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
18  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
19  import io.reactivex.netty.servo.http.HttpClientListener;
20  import java.net.URI;
21  import java.net.URISyntaxException;
22  import java.util.Collections;
23  import java.util.List;
24  import java.util.Map;
25  import java.util.Optional;
26  import java.util.concurrent.CopyOnWriteArrayList;
27  import java.util.concurrent.ScheduledExecutorService;
28  import java.util.concurrent.TimeUnit;
29  import java.util.concurrent.atomic.AtomicInteger;
30  import javax.net.ssl.SSLEngine;
31  import rx.Observable;
32  import rx.functions.Func1;
33  import rx.functions.Func2;
34  import com.google.common.annotations.VisibleForTesting;
35  import com.google.common.base.Preconditions;
36  import com.netflix.client.RequestSpecificRetryHandler;
37  import com.netflix.client.RetryHandler;
38  import com.netflix.client.config.CommonClientConfigKey;
39  import com.netflix.client.config.DefaultClientConfigImpl;
40  import com.netflix.client.config.IClientConfig;
41  import com.netflix.client.config.IClientConfigKey;
42  import com.netflix.client.ssl.ClientSslSocketFactoryException;
43  import com.netflix.loadbalancer.ILoadBalancer;
44  import com.netflix.loadbalancer.LoadBalancerBuilder;
45  import com.netflix.loadbalancer.Server;
46  import com.netflix.loadbalancer.ServerStats;
47  import com.netflix.loadbalancer.reactive.ExecutionContext;
48  import com.netflix.loadbalancer.reactive.ExecutionListener;
49  import com.netflix.loadbalancer.reactive.LoadBalancerCommand;
50  import com.netflix.loadbalancer.reactive.ServerOperation;
51  import com.netflix.ribbon.transport.netty.LoadBalancingRxClientWithPoolOptions;
52  public class LoadBalancingHttpClient<I, O> extends LoadBalancingRxClientWithPoolOptions<HttpClientRequest<I>, HttpClientResponse<O>, HttpClient<I, O>>
53          implements HttpClient<I, O> {
54      private static final HttpClientConfig DEFAULT_RX_CONFIG = HttpClientConfig.Builder.newDefaultConfig();
55      private final String requestIdHeaderName;
56      private final HttpRequestIdProvider requestIdProvider;
57      private final List<ExecutionListener<HttpClientRequest<I>, HttpClientResponse<O>>> listeners;
58      private final LoadBalancerCommand<HttpClientResponse<O>> defaultCommandBuilder;
59      private final Func2<HttpClientResponse<O>, Integer, Observable<HttpClientResponse<O>>> responseToErrorPolicy;
60      private final Func1<Integer, Integer> backoffStrategy;
61      public static class Builder<I, O> {
62          ILoadBalancer lb;
63          IClientConfig config;
64          RetryHandler retryHandler;
65          PipelineConfigurator<HttpClientResponse<O>, HttpClientRequest<I>> pipelineConfigurator;
66          ScheduledExecutorService poolCleanerScheduler;
67          List<ExecutionListener<HttpClientRequest<I>, HttpClientResponse<O>>> listeners;
68          Func2<HttpClientResponse<O>, Integer, Observable<HttpClientResponse<O>>> responseToErrorPolicy;
69          Func1<Integer, Integer> backoffStrategy;
70          Func1<Builder<I, O>, LoadBalancingHttpClient<I, O>> build;
71          protected Builder(Func1<Builder<I, O>, LoadBalancingHttpClient<I, O>> build) {
72              this.build = build;
73          }
74          public Builder<I, O> withLoadBalancer(ILoadBalancer lb) {
75              this.lb = lb;
76              return this;
77          }
78          public Builder<I, O> withClientConfig(IClientConfig config) {
79              this.config = config;
80              return this;
81          }
82          public Builder<I, O> withRetryHandler(RetryHandler retryHandler) {
83              this.retryHandler = retryHandler;
84              return this;
85          }
86          public Builder<I, O> withPipelineConfigurator(PipelineConfigurator<HttpClientResponse<O>, HttpClientRequest<I>> pipelineConfigurator) {
87              this.pipelineConfigurator = pipelineConfigurator;
88              return this;
89          }
90          public Builder<I, O> withPoolCleanerScheduler(ScheduledExecutorService poolCleanerScheduler) {
91              this.poolCleanerScheduler = poolCleanerScheduler;
92              return this;
93          }
94          public Builder<I, O> withExecutorListeners(List<ExecutionListener<HttpClientRequest<I>, HttpClientResponse<O>>> listeners) {
95              this.listeners = listeners;
<span onclick='openModal()' class='match'>96              return this;
97          }
98          public Builder<I, O> withResponseToErrorPolicy(Func2<HttpClientResponse<O>, Integer, Observable<HttpClientResponse<O>>> responseToErrorPolicy) {
99              this.responseToErrorPolicy = responseToErrorPolicy;
100              return this;
101          }
102          public Builder<I, O> withBackoffStrategy(Func1<Integer, Integer> backoffStrategy) {
103              this.backoffStrategy = backoffStrategy;
104              return this;
105          }
106          public LoadBalancingHttpClient<I, O> build() {
</span>107              if (retryHandler == null) {
108                  retryHandler = new NettyHttpLoadBalancerErrorHandler();
109              }
110              if (config == null) {
111                  config = DefaultClientConfigImpl.getClientConfigWithDefaultValues();
112              }
113              if (lb == null) {
114                  lb = LoadBalancerBuilder.newBuilder().withClientConfig(config).buildLoadBalancerFromConfigWithReflection();
115              }
116              if (listeners == null) {
117                  listeners = Collections.<ExecutionListener<HttpClientRequest<I>, HttpClientResponse<O>>>emptyList();
118              }
119              if (backoffStrategy == null) {
120                  backoffStrategy = new Func1<Integer, Integer>() {
121                      @Override
122                      public Integer call(Integer backoffCount) {
123                          int interval = config.getOrDefault(IClientConfigKey.Keys.BackoffInterval);
124                          if (backoffCount < 0) {
125                              backoffCount = 0;
126                          }
127                          else if (backoffCount > 10) {   
128                              backoffCount = 10;
129                          }
130                          return (int)Math.pow(2, backoffCount) * interval;
131                      }
132                  };
133              }
134              if (responseToErrorPolicy == null) {
135                  responseToErrorPolicy = new DefaultResponseToErrorPolicy<O>();
136              }
137              return build.call(this);
138          }
139      }
140      public static <I, O> Builder<I, O> builder() {
141          return new Builder<I, O>(new Func1<Builder<I, O>, LoadBalancingHttpClient<I, O>>() {
142              @Override
143              public LoadBalancingHttpClient<I, O> call(Builder<I, O> builder) {
144                  return new LoadBalancingHttpClient<I, O>(builder);
145              }
146          });
147      }
148      protected LoadBalancingHttpClient(Builder<I, O> builder) {
149          super(builder.lb, builder.config, new RequestSpecificRetryHandler(true, true, builder.retryHandler, null), builder.pipelineConfigurator, builder.poolCleanerScheduler);
150          requestIdHeaderName = getProperty(IClientConfigKey.Keys.RequestIdHeaderName, null, null);
151          requestIdProvider = (requestIdHeaderName != null) 
152                            ? new HttpRequestIdProvider(requestIdHeaderName, RxContexts.DEFAULT_CORRELATOR)
153                            : null;
154          this.listeners = new CopyOnWriteArrayList<ExecutionListener<HttpClientRequest<I>, HttpClientResponse<O>>>(builder.listeners);
155          defaultCommandBuilder = LoadBalancerCommand.<HttpClientResponse<O>>builder()
156                  .withLoadBalancerContext(lbContext)
157                  .withListeners(this.listeners)
158                  .withClientConfig(builder.config)
159                  .withRetryHandler(builder.retryHandler)
160                  .build();
161          this.responseToErrorPolicy = builder.responseToErrorPolicy;
162          this.backoffStrategy = builder.backoffStrategy;
163      }
164      private RetryHandler getRequestRetryHandler(HttpClientRequest<?> request, IClientConfig requestConfig) {
165          return new RequestSpecificRetryHandler(
166                  true, 
167                  request.getMethod().equals(HttpMethod.GET),     
168                  defaultRetryHandler, 
169                  requestConfig);
170      }
171      protected static void setHostHeader(HttpClientRequest<?> request, String host) {
172          request.getHeaders().set(HttpHeaders.Names.HOST, host);
173      }
174      @Override
175      public Observable<HttpClientResponse<O>> submit(HttpClientRequest<I> request) {
176          return submit(request, null, null);
177      }
178      @Override
179      public Observable<HttpClientResponse<O>> submit(final HttpClientRequest<I> request, final ClientConfig config) {
180          return submit(null, request, null, null, config);
181      }
182      public Observable<HttpClientResponse<O>> submit(Server server, final HttpClientRequest<I> request, final IClientConfig requestConfig) {
183          return submit(server, request, null, requestConfig, getRxClientConfig(requestConfig));
184      }
185      public Observable<HttpClientResponse<O>> submit(final HttpClientRequest<I> request, final RetryHandler errorHandler, final IClientConfig requestConfig) {
186          return submit(null, request, errorHandler, requestConfig, null);
187      }
188      public Observable<HttpClientResponse<O>> submit(Server server, final HttpClientRequest<I> request) {
189          return submit(server, request, null, null, getRxClientConfig(null));
190      }
191      protected ServerOperation<HttpClientResponse<O>> requestToOperation(final HttpClientRequest<I> request, final ClientConfig rxClientConfig) {
192          Preconditions.checkNotNull(request);
193          return new ServerOperation<HttpClientResponse<O>>() {
194              final AtomicInteger count = new AtomicInteger(0);
195              @Override
196              public Observable<HttpClientResponse<O>> call(Server server) {
197                  HttpClient<I,O> rxClient = getOrCreateRxClient(server);
198                  setHostHeader(request, server.getHost());
199                  Observable<HttpClientResponse<O>> o;
200                  if (rxClientConfig != null) {
201                      o = rxClient.submit(request, rxClientConfig);
202                  } 
203                  else {
204                      o = rxClient.submit(request);
205                  }
206                  return o.concatMap(new Func1<HttpClientResponse<O>, Observable<HttpClientResponse<O>>>() {
207                      @Override
208                      public Observable<HttpClientResponse<O>> call(HttpClientResponse<O> t1) {
209                          if (t1.getStatus().code()/100 == 4 || t1.getStatus().code()/100 == 5)
210                              return responseToErrorPolicy.call(t1, backoffStrategy.call(count.getAndIncrement()));
211                          else
212                              return Observable.just(t1);
213                      }
214                  });
215              }
216          };
217      }
218      private RxClient.ClientConfig getRxClientConfig(IClientConfig requestConfig) {
219          if (requestConfig == null) {
220              return DEFAULT_RX_CONFIG;
221          }
222          int requestReadTimeout = getProperty(IClientConfigKey.Keys.ReadTimeout, requestConfig, 
223                                               DefaultClientConfigImpl.DEFAULT_READ_TIMEOUT);
224          Boolean followRedirect = getProperty(IClientConfigKey.Keys.FollowRedirects, requestConfig, null);
225          HttpClientConfig.Builder builder = new HttpClientConfig.Builder().readTimeout(requestReadTimeout, TimeUnit.MILLISECONDS);
226          if (followRedirect != null) {
227              builder.setFollowRedirect(followRedirect);
228          }
229          return builder.build();        
230      }
231      private RxClient.ClientConfig getRxClientConfig(IClientConfig ribbonClientConfig, ClientConfig rxClientConfig) {
232          if (ribbonClientConfig == null) {
233              return rxClientConfig;
234          } 
235          else if (rxClientConfig == null) {
236              return getRxClientConfig(ribbonClientConfig);
237          }
238          int readTimeoutFormRibbon = ribbonClientConfig.get(CommonClientConfigKey.ReadTimeout, -1);
239          if (rxClientConfig instanceof HttpClientConfig) {
240              HttpClientConfig httpConfig = (HttpClientConfig) rxClientConfig;
241              HttpClientConfig.Builder builder = HttpClientConfig.Builder.from(httpConfig);
242              if (readTimeoutFormRibbon >= 0) {
243                  builder.readTimeout(readTimeoutFormRibbon, TimeUnit.MILLISECONDS);
244              }
245              return builder.build();
246          } 
247          else {
248              RxClient.ClientConfig.Builder builder = new RxClient.ClientConfig.Builder(rxClientConfig);
249              if (readTimeoutFormRibbon >= 0) {
250                  builder.readTimeout(readTimeoutFormRibbon, TimeUnit.MILLISECONDS);
251              }
252              return builder.build();
253          }
254      }
255      private IClientConfig getRibbonClientConfig(ClientConfig rxClientConfig) {
256          if (rxClientConfig != null && rxClientConfig.isReadTimeoutSet()) {
257              return IClientConfig.Builder.newBuilder().withReadTimeout((int) rxClientConfig.getReadTimeoutInMillis()).build();
258          }
259          return null;
260      }
261      private Observable<HttpClientResponse<O>> submit(final Server server, final HttpClientRequest<I> request, final RetryHandler errorHandler, final IClientConfig requestConfig, final ClientConfig rxClientConfig) {
262          RetryHandler retryHandler = errorHandler;
263          if (retryHandler == null) {
264              retryHandler = getRequestRetryHandler(request, requestConfig);
265          }
266          final IClientConfig config = requestConfig == null ? DefaultClientConfigImpl.getEmptyConfig() : requestConfig;
267          final ExecutionContext<HttpClientRequest<I>> context = new ExecutionContext<HttpClientRequest<I>>(request, config, this.getClientConfig(), retryHandler);
268          Observable<HttpClientResponse<O>> result = submitToServerInURI(request, config, rxClientConfig, retryHandler, context);
269          if (result == null) {
270              LoadBalancerCommand<HttpClientResponse<O>> command;
271              if (retryHandler != defaultRetryHandler) {
272                  command = LoadBalancerCommand.<HttpClientResponse<O>>builder()
273                          .withExecutionContext(context)
274                          .withLoadBalancerContext(lbContext)
275                          .withListeners(listeners)
276                          .withClientConfig(this.getClientConfig())
277                          .withRetryHandler(retryHandler)
278                          .withServer(server)
279                          .build();
280              }
281              else {
282                  command = defaultCommandBuilder;
283              }
284              result = command.submit(requestToOperation(request, getRxClientConfig(config, rxClientConfig)));
285          }
286          return result;
287      }
288      @VisibleForTesting
289      ServerStats getServerStats(Server server) {
290          return lbContext.getServerStats(server);
291      }
292      private Observable<HttpClientResponse<O>> submitToServerInURI(
293              HttpClientRequest<I> request, IClientConfig requestConfig, ClientConfig config,
294              RetryHandler errorHandler, ExecutionContext<HttpClientRequest<I>> context)  {
295          URI uri;
296          try {
297              uri = new URI(request.getUri());
298          } catch (URISyntaxException e) {
299              return Observable.error(e);
300          }
301          String host = uri.getHost();
302          if (host == null) {
303              return null;
304          }
305          int port = uri.getPort();
306          if (port < 0) {
307              if (clientConfig.get(IClientConfigKey.Keys.IsSecure, false)) {
308                  port = 443;
309              } else {
310                  port = 80;
311              }
312          }
313          return LoadBalancerCommand.<HttpClientResponse<O>>builder()
314                  .withRetryHandler(errorHandler)
315                  .withLoadBalancerContext(lbContext)
316                  .withListeners(listeners)
317                  .withExecutionContext(context)
318                  .withServer(new Server(host, port))
319                  .build()
320                  .submit(this.requestToOperation(request, getRxClientConfig(requestConfig, config)));
321      }
322      @Override
323      protected HttpClient<I, O> createRxClient(Server server) {
324          HttpClientBuilder<I, O> clientBuilder;
325          if (requestIdProvider != null) {
326              clientBuilder = RxContexts.<I, O>newHttpClientBuilder(server.getHost(), server.getPort(), 
327                      requestIdProvider, RxContexts.DEFAULT_CORRELATOR, pipelineConfigurator);
328          } else {
329              clientBuilder = RxContexts.<I, O>newHttpClientBuilder(server.getHost(), server.getPort(), 
330                      RxContexts.DEFAULT_CORRELATOR, pipelineConfigurator);
331          }
332          Integer connectTimeout = getProperty(IClientConfigKey.Keys.ConnectTimeout,  null, DefaultClientConfigImpl.DEFAULT_CONNECT_TIMEOUT);
333          Integer readTimeout    = getProperty(IClientConfigKey.Keys.ReadTimeout,     null, DefaultClientConfigImpl.DEFAULT_READ_TIMEOUT);
334          Boolean followRedirect = getProperty(IClientConfigKey.Keys.FollowRedirects, null, null);
335          HttpClientConfig.Builder builder = new HttpClientConfig.Builder().readTimeout(readTimeout, TimeUnit.MILLISECONDS);
336          if (followRedirect != null) {
337              builder.setFollowRedirect(followRedirect);
338          }
339          clientBuilder
340                  .channelOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout)
341                  .config(builder.build());
342          if (isPoolEnabled()) {
343              clientBuilder
344                  .withConnectionPoolLimitStrategy(poolStrategy)
345                  .withIdleConnectionsTimeoutMillis(idleConnectionEvictionMills)
346                  .withPoolIdleCleanupScheduler(poolCleanerScheduler);
347          } 
348          else {
349              clientBuilder
350                  .withNoConnectionPooling();
351          }
352          if (sslContextFactory != null) {
353              try {
354                  SSLEngineFactory myFactory = new DefaultFactories.SSLContextBasedFactory(sslContextFactory.getSSLContext()) {
355                      @Override
356                      public SSLEngine createSSLEngine(ByteBufAllocator allocator) {
357                          SSLEngine myEngine = super.createSSLEngine(allocator);
358                          myEngine.setUseClientMode(true);
359                          return myEngine;
360                      }
361                  };
362                  clientBuilder.withSslEngineFactory(myFactory);
363              } catch (ClientSslSocketFactoryException e) {
364                  throw new RuntimeException(e);
365              }
366          }
367          return clientBuilder.build();
368      }
369      @VisibleForTesting
370      HttpClientListener getListener() {
371          return (HttpClientListener) listener;
372      }
373      @VisibleForTesting
374      Map<Server, HttpClient<I, O>> getRxClients() {
375          return rxClientCache;
376      }
377      @Override
378      protected MetricEventsListener<? extends ClientMetricsEvent<?>> createListener(String name) {
379          return HttpClientListener.newHttpListener(name);
380      }
381  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Query.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-LoadBalancingHttpClient.java</div>
                </div>
                <div class="column column_space"><pre><code>347      return this;
348    }
349    public Query dialect(int dialect) {
350      _dialect = dialect;
351      return this;
352    }
353    public Query slop(int slop) {
354      _slop = slop;
355      return this;
356    }
357    public Query timeout(long timeout) {
</pre></code></div>
                <div class="column column_space"><pre><code>96              return this;
97          }
98          public Builder<I, O> withResponseToErrorPolicy(Func2<HttpClientResponse<O>, Integer, Observable<HttpClientResponse<O>>> responseToErrorPolicy) {
99              this.responseToErrorPolicy = responseToErrorPolicy;
100              return this;
101          }
102          public Builder<I, O> withBackoffStrategy(Func1<Integer, Integer> backoffStrategy) {
103              this.backoffStrategy = backoffStrategy;
104              return this;
105          }
106          public LoadBalancingHttpClient<I, O> build() {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    