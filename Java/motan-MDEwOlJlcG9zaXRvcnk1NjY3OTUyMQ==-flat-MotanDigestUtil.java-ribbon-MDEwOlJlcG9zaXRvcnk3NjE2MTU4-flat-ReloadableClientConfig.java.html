
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.511627906976744%, Tokens: 10</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MotanDigestUtil.java</h3>
            <pre><code>1  package com.weibo.api.motan.util;
2  import java.io.UnsupportedEncodingException;
3  import java.security.MessageDigest;
4  import java.security.NoSuchAlgorithmException;
5  import java.util.zip.CRC32;
6  import org.slf4j.Logger;
7  import org.slf4j.LoggerFactory;
8  import com.weibo.api.motan.common.MotanConstants;
9  public class MotanDigestUtil {
10      private static Logger log = LoggerFactory.getLogger(MotanDigestUtil.class);
11      private static ThreadLocal<CRC32> crc32Provider = new ThreadLocal<CRC32>() {
12          @Override
13          protected CRC32 initialValue() {
14              return new CRC32();
15          }
16      };
17      public static long getCrc32(String str) {
<span onclick='openModal()' class='match'>18          try {
19              return getCrc32(str.getBytes(MotanConstants.DEFAULT_CHARACTER));
20          } catch (UnsupportedEncodingException e) {
21              log.warn(String.format("Error: getCrc32, str=%s", str), e);
22              return -1;
23          }
</span>24      }
25      public static long getCrc32(byte[] b) {
26          CRC32 crc = crc32Provider.get();
27          crc.reset();
28          crc.update(b);
29          return crc.getValue();
30      }
31      public static String md5LowerCase(String plainText) {
32          try {
33              MessageDigest md = MessageDigest.getInstance("MD5");
34              md.update(plainText.getBytes());
35              byte b[] = md.digest();
36              int i;
37              StringBuilder buf = new StringBuilder("");
38              for (byte element : b) {
39                  i = element;
40                  if (i < 0) {
41                      i += 256;
42                  }
43                  if (i < 16) {
44                      buf.append("0");
45                  }
46                  buf.append(Integer.toHexString(i));
47              }
48              return buf.toString();
49          } catch (NoSuchAlgorithmException e) {
50              log.error("md5 digest error!", e);
51          }
52          return null;
53      }
54  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ReloadableClientConfig.java</h3>
            <pre><code>1  package com.netflix.client.config;
2  import com.google.common.base.Preconditions;
3  import org.apache.commons.lang.StringUtils;
4  import org.slf4j.Logger;
5  import org.slf4j.LoggerFactory;
6  import java.lang.reflect.Method;
7  import java.util.HashMap;
8  import java.util.List;
9  import java.util.Map;
10  import java.util.Optional;
11  import java.util.concurrent.ConcurrentHashMap;
12  import java.util.concurrent.CopyOnWriteArrayList;
13  import java.util.concurrent.TimeUnit;
14  import java.util.concurrent.atomic.AtomicLong;
15  import java.util.concurrent.atomic.AtomicReference;
16  import java.util.function.BiConsumer;
17  import java.util.function.Consumer;
18  import java.util.function.Supplier;
19  import java.util.stream.Collectors;
20  public abstract class ReloadableClientConfig implements IClientConfig {
21      private static final Logger LOG = LoggerFactory.getLogger(ReloadableClientConfig.class);
22      private static final String DEFAULT_CLIENT_NAME = "";
23      private static final String DEFAULT_NAMESPACE = "ribbon";
24      private final Map<IClientConfigKey, Optional<?>> internalProperties = new ConcurrentHashMap<>();
25      private final Map<IClientConfigKey, ReloadableProperty<?>> dynamicProperties = new ConcurrentHashMap<>();
26      private final Map<IClientConfigKey, Runnable> changeActions = new ConcurrentHashMap<>();
27      private final AtomicLong refreshCounter = new AtomicLong();
28      private final PropertyResolver resolver;
29      private String clientName = DEFAULT_CLIENT_NAME;
30      private String namespace = DEFAULT_NAMESPACE;
31      private boolean isDynamic = false;
32      protected ReloadableClientConfig(PropertyResolver resolver) {
33          this.resolver = resolver;
34      }
35      protected PropertyResolver getPropertyResolver() {
36          return this.resolver;
37      }
38      public final void reload() {
39          changeActions.values().forEach(Runnable::run);
40          dynamicProperties.values().forEach(ReloadableProperty::reload);
41          cachedToString = null;
42      }
43      @Deprecated
44      public void setClientName(String clientName){
45          this.clientName  = clientName;
46      }
47      @Override
48      public final String getClientName() {
49          return clientName;
50      }
51      @Override
52      public String getNameSpace() {
53          return namespace;
54      }
55      @Override
56      public final void setNameSpace(String nameSpace) {
57          this.namespace = nameSpace;
58      }
59      @Override
60      public void loadProperties(String clientName) {
61          LOG.info("[{}] loading config", clientName);
62          this.clientName = clientName;
63          this.isDynamic = true;
64          loadDefaultValues();
65          resolver.onChange(this::reload);
66          internalProperties.forEach((key, value) -> LOG.info("[{}] {}={}", clientName, key, value.orElse(null)));
67      }
68      @Override
69      @Deprecated
70      public final Map<String, Object> getProperties() {
71          final Map<String, Object> result = new HashMap<>(internalProperties.size());
72          forEach((key, value) -> result.put(key.key(), String.valueOf(value)));
73          return result;
74      }
75      @Override
76      public void forEach(BiConsumer<IClientConfigKey<?>, Object> consumer) {
77          internalProperties.forEach((key, value) -> {
78              if (value.isPresent()) {
79                  consumer.accept(key, value.get());
80              }
81          });
82      }
83      private <T> void autoRefreshFromPropertyResolver(final IClientConfigKey<T> key) {
84          changeActions.computeIfAbsent(key, ignore -> {
85              final Supplier<Optional<T>> valueSupplier = () -> resolveFromPropertyResolver(key);
86              final Optional<T> current = valueSupplier.get();
87              if (current.isPresent()) {
88                  internalProperties.put(key, current);
89              }
90              final AtomicReference<Optional<T>> previous = new AtomicReference<>(current);
91              return () -> {
92                  final Optional<T> next = valueSupplier.get();
93                  if (!next.equals(previous.get())) {
94                      LOG.info("[{}] new value for {}: {} -> {}", clientName, key.key(), previous.get(), next);
95                      previous.set(next); 
96                      internalProperties.put(key, next);
97                  }
98              };
99          });
100      }
101      interface ReloadableProperty<T> extends Property<T> {
102          void reload();
103      }
104      private synchronized <T> Property<T> getOrCreateProperty(final IClientConfigKey<T> key, final Supplier<Optional<T>> valueSupplier, final Supplier<T> defaultSupplier) {
105          Preconditions.checkNotNull(valueSupplier, "defaultValueSupplier cannot be null");
106          return (Property<T>)dynamicProperties.computeIfAbsent(key, ignore -> new ReloadableProperty<T>() {
107                  private volatile Optional<T> current = Optional.empty();
108                  private List<Consumer<T>> consumers = new CopyOnWriteArrayList<>();
109                  {
110                      reload();
111                  }
112                  @Override
113                  public void onChange(Consumer<T> consumer) {
114                      consumers.add(consumer);
115                  }
116                  @Override
117                  public Optional<T> get() {
118                      return current;
119                  }
120                  @Override
121                  public T getOrDefault() {
122                      return current.orElse(defaultSupplier.get());
123                  }
124                  @Override
125                  public void reload() {
126                      refreshCounter.incrementAndGet();
127                      Optional<T> next = valueSupplier.get();
128                      if (!next.equals(current)) {
129                          current = next;
130                          consumers.forEach(consumer -> consumer.accept(next.orElseGet(defaultSupplier::get)));
131                      }
132                  }
133                  @Override
134                  public String toString() {
135                      return String.valueOf(get());
136                  }
137              });
138      }
139      @Override
140      public final <T> T get(IClientConfigKey<T> key) {
141          Optional<T> value = (Optional<T>)internalProperties.get(key);
142          if (value == null) {
143              if (!isDynamic) {
144                  return null;
145              } else {
146                  set(key, null);
147                  value = (Optional<T>) internalProperties.get(key);
148              }
149          }
150          return value.orElse(null);
151      }
152      @Override
153      public final <T> Property<T> getGlobalProperty(IClientConfigKey<T> key) {
154          LOG.debug("[{}] get global property '{}' with default '{}'", clientName, key.key(), key.defaultValue());
155          return getOrCreateProperty(
156                  key,
157                  () -> resolver.get(key.key(), key.type()),
158                  key::defaultValue);
159      }
160      @Override
161      public final <T> Property<T> getDynamicProperty(IClientConfigKey<T> key) {
162          LOG.debug("[{}] get dynamic property key={} ns={}", clientName, key.key(), getNameSpace());
163          get(key);
164          return getOrCreateProperty(
165                  key,
166                  () -> (Optional<T>)internalProperties.getOrDefault(key, Optional.empty()),
167                  key::defaultValue);
168      }
169      @Override
170      public <T> Property<T> getPrefixMappedProperty(IClientConfigKey<T> key) {
171          LOG.debug("[{}] get dynamic property key={} ns={} client={}", clientName, key.key(), getNameSpace());
172          return getOrCreateProperty(
173                  key,
174                  getPrefixedMapPropertySupplier(key),
175                  key::defaultValue);
176      }
177      private <T> Optional<T> resolveFromPropertyResolver(IClientConfigKey<T> key) {
178          Optional<T> value;
179          if (!StringUtils.isEmpty(clientName)) {
180              value = resolver.get(clientName + "." + getNameSpace() + "." + key.key(), key.type());
181              if (value.isPresent()) {
182                  return value;
183              }
184          }
185          return resolver.get(getNameSpace() + "." + key.key(), key.type());
186      }
187      @Override
188      public <T> Optional<T> getIfSet(IClientConfigKey<T> key) {
189          return (Optional<T>)internalProperties.getOrDefault(key, Optional.empty());
190      }
191      private <T> T resolveValueToType(IClientConfigKey<T> key, Object value) {
192          if (value == null) {
193              return null;
194          }
195          final Class<T> type = key.type();
196          if (!value.getClass().equals(type)) {
197              try {
198                  if (type.equals(String.class)) {
199                      return (T) value.toString();
200                  } else if (value.getClass().equals(String.class)) {
201                      final String strValue = (String) value;
202                      if (Integer.class.equals(type)) {
203                          return (T) Integer.valueOf(strValue);
204                      } else if (Boolean.class.equals(type)) {
205                          return (T) Boolean.valueOf(strValue);
206                      } else if (Float.class.equals(type)) {
207                          return (T) Float.valueOf(strValue);
208                      } else if (Long.class.equals(type)) {
209                          return (T) Long.valueOf(strValue);
210                      } else if (Double.class.equals(type)) {
211                          return (T) Double.valueOf(strValue);
212                      } else if (TimeUnit.class.equals(type)) {
213                          return (T) TimeUnit.valueOf(strValue);
214                      } else {
215                          return PropertyUtils.resolveWithValueOf(type, strValue)
216                                  .orElseThrow(() -> new IllegalArgumentException("Unsupported value type `" + type + "'"));
217                      }
218                  } else {
219                      return PropertyUtils.resolveWithValueOf(type, value.toString())
220                              .orElseThrow(() -> new IllegalArgumentException("Incompatible value type `" + value.getClass() + "` while expecting '" + type + "`"));
221                  }
222              } catch (Exception e) {
223                  throw new IllegalArgumentException("Error parsing value '" + value + "' for '" + key.key() + "'", e);
224              }
225          } else {
226              return (T)value;
227          }
228      }
229      private <T> Supplier<Optional<T>> getPrefixedMapPropertySupplier(IClientConfigKey<T> key) {
230          final Method method;
231          try {
232              method = key.type().getDeclaredMethod("valueOf", Map.class);
233          } catch (NoSuchMethodException e) {
234              throw new UnsupportedOperationException("Class '" + key.type().getName() + "' must have static method valueOf(Map<String, String>)", e);
235          }
236          return () -> {
237              final Map<String, String> values = new HashMap<>();
238              resolver.forEach(getNameSpace() + "." + key.key(), values::put);
239              if (!StringUtils.isEmpty(clientName)) {
240                  resolver.forEach(clientName + "." + getNameSpace() + "." + key.key(), values::put);
241              }
<span onclick='openModal()' class='match'>242              try {
243                  return Optional.ofNullable((T)method.invoke(null, values));
244              } catch (Exception e) {
245                  LOG.warn("Unable to map value for '{}'", key.key(), e);
246                  return Optional.empty();
247              }
</span>248          };
249      }
250      @Override
251      public final <T> T get(IClientConfigKey<T> key, T defaultValue) {
252          return Optional.ofNullable(get(key)).orElse(defaultValue);
253      }
254      protected final <T> void setDefault(IClientConfigKey<T> key) {
255          setDefault(key, key.defaultValue());
256      }
257      protected final <T> void setDefault(IClientConfigKey<T> key, T value) {
258          Preconditions.checkArgument(key != null, "key cannot be null");
259          value = resolveFromPropertyResolver(key).orElse(value);
260          internalProperties.put(key, Optional.ofNullable(value));
261          if (isDynamic) {
262              autoRefreshFromPropertyResolver(key);
263          }
264          cachedToString = null;
265      }
266      @Override
267      public <T> IClientConfig set(IClientConfigKey<T> key, T value) {
268          Preconditions.checkArgument(key != null, "key cannot be null");
269          value = resolveValueToType(key, value);
270          if (isDynamic) {
271              internalProperties.put(key, Optional.ofNullable(resolveFromPropertyResolver(key).orElse(value)));
272              autoRefreshFromPropertyResolver(key);
273          } else {
274              internalProperties.put(key, Optional.ofNullable(value));
275          }
276          cachedToString = null;
277          return this;
278      }
279      @Override
280      @Deprecated
281      public void setProperty(IClientConfigKey key, Object value) {
282          Preconditions.checkArgument(value != null, "Value may not be null");
283          set(key, value);
284      }
285      @Override
286      @Deprecated
287      public Object getProperty(IClientConfigKey key) {
288          return get(key);
289      }
290      @Override
291      @Deprecated
292      public Object getProperty(IClientConfigKey key, Object defaultVal) {
293          return Optional.ofNullable(get(key)).orElse(defaultVal);
294      }
295      @Override
296      @Deprecated
297      public boolean containsProperty(IClientConfigKey key) {
298          return internalProperties.containsKey(key);
299      }
300      @Override
301      @Deprecated
302      public int getPropertyAsInteger(IClientConfigKey key, int defaultValue) {
303          return Optional.ofNullable(getProperty(key)).map(Integer.class::cast).orElse(defaultValue);
304      }
305      @Override
306      @Deprecated
307      public String getPropertyAsString(IClientConfigKey key, String defaultValue) {
308          return Optional.ofNullable(getProperty(key)).map(Object::toString).orElse(defaultValue);
309      }
310      @Override
311      @Deprecated
312      public boolean getPropertyAsBoolean(IClientConfigKey key, boolean defaultValue) {
313          return Optional.ofNullable(getProperty(key)).map(Boolean.class::cast).orElse(defaultValue);
314      }
315      public IClientConfig applyOverride(IClientConfig override) {
316          if (override == null) {
317              return this;
318          }
319          override.forEach((key, value) -> setProperty(key, value));
320          return this;
321      }
322      private volatile String cachedToString = null;
323      @Override
324      public String toString() {
325          if (cachedToString == null) {
326              String newToString = generateToString();
327              cachedToString = newToString;
328              return newToString;
329          }
330          return cachedToString;
331      }
332      public long getRefreshCount() {
333          return refreshCounter.get();
334      }
335      private String generateToString() {
336          return "ClientConfig:" + internalProperties.entrySet().stream()
337                      .map(t -> {
338                          if (t.getKey().key().endsWith("Password") && t.getValue().isPresent()) {
339                              return t.getKey() + ":***";
340                          }
341                          return t.getKey() + ":" + t.getValue().orElse(null);
342                      })
343                  .collect(Collectors.joining(", "));
344      }
345  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MotanDigestUtil.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ReloadableClientConfig.java</div>
                </div>
                <div class="column column_space"><pre><code>18          try {
19              return getCrc32(str.getBytes(MotanConstants.DEFAULT_CHARACTER));
20          } catch (UnsupportedEncodingException e) {
21              log.warn(String.format("Error: getCrc32, str=%s", str), e);
22              return -1;
23          }
</pre></code></div>
                <div class="column column_space"><pre><code>242              try {
243                  return Optional.ofNullable((T)method.invoke(null, values));
244              } catch (Exception e) {
245                  LOG.warn("Unable to map value for '{}'", key.key(), e);
246                  return Optional.empty();
247              }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    