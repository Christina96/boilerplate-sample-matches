<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for AppGlideModuleWithLibraryInPackageTest.java & MultiModelLoaderFactory.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for AppGlideModuleWithLibraryInPackageTest.java & MultiModelLoaderFactory.java
      </h3>
      <h1 align="center">
        6.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>AppGlideModuleWithLibraryInPackageTest.java (13.445378%)<TH>MultiModelLoaderFactory.java (4.0920715%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match65440-0.html#0',2,'match65440-1.html#0',3)" NAME="0">(7-28)<TD><A HREF="javascript:ZweiFrames('match65440-0.html#0',2,'match65440-1.html#0',3)" NAME="0">(3-24)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AppGlideModuleWithLibraryInPackageTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
package com.bumptech.glide.annotation.compiler;

import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
<A NAME="0"></A>import static com.bumptech.glide.annotation.compiler.test.Util.glide;
import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
import static com.google.testing.compile.CompilationSubject.assertThat;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match65440-1.html#0',3,'match65440-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.testing.compile.Compiler.javac;

import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
import com.bumptech.glide.annotation.compiler.test.Util;
import com.google.testing.compile.Compilation;
import java.io.IOException;
import javax.tools.JavaFileObject;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class in a
 * strangely named subpackage.
 */
@RunWith(JUnit4.class)
public class AppGlideModuleWithLibraryInPackageTest implements CompilationProvider {
  @Rule</B></FONT>
  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);

  private Compilation compilation;

  @Before
  public void setUp() {
    compilation =
        javac()
            .withProcessors(new GlideAnnotationProcessor())
            .compile(
                forResource(&quot;AppModuleWithLibraryInPackage.java&quot;),
                forResource(&quot;LibraryModuleInPackage.java&quot;));
    assertThat(compilation).succeededWithoutWarnings();
  }

  @Override
  public Compilation getCompilation() {
    return compilation;
  }

  @Test
  @ReferencedResource
  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
    assertThat(compilation)
        .generatedSourceFile(subpackage(&quot;GlideOptions&quot;))
        .hasSourceEquivalentTo(appResource(&quot;GlideOptions.java&quot;));
  }

  @Test
  @ReferencedResource
  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
    assertThat(compilation)
        .generatedSourceFile(subpackage(&quot;GlideRequest&quot;))
        .hasSourceEquivalentTo(appResource(&quot;GlideRequest.java&quot;));
  }

  @Test
  @ReferencedResource
  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
    assertThat(compilation)
        .generatedSourceFile(subpackage(&quot;GlideRequests&quot;))
        .hasSourceEquivalentTo(appResource(&quot;GlideRequests.java&quot;));
  }

  @Test
  @ReferencedResource
  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
    assertThat(compilation)
        .generatedSourceFile(subpackage(&quot;GlideApp&quot;))
        .hasSourceEquivalentTo(appResource(&quot;GlideApp.java&quot;));
  }

  @Test
  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
    assertThat(compilation)
        .generatedSourceFile(glide(&quot;GeneratedAppGlideModuleImpl&quot;))
        .hasSourceEquivalentTo(forResource(&quot;GeneratedAppGlideModuleImpl.java&quot;));
  }

  @Test
  @ReferencedResource
  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
    assertThat(compilation)
        .generatedSourceFile(glide(&quot;GeneratedRequestManagerFactory&quot;))
        .hasSourceEquivalentTo(appResource(&quot;GeneratedRequestManagerFactory.java&quot;));
  }

  private JavaFileObject forResource(String name) {
    return Util.forResource(getClass().getSimpleName(), name);
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MultiModelLoaderFactory.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A>package com.bumptech.glide.load.model;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match65440-0.html#0',2,'match65440-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;
import androidx.core.util.Pools.Pool;
import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
import com.bumptech.glide.load.Options;
import com.bumptech.glide.util.Preconditions;
import com.bumptech.glide.util.Synthetic;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

/**
 * Capable of building an {@link ModelLoader} that wraps one or more other {@link ModelLoader}s for
 * a given model and data class.
 */
// Hides Model throughout.
@SuppressWarnings(&quot;TypeParameterHidesVisibleType&quot;)
public class MultiModelLoaderFactory {
  private static final Factory DEFAULT_FACTORY = new Factory()</B></FONT>;
  private static final ModelLoader&lt;Object, Object&gt; EMPTY_MODEL_LOADER = new EmptyModelLoader();
  private final List&lt;Entry&lt;?, ?&gt;&gt; entries = new ArrayList&lt;&gt;();
  private final Factory factory;
  private final Set&lt;Entry&lt;?, ?&gt;&gt; alreadyUsedEntries = new HashSet&lt;&gt;();
  private final Pool&lt;List&lt;Throwable&gt;&gt; throwableListPool;

  public MultiModelLoaderFactory(@NonNull Pool&lt;List&lt;Throwable&gt;&gt; throwableListPool) {
    this(throwableListPool, DEFAULT_FACTORY);
  }

  @VisibleForTesting
  MultiModelLoaderFactory(
      @NonNull Pool&lt;List&lt;Throwable&gt;&gt; throwableListPool, @NonNull Factory factory) {
    this.throwableListPool = throwableListPool;
    this.factory = factory;
  }

  synchronized &lt;Model, Data&gt; void append(
      @NonNull Class&lt;Model&gt; modelClass,
      @NonNull Class&lt;Data&gt; dataClass,
      @NonNull ModelLoaderFactory&lt;? extends Model, ? extends Data&gt; factory) {
    add(modelClass, dataClass, factory, /*append=*/ true);
  }

  synchronized &lt;Model, Data&gt; void prepend(
      @NonNull Class&lt;Model&gt; modelClass,
      @NonNull Class&lt;Data&gt; dataClass,
      @NonNull ModelLoaderFactory&lt;? extends Model, ? extends Data&gt; factory) {
    add(modelClass, dataClass, factory, /*append=*/ false);
  }

  private &lt;Model, Data&gt; void add(
      @NonNull Class&lt;Model&gt; modelClass,
      @NonNull Class&lt;Data&gt; dataClass,
      @NonNull ModelLoaderFactory&lt;? extends Model, ? extends Data&gt; factory,
      boolean append) {
    Entry&lt;Model, Data&gt; entry = new Entry&lt;&gt;(modelClass, dataClass, factory);
    entries.add(append ? entries.size() : 0, entry);
  }

  @NonNull
  synchronized &lt;Model, Data&gt; List&lt;ModelLoaderFactory&lt;? extends Model, ? extends Data&gt;&gt; replace(
      @NonNull Class&lt;Model&gt; modelClass,
      @NonNull Class&lt;Data&gt; dataClass,
      @NonNull ModelLoaderFactory&lt;? extends Model, ? extends Data&gt; factory) {
    List&lt;ModelLoaderFactory&lt;? extends Model, ? extends Data&gt;&gt; removed =
        remove(modelClass, dataClass);
    append(modelClass, dataClass, factory);
    return removed;
  }

  @NonNull
  synchronized &lt;Model, Data&gt; List&lt;ModelLoaderFactory&lt;? extends Model, ? extends Data&gt;&gt; remove(
      @NonNull Class&lt;Model&gt; modelClass, @NonNull Class&lt;Data&gt; dataClass) {
    List&lt;ModelLoaderFactory&lt;? extends Model, ? extends Data&gt;&gt; factories = new ArrayList&lt;&gt;();
    for (Iterator&lt;Entry&lt;?, ?&gt;&gt; iterator = entries.iterator(); iterator.hasNext(); ) {
      Entry&lt;?, ?&gt; entry = iterator.next();
      if (entry.handles(modelClass, dataClass)) {
        iterator.remove();
        factories.add(this.&lt;Model, Data&gt;getFactory(entry));
      }
    }
    return factories;
  }

  @NonNull
  synchronized &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; build(@NonNull Class&lt;Model&gt; modelClass) {
    try {
      List&lt;ModelLoader&lt;Model, ?&gt;&gt; loaders = new ArrayList&lt;&gt;();
      for (Entry&lt;?, ?&gt; entry : entries) {
        // Avoid stack overflow recursively creating model loaders by only creating loaders in
        // recursive requests if they haven't been created earlier in the chain. For example:
        // A Uri loader may translate to another model, which in turn may translate back to a Uri.
        // The original Uri loader won't be provided to the intermediate model loader, although
        // other Uri loaders will be.
        if (alreadyUsedEntries.contains(entry)) {
          continue;
        }
        if (entry.handles(modelClass)) {
          alreadyUsedEntries.add(entry);
          loaders.add(this.&lt;Model, Object&gt;build(entry));
          alreadyUsedEntries.remove(entry);
        }
      }
      return loaders;
    } catch (Throwable t) {
      alreadyUsedEntries.clear();
      throw t;
    }
  }

  @NonNull
  synchronized List&lt;Class&lt;?&gt;&gt; getDataClasses(@NonNull Class&lt;?&gt; modelClass) {
    List&lt;Class&lt;?&gt;&gt; result = new ArrayList&lt;&gt;();
    for (Entry&lt;?, ?&gt; entry : entries) {
      if (!result.contains(entry.dataClass) &amp;&amp; entry.handles(modelClass)) {
        result.add(entry.dataClass);
      }
    }
    return result;
  }

  @NonNull
  public synchronized &lt;Model, Data&gt; ModelLoader&lt;Model, Data&gt; build(
      @NonNull Class&lt;Model&gt; modelClass, @NonNull Class&lt;Data&gt; dataClass) {
    try {
      List&lt;ModelLoader&lt;Model, Data&gt;&gt; loaders = new ArrayList&lt;&gt;();
      boolean ignoredAnyEntries = false;
      for (Entry&lt;?, ?&gt; entry : entries) {
        // Avoid stack overflow recursively creating model loaders by only creating loaders in
        // recursive requests if they haven't been created earlier in the chain. For example:
        // A Uri loader may translate to another model, which in turn may translate back to a Uri.
        // The original Uri loader won't be provided to the intermediate model loader, although
        // other Uri loaders will be.
        if (alreadyUsedEntries.contains(entry)) {
          ignoredAnyEntries = true;
          continue;
        }
        if (entry.handles(modelClass, dataClass)) {
          alreadyUsedEntries.add(entry);
          loaders.add(this.&lt;Model, Data&gt;build(entry));
          alreadyUsedEntries.remove(entry);
        }
      }
      if (loaders.size() &gt; 1) {
        return factory.build(loaders, throwableListPool);
      } else if (loaders.size() == 1) {
        return loaders.get(0);
      } else {
        // Avoid crashing if recursion results in no loaders available. The assertion is supposed to
        // catch completely unhandled types, recursion may mean a subtype isn't handled somewhere
        // down the stack, which is often ok.
        if (ignoredAnyEntries) {
          return emptyModelLoader();
        } else {
          throw new NoModelLoaderAvailableException(modelClass, dataClass);
        }
      }
    } catch (Throwable t) {
      alreadyUsedEntries.clear();
      throw t;
    }
  }

  @NonNull
  @SuppressWarnings(&quot;unchecked&quot;)
  private &lt;Model, Data&gt; ModelLoaderFactory&lt;Model, Data&gt; getFactory(@NonNull Entry&lt;?, ?&gt; entry) {
    return (ModelLoaderFactory&lt;Model, Data&gt;) entry.factory;
  }

  @NonNull
  @SuppressWarnings(&quot;unchecked&quot;)
  private &lt;Model, Data&gt; ModelLoader&lt;Model, Data&gt; build(@NonNull Entry&lt;?, ?&gt; entry) {
    return (ModelLoader&lt;Model, Data&gt;) Preconditions.checkNotNull(entry.factory.build(this));
  }

  @NonNull
  @SuppressWarnings(&quot;unchecked&quot;)
  private static &lt;Model, Data&gt; ModelLoader&lt;Model, Data&gt; emptyModelLoader() {
    return (ModelLoader&lt;Model, Data&gt;) EMPTY_MODEL_LOADER;
  }

  private static class Entry&lt;Model, Data&gt; {
    private final Class&lt;Model&gt; modelClass;
    @Synthetic final Class&lt;Data&gt; dataClass;
    @Synthetic final ModelLoaderFactory&lt;? extends Model, ? extends Data&gt; factory;

    public Entry(
        @NonNull Class&lt;Model&gt; modelClass,
        @NonNull Class&lt;Data&gt; dataClass,
        @NonNull ModelLoaderFactory&lt;? extends Model, ? extends Data&gt; factory) {
      this.modelClass = modelClass;
      this.dataClass = dataClass;
      this.factory = factory;
    }

    public boolean handles(@NonNull Class&lt;?&gt; modelClass, @NonNull Class&lt;?&gt; dataClass) {
      return handles(modelClass) &amp;&amp; this.dataClass.isAssignableFrom(dataClass);
    }

    public boolean handles(@NonNull Class&lt;?&gt; modelClass) {
      return this.modelClass.isAssignableFrom(modelClass);
    }
  }

  static class Factory {
    @NonNull
    public &lt;Model, Data&gt; MultiModelLoader&lt;Model, Data&gt; build(
        @NonNull List&lt;ModelLoader&lt;Model, Data&gt;&gt; modelLoaders,
        @NonNull Pool&lt;List&lt;Throwable&gt;&gt; throwableListPool) {
      return new MultiModelLoader&lt;&gt;(modelLoaders, throwableListPool);
    }
  }

  private static class EmptyModelLoader implements ModelLoader&lt;Object, Object&gt; {
    @Synthetic
    EmptyModelLoader() {}

    @Nullable
    @Override
    public LoadData&lt;Object&gt; buildLoadData(
        @NonNull Object o, int width, int height, @NonNull Options options) {
      return null;
    }

    @Override
    public boolean handles(@NonNull Object o) {
      return false;
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
