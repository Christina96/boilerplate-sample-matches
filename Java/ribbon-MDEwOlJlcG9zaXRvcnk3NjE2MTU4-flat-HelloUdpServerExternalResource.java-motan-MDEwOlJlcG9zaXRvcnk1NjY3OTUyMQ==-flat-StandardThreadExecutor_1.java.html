
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.434944237918216%, Tokens: 10</h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-HelloUdpServerExternalResource.java</h3>
            <pre><code>1  package com.netflix.client.netty.udp;
2  import io.netty.buffer.ByteBuf;
3  import io.netty.channel.socket.DatagramPacket;
4  import io.reactivex.netty.RxNetty;
5  import io.reactivex.netty.channel.ConnectionHandler;
6  import io.reactivex.netty.channel.ObservableConnection;
7  import io.reactivex.netty.protocol.udp.server.UdpServer;
8  import java.net.DatagramSocket;
9  import java.net.InetSocketAddress;
<span onclick='openModal()' class='match'>10  import java.net.SocketException;
11  import java.nio.charset.Charset;
12  import java.util.concurrent.TimeUnit;
13  import org.junit.rules.ExternalResource;
14  import org.slf4j.Logger;
15  import org.slf4j.LoggerFactory;
16  import rx.Observable;
17  import rx.functions.Func1;
18  public class HelloUdpServerExternalResource extends ExternalResource {
19      private static final Logger LOG = LoggerFactory.getLogger(HelloUdpServerExternalResource.class);
</span>20      static final String WELCOME_MSG = "Welcome to the broadcast world!";
21      static final byte[] WELCOME_MSG_BYTES = WELCOME_MSG.getBytes(Charset.defaultCharset());
22      private UdpServer<DatagramPacket, DatagramPacket> server;
23      private int timeout = 0;
24      public HelloUdpServerExternalResource() {
25      }
26      private int choosePort() throws SocketException {
27          DatagramSocket serverSocket = new DatagramSocket();
28          int port = serverSocket.getLocalPort();
29          serverSocket.close();
30          return port;
31      }
32      public void setTimeout(int timeout) {
33          this.timeout = timeout;
34      }
35      public void start() {
36          int port;
37          try {
38              port = choosePort();
39          } catch (SocketException e) {
40              throw new RuntimeException("Error choosing point", e);
41          }
42          server = RxNetty.createUdpServer(port, new ConnectionHandler<DatagramPacket, DatagramPacket>() {
43              @Override
44              public Observable<Void> handle(final ObservableConnection<DatagramPacket, DatagramPacket> newConnection) {
45                  return newConnection.getInput().flatMap(new Func1<DatagramPacket, Observable<Void>>() {
46                      @Override
47                      public Observable<Void> call(final DatagramPacket received) {
48                          return Observable.interval(timeout, TimeUnit.MILLISECONDS).take(1).flatMap(new Func1<Long, Observable<Void>>() {
49                              @Override
50                              public Observable<Void> call(Long aLong) {
51                                  InetSocketAddress sender = received.sender();
52                                  LOG.info("Received datagram. Sender: " + sender);
53                                  ByteBuf data = newConnection.getChannel().alloc().buffer(WELCOME_MSG_BYTES.length);
54                                  data.writeBytes(WELCOME_MSG_BYTES);
55                                  return newConnection.writeAndFlush(new DatagramPacket(data, sender));
56                              }
57                          });
58                      }
59                  });
60              }
61          });
62          server.start();
63          LOG.info("UDP hello server started at port: " + port);
64      }
65      protected void after() {
66          if (server != null) {
67              try {
68                  server.shutdown();
69              } catch (InterruptedException e) {
70                  LOG.error("Failed to shut down server", e);
71              }
72          }
73      }
74      public int getServerPort() {
75          return server.getServerPort();
76      }
77  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-StandardThreadExecutor_1.java</h3>
            <pre><code>1  package com.weibo.api.motan.core;
<span onclick='openModal()' class='match'>2  import java.util.concurrent.Executors;
3  import java.util.concurrent.LinkedTransferQueue;
4  import java.util.concurrent.RejectedExecutionException;
5  import java.util.concurrent.RejectedExecutionHandler;
6  import java.util.concurrent.ThreadFactory;
7  import java.util.concurrent.ThreadPoolExecutor;
8  import java.util.concurrent.TimeUnit;
9  import java.util.concurrent.atomic.AtomicInteger;
10  public class StandardThreadExecutor extends ThreadPoolExecutor {
11  	public static final int DEFAULT_MIN_THREADS = 20;
</span>12  	public static final int DEFAULT_MAX_THREADS = 200;
13  	public static final int DEFAULT_MAX_IDLE_TIME = 60 * 1000; 
14  	protected AtomicInteger submittedTasksCount;	
15  	private int maxSubmittedTaskCount;				
16  	public StandardThreadExecutor() {
17  		this(DEFAULT_MIN_THREADS, DEFAULT_MAX_THREADS);
18  	}
19  	public StandardThreadExecutor(int coreThread, int maxThreads) {
20  		this(coreThread, maxThreads, maxThreads);
21  	}
22  	public StandardThreadExecutor(int coreThread, int maxThreads, long keepAliveTime, TimeUnit unit) {
23  		this(coreThread, maxThreads, keepAliveTime, unit, maxThreads);
24  	}
25  	public StandardThreadExecutor(int coreThreads, int maxThreads, int queueCapacity) {
26  		this(coreThreads, maxThreads, queueCapacity, Executors.defaultThreadFactory());
27  	}
28  	public StandardThreadExecutor(int coreThreads, int maxThreads, int queueCapacity, ThreadFactory threadFactory) {
29  		this(coreThreads, maxThreads, DEFAULT_MAX_IDLE_TIME, TimeUnit.MILLISECONDS, queueCapacity, threadFactory);
30  	}
31  	public StandardThreadExecutor(int coreThreads, int maxThreads, long keepAliveTime, TimeUnit unit, int queueCapacity) {
32  		this(coreThreads, maxThreads, keepAliveTime, unit, queueCapacity, Executors.defaultThreadFactory());
33  	}
34  	public StandardThreadExecutor(int coreThreads, int maxThreads, long keepAliveTime, TimeUnit unit,
35  			int queueCapacity, ThreadFactory threadFactory) {
36  		this(coreThreads, maxThreads, keepAliveTime, unit, queueCapacity, threadFactory, new AbortPolicy());
37  	}
38  	public StandardThreadExecutor(int coreThreads, int maxThreads, long keepAliveTime, TimeUnit unit,
39  			int queueCapacity, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
40  		super(coreThreads, maxThreads, keepAliveTime, unit, new ExecutorQueue(), threadFactory, handler);
41  		((ExecutorQueue) getQueue()).setStandardThreadExecutor(this);
42  		submittedTasksCount = new AtomicInteger(0);
43  		maxSubmittedTaskCount = queueCapacity + maxThreads; 
44  	}
45  	public void execute(Runnable command) {
46  		int count = submittedTasksCount.incrementAndGet();
47  		if (count > maxSubmittedTaskCount) {
48  			submittedTasksCount.decrementAndGet();
49  			getRejectedExecutionHandler().rejectedExecution(command, this);
50  			return;
51  		}
52  		try {
53  			super.execute(command);
54  		} catch (RejectedExecutionException rx) {
55  			if (!((ExecutorQueue) getQueue()).force(command)) {
56  				submittedTasksCount.decrementAndGet();
57  				getRejectedExecutionHandler().rejectedExecution(command, this);
58  			}
59  		}
60  	}
61  	public int getSubmittedTasksCount() {
62  		return this.submittedTasksCount.get();
63  	}
64  	public int getMaxSubmittedTaskCount() {
65  		return maxSubmittedTaskCount;
66  	}
67  	protected void afterExecute(Runnable r, Throwable t) {
68  		submittedTasksCount.decrementAndGet();
69  	}
70  }
71  class ExecutorQueue extends LinkedTransferQueue<Runnable> {
72  	private static final long serialVersionUID = -265236426751004839L;
73  	StandardThreadExecutor threadPoolExecutor;
74  	public ExecutorQueue() {
75  		super();
76  	}
77  	public void setStandardThreadExecutor(StandardThreadExecutor threadPoolExecutor) {
78  		this.threadPoolExecutor = threadPoolExecutor;
79  	}
80  	public boolean force(Runnable o) {
81  		if (threadPoolExecutor.isShutdown()) {
82  			throw new RejectedExecutionException("Executor not running, can't force a command into the queue");
83  		}
84  		return super.offer(o);
85  	}
86  	public boolean offer(Runnable o) {
87  		int poolSize = threadPoolExecutor.getPoolSize();
88  		if (poolSize == threadPoolExecutor.getMaximumPoolSize()) {
89  			return super.offer(o);
90  		}
91  		if (threadPoolExecutor.getSubmittedTasksCount() <= poolSize) {
92  			return super.offer(o);
93  		}
94  		if (poolSize < threadPoolExecutor.getMaximumPoolSize()) {
95  			return false;
96  		}
97  		return super.offer(o);
98  	}
99  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-HelloUdpServerExternalResource.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-StandardThreadExecutor_1.java</div>
                <div class="column column_space"><pre><code>10  import java.net.SocketException;
11  import java.nio.charset.Charset;
12  import java.util.concurrent.TimeUnit;
13  import org.junit.rules.ExternalResource;
14  import org.slf4j.Logger;
15  import org.slf4j.LoggerFactory;
16  import rx.Observable;
17  import rx.functions.Func1;
18  public class HelloUdpServerExternalResource extends ExternalResource {
19      private static final Logger LOG = LoggerFactory.getLogger(HelloUdpServerExternalResource.class);
</pre></code></div>
                <div class="column column_space"><pre><code>2  import java.util.concurrent.Executors;
3  import java.util.concurrent.LinkedTransferQueue;
4  import java.util.concurrent.RejectedExecutionException;
5  import java.util.concurrent.RejectedExecutionHandler;
6  import java.util.concurrent.ThreadFactory;
7  import java.util.concurrent.ThreadPoolExecutor;
8  import java.util.concurrent.TimeUnit;
9  import java.util.concurrent.atomic.AtomicInteger;
10  public class StandardThreadExecutor extends ThreadPoolExecutor {
11  	public static final int DEFAULT_MIN_THREADS = 20;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    