
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaScanner.java</h3>
            <pre><code>1  package io.vov.vitamio;
2  import android.content.ContentProviderClient;
3  import android.content.ContentUris;
4  import android.content.ContentValues;
5  import android.content.Context;
6  import android.database.Cursor;
7  import android.database.SQLException;
8  import android.net.Uri;
9  import android.os.RemoteException;
10  import android.text.TextUtils;
11  import io.vov.vitamio.provider.MediaStore;
12  import io.vov.vitamio.provider.MediaStore.Video;
13  import io.vov.vitamio.utils.ContextUtils;
14  import io.vov.vitamio.utils.FileUtils;
15  import io.vov.vitamio.utils.Log;
16  import java.io.File;
17  import java.util.HashMap;
18  import java.util.Iterator;
19  public class MediaScanner {
20    private static final String[] VIDEO_PROJECTION = new String[]{Video.Media._ID, Video.Media.DATA, Video.Media.DATE_MODIFIED,};
21    private static final int ID_VIDEO_COLUMN_INDEX = 0;
22    private static final int PATH_VIDEO_COLUMN_INDEX = 1;
23    private static final int DATE_MODIFIED_VIDEO_COLUMN_INDEX = 2;
24    private Context mContext;
25    private ContentProviderClient mProvider;
26    private boolean mCaseInsensitivePaths;
27    private HashMap<String, FileCacheEntry> mFileCache;
28    private MyMediaScannerClient mClient = new MyMediaScannerClient();
29    public MediaScanner(Context ctx) {
30      mContext = ctx;
31      native_init(mClient);
32    }
33    private static native boolean loadFFmpeg_native(String ffmpegPath);
34    private void initialize() {
35      mCaseInsensitivePaths = true;
36    }
37    private void prescan(String filePath) throws RemoteException {
38      mProvider = mContext.getContentResolver().acquireContentProviderClient(MediaStore.AUTHORITY);
39      Cursor c = null;
40      String where = null;
41      String[] selectionArgs = null;
42      if (mFileCache == null)
43        mFileCache = new HashMap<String, FileCacheEntry>();
44      else
45        mFileCache.clear();
46      try {
47        if (filePath != null) {
48          where = Video.Media.DATA + "=?";
49          selectionArgs = new String[]{filePath};
50        }
51        c = mProvider.query(Video.Media.CONTENT_URI, VIDEO_PROJECTION, where, selectionArgs, null);
52        if (c != null) {
53          try {
54            while (c.moveToNext()) {
55              long rowId = c.getLong(ID_VIDEO_COLUMN_INDEX);
56              String path = c.getString(PATH_VIDEO_COLUMN_INDEX);
57              long lastModified = c.getLong(DATE_MODIFIED_VIDEO_COLUMN_INDEX);
58              if (path.startsWith("/")) {
59                File tempFile = new File(path);
60                if (!TextUtils.isEmpty(filePath) && !tempFile.exists()) {
61                  mProvider.delete(Video.Media.CONTENT_URI, where, selectionArgs);
62                  return;
63                }
64                path = FileUtils.getCanonical(tempFile);
65                String key = mCaseInsensitivePaths ? path.toLowerCase() : path;
66                mFileCache.put(key, new FileCacheEntry(Video.Media.CONTENT_URI, rowId, path, lastModified));
67              }
68            }
69          } finally {
70            c.close();
71            c = null;
72          }
73        }
74      } finally {
75        if (c != null) {
76          c.close();
77        }
78      }
79    }
80    ;
81    private void postscan(String[] directories) throws RemoteException {
82      Iterator<FileCacheEntry> iterator = mFileCache.values().iterator();
83      while (iterator.hasNext()) {
84        FileCacheEntry entry = iterator.next();
85        String path = entry.mPath;
86        if (!entry.mSeenInFileSystem) {
87          if (inScanDirectory(path, directories) && !new File(path).exists()) {
88            mProvider.delete(ContentUris.withAppendedId(entry.mTableUri, entry.mRowId), null, null);
89            iterator.remove();
90          }
91        }
92      }
93      mFileCache.clear();
94      mFileCache = null;
95      mProvider.release();
96      mProvider = null;
97    }
98    private boolean inScanDirectory(String path, String[] directories) {
99      for (int i = 0; i < directories.length; i++) {
100        if (path.startsWith(directories[i]))
101          return true;
102      }
103      return false;
104    }
105    public void scanDirectories(String[] directories) {
106      try {
107        long start = System.currentTimeMillis();
108        prescan(null);
109        long prescan = System.currentTimeMillis();
110        for (int i = 0; i < directories.length; i++) {
111          if (!TextUtils.isEmpty(directories[i])) {
112            directories[i] = ContextUtils.fixLastSlash(directories[i]);
113            processDirectory(directories[i], MediaFile.sFileExtensions);
114          }
115        }
116        long scan = System.currentTimeMillis();
117        postscan(directories);
118        long end = System.currentTimeMillis();
119        Log.d(" prescan time: %dms", prescan - start);
120        Log.d("    scan time: %dms", scan - prescan);
121        Log.d("postscan time: %dms", end - scan);
122        Log.d("   total time: %dms", end - start);
123      } catch (SQLException e) {
124        Log.e("SQLException in MediaScanner.scan()", e);
125      } catch (UnsupportedOperationException e) {
126        Log.e("UnsupportedOperationException in MediaScanner.scan()", e);
127      } catch (RemoteException e) {
128        Log.e("RemoteException in MediaScanner.scan()", e);
129      }
130    }
131    public Uri scanSingleFile(String path, String mimeType) {
132      try {
133        prescan(path);
134        File file = new File(path);
135        long lastModifiedSeconds = file.lastModified() / 1000;
136        return mClient.doScanFile(path, lastModifiedSeconds, file.length(), true);
137      } catch (RemoteException e) {
138        Log.e("RemoteException in MediaScanner.scanFile()", e);
139        return null;
140      }
141    }
142    static {
143      String LIB_ROOT = Vitamio.getLibraryPath();
144      Log.i("LIB ROOT: %s", LIB_ROOT);
145      System.load(LIB_ROOT + "libstlport_shared.so");
146      System.load(LIB_ROOT + "libvscanner.so");
147      loadFFmpeg_native(LIB_ROOT + "libffmpeg.so");
148    }
149    private native void processDirectory(String path, String extensions);
150    private native boolean processFile(String path, String mimeType);
151    private native final void native_init(MediaScannerClient client);
152    public native void release();
153    private native final void native_finalize();
154    @Override
155    protected void finalize() throws Throwable {
156      try {
157        native_finalize();
158      } finally {
159        super.finalize();
160      }
161    }
162    private static class FileCacheEntry {
163      Uri mTableUri;
164      long mRowId;
165      String mPath;
166      long mLastModified;
167      boolean mLastModifiedChanged;
168      boolean mSeenInFileSystem;
169      FileCacheEntry(Uri tableUri, long rowId, String path, long lastModified) {
170        mTableUri = tableUri;
171        mRowId = rowId;
172        mPath = path;
173        mLastModified = lastModified;
174        mSeenInFileSystem = false;
175        mLastModifiedChanged = false;
176      }
177      @Override
178      public String toString() {
179        return mPath;
180      }
181    }
182    private class MyMediaScannerClient implements MediaScannerClient {
183      private String mMimeType;
184      private int mFileType;
185      private String mPath;
186      private long mLastModified;
187      private long mFileSize;
188      private String mTitle;
189      private String mArtist;
190      private String mAlbum;
191      private String mLanguage;
192      private long mDuration;
193      private int mWidth;
194      private int mHeight;
195      public FileCacheEntry beginFile(String path, long lastModified, long fileSize) {
196        int lastSlash = path.lastIndexOf('/');
197        if (lastSlash >= 0 && lastSlash + 2 < path.length()) {
198          if (path.regionMatches(lastSlash + 1, "._", 0, 2))
199            return null;
200          if (path.regionMatches(true, path.length() - 4, ".jpg", 0, 4)) {
201            if (path.regionMatches(true, lastSlash + 1, "AlbumArt_{", 0, 10) || path.regionMatches(true, lastSlash + 1, "AlbumArt.", 0, 9)) {
202              return null;
203            }
204            int length = path.length() - lastSlash - 1;
205            if ((length == 17 && path.regionMatches(true, lastSlash + 1, "AlbumArtSmall", 0, 13)) || (length == 10 && path.regionMatches(true, lastSlash + 1, "Folder", 0, 6))) {
206              return null;
207            }
208          }
209        }
210        MediaFile.MediaFileType mediaFileType = MediaFile.getFileType(path);
211        if (mediaFileType != null) {
212          mFileType = mediaFileType.fileType;
213          mMimeType = mediaFileType.mimeType;
214        }
215        String key = FileUtils.getCanonical(new File(path));
216        if (mCaseInsensitivePaths)
217          key = path.toLowerCase();
218        FileCacheEntry entry = mFileCache.get(key);
219        if (entry == null) {
220          entry = new FileCacheEntry(null, 0, path, 0);
221          mFileCache.put(key, entry);
222        }
223        entry.mSeenInFileSystem = true;
224        long delta = lastModified - entry.mLastModified;
225        if (delta > 1 || delta < -1) {
226          entry.mLastModified = lastModified;
227          entry.mLastModifiedChanged = true;
228        }
229        mPath = path;
230        mLastModified = lastModified;
231        mFileSize = fileSize;
232        mTitle = null;
233        mDuration = 0;
234        return entry;
235      }
236      public void scanFile(String path, long lastModified, long fileSize) {
237        Log.i("scanFile: %s", path);
238        doScanFile(path, lastModified, fileSize, false);
239      }
240      public Uri doScanFile(String path, long lastModified, long fileSize, boolean scanAlways) {
241        Uri result = null;
242        try {
243          FileCacheEntry entry = beginFile(path, lastModified, fileSize);
244          if (entry != null && (entry.mLastModifiedChanged || scanAlways)) {
245            if (processFile(path, null)) {
246              result = endFile(entry);
247            } else {
248              if (mCaseInsensitivePaths)
249                mFileCache.remove(path.toLowerCase());
250              else
251                mFileCache.remove(path);
252            }
253          }
254        } catch (RemoteException e) {
255          Log.e("RemoteException in MediaScanner.scanFile()", e);
256        }
257        return result;
258      }
259      private int parseSubstring(String s, int start, int defaultValue) {
260        int length = s.length();
261        if (start == length)
262          return defaultValue;
263        char ch = s.charAt(start++);
264        if (ch < '0' || ch > '9')
265          return defaultValue;
266        int result = ch - '0';
267        while (start < length) {
268          ch = s.charAt(start++);
269          if (ch < '0' || ch > '9')
270            return result;
271          result = result * 10 + (ch - '0');
272        }
273        return result;
274      }
275      public void handleStringTag(String name, byte[] valueBytes, String valueEncoding) {
276        String value;
<span onclick='openModal()' class='match'>277        try {
278          value = new String(valueBytes, valueEncoding);
279        } catch (Exception e) {
280          Log.e("handleStringTag", e);
</span>281          value = new String(valueBytes);
282        }
283        Log.i("%s : %s", name, value);
284        if (name.equalsIgnoreCase("title")) {
285          mTitle = value;
286        } else if (name.equalsIgnoreCase("artist")) {
287          mArtist = value.trim();
288        } else if (name.equalsIgnoreCase("albumartist")) {
289          if (TextUtils.isEmpty(mArtist))
290            mArtist = value.trim();
291        } else if (name.equalsIgnoreCase("album")) {
292          mAlbum = value.trim();
293        } else if (name.equalsIgnoreCase("language")) {
294          mLanguage = value.trim();
295        } else if (name.equalsIgnoreCase("duration")) {
296          mDuration = parseSubstring(value, 0, 0);
297        } else if (name.equalsIgnoreCase("width")) {
298          mWidth = parseSubstring(value, 0, 0);
299        } else if (name.equalsIgnoreCase("height")) {
300          mHeight = parseSubstring(value, 0, 0);
301        }
302      }
303      public void setMimeType(String mimeType) {
304        Log.i("setMimeType: %s", mimeType);
305        mMimeType = mimeType;
306        mFileType = MediaFile.getFileTypeForMimeType(mimeType);
307      }
308      private ContentValues toValues() {
309        ContentValues map = new ContentValues();
310        map.put(MediaStore.MediaColumns.DATA, mPath);
311        map.put(MediaStore.MediaColumns.DATE_MODIFIED, mLastModified);
312        map.put(MediaStore.MediaColumns.SIZE, mFileSize);
313        map.put(MediaStore.MediaColumns.MIME_TYPE, mMimeType);
314        map.put(MediaStore.MediaColumns.TITLE, mTitle);
315        if (MediaFile.isVideoFileType(mFileType)) {
316          map.put(Video.Media.DURATION, mDuration);
317          map.put(Video.Media.LANGUAGE, mLanguage);
318          map.put(Video.Media.ALBUM, mAlbum);
319          map.put(Video.Media.ARTIST, mArtist);
320          map.put(Video.Media.WIDTH, mWidth);
321          map.put(Video.Media.HEIGHT, mHeight);
322        }
323        return map;
324      }
325      private Uri endFile(FileCacheEntry entry) throws RemoteException {
326        Uri tableUri;
327        boolean isVideo = MediaFile.isVideoFileType(mFileType) && mWidth > 0 && mHeight > 0;
328        if (isVideo) {
329          tableUri = Video.Media.CONTENT_URI;
330        } else {
331          return null;
332        }
333        entry.mTableUri = tableUri;
334        ContentValues values = toValues();
335        String title = values.getAsString(MediaStore.MediaColumns.TITLE);
336        if (TextUtils.isEmpty(title)) {
337          title = values.getAsString(MediaStore.MediaColumns.DATA);
338          int lastSlash = title.lastIndexOf('/');
339          if (lastSlash >= 0) {
340            lastSlash++;
341            if (lastSlash < title.length())
342              title = title.substring(lastSlash);
343          }
344          int lastDot = title.lastIndexOf('.');
345          if (lastDot > 0)
346            title = title.substring(0, lastDot);
347          values.put(MediaStore.MediaColumns.TITLE, title);
348        }
349        long rowId = entry.mRowId;
350        Uri result = null;
351        if (rowId == 0) {
352          result = mProvider.insert(tableUri, values);
353          if (result != null) {
354            rowId = ContentUris.parseId(result);
355            entry.mRowId = rowId;
356          }
357        } else {
358          result = ContentUris.withAppendedId(tableUri, rowId);
359          mProvider.update(result, values, null, null);
360        }
361        return result;
362      }
363      public void addNoMediaFolder(String path) {
364        ContentValues values = new ContentValues();
365        values.put(MediaStore.MediaColumns.DATA, "");
366        String[] pathSpec = new String[]{path + '%'};
367        try {
368          mProvider.update(Video.Media.CONTENT_URI, values, MediaStore.MediaColumns.DATA + " LIKE ?", pathSpec);
369        } catch (RemoteException e) {
370          throw new RuntimeException();
371        }
372      }
373    }
374  }
</code></pre>
        </div>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaPlayer.java</h3>
            <pre><code>1  package io.vov.vitamio;
2  import android.annotation.SuppressLint;
3  import android.content.ContentResolver;
4  import android.content.Context;
5  import android.content.res.AssetFileDescriptor;
6  import android.graphics.Bitmap;
7  import android.graphics.Canvas;
8  import android.media.AudioFormat;
9  import android.media.AudioManager;
10  import android.media.AudioTrack;
11  import android.net.Uri;
12  import android.os.Build;
13  import android.os.Bundle;
14  import android.os.Handler;
15  import android.os.Looper;
16  import android.os.Message;
17  import android.os.PowerManager;
18  import android.text.TextUtils;
19  import android.util.SparseArray;
20  import android.view.Surface;
21  import android.view.SurfaceHolder;
22  import io.vov.vitamio.utils.FileUtils;
23  import io.vov.vitamio.utils.Log;
24  import java.io.File;
25  import java.io.FileDescriptor;
26  import java.io.FileInputStream;
27  import java.io.IOException;
28  import java.io.UnsupportedEncodingException;
29  import java.nio.ByteBuffer;
30  import java.nio.charset.Charset;
31  import java.util.HashMap;
32  import java.util.Map;
33  import java.util.concurrent.atomic.AtomicBoolean;
34  public class MediaPlayer {
35    public static final int CACHE_TYPE_NOT_AVAILABLE = 1;
36    public static final int CACHE_TYPE_START = 2;
37    public static final int CACHE_TYPE_UPDATE = 3;
38    public static final int CACHE_TYPE_SPEED = 4;
39    public static final int CACHE_TYPE_COMPLETE = 5;
40    public static final int CACHE_INFO_NO_SPACE = 1;
41    public static final int CACHE_INFO_STREAM_NOT_SUPPORT = 2;
42    public static final int MEDIA_ERROR_UNKNOWN = 1;
43    public static final int MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = 200;
44    public static final int MEDIA_ERROR_IO = -5;
45    public static final int MEDIA_ERROR_MALFORMED = -1007;
46    public static final int MEDIA_ERROR_UNSUPPORTED = -1010;
47    public static final int MEDIA_ERROR_TIMED_OUT = -110;
48    public static final int MEDIA_INFO_VIDEO_TRACK_LAGGING = 700;
49    public static final int MEDIA_INFO_BUFFERING_START = 701;
50    public static final int MEDIA_INFO_BUFFERING_END = 702;
51    public static final int MEDIA_INFO_NOT_SEEKABLE = 801;
52    public static final int MEDIA_INFO_DOWNLOAD_RATE_CHANGED = 901;
53    public static final int VIDEOQUALITY_LOW = -16;
54    public static final int VIDEOQUALITY_MEDIUM = 0;
55    public static final int VIDEOQUALITY_HIGH = 16;
56    public static final int VIDEOCHROMA_RGB565 = 0;
57    public static final int VIDEOCHROMA_RGBA = 1;
58    public static final int SUBTITLE_INTERNAL = 0;
59    public static final int SUBTITLE_EXTERNAL = 1;
60    public static final String[] SUB_TYPES = {".srt", ".ssa", ".smi", ".txt", ".sub", ".ass", ".webvtt"};
61    private static final int MEDIA_NOP = 0;
62    private static final int MEDIA_PREPARED = 1;
63    private static final int MEDIA_PLAYBACK_COMPLETE = 2;
64    private static final int MEDIA_BUFFERING_UPDATE = 3;
65    private static final int MEDIA_SEEK_COMPLETE = 4;
66    private static final int MEDIA_SET_VIDEO_SIZE = 5;
67    private static final int MEDIA_ERROR = 100;
68    private static final int MEDIA_INFO = 200;
69    private static final int MEDIA_CACHE = 300;
70    private static final int MEDIA_HW_ERROR = 400;
71    private static final int MEDIA_TIMED_TEXT = 1000;
72    private static final int MEDIA_CACHING_UPDATE = 2000;
73    private static final String MEDIA_CACHING_SEGMENTS = "caching_segment";
74    private static final String MEDIA_CACHING_TYPE = "caching_type";
75    private static final String MEDIA_CACHING_INFO = "caching_info";
76    private static final String MEDIA_SUBTITLE_STRING = "sub_string";
77    private static final String MEDIA_SUBTITLE_BYTES = "sub_bytes";
78    private static final String MEDIA_SUBTITLE_TYPE = "sub_type";
79    private static final int SUBTITLE_TEXT = 0;
80    private static final int SUBTITLE_BITMAP = 1;
81    private static AtomicBoolean NATIVE_OMX_LOADED = new AtomicBoolean(false);
82    private Context mContext;
83    private Surface mSurface;
84    private SurfaceHolder mSurfaceHolder;
85    private EventHandler mEventHandler;
86    private PowerManager.WakeLock mWakeLock = null;
87    private boolean mScreenOnWhilePlaying;
88    private boolean mStayAwake;
89    private Metadata mMeta;
90    private TrackInfo[] mInbandTracks;
91    private TrackInfo mOutOfBandTracks;
92    private AssetFileDescriptor mFD = null;
93    private OnHWRenderFailedListener mOnHWRenderFailedListener;
94    private OnPreparedListener mOnPreparedListener;
95    private OnCompletionListener mOnCompletionListener;
96    private OnBufferingUpdateListener mOnBufferingUpdateListener;
97    private OnCachingUpdateListener mOnCachingUpdateListener;
98    private OnSeekCompleteListener mOnSeekCompleteListener;
99    private OnVideoSizeChangedListener mOnVideoSizeChangedListener;
100    private OnErrorListener mOnErrorListener;
101    private OnInfoListener mOnInfoListener;
102    private OnTimedTextListener mOnTimedTextListener;
103    private AudioTrack mAudioTrack;
104    private int mAudioTrackBufferSize;
105    private Surface mLocalSurface;
106    private Bitmap mBitmap;
107    private ByteBuffer mByteBuffer;
108    public MediaPlayer(Context ctx) {
109      this(ctx, false);
110    }
111    public MediaPlayer(Context ctx, boolean preferHWDecoder) {
112      mContext = ctx;
113      String LIB_ROOT = Vitamio.getLibraryPath();
114      if (preferHWDecoder) {
115        if (!NATIVE_OMX_LOADED.get()) {
116          if (Build.VERSION.SDK_INT > 17)
117            loadOMX_native(LIB_ROOT + "libOMX.18.so");
118          else if (Build.VERSION.SDK_INT > 13)
119            loadOMX_native(LIB_ROOT + "libOMX.14.so");
120          else if (Build.VERSION.SDK_INT > 10)
121            loadOMX_native(LIB_ROOT + "libOMX.11.so");
122          else
123            loadOMX_native(LIB_ROOT + "libOMX.9.so");
124          NATIVE_OMX_LOADED.set(true);
125        }
126      } else {
127        try {
128          unloadOMX_native();
129        } catch (UnsatisfiedLinkError e) {
130          Log.e("unloadOMX failed %s", e.toString());
131        }
132        NATIVE_OMX_LOADED.set(false);
133      }
134      Looper looper;
135      if ((looper = Looper.myLooper()) != null)
136        mEventHandler = new EventHandler(this, looper);
137      else if ((looper = Looper.getMainLooper()) != null)
138        mEventHandler = new EventHandler(this, looper);
139      else
140        mEventHandler = null;
141      native_init();
142    }
143    static {
144      String LIB_ROOT = Vitamio.getLibraryPath();
145      try {
146        Log.i("LIB ROOT: %s", LIB_ROOT);
147        System.load(LIB_ROOT + "libstlport_shared.so");
148        System.load(LIB_ROOT + "libvplayer.so");
149        loadFFmpeg_native(LIB_ROOT + "libffmpeg.so");
150        boolean vvo_loaded = false;
151        if (Build.VERSION.SDK_INT > 8)
152          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.9.so");
153        else if (Build.VERSION.SDK_INT > 7)
154          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.8.so");
155        else
156          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.7.so");
157        if (!vvo_loaded) {
158          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.j.so");
159          Log.d("FALLBACK TO VVO JNI " + vvo_loaded);
160        }
161        loadVAO_native(LIB_ROOT + "libvao.0.so");
162      } catch (java.lang.UnsatisfiedLinkError e) {
163        Log.e("Error loading libs", e);
164      }
165    }
166    private static void postEventFromNative(Object mediaplayer_ref, int what, int arg1, int arg2, Object obj) {
167      MediaPlayer mp = (MediaPlayer) (mediaplayer_ref);
168      if (mp == null)
169        return;
170      if (mp.mEventHandler != null) {
171        Message m = mp.mEventHandler.obtainMessage(what, arg1, arg2, obj);
172        mp.mEventHandler.sendMessage(m);
173      }
174    }
175    private static native boolean loadVAO_native(String vaoPath);
176    private static native boolean loadVVO_native(String vvoPath);
177    private static native boolean loadOMX_native(String omxPath);
178    private static native void unloadOMX_native();
179    private static native boolean loadFFmpeg_native(String ffmpegPath);
180    private native void _setVideoSurface(Surface surface);
181    public void setDisplay(SurfaceHolder sh) {
182      if (sh == null) {
183        releaseDisplay();
184      } else {
185        mSurfaceHolder = sh;
186        mSurface = sh.getSurface();
187        _setVideoSurface(mSurface);
188        updateSurfaceScreenOn();
189      }
190    }
191    public void setSurface(Surface surface) {
192      if (surface == null) {
193        releaseDisplay();
194      } else {
195        mSurfaceHolder = null;
196        mSurface = surface;
197        _setVideoSurface(mSurface);
198        updateSurfaceScreenOn();
199      }
200    }
201    public void setDataSource(String path) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
202      _setDataSource(path, null, null);
203    }
204    public void setDataSource(Context context, Uri uri) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
205      setDataSource(context, uri, null);
206    }
207    public void setDataSource(Context context, Uri uri, Map<String, String> headers) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
208      if (context == null || uri == null)
209        throw new IllegalArgumentException();
210      String scheme = uri.getScheme();
211      if (scheme == null || scheme.equals("file")) {
212        setDataSource(FileUtils.getPath(uri.toString()));
213        return;
214      }
215      try {
216        ContentResolver resolver = context.getContentResolver();
217        mFD = resolver.openAssetFileDescriptor(uri, "r");
218        if (mFD == null)
219          return;
220        setDataSource(mFD.getParcelFileDescriptor().getFileDescriptor());
221        return;
222      } catch (Exception e) {
223        closeFD();
224      }
225      setDataSource(uri.toString(), headers);
226    }
227    public void setDataSource(String path, Map<String, String> headers)
228            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException
229    {
230        String[] keys = null;
231        String[] values = null;
232        if (headers != null) {
233            keys = new String[headers.size()];
234            values = new String[headers.size()];
235            int i = 0;
236            for (Map.Entry<String, String> entry: headers.entrySet()) {
237                keys[i] = entry.getKey();
238                values[i] = entry.getValue();
239                ++i;
240            }
241        }
242        setDataSource(path, keys, values);
243    }
244  	public void setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
245  		final Uri uri = Uri.parse(path);
246  		if ("file".equals(uri.getScheme())) {
247  			path = uri.getPath();
248  		}
249  		final File file = new File(path);
250  		if (file.exists()) {
251  			FileInputStream is = new FileInputStream(file);
252  			FileDescriptor fd = is.getFD();
253  			setDataSource(fd);
254  			is.close();
255  		} else {
256  			_setDataSource(path, keys, values);
257  		}
258  	}
259    public void setDataSegments(String[] uris, String cacheDir) {
260    	_setDataSegmentsSource(uris, cacheDir);
261    }
262    public void setOnHWRenderFailedListener(OnHWRenderFailedListener l) {
263      mOnHWRenderFailedListener = l;
264    }
265    private native void _setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, IllegalStateException;
266    public native void setDataSource(FileDescriptor fd) throws IOException, IllegalArgumentException, IllegalStateException;
267    private native void _setDataSegmentsSource(String[] segments, String cacheDir);
268    public native void prepare() throws IOException, IllegalStateException;
269    public native void prepareAsync() throws IllegalStateException;
270    public void start() throws IllegalStateException {
271      stayAwake(true);
272      _start();
273    }
274    private native void _start() throws IllegalStateException;
275    public void stop() throws IllegalStateException {
276      stayAwake(false);
277      _stop();
278    }
279    private native void _stop() throws IllegalStateException;
280    public void pause() throws IllegalStateException {
281      stayAwake(false);
282      _pause();
283    }
284    private native void _pause() throws IllegalStateException;
285    @SuppressLint("Wakelock")
286    public void setWakeMode(Context context, int mode) {
287      boolean washeld = false;
288      if (mWakeLock != null) {
289        if (mWakeLock.isHeld()) {
290          washeld = true;
291          mWakeLock.release();
292        }
293        mWakeLock = null;
294      }
295      PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
296      mWakeLock = pm.newWakeLock(mode | PowerManager.ON_AFTER_RELEASE, MediaPlayer.class.getName());
297      mWakeLock.setReferenceCounted(false);
298      if (washeld) {
299        mWakeLock.acquire();
300      }
301    }
302    public void setScreenOnWhilePlaying(boolean screenOn) {
303      if (mScreenOnWhilePlaying != screenOn) {
304        mScreenOnWhilePlaying = screenOn;
305        updateSurfaceScreenOn();
306      }
307    }
308    @SuppressLint("Wakelock")
309    private void stayAwake(boolean awake) {
310      if (mWakeLock != null) {
311        if (awake && !mWakeLock.isHeld()) {
312          mWakeLock.acquire();
313        } else if (!awake && mWakeLock.isHeld()) {
314          mWakeLock.release();
315        }
316      }
317      mStayAwake = awake;
318      updateSurfaceScreenOn();
319    }
320    private void updateSurfaceScreenOn() {
321      if (mSurfaceHolder != null)
322        mSurfaceHolder.setKeepScreenOn(mScreenOnWhilePlaying && mStayAwake);
323    }
324    public native int getVideoWidth();
325    private native int getVideoWidth_a();
326    public native int getVideoHeight();
327    private native int getVideoHeight_a();
328    public native boolean isPlaying();
329    public native void setUseCache(boolean cache);
330    public native void setCacheDirectory(String directory);
331    public native void setAdaptiveStream(boolean adaptive);
332    public native void seekTo(long msec) throws IllegalStateException;
333    public native long getCurrentPosition();
334    public native Bitmap getCurrentFrame();
335    public native long getDuration();
336    public Metadata getMetadata() {
337      if (mMeta == null) {
338        mMeta = new Metadata();
339        Map<byte[], byte[]> meta = new HashMap<byte[], byte[]>();
340        if (!native_getMetadata(meta)) {
341          return null;
342        }
343        if (!mMeta.parse(meta, getMetaEncoding())) {
344          return null;
345        }
346      }
347      return mMeta;
348    }
349    public void release() {
350      stayAwake(false);
351      updateSurfaceScreenOn();
352      mOnPreparedListener = null;
353      mOnBufferingUpdateListener = null;
354      mOnCompletionListener = null;
355      mOnSeekCompleteListener = null;
356      mOnErrorListener = null;
357      mOnInfoListener = null;
358      mOnVideoSizeChangedListener = null;
359      mOnCachingUpdateListener = null;
360      mOnHWRenderFailedListener = null;
361      _release();
362      closeFD();
363    }
364    private native void _release();
365    public void reset() {
366      stayAwake(false);
367      _reset();
368      mEventHandler.removeCallbacksAndMessages(null);
369      closeFD();
370    }
371    private native void _reset();
372    private void closeFD() {
373      if (mFD != null) {
374        try {
375          mFD.close();
376        } catch (IOException e) {
377          Log.e("closeFD", e);
378        }
379        mFD = null;
380      }
381    }
382    public native void setLooping(boolean looping);
383    public native boolean isLooping();
384    public native void setAudioAmplify(float ratio);
385    public native void setVolume(float leftVolume, float rightVolume);
386    private native final boolean native_getTrackInfo(SparseArray<byte[]> trackSparse);
387    private native final boolean native_getMetadata(Map<byte[], byte[]> meta);
388    private native final void native_init();
389    private native final void native_finalize();
390    public TrackInfo[] getTrackInfo(String encoding) {
391    	TrackInfo[] trackInfo = getInbandTrackInfo(encoding);
392    	String timedTextPath = getTimedTextPath();
393    	if (TextUtils.isEmpty(timedTextPath)) {
394    		return trackInfo;
395    	}
396      TrackInfo[] allTrackInfo = new TrackInfo[trackInfo.length + 1];
397      System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
398      int i = trackInfo.length;
399      SparseArray<MediaFormat> trackInfoArray = new SparseArray<MediaFormat>();
400      MediaFormat mediaFormat = new MediaFormat();
401      mediaFormat.setString(MediaFormat.KEY_TITLE, timedTextPath.substring(timedTextPath.lastIndexOf("/")));
402      mediaFormat.setString(MediaFormat.KEY_PATH, timedTextPath);
403      SparseArray<MediaFormat> timedTextSparse = findTrackFromTrackInfo(TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT, trackInfo);
404      if (timedTextSparse == null || timedTextSparse.size() == 0)
405      	trackInfoArray.put(timedTextSparse.keyAt(0), mediaFormat);
406      else 
407      	trackInfoArray.put(timedTextSparse.keyAt(timedTextSparse.size() - 1), mediaFormat);
408      mOutOfBandTracks = new TrackInfo(TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE, trackInfoArray);
409      allTrackInfo[i] = mOutOfBandTracks;
410      return allTrackInfo;
411    }
412    private TrackInfo[] getInbandTrackInfo(String encoding) {
413    	if (mInbandTracks == null) {
414    		SparseArray<byte[]> trackSparse = new SparseArray<byte[]>();
415        if (!native_getTrackInfo(trackSparse)) {
416          return null;
417        }
418        int size = trackSparse.size();
419        mInbandTracks = new TrackInfo[size];
420        for (int i = 0; i < size; i++) {
421        	SparseArray<MediaFormat> sparseArray = parseTrackInfo(trackSparse.valueAt(i), encoding);
422          TrackInfo trackInfo = new TrackInfo(trackSparse.keyAt(i), sparseArray);
423          mInbandTracks[i] = trackInfo;
424        }
425    	}
426      return mInbandTracks;
427    }
428    public TrackInfo[] getTrackInfo() {
429      return getTrackInfo(Charset.defaultCharset().name());
430    }
431    private SparseArray<MediaFormat> parseTrackInfo(byte[] tracks, String encoding) {
432      SparseArray<MediaFormat> trackSparse = new SparseArray<MediaFormat>();
433      String trackString;
434      int trackNum;
<span onclick='openModal()' class='match'>435      try {
436        trackString = new String(tracks, encoding);
437      } catch (Exception e) {
438        Log.e("getTrackMap exception");
</span>439        trackString = new String(tracks);
440      }
441      for (String s : trackString.split("!#!")) {
442        try {
443        	MediaFormat mediaFormat = null;
444        	String[] formats = s.split("\\.");
445        	if (formats == null)
446        		continue;
447        	trackNum = Integer.parseInt(formats[0]);
448        	if (formats.length == 3) {
449        		mediaFormat = MediaFormat.createSubtitleFormat(formats[2], formats[1]);
450        	} else if (formats.length == 2) {
451        		mediaFormat = MediaFormat.createSubtitleFormat("", formats[1]);
452        	}
453          trackSparse.put(trackNum, mediaFormat);
454        } catch (NumberFormatException e) {
455        }
456      }
457      return trackSparse;
458    }
459    public SparseArray<MediaFormat> findTrackFromTrackInfo(int mediaTrackType, TrackInfo[] trackInfo) {
460      for (int i = 0; i < trackInfo.length; i++) {
461        if (trackInfo[i].getTrackType() == mediaTrackType) {
462          return trackInfo[i].getTrackInfoArray();
463        }
464      }
465      return null;
466    }
467    public native void addTimedTextSource(String path);
468    public void selectTrack(int index) {
469    	selectOrDeselectBandTrack(index, true &bsol;* select */);
470    }
471    public void deselectTrack(int index) {
472    	selectOrDeselectBandTrack(index, false &bsol;* select */);
473    }
474    private void selectOrDeselectBandTrack(int index, boolean select) {
475    	if (mOutOfBandTracks != null) {
476    		SparseArray<MediaFormat> mediaSparse = mOutOfBandTracks.getTrackInfoArray();
477    		int trackIndex = mediaSparse.keyAt(0);
478    		MediaFormat mediaFormat = mediaSparse.valueAt(0);
479      	if (index == trackIndex  && select) {
480      		addTimedTextSource(mediaFormat.getString(MediaFormat.KEY_PATH));
481      		return;
482      	}
483    	}
484    	selectOrDeselectTrack(index, select);
485    }
486    private native void selectOrDeselectTrack(int index, boolean select);
487    @Override
488    protected void finalize() {
489      native_finalize();
490    }
491    public void setOnPreparedListener(OnPreparedListener listener) {
492      mOnPreparedListener = listener;
493    }
494    public void setOnCompletionListener(OnCompletionListener listener) {
495      mOnCompletionListener = listener;
496    }
497    public void setOnBufferingUpdateListener(OnBufferingUpdateListener listener) {
498      mOnBufferingUpdateListener = listener;
499    }
500    public void setOnCachingUpdateListener(OnCachingUpdateListener listener) {
501      mOnCachingUpdateListener = listener;
502    }
503    private void updateCacheStatus(int type, int info, long[] segments) {
504      if (mEventHandler != null) {
505        Message m = mEventHandler.obtainMessage(MEDIA_CACHING_UPDATE);
506        Bundle b = m.getData();
507        b.putInt(MEDIA_CACHING_TYPE, type);
508        b.putInt(MEDIA_CACHING_INFO, info);
509        b.putLongArray(MEDIA_CACHING_SEGMENTS, segments);
510        mEventHandler.sendMessage(m);
511      }
512    }
513    public void setOnSeekCompleteListener(OnSeekCompleteListener listener) {
514      mOnSeekCompleteListener = listener;
515    }
516    public void setOnVideoSizeChangedListener(OnVideoSizeChangedListener listener) {
517      mOnVideoSizeChangedListener = listener;
518    }
519    public void setOnErrorListener(OnErrorListener listener) {
520      mOnErrorListener = listener;
521    }
522    public void setOnInfoListener(OnInfoListener listener) {
523      mOnInfoListener = listener;
524    }
525    public void setOnTimedTextListener(OnTimedTextListener listener) {
526      mOnTimedTextListener = listener;
527    }
528    private void updateSub(int subType, byte[] bytes, String encoding, int width, int height) {
529      if (mEventHandler != null) {
530        Message m = mEventHandler.obtainMessage(MEDIA_TIMED_TEXT, width, height);
531        Bundle b = m.getData();
532        if (subType == SUBTITLE_TEXT) {
533          b.putInt(MEDIA_SUBTITLE_TYPE, SUBTITLE_TEXT);
534          if (encoding == null) {
535            b.putString(MEDIA_SUBTITLE_STRING, new String(bytes));
536          } else {
537            try {
538              b.putString(MEDIA_SUBTITLE_STRING, new String(bytes, encoding.trim()));
539            } catch (UnsupportedEncodingException e) {
540              Log.e("updateSub", e);
541              b.putString(MEDIA_SUBTITLE_STRING, new String(bytes));
542            }
543          }
544        } else if (subType == SUBTITLE_BITMAP) {
545          b.putInt(MEDIA_SUBTITLE_TYPE, SUBTITLE_BITMAP);
546          b.putByteArray(MEDIA_SUBTITLE_BYTES, bytes);
547        }
548        mEventHandler.sendMessage(m);
549      }
550    }
551    protected native void _releaseVideoSurface();
552    public void releaseDisplay() {
553      _releaseVideoSurface();
554      mSurfaceHolder = null;
555      mSurface = null;
556    }
557    public native float getVideoAspectRatio();
558    public native void setVideoQuality(int quality);
559    public native void setVideoChroma(int chroma);
560    public native void setDeinterlace(boolean deinterlace);
561    public native void setBufferSize(long bufSize);
562    public native void setPlaybackSpeed(float speed);
563    public native boolean isBuffering();
564    public native int getBufferProgress();
565    public native String getMetaEncoding();
566    public native void setMetaEncoding(String encoding);
567  	public native int getAudioTrack();
568  	public native int getVideoTrack();
569    public native void setTimedTextShown(boolean shown);
570    public native void setTimedTextEncoding(String encoding);
571    public native int getTimedTextLocation();
572    public native String getTimedTextPath();
573    public native int getTimedTextTrack();
574    private int audioTrackInit(int sampleRateInHz, int channels) {
575      audioTrackRelease();
576      int channelConfig = channels >= 2 ? AudioFormat.CHANNEL_OUT_STEREO : AudioFormat.CHANNEL_OUT_MONO;
577      try {
578        mAudioTrackBufferSize = AudioTrack.getMinBufferSize(sampleRateInHz, channelConfig, AudioFormat.ENCODING_PCM_16BIT);
579        mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRateInHz, channelConfig, AudioFormat.ENCODING_PCM_16BIT, mAudioTrackBufferSize, AudioTrack.MODE_STREAM);
580      } catch (Exception e) {
581        mAudioTrackBufferSize = 0;
582        Log.e("audioTrackInit", e);
583      }
584      return mAudioTrackBufferSize;
585    }
586    private void audioTrackSetVolume(float leftVolume, float rightVolume) {
587      if (mAudioTrack != null)
588        mAudioTrack.setStereoVolume(leftVolume, rightVolume);
589    }
590    private void audioTrackWrite(byte[] audioData, int offsetInBytes, int sizeInBytes) {
591      if (mAudioTrack != null && mAudioTrack.getPlayState() == AudioTrack.PLAYSTATE_PLAYING) {
592        int written;
593        while (sizeInBytes > 0) {
594          written = sizeInBytes > mAudioTrackBufferSize ? mAudioTrackBufferSize : sizeInBytes;
595          mAudioTrack.write(audioData, offsetInBytes, written);
596          sizeInBytes -= written;
597          offsetInBytes += written;
598        }
599      }
600    }
601    private void audioTrackStart() {
602      if (mAudioTrack != null && mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED && mAudioTrack.getPlayState() != AudioTrack.PLAYSTATE_PLAYING)
603        mAudioTrack.play();
604    }
605    private void audioTrackPause() {
606      if (mAudioTrack != null && mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)
607        mAudioTrack.pause();
608    }
609    private void audioTrackRelease() {
610      if (mAudioTrack != null) {
611        if (mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)
612          mAudioTrack.stop();
613        mAudioTrack.release();
614      }
615      mAudioTrack = null;
616    }
617    public int getAudioSessionId() {
618  	return mAudioTrack.getAudioSessionId();
619    }
620    private ByteBuffer surfaceInit() {
621      synchronized (this) {
622        mLocalSurface = mSurface;
623        int w = getVideoWidth_a();
624        int h = getVideoHeight_a();
625        if (mLocalSurface != null && w != 0 && h != 0) {
626          mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.RGB_565);
627          mByteBuffer = ByteBuffer.allocateDirect(w * h * 2);
628        } else {
629          mBitmap = null;
630          mByteBuffer = null;
631        }
632        return mByteBuffer;
633      }
634    }
635    private void surfaceRender() {
636      synchronized (this) {
637        if (mLocalSurface == null || !mLocalSurface.isValid() || mBitmap == null || mByteBuffer == null)
638          return;
639        try {
640          Canvas c = mLocalSurface.lockCanvas(null);
641          mBitmap.copyPixelsFromBuffer(mByteBuffer);
642          c.drawBitmap(mBitmap, 0, 0, null);
643          mLocalSurface.unlockCanvasAndPost(c);
644        } catch (Exception e) {
645          Log.e("surfaceRender", e);
646        }
647      }
648    }
649    private void surfaceRelease() {
650      synchronized (this) {
651        mLocalSurface = null;
652        mBitmap = null;
653        mByteBuffer = null;
654      }
655    }
656    public interface OnHWRenderFailedListener {
657      public void onFailed();
658    }
659    public interface OnPreparedListener {
660      void onPrepared(MediaPlayer mp);
661    }
662    public interface OnCompletionListener {
663      void onCompletion(MediaPlayer mp);
664    }
665    public interface OnBufferingUpdateListener {
666      void onBufferingUpdate(MediaPlayer mp, int percent);
667    }
668    public interface OnCachingUpdateListener {
669      void onCachingUpdate(MediaPlayer mp, long[] segments);
670      void onCachingSpeed(MediaPlayer mp, int speed);
671      void onCachingStart(MediaPlayer mp);
672     	void onCachingComplete(MediaPlayer mp); 
673      void onCachingNotAvailable(MediaPlayer mp, int info);
674    }
675    public interface OnSeekCompleteListener {
676      public void onSeekComplete(MediaPlayer mp);
677    }
678    public interface OnVideoSizeChangedListener {
679      public void onVideoSizeChanged(MediaPlayer mp, int width, int height);
680    }
681    public interface OnErrorListener {
682      boolean onError(MediaPlayer mp, int what, int extra);
683    }
684    public interface OnInfoListener {
685      boolean onInfo(MediaPlayer mp, int what, int extra);
686    }
687    public interface OnTimedTextListener {
688      public void onTimedText(String text);
689      public void onTimedTextUpdate(byte[] pixels, int width, int height);
690    }
691    static public class TrackInfo {
692      public static final int MEDIA_TRACK_TYPE_UNKNOWN = 0;
693      public static final int MEDIA_TRACK_TYPE_VIDEO = 1;
694      public static final int MEDIA_TRACK_TYPE_AUDIO = 2;
695      public static final int MEDIA_TRACK_TYPE_TIMEDTEXT = 3;
696      public static final int MEDIA_TRACK_TYPE_SUBTITLE = 4;
697      final int mTrackType;
698      final SparseArray<MediaFormat> mTrackInfoArray;
699      TrackInfo(int trackType, SparseArray<MediaFormat> trackInfoArray) {
700        mTrackType = trackType;
701        mTrackInfoArray = trackInfoArray;
702      }
703      public int getTrackType() {
704        return mTrackType;
705      }
706      public SparseArray<MediaFormat> getTrackInfoArray() {
707        return mTrackInfoArray;
708      }
709    }
710    @SuppressLint("HandlerLeak")
711    private class EventHandler extends Handler {
712      private MediaPlayer mMediaPlayer;
713      private Bundle mData;
714      public EventHandler(MediaPlayer mp, Looper looper) {
715        super(looper);
716        mMediaPlayer = mp;
717      }
718      @Override
719      public void handleMessage(Message msg) {
720        switch (msg.what) {
721          case MEDIA_PREPARED:
722            if (mOnPreparedListener != null)
723              mOnPreparedListener.onPrepared(mMediaPlayer);
724            return;
725          case MEDIA_PLAYBACK_COMPLETE:
726            if (mOnCompletionListener != null)
727              mOnCompletionListener.onCompletion(mMediaPlayer);
728            stayAwake(false);
729            return;
730          case MEDIA_BUFFERING_UPDATE:
731            if (mOnBufferingUpdateListener != null)
732              mOnBufferingUpdateListener.onBufferingUpdate(mMediaPlayer, msg.arg1);
733            return;
734          case MEDIA_SEEK_COMPLETE:
735            if (isPlaying())
736              stayAwake(true);
737            if (mOnSeekCompleteListener != null)
738              mOnSeekCompleteListener.onSeekComplete(mMediaPlayer);
739            return;
740          case MEDIA_SET_VIDEO_SIZE:
741            if (mOnVideoSizeChangedListener != null)
742              mOnVideoSizeChangedListener.onVideoSizeChanged(mMediaPlayer, msg.arg1, msg.arg2);
743            return;
744          case MEDIA_ERROR:
745            Log.e("Error (%d, %d)", msg.arg1, msg.arg2);
746            boolean error_was_handled = false;
747            if (mOnErrorListener != null)
748              error_was_handled = mOnErrorListener.onError(mMediaPlayer, msg.arg1, msg.arg2);
749            if (mOnCompletionListener != null && !error_was_handled)
750              mOnCompletionListener.onCompletion(mMediaPlayer);
751            stayAwake(false);
752            return;
753          case MEDIA_INFO:
754            Log.i("Info (%d, %d)", msg.arg1, msg.arg2);
755            if (mOnInfoListener != null)
756              mOnInfoListener.onInfo(mMediaPlayer, msg.arg1, msg.arg2);
757            return;
758          case MEDIA_CACHE:
759            return;
760          case MEDIA_TIMED_TEXT:
761            mData = msg.getData();
762            if (mData.getInt(MEDIA_SUBTITLE_TYPE) == SUBTITLE_TEXT) {
763              Log.i("Subtitle : %s", mData.getString(MEDIA_SUBTITLE_STRING));
764              if (mOnTimedTextListener != null)
765                mOnTimedTextListener.onTimedText(mData.getString(MEDIA_SUBTITLE_STRING));
766            } else if (mData.getInt(MEDIA_SUBTITLE_TYPE) == SUBTITLE_BITMAP) {
767              Log.i("Subtitle : bitmap");
768              if (mOnTimedTextListener != null)
769                mOnTimedTextListener.onTimedTextUpdate(mData.getByteArray(MEDIA_SUBTITLE_BYTES), msg.arg1, msg.arg2);
770            }
771            return;
772          case MEDIA_CACHING_UPDATE:
773            if (mOnCachingUpdateListener != null) {
774              int cacheType = msg.getData().getInt(MEDIA_CACHING_TYPE);
775              if (cacheType == CACHE_TYPE_NOT_AVAILABLE) {
776                mOnCachingUpdateListener.onCachingNotAvailable(mMediaPlayer, msg.getData().getInt(MEDIA_CACHING_INFO));
777              } else if (cacheType == CACHE_TYPE_UPDATE) {
778                mOnCachingUpdateListener.onCachingUpdate(mMediaPlayer, msg.getData().getLongArray(MEDIA_CACHING_SEGMENTS));
779              } else if (cacheType == CACHE_TYPE_SPEED) {
780                mOnCachingUpdateListener.onCachingSpeed(mMediaPlayer, msg.getData().getInt(MEDIA_CACHING_INFO));
781              } else if (cacheType == CACHE_TYPE_START) {
782              	mOnCachingUpdateListener.onCachingStart(mMediaPlayer);
783              } else if (cacheType == CACHE_TYPE_COMPLETE) {
784              	mOnCachingUpdateListener.onCachingComplete(mMediaPlayer);
785              }
786            }
787            return;
788          case MEDIA_NOP:
789            return;
790          case MEDIA_HW_ERROR:
791          	if (mOnHWRenderFailedListener != null)
792          		mOnHWRenderFailedListener.onFailed();
793          	return;
794          default:
795            Log.e("Unknown message type " + msg.what);
796            return;
797        }
798      }
799    }
800  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaScanner.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaPlayer.java</div>
                </div>
                <div class="column column_space"><pre><code>277        try {
278          value = new String(valueBytes, valueEncoding);
279        } catch (Exception e) {
280          Log.e("handleStringTag", e);
</pre></code></div>
                <div class="column column_space"><pre><code>435      try {
436        trackString = new String(tracks, encoding);
437      } catch (Exception e) {
438        Log.e("getTrackMap exception");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    