<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for XContentTestUtilsTests.java &amp; Coordinator.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for XContentTestUtilsTests.java &amp; Coordinator.java
      </h3>
<h1 align="center">
        8.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>XContentTestUtilsTests.java (38.69863%)<th>Coordinator.java (4.7659216%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(155-162)<td><a href="#" name="0">(877-885)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(20-43)<td><a href="#" name="1">(20-41)</a><td align="center"><font color="#e80000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(80-85)<td><a href="#" name="2">(1058-1067)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(106-112)<td><a href="#" name="3">(847-857)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(171-174)<td><a href="#" name="4">(675-681)</a><td align="center"><font color="#6e0000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(188-191)<td><a href="#" name="5">(201-203)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(185-187)<td><a href="#" name="6">(556-560)</a><td align="center"><font color="#630000">9</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(51-59)<td><a href="#" name="7">(300-302)</a><td align="center"><font color="#630000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>XContentTestUtilsTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.test;
2 import org.elasticsearch.common.bytes.BytesReference;
3 import org.elasticsearch.common.xcontent.DeprecationHandler;
4 import org.elasticsearch.common.xcontent.NamedXContentRegistry;
5 import org.elasticsearch.common.xcontent.XContentBuilder;
6 import org.elasticsearch.common.xcontent.XContentFactory;
7 import org.elasticsearch.common.xcontent.XContentHelper;
8 import org.elasticsearch.common.xcontent.XContentParser;
9 import org.elasticsearch.common.xcontent.XContentType;
10 import org.elasticsearch.common.xcontent.json.JsonXContent;
11 import java.io.IOException;
12 import java.util.Collections;
13 import java.util.HashMap;
14 import java.util.List;
15 import java.util.Map;
16 import java.util.Stack;
17 import java.util.function.Predicate;
18 import static org.elasticsearch.test.XContentTestUtils.insertRandomFields;
19 import static org.hamcrest.Matchers.equalTo;
20 import static org.hamcrest.Matchers.hasItem;
21 import</b></font> static org.hamcrest.Matchers.instanceOf;
22 public class XContentTestUtilsTests extends ESTestCase {
23     public void testGetInsertPaths() throws IOException {
24 <a name="7"></a>        XContentBuilder builder = JsonXContent.contentBuilder();
25         builder.startObject();
26         {
27             <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>builder.field("field1", "value");
28             builder.startArray("list1");
29             {
30                 builder.value(0);
31                 builder.value(1);
32                 builder.startObject();
33                 builder.endObject();
34                 builder.value(3);
35                 builder.startObject</b></font>();
36                 builder.endObject();
37             }
38             builder.endArray();
39             builder.startObject("inner1");
40             {
41                 builder.field("inner1field1", "value");
42                 builder.startObject("inn.er2");
43                 {
44                     builder.field("inner2field1", "value");
45                 }
46                 builder.endObject();
47             }
48             builder.endObject();
49         }
50         builder.endObject();
51         try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY,
52 <a name="2"></a>            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, BytesReference.bytes(builder), builder.contentType())) {
53             parser.nextToken();
54             List&lt;String&gt; insertPaths = XContentTestUtils.getInsertPaths(parser, new Stack&lt;&gt;());
55             <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(5, insertPaths.size());
56             assertThat(insertPaths, hasItem(equalTo("")));
57             assertThat(insertPaths, hasItem(equalTo("list1.2")));
58             assertThat(insertPaths, hasItem(equalTo("list1.4")));
59             assertThat(insertPaths, hasItem(equalTo("inner1")));
60             assertThat(insertPaths, hasItem(equalTo</b></font>("inner1.inn\\.er2")));
61         }
62     }
63     @SuppressWarnings("unchecked")
64     public void testInsertIntoXContent() throws IOException {
65         XContentBuilder builder = JsonXContent.contentBuilder();
66         builder.startObject();
67         builder.endObject();
68         builder = XContentTestUtils.insertIntoXContent(XContentType.JSON.xContent(), BytesReference.bytes(builder),
69                 Collections.singletonList(""), () -&gt; "inn.er1", () -&gt; new HashMap&lt;&gt;());
70         builder = XContentTestUtils.insertIntoXContent(XContentType.JSON.xContent(), BytesReference.bytes(builder),
71                 Collections.singletonList(""), () -&gt; "field1", () -&gt; "value1");
72         builder = XContentTestUtils.insertIntoXContent(XContentType.JSON.xContent(), BytesReference.bytes(builder),
73                 Collections.singletonList("inn\\.er1"), () -&gt; "inner2", () -&gt; new HashMap&lt;&gt;());
74         builder = XContentTestUtils.insertIntoXContent(XContentType.JSON.xContent(), BytesReference.bytes(builder),
75                 Collections.singletonList("inn\\.er1"), () -&gt; "field2", () -&gt; "value2");
76         try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY,
77 <a name="3"></a>            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, BytesReference.bytes(builder), builder.contentType())) {
78             Map&lt;String, Object&gt; map = parser.map();
79             assertEquals(2, map.size());
80             <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals("value1", map.get("field1"));
81             assertThat(map.get("inn.er1"), instanceOf(Map.class));
82             Map&lt;String, Object&gt; innerMap = (Map&lt;String, Object&gt;) map.get("inn.er1");
83             assertEquals(2, innerMap.size());
84             assertEquals("value2", innerMap.get("field2"));
85             assertThat(innerMap.get("inner2"), instanceOf(Map.class));
86             assertEquals</b></font>(0, ((Map&lt;String, Object&gt;) innerMap.get("inner2")).size());
87         }
88     }
89     @SuppressWarnings("unchecked")
90     public void testInsertRandomXContent() throws IOException {
91         XContentBuilder builder = XContentFactory.jsonBuilder();
92         builder.startObject();
93         {
94             builder.startObject("foo");
95             {
96                 builder.field("bar", 1);
97             }
98             builder.endObject();
99             builder.startObject("foo1");
100             {
101                 builder.startObject("foo2");
102                 {
103                     builder.field("buzz", 1);
104                 }
105                 builder.endObject();
106             }
107             builder.endObject();
108             builder.field("foo3", 2);
109             builder.startArray("foo4");
110             {
111                 builder.startObject();
112                 {
113                     builder.field("foo5", 1);
114                 }
115                 builder.endObject();
116             }
117             builder.endArray();
118         }
119         builder.endObject();
120         Map&lt;String, Object&gt; resultMap;
121         try (XContentParser parser = createParser(XContentType.JSON.xContent(),
122 <a name="0"></a>                insertRandomFields(builder.contentType(), BytesReference.bytes(builder), null, random()))) {
123             resultMap = parser.map();
124         }
125         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(5, resultMap.keySet().size());
126         assertEquals(2, ((Map&lt;String, Object&gt;) resultMap.get("foo")).keySet().size());
127         Map&lt;String, Object&gt; foo1 = (Map&lt;String, Object&gt;) resultMap.get("foo1");
128         assertEquals(2, foo1.keySet().size());
129         assertEquals(2, ((Map&lt;String, Object&gt;) foo1.get("foo2")).keySet().size());
130         List&lt;Object&gt; foo4List = (List&lt;Object&gt;) resultMap.get("foo4");
131         assertEquals(1, foo4List.size());
132         assertEquals(2, ((Map&lt;String, Object&gt;) foo4List.get(0)).keySet</b></font>().size());
133         Predicate&lt;String&gt; pathsToExclude = path -&gt; path.endsWith("foo1");
134         try (XContentParser parser = createParser(XContentType.JSON.xContent(),
135                 insertRandomFields(builder.contentType(), BytesReference.bytes(builder), pathsToExclude, random()))) {
136             resultMap = parser.map();
137 <a name="4"></a>        }
138         assertEquals(5, resultMap.keySet().size());
139         assertEquals(2, ((Map&lt;String, Object&gt;) resultMap.get("foo")).keySet().size());
140         foo1 = (Map&lt;String, Object&gt;) <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>resultMap.get("foo1");
141         assertEquals(1, foo1.keySet().size());
142         assertEquals(2, ((Map&lt;String, Object&gt;) foo1.get("foo2")).keySet().size());
143         foo4List = (List&lt;Object&gt;) resultMap.get</b></font>("foo4");
144         assertEquals(1, foo4List.size());
145         assertEquals(2, ((Map&lt;String, Object&gt;) foo4List.get(0)).keySet().size());
146         pathsToExclude = path -&gt; path.contains("foo1");
147         try (XContentParser parser = createParser(XContentType.JSON.xContent(),
148                 insertRandomFields(builder.contentType(), BytesReference.bytes(builder), pathsToExclude, random()))) {
149             resultMap = parser.map();
150 <a name="6"></a>        }
151         assertEquals(5, resultMap.keySet().size());
152         assertEquals(2, ((Map&lt;String, Object&gt;) resultMap.get("foo")).keySet().size());
153 <a name="5"></a>        <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>foo1 = (Map&lt;String, Object&gt;) resultMap.get("foo1");
154         assertEquals(1, foo1.keySet().size());
155         assertEquals(1, ((Map&lt;String, Object&gt;) foo1.get</b></font>("foo2")).keySet().size());
156         foo4List = (List&lt;Object&gt;) <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>resultMap.get("foo4");
157         assertEquals(1, foo4List.size());
158         assertEquals(2, ((Map&lt;String, Object&gt;) foo4List.get(0)).keySet().size());
159     }</b></font>
160 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Coordinator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.cluster.coordination;
2 import org.apache.logging.log4j.Level;
3 import org.apache.logging.log4j.LogManager;
4 import org.apache.logging.log4j.Logger;
5 import org.apache.logging.log4j.message.ParameterizedMessage;
6 import org.apache.lucene.util.SetOnce;
7 import org.elasticsearch.action.ActionListener;
8 import org.elasticsearch.cluster.ClusterChangedEvent;
9 import org.elasticsearch.cluster.ClusterName;
10 import org.elasticsearch.cluster.ClusterState;
11 import org.elasticsearch.cluster.ClusterStateTaskConfig;
12 import org.elasticsearch.cluster.ClusterStateUpdateTask;
13 import org.elasticsearch.cluster.LocalClusterUpdateTask;
14 import org.elasticsearch.cluster.block.ClusterBlocks;
15 import org.elasticsearch.cluster.coordination.ClusterFormationFailureHelper.ClusterFormationState;
16 import org.elasticsearch.cluster.coordination.CoordinationMetadata.VotingConfigExclusion;
17 import org.elasticsearch.cluster.coordination.CoordinationMetadata.VotingConfiguration;
18 import org.elasticsearch.cluster.coordination.FollowersChecker.FollowerCheckRequest;
19 import org.elasticsearch.cluster.coordination.JoinHelper.InitialJoinAccumulator;
20 import org.elasticsearch.cluster.metadata.Metadata;
21 import</b></font> org.elasticsearch.cluster.node.DiscoveryNode;
22 import org.elasticsearch.cluster.node.DiscoveryNodes;
23 import org.elasticsearch.cluster.routing.RerouteService;
24 import org.elasticsearch.cluster.routing.allocation.AllocationService;
25 import org.elasticsearch.cluster.service.ClusterApplier;
26 import org.elasticsearch.cluster.service.ClusterApplier.ClusterApplyListener;
27 import org.elasticsearch.cluster.service.MasterService;
28 import javax.annotation.Nullable;
29 import org.elasticsearch.common.Priority;
30 import org.elasticsearch.common.Strings;
31 import org.elasticsearch.common.component.AbstractLifecycleComponent;
32 import org.elasticsearch.common.io.stream.NamedWriteableRegistry;
33 import org.elasticsearch.common.lease.Releasable;
34 import org.elasticsearch.common.settings.ClusterSettings;
35 import org.elasticsearch.common.settings.Setting;
36 import org.elasticsearch.common.settings.Settings;
37 import org.elasticsearch.common.transport.TransportAddress;
38 import io.crate.common.unit.TimeValue;
39 import org.elasticsearch.common.util.concurrent.EsExecutors;
40 import org.elasticsearch.common.util.concurrent.ListenableFuture;
41 import org.elasticsearch.common.xcontent.XContentHelper;
42 import org.elasticsearch.common.xcontent.json.JsonXContent;
43 import org.elasticsearch.discovery.Discovery;
44 import org.elasticsearch.discovery.DiscoveryModule;
45 import org.elasticsearch.discovery.DiscoveryStats;
46 import org.elasticsearch.discovery.HandshakingTransportAddressConnector;
47 import org.elasticsearch.discovery.PeerFinder;
48 import org.elasticsearch.discovery.SeedHostsProvider;
49 import org.elasticsearch.discovery.SeedHostsResolver;
50 import org.elasticsearch.threadpool.Scheduler;
51 import org.elasticsearch.threadpool.ThreadPool.Names;
52 import org.elasticsearch.transport.TransportResponse.Empty;
53 import org.elasticsearch.transport.TransportService;
54 import java.io.IOException;
55 import java.util.ArrayList;
56 import java.util.Collection;
57 import java.util.Collections;
58 import java.util.HashSet;
59 import java.util.List;
60 import java.util.Optional;
61 import java.util.Random;
62 import java.util.Set;
63 import java.util.concurrent.atomic.AtomicBoolean;
64 import java.util.function.BiConsumer;
65 import java.util.function.Supplier;
66 import java.util.stream.Collectors;
67 import java.util.stream.Stream;
68 import java.util.stream.StreamSupport;
69 import static org.elasticsearch.cluster.coordination.NoMasterBlockService.NO_MASTER_BLOCK_ID;
70 import static org.elasticsearch.gateway.ClusterStateUpdaters.hideStateIfNotRecovered;
71 import static org.elasticsearch.gateway.GatewayService.STATE_NOT_RECOVERED_BLOCK;
72 public class Coordinator extends AbstractLifecycleComponent implements Discovery {
73     private static final Logger LOGGER = LogManager.getLogger(Coordinator.class);
74     public static final Setting&lt;TimeValue&gt; PUBLISH_INFO_TIMEOUT_SETTING =
75         Setting.timeSetting("cluster.publish.info_timeout",
76             TimeValue.timeValueMillis(10000), TimeValue.timeValueMillis(1), Setting.Property.NodeScope);
77     public static final Setting&lt;TimeValue&gt; PUBLISH_TIMEOUT_SETTING =
78         Setting.timeSetting("cluster.publish.timeout",
79             TimeValue.timeValueMillis(30000), TimeValue.timeValueMillis(1), Setting.Property.NodeScope);
80     private final Settings settings;
81     private final boolean singleNodeDiscovery;
82     private final TransportService transportService;
83     private final MasterService masterService;
84     private final AllocationService allocationService;
85     private final JoinHelper joinHelper;
86     private final NodeRemovalClusterStateTaskExecutor nodeRemovalExecutor;
87     private final Supplier&lt;CoordinationState.PersistedState&gt; persistedStateSupplier;
88     private final NoMasterBlockService noMasterBlockService;
89     final Object mutex = new Object();
90     private final SetOnce&lt;CoordinationState&gt; coordinationState = new SetOnce&lt;&gt;();     private volatile ClusterState applierState; 
91     private final PeerFinder peerFinder;
92     private final PreVoteCollector preVoteCollector;
93     private final Random random;
94     private final ElectionSchedulerFactory electionSchedulerFactory;
95     private final SeedHostsResolver configuredHostsResolver;
96     private final TimeValue publishTimeout;
97     private final TimeValue publishInfoTimeout;
98     private final PublicationTransportHandler publicationHandler;
99     private final LeaderChecker leaderChecker;
100     private final FollowersChecker followersChecker;
101     private final ClusterApplier clusterApplier;
102     private final Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; onJoinValidators;
103     @Nullable
104     private Releasable electionScheduler;
105     @Nullable
106     private Releasable prevotingRound;
107     private long maxTermSeen;
108     private final Reconfigurator reconfigurator;
109     private final ClusterBootstrapService clusterBootstrapService;
110     private final LagDetector lagDetector;
111     private final ClusterFormationFailureHelper clusterFormationFailureHelper;
112     private Mode mode;
113     private Optional&lt;DiscoveryNode&gt; lastKnownLeader;
114     private Optional&lt;Join&gt; lastJoin;
115     private JoinHelper.JoinAccumulator joinAccumulator;
116     private Optional&lt;CoordinatorPublication&gt; currentPublication = Optional.empty();
117     public Coordinator(String nodeName, Settings settings, ClusterSettings clusterSettings, TransportService transportService,
118                        NamedWriteableRegistry namedWriteableRegistry, AllocationService allocationService, MasterService masterService,
119                        Supplier&lt;CoordinationState.PersistedState&gt; persistedStateSupplier, SeedHostsProvider seedHostsProvider,
120                        ClusterApplier clusterApplier, Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; onJoinValidators, Random random,
121                        RerouteService rerouteService) {
122         this.settings = settings;
123         this.transportService = transportService;
124         this.masterService = masterService;
125         this.allocationService = allocationService;
126         this.onJoinValidators = JoinTaskExecutor.addBuiltInJoinValidators(onJoinValidators);
127         this.singleNodeDiscovery = DiscoveryModule.SINGLE_NODE_DISCOVERY_TYPE.equals(DiscoveryModule.DISCOVERY_TYPE_SETTING.get(settings));
128         this.joinHelper = new JoinHelper(settings, allocationService, masterService, transportService,
129             this::getCurrentTerm, this::getStateForMasterService, this::handleJoinRequest, this::joinLeaderInTerm, this.onJoinValidators,
130             rerouteService);
131         this.persistedStateSupplier = persistedStateSupplier;
132         this.noMasterBlockService = new NoMasterBlockService(settings, clusterSettings);
133         this.lastKnownLeader = Optional.empty();
134         this.lastJoin = Optional.empty();
135         this.joinAccumulator = new InitialJoinAccumulator();
136         this.publishTimeout = PUBLISH_TIMEOUT_SETTING.get(settings);
137         this.publishInfoTimeout = PUBLISH_INFO_TIMEOUT_SETTING.get(settings);
138         this.random = random;
139         this.electionSchedulerFactory = new ElectionSchedulerFactory(settings, random, transportService.getThreadPool());
140         this.preVoteCollector = new PreVoteCollector(transportService, this::startElection, this::updateMaxTermSeen);
141         configuredHostsResolver = new SeedHostsResolver(nodeName, settings, transportService, seedHostsProvider);
142         this.peerFinder = new CoordinatorPeerFinder(settings, transportService,
143             new HandshakingTransportAddressConnector(settings, transportService), configuredHostsResolver);
144         this.publicationHandler = new PublicationTransportHandler(transportService, namedWriteableRegistry,
145             this::handlePublishRequest, this::handleApplyCommit);
146         this.leaderChecker = new LeaderChecker(settings, transportService, this::onLeaderFailure);
147         this.followersChecker = new FollowersChecker(settings, transportService, this::onFollowerCheckRequest, this::removeNode);
148         this.nodeRemovalExecutor = new NodeRemovalClusterStateTaskExecutor(allocationService, LOGGER);
149         this.clusterApplier = clusterApplier;
150         masterService.setClusterStateSupplier(this::getStateForMasterService);
151         this.reconfigurator = new Reconfigurator(settings, clusterSettings);
152         this.clusterBootstrapService = new ClusterBootstrapService(settings, transportService, this::getFoundPeers,
153             this::isInitialConfigurationSet, this::setInitialConfiguration);
154         this.lagDetector = new LagDetector(settings, transportService.getThreadPool(), n -&gt; removeNode(n, "lagging"),
155             transportService::getLocalNode);
156         this.clusterFormationFailureHelper = new ClusterFormationFailureHelper(settings, this::getClusterFormationState,
157             transportService.getThreadPool(), joinHelper::logLastFailedJoinAttempt);
158     }
159 <a name="5"></a>
160     private ClusterFormationState getClusterFormationState() {
161         return new ClusterFormationState(settings, getStateForMasterService(), peerFinder.getLastResolvedAddresses(),
162             Stream.concat(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Stream.of(getLocalNode()), StreamSupport.stream(peerFinder.getFoundPeers().spliterator(), false))
163                 .collect(Collectors.toList()), getCurrentTerm());
164     }</b></font>
165     private void onLeaderFailure(Exception e) {
166         synchronized (mutex) {
167             if (mode != Mode.CANDIDATE) {
168                 assert lastKnownLeader.isPresent();
169                 LOGGER.info(new ParameterizedMessage("master node [{}] failed, restarting discovery", lastKnownLeader.get()), e);
170             }
171             becomeCandidate("onLeaderFailure");
172         }
173     }
174     private void removeNode(DiscoveryNode discoveryNode, String reason) {
175         synchronized (mutex) {
176             if (mode == Mode.LEADER) {
177                 masterService.submitStateUpdateTask("node-left",
178                     new NodeRemovalClusterStateTaskExecutor.Task(discoveryNode, reason),
179                     ClusterStateTaskConfig.build(Priority.IMMEDIATE),
180                     nodeRemovalExecutor,
181                     nodeRemovalExecutor);
182             }
183         }
184     }
185     void onFollowerCheckRequest(FollowerCheckRequest followerCheckRequest) {
186         synchronized (mutex) {
187             ensureTermAtLeast(followerCheckRequest.getSender(), followerCheckRequest.getTerm());
188             if (getCurrentTerm() != followerCheckRequest.getTerm()) {
189                 LOGGER.trace("onFollowerCheckRequest: current term is [{}], rejecting {}", getCurrentTerm(), followerCheckRequest);
190                 throw new CoordinationStateRejectedException("onFollowerCheckRequest: current term is ["
191                     + getCurrentTerm() + "], rejecting " + followerCheckRequest);
192             }
193             if (getLastAcceptedState().term() &lt; getCurrentTerm()) {
194                 becomeFollower("onFollowerCheckRequest", followerCheckRequest.getSender());
195             } else if (mode == Mode.FOLLOWER) {
196                 LOGGER.trace("onFollowerCheckRequest: responding successfully to {}", followerCheckRequest);
197             } else if (joinHelper.isJoinPending()) {
198                 LOGGER.trace("onFollowerCheckRequest: rejoining master, responding successfully to {}", followerCheckRequest);
199             } else {
200                 LOGGER.trace("onFollowerCheckRequest: received check from faulty master, rejecting {}", followerCheckRequest);
201                 throw new CoordinationStateRejectedException(
202                     "onFollowerCheckRequest: received check from faulty master, rejecting " + followerCheckRequest);
203             }
204         }
205     }
206     private void handleApplyCommit(ApplyCommitRequest applyCommitRequest, ActionListener&lt;Void&gt; applyListener) {
207         synchronized (mutex) {
208             LOGGER.trace("handleApplyCommit: applying commit {}", applyCommitRequest);
209             coordinationState.get().handleCommit(applyCommitRequest);
210             final ClusterState committedState = hideStateIfNotRecovered(coordinationState.get().getLastAcceptedState());
211             applierState = mode == Mode.CANDIDATE ? clusterStateWithNoMasterBlock(committedState) : committedState;
212             if (applyCommitRequest.getSourceNode().equals(getLocalNode())) {
213                 applyListener.onResponse(null);
214             } else {
215                 clusterApplier.onNewClusterState(applyCommitRequest.toString(), () -&gt; applierState,
216                     new ClusterApplyListener() {
217                         @Override
218                         public void onFailure(String source, Exception e) {
219                             applyListener.onFailure(e);
220                         }
221                         @Override
222                         public void onSuccess(String source) {
223                             applyListener.onResponse(null);
224                         }
225                     });
226             }
227         }
228     }
229     PublishWithJoinResponse handlePublishRequest(PublishRequest publishRequest) {
230         assert publishRequest.getAcceptedState().nodes().getLocalNode().equals(getLocalNode()) :
231             publishRequest.getAcceptedState().nodes().getLocalNode() + " != " + getLocalNode();
232         synchronized (mutex) {
233             final DiscoveryNode sourceNode = publishRequest.getAcceptedState().nodes().getMasterNode();
234             LOGGER.trace("handlePublishRequest: handling [{}] from [{}]", publishRequest, sourceNode);
235             if (sourceNode.equals(getLocalNode()) &amp;&amp; mode != Mode.LEADER) {
236                 throw new CoordinationStateRejectedException("no longer leading this publication's term: " + publishRequest);
237             }
238 <a name="7"></a>            final ClusterState localState = coordinationState.get().getLastAcceptedState();
239             if (localState.metadata().clusterUUIDCommitted() &amp;&amp;
240                 localState.metadata().clusterUUID().equals(<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>publishRequest.getAcceptedState().metadata().clusterUUID()) == false) {
241                 LOGGER.warn("received cluster state from {} with a different cluster uuid {} than local cluster uuid {}, rejecting",
242                     sourceNode, publishRequest.getAcceptedState().metadata().clusterUUID(), localState.metadata</b></font>().clusterUUID());
243                 throw new CoordinationStateRejectedException("received cluster state from " + sourceNode +
244                     " with a different cluster uuid " + publishRequest.getAcceptedState().metadata().clusterUUID() +
245                     " than local cluster uuid " + localState.metadata().clusterUUID() + ", rejecting");
246             }
247             if (publishRequest.getAcceptedState().term() &gt; localState.term()) {
248                 onJoinValidators.forEach(a -&gt; a.accept(getLocalNode(), publishRequest.getAcceptedState()));
249             }
250             ensureTermAtLeast(sourceNode, publishRequest.getAcceptedState().term());
251             final PublishResponse publishResponse = coordinationState.get().handlePublishRequest(publishRequest);
252             if (sourceNode.equals(getLocalNode())) {
253                 preVoteCollector.update(getPreVoteResponse(), getLocalNode());
254             } else {
255                 becomeFollower("handlePublishRequest", sourceNode);             }
256             return new PublishWithJoinResponse(publishResponse,
257                 joinWithDestination(lastJoin, sourceNode, publishRequest.getAcceptedState().term()));
258         }
259     }
260     private static Optional&lt;Join&gt; joinWithDestination(Optional&lt;Join&gt; lastJoin, DiscoveryNode leader, long term) {
261         if (lastJoin.isPresent()
262             &amp;&amp; lastJoin.get().targetMatches(leader)
263             &amp;&amp; lastJoin.get().getTerm() == term) {
264             return lastJoin;
265         }
266         return Optional.empty();
267     }
268     private void closePrevotingAndElectionScheduler() {
269         if (prevotingRound != null) {
270             prevotingRound.close();
271             prevotingRound = null;
272         }
273         if (electionScheduler != null) {
274             electionScheduler.close();
275             electionScheduler = null;
276         }
277     }
278     private void updateMaxTermSeen(final long term) {
279         synchronized (mutex) {
280             maxTermSeen = Math.max(maxTermSeen, term);
281             final long currentTerm = getCurrentTerm();
282             if (mode == Mode.LEADER &amp;&amp; maxTermSeen &gt; currentTerm) {
283                 if (publicationInProgress()) {
284                     LOGGER.debug("updateMaxTermSeen: maxTermSeen = {} &gt; currentTerm = {}, enqueueing term bump", maxTermSeen, currentTerm);
285                 } else {
286                     try {
287                         LOGGER.debug("updateMaxTermSeen: maxTermSeen = {} &gt; currentTerm = {}, bumping term", maxTermSeen, currentTerm);
288                         ensureTermAtLeast(getLocalNode(), maxTermSeen);
289                         startElection();
290                     } catch (Exception e) {
291                         LOGGER.warn(new ParameterizedMessage("failed to bump term to {}", maxTermSeen), e);
292                         becomeCandidate("updateMaxTermSeen");
293                     }
294                 }
295             }
296         }
297     }
298     private void startElection() {
299         synchronized (mutex) {
300             if (mode == Mode.CANDIDATE) {
301                 if (localNodeMayWinElection(getLastAcceptedState()) == false) {
302                     LOGGER.trace("skip election as local node may not win it: {}", getLastAcceptedState().coordinationMetadata());
303                     return;
304                 }
305                 final StartJoinRequest startJoinRequest
306                     = new StartJoinRequest(getLocalNode(), Math.max(getCurrentTerm(), maxTermSeen) + 1);
307                 LOGGER.debug("starting election with {}", startJoinRequest);
308                 getDiscoveredNodes().forEach(node -&gt; joinHelper.sendStartJoinRequest(startJoinRequest, node));
309             }
310         }
311     }
312     private void abdicateTo(DiscoveryNode newMaster) {
313         assert Thread.holdsLock(mutex);
314         assert mode == Mode.LEADER : "expected to be leader on abdication but was " + mode;
315         assert newMaster.isMasterEligibleNode() : "should only abdicate to master-eligible node but was " + newMaster;
316         final StartJoinRequest startJoinRequest = new StartJoinRequest(newMaster, Math.max(getCurrentTerm(), maxTermSeen) + 1);
317         LOGGER.info("abdicating to {} with term {}", newMaster, startJoinRequest.getTerm());
318         getLastAcceptedState().nodes().mastersFirstStream().forEach(node -&gt; joinHelper.sendStartJoinRequest(startJoinRequest, node));
319         assert mode == Mode.LEADER : "should still be leader after sending abdication messages " + mode;
320         becomeCandidate("after abdicating to " + newMaster);
321     }
322     private static boolean localNodeMayWinElection(ClusterState lastAcceptedState) {
323         final DiscoveryNode localNode = lastAcceptedState.nodes().getLocalNode();
324         assert localNode != null;
325         return nodeMayWinElection(lastAcceptedState, localNode);
326     }
327     private static boolean nodeMayWinElection(ClusterState lastAcceptedState, DiscoveryNode node) {
328         final String nodeId = node.getId();
329         return lastAcceptedState.getLastCommittedConfiguration().getNodeIds().contains(nodeId)
330             || lastAcceptedState.getLastAcceptedConfiguration().getNodeIds().contains(nodeId)
331             || lastAcceptedState.getVotingConfigExclusions().stream().noneMatch(vce -&gt; vce.getNodeId().equals(nodeId));
332     }
333     private Optional&lt;Join&gt; ensureTermAtLeast(DiscoveryNode sourceNode, long targetTerm) {
334         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
335         if (getCurrentTerm() &lt; targetTerm) {
336             return Optional.of(joinLeaderInTerm(new StartJoinRequest(sourceNode, targetTerm)));
337         }
338         return Optional.empty();
339     }
340     private Join joinLeaderInTerm(StartJoinRequest startJoinRequest) {
341         synchronized (mutex) {
342             LOGGER.debug("joinLeaderInTerm: for [{}] with term {}", startJoinRequest.getSourceNode(), startJoinRequest.getTerm());
343             final Join join = coordinationState.get().handleStartJoin(startJoinRequest);
344             lastJoin = Optional.of(join);
345             peerFinder.setCurrentTerm(getCurrentTerm());
346             if (mode != Mode.CANDIDATE) {
347                 becomeCandidate("joinLeaderInTerm");             } else {
348                 followersChecker.updateFastResponseState(getCurrentTerm(), mode);
349                 preVoteCollector.update(getPreVoteResponse(), null);
350             }
351             return join;
352         }
353     }
354     private void handleJoinRequest(JoinRequest joinRequest, JoinHelper.JoinCallback joinCallback) {
355         assert Thread.holdsLock(mutex) == false;
356         assert getLocalNode().isMasterEligibleNode() : getLocalNode() + " received a join but is not master-eligible";
357         LOGGER.trace("handleJoinRequest: as {}, handling {}", mode, joinRequest);
358         if (singleNodeDiscovery &amp;&amp; joinRequest.getSourceNode().equals(getLocalNode()) == false) {
359             joinCallback.onFailure(new IllegalStateException("cannot join node with [" + DiscoveryModule.DISCOVERY_TYPE_SETTING.getKey() +
360                 "] set to [" + DiscoveryModule.SINGLE_NODE_DISCOVERY_TYPE + "] discovery"));
361             return;
362         }
363         transportService.connectToNode(joinRequest.getSourceNode(), ActionListener.wrap(ignore -&gt; {
364             final ClusterState stateForJoinValidation = getStateForMasterService();
365             if (stateForJoinValidation.nodes().isLocalNodeElectedMaster()) {
366                 onJoinValidators.forEach(a -&gt; a.accept(joinRequest.getSourceNode(), stateForJoinValidation));
367                 if (stateForJoinValidation.getBlocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK) == false) {
368                     JoinTaskExecutor.ensureMajorVersionBarrier(joinRequest.getSourceNode().getVersion(),
369                         stateForJoinValidation.getNodes().getMinNodeVersion());
370                 }
371                 sendValidateJoinRequest(stateForJoinValidation, joinRequest, joinCallback);
372             } else {
373                 processJoinRequest(joinRequest, joinCallback);
374             }
375         }, joinCallback::onFailure));
376     }
377     void sendValidateJoinRequest(ClusterState stateForJoinValidation, JoinRequest joinRequest,
378                                  JoinHelper.JoinCallback joinCallback) {
379         joinHelper.sendValidateJoinRequest(joinRequest.getSourceNode(), stateForJoinValidation, new ActionListener&lt;Empty&gt;() {
380             @Override
381             public void onResponse(Empty empty) {
382                 try {
383                     processJoinRequest(joinRequest, joinCallback);
384                 } catch (Exception e) {
385                     joinCallback.onFailure(e);
386                 }
387             }
388             @Override
389             public void onFailure(Exception e) {
390                 LOGGER.warn(() -&gt; new ParameterizedMessage("failed to validate incoming join request from node [{}]",
391                     joinRequest.getSourceNode()), e);
392                 joinCallback.onFailure(new IllegalStateException("failure when sending a validation request to node", e));
393             }
394         });
395     }
396     private void processJoinRequest(JoinRequest joinRequest, JoinHelper.JoinCallback joinCallback) {
397         final Optional&lt;Join&gt; optionalJoin = joinRequest.getOptionalJoin();
398         synchronized (mutex) {
399             final CoordinationState coordState = coordinationState.get();
400             final boolean prevElectionWon = coordState.electionWon();
401             optionalJoin.ifPresent(this::handleJoin);
402             joinAccumulator.handleJoinRequest(joinRequest.getSourceNode(), joinCallback);
403             if (prevElectionWon == false &amp;&amp; coordState.electionWon()) {
404                 becomeLeader("handleJoinRequest");
405             }
406         }
407     }
408     void becomeCandidate(String method) {
409         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
410         LOGGER.debug("{}: coordinator becoming CANDIDATE in term {} (was {}, lastKnownLeader was [{}])",
411             method, getCurrentTerm(), mode, lastKnownLeader);
412         if (mode != Mode.CANDIDATE) {
413             final Mode prevMode = mode;
414             mode = Mode.CANDIDATE;
415             cancelActivePublication("become candidate: " + method);
416             joinAccumulator.close(mode);
417             joinAccumulator = joinHelper.new CandidateJoinAccumulator();
418             peerFinder.activate(coordinationState.get().getLastAcceptedState().nodes());
419             clusterFormationFailureHelper.start();
420             leaderChecker.setCurrentNodes(DiscoveryNodes.EMPTY_NODES);
421             leaderChecker.updateLeader(null);
422             followersChecker.clearCurrentNodes();
423             followersChecker.updateFastResponseState(getCurrentTerm(), mode);
424             lagDetector.clearTrackedNodes();
425             if (prevMode == Mode.LEADER) {
426                 cleanMasterService();
427             }
428             if (applierState.nodes().getMasterNodeId() != null) {
429                 applierState = clusterStateWithNoMasterBlock(applierState);
430                 clusterApplier.onNewClusterState("becoming candidate: " + method, () -&gt; applierState, (source, e) -&gt; {
431                 });
432             }
433         }
434         preVoteCollector.update(getPreVoteResponse(), null);
435     }
436     void becomeLeader(String method) {
437         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
438         assert mode == Mode.CANDIDATE : "expected candidate but was " + mode;
439         assert getLocalNode().isMasterEligibleNode() : getLocalNode() + " became a leader but is not master-eligible";
440         LOGGER.debug("{}: coordinator becoming LEADER in term {} (was {}, lastKnownLeader was [{}])",
441             method, getCurrentTerm(), mode, lastKnownLeader);
442         mode = Mode.LEADER;
443 <a name="6"></a>        joinAccumulator.close(mode);
444         joinAccumulator = joinHelper.new LeaderJoinAccumulator();
445         <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>lastKnownLeader = Optional.of(getLocalNode());
446         peerFinder.deactivate(getLocalNode());
447         clusterFormationFailureHelper.stop();
448         closePrevotingAndElectionScheduler();
449         preVoteCollector.update(getPreVoteResponse</b></font>(), getLocalNode());
450         assert leaderChecker.leader() == null : leaderChecker.leader();
451         followersChecker.updateFastResponseState(getCurrentTerm(), mode);
452     }
453     void becomeFollower(String method, DiscoveryNode leaderNode) {
454         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
455         assert leaderNode.isMasterEligibleNode() : leaderNode + " became a leader but is not master-eligible";
456         assert mode != Mode.LEADER : "do not switch to follower from leader (should be candidate first)";
457         if (mode == Mode.FOLLOWER &amp;&amp; Optional.of(leaderNode).equals(lastKnownLeader)) {
458             LOGGER.trace("{}: coordinator remaining FOLLOWER of [{}] in term {}",
459                 method, leaderNode, getCurrentTerm());
460         } else {
461             LOGGER.debug("{}: coordinator becoming FOLLOWER of [{}] in term {} (was {}, lastKnownLeader was [{}])",
462                 method, leaderNode, getCurrentTerm(), mode, lastKnownLeader);
463         }
464         final boolean restartLeaderChecker = (mode == Mode.FOLLOWER &amp;&amp; Optional.of(leaderNode).equals(lastKnownLeader)) == false;
465         if (mode != Mode.FOLLOWER) {
466             mode = Mode.FOLLOWER;
467             joinAccumulator.close(mode);
468             joinAccumulator = new JoinHelper.FollowerJoinAccumulator();
469             leaderChecker.setCurrentNodes(DiscoveryNodes.EMPTY_NODES);
470         }
471         lastKnownLeader = Optional.of(leaderNode);
472         peerFinder.deactivate(leaderNode);
473         clusterFormationFailureHelper.stop();
474         closePrevotingAndElectionScheduler();
475         cancelActivePublication("become follower: " + method);
476         preVoteCollector.update(getPreVoteResponse(), leaderNode);
477         if (restartLeaderChecker) {
478             leaderChecker.updateLeader(leaderNode);
479         }
480         followersChecker.clearCurrentNodes();
481         followersChecker.updateFastResponseState(getCurrentTerm(), mode);
482         lagDetector.clearTrackedNodes();
483     }
484     private void cleanMasterService() {
485         masterService.submitStateUpdateTask("clean-up after stepping down as master",
486             new LocalClusterUpdateTask() {
487                 @Override
488                 public void onFailure(String source, Exception e) {
489                     LOGGER.trace("failed to clean-up after stepping down as master", e);
490                 }
491                 @Override
492                 public ClusterTasksResult&lt;LocalClusterUpdateTask&gt; execute(ClusterState currentState) {
493                     if (currentState.nodes().isLocalNodeElectedMaster() == false) {
494                         allocationService.cleanCaches();
495                     }
496                     return unchanged();
497                 }
498             });
499     }
500     private PreVoteResponse getPreVoteResponse() {
501         return new PreVoteResponse(getCurrentTerm(), coordinationState.get().getLastAcceptedTerm(),
502             coordinationState.get().getLastAcceptedState().version());
503     }
504     long getCurrentTerm() {
505         synchronized (mutex) {
506             return coordinationState.get().getCurrentTerm();
507         }
508     }
509     Mode getMode() {
510         synchronized (mutex) {
511             return mode;
512         }
513     }
514     DiscoveryNode getLocalNode() {
515         return transportService.getLocalNode();
516     }
517     boolean publicationInProgress() {
518         synchronized (mutex) {
519             return currentPublication.isPresent();
520         }
521     }
522     @Override
523     protected void doStart() {
524         synchronized (mutex) {
525             CoordinationState.PersistedState persistedState = persistedStateSupplier.get();
526             coordinationState.set(new CoordinationState(settings, getLocalNode(), persistedState));
527             peerFinder.setCurrentTerm(getCurrentTerm());
528             configuredHostsResolver.start();
529             final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState();
530             if (lastAcceptedState.metadata().clusterUUIDCommitted()) {
531                 LOGGER.info("cluster UUID [{}]", lastAcceptedState.metadata().clusterUUID());
532             }
533             final VotingConfiguration votingConfiguration = lastAcceptedState.getLastCommittedConfiguration();
534             if (singleNodeDiscovery &amp;&amp;
535                 votingConfiguration.isEmpty() == false &amp;&amp;
536                 votingConfiguration.hasQuorum(Collections.singleton(getLocalNode().getId())) == false) {
537                 throw new IllegalStateException("cannot start with [" + DiscoveryModule.DISCOVERY_TYPE_SETTING.getKey() + "] set to [" +
538                     DiscoveryModule.SINGLE_NODE_DISCOVERY_TYPE + "] when local node " + getLocalNode() +
539 <a name="4"></a>                    " does not have quorum in voting configuration " + votingConfiguration);
540             }
541             ClusterState initialState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.get(settings))
542                 .blocks(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ClusterBlocks.builder()
543                     .addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)
544                     .addGlobalBlock(noMasterBlockService.getNoMasterBlock()))
545                 .nodes(DiscoveryNodes.builder().add(getLocalNode()).localNodeId(getLocalNode().getId()))
546                 .build();
547             applierState = initialState;
548             clusterApplier.setInitialState</b></font>(initialState);
549         }
550     }
551     @Override
552     public DiscoveryStats stats() {
553         return new DiscoveryStats(new PendingClusterStateStats(0, 0, 0), publicationHandler.stats());
554     }
555     @Override
556     public void startInitialJoin() {
557         synchronized (mutex) {
558             becomeCandidate("startInitialJoin");
559         }
560         clusterBootstrapService.scheduleUnconfiguredBootstrap();
561     }
562     @Override
563     protected void doStop() {
564         configuredHostsResolver.stop();
565     }
566     @Override
567     protected void doClose() throws IOException {
568         final CoordinationState coordinationState = this.coordinationState.get();
569         if (coordinationState != null) {
570             synchronized (mutex) {
571                 coordinationState.close();
572             }
573         }
574     }
575     public void invariant() {
576         synchronized (mutex) {
577             final Optional&lt;DiscoveryNode&gt; peerFinderLeader = peerFinder.getLeader();
578             assert peerFinder.getCurrentTerm() == getCurrentTerm();
579             assert followersChecker.getFastResponseState().term == getCurrentTerm() : followersChecker.getFastResponseState();
580             assert followersChecker.getFastResponseState().mode == getMode() : followersChecker.getFastResponseState();
581             assert (applierState.nodes().getMasterNodeId() == null) == applierState.blocks().hasGlobalBlockWithId(NO_MASTER_BLOCK_ID);
582             assert preVoteCollector.getPreVoteResponse().equals(getPreVoteResponse())
583                 : preVoteCollector + " vs " + getPreVoteResponse();
584             assert lagDetector.getTrackedNodes().contains(getLocalNode()) == false : lagDetector.getTrackedNodes();
585             assert followersChecker.getKnownFollowers().equals(lagDetector.getTrackedNodes())
586                 : followersChecker.getKnownFollowers() + " vs " + lagDetector.getTrackedNodes();
587             if (mode == Mode.LEADER) {
588                 final boolean becomingMaster = getStateForMasterService().term() != getCurrentTerm();
589                 assert coordinationState.get().electionWon();
590                 assert lastKnownLeader.isPresent() &amp;&amp; lastKnownLeader.get().equals(getLocalNode());
591                 assert joinAccumulator instanceof JoinHelper.LeaderJoinAccumulator;
592                 assert peerFinderLeader.equals(lastKnownLeader) : peerFinderLeader;
593                 assert electionScheduler == null : electionScheduler;
594                 assert prevotingRound == null : prevotingRound;
595                 assert becomingMaster || getStateForMasterService().nodes().getMasterNodeId() != null : getStateForMasterService();
596                 assert leaderChecker.leader() == null : leaderChecker.leader();
597                 assert getLocalNode().equals(applierState.nodes().getMasterNode()) ||
598                     (applierState.nodes().getMasterNodeId() == null &amp;&amp; applierState.term() &lt; getCurrentTerm());
599                 assert preVoteCollector.getLeader() == getLocalNode() : preVoteCollector;
600                 assert clusterFormationFailureHelper.isRunning() == false;
601                 final boolean activePublication = currentPublication.map(CoordinatorPublication::isActiveForCurrentLeader).orElse(false);
602                 if (becomingMaster &amp;&amp; activePublication == false) {
603                     assert followersChecker.getKnownFollowers().isEmpty() : followersChecker.getKnownFollowers();
604                 } else {
605                     final ClusterState lastPublishedState;
606                     if (activePublication) {
607                         lastPublishedState = currentPublication.get().publishedState();
608                     } else {
609                         lastPublishedState = coordinationState.get().getLastAcceptedState();
610                     }
611                     final Set&lt;DiscoveryNode&gt; lastPublishedNodes = new HashSet&lt;&gt;();
612                     lastPublishedState.nodes().forEach(lastPublishedNodes::add);
613                     assert lastPublishedNodes.remove(getLocalNode());                     assert lastPublishedNodes.equals(followersChecker.getKnownFollowers()) :
614                         lastPublishedNodes + " != " + followersChecker.getKnownFollowers();
615                 }
616                 assert becomingMaster || activePublication ||
617                     coordinationState.get().getLastAcceptedConfiguration().equals(coordinationState.get().getLastCommittedConfiguration())
618                     : coordinationState.get().getLastAcceptedConfiguration() + " != "
619                     + coordinationState.get().getLastCommittedConfiguration();
620             } else if (mode == Mode.FOLLOWER) {
621                 assert coordinationState.get().electionWon() == false : getLocalNode() + " is FOLLOWER so electionWon() should be false";
622                 assert lastKnownLeader.isPresent() &amp;&amp; (lastKnownLeader.get().equals(getLocalNode()) == false);
623                 assert joinAccumulator instanceof JoinHelper.FollowerJoinAccumulator;
624                 assert peerFinderLeader.equals(lastKnownLeader) : peerFinderLeader;
625                 assert electionScheduler == null : electionScheduler;
626                 assert prevotingRound == null : prevotingRound;
627                 assert getStateForMasterService().nodes().getMasterNodeId() == null : getStateForMasterService();
628                 assert leaderChecker.currentNodeIsMaster() == false;
629                 assert lastKnownLeader.equals(Optional.of(leaderChecker.leader()));
630                 assert followersChecker.getKnownFollowers().isEmpty();
631                 assert lastKnownLeader.get().equals(applierState.nodes().getMasterNode()) ||
632                     (applierState.nodes().getMasterNodeId() == null &amp;&amp;
633                         (applierState.term() &lt; getCurrentTerm() || applierState.version() &lt; getLastAcceptedState().version()));
634                 assert currentPublication.map(Publication::isCommitted).orElse(true);
635                 assert preVoteCollector.getLeader().equals(lastKnownLeader.get()) : preVoteCollector;
636                 assert clusterFormationFailureHelper.isRunning() == false;
637             } else {
638                 assert mode == Mode.CANDIDATE;
639                 assert joinAccumulator instanceof JoinHelper.CandidateJoinAccumulator;
640                 assert peerFinderLeader.isPresent() == false : peerFinderLeader;
641                 assert prevotingRound == null || electionScheduler != null;
642                 assert getStateForMasterService().nodes().getMasterNodeId() == null : getStateForMasterService();
643                 assert leaderChecker.currentNodeIsMaster() == false;
644                 assert leaderChecker.leader() == null : leaderChecker.leader();
645                 assert followersChecker.getKnownFollowers().isEmpty();
646                 assert applierState.nodes().getMasterNodeId() == null;
647                 assert currentPublication.map(Publication::isCommitted).orElse(true);
648                 assert preVoteCollector.getLeader() == null : preVoteCollector;
649                 assert clusterFormationFailureHelper.isRunning();
650             }
651         }
652     }
653     public boolean isInitialConfigurationSet() {
654         return getStateForMasterService().getLastAcceptedConfiguration().isEmpty() == false;
655     }
656     public boolean setInitialConfiguration(final VotingConfiguration votingConfiguration) {
657         synchronized (mutex) {
658             final ClusterState currentState = getStateForMasterService();
659             if (isInitialConfigurationSet()) {
660                 LOGGER.debug("initial configuration already set, ignoring {}", votingConfiguration);
661                 return false;
662             }
663             if (getLocalNode().isMasterEligibleNode() == false) {
664                 LOGGER.debug("skip setting initial configuration as local node is not a master-eligible node");
665                 throw new CoordinationStateRejectedException(
666                     "this node is not master-eligible, but cluster bootstrapping can only happen on a master-eligible node");
667             }
668             if (votingConfiguration.getNodeIds().contains(getLocalNode().getId()) == false) {
669                 LOGGER.debug("skip setting initial configuration as local node is not part of initial configuration");
670                 throw new CoordinationStateRejectedException("local node is not part of initial configuration");
671             }
672             final List&lt;DiscoveryNode&gt; knownNodes = new ArrayList&lt;&gt;();
673             knownNodes.add(getLocalNode());
674             peerFinder.getFoundPeers().forEach(knownNodes::add);
675             if (votingConfiguration.hasQuorum(knownNodes.stream().map(DiscoveryNode::getId).collect(Collectors.toList())) == false) {
676                 LOGGER.debug("skip setting initial configuration as not enough nodes discovered to form a quorum in the " +
677                     "initial configuration [knownNodes={}, {}]", knownNodes, votingConfiguration);
678                 throw new CoordinationStateRejectedException("not enough nodes discovered to form a quorum in the initial configuration " +
679                     "[knownNodes=" + knownNodes + ", " + votingConfiguration + "]");
680 <a name="3"></a>            }
681             LOGGER.info("setting initial configuration to {}", votingConfiguration);
682             final CoordinationMetadata coordinationMetadata = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CoordinationMetadata.builder(currentState.coordinationMetadata())
683                 .lastAcceptedConfiguration(votingConfiguration)
684                 .lastCommittedConfiguration(votingConfiguration)
685                 .build();
686             Metadata.Builder metadataBuilder = Metadata.builder(currentState.metadata());
687             metadataBuilder.generateClusterUuidIfNeeded();             metadataBuilder.coordinationMetadata(coordinationMetadata);
688             coordinationState.get().setInitialState(ClusterState.builder</b></font>(currentState).metadata(metadataBuilder).build());
689             assert localNodeMayWinElection(getLastAcceptedState()) :
690                 "initial state does not allow local node to win election: " + getLastAcceptedState().coordinationMetadata();
691             preVoteCollector.update(getPreVoteResponse(), null);             startElectionScheduler();
692             return true;
693         }
694     }
695     ClusterState improveConfiguration(ClusterState clusterState) {
696         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
697         final Stream&lt;String&gt; excludedNodeIds = clusterState.getVotingConfigExclusions().stream().map(VotingConfigExclusion::getNodeId);
698 <a name="0"></a>                final Stream&lt;String&gt; masterIneligibleNodeIdsInVotingConfig = StreamSupport.stream(clusterState.nodes().spliterator(), false)
699             .filter(n -&gt; n.isMasterEligibleNode() == false
700                 &amp;&amp; (<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>clusterState.getLastAcceptedConfiguration().getNodeIds().contains(n.getId())
701                 || clusterState.getLastCommittedConfiguration().getNodeIds().contains(n.getId())))
702             .map(DiscoveryNode::getId);
703         final Set&lt;DiscoveryNode&gt; liveNodes = StreamSupport.stream(clusterState.nodes().spliterator(), false)
704             .filter(DiscoveryNode::isMasterEligibleNode).filter(coordinationState.get()::containsJoinVoteFor).collect(Collectors.toSet());
705         final VotingConfiguration newConfig = reconfigurator.reconfigure(liveNodes,
706             Stream.concat(masterIneligibleNodeIdsInVotingConfig, excludedNodeIds).collect(Collectors.toSet()),
707             getLocalNode(), clusterState.getLastAcceptedConfiguration</b></font>());
708         if (newConfig.equals(clusterState.getLastAcceptedConfiguration()) == false) {
709             assert coordinationState.get().joinVotesHaveQuorumFor(newConfig);
710             return ClusterState.builder(clusterState).metadata(Metadata.builder(clusterState.metadata())
711                 .coordinationMetadata(CoordinationMetadata.builder(clusterState.coordinationMetadata())
712                     .lastAcceptedConfiguration(newConfig).build())).build();
713         }
714         return clusterState;
715     }
716     private AtomicBoolean reconfigurationTaskScheduled = new AtomicBoolean();
717     private void scheduleReconfigurationIfNeeded() {
718         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
719         assert mode == Mode.LEADER : mode;
720         assert currentPublication.isPresent() == false : "Expected no publication in progress";
721         final ClusterState state = getLastAcceptedState();
722         if (improveConfiguration(state) != state &amp;&amp; reconfigurationTaskScheduled.compareAndSet(false, true)) {
723             LOGGER.trace("scheduling reconfiguration");
724             masterService.submitStateUpdateTask("reconfigure", new ClusterStateUpdateTask(Priority.URGENT) {
725                 @Override
726                 public ClusterState execute(ClusterState currentState) {
727                     reconfigurationTaskScheduled.set(false);
728                     synchronized (mutex) {
729                         return improveConfiguration(currentState);
730                     }
731                 }
732                 @Override
733                 public void onFailure(String source, Exception e) {
734                     reconfigurationTaskScheduled.set(false);
735                     LOGGER.debug("reconfiguration failed", e);
736                 }
737             });
738         }
739     }
740     boolean missingJoinVoteFrom(DiscoveryNode node) {
741         return node.isMasterEligibleNode() &amp;&amp; coordinationState.get().containsJoinVoteFor(node) == false;
742     }
743     private void handleJoin(Join join) {
744         synchronized (mutex) {
745             ensureTermAtLeast(getLocalNode(), join.getTerm()).ifPresent(this::handleJoin);
746             if (coordinationState.get().electionWon()) {
747                 final boolean isNewJoinFromMasterEligibleNode = handleJoinIgnoringExceptions(join);
748                 final boolean establishedAsMaster = mode == Mode.LEADER &amp;&amp; getLastAcceptedState().term() == getCurrentTerm();
749                 if (isNewJoinFromMasterEligibleNode &amp;&amp; establishedAsMaster &amp;&amp; publicationInProgress() == false) {
750                     scheduleReconfigurationIfNeeded();
751                 }
752             } else {
753                 coordinationState.get().handleJoin(join);             }
754         }
755     }
756     private boolean handleJoinIgnoringExceptions(Join join) {
757         try {
758             return coordinationState.get().handleJoin(join);
759         } catch (CoordinationStateRejectedException e) {
760             LOGGER.debug(new ParameterizedMessage("failed to add {} - ignoring", join), e);
761             return false;
762         }
763     }
764     public ClusterState getLastAcceptedState() {
765         synchronized (mutex) {
766             return coordinationState.get().getLastAcceptedState();
767         }
768     }
769     @Nullable
770     public ClusterState getApplierState() {
771         return applierState;
772     }
773     private List&lt;DiscoveryNode&gt; getDiscoveredNodes() {
774         final List&lt;DiscoveryNode&gt; nodes = new ArrayList&lt;&gt;();
775         nodes.add(getLocalNode());
776         peerFinder.getFoundPeers().forEach(nodes::add);
777         return nodes;
778     }
779     ClusterState getStateForMasterService() {
780         synchronized (mutex) {
781             final ClusterState clusterState = coordinationState.get().getLastAcceptedState();
782             if (mode != Mode.LEADER || clusterState.term() != getCurrentTerm()) {
783                 return clusterStateWithNoMasterBlock(clusterState);
784             }
785             return clusterState;
786         }
787     }
788     private ClusterState clusterStateWithNoMasterBlock(ClusterState clusterState) {
789         if (clusterState.nodes().getMasterNodeId() != null) {
790             assert clusterState.blocks().hasGlobalBlockWithId(NO_MASTER_BLOCK_ID) == false :
791                 "NO_MASTER_BLOCK should only be added by Coordinator";
792             final ClusterBlocks clusterBlocks = ClusterBlocks.builder().blocks(clusterState.blocks()).addGlobalBlock(
793                 noMasterBlockService.getNoMasterBlock()).build();
794             final DiscoveryNodes discoveryNodes = new DiscoveryNodes.Builder(clusterState.nodes()).masterNodeId(null).build();
795             return ClusterState.builder(clusterState).blocks(clusterBlocks).nodes(discoveryNodes).build();
796         } else {
797             return clusterState;
798         }
799     }
800     @Override
801     public void publish(ClusterChangedEvent clusterChangedEvent, ActionListener&lt;Void&gt; publishListener, AckListener ackListener) {
802         try {
803             synchronized (mutex) {
804                 if (mode != Mode.LEADER || getCurrentTerm() != clusterChangedEvent.state().term()) {
805                     LOGGER.debug(() -&gt; new ParameterizedMessage("[{}] failed publication as node is no longer master for term {}",
806                         clusterChangedEvent.source(), clusterChangedEvent.state().term()));
807                     publishListener.onFailure(new FailedToCommitClusterStateException("node is no longer master for term " +
808                         clusterChangedEvent.state().term() + " while handling publication"));
809                     return;
810                 }
811                 if (currentPublication.isPresent()) {
812                     assert false : "[" + currentPublication.get() + "] in progress, cannot start new publication";
813                     LOGGER.warn(() -&gt; new ParameterizedMessage("[{}] failed publication as already publication in progress",
814                         clusterChangedEvent.source()));
815                     publishListener.onFailure(new FailedToCommitClusterStateException("publication " + currentPublication.get() +
816                         " already in progress"));
817                     return;
818                 }
819                 assert assertPreviousStateConsistency(clusterChangedEvent);
820                 final ClusterState clusterState = clusterChangedEvent.state();
821                 assert getLocalNode().equals(clusterState.getNodes().get(getLocalNode().getId())) :
822                     getLocalNode() + " should be in published " + clusterState;
823                 final PublicationTransportHandler.PublicationContext publicationContext =
824                     publicationHandler.newPublicationContext(clusterChangedEvent);
825                 final PublishRequest publishRequest = coordinationState.get().handleClientValue(clusterState);
826                 final CoordinatorPublication publication = new CoordinatorPublication(publishRequest, publicationContext,
827                     new ListenableFuture&lt;&gt;(), ackListener, publishListener);
828                 currentPublication = Optional.of(publication);
829                 final DiscoveryNodes publishNodes = publishRequest.getAcceptedState().nodes();
830                 leaderChecker.setCurrentNodes(publishNodes);
831                 followersChecker.setCurrentNodes(publishNodes);
832                 lagDetector.setTrackedNodes(publishNodes);
833                 publication.start(followersChecker.getFaultyNodes());
834             }
835         } catch (Exception e) {
836             LOGGER.debug(() -&gt; new ParameterizedMessage("[{}] publishing failed", clusterChangedEvent.source()), e);
837             publishListener.onFailure(new FailedToCommitClusterStateException("publishing failed", e));
838         }
839     }
840 <a name="2"></a>        private boolean assertPreviousStateConsistency(ClusterChangedEvent event) {
841         assert <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>event.previousState() == coordinationState.get().getLastAcceptedState() ||
842             XContentHelper.convertToMap(
843                 JsonXContent.JSON_XCONTENT, Strings.toString(event.previousState()), false
844             ).equals(
845                 XContentHelper.convertToMap(
846                     JsonXContent.JSON_XCONTENT,
847                     Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState())),
848                     false))
849             : Strings.toString(event.previousState()) + " vs "
850             + Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState</b></font>()));
851         return true;
852     }
853     private &lt;T&gt; ActionListener&lt;T&gt; wrapWithMutex(ActionListener&lt;T&gt; listener) {
854         return new ActionListener&lt;T&gt;() {
855             @Override
856             public void onResponse(T t) {
857                 synchronized (mutex) {
858                     listener.onResponse(t);
859                 }
860             }
861             @Override
862             public void onFailure(Exception e) {
863                 synchronized (mutex) {
864                     listener.onFailure(e);
865                 }
866             }
867         };
868     }
869     private void cancelActivePublication(String reason) {
870         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
871         if (currentPublication.isPresent()) {
872             currentPublication.get().cancel(reason);
873         }
874     }
875     public Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; getOnJoinValidators() {
876         return onJoinValidators;
877     }
878     public enum Mode {
879         CANDIDATE, LEADER, FOLLOWER
880     }
881     private class CoordinatorPeerFinder extends PeerFinder {
882         CoordinatorPeerFinder(Settings settings, TransportService transportService, TransportAddressConnector transportAddressConnector,
883                               ConfiguredHostsResolver configuredHostsResolver) {
884             super(settings, transportService, transportAddressConnector,
885                 singleNodeDiscovery ? hostsResolver -&gt; Collections.emptyList() : configuredHostsResolver);
886         }
887         @Override
888         protected void onActiveMasterFound(DiscoveryNode masterNode, long term) {
889             synchronized (mutex) {
890                 ensureTermAtLeast(masterNode, term);
891                 joinHelper.sendJoinRequest(masterNode, joinWithDestination(lastJoin, masterNode, term));
892             }
893         }
894         @Override
895         protected void startProbe(TransportAddress transportAddress) {
896             if (singleNodeDiscovery == false) {
897                 super.startProbe(transportAddress);
898             }
899         }
900         @Override
901         protected void onFoundPeersUpdated() {
902             synchronized (mutex) {
903                 final Iterable&lt;DiscoveryNode&gt; foundPeers = getFoundPeers();
904                 if (mode == Mode.CANDIDATE) {
905                     final CoordinationState.VoteCollection expectedVotes = new CoordinationState.VoteCollection();
906                     foundPeers.forEach(expectedVotes::addVote);
907                     expectedVotes.addVote(Coordinator.this.getLocalNode());
908                     final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState();
909                     final boolean foundQuorum = CoordinationState.isElectionQuorum(expectedVotes, lastAcceptedState);
910                     if (foundQuorum) {
911                         if (electionScheduler == null) {
912                             startElectionScheduler();
913                         }
914                     } else {
915                         closePrevotingAndElectionScheduler();
916                     }
917                 }
918             }
919             clusterBootstrapService.onFoundPeersUpdated();
920         }
921     }
922     private void startElectionScheduler() {
923         assert electionScheduler == null : electionScheduler;
924         if (getLocalNode().isMasterEligibleNode() == false) {
925             return;
926         }
927         final TimeValue gracePeriod = TimeValue.ZERO;         electionScheduler = electionSchedulerFactory.startElectionScheduler(gracePeriod, new Runnable() {
928             @Override
929             public void run() {
930                 synchronized (mutex) {
931                     if (mode == Mode.CANDIDATE) {
932                         final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState();
933                         if (localNodeMayWinElection(lastAcceptedState) == false) {
934                             LOGGER.trace("skip prevoting as local node may not win election: {}",
935                                 lastAcceptedState.coordinationMetadata());
936                             return;
937                         }
938                         if (prevotingRound != null) {
939                             prevotingRound.close();
940                         }
941                         prevotingRound = preVoteCollector.start(lastAcceptedState, getDiscoveredNodes());
942                     }
943                 }
944             }
945             @Override
946             public String toString() {
947                 return "scheduling of new prevoting round";
948             }
949         });
950     }
951     public Iterable&lt;DiscoveryNode&gt; getFoundPeers() {
952         return peerFinder.getFoundPeers();
953     }
954     boolean cancelCommittedPublication() {
955         synchronized (mutex) {
956             if (currentPublication.isPresent()) {
957                 final CoordinatorPublication publication = currentPublication.get();
958                 if (publication.isCommitted()) {
959                     publication.cancel("cancelCommittedPublication");
960                     LOGGER.debug("Cancelled publication of [{}].", publication);
961                     return true;
962                 }
963             }
964             return false;
965         }
966     }
967     class CoordinatorPublication extends Publication {
968         private final PublishRequest publishRequest;
969         private final ListenableFuture&lt;Void&gt; localNodeAckEvent;
970         private final AckListener ackListener;
971         private final ActionListener&lt;Void&gt; publishListener;
972         private final PublicationTransportHandler.PublicationContext publicationContext;
973         private final Scheduler.ScheduledCancellable timeoutHandler;
974         private final Scheduler.Cancellable infoTimeoutHandler;
975         private final List&lt;Join&gt; receivedJoins = new ArrayList&lt;&gt;();
976         private boolean receivedJoinsProcessed;
977         CoordinatorPublication(PublishRequest publishRequest, PublicationTransportHandler.PublicationContext publicationContext,
978                                ListenableFuture&lt;Void&gt; localNodeAckEvent, AckListener ackListener, ActionListener&lt;Void&gt; publishListener) {
979             super(publishRequest,
980                 new AckListener() {
981                     @Override
982                     public void onCommit(TimeValue commitTime) {
983                         ackListener.onCommit(commitTime);
984                     }
985                     @Override
986                     public void onNodeAck(DiscoveryNode node, Exception e) {
987                         if (node.equals(getLocalNode())) {
988                             synchronized (mutex) {
989                                 if (e == null) {
990                                     localNodeAckEvent.onResponse(null);
991                                 } else {
992                                     localNodeAckEvent.onFailure(e);
993                                 }
994                             }
995                         } else {
996                             ackListener.onNodeAck(node, e);
997                             if (e == null) {
998                                 lagDetector.setAppliedVersion(node, publishRequest.getAcceptedState().version());
999                             }
1000                         }
1001                     }
1002                 },
1003                 transportService.getThreadPool()::relativeTimeInMillis);
1004             this.publishRequest = publishRequest;
1005             this.publicationContext = publicationContext;
1006             this.localNodeAckEvent = localNodeAckEvent;
1007             this.ackListener = ackListener;
1008             this.publishListener = publishListener;
1009             this.timeoutHandler = transportService.getThreadPool().schedule(new Runnable() {
1010                 @Override
1011                 public void run() {
1012                     synchronized (mutex) {
1013                         cancel("timed out after " + publishTimeout);
1014                     }
1015                 }
1016                 @Override
1017                 public String toString() {
1018                     return "scheduled timeout for " + this;
1019                 }
1020             }, publishTimeout, Names.GENERIC);
1021             this.infoTimeoutHandler = transportService.getThreadPool().schedule(new Runnable() {
1022                 @Override
1023                 public void run() {
1024                     synchronized (mutex) {
1025                         logIncompleteNodes(Level.INFO);
1026                     }
1027                 }
1028                 @Override
1029                 public String toString() {
1030                     return "scheduled timeout for reporting on " + CoordinatorPublication.this;
1031                 }
1032             }, publishInfoTimeout, Names.GENERIC);
1033         }
1034         private void removePublicationAndPossiblyBecomeCandidate(String reason) {
1035             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1036             assert currentPublication.get() == this;
1037             currentPublication = Optional.empty();
1038             logger.debug("publication ended unsuccessfully: {}", this);
1039             if (isActiveForCurrentLeader()) {
1040                 becomeCandidate(reason);
1041             }
1042         }
1043         boolean isActiveForCurrentLeader() {
1044             return mode == Mode.LEADER &amp;&amp; publishRequest.getAcceptedState().term() == getCurrentTerm();
1045         }
1046         @Override
1047         protected void onCompletion(boolean committed) {
1048             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1049             localNodeAckEvent.addListener(new ActionListener&lt;Void&gt;() {
1050                 @Override
1051                 public void onResponse(Void ignore) {
1052                     assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1053                     assert committed;
1054                     receivedJoins.forEach(CoordinatorPublication.this::handleAssociatedJoin);
1055                     assert receivedJoinsProcessed == false;
1056                     receivedJoinsProcessed = true;
1057                     clusterApplier.onNewClusterState(CoordinatorPublication.this.toString(), () -&gt; applierState,
1058                         new ClusterApplyListener() {
1059                             @Override
1060                             public void onFailure(String source, Exception e) {
1061                                 synchronized (mutex) {
1062                                     removePublicationAndPossiblyBecomeCandidate("clusterApplier#onNewClusterState");
1063                                 }
1064                                 timeoutHandler.cancel();
1065                                 infoTimeoutHandler.cancel();
1066                                 ackListener.onNodeAck(getLocalNode(), e);
1067                                 publishListener.onFailure(e);
1068                             }
1069                             @Override
1070                             public void onSuccess(String source) {
1071                                 synchronized (mutex) {
1072                                     assert currentPublication.get() == CoordinatorPublication.this;
1073                                     currentPublication = Optional.empty();
1074                                     logger.debug("publication ended successfully: {}", CoordinatorPublication.this);
1075                                     updateMaxTermSeen(getCurrentTerm());
1076                                     if (mode == Mode.LEADER) {
1077                                         boolean attemptReconfiguration = true;
1078                                         final ClusterState state = getLastAcceptedState();                                         if (localNodeMayWinElection(state) == false) {
1079                                             final List&lt;DiscoveryNode&gt; masterCandidates = completedNodes().stream()
1080                                                 .filter(DiscoveryNode::isMasterEligibleNode)
1081                                                 .filter(node -&gt; nodeMayWinElection(state, node))
1082                                                 .collect(Collectors.toList());
1083                                             if (masterCandidates.isEmpty() == false) {
1084                                                 abdicateTo(masterCandidates.get(random.nextInt(masterCandidates.size())));
1085                                                 attemptReconfiguration = false;
1086                                             }
1087                                         }
1088                                         if (attemptReconfiguration) {
1089                                             scheduleReconfigurationIfNeeded();
1090                                         }
1091                                     }
1092                                     lagDetector.startLagDetector(publishRequest.getAcceptedState().version());
1093                                     logIncompleteNodes(Level.WARN);
1094                                 }
1095                                 timeoutHandler.cancel();
1096                                 infoTimeoutHandler.cancel();
1097                                 ackListener.onNodeAck(getLocalNode(), null);
1098                                 publishListener.onResponse(null);
1099                             }
1100                         });
1101                 }
1102                 @Override
1103                 public void onFailure(Exception e) {
1104                     assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1105                     removePublicationAndPossiblyBecomeCandidate("Publication.onCompletion(false)");
1106                     timeoutHandler.cancel();
1107                     infoTimeoutHandler.cancel();
1108                     final FailedToCommitClusterStateException exception = new FailedToCommitClusterStateException("publication failed", e);
1109                     ackListener.onNodeAck(getLocalNode(), exception);                     publishListener.onFailure(exception);
1110                 }
1111             }, EsExecutors.directExecutor());
1112         }
1113         private void handleAssociatedJoin(Join join) {
1114             if (join.getTerm() == getCurrentTerm() &amp;&amp; missingJoinVoteFrom(join.getSourceNode())) {
1115                 logger.trace("handling {}", join);
1116                 handleJoin(join);
1117             }
1118         }
1119         @Override
1120         protected boolean isPublishQuorum(CoordinationState.VoteCollection votes) {
1121             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1122             return coordinationState.get().isPublishQuorum(votes);
1123         }
1124         @Override
1125         protected Optional&lt;ApplyCommitRequest&gt; handlePublishResponse(DiscoveryNode sourceNode,
1126                                                                      PublishResponse publishResponse) {
1127             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1128             assert getCurrentTerm() &gt;= publishResponse.getTerm();
1129             return coordinationState.get().handlePublishResponse(sourceNode, publishResponse);
1130         }
1131         @Override
1132         protected void onJoin(Join join) {
1133             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1134             if (receivedJoinsProcessed) {
1135                 handleAssociatedJoin(join);
1136             } else {
1137                 receivedJoins.add(join);
1138             }
1139         }
1140         @Override
1141         protected void onMissingJoin(DiscoveryNode discoveryNode) {
1142             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1143             if (missingJoinVoteFrom(discoveryNode)) {
1144                 final long term = publishRequest.getAcceptedState().term();
1145                 logger.debug("onMissingJoin: no join vote from {}, bumping term to exceed {}", discoveryNode, term);
1146                 updateMaxTermSeen(term + 1);
1147             }
1148         }
1149         @Override
1150         protected void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest,
1151                                           ActionListener&lt;PublishWithJoinResponse&gt; responseActionListener) {
1152             publicationContext.sendPublishRequest(destination, publishRequest, wrapWithMutex(responseActionListener));
1153         }
1154         @Override
1155         protected void sendApplyCommit(DiscoveryNode destination, ApplyCommitRequest applyCommit,
1156                                        ActionListener&lt;Empty&gt; responseActionListener) {
1157             publicationContext.sendApplyCommit(destination, applyCommit, wrapWithMutex(responseActionListener));
1158         }
1159     }
1160 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
