<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for JavaScriptLanguage.java & AlterTableAddColumnAnalyzerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for JavaScriptLanguage.java & AlterTableAddColumnAnalyzerTest.java
      </h3>
      <h1 align="center">
        10.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>JavaScriptLanguage.java (46.728973%)<TH>AlterTableAddColumnAnalyzerTest.java (5.827506%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2134245-0.html#0',2,'match2134245-1.html#0',3)" NAME="0">(24-46)<TD><A HREF="javascript:ZweiFrames('match2134245-0.html#0',2,'match2134245-1.html#0',3)" NAME="0">(31-54)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2134245-0.html#1',2,'match2134245-1.html#1',3)" NAME="1">(74-81)<TD><A HREF="javascript:ZweiFrames('match2134245-0.html#1',2,'match2134245-1.html#1',3)" NAME="1">(346-349)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2134245-0.html#2',2,'match2134245-1.html#2',3)" NAME="2">(48-53)<TD><A HREF="javascript:ZweiFrames('match2134245-0.html#2',2,'match2134245-1.html#2',3)" NAME="2">(224-228)</A><TD ALIGN=center><FONT COLOR="#7f0000">10</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2134245-0.html#3',2,'match2134245-1.html#3',3)" NAME="3">(85-90)<TD><A HREF="javascript:ZweiFrames('match2134245-0.html#3',2,'match2134245-1.html#3',3)" NAME="3">(265-269)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>JavaScriptLanguage.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.operation.language;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2134245-1.html#0',3,'match2134245-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.expression.udf.UDFLanguage;
import io.crate.expression.udf.UserDefinedFunctionMetadata;
import io.crate.expression.udf.UserDefinedFunctionService;
import io.crate.metadata.Scalar;
import io.crate.metadata.functions.Signature;
import io.crate.types.DataType;
import org.elasticsearch.common.inject.Inject;
import org.graalvm.polyglot.Context;
import org.graalvm.polyglot.Engine;
import org.graalvm.polyglot.HostAccess;
import org.graalvm.polyglot.PolyglotException;
import org.graalvm.polyglot.Source;
import org.graalvm.polyglot.Value;

import javax.annotation.Nullable;
import javax.script.ScriptException;
import java.io.IOException;
import java.util.Locale;
import java.util.stream.Collectors;

public class JavaScriptLanguage implements UDFLanguage {
<A NAME="2"></A>
    static final String NAME = &quot;javascript&quot;</B></FONT>;

    <FONT color="#980517"><A HREF="javascript:ZweiFrames('match2134245-1.html#2',3,'match2134245-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>private static final Engine ENGINE = Engine.newBuilder()
        .option(&quot;js.foreign-object-prototype&quot;, &quot;true&quot;)
        .option(&quot;engine.WarnInterpreterOnly&quot;, &quot;false&quot;)
        .build();

    private static final HostAccess HOST_ACCESS = HostAccess.newBuilder</B></FONT>()
        .allowListAccess(true)
        .allowArrayAccess(true)
        .build();

    @Inject
    public JavaScriptLanguage(UserDefinedFunctionService udfService) {
        udfService.registerLanguage(this);
    }

    public Scalar createFunctionImplementation(UserDefinedFunctionMetadata meta,
                                               Signature signature) throws ScriptException {
        return new JavaScriptUserDefinedFunction(signature, meta.definition());
    }

    @Nullable
    public String validate(UserDefinedFunctionMetadata meta) {
        try {
<A NAME="1"></A>            resolvePolyglotFunctionValue(meta.name(), meta.definition());
            return null;
        } catch (IllegalArgumentException | IOException | PolyglotException t) {
            return <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2134245-1.html#1',3,'match2134245-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>String.format(Locale.ENGLISH, &quot;Invalid JavaScript in function '%s.%s(%s)' AS '%s': %s&quot;,
                meta.schema(),
                meta.name(),
                meta.argumentTypes().stream().map(DataType::getName).collect(Collectors.joining(&quot;, &quot;)),
                meta.definition(),
                t.getMessage()
            );
        }</B></FONT>
<A NAME="3"></A>    }

    static Value resolvePolyglotFunctionValue(String functionName, String script) throws IOException {
        <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2134245-1.html#3',3,'match2134245-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>var context = Context.newBuilder(&quot;js&quot;)
            .engine(ENGINE)
            .allowHostAccess(HOST_ACCESS)
            .build();
        var source = Source.newBuilder(&quot;js&quot;, script, functionName).build();
        context.eval</B></FONT>(source);
        var polyglotFunctionValue = context.getBindings(&quot;js&quot;).getMember(functionName);
        if (polyglotFunctionValue == null) {
            throw new IllegalArgumentException(
                &quot;The name of the function signature '&quot; + functionName + &quot;' doesn't match &quot; +
                &quot;the function name in the function definition.&quot;);
        }
        return polyglotFunctionValue;
    }

    public String name() {
        return NAME;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AlterTableAddColumnAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.analyze;

import static io.crate.testing.TestingHelpers.mapToSortedString;
import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.core.IsEqual.equalTo;
<A NAME="0"></A>
import java.util.Arrays;
import java.util.Collection;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2134245-0.html#0',2,'match2134245-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.List;
import java.util.Map;
import java.util.Set;

import org.hamcrest.Matchers;
import org.junit.Test;

import io.crate.common.collections.Maps;
import io.crate.data.Row;
import io.crate.exceptions.OperationOnInaccessibleRelationException;
import io.crate.metadata.ColumnIdent;
import io.crate.planner.PlannerContext;
import io.crate.planner.node.ddl.AlterTableAddColumnPlan;
import io.crate.planner.operators.SubQueryResults;
import io.crate.sql.parser.ParsingException;
import io.crate.sql.tree.ColumnPolicy;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.types.DataTypes;
import io.crate.types.ObjectType;

public class AlterTableAddColumnAnalyzerTest extends CrateDummyClusterServiceUnitTest {

    private SQLExecutor e</B></FONT>;

    private BoundAddColumn analyze(String stmt) {
        PlannerContext plannerContext = e.getPlannerContext(clusterService.state());
        return AlterTableAddColumnPlan.bind(
            e.analyze(stmt),
            plannerContext.transactionContext(),
            plannerContext.nodeContext(),
            Row.EMPTY,
            SubQueryResults.EMPTY,
            e.fulltextAnalyzerResolver()
        );
    }

    @Test
    public void test_can_add_column_to_table_with_multiple_nested_pks() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table nested_pks (&quot; +
                      &quot;     pk object as (a int, b object as (c int)),&quot; +
                      &quot;     primary key (pk['a'], pk['b']['c'])&quot; +
                      &quot;)&quot;)
            .build();
        BoundAddColumn boundAddColumn = analyze(&quot;alter table nested_pks add x int&quot;);
        assertThat(
            boundAddColumn.mapping().toString(),
            is(&quot;{_meta={primary_keys=[pk.a, pk.b.c]}, &quot; +
               &quot;properties={&quot; +
                    &quot;x={position=2, type=integer}, &quot; +
                    &quot;pk={dynamic=true, type=object, properties={a={type=integer}, b={dynamic=true, type=object, properties={c={type=integer}}}}}}}&quot;)
        );
    }

    @Test
    public void testAddColumnOnSystemTableIsNotAllowed() throws Exception {
        e = SQLExecutor.builder(clusterService).build();

        expectedException.expect(OperationOnInaccessibleRelationException.class);
        expectedException.expectMessage(&quot;The relation \&quot;sys.shards\&quot; doesn't support or allow ALTER &quot; +
                                        &quot;operations, as it is read-only.&quot;);
        e.analyze(&quot;alter table sys.shards add column foobar string&quot;);
    }

    @Test
    public void testAddColumnOnSinglePartitionNotAllowed() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addPartitionedTable(
                TableDefinitions.TEST_PARTITIONED_TABLE_DEFINITION,
                TableDefinitions.TEST_PARTITIONED_TABLE_PARTITIONS)
            .build();

        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;Adding a column to a single partition is not supported&quot;);
        e.analyze(&quot;alter table parted partition (date = 1395874800000) add column foobar string&quot;);
    }

    @Test
    public void testAddColumnWithAnalyzerAndNonStringType() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (name text)&quot;)
            .build();

        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(
            &quot;Can't use an Analyzer on column foobar['age'] because analyzers are only allowed &quot; +
            &quot;on columns of type \&quot;&quot; + DataTypes.STRING.getName() + &quot;\&quot; of the unbound length limit&quot;);
        analyze(&quot;alter table users add column foobar object as (age int index using fulltext)&quot;);
    }

    @Test
    public void testAddFulltextIndex() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (name text)&quot;)
            .build();

        expectedException.expect(ParsingException.class);
        e.analyze(&quot;alter table users add column index ft_foo using fulltext (name)&quot;);
    }

    @Test
    public void testAddColumnThatExistsAlready() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (name text)&quot;)
            .build();

        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;The table doc.users already has a column named name&quot;);
        analyze(&quot;alter table users add column name string&quot;);
    }

    @Test
    public void testAddColumnToATableWithoutPrimaryKey() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint, name text) clustered by (id)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column foobar string&quot;);
        Map&lt;String, Object&gt; mapping = analysis.mapping();

        Object primaryKeys = ((Map) mapping.get(&quot;_meta&quot;)).get(&quot;primary_keys&quot;);
        assertNull(primaryKeys); // _id shouldn't be included
    }

    @Test
    public void testAddColumnAsPrimaryKey() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column additional_pk string primary key&quot;);

        assertThat(AnalyzedTableElements.primaryKeys(analysis.analyzedTableElements()), Matchers.contains(
            &quot;additional_pk&quot;, &quot;id&quot;
        ));

        AnalyzedColumnDefinition&lt;Object&gt; idColumn = null;
        AnalyzedColumnDefinition&lt;Object&gt; additionalPkColumn = null;
        for (AnalyzedColumnDefinition&lt;Object&gt; column : analysis.analyzedTableElements().columns()) {
            if (column.name().equals(&quot;id&quot;)) {
                idColumn = column;
            } else {
                additionalPkColumn = column;
            }
        }
        assertNotNull(idColumn);
        assertThat(idColumn.ident(), equalTo(new ColumnIdent(&quot;id&quot;)));
        assertThat(idColumn.dataType(), equalTo(DataTypes.LONG));

        assertNotNull(additionalPkColumn);
        assertThat(additionalPkColumn.ident(), equalTo(new ColumnIdent(&quot;additional_pk&quot;)));
        assertThat(additionalPkColumn.dataType(), equalTo(DataTypes.STRING));
    }

    @Test
    public void testAddPrimaryKeyColumnWithArrayTypeUnsupported() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();

        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;Cannot use columns of type \&quot;array\&quot; as primary key&quot;);
        analyze(&quot;alter table users add column newpk array(string) primary key&quot;);
    }

    @Test
    public void testAddColumnToATableWithNotNull() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint, name text) clustered by (id)&quot;)
            .build();

        BoundAddColumn analysis = analyze(
            &quot;alter table users add column notnullcol string not null&quot;);
        Map&lt;String, Object&gt; mapping = analysis.mapping();

        assertThat((String) ((Set) ((Map) ((Map) mapping.get(&quot;_meta&quot;)).get(&quot;constraints&quot;)).get(&quot;not_null&quot;))
            .toArray(new String[0])[0], is(&quot;notnullcol&quot;));
    }

    @Test
    public void testAddArrayColumn() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();

        BoundAddColumn analysis = analyze(&quot;alter table users add newtags array(string)&quot;);
        AnalyzedColumnDefinition&lt;Object&gt; columnDefinition = analysis.analyzedTableElements().columns().get(0);
        assertThat(columnDefinition.name(), Matchers.equalTo(&quot;newtags&quot;));
        assertThat(columnDefinition.dataType(), Matchers.equalTo(DataTypes.STRING));
<A NAME="2"></A>        assertTrue(columnDefinition.isArrayOrInArray());

        Map&lt;String, Object&gt; mappingProperties = (Map) analysis.mapping().get(&quot;properties&quot;);
        <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2134245-0.html#2',2,'match2134245-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Map&lt;String, Object&gt; newtags = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;newtags&quot;);

        assertThat((String) newtags.get(&quot;type&quot;), is(&quot;array&quot;));
        Map&lt;String, Object&gt; inner = (Map&lt;String, Object&gt;) newtags.get(&quot;inner&quot;);
        assertThat((String) inner.get(&quot;type&quot;), is</B></FONT>(&quot;keyword&quot;));
    }

    public void testAddObjectColumnWithUnderscore() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();
        BoundAddColumn analysis = analyze(&quot;alter table users add column foo['_x'] int&quot;);

        assertThat(analysis.analyzedTableElements().columns().size(), is(2)); // id pk column is also added
        AnalyzedColumnDefinition&lt;Object&gt; column = analysis.analyzedTableElements().columns().get(0);
        assertThat(column.ident(), Matchers.equalTo(new ColumnIdent(&quot;foo&quot;)));
        assertThat(column.children().size(), is(1));
        AnalyzedColumnDefinition&lt;Object&gt; xColumn = column.children().get(0);
        assertThat(xColumn.ident(), Matchers.equalTo(new ColumnIdent(&quot;foo&quot;, Arrays.asList(&quot;_x&quot;))));
    }

    @Test
    public void testAddNewNestedObjectColumn() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column foo['x']['y'] string&quot;);

        assertThat(analysis.analyzedTableElements().columns().size(), is(2)); // id pk column is also added
        AnalyzedColumnDefinition&lt;Object&gt; column = analysis.analyzedTableElements().columns().get(0);
        assertThat(column.ident(), Matchers.equalTo(new ColumnIdent(&quot;foo&quot;)));
        assertThat(column.children().size(), is(1));
        AnalyzedColumnDefinition&lt;Object&gt; xColumn = column.children().get(0);
        assertThat(xColumn.ident(), Matchers.equalTo(new ColumnIdent(&quot;foo&quot;, Arrays.asList(&quot;x&quot;))));
        assertThat(xColumn.children().size(), is(1));
        AnalyzedColumnDefinition&lt;Object&gt; yColumn = xColumn.children().get(0);
        assertThat(yColumn.ident(), Matchers.equalTo(new ColumnIdent(&quot;foo&quot;, Arrays.asList(&quot;x&quot;, &quot;y&quot;))));
<A NAME="3"></A>        assertThat(yColumn.children().size(), is(0));

        Map&lt;String, Object&gt; mapping = analysis.mapping();
        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2134245-0.html#3',2,'match2134245-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Map foo = (Map) Maps.getByPath(mapping, &quot;properties.foo&quot;);
        assertThat((String) foo.get(&quot;type&quot;), is(&quot;object&quot;));

        Map x = (Map) Maps.getByPath(mapping, &quot;properties.foo.properties.x&quot;);
        assertThat((String) x.get</B></FONT>(&quot;type&quot;), is(&quot;object&quot;));

        Map y = (Map) Maps.getByPath(mapping, &quot;properties.foo.properties.x.properties.y&quot;);
        assertThat((String) y.get(&quot;type&quot;), is(&quot;keyword&quot;));
    }

    @Test
    public void testAddNewNestedColumnToObjectArray() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;&quot;&quot;
                create table users (
                    id bigint primary key,
                    friends array(object as (
                        id long,
                        groups array(string)
                    ))
                )
            &quot;&quot;&quot;)
            .build();
        BoundAddColumn analysis = analyze(&quot;alter table users add friends['is_nice'] BOOLEAN&quot;);

        List&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; columns = analysis.analyzedTableElements().columns();
        assertThat(columns.size(), is(2)); // second one is primary key
        AnalyzedColumnDefinition&lt;Object&gt; friends = columns.get(0);
        assertThat(mapToSortedString(AnalyzedColumnDefinition.toMapping(friends)), is(&quot;inner={&quot; +
                                                                &quot;dynamic=true, &quot; +
                                                                &quot;position=2, &quot; +
                                                                &quot;properties={&quot; +
                                                                    &quot;is_nice={&quot; +
                                                                      &quot;position=3, &quot; +
                                                                      &quot;type=boolean&quot; +
                                                                    &quot;}&quot; +
                                                                &quot;}, &quot; +
                                                                &quot;type=object&quot; +
                                                              &quot;}, type=array&quot;));
    }

    @Test
    public void testAddColumnToObjectTypeMaintainsObjectPolicy() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;&quot;&quot;
                create table users (
                    id bigint primary key,
                    address object (strict) as (
                        postcode text
                    )
                )
            &quot;&quot;&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column address['street'] string&quot;);
        List&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; columns = analysis.analyzedTableElements().columns();
        assertThat(columns.size(), is(2));

        AnalyzedColumnDefinition&lt;Object&gt; address = columns.get(0);
        assertThat(address.objectType, is(ColumnPolicy.STRICT));
    }

    @Test
    public void testAddColumnToStrictObject() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;&quot;&quot;
                create table users (
                    id bigint primary key,
                    address object (strict) as (
                        postcode text
                    )
                )
            &quot;&quot;&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column address['street'] string&quot;);
        List&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; columns = analysis.analyzedTableElements().columns();
        assertThat(columns.size(), is(2));
<A NAME="1"></A>
        AnalyzedColumnDefinition&lt;Object&gt; address = columns.get(0);
        AnalyzedColumnDefinition&lt;Object&gt; street = address.children().get(0);
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2134245-0.html#1',2,'match2134245-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(street.ident(), is(ColumnIdent.fromPath(&quot;address.street&quot;)));
        assertThat(street.dataType(), is(DataTypes.STRING));
        assertThat(street.isParentColumn(), is(false));
    }</B></FONT>

    @Test
    public void testAddNewNestedColumnToObjectColumn() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, details object)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column details['foo'] object as (score float, name string)&quot;);
        List&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; columns = analysis.analyzedTableElements().columns();
        assertThat(columns.size(), is(2)); // second one is primary key

        AnalyzedColumnDefinition&lt;Object&gt; details = columns.get(0);
        assertThat(details.ident(), is(ColumnIdent.fromPath(&quot;details&quot;)));
        assertThat(details.dataType().id(), is(ObjectType.ID));
        assertThat(details.isParentColumn(), is(true));
        assertThat(details.children().size(), is(1));

        AnalyzedColumnDefinition&lt;Object&gt; foo = details.children().get(0);
        assertThat(foo.ident(), is(ColumnIdent.fromPath(&quot;details.foo&quot;)));
        assertThat(foo.dataType().id(), is(ObjectType.ID));
        assertThat(foo.isParentColumn(), is(false));

        assertThat(columns.get(0).children().get(0).children().size(), is(2));

        AnalyzedColumnDefinition&lt;Object&gt; score = columns.get(0).children().get(0).children().get(0);
        assertThat(score.ident(), is(ColumnIdent.fromPath(&quot;details.foo.score&quot;)));
        assertThat(score.dataType(), is(DataTypes.FLOAT));

        AnalyzedColumnDefinition name = columns.get(0).children().get(0).children().get(1);
        assertThat(name.ident(), is(ColumnIdent.fromPath(&quot;details.foo.name&quot;)));
        assertThat(name.dataType(), is(DataTypes.STRING));

        Map&lt;String, Object&gt; mapping = analysis.mapping();
        assertThat(mapToSortedString(mapping),
            is(&quot;_meta={primary_keys=[id]}, &quot; +
               &quot;properties={details={dynamic=true, position=2,&quot; +
               &quot; properties={foo={dynamic=true, position=3,&quot; +
               &quot; properties={name={position=5, type=keyword}, score={position=4, type=float}}, type=object}},&quot; +
               &quot; type=object}, &quot; +
               &quot;id={type=long}}&quot;));
    }

    @Test
    public void testAddNewNestedColumnWithArrayToRoot() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column new_obj_col object as (a array(long))&quot;);
        List&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; columns = analysis.analyzedTableElements().columns();
        assertThat(columns.size(), is(2)); // second one is primary key
        assertThat(columns.get(0).dataType().id(), is(ObjectType.ID));
        assertThat(columns.get(0).children().get(0).dataType(), is(DataTypes.LONG));
        assertTrue(columns.get(0).children().get(0).isArrayOrInArray());
    }

    @Test
    public void testAddNewNestedColumnWithArrayToObjectColumn() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column new_obj_col object as (o object as (b array(long)))&quot;);
        List&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; columns = analysis.analyzedTableElements().columns();
        assertThat(columns.size(), is(2)); // second one is primary key
        assertThat(columns.get(0).children().get(0).dataType().id(), is(ObjectType.ID));
        assertThat(columns.get(0).children().get(0).children().get(0).dataType(), is(DataTypes.LONG));
        assertTrue(columns.get(0).children().get(0).children().get(0).isArrayOrInArray());
    }

    @Test
    public void testAddNewNestedColumnToNestedObjectColumn() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(TableDefinitions.DEEPLY_NESTED_TABLE_DEFINITION)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table deeply_nested add column details['stuff']['foo'] object as (score float, price string)&quot;);
        List&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; columns = analysis.analyzedTableElements().columns();
        assertThat(columns.size(), is(1));
        assertThat(columns.get(0).ident(), is(ColumnIdent.fromPath(&quot;details&quot;)));
        assertThat(columns.get(0).dataType().id(), is(ObjectType.ID));
        assertThat(columns.get(0).isParentColumn(), is(true));
        assertThat(columns.get(0).children().size(), is(1));

        AnalyzedColumnDefinition&lt;Object&gt; stuff = columns.get(0).children().get(0);
        assertThat(stuff.ident(), is(ColumnIdent.fromPath(&quot;details.stuff&quot;)));
        assertThat(stuff.dataType().id(), is(ObjectType.ID));
        assertThat(stuff.isParentColumn(), is(true));
        assertThat(stuff.children().size(), is(1));

        AnalyzedColumnDefinition&lt;Object&gt; foo = stuff.children().get(0);
        assertThat(foo.ident(), is(ColumnIdent.fromPath(&quot;details.stuff.foo&quot;)));
        assertThat(foo.dataType().id(), is(ObjectType.ID));
        assertThat(foo.isParentColumn(), is(false));
        assertThat(foo.children().size(), is(2));

        AnalyzedColumnDefinition&lt;Object&gt; score = foo.children().get(0);
        assertThat(score.ident(), is(ColumnIdent.fromPath(&quot;details.stuff.foo.score&quot;)));
        assertThat(score.dataType(), is(DataTypes.FLOAT));

        AnalyzedColumnDefinition&lt;Object&gt; price = foo.children().get(1);
        assertThat(price.ident(), is(ColumnIdent.fromPath(&quot;details.stuff.foo.price&quot;)));
        assertThat(price.dataType(), is(DataTypes.STRING));

        Map&lt;String, Object&gt; mapping = analysis.mapping();
        assertThat(mapToSortedString(mapping),
            is(&quot;_meta={}, properties={details={dynamic=true, position=1, &quot; +
               &quot;properties={stuff={dynamic=true, position=3, properties={foo={dynamic=true, position=5, &quot; +
               &quot;properties={price={position=7, type=keyword}, &quot; +
               &quot;score={position=6, type=float}}, type=object}}, type=object}}, type=object}}&quot;));
    }

    @Test
    public void testAddGeneratedColumn() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column name_generated as concat(name, 'foo')&quot;);

        assertThat(analysis.hasNewGeneratedColumns(), is(true));
        assertThat(analysis.analyzedTableElements().columnIdents(), containsInAnyOrder(
            new ColumnIdent(&quot;name_generated&quot;), new ColumnIdent(&quot;id&quot;)));

        AnalyzedColumnDefinition nameGeneratedColumn = null;
        for (AnalyzedColumnDefinition&lt;Object&gt; columnDefinition : analysis.analyzedTableElements().columns()) {
            if (columnDefinition.ident().name().equals(&quot;name_generated&quot;)) {
                nameGeneratedColumn = columnDefinition;
            }
        }
        assertNotNull(nameGeneratedColumn);
        assertThat(nameGeneratedColumn.dataType(), equalTo(DataTypes.STRING));
        assertThat(nameGeneratedColumn.formattedGeneratedExpression(), is(&quot;concat(name, 'foo')&quot;));
    }

    @Test
    public void testAddColumnWithCheckConstraint() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column bazinga int constraint bazinga_check check(bazinga &gt; 0)&quot;);
        assertThat(analysis.analyzedTableElements().getCheckConstraints(), is(Map.of(&quot;bazinga_check&quot;, &quot;\&quot;bazinga\&quot; &gt; 0&quot;)));
        Map&lt;String, Object&gt; mapping = analysis.mapping();
        assertThat(mapToSortedString(mapping),
                   is(&quot;_meta={check_constraints={bazinga_check=\&quot;bazinga\&quot; &gt; 0}, primary_keys=[id]}, &quot; +
                      &quot;properties={bazinga={position=3, type=integer}, id={type=long}}&quot;));
    }

    @Test
    public void testAddColumnWithCheckConstraintFailsBecauseItRefersToAnotherColumn() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();
        expectedException.expectMessage(&quot;CHECK expressions defined in this context cannot refer to other columns: id&quot;);
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column bazinga int constraint bazinga_check check(id &gt; 0)&quot;);
    }

    @Test
    public void testAddColumnWithColumnStoreDisabled() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table users (id bigint primary key, name text)&quot;)
            .build();
        BoundAddColumn analysis = analyze(
            &quot;alter table users add column string_no_docvalues string STORAGE WITH (columnstore = false)&quot;);
        Map&lt;String, Object&gt; mapping = analysis.mapping();
        assertThat(mapToSortedString(mapping),
            is(&quot;_meta={primary_keys=[id]}, properties={id={type=long}, &quot; +
               &quot;string_no_docvalues={doc_values=false, position=3, type=keyword}}&quot;));
    }

    @Test
    public void test_primary_key_contains_index_definitions_on_alter_table_new_column() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table tbl (num bigint index off, primary key (num))&quot;)
            .build();
        BoundAddColumn addColumn = analyze(&quot;alter table tbl add column browser text&quot;);
        Map&lt;String, Object&gt; mapping = (Map&lt;String, Object&gt;) addColumn.mapping().get(&quot;properties&quot;);
        assertThat(mapping, Matchers.hasEntry(is(&quot;num&quot;), is(Map.of(&quot;index&quot;, false, &quot;type&quot;, &quot;long&quot;))));
    }

    @Test
    public void test_adding_a_column_with_constraint_adds_existing_constraints_in_mapping() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;CREATE TABLE tbl (author text CHECK (author != ''))&quot;)
            .build();
        BoundAddColumn addColumn = analyze(&quot;ALTER TABLE tbl ADD COLUMN dummy text CHECK (dummy != '')&quot;);
        Map&lt;String, Object&gt; mapping = (Map&lt;String, Object&gt;) addColumn.mapping();
        Map&lt;String, Object&gt; meta = (Map&lt;String, Object&gt;) mapping.get(&quot;_meta&quot;);
        Map&lt;String, Object&gt; checks = (Map&lt;String, Object&gt;) meta.get(&quot;check_constraints&quot;);

        // not asserting concrete keys because check names contain random suffixes
        assertThat(checks.size(), is(2));
    }

    @Test
    public void test_adding_not_null_column_only_contains_new_column_names_in_constraints() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;CREATE TABLE tbl (author text NOT NULL)&quot;)
            .build();
        BoundAddColumn addColumn = analyze(&quot;ALTER TABLE tbl ADD COLUMN dummy text NOT NULL&quot;);
        Map&lt;String, Object&gt; mapping = (Map&lt;String, Object&gt;) addColumn.mapping();
        Map&lt;String, Object&gt; meta = (Map&lt;String, Object&gt;) mapping.get(&quot;_meta&quot;);
        Collection&lt;String&gt; notNull = (Collection&lt;String&gt;)
            ((Map&lt;String, Object&gt;) meta.get(&quot;constraints&quot;)).get(&quot;not_null&quot;);

        assertThat(notNull, Matchers.containsInAnyOrder(&quot;dummy&quot;));
    }

    @Test
    public void test_can_add_fulltext_columns_without_explicit_analyzer() throws Exception {
        e = SQLExecutor.builder(clusterService)
            .addTable(&quot;CREATE TABLE tbl (x int)&quot;)
            .build();
        BoundAddColumn addColumn = analyze(&quot;ALTER TABLE tbl ADD COLUMN content TEXT INDEX USING FULLTEXT&quot;);
        Map&lt;String, Object&gt; properties = (Map&lt;String, Object&gt;) addColumn.mapping().get(&quot;properties&quot;);
        Map&lt;String, Object&gt; content = (Map&lt;String, Object&gt;) properties.get(&quot;content&quot;);

        assertThat(
            &quot;Fulltext columns must have type `text`. Regular varchar or text columns have type `keyword`&quot;,
            content.get(&quot;type&quot;),
            is(&quot;text&quot;)
        );
    }
}
</PRE>
</div>
  </div>
</body>
</html>
