<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for CompletableFuturesTest.java &amp; MasterService.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for CompletableFuturesTest.java &amp; MasterService.java
      </h3>
<h1 align="center">
        5.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>CompletableFuturesTest.java (47.22222%)<th>MasterService.java (3.0195382%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-41)<td><a href="#" name="0">(58-74)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(62-70)<td><a href="#" name="1">(284-290)</a><td align="center"><font color="#c80000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(50-56)<td><a href="#" name="2">(791-794)</a><td align="center"><font color="#a30000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CompletableFuturesTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package io.crate.concurrent;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import org.hamcrest.Matchers;
4 import org.junit.Rule;
5 import org.junit.Test;
6 import org.junit.rules.ExpectedException;
7 import java.util.Arrays;
8 import java.util.List;
9 import java.util.concurrent.CompletableFuture;
10 import java.util.concurrent.Executor;
11 import java.util.concurrent.RejectedExecutionException;
12 import java.util.concurrent.TimeUnit;
13 import static org.hamcrest.Matchers.is;
14 import static org.junit.Assert.assertThat;
15 public class CompletableFuturesTest {
16     @Rule</b></font>
17     public ExpectedException expectedException = ExpectedException.none();
18     @Test
19     public void testAllAsListFailurePropagation() throws Exception {
20         CompletableFuture&lt;Integer&gt; f1 = new CompletableFuture&lt;&gt;();
21 <a name="2"></a>        CompletableFuture&lt;Integer&gt; f2 = new CompletableFuture&lt;&gt;();
22         CompletableFuture&lt;List&lt;Integer&gt;&gt; all = CompletableFutures.allAsList(Arrays.asList(f1, f2));
23         f1.completeExceptionally(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new IllegalStateException("dummy"));
24         assertThat("future must wait for all subFutures", all.isDone(), is(false));
25         f2.complete(2);
26         expectedException.expectCause(Matchers.instanceOf(IllegalStateException.class));
27         all.get(10, TimeUnit.SECONDS);
28     }</b></font>
29     @Test
30 <a name="1"></a>    public void testAllAsListResultContainsListOfResults() throws Exception {
31         CompletableFuture&lt;Integer&gt; f1 = new CompletableFuture&lt;&gt;();
32         CompletableFuture&lt;Integer&gt; f2 = new CompletableFuture&lt;&gt;();
33         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>CompletableFuture&lt;List&lt;Integer&gt;&gt; all = CompletableFutures.allAsList(Arrays.asList(f1, f2));
34         f1.complete(10);
35         f2.complete(20);
36         assertThat(all.get(10, TimeUnit.SECONDS), Matchers.contains(10, 20));
37     }
38     @Test</b></font>
39     public void testSupplyAsyncReturnsFailedFutureOnException() throws Exception {
40         Executor rejectingExecutor = command -&gt; {
41             throw new RejectedExecutionException("rejected");
42         };
43         CompletableFuture&lt;Object&gt; future = CompletableFutures.supplyAsync(() -&gt; null, rejectingExecutor);
44         assertThat(future.isCompletedExceptionally(), is(true));
45     }
46 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MasterService.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.cluster.service;
2 import static org.elasticsearch.common.util.concurrent.EsExecutors.daemonThreadFactory;
3 import java.util.Collections;
4 import java.util.List;
5 import java.util.Locale;
6 import java.util.Map;
7 import java.util.Objects;
8 import java.util.concurrent.TimeUnit;
9 import java.util.stream.Collectors;
10 import javax.annotation.Nullable;
11 import org.apache.logging.log4j.LogManager;
12 import org.apache.logging.log4j.Logger;
13 import org.apache.logging.log4j.message.ParameterizedMessage;
14 import org.elasticsearch.Assertions;
15 import org.elasticsearch.action.support.PlainActionFuture;
16 import org.elasticsearch.cluster.AckedClusterStateTaskListener;
17 import org.elasticsearch.cluster.ClusterChangedEvent;
18 import org.elasticsearch.cluster.ClusterState;
19 import org.elasticsearch.cluster.ClusterState.Builder;
20 import org.elasticsearch.cluster.ClusterStateTaskConfig;
21 import org.elasticsearch.cluster.ClusterStateTaskExecutor;
22 import org.elasticsearch.cluster.ClusterStateTaskExecutor.ClusterTasksResult;
23 import org.elasticsearch.cluster.ClusterStateTaskListener;
24 import org.elasticsearch.cluster.coordination.ClusterStatePublisher;
25 import org.elasticsearch.cluster.coordination.FailedToCommitClusterStateException;
26 import org.elasticsearch.cluster.metadata.Metadata;
27 import org.elasticsearch.cluster.metadata.ProcessClusterEventTimeoutException;
28 import org.elasticsearch.cluster.node.DiscoveryNode;
29 import org.elasticsearch.cluster.node.DiscoveryNodes;
30 import org.elasticsearch.cluster.routing.RoutingTable;
31 import org.elasticsearch.common.Priority;
32 <a name="0"></a>import org.elasticsearch.common.component.AbstractLifecycleComponent;
33 import org.elasticsearch.common.settings.ClusterSettings;
34 import org.elasticsearch.common.settings.Setting;
35 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.common.settings.Settings;
36 import org.elasticsearch.common.util.concurrent.CountDown;
37 import org.elasticsearch.common.util.concurrent.EsExecutors;
38 import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;
39 import org.elasticsearch.common.util.concurrent.FutureUtils;
40 import org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor;
41 import org.elasticsearch.discovery.Discovery;
42 import org.elasticsearch.node.Node;
43 import org.elasticsearch.threadpool.Scheduler;
44 import org.elasticsearch.threadpool.ThreadPool;
45 import io.crate.common.collections.Lists2;
46 import io.crate.common.unit.TimeValue;
47 public class MasterService extends AbstractLifecycleComponent {
48     private static final Logger LOGGER = LogManager.getLogger(MasterService.class)</b></font>;
49     public static final Setting&lt;TimeValue&gt; MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING =
50         Setting.positiveTimeSetting("cluster.service.slow_master_task_logging_threshold", TimeValue.timeValueSeconds(10),
51             Setting.Property.Dynamic, Setting.Property.NodeScope);
52     static final String MASTER_UPDATE_THREAD_NAME = "masterService#updateTask";
53     ClusterStatePublisher clusterStatePublisher;
54     private final String nodeName;
55     private java.util.function.Supplier&lt;ClusterState&gt; clusterStateSupplier;
56     private volatile TimeValue slowTaskLoggingThreshold;
57     protected final ThreadPool threadPool;
58     private volatile PrioritizedEsThreadPoolExecutor threadPoolExecutor;
59     private volatile Batcher taskBatcher;
60     public MasterService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool) {
61         this.nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));
62         this.slowTaskLoggingThreshold = MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(settings);
63         clusterSettings.addSettingsUpdateConsumer(MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING, this::setSlowTaskLoggingThreshold);
64         this.threadPool = threadPool;
65     }
66     private void setSlowTaskLoggingThreshold(TimeValue slowTaskLoggingThreshold) {
67         this.slowTaskLoggingThreshold = slowTaskLoggingThreshold;
68     }
69     public synchronized void setClusterStatePublisher(ClusterStatePublisher publisher) {
70         clusterStatePublisher = publisher;
71     }
72     public synchronized void setClusterStateSupplier(java.util.function.Supplier&lt;ClusterState&gt; clusterStateSupplier) {
73         this.clusterStateSupplier = clusterStateSupplier;
74     }
75     @Override
76     protected synchronized void doStart() {
77         Objects.requireNonNull(clusterStatePublisher, "please set a cluster state publisher before starting");
78         Objects.requireNonNull(clusterStateSupplier, "please set a cluster state supplier before starting");
79         threadPoolExecutor = createThreadPoolExecutor();
80         taskBatcher = new Batcher(LOGGER, threadPoolExecutor);
81     }
82     protected PrioritizedEsThreadPoolExecutor createThreadPoolExecutor() {
83         return EsExecutors.newSinglePrioritizing(
84                 nodeName + "/" + MASTER_UPDATE_THREAD_NAME,
85                 daemonThreadFactory(nodeName, MASTER_UPDATE_THREAD_NAME),
86                 threadPool.scheduler());
87     }
88     @SuppressWarnings("unchecked")
89     class Batcher extends TaskBatcher {
90         Batcher(Logger logger, PrioritizedEsThreadPoolExecutor threadExecutor) {
91             super(logger, threadExecutor);
92         }
93         @Override
94         protected void onTimeout(List&lt;? extends BatchedTask&gt; tasks, TimeValue timeout) {
95             threadPool.generic().execute(
96                 () -&gt; tasks.forEach(
97                     task -&gt; ((UpdateTask) task).listener.onFailure(task.source,
98                         new ProcessClusterEventTimeoutException(timeout, task.source))));
99         }
100         @Override
101         protected void run(Object batchingKey, List&lt;? extends BatchedTask&gt; tasks, String tasksSummary) {
102             ClusterStateTaskExecutor&lt;Object&gt; taskExecutor = (ClusterStateTaskExecutor&lt;Object&gt;) batchingKey;
103             List&lt;UpdateTask&gt; updateTasks = (List&lt;UpdateTask&gt;) tasks;
104             runTasks(new TaskInputs(taskExecutor, updateTasks, tasksSummary));
105         }
106         class UpdateTask extends BatchedTask {
107             final ClusterStateTaskListener listener;
108             UpdateTask(Priority priority, String source, Object task, ClusterStateTaskListener listener,
109                        ClusterStateTaskExecutor&lt;?&gt; executor) {
110                 super(priority, source, executor, task);
111                 this.listener = listener;
112             }
113             @Override
114             public String describeTasks(List&lt;? extends BatchedTask&gt; tasks) {
115                 return ((ClusterStateTaskExecutor&lt;Object&gt;) batchingKey).describeTasks(
116                     tasks.stream().map(BatchedTask::getTask).collect(Collectors.toList()));
117             }
118         }
119     }
120     @Override
121     protected synchronized void doStop() {
122         ThreadPool.terminate(threadPoolExecutor, 10, TimeUnit.SECONDS);
123     }
124     @Override
125     protected synchronized void doClose() {
126     }
127     ClusterState state() {
128         return clusterStateSupplier.get();
129     }
130     private static boolean isMasterUpdateThread() {
131         return Thread.currentThread().getName().contains(MASTER_UPDATE_THREAD_NAME);
132     }
133     public static boolean assertNotMasterUpdateThread(String reason) {
134         assert isMasterUpdateThread() == false :
135             "Expected current thread [" + Thread.currentThread() + "] to not be the master service thread. Reason: [" + reason + "]";
136         return true;
137     }
138     private void runTasks(TaskInputs taskInputs) {
139         final String summary = taskInputs.summary;
140         if (!lifecycle.started()) {
141             LOGGER.debug("processing [{}]: ignoring, master service not started", summary);
142             return;
143         }
144         LOGGER.debug("executing cluster state update for [{}]", summary);
145         final ClusterState previousClusterState = state();
146         if (!previousClusterState.nodes().isLocalNodeElectedMaster() &amp;&amp; taskInputs.runOnlyWhenMaster()) {
147             LOGGER.debug("failing [{}]: local node is no longer master", summary);
148             taskInputs.onNoLongerMaster();
149             return;
150         }
151         final long computationStartTime = threadPool.relativeTimeInMillis();
152         final TaskOutputs taskOutputs = calculateTaskOutputs(taskInputs, previousClusterState);
153         taskOutputs.notifyFailedTasks();
154         final TimeValue computationTime = getTimeSince(computationStartTime);
155         logExecutionTime(computationTime, "compute cluster state update", summary);
156         if (taskOutputs.clusterStateUnchanged()) {
157             final long notificationStartTime = threadPool.relativeTimeInMillis();
158             taskOutputs.notifySuccessfulTasksOnUnchangedClusterState();
159             final TimeValue executionTime = getTimeSince(notificationStartTime);
160             logExecutionTime(executionTime, "notify listeners on unchanged cluster state", summary);
161         } else {
162             final ClusterState newClusterState = taskOutputs.newClusterState;
163             if (LOGGER.isTraceEnabled()) {
164                 LOGGER.trace("cluster state updated, source [{}]\n{}", summary, newClusterState);
165             } else {
166                 LOGGER.debug("cluster state updated, version [{}], source [{}]", newClusterState.version(), summary);
167             }
168             final long publicationStartTime = threadPool.relativeTimeInMillis();
169             try {
170                 ClusterChangedEvent clusterChangedEvent = new ClusterChangedEvent(summary, newClusterState, previousClusterState);
171                 final DiscoveryNodes.Delta nodesDelta = clusterChangedEvent.nodesDelta();
172                 if (nodesDelta.hasChanges() &amp;&amp; LOGGER.isInfoEnabled()) {
173                     String nodeSummary = nodesDelta.shortSummary();
174                     if (nodeSummary.length() &gt; 0) {
175                         LOGGER.info("{}, term: {}, version: {}, reason: {}",
176                             summary, newClusterState.term(), newClusterState.version(), nodeSummary);
177                     }
178                 }
179                 LOGGER.debug("publishing cluster state version [{}]", newClusterState.version());
180                 publish(clusterChangedEvent, taskOutputs, publicationStartTime);
181             } catch (Exception e) {
182                 handleException(summary, publicationStartTime, newClusterState, e);
183             }
184         }
185     }
186     private TimeValue getTimeSince(long startTimeMillis) {
187         return TimeValue.timeValueMillis(Math.max(0, threadPool.relativeTimeInMillis() - startTimeMillis));
188     }
189     protected void publish(ClusterChangedEvent clusterChangedEvent, TaskOutputs taskOutputs, long startTimeMillis) {
190         final PlainActionFuture&lt;Void&gt; fut = new PlainActionFuture&lt;Void&gt;() {
191             @Override
192             protected boolean blockingAllowed() {
193                 return isMasterUpdateThread() || super.blockingAllowed();
194             }
195         };
196         clusterStatePublisher.publish(clusterChangedEvent, fut, taskOutputs.createAckListener(threadPool, clusterChangedEvent.state()));
197         try {
198             FutureUtils.get(fut);
199             onPublicationSuccess(clusterChangedEvent, taskOutputs);
200         } catch (Exception e) {
201             onPublicationFailed(clusterChangedEvent, taskOutputs, startTimeMillis, e);
202         }
203     }
204     void onPublicationSuccess(ClusterChangedEvent clusterChangedEvent, TaskOutputs taskOutputs) {
205         final long notificationStartTime = threadPool.relativeTimeInMillis();
206         taskOutputs.processedDifferentClusterState(clusterChangedEvent.previousState(), clusterChangedEvent.state());
207         try {
208             taskOutputs.clusterStatePublished(clusterChangedEvent);
209         } catch (Exception e) {
210             LOGGER.error(() -&gt; new ParameterizedMessage(
211 <a name="1"></a>                "exception thrown while notifying executor of new cluster state publication [{}]",
212                 clusterChangedEvent.source()), e);
213         }
214         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final TimeValue executionTime = getTimeSince(notificationStartTime);
215         logExecutionTime(executionTime, "notify listeners on successful publication of cluster state (version: "
216             + clusterChangedEvent.state().version() + ", uuid: " + clusterChangedEvent.state().stateUUID() + ')',
217             clusterChangedEvent.source());
218     }
219     void onPublicationF</b></font>ailed(ClusterChangedEvent clusterChangedEvent, TaskOutputs taskOutputs, long startTimeMillis, Exception exception) {
220         if (exception instanceof FailedToCommitClusterStateException) {
221             final long version = clusterChangedEvent.state().version();
222             LOGGER.warn(() -&gt; new ParameterizedMessage(
223                 "failing [{}]: failed to commit cluster state version [{}]", clusterChangedEvent.source(), version), exception);
224             taskOutputs.publishingFailed((FailedToCommitClusterStateException) exception);
225         } else {
226             handleException(clusterChangedEvent.source(), startTimeMillis, clusterChangedEvent.state(), exception);
227         }
228     }
229     private void handleException(String summary, long startTimeMillis, ClusterState newClusterState, Exception e) {
230         final TimeValue executionTime = getTimeSince(startTimeMillis);
231         final long version = newClusterState.version();
232         final String stateUUID = newClusterState.stateUUID();
233         final String fullState = newClusterState.toString();
234         LOGGER.warn(new ParameterizedMessage(
235                 "took [{}] and then failed to publish updated cluster state (version: {}, uuid: {}) for [{}]:\n{}",
236                 executionTime,
237                 version,
238                 stateUUID,
239                 summary,
240                 fullState),
241             e);
242     }
243     private TaskOutputs calculateTaskOutputs(TaskInputs taskInputs, ClusterState previousClusterState) {
244         ClusterTasksResult&lt;Object&gt; clusterTasksResult = executeTasks(taskInputs, previousClusterState);
245         ClusterState newClusterState = patchVersions(previousClusterState, clusterTasksResult);
246         return new TaskOutputs(taskInputs, previousClusterState, newClusterState, getNonFailedTasks(taskInputs, clusterTasksResult),
247             clusterTasksResult.executionResults);
248     }
249     private ClusterState patchVersions(ClusterState previousClusterState, ClusterTasksResult&lt;?&gt; executionResult) {
250         ClusterState newClusterState = executionResult.resultingState;
251         if (previousClusterState != newClusterState) {
252             Builder builder = incrementVersion(newClusterState);
253             if (previousClusterState.routingTable() != newClusterState.routingTable()) {
254                 builder.routingTable(RoutingTable.builder(newClusterState.routingTable())
255                     .version(newClusterState.routingTable().version() + 1).build());
256             }
257             if (previousClusterState.metadata() != newClusterState.metadata()) {
258                 builder.metadata(Metadata.builder(newClusterState.metadata()).version(newClusterState.metadata().version() + 1));
259             }
260             newClusterState = builder.build();
261         }
262         return newClusterState;
263     }
264     public Builder incrementVersion(ClusterState clusterState) {
265         return ClusterState.builder(clusterState).incrementVersion();
266     }
267     public &lt;T extends ClusterStateTaskConfig &amp; ClusterStateTaskExecutor&lt;T&gt; &amp; ClusterStateTaskListener&gt;
268         void submitStateUpdateTask(
269         String source, T updateTask) {
270         submitStateUpdateTask(source, updateTask, updateTask, updateTask, updateTask);
271     }
272     public &lt;T&gt; void submitStateUpdateTask(String source, T task,
273                                           ClusterStateTaskConfig config,
274                                           ClusterStateTaskExecutor&lt;T&gt; executor,
275                                           ClusterStateTaskListener listener) {
276         submitStateUpdateTasks(source, Collections.singletonMap(task, listener), config, executor);
277     }
278     class TaskOutputs {
279         final TaskInputs taskInputs;
280         final ClusterState previousClusterState;
281         final ClusterState newClusterState;
282         final List&lt;Batcher.UpdateTask&gt; nonFailedTasks;
283         final Map&lt;Object, ClusterStateTaskExecutor.TaskResult&gt; executionResults;
284         TaskOutputs(TaskInputs taskInputs, ClusterState previousClusterState,
285                            ClusterState newClusterState,
286                            List&lt;Batcher.UpdateTask&gt; nonFailedTasks,
287                            Map&lt;Object, ClusterStateTaskExecutor.TaskResult&gt; executionResults) {
288             this.taskInputs = taskInputs;
289             this.previousClusterState = previousClusterState;
290             this.newClusterState = newClusterState;
291             this.nonFailedTasks = nonFailedTasks;
292             this.executionResults = executionResults;
293         }
294         void publishingFailed(FailedToCommitClusterStateException t) {
295             nonFailedTasks.forEach(task -&gt; task.listener.onFailure(task.source(), t));
296         }
297         void processedDifferentClusterState(ClusterState previousClusterState, ClusterState newClusterState) {
298             nonFailedTasks.forEach(task -&gt; task.listener.clusterStateProcessed(task.source(), previousClusterState, newClusterState));
299         }
300         void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {
301             taskInputs.executor.clusterStatePublished(clusterChangedEvent);
302         }
303         Discovery.AckListener createAckListener(ThreadPool threadPool, ClusterState newClusterState) {
304             return new DelegatingAckListener(nonFailedTasks.stream()
305                 .filter(task -&gt; task.listener instanceof AckedClusterStateTaskListener)
306                 .map(task -&gt; new AckCountDownListener((AckedClusterStateTaskListener) task.listener, newClusterState.version(),
307                     newClusterState.nodes(), threadPool))
308                 .collect(Collectors.toList()));
309         }
310         boolean clusterStateUnchanged() {
311             return previousClusterState == newClusterState;
312         }
313         void notifyFailedTasks() {
314             for (Batcher.UpdateTask updateTask : taskInputs.updateTasks) {
315                 assert executionResults.containsKey(updateTask.task) : "missing " + updateTask;
316                 final ClusterStateTaskExecutor.TaskResult taskResult = executionResults.get(updateTask.task);
317                 if (taskResult.isSuccess() == false) {
318                     updateTask.listener.onFailure(updateTask.source(), taskResult.getFailure());
319                 }
320             }
321         }
322         void notifySuccessfulTasksOnUnchangedClusterState() {
323             nonFailedTasks.forEach(task -&gt; {
324                 if (task.listener instanceof AckedClusterStateTaskListener) {
325                     //no need to wait for ack if nothing changed, the update can be counted as acknowledged
326                     ((AckedClusterStateTaskListener) task.listener).onAllNodesAcked(null);
327                 }
328                 task.listener.clusterStateProcessed(task.source(), newClusterState, newClusterState);
329             });
330         }
331     }
332     public List&lt;PendingClusterTask&gt; pendingTasks() {
333         return Lists2.map(
334             threadPoolExecutor.getPending(),
335             pending -&gt; {
336                 assert pending.task instanceof SourcePrioritizedRunnable :
337                     "thread pool executor should only use SourcePrioritizedRunnable instances but found: " + pending.task.getClass().getName();
338                 SourcePrioritizedRunnable task = (SourcePrioritizedRunnable) pending.task;
339                 return new PendingClusterTask(
340                     pending.insertionOrder,
341                     pending.priority,
342                     task.source(),
343                     task.getAgeInMillis(),
344                     pending.executing
345                 );
346             }
347         );
348     }
349     public int numberOfPendingTasks() {
350         return threadPoolExecutor.getNumberOfPendingTasks();
351     }
352     public TimeValue getMaxTaskWaitTime() {
353         return threadPoolExecutor.getMaxTaskWaitTime();
354     }
355     private SafeClusterStateTaskListener safe(ClusterStateTaskListener listener) {
356         if (listener instanceof AckedClusterStateTaskListener) {
357             return new SafeAckedClusterStateTaskListener((AckedClusterStateTaskListener) listener, LOGGER);
358         } else {
359             return new SafeClusterStateTaskListener(listener, LOGGER);
360         }
361     }
362     private static class SafeClusterStateTaskListener implements ClusterStateTaskListener {
363         private final ClusterStateTaskListener listener;
364         private final Logger logger;
365         SafeClusterStateTaskListener(ClusterStateTaskListener listener, Logger logger) {
366             this.listener = listener;
367             this.logger = logger;
368         }
369         @Override
370         public void onFailure(String source, Exception e) {
371             try {
372                 listener.onFailure(source, e);
373             } catch (Exception inner) {
374                 inner.addSuppressed(e);
375                 logger.error(() -&gt; new ParameterizedMessage(
376                         "exception thrown by listener notifying of failure from [{}]", source), inner);
377             }
378         }
379         @Override
380         public void onNoLongerMaster(String source) {
381             try {
382                 listener.onNoLongerMaster(source);
383             } catch (Exception e) {
384                 logger.error(() -&gt; new ParameterizedMessage(
385                         "exception thrown by listener while notifying no longer master from [{}]", source), e);
386             }
387         }
388         @Override
389         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {
390             try {
391                 listener.clusterStateProcessed(source, oldState, newState);
392             } catch (Exception e) {
393                 logger.error(() -&gt; new ParameterizedMessage(
394                         "exception thrown by listener while notifying of cluster state processed from [{}], old cluster state:\n" +
395                             "{}\nnew cluster state:\n{}", source, oldState, newState), e);
396             }
397         }
398     }
399     private static class SafeAckedClusterStateTaskListener extends SafeClusterStateTaskListener implements AckedClusterStateTaskListener {
400         private final AckedClusterStateTaskListener listener;
401         private final Logger logger;
402         SafeAckedClusterStateTaskListener(AckedClusterStateTaskListener listener, Logger logger) {
403             super(listener, logger);
404             this.listener = listener;
405             this.logger = logger;
406         }
407         @Override
408         public boolean mustAck(DiscoveryNode discoveryNode) {
409             return listener.mustAck(discoveryNode);
410         }
411         @Override
412         public void onAllNodesAcked(@Nullable Exception e) {
413             try {
414                 listener.onAllNodesAcked(e);
415             } catch (Exception inner) {
416                 inner.addSuppressed(e);
417                 logger.error("exception thrown by listener while notifying on all nodes acked", inner);
418             }
419         }
420         @Override
421         public void onAckTimeout() {
422             try {
423                 listener.onAckTimeout();
424             } catch (Exception e) {
425                 logger.error("exception thrown by listener while notifying on ack timeout", e);
426             }
427         }
428         @Override
429         public TimeValue ackTimeout() {
430             return listener.ackTimeout();
431         }
432     }
433     private void logExecutionTime(TimeValue executionTime, String activity, String summary) {
434         if (executionTime.getMillis() &gt; slowTaskLoggingThreshold.getMillis()) {
435             LOGGER.warn("took [{}], which is over [{}], to {} for [{}]", executionTime, slowTaskLoggingThreshold, activity, summary);
436         } else {
437             LOGGER.debug("took [{}] to {} for [{}]", executionTime, activity, summary);
438         }
439     }
440     private static class DelegatingAckListener implements Discovery.AckListener {
441         private final List&lt;Discovery.AckListener&gt; listeners;
442         private DelegatingAckListener(List&lt;Discovery.AckListener&gt; listeners) {
443             this.listeners = listeners;
444         }
445         @Override
446         public void onCommit(TimeValue commitTime) {
447             for (Discovery.AckListener listener : listeners) {
448                 listener.onCommit(commitTime);
449             }
450         }
451         @Override
452         public void onNodeAck(DiscoveryNode node, @Nullable Exception e) {
453             for (Discovery.AckListener listener : listeners) {
454                 listener.onNodeAck(node, e);
455             }
456         }
457     }
458     private static class AckCountDownListener implements Discovery.AckListener {
459         private static final Logger LOGGER = LogManager.getLogger(AckCountDownListener.class);
460         private final AckedClusterStateTaskListener ackedTaskListener;
461         private final CountDown countDown;
462         private final DiscoveryNode masterNode;
463         private final ThreadPool threadPool;
464         private final long clusterStateVersion;
465         private volatile Scheduler.Cancellable ackTimeoutCallback;
466         private Exception lastFailure;
467         AckCountDownListener(AckedClusterStateTaskListener ackedTaskListener, long clusterStateVersion, DiscoveryNodes nodes,
468                              ThreadPool threadPool) {
469             this.ackedTaskListener = ackedTaskListener;
470             this.clusterStateVersion = clusterStateVersion;
471             this.threadPool = threadPool;
472             this.masterNode = nodes.getMasterNode();
473             int countDown = 0;
474             for (DiscoveryNode node : nodes) {
475                 //we always wait for at least the master node
476                 if (node.equals(masterNode) || ackedTaskListener.mustAck(node)) {
477                     countDown++;
478                 }
479             }
480             LOGGER.trace("expecting {} acknowledgements for cluster_state update (version: {})", countDown, clusterStateVersion);
481             this.countDown = new CountDown(countDown + 1);         }
482         @Override
483         public void onCommit(TimeValue commitTime) {
484             TimeValue ackTimeout = ackedTaskListener.ackTimeout();
485             if (ackTimeout == null) {
486                 ackTimeout = TimeValue.ZERO;
487             }
488             final TimeValue timeLeft = TimeValue.timeValueNanos(Math.max(0, ackTimeout.nanos() - commitTime.nanos()));
489             if (timeLeft.nanos() == 0L) {
490                 onTimeout();
491             } else if (countDown.countDown()) {
492                 finish();
493             } else {
494                 this.ackTimeoutCallback = threadPool.schedule(this::onTimeout, timeLeft, ThreadPool.Names.GENERIC);
495                 if (countDown.isCountedDown()) {
496                     ackTimeoutCallback.cancel();
497                 }
498             }
499         }
500         @Override
501         public void onNodeAck(DiscoveryNode node, @Nullable Exception e) {
502             if (node.equals(masterNode) == false &amp;&amp; ackedTaskListener.mustAck(node) == false) {
503                 return;
504             }
505             if (e == null) {
506                 LOGGER.trace("ack received from node [{}], cluster_state update (version: {})", node, clusterStateVersion);
507             } else {
508                 this.lastFailure = e;
509                 LOGGER.debug(() -&gt; new ParameterizedMessage(
510                         "ack received from node [{}], cluster_state update (version: {})", node, clusterStateVersion), e);
511             }
512             if (countDown.countDown()) {
513                 finish();
514             }
515         }
516         private void finish() {
517             LOGGER.trace("all expected nodes acknowledged cluster_state update (version: {})", clusterStateVersion);
518             if (ackTimeoutCallback != null) {
519                 ackTimeoutCallback.cancel();
520             }
521             ackedTaskListener.onAllNodesAcked(lastFailure);
522         }
523         public void onTimeout() {
524             if (countDown.fastForward()) {
525                 LOGGER.trace("timeout waiting for acknowledgement for cluster_state update (version: {})", clusterStateVersion);
526                 ackedTaskListener.onAckTimeout();
527             }
528         }
529     }
530     private ClusterTasksResult&lt;Object&gt; executeTasks(TaskInputs taskInputs, ClusterState previousClusterState) {
531         ClusterTasksResult&lt;Object&gt; clusterTasksResult;
532         try {
533             List&lt;Object&gt; inputs = taskInputs.updateTasks.stream().map(tUpdateTask -&gt; tUpdateTask.task).collect(Collectors.toList());
534             clusterTasksResult = taskInputs.executor.execute(previousClusterState, inputs);
535             if (previousClusterState != clusterTasksResult.resultingState &amp;&amp;
536                 previousClusterState.nodes().isLocalNodeElectedMaster() &amp;&amp;
537                 (clusterTasksResult.resultingState.nodes().isLocalNodeElectedMaster() == false)) {
538                 throw new AssertionError("update task submitted to MasterService cannot remove master");
539             }
540         } catch (Exception e) {
541             LOGGER.trace(() -&gt; new ParameterizedMessage(
542                     "failed to execute cluster state update (on version: [{}], uuid: [{}]) for [{}]\n{}{}{}",
543                     previousClusterState.version(),
544                     previousClusterState.stateUUID(),
545                     taskInputs.summary,
546                     previousClusterState.nodes(),
547                     previousClusterState.routingTable(),
548                     previousClusterState.getRoutingNodes()),                 e);
549             clusterTasksResult = ClusterTasksResult.builder()
550                 .failures(taskInputs.updateTasks.stream().map(updateTask -&gt; updateTask.task)::iterator, e)
551                 .build(previousClusterState);
552         }
553         assert clusterTasksResult.executionResults != null;
554         assert clusterTasksResult.executionResults.size() == taskInputs.updateTasks.size()
555             : String.format(Locale.ROOT, "expected [%d] task result%s but was [%d]", taskInputs.updateTasks.size(),
556             taskInputs.updateTasks.size() == 1 ? "" : "s", clusterTasksResult.executionResults.size());
557         if (Assertions.ENABLED) {
558             ClusterTasksResult&lt;Object&gt; finalClusterTasksResult = clusterTasksResult;
559             taskInputs.updateTasks.forEach(updateTask -&gt; {
560                 assert finalClusterTasksResult.executionResults.containsKey(updateTask.task) :
561                     "missing task result for " + updateTask;
562             });
563         }
564         return clusterTasksResult;
565     }
566     private List&lt;Batcher.UpdateTask&gt; getNonFailedTasks(TaskInputs taskInputs,
567                                                       ClusterTasksResult&lt;Object&gt; clusterTasksResult) {
568         return taskInputs.updateTasks.stream().filter(updateTask -&gt; {
569             assert clusterTasksResult.executionResults.containsKey(updateTask.task) : "missing " + updateTask;
570             final ClusterStateTaskExecutor.TaskResult taskResult =
571                 clusterTasksResult.executionResults.get(updateTask.task);
572             return taskResult.isSuccess();
573         }).collect(Collectors.toList());
574     }
575     private class TaskInputs {
576         final String summary;
577         final List&lt;Batcher.UpdateTask&gt; updateTasks;
578         final ClusterStateTaskExecutor&lt;Object&gt; executor;
579         TaskInputs(ClusterStateTaskExecutor&lt;Object&gt; executor, List&lt;Batcher.UpdateTask&gt; updateTasks, String summary) {
580             this.summary = summary;
581             this.executor = executor;
582             this.updateTasks = updateTasks;
583         }
584         boolean runOnlyWhenMaster() {
585             return executor.runOnlyOnMaster();
586         }
587         void onNoLongerMaster() {
588             updateTasks.forEach(task -&gt; task.listener.onNoLongerMaster(task.source()));
589         }
590     }
591     public &lt;T&gt; void submitStateUpdateTasks(final String source,
592                                            final Map&lt;T, ClusterStateTaskListener&gt; tasks, final ClusterStateTaskConfig config,
593                                            final ClusterStateTaskExecutor&lt;T&gt; executor) {
594         if (!lifecycle.started()) {
595             return;
596 <a name="2"></a>        }
597         try {
598             List&lt;Batcher.UpdateTask&gt; safeTasks = tasks.entrySet().stream()
599                 .map(e -&gt; <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>taskBatcher.new UpdateTask(config.priority(), source, e.getKey(), safe(e.getValue()), executor))
600                 .collect(Collectors.toList());
601             taskBatcher.submitTasks(safeTasks, config.timeout());
602         }</b></font> catch (EsRejectedExecutionException e) {
603             if (!lifecycle.stoppedOrClosed()) {
604                 throw e;
605             }
606         }
607     }
608 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
