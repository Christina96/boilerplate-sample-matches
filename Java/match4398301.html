<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for CastFunctionResolver.java &amp; InternalTestCluster.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for CastFunctionResolver.java &amp; InternalTestCluster.java
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>CastFunctionResolver.java (51.724136%)<th>InternalTestCluster.java (1.3278253%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-42)<td><a href="#" name="0">(138-165)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(91-101)<td><a href="#" name="1">(472-476)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(78-90)<td><a href="#" name="2">(440-443)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(53-58)<td><a href="#" name="3">(401-404)</a><td align="center"><font color="#990000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CastFunctionResolver.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package io.crate.expression.scalar.cast;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.exceptions.ConversionException;
4 import io.crate.expression.symbol.Function;
5 import io.crate.expression.symbol.Literal;
6 import io.crate.expression.symbol.Symbol;
7 import io.crate.metadata.functions.Signature;
8 import io.crate.types.DataType;
9 import io.crate.types.DataTypes;
10 import java.util.List;
11 import java.util.Set;
12 import javax.annotation.Nullable;
13 import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;
14 import static io.crate.types.TypeSignature.parseTypeSignature;
15 public class CastFunctionResolver {
16     public static final List&lt;String&gt; CAST_FUNCTION_NAMES = List.of</b></font>(
17         ExplicitCastFunction.NAME, ImplicitCastFunction.NAME, TryCastFunction.NAME);
18     @Nullable
19     public static CastMode getCastMode(String functionName) {
20         return switch (functionName) {
21             case ExplicitCastFunction.NAME -&gt; CastMode.EXPLICIT;
22             case ImplicitCastFunction.NAME -&gt; CastMode.IMPLICIT;
23 <a name="3"></a>            case TryCastFunction.NAME -&gt; CastMode.TRY;
24             default -&gt; null;
25         };
26     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
27     public static Symbol generateCastFunction(Symbol sourceSymbol,
28                                               DataType&lt;?&gt; targetType,
29                                               CastMode... castModes) {
30         var modes = Set.of</b></font>(castModes);
31         assert !modes.containsAll(List.of(CastMode.EXPLICIT, CastMode.IMPLICIT))
32             : "explicit and implicit cast modes are mutually exclusive";
33         DataType&lt;?&gt; sourceType = sourceSymbol.valueType();
34         if (!sourceType.isConvertableTo(targetType, modes.contains(CastMode.EXPLICIT))) {
35             throw new ConversionException(sourceType, targetType);
36         }
37         if (modes.contains(CastMode.TRY) || modes.contains(CastMode.EXPLICIT)) {
38             var name = modes.contains(CastMode.TRY)
39 <a name="2"></a>                ? TryCastFunction.NAME
40                 : ExplicitCastFunction.NAME;
41             return new Function(
42                 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Signature
43                     .scalar(
44                         name,
45                         parseTypeSignature("E"),
46                         parseTypeSignature("V"),
47                         parseTypeSignature("V")
48                     ).withTypeVariableConstraints(typeVariable("E"), typeVariable("V")),
49                 List.of(sourceSymbol, Literal.of(targetType, null)),
50 <a name="1"></a>                targetType
51             );
52         }</b></font> else {
53             return <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new Function(
54                 Signature
55                     .scalar(
56                         ImplicitCastFunction.NAME,
57                         parseTypeSignature("E"),
58                         DataTypes.STRING.getTypeSignature(),
59                         DataTypes.UNDEFINED.getTypeSignature())
60                     .withTypeVariableConstraints(typeVariable("E")),
61                 List.of(
62                     sourceSymbol,
63                     Literal.of(targetType.getTypeSignature</b></font>().toString())
64                 ),
65                 targetType
66             );
67         }
68     }
69 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>InternalTestCluster.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.test;
2 import static io.crate.common.unit.TimeValue.timeValueSeconds;
3 import static org.apache.lucene.util.LuceneTestCase.TEST_NIGHTLY;
4 import static org.apache.lucene.util.LuceneTestCase.rarely;
5 import static org.elasticsearch.cluster.coordination.ClusterBootstrapService.INITIAL_MASTER_NODES_SETTING;
6 import static org.elasticsearch.discovery.DiscoveryModule.DISCOVERY_TYPE_SETTING;
7 import static org.elasticsearch.discovery.DiscoveryModule.ZEN2_DISCOVERY_TYPE;
8 import static org.elasticsearch.node.Node.INITIAL_STATE_TIMEOUT_SETTING;
9 import static org.elasticsearch.discovery.FileBasedSeedHostsProvider.UNICAST_HOSTS_FILE;
10 import static org.elasticsearch.indices.breaker.HierarchyCircuitBreakerService.TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING;
11 import static org.elasticsearch.test.ESTestCase.assertBusy;
12 import static org.elasticsearch.test.ESTestCase.randomFrom;
13 import static org.hamcrest.Matchers.equalTo;
14 import static org.hamcrest.Matchers.greaterThan;
15 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
16 import static org.hamcrest.Matchers.not;
17 import static org.hamcrest.Matchers.nullValue;
18 import static org.junit.Assert.assertThat;
19 import static org.junit.Assert.assertTrue;
20 import static org.junit.Assert.fail;
21 import java.io.Closeable;
22 import java.io.IOException;
23 import java.net.InetSocketAddress;
24 import java.nio.file.Files;
25 import java.nio.file.Path;
26 import java.util.ArrayList;
27 import java.util.Arrays;
28 import java.util.Collection;
29 import java.util.Collections;
30 import java.util.HashMap;
31 import java.util.HashSet;
32 import java.util.Iterator;
33 import java.util.List;
34 import java.util.Map;
35 import java.util.NavigableMap;
36 import java.util.Objects;
37 import java.util.Random;
38 import java.util.Set;
39 import java.util.TreeMap;
40 import java.util.concurrent.ExecutionException;
41 import java.util.concurrent.ExecutorService;
42 import java.util.concurrent.Future;
43 import java.util.concurrent.TimeUnit;
44 import java.util.concurrent.atomic.AtomicBoolean;
45 import java.util.concurrent.atomic.AtomicInteger;
46 import java.util.function.Predicate;
47 import java.util.stream.Collectors;
48 import java.util.stream.IntStream;
49 import java.util.stream.Stream;
50 import javax.annotation.Nullable;
51 import com.carrotsearch.hppc.ObjectLongMap;
52 import com.carrotsearch.hppc.cursors.IntObjectCursor;
53 import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
54 import com.carrotsearch.randomizedtesting.RandomizedTest;
55 import com.carrotsearch.randomizedtesting.SeedUtils;
56 import com.carrotsearch.randomizedtesting.generators.RandomNumbers;
57 import com.carrotsearch.randomizedtesting.generators.RandomPicks;
58 import com.carrotsearch.randomizedtesting.generators.RandomStrings;
59 import org.apache.logging.log4j.LogManager;
60 import org.apache.logging.log4j.Logger;
61 import org.apache.lucene.store.AlreadyClosedException;
62 import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;
63 import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsRequest;
64 import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;
65 import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;
66 import org.elasticsearch.client.Client;
67 import org.elasticsearch.cluster.ClusterName;
68 import org.elasticsearch.cluster.ClusterState;
69 import org.elasticsearch.cluster.action.index.MappingUpdatedAction;
70 import org.elasticsearch.cluster.coordination.ClusterBootstrapService;
71 import org.elasticsearch.cluster.metadata.IndexMetadata;
72 import org.elasticsearch.cluster.node.DiscoveryNode;
73 import org.elasticsearch.cluster.node.DiscoveryNodeRole;
74 import org.elasticsearch.cluster.node.DiscoveryNodes;
75 import org.elasticsearch.cluster.routing.IndexRoutingTable;
76 import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
77 import org.elasticsearch.cluster.routing.OperationRouting;
78 import org.elasticsearch.cluster.routing.ShardRouting;
79 import org.elasticsearch.cluster.routing.allocation.DiskThresholdSettings;
80 import org.elasticsearch.cluster.routing.allocation.decider.ThrottlingAllocationDecider;
81 import org.elasticsearch.cluster.service.ClusterService;
82 import org.elasticsearch.common.Randomness;
83 import org.elasticsearch.common.Strings;
84 import org.elasticsearch.common.breaker.CircuitBreaker;
85 import org.elasticsearch.common.component.LifecycleListener;
86 import org.elasticsearch.common.io.FileSystemUtils;
87 import org.elasticsearch.common.io.stream.NamedWriteableRegistry;
88 import org.elasticsearch.common.lease.Releasables;
89 import org.elasticsearch.common.settings.Settings;
90 import org.elasticsearch.common.settings.Settings.Builder;
91 import org.elasticsearch.common.unit.ByteSizeUnit;
92 import org.elasticsearch.common.unit.ByteSizeValue;
93 import org.elasticsearch.common.util.PageCacheRecycler;
94 import org.elasticsearch.common.util.concurrent.EsExecutors;
95 import org.elasticsearch.common.util.concurrent.FutureUtils;
96 import org.elasticsearch.env.Environment;
97 import org.elasticsearch.env.NodeEnvironment;
98 import org.elasticsearch.env.ShardLockObtainFailedException;
99 import org.elasticsearch.http.HttpServerTransport;
100 import org.elasticsearch.index.Index;
101 import org.elasticsearch.index.IndexService;
102 import org.elasticsearch.index.engine.CommitStats;
103 import org.elasticsearch.index.engine.DocIdSeqNoAndSource;
104 import org.elasticsearch.index.engine.Engine;
105 import org.elasticsearch.index.engine.InternalEngine;
106 import org.elasticsearch.index.seqno.SeqNoStats;
107 import org.elasticsearch.index.seqno.SequenceNumbers;
108 import org.elasticsearch.index.shard.IndexShard;
109 import org.elasticsearch.index.shard.IndexShardTestCase;
110 import org.elasticsearch.index.shard.ShardId;
111 <a name="0"></a>import org.elasticsearch.indices.IndicesService;
112 import org.elasticsearch.indices.breaker.CircuitBreakerService;
113 import org.elasticsearch.indices.breaker.HierarchyCircuitBreakerService;
114 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.elasticsearch.indices.recovery.RecoverySettings;
115 import org.elasticsearch.node.MockNode;
116 import org.elasticsearch.node.Node;
117 import org.elasticsearch.node.NodeValidationException;
118 import org.elasticsearch.plugins.Plugin;
119 import org.elasticsearch.test.disruption.ServiceDisruptionScheme;
120 import org.elasticsearch.test.transport.MockTransportService;
121 import org.elasticsearch.transport.TransportService;
122 import org.elasticsearch.transport.TransportSettings;
123 import io.crate.common.io.IOUtils;
124 import io.crate.common.unit.TimeValue;
125 import static org.junit.Assert.assertEquals;
126 public final class InternalTestCluster extends TestCluster {
127     private final Logger logger = LogManager.getLogger</b></font>(getClass());
128     private static final Predicate&lt;NodeAndClient&gt; DATA_NODE_PREDICATE =
129         nodeAndClient -&gt; DiscoveryNode.isDataNode(nodeAndClient.node.settings());
130     private static final Predicate&lt;NodeAndClient&gt; NO_DATA_NO_MASTER_PREDICATE = nodeAndClient -&gt;
131         DiscoveryNode.isMasterEligibleNode(nodeAndClient.node.settings()) == false
132             &amp;&amp; DiscoveryNode.isDataNode(nodeAndClient.node.settings()) == false;
133     private static final Predicate&lt;NodeAndClient&gt; MASTER_NODE_PREDICATE =
134         nodeAndClient -&gt; DiscoveryNode.isMasterEligibleNode(nodeAndClient.node.settings());
135     public static final int DEFAULT_LOW_NUM_MASTER_NODES = 1;
136     public static final int DEFAULT_HIGH_NUM_MASTER_NODES = 3;
137     static final int DEFAULT_MIN_NUM_DATA_NODES = 1;
138     static final int DEFAULT_MAX_NUM_DATA_NODES = TEST_NIGHTLY ? 6 : 3;
139     static final int DEFAULT_NUM_CLIENT_NODES = -1;
140     static final int DEFAULT_MIN_NUM_CLIENT_NODES = 0;
141     static final int DEFAULT_MAX_NUM_CLIENT_NODES = 1;
142     private volatile NavigableMap&lt;String, NodeAndClient&gt; nodes = Collections.emptyNavigableMap();
143     private final Set&lt;Path&gt; dataDirToClean = new HashSet&lt;&gt;();
144     private final String clusterName;
145     private final AtomicBoolean open = new AtomicBoolean(true);
146     private final Settings defaultSettings;
147     private final AtomicInteger nextNodeId = new AtomicInteger(0);
148     private final long[] sharedNodesSeeds;
149     private final int numSharedDedicatedMasterNodes;
150     private final int numSharedDataNodes;
151     private final int numSharedCoordOnlyNodes;
152     private final NodeConfigurationSource nodeConfigurationSource;
153     private final ExecutorService executor;
154     private final boolean autoManageMasterNodes;
155     private final Collection&lt;Class&lt;? extends Plugin&gt;&gt; mockPlugins;
156     private final boolean forbidPrivateIndexSettings;
157     private final int numDataPaths;
158     private final String nodePrefix;
159     private final Path baseDir;
160     private ServiceDisruptionScheme activeDisruptionScheme;
161     private int bootstrapMasterNodeIndex = -1;
162     public InternalTestCluster(
163             final long clusterSeed,
164             final Path baseDir,
165             final boolean randomlyAddDedicatedMasters,
166             final boolean autoManageMasterNodes,
167             final int minNumDataNodes,
168             final int maxNumDataNodes,
169             final String clusterName,
170             final NodeConfigurationSource nodeConfigurationSource,
171             final int numClientNodes,
172             final String nodePrefix,
173             final Collection&lt;Class&lt;? extends Plugin&gt;&gt; mockPlugins) {
174         this(
175                 clusterSeed,
176                 baseDir,
177                 randomlyAddDedicatedMasters,
178                 autoManageMasterNodes,
179                 minNumDataNodes,
180                 maxNumDataNodes,
181                 clusterName,
182                 nodeConfigurationSource,
183                 numClientNodes,
184                 nodePrefix,
185                 mockPlugins,
186                 true);
187     }
188     public InternalTestCluster(
189             final long clusterSeed,
190             final Path baseDir,
191             final boolean randomlyAddDedicatedMasters,
192             final boolean autoManageMasterNodes,
193             final int minNumDataNodes,
194             final int maxNumDataNodes,
195             final String clusterName,
196             final NodeConfigurationSource nodeConfigurationSource,
197             final int numClientNodes,
198             final String nodePrefix,
199             final Collection&lt;Class&lt;? extends Plugin&gt;&gt; mockPlugins,
200             final boolean forbidPrivateIndexSettings) {
201         super(clusterSeed);
202         this.autoManageMasterNodes = autoManageMasterNodes;
203         this.forbidPrivateIndexSettings = forbidPrivateIndexSettings;
204         this.baseDir = baseDir;
205         this.clusterName = clusterName;
206         if (minNumDataNodes &lt; 0 || maxNumDataNodes &lt; 0) {
207             throw new IllegalArgumentException("minimum and maximum number of data nodes must be &gt;= 0");
208         }
209         if (maxNumDataNodes &lt; minNumDataNodes) {
210             throw new IllegalArgumentException("maximum number of data nodes must be &gt;= minimum number of  data nodes");
211         }
212         Random random = new Random(clusterSeed);
213         boolean useDedicatedMasterNodes = randomlyAddDedicatedMasters &amp;&amp; random.nextBoolean();
214         this.numSharedDataNodes = RandomNumbers.randomIntBetween(random, minNumDataNodes, maxNumDataNodes);
215         assert this.numSharedDataNodes &gt;= 0;
216         if (numSharedDataNodes == 0) {
217             this.numSharedCoordOnlyNodes = 0;
218             this.numSharedDedicatedMasterNodes = 0;
219         } else {
220             if (useDedicatedMasterNodes) {
221                 if (random.nextBoolean()) {
222                     this.numSharedDedicatedMasterNodes = DEFAULT_LOW_NUM_MASTER_NODES;
223                 } else {
224                     this.numSharedDedicatedMasterNodes = DEFAULT_HIGH_NUM_MASTER_NODES;
225                 }
226             } else {
227                 this.numSharedDedicatedMasterNodes = 0;
228             }
229             if (numClientNodes &lt; 0) {
230                 this.numSharedCoordOnlyNodes =  RandomNumbers.randomIntBetween(random,
231                         DEFAULT_MIN_NUM_CLIENT_NODES, DEFAULT_MAX_NUM_CLIENT_NODES);
232             } else {
233                 this.numSharedCoordOnlyNodes = numClientNodes;
234             }
235         }
236         assert this.numSharedCoordOnlyNodes &gt;= 0;
237         this.nodePrefix = nodePrefix;
238         assert nodePrefix != null;
239         this.mockPlugins = mockPlugins;
240         sharedNodesSeeds = new long[numSharedDedicatedMasterNodes + numSharedDataNodes + numSharedCoordOnlyNodes];
241         for (int i = 0; i &lt; sharedNodesSeeds.length; i++) {
242             sharedNodesSeeds[i] = random.nextLong();
243         }
244         logger.info("Setup InternalTestCluster [{}] with seed [{}] using [{}] dedicated masters, " +
245                 "[{}] (data) nodes and [{}] coord only nodes (master nodes are [{}])",
246             clusterName, SeedUtils.formatSeed(clusterSeed),
247             numSharedDedicatedMasterNodes, numSharedDataNodes, numSharedCoordOnlyNodes,
248             autoManageMasterNodes ? "auto-managed" : "manual");
249         this.nodeConfigurationSource = nodeConfigurationSource;
250         numDataPaths = random.nextInt(5) == 0 ? 2 + random.nextInt(3) : 1;
251         Builder builder = Settings.builder();
252         builder.put(Environment.PATH_HOME_SETTING.getKey(), baseDir);
253         builder.put(Environment.PATH_REPO_SETTING.getKey(), baseDir.resolve("repos"));
254         builder.put(TransportSettings.PORT.getKey(), 0);
255         builder.put("http.port", 0);
256         if (Strings.hasLength(System.getProperty("tests.es.logger.level"))) {
257             builder.put("logger.level", System.getProperty("tests.es.logger.level"));
258         }
259         if (Strings.hasLength(System.getProperty("es.logger.prefix"))) {
260             builder.put("logger.prefix", System.getProperty("es.logger.prefix"));
261         }
262         builder.put(TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(), "100%");
263         builder.put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), "1b");
264         builder.put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), "1b");
265         builder.put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), "1b");
266         if (TEST_NIGHTLY) {
267             builder.put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING.getKey(),
268                     RandomNumbers.randomIntBetween(random, 5, 10));
269             builder.put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(),
270                     RandomNumbers.randomIntBetween(random, 5, 10));
271         } else if (random.nextInt(100) &lt;= 90) {
272             builder.put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING.getKey(),
273                     RandomNumbers.randomIntBetween(random, 2, 5));
274             builder.put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(),
275                     RandomNumbers.randomIntBetween(random, 2, 5));
276         }
277         builder.put(RecoverySettings.INDICES_RECOVERY_RETRY_DELAY_STATE_SYNC_SETTING.getKey(), TimeValue.timeValueMillis(
278                 RandomNumbers.randomIntBetween(random, 20, 50)));
279         builder.put(RecoverySettings.INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING.getKey(),
280                     RandomNumbers.randomIntBetween(random, 1, 5));
281         defaultSettings = builder.build();
282         executor = EsExecutors.newScaling(
283             "internal_test_cluster_executor",
284             0,
285             Integer.MAX_VALUE,
286             0,
287             TimeUnit.SECONDS,
288             EsExecutors.daemonThreadFactory("test_" + clusterName));
289     }
290     public void setBootstrapMasterNodeIndex(int bootstrapMasterNodeIndex) {
291         assert autoManageMasterNodes == false || bootstrapMasterNodeIndex == -1
292             : "bootstrapMasterNodeIndex should be -1 if autoManageMasterNodes is true, but was " + bootstrapMasterNodeIndex;
293         this.bootstrapMasterNodeIndex = bootstrapMasterNodeIndex;
294     }
295     @Override
296     public String getClusterName() {
297         return clusterName;
298     }
299 <a name="3"></a>
300     public String[] getNodeNames() {
301         return nodes.keySet().toArray(Strings.EMPTY_ARRAY);
302     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
303     private Settings getSettings(int nodeOrdinal, long nodeSeed, Settings others) {
304         Builder builder = Settings.builder().put(defaultSettings)</b></font>
305             .put(getRandomNodeSettings(nodeSeed));
306         Settings settings = nodeConfigurationSource.nodeSettings(nodeOrdinal);
307         if (settings != null) {
308             if (settings.get(ClusterName.CLUSTER_NAME_SETTING.getKey()) != null) {
309                 throw new IllegalStateException("Tests must not set a '" + ClusterName.CLUSTER_NAME_SETTING.getKey()
310                         + "' as a node setting set '" + ClusterName.CLUSTER_NAME_SETTING.getKey() + "': ["
311                         + settings.get(ClusterName.CLUSTER_NAME_SETTING.getKey()) + "]");
312             }
313             builder.put(settings);
314         }
315         if (others != null) {
316             builder.put(others);
317         }
318         builder.put(ClusterName.CLUSTER_NAME_SETTING.getKey(), clusterName);
319         return builder.build();
320     }
321     public Collection&lt;Class&lt;? extends Plugin&gt;&gt; getPlugins() {
322         Set&lt;Class&lt;? extends Plugin&gt;&gt; plugins = new HashSet&lt;&gt;(nodeConfigurationSource.nodePlugins());
323         plugins.addAll(mockPlugins);
324         return plugins;
325     }
326     private static Settings getRandomNodeSettings(long seed) {
327         Random random = new Random(seed);
328         Builder builder = Settings.builder();
329         builder.put(TransportSettings.TRANSPORT_COMPRESS.getKey(), rarely(random));
330         if (random.nextBoolean()) {
331             builder.put("cache.recycler.page.type", RandomPicks.randomFrom(random, PageCacheRecycler.Type.values()));
332         }
333         builder.put(EsExecutors.PROCESSORS_SETTING.getKey(), 1 + random.nextInt(3));
334 <a name="2"></a>
335         if (random.nextBoolean()) {
336             <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>builder.put(TransportSettings.CONNECTIONS_PER_NODE_RECOVERY.getKey(), random.nextInt(2) + 1);
337             builder.put(TransportSettings.CONNECTIONS_PER_NODE_BULK.getKey(), random.nextInt(3) + 1);
338             builder.put(TransportSettings.CONNECTIONS_PER_NODE_REG.getKey(), random.nextInt(6) + 1);
339         }</b></font>
340         if (random.nextBoolean()) {
341             builder.put(MappingUpdatedAction.INDICES_MAPPING_DYNAMIC_TIMEOUT_SETTING.getKey(),
342                     timeValueSeconds(RandomNumbers.randomIntBetween(random, 10, 30)).getStringRep());
343         }
344         if (random.nextInt(10) == 0) {
345             builder.put(HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_TYPE_SETTING.getKey(), "noop");
346         }
347         if (random.nextBoolean()) {
348             if (random.nextInt(10) == 0) {                 builder.put(RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING.getKey(),
349                         new ByteSizeValue(RandomNumbers.randomIntBetween(random, 1, 10), ByteSizeUnit.MB));
350             } else {
351                 builder.put(RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING.getKey(),
352                         new ByteSizeValue(RandomNumbers.randomIntBetween(random, 10, 200), ByteSizeUnit.MB));
353             }
354         }
355         if (random.nextBoolean()) {
356             builder.put(TransportSettings.PING_SCHEDULE.getKey(), RandomNumbers.randomIntBetween(random, 100, 2000) + "ms");
357         }
358         return builder.build();
359 <a name="1"></a>    }
360     public static String clusterName(String prefix, long clusterSeed) {
361         StringBuilder builder = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new StringBuilder(prefix);
362         builder.append("-TEST_WORKER_VM=[").append(ESTestCase.TEST_WORKER_VM_ID).append(']');
363         builder.append("-CLUSTER_SEED=[").append(clusterSeed).append(']');
364         builder.append("-HASH=[").append(SeedUtils.formatSeed</b></font>(System.nanoTime())).append(']');
365         return builder.toString();
366     }
367     private void ensureOpen() {
368         if (!open.get()) {
369             throw new RuntimeException("Cluster is already closed");
370         }
371     }
372     private NodeAndClient getOrBuildRandomNode() {
373         assert Thread.holdsLock(this);
374         final NodeAndClient randomNodeAndClient = getRandomNodeAndClient();
375         if (randomNodeAndClient != null) {
376             return randomNodeAndClient;
377         }
378         final Runnable onTransportServiceStarted = () -&gt; {}; 
379         final int nodeId = nextNodeId.getAndIncrement();
380         final Settings settings = getNodeSettings(nodeId, random.nextLong(), Settings.EMPTY);
381         final Settings nodeSettings = Settings.builder()
382                 .putList(INITIAL_MASTER_NODES_SETTING.getKey(), Node.NODE_NAME_SETTING.get(settings))
383                 .put(settings)
384                 .build();
385         final NodeAndClient buildNode = buildNode(nodeId, nodeSettings, false, onTransportServiceStarted);
386         assert nodes.isEmpty();
387         buildNode.startNode();
388         publishNode(buildNode);
389         return buildNode;
390     }
391     private NodeAndClient getRandomNodeAndClient() {
392         return getRandomNodeAndClient(nc -&gt; true);
393     }
394     private synchronized NodeAndClient getRandomNodeAndClient(Predicate&lt;NodeAndClient&gt; predicate) {
395         ensureOpen();
396         List&lt;NodeAndClient&gt; values = nodes.values().stream().filter(predicate).collect(Collectors.toList());
397         if (values.isEmpty() == false) {
398             return randomFrom(random, values);
399         }
400         return null;
401     }
402     public synchronized void ensureAtLeastNumDataNodes(int n) {
403         int size = numDataNodes();
404         if (size &lt; n) {
405             logger.info("increasing cluster size from {} to {}", size, n);
406             if (numSharedDedicatedMasterNodes &gt; 0) {
407                 startDataOnlyNodes(n - size);
408             } else {
409                 startNodes(n - size);
410             }
411             validateClusterFormed();
412         }
413     }
414     public synchronized void ensureAtMostNumDataNodes(int n) throws IOException {
415         int size = numDataNodes();
416         if (size &lt;= n) {
417             return;
418         }
419         final Stream&lt;NodeAndClient&gt; collection = n == 0
420                 ? nodes.values().stream()
421                 : nodes.values().stream()
422                         .filter(DATA_NODE_PREDICATE.and(new NodeNamePredicate(getMasterName()).negate()));
423         final Iterator&lt;NodeAndClient&gt; values = collection.iterator();
424         logger.info("changing cluster size from {} data nodes to {}", size, n);
425         Set&lt;NodeAndClient&gt; nodesToRemove = new HashSet&lt;&gt;();
426         int numNodesAndClients = 0;
427         while (values.hasNext() &amp;&amp; numNodesAndClients++ &lt; size - n) {
428             NodeAndClient next = values.next();
429             nodesToRemove.add(next);
430         }
431         stopNodesAndClients(nodesToRemove);
432         if (!nodesToRemove.isEmpty() &amp;&amp; size() &gt; 0) {
433             validateClusterFormed();
434         }
435     }
436     private Settings getNodeSettings(final int nodeId, final long seed, final Settings extraSettings) {
437         final Settings settings = getSettings(nodeId, seed, extraSettings);
438         final String name = buildNodeName(nodeId, settings);
439         final Settings.Builder updatedSettings = Settings.builder();
440         updatedSettings.put(Environment.PATH_HOME_SETTING.getKey(), baseDir);
441         if (numDataPaths &gt; 1) {
442             updatedSettings.putList(Environment.PATH_DATA_SETTING.getKey(), IntStream.range(0, numDataPaths).mapToObj(i -&gt;
443                 baseDir.resolve(name).resolve("d" + i).toString()).collect(Collectors.toList()));
444         } else {
445             updatedSettings.put(Environment.PATH_DATA_SETTING.getKey(), baseDir.resolve(name));
446         }
447         updatedSettings.put(Environment.PATH_SHARED_DATA_SETTING.getKey(), baseDir.resolve(name + "-shared"));
448         updatedSettings.put(settings);
449         updatedSettings.put("node.name", name);
450         updatedSettings.put(NodeEnvironment.NODE_ID_SEED_SETTING.getKey(), seed);
451         if (autoManageMasterNodes) {
452             assertThat("if master nodes are automatically managed then nodes must complete a join cycle when starting",
453                 updatedSettings.get(INITIAL_STATE_TIMEOUT_SETTING.getKey()), nullValue());
454         }
455         return updatedSettings.build();
456     }
457     private synchronized NodeAndClient buildNode(int nodeId, Settings settings,
458                                     boolean reuseExisting, Runnable onTransportServiceStarted) {
459         assert Thread.holdsLock(this);
460         ensureOpen();
461         Collection&lt;Class&lt;? extends Plugin&gt;&gt; plugins = getPlugins();
462         String name = settings.get("node.name");
463         final NodeAndClient nodeAndClient = nodes.get(name);
464         if (reuseExisting &amp;&amp; nodeAndClient != null) {
465             onTransportServiceStarted.run();             return nodeAndClient;
466         }
467         assert reuseExisting || nodeAndClient == null : "node name [" + name + "] already exists but not allowed to use it";
468         MockNode node = new MockNode(
469                 settings,
470                 plugins,
471                 nodeConfigurationSource.nodeConfigPath(nodeId),
472                 forbidPrivateIndexSettings);
473         node.injector().getInstance(TransportService.class).addLifecycleListener(new LifecycleListener() {
474             @Override
475             public void afterStart() {
476                 onTransportServiceStarted.run();
477             }
478         });
479         return new NodeAndClient(name, node, settings, nodeId);
480     }
481     private String getNodePrefix(Settings settings) {
482         return nodePrefix + getRoleSuffix(settings);
483     }
484     private String buildNodeName(int id, Settings settings) {
485         return getNodePrefix(settings) + id;
486     }
487     private static String getRoleSuffix(Settings settings) {
488         String suffix = "";
489         if (Node.NODE_MASTER_SETTING.exists(settings) &amp;&amp; Node.NODE_MASTER_SETTING.get(settings)) {
490             suffix = suffix + DiscoveryNodeRole.MASTER_ROLE.roleNameAbbreviation();
491         }
492         if (Node.NODE_DATA_SETTING.exists(settings) &amp;&amp; Node.NODE_DATA_SETTING.get(settings)) {
493             suffix = suffix + DiscoveryNodeRole.DATA_ROLE.roleNameAbbreviation();
494         }
495         if (Node.NODE_MASTER_SETTING.exists(settings) &amp;&amp; Node.NODE_MASTER_SETTING.get(settings) == false &amp;&amp;
496             Node.NODE_DATA_SETTING.exists(settings) &amp;&amp; Node.NODE_DATA_SETTING.get(settings) == false
497             ) {
498             suffix = suffix + "c";
499         }
500         return suffix;
501     }
502     @Override
503     public synchronized Client client() {
504         ensureOpen();
505         return getOrBuildRandomNode().client();
506     }
507     public Client dataNodeClient() {
508         return getRandomNodeAndClient(DATA_NODE_PREDICATE).client();
509     }
510     public Client masterClient() {
511         NodeAndClient randomNodeAndClient = getRandomNodeAndClient(new NodeNamePredicate(getMasterName()));
512         if (randomNodeAndClient != null) {
513             return randomNodeAndClient.nodeClient();         }
514         throw new AssertionError("No master client found");
515     }
516     public Client nonMasterClient() {
517         NodeAndClient randomNodeAndClient = getRandomNodeAndClient(new NodeNamePredicate(getMasterName()).negate());
518         if (randomNodeAndClient != null) {
519             return randomNodeAndClient.nodeClient();         }
520         throw new AssertionError("No non-master client found");
521     }
522     public synchronized Client coordOnlyNodeClient() {
523         ensureOpen();
524         NodeAndClient randomNodeAndClient = getRandomNodeAndClient(NO_DATA_NO_MASTER_PREDICATE);
525         if (randomNodeAndClient != null) {
526             return randomNodeAndClient.client();
527         }
528         int nodeId = nextNodeId.getAndIncrement();
529         Settings settings = getSettings(nodeId, random.nextLong(), Settings.EMPTY);
530         startCoordinatingOnlyNode(settings);
531         return getRandomNodeAndClient(NO_DATA_NO_MASTER_PREDICATE).client();
532     }
533     public synchronized String startCoordinatingOnlyNode(Settings settings) {
534         ensureOpen();         Builder builder = Settings.builder().put(settings).put(Node.NODE_MASTER_SETTING.getKey(), false)
535             .put(Node.NODE_DATA_SETTING.getKey(), false);
536         return startNode(builder);
537     }
538     public Client client(String nodeName) {
539         NodeAndClient nodeAndClient = nodes.get(nodeName);
540         if (nodeAndClient != null) {
541             return nodeAndClient.client();
542         }
543         throw new AssertionError("No node found with name: [" + nodeName + "]");
544     }
545     public Client smartClient() {
546         NodeAndClient randomNodeAndClient = getRandomNodeAndClient();
547         if (randomNodeAndClient != null) {
548             return randomNodeAndClient.nodeClient();
549         }
550         throw new AssertionError("No smart client found");
551     }
552     @Override
553     public synchronized void close() throws IOException {
554         if (this.open.compareAndSet(true, false)) {
555             if (activeDisruptionScheme != null) {
556                 activeDisruptionScheme.testClusterClosed();
557                 activeDisruptionScheme = null;
558             }
559             try {
560                 IOUtils.close(nodes.values());
561             } finally {
562                 nodes = Collections.emptyNavigableMap();
563                 executor.shutdownNow();
564             }
565         }
566     }
567     private final class NodeAndClient implements Closeable {
568         private MockNode node;
569         private final Settings originalNodeSettings;
570         private Client nodeClient;
571         private final AtomicBoolean closed = new AtomicBoolean(false);
572         private final String name;
573         private final int nodeAndClientId;
574         NodeAndClient(String name, MockNode node, Settings originalNodeSettings, int nodeAndClientId) {
575             this.node = node;
576             this.name = name;
577             this.originalNodeSettings = originalNodeSettings;
578             this.nodeAndClientId = nodeAndClientId;
579             markNodeDataDirsAsNotEligibleForWipe(node);
580         }
581         Node node() {
582             if (closed.get()) {
583                 throw new RuntimeException("already closed");
584             }
585             return node;
586         }
587         public int nodeAndClientId() {
588             return nodeAndClientId;
589         }
590         public String getName() {
591             return name;
592         }
593         public boolean isMasterEligible() {
594             return Node.NODE_MASTER_SETTING.get(node.settings());
595         }
596         Client client() {
597             return getOrBuildNodeClient();
598         }
599         Client nodeClient() {
600             if (closed.get()) {
601                 throw new RuntimeException("already closed");
602             }
603             return getOrBuildNodeClient();
604         }
605         private Client getOrBuildNodeClient() {
606             synchronized (InternalTestCluster.this) {
607                 if (closed.get()) {
608                     throw new RuntimeException("already closed");
609                 }
610                 if (nodeClient == null) {
611                     nodeClient = node.client();
612                 }
613                 return nodeClient;
614             }
615         }
616         void resetClient() {
617             if (closed.get() == false) {
618                 Releasables.close(nodeClient);
619                 nodeClient = null;
620             }
621         }
622         void startNode() {
623             boolean success = false;
624             try {
625                 node.start();
626                 success = true;
627             } catch (NodeValidationException e) {
628                 throw new RuntimeException(e);
629             } finally {
630                 if (success == false) {
631                     IOUtils.closeWhileHandlingException(node);
632                 }
633             }
634         }
635         Settings closeForRestart(RestartCallback callback) throws Exception {
636             assert callback != null;
637             close();
638             removeNode(this);
639             Settings callbackSettings = callback.onNodeStopped(name);
640             assert callbackSettings != null;
641             Settings.Builder newSettings = Settings.builder();
642             if (autoManageMasterNodes) {
643                 newSettings.putList(INITIAL_MASTER_NODES_SETTING.getKey());
644             }
645             newSettings.put(callbackSettings);
646             clearDataIfNeeded(callback);
647             return newSettings.build();
648         }
649         private void clearDataIfNeeded(RestartCallback callback) throws IOException {
650             if (callback.clearData(name)) {
651                 NodeEnvironment nodeEnv = node.getNodeEnvironment();
652                 if (nodeEnv.hasNodeFile()) {
653                     final Path[] locations = nodeEnv.nodeDataPaths();
654                     logger.debug("removing node data paths: [{}]", Arrays.toString(locations));
655                     IOUtils.rm(locations);
656                 }
657             }
658         }
659         private void recreateNode(final Settings newSettings, final Runnable onTransportServiceStarted) {
660             if (closed.get() == false) {
661                 throw new IllegalStateException("node " + name + " should be closed before recreating it");
662             }
663             final long newIdSeed = NodeEnvironment.NODE_ID_SEED_SETTING.get(node.settings()) + 1;
664             Settings finalSettings = Settings.builder()
665                     .put(originalNodeSettings)
666                     .put(newSettings)
667                     .put(NodeEnvironment.NODE_ID_SEED_SETTING.getKey(), newIdSeed)
668                     .build();
669             Collection&lt;Class&lt;? extends Plugin&gt;&gt; plugins = node.getClasspathPlugins();
670             node = new MockNode(finalSettings, plugins);
671             node.injector().getInstance(TransportService.class).addLifecycleListener(new LifecycleListener() {
672                 @Override
673                 public void afterStart() {
674                     onTransportServiceStarted.run();
675                 }
676             });
677             closed.set(false);
678             markNodeDataDirsAsNotEligibleForWipe(node);
679         }
680         @Override
681         public void close() throws IOException {
682             assert Thread.holdsLock(InternalTestCluster.this);
683             try {
684                 resetClient();
685             } finally {
686                 closed.set(true);
687                 markNodeDataDirsAsPendingForWipe(node);
688                 node.close();
689                 try {
690                     if (node.awaitClose(10, TimeUnit.SECONDS) == false) {
691                         throw new IOException("Node didn't close within 10 seconds.");
692                     }
693                 } catch (InterruptedException e) {
694                     throw new AssertionError("Interruption while waiting for the node to close", e);
695                 }
696             }
697         }
698         private void markNodeDataDirsAsPendingForWipe(Node node) {
699             assert Thread.holdsLock(InternalTestCluster.this);
700             NodeEnvironment nodeEnv = node.getNodeEnvironment();
701             if (nodeEnv.hasNodeFile()) {
702                 dataDirToClean.addAll(Arrays.asList(nodeEnv.nodeDataPaths()));
703             }
704         }
705         private void markNodeDataDirsAsNotEligibleForWipe(Node node) {
706             assert Thread.holdsLock(InternalTestCluster.this);
707             NodeEnvironment nodeEnv = node.getNodeEnvironment();
708             if (nodeEnv.hasNodeFile()) {
709                 dataDirToClean.removeAll(Arrays.asList(nodeEnv.nodeDataPaths()));
710             }
711         }
712     }
713     @Override
714     public synchronized void beforeTest(Random random) throws IOException, InterruptedException {
715         super.beforeTest(random);
716         reset(true);
717     }
718     private synchronized void reset(boolean wipeData) throws IOException {
719         for (NodeAndClient nodeAndClient : nodes.values()) {
720             TransportService transportService = nodeAndClient.node.injector().getInstance(TransportService.class);
721             if (transportService instanceof MockTransportService) {
722                 final MockTransportService mockTransportService = (MockTransportService) transportService;
723                 mockTransportService.clearAllRules();
724             }
725         }
726         randomlyResetClients();
727         final int newSize = sharedNodesSeeds.length;
728         if (nextNodeId.get() == newSize &amp;&amp; nodes.size() == newSize) {
729             if (wipeData) {
730                 wipePendingDataDirectories();
731             }
732             logger.debug("Cluster hasn't changed - moving out - nodes: [{}] nextNodeId: [{}] numSharedNodes: [{}]",
733                     nodes.keySet(), nextNodeId.get(), newSize);
734             return;
735         }
736         logger.debug("Cluster is NOT consistent - restarting shared nodes - nodes: [{}] nextNodeId: [{}] numSharedNodes: [{}]",
737                 nodes.keySet(), nextNodeId.get(), newSize);
738         final List&lt;NodeAndClient&gt; toClose = new ArrayList&lt;&gt;();
739         for (NodeAndClient nodeAndClient : nodes.values()) {
740             if (nodeAndClient.nodeAndClientId() &gt;= sharedNodesSeeds.length) {
741                 logger.debug("Close Node [{}] not shared", nodeAndClient.name);
742                 toClose.add(nodeAndClient);
743             }
744         }
745         stopNodesAndClients(toClose);
746         if (wipeData) {
747             wipePendingDataDirectories();
748         }
749         assertTrue("expected at least one master-eligible node left in " + nodes,
750             nodes.isEmpty() || nodes.values().stream().anyMatch(NodeAndClient::isMasterEligible));
751         final int prevNodeCount = nodes.size();
752         assert newSize == numSharedDedicatedMasterNodes + numSharedDataNodes + numSharedCoordOnlyNodes;
753         final List&lt;NodeAndClient&gt; toStartAndPublish = new ArrayList&lt;&gt;();         final Runnable onTransportServiceStarted = () -&gt; rebuildUnicastHostFiles(toStartAndPublish);
754         final List&lt;Settings&gt; settings = new ArrayList&lt;&gt;();
755         for (int i = 0; i &lt; numSharedDedicatedMasterNodes; i++) {
756             final Settings.Builder extraSettings = Settings.builder();
757             extraSettings.put(Node.NODE_MASTER_SETTING.getKey(), true);
758             extraSettings.put(Node.NODE_DATA_SETTING.getKey(), false);
759             settings.add(getNodeSettings(i, sharedNodesSeeds[i], extraSettings.build()));
760         }
761         for (int i = numSharedDedicatedMasterNodes; i &lt; numSharedDedicatedMasterNodes + numSharedDataNodes; i++) {
762             final Settings.Builder extraSettings = Settings.builder();
763             if (numSharedDedicatedMasterNodes &gt; 0) {
764                 extraSettings.put(Node.NODE_MASTER_SETTING.getKey(), false).build();
765                 extraSettings.put(Node.NODE_DATA_SETTING.getKey(), true).build();
766             }
767             settings.add(getNodeSettings(i, sharedNodesSeeds[i], extraSettings.build()));
768         }
769         for (int i = numSharedDedicatedMasterNodes + numSharedDataNodes;
770              i &lt; numSharedDedicatedMasterNodes + numSharedDataNodes + numSharedCoordOnlyNodes; i++) {
771             final Builder extraSettings = Settings.builder().put(Node.NODE_MASTER_SETTING.getKey(), false)
772                 .put(Node.NODE_DATA_SETTING.getKey(), false);
773             settings.add(getNodeSettings(i, sharedNodesSeeds[i], extraSettings.build()));
774         }
775         int autoBootstrapMasterNodeIndex = -1;
776         final List&lt;String&gt; masterNodeNames = settings.stream()
777                 .filter(Node.NODE_MASTER_SETTING::get)
778                 .map(Node.NODE_NAME_SETTING::get)
779                 .collect(Collectors.toList());
780         if (prevNodeCount == 0 &amp;&amp; autoManageMasterNodes) {
781             if (numSharedDedicatedMasterNodes &gt; 0) {
782                 autoBootstrapMasterNodeIndex = RandomNumbers.randomIntBetween(random, 0, numSharedDedicatedMasterNodes - 1);
783             } else if (numSharedDataNodes &gt; 0) {
784                 autoBootstrapMasterNodeIndex = RandomNumbers.randomIntBetween(random, 0, numSharedDataNodes - 1);
785             }
786         }
787         final List&lt;Settings&gt; updatedSettings = bootstrapMasterNodeWithSpecifiedIndex(settings);
788         for (int i = 0; i &lt; numSharedDedicatedMasterNodes + numSharedDataNodes + numSharedCoordOnlyNodes; i++) {
789             Settings nodeSettings = updatedSettings.get(i);
790             if (i == autoBootstrapMasterNodeIndex) {
791                 nodeSettings = Settings.builder().putList(INITIAL_MASTER_NODES_SETTING.getKey(), masterNodeNames).put(nodeSettings).build();
792             }
793             final NodeAndClient nodeAndClient = buildNode(i, nodeSettings, true, onTransportServiceStarted);
794             toStartAndPublish.add(nodeAndClient);
795         }
796         startAndPublishNodesAndClients(toStartAndPublish);
797         nextNodeId.set(newSize);
798         assert size() == newSize;
799         if (autoManageMasterNodes &amp;&amp; newSize &gt; 0) {
800             validateClusterFormed();
801         }
802         logger.debug("Cluster is consistent again - nodes: [{}] nextNodeId: [{}] numSharedNodes: [{}]",
803                 nodes.keySet(), nextNodeId.get(), newSize);
804     }
805     public synchronized void validateClusterFormed() {
806         final Set&lt;DiscoveryNode&gt; expectedNodes = new HashSet&lt;&gt;();
807         for (NodeAndClient nodeAndClient : nodes.values()) {
808             expectedNodes.add(getInstanceFromNode(ClusterService.class, nodeAndClient.node()).localNode());
809         }
810         logger.trace("validating cluster formed, expecting {}", expectedNodes);
811         try {
812             assertBusy(() -&gt; {
813                 final List&lt;ClusterState&gt; states = nodes.values().stream()
814                     .map(node -&gt; getInstanceFromNode(ClusterService.class, node.node()))
815                     .map(ClusterService::state)
816                     .collect(Collectors.toList());
817                 final String debugString = ", expected nodes: " + expectedNodes + " and actual cluster states " + states;
818                 assertTrue("Missing master" + debugString, states.stream().allMatch(cs -&gt; cs.nodes().getMasterNodeId() != null));
819                 assertEquals("Not all masters in same term" + debugString, 1,
820                     states.stream().mapToLong(ClusterState::term).distinct().count());
821                 states.forEach(cs -&gt; {
822                     DiscoveryNodes discoveryNodes = cs.nodes();
823                     assertEquals("Node size mismatch" + debugString, expectedNodes.size(), discoveryNodes.getSize());
824                     for (DiscoveryNode expectedNode : expectedNodes) {
825                         assertTrue("Expected node to exist: " + expectedNode + debugString, discoveryNodes.nodeExists(expectedNode));
826                     }
827                 });
828             }, 30, TimeUnit.SECONDS);
829         } catch (AssertionError ae) {
830             throw new IllegalStateException("cluster failed to form", ae);
831         } catch (Exception e) {
832             throw new IllegalStateException(e);
833         }
834     }
835     @Override
836     public synchronized void afterTest() {
837         wipePendingDataDirectories();
838         randomlyResetClients();     }
839     @Override
840     public void beforeIndexDeletion() throws Exception {
841         assertNoPendingIndexOperations();
842         //check that shards that have same sync id also contain same number of documents
843         assertSameSyncIdSameDocs();
844         assertOpenTranslogReferences();
845     }
846     private void assertSameSyncIdSameDocs() {
847         Map&lt;String, Long&gt; docsOnShards = new HashMap&lt;&gt;();
848         final Collection&lt;NodeAndClient&gt; nodesAndClients = nodes.values();
849         for (NodeAndClient nodeAndClient : nodesAndClients) {
850             IndicesService indexServices = getInstance(IndicesService.class, nodeAndClient.name);
851             for (IndexService indexService : indexServices) {
852                 for (IndexShard indexShard : indexService) {
853                     try {
854                         CommitStats commitStats = indexShard.commitStats();
855                         String syncId = commitStats.getUserData().get(Engine.SYNC_COMMIT_ID);
856                         if (syncId != null) {
857                             long liveDocsOnShard = commitStats.getNumDocs();
858                             if (docsOnShards.get(syncId) != null) {
859                                 assertThat("sync id is equal but number of docs does not match on node "
860                                     + nodeAndClient.name + ". expected " + docsOnShards.get(syncId) + " but got "
861                                     + liveDocsOnShard, docsOnShards.get(syncId), equalTo(liveDocsOnShard));
862                             } else {
863                                 docsOnShards.put(syncId, liveDocsOnShard);
864                             }
865                         }
866                     } catch (AlreadyClosedException e) {
867                     }
868                 }
869             }
870         }
871     }
872     private void assertNoPendingIndexOperations() throws Exception {
873         assertBusy(() -&gt; {
874             for (NodeAndClient nodeAndClient : nodes.values()) {
875                 IndicesService indexServices = getInstance(IndicesService.class, nodeAndClient.name);
876                 for (IndexService indexService : indexServices) {
877                     for (IndexShard indexShard : indexService) {
878                         List&lt;String&gt; operations = indexShard.getActiveOperations();
879                         if (operations.size() &gt; 0) {
880                             throw new AssertionError(
881                                 "shard " + indexShard.shardId() + " on node [" + nodeAndClient.name + "] has pending operations:\n --&gt; " +
882                                     String.join("\n --&gt; ", operations)
883                             );
884                         }
885                     }
886                 }
887             }
888         }, 60, TimeUnit.SECONDS);
889     }
890     private void assertOpenTranslogReferences() throws Exception {
891         assertBusy(() -&gt; {
892             for (NodeAndClient nodeAndClient : nodes.values()) {
893                 IndicesService indexServices = getInstance(IndicesService.class, nodeAndClient.name);
894                 for (IndexService indexService : indexServices) {
895                     for (IndexShard indexShard : indexService) {
896                         try {
897                             if (IndexShardTestCase.getEngine(indexShard) instanceof InternalEngine) {
898                                 IndexShardTestCase.getTranslog(indexShard).getDeletionPolicy().assertNoOpenTranslogRefs();
899                             }
900                         } catch (AlreadyClosedException ok) {
901                         }
902                     }
903                 }
904             }
905         }, 60, TimeUnit.SECONDS);
906     }
907     public void assertConsistentHistoryBetweenTranslogAndLuceneIndex() throws IOException {
908         for (NodeAndClient nodeAndClient : nodes.values()) {
909             IndicesService indexServices = getInstance(IndicesService.class, nodeAndClient.name);
910             for (IndexService indexService : indexServices) {
911                 for (IndexShard indexShard : indexService) {
912                     try {
913                         IndexShardTestCase.assertConsistentHistoryBetweenTranslogAndLucene(indexShard);
914                     } catch (AlreadyClosedException ignored) {
915                     }
916                 }
917             }
918         }
919     }
920     private IndexShard getShardOrNull(ClusterState clusterState, ShardRouting shardRouting) {
921         if (shardRouting == null || shardRouting.assignedToNode() == false) {
922             return null;
923         }
924         final DiscoveryNode assignedNode = clusterState.nodes().get(shardRouting.currentNodeId());
925         if (assignedNode == null) {
926             return null;
927         }
928         return getInstance(IndicesService.class, assignedNode.getName()).getShardOrNull(shardRouting.shardId());
929     }
930     public void assertSeqNos() throws Exception {
931         assertBusy(() -&gt; {
932             final ClusterState state = clusterService().state();
933             for (ObjectObjectCursor&lt;String, IndexRoutingTable&gt; indexRoutingTable : state.routingTable().indicesRouting()) {
934                 for (IntObjectCursor&lt;IndexShardRoutingTable&gt; indexShardRoutingTable : indexRoutingTable.value.shards()) {
935                     ShardRouting primaryShardRouting = indexShardRoutingTable.value.primaryShard();
936                     final IndexShard primaryShard = getShardOrNull(state, primaryShardRouting);
937                     if (primaryShard == null) {
938                         continue; //just ignore - shard movement
939                     }
940                     final SeqNoStats primarySeqNoStats;
941                     final ObjectLongMap&lt;String&gt; syncGlobalCheckpoints;
942                     try {
943                         primarySeqNoStats = primaryShard.seqNoStats();
944                         syncGlobalCheckpoints = primaryShard.getInSyncGlobalCheckpoints();
945                     } catch (AlreadyClosedException ex) {
946                         continue;                     }
947                     assertThat(primaryShardRouting + " should have set the global checkpoint",
948                         primarySeqNoStats.getGlobalCheckpoint(), not(equalTo(SequenceNumbers.UNASSIGNED_SEQ_NO)));
949                     for (ShardRouting replicaShardRouting : indexShardRoutingTable.value.replicaShards()) {
950                         final IndexShard replicaShard = getShardOrNull(state, replicaShardRouting);
951                         if (replicaShard == null) {
952                             continue; //just ignore - shard movement
953                         }
954                         final SeqNoStats seqNoStats;
955                         try {
956                             seqNoStats = replicaShard.seqNoStats();
957                         } catch (AlreadyClosedException e) {
958                             continue;                         }
959                         assertThat(replicaShardRouting + " seq_no_stats mismatch", seqNoStats, equalTo(primarySeqNoStats));
960                         assertThat(replicaShardRouting + " global checkpoint syncs mismatch", seqNoStats.getGlobalCheckpoint(),
961                             equalTo(syncGlobalCheckpoints.get(replicaShardRouting.allocationId().getId())));
962                     }
963                 }
964             }
965         }, 60, TimeUnit.SECONDS);
966     }
967     public void assertSameDocIdsOnShards() throws Exception {
968         assertBusy(() -&gt; {
969             ClusterState state = client().admin().cluster().prepareState().get().getState();
970             for (ObjectObjectCursor&lt;String, IndexRoutingTable&gt; indexRoutingTable : state.routingTable().indicesRouting()) {
971                 for (IntObjectCursor&lt;IndexShardRoutingTable&gt; indexShardRoutingTable : indexRoutingTable.value.shards()) {
972                     ShardRouting primaryShardRouting = indexShardRoutingTable.value.primaryShard();
973                     IndexShard primaryShard = getShardOrNull(state, primaryShardRouting);
974                     if (primaryShard == null) {
975                         continue;
976                     }
977                     final List&lt;DocIdSeqNoAndSource&gt; docsOnPrimary;
978                     try {
979                         docsOnPrimary = IndexShardTestCase.getDocIdAndSeqNos(primaryShard);
980                     } catch (AlreadyClosedException ex) {
981                         continue;
982                     }
983                     for (ShardRouting replicaShardRouting : indexShardRoutingTable.value.replicaShards()) {
984                         IndexShard replicaShard = getShardOrNull(state, replicaShardRouting);
985                         if (replicaShard == null) {
986                             continue;
987                         }
988                         final List&lt;DocIdSeqNoAndSource&gt; docsOnReplica;
989                         try {
990                             docsOnReplica = IndexShardTestCase.getDocIdAndSeqNos(replicaShard);
991                         } catch (AlreadyClosedException ex) {
992                             continue;
993                         }
994                         assertThat("out of sync shards: primary=[" + primaryShardRouting + "] num_docs_on_primary=[" + docsOnPrimary.size()
995                                 + "] vs replica=[" + replicaShardRouting + "] num_docs_on_replica=[" + docsOnReplica.size() + "]",
996                             docsOnReplica, equalTo(docsOnPrimary));
997                     }
998                 }
999             }
1000         });
1001     }
1002     private void randomlyResetClients() {
1003         assert Thread.holdsLock(this);
1004         if (RandomizedTest.isNightly() &amp;&amp; rarely(random)) {
1005             final Collection&lt;NodeAndClient&gt; nodesAndClients = nodes.values();
1006             for (NodeAndClient nodeAndClient : nodesAndClients) {
1007                 nodeAndClient.resetClient();
1008             }
1009         }
1010     }
1011     public synchronized void wipePendingDataDirectories() {
1012         if (!dataDirToClean.isEmpty()) {
1013             try {
1014                 for (Path path : dataDirToClean) {
1015                     try {
1016                         FileSystemUtils.deleteSubDirectories(path);
1017                         logger.info("Successfully wiped data directory for node location: {}", path);
1018                     } catch (IOException e) {
1019                         logger.info("Failed to wipe data directory for node location: {}", path);
1020                     }
1021                 }
1022             } finally {
1023                 dataDirToClean.clear();
1024             }
1025         }
1026     }
1027     public ClusterService clusterService() {
1028         return clusterService(null);
1029     }
1030     public ClusterService clusterService(@Nullable String node) {
1031         return getInstance(ClusterService.class, node);
1032     }
1033     public &lt;T&gt; Iterable&lt;T&gt; getInstances(Class&lt;T&gt; clazz) {
1034         return nodes.values().stream().map(node -&gt; getInstanceFromNode(clazz, node.node)).collect(Collectors.toList());
1035     }
1036     public &lt;T&gt; Iterable&lt;T&gt; getDataNodeInstances(Class&lt;T&gt; clazz) {
1037         return getInstances(clazz, DATA_NODE_PREDICATE);
1038     }
1039     public synchronized &lt;T&gt; T getCurrentMasterNodeInstance(Class&lt;T&gt; clazz) {
1040         return getInstance(clazz, new NodeNamePredicate(getMasterName()));
1041     }
1042     public &lt;T&gt; Iterable&lt;T&gt; getDataOrMasterNodeInstances(Class&lt;T&gt; clazz) {
1043         return getInstances(clazz, DATA_NODE_PREDICATE.or(MASTER_NODE_PREDICATE));
1044     }
1045     private &lt;T&gt; Iterable&lt;T&gt; getInstances(Class&lt;T&gt; clazz, Predicate&lt;NodeAndClient&gt; predicate) {
1046         Iterable&lt;NodeAndClient&gt; filteredNodes = nodes.values().stream().filter(predicate)::iterator;
1047         List&lt;T&gt; instances = new ArrayList&lt;&gt;();
1048         for (NodeAndClient nodeAndClient : filteredNodes) {
1049             instances.add(getInstanceFromNode(clazz, nodeAndClient.node));
1050         }
1051         return instances;
1052     }
1053     public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, final String node) {
1054         return getInstance(clazz, nc -&gt; node == null || node.equals(nc.name));
1055     }
1056     public &lt;T&gt; T getDataNodeInstance(Class&lt;T&gt; clazz) {
1057         return getInstance(clazz, DATA_NODE_PREDICATE);
1058     }
1059     public &lt;T&gt; T getMasterNodeInstance(Class&lt;T&gt; clazz) {
1060         return getInstance(clazz, MASTER_NODE_PREDICATE);
1061     }
1062     private synchronized &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, Predicate&lt;NodeAndClient&gt; predicate) {
1063         NodeAndClient randomNodeAndClient = getRandomNodeAndClient(predicate);
1064         assert randomNodeAndClient != null;
1065         return getInstanceFromNode(clazz, randomNodeAndClient.node);
1066     }
1067     public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz) {
1068         return getInstance(clazz, nc -&gt; true);
1069     }
1070     private static &lt;T&gt; T getInstanceFromNode(Class&lt;T&gt; clazz, Node node) {
1071         return node.injector().getInstance(clazz);
1072     }
1073     public Settings dataPathSettings(String node) {
1074         return nodes.values()
1075             .stream()
1076             .filter(nc -&gt; nc.name.equals(node))
1077             .findFirst().get().node().settings()
1078             .filter(key -&gt; key.equals(Environment.PATH_DATA_SETTING.getKey()) ||  key.equals(Environment.PATH_SHARED_DATA_SETTING.getKey()));
1079     }
1080     @Override
1081     public int size() {
1082         return nodes.size();
1083     }
1084     @Override
1085     public InetSocketAddress[] httpAddresses() {
1086         List&lt;InetSocketAddress&gt; addresses = new ArrayList&lt;&gt;();
1087         for (HttpServerTransport httpServerTransport : getInstances(HttpServerTransport.class)) {
1088             addresses.add(httpServerTransport.boundAddress().publishAddress().address());
1089         }
1090         return addresses.toArray(new InetSocketAddress[0]);
1091     }
1092     public synchronized boolean stopRandomDataNode() throws IOException {
1093         ensureOpen();
1094         NodeAndClient nodeAndClient = getRandomNodeAndClient(DATA_NODE_PREDICATE);
1095         if (nodeAndClient != null) {
1096             logger.info("Closing random node [{}] ", nodeAndClient.name);
1097             stopNodesAndClient(nodeAndClient);
1098             return true;
1099         }
1100         return false;
1101     }
1102     public synchronized void stopRandomNode(final Predicate&lt;Settings&gt; filter) throws IOException {
1103         ensureOpen();
1104         NodeAndClient nodeAndClient = getRandomNodeAndClient(nc -&gt; filter.test(nc.node.settings()));
1105         if (nodeAndClient != null) {
1106             if (nodeAndClient.nodeAndClientId() &lt; sharedNodesSeeds.length &amp;&amp; nodeAndClient.isMasterEligible() &amp;&amp; autoManageMasterNodes
1107                 &amp;&amp; nodes.values().stream()
1108                         .filter(NodeAndClient::isMasterEligible)
1109                         .filter(n -&gt; n.nodeAndClientId() &lt; sharedNodesSeeds.length)
1110                         .count() == 1) {
1111                 throw new AssertionError("Tried to stop the only master eligible shared node");
1112             }
1113             logger.info("Closing filtered random node [{}] ", nodeAndClient.name);
1114             stopNodesAndClient(nodeAndClient);
1115         }
1116     }
1117     public synchronized void stopCurrentMasterNode() throws IOException {
1118         ensureOpen();
1119         assert size() &gt; 0;
1120         String masterNodeName = getMasterName();
1121         final NodeAndClient masterNode = nodes.get(masterNodeName);
1122         assert masterNode != null;
1123         logger.info("Closing master node [{}] ", masterNodeName);
1124         stopNodesAndClient(masterNode);
1125     }
1126     public synchronized void stopRandomNonMasterNode() throws IOException {
1127         NodeAndClient nodeAndClient = getRandomNodeAndClient(new NodeNamePredicate(getMasterName()).negate());
1128         if (nodeAndClient != null) {
1129             logger.info("Closing random non master node [{}] current master [{}] ", nodeAndClient.name, getMasterName());
1130             stopNodesAndClient(nodeAndClient);
1131         }
1132     }
1133     private synchronized void startAndPublishNodesAndClients(List&lt;NodeAndClient&gt; nodeAndClients) {
1134         if (nodeAndClients.size() &gt; 0) {
1135             final int newMasters = (int) nodeAndClients.stream().filter(NodeAndClient::isMasterEligible)
1136                 .filter(nac -&gt; nodes.containsKey(nac.name) == false)                 .count();
1137             rebuildUnicastHostFiles(nodeAndClients);             List&lt;Future&lt;?&gt;&gt; futures = nodeAndClients.stream().map(node -&gt; executor.submit(node::startNode)).collect(Collectors.toList());
1138             try {
1139                 for (Future&lt;?&gt; future : futures) {
1140                     future.get();
1141                 }
1142             } catch (InterruptedException e) {
1143                 throw new AssertionError("interrupted while starting nodes", e);
1144             } catch (ExecutionException e) {
1145                 RuntimeException re = FutureUtils.rethrowExecutionException(e);
1146                 re.addSuppressed(new RuntimeException("failed to start nodes"));
1147                 throw re;
1148             }
1149             nodeAndClients.forEach(this::publishNode);
1150             if (autoManageMasterNodes &amp;&amp; newMasters &gt; 0) {
1151                 validateClusterFormed();
1152             }
1153         }
1154     }
1155     private final Object discoveryFileMutex = new Object();
1156     private void rebuildUnicastHostFiles(List&lt;NodeAndClient&gt; newNodes) {
1157         synchronized (discoveryFileMutex) {
1158             try {
1159                 final Collection&lt;NodeAndClient&gt; currentNodes = nodes.values();
1160                 Stream&lt;NodeAndClient&gt; unicastHosts = Stream.concat(currentNodes.stream(), newNodes.stream());
1161                 List&lt;String&gt; discoveryFileContents = unicastHosts.map(
1162                     nac -&gt; nac.node.injector().getInstance(TransportService.class)
1163                 ).filter(Objects::nonNull)
1164                     .map(TransportService::getLocalNode).filter(Objects::nonNull).filter(DiscoveryNode::isMasterEligibleNode)
1165                     .map(n -&gt; n.getAddress().toString())
1166                     .distinct().collect(Collectors.toList());
1167                 Set&lt;Path&gt; configPaths = Stream.concat(currentNodes.stream(), newNodes.stream())
1168                     .map(nac -&gt; nac.node.getEnvironment().configFile()).collect(Collectors.toSet());
1169                 logger.debug("configuring discovery with {} at {}", discoveryFileContents, configPaths);
1170                 for (final Path configPath : configPaths) {
1171                     Files.createDirectories(configPath);
1172                     Files.write(configPath.resolve(UNICAST_HOSTS_FILE), discoveryFileContents);
1173                 }
1174             } catch (IOException e) {
1175                 throw new AssertionError("failed to configure file-based discovery", e);
1176             }
1177         }
1178     }
1179     private void stopNodesAndClient(NodeAndClient nodeAndClient) throws IOException {
1180         stopNodesAndClients(Collections.singleton(nodeAndClient));
1181     }
1182     private synchronized void stopNodesAndClients(Collection&lt;NodeAndClient&gt; nodeAndClients) throws IOException {
1183         final Set&lt;String&gt; excludedNodeIds = excludeMasters(nodeAndClients);
1184         for (NodeAndClient nodeAndClient: nodeAndClients) {
1185             removeDisruptionSchemeFromNode(nodeAndClient);
1186             final NodeAndClient previous = removeNode(nodeAndClient);
1187             assert previous == nodeAndClient;
1188             nodeAndClient.close();
1189         }
1190         removeExclusions(excludedNodeIds);
1191     }
1192     public void restartRandomDataNode() throws Exception {
1193         restartRandomDataNode(EMPTY_CALLBACK);
1194     }
1195     public synchronized void restartRandomDataNode(RestartCallback callback) throws Exception {
1196         ensureOpen();
1197         NodeAndClient nodeAndClient = getRandomNodeAndClient(InternalTestCluster.DATA_NODE_PREDICATE);
1198         if (nodeAndClient != null) {
1199             restartNode(nodeAndClient, callback);
1200         }
1201     }
1202     public synchronized void restartNode(String nodeName, RestartCallback callback) throws Exception {
1203         ensureOpen();
1204         NodeAndClient nodeAndClient = nodes.get(nodeName);
1205         if (nodeAndClient != null) {
1206             restartNode(nodeAndClient, callback);
1207         }
1208     }
1209     public static final RestartCallback EMPTY_CALLBACK = new RestartCallback();
1210     public void fullRestart() throws Exception {
1211         fullRestart(EMPTY_CALLBACK);
1212     }
1213     public synchronized void rollingRestart(RestartCallback callback) throws Exception {
1214         int numNodesRestarted = 0;
1215         for (NodeAndClient nodeAndClient : nodes.values()) {
1216             callback.doAfterNodes(numNodesRestarted++, nodeAndClient.nodeClient());
1217             restartNode(nodeAndClient, callback);
1218         }
1219     }
1220     private void restartNode(NodeAndClient nodeAndClient, RestartCallback callback) throws Exception {
1221         assert Thread.holdsLock(this);
1222         logger.info("Restarting node [{}] ", nodeAndClient.name);
1223         if (activeDisruptionScheme != null) {
1224             activeDisruptionScheme.removeFromNode(nodeAndClient.name, this);
1225         }
1226         final Set&lt;String&gt; excludedNodeIds = excludeMasters(Collections.singleton(nodeAndClient));
1227         final Settings newSettings = nodeAndClient.closeForRestart(callback);
1228         removeExclusions(excludedNodeIds);
1229         nodeAndClient.recreateNode(newSettings, () -&gt; rebuildUnicastHostFiles(Collections.singletonList(nodeAndClient)));
1230         nodeAndClient.startNode();
1231         publishNode(nodeAndClient);
1232         if (callback.validateClusterForming() || excludedNodeIds.isEmpty() == false) {
1233             validateClusterFormed();
1234         }
1235     }
1236     private NodeAndClient removeNode(NodeAndClient nodeAndClient) {
1237         assert Thread.holdsLock(this);
1238         final NavigableMap&lt;String, NodeAndClient&gt; newNodes = new TreeMap&lt;&gt;(nodes);
1239         final NodeAndClient previous = newNodes.remove(nodeAndClient.name);
1240         nodes = Collections.unmodifiableNavigableMap(newNodes);
1241         return previous;
1242     }
1243     private Set&lt;String&gt; excludeMasters(Collection&lt;NodeAndClient&gt; nodeAndClients) {
1244         assert Thread.holdsLock(this);
1245         final Set&lt;String&gt; excludedNodeIds = new HashSet&lt;&gt;();
1246         if (autoManageMasterNodes &amp;&amp; nodeAndClients.size() &gt; 0) {
1247             final long currentMasters = nodes.values().stream().filter(NodeAndClient::isMasterEligible).count();
1248             final long stoppingMasters = nodeAndClients.stream().filter(NodeAndClient::isMasterEligible).count();
1249             assert stoppingMasters &lt;= currentMasters : currentMasters + " &lt; " + stoppingMasters;
1250             if (stoppingMasters != currentMasters &amp;&amp; stoppingMasters &gt; 0) {
1251                 nodeAndClients.stream().filter(NodeAndClient::isMasterEligible).map(NodeAndClient::getName).forEach(excludedNodeIds::add);
1252                 assert excludedNodeIds.size() == stoppingMasters;
1253                 logger.info("adding voting config exclusions {} prior to restart/shutdown", excludedNodeIds);
1254                 try {
1255                     client().execute(AddVotingConfigExclusionsAction.INSTANCE,
1256                             new AddVotingConfigExclusionsRequest(excludedNodeIds.toArray(Strings.EMPTY_ARRAY))).get();
1257                 } catch (InterruptedException | ExecutionException e) {
1258                     throw new AssertionError("unexpected", e);
1259                 }
1260             }
1261         }
1262         return excludedNodeIds;
1263     }
1264     private void removeExclusions(Set&lt;String&gt; excludedNodeIds) {
1265         assert Thread.holdsLock(this);
1266         if (excludedNodeIds.isEmpty() == false) {
1267             logger.info("removing voting config exclusions for {} after restart/shutdown", excludedNodeIds);
1268             try {
1269                 Client client = getRandomNodeAndClient(node -&gt; excludedNodeIds.contains(node.name) == false).client();
1270                 client.execute(ClearVotingConfigExclusionsAction.INSTANCE, new ClearVotingConfigExclusionsRequest()).get();
1271             } catch (InterruptedException | ExecutionException e) {
1272                 throw new AssertionError("unexpected", e);
1273             }
1274         }
1275     }
1276     public synchronized void fullRestart(RestartCallback callback) throws Exception {
1277         int numNodesRestarted = 0;
1278         final Settings[] newNodeSettings = new Settings[nextNodeId.get()];
1279         final List&lt;NodeAndClient&gt; toStartAndPublish = new ArrayList&lt;&gt;();         for (NodeAndClient nodeAndClient : nodes.values()) {
1280             callback.doAfterNodes(numNodesRestarted++, nodeAndClient.nodeClient());
1281             logger.info("Stopping and resetting node [{}] ", nodeAndClient.name);
1282             if (activeDisruptionScheme != null) {
1283                 activeDisruptionScheme.removeFromNode(nodeAndClient.name, this);
1284             }
1285             final Settings newSettings = nodeAndClient.closeForRestart(callback);
1286             newNodeSettings[nodeAndClient.nodeAndClientId()] = newSettings;
1287             toStartAndPublish.add(nodeAndClient);
1288         }
1289         callback.onAllNodesStopped();
1290         Randomness.shuffle(toStartAndPublish);
1291         for (NodeAndClient nodeAndClient : toStartAndPublish) {
1292             logger.info("recreating node [{}] ", nodeAndClient.name);
1293             nodeAndClient.recreateNode(newNodeSettings[nodeAndClient.nodeAndClientId()], () -&gt; rebuildUnicastHostFiles(toStartAndPublish));
1294         }
1295         startAndPublishNodesAndClients(toStartAndPublish);
1296         if (callback.validateClusterForming()) {
1297             validateClusterFormed();
1298         }
1299     }
1300     public String getMasterName() {
1301         return getMasterName(null);
1302     }
1303     public String getMasterName(@Nullable String viaNode) {
1304         try {
1305             Client client = viaNode != null ? client(viaNode) : client();
1306             return client.admin().cluster().prepareState().get().getState().nodes().getMasterNode().getName();
1307         } catch (Exception e) {
1308             logger.warn("Can't fetch cluster state", e);
1309             throw new RuntimeException("Can't get master node " + e.getMessage(), e);
1310         }
1311     }
1312     synchronized Set&lt;String&gt; allDataNodesButN(int count) {
1313         final int numNodes = numDataNodes() - count;
1314         assert size() &gt;= numNodes;
1315         Map&lt;String, NodeAndClient&gt; dataNodes =
1316             nodes
1317                 .entrySet()
1318                 .stream()
1319                 .filter(entry -&gt; DATA_NODE_PREDICATE.test(entry.getValue()))
1320                 .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
1321         final HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
1322         final Iterator&lt;String&gt; iterator = dataNodes.keySet().iterator();
1323         for (int i = 0; i &lt; numNodes; i++) {
1324             assert iterator.hasNext();
1325             set.add(iterator.next());
1326         }
1327         return set;
1328     }
1329     public synchronized Set&lt;String&gt; nodesInclude(String index) {
1330         if (clusterService().state().routingTable().hasIndex(index)) {
1331             List&lt;ShardRouting&gt; allShards = clusterService().state().routingTable().allShards(index);
1332             DiscoveryNodes discoveryNodes = clusterService().state().getNodes();
1333             Set&lt;String&gt; nodes = new HashSet&lt;&gt;();
1334             for (ShardRouting shardRouting : allShards) {
1335                 if (shardRouting.assignedToNode()) {
1336                     DiscoveryNode discoveryNode = discoveryNodes.get(shardRouting.currentNodeId());
1337                     nodes.add(discoveryNode.getName());
1338                 }
1339             }
1340             return nodes;
1341         }
1342         return Collections.emptySet();
1343     }
1344     private List&lt;Settings&gt; bootstrapMasterNodeWithSpecifiedIndex(List&lt;Settings&gt; allNodesSettings) {
1345         assert Thread.holdsLock(this);
1346         if (bootstrapMasterNodeIndex == -1) {             return allNodesSettings;
1347         }
1348         int currentNodeId = numMasterNodes() - 1;
1349         List&lt;Settings&gt; newSettings = new ArrayList&lt;&gt;();
1350         for (Settings settings : allNodesSettings) {
1351             if (Node.NODE_MASTER_SETTING.get(settings) == false) {
1352                 newSettings.add(settings);
1353             } else {
1354                 currentNodeId++;
1355                 if (currentNodeId != bootstrapMasterNodeIndex) {
1356                     newSettings.add(settings);
1357                 } else {
1358                     List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;();
1359                     for (Settings nodeSettings : getDataOrMasterNodeInstances(Settings.class)) {
1360                         if (Node.NODE_MASTER_SETTING.get(nodeSettings)) {
1361                             nodeNames.add(Node.NODE_NAME_SETTING.get(nodeSettings));
1362                         }
1363                     }
1364                     for (Settings nodeSettings : allNodesSettings) {
1365                         if (Node.NODE_MASTER_SETTING.get(nodeSettings)) {
1366                             nodeNames.add(Node.NODE_NAME_SETTING.get(nodeSettings));
1367                         }
1368                     }
1369                     newSettings.add(Settings.builder().put(settings)
1370                             .putList(ClusterBootstrapService.INITIAL_MASTER_NODES_SETTING.getKey(), nodeNames)
1371                             .build());
1372                     setBootstrapMasterNodeIndex(-1);
1373                 }
1374             }
1375         }
1376         return newSettings;
1377     }
1378     public String startNode() {
1379         return startNode(Settings.EMPTY);
1380     }
1381     public String startNode(Settings.Builder settings) {
1382         return startNode(settings.build());
1383     }
1384     public String startNode(Settings settings) {
1385         return startNodes(settings).get(0);
1386     }
1387     public List&lt;String&gt; startNodes(int numOfNodes) {
1388         return startNodes(numOfNodes, Settings.EMPTY);
1389     }
1390     public List&lt;String&gt; startNodes(int numOfNodes, Settings settings) {
1391         return startNodes(Collections.nCopies(numOfNodes, settings).toArray(new Settings[0]));
1392     }
1393     public synchronized List&lt;String&gt; startNodes(Settings... extraSettings) {
1394         final int newMasterCount = Math.toIntExact(Stream.of(extraSettings).filter(Node.NODE_MASTER_SETTING::get).count());
1395         final List&lt;NodeAndClient&gt; nodes = new ArrayList&lt;&gt;();
1396         final int prevMasterCount = getMasterNodesCount();
1397         int autoBootstrapMasterNodeIndex = autoManageMasterNodes &amp;&amp; prevMasterCount == 0 &amp;&amp; newMasterCount &gt; 0
1398             &amp;&amp; Arrays.stream(extraSettings)
1399                     .allMatch(s -&gt; Node.NODE_MASTER_SETTING.get(s) == false || ZEN2_DISCOVERY_TYPE.equals(DISCOVERY_TYPE_SETTING.get(s)))
1400             ? RandomNumbers.randomIntBetween(random, 0, newMasterCount - 1) : -1;
1401         final int numOfNodes = extraSettings.length;
1402         final int firstNodeId = nextNodeId.getAndIncrement();
1403         final List&lt;Settings&gt; settings = new ArrayList&lt;&gt;();
1404         for (int i = 0; i &lt; numOfNodes; i++) {
1405             settings.add(getNodeSettings(firstNodeId + i, random.nextLong(), extraSettings[i]));
1406         }
1407         nextNodeId.set(firstNodeId + numOfNodes);
1408         final List&lt;String&gt; initialMasterNodes = settings.stream()
1409                 .filter(Node.NODE_MASTER_SETTING::get)
1410                 .map(Node.NODE_NAME_SETTING::get)
1411                 .collect(Collectors.toList());
1412         final List&lt;Settings&gt; updatedSettings = bootstrapMasterNodeWithSpecifiedIndex(settings);
1413         for (int i = 0; i &lt; numOfNodes; i++) {
1414             final Settings nodeSettings = updatedSettings.get(i);
1415             final Builder builder = Settings.builder();
1416             if (Node.NODE_MASTER_SETTING.get(nodeSettings)) {
1417                 if (autoBootstrapMasterNodeIndex == 0) {
1418                     builder.putList(INITIAL_MASTER_NODES_SETTING.getKey(), initialMasterNodes);
1419                 }
1420                 autoBootstrapMasterNodeIndex -= 1;
1421             }
1422             final NodeAndClient nodeAndClient =
1423                     buildNode(firstNodeId + i, builder.put(nodeSettings).build(), false, () -&gt; rebuildUnicastHostFiles(nodes));
1424             nodes.add(nodeAndClient);
1425         }
1426         startAndPublishNodesAndClients(nodes);
1427         if (autoManageMasterNodes) {
1428             validateClusterFormed();
1429         }
1430         return nodes.stream().map(NodeAndClient::getName).collect(Collectors.toList());
1431     }
1432     public List&lt;String&gt; startMasterOnlyNodes(int numNodes) {
1433         return startMasterOnlyNodes(numNodes, Settings.EMPTY);
1434     }
1435     public List&lt;String&gt; startMasterOnlyNodes(int numNodes, Settings settings) {
1436         Settings settings1 = Settings.builder()
1437                 .put(settings)
1438                 .put(Node.NODE_MASTER_SETTING.getKey(), true)
1439                 .put(Node.NODE_DATA_SETTING.getKey(), false)
1440                 .build();
1441         return startNodes(numNodes, settings1);
1442     }
1443     public List&lt;String&gt; startDataOnlyNodes(int numNodes) {
1444         return startDataOnlyNodes(numNodes, Settings.EMPTY);
1445     }
1446     public List&lt;String&gt; startDataOnlyNodes(int numNodes, Settings settings) {
1447         return startNodes(
1448             numNodes,
1449             Settings.builder().put(settings).put(Node.NODE_MASTER_SETTING.getKey(), false)
1450                 .put(Node.NODE_DATA_SETTING.getKey(), true).build());
1451     }
1452     private int getMasterNodesCount() {
1453         return (int) nodes.values().stream().filter(n -&gt; Node.NODE_MASTER_SETTING.get(n.node().settings())).count();
1454     }
1455     public String startMasterOnlyNode() {
1456         return startMasterOnlyNode(Settings.EMPTY);
1457     }
1458     public String startMasterOnlyNode(Settings settings) {
1459         Settings settings1 = Settings.builder()
1460                 .put(settings)
1461                 .put(Node.NODE_MASTER_SETTING.getKey(), true)
1462                 .put(Node.NODE_DATA_SETTING.getKey(), false)
1463                 .build();
1464         return startNode(settings1);
1465     }
1466     public String startDataOnlyNode() {
1467         return startDataOnlyNode(Settings.EMPTY);
1468     }
1469     public String startDataOnlyNode(Settings settings) {
1470         Settings settings1 = Settings.builder()
1471                 .put(settings)
1472                 .put(Node.NODE_MASTER_SETTING.getKey(), false)
1473                 .put(Node.NODE_DATA_SETTING.getKey(), true)
1474                 .build();
1475         return startNode(settings1);
1476     }
1477     private synchronized void publishNode(NodeAndClient nodeAndClient) {
1478         assert !nodeAndClient.node().isClosed();
1479         final NavigableMap&lt;String, NodeAndClient&gt; newNodes = new TreeMap&lt;&gt;(nodes);
1480         newNodes.put(nodeAndClient.name, nodeAndClient);
1481         nodes = Collections.unmodifiableNavigableMap(newNodes);
1482         applyDisruptionSchemeToNode(nodeAndClient);
1483     }
1484     public void closeNonSharedNodes(boolean wipeData) throws IOException {
1485         reset(wipeData);
1486     }
1487     @Override
1488     public int numDataNodes() {
1489         return dataNodeAndClients().size();
1490     }
1491     @Override
1492     public int numDataAndMasterNodes() {
1493         return filterNodes(nodes, DATA_NODE_PREDICATE.or(MASTER_NODE_PREDICATE)).size();
1494     }
1495     public int numMasterNodes() {
1496       return filterNodes(nodes, NodeAndClient::isMasterEligible).size();
1497     }
1498     public void setDisruptionScheme(ServiceDisruptionScheme scheme) {
1499         assert activeDisruptionScheme == null :
1500             "there is already and active disruption [" + activeDisruptionScheme + "]. call clearDisruptionScheme first";
1501         scheme.applyToCluster(this);
1502         activeDisruptionScheme = scheme;
1503     }
1504     public void clearDisruptionScheme() {
1505         clearDisruptionScheme(true);
1506     }
1507     public synchronized void clearDisruptionScheme(boolean ensureHealthyCluster) {
1508         if (activeDisruptionScheme != null) {
1509             TimeValue expectedHealingTime = activeDisruptionScheme.expectedTimeToHeal();
1510             logger.info("Clearing active scheme {}, expected healing time {}", activeDisruptionScheme, expectedHealingTime);
1511             if (ensureHealthyCluster) {
1512                 activeDisruptionScheme.removeAndEnsureHealthy(this);
1513             } else {
1514                 activeDisruptionScheme.removeFromCluster(this);
1515             }
1516         }
1517         activeDisruptionScheme = null;
1518     }
1519     private void applyDisruptionSchemeToNode(NodeAndClient nodeAndClient) {
1520         if (activeDisruptionScheme != null) {
1521             assert nodes.containsKey(nodeAndClient.name);
1522             activeDisruptionScheme.applyToNode(nodeAndClient.name, this);
1523         }
1524     }
1525     private void removeDisruptionSchemeFromNode(NodeAndClient nodeAndClient) {
1526         if (activeDisruptionScheme != null) {
1527             assert nodes.containsKey(nodeAndClient.name);
1528             activeDisruptionScheme.removeFromNode(nodeAndClient.name, this);
1529         }
1530     }
1531     private Collection&lt;NodeAndClient&gt; dataNodeAndClients() {
1532         return filterNodes(nodes, DATA_NODE_PREDICATE);
1533     }
1534     private static Collection&lt;NodeAndClient&gt; filterNodes(Map&lt;String, InternalTestCluster.NodeAndClient&gt; map,
1535             Predicate&lt;NodeAndClient&gt; predicate) {
1536         return map
1537             .values()
1538             .stream()
1539             .filter(predicate)
1540             .collect(Collectors.toCollection(ArrayList::new));
1541     }
1542     private static final class NodeNamePredicate implements Predicate&lt;NodeAndClient&gt; {
1543         private final String nodeName;
1544         NodeNamePredicate(String nodeName) {
1545             this.nodeName = nodeName;
1546         }
1547         @Override
1548         public boolean test(NodeAndClient nodeAndClient) {
1549             return nodeName.equals(nodeAndClient.getName());
1550         }
1551     }
1552     synchronized String routingKeyForShard(Index index, int shard, Random random) {
1553         assertThat(shard, greaterThanOrEqualTo(0));
1554         assertThat(shard, greaterThanOrEqualTo(0));
1555         for (NodeAndClient n : nodes.values()) {
1556             Node node = n.node;
1557             IndicesService indicesService = getInstanceFromNode(IndicesService.class, node);
1558             ClusterService clusterService = getInstanceFromNode(ClusterService.class, node);
1559             IndexService indexService = indicesService.indexService(index);
1560             if (indexService != null) {
1561                 assertThat(indexService.getIndexSettings().getSettings().getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS, -1),
1562                         greaterThan(shard));
1563                 OperationRouting operationRouting = clusterService.operationRouting();
1564                 while (true) {
1565                     String routing = RandomStrings.randomAsciiLettersOfLength(random, 10);
1566                     final int targetShard = operationRouting
1567                             .indexShards(clusterService.state(), index.getName(), null, routing)
1568                             .shardId().getId();
1569                     if (shard == targetShard) {
1570                         return routing;
1571                     }
1572                 }
1573             }
1574         }
1575         fail("Could not find a node that holds " + index);
1576         return null;
1577     }
1578     @Override
1579     public Iterable&lt;Client&gt; getClients() {
1580         return () -&gt; {
1581             ensureOpen();
1582             final Iterator&lt;NodeAndClient&gt; iterator = nodes.values().iterator();
1583             return new Iterator&lt;Client&gt;() {
1584                 @Override
1585                 public boolean hasNext() {
1586                     return iterator.hasNext();
1587                 }
1588                 @Override
1589                 public Client next() {
1590                     return iterator.next().client();
1591                 }
1592                 @Override
1593                 public void remove() {
1594                     throw new UnsupportedOperationException("");
1595                 }
1596             };
1597         };
1598     }
1599     @Override
1600     public NamedWriteableRegistry getNamedWriteableRegistry() {
1601         return getInstance(NamedWriteableRegistry.class);
1602     }
1603     public static Predicate&lt;Settings&gt; nameFilter(String... nodeNames) {
1604         final Set&lt;String&gt; nodes = Set.of(nodeNames);
1605         return settings -&gt; nodes.contains(settings.get("node.name"));
1606     }
1607     public static class RestartCallback {
1608         public Settings onNodeStopped(String nodeName) throws Exception {
1609             return Settings.EMPTY;
1610         }
1611         public void doAfterNodes(int n, Client client) throws Exception {
1612         }
1613         public void onAllNodesStopped() throws Exception {
1614         }
1615         public boolean clearData(String nodeName) {
1616             return false;
1617         }
1618         public boolean validateClusterForming() { return true; }
1619     }
1620     public Settings getDefaultSettings() {
1621         return defaultSettings;
1622     }
1623     @Override
1624     public void ensureEstimatedStats() {
1625         for (NodeAndClient nodeAndClient : nodes.values()) {
1626             final String name = nodeAndClient.name;
1627             final CircuitBreakerService breakerService = getInstanceFromNode(CircuitBreakerService.class, nodeAndClient.node);
1628             try {
1629                 assertBusy(() -&gt; {
1630                     CircuitBreaker acctBreaker = breakerService.getBreaker(CircuitBreaker.ACCOUNTING);
1631                     assertThat("Accounting breaker not reset to 0 on node: " + name + ", are there still Lucene indices around?",
1632                         acctBreaker.getUsed(), equalTo(0L));
1633                 });
1634             } catch (Exception e) {
1635                 throw new AssertionError("Exception during check for accounting breaker reset to 0", e);
1636             }
1637             try {
1638                 assertBusy(() -&gt; {
1639                     CircuitBreaker reqBreaker = breakerService.getBreaker(CircuitBreaker.REQUEST);
1640                     assertThat("Request breaker not reset to 0 on node: " + name, reqBreaker.getUsed(), equalTo(0L));
1641                 });
1642             } catch (Exception e) {
1643                 throw new AssertionError("Exception during check for request breaker reset to 0", e);
1644             }
1645             try {
1646                 assertBusy(() -&gt; {
1647                     CircuitBreaker crateQueryBreaker = breakerService.getBreaker("query");
1648                     if (crateQueryBreaker != null) {
1649                         assertThat("Query breaker not reset to 0 on node: " + name,
1650                                     crateQueryBreaker.getUsed(),
1651                                     equalTo(0L));
1652                     }
1653                 });
1654             } catch (Exception e) {
1655                 throw new AssertionError("Exception during check for query breaker reset to 0", e);
1656             }
1657         }
1658     }
1659     @Override
1660     public synchronized void assertAfterTest() throws IOException {
1661         super.assertAfterTest();
1662         assertRequestsFinished();
1663         for (NodeAndClient nodeAndClient : nodes.values()) {
1664             NodeEnvironment env = nodeAndClient.node().getNodeEnvironment();
1665             Set&lt;ShardId&gt; shardIds = env.lockedShards();
1666             for (ShardId id : shardIds) {
1667                 try {
1668                     env.shardLock(id, "InternalTestCluster assert after test", TimeUnit.SECONDS.toMillis(5)).close();
1669                 } catch (ShardLockObtainFailedException ex) {
1670                     throw new AssertionError("Shard " + id + " is still locked after 5 sec waiting", ex);
1671                 }
1672             }
1673         }
1674     }
1675     private void assertRequestsFinished() {
1676         assert Thread.holdsLock(this);
1677         for (NodeAndClient nodeAndClient : nodes.values()) {
1678             CircuitBreaker inFlightRequestsBreaker = getInstance(CircuitBreakerService.class, nodeAndClient.name)
1679                 .getBreaker(CircuitBreaker.IN_FLIGHT_REQUESTS);
1680             try {
1681                 assertBusy(() -&gt; {
1682                     long bytesUsed = inFlightRequestsBreaker.getUsed();
1683                     assertThat("All incoming requests on node [" + nodeAndClient.name + "] should have finished. Expected 0 but got " +
1684                         bytesUsed, bytesUsed, equalTo(0L));
1685                 });
1686             } catch (Exception e) {
1687                 logger.error("Could not assert finished requests within timeout", e);
1688                 fail("Could not assert finished requests within timeout on node [" + nodeAndClient.name + "]");
1689             }
1690         }
1691     }
1692     public int numNodes() {
1693         return nodes.size();
1694     }
1695 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
