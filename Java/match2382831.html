<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for PolyglotValuesConverter.java & PrivateElementsImpl.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for PolyglotValuesConverter.java & PrivateElementsImpl.java
      </h3>
      <h1 align="center">
        9.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>PolyglotValuesConverter.java (10.204082%)<TH>PrivateElementsImpl.java (8.823529%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2382831-0.html#0',2,'match2382831-1.html#0',3)" NAME="0">(24-41)<TD><A HREF="javascript:ZweiFrames('match2382831-0.html#0',2,'match2382831-1.html#0',3)" NAME="0">(21-48)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>PolyglotValuesConverter.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.operation.language;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2382831-1.html#0',3,'match2382831-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.data.Input;
import io.crate.types.ArrayType;
import io.crate.types.DataType;
import io.crate.types.DataTypes;
import io.crate.types.GeoPointType;
import io.crate.types.GeoShapeType;
import io.crate.types.ObjectType;
import org.graalvm.polyglot.TypeLiteral;
import org.graalvm.polyglot.Value;
import org.graalvm.polyglot.proxy.ProxyObject;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

class PolyglotValuesConverter {

    private static final TypeLiteral&lt;Number&gt; NUMBER_TYPE_LITERAL = new TypeLiteral&lt;&gt;() {</B></FONT>
    };
    private static final TypeLiteral&lt;Map&gt; MAP_TYPE_LITERAL = new TypeLiteral&lt;&gt;() {
    };

    static Object toCrateObject(Value value, DataType&lt;?&gt; type) {
        if (value == null) {
            return null;
        }
        switch (type.id()) {
            case ArrayType.ID:
                ArrayList&lt;Object&gt; items = new ArrayList&lt;&gt;((int) value.getArraySize());
                for (int idx = 0; idx &lt; value.getArraySize(); idx++) {
                    var item = toCrateObject(value.getArrayElement(idx), ((ArrayType&lt;?&gt;) type).innerType());
                    items.add(idx, item);
                }
                return type.implicitCast(items);
            case ObjectType.ID:
                return type.implicitCast(value.as(MAP_TYPE_LITERAL));
            case GeoPointType.ID:
                if (value.hasArrayElements()) {
                    return type.implicitCast(toCrateObject(value, DataTypes.DOUBLE_ARRAY));
                } else {
                    return type.implicitCast(value.asString());
                }
            case GeoShapeType.ID:
                if (value.isString()) {
                    return type.implicitCast(value.asString());
                } else {
                    return type.implicitCast(value.as(MAP_TYPE_LITERAL));
                }
            default:
                final Object polyglotValue;
                if (value.isNumber()) {
                    polyglotValue = value.as(NUMBER_TYPE_LITERAL);
                } else if (value.isString()) {
                    polyglotValue = value.asString();
                } else if (value.isBoolean()) {
                    polyglotValue = value.asBoolean();
                } else {
                    polyglotValue = value.asString();
                }
                return type.implicitCast(polyglotValue);
        }
    }

    static Object[] toPolyglotValues(Input&lt;Object&gt;[] inputs, List&lt;DataType&lt;?&gt;&gt; dataTypes) {
        Object[] args = new Object[inputs.length];
        for (int i = 0; i &lt; inputs.length; i++) {
            switch (dataTypes.get(i).id()) {
                case ObjectType.ID, GeoShapeType.ID -&gt;
                    //noinspection unchecked
                    args[i] = ProxyObject.fromMap((Map&lt;String, Object&gt;) inputs[i].value());
                default -&gt; args[i] = Value.asValue(inputs[i].value());
            }
        }
        return args;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>PrivateElementsImpl.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.elasticsearch.common.inject.internal;
<A NAME="0"></A>
import org.elasticsearch.common.inject.Binder;
import org.elasticsearch.common.inject.Injector;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2382831-0.html#0',2,'match2382831-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import org.elasticsearch.common.inject.Key;
import org.elasticsearch.common.inject.PrivateBinder;
import org.elasticsearch.common.inject.spi.Element;
import org.elasticsearch.common.inject.spi.ElementVisitor;
import org.elasticsearch.common.inject.spi.PrivateElements;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import static java.util.Collections.unmodifiableMap;

/**
 * @author jessewilson@google.com (Jesse Wilson)
 */
public final class PrivateElementsImpl implements PrivateElements {

    /*
    * This class acts as both a value object and as a builder. When getElements() is called, an
    * immutable collection of elements is constructed and the original mutable list is nulled out.
    * Similarly, the exposed keys are made immutable on access.
    */

    private final Object source</B></FONT>;

    private List&lt;Element&gt; elementsMutable = new ArrayList&lt;&gt;();
    private List&lt;ExposureBuilder&lt;?&gt;&gt; exposureBuilders = new ArrayList&lt;&gt;();

    /**
     * lazily instantiated
     */
    private List&lt;Element&gt; elements;

    /**
     * lazily instantiated
     */
    private Map&lt;Key&lt;?&gt;, Object&gt; exposedKeysToSources;
    private Injector injector;

    public PrivateElementsImpl(Object source) {
        this.source = Objects.requireNonNull(source, &quot;source&quot;);
    }

    @Override
    public Object getSource() {
        return source;
    }

    @Override
    public List&lt;Element&gt; getElements() {
        if (elements == null) {
            elements = Collections.unmodifiableList(elementsMutable);
            elementsMutable = null;
        }

        return elements;
    }

    @Override
    public Injector getInjector() {
        return injector;
    }

    public void initInjector(Injector injector) {
        if (this.injector != null) {
            throw new IllegalStateException(&quot;injector already initialized&quot;);
        }
        this.injector = Objects.requireNonNull(injector, &quot;injector&quot;);
    }

    @Override
    public Set&lt;Key&lt;?&gt;&gt; getExposedKeys() {
        if (exposedKeysToSources == null) {
            Map&lt;Key&lt;?&gt;, Object&gt; exposedKeysToSourcesMutable = new LinkedHashMap&lt;&gt;();
            for (ExposureBuilder&lt;?&gt; exposureBuilder : exposureBuilders) {
                exposedKeysToSourcesMutable.put(exposureBuilder.getKey(), exposureBuilder.getSource());
            }
            exposedKeysToSources = unmodifiableMap(exposedKeysToSourcesMutable);
            exposureBuilders = null;
        }

        return exposedKeysToSources.keySet();
    }

    @Override
    public &lt;T&gt; T acceptVisitor(ElementVisitor&lt;T&gt; visitor) {
        return visitor.visit(this);
    }

    public List&lt;Element&gt; getElementsMutable() {
        return elementsMutable;
    }

    public void addExposureBuilder(ExposureBuilder&lt;?&gt; exposureBuilder) {
        exposureBuilders.add(exposureBuilder);
    }

    @Override
    public void applyTo(Binder binder) {
        PrivateBinder privateBinder = binder.withSource(source).newPrivateBinder();

        for (Element element : getElements()) {
            element.applyTo(privateBinder);
        }

        getExposedKeys(); // ensure exposedKeysToSources is populated
        for (Map.Entry&lt;Key&lt;?&gt;, Object&gt; entry : exposedKeysToSources.entrySet()) {
            privateBinder.withSource(entry.getValue()).expose(entry.getKey());
        }
    }

    @Override
    public Object getExposedSource(Key&lt;?&gt; key) {
        getExposedKeys(); // ensure exposedKeysToSources is populated
        Object source = exposedKeysToSources.get(key);
        if (source == null) {
            throw new IllegalArgumentException(key + &quot; not exposed by &quot; + &quot;.&quot;);
        }
        return source;
    }

    @Override
    public String toString() {
        return new ToStringBuilder(PrivateElements.class)
                .add(&quot;exposedKeys&quot;, getExposedKeys())
                .add(&quot;source&quot;, getSource())
                .toString();
    }
}
</PRE>
</div>
  </div>
</body>
</html>
