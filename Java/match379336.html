<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RegularImmutableMap_1.java &amp; Floats.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RegularImmutableMap_1.java &amp; Floats.java
      </h3>
<h1 align="center">
        14.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RegularImmutableMap_1.java (17.043121%)<th>Floats.java (12.948518%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-43)<td><a href="#" name="0">(22-49)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(294-306)<td><a href="#" name="1">(532-544)</a><td align="center"><font color="#e20000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(373-382)<td><a href="#" name="2">(293-302)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(327-334)<td><a href="#" name="3">(548-556)</a><td align="center"><font color="#b80000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(283-290)<td><a href="#" name="4">(195-212)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(352-359)<td><a href="#" name="5">(637-644)</a><td align="center"><font color="#8d0000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RegularImmutableMap_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.collect;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.base.Preconditions.checkPositionIndex;
5 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
6 import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
7 import static java.util.Objects.requireNonNull;
8 import com.google.common.annotations.GwtCompatible;
9 import com.google.common.annotations.GwtIncompatible;
10 import com.google.common.annotations.VisibleForTesting;
11 import com.google.common.collect.ImmutableMapEntry.NonTerminalImmutableMapEntry;
12 import com.google.errorprone.annotations.CanIgnoreReturnValue;
13 import java.io.Serializable;
14 import java.util.IdentityHashMap;
15 import java.util.function.BiConsumer;
16 import javax.annotation.CheckForNull;
17 import org.checkerframework.checker.nullness.qual.Nullable;
18 @GwtCompatible(s</b></font>erializable = true, emulated = true)
19 @ElementTypesAreNonnullByDefault
20 final class RegularImmutableMap&lt;K, V&gt; extends ImmutableMap&lt;K, V&gt; {
21   @SuppressWarnings("unchecked")
22   static final ImmutableMap&lt;Object, Object&gt; EMPTY =
23       new RegularImmutableMap&lt;&gt;((Entry&lt;Object, Object&gt;[]) ImmutableMap.EMPTY_ENTRY_ARRAY, null, 0);
24   @VisibleForTesting static final double MAX_LOAD_FACTOR = 1.2;
25   @VisibleForTesting static final double HASH_FLOODING_FPP = 0.001;
26   @VisibleForTesting static final int MAX_HASH_BUCKET_LENGTH = 8;
27   @VisibleForTesting final transient Entry&lt;K, V&gt;[] entries;
28   @CheckForNull private final transient @Nullable ImmutableMapEntry&lt;K, V&gt;[] table;
29   private final transient int mask;
30   static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; fromEntries(Entry&lt;K, V&gt;... entries) {
31     return fromEntryArray(entries.length, entries,   }
32   static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; fromEntryArray(
33       int n, @Nullable Entry&lt;K, V&gt;[] entryArray, boolean throwIfDuplicateKeys) {
34     checkPositionIndex(n, entryArray.length);
35     if (n == 0) {
36       @SuppressWarnings("unchecked")       ImmutableMap&lt;K, V&gt; empty = (ImmutableMap&lt;K, V&gt;) EMPTY;
37       return empty;
38     }
39     try {
40       return fromEntryArrayCheckingBucketOverflow(n, entryArray, throwIfDuplicateKeys);
41     } catch (BucketOverflowException e) {
42       return JdkBackedImmutableMap.create(n, entryArray, throwIfDuplicateKeys);
43     }
44   }
45   private static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; fromEntryArrayCheckingBucketOverflow(
46       int n, @Nullable Entry&lt;K, V&gt;[] entryArray, boolean throwIfDuplicateKeys)
47       throws BucketOverflowException {
48     @SuppressWarnings("nullness")
49     Entry&lt;K, V&gt;[] entries =
50         (n == entryArray.length) ? (Entry&lt;K, V&gt;[]) entryArray : createEntryArray(n);
51     int tableSize = Hashing.closedTableSize(n, MAX_LOAD_FACTOR);
52     @Nullable ImmutableMapEntry&lt;K, V&gt;[] table = createEntryArray(tableSize);
53     int mask = tableSize - 1;
54     IdentityHashMap&lt;Entry&lt;K, V&gt;, Boolean&gt; duplicates = null;
55     int dupCount = 0;
56     for (int entryIndex = n - 1; entryIndex &gt;= 0; entryIndex--) {
57       Entry&lt;K, V&gt; entry = requireNonNull(entryArray[entryIndex]);
58       K key = entry.getKey();
59       V value = entry.getValue();
60       checkEntryNotNull(key, value);
61       int tableIndex = Hashing.smear(key.hashCode()) &amp; mask;
62       ImmutableMapEntry&lt;K, V&gt; keyBucketHead = table[tableIndex];
63       ImmutableMapEntry&lt;K, V&gt; effectiveEntry =
64           checkNoConflictInKeyBucket(key, value, keyBucketHead, throwIfDuplicateKeys);
65       if (effectiveEntry == null) {
66         effectiveEntry =
67             (keyBucketHead == null)
68                 ? makeImmutable(entry, key, value)
69                 : new NonTerminalImmutableMapEntry&lt;K, V&gt;(key, value, keyBucketHead);
70         table[tableIndex] = effectiveEntry;
71       } else {
72         if (duplicates == null) {
73           duplicates = new IdentityHashMap&lt;&gt;();
74         }
75         duplicates.put(effectiveEntry, true);
76         dupCount++;
77         if (entries == entryArray) {
78           entries = entries.clone();
79         }
80       }
81       entries[entryIndex] = effectiveEntry;
82     }
83     if (duplicates != null) {
84       entries = RegularImmutableMap.&lt;K, V&gt;removeDuplicates(entries, n, n - dupCount, duplicates);
85       int newTableSize = Hashing.closedTableSize(entries.length, MAX_LOAD_FACTOR);
86       if (newTableSize != tableSize) {
87         return fromEntryArrayCheckingBucketOverflow(
88             entries.length, entries,       }
89     }
90     return new RegularImmutableMap&lt;&gt;(entries, table, mask);
91   }
92   static &lt;K, V&gt; Entry&lt;K, V&gt;[] removeDuplicates(
93       Entry&lt;K, V&gt;[] entries, int n, int newN, IdentityHashMap&lt;Entry&lt;K, V&gt;, Boolean&gt; duplicates) {
94     Entry&lt;K, V&gt;[] newEntries = createEntryArray(newN);
95     for (int in = 0, out = 0; in &lt; n; in++) {
96       Entry&lt;K, V&gt; entry = entries[in];
97       Boolean status = duplicates.get(entry);
98       if (status != null) {
99         if (status) {
100           duplicates.put(entry, false);
101         } else {
102           continue;         }
103       }
104       newEntries[out++] = entry;
105     }
106     return newEntries;
107   }
108   static &lt;K, V&gt; ImmutableMapEntry&lt;K, V&gt; makeImmutable(Entry&lt;K, V&gt; entry, K key, V value) {
109     boolean reusable =
110         entry instanceof ImmutableMapEntry &amp;&amp; ((ImmutableMapEntry&lt;K, V&gt;) entry).isReusable();
111     return reusable ? (ImmutableMapEntry&lt;K, V&gt;) entry : new ImmutableMapEntry&lt;K, V&gt;(key, value);
112   }
113   static &lt;K, V&gt; ImmutableMapEntry&lt;K, V&gt; makeImmutable(Entry&lt;K, V&gt; entry) {
114     return makeImmutable(entry, entry.getKey(), entry.getValue());
115   }
116   private RegularImmutableMap(
117       Entry&lt;K, V&gt;[] entries, @CheckForNull @Nullable ImmutableMapEntry&lt;K, V&gt;[] table, int mask) {
118     this.entries = entries;
119     this.table = table;
120     this.mask = mask;
121   }
122   @CanIgnoreReturnValue
123   static &lt;K, V&gt; @Nullable ImmutableMapEntry&lt;K, V&gt; checkNoConflictInKeyBucket(
124       Object key,
125       Object newValue,
126       @CheckForNull ImmutableMapEntry&lt;K, V&gt; keyBucketHead,
127       boolean throwIfDuplicateKeys)
128       throws BucketOverflowException {
129     int bucketSize = 0;
130     for (; keyBucketHead != null; keyBucketHead = keyBucketHead.getNextInKeyBucket()) {
131       if (keyBucketHead.getKey().equals(key)) {
132         if (throwIfDuplicateKeys) {
133           checkNoConflict(        } else {
134           return keyBucketHead;
135         }
136       }
137       if (++bucketSize &gt; MAX_HASH_BUCKET_LENGTH) {
138         throw new BucketOverflowException();
139       }
140     }
141     return null;
142   }
143   static class BucketOverflowException extends Exception {}
144   @Override
145   @CheckForNull
146   public V get(@CheckForNull Object key) {
147     return get(key, table, mask);
148   }
149   @CheckForNull
150   static &lt;V&gt; V get(
151       @CheckForNull Object key,
152       @CheckForNull @Nullable ImmutableMapEntry&lt;?, V&gt;[] keyTable,
153       int mask) {
154     if (key == null || keyTable == null) {
155       return null;
156     }
157     int index = Hashing.smear(key.hashCode()) &amp; mask;
158     for (ImmutableMapEntry&lt;?, V&gt; entry = keyTable[index];
159         entry != null;
160         entry = entry.getNextInKeyBucket()) {
161       Object candidateKey = entry.getKey();
162       if (key.equals(candidateKey)) {
163         return entry.getValue();
164       <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
165     }
166     return null;
167   }
168   @Override
169   public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
170     checkNotNull</b></font>(action);
171 <a name="1"></a>    for (Entry&lt;K, V&gt; entry : entries) {
172       action.accept(entry.getKey(), entry.getValue());
173     }
174   <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
175   @Override
176   public int size() {
177     return entries.length;
178   }
179   @Override
180   boolean isPartialView() {
181     return false;
182   }
183   @</b></font>Override
184   ImmutableSet&lt;Entry&lt;K, V&gt;&gt; createEntrySet() {
185     return new ImmutableMapEntrySet.RegularEntrySet&lt;&gt;(this, entries);
186   }
187   @Override
188   ImmutableSet&lt;K&gt; createKeySet() {
189     return new KeySet&lt;&gt;(this);
190   }
191   @GwtCompatible(emulated = true)
192   private static final class KeySet&lt;K&gt; extends IndexedImmutableSet&lt;K&gt; {
193     private final RegularImmutableMap&lt;K, ?&gt; map;
194     KeySet(RegularImmutableMap&lt;K, ?&gt; map) {
195       this.map = map;
196     }
197 <a name="3"></a>    @Override
198     K get(int index) {
199       return map.entries[index].getKey();
200     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
201     @Override
202     public boolean contains(@CheckForNull Object object) {
203       return map.containsKey(object);
204     }
205     @</b></font>Override
206     boolean isPartialView() {
207       return true;
208     }
209     @Override
210     public int size() {
211       return map.size();
212     }
213     @GwtIncompatible     @SuppressWarnings("unused")
214     private static class SerializedForm&lt;K&gt; implements Serializable {
215       final ImmutableMap&lt;K, ?&gt; map;
216 <a name="5"></a>
217       SerializedForm(ImmutableMap&lt;K, ?&gt; map) {
218         this.map = map;
219       <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
220       Object readResolve() {
221         return map.keySet();
222       }
223       private static final long serialVersionUID = 0;
224     }</b></font>
225   }
226   @Override
227   ImmutableCollection&lt;V&gt; createValues() {
228     return new Values&lt;&gt;(this);
229   }
230   @GwtCompatible(emulated = true)
231   private static final class Values&lt;K, V&gt; extends ImmutableList&lt;V&gt; {
232     final RegularImmutableMap&lt;K, V&gt; map;
233 <a name="2"></a>
234     Values(RegularImmutableMap&lt;K, V&gt; map) {
235       this.map = map;
236     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
237     @Override
238     public V get(int index) {
239       return map.entries[index].getValue();
240     }
241     @Override
242     public int size() {
243       return</b></font> map.size();
244     }
245     @Override
246     boolean isPartialView() {
247       return true;
248     }
249     @GwtIncompatible     @SuppressWarnings("unused")
250     private static class SerializedForm&lt;V&gt; implements Serializable {
251       final ImmutableMap&lt;?, V&gt; map;
252       SerializedForm(ImmutableMap&lt;?, V&gt; map) {
253         this.map = map;
254       }
255       Object readResolve() {
256         return map.values();
257       }
258       private static final long serialVersionUID = 0;
259     }
260   }
261   private static final long serialVersionUID = 0;
262 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Floats.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.primitives;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkElementIndex;
4 <a name="0"></a>import static com.google.common.base.Preconditions.checkNotNull;
5 import static com.google.common.base.Preconditions.checkPositionIndexes;
6 import static com.google.common.base.Strings.lenientFormat;
7 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import static java.lang.Float.NEGATIVE_INFINITY;
8 import static java.lang.Float.POSITIVE_INFINITY;
9 import com.google.common.annotations.Beta;
10 import com.google.common.annotations.GwtCompatible;
11 import com.google.common.annotations.GwtIncompatible;
12 import com.google.common.base.Converter;
13 import java.io.Serializable;
14 import java.util.AbstractList;
15 import java.util.Arrays;
16 import java.util.Collection;
17 import java.util.Collections;
18 import java.util.Comparator;
19 import java.util.List;
20 import java.util.RandomAccess;
21 import javax.annotation.CheckForNull;
22 @GwtCompatible(e</b></font>mulated = true)
23 @ElementTypesAreNonnullByDefault
24 public final class Floats extends FloatsMethodsForWeb {
25   private Floats() {}
26   public static final int BYTES = Float.SIZE / Byte.SIZE;
27   public static int hashCode(float value) {
28     return ((Float) value).hashCode();
29   }
30   public static int compare(float a, float b) {
31     return Float.compare(a, b);
32   }
33   public static boolean isFinite(float value) {
34     return NEGATIVE_INFINITY &lt; value &amp;&amp; value &lt; POSITIVE_INFINITY;
35   }
36   public static boolean contains(float[] array, float target) {
37     for (float value : array) {
38       if (value == target) {
39         return true;
40       }
41     }
42     return false;
43   }
44   public static int indexOf(float[] array, float target) {
45     return indexOf(array, target, 0, array.length);
46   }
47   private static int indexOf(float[] array, float target, int start, int end) {
48     for (int i = start; i &lt; end; i++) {
49       if (array[i] == target) {
50         return i;
51       }
52     }
53     return -1;
54   }
55   public static int indexOf(float[] array, float[] target) {
56     checkNotNull(array, "array");
57     checkNotNull(target, "target");
58     if (target.length == 0) {
59       return 0;
60     }
61     outer:
62     for (int i = 0; i &lt; array.length - target.length + 1; i++) {
63       for (int j = 0; j &lt; target.length; j++) {
64         if (array[i + j] != target[j]) {
65           continue outer;
66         }
67       }
68       return i;
69     }
70     return -1;
71   }
72   public static int lastIndexOf(float[] array, float target) {
73     return lastIndexOf(array, target, 0, array.length);
74   }
75   private static int lastIndexOf(float[] array, float target, int start, int end) {
76 <a name="4"></a>    for (int i = end - 1; i &gt;= start; i--) {
77       if (array[i] == target) {
78         return i;
79       <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
80     }
81     return -1;
82   }
83   @GwtIncompatible(
84       "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
85   public static float min(float... array) {
86     checkArgument</b></font>(array.length &gt; 0);
87     float min = array[0];
88     for (int i = 1; i &lt; array.length; i++) {
89       min = Math.min(min, array[i]);
90     }
91     return min;
92   }
93   @GwtIncompatible(
94       "Available in GWT! Annotation is to avoid conflict with GWT specialization of base class.")
95   public static float max(float... array) {
96     checkArgument(array.length &gt; 0);
97     float max = array[0];
98     for (int i = 1; i &lt; array.length; i++) {
99       max = Math.max(max, array[i]);
100     }
101     return max;
102   }
103   @Beta
104   public static float constrainToRange(float value, float min, float max) {
105     if (min &lt;= max) {
106       return Math.min(Math.max(value, min), max);
107     }
108     throw new IllegalArgumentException(
109         lenientFormat("min (%s) must be less than or equal to max (%s)", min, max));
110   }
111   public static float[] concat(float[]... arrays) {
112     int length = 0;
113     for (float[] array : arrays) {
114       length += array.length;
115     }
116     float[] result = new float[length];
117     int pos = 0;
118     for (float[] array : arrays) {
119       System.arraycopy(array, 0, result, pos, array.length);
120       pos += array.length;
121     }
122     return result;
123   }
124   private static final class FloatConverter extends Converter&lt;String, Float&gt;
125       implements Serializable {
126     static final FloatConverter INSTANCE = new FloatConverter();
127 <a name="2"></a>    @Override
128     protected Float doForward(String value) {
129       return Float.valueOf(value);
130     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
131     @Override
132     protected String doBackward(Float value) {
133       return value.toString();
134     }
135     @Override
136     public String toString() {
137       return</b></font> "Floats.stringConverter()";
138     }
139     private Object readResolve() {
140       return INSTANCE;
141     }
142     private static final long serialVersionUID = 1;
143   }
144   @Beta
145   public static Converter&lt;String, Float&gt; stringConverter() {
146     return FloatConverter.INSTANCE;
147   }
148   public static float[] ensureCapacity(float[] array, int minLength, int padding) {
149     checkArgument(minLength &gt;= 0, "Invalid minLength: %s", minLength);
150     checkArgument(padding &gt;= 0, "Invalid padding: %s", padding);
151     return (array.length &lt; minLength) ? Arrays.copyOf(array, minLength + padding) : array;
152   }
153   public static String join(String separator, float... array) {
154     checkNotNull(separator);
155     if (array.length == 0) {
156       return "";
157     }
158     StringBuilder builder = new StringBuilder(array.length * 12);
159     builder.append(array[0]);
160     for (int i = 1; i &lt; array.length; i++) {
161       builder.append(separator).append(array[i]);
162     }
163     return builder.toString();
164   }
165   public static Comparator&lt;float[]&gt; lexicographicalComparator() {
166     return LexicographicalComparator.INSTANCE;
167   }
168   private enum LexicographicalComparator implements Comparator&lt;float[]&gt; {
169     INSTANCE;
170     @Override
171     public int compare(float[] left, float[] right) {
172       int minLength = Math.min(left.length, right.length);
173       for (int i = 0; i &lt; minLength; i++) {
174         int result = Float.compare(left[i], right[i]);
175         if (result != 0) {
176           return result;
177         }
178       }
179       return left.length - right.length;
180     }
181     @Override
182     public String toString() {
183       return "Floats.lexicographicalComparator()";
184     }
185   }
186   public static void sortDescending(float[] array) {
187     checkNotNull(array);
188     sortDescending(array, 0, array.length);
189   }
190   public static void sortDescending(float[] array, int fromIndex, int toIndex) {
191     checkNotNull(array);
192     checkPositionIndexes(fromIndex, toIndex, array.length);
193     Arrays.sort(array, fromIndex, toIndex);
194     reverse(array, fromIndex, toIndex);
195   }
196   public static void reverse(float[] array) {
197     checkNotNull(array);
198     reverse(array, 0, array.length);
199   }
200   public static void reverse(float[] array, int fromIndex, int toIndex) {
201     checkNotNull(array);
202     checkPositionIndexes(fromIndex, toIndex, array.length);
203     for (int i = fromIndex, j = toIndex - 1; i &lt; j; i++, j--) {
204       float tmp = array[i];
205       array[i] = array[j];
206       array[j] = tmp;
207     }
208   }
209   public static float[] toArray(Collection&lt;? extends Number&gt; collection) {
210     if (collection instanceof FloatArrayAsList) {
211       return ((FloatArrayAsList) collection).toFloatArray();
212     }
213     Object[] boxedArray = collection.toArray();
214     int len = boxedArray.length;
215     float[] array = new float[len];
216     for (int i = 0; i &lt; len; i++) {
217       array[i] = ((Number) checkNotNull(boxedArray[i])).floatValue();
218     }
219     return array;
220   }
221   public static List&lt;Float&gt; asList(float... backingArray) {
222     if (backingArray.length == 0) {
223       return Collections.emptyList();
224     }
225     return new FloatArrayAsList(backingArray);
226   }
227   @GwtCompatible
228   private static class FloatArrayAsList extends AbstractList&lt;Float&gt;
229       implements RandomAccess, Serializable {
230     final float[] array;
231     final int start;
232     final int end;
233     FloatArrayAsList(float[] array) {
234       this(array, 0, array.length);
235     }
236     FloatArrayAsList(float[] array, int start, int end) {
237 <a name="1"></a>      this.array = array;
238       this.start = start;
239       this.end = end;
240     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
241     @Override
242     public int size() {
243       return end - start;
244     }
245     @Override
246     public boolean isEmpty() {
247       return false;
248     }
249     @</b></font>Override
250 <a name="3"></a>    public Float get(int index) {
251       checkElementIndex(index, size());
252       return array[start + index];
253     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
254     @Override
255     public boolean contains(@CheckForNull Object target) {
256       return (target instanceof Float) &amp;&amp; Floats.indexOf(array, (Float) target, start, end) != -1;
257     }
258     @</b></font>Override
259     public int indexOf(@CheckForNull Object target) {
260       if (target instanceof Float) {
261         int i = Floats.indexOf(array, (Float) target, start, end);
262         if (i &gt;= 0) {
263           return i - start;
264         }
265       }
266       return -1;
267     }
268     @Override
269     public int lastIndexOf(@CheckForNull Object target) {
270       if (target instanceof Float) {
271         int i = Floats.lastIndexOf(array, (Float) target, start, end);
272         if (i &gt;= 0) {
273           return i - start;
274         }
275       }
276       return -1;
277     }
278     @Override
279     public Float set(int index, Float element) {
280       checkElementIndex(index, size());
281       float oldValue = array[start + index];
282       array[start + index] = checkNotNull(element);
283       return oldValue;
284     }
285     @Override
286     public List&lt;Float&gt; subList(int fromIndex, int toIndex) {
287       int size = size();
288       checkPositionIndexes(fromIndex, toIndex, size);
289       if (fromIndex == toIndex) {
290         return Collections.emptyList();
291       }
292       return new FloatArrayAsList(array, start + fromIndex, start + toIndex);
293     }
294     @Override
295     public boolean equals(@CheckForNull Object object) {
296       if (object == this) {
297         return true;
298       }
299       if (object instanceof FloatArrayAsList) {
300         FloatArrayAsList that = (FloatArrayAsList) object;
301         int size = size();
302         if (that.size() != size) {
303           return false;
304         }
305         for (int i = 0; i &lt; size; i++) {
306           if (array[start + i] != that.array[that.start + i]) {
307             return false;
308           }
309         }
310         return true;
311       }
312       return super.equals(object);
313     }
314     @Override
315     public int hashCode() {
316       int result = 1;
317       for (int i = start; i &lt; end; i++) {
318         result = 31 * result + Floats.hashCode(array[i]);
319       }
320       return result;
321     }
322     @Override
323     public String toString() {
324       StringBuilder builder = new StringBuilder(size() * 12);
325       builder.append('[').append(array[start]);
326       for (int i = start + 1; i &lt; end; i++) {
327 <a name="5"></a>        builder.append(", ").append(array[i]);
328       }
329       return builder.append(']').toString();
330     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
331     float[] toFloatArray() {
332       return Arrays.copyOfRange(array, start, end);
333     }
334     private static final long serialVersionUID = 0;
335   }</b></font>
336   @Beta
337   @GwtIncompatible   @CheckForNull
338   public static Float tryParse(String string) {
339     if (Doubles.FLOATING_POINT_PATTERN.matcher(string).matches()) {
340       try {
341         return Float.parseFloat(string);
342       } catch (NumberFormatException e) {
343       }
344     }
345     return null;
346   }
347 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
