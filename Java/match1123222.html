<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for StandardMutableNetwork.java &amp; ByteSourceTest_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for StandardMutableNetwork.java &amp; ByteSourceTest_1.java
      </h3>
<h1 align="center">
        6.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>StandardMutableNetwork.java (15.263158%)<th>ByteSourceTest_1.java (4.136947%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(71-77)<td><a href="#" name="0">(462-468)</a><td align="center"><font color="#ff0000">10</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(17-28)<td><a href="#" name="1">(17-28)</a><td align="center"><font color="#ff0000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(158-162)<td><a href="#" name="2">(235-250)</a><td align="center"><font color="#e50000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>StandardMutableNetwork.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.graph;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.base.Preconditions.checkState;
5 import static com.google.common.graph.GraphConstants.PARALLEL_EDGES_NOT_ALLOWED;
6 import static com.google.common.graph.GraphConstants.REUSING_EDGE;
7 import static com.google.common.graph.GraphConstants.SELF_LOOPS_NOT_ALLOWED;
8 import static java.util.Objects.requireNonNull;
9 import com.google.common.collect.ImmutableList;
10 import</b></font> com.google.errorprone.annotations.CanIgnoreReturnValue;
11 @ElementTypesAreNonnullByDefault
12 final class StandardMutableNetwork&lt;N, E&gt; extends StandardNetwork&lt;N, E&gt;
13     implements MutableNetwork&lt;N, E&gt; {
14   StandardMutableNetwork(NetworkBuilder&lt;? super N, ? super E&gt; builder) {
15     super(builder);
16   }
17   @Override
18   @CanIgnoreReturnValue
19   public boolean addNode(N node) {
20     checkNotNull(node, "node");
21     if (containsNode(node)) {
22       return false;
23     }
24     addNodeInternal(node);
25     return true;
26   }
27   @CanIgnoreReturnValue
28   private NetworkConnections&lt;N, E&gt; addNodeInternal(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>N node) {
29     NetworkConnections&lt;N, E&gt; connections = newConnections();
30     checkState(nodeConnections.put(node, connections) == null);
31     return connections;
32   }
33   @Overri</b></font>de
34   @CanIgnoreReturnValue
35   public boolean addEdge(N nodeU, N nodeV, E edge) {
36     checkNotNull(nodeU, "nodeU");
37     checkNotNull(nodeV, "nodeV");
38     checkNotNull(edge, "edge");
39     if (containsEdge(edge)) {
40       EndpointPair&lt;N&gt; existingIncidentNodes = incidentNodes(edge);
41       EndpointPair&lt;N&gt; newIncidentNodes = EndpointPair.of(this, nodeU, nodeV);
42       checkArgument(
43           existingIncidentNodes.equals(newIncidentNodes),
44           REUSING_EDGE,
45           edge,
46           existingIncidentNodes,
47           newIncidentNodes);
48       return false;
49     }
50     NetworkConnections&lt;N, E&gt; connectionsU = nodeConnections.get(nodeU);
51     if (!allowsParallelEdges()) {
52       checkArgument(
53           !(connectionsU != null &amp;&amp; connectionsU.successors().contains(nodeV)),
54           PARALLEL_EDGES_NOT_ALLOWED,
55           nodeU,
56           nodeV);
57     }
58     boolean isSelfLoop = nodeU.equals(nodeV);
59     if (!allowsSelfLoops()) {
60       checkArgument(!isSelfLoop, SELF_LOOPS_NOT_ALLOWED, nodeU);
61     }
62     if (connectionsU == null) {
63       connectionsU = addNodeInternal(nodeU);
64     }
65     connectionsU.addOutEdge(edge, nodeV);
66     NetworkConnections&lt;N, E&gt; connectionsV = nodeConnections.get(nodeV);
67     if (connectionsV == null) {
68       connectionsV = addNodeInternal(nodeV);
69     }
70     connectionsV.addInEdge(edge, nodeU, isSelfLoop);
71     edgeToReferenceNode.put(edge, nodeU);
72     return true;
73   }
74   @Override
75   @CanIgnoreReturnValue
76   public boolean addEdge(EndpointPair&lt;N&gt; endpoints, E edge) {
77     validateEndpoints(endpoints);
78     return addEdge(endpoints.nodeU(), endpoints.nodeV(), edge);
79   }
80   @Override
81   @CanIgnoreReturnValue
82   public boolean removeNode(N node) {
83     checkNotNull(node, "node");
84     NetworkConnections&lt;N, E&gt; connections = nodeConnections.get(node);
85     if (connections == null) {
86       return false;
87     }
88     for (E edge : ImmutableList.copyOf(connections.incidentEdges())) {
89       removeEdge(edge);
90     }
91     nodeConnections.remove(node);
92     return true;
93   }
94   @Override
95   @CanIgnoreReturnValue
96   public boolean removeEdge(E edge) {
97     checkNotNull(edge, "edge");
98     N nodeU = edgeToReferenceNode.get(edge);
99     if (nodeU == null) {
100       return false;
101 <a name="2"></a>    }
102     NetworkConnections&lt;N, E&gt; connectionsU = requireNonNull(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>nodeConnections.get(nodeU));
103     N nodeV = connectionsU.adjacentNode(edge);
104     NetworkConnections&lt;N, E&gt; connectionsV = requireNonNull(nodeConnections.get(nodeV));
105     connectionsU.removeOutEdge(edge);
106     connectionsV.removeInEdge(edge, allowsSelfLoops</b></font>() &amp;&amp; nodeU.equals(nodeV));
107     edgeToReferenceNode.remove(edge);
108     return true;
109   }
110   private NetworkConnections&lt;N, E&gt; newConnections() {
111     return isDirected()
112         ? allowsParallelEdges()
113             ? DirectedMultiNetworkConnections.&lt;N, E&gt;of()
114             : DirectedNetworkConnections.&lt;N, E&gt;of()
115         : allowsParallelEdges()
116             ? UndirectedMultiNetworkConnections.&lt;N, E&gt;of()
117             : UndirectedNetworkConnections.&lt;N, E&gt;of();
118   }
119 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ByteSourceTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.io;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.io.TestOption.AVAILABLE_ALWAYS_ZERO;
4 import static com.google.common.io.TestOption.CLOSE_THROWS;
5 import static com.google.common.io.TestOption.OPEN_THROWS;
6 import static com.google.common.io.TestOption.READ_THROWS;
7 import static com.google.common.io.TestOption.SKIP_THROWS;
8 import static com.google.common.io.TestOption.WRITE_THROWS;
9 import static org.junit.Assert.assertArrayEquals;
10 import</b></font> com.google.common.base.Charsets;
11 import com.google.common.collect.ImmutableList;
12 import com.google.common.collect.ImmutableSet;
13 import com.google.common.collect.Iterables;
14 import com.google.common.hash.Hashing;
15 import com.google.common.io.Closer.LoggingSuppressor;
16 import com.google.common.primitives.UnsignedBytes;
17 import com.google.common.testing.TestLogHandler;
18 import java.io.ByteArrayOutputStream;
19 import java.io.IOException;
20 import java.io.InputStream;
21 import java.io.OutputStream;
22 import java.util.Arrays;
23 import java.util.EnumSet;
24 import junit.framework.TestSuite;
25 public class ByteSourceTest extends IoTestCase {
26   @AndroidIncompatible   public static TestSuite suite() {
27     TestSuite suite = new TestSuite();
28     for (boolean asCharSource : new boolean[] {false, true}) {
29       suite.addTest(
30           ByteSourceTester.tests(
31               "ByteSource.wrap[byte[]]",
32               SourceSinkFactories.byteArraySourceFactory(),
33               asCharSource));
34       suite.addTest(
35           ByteSourceTester.tests(
36               "ByteSource.empty[]", SourceSinkFactories.emptyByteSourceFactory(), asCharSource));
37     }
38     suite.addTestSuite(ByteSourceTest.class);
39     return suite;
40   }
41   private static final byte[] bytes = newPreFilledByteArray(10000);
42   private TestByteSource source;
43   @Override
44   protected void setUp() throws Exception {
45     source = new TestByteSource(bytes);
46   }
47   public void testOpenBufferedStream() throws IOException {
48     InputStream in = source.openBufferedStream();
49     assertTrue(source.wasStreamOpened());
50     assertFalse(source.wasStreamClosed());
51     ByteArrayOutputStream out = new ByteArrayOutputStream();
52     ByteStreams.copy(in, out);
53     in.close();
54     out.close();
55     assertTrue(source.wasStreamClosed());
56     assertArrayEquals(bytes, out.toByteArray());
57   }
58   public void testSize() throws IOException {
59     assertEquals(bytes.length, source.size());
60     assertTrue(source.wasStreamOpened() &amp;&amp; source.wasStreamClosed());
61     assertEquals(bytes.length, new TestByteSource(bytes, SKIP_THROWS).size());
62     assertEquals(bytes.length, new TestByteSource(bytes, AVAILABLE_ALWAYS_ZERO).size());
63   }
64   public void testCopyTo_outputStream() throws IOException {
65     ByteArrayOutputStream out = new ByteArrayOutputStream();
66     assertEquals(bytes.length, source.copyTo(out));
67     assertTrue(source.wasStreamOpened() &amp;&amp; source.wasStreamClosed());
68     assertArrayEquals(bytes, out.toByteArray());
69   }
70   public void testCopyTo_byteSink() throws IOException {
71     TestByteSink sink = new TestByteSink();
72     assertFalse(sink.wasStreamOpened() || sink.wasStreamClosed());
73     assertEquals(bytes.length, source.copyTo(sink));
74     assertTrue(source.wasStreamOpened() &amp;&amp; source.wasStreamClosed());
75     assertTrue(sink.wasStreamOpened() &amp;&amp; sink.wasStreamClosed());
76     assertArrayEquals(bytes, sink.getBytes());
77   }
78   public void testRead_toArray() throws IOException {
79     assertArrayEquals(bytes, source.read());
80     assertTrue(source.wasStreamOpened() &amp;&amp; source.wasStreamClosed());
81   }
82   public void testRead_withProcessor() throws IOException {
83     final byte[] processedBytes = new byte[bytes.length];
84     ByteProcessor&lt;byte[]&gt; processor =
85         new ByteProcessor&lt;byte[]&gt;() {
86           int pos;
87           @Override
88           public boolean processBytes(byte[] buf, int off, int len) throws IOException {
89             System.arraycopy(buf, off, processedBytes, pos, len);
90             pos += len;
91             return true;
92           }
93           @Override
94           public byte[] getResult() {
95             return processedBytes;
96           }
97         };
98     source.read(processor);
99     assertTrue(source.wasStreamOpened() &amp;&amp; source.wasStreamClosed());
100     assertArrayEquals(bytes, processedBytes);
101   }
102   public void testRead_withProcessor_stopsOnFalse() throws IOException {
103     ByteProcessor&lt;Void&gt; processor =
104         new ByteProcessor&lt;Void&gt;() {
105           boolean firstCall = true;
106           @Override
107           public boolean processBytes(byte[] buf, int off, int len) throws IOException {
108             assertTrue("consume() called twice", firstCall);
109             firstCall = false;
110             return false;
111           }
112           @Override
113           public Void getResult() {
114             return null;
115           }
116         };
117     source.read(processor);
118     assertTrue(source.wasStreamOpened() &amp;&amp; source.wasStreamClosed());
119   }
120   public void testHash() throws IOException {
121     ByteSource byteSource = new TestByteSource("hamburger\n".getBytes(Charsets.US_ASCII));
122     assertEquals("cfa0c5002275c90508338a5cdb2a9781", byteSource.hash(Hashing.md5()).toString());
123   }
124   public void testContentEquals() throws IOException {
125     assertTrue(source.contentEquals(source));
126     assertTrue(source.wasStreamOpened() &amp;&amp; source.wasStreamClosed());
127     ByteSource equalSource = new TestByteSource(bytes);
128     assertTrue(source.contentEquals(equalSource));
129     assertTrue(new TestByteSource(bytes).contentEquals(source));
130     ByteSource fewerBytes = new TestByteSource(newPreFilledByteArray(bytes.length / 2));
131     assertFalse(source.contentEquals(fewerBytes));
132     byte[] copy = bytes.clone();
133     copy[9876] = 1;
134     ByteSource oneByteOff = new TestByteSource(copy);
135     assertFalse(source.contentEquals(oneByteOff));
136   }
137   public void testSlice() throws IOException {
138     try {
139       source.slice(-1, 10);
140       fail();
141     } catch (IllegalArgumentException expected) {
142     }
143     try {
144       source.slice(0, -1);
145       fail();
146     } catch (IllegalArgumentException expected) {
147     }
148     assertCorrectSlice(0, 0, 0, 0);
149     assertCorrectSlice(0, 0, 1, 0);
150     assertCorrectSlice(100, 0, 10, 10);
151     assertCorrectSlice(100, 0, 100, 100);
152     assertCorrectSlice(100, 5, 10, 10);
153     assertCorrectSlice(100, 5, 100, 95);
154     assertCorrectSlice(100, 100, 0, 0);
155     assertCorrectSlice(100, 100, 10, 0);
156     assertCorrectSlice(100, 101, 10, 0);
157   }
158 <a name="2"></a>    public void testSlice_appendingAfterSlicing() throws IOException {
159     AppendableByteSource source = new AppendableByteSource(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>newPreFilledByteArray(5));
160     ByteSource slice = source.slice(10, 5);
161     InputStream in = slice.openStream();
162     source.append(newPreFilledByteArray(5, 10));
163     assertEquals(-1, in.read</b></font>());
164   }
165   private static class AppendableByteSource extends ByteSource {
166     private byte[] bytes;
167     public AppendableByteSource(byte[] initialBytes) {
168       this.bytes = initialBytes.clone();
169     }
170     @Override
171     public InputStream openStream() {
172       return new In();
173     }
174     public void append(byte[] b) {
175       byte[] newBytes = Arrays.copyOf(bytes, bytes.length + b.length);
176       System.arraycopy(b, 0, newBytes, bytes.length, b.length);
177       bytes = newBytes;
178     }
179     private class In extends InputStream {
180       private int pos;
181       @Override
182       public int read() throws IOException {
183         byte[] b = new byte[1];
184         return read(b) == -1 ? -1 : UnsignedBytes.toInt(b[0]);
185       }
186       @Override
187       public int read(byte[] b, int off, int len) {
188         if (pos &gt;= bytes.length) {
189           return -1;
190         }
191         int lenToRead = Math.min(len, bytes.length - pos);
192         System.arraycopy(bytes, pos, b, off, lenToRead);
193         pos += lenToRead;
194         return lenToRead;
195       }
196     }
197   }
198   private static void assertCorrectSlice(int input, int offset, long length, int expectRead)
199       throws IOException {
200     checkArgument(expectRead == (int) Math.max(0, Math.min(input, offset + length) - offset));
201     byte[] expected = newPreFilledByteArray(offset, expectRead);
202     ByteSource source = new TestByteSource(newPreFilledByteArray(input));
203     ByteSource slice = source.slice(offset, length);
204     assertArrayEquals(expected, slice.read());
205   }
206   public void testCopyToStream_doesNotCloseThatStream() throws IOException {
207     TestOutputStream out = new TestOutputStream(ByteStreams.nullOutputStream());
208     assertFalse(out.closed());
209     source.copyTo(out);
210     assertFalse(out.closed());
211   }
212   public void testClosesOnErrors_copyingToByteSinkThatThrows() {
213     for (TestOption option : EnumSet.of(OPEN_THROWS, WRITE_THROWS, CLOSE_THROWS)) {
214       TestByteSource okSource = new TestByteSource(bytes);
215       try {
216         okSource.copyTo(new TestByteSink(option));
217         fail();
218       } catch (IOException expected) {
219       }
220       assertTrue(
221           "stream not closed when copying to sink with option: " + option,
222           !okSource.wasStreamOpened() || okSource.wasStreamClosed());
223     }
224   }
225   public void testClosesOnErrors_whenReadThrows() {
226     TestByteSource failSource = new TestByteSource(bytes, READ_THROWS);
227     try {
228       failSource.copyTo(new TestByteSink());
229       fail();
230     } catch (IOException expected) {
231     }
232     assertTrue(failSource.wasStreamClosed());
233   }
234   public void testClosesOnErrors_copyingToOutputStreamThatThrows() {
235     TestByteSource okSource = new TestByteSource(bytes);
236     try {
237       OutputStream out = new TestOutputStream(ByteStreams.nullOutputStream(), WRITE_THROWS);
238       okSource.copyTo(out);
239       fail();
240     } catch (IOException expected) {
241     }
242     assertTrue(okSource.wasStreamClosed());
243   }
244   public void testConcat() throws IOException {
245     ByteSource b1 = ByteSource.wrap(new byte[] {0, 1, 2, 3});
246     ByteSource b2 = ByteSource.wrap(new byte[0]);
247     ByteSource b3 = ByteSource.wrap(new byte[] {4, 5});
248     byte[] expected = {0, 1, 2, 3, 4, 5};
249     assertArrayEquals(expected, ByteSource.concat(ImmutableList.of(b1, b2, b3)).read());
250     assertArrayEquals(expected, ByteSource.concat(b1, b2, b3).read());
251     assertArrayEquals(expected, ByteSource.concat(ImmutableList.of(b1, b2, b3).iterator()).read());
252     assertEquals(expected.length, ByteSource.concat(b1, b2, b3).size());
253     assertFalse(ByteSource.concat(b1, b2, b3).isEmpty());
254     ByteSource emptyConcat = ByteSource.concat(ByteSource.empty(), ByteSource.empty());
255     assertTrue(emptyConcat.isEmpty());
256     assertEquals(0, emptyConcat.size());
257   }
258   public void testConcat_infiniteIterable() throws IOException {
259     ByteSource source = ByteSource.wrap(new byte[] {0, 1, 2, 3});
260     Iterable&lt;ByteSource&gt; cycle = Iterables.cycle(ImmutableList.of(source));
261     ByteSource concatenated = ByteSource.concat(cycle);
262     byte[] expected = {0, 1, 2, 3, 0, 1, 2, 3};
263     assertArrayEquals(expected, concatenated.slice(0, 8).read());
264   }
265   private static final ByteSource BROKEN_CLOSE_SOURCE =
266       new TestByteSource(new byte[10], CLOSE_THROWS);
267   private static final ByteSource BROKEN_OPEN_SOURCE =
268       new TestByteSource(new byte[10], OPEN_THROWS);
269   private static final ByteSource BROKEN_READ_SOURCE =
270       new TestByteSource(new byte[10], READ_THROWS);
271   private static final ByteSink BROKEN_CLOSE_SINK = new TestByteSink(CLOSE_THROWS);
272   private static final ByteSink BROKEN_OPEN_SINK = new TestByteSink(OPEN_THROWS);
273   private static final ByteSink BROKEN_WRITE_SINK = new TestByteSink(WRITE_THROWS);
274   private static final ImmutableSet&lt;ByteSource&gt; BROKEN_SOURCES =
275       ImmutableSet.of(BROKEN_CLOSE_SOURCE, BROKEN_OPEN_SOURCE, BROKEN_READ_SOURCE);
276   private static final ImmutableSet&lt;ByteSink&gt; BROKEN_SINKS =
277       ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);
278   public void testCopyExceptions() {
279     if (Closer.create().suppressor instanceof LoggingSuppressor) {
280       TestLogHandler logHandler = new TestLogHandler();
281       Closeables.logger.addHandler(logHandler);
282       try {
283         for (ByteSource in : BROKEN_SOURCES) {
284           runFailureTest(in, newNormalByteSink());
285           assertTrue(logHandler.getStoredLogRecords().isEmpty());
286           runFailureTest(in, BROKEN_CLOSE_SINK);
287           assertEquals((in == BROKEN_OPEN_SOURCE) ? 0 : 1, getAndResetRecords(logHandler));
288         }
289         for (ByteSink out : BROKEN_SINKS) {
290           runFailureTest(newNormalByteSource(), out);
291           assertTrue(logHandler.getStoredLogRecords().isEmpty());
292           runFailureTest(BROKEN_CLOSE_SOURCE, out);
293           assertEquals(1, getAndResetRecords(logHandler));
294         }
295         for (ByteSource in : BROKEN_SOURCES) {
296           for (ByteSink out : BROKEN_SINKS) {
297             runFailureTest(in, out);
298             assertTrue(getAndResetRecords(logHandler) &lt;= 1);
299           }
300         }
301       } finally {
302         Closeables.logger.removeHandler(logHandler);
303       }
304     } else {
305       for (ByteSource in : BROKEN_SOURCES) {
306         int suppressed = runSuppressionFailureTest(in, newNormalByteSink());
307         assertEquals(0, suppressed);
308         suppressed = runSuppressionFailureTest(in, BROKEN_CLOSE_SINK);
309         assertEquals((in == BROKEN_OPEN_SOURCE) ? 0 : 1, suppressed);
310       }
311       for (ByteSink out : BROKEN_SINKS) {
312         int suppressed = runSuppressionFailureTest(newNormalByteSource(), out);
313         assertEquals(0, suppressed);
314         suppressed = runSuppressionFailureTest(BROKEN_CLOSE_SOURCE, out);
315         assertEquals(1, suppressed);
316       }
317       for (ByteSource in : BROKEN_SOURCES) {
318         for (ByteSink out : BROKEN_SINKS) {
319           int suppressed = runSuppressionFailureTest(in, out);
320           assertTrue(suppressed &lt;= 1);
321         }
322       }
323     }
324   }
325   public void testSlice_returnEmptySource() {
326 <a name="0"></a>    assertEquals(ByteSource.empty(), source.slice(0, 3).slice(4, 3));
327   }
328   private static int getAndResetRecords(<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>TestLogHandler logHandler) {
329     int records = logHandler.getStoredLogRecords().size();
330     logHandler.clear();
331     return records;
332   }
333   private static</b></font> void runFailureTest(ByteSource in, ByteSink out) {
334     try {
335       in.copyTo(out);
336       fail();
337     } catch (IOException expected) {
338     }
339   }
340   private static int runSuppressionFailureTest(ByteSource in, ByteSink out) {
341     try {
342       in.copyTo(out);
343       fail();
344     } catch (IOException expected) {
345       return CloserTest.getSuppressed(expected).length;
346     }
347     throw new AssertionError();   }
348   private static ByteSource newNormalByteSource() {
349     return ByteSource.wrap(new byte[10]);
350   }
351   private static ByteSink newNormalByteSink() {
352     return new ByteSink() {
353       @Override
354       public OutputStream openStream() {
355         return new ByteArrayOutputStream();
356       }
357     };
358   }
359 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
