<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for KillAnalyzer.java & CreateAlterTableStatementAnalyzerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for KillAnalyzer.java & CreateAlterTableStatementAnalyzerTest.java
      </h3>
      <h1 align="center">
        1.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>KillAnalyzer.java (22.727272%)<TH>CreateAlterTableStatementAnalyzerTest.java (0.5125577%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match4594539-0.html#0',2,'match4594539-1.html#0',3)" NAME="0">(24-35)<TD><A HREF="javascript:ZweiFrames('match4594539-0.html#0',2,'match4594539-1.html#0',3)" NAME="0">(77-88)</A><TD ALIGN=center><FONT COLOR="#ff0000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>KillAnalyzer.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.analyze;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match4594539-1.html#0',3,'match4594539-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.analyze.expressions.ExpressionAnalysisContext;
import io.crate.analyze.expressions.ExpressionAnalyzer;
import io.crate.analyze.relations.FieldProvider;
import io.crate.expression.symbol.Symbol;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.NodeContext;
import io.crate.sql.tree.Expression;
import io.crate.sql.tree.KillStatement;

public class KillAnalyzer {

    private final NodeContext nodeCtx</B></FONT>;

    KillAnalyzer(NodeContext nodeCtx) {
        this.nodeCtx = nodeCtx;
    }

    public AnalyzedKill analyze(KillStatement&lt;Expression&gt; killStatement,
                                ParamTypeHints paramTypeHints,
                                CoordinatorTxnCtx txnCtx) {
        Symbol jobId;
        if (killStatement.jobId() != null) {
            var exprAnalyzerWithoutFields = new ExpressionAnalyzer(
                txnCtx, nodeCtx, paramTypeHints, FieldProvider.UNSUPPORTED, null);
            jobId = exprAnalyzerWithoutFields.convert(
                killStatement.jobId(),
                new ExpressionAnalysisContext(txnCtx.sessionContext()));
        } else {
            jobId = null;
        }
        return new AnalyzedKill(jobId);
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CreateAlterTableStatementAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.analyze;

import io.crate.common.collections.Maps;
import io.crate.data.RowN;
import io.crate.exceptions.ColumnUnknownException;
import io.crate.exceptions.InvalidColumnNameException;
import io.crate.exceptions.InvalidRelationName;
import io.crate.exceptions.InvalidSchemaNameException;
import io.crate.exceptions.OperationOnInaccessibleRelationException;
import io.crate.exceptions.RelationAlreadyExists;
import io.crate.exceptions.UnsupportedFeatureException;
import io.crate.metadata.ColumnIdent;
import io.crate.metadata.FulltextAnalyzerResolver;
import io.crate.metadata.RelationName;
import io.crate.metadata.Schemas;
import io.crate.planner.PlannerContext;
import io.crate.planner.node.ddl.AlterTableAddColumnPlan;
import io.crate.planner.node.ddl.AlterTableDropCheckConstraintPlan;
import io.crate.planner.node.ddl.AlterTablePlan;
import io.crate.planner.node.ddl.CreateBlobTablePlan;
import io.crate.planner.node.ddl.CreateTablePlan;
import io.crate.planner.operators.SubQueryResults;
import io.crate.sql.parser.ParsingException;
import io.crate.sql.tree.ColumnPolicy;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.types.DataTypes;
import org.elasticsearch.cluster.ClusterName;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.metadata.AutoExpandReplicas;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.Metadata;
import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;
import org.elasticsearch.cluster.routing.allocation.decider.MaxRetryAllocationDecider;
import org.elasticsearch.common.Randomness;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.index.IndexSettings;
import org.elasticsearch.index.mapper.MapperService;
import org.elasticsearch.test.ClusterServiceUtils;
import org.hamcrest.Matchers;
import org.junit.Before;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static com.carrotsearch.randomizedtesting.RandomizedTest.$;
<A NAME="0"></A>import static io.crate.metadata.FulltextAnalyzerResolver.CustomType.ANALYZER;
import static io.crate.testing.Asserts.assertThrowsMatches;
import static io.crate.testing.TestingHelpers.mapToSortedString;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4594539-0.html#0',2,'match4594539-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_ROUTING_EXCLUDE_GROUP_SETTING;
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.isEmptyOrNullString;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.Matchers.startsWith;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class CreateAlterTableStatementAnalyzerTest extends CrateDummyClusterServiceUnitTest {

    private SQLExecutor e</B></FONT>;
    private PlannerContext plannerContext;

    @Before
    public void prepare() throws IOException {
        String analyzerSettings = FulltextAnalyzerResolver.encodeSettings(
            Settings.builder().put(&quot;search&quot;, &quot;foobar&quot;).build()).utf8ToString();
        Metadata metadata = Metadata.builder()
            .persistentSettings(
                Settings.builder().put(ANALYZER.buildSettingName(&quot;ft_search&quot;), analyzerSettings).build())
            .build();
        ClusterState state = ClusterState.builder(ClusterName.DEFAULT)
            .metadata(metadata)
            .build();
        ClusterServiceUtils.setState(clusterService, state);
        e = SQLExecutor.builder(clusterService, 3, Randomness.get(), List.of())
            .enableDefaultTables()
            .build();
        plannerContext = e.getPlannerContext(clusterService.state());
    }

    private &lt;S&gt; S analyze(String stmt, Object... arguments) {
        return analyze(e, stmt, arguments);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;S&gt; S analyze(SQLExecutor e, String stmt, Object... arguments) {
        AnalyzedStatement analyzedStatement = e.analyze(stmt);
        if (analyzedStatement instanceof AnalyzedCreateTable) {
            return (S) CreateTablePlan.bind(
                (AnalyzedCreateTable) analyzedStatement,
                plannerContext.transactionContext(),
                plannerContext.nodeContext(),
                new RowN(arguments),
                SubQueryResults.EMPTY,
                new NumberOfShards(clusterService),
                e.schemas(),
                e.fulltextAnalyzerResolver()
            );
        } else if (analyzedStatement instanceof AnalyzedAlterTable) {
            return (S) AlterTablePlan.bind(
                (AnalyzedAlterTable) analyzedStatement,
                plannerContext.transactionContext(),
                plannerContext.nodeContext(),
                new RowN(arguments),
                SubQueryResults.EMPTY
            );
        } else if (analyzedStatement instanceof AnalyzedAlterTableAddColumn) {
            return (S) AlterTableAddColumnPlan.bind(
                (AnalyzedAlterTableAddColumn) analyzedStatement,
                plannerContext.transactionContext(),
                plannerContext.nodeContext(),
                new RowN(arguments),
                SubQueryResults.EMPTY,
                null
            );
        } else if (analyzedStatement instanceof AnalyzedAlterTableDropCheckConstraint) {
            return (S) AlterTableDropCheckConstraintPlan.bind(
                (AnalyzedAlterTableDropCheckConstraint) analyzedStatement
            );
        } else {
            return (S) analyzedStatement;
        }
    }

    @Test
    public void testTimestampDataTypeDeprecationWarning() {
        analyze(&quot;create table t (ts timestamp)&quot;);
        assertWarnings(
            &quot;Column [ts]: Usage of the `TIMESTAMP` data type as a timestamp with zone is deprecated,&quot; +
            &quot; use the `TIMESTAMPTZ` or `TIMESTAMP WITH TIME ZONE` data type instead.&quot;
        );
    }

    @Test
    public void test_cannot_create_table_that_contains_a_column_definition_of_type_time () {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot use the type `time with time zone` for column: ts&quot;);
        analyze(&quot;create table t (ts time with time zone)&quot;);
    }

    @Test
    public void test_cannot_alter_table_to_add_a_column_definition_of_type_time () {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot use the type `time with time zone` for column: ts&quot;);
        analyze(&quot;alter table user_refresh_interval add column ts time with time zone&quot;);
    }

    @Test
    public void testCreateTableInSystemSchemasIsProhibited() {
        for (String schema : Schemas.READ_ONLY_SYSTEM_SCHEMAS) {
            try {
                analyze(String.format(&quot;CREATE TABLE %s.%s (ordinal INTEGER, name STRING)&quot;, schema, &quot;my_table&quot;));
                fail(&quot;create table in read-only schema must fail&quot;);
            } catch (IllegalArgumentException e) {
                assertThat(e.getLocalizedMessage(), startsWith(&quot;Cannot create relation in read-only schema: &quot; + schema));
            }
        }
    }

    @Test
    public void testCreateTableWithAlternativePrimaryKeySyntax() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer, name string, primary key (id, name))&quot;
        );

        String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
        assertThat(primaryKeys.length, is(2));
        assertThat(primaryKeys[0], is(&quot;id&quot;));
        assertThat(primaryKeys[1], is(&quot;name&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testSimpleCreateTable() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, name string not null) &quot; +
            &quot;clustered into 3 shards with (number_of_replicas=0)&quot;);

        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;3&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is(&quot;0&quot;));

        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));

        assertNull(metaMapping.get(&quot;columns&quot;));

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();

        Map&lt;String, Object&gt; idMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;id&quot;);
        assertThat(idMapping.get(&quot;type&quot;), is(&quot;integer&quot;));

        Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;name&quot;);
        assertThat(nameMapping.get(&quot;type&quot;), is(&quot;keyword&quot;));

        String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
        assertThat(primaryKeys.length, is(1));
        assertThat(primaryKeys[0], is(&quot;id&quot;));

        String[] notNullColumns = analysis.notNullColumns().toArray(new String[0]);
        assertThat(notNullColumns.length, is(1));
        assertThat(notNullColumns[0], is(&quot;name&quot;));
    }

    @Test
    public void testCreateTableWithDefaultNumberOfShards() {
        BoundCreateTable analysis = analyze(&quot;create table foo (id integer primary key, name string)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;6&quot;));
    }

    @Test
    public void testCreateTableWithDefaultNumberOfShardsWithClusterByClause() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key) clustered by (id)&quot;
        );
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;6&quot;));
    }

    @Test
    public void testCreateTableNumberOfShardsProvidedInClusteredClause() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key) &quot; +
            &quot;clustered by (id) into 8 shards&quot;
        );
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;8&quot;));
    }

    @Test
    public void testCreateTableWithTotalFieldsLimit() {
        BoundCreateTable analysis = analyze(
            &quot;CREATE TABLE foo (id int primary key) &quot; +
            &quot;with (\&quot;mapping.total_fields.limit\&quot;=5000)&quot;);
        assertThat(analysis.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()), is(&quot;5000&quot;));
    }

    @Test
    public void testCreateTableWithRefreshInterval() {
        BoundCreateTable analysis = analyze(
            &quot;CREATE TABLE foo (id int primary key, content string) &quot; +
            &quot;with (refresh_interval='5000ms')&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()), is(&quot;5s&quot;));
    }

    @Test
    public void testCreateTableWithNumberOfShardsOnWithClauseIsInvalid() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Invalid property \&quot;number_of_shards\&quot; passed to [ALTER | CREATE] TABLE statement&quot;);
        analyze(&quot;CREATE TABLE foo (id int primary key, content string) &quot; +
                &quot;with (number_of_shards=8)&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testCreateTableWithRefreshIntervalWrongNumberFormat() {
        analyze(&quot;CREATE TABLE foo (id int primary key, content string) &quot; +
                &quot;with (refresh_interval='1asdf')&quot;);
    }

    @Test
    public void testAlterTableWithRefreshInterval() {
        // alter t set
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE user_refresh_interval &quot; +
            &quot;SET (refresh_interval = '5000ms')&quot;);
        assertEquals(&quot;5s&quot;, analysisSet.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()));

        // alter t reset
        BoundAlterTable analysisReset = analyze(
            &quot;ALTER TABLE user_refresh_interval &quot; +
            &quot;RESET (refresh_interval)&quot;);
        assertEquals(&quot;1s&quot;, analysisReset.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()));
    }

    @Test
    public void testTotalFieldsLimitCanBeUsedWithAlterTable() {
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE users &quot; +
            &quot;SET (\&quot;mapping.total_fields.limit\&quot; = '5000')&quot;);
        assertEquals(&quot;5000&quot;, analysisSet.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()));

        // Check if resetting total_fields results in default value
        BoundAlterTable analysisReset = analyze(
            &quot;ALTER TABLE users &quot; +
            &quot;RESET (\&quot;mapping.total_fields.limit\&quot;)&quot;);
        assertEquals(&quot;1000&quot;, analysisReset.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()));
    }

    @Test
    public void testAlterTableWithColumnPolicy() {
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE user_refresh_interval &quot; +
            &quot;SET (column_policy = 'strict')&quot;);
        assertEquals(
            ColumnPolicy.STRICT.lowerCaseName(),
            analysisSet.tableParameter().mappings().get(TableParameters.COLUMN_POLICY.getKey()));
    }

    @Test
    public void testAlterTableWithInvalidColumnPolicy() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Invalid value for argument 'column_policy'&quot;);
        analyze(&quot;ALTER TABLE user_refresh_interval &quot; +
                  &quot;SET (column_policy = 'ignored')&quot;);
    }

    @Test
    public void testAlterTableWithMaxNGramDiffSetting() {
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE users &quot; +
            &quot;SET (max_ngram_diff = 42)&quot;);
        assertThat(analysisSet.tableParameter().settings().get(IndexSettings.MAX_NGRAM_DIFF_SETTING.getKey()), is(&quot;42&quot;));
    }

    @Test
    public void testAlterTableWithMaxShingleDiffSetting() {
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE users &quot; +
            &quot;SET (max_shingle_diff = 43)&quot;);
        assertThat(analysisSet.tableParameter().settings().get(IndexSettings.MAX_SHINGLE_DIFF_SETTING.getKey()), is(&quot;43&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithClusteredBy() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer, name string) clustered by(id)&quot;);

        Map&lt;String, Object&gt; meta = (Map) analysis.mapping().get(&quot;_meta&quot;);
        assertNotNull(meta);
        assertThat(meta.get(&quot;routing&quot;), is(&quot;id&quot;));
    }

    @Test(expected = IllegalArgumentException.class)
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithClusteredByNotInPrimaryKeys() {
        analyze(&quot;create table foo (id integer primary key, name string) clustered by(name)&quot;);
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithObjects() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details object as (name string, age integer))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;details&quot;);

        assertThat(details.get(&quot;type&quot;), is(&quot;object&quot;));
        assertThat(details.get(&quot;dynamic&quot;), is(&quot;true&quot;));

        Map&lt;String, Object&gt; detailsProperties = (Map&lt;String, Object&gt;) details.get(&quot;properties&quot;);
        Map&lt;String, Object&gt; nameProperties = (Map&lt;String, Object&gt;) detailsProperties.get(&quot;name&quot;);
        assertThat(nameProperties.get(&quot;type&quot;), is(&quot;keyword&quot;));

        Map&lt;String, Object&gt; ageProperties = (Map&lt;String, Object&gt;) detailsProperties.get(&quot;age&quot;);
        assertThat(ageProperties.get(&quot;type&quot;), is(&quot;integer&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithStrictObject() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details object(strict) as (name string, age integer))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;details&quot;);

        assertThat(details.get(&quot;type&quot;), is(&quot;object&quot;));
        assertThat(details.get(&quot;dynamic&quot;), is(&quot;strict&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithIgnoredObject()  {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details object(ignored))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;details&quot;);

        assertThat(details.get(&quot;type&quot;), is(&quot;object&quot;));
        assertThat(details.get(&quot;dynamic&quot;), is(&quot;false&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithSubscriptInFulltextIndexDefinition() {
        BoundCreateTable analysis = analyze(
            &quot;create table my_table1g (&quot; +
            &quot;   title string, &quot; +
            &quot;   author object(dynamic) as ( &quot; +
            &quot;   name string, &quot; +
            &quot;   birthday timestamp with time zone&quot; +
            &quot;), &quot; +
            &quot;INDEX author_title_ft using fulltext(title, author['name']))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;author&quot;);
        Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) ((Map&lt;String, Object&gt;) details.get(&quot;properties&quot;)).get(&quot;name&quot;);

        assertThat(((List&lt;String&gt;) nameMapping.get(&quot;copy_to&quot;)).get(0), is(&quot;author_title_ft&quot;));
    }

    @Test(expected = ColumnUnknownException.class)
    public void testCreateTableWithInvalidFulltextIndexDefinition() {
        analyze(
            &quot;create table my_table1g (&quot; +
            &quot;   title string, &quot; +
            &quot;   author object(dynamic) as ( &quot; +
            &quot;   name string, &quot; +
            &quot;   birthday timestamp with time zone&quot; +
            &quot;), &quot; +
            &quot;INDEX author_title_ft using fulltext(title, author['name']['foo']['bla']))&quot;);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableWithArray() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details array(string), more_details text[])&quot;);
        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;details&quot;);
        assertThat(details.get(&quot;type&quot;), is(&quot;array&quot;));
        Map&lt;String, Object&gt; inner = (Map&lt;String, Object&gt;) details.get(&quot;inner&quot;);
        assertThat(inner.get(&quot;type&quot;), is(&quot;keyword&quot;));


        Map&lt;String, Object&gt; moreDetails = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;more_details&quot;);
        assertThat(moreDetails.get(&quot;type&quot;), is(&quot;array&quot;));
        Map&lt;String, Object&gt; moreDetailsInner = (Map&lt;String, Object&gt;) details.get(&quot;inner&quot;);
        assertThat(moreDetailsInner.get(&quot;type&quot;), is(&quot;keyword&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithObjectsArray() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details array(object as (name string, age integer, tags array(string))))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;details={inner={dynamic=true, position=2, properties={age={position=4, type=integer}, &quot; +
                      &quot;name={position=3, type=keyword}, &quot; +
                      &quot;tags={inner={position=5, type=keyword}, type=array}}, type=object}, type=array}, &quot; +
                      &quot;id={position=1, type=integer}&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithAnalyzer() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, content string INDEX using fulltext with (analyzer='german'))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content&quot;);

        assertThat(contentMapping.get(&quot;index&quot;), nullValue());
        assertThat(contentMapping.get(&quot;analyzer&quot;), is(&quot;german&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithAnalyzerParameter() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, content string INDEX using fulltext with (analyzer=?))&quot;,
            &quot;german&quot;
        );

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content&quot;);

        assertThat(contentMapping.get(&quot;index&quot;), nullValue());
        assertThat(contentMapping.get(&quot;analyzer&quot;), is(&quot;german&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void textCreateTableWithCustomAnalyzerInNestedColumn() {
        BoundCreateTable analysis = analyze(
            &quot;create table ft_search (&quot; +
            &quot;\&quot;user\&quot; object (strict) as (&quot; +
            &quot;name string index using fulltext with (analyzer='ft_search') &quot; +
            &quot;)&quot; +
            &quot;)&quot;);
        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;user&quot;);
        Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) ((Map&lt;String, Object&gt;) details.get(&quot;properties&quot;)).get(&quot;name&quot;);

        assertThat(nameMapping.get(&quot;index&quot;), nullValue());
        assertThat(nameMapping.get(&quot;analyzer&quot;), is(&quot;ft_search&quot;));

        assertThat(analysis.tableParameter().settings().get(&quot;search&quot;), is(&quot;foobar&quot;));
    }

    @Test
    public void testCreateTableWithSchemaName() {
        BoundCreateTable analysis =
            analyze(&quot;create table something.foo (id integer primary key)&quot;);
        RelationName relationName = analysis.tableIdent();
        assertThat(relationName.schema(), is(&quot;something&quot;));
        assertThat(relationName.name(), is(&quot;foo&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithIndexColumn() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, content string, INDEX content_ft using fulltext (content))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content&quot;);

        assertThat((String) contentMapping.get(&quot;index&quot;), isEmptyOrNullString());
        assertThat(((List&lt;String&gt;) contentMapping.get(&quot;copy_to&quot;)).get(0), is(&quot;content_ft&quot;));

        Map&lt;String, Object&gt; ft_mapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content_ft&quot;);
        assertThat(ft_mapping.get(&quot;index&quot;), nullValue());
        assertThat(ft_mapping.get(&quot;analyzer&quot;), is(&quot;standard&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithPlainIndexColumn() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, content string, INDEX content_ft using plain (content))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content&quot;);

        assertThat((String) contentMapping.get(&quot;index&quot;), isEmptyOrNullString());
        assertThat(((List&lt;String&gt;) contentMapping.get(&quot;copy_to&quot;)).get(0), is(&quot;content_ft&quot;));

        Map&lt;String, Object&gt; ft_mapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content_ft&quot;);
        assertThat(ft_mapping.get(&quot;index&quot;), nullValue());
        assertThat(ft_mapping.get(&quot;analyzer&quot;), is(&quot;keyword&quot;));
    }

    @Test
    public void testCreateTableWithIndexColumnOverNonString() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;INDEX definition only support 'string' typed source columns&quot;);
        analyze(&quot;create table foo (id integer, id2 integer, INDEX id_ft using fulltext (id, id2))&quot;);
    }

    @Test
    public void testCreateTableWithIndexColumnOverNonString2() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;INDEX definition only support 'string' typed source columns&quot;);
        analyze(&quot;create table foo (id integer, name string, INDEX id_ft using fulltext (id, name))&quot;);
    }

    @Test
    public void testChangeNumberOfReplicas() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (number_of_replicas=2)&quot;);

        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is(&quot;2&quot;));
    }

    @Test
    public void testResetNumberOfReplicas() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users reset (number_of_replicas)&quot;);

        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is(&quot;0&quot;));
        assertThat(analysis.tableParameter().settings().get(AutoExpandReplicas.SETTING.getKey()), is(&quot;0-1&quot;));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testAlterTableWithInvalidProperty() {
        analyze(&quot;alter table users set (foobar='2')&quot;);
    }

    @Test
    public void testAlterSystemTable() {
        expectedException.expect(OperationOnInaccessibleRelationException.class);
        expectedException.expectMessage(&quot;The relation \&quot;sys.shards\&quot; doesn't support or allow ALTER &quot; +
                                        &quot;operations, as it is read-only.&quot;);
        analyze(&quot;alter table sys.shards reset (number_of_replicas)&quot;);
    }

    @Test
    public void testCreateTableWithMultiplePrimaryKeys() {
        BoundCreateTable analysis = analyze(
            &quot;create table test (id integer primary key, name string primary key)&quot;);

        String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
        assertThat(primaryKeys.length, is(2));
        assertThat(primaryKeys[0], is(&quot;id&quot;));
        assertThat(primaryKeys[1], is(&quot;name&quot;));
    }

    @Test
    public void testCreateTableWithMultiplePrimaryKeysAndClusteredBy() {
        BoundCreateTable analysis = analyze(
            &quot;create table test (id integer primary key, name string primary key) &quot; +
            &quot;clustered by(name)&quot;);

        String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
        assertThat(primaryKeys.length, is(2));
        assertThat(primaryKeys[0], is(&quot;id&quot;));
        assertThat(primaryKeys[1], is(&quot;name&quot;));

        //noinspection unchecked
        Map&lt;String, Object&gt; meta = (Map) analysis.mapping().get(&quot;_meta&quot;);
        assertNotNull(meta);
        assertThat(meta.get(&quot;routing&quot;), is(&quot;name&quot;));

    }

    @Test
    public void testCreateTableWithObjectAndUnderscoreColumnPrefix() {
        BoundCreateTable analysis = analyze(&quot;create table test (o object as (_id integer), name string)&quot;);

        assertThat(analysis.analyzedTableElements().columns().size(), is(2)); // id pk column is also added
        AnalyzedColumnDefinition&lt;Object&gt; column = analysis.analyzedTableElements().columns().get(0);
        assertEquals(column.ident(), new ColumnIdent(&quot;o&quot;));
        assertThat(column.children().size(), is(1));
        AnalyzedColumnDefinition&lt;Object&gt; xColumn = column.children().get(0);
        assertEquals(xColumn.ident(), new ColumnIdent(&quot;o&quot;, Collections.singletonList(&quot;_id&quot;)));
    }

    @Test(expected = InvalidColumnNameException.class)
    public void testCreateTableWithUnderscoreColumnPrefix() {
        analyze(&quot;create table test (_id integer, name string)&quot;);
    }

    @Test(expected = ParsingException.class)
    public void testCreateTableWithColumnDot() {
        analyze(&quot;create table test (dot.column integer)&quot;);
    }

    @Test(expected = InvalidRelationName.class)
    public void testCreateTableIllegalTableName() {
        analyze(&quot;create table \&quot;abc.def\&quot; (id integer primary key, name string)&quot;);
    }

    @Test
    public void testTableStartWithUnderscore() {
        expectedException.expect(InvalidRelationName.class);
        expectedException.expectMessage(&quot;Relation name \&quot;doc._invalid\&quot; is invalid.&quot;);
        analyze(&quot;create table _invalid (id integer primary key)&quot;);
    }

    @Test
    public void testHasColumnDefinition() {
        BoundCreateTable analysis = analyze(
            &quot;create table my_table (&quot; +
            &quot;  id integer primary key, &quot; +
            &quot;  name string, &quot; +
            &quot;  indexed string index using fulltext with (analyzer='german'),&quot; +
            &quot;  arr array(object as(&quot; +
            &quot;    nested float,&quot; +
            &quot;    nested_object object as (id byte)&quot; +
            &quot;  )),&quot; +
            &quot;  obj object as ( content string ),&quot; +
            &quot;  index ft using fulltext(name, obj['content']) with (analyzer='standard')&quot; +
            &quot;)&quot;);
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;id&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;name&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;indexed&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;arr&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;arr.nested&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;arr.nested_object.id&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;obj&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;obj.content&quot;)));

        assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;arr.nested.wrong&quot;)));
        assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;ft&quot;)));
        assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;obj.content.ft&quot;)));
    }

    @Test
    public void testCreateTableWithGeoPoint() {
        BoundCreateTable analyze = analyze(
            &quot;create table geo_point_table (\n&quot; +
            &quot;    id integer primary key,\n&quot; +
            &quot;    my_point geo_point\n&quot; +
            &quot;)\n&quot;);
        Map my_point = (Map) analyze.mappingProperties().get(&quot;my_point&quot;);
        assertEquals(&quot;geo_point&quot;, my_point.get(&quot;type&quot;));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testClusteredIntoZeroShards() {
        analyze(&quot;create table my_table (&quot; +
                &quot;  id integer,&quot; +
                &quot;  name string&quot; +
                &quot;) clustered into 0 shards&quot;);
    }

    @Test
    public void testBlobTableClusteredIntoZeroShards() {
        AnalyzedCreateBlobTable blobTable = analyze(&quot;create blob table my_table clustered into 0 shards&quot;);

        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;num_shards in CLUSTERED clause must be greater than 0&quot;);
        CreateBlobTablePlan.buildSettings(
            blobTable.createBlobTable(),
            plannerContext.transactionContext(),
            plannerContext.nodeContext(),
            new RowN(new Object[0]),
            SubQueryResults.EMPTY,
            new NumberOfShards(clusterService));

    }

    @Test
    public void testEarlyPrimaryKeyConstraint() {
        BoundCreateTable analysis = analyze(
            &quot;create table my_table (&quot; +
            &quot;primary key (id1, id2),&quot; +
            &quot;id1 integer,&quot; +
            &quot;id2 long&quot; +
            &quot;)&quot;);
        assertThat(analysis.primaryKeys().size(), is(2));
        assertThat(analysis.primaryKeys(), hasItems(&quot;id1&quot;, &quot;id2&quot;));
    }

    @Test(expected = ColumnUnknownException.class)
    public void testPrimaryKeyConstraintNonExistingColumns() {
        analyze(&quot;create table my_table (&quot; +
                &quot;primary key (id1, id2),&quot; +
                &quot;title string,&quot; +
                &quot;name string&quot; +
                &quot;)&quot;);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEarlyIndexDefinition() {
        BoundCreateTable analysis = analyze(
            &quot;create table my_table (&quot; +
            &quot;index ft using fulltext(title, name) with (analyzer='snowball'),&quot; +
            &quot;title string,&quot; +
            &quot;name string&quot; +
            &quot;)&quot;);
        Map&lt;String, Object&gt; metaMap = (Map) analysis.mapping().get(&quot;_meta&quot;);
        assertThat(
            metaMap.get(&quot;indices&quot;).toString(),
            is(&quot;{ft={}}&quot;));
        assertThat(
            (List&lt;String&gt;) ((Map&lt;String, Object&gt;) analysis.mappingProperties()
                .get(&quot;title&quot;)).get(&quot;copy_to&quot;),
            hasItem(&quot;ft&quot;)
        );
        assertThat(
            (List&lt;String&gt;) ((Map&lt;String, Object&gt;) analysis.mappingProperties()
                .get(&quot;name&quot;)).get(&quot;copy_to&quot;),
            hasItem(&quot;ft&quot;));

    }

    @Test(expected = ColumnUnknownException.class)
    public void testIndexDefinitionNonExistingColumns() {
        analyze(&quot;create table my_table (&quot; +
                &quot;index ft using fulltext(id1, id2) with (analyzer='snowball'),&quot; +
                &quot;title string,&quot; +
                &quot;name string&quot; +
                &quot;)&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testAnalyzerOnInvalidType() {
        analyze(&quot;create table my_table (x integer INDEX using fulltext with (analyzer='snowball'))&quot;);
    }

    @Test
    public void createTableNegativeReplicas() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Failed to parse value [-1] for setting [number_of_replicas] must be &gt;= 0&quot;);
        analyze(&quot;create table t (id int, name string) with (number_of_replicas=-1)&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testCreateTableSameColumn() {
        analyze(&quot;create table my_table (title string, title integer)&quot;);
    }


    @Test(expected = UnsupportedOperationException.class)
    public void testCreateTableWithArrayPrimaryKeyUnsupported() {
        analyze(&quot;create table t (id array(int) primary key)&quot;);
    }

    @Test
    public void testCreateTableWithClusteredIntoShardsParameter() {
        BoundCreateTable analysis = analyze(
            &quot;create table t (id int primary key) clustered into ? shards&quot;, 2);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;2&quot;));
    }

    @Test
    public void testCreateTableWithClusteredIntoShardsParameterNonNumeric() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;invalid number 'foo'&quot;);
        analyze(&quot;create table t (id int primary key) clustered into ? shards&quot;, &quot;foo&quot;);
    }

    @Test
    public void testCreateTableWithParitionedColumnInClusteredBy() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot use CLUSTERED BY column in PARTITIONED BY clause&quot;);
        analyze(&quot;create table t(id int primary key) partitioned by (id) clustered by (id)&quot;);
    }

    @Test
    public void testCreateTableUsesDefaultSchema() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService, 1, Randomness.get(), List.of())
            .setSearchPath(&quot;firstSchema&quot;, &quot;secondSchema&quot;)
            .build();

        BoundCreateTable analysis = analyze(sqlExecutor, &quot;create table t (id int)&quot;);
        assertThat(analysis.tableIdent().schema(), is(sqlExecutor.getSessionContext().searchPath().currentSchema()));
    }

    @Test
    public void testCreateTableWithEmptySchema() {
        expectedException.expect(InvalidSchemaNameException.class);
        expectedException.expectMessage(&quot;schema name \&quot;\&quot; is invalid.&quot;);
        analyze(&quot;create table \&quot;\&quot;.my_table (&quot; +
                &quot;id long primary key&quot; +
                &quot;)&quot;);
    }

    @Test
    public void testCreateTableWithIllegalSchema() {
        expectedException.expect(InvalidSchemaNameException.class);
        expectedException.expectMessage(&quot;schema name \&quot;with.\&quot; is invalid.&quot;);
        analyze(&quot;create table \&quot;with.\&quot;.my_table (&quot; +
                &quot;id long primary key&quot; +
                &quot;)&quot;);
    }

    @Test
    public void testCreateTableWithInvalidColumnName() {
        expectedException.expect(InvalidColumnNameException.class);
        expectedException.expectMessage(
            &quot;\&quot;_test\&quot; conflicts with system column pattern&quot;);
        analyze(&quot;create table my_table (\&quot;_test\&quot; string)&quot;);
    }

    @Test
    public void testCreateTableShouldRaiseErrorIfItExists() {
        expectedException.expect(RelationAlreadyExists.class);
        analyze(&quot;create table users (\&quot;'test\&quot; string)&quot;);
    }

    @Test
    public void testExplicitSchemaHasPrecedenceOverDefaultSchema() {
        SQLExecutor e = SQLExecutor.builder(clusterService).setSearchPath(&quot;hoschi&quot;).build();
        BoundCreateTable statement = analyze(e, &quot;create table foo.bar (x string)&quot;);

        // schema from statement must take precedence
        assertThat(statement.tableIdent().schema(), is(&quot;foo&quot;));
    }

    @Test
    public void testDefaultSchemaIsAddedToTableIdentIfNoExplicitSchemaExistsInTheStatement() {
        SQLExecutor e = SQLExecutor.builder(clusterService).setSearchPath(&quot;hoschi&quot;).build();
        BoundCreateTable statement = analyze(e, &quot;create table bar (x string)&quot;);

        assertThat(statement.tableIdent().schema(), is(&quot;hoschi&quot;));
    }

    @Test
    public void testChangeReadBlock() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.read\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeWriteBlock() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.write\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_WRITE_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeMetadataBlock() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.metadata\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_METADATA_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeReadOnlyBlock() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.read_only\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_READ_ONLY_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeBlockReadOnlyAllowDelete() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.read_only_allow_delete\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeBlockReadOnlyAllowedDeletePartitionedTable() {
        BoundAlterTable analysis =
            analyze(&quot;alter table parted set (\&quot;blocks.read_only_allow_delete\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeFlushThresholdSize() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;translog.flush_threshold_size\&quot;='300b')&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey()), is(&quot;300b&quot;));
    }

    @Test
    public void testChangeTranslogInterval() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;translog.sync_interval\&quot;='100ms')&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()), is(&quot;100ms&quot;));
    }

    @Test
    public void testChangeTranslogDurability() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;translog.durability\&quot;='ASYNC')&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey()), is(&quot;ASYNC&quot;));
    }

    @Test
    public void testRoutingAllocationEnable() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;routing.allocation.enable\&quot;=\&quot;none\&quot;)&quot;);
        assertThat(analysis.tableParameter().settings().get(EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey()), is(&quot;none&quot;));
    }

    @Test
    public void testRoutingAllocationValidation() {
        expectedException.expect(IllegalArgumentException.class);
        analyze(&quot;alter table users set (\&quot;routing.allocation.enable\&quot;=\&quot;foo\&quot;)&quot;);
    }

    @Test
    public void testAlterTableSetShards() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;number_of_shards\&quot;=1)&quot;);
        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;1&quot;));
    }

    @Test
    public void testAlterTableResetShards() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users reset (\&quot;number_of_shards\&quot;)&quot;);
        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;5&quot;));
    }

    @Test
    public void testTranslogSyncInterval() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;translog.sync_interval\&quot;='1s')&quot;);
        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()), is(&quot;1s&quot;));
    }

    @Test
    public void testAllocationMaxRetriesValidation() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;allocation.max_retries\&quot;=1)&quot;);
        assertThat(analysis.tableParameter().settings().get(MaxRetryAllocationDecider.SETTING_ALLOCATION_MAX_RETRY.getKey()), is(&quot;1&quot;));
    }

    @Test
    public void testCreateReadOnlyTable() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, name string) &quot;
            + &quot;clustered into 3 shards with (\&quot;blocks.read_only\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_READ_ONLY_SETTING.getKey()), is(&quot;true&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableWithGeneratedColumn() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day as date_trunc('day', ts))&quot;);

        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(generatedColumnsMapping.size(), is(1));
        assertThat(generatedColumnsMapping.get(&quot;day&quot;), is(&quot;date_trunc('day', ts)&quot;));

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; dayMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;day&quot;);
        assertThat(dayMapping.get(&quot;type&quot;), is(&quot;date&quot;));
        Map&lt;String, Object&gt; tsMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;ts&quot;);
        assertThat(tsMapping.get(&quot;type&quot;), is(&quot;date&quot;));
    }

    @Test
    public void testCreateTableWithColumnOfArrayTypeAndGeneratedExpression() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (arr array(integer) as ([1.0, 2.0]))&quot;);

        assertThat(
            mapToSortedString(analysis.mappingProperties()),
            is(&quot;arr={inner={position=1, type=integer}, type=array}&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableGeneratedColumnWithCast() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day timestamp with time zone GENERATED ALWAYS as ts + 1)&quot;);
        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(
            generatedColumnsMapping.get(&quot;day&quot;),
            is(&quot;(ts + 1::bigint)&quot;));

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; dayMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;day&quot;);
        assertThat(dayMapping.get(&quot;type&quot;), is(&quot;date&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableWithCurrentTimestampAsGeneratedColumnIsntNormalized() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (ts timestamp with time zone GENERATED ALWAYS as current_timestamp(3))&quot;);

        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(generatedColumnsMapping.size(), is(1));
        // current_timestamp used to get evaluated and then this contained the actual timestamp instead of the function name
        assertThat(generatedColumnsMapping.get(&quot;ts&quot;), is(&quot;current_timestamp(3)&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableGeneratedColumnWithSubscript() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (\&quot;user\&quot; object as (name string), name as concat(\&quot;user\&quot;['name'], 'foo'))&quot;);

        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(generatedColumnsMapping.get(&quot;name&quot;), is(&quot;concat(\&quot;user\&quot;['name'], 'foo')&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableGeneratedColumnParameter() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (\&quot;user\&quot; object as (name string), name as concat(\&quot;user\&quot;['name'], ?))&quot;, $(&quot;foo&quot;));
        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(generatedColumnsMapping.get(&quot;name&quot;), is(&quot;concat(\&quot;user\&quot;['name'], 'foo')&quot;));
    }

    @Test
    public void testCreateTableGeneratedColumnWithInvalidType() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;expression value type&quot; +
                                        &quot; 'timestamp with time zone' not supported for conversion to 'ip'&quot;);
        analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day ip GENERATED ALWAYS as date_trunc('day', ts))&quot;);
    }

    @Test
    public void testCreateTableGeneratedColumnWithMatch() {
        expectedException.expect(UnsupportedFeatureException.class);
        expectedException.expectMessage(&quot;Cannot use MATCH in CREATE TABLE statements&quot;);
        analyze(&quot;create table foo (name string, bar as match(name, 'crate'))&quot;);
    }

    @Test
    public void testCreateTableGeneratedColumnBasedOnGeneratedColumn() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;A generated column cannot be based on a generated column&quot;);
        analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day as date_trunc('day', ts),&quot; +
            &quot;   date_string as cast(day as string))&quot;);
    }

    @Test
    public void testCreateTableGeneratedColumnBasedOnUnknownColumn() {
        expectedException.expect(ColumnUnknownException.class);
        expectedException.expectMessage(&quot;Column unknown_col unknown&quot;);
        analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day as date_trunc('day', ts),&quot; +
            &quot;   date_string as cast(unknown_col as string))&quot;);
    }

    @Test
    public void testCreateTableWithDefaultExpressionLiteral() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (name text default 'bar')&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;name={default_expr='bar', position=1, type=keyword}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionFunction() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (name text default upper('bar'))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;name={default_expr='BAR', position=1, type=keyword}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionWithCast() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id int default 3.5)&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;id={default_expr=_cast(3.5, 'integer'), position=1, type=integer}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionIsNotNormalized() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (ts timestamp with time zone default current_timestamp(3))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;ts={default_expr=current_timestamp(3), &quot; +
                      &quot;format=epoch_millis||strict_date_optional_time, &quot; +
                      &quot;position=1, type=date}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionAsCompoundTypes() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (&quot; +
            &quot;   obj object as (key text) default {key=''},&quot; +
            &quot;   arr array(long) default [1, 2])&quot;);

        assertThat(mapToSortedString(analysis.mappingProperties()), is(
            &quot;arr={inner={position=3, type=long}, type=array}, &quot; +
            &quot;obj={default_expr={\&quot;key\&quot;=''}, dynamic=true, position=1, properties={key={position=2, type=keyword}}, type=object}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionAsGeoTypes() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (&quot; +
            &quot;   p geo_point default [0,0],&quot; +
            &quot;   s geo_shape default 'LINESTRING (0 0, 1 1)')&quot;);

        assertThat(mapToSortedString(analysis.mappingProperties()), is(
            &quot;p={default_expr=_cast([0, 0], 'geo_point'), position=1, type=geo_point}, &quot; +
            &quot;s={default_expr=_cast('LINESTRING (0 0, 1 1)', 'geo_shape'), position=2, type=geo_shape}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionRefToColumnsNotAllowed() {
        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;Columns cannot be used in this context. &quot; +
                                        &quot;Maybe you wanted to use a string literal which requires single quotes: 'name'&quot;);
        analyze(&quot;create table foo (name text, name_def text default upper(name))&quot;);
    }

    @Test
    public void testCreateTableWithObjectAsPrimaryKey() {
        expectedException.expectMessage(&quot;Cannot use columns of type \&quot;object\&quot; as primary key&quot;);
        expectedException.expect(UnsupportedOperationException.class);
        analyze(&quot;create table t (obj object as (x int) primary key)&quot;);
    }

    @Test
    public void testCreateTableWithGeoPointAsPrimaryKey() {
        expectedException.expectMessage(&quot;Cannot use columns of type \&quot;geo_point\&quot; as primary key&quot;);
        expectedException.expect(UnsupportedOperationException.class);
        analyze(&quot;create table t (c geo_point primary key)&quot;);
    }

    @Test
    public void testCreateTableWithGeoShapeAsPrimaryKey() {
        expectedException.expectMessage(&quot;Cannot use columns of type \&quot;geo_shape\&quot; as primary key&quot;);
        expectedException.expect(UnsupportedOperationException.class);
        analyze(&quot;create table t (c geo_shape primary key)&quot;);
    }

    @Test
    public void testCreateTableWithDuplicatePrimaryKey() {
        assertDuplicatePrimaryKey(&quot;create table t (id int, primary key (id, id))&quot;);
        assertDuplicatePrimaryKey(&quot;create table t (obj object as (id int), primary key (obj['id'], obj['id']))&quot;);
        assertDuplicatePrimaryKey(&quot;create table t (id int primary key, primary key (id))&quot;);
        assertDuplicatePrimaryKey(&quot;create table t (obj object as (id int primary key), primary key (obj['id']))&quot;);
    }

    private void assertDuplicatePrimaryKey(String stmt) {
        try {
            analyze(stmt);
            fail(String.format(Locale.ENGLISH, &quot;Statement '%s' did not result in duplicate primary key exception&quot;, stmt));
        } catch (IllegalArgumentException e) {
            String msg = &quot;appears twice in primary key constraint&quot;;
            if (!e.getMessage().contains(msg)) {
                fail(&quot;Exception message is expected to contain: &quot; + msg);
            }
        }
    }

    @Test
    public void testAlterTableAddColumnWithCheckConstraint() throws Exception {
        SQLExecutor.builder(clusterService)
            .addTable(&quot;create table t (&quot; +
                      &quot;    id int primary key, &quot; +
                      &quot;    qty int constraint check_qty_gt_zero check(qty &gt; 0), &quot; +
                      &quot;    constraint check_id_ge_zero check (id &gt;= 0)&quot; +
                      &quot;)&quot;)
            .build();
        String alterStmt = &quot;alter table t add column bazinga int constraint bazinga_check check(bazinga != 42)&quot;;
        BoundAddColumn analysis = analyze(alterStmt);
        Map&lt;String, Object&gt; mapping = analysis.mapping();
        Map&lt;String, String&gt; checkConstraints = analysis.analyzedTableElements().getCheckConstraints();
        assertEquals(checkConstraints.get(&quot;check_id_ge_zero&quot;),
                     Maps.getByPath(mapping, Arrays.asList(&quot;_meta&quot;, &quot;check_constraints&quot;, &quot;check_id_ge_zero&quot;)));
        assertEquals(checkConstraints.get(&quot;check_qty_gt_zero&quot;),
                     Maps.getByPath(mapping, Arrays.asList(&quot;_meta&quot;, &quot;check_constraints&quot;, &quot;check_qty_gt_zero&quot;)));
        assertEquals(checkConstraints.get(&quot;bazinga_check&quot;),
                     Maps.getByPath(mapping, Arrays.asList(&quot;_meta&quot;, &quot;check_constraints&quot;, &quot;bazinga_check&quot;)));
    }

    @Test
    public void testCreateTableWithPrimaryKeyConstraintInArrayItem() {
        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;Cannot use column \&quot;id\&quot; as primary key within an array object&quot;);
        analyze(&quot;create table test (arr array(object as (id long primary key)))&quot;);
    }

    @Test
    public void testCreateTableWithDeepNestedPrimaryKeyConstraintInArrayItem() {
        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;Cannot use column \&quot;name\&quot; as primary key within an array object&quot;);
        analyze(&quot;create table test (arr array(object as (\&quot;user\&quot; object as (name string primary key), id long)))&quot;);
    }

    @Test
    public void testCreateTableWithInvalidIndexConstraint() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;INDEX constraint cannot be used on columns of type \&quot;object\&quot;&quot;);
        analyze(&quot;create table test (obj object index off)&quot;);
    }

    @Test
    public void testCreateTableWithColumnStoreDisabled() {
        BoundCreateTable analysis = analyze(
            &quot;create table columnstore_disabled (s string STORAGE WITH (columnstore = false))&quot;);
        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties), is(&quot;s={doc_values=false, position=1, type=keyword}&quot;));
    }

    @Test
    public void testCreateTableWithColumnStoreDisabledOnInvalidDataType() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Invalid storage option \&quot;columnstore\&quot; for data type \&quot;integer\&quot;&quot;);
        analyze(&quot;create table columnstore_disabled (s int STORAGE WITH (columnstore = false))&quot;);
    }

    @Test
    public void testCreateTableFailsIfNameConflictsWithView() {
        SQLExecutor executor = SQLExecutor.builder(clusterService)
            .addView(RelationName.fromIndexName(&quot;v1&quot;), &quot;Select * from t1&quot;)
            .build();
        expectedException.expect(RelationAlreadyExists.class);
        expectedException.expectMessage(&quot;Relation 'doc.v1' already exists&quot;);
        analyze(executor, &quot;create table v1 (x int) clustered into 1 shards with (number_of_replicas = 0)&quot;);
    }

    @Test
    public void testGeneratedColumnInsideObjectIsProcessed() {
        BoundCreateTable stmt = analyze(&quot;create table t (obj object as (c as 1 + 1))&quot;);
        AnalyzedColumnDefinition&lt;Object&gt; obj = stmt.analyzedTableElements().columns().get(0);
        AnalyzedColumnDefinition&lt;?&gt; c = obj.children().get(0);

        assertThat(c.dataType(), is(DataTypes.INTEGER));
        assertThat(c.formattedGeneratedExpression(), is(&quot;2&quot;));
        assertThat(AnalyzedTableElements.toMapping(stmt.analyzedTableElements()).toString(),
                   is(&quot;{_meta={generated_columns={obj.c=2}}, &quot; +
                      &quot;properties={obj={dynamic=true, position=1, type=object, properties={c={position=2, type=integer}}}}}&quot;));
    }

    @Test
    public void testNumberOfRoutingShardsCanBeSetAtCreateTable() {
        BoundCreateTable stmt = analyze(&quot;&quot;&quot;
            create table t (x int)
            clustered into 2 shards
            with (number_of_routing_shards = 10)
        &quot;&quot;&quot;);
        assertThat(stmt.tableParameter().settings().get(&quot;index.number_of_routing_shards&quot;), is(&quot;10&quot;));
    }

    @Test
    public void testNumberOfRoutingShardsCanBeSetAtCreateTableForPartitionedTables() {
        BoundCreateTable stmt = analyze(
            &quot;create table t (p int, x int) clustered into 2 shards partitioned by (p) &quot; +
            &quot;with (number_of_routing_shards = 10)&quot;);
        assertThat(stmt.tableParameter().settings().get(&quot;index.number_of_routing_shards&quot;), is(&quot;10&quot;));
    }

    @Test
    public void testAlterTableSetDynamicSetting() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;routing.allocation.exclude.foo\&quot;='bar')&quot;);
        assertThat(analysis.tableParameter().settings().get(INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + &quot;foo&quot;), is(&quot;bar&quot;));
    }

    @Test
    public void testAlterTableResetDynamicSetting() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users reset (\&quot;routing.allocation.exclude.foo\&quot;)&quot;);
        assertThat(analysis.tableParameter().settings().get(INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + &quot;foo&quot;), nullValue());
    }

    @Test
    public void testCreateTableWithIntervalFails() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot use the type `interval` for column: i&quot;);
        analyze(&quot;create table test (i interval)&quot;);
    }

    @Test
    public void test_character_varying_type_can_be_used_in_create_table() throws Exception {
        BoundCreateTable stmt = analyze(&quot;create table tbl (name character varying)&quot;);
        assertThat(
            mapToSortedString(stmt.mappingProperties()),
            is(&quot;name={position=1, type=keyword}&quot;));
    }

    @Test
    public void test_create_table_with_varchar_column_of_limited_length() {
        BoundCreateTable stmt = analyze(&quot;CREATE TABLE tbl (name character varying(2))&quot;);
        assertThat(
            mapToSortedString(stmt.mappingProperties()),
            is(&quot;name={length_limit=2, position=1, type=keyword}&quot;));
    }

    @Test
    public void test_create_table_with_varchar_column_of_limited_length_with_analyzer_throws_exception() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(
            &quot;Can't use an Analyzer on column name because analyzers are only allowed on columns &quot; +
            &quot;of type \&quot;&quot; + DataTypes.STRING.getName() + &quot;\&quot; of the unbound length limit.&quot;);
        analyze(&quot;CREATE TABLE tbl (name varchar(2) INDEX using fulltext WITH (analyzer='german'))&quot;);
    }

    @Test
    public void test_oidvector_cannot_be_used_in_create_table() throws Exception {
        expectedException.expectMessage(&quot;Cannot use the type `oidvector` for column: x&quot;);
        analyze(&quot;CREATE TABLE tbl (x oidvector)&quot;);
    }

    @Test
    public void test_generated_column_arguments_are_detected_as_array_and_validation_fails_with_missing_overload() throws Exception {
        Exception exception = Assertions.assertThrows(
            Exception.class,
            () -&gt; analyze(&quot;CREATE TABLE tbl (xs int[], x as max(xs))&quot;)
        );
        assertThat(
            exception.getMessage(),
            Matchers.startsWith(&quot;Unknown function: max(doc.tbl.xs), no overload found for matching argument types: (integer_array)&quot;)
        );
    }

    @Test
    public void test_prohibit_using_aggregations_in_generated_columns() throws Exception {
        Exception exception = Assertions.assertThrows(
            Exception.class,
            () -&gt; analyze(&quot;CREATE TABLE tbl (x int, y as max(x))&quot;)
        );
        assertThat(
            exception.getMessage(),
            Matchers.startsWith(&quot;Aggregation functions are not allowed in generated columns: max(x)&quot;)
        );
    }

    @Test
    public void test_can_use_bit_type_in_create_table_statement() throws Exception {
        BoundCreateTable stmt = analyze(&quot;CREATE TABLE tbl (xs bit(20))&quot;);
        assertThat(mapToSortedString(stmt.mappingProperties()), is(
            &quot;xs={length=20, position=1, type=bit}&quot;
        ));
    }

    @Test
    public void test_bit_type_defaults_to_length_1() throws Exception {
        BoundCreateTable stmt = analyze(&quot;CREATE TABLE tbl (xs bit)&quot;);
        assertThat(mapToSortedString(stmt.mappingProperties()), is(
            &quot;xs={length=1, position=1, type=bit}&quot;
        ));
    }

    @Test
    public void test_now_function_is_not_normalized_to_literal_in_create_table() throws Exception {
        BoundCreateTable stmt = analyze(&quot;create table tbl (ts timestamp with time zone default now())&quot;);
        assertThat(mapToSortedString(stmt.mappingProperties()), Matchers.startsWith(
            &quot;ts={default_expr=now()&quot;
        ));
    }

    @Test
    public void test_current_user_function_is_not_normalized_to_literal_in_create_table() throws Exception {
        BoundCreateTable stmt = analyze(&quot;create table tbl (user_name text default current_user)&quot;);
        assertThat(mapToSortedString(stmt.mappingProperties()), Matchers.startsWith(
            &quot;user_name={default_expr=CURRENT_USER, position=1, type=keyword}&quot;
        ));
    }

    @Test
    public void test_create_table_with_invalid_storage_option_errors_with_invalid_property_name() throws Exception {
        assertThrowsMatches(
            () -&gt; analyze(&quot;create table tbl (name text storage with (foobar = true))&quot;),
            IllegalArgumentException.class,
            &quot;Invalid STORAGE WITH option `foobar`&quot;
        );
    }
}
</PRE>
</div>
  </div>
</body>
</html>
