<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for KillAnalyzer.java &amp; CreateAlterTableStatementAnalyzerTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for KillAnalyzer.java &amp; CreateAlterTableStatementAnalyzerTest.java
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>KillAnalyzer.java (22.727272%)<th>CreateAlterTableStatementAnalyzerTest.java (0.5125577%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-35)<td><a href="#" name="0">(77-88)</a><td align="center"><font color="#ff0000">10</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>KillAnalyzer.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19  * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <a name="0"></a>
22 package io.crate.analyze;
23 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.analyze.expressions.ExpressionAnalysisContext;
24 import io.crate.analyze.expressions.ExpressionAnalyzer;
25 import io.crate.analyze.relations.FieldProvider;
26 import io.crate.expression.symbol.Symbol;
27 import io.crate.metadata.CoordinatorTxnCtx;
28 import io.crate.metadata.NodeContext;
29 import io.crate.sql.tree.Expression;
30 import io.crate.sql.tree.KillStatement;
31 public class KillAnalyzer {
32     private final NodeContext nodeCtx</b></font>;
33     KillAnalyzer(NodeContext nodeCtx) {
34         this.nodeCtx = nodeCtx;
35     }
36     public AnalyzedKill analyze(KillStatement&lt;Expression&gt; killStatement,
37                                 ParamTypeHints paramTypeHints,
38                                 CoordinatorTxnCtx txnCtx) {
39         Symbol jobId;
40         if (killStatement.jobId() != null) {
41             var exprAnalyzerWithoutFields = new ExpressionAnalyzer(
42                 txnCtx, nodeCtx, paramTypeHints, FieldProvider.UNSUPPORTED, null);
43             jobId = exprAnalyzerWithoutFields.convert(
44                 killStatement.jobId(),
45                 new ExpressionAnalysisContext(txnCtx.sessionContext()));
46         } else {
47             jobId = null;
48         }
49         return new AnalyzedKill(jobId);
50     }
51 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CreateAlterTableStatementAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19  * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 package io.crate.analyze;
22 import io.crate.common.collections.Maps;
23 import io.crate.data.RowN;
24 import io.crate.exceptions.ColumnUnknownException;
25 import io.crate.exceptions.InvalidColumnNameException;
26 import io.crate.exceptions.InvalidRelationName;
27 import io.crate.exceptions.InvalidSchemaNameException;
28 import io.crate.exceptions.OperationOnInaccessibleRelationException;
29 import io.crate.exceptions.RelationAlreadyExists;
30 import io.crate.exceptions.UnsupportedFeatureException;
31 import io.crate.metadata.ColumnIdent;
32 import io.crate.metadata.FulltextAnalyzerResolver;
33 import io.crate.metadata.RelationName;
34 import io.crate.metadata.Schemas;
35 import io.crate.planner.PlannerContext;
36 import io.crate.planner.node.ddl.AlterTableAddColumnPlan;
37 import io.crate.planner.node.ddl.AlterTableDropCheckConstraintPlan;
38 import io.crate.planner.node.ddl.AlterTablePlan;
39 import io.crate.planner.node.ddl.CreateBlobTablePlan;
40 import io.crate.planner.node.ddl.CreateTablePlan;
41 import io.crate.planner.operators.SubQueryResults;
42 import io.crate.sql.parser.ParsingException;
43 import io.crate.sql.tree.ColumnPolicy;
44 import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
45 import io.crate.testing.SQLExecutor;
46 import io.crate.types.DataTypes;
47 import org.elasticsearch.cluster.ClusterName;
48 import org.elasticsearch.cluster.ClusterState;
49 import org.elasticsearch.cluster.metadata.AutoExpandReplicas;
50 import org.elasticsearch.cluster.metadata.IndexMetadata;
51 import org.elasticsearch.cluster.metadata.Metadata;
52 import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;
53 import org.elasticsearch.cluster.routing.allocation.decider.MaxRetryAllocationDecider;
54 import org.elasticsearch.common.Randomness;
55 import org.elasticsearch.common.settings.Settings;
56 import org.elasticsearch.index.IndexSettings;
57 import org.elasticsearch.index.mapper.MapperService;
58 import org.elasticsearch.test.ClusterServiceUtils;
59 import org.hamcrest.Matchers;
60 import org.junit.Before;
61 import org.junit.Test;
62 import org.junit.jupiter.api.Assertions;
63 import java.io.IOException;
64 import java.util.Arrays;
65 import java.util.Collections;
66 import java.util.List;
67 import java.util.Locale;
68 import java.util.Map;
69 import static com.carrotsearch.randomizedtesting.RandomizedTest.$;
70 <a name="0"></a>import static io.crate.metadata.FulltextAnalyzerResolver.CustomType.ANALYZER;
71 import static io.crate.testing.Asserts.assertThrowsMatches;
72 import static io.crate.testing.TestingHelpers.mapToSortedString;
73 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_ROUTING_EXCLUDE_GROUP_SETTING;
74 import static org.hamcrest.Matchers.hasItem;
75 import static org.hamcrest.Matchers.hasItems;
76 import static org.hamcrest.Matchers.is;
77 import static org.hamcrest.Matchers.isEmptyOrNullString;
78 import static org.hamcrest.Matchers.nullValue;
79 import static org.hamcrest.Matchers.startsWith;
80 import static org.junit.jupiter.api.Assertions.assertThrows;
81 public class CreateAlterTableStatementAnalyzerTest extends CrateDummyClusterServiceUnitTest {
82     private SQLExecutor e</b></font>;
83     private PlannerContext plannerContext;
84     @Before
85     public void prepare() throws IOException {
86         String analyzerSettings = FulltextAnalyzerResolver.encodeSettings(
87             Settings.builder().put("search", "foobar").build()).utf8ToString();
88         Metadata metadata = Metadata.builder()
89             .persistentSettings(
90                 Settings.builder().put(ANALYZER.buildSettingName("ft_search"), analyzerSettings).build())
91             .build();
92         ClusterState state = ClusterState.builder(ClusterName.DEFAULT)
93             .metadata(metadata)
94             .build();
95         ClusterServiceUtils.setState(clusterService, state);
96         e = SQLExecutor.builder(clusterService, 3, Randomness.get(), List.of())
97             .enableDefaultTables()
98             .build();
99         plannerContext = e.getPlannerContext(clusterService.state());
100     }
101     private &lt;S&gt; S analyze(String stmt, Object... arguments) {
102         return analyze(e, stmt, arguments);
103     }
104     @SuppressWarnings("unchecked")
105     private &lt;S&gt; S analyze(SQLExecutor e, String stmt, Object... arguments) {
106         AnalyzedStatement analyzedStatement = e.analyze(stmt);
107         if (analyzedStatement instanceof AnalyzedCreateTable) {
108             return (S) CreateTablePlan.bind(
109                 (AnalyzedCreateTable) analyzedStatement,
110                 plannerContext.transactionContext(),
111                 plannerContext.nodeContext(),
112                 new RowN(arguments),
113                 SubQueryResults.EMPTY,
114                 new NumberOfShards(clusterService),
115                 e.schemas(),
116                 e.fulltextAnalyzerResolver()
117             );
118         } else if (analyzedStatement instanceof AnalyzedAlterTable) {
119             return (S) AlterTablePlan.bind(
120                 (AnalyzedAlterTable) analyzedStatement,
121                 plannerContext.transactionContext(),
122                 plannerContext.nodeContext(),
123                 new RowN(arguments),
124                 SubQueryResults.EMPTY
125             );
126         } else if (analyzedStatement instanceof AnalyzedAlterTableAddColumn) {
127             return (S) AlterTableAddColumnPlan.bind(
128                 (AnalyzedAlterTableAddColumn) analyzedStatement,
129                 plannerContext.transactionContext(),
130                 plannerContext.nodeContext(),
131                 new RowN(arguments),
132                 SubQueryResults.EMPTY,
133                 null
134             );
135         } else if (analyzedStatement instanceof AnalyzedAlterTableDropCheckConstraint) {
136             return (S) AlterTableDropCheckConstraintPlan.bind(
137                 (AnalyzedAlterTableDropCheckConstraint) analyzedStatement
138             );
139         } else {
140             return (S) analyzedStatement;
141         }
142     }
143     @Test
144     public void testTimestampDataTypeDeprecationWarning() {
145         analyze("create table t (ts timestamp)");
146         assertWarnings(
147             "Column [ts]: Usage of the `TIMESTAMP` data type as a timestamp with zone is deprecated," +
148             " use the `TIMESTAMPTZ` or `TIMESTAMP WITH TIME ZONE` data type instead."
149         );
150     }
151     @Test
152     public void test_cannot_create_table_that_contains_a_column_definition_of_type_time () {
153         expectedException.expect(IllegalArgumentException.class);
154         expectedException.expectMessage("Cannot use the type `time with time zone` for column: ts");
155         analyze("create table t (ts time with time zone)");
156     }
157     @Test
158     public void test_cannot_alter_table_to_add_a_column_definition_of_type_time () {
159         expectedException.expect(IllegalArgumentException.class);
160         expectedException.expectMessage("Cannot use the type `time with time zone` for column: ts");
161         analyze("alter table user_refresh_interval add column ts time with time zone");
162     }
163     @Test
164     public void testCreateTableInSystemSchemasIsProhibited() {
165         for (String schema : Schemas.READ_ONLY_SYSTEM_SCHEMAS) {
166             try {
167                 analyze(String.format("CREATE TABLE %s.%s (ordinal INTEGER, name STRING)", schema, "my_table"));
168                 fail("create table in read-only schema must fail");
169             } catch (IllegalArgumentException e) {
170                 assertThat(e.getLocalizedMessage(), startsWith("Cannot create relation in read-only schema: " + schema));
171             }
172         }
173     }
174     @Test
175     public void testCreateTableWithAlternativePrimaryKeySyntax() {
176         BoundCreateTable analysis = analyze(
177             "create table foo (id integer, name string, primary key (id, name))"
178         );
179         String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
180         assertThat(primaryKeys.length, is(2));
181         assertThat(primaryKeys[0], is("id"));
182         assertThat(primaryKeys[1], is("name"));
183     }
184     @Test
185     @SuppressWarnings("unchecked")
186     public void testSimpleCreateTable() {
187         BoundCreateTable analysis = analyze(
188             "create table foo (id integer primary key, name string not null) " +
189             "clustered into 3 shards with (number_of_replicas=0)");
190         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("3"));
191         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is("0"));
192         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
193         assertNull(metaMapping.get("columns"));
194         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
195         Map&lt;String, Object&gt; idMapping = (Map&lt;String, Object&gt;) mappingProperties.get("id");
196         assertThat(idMapping.get("type"), is("integer"));
197         Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) mappingProperties.get("name");
198         assertThat(nameMapping.get("type"), is("keyword"));
199         String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
200         assertThat(primaryKeys.length, is(1));
201         assertThat(primaryKeys[0], is("id"));
202         String[] notNullColumns = analysis.notNullColumns().toArray(new String[0]);
203         assertThat(notNullColumns.length, is(1));
204         assertThat(notNullColumns[0], is("name"));
205     }
206     @Test
207     public void testCreateTableWithDefaultNumberOfShards() {
208         BoundCreateTable analysis = analyze("create table foo (id integer primary key, name string)");
209         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("6"));
210     }
211     @Test
212     public void testCreateTableWithDefaultNumberOfShardsWithClusterByClause() {
213         BoundCreateTable analysis = analyze(
214             "create table foo (id integer primary key) clustered by (id)"
215         );
216         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("6"));
217     }
218     @Test
219     public void testCreateTableNumberOfShardsProvidedInClusteredClause() {
220         BoundCreateTable analysis = analyze(
221             "create table foo (id integer primary key) " +
222             "clustered by (id) into 8 shards"
223         );
224         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("8"));
225     }
226     @Test
227     public void testCreateTableWithTotalFieldsLimit() {
228         BoundCreateTable analysis = analyze(
229             "CREATE TABLE foo (id int primary key) " +
230             "with (\"mapping.total_fields.limit\"=5000)");
231         assertThat(analysis.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()), is("5000"));
232     }
233     @Test
234     public void testCreateTableWithRefreshInterval() {
235         BoundCreateTable analysis = analyze(
236             "CREATE TABLE foo (id int primary key, content string) " +
237             "with (refresh_interval='5000ms')");
238         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()), is("5s"));
239     }
240     @Test
241     public void testCreateTableWithNumberOfShardsOnWithClauseIsInvalid() {
242         expectedException.expect(IllegalArgumentException.class);
243         expectedException.expectMessage("Invalid property \"number_of_shards\" passed to [ALTER | CREATE] TABLE statement");
244         analyze("CREATE TABLE foo (id int primary key, content string) " +
245                 "with (number_of_shards=8)");
246     }
247     @Test(expected = IllegalArgumentException.class)
248     public void testCreateTableWithRefreshIntervalWrongNumberFormat() {
249         analyze("CREATE TABLE foo (id int primary key, content string) " +
250                 "with (refresh_interval='1asdf')");
251     }
252     @Test
253     public void testAlterTableWithRefreshInterval() {
254         BoundAlterTable analysisSet = analyze(
255             "ALTER TABLE user_refresh_interval " +
256             "SET (refresh_interval = '5000ms')");
257         assertEquals("5s", analysisSet.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()));
258         BoundAlterTable analysisReset = analyze(
259             "ALTER TABLE user_refresh_interval " +
260             "RESET (refresh_interval)");
261         assertEquals("1s", analysisReset.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()));
262     }
263     @Test
264     public void testTotalFieldsLimitCanBeUsedWithAlterTable() {
265         BoundAlterTable analysisSet = analyze(
266             "ALTER TABLE users " +
267             "SET (\"mapping.total_fields.limit\" = '5000')");
268         assertEquals("5000", analysisSet.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()));
269         BoundAlterTable analysisReset = analyze(
270             "ALTER TABLE users " +
271             "RESET (\"mapping.total_fields.limit\")");
272         assertEquals("1000", analysisReset.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()));
273     }
274     @Test
275     public void testAlterTableWithColumnPolicy() {
276         BoundAlterTable analysisSet = analyze(
277             "ALTER TABLE user_refresh_interval " +
278             "SET (column_policy = 'strict')");
279         assertEquals(
280             ColumnPolicy.STRICT.lowerCaseName(),
281             analysisSet.tableParameter().mappings().get(TableParameters.COLUMN_POLICY.getKey()));
282     }
283     @Test
284     public void testAlterTableWithInvalidColumnPolicy() {
285         expectedException.expect(IllegalArgumentException.class);
286         expectedException.expectMessage("Invalid value for argument 'column_policy'");
287         analyze("ALTER TABLE user_refresh_interval " +
288                   "SET (column_policy = 'ignored')");
289     }
290     @Test
291     public void testAlterTableWithMaxNGramDiffSetting() {
292         BoundAlterTable analysisSet = analyze(
293             "ALTER TABLE users " +
294             "SET (max_ngram_diff = 42)");
295         assertThat(analysisSet.tableParameter().settings().get(IndexSettings.MAX_NGRAM_DIFF_SETTING.getKey()), is("42"));
296     }
297     @Test
298     public void testAlterTableWithMaxShingleDiffSetting() {
299         BoundAlterTable analysisSet = analyze(
300             "ALTER TABLE users " +
301             "SET (max_shingle_diff = 43)");
302         assertThat(analysisSet.tableParameter().settings().get(IndexSettings.MAX_SHINGLE_DIFF_SETTING.getKey()), is("43"));
303     }
304     @Test
305     @SuppressWarnings("unchecked")
306     public void testCreateTableWithClusteredBy() {
307         BoundCreateTable analysis = analyze(
308             "create table foo (id integer, name string) clustered by(id)");
309         Map&lt;String, Object&gt; meta = (Map) analysis.mapping().get("_meta");
310         assertNotNull(meta);
311         assertThat(meta.get("routing"), is("id"));
312     }
313     @Test(expected = IllegalArgumentException.class)
314     @SuppressWarnings("unchecked")
315     public void testCreateTableWithClusteredByNotInPrimaryKeys() {
316         analyze("create table foo (id integer primary key, name string) clustered by(name)");
317     }
318     @Test
319     @SuppressWarnings("unchecked")
320     public void testCreateTableWithObjects() {
321         BoundCreateTable analysis = analyze(
322             "create table foo (id integer primary key, details object as (name string, age integer))");
323         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
324         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("details");
325         assertThat(details.get("type"), is("object"));
326         assertThat(details.get("dynamic"), is("true"));
327         Map&lt;String, Object&gt; detailsProperties = (Map&lt;String, Object&gt;) details.get("properties");
328         Map&lt;String, Object&gt; nameProperties = (Map&lt;String, Object&gt;) detailsProperties.get("name");
329         assertThat(nameProperties.get("type"), is("keyword"));
330         Map&lt;String, Object&gt; ageProperties = (Map&lt;String, Object&gt;) detailsProperties.get("age");
331         assertThat(ageProperties.get("type"), is("integer"));
332     }
333     @Test
334     @SuppressWarnings("unchecked")
335     public void testCreateTableWithStrictObject() {
336         BoundCreateTable analysis = analyze(
337             "create table foo (id integer primary key, details object(strict) as (name string, age integer))");
338         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
339         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("details");
340         assertThat(details.get("type"), is("object"));
341         assertThat(details.get("dynamic"), is("strict"));
342     }
343     @Test
344     @SuppressWarnings("unchecked")
345     public void testCreateTableWithIgnoredObject()  {
346         BoundCreateTable analysis = analyze(
347             "create table foo (id integer primary key, details object(ignored))");
348         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
349         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("details");
350         assertThat(details.get("type"), is("object"));
351         assertThat(details.get("dynamic"), is("false"));
352     }
353     @Test
354     @SuppressWarnings("unchecked")
355     public void testCreateTableWithSubscriptInFulltextIndexDefinition() {
356         BoundCreateTable analysis = analyze(
357             "create table my_table1g (" +
358             "   title string, " +
359             "   author object(dynamic) as ( " +
360             "   name string, " +
361             "   birthday timestamp with time zone" +
362             "), " +
363             "INDEX author_title_ft using fulltext(title, author['name']))");
364         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
365         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("author");
366         Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) ((Map&lt;String, Object&gt;) details.get("properties")).get("name");
367         assertThat(((List&lt;String&gt;) nameMapping.get("copy_to")).get(0), is("author_title_ft"));
368     }
369     @Test(expected = ColumnUnknownException.class)
370     public void testCreateTableWithInvalidFulltextIndexDefinition() {
371         analyze(
372             "create table my_table1g (" +
373             "   title string, " +
374             "   author object(dynamic) as ( " +
375             "   name string, " +
376             "   birthday timestamp with time zone" +
377             "), " +
378             "INDEX author_title_ft using fulltext(title, author['name']['foo']['bla']))");
379     }
380     @SuppressWarnings("unchecked")
381     @Test
382     public void testCreateTableWithArray() {
383         BoundCreateTable analysis = analyze(
384             "create table foo (id integer primary key, details array(string), more_details text[])");
385         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
386         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("details");
387         assertThat(details.get("type"), is("array"));
388         Map&lt;String, Object&gt; inner = (Map&lt;String, Object&gt;) details.get("inner");
389         assertThat(inner.get("type"), is("keyword"));
390         Map&lt;String, Object&gt; moreDetails = (Map&lt;String, Object&gt;) mappingProperties.get("more_details");
391         assertThat(moreDetails.get("type"), is("array"));
392         Map&lt;String, Object&gt; moreDetailsInner = (Map&lt;String, Object&gt;) details.get("inner");
393         assertThat(moreDetailsInner.get("type"), is("keyword"));
394     }
395     @Test
396     @SuppressWarnings("unchecked")
397     public void testCreateTableWithObjectsArray() {
398         BoundCreateTable analysis = analyze(
399             "create table foo (id integer primary key, details array(object as (name string, age integer, tags array(string))))");
400         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
401         assertThat(mapToSortedString(mappingProperties),
402                    is("details={inner={dynamic=true, position=2, properties={age={position=4, type=integer}, " +
403                       "name={position=3, type=keyword}, " +
404                       "tags={inner={position=5, type=keyword}, type=array}}, type=object}, type=array}, " +
405                       "id={position=1, type=integer}"));
406     }
407     @Test
408     @SuppressWarnings("unchecked")
409     public void testCreateTableWithAnalyzer() {
410         BoundCreateTable analysis = analyze(
411             "create table foo (id integer primary key, content string INDEX using fulltext with (analyzer='german'))");
412         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
413         Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get("content");
414         assertThat(contentMapping.get("index"), nullValue());
415         assertThat(contentMapping.get("analyzer"), is("german"));
416     }
417     @Test
418     @SuppressWarnings("unchecked")
419     public void testCreateTableWithAnalyzerParameter() {
420         BoundCreateTable analysis = analyze(
421             "create table foo (id integer primary key, content string INDEX using fulltext with (analyzer=?))",
422             "german"
423         );
424         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
425         Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get("content");
426         assertThat(contentMapping.get("index"), nullValue());
427         assertThat(contentMapping.get("analyzer"), is("german"));
428     }
429     @SuppressWarnings("unchecked")
430     @Test
431     public void textCreateTableWithCustomAnalyzerInNestedColumn() {
432         BoundCreateTable analysis = analyze(
433             "create table ft_search (" +
434             "\"user\" object (strict) as (" +
435             "name string index using fulltext with (analyzer='ft_search') " +
436             ")" +
437             ")");
438         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
439         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("user");
440         Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) ((Map&lt;String, Object&gt;) details.get("properties")).get("name");
441         assertThat(nameMapping.get("index"), nullValue());
442         assertThat(nameMapping.get("analyzer"), is("ft_search"));
443         assertThat(analysis.tableParameter().settings().get("search"), is("foobar"));
444     }
445     @Test
446     public void testCreateTableWithSchemaName() {
447         BoundCreateTable analysis =
448             analyze("create table something.foo (id integer primary key)");
449         RelationName relationName = analysis.tableIdent();
450         assertThat(relationName.schema(), is("something"));
451         assertThat(relationName.name(), is("foo"));
452     }
453     @Test
454     @SuppressWarnings("unchecked")
455     public void testCreateTableWithIndexColumn() {
456         BoundCreateTable analysis = analyze(
457             "create table foo (id integer primary key, content string, INDEX content_ft using fulltext (content))");
458         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
459         Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get("content");
460         assertThat((String) contentMapping.get("index"), isEmptyOrNullString());
461         assertThat(((List&lt;String&gt;) contentMapping.get("copy_to")).get(0), is("content_ft"));
462         Map&lt;String, Object&gt; ft_mapping = (Map&lt;String, Object&gt;) mappingProperties.get("content_ft");
463         assertThat(ft_mapping.get("index"), nullValue());
464         assertThat(ft_mapping.get("analyzer"), is("standard"));
465     }
466     @Test
467     @SuppressWarnings("unchecked")
468     public void testCreateTableWithPlainIndexColumn() {
469         BoundCreateTable analysis = analyze(
470             "create table foo (id integer primary key, content string, INDEX content_ft using plain (content))");
471         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
472         Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get("content");
473         assertThat((String) contentMapping.get("index"), isEmptyOrNullString());
474         assertThat(((List&lt;String&gt;) contentMapping.get("copy_to")).get(0), is("content_ft"));
475         Map&lt;String, Object&gt; ft_mapping = (Map&lt;String, Object&gt;) mappingProperties.get("content_ft");
476         assertThat(ft_mapping.get("index"), nullValue());
477         assertThat(ft_mapping.get("analyzer"), is("keyword"));
478     }
479     @Test
480     public void testCreateTableWithIndexColumnOverNonString() {
481         expectedException.expect(IllegalArgumentException.class);
482         expectedException.expectMessage("INDEX definition only support 'string' typed source columns");
483         analyze("create table foo (id integer, id2 integer, INDEX id_ft using fulltext (id, id2))");
484     }
485     @Test
486     public void testCreateTableWithIndexColumnOverNonString2() {
487         expectedException.expect(IllegalArgumentException.class);
488         expectedException.expectMessage("INDEX definition only support 'string' typed source columns");
489         analyze("create table foo (id integer, name string, INDEX id_ft using fulltext (id, name))");
490     }
491     @Test
492     public void testChangeNumberOfReplicas() {
493         BoundAlterTable analysis =
494             analyze("alter table users set (number_of_replicas=2)");
495         assertThat(analysis.table().ident().name(), is("users"));
496         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is("2"));
497     }
498     @Test
499     public void testResetNumberOfReplicas() {
500         BoundAlterTable analysis =
501             analyze("alter table users reset (number_of_replicas)");
502         assertThat(analysis.table().ident().name(), is("users"));
503         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is("0"));
504         assertThat(analysis.tableParameter().settings().get(AutoExpandReplicas.SETTING.getKey()), is("0-1"));
505     }
506     @Test(expected = IllegalArgumentException.class)
507     public void testAlterTableWithInvalidProperty() {
508         analyze("alter table users set (foobar='2')");
509     }
510     @Test
511     public void testAlterSystemTable() {
512         expectedException.expect(OperationOnInaccessibleRelationException.class);
513         expectedException.expectMessage("The relation \"sys.shards\" doesn't support or allow ALTER " +
514                                         "operations, as it is read-only.");
515         analyze("alter table sys.shards reset (number_of_replicas)");
516     }
517     @Test
518     public void testCreateTableWithMultiplePrimaryKeys() {
519         BoundCreateTable analysis = analyze(
520             "create table test (id integer primary key, name string primary key)");
521         String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
522         assertThat(primaryKeys.length, is(2));
523         assertThat(primaryKeys[0], is("id"));
524         assertThat(primaryKeys[1], is("name"));
525     }
526     @Test
527     public void testCreateTableWithMultiplePrimaryKeysAndClusteredBy() {
528         BoundCreateTable analysis = analyze(
529             "create table test (id integer primary key, name string primary key) " +
530             "clustered by(name)");
531         String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
532         assertThat(primaryKeys.length, is(2));
533         assertThat(primaryKeys[0], is("id"));
534         assertThat(primaryKeys[1], is("name"));
535         //noinspection unchecked
536         Map&lt;String, Object&gt; meta = (Map) analysis.mapping().get("_meta");
537         assertNotNull(meta);
538         assertThat(meta.get("routing"), is("name"));
539     }
540     @Test
541     public void testCreateTableWithObjectAndUnderscoreColumnPrefix() {
542         BoundCreateTable analysis = analyze("create table test (o object as (_id integer), name string)");
543         assertThat(analysis.analyzedTableElements().columns().size(), is(2));         AnalyzedColumnDefinition&lt;Object&gt; column = analysis.analyzedTableElements().columns().get(0);
544         assertEquals(column.ident(), new ColumnIdent("o"));
545         assertThat(column.children().size(), is(1));
546         AnalyzedColumnDefinition&lt;Object&gt; xColumn = column.children().get(0);
547         assertEquals(xColumn.ident(), new ColumnIdent("o", Collections.singletonList("_id")));
548     }
549     @Test(expected = InvalidColumnNameException.class)
550     public void testCreateTableWithUnderscoreColumnPrefix() {
551         analyze("create table test (_id integer, name string)");
552     }
553     @Test(expected = ParsingException.class)
554     public void testCreateTableWithColumnDot() {
555         analyze("create table test (dot.column integer)");
556     }
557     @Test(expected = InvalidRelationName.class)
558     public void testCreateTableIllegalTableName() {
559         analyze("create table \"abc.def\" (id integer primary key, name string)");
560     }
561     @Test
562     public void testTableStartWithUnderscore() {
563         expectedException.expect(InvalidRelationName.class);
564         expectedException.expectMessage("Relation name \"doc._invalid\" is invalid.");
565         analyze("create table _invalid (id integer primary key)");
566     }
567     @Test
568     public void testHasColumnDefinition() {
569         BoundCreateTable analysis = analyze(
570             "create table my_table (" +
571             "  id integer primary key, " +
572             "  name string, " +
573             "  indexed string index using fulltext with (analyzer='german')," +
574             "  arr array(object as(" +
575             "    nested float," +
576             "    nested_object object as (id byte)" +
577             "  ))," +
578             "  obj object as ( content string )," +
579             "  index ft using fulltext(name, obj['content']) with (analyzer='standard')" +
580             ")");
581         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("id")));
582         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("name")));
583         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("indexed")));
584         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("arr")));
585         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("arr.nested")));
586         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("arr.nested_object.id")));
587         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("obj")));
588         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("obj.content")));
589         assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath("arr.nested.wrong")));
590         assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath("ft")));
591         assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath("obj.content.ft")));
592     }
593     @Test
594     public void testCreateTableWithGeoPoint() {
595         BoundCreateTable analyze = analyze(
596             "create table geo_point_table (\n" +
597             "    id integer primary key,\n" +
598             "    my_point geo_point\n" +
599             ")\n");
600         Map my_point = (Map) analyze.mappingProperties().get("my_point");
601         assertEquals("geo_point", my_point.get("type"));
602     }
603     @Test(expected = IllegalArgumentException.class)
604     public void testClusteredIntoZeroShards() {
605         analyze("create table my_table (" +
606                 "  id integer," +
607                 "  name string" +
608                 ") clustered into 0 shards");
609     }
610     @Test
611     public void testBlobTableClusteredIntoZeroShards() {
612         AnalyzedCreateBlobTable blobTable = analyze("create blob table my_table clustered into 0 shards");
613         expectedException.expect(IllegalArgumentException.class);
614         expectedException.expectMessage("num_shards in CLUSTERED clause must be greater than 0");
615         CreateBlobTablePlan.buildSettings(
616             blobTable.createBlobTable(),
617             plannerContext.transactionContext(),
618             plannerContext.nodeContext(),
619             new RowN(new Object[0]),
620             SubQueryResults.EMPTY,
621             new NumberOfShards(clusterService));
622     }
623     @Test
624     public void testEarlyPrimaryKeyConstraint() {
625         BoundCreateTable analysis = analyze(
626             "create table my_table (" +
627             "primary key (id1, id2)," +
628             "id1 integer," +
629             "id2 long" +
630             ")");
631         assertThat(analysis.primaryKeys().size(), is(2));
632         assertThat(analysis.primaryKeys(), hasItems("id1", "id2"));
633     }
634     @Test(expected = ColumnUnknownException.class)
635     public void testPrimaryKeyConstraintNonExistingColumns() {
636         analyze("create table my_table (" +
637                 "primary key (id1, id2)," +
638                 "title string," +
639                 "name string" +
640                 ")");
641     }
642     @SuppressWarnings("unchecked")
643     @Test
644     public void testEarlyIndexDefinition() {
645         BoundCreateTable analysis = analyze(
646             "create table my_table (" +
647             "index ft using fulltext(title, name) with (analyzer='snowball')," +
648             "title string," +
649             "name string" +
650             ")");
651         Map&lt;String, Object&gt; metaMap = (Map) analysis.mapping().get("_meta");
652         assertThat(
653             metaMap.get("indices").toString(),
654             is("{ft={}}"));
655         assertThat(
656             (List&lt;String&gt;) ((Map&lt;String, Object&gt;) analysis.mappingProperties()
657                 .get("title")).get("copy_to"),
658             hasItem("ft")
659         );
660         assertThat(
661             (List&lt;String&gt;) ((Map&lt;String, Object&gt;) analysis.mappingProperties()
662                 .get("name")).get("copy_to"),
663             hasItem("ft"));
664     }
665     @Test(expected = ColumnUnknownException.class)
666     public void testIndexDefinitionNonExistingColumns() {
667         analyze("create table my_table (" +
668                 "index ft using fulltext(id1, id2) with (analyzer='snowball')," +
669                 "title string," +
670                 "name string" +
671                 ")");
672     }
673     @Test(expected = IllegalArgumentException.class)
674     public void testAnalyzerOnInvalidType() {
675         analyze("create table my_table (x integer INDEX using fulltext with (analyzer='snowball'))");
676     }
677     @Test
678     public void createTableNegativeReplicas() {
679         expectedException.expect(IllegalArgumentException.class);
680         expectedException.expectMessage("Failed to parse value [-1] for setting [number_of_replicas] must be &gt;= 0");
681         analyze("create table t (id int, name string) with (number_of_replicas=-1)");
682     }
683     @Test(expected = IllegalArgumentException.class)
684     public void testCreateTableSameColumn() {
685         analyze("create table my_table (title string, title integer)");
686     }
687     @Test(expected = UnsupportedOperationException.class)
688     public void testCreateTableWithArrayPrimaryKeyUnsupported() {
689         analyze("create table t (id array(int) primary key)");
690     }
691     @Test
692     public void testCreateTableWithClusteredIntoShardsParameter() {
693         BoundCreateTable analysis = analyze(
694             "create table t (id int primary key) clustered into ? shards", 2);
695         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("2"));
696     }
697     @Test
698     public void testCreateTableWithClusteredIntoShardsParameterNonNumeric() {
699         expectedException.expect(IllegalArgumentException.class);
700         expectedException.expectMessage("invalid number 'foo'");
701         analyze("create table t (id int primary key) clustered into ? shards", "foo");
702     }
703     @Test
704     public void testCreateTableWithParitionedColumnInClusteredBy() {
705         expectedException.expect(IllegalArgumentException.class);
706         expectedException.expectMessage("Cannot use CLUSTERED BY column in PARTITIONED BY clause");
707         analyze("create table t(id int primary key) partitioned by (id) clustered by (id)");
708     }
709     @Test
710     public void testCreateTableUsesDefaultSchema() {
711         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService, 1, Randomness.get(), List.of())
712             .setSearchPath("firstSchema", "secondSchema")
713             .build();
714         BoundCreateTable analysis = analyze(sqlExecutor, "create table t (id int)");
715         assertThat(analysis.tableIdent().schema(), is(sqlExecutor.getSessionContext().searchPath().currentSchema()));
716     }
717     @Test
718     public void testCreateTableWithEmptySchema() {
719         expectedException.expect(InvalidSchemaNameException.class);
720         expectedException.expectMessage("schema name \"\" is invalid.");
721         analyze("create table \"\".my_table (" +
722                 "id long primary key" +
723                 ")");
724     }
725     @Test
726     public void testCreateTableWithIllegalSchema() {
727         expectedException.expect(InvalidSchemaNameException.class);
728         expectedException.expectMessage("schema name \"with.\" is invalid.");
729         analyze("create table \"with.\".my_table (" +
730                 "id long primary key" +
731                 ")");
732     }
733     @Test
734     public void testCreateTableWithInvalidColumnName() {
735         expectedException.expect(InvalidColumnNameException.class);
736         expectedException.expectMessage(
737             "\"_test\" conflicts with system column pattern");
738         analyze("create table my_table (\"_test\" string)");
739     }
740     @Test
741     public void testCreateTableShouldRaiseErrorIfItExists() {
742         expectedException.expect(RelationAlreadyExists.class);
743         analyze("create table users (\"'test\" string)");
744     }
745     @Test
746     public void testExplicitSchemaHasPrecedenceOverDefaultSchema() {
747         SQLExecutor e = SQLExecutor.builder(clusterService).setSearchPath("hoschi").build();
748         BoundCreateTable statement = analyze(e, "create table foo.bar (x string)");
749         assertThat(statement.tableIdent().schema(), is("foo"));
750     }
751     @Test
752     public void testDefaultSchemaIsAddedToTableIdentIfNoExplicitSchemaExistsInTheStatement() {
753         SQLExecutor e = SQLExecutor.builder(clusterService).setSearchPath("hoschi").build();
754         BoundCreateTable statement = analyze(e, "create table bar (x string)");
755         assertThat(statement.tableIdent().schema(), is("hoschi"));
756     }
757     @Test
758     public void testChangeReadBlock() {
759         BoundAlterTable analysis =
760             analyze("alter table users set (\"blocks.read\"=true)");
761         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_SETTING.getKey()), is("true"));
762     }
763     @Test
764     public void testChangeWriteBlock() {
765         BoundAlterTable analysis =
766             analyze("alter table users set (\"blocks.write\"=true)");
767         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_WRITE_SETTING.getKey()), is("true"));
768     }
769     @Test
770     public void testChangeMetadataBlock() {
771         BoundAlterTable analysis =
772             analyze("alter table users set (\"blocks.metadata\"=true)");
773         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_METADATA_SETTING.getKey()), is("true"));
774     }
775     @Test
776     public void testChangeReadOnlyBlock() {
777         BoundAlterTable analysis =
778             analyze("alter table users set (\"blocks.read_only\"=true)");
779         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_READ_ONLY_SETTING.getKey()), is("true"));
780     }
781     @Test
782     public void testChangeBlockReadOnlyAllowDelete() {
783         BoundAlterTable analysis =
784             analyze("alter table users set (\"blocks.read_only_allow_delete\"=true)");
785         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.getKey()), is("true"));
786     }
787     @Test
788     public void testChangeBlockReadOnlyAllowedDeletePartitionedTable() {
789         BoundAlterTable analysis =
790             analyze("alter table parted set (\"blocks.read_only_allow_delete\"=true)");
791         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.getKey()), is("true"));
792     }
793     @Test
794     public void testChangeFlushThresholdSize() {
795         BoundAlterTable analysis =
796             analyze("alter table users set (\"translog.flush_threshold_size\"='300b')");
797         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey()), is("300b"));
798     }
799     @Test
800     public void testChangeTranslogInterval() {
801         BoundAlterTable analysis =
802             analyze("alter table users set (\"translog.sync_interval\"='100ms')");
803         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()), is("100ms"));
804     }
805     @Test
806     public void testChangeTranslogDurability() {
807         BoundAlterTable analysis =
808             analyze("alter table users set (\"translog.durability\"='ASYNC')");
809         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey()), is("ASYNC"));
810     }
811     @Test
812     public void testRoutingAllocationEnable() {
813         BoundAlterTable analysis =
814             analyze("alter table users set (\"routing.allocation.enable\"=\"none\")");
815         assertThat(analysis.tableParameter().settings().get(EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey()), is("none"));
816     }
817     @Test
818     public void testRoutingAllocationValidation() {
819         expectedException.expect(IllegalArgumentException.class);
820         analyze("alter table users set (\"routing.allocation.enable\"=\"foo\")");
821     }
822     @Test
823     public void testAlterTableSetShards() {
824         BoundAlterTable analysis =
825             analyze("alter table users set (\"number_of_shards\"=1)");
826         assertThat(analysis.table().ident().name(), is("users"));
827         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("1"));
828     }
829     @Test
830     public void testAlterTableResetShards() {
831         BoundAlterTable analysis =
832             analyze("alter table users reset (\"number_of_shards\")");
833         assertThat(analysis.table().ident().name(), is("users"));
834         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("5"));
835     }
836     @Test
837     public void testTranslogSyncInterval() {
838         BoundAlterTable analysis =
839             analyze("alter table users set (\"translog.sync_interval\"='1s')");
840         assertThat(analysis.table().ident().name(), is("users"));
841         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()), is("1s"));
842     }
843     @Test
844     public void testAllocationMaxRetriesValidation() {
845         BoundAlterTable analysis =
846             analyze("alter table users set (\"allocation.max_retries\"=1)");
847         assertThat(analysis.tableParameter().settings().get(MaxRetryAllocationDecider.SETTING_ALLOCATION_MAX_RETRY.getKey()), is("1"));
848     }
849     @Test
850     public void testCreateReadOnlyTable() {
851         BoundCreateTable analysis = analyze(
852             "create table foo (id integer primary key, name string) "
853             + "clustered into 3 shards with (\"blocks.read_only\"=true)");
854         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_READ_ONLY_SETTING.getKey()), is("true"));
855     }
856     @SuppressWarnings("unchecked")
857     @Test
858     public void testCreateTableWithGeneratedColumn() {
859         BoundCreateTable analysis = analyze(
860             "create table foo (" +
861             "   ts timestamp with time zone," +
862             "   day as date_trunc('day', ts))");
863         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
864         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
865         assertThat(generatedColumnsMapping.size(), is(1));
866         assertThat(generatedColumnsMapping.get("day"), is("date_trunc('day', ts)"));
867         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
868         Map&lt;String, Object&gt; dayMapping = (Map&lt;String, Object&gt;) mappingProperties.get("day");
869         assertThat(dayMapping.get("type"), is("date"));
870         Map&lt;String, Object&gt; tsMapping = (Map&lt;String, Object&gt;) mappingProperties.get("ts");
871         assertThat(tsMapping.get("type"), is("date"));
872     }
873     @Test
874     public void testCreateTableWithColumnOfArrayTypeAndGeneratedExpression() {
875         BoundCreateTable analysis = analyze(
876             "create table foo (arr array(integer) as ([1.0, 2.0]))");
877         assertThat(
878             mapToSortedString(analysis.mappingProperties()),
879             is("arr={inner={position=1, type=integer}, type=array}"));
880     }
881     @SuppressWarnings("unchecked")
882     @Test
883     public void testCreateTableGeneratedColumnWithCast() {
884         BoundCreateTable analysis = analyze(
885             "create table foo (" +
886             "   ts timestamp with time zone," +
887             "   day timestamp with time zone GENERATED ALWAYS as ts + 1)");
888         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
889         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
890         assertThat(
891             generatedColumnsMapping.get("day"),
892             is("(ts + 1::bigint)"));
893         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
894         Map&lt;String, Object&gt; dayMapping = (Map&lt;String, Object&gt;) mappingProperties.get("day");
895         assertThat(dayMapping.get("type"), is("date"));
896     }
897     @SuppressWarnings("unchecked")
898     @Test
899     public void testCreateTableWithCurrentTimestampAsGeneratedColumnIsntNormalized() {
900         BoundCreateTable analysis = analyze(
901             "create table foo (ts timestamp with time zone GENERATED ALWAYS as current_timestamp(3))");
902         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
903         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
904         assertThat(generatedColumnsMapping.size(), is(1));
905         assertThat(generatedColumnsMapping.get("ts"), is("current_timestamp(3)"));
906     }
907     @SuppressWarnings("unchecked")
908     @Test
909     public void testCreateTableGeneratedColumnWithSubscript() {
910         BoundCreateTable analysis = analyze(
911             "create table foo (\"user\" object as (name string), name as concat(\"user\"['name'], 'foo'))");
912         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
913         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
914         assertThat(generatedColumnsMapping.get("name"), is("concat(\"user\"['name'], 'foo')"));
915     }
916     @SuppressWarnings("unchecked")
917     @Test
918     public void testCreateTableGeneratedColumnParameter() {
919         BoundCreateTable analysis = analyze(
920             "create table foo (\"user\" object as (name string), name as concat(\"user\"['name'], ?))", $("foo"));
921         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
922         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
923         assertThat(generatedColumnsMapping.get("name"), is("concat(\"user\"['name'], 'foo')"));
924     }
925     @Test
926     public void testCreateTableGeneratedColumnWithInvalidType() {
927         expectedException.expect(IllegalArgumentException.class);
928         expectedException.expectMessage("expression value type" +
929                                         " 'timestamp with time zone' not supported for conversion to 'ip'");
930         analyze(
931             "create table foo (" +
932             "   ts timestamp with time zone," +
933             "   day ip GENERATED ALWAYS as date_trunc('day', ts))");
934     }
935     @Test
936     public void testCreateTableGeneratedColumnWithMatch() {
937         expectedException.expect(UnsupportedFeatureException.class);
938         expectedException.expectMessage("Cannot use MATCH in CREATE TABLE statements");
939         analyze("create table foo (name string, bar as match(name, 'crate'))");
940     }
941     @Test
942     public void testCreateTableGeneratedColumnBasedOnGeneratedColumn() {
943         expectedException.expect(IllegalArgumentException.class);
944         expectedException.expectMessage("A generated column cannot be based on a generated column");
945         analyze(
946             "create table foo (" +
947             "   ts timestamp with time zone," +
948             "   day as date_trunc('day', ts)," +
949             "   date_string as cast(day as string))");
950     }
951     @Test
952     public void testCreateTableGeneratedColumnBasedOnUnknownColumn() {
953         expectedException.expect(ColumnUnknownException.class);
954         expectedException.expectMessage("Column unknown_col unknown");
955         analyze(
956             "create table foo (" +
957             "   ts timestamp with time zone," +
958             "   day as date_trunc('day', ts)," +
959             "   date_string as cast(unknown_col as string))");
960     }
961     @Test
962     public void testCreateTableWithDefaultExpressionLiteral() {
963         BoundCreateTable analysis = analyze(
964             "create table foo (name text default 'bar')");
965         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
966         assertThat(mapToSortedString(mappingProperties),
967                    is("name={default_expr='bar', position=1, type=keyword}"));
968     }
969     @Test
970     public void testCreateTableWithDefaultExpressionFunction() {
971         BoundCreateTable analysis = analyze(
972             "create table foo (name text default upper('bar'))");
973         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
974         assertThat(mapToSortedString(mappingProperties),
975                    is("name={default_expr='BAR', position=1, type=keyword}"));
976     }
977     @Test
978     public void testCreateTableWithDefaultExpressionWithCast() {
979         BoundCreateTable analysis = analyze(
980             "create table foo (id int default 3.5)");
981         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
982         assertThat(mapToSortedString(mappingProperties),
983                    is("id={default_expr=_cast(3.5, 'integer'), position=1, type=integer}"));
984     }
985     @Test
986     public void testCreateTableWithDefaultExpressionIsNotNormalized() {
987         BoundCreateTable analysis = analyze(
988             "create table foo (ts timestamp with time zone default current_timestamp(3))");
989         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
990         assertThat(mapToSortedString(mappingProperties),
991                    is("ts={default_expr=current_timestamp(3), " +
992                       "format=epoch_millis||strict_date_optional_time, " +
993                       "position=1, type=date}"));
994     }
995     @Test
996     public void testCreateTableWithDefaultExpressionAsCompoundTypes() {
997         BoundCreateTable analysis = analyze(
998             "create table foo (" +
999             "   obj object as (key text) default {key=''}," +
1000             "   arr array(long) default [1, 2])");
1001         assertThat(mapToSortedString(analysis.mappingProperties()), is(
1002             "arr={inner={position=3, type=long}, type=array}, " +
1003             "obj={default_expr={\"key\"=''}, dynamic=true, position=1, properties={key={position=2, type=keyword}}, type=object}"));
1004     }
1005     @Test
1006     public void testCreateTableWithDefaultExpressionAsGeoTypes() {
1007         BoundCreateTable analysis = analyze(
1008             "create table foo (" +
1009             "   p geo_point default [0,0]," +
1010             "   s geo_shape default 'LINESTRING (0 0, 1 1)')");
1011         assertThat(mapToSortedString(analysis.mappingProperties()), is(
1012             "p={default_expr=_cast([0, 0], 'geo_point'), position=1, type=geo_point}, " +
1013             "s={default_expr=_cast('LINESTRING (0 0, 1 1)', 'geo_shape'), position=2, type=geo_shape}"));
1014     }
1015     @Test
1016     public void testCreateTableWithDefaultExpressionRefToColumnsNotAllowed() {
1017         expectedException.expect(UnsupportedOperationException.class);
1018         expectedException.expectMessage("Columns cannot be used in this context. " +
1019                                         "Maybe you wanted to use a string literal which requires single quotes: 'name'");
1020         analyze("create table foo (name text, name_def text default upper(name))");
1021     }
1022     @Test
1023     public void testCreateTableWithObjectAsPrimaryKey() {
1024         expectedException.expectMessage("Cannot use columns of type \"object\" as primary key");
1025         expectedException.expect(UnsupportedOperationException.class);
1026         analyze("create table t (obj object as (x int) primary key)");
1027     }
1028     @Test
1029     public void testCreateTableWithGeoPointAsPrimaryKey() {
1030         expectedException.expectMessage("Cannot use columns of type \"geo_point\" as primary key");
1031         expectedException.expect(UnsupportedOperationException.class);
1032         analyze("create table t (c geo_point primary key)");
1033     }
1034     @Test
1035     public void testCreateTableWithGeoShapeAsPrimaryKey() {
1036         expectedException.expectMessage("Cannot use columns of type \"geo_shape\" as primary key");
1037         expectedException.expect(UnsupportedOperationException.class);
1038         analyze("create table t (c geo_shape primary key)");
1039     }
1040     @Test
1041     public void testCreateTableWithDuplicatePrimaryKey() {
1042         assertDuplicatePrimaryKey("create table t (id int, primary key (id, id))");
1043         assertDuplicatePrimaryKey("create table t (obj object as (id int), primary key (obj['id'], obj['id']))");
1044         assertDuplicatePrimaryKey("create table t (id int primary key, primary key (id))");
1045         assertDuplicatePrimaryKey("create table t (obj object as (id int primary key), primary key (obj['id']))");
1046     }
1047     private void assertDuplicatePrimaryKey(String stmt) {
1048         try {
1049             analyze(stmt);
1050             fail(String.format(Locale.ENGLISH, "Statement '%s' did not result in duplicate primary key exception", stmt));
1051         } catch (IllegalArgumentException e) {
1052             String msg = "appears twice in primary key constraint";
1053             if (!e.getMessage().contains(msg)) {
1054                 fail("Exception message is expected to contain: " + msg);
1055             }
1056         }
1057     }
1058     @Test
1059     public void testAlterTableAddColumnWithCheckConstraint() throws Exception {
1060         SQLExecutor.builder(clusterService)
1061             .addTable("create table t (" +
1062                       "    id int primary key, " +
1063                       "    qty int constraint check_qty_gt_zero check(qty &gt; 0), " +
1064                       "    constraint check_id_ge_zero check (id &gt;= 0)" +
1065                       ")")
1066             .build();
1067         String alterStmt = "alter table t add column bazinga int constraint bazinga_check check(bazinga != 42)";
1068         BoundAddColumn analysis = analyze(alterStmt);
1069         Map&lt;String, Object&gt; mapping = analysis.mapping();
1070         Map&lt;String, String&gt; checkConstraints = analysis.analyzedTableElements().getCheckConstraints();
1071         assertEquals(checkConstraints.get("check_id_ge_zero"),
1072                      Maps.getByPath(mapping, Arrays.asList("_meta", "check_constraints", "check_id_ge_zero")));
1073         assertEquals(checkConstraints.get("check_qty_gt_zero"),
1074                      Maps.getByPath(mapping, Arrays.asList("_meta", "check_constraints", "check_qty_gt_zero")));
1075         assertEquals(checkConstraints.get("bazinga_check"),
1076                      Maps.getByPath(mapping, Arrays.asList("_meta", "check_constraints", "bazinga_check")));
1077     }
1078     @Test
1079     public void testCreateTableWithPrimaryKeyConstraintInArrayItem() {
1080         expectedException.expect(UnsupportedOperationException.class);
1081         expectedException.expectMessage("Cannot use column \"id\" as primary key within an array object");
1082         analyze("create table test (arr array(object as (id long primary key)))");
1083     }
1084     @Test
1085     public void testCreateTableWithDeepNestedPrimaryKeyConstraintInArrayItem() {
1086         expectedException.expect(UnsupportedOperationException.class);
1087         expectedException.expectMessage("Cannot use column \"name\" as primary key within an array object");
1088         analyze("create table test (arr array(object as (\"user\" object as (name string primary key), id long)))");
1089     }
1090     @Test
1091     public void testCreateTableWithInvalidIndexConstraint() {
1092         expectedException.expect(IllegalArgumentException.class);
1093         expectedException.expectMessage("INDEX constraint cannot be used on columns of type \"object\"");
1094         analyze("create table test (obj object index off)");
1095     }
1096     @Test
1097     public void testCreateTableWithColumnStoreDisabled() {
1098         BoundCreateTable analysis = analyze(
1099             "create table columnstore_disabled (s string STORAGE WITH (columnstore = false))");
1100         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
1101         assertThat(mapToSortedString(mappingProperties), is("s={doc_values=false, position=1, type=keyword}"));
1102     }
1103     @Test
1104     public void testCreateTableWithColumnStoreDisabledOnInvalidDataType() {
1105         expectedException.expect(IllegalArgumentException.class);
1106         expectedException.expectMessage("Invalid storage option \"columnstore\" for data type \"integer\"");
1107         analyze("create table columnstore_disabled (s int STORAGE WITH (columnstore = false))");
1108     }
1109     @Test
1110     public void testCreateTableFailsIfNameConflictsWithView() {
1111         SQLExecutor executor = SQLExecutor.builder(clusterService)
1112             .addView(RelationName.fromIndexName("v1"), "Select * from t1")
1113             .build();
1114         expectedException.expect(RelationAlreadyExists.class);
1115         expectedException.expectMessage("Relation 'doc.v1' already exists");
1116         analyze(executor, "create table v1 (x int) clustered into 1 shards with (number_of_replicas = 0)");
1117     }
1118     @Test
1119     public void testGeneratedColumnInsideObjectIsProcessed() {
1120         BoundCreateTable stmt = analyze("create table t (obj object as (c as 1 + 1))");
1121         AnalyzedColumnDefinition&lt;Object&gt; obj = stmt.analyzedTableElements().columns().get(0);
1122         AnalyzedColumnDefinition&lt;?&gt; c = obj.children().get(0);
1123         assertThat(c.dataType(), is(DataTypes.INTEGER));
1124         assertThat(c.formattedGeneratedExpression(), is("2"));
1125         assertThat(AnalyzedTableElements.toMapping(stmt.analyzedTableElements()).toString(),
1126                    is("{_meta={generated_columns={obj.c=2}}, " +
1127                       "properties={obj={dynamic=true, position=1, type=object, properties={c={position=2, type=integer}}}}}"));
1128     }
1129     @Test
1130     public void testNumberOfRoutingShardsCanBeSetAtCreateTable() {
1131         BoundCreateTable stmt = analyze("""
1132             create table t (x int)
1133             clustered into 2 shards
1134             with (number_of_routing_shards = 10)
1135         """);
1136         assertThat(stmt.tableParameter().settings().get("index.number_of_routing_shards"), is("10"));
1137     }
1138     @Test
1139     public void testNumberOfRoutingShardsCanBeSetAtCreateTableForPartitionedTables() {
1140         BoundCreateTable stmt = analyze(
1141             "create table t (p int, x int) clustered into 2 shards partitioned by (p) " +
1142             "with (number_of_routing_shards = 10)");
1143         assertThat(stmt.tableParameter().settings().get("index.number_of_routing_shards"), is("10"));
1144     }
1145     @Test
1146     public void testAlterTableSetDynamicSetting() {
1147         BoundAlterTable analysis =
1148             analyze("alter table users set (\"routing.allocation.exclude.foo\"='bar')");
1149         assertThat(analysis.tableParameter().settings().get(INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + "foo"), is("bar"));
1150     }
1151     @Test
1152     public void testAlterTableResetDynamicSetting() {
1153         BoundAlterTable analysis =
1154             analyze("alter table users reset (\"routing.allocation.exclude.foo\")");
1155         assertThat(analysis.tableParameter().settings().get(INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + "foo"), nullValue());
1156     }
1157     @Test
1158     public void testCreateTableWithIntervalFails() {
1159         expectedException.expect(IllegalArgumentException.class);
1160         expectedException.expectMessage("Cannot use the type `interval` for column: i");
1161         analyze("create table test (i interval)");
1162     }
1163     @Test
1164     public void test_character_varying_type_can_be_used_in_create_table() throws Exception {
1165         BoundCreateTable stmt = analyze("create table tbl (name character varying)");
1166         assertThat(
1167             mapToSortedString(stmt.mappingProperties()),
1168             is("name={position=1, type=keyword}"));
1169     }
1170     @Test
1171     public void test_create_table_with_varchar_column_of_limited_length() {
1172         BoundCreateTable stmt = analyze("CREATE TABLE tbl (name character varying(2))");
1173         assertThat(
1174             mapToSortedString(stmt.mappingProperties()),
1175             is("name={length_limit=2, position=1, type=keyword}"));
1176     }
1177     @Test
1178     public void test_create_table_with_varchar_column_of_limited_length_with_analyzer_throws_exception() {
1179         expectedException.expect(IllegalArgumentException.class);
1180         expectedException.expectMessage(
1181             "Can't use an Analyzer on column name because analyzers are only allowed on columns " +
1182             "of type \"" + DataTypes.STRING.getName() + "\" of the unbound length limit.");
1183         analyze("CREATE TABLE tbl (name varchar(2) INDEX using fulltext WITH (analyzer='german'))");
1184     }
1185     @Test
1186     public void test_oidvector_cannot_be_used_in_create_table() throws Exception {
1187         expectedException.expectMessage("Cannot use the type `oidvector` for column: x");
1188         analyze("CREATE TABLE tbl (x oidvector)");
1189     }
1190     @Test
1191     public void test_generated_column_arguments_are_detected_as_array_and_validation_fails_with_missing_overload() throws Exception {
1192         Exception exception = Assertions.assertThrows(
1193             Exception.class,
1194             () -&gt; analyze("CREATE TABLE tbl (xs int[], x as max(xs))")
1195         );
1196         assertThat(
1197             exception.getMessage(),
1198             Matchers.startsWith("Unknown function: max(doc.tbl.xs), no overload found for matching argument types: (integer_array)")
1199         );
1200     }
1201     @Test
1202     public void test_prohibit_using_aggregations_in_generated_columns() throws Exception {
1203         Exception exception = Assertions.assertThrows(
1204             Exception.class,
1205             () -&gt; analyze("CREATE TABLE tbl (x int, y as max(x))")
1206         );
1207         assertThat(
1208             exception.getMessage(),
1209             Matchers.startsWith("Aggregation functions are not allowed in generated columns: max(x)")
1210         );
1211     }
1212     @Test
1213     public void test_can_use_bit_type_in_create_table_statement() throws Exception {
1214         BoundCreateTable stmt = analyze("CREATE TABLE tbl (xs bit(20))");
1215         assertThat(mapToSortedString(stmt.mappingProperties()), is(
1216             "xs={length=20, position=1, type=bit}"
1217         ));
1218     }
1219     @Test
1220     public void test_bit_type_defaults_to_length_1() throws Exception {
1221         BoundCreateTable stmt = analyze("CREATE TABLE tbl (xs bit)");
1222         assertThat(mapToSortedString(stmt.mappingProperties()), is(
1223             "xs={length=1, position=1, type=bit}"
1224         ));
1225     }
1226     @Test
1227     public void test_now_function_is_not_normalized_to_literal_in_create_table() throws Exception {
1228         BoundCreateTable stmt = analyze("create table tbl (ts timestamp with time zone default now())");
1229         assertThat(mapToSortedString(stmt.mappingProperties()), Matchers.startsWith(
1230             "ts={default_expr=now()"
1231         ));
1232     }
1233     @Test
1234     public void test_current_user_function_is_not_normalized_to_literal_in_create_table() throws Exception {
1235         BoundCreateTable stmt = analyze("create table tbl (user_name text default current_user)");
1236         assertThat(mapToSortedString(stmt.mappingProperties()), Matchers.startsWith(
1237             "user_name={default_expr=CURRENT_USER, position=1, type=keyword}"
1238         ));
1239     }
1240     @Test
1241     public void test_create_table_with_invalid_storage_option_errors_with_invalid_property_name() throws Exception {
1242         assertThrowsMatches(
1243             () -&gt; analyze("create table tbl (name text storage with (foobar = true))"),
1244             IllegalArgumentException.class,
1245             "Invalid STORAGE WITH option `foobar`"
1246         );
1247     }
1248 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
