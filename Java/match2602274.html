<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for LuceneBatchIterator.java &amp; AnalyzedTableElements.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for LuceneBatchIterator.java &amp; AnalyzedTableElements.java
      </h3>
<h1 align="center">
        8.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>LuceneBatchIterator.java (19.858156%)<th>AnalyzedTableElements.java (5.5888224%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-48)<td><a href="#" name="0">(22-49)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(58-69)<td><a href="#" name="1">(85-95)</a><td align="center"><font color="#700000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(202-208)<td><a href="#" name="2">(511-518)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(181-186)<td><a href="#" name="3">(206-211)</a><td align="center"><font color="#660000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LuceneBatchIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.execution.engine.collect.collectors;

import io.crate.data.BatchIterator;
import io.crate.data.Input;
import io.crate.data.Row;
import io.crate.exceptions.Exceptions;
import io.crate.execution.engine.fetch.ReaderContext;
import io.crate.expression.InputRow;
import io.crate.expression.reference.doc.lucene.CollectorContext;
import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;
import org.apache.lucene.index.LeafReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.search.DocIdSetIterator;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreMode;
import org.apache.lucene.search.Scorer;
import org.apache.lucene.search.Weight;
import org.apache.lucene.util.Bits;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import</b></font> java.util.concurrent.CompletionStage;

/**
 * BatchIterator implementation which exposes the data stored in a lucene index.
 * It supports filtering the data using a lucene {@link Query} or via {@code minScore}.
 * &lt;p&gt;
 * Row data depends on {@code inputs} and {@code expressions}. The data is unordered.
<a name="1"></a> */
public class LuceneBatchIterator implements BatchIterator&lt;Row&gt; {

    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private final IndexSearcher indexSearcher;
    private final Query query;
    private final CollectorContext collectorContext;
    private final boolean doScores;
    private final LuceneCollectorExpression[] expressions;
    private final List&lt;LeafReaderContext&gt; leaves;
    private final InputRow row;
    private Weight weight;
    private final Float minScore;

    private Iterator&lt;LeafReaderContext&gt; leavesIt;
    private LeafReaderContext currentLeaf</b></font>;
    private Scorer currentScorer;
    private DocIdSetIterator currentDocIdSetIt;
    private volatile Throwable killed;

    public LuceneBatchIterator(IndexSearcher indexSearcher,
                               Query query,
                               @Nullable Float minScore,
                               boolean doScores,
                               CollectorContext collectorContext,
                               List&lt;? extends Input&lt;?&gt;&gt; inputs,
                               Collection&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; expressions) {
        this.indexSearcher = indexSearcher;
        this.query = query;
        this.doScores = doScores || minScore != null;
        this.minScore = minScore;
        this.collectorContext = collectorContext;
        this.row = new InputRow(inputs);
        this.expressions = expressions.toArray(new LuceneCollectorExpression[0]);
        leaves = indexSearcher.getTopReaderContext().leaves();
        leavesIt = leaves.iterator();
    }

    @Override
    public Row currentElement() {
        return row;
    }

    @Override
    public void moveToStart() {
        raiseIfKilled();
        leavesIt = leaves.iterator();
    }

    @Override
    public boolean moveNext() {
        raiseIfKilled();
        if (weight == null) {
            try {
                weight = createWeight();
            } catch (IOException e) {
                Exceptions.rethrowUnchecked(e);
            }
        }

        try {
            return innerMoveNext();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private boolean innerMoveNext() throws IOException {
        while (tryAdvanceDocIdSetIterator()) {
            LeafReader reader = currentLeaf.reader();
            Bits liveDocs = reader.getLiveDocs();
            int doc;
            while ((doc = currentDocIdSetIt.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
                if (docDeleted(liveDocs, doc) || belowMinScore(currentScorer)) {
                    continue;
                }
                onDoc(doc);
                return true;
            }
            currentDocIdSetIt = null;
        }
        clearState();
        return false;
    }

    private boolean belowMinScore(Scorer currentScorer) throws IOException {
        return minScore != null &amp;&amp; currentScorer.score() &lt; minScore;
    }

    private boolean tryAdvanceDocIdSetIterator() throws IOException {
        if (currentDocIdSetIt != null) {
            return true;
        }
        while (leavesIt.hasNext()) {
            LeafReaderContext leaf = leavesIt.next();
            Scorer scorer = weight.scorer(leaf);
            if (scorer == null) {
                continue;
            }
            currentScorer = scorer;
            currentLeaf = leaf;
            currentDocIdSetIt = scorer.iterator();
            var readerContext = new ReaderContext(currentLeaf);
            for (LuceneCollectorExpression&lt;?&gt; expression : expressions) {
                expression.setScorer(currentScorer);
                expression.setNextReader(readerContext);
            }
            return true;
        }
        return false;
    }

    private void clearState() {
        currentDocIdSetIt = null;
        currentScorer = null;
        currentLeaf = null;
    }

    @Override
    public void close() {
        clearState();
        killed = BatchIterator.CLOSED;
    }

<a name="3"></a>    @Override
    public CompletionStage&lt;?&gt; loadNextBatch() throws Exception {
        throw new IllegalStateException("BatchIterator already fully loaded");
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    private Weight createWeight() throws IOException {
        for (LuceneCollectorExpression&lt;?&gt; expression : expressions) {
            expression.startCollect(collectorContext);
        }</b></font>
        ScoreMode scoreMode = doScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;
        return indexSearcher.createWeight(indexSearcher.rewrite(query), scoreMode, 1f);
    }

    @Override
    public boolean allLoaded() {
        return true;
    }

    @Override
    public boolean hasLazyResultSet() {
        return true;
<a name="2"></a>    }

    private static boolean docDeleted(@Nullable Bits liveDocs, int doc) {
        if (liveDocs == null) <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
            return false;
        }
        return liveDocs.get(doc) == false;
    }

    private void onDoc(int doc</b></font>) throws IOException {
        for (LuceneCollectorExpression&lt;?&gt; expression : expressions) {
            expression.setNextDocId(doc);
        }
    }

    private void raiseIfKilled() {
        if (killed != null) {
            Exceptions.rethrowUnchecked(killed);
        }
    }

    @Override
    public void kill(@Nonnull Throwable throwable) {
        killed = throwable;
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AnalyzedTableElements.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.analyze;

import io.crate.analyze.expressions.TableReferenceResolver;
import io.crate.common.annotations.VisibleForTesting;
import io.crate.exceptions.ColumnUnknownException;
import io.crate.expression.scalar.cast.CastFunctionResolver;
import io.crate.expression.symbol.RefVisitor;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.SymbolVisitors;
import io.crate.expression.symbol.Symbols;
import io.crate.expression.symbol.format.Style;
import io.crate.metadata.ColumnIdent;
import io.crate.metadata.FulltextAnalyzerResolver;
import io.crate.metadata.GeneratedReference;
import io.crate.metadata.Reference;
import io.crate.metadata.ReferenceIdent;
import io.crate.metadata.RelationName;
import io.crate.metadata.RowGranularity;
import io.crate.sql.tree.CheckColumnConstraint;
import io.crate.sql.tree.CheckConstraint;
import io.crate.types.ArrayType;
import io.crate.types.DataType;
import io.crate.types.DataTypes;

import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.settings.Settings;

import</b></font> javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;

public class AnalyzedTableElements&lt;T&gt; {

    public List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; partitionedByColumns = new ArrayList&lt;&gt;();
    private List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; columns = new ArrayList&lt;&gt;();
    private Set&lt;ColumnIdent&gt; columnIdents = new HashSet&lt;&gt;();
    private Map&lt;ColumnIdent, DataType&gt; columnTypes = new HashMap&lt;&gt;();
    private Set&lt;String&gt; primaryKeys;
    private Set&lt;String&gt; notNullColumns;
    private Map&lt;String, String&gt; checkConstraints = new LinkedHashMap&lt;&gt;();
    private List&lt;List&lt;String&gt;&gt; partitionedBy;
    private int numGeneratedColumns = 0;


    /**
     * additional primary keys that are not inline with a column definition
     */
    private List&lt;T&gt; additionalPrimaryKeys = new ArrayList&lt;&gt;();
    private Map&lt;T, Set&lt;String&gt;&gt; copyToMap = new HashMap&lt;&gt;();

<a name="1"></a>    public AnalyzedTableElements() {
    }

    private AnalyzedTableElements(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; partitionedByColumns,
                                  List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; columns,
                                  Set&lt;ColumnIdent&gt; columnIdents,
                                  Map&lt;ColumnIdent, DataType&gt; columnTypes,
                                  Set&lt;String&gt; primaryKeys,
                                  Set&lt;String&gt; notNullColumns,
                                  Map&lt;String, String&gt; checkConstraints,
                                  List&lt;List&lt;String&gt;&gt; partitionedBy,
                                  int numGeneratedColumns,
                                  List&lt;T&gt; additionalPrimaryKeys,
                                  Map&lt;T, Set&lt;String&gt;&gt; copyToMap</b></font>) {
        this.partitionedByColumns = partitionedByColumns;
        this.columns = columns;
        this.columnIdents = columnIdents;
        this.columnTypes = columnTypes;
        this.primaryKeys = primaryKeys;
        this.notNullColumns = notNullColumns;
        this.checkConstraints = checkConstraints;
        this.partitionedBy = partitionedBy;
        this.numGeneratedColumns = numGeneratedColumns;
        this.additionalPrimaryKeys = additionalPrimaryKeys;
        this.copyToMap = copyToMap;
    }

    static Map&lt;String, Object&gt; toMapping(AnalyzedTableElements&lt;Object&gt; elements) {
        final Map&lt;String, Object&gt; mapping = new HashMap&lt;&gt;();
        final Map&lt;String, Object&gt; meta = new HashMap&lt;&gt;();
        final Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;(elements.columns.size());

        Map&lt;String, String&gt; generatedColumns = new HashMap&lt;&gt;();
        Map&lt;String, Object&gt; indicesMap = new HashMap&lt;&gt;();
        for (AnalyzedColumnDefinition&lt;Object&gt; column : elements.columns) {
            properties.put(column.name(), AnalyzedColumnDefinition.toMapping(column));
            if (column.isIndexColumn()) {
                indicesMap.put(column.name(), column.toMetaIndicesMapping());
            }
            addToGeneratedColumns("", column, generatedColumns);
        }

        if (!elements.partitionedByColumns.isEmpty()) {
            meta.put("partitioned_by", elements.partitionedBy());
        }
        if (!indicesMap.isEmpty()) {
            meta.put("indices", indicesMap);
        }
        if (!primaryKeys(elements).isEmpty()) {
            meta.put("primary_keys", primaryKeys(elements));
        }
        if (!generatedColumns.isEmpty()) {
            meta.put("generated_columns", generatedColumns);
        }
        if (!notNullColumns(elements).isEmpty()) {
            Map&lt;String, Object&gt; constraints = new HashMap&lt;&gt;();
            constraints.put("not_null", notNullColumns(elements));
            meta.put("constraints", constraints);
        }
        if (!elements.checkConstraints.isEmpty()) {
            meta.put("check_constraints", elements.checkConstraints);
        }

        mapping.put("_meta", meta);
        mapping.put("properties", properties);

        return mapping;
    }

    private static void addToGeneratedColumns(String columnPrefix,
                                              AnalyzedColumnDefinition&lt;Object&gt; column,
                                              Map&lt;String, String&gt; generatedColumns) {
        String generatedExpression = column.formattedGeneratedExpression();
        if (generatedExpression != null) {
            generatedColumns.put(columnPrefix + column.name(), generatedExpression);
        }
        for (AnalyzedColumnDefinition&lt;Object&gt; child : column.children()) {
            addToGeneratedColumns(columnPrefix + column.name() + '.', child, generatedColumns);
        }
    }

    public &lt;U&gt; AnalyzedTableElements&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
        List&lt;U&gt; additionalPrimaryKeys = new ArrayList&lt;&gt;(this.additionalPrimaryKeys.size());
        for (T p : this.additionalPrimaryKeys) {
            additionalPrimaryKeys.add(mapper.apply(p));
        }
        Map&lt;U, Set&lt;String&gt;&gt; copyToMap = new HashMap&lt;&gt;(this.copyToMap.size());
        for (Map.Entry&lt;T, Set&lt;String&gt;&gt; entry : this.copyToMap.entrySet()) {
            copyToMap.put(mapper.apply(entry.getKey()), entry.getValue());
        }
        List&lt;AnalyzedColumnDefinition&lt;U&gt;&gt; partitionedByColumns = new ArrayList&lt;&gt;(this.partitionedByColumns.size());
        for (AnalyzedColumnDefinition&lt;T&gt; d : this.partitionedByColumns) {
            partitionedByColumns.add(d.map(mapper));
        }
        List&lt;AnalyzedColumnDefinition&lt;U&gt;&gt; columns = new ArrayList&lt;&gt;(this.columns.size());
        for (AnalyzedColumnDefinition&lt;T&gt; d : this.columns) {
            columns.add(d.map(mapper));
        }
        return new AnalyzedTableElements&lt;&gt;(
            partitionedByColumns,
            columns,
            columnIdents,
            columnTypes,
            primaryKeys,
            notNullColumns,
            checkConstraints,
            partitionedBy,
            numGeneratedColumns,
            additionalPrimaryKeys,
            copyToMap
        );
    }


    public List&lt;List&lt;String&gt;&gt; partitionedBy() {
        if (partitionedBy == null) {
            partitionedBy = new ArrayList&lt;&gt;(partitionedByColumns.size());
            for (AnalyzedColumnDefinition&lt;T&gt; partitionedByColumn : partitionedByColumns) {
                partitionedBy.add(List.of(
                    partitionedByColumn.ident().fqn(), partitionedByColumn.typeNameForESMapping()));
            }
<a name="3"></a>        }

        return partitionedBy;
    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    private void expandColumnIdents() {
        for (AnalyzedColumnDefinition&lt;T&gt; column : columns) {
            expandColumn(column);
        }</b></font>
    }

    private void expandColumn(AnalyzedColumnDefinition&lt;T&gt; column) {
        if (column.isIndexColumn()) {
            columnIdents.remove(column.ident());
            return;
        }

        columnIdents.add(column.ident());
        columnTypes.put(column.ident(), column.dataType());
        for (AnalyzedColumnDefinition&lt;T&gt; child : column.children()) {
            expandColumn(child);
        }
    }

    static Set&lt;String&gt; notNullColumns(AnalyzedTableElements&lt;Object&gt; elements) {
        if (elements.notNullColumns == null) {
            elements.notNullColumns = new HashSet&lt;&gt;();
            for (AnalyzedColumnDefinition&lt;Object&gt; column : elements.columns) {
                addNotNullFromChildren(column, elements);
            }
        }
        return elements.notNullColumns;
    }

    /**
     * Recursively add all not null constraints from child columns (object columns)
     */
    private static void addNotNullFromChildren(AnalyzedColumnDefinition&lt;Object&gt; parentColumn, AnalyzedTableElements&lt;Object&gt; elements) {
        LinkedList&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; childColumns = new LinkedList&lt;&gt;();
        childColumns.add(parentColumn);

        while (!childColumns.isEmpty()) {
            AnalyzedColumnDefinition&lt;Object&gt; column = childColumns.remove();
            String fqn = column.ident().fqn();
            if (column.hasNotNullConstraint() &amp;&amp; !primaryKeys(elements).contains(fqn)) { // Columns part of pk are implicitly not null
                elements.notNullColumns.add(fqn);
            }
            childColumns.addAll(column.children());
        }
    }

    public static Set&lt;String&gt; primaryKeys(AnalyzedTableElements&lt;Object&gt; elements) {
        if (elements.primaryKeys == null) {
            elements.primaryKeys = new LinkedHashSet&lt;&gt;(); // To preserve order
            for (Object pk : elements.additionalPrimaryKeys) {
                String pkAsString = pk.toString();
                checkPrimaryKeyAlreadyDefined(elements.primaryKeys, pkAsString);
                elements.primaryKeys.add(pkAsString);
            }
            for (AnalyzedColumnDefinition&lt;Object&gt; column : elements.columns) {
                elements.addPrimaryKeys(elements.primaryKeys, column);
            }
        }
        return elements.primaryKeys;
    }

    private void addPrimaryKeys(Set&lt;String&gt; primaryKeys, AnalyzedColumnDefinition&lt;T&gt; column) {
        if (column.hasPrimaryKeyConstraint()) {
            String fqn = column.ident().fqn();
            checkPrimaryKeyAlreadyDefined(primaryKeys, fqn);
            primaryKeys.add(fqn);
        }
        for (AnalyzedColumnDefinition&lt;T&gt; analyzedColumnDefinition : column.children()) {
            addPrimaryKeys(primaryKeys, analyzedColumnDefinition);
        }
    }

    private static void checkPrimaryKeyAlreadyDefined(Set&lt;String&gt; primaryKeys, String columnName) {
        if (primaryKeys.contains(columnName)) {
            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                                                             "Column \"%s\" appears twice in primary key constraint", columnName));
        }
    }

    void addPrimaryKey(T fqColumnName) {
        additionalPrimaryKeys.add(fqColumnName);
    }

    public void add(AnalyzedColumnDefinition&lt;T&gt; analyzedColumnDefinition) {
        if (columnIdents.contains(analyzedColumnDefinition.ident())) {
            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                                                             "column \"%s\" specified more than once", analyzedColumnDefinition.ident().sqlFqn()));
        }
        columnIdents.add(analyzedColumnDefinition.ident());
        columns.add(analyzedColumnDefinition);
        columnTypes.put(analyzedColumnDefinition.ident(), analyzedColumnDefinition.dataType());
        if (analyzedColumnDefinition.isGenerated()) {
            numGeneratedColumns++;
        }
    }

    public static Settings validateAndBuildSettings(AnalyzedTableElements&lt;Object&gt; tableElementsEvaluated,
                                                    FulltextAnalyzerResolver fulltextAnalyzerResolver) {
        Settings.Builder builder = Settings.builder();
        for (AnalyzedColumnDefinition&lt;Object&gt; column : tableElementsEvaluated.columns) {
            AnalyzedColumnDefinition.applyAndValidateAnalyzerSettings(column, fulltextAnalyzerResolver);
            builder.put(column.builtAnalyzerSettings());
        }
        return builder.build();
    }

    public static Map&lt;String, Object&gt; finalizeAndValidate(RelationName relationName,
                                                          AnalyzedTableElements&lt;Symbol&gt; tableElementsWithExpressionSymbols,
                                                          AnalyzedTableElements&lt;Object&gt; tableElementsEvaluated) {
        tableElementsEvaluated.expandColumnIdents();
        validateExpressions(tableElementsWithExpressionSymbols, tableElementsEvaluated);
        for (AnalyzedColumnDefinition&lt;Object&gt; column : tableElementsEvaluated.columns) {
            column.validate();
            tableElementsEvaluated.addCopyToInfo(column);
        }
        validateIndexDefinitions(relationName, tableElementsEvaluated);
        validatePrimaryKeys(relationName, tableElementsEvaluated);
        return toMapping(tableElementsEvaluated);
    }

    private static void validateExpressions(AnalyzedTableElements&lt;Symbol&gt; tableElementsWithExpressionSymbols,
                                            AnalyzedTableElements&lt;Object&gt; tableElementsEvaluated) {
        for (int i = 0; i &lt; tableElementsWithExpressionSymbols.columns.size(); i++) {
            processExpressions(
                tableElementsWithExpressionSymbols.columns.get(i),
                tableElementsEvaluated.columns.get(i)
            );
        }
    }

    public TableReferenceResolver referenceResolver(RelationName relationName) {
        List&lt;Reference&gt; tableReferences = new ArrayList&lt;&gt;();
        for (AnalyzedColumnDefinition&lt;T&gt; columnDefinition : columns) {
            buildReference(relationName, columnDefinition, tableReferences);
        }
        return new TableReferenceResolver(tableReferences, relationName);
    }

    private static void processExpressions(AnalyzedColumnDefinition&lt;Symbol&gt; columnDefinitionWithExpressionSymbols,
                                           AnalyzedColumnDefinition&lt;Object&gt; columnDefinitionEvaluated) {
        Symbol generatedExpression = columnDefinitionWithExpressionSymbols.generatedExpression();
        if (generatedExpression != null) {
            validateAndFormatExpression(
                generatedExpression,
                columnDefinitionWithExpressionSymbols,
                columnDefinitionEvaluated,
                columnDefinitionEvaluated::formattedGeneratedExpression);
        }
        Symbol defaultExpression = columnDefinitionWithExpressionSymbols.defaultExpression();
        if (defaultExpression != null) {
            RefVisitor.visitRefs(defaultExpression, r -&gt; {
                throw new UnsupportedOperationException(
                    "Columns cannot be used in this context. " +
                    "Maybe you wanted to use a string literal which requires single quotes: '" + r.column().sqlFqn() + "'");
            });
            validateAndFormatExpression(
                defaultExpression,
                columnDefinitionWithExpressionSymbols,
                columnDefinitionEvaluated,
                columnDefinitionEvaluated::formattedDefaultExpression);
        }
        for (int i = 0; i &lt; columnDefinitionWithExpressionSymbols.children().size(); i++) {
            processExpressions(
                columnDefinitionWithExpressionSymbols.children().get(i),
                columnDefinitionEvaluated.children().get(i)
            );
        }
    }

    private static void validateAndFormatExpression(Symbol function,
                                                    AnalyzedColumnDefinition&lt;Symbol&gt; columnDefinitionWithExpressionSymbols,
                                                    AnalyzedColumnDefinition&lt;Object&gt; columnDefinitionEvaluated,
                                                    Consumer&lt;String&gt; formattedExpressionConsumer) {
        String formattedExpression;
        DataType&lt;?&gt; valueType = function.valueType();
        DataType&lt;?&gt; definedType = columnDefinitionWithExpressionSymbols.dataType();

        if (SymbolVisitors.any(Symbols::isAggregate, function)) {
            throw new UnsupportedOperationException("Aggregation functions are not allowed in generated columns: " + function);
        }

        // check for optional defined type and add `cast` to expression if possible
        if (definedType != null &amp;&amp; !definedType.equals(valueType)) {
            final DataType&lt;?&gt; columnDataType;
            if (ArrayType.NAME.equals(columnDefinitionWithExpressionSymbols.collectionType())) {
                columnDataType = new ArrayType&lt;&gt;(definedType);
            } else {
                columnDataType = definedType;
            }
            if (!valueType.isConvertableTo(columnDataType, false)) {
                throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                    "expression value type '%s' not supported for conversion to '%s'",
                    valueType, columnDataType.getName())
                );
            }

            Symbol castFunction = CastFunctionResolver.generateCastFunction(function, columnDataType);
            formattedExpression = castFunction.toString(Style.UNQUALIFIED);
        } else {
            if (valueType instanceof ArrayType) {
                columnDefinitionEvaluated.collectionType(ArrayType.NAME);
                columnDefinitionEvaluated.dataType(ArrayType.unnest(valueType).getName());
            } else {
                columnDefinitionEvaluated.dataType(valueType.getName());
            }
            formattedExpression = function.toString(Style.UNQUALIFIED);
        }
        formattedExpressionConsumer.accept(formattedExpression);
    }

    private static &lt;T&gt; void buildReference(RelationName relationName,
                                           AnalyzedColumnDefinition&lt;T&gt; columnDefinition,
                                           List&lt;Reference&gt; references) {
        Reference reference;

        DataType&lt;?&gt; type = columnDefinition.dataType() == null ? DataTypes.UNDEFINED : columnDefinition.dataType();
        DataType&lt;?&gt; realType = ArrayType.NAME.equals(columnDefinition.collectionType())
            ? new ArrayType&lt;&gt;(type)
            : type;
        if (columnDefinition.isGenerated() == false) {
            reference = new Reference(
                new ReferenceIdent(relationName, columnDefinition.ident()),
                RowGranularity.DOC,
                realType,
                columnDefinition.position,
                null // not required in this context
            );
        } else {
            reference = new GeneratedReference(
                columnDefinition.position,
                new ReferenceIdent(relationName, columnDefinition.ident()),
                RowGranularity.DOC,
                realType,
                "dummy expression, real one not needed here");
        }
        references.add(reference);
        for (AnalyzedColumnDefinition&lt;T&gt; childDefinition : columnDefinition.children()) {
            buildReference(relationName, childDefinition, references);
        }
    }

    private void addCopyToInfo(AnalyzedColumnDefinition&lt;T&gt; column) {
        if (!column.isIndexColumn()) {
            Set&lt;String&gt; targets = copyToMap.get(column.ident().fqn());
            if (targets != null) {
                column.addCopyTo(targets);
            }
        }
        for (AnalyzedColumnDefinition&lt;T&gt; child : column.children()) {
            addCopyToInfo(child);
        }
    }

    private static void validatePrimaryKeys(RelationName relationName, AnalyzedTableElements&lt;Object&gt; elements) {
        for (Object additionalPrimaryKey : elements.additionalPrimaryKeys) {
            ColumnIdent columnIdent = ColumnIdent.fromPath(additionalPrimaryKey.toString());
            if (!elements.columnIdents.contains(columnIdent)) {
                throw new ColumnUnknownException(columnIdent.sqlFqn(), relationName);
            }
        }
        // will collect both column constraint and additional defined once and check for duplicates
        primaryKeys(elements);
    }

    private static void validateIndexDefinitions(RelationName relationName, AnalyzedTableElements&lt;Object&gt; tableElements) {
        for (Map.Entry&lt;Object, Set&lt;String&gt;&gt; entry : tableElements.copyToMap.entrySet()) {
            ColumnIdent columnIdent = ColumnIdent.fromPath(entry.getKey().toString());
            if (!tableElements.columnIdents.contains(columnIdent)) {
                throw new ColumnUnknownException(columnIdent.sqlFqn(), relationName);
            }
            if (!DataTypes.STRING.equals(tableElements.columnTypes.get(columnIdent))) {
                throw new IllegalArgumentException("INDEX definition only support 'string' typed source columns");
            }
        }
    }

    void addCopyTo(T sourceColumn, String targetIndex) {
        Set&lt;String&gt; targetColumns = copyToMap.get(sourceColumn);
        if (targetColumns == null) {
            targetColumns = new HashSet&lt;&gt;();
            copyToMap.put(sourceColumn, targetColumns);
        }
        targetColumns.add(targetIndex);
    }

    public Set&lt;ColumnIdent&gt; columnIdents() {
        return columnIdents;
    }

    @Nullable
    private static AnalyzedColumnDefinition&lt;Object&gt; columnDefinitionByIdent(AnalyzedTableElements&lt;Object&gt; elements, ColumnIdent ident) {
        AnalyzedColumnDefinition&lt;Object&gt; result = null;
        ColumnIdent root = ident.getRoot();
        for (AnalyzedColumnDefinition&lt;Object&gt; column : elements.columns) {
            if (column.ident().equals(root)) {
                result = column;
                break;
            }
        }
        if (result == null) {
<a name="2"></a>            return null;
        }

        if (result.ident().equals(ident)) <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
            return result;
        }

        return findInChildren(result, ident);
    }

    private static AnalyzedColumnDefinition&lt;Object&gt; findInChildren(AnalyzedColumnDefinition&lt;Object&gt; column</b></font>,
                                                                   ColumnIdent ident) {
        AnalyzedColumnDefinition&lt;Object&gt; result = null;
        for (AnalyzedColumnDefinition&lt;Object&gt; child : column.children()) {
            if (child.ident().equals(ident)) {
                result = child;
                break;
            }
            AnalyzedColumnDefinition&lt;Object&gt; inChildren = findInChildren(child, ident);
            if (inChildren != null) {
                return inChildren;
            }
        }
        return result;
    }

    public static void changeToPartitionedByColumn(AnalyzedTableElements&lt;Object&gt; elements,
                                                   ColumnIdent partitionedByIdent,
                                                   boolean skipIfNotFound,
                                                   RelationName relationName) {
        if (partitionedByIdent.name().startsWith("_")) {
            throw new IllegalArgumentException("Cannot use system columns in PARTITIONED BY clause");
        }

        // need to call primaryKeys() before the partition column is removed from the columns list
        if (!primaryKeys(elements).isEmpty() &amp;&amp; !primaryKeys(elements).contains(partitionedByIdent.fqn())) {
            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                                                             "Cannot use non primary key column '%s' in PARTITIONED BY clause if primary key is set on table",
                                                             partitionedByIdent.sqlFqn()));
        }

        AnalyzedColumnDefinition&lt;Object&gt; columnDefinition = columnDefinitionByIdent(elements, partitionedByIdent);
        if (columnDefinition == null) {
            if (skipIfNotFound) {
                return;
            }
            throw new ColumnUnknownException(partitionedByIdent.sqlFqn(), relationName);
        }
        DataType&lt;?&gt; columnType = columnDefinition.dataType();
        if (!DataTypes.isPrimitive(columnType)) {
            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                                                             "Cannot use column %s of type %s in PARTITIONED BY clause",
                                                             columnDefinition.ident().sqlFqn(), columnDefinition.dataType()));
        }
        if (columnDefinition.isArrayOrInArray()) {
            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                                                             "Cannot use array column %s in PARTITIONED BY clause", columnDefinition.ident().sqlFqn()));


        }
        if (columnDefinition.indexConstraint() == Reference.IndexType.FULLTEXT) {
            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                                                             "Cannot use column %s with fulltext index in PARTITIONED BY clause",
                                                             columnDefinition.ident().sqlFqn()));
        }
        elements.columnIdents.remove(columnDefinition.ident());
        columnDefinition.indexConstraint(Reference.IndexType.NONE);
        elements.partitionedByColumns.add(columnDefinition);
    }

    public List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; columns() {
        return columns;
    }

    private void addCheckConstraint(String fqRelationName,
                                    @Nullable String columnName,
                                    @Nullable String name,
                                    String expressionStr) {
        String uniqueName = name;
        if (uniqueName == null) {
            uniqueName = uniqueCheckConstraintName(fqRelationName, columnName);
        }
        if (checkConstraints.put(uniqueName, expressionStr) != null) {
            throw new IllegalArgumentException(String.format(
                Locale.ENGLISH, "a check constraint of the same name is already declared [%s]", uniqueName));
        }
    }

    private static String uniqueCheckConstraintName(String fqTableName, @Nullable String columnName) {
        StringBuilder sb = new StringBuilder(fqTableName.replaceAll("\\.", "_"));
        if (columnName != null) {
            sb.append("_").append(columnName);
        }
        sb.append("_check_");
        String uuid = UUIDs.dirtyUUID().toString();
        int idx = uuid.lastIndexOf("-");
        sb.append(idx &gt; 0 ? uuid.substring(idx + 1) : uuid);
        return sb.toString();
    }

    public void addCheckConstraint(RelationName relationName, CheckConstraint&lt;?&gt; check) {
        addCheckConstraint(relationName.fqn(), check.columnName(), check.name(), check.expressionStr());
    }

    public void addCheckColumnConstraint(RelationName relationName, CheckColumnConstraint&lt;?&gt; check) {
        addCheckConstraint(relationName.fqn(), check.columnName(), check.name(), check.expressionStr());
    }

    @VisibleForTesting
    Map&lt;String, String&gt; getCheckConstraints() {
        return Map.copyOf(checkConstraints);
    }

    public boolean hasGeneratedColumns() {
        return numGeneratedColumns &gt; 0;
    }

}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
