<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for LuceneBatchIterator.java &amp; AnalyzedTableElements.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for LuceneBatchIterator.java &amp; AnalyzedTableElements.java
      </h3>
<h1 align="center">
        8.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>LuceneBatchIterator.java (19.858156%)<th>AnalyzedTableElements.java (5.5888224%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-48)<td><a href="#" name="0">(22-49)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(58-69)<td><a href="#" name="1">(85-95)</a><td align="center"><font color="#700000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(202-208)<td><a href="#" name="2">(511-518)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(181-186)<td><a href="#" name="3">(206-211)</a><td align="center"><font color="#660000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LuceneBatchIterator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.execution.engine.collect.collectors;
2 import io.crate.data.BatchIterator;
3 import io.crate.data.Input;
4 import io.crate.data.Row;
5 import io.crate.exceptions.Exceptions;
6 import io.crate.execution.engine.fetch.ReaderContext;
7 import io.crate.expression.InputRow;
8 import io.crate.expression.reference.doc.lucene.CollectorContext;
9 import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;
10 import org.apache.lucene.index.LeafReader;
11 import org.apache.lucene.index.LeafReaderContext;
12 import org.apache.lucene.search.DocIdSetIterator;
13 import org.apache.lucene.search.IndexSearcher;
14 import org.apache.lucene.search.Query;
15 import org.apache.lucene.search.ScoreMode;
16 import org.apache.lucene.search.Scorer;
17 import org.apache.lucene.search.Weight;
18 import org.apache.lucene.util.Bits;
19 import javax.annotation.Nonnull;
20 import javax.annotation.Nullable;
21 import java.io.IOException;
22 import java.util.Collection;
23 import java.util.Iterator;
24 import java.util.List;
25 import</b></font> java.util.concurrent.CompletionStage;
26 public class LuceneBatchIterator implements BatchIterator&lt;Row&gt; {
27     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private final IndexSearcher indexSearcher;
28     private final Query query;
29     private final CollectorContext collectorContext;
30     private final boolean doScores;
31     private final LuceneCollectorExpression[] expressions;
32     private final List&lt;LeafReaderContext&gt; leaves;
33     private final InputRow row;
34     private Weight weight;
35     private final Float minScore;
36     private Iterator&lt;LeafReaderContext&gt; leavesIt;
37     private LeafReaderContext currentLeaf</b></font>;
38     private Scorer currentScorer;
39     private DocIdSetIterator currentDocIdSetIt;
40     private volatile Throwable killed;
41     public LuceneBatchIterator(IndexSearcher indexSearcher,
42                                Query query,
43                                @Nullable Float minScore,
44                                boolean doScores,
45                                CollectorContext collectorContext,
46                                List&lt;? extends Input&lt;?&gt;&gt; inputs,
47                                Collection&lt;? extends LuceneCollectorExpression&lt;?&gt;&gt; expressions) {
48         this.indexSearcher = indexSearcher;
49         this.query = query;
50         this.doScores = doScores || minScore != null;
51         this.minScore = minScore;
52         this.collectorContext = collectorContext;
53         this.row = new InputRow(inputs);
54         this.expressions = expressions.toArray(new LuceneCollectorExpression[0]);
55         leaves = indexSearcher.getTopReaderContext().leaves();
56         leavesIt = leaves.iterator();
57     }
58     @Override
59     public Row currentElement() {
60         return row;
61     }
62     @Override
63     public void moveToStart() {
64         raiseIfKilled();
65         leavesIt = leaves.iterator();
66     }
67     @Override
68     public boolean moveNext() {
69         raiseIfKilled();
70         if (weight == null) {
71             try {
72                 weight = createWeight();
73             } catch (IOException e) {
74                 Exceptions.rethrowUnchecked(e);
75             }
76         }
77         try {
78             return innerMoveNext();
79         } catch (IOException e) {
80             throw new RuntimeException(e);
81         }
82     }
83     private boolean innerMoveNext() throws IOException {
84         while (tryAdvanceDocIdSetIterator()) {
85             LeafReader reader = currentLeaf.reader();
86             Bits liveDocs = reader.getLiveDocs();
87             int doc;
88             while ((doc = currentDocIdSetIt.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
89                 if (docDeleted(liveDocs, doc) || belowMinScore(currentScorer)) {
90                     continue;
91                 }
92                 onDoc(doc);
93                 return true;
94             }
95             currentDocIdSetIt = null;
96         }
97         clearState();
98         return false;
99     }
100     private boolean belowMinScore(Scorer currentScorer) throws IOException {
101         return minScore != null &amp;&amp; currentScorer.score() &lt; minScore;
102     }
103     private boolean tryAdvanceDocIdSetIterator() throws IOException {
104         if (currentDocIdSetIt != null) {
105             return true;
106         }
107         while (leavesIt.hasNext()) {
108             LeafReaderContext leaf = leavesIt.next();
109             Scorer scorer = weight.scorer(leaf);
110             if (scorer == null) {
111                 continue;
112             }
113             currentScorer = scorer;
114             currentLeaf = leaf;
115             currentDocIdSetIt = scorer.iterator();
116             var readerContext = new ReaderContext(currentLeaf);
117             for (LuceneCollectorExpression&lt;?&gt; expression : expressions) {
118                 expression.setScorer(currentScorer);
119                 expression.setNextReader(readerContext);
120             }
121             return true;
122         }
123         return false;
124     }
125     private void clearState() {
126         currentDocIdSetIt = null;
127         currentScorer = null;
128         currentLeaf = null;
129     }
130     @Override
131     public void close() {
132         clearState();
133         killed = BatchIterator.CLOSED;
134     }
135 <a name="3"></a>    @Override
136     public CompletionStage&lt;?&gt; loadNextBatch() throws Exception {
137         throw new IllegalStateException("BatchIterator already fully loaded");
138     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
139     private Weight createWeight() throws IOException {
140         for (LuceneCollectorExpression&lt;?&gt; expression : expressions) {
141             expression.startCollect(collectorContext);
142         }</b></font>
143         ScoreMode scoreMode = doScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;
144         return indexSearcher.createWeight(indexSearcher.rewrite(query), scoreMode, 1f);
145     }
146     @Override
147     public boolean allLoaded() {
148         return true;
149     }
150     @Override
151     public boolean hasLazyResultSet() {
152         return true;
153 <a name="2"></a>    }
154     private static boolean docDeleted(@Nullable Bits liveDocs, int doc) {
155         if (liveDocs == null) <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
156             return false;
157         }
158         return liveDocs.get(doc) == false;
159     }
160     private void onDoc(int doc</b></font>) throws IOException {
161         for (LuceneCollectorExpression&lt;?&gt; expression : expressions) {
162             expression.setNextDocId(doc);
163         }
164     }
165     private void raiseIfKilled() {
166         if (killed != null) {
167             Exceptions.rethrowUnchecked(killed);
168         }
169     }
170     @Override
171     public void kill(@Nonnull Throwable throwable) {
172         killed = throwable;
173     }
174 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AnalyzedTableElements.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.analyze;
2 import io.crate.analyze.expressions.TableReferenceResolver;
3 import io.crate.common.annotations.VisibleForTesting;
4 import io.crate.exceptions.ColumnUnknownException;
5 import io.crate.expression.scalar.cast.CastFunctionResolver;
6 import io.crate.expression.symbol.RefVisitor;
7 import io.crate.expression.symbol.Symbol;
8 import io.crate.expression.symbol.SymbolVisitors;
9 import io.crate.expression.symbol.Symbols;
10 import io.crate.expression.symbol.format.Style;
11 import io.crate.metadata.ColumnIdent;
12 import io.crate.metadata.FulltextAnalyzerResolver;
13 import io.crate.metadata.GeneratedReference;
14 import io.crate.metadata.Reference;
15 import io.crate.metadata.ReferenceIdent;
16 import io.crate.metadata.RelationName;
17 import io.crate.metadata.RowGranularity;
18 import io.crate.sql.tree.CheckColumnConstraint;
19 import io.crate.sql.tree.CheckConstraint;
20 import io.crate.types.ArrayType;
21 import io.crate.types.DataType;
22 import io.crate.types.DataTypes;
23 import org.elasticsearch.common.UUIDs;
24 import org.elasticsearch.common.settings.Settings;
25 import</b></font> javax.annotation.Nullable;
26 import java.util.ArrayList;
27 import java.util.HashMap;
28 import java.util.HashSet;
29 import java.util.LinkedHashMap;
30 import java.util.LinkedHashSet;
31 import java.util.LinkedList;
32 import java.util.List;
33 import java.util.Locale;
34 import java.util.Map;
35 import java.util.Set;
36 import java.util.function.Consumer;
37 import java.util.function.Function;
38 public class AnalyzedTableElements&lt;T&gt; {
39     public List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; partitionedByColumns = new ArrayList&lt;&gt;();
40     private List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; columns = new ArrayList&lt;&gt;();
41     private Set&lt;ColumnIdent&gt; columnIdents = new HashSet&lt;&gt;();
42     private Map&lt;ColumnIdent, DataType&gt; columnTypes = new HashMap&lt;&gt;();
43     private Set&lt;String&gt; primaryKeys;
44     private Set&lt;String&gt; notNullColumns;
45     private Map&lt;String, String&gt; checkConstraints = new LinkedHashMap&lt;&gt;();
46     private List&lt;List&lt;String&gt;&gt; partitionedBy;
47     private int numGeneratedColumns = 0;
48     private List&lt;T&gt; additionalPrimaryKeys = new ArrayList&lt;&gt;();
49     private Map&lt;T, Set&lt;String&gt;&gt; copyToMap = new HashMap&lt;&gt;();
50 <a name="1"></a>    public AnalyzedTableElements() {
51     }
52     private AnalyzedTableElements(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; partitionedByColumns,
53                                   List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; columns,
54                                   Set&lt;ColumnIdent&gt; columnIdents,
55                                   Map&lt;ColumnIdent, DataType&gt; columnTypes,
56                                   Set&lt;String&gt; primaryKeys,
57                                   Set&lt;String&gt; notNullColumns,
58                                   Map&lt;String, String&gt; checkConstraints,
59                                   List&lt;List&lt;String&gt;&gt; partitionedBy,
60                                   int numGeneratedColumns,
61                                   List&lt;T&gt; additionalPrimaryKeys,
62                                   Map&lt;T, Set&lt;String&gt;&gt; copyToMap</b></font>) {
63         this.partitionedByColumns = partitionedByColumns;
64         this.columns = columns;
65         this.columnIdents = columnIdents;
66         this.columnTypes = columnTypes;
67         this.primaryKeys = primaryKeys;
68         this.notNullColumns = notNullColumns;
69         this.checkConstraints = checkConstraints;
70         this.partitionedBy = partitionedBy;
71         this.numGeneratedColumns = numGeneratedColumns;
72         this.additionalPrimaryKeys = additionalPrimaryKeys;
73         this.copyToMap = copyToMap;
74     }
75     static Map&lt;String, Object&gt; toMapping(AnalyzedTableElements&lt;Object&gt; elements) {
76         final Map&lt;String, Object&gt; mapping = new HashMap&lt;&gt;();
77         final Map&lt;String, Object&gt; meta = new HashMap&lt;&gt;();
78         final Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;(elements.columns.size());
79         Map&lt;String, String&gt; generatedColumns = new HashMap&lt;&gt;();
80         Map&lt;String, Object&gt; indicesMap = new HashMap&lt;&gt;();
81         for (AnalyzedColumnDefinition&lt;Object&gt; column : elements.columns) {
82             properties.put(column.name(), AnalyzedColumnDefinition.toMapping(column));
83             if (column.isIndexColumn()) {
84                 indicesMap.put(column.name(), column.toMetaIndicesMapping());
85             }
86             addToGeneratedColumns("", column, generatedColumns);
87         }
88         if (!elements.partitionedByColumns.isEmpty()) {
89             meta.put("partitioned_by", elements.partitionedBy());
90         }
91         if (!indicesMap.isEmpty()) {
92             meta.put("indices", indicesMap);
93         }
94         if (!primaryKeys(elements).isEmpty()) {
95             meta.put("primary_keys", primaryKeys(elements));
96         }
97         if (!generatedColumns.isEmpty()) {
98             meta.put("generated_columns", generatedColumns);
99         }
100         if (!notNullColumns(elements).isEmpty()) {
101             Map&lt;String, Object&gt; constraints = new HashMap&lt;&gt;();
102             constraints.put("not_null", notNullColumns(elements));
103             meta.put("constraints", constraints);
104         }
105         if (!elements.checkConstraints.isEmpty()) {
106             meta.put("check_constraints", elements.checkConstraints);
107         }
108         mapping.put("_meta", meta);
109         mapping.put("properties", properties);
110         return mapping;
111     }
112     private static void addToGeneratedColumns(String columnPrefix,
113                                               AnalyzedColumnDefinition&lt;Object&gt; column,
114                                               Map&lt;String, String&gt; generatedColumns) {
115         String generatedExpression = column.formattedGeneratedExpression();
116         if (generatedExpression != null) {
117             generatedColumns.put(columnPrefix + column.name(), generatedExpression);
118         }
119         for (AnalyzedColumnDefinition&lt;Object&gt; child : column.children()) {
120             addToGeneratedColumns(columnPrefix + column.name() + '.', child, generatedColumns);
121         }
122     }
123     public &lt;U&gt; AnalyzedTableElements&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
124         List&lt;U&gt; additionalPrimaryKeys = new ArrayList&lt;&gt;(this.additionalPrimaryKeys.size());
125         for (T p : this.additionalPrimaryKeys) {
126             additionalPrimaryKeys.add(mapper.apply(p));
127         }
128         Map&lt;U, Set&lt;String&gt;&gt; copyToMap = new HashMap&lt;&gt;(this.copyToMap.size());
129         for (Map.Entry&lt;T, Set&lt;String&gt;&gt; entry : this.copyToMap.entrySet()) {
130             copyToMap.put(mapper.apply(entry.getKey()), entry.getValue());
131         }
132         List&lt;AnalyzedColumnDefinition&lt;U&gt;&gt; partitionedByColumns = new ArrayList&lt;&gt;(this.partitionedByColumns.size());
133         for (AnalyzedColumnDefinition&lt;T&gt; d : this.partitionedByColumns) {
134             partitionedByColumns.add(d.map(mapper));
135         }
136         List&lt;AnalyzedColumnDefinition&lt;U&gt;&gt; columns = new ArrayList&lt;&gt;(this.columns.size());
137         for (AnalyzedColumnDefinition&lt;T&gt; d : this.columns) {
138             columns.add(d.map(mapper));
139         }
140         return new AnalyzedTableElements&lt;&gt;(
141             partitionedByColumns,
142             columns,
143             columnIdents,
144             columnTypes,
145             primaryKeys,
146             notNullColumns,
147             checkConstraints,
148             partitionedBy,
149             numGeneratedColumns,
150             additionalPrimaryKeys,
151             copyToMap
152         );
153     }
154     public List&lt;List&lt;String&gt;&gt; partitionedBy() {
155         if (partitionedBy == null) {
156             partitionedBy = new ArrayList&lt;&gt;(partitionedByColumns.size());
157             for (AnalyzedColumnDefinition&lt;T&gt; partitionedByColumn : partitionedByColumns) {
158                 partitionedBy.add(List.of(
159                     partitionedByColumn.ident().fqn(), partitionedByColumn.typeNameForESMapping()));
160             }
161 <a name="3"></a>        }
162         return partitionedBy;
163     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
164     private void expandColumnIdents() {
165         for (AnalyzedColumnDefinition&lt;T&gt; column : columns) {
166             expandColumn(column);
167         }</b></font>
168     }
169     private void expandColumn(AnalyzedColumnDefinition&lt;T&gt; column) {
170         if (column.isIndexColumn()) {
171             columnIdents.remove(column.ident());
172             return;
173         }
174         columnIdents.add(column.ident());
175         columnTypes.put(column.ident(), column.dataType());
176         for (AnalyzedColumnDefinition&lt;T&gt; child : column.children()) {
177             expandColumn(child);
178         }
179     }
180     static Set&lt;String&gt; notNullColumns(AnalyzedTableElements&lt;Object&gt; elements) {
181         if (elements.notNullColumns == null) {
182             elements.notNullColumns = new HashSet&lt;&gt;();
183             for (AnalyzedColumnDefinition&lt;Object&gt; column : elements.columns) {
184                 addNotNullFromChildren(column, elements);
185             }
186         }
187         return elements.notNullColumns;
188     }
189     private static void addNotNullFromChildren(AnalyzedColumnDefinition&lt;Object&gt; parentColumn, AnalyzedTableElements&lt;Object&gt; elements) {
190         LinkedList&lt;AnalyzedColumnDefinition&lt;Object&gt;&gt; childColumns = new LinkedList&lt;&gt;();
191         childColumns.add(parentColumn);
192         while (!childColumns.isEmpty()) {
193             AnalyzedColumnDefinition&lt;Object&gt; column = childColumns.remove();
194             String fqn = column.ident().fqn();
195             if (column.hasNotNullConstraint() &amp;&amp; !primaryKeys(elements).contains(fqn)) {                 elements.notNullColumns.add(fqn);
196             }
197             childColumns.addAll(column.children());
198         }
199     }
200     public static Set&lt;String&gt; primaryKeys(AnalyzedTableElements&lt;Object&gt; elements) {
201         if (elements.primaryKeys == null) {
202             elements.primaryKeys = new LinkedHashSet&lt;&gt;();             for (Object pk : elements.additionalPrimaryKeys) {
203                 String pkAsString = pk.toString();
204                 checkPrimaryKeyAlreadyDefined(elements.primaryKeys, pkAsString);
205                 elements.primaryKeys.add(pkAsString);
206             }
207             for (AnalyzedColumnDefinition&lt;Object&gt; column : elements.columns) {
208                 elements.addPrimaryKeys(elements.primaryKeys, column);
209             }
210         }
211         return elements.primaryKeys;
212     }
213     private void addPrimaryKeys(Set&lt;String&gt; primaryKeys, AnalyzedColumnDefinition&lt;T&gt; column) {
214         if (column.hasPrimaryKeyConstraint()) {
215             String fqn = column.ident().fqn();
216             checkPrimaryKeyAlreadyDefined(primaryKeys, fqn);
217             primaryKeys.add(fqn);
218         }
219         for (AnalyzedColumnDefinition&lt;T&gt; analyzedColumnDefinition : column.children()) {
220             addPrimaryKeys(primaryKeys, analyzedColumnDefinition);
221         }
222     }
223     private static void checkPrimaryKeyAlreadyDefined(Set&lt;String&gt; primaryKeys, String columnName) {
224         if (primaryKeys.contains(columnName)) {
225             throw new IllegalArgumentException(String.format(Locale.ENGLISH,
226                                                              "Column \"%s\" appears twice in primary key constraint", columnName));
227         }
228     }
229     void addPrimaryKey(T fqColumnName) {
230         additionalPrimaryKeys.add(fqColumnName);
231     }
232     public void add(AnalyzedColumnDefinition&lt;T&gt; analyzedColumnDefinition) {
233         if (columnIdents.contains(analyzedColumnDefinition.ident())) {
234             throw new IllegalArgumentException(String.format(Locale.ENGLISH,
235                                                              "column \"%s\" specified more than once", analyzedColumnDefinition.ident().sqlFqn()));
236         }
237         columnIdents.add(analyzedColumnDefinition.ident());
238         columns.add(analyzedColumnDefinition);
239         columnTypes.put(analyzedColumnDefinition.ident(), analyzedColumnDefinition.dataType());
240         if (analyzedColumnDefinition.isGenerated()) {
241             numGeneratedColumns++;
242         }
243     }
244     public static Settings validateAndBuildSettings(AnalyzedTableElements&lt;Object&gt; tableElementsEvaluated,
245                                                     FulltextAnalyzerResolver fulltextAnalyzerResolver) {
246         Settings.Builder builder = Settings.builder();
247         for (AnalyzedColumnDefinition&lt;Object&gt; column : tableElementsEvaluated.columns) {
248             AnalyzedColumnDefinition.applyAndValidateAnalyzerSettings(column, fulltextAnalyzerResolver);
249             builder.put(column.builtAnalyzerSettings());
250         }
251         return builder.build();
252     }
253     public static Map&lt;String, Object&gt; finalizeAndValidate(RelationName relationName,
254                                                           AnalyzedTableElements&lt;Symbol&gt; tableElementsWithExpressionSymbols,
255                                                           AnalyzedTableElements&lt;Object&gt; tableElementsEvaluated) {
256         tableElementsEvaluated.expandColumnIdents();
257         validateExpressions(tableElementsWithExpressionSymbols, tableElementsEvaluated);
258         for (AnalyzedColumnDefinition&lt;Object&gt; column : tableElementsEvaluated.columns) {
259             column.validate();
260             tableElementsEvaluated.addCopyToInfo(column);
261         }
262         validateIndexDefinitions(relationName, tableElementsEvaluated);
263         validatePrimaryKeys(relationName, tableElementsEvaluated);
264         return toMapping(tableElementsEvaluated);
265     }
266     private static void validateExpressions(AnalyzedTableElements&lt;Symbol&gt; tableElementsWithExpressionSymbols,
267                                             AnalyzedTableElements&lt;Object&gt; tableElementsEvaluated) {
268         for (int i = 0; i &lt; tableElementsWithExpressionSymbols.columns.size(); i++) {
269             processExpressions(
270                 tableElementsWithExpressionSymbols.columns.get(i),
271                 tableElementsEvaluated.columns.get(i)
272             );
273         }
274     }
275     public TableReferenceResolver referenceResolver(RelationName relationName) {
276         List&lt;Reference&gt; tableReferences = new ArrayList&lt;&gt;();
277         for (AnalyzedColumnDefinition&lt;T&gt; columnDefinition : columns) {
278             buildReference(relationName, columnDefinition, tableReferences);
279         }
280         return new TableReferenceResolver(tableReferences, relationName);
281     }
282     private static void processExpressions(AnalyzedColumnDefinition&lt;Symbol&gt; columnDefinitionWithExpressionSymbols,
283                                            AnalyzedColumnDefinition&lt;Object&gt; columnDefinitionEvaluated) {
284         Symbol generatedExpression = columnDefinitionWithExpressionSymbols.generatedExpression();
285         if (generatedExpression != null) {
286             validateAndFormatExpression(
287                 generatedExpression,
288                 columnDefinitionWithExpressionSymbols,
289                 columnDefinitionEvaluated,
290                 columnDefinitionEvaluated::formattedGeneratedExpression);
291         }
292         Symbol defaultExpression = columnDefinitionWithExpressionSymbols.defaultExpression();
293         if (defaultExpression != null) {
294             RefVisitor.visitRefs(defaultExpression, r -&gt; {
295                 throw new UnsupportedOperationException(
296                     "Columns cannot be used in this context. " +
297                     "Maybe you wanted to use a string literal which requires single quotes: '" + r.column().sqlFqn() + "'");
298             });
299             validateAndFormatExpression(
300                 defaultExpression,
301                 columnDefinitionWithExpressionSymbols,
302                 columnDefinitionEvaluated,
303                 columnDefinitionEvaluated::formattedDefaultExpression);
304         }
305         for (int i = 0; i &lt; columnDefinitionWithExpressionSymbols.children().size(); i++) {
306             processExpressions(
307                 columnDefinitionWithExpressionSymbols.children().get(i),
308                 columnDefinitionEvaluated.children().get(i)
309             );
310         }
311     }
312     private static void validateAndFormatExpression(Symbol function,
313                                                     AnalyzedColumnDefinition&lt;Symbol&gt; columnDefinitionWithExpressionSymbols,
314                                                     AnalyzedColumnDefinition&lt;Object&gt; columnDefinitionEvaluated,
315                                                     Consumer&lt;String&gt; formattedExpressionConsumer) {
316         String formattedExpression;
317         DataType&lt;?&gt; valueType = function.valueType();
318         DataType&lt;?&gt; definedType = columnDefinitionWithExpressionSymbols.dataType();
319         if (SymbolVisitors.any(Symbols::isAggregate, function)) {
320             throw new UnsupportedOperationException("Aggregation functions are not allowed in generated columns: " + function);
321         }
322         if (definedType != null &amp;&amp; !definedType.equals(valueType)) {
323             final DataType&lt;?&gt; columnDataType;
324             if (ArrayType.NAME.equals(columnDefinitionWithExpressionSymbols.collectionType())) {
325                 columnDataType = new ArrayType&lt;&gt;(definedType);
326             } else {
327                 columnDataType = definedType;
328             }
329             if (!valueType.isConvertableTo(columnDataType, false)) {
330                 throw new IllegalArgumentException(String.format(Locale.ENGLISH,
331                     "expression value type '%s' not supported for conversion to '%s'",
332                     valueType, columnDataType.getName())
333                 );
334             }
335             Symbol castFunction = CastFunctionResolver.generateCastFunction(function, columnDataType);
336             formattedExpression = castFunction.toString(Style.UNQUALIFIED);
337         } else {
338             if (valueType instanceof ArrayType) {
339                 columnDefinitionEvaluated.collectionType(ArrayType.NAME);
340                 columnDefinitionEvaluated.dataType(ArrayType.unnest(valueType).getName());
341             } else {
342                 columnDefinitionEvaluated.dataType(valueType.getName());
343             }
344             formattedExpression = function.toString(Style.UNQUALIFIED);
345         }
346         formattedExpressionConsumer.accept(formattedExpression);
347     }
348     private static &lt;T&gt; void buildReference(RelationName relationName,
349                                            AnalyzedColumnDefinition&lt;T&gt; columnDefinition,
350                                            List&lt;Reference&gt; references) {
351         Reference reference;
352         DataType&lt;?&gt; type = columnDefinition.dataType() == null ? DataTypes.UNDEFINED : columnDefinition.dataType();
353         DataType&lt;?&gt; realType = ArrayType.NAME.equals(columnDefinition.collectionType())
354             ? new ArrayType&lt;&gt;(type)
355             : type;
356         if (columnDefinition.isGenerated() == false) {
357             reference = new Reference(
358                 new ReferenceIdent(relationName, columnDefinition.ident()),
359                 RowGranularity.DOC,
360                 realType,
361                 columnDefinition.position,
362                 null             );
363         } else {
364             reference = new GeneratedReference(
365                 columnDefinition.position,
366                 new ReferenceIdent(relationName, columnDefinition.ident()),
367                 RowGranularity.DOC,
368                 realType,
369                 "dummy expression, real one not needed here");
370         }
371         references.add(reference);
372         for (AnalyzedColumnDefinition&lt;T&gt; childDefinition : columnDefinition.children()) {
373             buildReference(relationName, childDefinition, references);
374         }
375     }
376     private void addCopyToInfo(AnalyzedColumnDefinition&lt;T&gt; column) {
377         if (!column.isIndexColumn()) {
378             Set&lt;String&gt; targets = copyToMap.get(column.ident().fqn());
379             if (targets != null) {
380                 column.addCopyTo(targets);
381             }
382         }
383         for (AnalyzedColumnDefinition&lt;T&gt; child : column.children()) {
384             addCopyToInfo(child);
385         }
386     }
387     private static void validatePrimaryKeys(RelationName relationName, AnalyzedTableElements&lt;Object&gt; elements) {
388         for (Object additionalPrimaryKey : elements.additionalPrimaryKeys) {
389             ColumnIdent columnIdent = ColumnIdent.fromPath(additionalPrimaryKey.toString());
390             if (!elements.columnIdents.contains(columnIdent)) {
391                 throw new ColumnUnknownException(columnIdent.sqlFqn(), relationName);
392             }
393         }
394         primaryKeys(elements);
395     }
396     private static void validateIndexDefinitions(RelationName relationName, AnalyzedTableElements&lt;Object&gt; tableElements) {
397         for (Map.Entry&lt;Object, Set&lt;String&gt;&gt; entry : tableElements.copyToMap.entrySet()) {
398             ColumnIdent columnIdent = ColumnIdent.fromPath(entry.getKey().toString());
399             if (!tableElements.columnIdents.contains(columnIdent)) {
400                 throw new ColumnUnknownException(columnIdent.sqlFqn(), relationName);
401             }
402             if (!DataTypes.STRING.equals(tableElements.columnTypes.get(columnIdent))) {
403                 throw new IllegalArgumentException("INDEX definition only support 'string' typed source columns");
404             }
405         }
406     }
407     void addCopyTo(T sourceColumn, String targetIndex) {
408         Set&lt;String&gt; targetColumns = copyToMap.get(sourceColumn);
409         if (targetColumns == null) {
410             targetColumns = new HashSet&lt;&gt;();
411             copyToMap.put(sourceColumn, targetColumns);
412         }
413         targetColumns.add(targetIndex);
414     }
415     public Set&lt;ColumnIdent&gt; columnIdents() {
416         return columnIdents;
417     }
418     @Nullable
419     private static AnalyzedColumnDefinition&lt;Object&gt; columnDefinitionByIdent(AnalyzedTableElements&lt;Object&gt; elements, ColumnIdent ident) {
420         AnalyzedColumnDefinition&lt;Object&gt; result = null;
421         ColumnIdent root = ident.getRoot();
422         for (AnalyzedColumnDefinition&lt;Object&gt; column : elements.columns) {
423             if (column.ident().equals(root)) {
424                 result = column;
425                 break;
426             }
427         }
428         if (result == null) {
429 <a name="2"></a>            return null;
430         }
431         if (result.ident().equals(ident)) <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
432             return result;
433         }
434         return findInChildren(result, ident);
435     }
436     private static AnalyzedColumnDefinition&lt;Object&gt; findInChildren(AnalyzedColumnDefinition&lt;Object&gt; column</b></font>,
437                                                                    ColumnIdent ident) {
438         AnalyzedColumnDefinition&lt;Object&gt; result = null;
439         for (AnalyzedColumnDefinition&lt;Object&gt; child : column.children()) {
440             if (child.ident().equals(ident)) {
441                 result = child;
442                 break;
443             }
444             AnalyzedColumnDefinition&lt;Object&gt; inChildren = findInChildren(child, ident);
445             if (inChildren != null) {
446                 return inChildren;
447             }
448         }
449         return result;
450     }
451     public static void changeToPartitionedByColumn(AnalyzedTableElements&lt;Object&gt; elements,
452                                                    ColumnIdent partitionedByIdent,
453                                                    boolean skipIfNotFound,
454                                                    RelationName relationName) {
455         if (partitionedByIdent.name().startsWith("_")) {
456             throw new IllegalArgumentException("Cannot use system columns in PARTITIONED BY clause");
457         }
458         if (!primaryKeys(elements).isEmpty() &amp;&amp; !primaryKeys(elements).contains(partitionedByIdent.fqn())) {
459             throw new IllegalArgumentException(String.format(Locale.ENGLISH,
460                                                              "Cannot use non primary key column '%s' in PARTITIONED BY clause if primary key is set on table",
461                                                              partitionedByIdent.sqlFqn()));
462         }
463         AnalyzedColumnDefinition&lt;Object&gt; columnDefinition = columnDefinitionByIdent(elements, partitionedByIdent);
464         if (columnDefinition == null) {
465             if (skipIfNotFound) {
466                 return;
467             }
468             throw new ColumnUnknownException(partitionedByIdent.sqlFqn(), relationName);
469         }
470         DataType&lt;?&gt; columnType = columnDefinition.dataType();
471         if (!DataTypes.isPrimitive(columnType)) {
472             throw new IllegalArgumentException(String.format(Locale.ENGLISH,
473                                                              "Cannot use column %s of type %s in PARTITIONED BY clause",
474                                                              columnDefinition.ident().sqlFqn(), columnDefinition.dataType()));
475         }
476         if (columnDefinition.isArrayOrInArray()) {
477             throw new IllegalArgumentException(String.format(Locale.ENGLISH,
478                                                              "Cannot use array column %s in PARTITIONED BY clause", columnDefinition.ident().sqlFqn()));
479         }
480         if (columnDefinition.indexConstraint() == Reference.IndexType.FULLTEXT) {
481             throw new IllegalArgumentException(String.format(Locale.ENGLISH,
482                                                              "Cannot use column %s with fulltext index in PARTITIONED BY clause",
483                                                              columnDefinition.ident().sqlFqn()));
484         }
485         elements.columnIdents.remove(columnDefinition.ident());
486         columnDefinition.indexConstraint(Reference.IndexType.NONE);
487         elements.partitionedByColumns.add(columnDefinition);
488     }
489     public List&lt;AnalyzedColumnDefinition&lt;T&gt;&gt; columns() {
490         return columns;
491     }
492     private void addCheckConstraint(String fqRelationName,
493                                     @Nullable String columnName,
494                                     @Nullable String name,
495                                     String expressionStr) {
496         String uniqueName = name;
497         if (uniqueName == null) {
498             uniqueName = uniqueCheckConstraintName(fqRelationName, columnName);
499         }
500         if (checkConstraints.put(uniqueName, expressionStr) != null) {
501             throw new IllegalArgumentException(String.format(
502                 Locale.ENGLISH, "a check constraint of the same name is already declared [%s]", uniqueName));
503         }
504     }
505     private static String uniqueCheckConstraintName(String fqTableName, @Nullable String columnName) {
506         StringBuilder sb = new StringBuilder(fqTableName.replaceAll("\\.", "_"));
507         if (columnName != null) {
508             sb.append("_").append(columnName);
509         }
510         sb.append("_check_");
511         String uuid = UUIDs.dirtyUUID().toString();
512         int idx = uuid.lastIndexOf("-");
513         sb.append(idx &gt; 0 ? uuid.substring(idx + 1) : uuid);
514         return sb.toString();
515     }
516     public void addCheckConstraint(RelationName relationName, CheckConstraint&lt;?&gt; check) {
517         addCheckConstraint(relationName.fqn(), check.columnName(), check.name(), check.expressionStr());
518     }
519     public void addCheckColumnConstraint(RelationName relationName, CheckColumnConstraint&lt;?&gt; check) {
520         addCheckConstraint(relationName.fqn(), check.columnName(), check.name(), check.expressionStr());
521     }
522     @VisibleForTesting
523     Map&lt;String, String&gt; getCheckConstraints() {
524         return Map.copyOf(checkConstraints);
525     }
526     public boolean hasGeneratedColumns() {
527         return numGeneratedColumns &gt; 0;
528     }
529 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
