
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 51, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ListenerTest.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty.http;
2  import com.google.common.collect.Lists;
3  import com.google.mockwebserver.MockResponse;
4  import com.google.mockwebserver.MockWebServer;
5  import com.netflix.client.ClientException;
6  import com.netflix.client.config.CommonClientConfigKey;
7  import com.netflix.client.config.DefaultClientConfigImpl;
8  import com.netflix.client.config.IClientConfig;
9  import com.netflix.config.ConfigurationManager;
10  import com.netflix.loadbalancer.AvailabilityFilteringRule;
11  import com.netflix.loadbalancer.BaseLoadBalancer;
12  import com.netflix.loadbalancer.DummyPing;
13  import com.netflix.loadbalancer.LoadBalancerBuilder;
14  import com.netflix.loadbalancer.Server;
15  import com.netflix.loadbalancer.reactive.ExecutionContext;
16  import com.netflix.loadbalancer.reactive.ExecutionInfo;
17  import com.netflix.loadbalancer.reactive.ExecutionListener;
18  import com.netflix.loadbalancer.reactive.ExecutionListener.AbortExecutionException;
19  import com.netflix.ribbon.transport.netty.RibbonTransport;
20  import io.netty.buffer.ByteBuf;
21  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
22  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
23  import org.junit.Ignore;
24  import org.junit.Test;
25  import rx.functions.Action1;
26  import java.io.IOException;
27  import java.util.Arrays;
28  import java.util.List;
29  import java.util.concurrent.CountDownLatch;
30  import java.util.concurrent.TimeUnit;
31  import java.util.concurrent.atomic.AtomicReference;
32  import static org.junit.Assert.*;
33  public class ListenerTest {
34      @Test
35      public void testFailedExecution() {
36          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues()
37                  .withProperty(CommonClientConfigKey.ConnectTimeout, &quot;100&quot;)
38                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
39                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
40          System.out.println(config);
41          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
42          Server badServer  = new Server(&quot;localhost:12345&quot;);
43          Server badServer2 = new Server(&quot;localhost:34567&quot;);
44          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer2);
45          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
46                  .withRule(new AvailabilityFilteringRule())
47                  .withPing(new DummyPing())
48                  .buildFixedServerListLoadBalancer(servers);
49          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
50          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;ByteBuf, ByteBuf&gt;(request, overrideConfig);
51          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
52          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
53          try {
54              client.submit(request, null, overrideConfig).toBlocking().last();
55              fail(&quot;Exception expected&quot;);
56          } catch(Exception e) {
57              assertNotNull(e);
58          }
59          assertEquals(1, listener.executionStartCounter.get());
60          assertEquals(4, listener.startWithServerCounter.get());
61          assertEquals(4, listener.exceptionWithServerCounter.get());
62          assertEquals(1, listener.executionFailedCounter.get());
63          assertTrue(listener.isContextChecked());
64          assertTrue(listener.isCheckExecutionInfo());
65          assertNotNull(listener.getFinalThrowable());
66          listener.getFinalThrowable().printStackTrace();
67          assertTrue(listener.getFinalThrowable() instanceof ClientException);
68          assertEquals(100, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
69      }
70      @Test
71      public void testFailedExecutionForAbsoluteURI() {
72          IClientConfig config = DefaultClientConfigImpl
73                  .getClientConfigWithDefaultValues()
74                  .withProperty(CommonClientConfigKey.ConnectTimeout, &quot;100&quot;)
75                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
76                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
77          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;http:&amp;bsol;&amp;bsol;xyz.unknowhost.xyz/testAsync/person&quot;);
78          Server badServer = new Server(&quot;localhost:12345&quot;);
79          Server badServer2 = new Server(&quot;localhost:34567&quot;);
80          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer2);
81          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
82                  .withRule(new AvailabilityFilteringRule())
83                  .withPing(new DummyPing())
84                  .buildFixedServerListLoadBalancer(servers);
85          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
86          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;ByteBuf, ByteBuf&gt;(request, overrideConfig);
87          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
88          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
89          try {
90              client.submit(request, null, overrideConfig).toBlocking().last();
91              fail(&quot;Exception expected&quot;);
92          } catch(Exception e) {
93              assertNotNull(e);
94          }
95          assertEquals(1, listener.executionStartCounter.get());
96          assertEquals(2, listener.startWithServerCounter.get());
97          assertEquals(2, listener.exceptionWithServerCounter.get());
98          assertEquals(1, listener.executionFailedCounter.get());
99          assertTrue(listener.isContextChecked());
100          assertTrue(listener.isCheckExecutionInfo());
101          assertTrue(listener.getFinalThrowable() instanceof ClientException);
102      }
103      @Test
104      public void testSuccessExecution() throws IOException {
105          MockWebServer server = new MockWebServer();
106          String content = &quot;OK&quot;;
107          server.enqueue(new MockResponse()
108                  .setResponseCode(200)
109                  .setHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
110                  .setBody(content));
111          server.play();
112          IClientConfig config = DefaultClientConfigImpl
113                  .getClientConfigWithDefaultValues()
114                  .withProperty(CommonClientConfigKey.ConnectTimeout, &quot;2000&quot;)
115                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
116                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
117          System.out.println(config);
118          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
119          Server badServer  = new Server(&quot;localhost:12345&quot;);
120          Server goodServer = new Server(&quot;localhost:&quot; + server.getPort());
121          List&lt;Server&gt; servers = Lists.newArrayList(goodServer, badServer);
122          BaseLoadBalancer lb = LoadBalancerBuilder.newBuilder()
123                  .withRule(new AvailabilityFilteringRule())
124                  .withPing(new DummyPing())
125                  .buildFixedServerListLoadBalancer(servers);
126          IClientConfig overrideConfig = DefaultClientConfigImpl
127                  .getEmptyConfig()
128                  .set(CommonClientConfigKey.ConnectTimeout, 500);
129          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;&gt;(request, overrideConfig);
130          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.newArrayList(listener);
131          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
132          HttpClientResponse&lt;ByteBuf&gt; response = client.submit(request, null, overrideConfig).toBlocking().last();
133          System.out.println(listener);
134          assertEquals(200, response.getStatus().code());
135          assertEquals(1, listener.executionStartCounter.get());
136          assertEquals(3, listener.startWithServerCounter.get());
137          assertEquals(2, listener.exceptionWithServerCounter.get());
138          assertEquals(0, listener.executionFailedCounter.get());
139          assertEquals(1, listener.executionSuccessCounter.get());
140          assertEquals(500, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
141          assertTrue(listener.isContextChecked());
142          assertTrue(listener.isCheckExecutionInfo());
143          assertSame(response, listener.getResponse());
144      }
145      @Test
146      public void testSuccessExecutionOnAbosoluteURI() throws IOException {
147          MockWebServer server = new MockWebServer();
148          String content = &quot;OK&quot;;
149          server.enqueue(new MockResponse().setResponseCode(200).setHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
150                  .setBody(content));
151          server.play();
152          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;2000&quot;)
153                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
154                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
155          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;http:&amp;bsol;&amp;bsol;localhost:&quot; + server.getPort() + &quot;/testAsync/person&quot;);
156          Server badServer = new Server(&quot;localhost:12345&quot;);
157          Server goodServer = new Server(&quot;localhost:&quot; + server.getPort());
158          List&lt;Server&gt; servers = Lists.newArrayList(goodServer, badServer);
159          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
160                  .withRule(new AvailabilityFilteringRule())
161                  .withPing(new DummyPing())
162                  .buildFixedServerListLoadBalancer(servers);
163          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig().set(CommonClientConfigKey.ConnectTimeout, 500);
164          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;ByteBuf, ByteBuf&gt;(request, overrideConfig);
165          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
166          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
167          HttpClientResponse&lt;ByteBuf&gt; response = client.submit(request, null, overrideConfig).toBlocking().last();
168          assertEquals(200, response.getStatus().code());
169          assertEquals(1, listener.executionStartCounter.get());
170          assertEquals(1, listener.startWithServerCounter.get());
171          assertEquals(0, listener.exceptionWithServerCounter.get());
172          assertEquals(0, listener.executionFailedCounter.get());
173          assertEquals(1, listener.executionSuccessCounter.get());
174          assertEquals(500, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
175          assertTrue(listener.isContextChecked());
176          assertTrue(listener.isCheckExecutionInfo());
177          assertSame(response, listener.getResponse());
178      }
179      @Test
180      public void testAbortedExecution() {
181          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;100&quot;)
182                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
183                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
184          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
185          Server badServer = new Server(&quot;localhost:12345&quot;);
186          Server badServer2 = new Server(&quot;localhost:34567&quot;);
187          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer2);
188          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
189                  .withRule(new AvailabilityFilteringRule())
190                  .withPing(new DummyPing())
191                  .buildFixedServerListLoadBalancer(servers);
192          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
193          TestExecutionListener listener = new TestExecutionListener(request, overrideConfig) {
194              @Override
195              public void onExecutionStart(ExecutionContext context) {
196                  throw new AbortExecutionException(&quot;exit now&quot;);
197              }
198          };
199          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
200          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
201          final CountDownLatch latch = new CountDownLatch(1);
202          final AtomicReference&lt;Throwable&gt; ref = new AtomicReference&lt;Throwable&gt;();
203          client.submit(request, null, overrideConfig).subscribe(new Action1&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;() {
204              @Override
205              public void call(HttpClientResponse&lt;ByteBuf&gt; byteBufHttpClientResponse) {
206              }
207          }, new Action1&lt;Throwable&gt;() {
208              @Override
209              public void call(Throwable throwable) {
210                  ref.set(throwable);
<span onclick='openModal()' class='match'>211                  latch.countDown();
212              }
213          });
214          try {
215              latch.await(500, TimeUnit.MILLISECONDS);
216          } catch (InterruptedException e) {
217              e.printStackTrace();
218          }
219          assertTrue(ref.get() instanceof AbortExecutionException);
220      }
221      @Test
222      public void testAbortedExecutionOnServer() {
</span>223          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;100&quot;)
224                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
225                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
226          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
227          Server badServer = new Server(&quot;localhost:12345&quot;);
228          Server badServer2 = new Server(&quot;localhost:34567&quot;);
229          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer2);
230          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
231                  .withRule(new AvailabilityFilteringRule())
232                  .withPing(new DummyPing())
233                  .buildFixedServerListLoadBalancer(servers);
234          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
235          TestExecutionListener listener = new TestExecutionListener(request, overrideConfig) {
236              @Override
237              public void onStartWithServer(ExecutionContext context, ExecutionInfo info) {
238                  throw new AbortExecutionException(&quot;exit now&quot;);
239              }
240          };
241          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
242          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
243          final CountDownLatch latch = new CountDownLatch(1);
244          final AtomicReference&lt;Throwable&gt; ref = new AtomicReference&lt;Throwable&gt;();
245          client.submit(request, null, overrideConfig).subscribe(new Action1&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;() {
246              @Override
247              public void call(HttpClientResponse&lt;ByteBuf&gt; byteBufHttpClientResponse) {
248              }
249          }, new Action1&lt;Throwable&gt;() {
250              @Override
251              public void call(Throwable throwable) {
252                  ref.set(throwable);
253                  latch.countDown();
254              }
255          });
256          try {
257              latch.await(500, TimeUnit.MILLISECONDS);
258          } catch (InterruptedException e) {
259              e.printStackTrace();
260          }
261          assertTrue(ref.get() instanceof AbortExecutionException);
262      }
263      @Test
264      public void testDisabledListener() throws Exception {
265          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues(&quot;myClient&quot;).withProperty(CommonClientConfigKey.ConnectTimeout, &quot;2000&quot;)
266                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
267                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
268          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
269          Server badServer = new Server(&quot;localhost:12345&quot;);
270          List&lt;Server&gt; servers = Lists.newArrayList(badServer);
271          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
272                  .withRule(new AvailabilityFilteringRule())
273                  .withPing(new DummyPing())
274                  .buildFixedServerListLoadBalancer(servers);
275          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig().set(CommonClientConfigKey.ConnectTimeout, 500);
276          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;ByteBuf, ByteBuf&gt;(request, overrideConfig);
277          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
278          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
279          ConfigurationManager.getConfigInstance().setProperty(&quot;ribbon.listener.&quot; + TestExecutionListener.class.getName() + &quot;.disabled&quot;, &quot;true&quot;);
280          try {
281              client.submit(request, null, overrideConfig).toBlocking().last();
282          } catch (Exception e) {
283              assertNotNull(e);
284          }
285          assertEquals(0, listener.executionStartCounter.get());
286          assertEquals(0, listener.startWithServerCounter.get());
287          assertEquals(0, listener.exceptionWithServerCounter.get());
288          assertEquals(0, listener.executionFailedCounter.get());
289          assertEquals(0, listener.executionSuccessCounter.get());
290          try {
291              client.submit(request, null, overrideConfig).toBlocking().last();
292          } catch (Exception e) {
293              assertNotNull(e);
294          }
295          assertEquals(0, listener.executionStartCounter.get());
296          assertEquals(0, listener.startWithServerCounter.get());
297          assertEquals(0, listener.exceptionWithServerCounter.get());
298          assertEquals(0, listener.executionFailedCounter.get());
299          assertEquals(0, listener.executionSuccessCounter.get());
300      }
301  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ListenerTest.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty.http;
2  import com.google.common.collect.Lists;
3  import com.google.mockwebserver.MockResponse;
4  import com.google.mockwebserver.MockWebServer;
5  import com.netflix.client.ClientException;
6  import com.netflix.client.config.CommonClientConfigKey;
7  import com.netflix.client.config.DefaultClientConfigImpl;
8  import com.netflix.client.config.IClientConfig;
9  import com.netflix.config.ConfigurationManager;
10  import com.netflix.loadbalancer.AvailabilityFilteringRule;
11  import com.netflix.loadbalancer.BaseLoadBalancer;
12  import com.netflix.loadbalancer.DummyPing;
13  import com.netflix.loadbalancer.LoadBalancerBuilder;
14  import com.netflix.loadbalancer.Server;
15  import com.netflix.loadbalancer.reactive.ExecutionContext;
16  import com.netflix.loadbalancer.reactive.ExecutionInfo;
17  import com.netflix.loadbalancer.reactive.ExecutionListener;
18  import com.netflix.loadbalancer.reactive.ExecutionListener.AbortExecutionException;
19  import com.netflix.ribbon.transport.netty.RibbonTransport;
20  import io.netty.buffer.ByteBuf;
21  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
22  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
23  import org.junit.Ignore;
24  import org.junit.Test;
25  import rx.functions.Action1;
26  import java.io.IOException;
27  import java.util.Arrays;
28  import java.util.List;
29  import java.util.concurrent.CountDownLatch;
30  import java.util.concurrent.TimeUnit;
31  import java.util.concurrent.atomic.AtomicReference;
32  import static org.junit.Assert.*;
33  public class ListenerTest {
34      @Test
35      public void testFailedExecution() {
36          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues()
37                  .withProperty(CommonClientConfigKey.ConnectTimeout, &quot;100&quot;)
38                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
39                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
40          System.out.println(config);
41          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
42          Server badServer  = new Server(&quot;localhost:12345&quot;);
43          Server badServer2 = new Server(&quot;localhost:34567&quot;);
44          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer2);
45          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
46                  .withRule(new AvailabilityFilteringRule())
47                  .withPing(new DummyPing())
48                  .buildFixedServerListLoadBalancer(servers);
49          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
50          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;ByteBuf, ByteBuf&gt;(request, overrideConfig);
51          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
52          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
53          try {
54              client.submit(request, null, overrideConfig).toBlocking().last();
55              fail(&quot;Exception expected&quot;);
56          } catch(Exception e) {
57              assertNotNull(e);
58          }
59          assertEquals(1, listener.executionStartCounter.get());
60          assertEquals(4, listener.startWithServerCounter.get());
61          assertEquals(4, listener.exceptionWithServerCounter.get());
62          assertEquals(1, listener.executionFailedCounter.get());
63          assertTrue(listener.isContextChecked());
64          assertTrue(listener.isCheckExecutionInfo());
65          assertNotNull(listener.getFinalThrowable());
66          listener.getFinalThrowable().printStackTrace();
67          assertTrue(listener.getFinalThrowable() instanceof ClientException);
68          assertEquals(100, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
69      }
70      @Test
71      public void testFailedExecutionForAbsoluteURI() {
72          IClientConfig config = DefaultClientConfigImpl
73                  .getClientConfigWithDefaultValues()
74                  .withProperty(CommonClientConfigKey.ConnectTimeout, &quot;100&quot;)
75                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
76                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
77          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;http:&amp;bsol;&amp;bsol;xyz.unknowhost.xyz/testAsync/person&quot;);
78          Server badServer = new Server(&quot;localhost:12345&quot;);
79          Server badServer2 = new Server(&quot;localhost:34567&quot;);
80          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer2);
81          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
82                  .withRule(new AvailabilityFilteringRule())
83                  .withPing(new DummyPing())
84                  .buildFixedServerListLoadBalancer(servers);
85          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
86          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;ByteBuf, ByteBuf&gt;(request, overrideConfig);
87          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
88          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
89          try {
90              client.submit(request, null, overrideConfig).toBlocking().last();
91              fail(&quot;Exception expected&quot;);
92          } catch(Exception e) {
93              assertNotNull(e);
94          }
95          assertEquals(1, listener.executionStartCounter.get());
96          assertEquals(2, listener.startWithServerCounter.get());
97          assertEquals(2, listener.exceptionWithServerCounter.get());
98          assertEquals(1, listener.executionFailedCounter.get());
99          assertTrue(listener.isContextChecked());
100          assertTrue(listener.isCheckExecutionInfo());
101          assertTrue(listener.getFinalThrowable() instanceof ClientException);
102      }
103      @Test
104      public void testSuccessExecution() throws IOException {
105          MockWebServer server = new MockWebServer();
106          String content = &quot;OK&quot;;
107          server.enqueue(new MockResponse()
108                  .setResponseCode(200)
109                  .setHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
110                  .setBody(content));
111          server.play();
112          IClientConfig config = DefaultClientConfigImpl
113                  .getClientConfigWithDefaultValues()
114                  .withProperty(CommonClientConfigKey.ConnectTimeout, &quot;2000&quot;)
115                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
116                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
117          System.out.println(config);
118          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
119          Server badServer  = new Server(&quot;localhost:12345&quot;);
120          Server goodServer = new Server(&quot;localhost:&quot; + server.getPort());
121          List&lt;Server&gt; servers = Lists.newArrayList(goodServer, badServer);
122          BaseLoadBalancer lb = LoadBalancerBuilder.newBuilder()
123                  .withRule(new AvailabilityFilteringRule())
124                  .withPing(new DummyPing())
125                  .buildFixedServerListLoadBalancer(servers);
126          IClientConfig overrideConfig = DefaultClientConfigImpl
127                  .getEmptyConfig()
128                  .set(CommonClientConfigKey.ConnectTimeout, 500);
129          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;&gt;(request, overrideConfig);
130          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.newArrayList(listener);
131          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
132          HttpClientResponse&lt;ByteBuf&gt; response = client.submit(request, null, overrideConfig).toBlocking().last();
133          System.out.println(listener);
134          assertEquals(200, response.getStatus().code());
135          assertEquals(1, listener.executionStartCounter.get());
136          assertEquals(3, listener.startWithServerCounter.get());
137          assertEquals(2, listener.exceptionWithServerCounter.get());
138          assertEquals(0, listener.executionFailedCounter.get());
139          assertEquals(1, listener.executionSuccessCounter.get());
140          assertEquals(500, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
141          assertTrue(listener.isContextChecked());
142          assertTrue(listener.isCheckExecutionInfo());
143          assertSame(response, listener.getResponse());
144      }
145      @Test
146      public void testSuccessExecutionOnAbosoluteURI() throws IOException {
147          MockWebServer server = new MockWebServer();
148          String content = &quot;OK&quot;;
149          server.enqueue(new MockResponse().setResponseCode(200).setHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
150                  .setBody(content));
151          server.play();
152          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;2000&quot;)
153                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
154                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
155          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;http:&amp;bsol;&amp;bsol;localhost:&quot; + server.getPort() + &quot;/testAsync/person&quot;);
156          Server badServer = new Server(&quot;localhost:12345&quot;);
157          Server goodServer = new Server(&quot;localhost:&quot; + server.getPort());
158          List&lt;Server&gt; servers = Lists.newArrayList(goodServer, badServer);
159          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
160                  .withRule(new AvailabilityFilteringRule())
161                  .withPing(new DummyPing())
162                  .buildFixedServerListLoadBalancer(servers);
163          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig().set(CommonClientConfigKey.ConnectTimeout, 500);
164          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;ByteBuf, ByteBuf&gt;(request, overrideConfig);
165          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
166          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
167          HttpClientResponse&lt;ByteBuf&gt; response = client.submit(request, null, overrideConfig).toBlocking().last();
168          assertEquals(200, response.getStatus().code());
169          assertEquals(1, listener.executionStartCounter.get());
170          assertEquals(1, listener.startWithServerCounter.get());
171          assertEquals(0, listener.exceptionWithServerCounter.get());
172          assertEquals(0, listener.executionFailedCounter.get());
173          assertEquals(1, listener.executionSuccessCounter.get());
174          assertEquals(500, listener.getContext().getClientProperty(CommonClientConfigKey.ConnectTimeout).intValue());
175          assertTrue(listener.isContextChecked());
176          assertTrue(listener.isCheckExecutionInfo());
177          assertSame(response, listener.getResponse());
178      }
179      @Test
180      public void testAbortedExecution() {
181          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;100&quot;)
182                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
183                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
184          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
185          Server badServer = new Server(&quot;localhost:12345&quot;);
186          Server badServer2 = new Server(&quot;localhost:34567&quot;);
187          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer2);
188          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
189                  .withRule(new AvailabilityFilteringRule())
190                  .withPing(new DummyPing())
191                  .buildFixedServerListLoadBalancer(servers);
192          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
193          TestExecutionListener listener = new TestExecutionListener(request, overrideConfig) {
194              @Override
195              public void onExecutionStart(ExecutionContext context) {
196                  throw new AbortExecutionException(&quot;exit now&quot;);
197              }
198          };
199          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
200          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
201          final CountDownLatch latch = new CountDownLatch(1);
202          final AtomicReference&lt;Throwable&gt; ref = new AtomicReference&lt;Throwable&gt;();
203          client.submit(request, null, overrideConfig).subscribe(new Action1&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;() {
204              @Override
205              public void call(HttpClientResponse&lt;ByteBuf&gt; byteBufHttpClientResponse) {
206              }
207          }, new Action1&lt;Throwable&gt;() {
208              @Override
209              public void call(Throwable throwable) {
210                  ref.set(throwable);
211                  latch.countDown();
212              }
213          });
214          try {
215              latch.await(500, TimeUnit.MILLISECONDS);
216          } catch (InterruptedException e) {
217              e.printStackTrace();
218          }
219          assertTrue(ref.get() instanceof AbortExecutionException);
220      }
221      @Test
222      public void testAbortedExecutionOnServer() {
223          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;100&quot;)
224                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
225                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
226          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
227          Server badServer = new Server(&quot;localhost:12345&quot;);
228          Server badServer2 = new Server(&quot;localhost:34567&quot;);
229          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer2);
230          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
231                  .withRule(new AvailabilityFilteringRule())
232                  .withPing(new DummyPing())
233                  .buildFixedServerListLoadBalancer(servers);
234          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig();
235          TestExecutionListener listener = new TestExecutionListener(request, overrideConfig) {
236              @Override
237              public void onStartWithServer(ExecutionContext context, ExecutionInfo info) {
238                  throw new AbortExecutionException(&quot;exit now&quot;);
239              }
240          };
241          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
242          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
243          final CountDownLatch latch = new CountDownLatch(1);
244          final AtomicReference&lt;Throwable&gt; ref = new AtomicReference&lt;Throwable&gt;();
245          client.submit(request, null, overrideConfig).subscribe(new Action1&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;() {
246              @Override
247              public void call(HttpClientResponse&lt;ByteBuf&gt; byteBufHttpClientResponse) {
248              }
249          }, new Action1&lt;Throwable&gt;() {
250              @Override
251              public void call(Throwable throwable) {
252                  ref.set(throwable);
<span onclick='openModal()' class='match'>253                  latch.countDown();
254              }
255          });
256          try {
257              latch.await(500, TimeUnit.MILLISECONDS);
258          } catch (InterruptedException e) {
259              e.printStackTrace();
260          }
261          assertTrue(ref.get() instanceof AbortExecutionException);
262      }
263      @Test
264      public void testDisabledListener() throws Exception {
</span>265          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues(&quot;myClient&quot;).withProperty(CommonClientConfigKey.ConnectTimeout, &quot;2000&quot;)
266                  .withProperty(CommonClientConfigKey.MaxAutoRetries, 1)
267                  .withProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, 1);
268          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
269          Server badServer = new Server(&quot;localhost:12345&quot;);
270          List&lt;Server&gt; servers = Lists.newArrayList(badServer);
271          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
272                  .withRule(new AvailabilityFilteringRule())
273                  .withPing(new DummyPing())
274                  .buildFixedServerListLoadBalancer(servers);
275          IClientConfig overrideConfig = DefaultClientConfigImpl.getEmptyConfig().set(CommonClientConfigKey.ConnectTimeout, 500);
276          TestExecutionListener&lt;ByteBuf, ByteBuf&gt; listener = new TestExecutionListener&lt;ByteBuf, ByteBuf&gt;(request, overrideConfig);
277          List&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt; listeners = Lists.&lt;ExecutionListener&lt;HttpClientRequest&lt;ByteBuf&gt;, HttpClientResponse&lt;ByteBuf&gt;&gt;&gt;newArrayList(listener);
278          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient(lb, config, new NettyHttpLoadBalancerErrorHandler(config), listeners);
279          ConfigurationManager.getConfigInstance().setProperty(&quot;ribbon.listener.&quot; + TestExecutionListener.class.getName() + &quot;.disabled&quot;, &quot;true&quot;);
280          try {
281              client.submit(request, null, overrideConfig).toBlocking().last();
282          } catch (Exception e) {
283              assertNotNull(e);
284          }
285          assertEquals(0, listener.executionStartCounter.get());
286          assertEquals(0, listener.startWithServerCounter.get());
287          assertEquals(0, listener.exceptionWithServerCounter.get());
288          assertEquals(0, listener.executionFailedCounter.get());
289          assertEquals(0, listener.executionSuccessCounter.get());
290          try {
291              client.submit(request, null, overrideConfig).toBlocking().last();
292          } catch (Exception e) {
293              assertNotNull(e);
294          }
295          assertEquals(0, listener.executionStartCounter.get());
296          assertEquals(0, listener.startWithServerCounter.get());
297          assertEquals(0, listener.exceptionWithServerCounter.get());
298          assertEquals(0, listener.executionFailedCounter.get());
299          assertEquals(0, listener.executionSuccessCounter.get());
300      }
301  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ListenerTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ListenerTest.java</div>
                </div>
                <div class="column column_space"><pre><code>211                  latch.countDown();
212              }
213          });
214          try {
215              latch.await(500, TimeUnit.MILLISECONDS);
216          } catch (InterruptedException e) {
217              e.printStackTrace();
218          }
219          assertTrue(ref.get() instanceof AbortExecutionException);
220      }
221      @Test
222      public void testAbortedExecutionOnServer() {
</pre></code></div>
                <div class="column column_space"><pre><code>253                  latch.countDown();
254              }
255          });
256          try {
257              latch.await(500, TimeUnit.MILLISECONDS);
258          } catch (InterruptedException e) {
259              e.printStackTrace();
260          }
261          assertTrue(ref.get() instanceof AbortExecutionException);
262      }
263      @Test
264      public void testDisabledListener() throws Exception {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    