<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for LongMathRoundingBenchmark.java &amp; ValueGraphTest_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for LongMathRoundingBenchmark.java &amp; ValueGraphTest_1.java
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>LongMathRoundingBenchmark.java (9.9009905%)<th>ValueGraphTest_1.java (1.3495277%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-28)<td><a href="#" name="0">(17-28)</a><td align="center"><font color="#ff0000">10</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LongMathRoundingBenchmark.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.math;
2 import static com.google.common.math.MathBenchmarking.ARRAY_MASK;
3 import static com.google.common.math.MathBenchmarking.ARRAY_SIZE;
4 import static com.google.common.math.MathBenchmarking.RANDOM_SOURCE;
5 import static com.google.common.math.MathBenchmarking.randomNonZeroBigInteger;
6 import static com.google.common.math.MathBenchmarking.randomPositiveBigInteger;
7 import com.google.caliper.BeforeExperiment;
8 import com.google.caliper.Benchmark;
9 import com.google.caliper.Param;
10 import</b></font> java.math.RoundingMode;
11 public class LongMathRoundingBenchmark {
12   @Param({"DOWN", "UP", "FLOOR", "CEILING", "HALF_EVEN", "HALF_UP", "HALF_DOWN"})
13   RoundingMode mode;
14   private static final long[] positive = new long[ARRAY_SIZE];
15   private static final long[] nonzero = new long[ARRAY_SIZE];
16   private static final long[] longs = new long[ARRAY_SIZE];
17   @BeforeExperiment
18   void setUp() {
19     for (int i = 0; i &lt; ARRAY_SIZE; i++) {
20       positive[i] = randomPositiveBigInteger(Long.SIZE - 2).longValue();
21       nonzero[i] = randomNonZeroBigInteger(Long.SIZE - 2).longValue();
22       longs[i] = RANDOM_SOURCE.nextLong();
23     }
24   }
25   @Benchmark
26   int log2(int reps) {
27     int tmp = 0;
28     for (int i = 0; i &lt; reps; i++) {
29       int j = i &amp; ARRAY_MASK;
30       tmp += LongMath.log2(positive[j], mode);
31     }
32     return tmp;
33   }
34   @Benchmark
35   int log10(int reps) {
36     int tmp = 0;
37     for (int i = 0; i &lt; reps; i++) {
38       int j = i &amp; ARRAY_MASK;
39       tmp += LongMath.log10(positive[j], mode);
40     }
41     return tmp;
42   }
43   @Benchmark
44   int sqrt(int reps) {
45     int tmp = 0;
46     for (int i = 0; i &lt; reps; i++) {
47       int j = i &amp; ARRAY_MASK;
48       tmp += LongMath.sqrt(positive[j], mode);
49     }
50     return tmp;
51   }
52   @Benchmark
53   int divide(int reps) {
54     int tmp = 0;
55     for (int i = 0; i &lt; reps; i++) {
56       int j = i &amp; ARRAY_MASK;
57       tmp += LongMath.divide(longs[j], nonzero[j], mode);
58     }
59     return tmp;
60   }
61 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ValueGraphTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright (C) 2016 The Guava Authors
3  *
4  * Licensed under the Apache License, Version 2.0 (the "License");
5  * you may not use this file except in compliance with the License.
6  * You may obtain a copy of the License at
7  *
8  * http://www.apache.org/licenses/LICENSE-2.0
9  *
10  * Unless required by applicable law or agreed to in writing, software
11  * distributed under the License is distributed on an "AS IS" BASIS,
12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13  * See the License for the specific language governing permissions and
14 <a name="0"></a> * limitations under the License.
15  */
16 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.graph;
17 import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
18 import static com.google.common.graph.TestUtil.assertStronglyEquivalent;
19 import static com.google.common.truth.Truth.assertThat;
20 import static java.util.concurrent.Executors.newFixedThreadPool;
21 import static org.junit.Assert.fail;
22 import com.google.common.collect.ImmutableList;
23 import java.util.Set;
24 import java.util.concurrent.Callable;
25 import</b></font> java.util.concurrent.CyclicBarrier;
26 import java.util.concurrent.ExecutorService;
27 import java.util.concurrent.Future;
28 import org.junit.After;
29 import org.junit.Test;
30 import org.junit.runner.RunWith;
31 import org.junit.runners.JUnit4;
32 @RunWith(JUnit4.class)
33 public final class ValueGraphTest {
34   private static final String DEFAULT = "default";
35   MutableValueGraph&lt;Integer, String&gt; graph;
36   @After
37   public void validateGraphState() {
38     assertStronglyEquivalent(graph, Graphs.copyOf(graph));
39     assertStronglyEquivalent(graph, ImmutableValueGraph.copyOf(graph));
40     Graph&lt;Integer&gt; asGraph = graph.asGraph();
41     AbstractGraphTest.validateGraph(asGraph);
42     assertThat(graph.nodes()).isEqualTo(asGraph.nodes());
43     assertThat(graph.edges()).isEqualTo(asGraph.edges());
44     assertThat(graph.nodeOrder()).isEqualTo(asGraph.nodeOrder());
45     assertThat(graph.incidentEdgeOrder()).isEqualTo(asGraph.incidentEdgeOrder());
46     assertThat(graph.isDirected()).isEqualTo(asGraph.isDirected());
47     assertThat(graph.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());
48     for (Integer node : graph.nodes()) {
49       assertThat(graph.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));
50       assertThat(graph.predecessors(node)).isEqualTo(asGraph.predecessors(node));
51       assertThat(graph.successors(node)).isEqualTo(asGraph.successors(node));
52       assertThat(graph.degree(node)).isEqualTo(asGraph.degree(node));
53       assertThat(graph.inDegree(node)).isEqualTo(asGraph.inDegree(node));
54       assertThat(graph.outDegree(node)).isEqualTo(asGraph.outDegree(node));
55       for (Integer otherNode : graph.nodes()) {
56         boolean hasEdge = graph.hasEdgeConnecting(node, otherNode);
57         assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode));
58         assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge);
59         assertThat(!graph.edgeValueOrDefault(node, otherNode, DEFAULT).equals(DEFAULT))
60             .isEqualTo(hasEdge);
61       }
62     }
63   }
64   @Test
65   public void directedGraph() {
66     graph = ValueGraphBuilder.directed().allowsSelfLoops(true).build();
67     graph.putEdgeValue(1, 2, "valueA");
68     graph.putEdgeValue(2, 1, "valueB");
69     graph.putEdgeValue(2, 3, "valueC");
70     graph.putEdgeValue(4, 4, "valueD");
71     assertThat(graph.edgeValueOrDefault(1, 2, null)).isEqualTo("valueA");
72     assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo("valueB");
73     assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo("valueC");
74     assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo("valueD");
75     assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo("valueA");
76     assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo("valueB");
77     assertThat(graph.edgeValueOrDefault(2, 3, DEFAULT)).isEqualTo("valueC");
78     assertThat(graph.edgeValueOrDefault(4, 4, DEFAULT)).isEqualTo("valueD");
79     String toString = graph.toString();
80     assertThat(toString).contains("valueA");
81     assertThat(toString).contains("valueB");
82     assertThat(toString).contains("valueC");
83     assertThat(toString).contains("valueD");
84   }
85   @Test
86   public void undirectedGraph() {
87     graph = ValueGraphBuilder.undirected().allowsSelfLoops(true).build();
88     graph.putEdgeValue(1, 2, "valueA");
89     graph.putEdgeValue(2, 1, "valueB");     graph.putEdgeValue(2, 3, "valueC");
90     graph.putEdgeValue(4, 4, "valueD");
91     assertThat(graph.edgeValueOrDefault(1, 2, null)).isEqualTo("valueB");
92     assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo("valueB");
93     assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo("valueC");
94     assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo("valueD");
95     assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo("valueB");
96     assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo("valueB");
97     assertThat(graph.edgeValueOrDefault(2, 3, DEFAULT)).isEqualTo("valueC");
98     assertThat(graph.edgeValueOrDefault(4, 4, DEFAULT)).isEqualTo("valueD");
99     String toString = graph.toString();
100     assertThat(toString).doesNotContain("valueA");
101     assertThat(toString).contains("valueB");
102     assertThat(toString).contains("valueC");
103     assertThat(toString).contains("valueD");
104   }
105   @Test
106   public void incidentEdgeOrder_unordered() {
107     graph = ValueGraphBuilder.directed().incidentEdgeOrder(ElementOrder.unordered()).build();
108     assertThat(graph.incidentEdgeOrder()).isEqualTo(ElementOrder.unordered());
109   }
110   @Test
111   public void incidentEdgeOrder_stable() {
112     graph = ValueGraphBuilder.directed().incidentEdgeOrder(ElementOrder.stable()).build();
113     assertThat(graph.incidentEdgeOrder()).isEqualTo(ElementOrder.stable());
114   }
115   @Test
116   public void hasEdgeConnecting_directed_correct() {
117     graph = ValueGraphBuilder.directed().build();
118     graph.putEdgeValue(1, 2, "A");
119     assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(1, 2))).isTrue();
120   }
121   @Test
122   public void hasEdgeConnecting_directed_backwards() {
123     graph = ValueGraphBuilder.directed().build();
124     graph.putEdgeValue(1, 2, "A");
125     assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(2, 1))).isFalse();
126   }
127   @Test
128   public void hasEdgeConnecting_directed_mismatch() {
129     graph = ValueGraphBuilder.directed().build();
130     graph.putEdgeValue(1, 2, "A");
131     assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(1, 2))).isFalse();
132     assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(2, 1))).isFalse();
133   }
134   @Test
135   public void hasEdgeConnecting_undirected_correct() {
136     graph = ValueGraphBuilder.undirected().build();
137     graph.putEdgeValue(1, 2, "A");
138     assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(1, 2))).isTrue();
139   }
140   @Test
141   public void hasEdgeConnecting_undirected_backwards() {
142     graph = ValueGraphBuilder.undirected().build();
143     graph.putEdgeValue(1, 2, "A");
144     assertThat(graph.hasEdgeConnecting(EndpointPair.unordered(2, 1))).isTrue();
145   }
146   @Test
147   public void hasEdgeConnecting_undirected_mismatch() {
148     graph = ValueGraphBuilder.undirected().build();
149     graph.putEdgeValue(1, 2, "A");
150     assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(1, 2))).isTrue();
151     assertThat(graph.hasEdgeConnecting(EndpointPair.ordered(2, 1))).isTrue();
152   }
153   @Test
154   public void edgeValueOrDefault_directed_correct() {
155     graph = ValueGraphBuilder.directed().build();
156     graph.putEdgeValue(1, 2, "A");
157     assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(1, 2), "default")).isEqualTo("A");
158   }
159   @Test
160   public void edgeValueOrDefault_directed_backwards() {
161     graph = ValueGraphBuilder.directed().build();
162     graph.putEdgeValue(1, 2, "A");
163     assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), "default"))
164         .isEqualTo("default");
165   }
166   @Test
167   public void edgeValueOrDefault_directed_mismatch() {
168     graph = ValueGraphBuilder.directed().build();
169     graph.putEdgeValue(1, 2, "A");
170     try {
171       String unused = graph.edgeValueOrDefault(EndpointPair.unordered(1, 2), "default");
172       unused = graph.edgeValueOrDefault(EndpointPair.unordered(2, 1), "default");
173       fail("Expected IllegalArgumentException: " + ENDPOINTS_MISMATCH);
174     } catch (IllegalArgumentException e) {
175       assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);
176     }
177   }
178   @Test
179   public void edgeValueOrDefault_undirected_correct() {
180     graph = ValueGraphBuilder.undirected().build();
181     graph.putEdgeValue(1, 2, "A");
182     assertThat(graph.edgeValueOrDefault(EndpointPair.unordered(1, 2), "default")).isEqualTo("A");
183   }
184   @Test
185   public void edgeValueOrDefault_undirected_backwards() {
186     graph = ValueGraphBuilder.undirected().build();
187     graph.putEdgeValue(1, 2, "A");
188     assertThat(graph.edgeValueOrDefault(EndpointPair.unordered(2, 1), "default")).isEqualTo("A");
189   }
190   @Test
191   public void edgeValueOrDefault_undirected_mismatch() {
192     graph = ValueGraphBuilder.undirected().build();
193     graph.putEdgeValue(1, 2, "A");
194     assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), "default")).isEqualTo("A");
195     assertThat(graph.edgeValueOrDefault(EndpointPair.ordered(2, 1), "default")).isEqualTo("A");
196   }
197   @Test
198   public void putEdgeValue_directed() {
199     graph = ValueGraphBuilder.directed().build();
200     assertThat(graph.putEdgeValue(1, 2, "valueA")).isNull();
201     assertThat(graph.putEdgeValue(2, 1, "valueB")).isNull();
202     assertThat(graph.putEdgeValue(1, 2, "valueC")).isEqualTo("valueA");
203     assertThat(graph.putEdgeValue(2, 1, "valueD")).isEqualTo("valueB");
204   }
205   @Test
206   public void putEdgeValue_directed_orderMismatch() {
207     graph = ValueGraphBuilder.directed().build();
208     try {
209       graph.putEdgeValue(EndpointPair.unordered(1, 2), "irrelevant");
210       fail("Expected IllegalArgumentException: " + ENDPOINTS_MISMATCH);
211     } catch (IllegalArgumentException e) {
212       assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);
213     }
214   }
215   @Test
216   public void putEdgeValue_undirected_orderMismatch() {
217     graph = ValueGraphBuilder.undirected().build();
218     assertThat(graph.putEdgeValue(EndpointPair.ordered(1, 2), "irrelevant")).isNull();
219   }
220   @Test
221   public void putEdgeValue_undirected() {
222     graph = ValueGraphBuilder.undirected().build();
223     assertThat(graph.putEdgeValue(1, 2, "valueA")).isNull();
224     assertThat(graph.putEdgeValue(2, 1, "valueB")).isEqualTo("valueA");
225     assertThat(graph.putEdgeValue(1, 2, "valueC")).isEqualTo("valueB");
226     assertThat(graph.putEdgeValue(2, 1, "valueD")).isEqualTo("valueC");
227   }
228   @Test
229   public void removeEdge_directed() {
230     graph = ValueGraphBuilder.directed().build();
231     graph.putEdgeValue(1, 2, "valueA");
232     graph.putEdgeValue(2, 1, "valueB");
233     graph.putEdgeValue(2, 3, "valueC");
234     assertThat(graph.removeEdge(1, 2)).isEqualTo("valueA");
235     assertThat(graph.removeEdge(1, 2)).isNull();
236     assertThat(graph.removeEdge(2, 1)).isEqualTo("valueB");
237     assertThat(graph.removeEdge(2, 1)).isNull();
238     assertThat(graph.removeEdge(2, 3)).isEqualTo("valueC");
239     assertThat(graph.removeEdge(2, 3)).isNull();
240   }
241   @Test
242   public void removeEdge_undirected() {
243     graph = ValueGraphBuilder.undirected().build();
244     graph.putEdgeValue(1, 2, "valueA");
245     graph.putEdgeValue(2, 1, "valueB");
246     graph.putEdgeValue(2, 3, "valueC");
247     assertThat(graph.removeEdge(1, 2)).isEqualTo("valueB");
248     assertThat(graph.removeEdge(1, 2)).isNull();
249     assertThat(graph.removeEdge(2, 1)).isNull();
250     assertThat(graph.removeEdge(2, 3)).isEqualTo("valueC");
251     assertThat(graph.removeEdge(2, 3)).isNull();
252   }
253   @Test
254   public void removeEdge_directed_orderMismatch() {
255     graph = ValueGraphBuilder.directed().build();
256     graph.putEdgeValue(1, 2, "1-&gt;2");
257     graph.putEdgeValue(2, 1, "2-&gt;1");
258     try {
259       graph.removeEdge(EndpointPair.unordered(1, 2));
260       graph.removeEdge(EndpointPair.unordered(2, 1));
261       fail("Expected IllegalArgumentException: " + ENDPOINTS_MISMATCH);
262     } catch (IllegalArgumentException e) {
263       assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);
264     }
265   }
266   @Test
267   public void removeEdge_undirected_orderMismatch() {
268     graph = ValueGraphBuilder.undirected().build();
269     graph.putEdgeValue(1, 2, "1-2");
270     assertThat(graph.removeEdge(EndpointPair.ordered(1, 2))).isEqualTo("1-2");
271   }
272   @Test
273   public void edgeValue_missing() {
274     graph = ValueGraphBuilder.directed().build();
275     assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(DEFAULT);
276     assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo(DEFAULT);
277     assertThat(graph.edgeValueOrDefault(1, 2, null)).isNull();
278     assertThat(graph.edgeValueOrDefault(2, 1, null)).isNull();
279     graph.putEdgeValue(1, 2, "valueA");
280     graph.putEdgeValue(2, 1, "valueB");
281     assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo("valueA");
282     assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo("valueB");
283     assertThat(graph.edgeValueOrDefault(1, 2, null)).isEqualTo("valueA");
284     assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo("valueB");
285     graph.removeEdge(1, 2);
286     graph.putEdgeValue(2, 1, "valueC");
287     assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(DEFAULT);
288     assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo("valueC");
289     assertThat(graph.edgeValueOrDefault(1, 2, null)).isNull();
290     assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo("valueC");
291   }
292   @Test
293   public void equivalence_considersEdgeValue() {
294     graph = ValueGraphBuilder.undirected().build();
295     graph.putEdgeValue(1, 2, "valueA");
296     MutableValueGraph&lt;Integer, String&gt; otherGraph = ValueGraphBuilder.undirected().build();
297     otherGraph.putEdgeValue(1, 2, "valueA");
298     assertThat(graph).isEqualTo(otherGraph);
299     otherGraph.putEdgeValue(1, 2, "valueB");
300     assertThat(graph).isNotEqualTo(otherGraph);   }
301   @Test
302   public void incidentEdges_stableIncidentEdgeOrder_preservesIncidentEdgesOrder_directed() {
303     graph = ValueGraphBuilder.directed().incidentEdgeOrder(ElementOrder.stable()).build();
304     graph.putEdgeValue(2, 1, "2-1");
305     graph.putEdgeValue(2, 3, "2-3");
306     graph.putEdgeValue(1, 2, "1-2");
307     assertThat(graph.incidentEdges(2))
308         .containsExactly(
309             EndpointPair.ordered(2, 1), EndpointPair.ordered(2, 3), EndpointPair.ordered(1, 2))
310         .inOrder();
311   }
312   @Test
313   public void incidentEdges_stableIncidentEdgeOrder_preservesIncidentEdgesOrder_undirected() {
314     graph = ValueGraphBuilder.undirected().incidentEdgeOrder(ElementOrder.stable()).build();
315     graph.putEdgeValue(2, 3, "2-3");
316     graph.putEdgeValue(2, 1, "2-1");
317     graph.putEdgeValue(2, 4, "2-4");
318     graph.putEdgeValue(1, 2, "1-2"); 
319     assertThat(graph.incidentEdges(2))
320         .containsExactly(
321             EndpointPair.unordered(2, 3),
322             EndpointPair.unordered(1, 2),
323             EndpointPair.unordered(2, 4))
324         .inOrder();
325   }
326   @Test
327   public void concurrentIteration() throws Exception {
328     graph = ValueGraphBuilder.directed().build();
329     graph.putEdgeValue(1, 2, "A");
330     graph.putEdgeValue(3, 4, "B");
331     graph.putEdgeValue(5, 6, "C");
332     int threadCount = 20;
333     ExecutorService executor = newFixedThreadPool(threadCount);
334     final CyclicBarrier barrier = new CyclicBarrier(threadCount);
335     ImmutableList.Builder&lt;Future&lt;?&gt;&gt; futures = ImmutableList.builder();
336     for (int i = 0; i &lt; threadCount; i++) {
337       futures.add(
338           executor.submit(
339               new Callable&lt;Object&gt;() {
340                 @Override
341                 public Object call() throws Exception {
342                   barrier.await();
343                   Integer first = graph.nodes().iterator().next();
344                   for (Integer node : graph.nodes()) {
345                     Set&lt;Integer&gt; unused = graph.successors(node);
346                   }
347                   /*
348                    * Also look up an earlier node so that, if the graph is using MapRetrievalCache,
349                    * we read one of the fields declared in that class.
350                    */
351                   Set&lt;Integer&gt; unused = graph.successors(first);
352                   return null;
353                 }
354               }));
355     }
356     for (Future&lt;?&gt; future : futures.build()) {
357       future.get();
358     }
359     executor.shutdown();
360   }
361 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
