
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.11961057023644%, Tokens: 12</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ServiceConfigBeanTest.java</h3>
            <pre><code>1  package com.weibo.api.motan.config.springsupport;
2  import com.weibo.api.motan.config.ServiceConfig;
3  import com.weibo.api.motan.rpc.Exporter;
4  import com.weibo.api.motan.rpc.URL;
5  import org.junit.After;
6  import org.junit.Before;
7  import org.junit.Test;
8  import java.util.List;
9  import static org.junit.Assert.*;
10  public class ServiceConfigBeanTest extends BaseTest {
11      ServiceConfig<ITest> serviceTest;
12      ServiceConfig<ITest> serviceTest2;
13      ServiceConfig<ITest> serviceTest3;
14      @SuppressWarnings({"unchecked", "rawtypes"})
15      @Before
16      public void setUp() throws Exception {
17          serviceTest = (ServiceConfig) cp.getBean("serviceTest");
18          serviceTest2 = (ServiceConfig) cp.getBean("serviceTestWithMethodConfig");
19          serviceTest3 = (ServiceConfig) cp.getBean("serviceTestInjvm");
20      }
21      @After
22      public void tearDown() throws Exception {}
23      @Test
24      public void testGetRef() {
25          ITest test = serviceTest.getRef();
26          assertTrue(test instanceof TestImpl);
27          assertEquals(test, serviceTest2.getRef());
28          assertNotSame(test, serviceTest3.getRef());
29      }
30      @Test
31      public void testExport() {
32          assertTrue(serviceTest.getExported().get());
33          assertTrue(serviceTest2.getExported().get());
34          assertTrue(serviceTest3.getExported().get());
35      }
36      @Test
37      public void testGetProtocolAndPort() {
38          List<Exporter<ITest>> exporters = serviceTest.getExporters();
39          assertEquals(2, exporters.size());
40          boolean injvm = false;
41          boolean motan = false;
42          for (Exporter<ITest> exporter : exporters) {
43              URL url = exporter.getUrl();
44              if ("injvm".equals(url.getProtocol()) && url.getPort() == 0) {
45                  injvm = true;
46              } else if ("motan".equals(url.getProtocol()) && url.getPort() == 7888) {
47                  motan = true;
48              }
49          }
50          assertTrue(injvm && motan);
<span onclick='openModal()' class='match'>51          exporters = serviceTest2.getExporters();
52          URL url = exporters.get(0).getUrl();
53          assertEquals(1, exporters.size());
54          assertEquals("motan", url.getProtocol());
55          assertEquals(18080, url.getPort().intValue());
56      }
</span>57  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ClusterSupport.java</h3>
            <pre><code>1  package com.weibo.api.motan.cluster.support;
2  import com.weibo.api.motan.closable.ShutDownHook;
3  import com.weibo.api.motan.cluster.Cluster;
4  import com.weibo.api.motan.cluster.HaStrategy;
5  import com.weibo.api.motan.cluster.LoadBalance;
6  import com.weibo.api.motan.common.MotanConstants;
7  import com.weibo.api.motan.common.URLParamType;
8  import com.weibo.api.motan.core.extension.ExtensionLoader;
9  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
10  import com.weibo.api.motan.exception.MotanFrameworkException;
11  import com.weibo.api.motan.protocol.support.ProtocolFilterDecorator;
12  import com.weibo.api.motan.registry.NotifyListener;
13  import com.weibo.api.motan.registry.Registry;
14  import com.weibo.api.motan.registry.RegistryFactory;
15  import com.weibo.api.motan.rpc.Protocol;
16  import com.weibo.api.motan.rpc.Referer;
17  import com.weibo.api.motan.rpc.URL;
18  import com.weibo.api.motan.util.*;
19  import org.apache.commons.lang3.ObjectUtils;
20  import org.apache.commons.lang3.StringUtils;
21  import java.util.*;
22  import java.util.concurrent.*;
23  public class ClusterSupport<T> implements NotifyListener, StatisticCallback {
24      private static ConcurrentHashMap<String, Protocol> protocols = new ConcurrentHashMap<>();
25      private static ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
26      private static Set<ClusterSupport> refreshSet = new HashSet<>();
27      static {
28          executorService.scheduleAtFixedRate(() -> {
29              for (ClusterSupport clusterSupport : refreshSet) {
30                  clusterSupport.refreshReferers();
31              }
32          }, MotanConstants.REFRESH_PERIOD, MotanConstants.REFRESH_PERIOD, TimeUnit.SECONDS);
33          ShutDownHook.registerShutdownHook(() -> {
34              if (!executorService.isShutdown()) {
35                  executorService.shutdown();
36              }
37          });
38      }
39      private Cluster<T> cluster;
40      private List<URL> registryUrls;
41      private URL url;
42      private Class<T> interfaceClass;
43      private Protocol protocol;
44      private ConcurrentHashMap<URL, List<Referer<T>>> registryReferers = new ConcurrentHashMap<>();
45      private int selectNodeCount;
46      private ConcurrentHashMap<URL, Map<String, GroupUrlsSelector>> registryGroupUrlsSelectorMap = new ConcurrentHashMap<>();
47      public ClusterSupport(Class<T> interfaceClass, List<URL> registryUrls, URL refUrl) {
48          this.registryUrls = registryUrls;
49          this.interfaceClass = interfaceClass;
50          this.url = refUrl;
51          protocol = getDecorateProtocol(url.getProtocol());
52          int maxConnectionCount = this.url.getIntParameter(URLParamType.maxConnectionPerGroup.getName(), URLParamType.maxConnectionPerGroup.getIntValue());
53          int maxClientConnection = this.url.getIntParameter(URLParamType.maxClientConnection.getName(), URLParamType.maxClientConnection.getIntValue());
54          selectNodeCount = (int) Math.ceil(1.0 * maxConnectionCount / maxClientConnection);
55      }
56      public void init() {
57          long start = System.currentTimeMillis();
58          prepareCluster();
59          URL subUrl = toSubscribeUrl(url);
60          for (URL ru : registryUrls) {
61              String directUrlStr = ru.getParameter(URLParamType.directUrl.getName());
62              if (StringUtils.isNotBlank(directUrlStr)) {
63                  List<URL> directUrls = UrlUtils.stringToURLs(directUrlStr);
64                  if (!directUrls.isEmpty()) {
65                      notify(ru, directUrls);
66                      LoggerUtil.info("Use direct urls, refUrl={}, directUrls={}", url, directUrls);
67                      continue;
68                  }
69              }
70              Registry registry = getRegistry(ru);
71              registry.subscribe(subUrl, this);
72          }
73          boolean check = Boolean.parseBoolean(url.getParameter(URLParamType.check.getName(), URLParamType.check.getValue()));
74          if (!CollectionUtil.isEmpty(cluster.getReferers()) || !check) {
75              cluster.init();
76              if (CollectionUtil.isEmpty(cluster.getReferers()) && !check) {
77                  LoggerUtil.warn(String.format("refer:%s", this.url.getPath() + "/" + this.url.getVersion()), "No services");
78              }
79              LoggerUtil.info("cluster init cost " + (System.currentTimeMillis() - start) + ", refer size:"
80                      + (cluster.getReferers() == null ? 0 : cluster.getReferers().size()) + ", cluster:" + cluster.getUrl().toSimpleString());
81              StatsUtil.registryStatisticCallback(this);
82              return;
83          }
84          throw new MotanFrameworkException(String.format("ClusterSupport No service urls for the refer:%s, registries:%s",
85                  this.url.getIdentity(), registryUrls), MotanErrorMsgConstant.SERVICE_UNFOUND);
86      }
87      public void destroy() {
88          URL subscribeUrl = toSubscribeUrl(url);
89          for (URL ru : registryUrls) {
90              try {
91                  Registry registry = getRegistry(ru);
92                  registry.unsubscribe(subscribeUrl, this);
93                  if (!MotanConstants.NODE_TYPE_REFERER.equals(url.getParameter(URLParamType.nodeType.getName()))) {
94                      registry.unregister(url);
95                  }
96              } catch (Exception e) {
97                  LoggerUtil.warn(String.format("Unregister or unsubscribe false for url (%s), registry= %s", url, ru.getIdentity()), e);
98              }
99          }
100          try {
101              getCluster().destroy();
102          } catch (Exception e) {
103              LoggerUtil.warn(String.format("Exception when destroy cluster: %s", getCluster().getUrl()));
104          }
105          StatsUtil.unRegistryStatisticCallback(this);
106      }
107      protected Registry getRegistry(URL url) {
108          RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getExtension(url.getProtocol());
109          return registryFactory.getRegistry(url);
110      }
111      private URL toSubscribeUrl(URL url) {
112          URL subUrl = url.createCopy();
113          subUrl.addParameter(URLParamType.nodeType.getName(), MotanConstants.NODE_TYPE_SERVICE);
114          return subUrl;
115      }
116      @Override
117      public synchronized void notify(URL registryUrl, List<URL> urls) {
118          if (CollectionUtil.isEmpty(urls)) {
119              onRegistryEmpty(registryUrl);
120              LoggerUtil.warn("ClusterSupport config change notify, urls is empty: registry={} service={} urls=[]", registryUrl.getUri(),
121                      url.getIdentity());
122              return;
123          }
124          LoggerUtil.info("ClusterSupport config change notify: registry={} service={} urls={}", registryUrl.getUri(), url.getIdentity(),
125                  getIdentities(urls));
126          processWeights(urls);
127          List<URL> serviceUrls = urls;
128          if (selectNodeCount > 0 && MotanSwitcherUtil.switcherIsOpenWithDefault("feature.motan.partial.server", true)) {
129              refreshSet.add(this);
130              serviceUrls = selectUrls(registryUrl, urls);
131          } else {
132              refreshSet.remove(this);
133          }
134          doRefreshReferersByUrls(registryUrl, serviceUrls);
135      }
136      private void doRefreshReferersByUrls(URL registryUrl, List<URL> serviceUrls) {
137          List<Referer<T>> newReferers = new ArrayList<>();
138          for (URL u : serviceUrls) {
139              if (!u.canServe(url)) {
140                  continue;
141              }
142              Referer<T> referer = getExistingReferer(u, registryReferers.get(registryUrl));
143              if (referer == null) {
144                  URL refererURL = u.createCopy();
145                  mergeClientConfigs(refererURL);
146                  referer = protocol.refer(interfaceClass, refererURL, u);
147              }
148              if (referer != null) {
149                  newReferers.add(referer);
150              }
151          }
152          if (CollectionUtil.isEmpty(newReferers)) {
153              onRegistryEmpty(registryUrl);
154              return;
155          }
156          registryReferers.put(registryUrl, newReferers);
157          refreshCluster();
158      }
159      protected List<URL> selectUrls(URL registryUrl, List<URL> urls) {
160          Map<String, List<URL>> groupUrlsMap = new HashMap<>();
161          for (URL u : urls) {
162              String group = u.getGroup();
163              if (!groupUrlsMap.containsKey(group)) {
164                  groupUrlsMap.put(group, new ArrayList<URL>());
165              }
166              if (u.canServe(url)) {
167                  groupUrlsMap.get(group).add(u);
168              }
169          }
170          Map<String, GroupUrlsSelector> selectorMap = registryGroupUrlsSelectorMap.computeIfAbsent(registryUrl, k -> new HashMap<>());
171          for (Map.Entry<String, List<URL>> entry : groupUrlsMap.entrySet()) {
172              GroupUrlsSelector groupUrlsSelector = selectorMap.computeIfAbsent(entry.getKey(), k -> new GroupUrlsSelector());
173              if (entry.getValue().size() <= selectNodeCount) {
174                  LoggerUtil.info("ClusterSupport config change notify: registry={} service={} group={} size={} non increased",
175                          registryUrl.getUri(), url.getIdentity(), entry.getKey(), entry.getValue().size());
176              }
177              groupUrlsSelector.updateBaseUrls(entry.getValue());
178          }
179          Set<String> removeGroups = new HashSet<>(selectorMap.keySet());
180          removeGroups.removeAll(groupUrlsMap.keySet());
181          if (!CollectionUtil.isEmpty(removeGroups)) {
182              for (String removeGroup : removeGroups) {
183                  selectorMap.remove(removeGroup);
184              }
185          }
186          return doSelectUrls(registryUrl);
187      }
188      private List<URL> doSelectUrls(URL registryUrl) {
189          List<URL> result = new ArrayList<>();
190          Map<String, GroupUrlsSelector> selectors = registryGroupUrlsSelectorMap.getOrDefault(registryUrl, Collections.emptyMap());
191          for (Map.Entry<String, GroupUrlsSelector> entry : selectors.entrySet()) {
192              List<URL> urls = entry.getValue().selectUrls();
193              result.addAll(urls);
194              LoggerUtil.info("ClusterSupport select group urls: registry={} service={} group={} expectSize={} size={} urls={}",
195                      registryUrl.getUri(), url.getIdentity(), entry.getKey(), entry.getValue().getSelectSize(), urls.size(), getIdentities(urls));
196          }
197          return result;
198      }
199      protected void refreshReferers() {
200          for (Map.Entry<URL, List<Referer<T>>> entry : registryReferers.entrySet()) {
201              URL registryUrl = entry.getKey();
202              LoggerUtil.info("ClusterSupport refreshReferers: registry={} service={}", registryUrl.getUri(), url.getIdentity());
203              Map<String, GroupUrlsSelector> groupSelectorMap = registryGroupUrlsSelectorMap.get(registryUrl);
204              if (groupSelectorMap == null || groupSelectorMap.size() == 0) {
205                  LoggerUtil.warn("ClusterSupport refreshReferers, groupSelectorMap is empty: registry={} service={}", registryUrl.getUri(), url.getIdentity());
206                  continue;
207              }
208              Map<String, Integer> groupAvailableCounter = new HashMap<>(groupSelectorMap.size());
209              for (Referer<T> referer : entry.getValue()) {
210                  String group = referer.getServiceUrl().getGroup();
211                  if (referer.isAvailable()) {
212                      groupAvailableCounter.put(group, groupAvailableCounter.getOrDefault(group, 0) + 1);
213                  }
214              }
215              boolean needRefresh = false;
216              for (Map.Entry<String, Integer> counter : groupAvailableCounter.entrySet()) {
217                  String group = counter.getKey();
218                  int available = counter.getValue();
219                  GroupUrlsSelector selector = groupSelectorMap.get(group);
220                  if (selector == null) {
221                      LoggerUtil.warn("ClusterSupport refreshReferers ,urls selector is null: registry={} service={} group={}", registryUrl.getUri(), url.getIdentity(), group);
222                      continue;
223                  }
224                  int selectSize = selector.getSelectSize();
225                  int newSize = selectSize;
226                  if (available <= 1.0 * selectNodeCount * 2 / 3 && selector.getBaseUrlsSize() > selectSize) {
227                      newSize = Math.min(selectSize + (selectNodeCount - available), selector.getBaseUrlsSize());
228                  } else if (available >= 1.0 * selectNodeCount * 4 / 3) {
229                      newSize = selectSize - (available - selectNodeCount);
230                  }
231                  if (newSize != selectSize) {
232                      needRefresh = true;
233                      selector.setSelectSize(newSize);
234                      LoggerUtil.info("ClusterSupport refreshReferers selectSize changed: registry={} service={} group={} newSize={} oldSize={}", registryUrl.getUri(), url.getIdentity(), group, newSize, selectSize);
235                  }
236              }
237              if (needRefresh) {
238                  List<URL> urls = doSelectUrls(registryUrl);
239                  doRefreshReferersByUrls(registryUrl, urls);
240              }
241          }
242      }
243      private void processWeights(List<URL> urls) {
244          if (urls != null && !urls.isEmpty()) {
245              URL ruleUrl = urls.get(0);
246              String weights = URLParamType.weights.getValue();
247              if ("rule".equalsIgnoreCase(ruleUrl.getProtocol())) {
248                  weights = ruleUrl.getParameter(URLParamType.weights.getName(), URLParamType.weights.getValue());
249                  urls.remove(0);
250              }
251              LoggerUtil.info("refresh weight. weight=" + weights);
252              this.cluster.getLoadBalance().setWeightString(weights);
253          }
254      }
255      private void onRegistryEmpty(URL excludeRegistryUrl) {
256          boolean noMoreOtherRefers = registryReferers.size() == 1 && registryReferers.containsKey(excludeRegistryUrl);
257          if (noMoreOtherRefers) {
258              LoggerUtil.warn(String.format("Ignore notify for no more referers in this cluster, registry: %s, cluster=%s",
259                      excludeRegistryUrl, getUrl()));
260          } else {
261              registryReferers.remove(excludeRegistryUrl);
262              refreshCluster();
263          }
264      }
265      protected Protocol getDecorateProtocol(String protocolName) {
266          Protocol decorateProtocol = protocols.get(protocolName);
267          if (decorateProtocol == null) {
268              protocols.putIfAbsent(protocolName, new ProtocolFilterDecorator(ExtensionLoader.getExtensionLoader(Protocol.class)
269                      .getExtension(protocolName)));
270              decorateProtocol = protocols.get(protocolName);
271          }
272          return decorateProtocol;
273      }
274      private Referer<T> getExistingReferer(URL url, List<Referer<T>> referers) {
275          if (referers == null) {
276              return null;
277          }
278          for (Referer<T> r : referers) {
279              if (ObjectUtils.equals(url, r.getUrl()) || ObjectUtils.equals(url, r.getServiceUrl())) {
280                  return r;
281              }
282          }
283          return null;
284      }
285      private void mergeClientConfigs(URL refererURL) {
<span onclick='openModal()' class='match'>286          String application = refererURL.getParameter(URLParamType.application.getName(), URLParamType.application.getValue());
287          String module = refererURL.getParameter(URLParamType.module.getName(), URLParamType.module.getValue());
288          refererURL.addParameters(this.url.getParameters());
289          refererURL.addParameter(URLParamType.application.getName(), application);
290          refererURL.addParameter(URLParamType.module.getName(), module);
291      }
</span>292      private void refreshCluster() {
293          List<Referer<T>> referers = new ArrayList<>();
294          for (List<Referer<T>> refs : registryReferers.values()) {
295              referers.addAll(refs);
296          }
297          cluster.onRefresh(referers);
298      }
299      public Cluster<T> getCluster() {
300          return cluster;
301      }
302      public URL getUrl() {
303          return url;
304      }
305      private String getIdentities(List<URL> urls) {
306          if (urls == null || urls.isEmpty()) {
307              return "[]";
308          }
309          StringBuilder builder = new StringBuilder();
310          builder.append("[");
311          for (URL u : urls) {
312              builder.append(u.getIdentity()).append(",");
313          }
314          builder.setLength(builder.length() - 1);
315          builder.append("]");
316          return builder.toString();
317      }
318      @SuppressWarnings("unchecked")
319      private void prepareCluster() {
320          String clusterName = url.getParameter(URLParamType.cluster.getName(), URLParamType.cluster.getValue());
321          String loadbalanceName = url.getParameter(URLParamType.loadbalance.getName(), URLParamType.loadbalance.getValue());
322          String haStrategyName = url.getParameter(URLParamType.haStrategy.getName(), URLParamType.haStrategy.getValue());
323          cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getExtension(clusterName);
324          LoadBalance<T> loadBalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName);
325          HaStrategy<T> ha = ExtensionLoader.getExtensionLoader(HaStrategy.class).getExtension(haStrategyName);
326          ha.setUrl(url);
327          cluster.setLoadBalance(loadBalance);
328          cluster.setHaStrategy(ha);
329          cluster.setUrl(url);
330      }
331      @Override
332      public String statisticCallback() {
333          if (cluster != null && !CollectionUtil.isEmpty(cluster.getReferers())) {
334              int unavailable = 0;
335              for (Referer referer : cluster.getReferers()) {
336                  if (!referer.isAvailable()) {
337                      unavailable++;
338                  }
339              }
340              return String.format("type:MOTAN_CLUSTER_STAT, name:%s_%s, nodes: %s, unavailable:%s", url.getGroup(), url.getPath(), cluster.getReferers().size(), unavailable);
341          }
342          return null;
343      }
344      private class GroupUrlsSelector {
345          private List<URL> baseUrls;
346          private int selectSize;
347          GroupUrlsSelector() {
348              baseUrls = new ArrayList<>();
349              selectSize = selectNodeCount;
350          }
351          void updateBaseUrls(List<URL> newBaseUrls) {
352              baseUrls.retainAll(newBaseUrls);
353              Set<URL> addedUrls = new HashSet<>(newBaseUrls);
354              addedUrls.removeAll(baseUrls);
355              for (URL addedUrl : addedUrls) {
356                  int addPosition = ThreadLocalRandom.current().nextInt(baseUrls.size() + 1);
357                  baseUrls.add(addPosition, addedUrl);
358              }
359          }
360          List<URL> selectUrls() {
361              List<URL> result = new ArrayList<>(selectSize);
362              if (baseUrls.size() >= selectSize) {
363                  result.addAll(baseUrls.subList(0, selectSize));
364              } else {
365                  result.addAll(baseUrls);
366              }
367              return result;
368          }
369          int getSelectSize() {
370              return selectSize;
371          }
372          void setSelectSize(int selectSize) {
373              this.selectSize = selectSize;
374          }
375          int getBaseUrlsSize() {
376              return baseUrls.size();
377          }
378      }
379  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ServiceConfigBeanTest.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ClusterSupport.java</div>
                <div class="column column_space"><pre><code>51          exporters = serviceTest2.getExporters();
52          URL url = exporters.get(0).getUrl();
53          assertEquals(1, exporters.size());
54          assertEquals("motan", url.getProtocol());
55          assertEquals(18080, url.getPort().intValue());
56      }
</pre></code></div>
                <div class="column column_space"><pre><code>286          String application = refererURL.getParameter(URLParamType.application.getName(), URLParamType.application.getValue());
287          String module = refererURL.getParameter(URLParamType.module.getName(), URLParamType.module.getValue());
288          refererURL.addParameters(this.url.getParameters());
289          refererURL.addParameter(URLParamType.application.getName(), application);
290          refererURL.addParameter(URLParamType.module.getName(), module);
291      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    