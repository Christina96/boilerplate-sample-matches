<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for FutureCallbackTest_1.java &amp; AbstractServiceTest_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for FutureCallbackTest_1.java &amp; AbstractServiceTest_1.java
      </h3>
<h1 align="center">
        11.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>FutureCallbackTest_1.java (38.912132%)<th>AbstractServiceTest_1.java (7.083016%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(105-114)<td><a href="#" name="0">(59-71)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(122-128)<td><a href="#" name="1">(451-456)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(41-48)<td><a href="#" name="2">(346-354)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(81-87)<td><a href="#" name="3">(87-93)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(17-29)<td><a href="#" name="4">(17-29)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(130-136)<td><a href="#" name="5">(75-82)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(89-94)<td><a href="#" name="6">(183-189)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(71-77)<td><a href="#" name="7">(849-855)</a><td align="center"><font color="#aa0000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FutureCallbackTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.util.concurrent;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.util.concurrent.Futures.addCallback;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import java.util.concurrent.CancellationException;
import java.util.concurrent.Executor;
import javax.annotation.CheckForNull;
import junit.framework.TestCase;
import</b></font> org.mockito.Mockito;
@GwtCompatible(emulated = true)
public class FutureCallbackTest extends TestCase {
<a name="2"></a>  public void testSameThreadSuccess() {
    SettableFuture&lt;String&gt; f = SettableFuture.create();
    MockCallback callback = new MockCallback("foo");
    <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>addCallback(f, callback, directExecutor());
    f.set("foo");
  }
  public void testExecutorSuccess() {
    CountingSameThreadExecutor ex = new CountingSameThreadExecutor();
    SettableFuture&lt;String&gt; f = SettableFuture.create();
    MockCallback callback = new</b></font> MockCallback("foo");
    Futures.addCallback(f, callback, ex);
    f.set("foo");
    assertEquals(1, ex.runCount);
  }
  public void testSameThreadExecutionException() {
    SettableFuture&lt;String&gt; f = SettableFuture.create();
    Exception e = new IllegalArgumentException("foo not found");
    MockCallback callback = new MockCallback(e);
    addCallback(f, callback, directExecutor());
    f.setException(e);
  }
  public void testCancel() {
    SettableFuture&lt;String&gt; f = SettableFuture.create();
    FutureCallback&lt;String&gt; callback =
        new FutureCallback&lt;String&gt;() {
          private boolean called = false;
<a name="7"></a>
          @Override
          public void onSuccess(String result) {
            <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>fail("Was not expecting onSuccess() to be called.");
          }
          @Override
          public synchronized void onFailure(Throwable t) {
            assertFalse(called);
            assertThat</b></font>(t).isInstanceOf(CancellationException.class);
<a name="3"></a>            called = true;
          }
        };
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>addCallback(f, callback, directExecutor());
    f.cancel(true);
  }
  public void testThrowErrorFromGet() {
<a name="6"></a>    Error error = new AssertionError("ASSERT!");
    ListenableFuture&lt;String&gt; f = UncheckedThrowingFuture.throwingError</b></font>(error);
    MockCallback callback = new MockCallback(error);
    <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>addCallback(f, callback, directExecutor());
  }
  public void testRuntimeExeceptionFromGet() {
    RuntimeException e = new IllegalArgumentException("foo not found");
    ListenableFuture&lt;String&gt; f = UncheckedThrowingFuture.throwingRuntimeException</b></font>(e);
    MockCallback callback = new MockCallback(e);
    addCallback(f, callback, directExecutor());
  }
  @GwtIncompatible   public void testOnSuccessThrowsRuntimeException() throws Exception {
    RuntimeException exception = new RuntimeException();
<a name="0"></a>    String result = "result";
    SettableFuture&lt;String&gt; future = SettableFuture.create();
    @SuppressWarnings("unchecked")     FutureCallback&lt;String&gt; callback = <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Mockito.mock(FutureCallback.class);
    addCallback(future, callback, directExecutor());
    Mockito.doThrow(exception).when(callback).onSuccess(result);
    future.set(result);
    assertEquals(result, future.get());
    Mockito.verify(callback).onSuccess(result);
    Mockito.verifyNoMoreInteractions(callback);
  }
  @GwtIncompatible   public void testOnSuccessThrowsError() throws Exception {
    class TestError extends Error {}
    TestError error = new TestError();
    String result = "result";
<a name="1"></a>    SettableFuture&lt;String&gt; future = SettableFuture.create();
    @SuppressWarnings("unchecked")     FutureCallback&lt;String&gt; callback = Mockito.mock(FutureCallback.class);
    addCallback(future, callback, <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>directExecutor());
    Mockito.doThrow(error).when(callback).onSuccess(result);
    try {
      future.set(result);
      fail("Should have thrown");
<a name="5"></a>    } catch (TestError e) {
      assertSame</b></font>(error, e);
    }
    <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(result, future.get());
    Mockito.verify(callback).onSuccess(result);
    Mockito.verifyNoMoreInteractions(callback);
  }
  public void testWildcardFuture() {
    SettableFuture&lt;String&gt; settable = SettableFuture.create()</b></font>;
    ListenableFuture&lt;?&gt; f = settable;
    FutureCallback&lt;Object&gt; callback =
        new FutureCallback&lt;Object&gt;() {
          @Override
          public void onSuccess(Object result) {}
          @Override
          public void onFailure(Throwable t) {}
        };
    addCallback(f, callback, directExecutor());
  }
  private class CountingSameThreadExecutor implements Executor {
    int runCount = 0;
    @Override
    public void execute(Runnable command) {
      command.run();
      runCount++;
    }
  }
  private final class MockCallback implements FutureCallback&lt;String&gt; {
    @CheckForNull private String value = null;
    @CheckForNull private Throwable failure = null;
    private boolean wasCalled = false;
    MockCallback(String expectedValue) {
      this.value = expectedValue;
    }
    public MockCallback(Throwable expectedFailure) {
      this.failure = expectedFailure;
    }
    @Override
    public synchronized void onSuccess(String result) {
      assertFalse(wasCalled);
      wasCalled = true;
      assertEquals(value, result);
    }
    @Override
    public synchronized void onFailure(Throwable t) {
      assertFalse(wasCalled);
      wasCalled = true;
      assertEquals(failure, t);
    }
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractServiceTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.util.concurrent;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static java.lang.Thread.currentThread;
import static java.util.concurrent.TimeUnit.SECONDS;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.util.concurrent.Service.Listener;
import com.google.common.util.concurrent.Service.State;
import</b></font> com.google.errorprone.annotations.concurrent.GuardedBy;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import junit.framework.TestCase;
public class AbstractServiceTest extends TestCase {
  private static final long LONG_TIMEOUT_MILLIS = 10000;
  private Thread executionThread;
  private Throwable thrownByExecutionThread;
  public void testNoOpServiceStartStop() throws Exception {
    NoOpService service = new NoOpService();
    RecordingListener listener = RecordingListener.record(service);
    assertEquals(State.NEW, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.running);
<a name="0"></a>
    service.startAsync();
    assertEquals(State.RUNNING, service.state());
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(service.isRunning());
    assertTrue(service.running);
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.running);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
  public void testNoOpServiceStartAndWai</b></font>tStopAndWait() throws Exception {
<a name="5"></a>    NoOpService service = new NoOpService();
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.state());
    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
  }
  public void testNoOpServiceStartAsyncAndAwaitStopAsyncAndAwait() throws Exception {
    NoOpService service = new NoOpService()</b></font>;
<a name="3"></a>    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
  }
  public void testNoOpServiceStopIdempotence() throws Exception {
    NoOpService service = new NoOpService();
    RecordingListener listener = RecordingListener.record</b></font>(service);
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    service.stopAsync();
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
  public void testNoOpServiceStopIdempotenceAfterWait() throws Exception {
    NoOpService service = new NoOpService();
    service.startAsync().awaitRunning();
    service.stopAsync().awaitTerminated();
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
  }
  public void testNoOpServiceStopIdempotenceDoubleWait() throws Exception {
    NoOpService service = new NoOpService();
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    service.stopAsync().awaitTerminated();
    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
  }
  public void testNoOpServiceStartStopAndWaitUninterruptible() throws Exception {
    NoOpService service = new NoOpService();
    currentThread().interrupt();
    try {
      service.startAsync().awaitRunning();
      assertEquals(State.RUNNING, service.state());
      service.stopAsync().awaitTerminated();
      assertEquals(State.TERMINATED, service.state());
      assertTrue(currentThread().isInterrupted());
    } finally {
      Thread.interrupted();     }
  }
  private static class NoOpService extends AbstractService {
    boolean running = false;
    @Override
    protected void doStart() {
      assertFalse(running);
      running = true;
      notifyStarted();
    }
    @Override
    protected void doStop() {
      assertTrue(running);
      running = false;
      notifyStopped();
    }
  }
  public void testManualServiceStartStop() throws Exception {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    assertEquals(State.STARTING, service.state());
    assertFalse(service.isRunning());
    assertTrue(service.doStartCalled);
    service.notifyStarted();     assertEquals(State.RUNNING, service.state());
    assertTrue(service.isRunning());
    service.stopAsync();
    assertEquals(State.STOPPING, service.state());
    assertFalse(service.isRunning());
    assertTrue(service.doStopCalled);
    service.notifyStopped(); <a name="6"></a>    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertEquals(
        <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
  public void testManualServiceNotifyStoppedWhileRunning() throws Exception {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record</b></font>(service);
    service.startAsync();
    service.notifyStarted();
    service.notifyStopped();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.doStopCalled);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.TERMINATED),
        listener.getStateHistory());
  }
  public void testManualServiceStopWhileStarting() throws Exception {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    assertEquals(State.STARTING, service.state());
    assertFalse(service.isRunning());
    assertTrue(service.doStartCalled);
    service.stopAsync();
    assertEquals(State.STOPPING, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.doStopCalled);
    service.notifyStarted();
    assertEquals(State.STOPPING, service.state());
    assertFalse(service.isRunning());
    assertTrue(service.doStopCalled);
    service.notifyStopped();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertEquals(
        ImmutableList.of(State.STARTING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
  public void testManualServiceStopMultipleTimesWhileStarting() throws Exception {
    ManualSwitchedService service = new ManualSwitchedService();
    final AtomicInteger stoppingCount = new AtomicInteger();
    service.addListener(
        new Listener() {
          @Override
          public void stopping(State from) {
            stoppingCount.incrementAndGet();
          }
        },
        directExecutor());
    service.startAsync();
    service.stopAsync();
    assertEquals(1, stoppingCount.get());
    service.stopAsync();
    assertEquals(1, stoppingCount.get());
  }
  public void testManualServiceStopWhileNew() throws Exception {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.doStartCalled);
    assertFalse(service.doStopCalled);
    assertEquals(ImmutableList.of(State.TERMINATED), listener.getStateHistory());
  }
  public void testManualServiceFailWhileStarting() throws Exception {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    service.notifyFailed(EXCEPTION);
    assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
  }
  public void testManualServiceFailWhileRunning() throws Exception {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    service.notifyStarted();
    service.notifyFailed(EXCEPTION);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
  }
  public void testManualServiceFailWhileStopping() throws Exception {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    service.notifyStarted();
    service.stopAsync();
    service.notifyFailed(EXCEPTION);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
        listener.getStateHistory());
  }
  public void testManualServiceUnrequestedStop() {
    ManualSwitchedService service = new ManualSwitchedService();
    service.startAsync();
    service.notifyStarted();
    assertEquals(State.RUNNING, service.state());
    assertTrue(service.isRunning());
    assertFalse(service.doStopCalled);
    service.notifyStopped();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.doStopCalled);
  }
  private static class ManualSwitchedService extends AbstractService {
    boolean doStartCalled = false;
    boolean doStopCalled = false;
    @Override
    protected void doStart() {
      assertFalse(doStartCalled);
      doStartCalled = true;
    }
    @Override
    protected void doStop() {
      assertFalse(doStopCalled);
      doStopCalled = true;
    }
  }
  public void testAwaitTerminated() throws Exception {
    final NoOpService service = new NoOpService();
    Thread waiter =
        new Thread() {
          @Override
          public void run() {
            service.awaitTerminated();
          }
        };
    waiter.start();
<a name="2"></a>    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    service.stopAsync();
    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>waiter.join(LONG_TIMEOUT_MILLIS);     assertFalse(waiter.isAlive());
  }
  public void testAwaitTerminated_FailedService() throws Exception {
    final ManualSwitchedService service = new ManualSwitchedService();
    final AtomicReference&lt;Throwable&gt; exception = Atomics.newReference();
    Thread waiter =
        new</b></font> Thread() {
          @Override
          public void run() {
            try {
              service.awaitTerminated();
              fail("Expected an IllegalStateException");
            } catch (Throwable t) {
              exception.set(t);
            }
          }
        };
    waiter.start();
    service.startAsync();
    service.notifyStarted();
    assertEquals(State.RUNNING, service.state());
    service.notifyFailed(EXCEPTION);
    assertEquals(State.FAILED, service.state());
    waiter.join(LONG_TIMEOUT_MILLIS);
    assertFalse(waiter.isAlive());
    assertThat(exception.get()).isInstanceOf(IllegalStateException.class);
    assertThat(exception.get()).hasCauseThat().isEqualTo(EXCEPTION);
  }
  public void testThreadedServiceStartAndWaitStopAndWait() throws Throwable {
    ThreadedService service = new ThreadedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    service.awaitRunChecks();
    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
    throwIfSet(thrownByExecutionThread);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
  public void testThreadedServiceStopIdempotence() throws Throwable {
    ThreadedService service = new ThreadedService();
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    service.awaitRunChecks();
    service.stopAsync();
    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
    throwIfSet(thrownByExecutionThread);
  }
  public void testThreadedServiceStopIdempotenceAfterWait() throws Throwable {
    ThreadedService service = new ThreadedService();
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    service.awaitRunChecks();
    service.stopAsync().awaitTerminated();
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
    executionThread.join();
    throwIfSet(thrownByExecutionThread);
  }
  public void testThreadedServiceStopIdempotenceDoubleWait() throws Throwable {
    ThreadedService service = new ThreadedService();
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    service.awaitRunChecks();
    service.stopAsync().awaitTerminated();
    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
    throwIfSet(thrownByExecutionThread);
  }
  public void testManualServiceFailureIdempotence() {
    ManualSwitchedService service = new ManualSwitchedService();
    /*
     * Set up a RecordingListener to perform its built-in assertions, even though we won't look at
     * its state history.
     */
    RecordingListener unused = RecordingListener.record(service);
<a name="1"></a>    service.startAsync();
    service.notifyFailed(new Exception("1"));
    service.notifyFailed(new Exception("2"));
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(service.failureCause()).hasMessageThat().isEqualTo("1");
    try {
      service.awaitRunning();
      fail();
    } catch (IllegalStateException e) {
      assertThat(e).hasCauseThat().hasMessageThat().isEqualTo</b></font>("1");
    }
  }
  private class ThreadedService extends AbstractService {
    final CountDownLatch hasConfirmedIsRunning = new CountDownLatch(1);
    /*
     * The main test thread tries to stop() the service shortly after
     * confirming that it is running. Meanwhile, the service itself is trying
     * to confirm that it is running. If the main thread's stop() call happens
     * before it has the chance, the test will fail. To avoid this, the main
     * thread calls this method, which waits until the service has performed
     * its own "running" check.
     */
    void awaitRunChecks() throws InterruptedException {
      assertTrue(
          "Service thread hasn't finished its checks. "
              + "Exception status (possibly stale): "
              + thrownByExecutionThread,
          hasConfirmedIsRunning.await(10, SECONDS));
    }
    @Override
    protected void doStart() {
      assertEquals(State.STARTING, state());
      invokeOnExecutionThreadForTest(
          new Runnable() {
            @Override
            public void run() {
              assertEquals(State.STARTING, state());
              notifyStarted();
              assertEquals(State.RUNNING, state());
              hasConfirmedIsRunning.countDown();
            }
          });
    }
    @Override
    protected void doStop() {
      assertEquals(State.STOPPING, state());
      invokeOnExecutionThreadForTest(
          new Runnable() {
            @Override
            public void run() {
              assertEquals(State.STOPPING, state());
              notifyStopped();
              assertEquals(State.TERMINATED, state());
            }
          });
    }
  }
  private void invokeOnExecutionThreadForTest(Runnable runnable) {
    executionThread = new Thread(runnable);
    executionThread.setUncaughtExceptionHandler(
        new UncaughtExceptionHandler() {
          @Override
          public void uncaughtException(Thread thread, Throwable e) {
            thrownByExecutionThread = e;
          }
        });
    executionThread.start();
  }
  private static void throwIfSet(Throwable t) throws Throwable {
    if (t != null) {
      throw t;
    }
  }
  public void testStopUnstartedService() throws Exception {
    NoOpService service = new NoOpService();
    RecordingListener listener = RecordingListener.record(service);
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
    try {
      service.startAsync();
      fail();
    } catch (IllegalStateException expected) {
    }
    assertEquals(State.TERMINATED, Iterables.getOnlyElement(listener.getStateHistory()));
  }
  public void testFailingServiceStartAndWait() throws Exception {
    StartFailingService service = new StartFailingService();
    RecordingListener listener = RecordingListener.record(service);
    try {
      service.startAsync().awaitRunning();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(EXCEPTION, service.failureCause());
      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
    }
    assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
  }
  public void testFailingServiceStopAndWait_stopFailing() throws Exception {
    StopFailingService service = new StopFailingService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync().awaitRunning();
    try {
      service.stopAsync().awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(EXCEPTION, service.failureCause());
      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
    }
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
        listener.getStateHistory());
  }
  public void testFailingServiceStopAndWait_runFailing() throws Exception {
    RunFailingService service = new RunFailingService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    try {
      service.awaitRunning();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(EXCEPTION, service.failureCause());
      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
    }
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
  }
  public void testThrowingServiceStartAndWait() throws Exception {
    StartThrowingService service = new StartThrowingService();
    RecordingListener listener = RecordingListener.record(service);
    try {
      service.startAsync().awaitRunning();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(service.exception, service.failureCause());
      assertThat(e).hasCauseThat().isEqualTo(service.exception);
    }
    assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
  }
  public void testThrowingServiceStopAndWait_stopThrowing() throws Exception {
    StopThrowingService service = new StopThrowingService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync().awaitRunning();
    try {
      service.stopAsync().awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(service.exception, service.failureCause());
      assertThat(e).hasCauseThat().isEqualTo(service.exception);
    }
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
        listener.getStateHistory());
  }
  public void testThrowingServiceStopAndWait_runThrowing() throws Exception {
    RunThrowingService service = new RunThrowingService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    try {
      service.awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(service.exception, service.failureCause());
      assertThat(e).hasCauseThat().isEqualTo(service.exception);
    }
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
  }
  public void testFailureCause_throwsIfNotFailed() {
    StopFailingService service = new StopFailingService();
    try {
      service.failureCause();
      fail();
    } catch (IllegalStateException expected) {
    }
    service.startAsync().awaitRunning();
    try {
      service.failureCause();
      fail();
    } catch (IllegalStateException expected) {
    }
    try {
      service.stopAsync().awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(EXCEPTION, service.failureCause());
      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
    }
  }
  public void testAddListenerAfterFailureDoesntCauseDeadlock() throws InterruptedException {
    final StartFailingService service = new StartFailingService();
    service.startAsync();
    assertEquals(State.FAILED, service.state());
    service.addListener(new RecordingListener(service), directExecutor());
    Thread thread =
        new Thread() {
          @Override
          public void run() {
            service.stopAsync();
          }
        };
    thread.start();
    thread.join(LONG_TIMEOUT_MILLIS);
    assertFalse(thread + " is deadlocked", thread.isAlive());
  }
  public void testListenerDoesntDeadlockOnStartAndWaitFromRunning() throws Exception {
    final NoOpThreadedService service = new NoOpThreadedService();
    service.addListener(
        new Listener() {
          @Override
          public void running() {
            service.awaitRunning();
          }
        },
        directExecutor());
    service.startAsync().awaitRunning(LONG_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    service.stopAsync();
  }
  public void testListenerDoesntDeadlockOnStopAndWaitFromTerminated() throws Exception {
    final NoOpThreadedService service = new NoOpThreadedService();
    service.addListener(
        new Listener() {
          @Override
          public void terminated(State from) {
            service.stopAsync().awaitTerminated();
          }
        },
        directExecutor());
    service.startAsync().awaitRunning();
    Thread thread =
        new Thread() {
          @Override
          public void run() {
            service.stopAsync().awaitTerminated();
          }
        };
    thread.start();
    thread.join(LONG_TIMEOUT_MILLIS);
    assertFalse(thread + " is deadlocked", thread.isAlive());
  }
  private static class NoOpThreadedService extends AbstractExecutionThreadService {
    final CountDownLatch latch = new CountDownLatch(1);
    @Override
    protected void run() throws Exception {
      latch.await();
    }
    @Override
    protected void triggerShutdown() {
      latch.countDown();
    }
  }
  private static class StartFailingService extends AbstractService {
    @Override
    protected void doStart() {
      notifyFailed(EXCEPTION);
    }
    @Override
    protected void doStop() {
      fail();
    }
  }
  private static class RunFailingService extends AbstractService {
    @Override
    protected void doStart() {
      notifyStarted();
      notifyFailed(EXCEPTION);
    }
    @Override
    protected void doStop() {
      fail();
    }
  }
  private static class StopFailingService extends AbstractService {
    @Override
    protected void doStart() {
      notifyStarted();
    }
    @Override
    protected void doStop() {
      notifyFailed(EXCEPTION);
    }
  }
  private static class StartThrowingService extends AbstractService {
    final RuntimeException exception = new RuntimeException("deliberate");
    @Override
    protected void doStart() {
      throw exception;
    }
    @Override
    protected void doStop() {
      fail();
    }
  }
  private static class RunThrowingService extends AbstractService {
    final RuntimeException exception = new RuntimeException("deliberate");
    @Override
    protected void doStart() {
      notifyStarted();
      throw exception;
    }
    @Override
    protected void doStop() {
      fail();
    }
  }
  private static class StopThrowingService extends AbstractService {
    final RuntimeException exception = new RuntimeException("deliberate");
    @Override
    protected void doStart() {
      notifyStarted();
    }
    @Override
    protected void doStop() {
      throw exception;
    }
  }
  private static class RecordingListener extends Listener {
    static RecordingListener record(Service service) {
      RecordingListener listener = new RecordingListener(service);
      service.addListener(listener, directExecutor());
      return listener;
    }
    final Service service;
    RecordingListener(Service service) {
      this.service = service;
    }
    @GuardedBy("this")
    final List&lt;State&gt; stateHistory = Lists.newArrayList();
    final CountDownLatch completionLatch = new CountDownLatch(1);
    ImmutableList&lt;State&gt; getStateHistory() throws Exception {
      completionLatch.await();
      synchronized (this) {
        return ImmutableList.copyOf(stateHistory);
      }
    }
    @Override
    public synchronized void starting() {
      assertTrue(stateHistory.isEmpty());
      assertNotSame(State.NEW, service.state());
      stateHistory.add(State.STARTING);
    }
    @Override
    public synchronized void running() {
<a name="7"></a>      assertEquals(State.STARTING, Iterables.getOnlyElement(stateHistory));
      stateHistory.add(State.RUNNING);
      service.awaitRunning();
      assertNotSame(State.STARTING, <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.state());
    }
    @Override
    public synchronized void stopping(State from) {
      assertEquals(from, Iterables.getLast(stateHistory));
      stateHistory.add</b></font>(State.STOPPING);
      if (from == State.STARTING) {
        try {
          service.awaitRunning();
          fail();
        } catch (IllegalStateException expected) {
          assertThat(expected).hasCauseThat().isNull();
          assertThat(expected)
              .hasMessageThat()
              .isEqualTo("Expected the service " + service + " to be RUNNING, but was STOPPING");
        }
      }
      assertNotSame(from, service.state());
    }
    @Override
    public synchronized void terminated(State from) {
      assertEquals(from, Iterables.getLast(stateHistory, State.NEW));
      stateHistory.add(State.TERMINATED);
      assertEquals(State.TERMINATED, service.state());
      if (from == State.NEW) {
        try {
          service.awaitRunning();
          fail();
        } catch (IllegalStateException expected) {
          assertThat(expected).hasCauseThat().isNull();
          assertThat(expected)
              .hasMessageThat()
              .isEqualTo("Expected the service " + service + " to be RUNNING, but was TERMINATED");
        }
      }
      completionLatch.countDown();
    }
    @Override
    public synchronized void failed(State from, Throwable failure) {
      assertEquals(from, Iterables.getLast(stateHistory));
      stateHistory.add(State.FAILED);
      assertEquals(State.FAILED, service.state());
      assertEquals(failure, service.failureCause());
      if (from == State.STARTING) {
        try {
          service.awaitRunning();
          fail();
        } catch (IllegalStateException e) {
          assertThat(e).hasCauseThat().isEqualTo(failure);
        }
      }
      try {
        service.awaitTerminated();
        fail();
      } catch (IllegalStateException e) {
        assertThat(e).hasCauseThat().isEqualTo(failure);
      }
      completionLatch.countDown();
    }
  }
  public void testNotifyStartedWhenNotStarting() {
    AbstractService service = new DefaultService();
    try {
      service.notifyStarted();
      fail();
    } catch (IllegalStateException expected) {
    }
  }
  public void testNotifyStoppedWhenNotRunning() {
    AbstractService service = new DefaultService();
    try {
      service.notifyStopped();
      fail();
    } catch (IllegalStateException expected) {
    }
  }
  public void testNotifyFailedWhenNotStarted() {
    AbstractService service = new DefaultService();
    try {
      service.notifyFailed(new Exception());
      fail();
    } catch (IllegalStateException expected) {
    }
  }
  public void testNotifyFailedWhenTerminated() {
    NoOpService service = new NoOpService();
    service.startAsync().awaitRunning();
    service.stopAsync().awaitTerminated();
    try {
      service.notifyFailed(new Exception());
      fail();
    } catch (IllegalStateException expected) {
    }
  }
  private static class DefaultService extends AbstractService {
    @Override
    protected void doStart() {}
    @Override
    protected void doStop() {}
  }
  private static final Exception EXCEPTION = new Exception();
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
