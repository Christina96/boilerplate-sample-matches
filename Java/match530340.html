<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for FutureCallbackTest_1.java &amp; AbstractServiceTest_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for FutureCallbackTest_1.java &amp; AbstractServiceTest_1.java
      </h3>
<h1 align="center">
        11.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>FutureCallbackTest_1.java (38.912132%)<th>AbstractServiceTest_1.java (7.083016%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(105-114)<td><a href="#" name="0">(59-71)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(122-128)<td><a href="#" name="1">(451-456)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(41-48)<td><a href="#" name="2">(346-354)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(81-87)<td><a href="#" name="3">(87-93)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(17-29)<td><a href="#" name="4">(17-29)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(130-136)<td><a href="#" name="5">(75-82)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(89-94)<td><a href="#" name="6">(183-189)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(71-77)<td><a href="#" name="7">(849-855)</a><td align="center"><font color="#aa0000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FutureCallbackTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.util.concurrent;
2 import static com.google.common.truth.Truth.assertThat;
3 import static com.google.common.util.concurrent.Futures.addCallback;
4 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
5 import com.google.common.annotations.GwtCompatible;
6 import com.google.common.annotations.GwtIncompatible;
7 import java.util.concurrent.CancellationException;
8 import java.util.concurrent.Executor;
9 import javax.annotation.CheckForNull;
10 import junit.framework.TestCase;
11 import</b></font> org.mockito.Mockito;
12 @GwtCompatible(emulated = true)
13 public class FutureCallbackTest extends TestCase {
14 <a name="2"></a>  public void testSameThreadSuccess() {
15     SettableFuture&lt;String&gt; f = SettableFuture.create();
16     MockCallback callback = new MockCallback("foo");
17     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>addCallback(f, callback, directExecutor());
18     f.set("foo");
19   }
20   public void testExecutorSuccess() {
21     CountingSameThreadExecutor ex = new CountingSameThreadExecutor();
22     SettableFuture&lt;String&gt; f = SettableFuture.create();
23     MockCallback callback = new</b></font> MockCallback("foo");
24     Futures.addCallback(f, callback, ex);
25     f.set("foo");
26     assertEquals(1, ex.runCount);
27   }
28   public void testSameThreadExecutionException() {
29     SettableFuture&lt;String&gt; f = SettableFuture.create();
30     Exception e = new IllegalArgumentException("foo not found");
31     MockCallback callback = new MockCallback(e);
32     addCallback(f, callback, directExecutor());
33     f.setException(e);
34   }
35   public void testCancel() {
36     SettableFuture&lt;String&gt; f = SettableFuture.create();
37     FutureCallback&lt;String&gt; callback =
38         new FutureCallback&lt;String&gt;() {
39           private boolean called = false;
40 <a name="7"></a>
41           @Override
42           public void onSuccess(String result) {
43             <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>fail("Was not expecting onSuccess() to be called.");
44           }
45           @Override
46           public synchronized void onFailure(Throwable t) {
47             assertFalse(called);
48             assertThat</b></font>(t).isInstanceOf(CancellationException.class);
49 <a name="3"></a>            called = true;
50           }
51         };
52     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>addCallback(f, callback, directExecutor());
53     f.cancel(true);
54   }
55   public void testThrowErrorFromGet() {
56 <a name="6"></a>    Error error = new AssertionError("ASSERT!");
57     ListenableFuture&lt;String&gt; f = UncheckedThrowingFuture.throwingError</b></font>(error);
58     MockCallback callback = new MockCallback(error);
59     <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>addCallback(f, callback, directExecutor());
60   }
61   public void testRuntimeExeceptionFromGet() {
62     RuntimeException e = new IllegalArgumentException("foo not found");
63     ListenableFuture&lt;String&gt; f = UncheckedThrowingFuture.throwingRuntimeException</b></font>(e);
64     MockCallback callback = new MockCallback(e);
65     addCallback(f, callback, directExecutor());
66   }
67   @GwtIncompatible   public void testOnSuccessThrowsRuntimeException() throws Exception {
68     RuntimeException exception = new RuntimeException();
69 <a name="0"></a>    String result = "result";
70     SettableFuture&lt;String&gt; future = SettableFuture.create();
71     @SuppressWarnings("unchecked")     FutureCallback&lt;String&gt; callback = <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Mockito.mock(FutureCallback.class);
72     addCallback(future, callback, directExecutor());
73     Mockito.doThrow(exception).when(callback).onSuccess(result);
74     future.set(result);
75     assertEquals(result, future.get());
76     Mockito.verify(callback).onSuccess(result);
77     Mockito.verifyNoMoreInteractions(callback);
78   }
79   @GwtIncompatible   public void testOnSuccessThrowsError() throws Exception {
80     class TestError extends Error {}
81     TestError error = new TestError();
82     String result = "result";
83 <a name="1"></a>    SettableFuture&lt;String&gt; future = SettableFuture.create();
84     @SuppressWarnings("unchecked")     FutureCallback&lt;String&gt; callback = Mockito.mock(FutureCallback.class);
85     addCallback(future, callback, <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>directExecutor());
86     Mockito.doThrow(error).when(callback).onSuccess(result);
87     try {
88       future.set(result);
89       fail("Should have thrown");
90 <a name="5"></a>    } catch (TestError e) {
91       assertSame</b></font>(error, e);
92     }
93     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(result, future.get());
94     Mockito.verify(callback).onSuccess(result);
95     Mockito.verifyNoMoreInteractions(callback);
96   }
97   public void testWildcardFuture() {
98     SettableFuture&lt;String&gt; settable = SettableFuture.create()</b></font>;
99     ListenableFuture&lt;?&gt; f = settable;
100     FutureCallback&lt;Object&gt; callback =
101         new FutureCallback&lt;Object&gt;() {
102           @Override
103           public void onSuccess(Object result) {}
104           @Override
105           public void onFailure(Throwable t) {}
106         };
107     addCallback(f, callback, directExecutor());
108   }
109   private class CountingSameThreadExecutor implements Executor {
110     int runCount = 0;
111     @Override
112     public void execute(Runnable command) {
113       command.run();
114       runCount++;
115     }
116   }
117   private final class MockCallback implements FutureCallback&lt;String&gt; {
118     @CheckForNull private String value = null;
119     @CheckForNull private Throwable failure = null;
120     private boolean wasCalled = false;
121     MockCallback(String expectedValue) {
122       this.value = expectedValue;
123     }
124     public MockCallback(Throwable expectedFailure) {
125       this.failure = expectedFailure;
126     }
127     @Override
128     public synchronized void onSuccess(String result) {
129       assertFalse(wasCalled);
130       wasCalled = true;
131       assertEquals(value, result);
132     }
133     @Override
134     public synchronized void onFailure(Throwable t) {
135       assertFalse(wasCalled);
136       wasCalled = true;
137       assertEquals(failure, t);
138     }
139   }
140 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractServiceTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.util.concurrent;
2 import static com.google.common.truth.Truth.assertThat;
3 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
4 import static java.lang.Thread.currentThread;
5 import static java.util.concurrent.TimeUnit.SECONDS;
6 import com.google.common.collect.ImmutableList;
7 import com.google.common.collect.Iterables;
8 import com.google.common.collect.Lists;
9 import com.google.common.util.concurrent.Service.Listener;
10 import com.google.common.util.concurrent.Service.State;
11 import</b></font> com.google.errorprone.annotations.concurrent.GuardedBy;
12 import java.lang.Thread.UncaughtExceptionHandler;
13 import java.util.List;
14 import java.util.concurrent.CountDownLatch;
15 import java.util.concurrent.TimeUnit;
16 import java.util.concurrent.atomic.AtomicInteger;
17 import java.util.concurrent.atomic.AtomicReference;
18 import junit.framework.TestCase;
19 public class AbstractServiceTest extends TestCase {
20   private static final long LONG_TIMEOUT_MILLIS = 10000;
21   private Thread executionThread;
22   private Throwable thrownByExecutionThread;
23   public void testNoOpServiceStartStop() throws Exception {
24     NoOpService service = new NoOpService();
25     RecordingListener listener = RecordingListener.record(service);
26     assertEquals(State.NEW, service.state());
27     assertFalse(service.isRunning());
28     assertFalse(service.running);
29 <a name="0"></a>
30     service.startAsync();
31     assertEquals(State.RUNNING, service.state());
32     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(service.isRunning());
33     assertTrue(service.running);
34     service.stopAsync();
35     assertEquals(State.TERMINATED, service.state());
36     assertFalse(service.isRunning());
37     assertFalse(service.running);
38     assertEquals(
39         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
40         listener.getStateHistory());
41   }
42   public void testNoOpServiceStartAndWai</b></font>tStopAndWait() throws Exception {
43 <a name="5"></a>    NoOpService service = new NoOpService();
44     service.startAsync().awaitRunning();
45     assertEquals(State.RUNNING, <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.state());
46     service.stopAsync().awaitTerminated();
47     assertEquals(State.TERMINATED, service.state());
48   }
49   public void testNoOpServiceStartAsyncAndAwaitStopAsyncAndAwait() throws Exception {
50     NoOpService service = new NoOpService()</b></font>;
51 <a name="3"></a>    service.startAsync().awaitRunning();
52     assertEquals(State.RUNNING, service.state());
53     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.stopAsync().awaitTerminated();
54     assertEquals(State.TERMINATED, service.state());
55   }
56   public void testNoOpServiceStopIdempotence() throws Exception {
57     NoOpService service = new NoOpService();
58     RecordingListener listener = RecordingListener.record</b></font>(service);
59     service.startAsync().awaitRunning();
60     assertEquals(State.RUNNING, service.state());
61     service.stopAsync();
62     service.stopAsync();
63     assertEquals(State.TERMINATED, service.state());
64     assertEquals(
65         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
66         listener.getStateHistory());
67   }
68   public void testNoOpServiceStopIdempotenceAfterWait() throws Exception {
69     NoOpService service = new NoOpService();
70     service.startAsync().awaitRunning();
71     service.stopAsync().awaitTerminated();
72     service.stopAsync();
73     assertEquals(State.TERMINATED, service.state());
74   }
75   public void testNoOpServiceStopIdempotenceDoubleWait() throws Exception {
76     NoOpService service = new NoOpService();
77     service.startAsync().awaitRunning();
78     assertEquals(State.RUNNING, service.state());
79     service.stopAsync().awaitTerminated();
80     service.stopAsync().awaitTerminated();
81     assertEquals(State.TERMINATED, service.state());
82   }
83   public void testNoOpServiceStartStopAndWaitUninterruptible() throws Exception {
84     NoOpService service = new NoOpService();
85     currentThread().interrupt();
86     try {
87       service.startAsync().awaitRunning();
88       assertEquals(State.RUNNING, service.state());
89       service.stopAsync().awaitTerminated();
90       assertEquals(State.TERMINATED, service.state());
91       assertTrue(currentThread().isInterrupted());
92     } finally {
93       Thread.interrupted();     }
94   }
95   private static class NoOpService extends AbstractService {
96     boolean running = false;
97     @Override
98     protected void doStart() {
99       assertFalse(running);
100       running = true;
101       notifyStarted();
102     }
103     @Override
104     protected void doStop() {
105       assertTrue(running);
106       running = false;
107       notifyStopped();
108     }
109   }
110   public void testManualServiceStartStop() throws Exception {
111     ManualSwitchedService service = new ManualSwitchedService();
112     RecordingListener listener = RecordingListener.record(service);
113     service.startAsync();
114     assertEquals(State.STARTING, service.state());
115     assertFalse(service.isRunning());
116     assertTrue(service.doStartCalled);
117     service.notifyStarted();     assertEquals(State.RUNNING, service.state());
118     assertTrue(service.isRunning());
119     service.stopAsync();
120     assertEquals(State.STOPPING, service.state());
121     assertFalse(service.isRunning());
122     assertTrue(service.doStopCalled);
123     service.notifyStopped(); <a name="6"></a>    assertEquals(State.TERMINATED, service.state());
124     assertFalse(service.isRunning());
125     assertEquals(
126         <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
127         listener.getStateHistory());
128   }
129   public void testManualServiceNotifyStoppedWhileRunning() throws Exception {
130     ManualSwitchedService service = new ManualSwitchedService();
131     RecordingListener listener = RecordingListener.record</b></font>(service);
132     service.startAsync();
133     service.notifyStarted();
134     service.notifyStopped();
135     assertEquals(State.TERMINATED, service.state());
136     assertFalse(service.isRunning());
137     assertFalse(service.doStopCalled);
138     assertEquals(
139         ImmutableList.of(State.STARTING, State.RUNNING, State.TERMINATED),
140         listener.getStateHistory());
141   }
142   public void testManualServiceStopWhileStarting() throws Exception {
143     ManualSwitchedService service = new ManualSwitchedService();
144     RecordingListener listener = RecordingListener.record(service);
145     service.startAsync();
146     assertEquals(State.STARTING, service.state());
147     assertFalse(service.isRunning());
148     assertTrue(service.doStartCalled);
149     service.stopAsync();
150     assertEquals(State.STOPPING, service.state());
151     assertFalse(service.isRunning());
152     assertFalse(service.doStopCalled);
153     service.notifyStarted();
154     assertEquals(State.STOPPING, service.state());
155     assertFalse(service.isRunning());
156     assertTrue(service.doStopCalled);
157     service.notifyStopped();
158     assertEquals(State.TERMINATED, service.state());
159     assertFalse(service.isRunning());
160     assertEquals(
161         ImmutableList.of(State.STARTING, State.STOPPING, State.TERMINATED),
162         listener.getStateHistory());
163   }
164   public void testManualServiceStopMultipleTimesWhileStarting() throws Exception {
165     ManualSwitchedService service = new ManualSwitchedService();
166     final AtomicInteger stoppingCount = new AtomicInteger();
167     service.addListener(
168         new Listener() {
169           @Override
170           public void stopping(State from) {
171             stoppingCount.incrementAndGet();
172           }
173         },
174         directExecutor());
175     service.startAsync();
176     service.stopAsync();
177     assertEquals(1, stoppingCount.get());
178     service.stopAsync();
179     assertEquals(1, stoppingCount.get());
180   }
181   public void testManualServiceStopWhileNew() throws Exception {
182     ManualSwitchedService service = new ManualSwitchedService();
183     RecordingListener listener = RecordingListener.record(service);
184     service.stopAsync();
185     assertEquals(State.TERMINATED, service.state());
186     assertFalse(service.isRunning());
187     assertFalse(service.doStartCalled);
188     assertFalse(service.doStopCalled);
189     assertEquals(ImmutableList.of(State.TERMINATED), listener.getStateHistory());
190   }
191   public void testManualServiceFailWhileStarting() throws Exception {
192     ManualSwitchedService service = new ManualSwitchedService();
193     RecordingListener listener = RecordingListener.record(service);
194     service.startAsync();
195     service.notifyFailed(EXCEPTION);
196     assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
197   }
198   public void testManualServiceFailWhileRunning() throws Exception {
199     ManualSwitchedService service = new ManualSwitchedService();
200     RecordingListener listener = RecordingListener.record(service);
201     service.startAsync();
202     service.notifyStarted();
203     service.notifyFailed(EXCEPTION);
204     assertEquals(
205         ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
206   }
207   public void testManualServiceFailWhileStopping() throws Exception {
208     ManualSwitchedService service = new ManualSwitchedService();
209     RecordingListener listener = RecordingListener.record(service);
210     service.startAsync();
211     service.notifyStarted();
212     service.stopAsync();
213     service.notifyFailed(EXCEPTION);
214     assertEquals(
215         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
216         listener.getStateHistory());
217   }
218   public void testManualServiceUnrequestedStop() {
219     ManualSwitchedService service = new ManualSwitchedService();
220     service.startAsync();
221     service.notifyStarted();
222     assertEquals(State.RUNNING, service.state());
223     assertTrue(service.isRunning());
224     assertFalse(service.doStopCalled);
225     service.notifyStopped();
226     assertEquals(State.TERMINATED, service.state());
227     assertFalse(service.isRunning());
228     assertFalse(service.doStopCalled);
229   }
230   private static class ManualSwitchedService extends AbstractService {
231     boolean doStartCalled = false;
232     boolean doStopCalled = false;
233     @Override
234     protected void doStart() {
235       assertFalse(doStartCalled);
236       doStartCalled = true;
237     }
238     @Override
239     protected void doStop() {
240       assertFalse(doStopCalled);
241       doStopCalled = true;
242     }
243   }
244   public void testAwaitTerminated() throws Exception {
245     final NoOpService service = new NoOpService();
246     Thread waiter =
247         new Thread() {
248           @Override
249           public void run() {
250             service.awaitTerminated();
251           }
252         };
253     waiter.start();
254 <a name="2"></a>    service.startAsync().awaitRunning();
255     assertEquals(State.RUNNING, service.state());
256     service.stopAsync();
257     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>waiter.join(LONG_TIMEOUT_MILLIS);     assertFalse(waiter.isAlive());
258   }
259   public void testAwaitTerminated_FailedService() throws Exception {
260     final ManualSwitchedService service = new ManualSwitchedService();
261     final AtomicReference&lt;Throwable&gt; exception = Atomics.newReference();
262     Thread waiter =
263         new</b></font> Thread() {
264           @Override
265           public void run() {
266             try {
267               service.awaitTerminated();
268               fail("Expected an IllegalStateException");
269             } catch (Throwable t) {
270               exception.set(t);
271             }
272           }
273         };
274     waiter.start();
275     service.startAsync();
276     service.notifyStarted();
277     assertEquals(State.RUNNING, service.state());
278     service.notifyFailed(EXCEPTION);
279     assertEquals(State.FAILED, service.state());
280     waiter.join(LONG_TIMEOUT_MILLIS);
281     assertFalse(waiter.isAlive());
282     assertThat(exception.get()).isInstanceOf(IllegalStateException.class);
283     assertThat(exception.get()).hasCauseThat().isEqualTo(EXCEPTION);
284   }
285   public void testThreadedServiceStartAndWaitStopAndWait() throws Throwable {
286     ThreadedService service = new ThreadedService();
287     RecordingListener listener = RecordingListener.record(service);
288     service.startAsync().awaitRunning();
289     assertEquals(State.RUNNING, service.state());
290     service.awaitRunChecks();
291     service.stopAsync().awaitTerminated();
292     assertEquals(State.TERMINATED, service.state());
293     throwIfSet(thrownByExecutionThread);
294     assertEquals(
295         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
296         listener.getStateHistory());
297   }
298   public void testThreadedServiceStopIdempotence() throws Throwable {
299     ThreadedService service = new ThreadedService();
300     service.startAsync().awaitRunning();
301     assertEquals(State.RUNNING, service.state());
302     service.awaitRunChecks();
303     service.stopAsync();
304     service.stopAsync().awaitTerminated();
305     assertEquals(State.TERMINATED, service.state());
306     throwIfSet(thrownByExecutionThread);
307   }
308   public void testThreadedServiceStopIdempotenceAfterWait() throws Throwable {
309     ThreadedService service = new ThreadedService();
310     service.startAsync().awaitRunning();
311     assertEquals(State.RUNNING, service.state());
312     service.awaitRunChecks();
313     service.stopAsync().awaitTerminated();
314     service.stopAsync();
315     assertEquals(State.TERMINATED, service.state());
316     executionThread.join();
317     throwIfSet(thrownByExecutionThread);
318   }
319   public void testThreadedServiceStopIdempotenceDoubleWait() throws Throwable {
320     ThreadedService service = new ThreadedService();
321     service.startAsync().awaitRunning();
322     assertEquals(State.RUNNING, service.state());
323     service.awaitRunChecks();
324     service.stopAsync().awaitTerminated();
325     service.stopAsync().awaitTerminated();
326     assertEquals(State.TERMINATED, service.state());
327     throwIfSet(thrownByExecutionThread);
328   }
329   public void testManualServiceFailureIdempotence() {
330     ManualSwitchedService service = new ManualSwitchedService();
331     /*
332      * Set up a RecordingListener to perform its built-in assertions, even though we won't look at
333      * its state history.
334      */
335     RecordingListener unused = RecordingListener.record(service);
336 <a name="1"></a>    service.startAsync();
337     service.notifyFailed(new Exception("1"));
338     service.notifyFailed(new Exception("2"));
339     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(service.failureCause()).hasMessageThat().isEqualTo("1");
340     try {
341       service.awaitRunning();
342       fail();
343     } catch (IllegalStateException e) {
344       assertThat(e).hasCauseThat().hasMessageThat().isEqualTo</b></font>("1");
345     }
346   }
347   private class ThreadedService extends AbstractService {
348     final CountDownLatch hasConfirmedIsRunning = new CountDownLatch(1);
349     /*
350      * The main test thread tries to stop() the service shortly after
351      * confirming that it is running. Meanwhile, the service itself is trying
352      * to confirm that it is running. If the main thread's stop() call happens
353      * before it has the chance, the test will fail. To avoid this, the main
354      * thread calls this method, which waits until the service has performed
355      * its own "running" check.
356      */
357     void awaitRunChecks() throws InterruptedException {
358       assertTrue(
359           "Service thread hasn't finished its checks. "
360               + "Exception status (possibly stale): "
361               + thrownByExecutionThread,
362           hasConfirmedIsRunning.await(10, SECONDS));
363     }
364     @Override
365     protected void doStart() {
366       assertEquals(State.STARTING, state());
367       invokeOnExecutionThreadForTest(
368           new Runnable() {
369             @Override
370             public void run() {
371               assertEquals(State.STARTING, state());
372               notifyStarted();
373               assertEquals(State.RUNNING, state());
374               hasConfirmedIsRunning.countDown();
375             }
376           });
377     }
378     @Override
379     protected void doStop() {
380       assertEquals(State.STOPPING, state());
381       invokeOnExecutionThreadForTest(
382           new Runnable() {
383             @Override
384             public void run() {
385               assertEquals(State.STOPPING, state());
386               notifyStopped();
387               assertEquals(State.TERMINATED, state());
388             }
389           });
390     }
391   }
392   private void invokeOnExecutionThreadForTest(Runnable runnable) {
393     executionThread = new Thread(runnable);
394     executionThread.setUncaughtExceptionHandler(
395         new UncaughtExceptionHandler() {
396           @Override
397           public void uncaughtException(Thread thread, Throwable e) {
398             thrownByExecutionThread = e;
399           }
400         });
401     executionThread.start();
402   }
403   private static void throwIfSet(Throwable t) throws Throwable {
404     if (t != null) {
405       throw t;
406     }
407   }
408   public void testStopUnstartedService() throws Exception {
409     NoOpService service = new NoOpService();
410     RecordingListener listener = RecordingListener.record(service);
411     service.stopAsync();
412     assertEquals(State.TERMINATED, service.state());
413     try {
414       service.startAsync();
415       fail();
416     } catch (IllegalStateException expected) {
417     }
418     assertEquals(State.TERMINATED, Iterables.getOnlyElement(listener.getStateHistory()));
419   }
420   public void testFailingServiceStartAndWait() throws Exception {
421     StartFailingService service = new StartFailingService();
422     RecordingListener listener = RecordingListener.record(service);
423     try {
424       service.startAsync().awaitRunning();
425       fail();
426     } catch (IllegalStateException e) {
427       assertEquals(EXCEPTION, service.failureCause());
428       assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
429     }
430     assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
431   }
432   public void testFailingServiceStopAndWait_stopFailing() throws Exception {
433     StopFailingService service = new StopFailingService();
434     RecordingListener listener = RecordingListener.record(service);
435     service.startAsync().awaitRunning();
436     try {
437       service.stopAsync().awaitTerminated();
438       fail();
439     } catch (IllegalStateException e) {
440       assertEquals(EXCEPTION, service.failureCause());
441       assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
442     }
443     assertEquals(
444         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
445         listener.getStateHistory());
446   }
447   public void testFailingServiceStopAndWait_runFailing() throws Exception {
448     RunFailingService service = new RunFailingService();
449     RecordingListener listener = RecordingListener.record(service);
450     service.startAsync();
451     try {
452       service.awaitRunning();
453       fail();
454     } catch (IllegalStateException e) {
455       assertEquals(EXCEPTION, service.failureCause());
456       assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
457     }
458     assertEquals(
459         ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
460   }
461   public void testThrowingServiceStartAndWait() throws Exception {
462     StartThrowingService service = new StartThrowingService();
463     RecordingListener listener = RecordingListener.record(service);
464     try {
465       service.startAsync().awaitRunning();
466       fail();
467     } catch (IllegalStateException e) {
468       assertEquals(service.exception, service.failureCause());
469       assertThat(e).hasCauseThat().isEqualTo(service.exception);
470     }
471     assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
472   }
473   public void testThrowingServiceStopAndWait_stopThrowing() throws Exception {
474     StopThrowingService service = new StopThrowingService();
475     RecordingListener listener = RecordingListener.record(service);
476     service.startAsync().awaitRunning();
477     try {
478       service.stopAsync().awaitTerminated();
479       fail();
480     } catch (IllegalStateException e) {
481       assertEquals(service.exception, service.failureCause());
482       assertThat(e).hasCauseThat().isEqualTo(service.exception);
483     }
484     assertEquals(
485         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
486         listener.getStateHistory());
487   }
488   public void testThrowingServiceStopAndWait_runThrowing() throws Exception {
489     RunThrowingService service = new RunThrowingService();
490     RecordingListener listener = RecordingListener.record(service);
491     service.startAsync();
492     try {
493       service.awaitTerminated();
494       fail();
495     } catch (IllegalStateException e) {
496       assertEquals(service.exception, service.failureCause());
497       assertThat(e).hasCauseThat().isEqualTo(service.exception);
498     }
499     assertEquals(
500         ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
501   }
502   public void testFailureCause_throwsIfNotFailed() {
503     StopFailingService service = new StopFailingService();
504     try {
505       service.failureCause();
506       fail();
507     } catch (IllegalStateException expected) {
508     }
509     service.startAsync().awaitRunning();
510     try {
511       service.failureCause();
512       fail();
513     } catch (IllegalStateException expected) {
514     }
515     try {
516       service.stopAsync().awaitTerminated();
517       fail();
518     } catch (IllegalStateException e) {
519       assertEquals(EXCEPTION, service.failureCause());
520       assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
521     }
522   }
523   public void testAddListenerAfterFailureDoesntCauseDeadlock() throws InterruptedException {
524     final StartFailingService service = new StartFailingService();
525     service.startAsync();
526     assertEquals(State.FAILED, service.state());
527     service.addListener(new RecordingListener(service), directExecutor());
528     Thread thread =
529         new Thread() {
530           @Override
531           public void run() {
532             service.stopAsync();
533           }
534         };
535     thread.start();
536     thread.join(LONG_TIMEOUT_MILLIS);
537     assertFalse(thread + " is deadlocked", thread.isAlive());
538   }
539   public void testListenerDoesntDeadlockOnStartAndWaitFromRunning() throws Exception {
540     final NoOpThreadedService service = new NoOpThreadedService();
541     service.addListener(
542         new Listener() {
543           @Override
544           public void running() {
545             service.awaitRunning();
546           }
547         },
548         directExecutor());
549     service.startAsync().awaitRunning(LONG_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
550     service.stopAsync();
551   }
552   public void testListenerDoesntDeadlockOnStopAndWaitFromTerminated() throws Exception {
553     final NoOpThreadedService service = new NoOpThreadedService();
554     service.addListener(
555         new Listener() {
556           @Override
557           public void terminated(State from) {
558             service.stopAsync().awaitTerminated();
559           }
560         },
561         directExecutor());
562     service.startAsync().awaitRunning();
563     Thread thread =
564         new Thread() {
565           @Override
566           public void run() {
567             service.stopAsync().awaitTerminated();
568           }
569         };
570     thread.start();
571     thread.join(LONG_TIMEOUT_MILLIS);
572     assertFalse(thread + " is deadlocked", thread.isAlive());
573   }
574   private static class NoOpThreadedService extends AbstractExecutionThreadService {
575     final CountDownLatch latch = new CountDownLatch(1);
576     @Override
577     protected void run() throws Exception {
578       latch.await();
579     }
580     @Override
581     protected void triggerShutdown() {
582       latch.countDown();
583     }
584   }
585   private static class StartFailingService extends AbstractService {
586     @Override
587     protected void doStart() {
588       notifyFailed(EXCEPTION);
589     }
590     @Override
591     protected void doStop() {
592       fail();
593     }
594   }
595   private static class RunFailingService extends AbstractService {
596     @Override
597     protected void doStart() {
598       notifyStarted();
599       notifyFailed(EXCEPTION);
600     }
601     @Override
602     protected void doStop() {
603       fail();
604     }
605   }
606   private static class StopFailingService extends AbstractService {
607     @Override
608     protected void doStart() {
609       notifyStarted();
610     }
611     @Override
612     protected void doStop() {
613       notifyFailed(EXCEPTION);
614     }
615   }
616   private static class StartThrowingService extends AbstractService {
617     final RuntimeException exception = new RuntimeException("deliberate");
618     @Override
619     protected void doStart() {
620       throw exception;
621     }
622     @Override
623     protected void doStop() {
624       fail();
625     }
626   }
627   private static class RunThrowingService extends AbstractService {
628     final RuntimeException exception = new RuntimeException("deliberate");
629     @Override
630     protected void doStart() {
631       notifyStarted();
632       throw exception;
633     }
634     @Override
635     protected void doStop() {
636       fail();
637     }
638   }
639   private static class StopThrowingService extends AbstractService {
640     final RuntimeException exception = new RuntimeException("deliberate");
641     @Override
642     protected void doStart() {
643       notifyStarted();
644     }
645     @Override
646     protected void doStop() {
647       throw exception;
648     }
649   }
650   private static class RecordingListener extends Listener {
651     static RecordingListener record(Service service) {
652       RecordingListener listener = new RecordingListener(service);
653       service.addListener(listener, directExecutor());
654       return listener;
655     }
656     final Service service;
657     RecordingListener(Service service) {
658       this.service = service;
659     }
660     @GuardedBy("this")
661     final List&lt;State&gt; stateHistory = Lists.newArrayList();
662     final CountDownLatch completionLatch = new CountDownLatch(1);
663     ImmutableList&lt;State&gt; getStateHistory() throws Exception {
664       completionLatch.await();
665       synchronized (this) {
666         return ImmutableList.copyOf(stateHistory);
667       }
668     }
669     @Override
670     public synchronized void starting() {
671       assertTrue(stateHistory.isEmpty());
672       assertNotSame(State.NEW, service.state());
673       stateHistory.add(State.STARTING);
674     }
675     @Override
676     public synchronized void running() {
677 <a name="7"></a>      assertEquals(State.STARTING, Iterables.getOnlyElement(stateHistory));
678       stateHistory.add(State.RUNNING);
679       service.awaitRunning();
680       assertNotSame(State.STARTING, <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>service.state());
681     }
682     @Override
683     public synchronized void stopping(State from) {
684       assertEquals(from, Iterables.getLast(stateHistory));
685       stateHistory.add</b></font>(State.STOPPING);
686       if (from == State.STARTING) {
687         try {
688           service.awaitRunning();
689           fail();
690         } catch (IllegalStateException expected) {
691           assertThat(expected).hasCauseThat().isNull();
692           assertThat(expected)
693               .hasMessageThat()
694               .isEqualTo("Expected the service " + service + " to be RUNNING, but was STOPPING");
695         }
696       }
697       assertNotSame(from, service.state());
698     }
699     @Override
700     public synchronized void terminated(State from) {
701       assertEquals(from, Iterables.getLast(stateHistory, State.NEW));
702       stateHistory.add(State.TERMINATED);
703       assertEquals(State.TERMINATED, service.state());
704       if (from == State.NEW) {
705         try {
706           service.awaitRunning();
707           fail();
708         } catch (IllegalStateException expected) {
709           assertThat(expected).hasCauseThat().isNull();
710           assertThat(expected)
711               .hasMessageThat()
712               .isEqualTo("Expected the service " + service + " to be RUNNING, but was TERMINATED");
713         }
714       }
715       completionLatch.countDown();
716     }
717     @Override
718     public synchronized void failed(State from, Throwable failure) {
719       assertEquals(from, Iterables.getLast(stateHistory));
720       stateHistory.add(State.FAILED);
721       assertEquals(State.FAILED, service.state());
722       assertEquals(failure, service.failureCause());
723       if (from == State.STARTING) {
724         try {
725           service.awaitRunning();
726           fail();
727         } catch (IllegalStateException e) {
728           assertThat(e).hasCauseThat().isEqualTo(failure);
729         }
730       }
731       try {
732         service.awaitTerminated();
733         fail();
734       } catch (IllegalStateException e) {
735         assertThat(e).hasCauseThat().isEqualTo(failure);
736       }
737       completionLatch.countDown();
738     }
739   }
740   public void testNotifyStartedWhenNotStarting() {
741     AbstractService service = new DefaultService();
742     try {
743       service.notifyStarted();
744       fail();
745     } catch (IllegalStateException expected) {
746     }
747   }
748   public void testNotifyStoppedWhenNotRunning() {
749     AbstractService service = new DefaultService();
750     try {
751       service.notifyStopped();
752       fail();
753     } catch (IllegalStateException expected) {
754     }
755   }
756   public void testNotifyFailedWhenNotStarted() {
757     AbstractService service = new DefaultService();
758     try {
759       service.notifyFailed(new Exception());
760       fail();
761     } catch (IllegalStateException expected) {
762     }
763   }
764   public void testNotifyFailedWhenTerminated() {
765     NoOpService service = new NoOpService();
766     service.startAsync().awaitRunning();
767     service.stopAsync().awaitTerminated();
768     try {
769       service.notifyFailed(new Exception());
770       fail();
771     } catch (IllegalStateException expected) {
772     }
773   }
774   private static class DefaultService extends AbstractService {
775     @Override
776     protected void doStart() {}
777     @Override
778     protected void doStop() {}
779   }
780   private static final Exception EXCEPTION = new Exception();
781 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
