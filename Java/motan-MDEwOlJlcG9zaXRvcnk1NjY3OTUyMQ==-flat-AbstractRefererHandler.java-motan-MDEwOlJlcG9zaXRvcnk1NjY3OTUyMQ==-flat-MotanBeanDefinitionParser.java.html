
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.442503639010189%, Tokens: 19</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-AbstractRefererHandler.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.weibo.api.motan.proxy;
2  import com.weibo.api.motan.cluster.Cluster;
3  import com.weibo.api.motan.common.MotanConstants;
4  import com.weibo.api.motan.common.URLParamType;
5  import com.weibo.api.motan.core.extension.ExtensionLoader;
6  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
7  import com.weibo.api.motan.exception.MotanFrameworkException;
8  import com.weibo.api.motan.exception.MotanServiceException;
9  import com.weibo.api.motan.rpc.*;
10  import com.weibo.api.motan.serialize.DeserializableObject;
11  import com.weibo.api.motan.switcher.Switcher;
12  import com.weibo.api.motan.switcher.SwitcherService;
13  import com.weibo.api.motan.util.*;
14  import org.apache.commons.lang3.StringUtils;
15  import java.io.IOException;
16  import java.lang.reflect.Method;
17  import java.util.HashMap;
18  import java.util.List;
19  import java.util.Map;
</span>20  public class AbstractRefererHandler<T> {
21      protected List<Cluster<T>> clusters;
22      protected Class<T> clz;
23      protected SwitcherService switcherService = null;
24      protected String interfaceName;
25      void init() {
26          String switchName = this.clusters.get(0).getUrl().getParameter(URLParamType.switcherService.getName(), URLParamType.switcherService.getValue());
27          switcherService = ExtensionLoader.getExtensionLoader(SwitcherService.class).getExtension(switchName);
28      }
29      Object invokeRequest(Request request, Class<?> returnType, boolean async) throws Throwable {
30          fillWithContext(request, async);
31          for (Cluster<T> cluster : clusters) {
32              String protocolSwitcher = MotanConstants.PROTOCOL_SWITCHER_PREFIX + cluster.getUrl().getProtocol();
33              Switcher switcher = switcherService.getSwitcher(protocolSwitcher);
34              if (switcher != null && !switcher.isOn()) {
35                  continue;
36              }
37              request.setAttachment(URLParamType.version.getName(), cluster.getUrl().getVersion());
38              request.setAttachment(URLParamType.clientGroup.getName(), cluster.getUrl().getGroup());
39              request.setAttachment(URLParamType.application.getName(), cluster.getUrl().getApplication());
40              request.setAttachment(URLParamType.module.getName(), cluster.getUrl().getModule());
41              return call(cluster, cluster.getUrl(), request, returnType, async);
42          }
43          throw new MotanServiceException("Referer call Error: cluster not exist, interface=" + interfaceName + " " + MotanFrameworkUtil.toString(request), MotanErrorMsgConstant.SERVICE_UNFOUND, false);
44      }
45      protected Object call(Caller<T> caller, URL refUrl, Request request, Class<?> returnType, boolean async) throws Throwable {
46          Response response;
47          boolean throwException = Boolean.parseBoolean(refUrl.getParameter(URLParamType.throwException.getName(), URLParamType.throwException.getValue()));
48          try {
49              MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_INVOKE);
50              response = caller.call(request);
51              if (async) {
52                  if (response instanceof ResponseFuture) {
53                      ((ResponseFuture) response).setReturnType(returnType);
54                      return response;
55                  } else {
56                      ResponseFuture responseFuture = new DefaultResponseFuture(request, 0, refUrl);
57                      if (response.getException() != null) {
58                          responseFuture.onFailure(response);
59                      } else {
60                          responseFuture.onSuccess(response);
61                      }
62                      responseFuture.setReturnType(returnType);
63                      return responseFuture;
64                  }
65              } else {
66                  Object value = response.getValue();
67                  if (value instanceof DeserializableObject) {
68                      try {
69                          value = ((DeserializableObject) value).deserialize(returnType);
70                      } catch (IOException e) {
71                          LoggerUtil.error("deserialize response value fail! deserialize type:" + returnType, e);
72                          throw new MotanFrameworkException("deserialize return value fail! deserialize type:" + returnType, e);
73                      }
74                  }
75                  return value;
76              }
77          } catch (RuntimeException e) {
78              if (ExceptionUtil.isBizException(e)) {
79                  Throwable t = e.getCause();
80                  if (t instanceof Exception) {
81                      throw t;
82                  } else {
83                      String msg = t == null ? "biz exception cause is null. origin error msg : " + e.getMessage() : ("biz exception cause is throwable error:" + t.getClass() + ", errMsg:" + t.getMessage());
84                      throw new MotanServiceException(msg);
85                  }
86              } else if (!throwException) {
87                  LoggerUtil.warn("RefererInvocationHandler invoke false, so return default value: uri=" + refUrl.getUri() + " " + MotanFrameworkUtil.toString(request), e);
88                  return getDefaultReturnValue(returnType);
89              } else {
90                  LoggerUtil.error("RefererInvocationHandler invoke Error: uri=" + refUrl.getUri() + " " + MotanFrameworkUtil.toString(request), e);
91                  throw e;
92              }
93          }
94      }
95      protected boolean isLocalMethod(Method method) {
96          if (method.getDeclaringClass().equals(Object.class)) {
97              try {
98                  clz.getDeclaredMethod(method.getName(), method.getParameterTypes());
99                  return false;
100              } catch (Exception e) {
101                  return true;
102              }
103          }
104          return false;
105      }
106      protected boolean fillDefaultRequest(DefaultRequest request, Method method, Object[] args) {
107          request.setRequestId(RequestIdGenerator.getRequestId());
108          request.setArguments(args);
109          String methodName = method.getName();
110          boolean async = false;
111          if (methodName.endsWith(MotanConstants.ASYNC_SUFFIX) && method.getReturnType().equals(ResponseFuture.class)) {
112              methodName = MotanFrameworkUtil.removeAsyncSuffix(methodName);
113              async = true;
114          }
115          request.setMethodName(methodName);
116          request.setParamtersDesc(ReflectUtil.getMethodParamDesc(method));
117          request.setInterfaceName(interfaceName);
118          return async;
119      }
120      protected Class<?> getRealReturnType(boolean asyncCall, Class<?> clazz, Method method, String methodName) {
121          if (asyncCall) {
122              try {
123                  Method m = clazz.getMethod(methodName, method.getParameterTypes());
124                  return m.getReturnType();
125              } catch (Exception e) {
126                  LoggerUtil.warn("RefererInvocationHandler get real return type fail. err:" + e.getMessage());
127                  return method.getReturnType();
128              }
129          } else {
130              return method.getReturnType();
131          }
132      }
133      protected void fillWithContext(Request request, boolean async) {
134          RpcContext curContext = RpcContext.getContext();
135          curContext.putAttribute(MotanConstants.ASYNC_SUFFIX, async);
136          Map<String, String> attachments = curContext.getRpcAttachments();
137          if (!attachments.isEmpty()) {
138              for (Map.Entry<String, String> entry : attachments.entrySet()) {
139                  request.setAttachment(entry.getKey(), entry.getValue());
140              }
141          }
142          if (StringUtils.isNotBlank(curContext.getClientRequestId())) {
143              request.setAttachment(URLParamType.requestIdFromClient.getName(), curContext.getClientRequestId());
144          }
145      }
146      protected Object getDefaultReturnValue(Class<?> returnType) {
147          if (returnType != null && returnType.isPrimitive()) {
148              return PrimitiveDefault.getDefaultReturnValue(returnType);
149          }
150          return null;
151      }
152      private static class PrimitiveDefault {
153          private static boolean defaultBoolean;
154          private static char defaultChar;
155          private static byte defaultByte;
156          private static short defaultShort;
157          private static int defaultInt;
158          private static long defaultLong;
159          private static float defaultFloat;
160          private static double defaultDouble;
161          private static final Map<Class<?>, Object> primitiveValues = new HashMap<>();
162          static {
163              primitiveValues.put(boolean.class, defaultBoolean);
164              primitiveValues.put(char.class, defaultChar);
165              primitiveValues.put(byte.class, defaultByte);
166              primitiveValues.put(short.class, defaultShort);
167              primitiveValues.put(int.class, defaultInt);
168              primitiveValues.put(long.class, defaultLong);
169              primitiveValues.put(float.class, defaultFloat);
170              primitiveValues.put(double.class, defaultDouble);
171          }
172          public static Object getDefaultReturnValue(Class<?> returnType) {
173              return primitiveValues.get(returnType);
174          }
175      }
176  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MotanBeanDefinitionParser.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.weibo.api.motan.config.springsupport;
2  import com.weibo.api.motan.config.*;
3  import org.apache.commons.lang3.StringUtils;
4  import org.springframework.beans.factory.config.BeanDefinition;
5  import org.springframework.beans.factory.config.BeanDefinitionHolder;
6  import org.springframework.beans.factory.config.RuntimeBeanReference;
7  import org.springframework.beans.factory.config.TypedStringValue;
8  import org.springframework.beans.factory.support.ManagedList;
9  import org.springframework.beans.factory.support.ManagedMap;
10  import org.springframework.beans.factory.support.RootBeanDefinition;
11  import org.springframework.beans.factory.xml.BeanDefinitionParser;
12  import org.springframework.beans.factory.xml.ParserContext;
13  import org.w3c.dom.Element;
14  import org.w3c.dom.NamedNodeMap;
15  import org.w3c.dom.Node;
16  import org.w3c.dom.NodeList;
17  import java.lang.reflect.Method;
18  import java.lang.reflect.Modifier;
19  import java.util.HashSet;
</span>20  import java.util.Set;
21  public class MotanBeanDefinitionParser implements BeanDefinitionParser {
22      private final Class<?> beanClass;
23      private final boolean required;
24      public MotanBeanDefinitionParser(Class<?> beanClass, boolean required) {
25          this.beanClass = beanClass;
26          this.required = required;
27      }
28      @Override
29      public BeanDefinition parse(Element element, ParserContext parserContext) {
30          try {
31              return parse(element, parserContext, beanClass, required);
32          } catch (ClassNotFoundException e) {
33              e.printStackTrace();
34              throw new RuntimeException(e);
35          }
36      }
37      @SuppressWarnings({"rawtypes", "unchecked"})
38      private static BeanDefinition parse(Element element, ParserContext parserContext, Class<?> beanClass, boolean required)
39              throws ClassNotFoundException {
40          RootBeanDefinition bd = new RootBeanDefinition();
41          bd.setBeanClass(beanClass);
42          bd.setLazyInit(false);
43          String id = element.getAttribute("id");
44          if ((id == null || id.length() == 0) && required) {
45              String generatedBeanName = element.getAttribute("name");
46              if (generatedBeanName == null || generatedBeanName.length() == 0) {
47                  generatedBeanName = element.getAttribute("class");
48              }
49              if (generatedBeanName == null || generatedBeanName.length() == 0) {
50                  generatedBeanName = beanClass.getName();
51              }
52              id = generatedBeanName;
53              int counter = 2;
54              while (parserContext.getRegistry().containsBeanDefinition(id)) {
55                  id = generatedBeanName + (counter++);
56              }
57          }
58          if (id != null && id.length() > 0) {
59              if (parserContext.getRegistry().containsBeanDefinition(id)) {
60                  throw new IllegalStateException("Duplicate spring bean id " + id);
61              }
62              parserContext.getRegistry().registerBeanDefinition(id, bd);
63          }
64          bd.getPropertyValues().addPropertyValue("id", id);
65          if (ProtocolConfig.class.equals(beanClass)) {
66              MotanNamespaceHandler.protocolDefineNames.add(id);
67          } else if (RegistryConfig.class.equals(beanClass)) {
68              MotanNamespaceHandler.registryDefineNames.add(id);
69          } else if (BasicServiceInterfaceConfig.class.equals(beanClass)) {
70              MotanNamespaceHandler.basicServiceConfigDefineNames.add(id);
71          } else if (BasicRefererInterfaceConfig.class.equals(beanClass)) {
72              MotanNamespaceHandler.basicRefererConfigDefineNames.add(id);
73          } else if (ServiceConfigBean.class.equals(beanClass)) {
74              String className = element.getAttribute("class");
75              if (className != null && className.length() > 0) {
76                  RootBeanDefinition classDefinition = new RootBeanDefinition();
77                  classDefinition.setBeanClass(Class.forName(className, true, Thread.currentThread().getContextClassLoader()));
78                  classDefinition.setLazyInit(false);
79                  parseProperties(element.getChildNodes(), classDefinition);
80                  bd.getPropertyValues().addPropertyValue("ref", new BeanDefinitionHolder(classDefinition, id + "Impl"));
81              }
82          }
83          Set<String> props = new HashSet<>();
84          ManagedMap parameters = null;
85          for (Method setter : beanClass.getMethods()) {
86              String name = setter.getName();
87              if (name.length() <= 3 || !name.startsWith("set") || !Modifier.isPublic(setter.getModifiers())
88                      || setter.getParameterTypes().length != 1) {
89                  continue;
90              }
91              String property = (name.substring(3, 4).toLowerCase() + name.substring(4)).replaceAll("_", "-");
92              props.add(property);
93              if ("id".equals(property)) {
94                  bd.getPropertyValues().addPropertyValue("id", id);
95                  continue;
96              }
97              String value = element.getAttribute(property);
98              if ("methods".equals(property)) {
99                  parseMethods(id, element.getChildNodes(), bd, parserContext);
100              }
101              if (StringUtils.isBlank(value)) {
102                  continue;
103              }
104              value = value.trim();
105              if (value.length() == 0) {
106                  continue;
107              }
108              Object reference = null;
109              if ("ref".equals(property)) {
110                  if (parserContext.getRegistry().containsBeanDefinition(value)) {
111                      BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);
112                      if (!refBean.isSingleton()) {
113                          throw new IllegalStateException("The exported service ref " + value + " must be singleton! Please set the " + value
114                                  + " bean scope to singleton, eg: <bean id=\"" + value + "\" scope=\"singleton\" ...>");
115                      }
116                  }
117                  reference = new RuntimeBeanReference(value);
118              } else if ("protocol".equals(property) && !StringUtils.isBlank(value)) {
119                  if (!value.contains(",")) {
120                      reference = new RuntimeBeanReference(value);
121                  } else {
122                      parseMultiRef("protocols", value, bd, parserContext);
123                  }
124              } else if ("registry".equals(property)) {
125                  parseMultiRef("registries", value, bd, parserContext);
126              } else if ("basicService".equals(property) || "basicReferer".equals(property)
127                      || "extConfig".equals(property) || "proxyRegistry".equals(property)) {
128                  reference = new RuntimeBeanReference(value);
129              } else if ("meshClient".equals(property)) {
130                  bd.getPropertyValues().addPropertyValue("meshClientString", new TypedStringValue(value));
131                  if (!"default".equals(value) && !"none".equals(value)) {
132                      reference = new RuntimeBeanReference(value);
133                  }
134              } else {
135                  reference = new TypedStringValue(value);
136              }
137              if (reference != null) {
138                  bd.getPropertyValues().addPropertyValue(property, reference);
139              }
140          }
141          if (ProtocolConfig.class.equals(beanClass)) {
142              NamedNodeMap attributes = element.getAttributes();
143              int len = attributes.getLength();
144              for (int i = 0; i < len; i++) {
145                  Node node = attributes.item(i);
146                  String name = node.getLocalName();
147                  if (!props.contains(name)) {
148                      if (parameters == null) {
149                          parameters = new ManagedMap();
150                      }
151                      String value = node.getNodeValue();
152                      parameters.put(name, new TypedStringValue(value, String.class));
153                  }
154              }
155              bd.getPropertyValues().addPropertyValue("parameters", parameters);
156          }
157          return bd;
158      }
159      @SuppressWarnings({"unchecked", "rawtypes"})
160      private static void parseMultiRef(String property, String value, RootBeanDefinition beanDefinition, ParserContext parserContext) {
161          String[] values = value.split("\\s*[,]+\\s*");
162          ManagedList list = null;
163          for (String v : values) {
164              if (v != null && v.length() > 0) {
165                  if (list == null) {
166                      list = new ManagedList();
167                  }
168                  list.add(new RuntimeBeanReference(v));
169              }
170          }
171          beanDefinition.getPropertyValues().addPropertyValue(property, list);
172      }
173      private static void parseProperties(NodeList nodeList, RootBeanDefinition beanDefinition) {
174          if (nodeList != null && nodeList.getLength() > 0) {
175              for (int i = 0; i < nodeList.getLength(); i++) {
176                  Node node = nodeList.item(i);
177                  if (node instanceof Element) {
178                      if ("property".equals(node.getNodeName()) || "property".equals(node.getLocalName())) {
179                          String name = ((Element) node).getAttribute("name");
180                          if (name != null && name.length() > 0) {
181                              String value = ((Element) node).getAttribute("value");
182                              String ref = ((Element) node).getAttribute("ref");
183                              if (value != null && value.length() > 0) {
184                                  beanDefinition.getPropertyValues().addPropertyValue(name, value);
185                              } else if (ref != null && ref.length() > 0) {
186                                  beanDefinition.getPropertyValues().addPropertyValue(name, new RuntimeBeanReference(ref));
187                              } else {
188                                  throw new UnsupportedOperationException("Unsupported <property name=\"" + name
189                                          + "\"> sub tag, Only supported <property name=\"" + name + "\" ref=\"...\" /> or <property name=\""
190                                          + name + "\" value=\"...\" />");
191                              }
192                          }
193                      }
194                  }
195              }
196          }
197      }
198      @SuppressWarnings({"unchecked", "rawtypes"})
199      private static void parseMethods(String id, NodeList nodeList, RootBeanDefinition beanDefinition, ParserContext parserContext)
200              throws ClassNotFoundException {
201          if (nodeList != null && nodeList.getLength() > 0) {
202              ManagedList methods = null;
203              for (int i = 0; i < nodeList.getLength(); i++) {
204                  Node node = nodeList.item(i);
205                  if (node instanceof Element) {
206                      Element element = (Element) node;
207                      if ("method".equals(node.getNodeName()) || "method".equals(node.getLocalName())) {
208                          String methodName = element.getAttribute("name");
209                          if (methodName == null || methodName.length() == 0) {
210                              throw new IllegalStateException("<motan:method> name attribute == null");
211                          }
212                          if (methods == null) {
213                              methods = new ManagedList();
214                          }
215                          BeanDefinition methodBeanDefinition = parse((Element) node, parserContext, MethodConfig.class, false);
216                          String name = id + "." + methodName;
217                          BeanDefinitionHolder methodBeanDefinitionHolder = new BeanDefinitionHolder(methodBeanDefinition, name);
218                          methods.add(methodBeanDefinitionHolder);
219                      }
220                  }
221              }
222              if (methods != null) {
223                  beanDefinition.getPropertyValues().addPropertyValue("methods", methods);
224              }
225          }
226      }
227  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-AbstractRefererHandler.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-MotanBeanDefinitionParser.java</div>
                </div>
                <div class="column column_space"><pre><code>1  package com.weibo.api.motan.proxy;
2  import com.weibo.api.motan.cluster.Cluster;
3  import com.weibo.api.motan.common.MotanConstants;
4  import com.weibo.api.motan.common.URLParamType;
5  import com.weibo.api.motan.core.extension.ExtensionLoader;
6  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
7  import com.weibo.api.motan.exception.MotanFrameworkException;
8  import com.weibo.api.motan.exception.MotanServiceException;
9  import com.weibo.api.motan.rpc.*;
10  import com.weibo.api.motan.serialize.DeserializableObject;
11  import com.weibo.api.motan.switcher.Switcher;
12  import com.weibo.api.motan.switcher.SwitcherService;
13  import com.weibo.api.motan.util.*;
14  import org.apache.commons.lang3.StringUtils;
15  import java.io.IOException;
16  import java.lang.reflect.Method;
17  import java.util.HashMap;
18  import java.util.List;
19  import java.util.Map;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package com.weibo.api.motan.config.springsupport;
2  import com.weibo.api.motan.config.*;
3  import org.apache.commons.lang3.StringUtils;
4  import org.springframework.beans.factory.config.BeanDefinition;
5  import org.springframework.beans.factory.config.BeanDefinitionHolder;
6  import org.springframework.beans.factory.config.RuntimeBeanReference;
7  import org.springframework.beans.factory.config.TypedStringValue;
8  import org.springframework.beans.factory.support.ManagedList;
9  import org.springframework.beans.factory.support.ManagedMap;
10  import org.springframework.beans.factory.support.RootBeanDefinition;
11  import org.springframework.beans.factory.xml.BeanDefinitionParser;
12  import org.springframework.beans.factory.xml.ParserContext;
13  import org.w3c.dom.Element;
14  import org.w3c.dom.NamedNodeMap;
15  import org.w3c.dom.Node;
16  import org.w3c.dom.NodeList;
17  import java.lang.reflect.Method;
18  import java.lang.reflect.Modifier;
19  import java.util.HashSet;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    