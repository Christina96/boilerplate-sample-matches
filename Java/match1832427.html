<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TreeMultimapExplicitTest_1.java &amp; Sets_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TreeMultimapExplicitTest_1.java &amp; Sets_1.java
      </h3>
<h1 align="center">
        2.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TreeMultimapExplicitTest_1.java (11.217949%)<th>Sets_1.java (1.5164645%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-37)<td><a href="#" name="0">(46-70)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(55-58)<td><a href="#" name="1">(1986-1989)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(48-51)<td><a href="#" name="2">(121-124)</a><td align="center"><font color="#a30000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeMultimapExplicitTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
package com.google.common.collect;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.truth.Truth.assertThat;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.testing.SerializableTester;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.SortedSet;
import junit.framework.TestCase;
@GwtCompatible(e</b></font>mulated = true)
public class TreeMultimapExplicitTest extends TestCase {
  private enum StringLength implements Comparator&lt;String&gt; {
<a name="2"></a>    COMPARATOR;
    @Override
    public int compare(String first, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>String second) {
      if (first == second) {
        return 0;
      } else if (first == null) {</b></font>
<a name="1"></a>        return -1;
      } else if (second == null) {
        return 1;
      } else <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if (first.length() != second.length()) {
        return first.length() - second.length();
      } else {
        return first.compareTo</b></font>(second);
      }
    }
  }
  private static final Comparator&lt;Integer&gt; DECREASING_INT_COMPARATOR =
      Ordering.&lt;Integer&gt;natural().reverse().nullsFirst();
  private SetMultimap&lt;String, Integer&gt; create() {
    return TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
  }
  private TreeMultimap&lt;String, Integer&gt; createPopulate() {
    TreeMultimap&lt;String, Integer&gt; multimap =
        TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
    multimap.put("google", 2);
    multimap.put("google", 6);
    multimap.put(null, 3);
    multimap.put(null, 1);
    multimap.put(null, 7);
    multimap.put("tree", 0);
    multimap.put("tree", null);
    return multimap;
  }
  public void testMultimapCreateFromTreeMultimap() {
    TreeMultimap&lt;String, Integer&gt; tree =
        TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
    tree.put("google", 2);
    tree.put("google", 6);
    tree.put("tree", 0);
    tree.put("tree", 3);
    assertThat(tree.keySet()).containsExactly("tree", "google").inOrder();
    assertThat(tree.get("google")).containsExactly(6, 2).inOrder();
    TreeMultimap&lt;String, Integer&gt; copy = TreeMultimap.create(tree);
    assertEquals(tree, copy);
    assertThat(copy.keySet()).containsExactly("google", "tree").inOrder();
    assertThat(copy.get("google")).containsExactly(2, 6).inOrder();
    assertEquals(Ordering.natural(), copy.keyComparator());
    assertEquals(Ordering.natural(), copy.valueComparator());
    assertEquals(Ordering.natural(), copy.get("google").comparator());
  }
  public void testToString() {
    Multimap&lt;String, Integer&gt; multimap = create();
    multimap.put("foo", 3);
    multimap.put("bar", 1);
    multimap.putAll("foo", Arrays.asList(-1, 2, 4));
    multimap.putAll("bar", Arrays.asList(2, 3));
    multimap.put("foo", 1);
    assertEquals("{bar=[3, 2, 1], foo=[4, 3, 2, 1, -1]}", multimap.toString());
  }
  public void testGetComparator() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    assertEquals(StringLength.COMPARATOR, multimap.keyComparator());
    assertEquals(DECREASING_INT_COMPARATOR, multimap.valueComparator());
  }
  public void testOrderedGet() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    assertThat(multimap.get(null)).containsExactly(7, 3, 1).inOrder();
    assertThat(multimap.get("google")).containsExactly(6, 2).inOrder();
    assertThat(multimap.get("tree")).containsExactly(null, 0).inOrder();
  }
  public void testOrderedKeySet() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    assertThat(multimap.keySet()).containsExactly(null, "tree", "google").inOrder();
  }
  public void testOrderedAsMapEntries() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    Iterator&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt; iterator = multimap.asMap().entrySet().iterator();
    Entry&lt;String, Collection&lt;Integer&gt;&gt; entry = iterator.next();
    assertEquals(null, entry.getKey());
    assertThat(entry.getValue()).containsExactly(7, 3, 1);
    entry = iterator.next();
    assertEquals("tree", entry.getKey());
    assertThat(entry.getValue()).containsExactly(null, 0);
    entry = iterator.next();
    assertEquals("google", entry.getKey());
    assertThat(entry.getValue()).containsExactly(6, 2);
  }
  public void testOrderedEntries() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    assertThat(multimap.entries())
        .containsExactly(
            Maps.immutableEntry((String) null, 7),
            Maps.immutableEntry((String) null, 3),
            Maps.immutableEntry((String) null, 1),
            Maps.immutableEntry("tree", (Integer) null),
            Maps.immutableEntry("tree", 0),
            Maps.immutableEntry("google", 6),
            Maps.immutableEntry("google", 2))
        .inOrder();
  }
  public void testOrderedValues() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    assertThat(multimap.values()).containsExactly(7, 3, 1, null, 0, 6, 2).inOrder();
  }
  public void testComparator() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    assertEquals(DECREASING_INT_COMPARATOR, multimap.get("foo").comparator());
    assertEquals(DECREASING_INT_COMPARATOR, multimap.get("missing").comparator());
  }
  public void testMultimapComparators() {
    Multimap&lt;String, Integer&gt; multimap = create();
    multimap.put("foo", 3);
    multimap.put("bar", 1);
    multimap.putAll("foo", Arrays.asList(-1, 2, 4));
    multimap.putAll("bar", Arrays.asList(2, 3));
    multimap.put("foo", 1);
    TreeMultimap&lt;String, Integer&gt; copy =
        TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
    copy.putAll(multimap);
    assertEquals(multimap, copy);
    assertEquals(StringLength.COMPARATOR, copy.keyComparator());
    assertEquals(DECREASING_INT_COMPARATOR, copy.valueComparator());
  }
  public void testSortedKeySet() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    SortedSet&lt;String&gt; keySet = multimap.keySet();
    assertEquals(null, keySet.first());
    assertEquals("google", keySet.last());
    assertEquals(StringLength.COMPARATOR, keySet.comparator());
    assertEquals(Sets.newHashSet(null, "tree"), keySet.headSet("yahoo"));
    assertEquals(Sets.newHashSet("google"), keySet.tailSet("yahoo"));
    assertEquals(Sets.newHashSet("tree"), keySet.subSet("ask", "yahoo"));
  }
  @GwtIncompatible   public void testExplicitComparatorSerialization() {
    TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
    TreeMultimap&lt;String, Integer&gt; copy = SerializableTester.reserializeAndAssert(multimap);
    assertThat(copy.values()).containsExactly(7, 3, 1, null, 0, 6, 2).inOrder();
    assertThat(copy.keySet()).containsExactly(null, "tree", "google").inOrder();
    assertEquals(multimap.keyComparator(), copy.keyComparator());
    assertEquals(multimap.valueComparator(), copy.valueComparator());
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Sets_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.collect;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Collections2.FilteredCollection;
import com.google.common.math.IntMath;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
<a name="0"></a>import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.NoSuchElementException;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.function.Consumer;
import java.util.stream.Collector;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;
@GwtCompatible(e</b></font>mulated = true)
@ElementTypesAreNonnullByDefault
public final class Sets {
  private Sets() {}
  abstract static class ImprovedAbstractSet&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
    @Override
    public boolean removeAll(Collection&lt;?&gt; c) {
      return removeAllImpl(this, c);
    }
    @Override
    public boolean retainAll(Collection&lt;?&gt; c) {
      return super.retainAll(checkNotNull(c));     }
  }
  @GwtCompatible(serializable = true)
  public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(
      E anElement, E... otherElements) {
    return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));
  }
  @GwtCompatible(serializable = true)
  public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Iterable&lt;E&gt; elements) {
    if (elements instanceof ImmutableEnumSet) {
      return (ImmutableEnumSet&lt;E&gt;) elements;
    } else if (elements instanceof Collection) {</b></font>
      Collection&lt;E&gt; collection = (Collection&lt;E&gt;) elements;
      if (collection.isEmpty()) {
        return ImmutableSet.of();
      } else {
        return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));
      }
    } else {
      Iterator&lt;E&gt; itr = elements.iterator();
      if (itr.hasNext()) {
        EnumSet&lt;E&gt; enumSet = EnumSet.of(itr.next());
        Iterators.addAll(enumSet, itr);
        return ImmutableEnumSet.asImmutable(enumSet);
      } else {
        return ImmutableSet.of();
      }
    }
  }
  public static &lt;E extends Enum&lt;E&gt;&gt; Collector&lt;E, ?, ImmutableSet&lt;E&gt;&gt; toImmutableEnumSet() {
    return CollectCollectors.toImmutableEnumSet();
  }
  public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; newEnumSet(
      Iterable&lt;E&gt; iterable, Class&lt;E&gt; elementType) {
    EnumSet&lt;E&gt; set = EnumSet.noneOf(elementType);
    Iterables.addAll(set, iterable);
    return set;
  }
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet() {
    return new HashSet&lt;E&gt;();
  }
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(E... elements) {
    HashSet&lt;E&gt; set = newHashSetWithExpectedSize(elements.length);
    Collections.addAll(set, elements);
    return set;
  }
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterable&lt;? extends E&gt; elements) {
    return (elements instanceof Collection)
        ? new HashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements)
        : newHashSet(elements.iterator());
  }
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterator&lt;? extends E&gt; elements) {
    HashSet&lt;E&gt; set = newHashSet();
    Iterators.addAll(set, elements);
    return set;
  }
  public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSetWithExpectedSize(
      int expectedSize) {
    return new HashSet&lt;E&gt;(Maps.capacity(expectedSize));
  }
  public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet() {
    return Platform.newConcurrentHashSet();
  }
  public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet(Iterable&lt;? extends E&gt; elements) {
    Set&lt;E&gt; set = newConcurrentHashSet();
    Iterables.addAll(set, elements);
    return set;
  }
  public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet() {
    return new LinkedHashSet&lt;E&gt;();
  }
  public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet(
      Iterable&lt;? extends E&gt; elements) {
    if (elements instanceof Collection) {
      return new LinkedHashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements);
    }
    LinkedHashSet&lt;E&gt; set = newLinkedHashSet();
    Iterables.addAll(set, elements);
    return set;
  }
  public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSetWithExpectedSize(
      int expectedSize) {
    return new LinkedHashSet&lt;E&gt;(Maps.capacity(expectedSize));
  }
  public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet() {
    return new TreeSet&lt;E&gt;();
  }
  public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet(Iterable&lt;? extends E&gt; elements) {
    TreeSet&lt;E&gt; set = newTreeSet();
    Iterables.addAll(set, elements);
    return set;
  }
  public static &lt;E extends @Nullable Object&gt; TreeSet&lt;E&gt; newTreeSet(
      Comparator&lt;? super E&gt; comparator) {
    return new TreeSet&lt;E&gt;(checkNotNull(comparator));
  }
  public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newIdentityHashSet() {
    return Collections.newSetFromMap(Maps.&lt;E, Boolean&gt;newIdentityHashMap());
  }
  @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet() {
    return new CopyOnWriteArraySet&lt;E&gt;();
  }
  @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet(
      Iterable&lt;? extends E&gt; elements) {
    Collection&lt;? extends E&gt; elementsCollection =
        (elements instanceof Collection)
            ? (Collection&lt;? extends E&gt;) elements
            : Lists.newArrayList(elements);
    return new CopyOnWriteArraySet&lt;E&gt;(elementsCollection);
  }
  public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(Collection&lt;E&gt; collection) {
    if (collection instanceof EnumSet) {
      return EnumSet.complementOf((EnumSet&lt;E&gt;) collection);
    }
    checkArgument(
        !collection.isEmpty(), "collection is empty; use the other version of this method");
    Class&lt;E&gt; type = collection.iterator().next().getDeclaringClass();
    return makeComplementByHand(collection, type);
  }
  public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(
      Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
    checkNotNull(collection);
    return (collection instanceof EnumSet)
        ? EnumSet.complementOf((EnumSet&lt;E&gt;) collection)
        : makeComplementByHand(collection, type);
  }
  private static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; makeComplementByHand(
      Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
    EnumSet&lt;E&gt; result = EnumSet.allOf(type);
    result.removeAll(collection);
    return result;
  }
  @Deprecated
  public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newSetFromMap(
      Map&lt;E, Boolean&gt; map) {
    return Collections.newSetFromMap(map);
  }
  public abstract static class SetView&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
    private SetView() {} 
    @SuppressWarnings("nullness")     public ImmutableSet&lt;E&gt; immutableCopy() {
      return ImmutableSet.copyOf(this);
    }
    @CanIgnoreReturnValue
    public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
      set.addAll(this);
      return set;
    }
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall("Always throws UnsupportedOperationException")
    public final boolean add(@ParametricNullness E e) {
      throw new UnsupportedOperationException();
    }
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall("Always throws UnsupportedOperationException")
    public final boolean remove(@CheckForNull Object object) {
      throw new UnsupportedOperationException();
    }
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall("Always throws UnsupportedOperationException")
    public final boolean addAll(Collection&lt;? extends E&gt; newElements) {
      throw new UnsupportedOperationException();
    }
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall("Always throws UnsupportedOperationException")
    public final boolean removeAll(Collection&lt;?&gt; oldElements) {
      throw new UnsupportedOperationException();
    }
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall("Always throws UnsupportedOperationException")
    public final boolean removeIf(java.util.function.Predicate&lt;? super E&gt; filter) {
      throw new UnsupportedOperationException();
    }
    @CanIgnoreReturnValue
    @Deprecated
    @Override
    @DoNotCall("Always throws UnsupportedOperationException")
    public final boolean retainAll(Collection&lt;?&gt; elementsToKeep) {
      throw new UnsupportedOperationException();
    }
    @Deprecated
    @Override
    @DoNotCall("Always throws UnsupportedOperationException")
    public final void clear() {
      throw new UnsupportedOperationException();
    }
    @Override
    public abstract UnmodifiableIterator&lt;E&gt; iterator();
  }
  public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; union(
      final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
    checkNotNull(set1, "set1");
    checkNotNull(set2, "set2");
    return new SetView&lt;E&gt;() {
      @Override
      public int size() {
        int size = set1.size();
        for (E e : set2) {
          if (!set1.contains(e)) {
            size++;
          }
        }
        return size;
      }
      @Override
      public boolean isEmpty() {
        return set1.isEmpty() &amp;&amp; set2.isEmpty();
      }
      @Override
      public UnmodifiableIterator&lt;E&gt; iterator() {
        return new AbstractIterator&lt;E&gt;() {
          final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
          final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
          @Override
          @CheckForNull
          protected E computeNext() {
            if (itr1.hasNext()) {
              return itr1.next();
            }
            while (itr2.hasNext()) {
              E e = itr2.next();
              if (!set1.contains(e)) {
                return e;
              }
            }
            return endOfData();
          }
        };
      }
      @Override
      public Stream&lt;E&gt; stream() {
        return Stream.concat(set1.stream(), set2.stream().filter((E e) -&gt; !set1.contains(e)));
      }
      @Override
      public Stream&lt;E&gt; parallelStream() {
        return stream().parallel();
      }
      @Override
      public boolean contains(@CheckForNull Object object) {
        return set1.contains(object) || set2.contains(object);
      }
      @Override
      public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
        set.addAll(set1);
        set.addAll(set2);
        return set;
      }
      @Override
      @SuppressWarnings("nullness")       public ImmutableSet&lt;E&gt; immutableCopy() {
        return new ImmutableSet.Builder&lt;E&gt;().addAll(set1).addAll(set2).build();
      }
    };
  }
  public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; intersection(
      final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
    checkNotNull(set1, "set1");
    checkNotNull(set2, "set2");
    return new SetView&lt;E&gt;() {
      @Override
      public UnmodifiableIterator&lt;E&gt; iterator() {
        return new AbstractIterator&lt;E&gt;() {
          final Iterator&lt;E&gt; itr = set1.iterator();
          @Override
          @CheckForNull
          protected E computeNext() {
            while (itr.hasNext()) {
              E e = itr.next();
              if (set2.contains(e)) {
                return e;
              }
            }
            return endOfData();
          }
        };
      }
      @Override
      public Stream&lt;E&gt; stream() {
        return set1.stream().filter(set2::contains);
      }
      @Override
      public Stream&lt;E&gt; parallelStream() {
        return set1.parallelStream().filter(set2::contains);
      }
      @Override
      public int size() {
        int size = 0;
        for (E e : set1) {
          if (set2.contains(e)) {
            size++;
          }
        }
        return size;
      }
      @Override
      public boolean isEmpty() {
        return Collections.disjoint(set2, set1);
      }
      @Override
      public boolean contains(@CheckForNull Object object) {
        return set1.contains(object) &amp;&amp; set2.contains(object);
      }
      @Override
      public boolean containsAll(Collection&lt;?&gt; collection) {
        return set1.containsAll(collection) &amp;&amp; set2.containsAll(collection);
      }
    };
  }
  public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; difference(
      final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
    checkNotNull(set1, "set1");
    checkNotNull(set2, "set2");
    return new SetView&lt;E&gt;() {
      @Override
      public UnmodifiableIterator&lt;E&gt; iterator() {
        return new AbstractIterator&lt;E&gt;() {
          final Iterator&lt;E&gt; itr = set1.iterator();
          @Override
          @CheckForNull
          protected E computeNext() {
            while (itr.hasNext()) {
              E e = itr.next();
              if (!set2.contains(e)) {
                return e;
              }
            }
            return endOfData();
          }
        };
      }
      @Override
      public Stream&lt;E&gt; stream() {
        return set1.stream().filter(e -&gt; !set2.contains(e));
      }
      @Override
      public Stream&lt;E&gt; parallelStream() {
        return set1.parallelStream().filter(e -&gt; !set2.contains(e));
      }
      @Override
      public int size() {
        int size = 0;
        for (E e : set1) {
          if (!set2.contains(e)) {
            size++;
          }
        }
        return size;
      }
      @Override
      public boolean isEmpty() {
        return set2.containsAll(set1);
      }
      @Override
      public boolean contains(@CheckForNull Object element) {
        return set1.contains(element) &amp;&amp; !set2.contains(element);
      }
    };
  }
  public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; symmetricDifference(
      final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
    checkNotNull(set1, "set1");
    checkNotNull(set2, "set2");
    return new SetView&lt;E&gt;() {
      @Override
      public UnmodifiableIterator&lt;E&gt; iterator() {
        final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
        final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
        return new AbstractIterator&lt;E&gt;() {
          @Override
          @CheckForNull
          public E computeNext() {
            while (itr1.hasNext()) {
              E elem1 = itr1.next();
              if (!set2.contains(elem1)) {
                return elem1;
              }
            }
            while (itr2.hasNext()) {
              E elem2 = itr2.next();
              if (!set1.contains(elem2)) {
                return elem2;
              }
            }
            return endOfData();
          }
        };
      }
      @Override
      public int size() {
        int size = 0;
        for (E e : set1) {
          if (!set2.contains(e)) {
            size++;
          }
        }
        for (E e : set2) {
          if (!set1.contains(e)) {
            size++;
          }
        }
        return size;
      }
      @Override
      public boolean isEmpty() {
        return set1.equals(set2);
      }
      @Override
      public boolean contains(@CheckForNull Object element) {
        return set1.contains(element) ^ set2.contains(element);
      }
    };
  }
  public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; filter(
      Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    if (unfiltered instanceof SortedSet) {
      return filter((SortedSet&lt;E&gt;) unfiltered, predicate);
    }
    if (unfiltered instanceof FilteredSet) {
      FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
      Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
      return new FilteredSet&lt;E&gt;((Set&lt;E&gt;) filtered.unfiltered, combinedPredicate);
    }
    return new FilteredSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
  }
  public static &lt;E extends @Nullable Object&gt; SortedSet&lt;E&gt; filter(
      SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    if (unfiltered instanceof FilteredSet) {
      FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
      Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
      return new FilteredSortedSet&lt;E&gt;((SortedSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
    }
    return new FilteredSortedSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
  }
  @GwtIncompatible   @SuppressWarnings("unchecked")
  public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; filter(
      NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    if (unfiltered instanceof FilteredSet) {
      FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
      Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
      return new FilteredNavigableSet&lt;E&gt;((NavigableSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
    }
    return new FilteredNavigableSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
  }
  private static class FilteredSet&lt;E extends @Nullable Object&gt; extends FilteredCollection&lt;E&gt;
      implements Set&lt;E&gt; {
    FilteredSet(Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
      super(unfiltered, predicate);
    }
    @Override
    public boolean equals(@CheckForNull Object object) {
      return equalsImpl(this, object);
    }
    @Override
    public int hashCode() {
      return hashCodeImpl(this);
    }
  }
  private static class FilteredSortedSet&lt;E extends @Nullable Object&gt; extends FilteredSet&lt;E&gt;
      implements SortedSet&lt;E&gt; {
    FilteredSortedSet(SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
      super(unfiltered, predicate);
    }
    @Override
    @CheckForNull
    public Comparator&lt;? super E&gt; comparator() {
      return ((SortedSet&lt;E&gt;) unfiltered).comparator();
    }
    @Override
    public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
      return new FilteredSortedSet&lt;E&gt;(
          ((SortedSet&lt;E&gt;) unfiltered).subSet(fromElement, toElement), predicate);
    }
    @Override
    public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
      return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).headSet(toElement), predicate);
    }
    @Override
    public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
      return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).tailSet(fromElement), predicate);
    }
    @Override
    @ParametricNullness
    public E first() {
      return Iterators.find(unfiltered.iterator(), predicate);
    }
    @Override
    @ParametricNullness
    public E last() {
      SortedSet&lt;E&gt; sortedUnfiltered = (SortedSet&lt;E&gt;) unfiltered;
      while (true) {
        E element = sortedUnfiltered.last();
        if (predicate.apply(element)) {
          return element;
        }
        sortedUnfiltered = sortedUnfiltered.headSet(element);
      }
    }
  }
  @GwtIncompatible   private static class FilteredNavigableSet&lt;E extends @Nullable Object&gt; extends FilteredSortedSet&lt;E&gt;
      implements NavigableSet&lt;E&gt; {
    FilteredNavigableSet(NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
      super(unfiltered, predicate);
    }
    NavigableSet&lt;E&gt; unfiltered() {
      return (NavigableSet&lt;E&gt;) unfiltered;
    }
    @Override
    @CheckForNull
    public E lower(@ParametricNullness E e) {
      return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);
    }
    @Override
    @CheckForNull
    public E floor(@ParametricNullness E e) {
      return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);
    }
    @Override
    @CheckForNull
    public E ceiling(@ParametricNullness E e) {
      return Iterables.find(unfiltered().tailSet(e, true), predicate, null);
    }
    @Override
    @CheckForNull
    public E higher(@ParametricNullness E e) {
      return Iterables.find(unfiltered().tailSet(e, false), predicate, null);
    }
    @Override
    @CheckForNull
    public E pollFirst() {
      return Iterables.removeFirstMatching(unfiltered(), predicate);
    }
    @Override
    @CheckForNull
    public E pollLast() {
      return Iterables.removeFirstMatching(unfiltered().descendingSet(), predicate);
    }
    @Override
    public NavigableSet&lt;E&gt; descendingSet() {
      return Sets.filter(unfiltered().descendingSet(), predicate);
    }
    @Override
    public Iterator&lt;E&gt; descendingIterator() {
      return Iterators.filter(unfiltered().descendingIterator(), predicate);
    }
    @Override
    @ParametricNullness
    public E last() {
      return Iterators.find(unfiltered().descendingIterator(), predicate);
    }
    @Override
    public NavigableSet&lt;E&gt; subSet(
        @ParametricNullness E fromElement,
        boolean fromInclusive,
        @ParametricNullness E toElement,
        boolean toInclusive) {
      return filter(
          unfiltered().subSet(fromElement, fromInclusive, toElement, toInclusive), predicate);
    }
    @Override
    public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
      return filter(unfiltered().headSet(toElement, inclusive), predicate);
    }
    @Override
    public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
      return filter(unfiltered().tailSet(fromElement, inclusive), predicate);
    }
  }
  public static &lt;B&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(List&lt;? extends Set&lt;? extends B&gt;&gt; sets) {
    return CartesianSet.create(sets);
  }
  @SafeVarargs
  public static &lt;B&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(Set&lt;? extends B&gt;... sets) {
    return cartesianProduct(Arrays.asList(sets));
  }
  private static final class CartesianSet&lt;E&gt; extends ForwardingCollection&lt;List&lt;E&gt;&gt;
      implements Set&lt;List&lt;E&gt;&gt; {
    private final transient ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes;
    private final transient CartesianList&lt;E&gt; delegate;
    static &lt;E&gt; Set&lt;List&lt;E&gt;&gt; create(List&lt;? extends Set&lt;? extends E&gt;&gt; sets) {
      ImmutableList.Builder&lt;ImmutableSet&lt;E&gt;&gt; axesBuilder = new ImmutableList.Builder&lt;&gt;(sets.size());
      for (Set&lt;? extends E&gt; set : sets) {
        ImmutableSet&lt;E&gt; copy = ImmutableSet.copyOf(set);
        if (copy.isEmpty()) {
          return ImmutableSet.of();
        }
        axesBuilder.add(copy);
      }
      final ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes = axesBuilder.build();
      ImmutableList&lt;List&lt;E&gt;&gt; listAxes =
          new ImmutableList&lt;List&lt;E&gt;&gt;() {
            @Override
            public int size() {
              return axes.size();
            }
            @Override
            public List&lt;E&gt; get(int index) {
              return axes.get(index).asList();
            }
            @Override
            boolean isPartialView() {
              return true;
            }
          };
      return new CartesianSet&lt;E&gt;(axes, new CartesianList&lt;E&gt;(listAxes));
    }
    private CartesianSet(ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes, CartesianList&lt;E&gt; delegate) {
      this.axes = axes;
      this.delegate = delegate;
    }
    @Override
    protected Collection&lt;List&lt;E&gt;&gt; delegate() {
      return delegate;
    }
    @Override
    public boolean contains(@CheckForNull Object object) {
      if (!(object instanceof List)) {
        return false;
      }
      List&lt;?&gt; list = (List&lt;?&gt;) object;
      if (list.size() != axes.size()) {
        return false;
      }
      int i = 0;
      for (Object o : list) {
        if (!axes.get(i).contains(o)) {
          return false;
        }
        i++;
      }
      return true;
    }
    @Override
    public boolean equals(@CheckForNull Object object) {
      if (object instanceof CartesianSet) {
        CartesianSet&lt;?&gt; that = (CartesianSet&lt;?&gt;) object;
        return this.axes.equals(that.axes);
      }
      return super.equals(object);
    }
    @Override
    public int hashCode() {
      int adjust = size() - 1;
      for (int i = 0; i &lt; axes.size(); i++) {
        adjust *= 31;
        adjust = ~~adjust;
      }
      int hash = 1;
      for (Set&lt;E&gt; axis : axes) {
        hash = 31 * hash + (size() / axis.size() * axis.hashCode());
        hash = ~~hash;
      }
      hash += adjust;
      return ~~hash;
    }
  }
  @GwtCompatible(serializable = false)
  public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; powerSet(Set&lt;E&gt; set) {
    return new PowerSet&lt;E&gt;(set);
  }
  private static final class SubSet&lt;E&gt; extends AbstractSet&lt;E&gt; {
    private final ImmutableMap&lt;E, Integer&gt; inputSet;
    private final int mask;
    SubSet(ImmutableMap&lt;E, Integer&gt; inputSet, int mask) {
      this.inputSet = inputSet;
      this.mask = mask;
    }
    @Override
    public Iterator&lt;E&gt; iterator() {
      return new UnmodifiableIterator&lt;E&gt;() {
        final ImmutableList&lt;E&gt; elements = inputSet.keySet().asList();
        int remainingSetBits = mask;
        @Override
        public boolean hasNext() {
          return remainingSetBits != 0;
        }
        @Override
        public E next() {
          int index = Integer.numberOfTrailingZeros(remainingSetBits);
          if (index == 32) {
            throw new NoSuchElementException();
          }
          remainingSetBits &amp;= ~(1 &lt;&lt; index);
          return elements.get(index);
        }
      };
    }
    @Override
    public int size() {
      return Integer.bitCount(mask);
    }
    @Override
    public boolean contains(@CheckForNull Object o) {
      Integer index = inputSet.get(o);
      return index != null &amp;&amp; (mask &amp; (1 &lt;&lt; index)) != 0;
    }
  }
  private static final class PowerSet&lt;E&gt; extends AbstractSet&lt;Set&lt;E&gt;&gt; {
    final ImmutableMap&lt;E, Integer&gt; inputSet;
    PowerSet(Set&lt;E&gt; input) {
      checkArgument(
          input.size() &lt;= 30, "Too many elements to create power set: %s &gt; 30", input.size());
      this.inputSet = Maps.indexMap(input);
    }
    @Override
    public int size() {
      return 1 &lt;&lt; inputSet.size();
    }
    @Override
    public boolean isEmpty() {
      return false;
    }
    @Override
    public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
      return new AbstractIndexedListIterator&lt;Set&lt;E&gt;&gt;(size()) {
        @Override
        protected Set&lt;E&gt; get(final int setBits) {
          return new SubSet&lt;E&gt;(inputSet, setBits);
        }
      };
    }
    @Override
    public boolean contains(@CheckForNull Object obj) {
      if (obj instanceof Set) {
        Set&lt;?&gt; set = (Set&lt;?&gt;) obj;
        return inputSet.keySet().containsAll(set);
      }
      return false;
    }
    @Override
    public boolean equals(@CheckForNull Object obj) {
      if (obj instanceof PowerSet) {
        PowerSet&lt;?&gt; that = (PowerSet&lt;?&gt;) obj;
        return inputSet.keySet().equals(that.inputSet.keySet());
      }
      return super.equals(obj);
    }
    @Override
    public int hashCode() {
      return inputSet.keySet().hashCode() &lt;&lt; (inputSet.size() - 1);
    }
    @Override
    public String toString() {
      return "powerSet(" + inputSet + ")";
    }
  }
  @Beta
  public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; combinations(Set&lt;E&gt; set, final int size) {
    final ImmutableMap&lt;E, Integer&gt; index = Maps.indexMap(set);
    checkNonnegative(size, "size");
    checkArgument(size &lt;= index.size(), "size (%s) must be &lt;= set.size() (%s)", size, index.size());
    if (size == 0) {
      return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(ImmutableSet.&lt;E&gt;of());
    } else if (size == index.size()) {
      return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(index.keySet());
    }
    return new AbstractSet&lt;Set&lt;E&gt;&gt;() {
      @Override
      public boolean contains(@CheckForNull Object o) {
        if (o instanceof Set) {
          Set&lt;?&gt; s = (Set&lt;?&gt;) o;
          return s.size() == size &amp;&amp; index.keySet().containsAll(s);
        }
        return false;
      }
      @Override
      public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
        return new AbstractIterator&lt;Set&lt;E&gt;&gt;() {
          final BitSet bits = new BitSet(index.size());
          @Override
          @CheckForNull
          protected Set&lt;E&gt; computeNext() {
            if (bits.isEmpty()) {
              bits.set(0, size);
            } else {
              int firstSetBit = bits.nextSetBit(0);
              int bitToFlip = bits.nextClearBit(firstSetBit);
              if (bitToFlip == index.size()) {
                return endOfData();
              }
              bits.set(0, bitToFlip - firstSetBit - 1);
              bits.clear(bitToFlip - firstSetBit - 1, bitToFlip);
              bits.set(bitToFlip);
            }
            final BitSet copy = (BitSet) bits.clone();
            return new AbstractSet&lt;E&gt;() {
              @Override
              public boolean contains(@CheckForNull Object o) {
                Integer i = index.get(o);
                return i != null &amp;&amp; copy.get(i);
              }
              @Override
              public Iterator&lt;E&gt; iterator() {
                return new AbstractIterator&lt;E&gt;() {
                  int i = -1;
                  @Override
                  @CheckForNull
                  protected E computeNext() {
                    i = copy.nextSetBit(i + 1);
                    if (i == -1) {
                      return endOfData();
                    }
                    return index.keySet().asList().get(i);
                  }
                };
              }
              @Override
              public int size() {
                return size;
              }
            };
          }
        };
      }
      @Override
      public int size() {
        return IntMath.binomial(index.size(), size);
      }
      @Override
      public String toString() {
        return "Sets.combinations(" + index.keySet() + ", " + size + ")";
      }
    };
  }
  static int hashCodeImpl(Set&lt;?&gt; s) {
    int hashCode = 0;
    for (Object o : s) {
      hashCode += o != null ? o.hashCode() : 0;
      hashCode = ~~hashCode;
    }
    return hashCode;
  }
  static boolean equalsImpl(Set&lt;?&gt; s, @CheckForNull Object object) {
    if (s == object) {
      return true;
    }
    if (object instanceof Set) {
      Set&lt;?&gt; o = (Set&lt;?&gt;) object;
      try {
        return s.size() == o.size() &amp;&amp; s.containsAll(o);
      } catch (NullPointerException | ClassCastException ignored) {
        return false;
      }
    }
    return false;
  }
  public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; unmodifiableNavigableSet(
      NavigableSet&lt;E&gt; set) {
    if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet) {
      return set;
    }
    return new UnmodifiableNavigableSet&lt;E&gt;(set);
  }
  static final class UnmodifiableNavigableSet&lt;E extends @Nullable Object&gt;
      extends ForwardingSortedSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Serializable {
    private final NavigableSet&lt;E&gt; delegate;
    private final SortedSet&lt;E&gt; unmodifiableDelegate;
    UnmodifiableNavigableSet(NavigableSet&lt;E&gt; delegate) {
      this.delegate = checkNotNull(delegate);
      this.unmodifiableDelegate = Collections.unmodifiableSortedSet(delegate);
    }
    @Override
    protected SortedSet&lt;E&gt; delegate() {
      return unmodifiableDelegate;
    }
    @Override
    public boolean removeIf(java.util.function.Predicate&lt;? super E&gt; filter) {
      throw new UnsupportedOperationException();
    }
    @Override
    public Stream&lt;E&gt; stream() {
      return delegate.stream();
    }
    @Override
    public Stream&lt;E&gt; parallelStream() {
      return delegate.parallelStream();
    }
    @Override
    public void forEach(Consumer&lt;? super E&gt; action) {
      delegate.forEach(action);
    }
    @Override
    @CheckForNull
    public E lower(@ParametricNullness E e) {
      return delegate.lower(e);
    }
    @Override
    @CheckForNull
    public E floor(@ParametricNullness E e) {
      return delegate.floor(e);
    }
    @Override
    @CheckForNull
    public E ceiling(@ParametricNullness E e) {
      return delegate.ceiling(e);
    }
    @Override
    @CheckForNull
    public E higher(@ParametricNullness E e) {
      return delegate.higher(e);
    }
    @Override
    @CheckForNull
    public E pollFirst() {
      throw new UnsupportedOperationException();
    }
    @Override
    @CheckForNull
    public E pollLast() {
      throw new UnsupportedOperationException();
    }
    @CheckForNull private transient UnmodifiableNavigableSet&lt;E&gt; descendingSet;
    @Override
    public NavigableSet&lt;E&gt; descendingSet() {
      UnmodifiableNavigableSet&lt;E&gt; result = descendingSet;
      if (result == null) {
        result = descendingSet = new UnmodifiableNavigableSet&lt;E&gt;(delegate.descendingSet());
        result.descendingSet = this;
      }
      return result;
    }
    @Override
    public Iterator&lt;E&gt; descendingIterator() {
      return Iterators.unmodifiableIterator(delegate.descendingIterator());
    }
    @Override
    public NavigableSet&lt;E&gt; subSet(
        @ParametricNullness E fromElement,
        boolean fromInclusive,
        @ParametricNullness E toElement,
        boolean toInclusive) {
      return unmodifiableNavigableSet(
          delegate.subSet(fromElement, fromInclusive, toElement, toInclusive));
    }
    @Override
    public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
      return unmodifiableNavigableSet(delegate.headSet(toElement, inclusive));
    }
    @Override
    public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
      return unmodifiableNavigableSet(delegate.tailSet(fromElement, inclusive));
    }
    private static final long serialVersionUID = 0;
  }
  @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; synchronizedNavigableSet(
      NavigableSet&lt;E&gt; navigableSet) {
    return Synchronized.navigableSet(navigableSet);
  }
  static boolean removeAllImpl(Set&lt;?&gt; set, Iterator&lt;?&gt; iterator) {
    boolean changed = false;
    while (iterator.hasNext()) {
      changed |= set.remove(iterator.next());
    }
    return changed;
  }
  static boolean removeAllImpl(Set&lt;?&gt; set, Collection&lt;?&gt; collection) {
    checkNotNull(collection);     if (collection instanceof Multiset) {
      collection = ((Multiset&lt;?&gt;) collection).elementSet();
    }
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if (collection instanceof Set &amp;&amp; collection.size() &gt; set.size()) {
      return Iterators.removeAll(set.iterator(), collection);
    } else {
      return removeAllImpl</b></font>(set, collection.iterator());
    }
  }
  @GwtIncompatible   static class DescendingSet&lt;E extends @Nullable Object&gt; extends ForwardingNavigableSet&lt;E&gt; {
    private final NavigableSet&lt;E&gt; forward;
    DescendingSet(NavigableSet&lt;E&gt; forward) {
      this.forward = forward;
    }
    @Override
    protected NavigableSet&lt;E&gt; delegate() {
      return forward;
    }
    @Override
    @CheckForNull
    public E lower(@ParametricNullness E e) {
      return forward.higher(e);
    }
    @Override
    @CheckForNull
    public E floor(@ParametricNullness E e) {
      return forward.ceiling(e);
    }
    @Override
    @CheckForNull
    public E ceiling(@ParametricNullness E e) {
      return forward.floor(e);
    }
    @Override
    @CheckForNull
    public E higher(@ParametricNullness E e) {
      return forward.lower(e);
    }
    @Override
    @CheckForNull
    public E pollFirst() {
      return forward.pollLast();
    }
    @Override
    @CheckForNull
    public E pollLast() {
      return forward.pollFirst();
    }
    @Override
    public NavigableSet&lt;E&gt; descendingSet() {
      return forward;
    }
    @Override
    public Iterator&lt;E&gt; descendingIterator() {
      return forward.iterator();
    }
    @Override
    public NavigableSet&lt;E&gt; subSet(
        @ParametricNullness E fromElement,
        boolean fromInclusive,
        @ParametricNullness E toElement,
        boolean toInclusive) {
      return forward.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();
    }
    @Override
    public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
      return standardSubSet(fromElement, toElement);
    }
    @Override
    public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
      return forward.tailSet(toElement, inclusive).descendingSet();
    }
    @Override
    public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
      return standardHeadSet(toElement);
    }
    @Override
    public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
      return forward.headSet(fromElement, inclusive).descendingSet();
    }
    @Override
    public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
      return standardTailSet(fromElement);
    }
    @SuppressWarnings("unchecked")
    @Override
    public Comparator&lt;? super E&gt; comparator() {
      Comparator&lt;? super E&gt; forwardComparator = forward.comparator();
      if (forwardComparator == null) {
        return (Comparator) Ordering.natural().reverse();
      } else {
        return reverse(forwardComparator);
      }
    }
    private static &lt;T extends @Nullable Object&gt; Ordering&lt;T&gt; reverse(Comparator&lt;T&gt; forward) {
      return Ordering.from(forward).reverse();
    }
    @Override
    @ParametricNullness
    public E first() {
      return forward.last();
    }
    @Override
    @ParametricNullness
    public E last() {
      return forward.first();
    }
    @Override
    public Iterator&lt;E&gt; iterator() {
      return forward.descendingIterator();
    }
    @Override
    public @Nullable Object[] toArray() {
      return standardToArray();
    }
    @Override
    @SuppressWarnings("nullness")     public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
      return standardToArray(array);
    }
    @Override
    public String toString() {
      return standardToString();
    }
  }
  @Beta
  @GwtIncompatible   public static &lt;K extends Comparable&lt;? super K&gt;&gt; NavigableSet&lt;K&gt; subSet(
      NavigableSet&lt;K&gt; set, Range&lt;K&gt; range) {
    if (set.comparator() != null
        &amp;&amp; set.comparator() != Ordering.natural()
        &amp;&amp; range.hasLowerBound()
        &amp;&amp; range.hasUpperBound()) {
      checkArgument(
          set.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) &lt;= 0,
          "set is using a custom comparator which is inconsistent with the natural ordering.");
    }
    if (range.hasLowerBound() &amp;&amp; range.hasUpperBound()) {
      return set.subSet(
          range.lowerEndpoint(),
          range.lowerBoundType() == BoundType.CLOSED,
          range.upperEndpoint(),
          range.upperBoundType() == BoundType.CLOSED);
    } else if (range.hasLowerBound()) {
      return set.tailSet(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED);
    } else if (range.hasUpperBound()) {
      return set.headSet(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);
    }
    return checkNotNull(set);
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
