<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TreeMultimapExplicitTest_1.java &amp; Sets_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TreeMultimapExplicitTest_1.java &amp; Sets_1.java
      </h3>
<h1 align="center">
        2.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TreeMultimapExplicitTest_1.java (11.217949%)<th>Sets_1.java (1.5164645%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-37)<td><a href="#" name="0">(46-70)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(55-58)<td><a href="#" name="1">(1986-1989)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(48-51)<td><a href="#" name="2">(121-124)</a><td align="center"><font color="#a30000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeMultimapExplicitTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.collect;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.truth.Truth.assertThat;
4 import com.google.common.annotations.GwtCompatible;
5 import com.google.common.annotations.GwtIncompatible;
6 import com.google.common.testing.SerializableTester;
7 import java.util.Arrays;
8 import java.util.Collection;
9 import java.util.Comparator;
10 import java.util.Iterator;
11 import java.util.Map.Entry;
12 import java.util.SortedSet;
13 import junit.framework.TestCase;
14 @GwtCompatible(e</b></font>mulated = true)
15 public class TreeMultimapExplicitTest extends TestCase {
16   private enum StringLength implements Comparator&lt;String&gt; {
17 <a name="2"></a>    COMPARATOR;
18     @Override
19     public int compare(String first, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>String second) {
20       if (first == second) {
21         return 0;
22       } else if (first == null) {</b></font>
23 <a name="1"></a>        return -1;
24       } else if (second == null) {
25         return 1;
26       } else <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if (first.length() != second.length()) {
27         return first.length() - second.length();
28       } else {
29         return first.compareTo</b></font>(second);
30       }
31     }
32   }
33   private static final Comparator&lt;Integer&gt; DECREASING_INT_COMPARATOR =
34       Ordering.&lt;Integer&gt;natural().reverse().nullsFirst();
35   private SetMultimap&lt;String, Integer&gt; create() {
36     return TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
37   }
38   private TreeMultimap&lt;String, Integer&gt; createPopulate() {
39     TreeMultimap&lt;String, Integer&gt; multimap =
40         TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
41     multimap.put("google", 2);
42     multimap.put("google", 6);
43     multimap.put(null, 3);
44     multimap.put(null, 1);
45     multimap.put(null, 7);
46     multimap.put("tree", 0);
47     multimap.put("tree", null);
48     return multimap;
49   }
50   public void testMultimapCreateFromTreeMultimap() {
51     TreeMultimap&lt;String, Integer&gt; tree =
52         TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
53     tree.put("google", 2);
54     tree.put("google", 6);
55     tree.put("tree", 0);
56     tree.put("tree", 3);
57     assertThat(tree.keySet()).containsExactly("tree", "google").inOrder();
58     assertThat(tree.get("google")).containsExactly(6, 2).inOrder();
59     TreeMultimap&lt;String, Integer&gt; copy = TreeMultimap.create(tree);
60     assertEquals(tree, copy);
61     assertThat(copy.keySet()).containsExactly("google", "tree").inOrder();
62     assertThat(copy.get("google")).containsExactly(2, 6).inOrder();
63     assertEquals(Ordering.natural(), copy.keyComparator());
64     assertEquals(Ordering.natural(), copy.valueComparator());
65     assertEquals(Ordering.natural(), copy.get("google").comparator());
66   }
67   public void testToString() {
68     Multimap&lt;String, Integer&gt; multimap = create();
69     multimap.put("foo", 3);
70     multimap.put("bar", 1);
71     multimap.putAll("foo", Arrays.asList(-1, 2, 4));
72     multimap.putAll("bar", Arrays.asList(2, 3));
73     multimap.put("foo", 1);
74     assertEquals("{bar=[3, 2, 1], foo=[4, 3, 2, 1, -1]}", multimap.toString());
75   }
76   public void testGetComparator() {
77     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
78     assertEquals(StringLength.COMPARATOR, multimap.keyComparator());
79     assertEquals(DECREASING_INT_COMPARATOR, multimap.valueComparator());
80   }
81   public void testOrderedGet() {
82     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
83     assertThat(multimap.get(null)).containsExactly(7, 3, 1).inOrder();
84     assertThat(multimap.get("google")).containsExactly(6, 2).inOrder();
85     assertThat(multimap.get("tree")).containsExactly(null, 0).inOrder();
86   }
87   public void testOrderedKeySet() {
88     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
89     assertThat(multimap.keySet()).containsExactly(null, "tree", "google").inOrder();
90   }
91   public void testOrderedAsMapEntries() {
92     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
93     Iterator&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt; iterator = multimap.asMap().entrySet().iterator();
94     Entry&lt;String, Collection&lt;Integer&gt;&gt; entry = iterator.next();
95     assertEquals(null, entry.getKey());
96     assertThat(entry.getValue()).containsExactly(7, 3, 1);
97     entry = iterator.next();
98     assertEquals("tree", entry.getKey());
99     assertThat(entry.getValue()).containsExactly(null, 0);
100     entry = iterator.next();
101     assertEquals("google", entry.getKey());
102     assertThat(entry.getValue()).containsExactly(6, 2);
103   }
104   public void testOrderedEntries() {
105     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
106     assertThat(multimap.entries())
107         .containsExactly(
108             Maps.immutableEntry((String) null, 7),
109             Maps.immutableEntry((String) null, 3),
110             Maps.immutableEntry((String) null, 1),
111             Maps.immutableEntry("tree", (Integer) null),
112             Maps.immutableEntry("tree", 0),
113             Maps.immutableEntry("google", 6),
114             Maps.immutableEntry("google", 2))
115         .inOrder();
116   }
117   public void testOrderedValues() {
118     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
119     assertThat(multimap.values()).containsExactly(7, 3, 1, null, 0, 6, 2).inOrder();
120   }
121   public void testComparator() {
122     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
123     assertEquals(DECREASING_INT_COMPARATOR, multimap.get("foo").comparator());
124     assertEquals(DECREASING_INT_COMPARATOR, multimap.get("missing").comparator());
125   }
126   public void testMultimapComparators() {
127     Multimap&lt;String, Integer&gt; multimap = create();
128     multimap.put("foo", 3);
129     multimap.put("bar", 1);
130     multimap.putAll("foo", Arrays.asList(-1, 2, 4));
131     multimap.putAll("bar", Arrays.asList(2, 3));
132     multimap.put("foo", 1);
133     TreeMultimap&lt;String, Integer&gt; copy =
134         TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
135     copy.putAll(multimap);
136     assertEquals(multimap, copy);
137     assertEquals(StringLength.COMPARATOR, copy.keyComparator());
138     assertEquals(DECREASING_INT_COMPARATOR, copy.valueComparator());
139   }
140   public void testSortedKeySet() {
141     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
142     SortedSet&lt;String&gt; keySet = multimap.keySet();
143     assertEquals(null, keySet.first());
144     assertEquals("google", keySet.last());
145     assertEquals(StringLength.COMPARATOR, keySet.comparator());
146     assertEquals(Sets.newHashSet(null, "tree"), keySet.headSet("yahoo"));
147     assertEquals(Sets.newHashSet("google"), keySet.tailSet("yahoo"));
148     assertEquals(Sets.newHashSet("tree"), keySet.subSet("ask", "yahoo"));
149   }
150   @GwtIncompatible   public void testExplicitComparatorSerialization() {
151     TreeMultimap&lt;String, Integer&gt; multimap = createPopulate();
152     TreeMultimap&lt;String, Integer&gt; copy = SerializableTester.reserializeAndAssert(multimap);
153     assertThat(copy.values()).containsExactly(7, 3, 1, null, 0, 6, 2).inOrder();
154     assertThat(copy.keySet()).containsExactly(null, "tree", "google").inOrder();
155     assertEquals(multimap.keyComparator(), copy.keyComparator());
156     assertEquals(multimap.valueComparator(), copy.valueComparator());
157   }
158 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Sets_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
5 import com.google.common.annotations.Beta;
6 import com.google.common.annotations.GwtCompatible;
7 import com.google.common.annotations.GwtIncompatible;
8 import com.google.common.base.Predicate;
9 import com.google.common.base.Predicates;
10 import com.google.common.collect.Collections2.FilteredCollection;
11 import com.google.common.math.IntMath;
12 import com.google.errorprone.annotations.CanIgnoreReturnValue;
13 import com.google.errorprone.annotations.DoNotCall;
14 import java.io.Serializable;
15 import java.util.AbstractSet;
16 import java.util.Arrays;
17 import java.util.BitSet;
18 import java.util.Collection;
19 import java.util.Collections;
20 import java.util.Comparator;
21 import java.util.EnumSet;
22 import java.util.HashSet;
23 import java.util.Iterator;
24 import java.util.LinkedHashSet;
25 <a name="0"></a>import java.util.List;
26 import java.util.Map;
27 import java.util.NavigableSet;
28 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.NoSuchElementException;
29 import java.util.Set;
30 import java.util.SortedSet;
31 import java.util.TreeSet;
32 import java.util.concurrent.ConcurrentHashMap;
33 import java.util.concurrent.CopyOnWriteArraySet;
34 import java.util.function.Consumer;
35 import java.util.stream.Collector;
36 import java.util.stream.Stream;
37 import javax.annotation.CheckForNull;
38 import org.checkerframework.checker.nullness.qual.Nullable;
39 @GwtCompatible(e</b></font>mulated = true)
40 @ElementTypesAreNonnullByDefault
41 public final class Sets {
42   private Sets() {}
43   abstract static class ImprovedAbstractSet&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
44     @Override
45     public boolean removeAll(Collection&lt;?&gt; c) {
46       return removeAllImpl(this, c);
47     }
48     @Override
49     public boolean retainAll(Collection&lt;?&gt; c) {
50       return super.retainAll(checkNotNull(c));     }
51   }
52   @GwtCompatible(serializable = true)
53   public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(
54       E anElement, E... otherElements) {
55     return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));
56   }
57   @GwtCompatible(serializable = true)
58   public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Iterable&lt;E&gt; elements) {
59     if (elements instanceof ImmutableEnumSet) {
60       return (ImmutableEnumSet&lt;E&gt;) elements;
61     } else if (elements instanceof Collection) {</b></font>
62       Collection&lt;E&gt; collection = (Collection&lt;E&gt;) elements;
63       if (collection.isEmpty()) {
64         return ImmutableSet.of();
65       } else {
66         return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));
67       }
68     } else {
69       Iterator&lt;E&gt; itr = elements.iterator();
70       if (itr.hasNext()) {
71         EnumSet&lt;E&gt; enumSet = EnumSet.of(itr.next());
72         Iterators.addAll(enumSet, itr);
73         return ImmutableEnumSet.asImmutable(enumSet);
74       } else {
75         return ImmutableSet.of();
76       }
77     }
78   }
79   public static &lt;E extends Enum&lt;E&gt;&gt; Collector&lt;E, ?, ImmutableSet&lt;E&gt;&gt; toImmutableEnumSet() {
80     return CollectCollectors.toImmutableEnumSet();
81   }
82   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; newEnumSet(
83       Iterable&lt;E&gt; iterable, Class&lt;E&gt; elementType) {
84     EnumSet&lt;E&gt; set = EnumSet.noneOf(elementType);
85     Iterables.addAll(set, iterable);
86     return set;
87   }
88   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet() {
89     return new HashSet&lt;E&gt;();
90   }
91   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(E... elements) {
92     HashSet&lt;E&gt; set = newHashSetWithExpectedSize(elements.length);
93     Collections.addAll(set, elements);
94     return set;
95   }
96   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterable&lt;? extends E&gt; elements) {
97     return (elements instanceof Collection)
98         ? new HashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements)
99         : newHashSet(elements.iterator());
100   }
101   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterator&lt;? extends E&gt; elements) {
102     HashSet&lt;E&gt; set = newHashSet();
103     Iterators.addAll(set, elements);
104     return set;
105   }
106   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSetWithExpectedSize(
107       int expectedSize) {
108     return new HashSet&lt;E&gt;(Maps.capacity(expectedSize));
109   }
110   public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet() {
111     return Platform.newConcurrentHashSet();
112   }
113   public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet(Iterable&lt;? extends E&gt; elements) {
114     Set&lt;E&gt; set = newConcurrentHashSet();
115     Iterables.addAll(set, elements);
116     return set;
117   }
118   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet() {
119     return new LinkedHashSet&lt;E&gt;();
120   }
121   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet(
122       Iterable&lt;? extends E&gt; elements) {
123     if (elements instanceof Collection) {
124       return new LinkedHashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements);
125     }
126     LinkedHashSet&lt;E&gt; set = newLinkedHashSet();
127     Iterables.addAll(set, elements);
128     return set;
129   }
130   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSetWithExpectedSize(
131       int expectedSize) {
132     return new LinkedHashSet&lt;E&gt;(Maps.capacity(expectedSize));
133   }
134   public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet() {
135     return new TreeSet&lt;E&gt;();
136   }
137   public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet(Iterable&lt;? extends E&gt; elements) {
138     TreeSet&lt;E&gt; set = newTreeSet();
139     Iterables.addAll(set, elements);
140     return set;
141   }
142   public static &lt;E extends @Nullable Object&gt; TreeSet&lt;E&gt; newTreeSet(
143       Comparator&lt;? super E&gt; comparator) {
144     return new TreeSet&lt;E&gt;(checkNotNull(comparator));
145   }
146   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newIdentityHashSet() {
147     return Collections.newSetFromMap(Maps.&lt;E, Boolean&gt;newIdentityHashMap());
148   }
149   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet() {
150     return new CopyOnWriteArraySet&lt;E&gt;();
151   }
152   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet(
153       Iterable&lt;? extends E&gt; elements) {
154     Collection&lt;? extends E&gt; elementsCollection =
155         (elements instanceof Collection)
156             ? (Collection&lt;? extends E&gt;) elements
157             : Lists.newArrayList(elements);
158     return new CopyOnWriteArraySet&lt;E&gt;(elementsCollection);
159   }
160   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(Collection&lt;E&gt; collection) {
161     if (collection instanceof EnumSet) {
162       return EnumSet.complementOf((EnumSet&lt;E&gt;) collection);
163     }
164     checkArgument(
165         !collection.isEmpty(), "collection is empty; use the other version of this method");
166     Class&lt;E&gt; type = collection.iterator().next().getDeclaringClass();
167     return makeComplementByHand(collection, type);
168   }
169   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(
170       Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
171     checkNotNull(collection);
172     return (collection instanceof EnumSet)
173         ? EnumSet.complementOf((EnumSet&lt;E&gt;) collection)
174         : makeComplementByHand(collection, type);
175   }
176   private static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; makeComplementByHand(
177       Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
178     EnumSet&lt;E&gt; result = EnumSet.allOf(type);
179     result.removeAll(collection);
180     return result;
181   }
182   @Deprecated
183   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newSetFromMap(
184       Map&lt;E, Boolean&gt; map) {
185     return Collections.newSetFromMap(map);
186   }
187   public abstract static class SetView&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
188     private SetView() {} 
189     @SuppressWarnings("nullness")     public ImmutableSet&lt;E&gt; immutableCopy() {
190       return ImmutableSet.copyOf(this);
191     }
192     @CanIgnoreReturnValue
193     public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
194       set.addAll(this);
195       return set;
196     }
197     @CanIgnoreReturnValue
198     @Deprecated
199     @Override
200     @DoNotCall("Always throws UnsupportedOperationException")
201     public final boolean add(@ParametricNullness E e) {
202       throw new UnsupportedOperationException();
203     }
204     @CanIgnoreReturnValue
205     @Deprecated
206     @Override
207     @DoNotCall("Always throws UnsupportedOperationException")
208     public final boolean remove(@CheckForNull Object object) {
209       throw new UnsupportedOperationException();
210     }
211     @CanIgnoreReturnValue
212     @Deprecated
213     @Override
214     @DoNotCall("Always throws UnsupportedOperationException")
215     public final boolean addAll(Collection&lt;? extends E&gt; newElements) {
216       throw new UnsupportedOperationException();
217     }
218     @CanIgnoreReturnValue
219     @Deprecated
220     @Override
221     @DoNotCall("Always throws UnsupportedOperationException")
222     public final boolean removeAll(Collection&lt;?&gt; oldElements) {
223       throw new UnsupportedOperationException();
224     }
225     @CanIgnoreReturnValue
226     @Deprecated
227     @Override
228     @DoNotCall("Always throws UnsupportedOperationException")
229     public final boolean removeIf(java.util.function.Predicate&lt;? super E&gt; filter) {
230       throw new UnsupportedOperationException();
231     }
232     @CanIgnoreReturnValue
233     @Deprecated
234     @Override
235     @DoNotCall("Always throws UnsupportedOperationException")
236     public final boolean retainAll(Collection&lt;?&gt; elementsToKeep) {
237       throw new UnsupportedOperationException();
238     }
239     @Deprecated
240     @Override
241     @DoNotCall("Always throws UnsupportedOperationException")
242     public final void clear() {
243       throw new UnsupportedOperationException();
244     }
245     @Override
246     public abstract UnmodifiableIterator&lt;E&gt; iterator();
247   }
248   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; union(
249       final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
250     checkNotNull(set1, "set1");
251     checkNotNull(set2, "set2");
252     return new SetView&lt;E&gt;() {
253       @Override
254       public int size() {
255         int size = set1.size();
256         for (E e : set2) {
257           if (!set1.contains(e)) {
258             size++;
259           }
260         }
261         return size;
262       }
263       @Override
264       public boolean isEmpty() {
265         return set1.isEmpty() &amp;&amp; set2.isEmpty();
266       }
267       @Override
268       public UnmodifiableIterator&lt;E&gt; iterator() {
269         return new AbstractIterator&lt;E&gt;() {
270           final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
271           final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
272           @Override
273           @CheckForNull
274           protected E computeNext() {
275             if (itr1.hasNext()) {
276               return itr1.next();
277             }
278             while (itr2.hasNext()) {
279               E e = itr2.next();
280               if (!set1.contains(e)) {
281                 return e;
282               }
283             }
284             return endOfData();
285           }
286         };
287       }
288       @Override
289       public Stream&lt;E&gt; stream() {
290         return Stream.concat(set1.stream(), set2.stream().filter((E e) -&gt; !set1.contains(e)));
291       }
292       @Override
293       public Stream&lt;E&gt; parallelStream() {
294         return stream().parallel();
295       }
296       @Override
297       public boolean contains(@CheckForNull Object object) {
298         return set1.contains(object) || set2.contains(object);
299       }
300       @Override
301       public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
302         set.addAll(set1);
303         set.addAll(set2);
304         return set;
305       }
306       @Override
307       @SuppressWarnings("nullness")       public ImmutableSet&lt;E&gt; immutableCopy() {
308         return new ImmutableSet.Builder&lt;E&gt;().addAll(set1).addAll(set2).build();
309       }
310     };
311   }
312   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; intersection(
313       final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
314     checkNotNull(set1, "set1");
315     checkNotNull(set2, "set2");
316     return new SetView&lt;E&gt;() {
317       @Override
318       public UnmodifiableIterator&lt;E&gt; iterator() {
319         return new AbstractIterator&lt;E&gt;() {
320           final Iterator&lt;E&gt; itr = set1.iterator();
321           @Override
322           @CheckForNull
323           protected E computeNext() {
324             while (itr.hasNext()) {
325               E e = itr.next();
326               if (set2.contains(e)) {
327                 return e;
328               }
329             }
330             return endOfData();
331           }
332         };
333       }
334       @Override
335       public Stream&lt;E&gt; stream() {
336         return set1.stream().filter(set2::contains);
337       }
338       @Override
339       public Stream&lt;E&gt; parallelStream() {
340         return set1.parallelStream().filter(set2::contains);
341       }
342       @Override
343       public int size() {
344         int size = 0;
345         for (E e : set1) {
346           if (set2.contains(e)) {
347             size++;
348           }
349         }
350         return size;
351       }
352       @Override
353       public boolean isEmpty() {
354         return Collections.disjoint(set2, set1);
355       }
356       @Override
357       public boolean contains(@CheckForNull Object object) {
358         return set1.contains(object) &amp;&amp; set2.contains(object);
359       }
360       @Override
361       public boolean containsAll(Collection&lt;?&gt; collection) {
362         return set1.containsAll(collection) &amp;&amp; set2.containsAll(collection);
363       }
364     };
365   }
366   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; difference(
367       final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
368     checkNotNull(set1, "set1");
369     checkNotNull(set2, "set2");
370     return new SetView&lt;E&gt;() {
371       @Override
372       public UnmodifiableIterator&lt;E&gt; iterator() {
373         return new AbstractIterator&lt;E&gt;() {
374           final Iterator&lt;E&gt; itr = set1.iterator();
375           @Override
376           @CheckForNull
377           protected E computeNext() {
378             while (itr.hasNext()) {
379               E e = itr.next();
380               if (!set2.contains(e)) {
381                 return e;
382               }
383             }
384             return endOfData();
385           }
386         };
387       }
388       @Override
389       public Stream&lt;E&gt; stream() {
390         return set1.stream().filter(e -&gt; !set2.contains(e));
391       }
392       @Override
393       public Stream&lt;E&gt; parallelStream() {
394         return set1.parallelStream().filter(e -&gt; !set2.contains(e));
395       }
396       @Override
397       public int size() {
398         int size = 0;
399         for (E e : set1) {
400           if (!set2.contains(e)) {
401             size++;
402           }
403         }
404         return size;
405       }
406       @Override
407       public boolean isEmpty() {
408         return set2.containsAll(set1);
409       }
410       @Override
411       public boolean contains(@CheckForNull Object element) {
412         return set1.contains(element) &amp;&amp; !set2.contains(element);
413       }
414     };
415   }
416   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; symmetricDifference(
417       final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
418     checkNotNull(set1, "set1");
419     checkNotNull(set2, "set2");
420     return new SetView&lt;E&gt;() {
421       @Override
422       public UnmodifiableIterator&lt;E&gt; iterator() {
423         final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
424         final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
425         return new AbstractIterator&lt;E&gt;() {
426           @Override
427           @CheckForNull
428           public E computeNext() {
429             while (itr1.hasNext()) {
430               E elem1 = itr1.next();
431               if (!set2.contains(elem1)) {
432                 return elem1;
433               }
434             }
435             while (itr2.hasNext()) {
436               E elem2 = itr2.next();
437               if (!set1.contains(elem2)) {
438                 return elem2;
439               }
440             }
441             return endOfData();
442           }
443         };
444       }
445       @Override
446       public int size() {
447         int size = 0;
448         for (E e : set1) {
449           if (!set2.contains(e)) {
450             size++;
451           }
452         }
453         for (E e : set2) {
454           if (!set1.contains(e)) {
455             size++;
456           }
457         }
458         return size;
459       }
460       @Override
461       public boolean isEmpty() {
462         return set1.equals(set2);
463       }
464       @Override
465       public boolean contains(@CheckForNull Object element) {
466         return set1.contains(element) ^ set2.contains(element);
467       }
468     };
469   }
470   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; filter(
471       Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
472     if (unfiltered instanceof SortedSet) {
473       return filter((SortedSet&lt;E&gt;) unfiltered, predicate);
474     }
475     if (unfiltered instanceof FilteredSet) {
476       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
477       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
478       return new FilteredSet&lt;E&gt;((Set&lt;E&gt;) filtered.unfiltered, combinedPredicate);
479     }
480     return new FilteredSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
481   }
482   public static &lt;E extends @Nullable Object&gt; SortedSet&lt;E&gt; filter(
483       SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
484     if (unfiltered instanceof FilteredSet) {
485       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
486       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
487       return new FilteredSortedSet&lt;E&gt;((SortedSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
488     }
489     return new FilteredSortedSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
490   }
491   @GwtIncompatible   @SuppressWarnings("unchecked")
492   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; filter(
493       NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
494     if (unfiltered instanceof FilteredSet) {
495       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
496       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
497       return new FilteredNavigableSet&lt;E&gt;((NavigableSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
498     }
499     return new FilteredNavigableSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
500   }
501   private static class FilteredSet&lt;E extends @Nullable Object&gt; extends FilteredCollection&lt;E&gt;
502       implements Set&lt;E&gt; {
503     FilteredSet(Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
504       super(unfiltered, predicate);
505     }
506     @Override
507     public boolean equals(@CheckForNull Object object) {
508       return equalsImpl(this, object);
509     }
510     @Override
511     public int hashCode() {
512       return hashCodeImpl(this);
513     }
514   }
515   private static class FilteredSortedSet&lt;E extends @Nullable Object&gt; extends FilteredSet&lt;E&gt;
516       implements SortedSet&lt;E&gt; {
517     FilteredSortedSet(SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
518       super(unfiltered, predicate);
519     }
520     @Override
521     @CheckForNull
522     public Comparator&lt;? super E&gt; comparator() {
523       return ((SortedSet&lt;E&gt;) unfiltered).comparator();
524     }
525     @Override
526     public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
527       return new FilteredSortedSet&lt;E&gt;(
528           ((SortedSet&lt;E&gt;) unfiltered).subSet(fromElement, toElement), predicate);
529     }
530     @Override
531     public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
532       return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).headSet(toElement), predicate);
533     }
534     @Override
535     public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
536       return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).tailSet(fromElement), predicate);
537     }
538     @Override
539     @ParametricNullness
540     public E first() {
541       return Iterators.find(unfiltered.iterator(), predicate);
542     }
543     @Override
544     @ParametricNullness
545     public E last() {
546       SortedSet&lt;E&gt; sortedUnfiltered = (SortedSet&lt;E&gt;) unfiltered;
547       while (true) {
548         E element = sortedUnfiltered.last();
549         if (predicate.apply(element)) {
550           return element;
551         }
552         sortedUnfiltered = sortedUnfiltered.headSet(element);
553       }
554     }
555   }
556   @GwtIncompatible   private static class FilteredNavigableSet&lt;E extends @Nullable Object&gt; extends FilteredSortedSet&lt;E&gt;
557       implements NavigableSet&lt;E&gt; {
558     FilteredNavigableSet(NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
559       super(unfiltered, predicate);
560     }
561     NavigableSet&lt;E&gt; unfiltered() {
562       return (NavigableSet&lt;E&gt;) unfiltered;
563     }
564     @Override
565     @CheckForNull
566     public E lower(@ParametricNullness E e) {
567       return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);
568     }
569     @Override
570     @CheckForNull
571     public E floor(@ParametricNullness E e) {
572       return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);
573     }
574     @Override
575     @CheckForNull
576     public E ceiling(@ParametricNullness E e) {
577       return Iterables.find(unfiltered().tailSet(e, true), predicate, null);
578     }
579     @Override
580     @CheckForNull
581     public E higher(@ParametricNullness E e) {
582       return Iterables.find(unfiltered().tailSet(e, false), predicate, null);
583     }
584     @Override
585     @CheckForNull
586     public E pollFirst() {
587       return Iterables.removeFirstMatching(unfiltered(), predicate);
588     }
589     @Override
590     @CheckForNull
591     public E pollLast() {
592       return Iterables.removeFirstMatching(unfiltered().descendingSet(), predicate);
593     }
594     @Override
595     public NavigableSet&lt;E&gt; descendingSet() {
596       return Sets.filter(unfiltered().descendingSet(), predicate);
597     }
598     @Override
599     public Iterator&lt;E&gt; descendingIterator() {
600       return Iterators.filter(unfiltered().descendingIterator(), predicate);
601     }
602     @Override
603     @ParametricNullness
604     public E last() {
605       return Iterators.find(unfiltered().descendingIterator(), predicate);
606     }
607     @Override
608     public NavigableSet&lt;E&gt; subSet(
609         @ParametricNullness E fromElement,
610         boolean fromInclusive,
611         @ParametricNullness E toElement,
612         boolean toInclusive) {
613       return filter(
614           unfiltered().subSet(fromElement, fromInclusive, toElement, toInclusive), predicate);
615     }
616     @Override
617     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
618       return filter(unfiltered().headSet(toElement, inclusive), predicate);
619     }
620     @Override
621     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
622       return filter(unfiltered().tailSet(fromElement, inclusive), predicate);
623     }
624   }
625   public static &lt;B&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(List&lt;? extends Set&lt;? extends B&gt;&gt; sets) {
626     return CartesianSet.create(sets);
627   }
628   @SafeVarargs
629   public static &lt;B&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(Set&lt;? extends B&gt;... sets) {
630     return cartesianProduct(Arrays.asList(sets));
631   }
632   private static final class CartesianSet&lt;E&gt; extends ForwardingCollection&lt;List&lt;E&gt;&gt;
633       implements Set&lt;List&lt;E&gt;&gt; {
634     private final transient ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes;
635     private final transient CartesianList&lt;E&gt; delegate;
636     static &lt;E&gt; Set&lt;List&lt;E&gt;&gt; create(List&lt;? extends Set&lt;? extends E&gt;&gt; sets) {
637       ImmutableList.Builder&lt;ImmutableSet&lt;E&gt;&gt; axesBuilder = new ImmutableList.Builder&lt;&gt;(sets.size());
638       for (Set&lt;? extends E&gt; set : sets) {
639         ImmutableSet&lt;E&gt; copy = ImmutableSet.copyOf(set);
640         if (copy.isEmpty()) {
641           return ImmutableSet.of();
642         }
643         axesBuilder.add(copy);
644       }
645       final ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes = axesBuilder.build();
646       ImmutableList&lt;List&lt;E&gt;&gt; listAxes =
647           new ImmutableList&lt;List&lt;E&gt;&gt;() {
648             @Override
649             public int size() {
650               return axes.size();
651             }
652             @Override
653             public List&lt;E&gt; get(int index) {
654               return axes.get(index).asList();
655             }
656             @Override
657             boolean isPartialView() {
658               return true;
659             }
660           };
661       return new CartesianSet&lt;E&gt;(axes, new CartesianList&lt;E&gt;(listAxes));
662     }
663     private CartesianSet(ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes, CartesianList&lt;E&gt; delegate) {
664       this.axes = axes;
665       this.delegate = delegate;
666     }
667     @Override
668     protected Collection&lt;List&lt;E&gt;&gt; delegate() {
669       return delegate;
670     }
671     @Override
672     public boolean contains(@CheckForNull Object object) {
673       if (!(object instanceof List)) {
674         return false;
675       }
676       List&lt;?&gt; list = (List&lt;?&gt;) object;
677       if (list.size() != axes.size()) {
678         return false;
679       }
680       int i = 0;
681       for (Object o : list) {
682         if (!axes.get(i).contains(o)) {
683           return false;
684         }
685         i++;
686       }
687       return true;
688     }
689     @Override
690     public boolean equals(@CheckForNull Object object) {
691       if (object instanceof CartesianSet) {
692         CartesianSet&lt;?&gt; that = (CartesianSet&lt;?&gt;) object;
693         return this.axes.equals(that.axes);
694       }
695       return super.equals(object);
696     }
697     @Override
698     public int hashCode() {
699       int adjust = size() - 1;
700       for (int i = 0; i &lt; axes.size(); i++) {
701         adjust *= 31;
702         adjust = ~~adjust;
703       }
704       int hash = 1;
705       for (Set&lt;E&gt; axis : axes) {
706         hash = 31 * hash + (size() / axis.size() * axis.hashCode());
707         hash = ~~hash;
708       }
709       hash += adjust;
710       return ~~hash;
711     }
712   }
713   @GwtCompatible(serializable = false)
714   public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; powerSet(Set&lt;E&gt; set) {
715     return new PowerSet&lt;E&gt;(set);
716   }
717   private static final class SubSet&lt;E&gt; extends AbstractSet&lt;E&gt; {
718     private final ImmutableMap&lt;E, Integer&gt; inputSet;
719     private final int mask;
720     SubSet(ImmutableMap&lt;E, Integer&gt; inputSet, int mask) {
721       this.inputSet = inputSet;
722       this.mask = mask;
723     }
724     @Override
725     public Iterator&lt;E&gt; iterator() {
726       return new UnmodifiableIterator&lt;E&gt;() {
727         final ImmutableList&lt;E&gt; elements = inputSet.keySet().asList();
728         int remainingSetBits = mask;
729         @Override
730         public boolean hasNext() {
731           return remainingSetBits != 0;
732         }
733         @Override
734         public E next() {
735           int index = Integer.numberOfTrailingZeros(remainingSetBits);
736           if (index == 32) {
737             throw new NoSuchElementException();
738           }
739           remainingSetBits &amp;= ~(1 &lt;&lt; index);
740           return elements.get(index);
741         }
742       };
743     }
744     @Override
745     public int size() {
746       return Integer.bitCount(mask);
747     }
748     @Override
749     public boolean contains(@CheckForNull Object o) {
750       Integer index = inputSet.get(o);
751       return index != null &amp;&amp; (mask &amp; (1 &lt;&lt; index)) != 0;
752     }
753   }
754   private static final class PowerSet&lt;E&gt; extends AbstractSet&lt;Set&lt;E&gt;&gt; {
755     final ImmutableMap&lt;E, Integer&gt; inputSet;
756     PowerSet(Set&lt;E&gt; input) {
757       checkArgument(
758           input.size() &lt;= 30, "Too many elements to create power set: %s &gt; 30", input.size());
759       this.inputSet = Maps.indexMap(input);
760     }
761     @Override
762     public int size() {
763       return 1 &lt;&lt; inputSet.size();
764     }
765     @Override
766     public boolean isEmpty() {
767       return false;
768     }
769     @Override
770     public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
771       return new AbstractIndexedListIterator&lt;Set&lt;E&gt;&gt;(size()) {
772         @Override
773         protected Set&lt;E&gt; get(final int setBits) {
774           return new SubSet&lt;E&gt;(inputSet, setBits);
775         }
776       };
777     }
778     @Override
779     public boolean contains(@CheckForNull Object obj) {
780       if (obj instanceof Set) {
781         Set&lt;?&gt; set = (Set&lt;?&gt;) obj;
782         return inputSet.keySet().containsAll(set);
783       }
784       return false;
785     }
786     @Override
787     public boolean equals(@CheckForNull Object obj) {
788       if (obj instanceof PowerSet) {
789         PowerSet&lt;?&gt; that = (PowerSet&lt;?&gt;) obj;
790         return inputSet.keySet().equals(that.inputSet.keySet());
791       }
792       return super.equals(obj);
793     }
794     @Override
795     public int hashCode() {
796       return inputSet.keySet().hashCode() &lt;&lt; (inputSet.size() - 1);
797     }
798     @Override
799     public String toString() {
800       return "powerSet(" + inputSet + ")";
801     }
802   }
803   @Beta
804   public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; combinations(Set&lt;E&gt; set, final int size) {
805     final ImmutableMap&lt;E, Integer&gt; index = Maps.indexMap(set);
806     checkNonnegative(size, "size");
807     checkArgument(size &lt;= index.size(), "size (%s) must be &lt;= set.size() (%s)", size, index.size());
808     if (size == 0) {
809       return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(ImmutableSet.&lt;E&gt;of());
810     } else if (size == index.size()) {
811       return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(index.keySet());
812     }
813     return new AbstractSet&lt;Set&lt;E&gt;&gt;() {
814       @Override
815       public boolean contains(@CheckForNull Object o) {
816         if (o instanceof Set) {
817           Set&lt;?&gt; s = (Set&lt;?&gt;) o;
818           return s.size() == size &amp;&amp; index.keySet().containsAll(s);
819         }
820         return false;
821       }
822       @Override
823       public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
824         return new AbstractIterator&lt;Set&lt;E&gt;&gt;() {
825           final BitSet bits = new BitSet(index.size());
826           @Override
827           @CheckForNull
828           protected Set&lt;E&gt; computeNext() {
829             if (bits.isEmpty()) {
830               bits.set(0, size);
831             } else {
832               int firstSetBit = bits.nextSetBit(0);
833               int bitToFlip = bits.nextClearBit(firstSetBit);
834               if (bitToFlip == index.size()) {
835                 return endOfData();
836               }
837               bits.set(0, bitToFlip - firstSetBit - 1);
838               bits.clear(bitToFlip - firstSetBit - 1, bitToFlip);
839               bits.set(bitToFlip);
840             }
841             final BitSet copy = (BitSet) bits.clone();
842             return new AbstractSet&lt;E&gt;() {
843               @Override
844               public boolean contains(@CheckForNull Object o) {
845                 Integer i = index.get(o);
846                 return i != null &amp;&amp; copy.get(i);
847               }
848               @Override
849               public Iterator&lt;E&gt; iterator() {
850                 return new AbstractIterator&lt;E&gt;() {
851                   int i = -1;
852                   @Override
853                   @CheckForNull
854                   protected E computeNext() {
855                     i = copy.nextSetBit(i + 1);
856                     if (i == -1) {
857                       return endOfData();
858                     }
859                     return index.keySet().asList().get(i);
860                   }
861                 };
862               }
863               @Override
864               public int size() {
865                 return size;
866               }
867             };
868           }
869         };
870       }
871       @Override
872       public int size() {
873         return IntMath.binomial(index.size(), size);
874       }
875       @Override
876       public String toString() {
877         return "Sets.combinations(" + index.keySet() + ", " + size + ")";
878       }
879     };
880   }
881   static int hashCodeImpl(Set&lt;?&gt; s) {
882     int hashCode = 0;
883     for (Object o : s) {
884       hashCode += o != null ? o.hashCode() : 0;
885       hashCode = ~~hashCode;
886     }
887     return hashCode;
888   }
889   static boolean equalsImpl(Set&lt;?&gt; s, @CheckForNull Object object) {
890     if (s == object) {
891       return true;
892     }
893     if (object instanceof Set) {
894       Set&lt;?&gt; o = (Set&lt;?&gt;) object;
895       try {
896         return s.size() == o.size() &amp;&amp; s.containsAll(o);
897       } catch (NullPointerException | ClassCastException ignored) {
898         return false;
899       }
900     }
901     return false;
902   }
903   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; unmodifiableNavigableSet(
904       NavigableSet&lt;E&gt; set) {
905     if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet) {
906       return set;
907     }
908     return new UnmodifiableNavigableSet&lt;E&gt;(set);
909   }
910   static final class UnmodifiableNavigableSet&lt;E extends @Nullable Object&gt;
911       extends ForwardingSortedSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Serializable {
912     private final NavigableSet&lt;E&gt; delegate;
913     private final SortedSet&lt;E&gt; unmodifiableDelegate;
914     UnmodifiableNavigableSet(NavigableSet&lt;E&gt; delegate) {
915       this.delegate = checkNotNull(delegate);
916       this.unmodifiableDelegate = Collections.unmodifiableSortedSet(delegate);
917     }
918     @Override
919     protected SortedSet&lt;E&gt; delegate() {
920       return unmodifiableDelegate;
921     }
922     @Override
923     public boolean removeIf(java.util.function.Predicate&lt;? super E&gt; filter) {
924       throw new UnsupportedOperationException();
925     }
926     @Override
927     public Stream&lt;E&gt; stream() {
928       return delegate.stream();
929     }
930     @Override
931     public Stream&lt;E&gt; parallelStream() {
932       return delegate.parallelStream();
933     }
934     @Override
935     public void forEach(Consumer&lt;? super E&gt; action) {
936       delegate.forEach(action);
937     }
938     @Override
939     @CheckForNull
940     public E lower(@ParametricNullness E e) {
941       return delegate.lower(e);
942     }
943     @Override
944     @CheckForNull
945     public E floor(@ParametricNullness E e) {
946       return delegate.floor(e);
947     }
948     @Override
949     @CheckForNull
950     public E ceiling(@ParametricNullness E e) {
951       return delegate.ceiling(e);
952     }
953     @Override
954     @CheckForNull
955     public E higher(@ParametricNullness E e) {
956       return delegate.higher(e);
957     }
958     @Override
959     @CheckForNull
960     public E pollFirst() {
961       throw new UnsupportedOperationException();
962     }
963     @Override
964     @CheckForNull
965     public E pollLast() {
966       throw new UnsupportedOperationException();
967     }
968     @CheckForNull private transient UnmodifiableNavigableSet&lt;E&gt; descendingSet;
969     @Override
970     public NavigableSet&lt;E&gt; descendingSet() {
971       UnmodifiableNavigableSet&lt;E&gt; result = descendingSet;
972       if (result == null) {
973         result = descendingSet = new UnmodifiableNavigableSet&lt;E&gt;(delegate.descendingSet());
974         result.descendingSet = this;
975       }
976       return result;
977     }
978     @Override
979     public Iterator&lt;E&gt; descendingIterator() {
980       return Iterators.unmodifiableIterator(delegate.descendingIterator());
981     }
982     @Override
983     public NavigableSet&lt;E&gt; subSet(
984         @ParametricNullness E fromElement,
985         boolean fromInclusive,
986         @ParametricNullness E toElement,
987         boolean toInclusive) {
988       return unmodifiableNavigableSet(
989           delegate.subSet(fromElement, fromInclusive, toElement, toInclusive));
990     }
991     @Override
992     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
993       return unmodifiableNavigableSet(delegate.headSet(toElement, inclusive));
994     }
995     @Override
996     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
997       return unmodifiableNavigableSet(delegate.tailSet(fromElement, inclusive));
998     }
999     private static final long serialVersionUID = 0;
1000   }
1001   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; synchronizedNavigableSet(
1002       NavigableSet&lt;E&gt; navigableSet) {
1003     return Synchronized.navigableSet(navigableSet);
1004   }
1005   static boolean removeAllImpl(Set&lt;?&gt; set, Iterator&lt;?&gt; iterator) {
1006     boolean changed = false;
1007     while (iterator.hasNext()) {
1008       changed |= set.remove(iterator.next());
1009     }
1010     return changed;
1011   }
1012   static boolean removeAllImpl(Set&lt;?&gt; set, Collection&lt;?&gt; collection) {
1013     checkNotNull(collection);     if (collection instanceof Multiset) {
1014       collection = ((Multiset&lt;?&gt;) collection).elementSet();
1015     }
1016     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if (collection instanceof Set &amp;&amp; collection.size() &gt; set.size()) {
1017       return Iterators.removeAll(set.iterator(), collection);
1018     } else {
1019       return removeAllImpl</b></font>(set, collection.iterator());
1020     }
1021   }
1022   @GwtIncompatible   static class DescendingSet&lt;E extends @Nullable Object&gt; extends ForwardingNavigableSet&lt;E&gt; {
1023     private final NavigableSet&lt;E&gt; forward;
1024     DescendingSet(NavigableSet&lt;E&gt; forward) {
1025       this.forward = forward;
1026     }
1027     @Override
1028     protected NavigableSet&lt;E&gt; delegate() {
1029       return forward;
1030     }
1031     @Override
1032     @CheckForNull
1033     public E lower(@ParametricNullness E e) {
1034       return forward.higher(e);
1035     }
1036     @Override
1037     @CheckForNull
1038     public E floor(@ParametricNullness E e) {
1039       return forward.ceiling(e);
1040     }
1041     @Override
1042     @CheckForNull
1043     public E ceiling(@ParametricNullness E e) {
1044       return forward.floor(e);
1045     }
1046     @Override
1047     @CheckForNull
1048     public E higher(@ParametricNullness E e) {
1049       return forward.lower(e);
1050     }
1051     @Override
1052     @CheckForNull
1053     public E pollFirst() {
1054       return forward.pollLast();
1055     }
1056     @Override
1057     @CheckForNull
1058     public E pollLast() {
1059       return forward.pollFirst();
1060     }
1061     @Override
1062     public NavigableSet&lt;E&gt; descendingSet() {
1063       return forward;
1064     }
1065     @Override
1066     public Iterator&lt;E&gt; descendingIterator() {
1067       return forward.iterator();
1068     }
1069     @Override
1070     public NavigableSet&lt;E&gt; subSet(
1071         @ParametricNullness E fromElement,
1072         boolean fromInclusive,
1073         @ParametricNullness E toElement,
1074         boolean toInclusive) {
1075       return forward.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();
1076     }
1077     @Override
1078     public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
1079       return standardSubSet(fromElement, toElement);
1080     }
1081     @Override
1082     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
1083       return forward.tailSet(toElement, inclusive).descendingSet();
1084     }
1085     @Override
1086     public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
1087       return standardHeadSet(toElement);
1088     }
1089     @Override
1090     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
1091       return forward.headSet(fromElement, inclusive).descendingSet();
1092     }
1093     @Override
1094     public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
1095       return standardTailSet(fromElement);
1096     }
1097     @SuppressWarnings("unchecked")
1098     @Override
1099     public Comparator&lt;? super E&gt; comparator() {
1100       Comparator&lt;? super E&gt; forwardComparator = forward.comparator();
1101       if (forwardComparator == null) {
1102         return (Comparator) Ordering.natural().reverse();
1103       } else {
1104         return reverse(forwardComparator);
1105       }
1106     }
1107     private static &lt;T extends @Nullable Object&gt; Ordering&lt;T&gt; reverse(Comparator&lt;T&gt; forward) {
1108       return Ordering.from(forward).reverse();
1109     }
1110     @Override
1111     @ParametricNullness
1112     public E first() {
1113       return forward.last();
1114     }
1115     @Override
1116     @ParametricNullness
1117     public E last() {
1118       return forward.first();
1119     }
1120     @Override
1121     public Iterator&lt;E&gt; iterator() {
1122       return forward.descendingIterator();
1123     }
1124     @Override
1125     public @Nullable Object[] toArray() {
1126       return standardToArray();
1127     }
1128     @Override
1129     @SuppressWarnings("nullness")     public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
1130       return standardToArray(array);
1131     }
1132     @Override
1133     public String toString() {
1134       return standardToString();
1135     }
1136   }
1137   @Beta
1138   @GwtIncompatible   public static &lt;K extends Comparable&lt;? super K&gt;&gt; NavigableSet&lt;K&gt; subSet(
1139       NavigableSet&lt;K&gt; set, Range&lt;K&gt; range) {
1140     if (set.comparator() != null
1141         &amp;&amp; set.comparator() != Ordering.natural()
1142         &amp;&amp; range.hasLowerBound()
1143         &amp;&amp; range.hasUpperBound()) {
1144       checkArgument(
1145           set.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) &lt;= 0,
1146           "set is using a custom comparator which is inconsistent with the natural ordering.");
1147     }
1148     if (range.hasLowerBound() &amp;&amp; range.hasUpperBound()) {
1149       return set.subSet(
1150           range.lowerEndpoint(),
1151           range.lowerBoundType() == BoundType.CLOSED,
1152           range.upperEndpoint(),
1153           range.upperBoundType() == BoundType.CLOSED);
1154     } else if (range.hasLowerBound()) {
1155       return set.tailSet(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED);
1156     } else if (range.hasUpperBound()) {
1157       return set.headSet(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);
1158     }
1159     return checkNotNull(set);
1160   }
1161 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
