<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for EmptyCachesTest_1.java &amp; ByteStreams_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for EmptyCachesTest_1.java &amp; ByteStreams_1.java
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>EmptyCachesTest_1.java (2.857143%)<th>ByteStreams_1.java (1.5477214%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-34)<td><a href="#" name="0">(15-34)</a><td align="center"><font color="#ff0000">18</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>EmptyCachesTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.cache;
2 import static com.google.common.cache.CacheTesting.checkEmpty;
3 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
4 import static java.util.Arrays.asList;
5 import static java.util.concurrent.TimeUnit.DAYS;
6 import static java.util.concurrent.TimeUnit.SECONDS;
7 import com.google.common.base.Function;
8 import com.google.common.cache.CacheBuilderFactory.DurationSpec;
9 import com.google.common.cache.LocalCache.Strength;
10 import com.google.common.collect.ImmutableSet;
11 import com.google.common.collect.Iterables;
12 import com.google.common.collect.Maps;
13 import com.google.common.testing.EqualsTester;
14 import java.util.Collection;
15 import java.util.Map.Entry;
16 import java.util.Set;
17 import java.util.concurrent.ExecutionException;
18 import</b></font> junit.framework.TestCase;
19 public class EmptyCachesTest extends TestCase {
20   public void testEmpty() {
21     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
22       checkEmpty(cache);
23     }
24   }
25   public void testInvalidate_empty() {
26     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
27       cache.getUnchecked("a");
28       cache.getUnchecked("b");
29       cache.invalidate("a");
30       cache.invalidate("b");
31       cache.invalidate(0);
32       checkEmpty(cache);
33     }
34   }
35   public void testInvalidateAll_empty() {
36     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
37       cache.getUnchecked("a");
38       cache.getUnchecked("b");
39       cache.getUnchecked("c");
40       cache.invalidateAll();
41       checkEmpty(cache);
42     }
43   }
44   public void testEquals_null() {
45     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
46       assertFalse(cache.equals(null));
47     }
48   }
49   public void testEqualsAndHashCode_different() {
50     for (CacheBuilder&lt;Object, Object&gt; builder : cacheFactory().buildAllPermutations()) {
51       new EqualsTester()
52           .addEqualityGroup(builder.build(identityLoader()))
53           .addEqualityGroup(builder.build(identityLoader()))
54           .addEqualityGroup(builder.build(identityLoader()))
55           .testEquals();
56     }
57   }
58   public void testGet_null() throws ExecutionException {
59     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
60       try {
61         cache.get(null);
62         fail("Expected NullPointerException");
63       } catch (NullPointerException expected) {
64       }
65       checkEmpty(cache);
66     }
67   }
68   public void testGetUnchecked_null() {
69     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
70       try {
71         cache.getUnchecked(null);
72         fail("Expected NullPointerException");
73       } catch (NullPointerException expected) {
74       }
75       checkEmpty(cache);
76     }
77   }
78   public void testKeySet_nullToArray() {
79     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
80       Set&lt;Object&gt; keys = cache.asMap().keySet();
81       try {
82         keys.toArray((Object[]) null);
83         fail();
84       } catch (NullPointerException expected) {
85       }
86       checkEmpty(cache);
87     }
88   }
89   public void testKeySet_addNotSupported() {
90     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
91       try {
92         cache.asMap().keySet().add(1);
93         fail();
94       } catch (UnsupportedOperationException expected) {
95       }
96       try {
97         cache.asMap().keySet().addAll(asList(1, 2));
98         fail();
99       } catch (UnsupportedOperationException expected) {
100       }
101     }
102   }
103   public void testKeySet_clear() {
104     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
105       warmUp(cache, 0, 100);
106       Set&lt;Object&gt; keys = cache.asMap().keySet();
107       keys.clear();
108       checkEmpty(keys);
109       checkEmpty(cache);
110     }
111   }
112   public void testKeySet_empty_remove() {
113     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
114       Set&lt;Object&gt; keys = cache.asMap().keySet();
115       assertFalse(keys.remove(null));
116       assertFalse(keys.remove(6));
117       assertFalse(keys.remove(-6));
118       assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));
119       assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));
120       checkEmpty(keys);
121       checkEmpty(cache);
122     }
123   }
124   public void testKeySet_remove() {
125     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
126       cache.getUnchecked(1);
127       cache.getUnchecked(2);
128       Set&lt;Object&gt; keys = cache.asMap().keySet();
129       keys.remove(1);
130       keys.remove(2);
131       assertFalse(keys.remove(null));
132       assertFalse(keys.remove(6));
133       assertFalse(keys.remove(-6));
134       assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));
135       assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));
136       checkEmpty(keys);
137       checkEmpty(cache);
138     }
139   }
140   public void testValues_nullToArray() {
141     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
142       Collection&lt;Object&gt; values = cache.asMap().values();
143       try {
144         values.toArray((Object[]) null);
145         fail();
146       } catch (NullPointerException expected) {
147       }
148       checkEmpty(cache);
149     }
150   }
151   public void testValues_addNotSupported() {
152     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
153       try {
154         cache.asMap().values().add(1);
155         fail();
156       } catch (UnsupportedOperationException expected) {
157       }
158       try {
159         cache.asMap().values().addAll(asList(1, 2));
160         fail();
161       } catch (UnsupportedOperationException expected) {
162       }
163     }
164   }
165   public void testValues_clear() {
166     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
167       warmUp(cache, 0, 100);
168       Collection&lt;Object&gt; values = cache.asMap().values();
169       values.clear();
170       checkEmpty(values);
171       checkEmpty(cache);
172     }
173   }
174   public void testValues_empty_remove() {
175     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
176       Collection&lt;Object&gt; values = cache.asMap().values();
177       assertFalse(values.remove(null));
178       assertFalse(values.remove(6));
179       assertFalse(values.remove(-6));
180       assertFalse(values.removeAll(asList(null, 0, 15, 1500)));
181       assertFalse(values.retainAll(asList(null, 0, 15, 1500)));
182       checkEmpty(values);
183       checkEmpty(cache);
184     }
185   }
186   public void testValues_remove() {
187     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
188       cache.getUnchecked(1);
189       cache.getUnchecked(2);
190       Collection&lt;Object&gt; values = cache.asMap().keySet();
191       values.remove(1);
192       values.remove(2);
193       assertFalse(values.remove(null));
194       assertFalse(values.remove(6));
195       assertFalse(values.remove(-6));
196       assertFalse(values.removeAll(asList(null, 0, 15, 1500)));
197       assertFalse(values.retainAll(asList(null, 0, 15, 1500)));
198       checkEmpty(values);
199       checkEmpty(cache);
200     }
201   }
202   public void testEntrySet_nullToArray() {
203     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
204       Set&lt;Entry&lt;Object, Object&gt;&gt; entries = cache.asMap().entrySet();
205       try {
206         entries.toArray((Entry&lt;Object, Object&gt;[]) null);
207         fail();
208       } catch (NullPointerException expected) {
209       }
210       checkEmpty(cache);
211     }
212   }
213   public void testEntrySet_addNotSupported() {
214     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
215       try {
216         cache.asMap().entrySet().add(entryOf(1, 1));
217         fail();
218       } catch (UnsupportedOperationException expected) {
219       }
220       try {
221         cache.asMap().values().addAll(asList(entryOf(1, 1), entryOf(2, 2)));
222         fail();
223       } catch (UnsupportedOperationException expected) {
224       }
225     }
226   }
227   public void testEntrySet_clear() {
228     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
229       warmUp(cache, 0, 100);
230       Set&lt;Entry&lt;Object, Object&gt;&gt; entrySet = cache.asMap().entrySet();
231       entrySet.clear();
232       checkEmpty(entrySet);
233       checkEmpty(cache);
234     }
235   }
236   public void testEntrySet_empty_remove() {
237     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
238       Set&lt;Entry&lt;Object, Object&gt;&gt; entrySet = cache.asMap().entrySet();
239       assertFalse(entrySet.remove(null));
240       assertFalse(entrySet.remove(entryOf(6, 6)));
241       assertFalse(entrySet.remove(entryOf(-6, -6)));
242       assertFalse(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15))));
243       assertFalse(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15))));
244       checkEmpty(entrySet);
245       checkEmpty(cache);
246     }
247   }
248   public void testEntrySet_remove() {
249     for (LoadingCache&lt;Object, Object&gt; cache : caches()) {
250       cache.getUnchecked(1);
251       cache.getUnchecked(2);
252       Set&lt;Entry&lt;Object, Object&gt;&gt; entrySet = cache.asMap().entrySet();
253       entrySet.remove(entryOf(1, 1));
254       entrySet.remove(entryOf(2, 2));
255       assertFalse(entrySet.remove(null));
256       assertFalse(entrySet.remove(entryOf(1, 1)));
257       assertFalse(entrySet.remove(entryOf(6, 6)));
258       assertFalse(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15))));
259       assertFalse(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15))));
260       checkEmpty(entrySet);
261       checkEmpty(cache);
262     }
263   }
264   private Iterable&lt;LoadingCache&lt;Object, Object&gt;&gt; caches() {
265     CacheBuilderFactory factory = cacheFactory();
266     return Iterables.transform(
267         factory.buildAllPermutations(),
268         new Function&lt;CacheBuilder&lt;Object, Object&gt;, LoadingCache&lt;Object, Object&gt;&gt;() {
269           @Override
270           public LoadingCache&lt;Object, Object&gt; apply(CacheBuilder&lt;Object, Object&gt; builder) {
271             return builder.build(identityLoader());
272           }
273         });
274   }
275   private CacheBuilderFactory cacheFactory() {
276     return new CacheBuilderFactory()
277         .withKeyStrengths(ImmutableSet.of(Strength.STRONG, Strength.WEAK))
278         .withValueStrengths(ImmutableSet.copyOf(Strength.values()))
279         .withConcurrencyLevels(ImmutableSet.of(1, 4, 16, 64))
280         .withMaximumSizes(ImmutableSet.of(0, 1, 10, 100, 1000))
281         .withInitialCapacities(ImmutableSet.of(0, 1, 10, 100, 1000))
282         .withExpireAfterWrites(
283             ImmutableSet.of(
284                 DurationSpec.of(0, SECONDS), DurationSpec.of(1, SECONDS), DurationSpec.of(1, DAYS)))
285         .withExpireAfterAccesses(
286             ImmutableSet.of(
287                 DurationSpec.of(0, SECONDS), DurationSpec.of(1, SECONDS), DurationSpec.of(1, DAYS)))
288         .withRefreshes(ImmutableSet.of(DurationSpec.of(1, SECONDS), DurationSpec.of(1, DAYS)));
289   }
290   private static void warmUp(LoadingCache&lt;Object, Object&gt; cache, int minimum, int maximum) {
291     for (int i = minimum; i &lt; maximum; i++) {
292       cache.getUnchecked(i);
293     }
294   }
295   private Entry&lt;Object, Object&gt; entryOf(Object key, Object value) {
296     return Maps.immutableEntry(key, value);
297   }
298 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ByteStreams_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.io;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.base.Preconditions.checkPositionIndex;
5 import static com.google.common.base.Preconditions.checkPositionIndexes;
6 import static java.lang.Math.max;
7 import static java.lang.Math.min;
8 import com.google.common.annotations.Beta;
9 import com.google.common.annotations.GwtIncompatible;
10 import com.google.common.math.IntMath;
11 import com.google.errorprone.annotations.CanIgnoreReturnValue;
12 import java.io.ByteArrayInputStream;
13 import java.io.ByteArrayOutputStream;
14 import java.io.DataInput;
15 import java.io.DataInputStream;
16 import java.io.DataOutput;
17 import java.io.DataOutputStream;
18 import</b></font> java.io.EOFException;
19 import java.io.FilterInputStream;
20 import java.io.IOException;
21 import java.io.InputStream;
22 import java.io.OutputStream;
23 import java.nio.ByteBuffer;
24 import java.nio.channels.FileChannel;
25 import java.nio.channels.ReadableByteChannel;
26 import java.nio.channels.WritableByteChannel;
27 import java.util.ArrayDeque;
28 import java.util.Arrays;
29 import java.util.Queue;
30 import javax.annotation.CheckForNull;
31 import org.checkerframework.checker.nullness.qual.Nullable;
32 @GwtIncompatible
33 @ElementTypesAreNonnullByDefault
34 public final class ByteStreams {
35   private static final int BUFFER_SIZE = 8192;
36   static byte[] createBuffer() {
37     return new byte[BUFFER_SIZE];
38   }
39   private static final int ZERO_COPY_CHUNK_SIZE = 512 * 1024;
40   private ByteStreams() {}
41   @CanIgnoreReturnValue
42   public static long copy(InputStream from, OutputStream to) throws IOException {
43     checkNotNull(from);
44     checkNotNull(to);
45     byte[] buf = createBuffer();
46     long total = 0;
47     while (true) {
48       int r = from.read(buf);
49       if (r == -1) {
50         break;
51       }
52       to.write(buf, 0, r);
53       total += r;
54     }
55     return total;
56   }
57   @CanIgnoreReturnValue
58   public static long copy(ReadableByteChannel from, WritableByteChannel to) throws IOException {
59     checkNotNull(from);
60     checkNotNull(to);
61     if (from instanceof FileChannel) {
62       FileChannel sourceChannel = (FileChannel) from;
63       long oldPosition = sourceChannel.position();
64       long position = oldPosition;
65       long copied;
66       do {
67         copied = sourceChannel.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
68         position += copied;
69         sourceChannel.position(position);
70       } while (copied &gt; 0 || position &lt; sourceChannel.size());
71       return position - oldPosition;
72     }
73     ByteBuffer buf = ByteBuffer.wrap(createBuffer());
74     long total = 0;
75     while (from.read(buf) != -1) {
76       Java8Compatibility.flip(buf);
77       while (buf.hasRemaining()) {
78         total += to.write(buf);
79       }
80       Java8Compatibility.clear(buf);
81     }
82     return total;
83   }
84   private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
85   private static final int TO_BYTE_ARRAY_DEQUE_SIZE = 20;
86   private static byte[] toByteArrayInternal(InputStream in, Queue&lt;byte[]&gt; bufs, int totalLen)
87       throws IOException {
88     int initialBufferSize = min(BUFFER_SIZE, max(128, Integer.highestOneBit(totalLen) * 2));
89     for (int bufSize = initialBufferSize;
90         totalLen &lt; MAX_ARRAY_LEN;
91         bufSize = IntMath.saturatedMultiply(bufSize, bufSize &lt; 4096 ? 4 : 2)) {
92       byte[] buf = new byte[min(bufSize, MAX_ARRAY_LEN - totalLen)];
93       bufs.add(buf);
94       int off = 0;
95       while (off &lt; buf.length) {
96         int r = in.read(buf, off, buf.length - off);
97         if (r == -1) {
98           return combineBuffers(bufs, totalLen);
99         }
100         off += r;
101         totalLen += r;
102       }
103     }
104     if (in.read() == -1) {
105       return combineBuffers(bufs, MAX_ARRAY_LEN);
106     } else {
107       throw new OutOfMemoryError("input is too large to fit in a byte array");
108     }
109   }
110   private static byte[] combineBuffers(Queue&lt;byte[]&gt; bufs, int totalLen) {
111     if (bufs.isEmpty()) {
112       return new byte[0];
113     }
114     byte[] result = bufs.remove();
115     if (result.length == totalLen) {
116       return result;
117     }
118     int remaining = totalLen - result.length;
119     result = Arrays.copyOf(result, totalLen);
120     while (remaining &gt; 0) {
121       byte[] buf = bufs.remove();
122       int bytesToCopy = min(remaining, buf.length);
123       int resultOffset = totalLen - remaining;
124       System.arraycopy(buf, 0, result, resultOffset, bytesToCopy);
125       remaining -= bytesToCopy;
126     }
127     return result;
128   }
129   public static byte[] toByteArray(InputStream in) throws IOException {
130     checkNotNull(in);
131     return toByteArrayInternal(in, new ArrayDeque&lt;byte[]&gt;(TO_BYTE_ARRAY_DEQUE_SIZE), 0);
132   }
133   static byte[] toByteArray(InputStream in, long expectedSize) throws IOException {
134     checkArgument(expectedSize &gt;= 0, "expectedSize (%s) must be non-negative", expectedSize);
135     if (expectedSize &gt; MAX_ARRAY_LEN) {
136       throw new OutOfMemoryError(expectedSize + " bytes is too large to fit in a byte array");
137     }
138     byte[] bytes = new byte[(int) expectedSize];
139     int remaining = (int) expectedSize;
140     while (remaining &gt; 0) {
141       int off = (int) expectedSize - remaining;
142       int read = in.read(bytes, off, remaining);
143       if (read == -1) {
144         return Arrays.copyOf(bytes, off);
145       }
146       remaining -= read;
147     }
148     int b = in.read();
149     if (b == -1) {
150       return bytes;
151     }
152     Queue&lt;byte[]&gt; bufs = new ArrayDeque&lt;&gt;(TO_BYTE_ARRAY_DEQUE_SIZE + 2);
153     bufs.add(bytes);
154     bufs.add(new byte[] {(byte) b});
155     return toByteArrayInternal(in, bufs, bytes.length + 1);
156   }
157   @CanIgnoreReturnValue
158   @Beta
159   public static long exhaust(InputStream in) throws IOException {
160     long total = 0;
161     long read;
162     byte[] buf = createBuffer();
163     while ((read = in.read(buf)) != -1) {
164       total += read;
165     }
166     return total;
167   }
168   @Beta
169   public static ByteArrayDataInput newDataInput(byte[] bytes) {
170     return newDataInput(new ByteArrayInputStream(bytes));
171   }
172   @Beta
173   public static ByteArrayDataInput newDataInput(byte[] bytes, int start) {
174     checkPositionIndex(start, bytes.length);
175     return newDataInput(new ByteArrayInputStream(bytes, start, bytes.length - start));
176   }
177   @Beta
178   public static ByteArrayDataInput newDataInput(ByteArrayInputStream byteArrayInputStream) {
179     return new ByteArrayDataInputStream(checkNotNull(byteArrayInputStream));
180   }
181   private static class ByteArrayDataInputStream implements ByteArrayDataInput {
182     final DataInput input;
183     ByteArrayDataInputStream(ByteArrayInputStream byteArrayInputStream) {
184       this.input = new DataInputStream(byteArrayInputStream);
185     }
186     @Override
187     public void readFully(byte b[]) {
188       try {
189         input.readFully(b);
190       } catch (IOException e) {
191         throw new IllegalStateException(e);
192       }
193     }
194     @Override
195     public void readFully(byte b[], int off, int len) {
196       try {
197         input.readFully(b, off, len);
198       } catch (IOException e) {
199         throw new IllegalStateException(e);
200       }
201     }
202     @Override
203     public int skipBytes(int n) {
204       try {
205         return input.skipBytes(n);
206       } catch (IOException e) {
207         throw new IllegalStateException(e);
208       }
209     }
210     @Override
211     public boolean readBoolean() {
212       try {
213         return input.readBoolean();
214       } catch (IOException e) {
215         throw new IllegalStateException(e);
216       }
217     }
218     @Override
219     public byte readByte() {
220       try {
221         return input.readByte();
222       } catch (EOFException e) {
223         throw new IllegalStateException(e);
224       } catch (IOException impossible) {
225         throw new AssertionError(impossible);
226       }
227     }
228     @Override
229     public int readUnsignedByte() {
230       try {
231         return input.readUnsignedByte();
232       } catch (IOException e) {
233         throw new IllegalStateException(e);
234       }
235     }
236     @Override
237     public short readShort() {
238       try {
239         return input.readShort();
240       } catch (IOException e) {
241         throw new IllegalStateException(e);
242       }
243     }
244     @Override
245     public int readUnsignedShort() {
246       try {
247         return input.readUnsignedShort();
248       } catch (IOException e) {
249         throw new IllegalStateException(e);
250       }
251     }
252     @Override
253     public char readChar() {
254       try {
255         return input.readChar();
256       } catch (IOException e) {
257         throw new IllegalStateException(e);
258       }
259     }
260     @Override
261     public int readInt() {
262       try {
263         return input.readInt();
264       } catch (IOException e) {
265         throw new IllegalStateException(e);
266       }
267     }
268     @Override
269     public long readLong() {
270       try {
271         return input.readLong();
272       } catch (IOException e) {
273         throw new IllegalStateException(e);
274       }
275     }
276     @Override
277     public float readFloat() {
278       try {
279         return input.readFloat();
280       } catch (IOException e) {
281         throw new IllegalStateException(e);
282       }
283     }
284     @Override
285     public double readDouble() {
286       try {
287         return input.readDouble();
288       } catch (IOException e) {
289         throw new IllegalStateException(e);
290       }
291     }
292     @Override
293     @CheckForNull
294     public String readLine() {
295       try {
296         return input.readLine();
297       } catch (IOException e) {
298         throw new IllegalStateException(e);
299       }
300     }
301     @Override
302     public String readUTF() {
303       try {
304         return input.readUTF();
305       } catch (IOException e) {
306         throw new IllegalStateException(e);
307       }
308     }
309   }
310   @Beta
311   public static ByteArrayDataOutput newDataOutput() {
312     return newDataOutput(new ByteArrayOutputStream());
313   }
314   @Beta
315   public static ByteArrayDataOutput newDataOutput(int size) {
316     if (size &lt; 0) {
317       throw new IllegalArgumentException(String.format("Invalid size: %s", size));
318     }
319     return newDataOutput(new ByteArrayOutputStream(size));
320   }
321   @Beta
322   public static ByteArrayDataOutput newDataOutput(ByteArrayOutputStream byteArrayOutputStream) {
323     return new ByteArrayDataOutputStream(checkNotNull(byteArrayOutputStream));
324   }
325   private static class ByteArrayDataOutputStream implements ByteArrayDataOutput {
326     final DataOutput output;
327     final ByteArrayOutputStream byteArrayOutputStream;
328     ByteArrayDataOutputStream(ByteArrayOutputStream byteArrayOutputStream) {
329       this.byteArrayOutputStream = byteArrayOutputStream;
330       output = new DataOutputStream(byteArrayOutputStream);
331     }
332     @Override
333     public void write(int b) {
334       try {
335         output.write(b);
336       } catch (IOException impossible) {
337         throw new AssertionError(impossible);
338       }
339     }
340     @Override
341     public void write(byte[] b) {
342       try {
343         output.write(b);
344       } catch (IOException impossible) {
345         throw new AssertionError(impossible);
346       }
347     }
348     @Override
349     public void write(byte[] b, int off, int len) {
350       try {
351         output.write(b, off, len);
352       } catch (IOException impossible) {
353         throw new AssertionError(impossible);
354       }
355     }
356     @Override
357     public void writeBoolean(boolean v) {
358       try {
359         output.writeBoolean(v);
360       } catch (IOException impossible) {
361         throw new AssertionError(impossible);
362       }
363     }
364     @Override
365     public void writeByte(int v) {
366       try {
367         output.writeByte(v);
368       } catch (IOException impossible) {
369         throw new AssertionError(impossible);
370       }
371     }
372     @Override
373     public void writeBytes(String s) {
374       try {
375         output.writeBytes(s);
376       } catch (IOException impossible) {
377         throw new AssertionError(impossible);
378       }
379     }
380     @Override
381     public void writeChar(int v) {
382       try {
383         output.writeChar(v);
384       } catch (IOException impossible) {
385         throw new AssertionError(impossible);
386       }
387     }
388     @Override
389     public void writeChars(String s) {
390       try {
391         output.writeChars(s);
392       } catch (IOException impossible) {
393         throw new AssertionError(impossible);
394       }
395     }
396     @Override
397     public void writeDouble(double v) {
398       try {
399         output.writeDouble(v);
400       } catch (IOException impossible) {
401         throw new AssertionError(impossible);
402       }
403     }
404     @Override
405     public void writeFloat(float v) {
406       try {
407         output.writeFloat(v);
408       } catch (IOException impossible) {
409         throw new AssertionError(impossible);
410       }
411     }
412     @Override
413     public void writeInt(int v) {
414       try {
415         output.writeInt(v);
416       } catch (IOException impossible) {
417         throw new AssertionError(impossible);
418       }
419     }
420     @Override
421     public void writeLong(long v) {
422       try {
423         output.writeLong(v);
424       } catch (IOException impossible) {
425         throw new AssertionError(impossible);
426       }
427     }
428     @Override
429     public void writeShort(int v) {
430       try {
431         output.writeShort(v);
432       } catch (IOException impossible) {
433         throw new AssertionError(impossible);
434       }
435     }
436     @Override
437     public void writeUTF(String s) {
438       try {
439         output.writeUTF(s);
440       } catch (IOException impossible) {
441         throw new AssertionError(impossible);
442       }
443     }
444     @Override
445     public byte[] toByteArray() {
446       return byteArrayOutputStream.toByteArray();
447     }
448   }
449   private static final OutputStream NULL_OUTPUT_STREAM =
450       new OutputStream() {
451         @Override
452         public void write(int b) {}
453         @Override
454         public void write(byte[] b) {
455           checkNotNull(b);
456         }
457         @Override
458         public void write(byte[] b, int off, int len) {
459           checkNotNull(b);
460           checkPositionIndexes(off, off + len, b.length);
461         }
462         @Override
463         public String toString() {
464           return "ByteStreams.nullOutputStream()";
465         }
466       };
467   @Beta
468   public static OutputStream nullOutputStream() {
469     return NULL_OUTPUT_STREAM;
470   }
471   @Beta
472   public static InputStream limit(InputStream in, long limit) {
473     return new LimitedInputStream(in, limit);
474   }
475   private static final class LimitedInputStream extends FilterInputStream {
476     private long left;
477     private long mark = -1;
478     LimitedInputStream(InputStream in, long limit) {
479       super(in);
480       checkNotNull(in);
481       checkArgument(limit &gt;= 0, "limit must be non-negative");
482       left = limit;
483     }
484     @Override
485     public int available() throws IOException {
486       return (int) Math.min(in.available(), left);
487     }
488     @Override
489     public synchronized void mark(int readLimit) {
490       in.mark(readLimit);
491       mark = left;
492     }
493     @Override
494     public int read() throws IOException {
495       if (left == 0) {
496         return -1;
497       }
498       int result = in.read();
499       if (result != -1) {
500         --left;
501       }
502       return result;
503     }
504     @Override
505     public int read(byte[] b, int off, int len) throws IOException {
506       if (left == 0) {
507         return -1;
508       }
509       len = (int) Math.min(len, left);
510       int result = in.read(b, off, len);
511       if (result != -1) {
512         left -= result;
513       }
514       return result;
515     }
516     @Override
517     public synchronized void reset() throws IOException {
518       if (!in.markSupported()) {
519         throw new IOException("Mark not supported");
520       }
521       if (mark == -1) {
522         throw new IOException("Mark not set");
523       }
524       in.reset();
525       left = mark;
526     }
527     @Override
528     public long skip(long n) throws IOException {
529       n = Math.min(n, left);
530       long skipped = in.skip(n);
531       left -= skipped;
532       return skipped;
533     }
534   }
535   @Beta
536   public static void readFully(InputStream in, byte[] b) throws IOException {
537     readFully(in, b, 0, b.length);
538   }
539   @Beta
540   public static void readFully(InputStream in, byte[] b, int off, int len) throws IOException {
541     int read = read(in, b, off, len);
542     if (read != len) {
543       throw new EOFException(
544           "reached end of stream after reading " + read + " bytes; " + len + " bytes expected");
545     }
546   }
547   @Beta
548   public static void skipFully(InputStream in, long n) throws IOException {
549     long skipped = skipUpTo(in, n);
550     if (skipped &lt; n) {
551       throw new EOFException(
552           "reached end of stream after skipping " + skipped + " bytes; " + n + " bytes expected");
553     }
554   }
555   static long skipUpTo(InputStream in, long n) throws IOException {
556     long totalSkipped = 0;
557     byte[] buf = null;
558     while (totalSkipped &lt; n) {
559       long remaining = n - totalSkipped;
560       long skipped = skipSafely(in, remaining);
561       if (skipped == 0) {
562         int skip = (int) Math.min(remaining, BUFFER_SIZE);
563         if (buf == null) {
564           buf = new byte[skip];
565         }
566         if ((skipped = in.read(buf, 0, skip)) == -1) {
567           break;
568         }
569       }
570       totalSkipped += skipped;
571     }
572     return totalSkipped;
573   }
574   private static long skipSafely(InputStream in, long n) throws IOException {
575     int available = in.available();
576     return available == 0 ? 0 : in.skip(Math.min(available, n));
577   }
578   @Beta
579   @CanIgnoreReturnValue   @ParametricNullness
580   public static &lt;T extends @Nullable Object&gt; T readBytes(
581       InputStream input, ByteProcessor&lt;T&gt; processor) throws IOException {
582     checkNotNull(input);
583     checkNotNull(processor);
584     byte[] buf = createBuffer();
585     int read;
586     do {
587       read = input.read(buf);
588     } while (read != -1 &amp;&amp; processor.processBytes(buf, 0, read));
589     return processor.getResult();
590   }
591   @Beta
592   @CanIgnoreReturnValue
593   public static int read(InputStream in, byte[] b, int off, int len) throws IOException {
594     checkNotNull(in);
595     checkNotNull(b);
596     if (len &lt; 0) {
597       throw new IndexOutOfBoundsException(String.format("len (%s) cannot be negative", len));
598     }
599     checkPositionIndexes(off, off + len, b.length);
600     int total = 0;
601     while (total &lt; len) {
602       int result = in.read(b, off + total, len - total);
603       if (result == -1) {
604         break;
605       }
606       total += result;
607     }
608     return total;
609   }
610 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
