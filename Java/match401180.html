<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TransportClusterRerouteAction.java & SourceFieldMapper.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TransportClusterRerouteAction.java & SourceFieldMapper.java
      </h3>
      <h1 align="center">
        24.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TransportClusterRerouteAction.java (25.0%)<TH>SourceFieldMapper.java (23.170732%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match401180-0.html#0',2,'match401180-1.html#0',3)" NAME="0">(54-64)<TD><A HREF="javascript:ZweiFrames('match401180-0.html#0',2,'match401180-1.html#0',3)" NAME="0">(133-142)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match401180-0.html#1',2,'match401180-1.html#1',3)" NAME="1">(28-44)<TD><A HREF="javascript:ZweiFrames('match401180-0.html#1',2,'match401180-1.html#1',3)" NAME="1">(22-38)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match401180-0.html#2',2,'match401180-1.html#2',3)" NAME="2">(68-74)<TD><A HREF="javascript:ZweiFrames('match401180-0.html#2',2,'match401180-1.html#2',3)" NAME="2">(73-78)</A><TD ALIGN=center><FONT COLOR="#b60000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TransportClusterRerouteAction.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.action.admin.cluster.reroute;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.message.ParameterizedMessage;
import org.elasticsearch.action.ActionListener;
<A NAME="1"></A>import org.elasticsearch.action.support.master.TransportMasterNodeAction;
import org.elasticsearch.cluster.AckedClusterStateUpdateTask;
import org.elasticsearch.cluster.ClusterState;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match401180-1.html#1',3,'match401180-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import org.elasticsearch.cluster.block.ClusterBlockException;
import org.elasticsearch.cluster.block.ClusterBlockLevel;
import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
import org.elasticsearch.cluster.routing.allocation.AllocationService;
import org.elasticsearch.cluster.routing.allocation.RoutingExplanations;
import org.elasticsearch.cluster.service.ClusterService;
import org.elasticsearch.common.Priority;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.threadpool.ThreadPool;
import org.elasticsearch.transport.TransportService;

import java.io.IOException;

public class TransportClusterRerouteAction extends TransportMasterNodeAction&lt;ClusterRerouteRequest, ClusterRerouteResponse&gt; {

    private final AllocationService allocationService</B></FONT>;

    @Inject
    public TransportClusterRerouteAction(TransportService transportService,
                                         ClusterService clusterService,
                                         ThreadPool threadPool,
                                         AllocationService allocationService,
<A NAME="0"></A>                                         IndexNameExpressionResolver indexNameExpressionResolver) {
        super(ClusterRerouteAction.NAME, transportService, clusterService, threadPool, ClusterRerouteRequest::new, indexNameExpressionResolver);
        this.allocationService = allocationService;
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match401180-1.html#0',3,'match401180-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    protected String executor() {
        // we go async right away
        return ThreadPool.Names.SAME;
    }

    @Override
    protected ClusterBlockException checkBlock(ClusterRerouteRequest request, ClusterState state) {
        return</B></FONT> state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);
<A NAME="2"></A>    }

    @Override
    protected ClusterRerouteResponse read(<FONT color="#980517"><A HREF="javascript:ZweiFrames('match401180-1.html#2',3,'match401180-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>StreamInput in) throws IOException {
        return new ClusterRerouteResponse(in);
    }

    @Override
    protected void masterOperation(final ClusterRerouteRequest request,
                                   final ClusterState state</B></FONT>,
                                   final ActionListener&lt;ClusterRerouteResponse&gt; listener) {
        ActionListener&lt;ClusterRerouteResponse&gt; logWrapper = ActionListener.map(
            listener,
            response -&gt; {
                if (request.dryRun() == false) {
                    response.getExplanations().getYesDecisionMessages().forEach(logger::info);
                }
                return response;
            }
        );

        clusterService.submitStateUpdateTask(&quot;cluster_reroute (api)&quot;, new ClusterRerouteResponseAckedClusterStateUpdateTask(logger,
            allocationService, request, logWrapper));
    }

    static class ClusterRerouteResponseAckedClusterStateUpdateTask extends AckedClusterStateUpdateTask&lt;ClusterRerouteResponse&gt; {

        private final ClusterRerouteRequest request;
        private final ActionListener&lt;ClusterRerouteResponse&gt; listener;
        private final Logger logger;
        private final AllocationService allocationService;
        private volatile ClusterState clusterStateToSend;
        private volatile RoutingExplanations explanations;

        ClusterRerouteResponseAckedClusterStateUpdateTask(Logger logger, AllocationService allocationService, ClusterRerouteRequest request,
                                                          ActionListener&lt;ClusterRerouteResponse&gt; listener) {
            super(Priority.IMMEDIATE, request, listener);
            this.request = request;
            this.listener = listener;
            this.logger = logger;
            this.allocationService = allocationService;
        }

        @Override
        protected ClusterRerouteResponse newResponse(boolean acknowledged) {
            return new ClusterRerouteResponse(acknowledged, clusterStateToSend, explanations);
        }

        @Override
        public void onAckTimeout() {
            listener.onResponse(new ClusterRerouteResponse(false, clusterStateToSend, new RoutingExplanations()));
        }

        @Override
        public void onFailure(String source, Exception e) {
            logger.debug(() -&gt; new ParameterizedMessage(&quot;failed to perform [{}]&quot;, source), e);
            super.onFailure(source, e);
        }

        @Override
        public ClusterState execute(ClusterState currentState) {
            AllocationService.CommandsResult commandsResult =
                allocationService.reroute(currentState, request.getCommands(), request.explain(), request.isRetryFailed());
            clusterStateToSend = commandsResult.getClusterState();
            explanations = commandsResult.explanations();
            if (request.dryRun()) {
                return currentState;
            }
            return commandsResult.getClusterState();
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SourceFieldMapper.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
<A NAME="1"></A>
package org.elasticsearch.index.mapper;

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match401180-0.html#1',2,'match401180-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.apache.lucene.document.FieldType;
import org.apache.lucene.document.NumericDocValuesField;
import org.apache.lucene.document.StoredField;
import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.IndexableField;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.xcontent.XContentBuilder;

public class SourceFieldMapper extends MetadataFieldMapper {

    public static final String NAME = &quot;_source&quot;</B></FONT>;
    public static final String RECOVERY_SOURCE_NAME = &quot;_recovery_source&quot;;

    public static final String CONTENT_TYPE = &quot;_source&quot;;

    public static class Defaults {
        public static final String NAME = SourceFieldMapper.NAME;

        public static final FieldType FIELD_TYPE = new FieldType();

        static {
            FIELD_TYPE.setIndexOptions(IndexOptions.NONE); // not indexed
            FIELD_TYPE.setStored(true);
            FIELD_TYPE.setOmitNorms(true);
            FIELD_TYPE.freeze();
        }

    }

    public static class Builder extends MetadataFieldMapper.Builder&lt;Builder&gt; {


        public Builder() {
            super(Defaults.NAME, new FieldType(Defaults.FIELD_TYPE));
        }

        @Override
        public SourceFieldMapper build(BuilderContext context) {
            return new SourceFieldMapper(context.indexSettings());
        }
    }

<A NAME="2"></A>    public static class TypeParser implements MetadataFieldMapper.TypeParser {

        @Override
        public MetadataFieldMapper.Builder&lt;?&gt; parse(String name, Map&lt;String, Object&gt; node, <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match401180-0.html#2',2,'match401180-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ParserContext parserContext) throws MapperParsingException {
            return new Builder();
        }

        @Override
        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context</B></FONT>) {
            final Settings indexSettings = context.mapperService().getIndexSettings().getSettings();
            return new SourceFieldMapper(indexSettings);
        }
    }

    static final class SourceFieldType extends MappedFieldType {

        public static final SourceFieldType INSTANCE = new SourceFieldType();

        private SourceFieldType() {
            super(NAME, false, false);
        }

        @Override
        public String typeName() {
            return CONTENT_TYPE;
        }

    }


    private SourceFieldMapper(Settings indexSettings) {
        super(Defaults.FIELD_TYPE, SourceFieldType.INSTANCE, indexSettings);
    }

    @Override
    public void preParse(ParseContext context) throws IOException {
        super.parse(context);
    }

    @Override
    public void parse(ParseContext context) throws IOException {
        // nothing to do here, we will call it in pre parse
    }

    @Override
    protected void parseCreateField(ParseContext context, List&lt;IndexableField&gt; fields) throws IOException {
        BytesReference originalSource = context.sourceToParse().source();
        BytesReference source = originalSource;
        if (fieldType.stored() &amp;&amp; source != null) {
            // Percolate and tv APIs may not set the source and that is ok, because these APIs will not index any data
            BytesRef ref = source.toBytesRef();
            fields.add(new StoredField(fieldType().name(), ref.bytes, ref.offset, ref.length));
        } else {
            source = null;
        }

        if (originalSource != null &amp;&amp; source != originalSource &amp;&amp; context.indexSettings().isSoftDeleteEnabled()) {
            // if we omitted source or modified it we add the _recovery_source to ensure we
            // have it for ops based recovery
            BytesRef ref = originalSource.toBytesRef();
<A NAME="0"></A>            fields.add(new StoredField(RECOVERY_SOURCE_NAME, ref.bytes, ref.offset, ref.length));
            fields.add(new NumericDocValuesField(RECOVERY_SOURCE_NAME, 1));
        }
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match401180-0.html#0',2,'match401180-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    protected String contentType() {
        return CONTENT_TYPE;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        return</B></FONT> builder;
    }

    @Override
    protected void mergeOptions(FieldMapper other, List&lt;String&gt; conflicts) {
    }
}
</PRE>
</div>
  </div>
</body>
</html>
