<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for SafeTreeSet.java & CharSource.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for SafeTreeSet.java & CharSource.java
      </h3>
      <h1 align="center">
        18.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>SafeTreeSet.java (26.1708%)<TH>CharSource.java (14.179105%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match250916-0.html#0',2,'match250916-1.html#0',3)" NAME="0">(146-163)<TD><A HREF="javascript:ZweiFrames('match250916-0.html#0',2,'match250916-1.html#0',3)" NAME="0">(481-498)</A><TD ALIGN=center><FONT COLOR="#ff0000">25</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match250916-0.html#1',2,'match250916-1.html#1',3)" NAME="1">(115-126)<TD><A HREF="javascript:ZweiFrames('match250916-0.html#1',2,'match250916-1.html#1',3)" NAME="1">(454-465)</A><TD ALIGN=center><FONT COLOR="#c10000">19</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match250916-0.html#2',2,'match250916-1.html#2',3)" NAME="2">(166-174)<TD><A HREF="javascript:ZweiFrames('match250916-0.html#2',2,'match250916-1.html#2',3)" NAME="2">(125-166)</A><TD ALIGN=center><FONT COLOR="#7a0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match250916-0.html#3',2,'match250916-1.html#3',3)" NAME="3">(190-196)<TD><A HREF="javascript:ZweiFrames('match250916-0.html#3',2,'match250916-1.html#3',3)" NAME="3">(547-553)</A><TD ALIGN=center><FONT COLOR="#700000">11</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match250916-0.html#4',2,'match250916-1.html#4',3)" NAME="4">(19-34)<TD><A HREF="javascript:ZweiFrames('match250916-0.html#4',2,'match250916-1.html#4',3)" NAME="4">(31-79)</A><TD ALIGN=center><FONT COLOR="#660000">10</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match250916-0.html#5',2,'match250916-1.html#5',3)" NAME="5">(218-223)<TD><A HREF="javascript:ZweiFrames('match250916-0.html#5',2,'match250916-1.html#5',3)" NAME="5">(530-535)</A><TD ALIGN=center><FONT COLOR="#5b0000">9</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match250916-0.html#6',2,'match250916-1.html#6',3)" NAME="6">(78-83)<TD><A HREF="javascript:ZweiFrames('match250916-0.html#6',2,'match250916-1.html#6',3)" NAME="6">(648-653)</A><TD ALIGN=center><FONT COLOR="#5b0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SafeTreeSet.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2010 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="4"></A>
package com.google.common.collect.testing;

<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match250916-1.html#4',3,'match250916-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import com.google.common.annotations.GwtIncompatible;
import java.io.Serializable;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NavigableSet;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * A wrapper around {@code TreeSet} that aggressively checks to see if elements are mutually
 * comparable. This implementation passes the navigable set test suites.
 *
 * @author Louis Wasserman
 */
@</B></FONT>GwtIncompatible
public final class SafeTreeSet&lt;E&gt; implements Serializable, NavigableSet&lt;E&gt; {
  @SuppressWarnings(&quot;unchecked&quot;)
  private static final Comparator&lt;Object&gt; NATURAL_ORDER =
      new Comparator&lt;Object&gt;() {
        @Override
        public int compare(Object o1, Object o2) {
          return ((Comparable&lt;Object&gt;) o1).compareTo(o2);
        }
      };

  private final NavigableSet&lt;E&gt; delegate;

  public SafeTreeSet() {
    this(new TreeSet&lt;E&gt;());
  }

  public SafeTreeSet(Collection&lt;? extends E&gt; collection) {
    this(new TreeSet&lt;E&gt;(collection));
  }

  public SafeTreeSet(Comparator&lt;? super E&gt; comparator) {
    this(new TreeSet&lt;E&gt;(comparator));
  }

  public SafeTreeSet(SortedSet&lt;E&gt; set) {
    this(new TreeSet&lt;E&gt;(set));
  }

  private SafeTreeSet(NavigableSet&lt;E&gt; delegate) {
    this.delegate = delegate;
    for (E e : this) {
      checkValid(e);
    }
  }

  @Override
  public boolean add(E element) {
    return delegate.add(checkValid(element));
  }

<A NAME="6"></A>  @Override
  public boolean addAll(Collection&lt;? extends E&gt; collection) {
    for (E e : collection) {
      <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match250916-1.html#6',3,'match250916-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkValid(e);
    }
    return delegate.addAll(collection);
  }

  @</B></FONT>Override
  public E ceiling(E e) {
    return delegate.ceiling(checkValid(e));
  }

  @Override
  public void clear() {
    delegate.clear();
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public Comparator&lt;? super E&gt; comparator() {
    Comparator&lt;? super E&gt; comparator = delegate.comparator();
    if (comparator == null) {
      comparator = (Comparator&lt;? super E&gt;) NATURAL_ORDER;
    }
    return comparator;
  }

  @Override
  public boolean contains(Object object) {
    return delegate.contains(checkValid(object));
  }

  @Override
  public boolean containsAll(Collection&lt;?&gt; c) {
    return delegate.containsAll(c);
  }
<A NAME="1"></A>
  @Override
  public Iterator&lt;E&gt; descendingIterator() {
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match250916-1.html#1',3,'match250916-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return delegate.descendingIterator();
  }

  @Override
  public NavigableSet&lt;E&gt; descendingSet() {
    return new SafeTreeSet&lt;&gt;(delegate.descendingSet());
  }

  @Override
  public E first() {
    return delegate.first();
  }</B></FONT>

  @Override
  public E floor(E e) {
    return delegate.floor(checkValid(e));
  }

  @Override
  public SortedSet&lt;E&gt; headSet(E toElement) {
    return headSet(toElement, false);
  }

  @Override
  public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
    return new SafeTreeSet&lt;&gt;(delegate.headSet(checkValid(toElement), inclusive));
  }

<A NAME="0"></A>  @Override
  public E higher(E e) {
    return delegate.higher(checkValid(e));
  <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match250916-1.html#0',3,'match250916-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

  @Override
  public boolean isEmpty() {
    return delegate.isEmpty();
  }

  @Override
  public Iterator&lt;E&gt; iterator() {
    return delegate.iterator();
  }

  @Override
  public E last() {
    return delegate.last();
  }

<A NAME="2"></A>  @</B></FONT>Override
  public E lower(E e) {
    return delegate.lower(checkValid(e));
  <FONT color="#980517"><A HREF="javascript:ZweiFrames('match250916-1.html#2',3,'match250916-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

  @Override
  public E pollFirst() {
    return delegate.pollFirst();
  }

  @Override
  public E pollLast() {</B></FONT>
    return delegate.pollLast();
  }

  @Override
  public boolean remove(Object object) {
    return delegate.remove(checkValid(object));
  }

  @Override
  public boolean removeAll(Collection&lt;?&gt; c) {
    return delegate.removeAll(c);
  }
<A NAME="3"></A>
  @Override
  public boolean retainAll(Collection&lt;?&gt; c) {
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match250916-1.html#3',3,'match250916-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return delegate.retainAll(c);
  }

  @Override
  public int size() {
    return delegate.size();
  }</B></FONT>

  @Override
  public NavigableSet&lt;E&gt; subSet(
      E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
    return new SafeTreeSet&lt;&gt;(
        delegate.subSet(
            checkValid(fromElement), fromInclusive, checkValid(toElement), toInclusive));
  }

  @Override
  public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
    return subSet(fromElement, true, toElement, false);
  }

  @Override
  public SortedSet&lt;E&gt; tailSet(E fromElement) {
    return tailSet(fromElement, true);
  }
<A NAME="5"></A>
  @Override
  public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
    return new SafeTreeSet&lt;&gt;(<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match250916-1.html#5',3,'match250916-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>delegate.tailSet(checkValid(fromElement), inclusive));
  }

  @Override
  public Object[] toArray() {
    return delegate.toArray</B></FONT>();
  }

  @Override
  public &lt;T&gt; T[] toArray(T[] a) {
    return delegate.toArray(a);
  }

  private &lt;T&gt; T checkValid(T t) {
    // a ClassCastException is what's supposed to happen!
    @SuppressWarnings(&quot;unchecked&quot;)
    E e = (E) t;
    comparator().compare(e, e);
    return t;
  }

  @Override
  public boolean equals(Object obj) {
    return delegate.equals(obj);
  }

  @Override
  public int hashCode() {
    return delegate.hashCode();
  }

  @Override
  public String toString() {
    return delegate.toString();
  }

  private static final long serialVersionUID = 0L;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CharSource.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.io;

import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Ascii;
import com.google.common.base.Optional;
import com.google.common.base.Splitter;
import com.google.common.collect.AbstractIterator;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
<A NAME="4"></A>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match250916-0.html#4',2,'match250916-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.io.Reader;
import java.io.StringReader;
import java.io.Writer;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.List;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A readable source of characters, such as a text file. Unlike a {@link Reader}, a {@code
 * CharSource} is not an open, stateful stream of characters that can be read and closed. Instead,
 * it is an immutable &lt;i&gt;supplier&lt;/i&gt; of {@code Reader} instances.
 *
 * &lt;p&gt;{@code CharSource} provides two kinds of methods:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Methods that return a reader:&lt;/b&gt; These methods should return a &lt;i&gt;new&lt;/i&gt;, independent
 *       instance each time they are called. The caller is responsible for ensuring that the
 *       returned reader is closed.
 *   &lt;li&gt;&lt;b&gt;Convenience methods:&lt;/b&gt; These are implementations of common operations that are
 *       typically implemented by opening a reader using one of the methods in the first category,
 *       doing something and finally closing the reader that was opened.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Several methods in this class, such as {@link #readLines()}, break the contents of the source
 * into lines. Like {@link BufferedReader}, these methods break lines on any of {@code \n}, {@code
 * \r} or {@code \r\n}, do not include the line separator in each line and do not consider there to
 * be an empty line at the end if the contents are terminated with a line separator.
 *
 * &lt;p&gt;Any {@link ByteSource} containing text encoded with a specific {@linkplain Charset character
 * encoding} may be viewed as a {@code CharSource} using {@link ByteSource#asCharSource(Charset)}.
 *
 * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; In general, {@code CharSource} is intended to be used for &quot;file-like&quot; sources
 * that provide readers that are:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Finite:&lt;/b&gt; Many operations, such as {@link #length()} and {@link #read()}, will either
 *       block indefinitely or fail if the source creates an infinite reader.
 *   &lt;li&gt;&lt;b&gt;Non-destructive:&lt;/b&gt; A &lt;i&gt;destructive&lt;/i&gt; reader will consume or otherwise alter the
 *       source as they are read from it. A source that provides such readers will not be reusable,
 *       and operations that read from the stream (including {@link #length()}, in some
 *       implementations) will prevent further operations from completing as expected.
 * &lt;/ul&gt;
 *
 * @since 14.0
 * @author Colin Decker
 */
@</B></FONT>GwtIncompatible
@ElementTypesAreNonnullByDefault
public abstract class CharSource {

  /** Constructor for use by subclasses. */
  protected CharSource() {}

  /**
   * Returns a {@link ByteSource} view of this char source that encodes chars read from this source
   * as bytes using the given {@link Charset}.
   *
   * &lt;p&gt;If {@link ByteSource#asCharSource} is called on the returned source with the same charset,
   * the default implementation of this method will ensure that the original {@code CharSource} is
   * returned, rather than round-trip encoding. Subclasses that override this method should behave
   * the same way.
   *
   * @since 20.0
   */
  @Beta
  public ByteSource asByteSource(Charset charset) {
    return new AsByteSource(charset);
  }

  /**
   * Opens a new {@link Reader} for reading from this source. This method returns a new, independent
   * reader each time it is called.
   *
   * &lt;p&gt;The caller is responsible for ensuring that the returned reader is closed.
   *
   * @throws IOException if an I/O error occurs while opening the reader
   */
  public abstract Reader openStream() throws IOException;

  /**
   * Opens a new {@link BufferedReader} for reading from this source. This method returns a new,
   * independent reader each time it is called.
   *
   * &lt;p&gt;The caller is responsible for ensuring that the returned reader is closed.
   *
   * @throws IOException if an I/O error occurs while of opening the reader
   */
  public BufferedReader openBufferedStream() throws IOException {
    Reader reader = openStream();
<A NAME="2"></A>    return (reader instanceof BufferedReader)
        ? (BufferedReader) reader
        : new BufferedReader(reader);
  <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match250916-0.html#2',2,'match250916-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  /**
   * Returns the size of this source in chars, if the size can be easily determined without actually
   * opening the data stream.
   *
   * &lt;p&gt;The default implementation returns {@link Optional#absent}. Some sources, such as a {@code
   * CharSequence}, may return a non-absent value. Note that in such cases, it is &lt;i&gt;possible&lt;/i&gt;
   * that this method will return a different number of chars than would be returned by reading all
   * of the chars.
   *
   * &lt;p&gt;Additionally, for mutable sources such as {@code StringBuilder}s, a subsequent read may
   * return a different number of chars if the contents are changed.
   *
   * @since 19.0
   */
  @Beta
  public Optional&lt;Long&gt; lengthIfKnown() {
    return Optional.absent();
  }

  /**
   * Returns the length of this source in chars, even if doing so requires opening and traversing an
   * entire stream. To avoid a potentially expensive operation, see {@link #lengthIfKnown}.
   *
   * &lt;p&gt;The default implementation calls {@link #lengthIfKnown} and returns the value if present. If
   * absent, it will fall back to a heavyweight operation that will open a stream, {@link
   * Reader#skip(long) skip} to the end of the stream, and return the total number of chars that
   * were skipped.
   *
   * &lt;p&gt;Note that for sources that implement {@link #lengthIfKnown} to provide a more efficient
   * implementation, it is &lt;i&gt;possible&lt;/i&gt; that this method will return a different number of chars
   * than would be returned by reading all of the chars.
   *
   * &lt;p&gt;In either case, for mutable sources such as files, a subsequent read may return a different
   * number of chars if the contents are changed.
   *
   * @throws IOException if an I/O error occurs while reading the length of this source
   * @since 19.0
   */
  @Beta
  public long length() throws IOException {</B></FONT>
    Optional&lt;Long&gt; lengthIfKnown = lengthIfKnown();
    if (lengthIfKnown.isPresent()) {
      return lengthIfKnown.get();
    }

    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      return countBySkipping(reader);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }

  private long countBySkipping(Reader reader) throws IOException {
    long count = 0;
    long read;
    while ((read = reader.skip(Long.MAX_VALUE)) != 0) {
      count += read;
    }
    return count;
  }

  /**
   * Appends the contents of this source to the given {@link Appendable} (such as a {@link Writer}).
   * Does not close {@code appendable} if it is {@code Closeable}.
   *
   * @return the number of characters copied
   * @throws IOException if an I/O error occurs while reading from this source or writing to {@code
   *     appendable}
   */
  @CanIgnoreReturnValue
  public long copyTo(Appendable appendable) throws IOException {
    checkNotNull(appendable);

    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      return CharStreams.copy(reader, appendable);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }

  /**
   * Copies the contents of this source to the given sink.
   *
   * @return the number of characters copied
   * @throws IOException if an I/O error occurs while reading from this source or writing to {@code
   *     sink}
   */
  @CanIgnoreReturnValue
  public long copyTo(CharSink sink) throws IOException {
    checkNotNull(sink);

    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      Writer writer = closer.register(sink.openStream());
      return CharStreams.copy(reader, writer);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }

  /**
   * Reads the contents of this source as a string.
   *
   * @throws IOException if an I/O error occurs while reading from this source
   */
  public String read() throws IOException {
    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      return CharStreams.toString(reader);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }

  /**
   * Reads the first line of this source as a string. Returns {@code null} if this source is empty.
   *
   * &lt;p&gt;Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of
   * text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code
   * \n}. If the source's content does not end in a line termination sequence, it is treated as if
   * it does.
   *
   * @throws IOException if an I/O error occurs while reading from this source
   */
  @CheckForNull
  public String readFirstLine() throws IOException {
    Closer closer = Closer.create();
    try {
      BufferedReader reader = closer.register(openBufferedStream());
      return reader.readLine();
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }

  /**
   * Reads all the lines of this source as a list of strings. The returned list will be empty if
   * this source is empty.
   *
   * &lt;p&gt;Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of
   * text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code
   * \n}. If the source's content does not end in a line termination sequence, it is treated as if
   * it does.
   *
   * @throws IOException if an I/O error occurs while reading from this source
   */
  public ImmutableList&lt;String&gt; readLines() throws IOException {
    Closer closer = Closer.create();
    try {
      BufferedReader reader = closer.register(openBufferedStream());
      List&lt;String&gt; result = Lists.newArrayList();
      String line;
      while ((line = reader.readLine()) != null) {
        result.add(line);
      }
      return ImmutableList.copyOf(result);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }

  /**
   * Reads lines of text from this source, processing each line as it is read using the given {@link
   * LineProcessor processor}. Stops when all lines have been processed or the processor returns
   * {@code false} and returns the result produced by the processor.
   *
   * &lt;p&gt;Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of
   * text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code
   * \n}. If the source's content does not end in a line termination sequence, it is treated as if
   * it does.
   *
   * @throws IOException if an I/O error occurs while reading from this source or if {@code
   *     processor} throws an {@code IOException}
   * @since 16.0
   */
  @Beta
  @CanIgnoreReturnValue // some processors won't return a useful result
  @ParametricNullness
  public &lt;T extends @Nullable Object&gt; T readLines(LineProcessor&lt;T&gt; processor) throws IOException {
    checkNotNull(processor);

    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      return CharStreams.readLines(reader, processor);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }

  /**
   * Returns whether the source has zero chars. The default implementation first checks {@link
   * #lengthIfKnown}, returning true if it's known to be zero and false if it's known to be
   * non-zero. If the length is not known, it falls back to opening a stream and checking for EOF.
   *
   * &lt;p&gt;Note that, in cases where {@code lengthIfKnown} returns zero, it is &lt;i&gt;possible&lt;/i&gt; that
   * chars are actually available for reading. This means that a source may return {@code true} from
   * {@code isEmpty()} despite having readable content.
   *
   * @throws IOException if an I/O error occurs
   * @since 15.0
   */
  public boolean isEmpty() throws IOException {
    Optional&lt;Long&gt; lengthIfKnown = lengthIfKnown();
    if (lengthIfKnown.isPresent()) {
      return lengthIfKnown.get() == 0L;
    }
    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      return reader.read() == -1;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }

  /**
   * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from
   * the source will contain the concatenated data from the streams of the underlying sources.
   *
   * &lt;p&gt;Only one underlying stream will be open at a time. Closing the concatenated stream will
   * close the open underlying stream.
   *
   * @param sources the sources to concatenate
   * @return a {@code CharSource} containing the concatenated data
   * @since 15.0
   */
  public static CharSource concat(Iterable&lt;? extends CharSource&gt; sources) {
    return new ConcatenatedCharSource(sources);
  }

  /**
   * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from
   * the source will contain the concatenated data from the streams of the underlying sources.
   *
   * &lt;p&gt;Only one underlying stream will be open at a time. Closing the concatenated stream will
   * close the open underlying stream.
   *
   * &lt;p&gt;Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this method
   * is called. This will fail if the iterator is infinite and may cause problems if the iterator
   * eagerly fetches data for each source when iterated (rather than producing sources that only
   * load data through their streams). Prefer using the {@link #concat(Iterable)} overload if
   * possible.
   *
   * @param sources the sources to concatenate
   * @return a {@code CharSource} containing the concatenated data
   * @throws NullPointerException if any of {@code sources} is {@code null}
   * @since 15.0
   */
  public static CharSource concat(Iterator&lt;? extends CharSource&gt; sources) {
    return concat(ImmutableList.copyOf(sources));
  }

  /**
   * Concatenates multiple {@link CharSource} instances into a single source. Streams returned from
   * the source will contain the concatenated data from the streams of the underlying sources.
   *
   * &lt;p&gt;Only one underlying stream will be open at a time. Closing the concatenated stream will
   * close the open underlying stream.
   *
   * @param sources the sources to concatenate
   * @return a {@code CharSource} containing the concatenated data
   * @throws NullPointerException if any of {@code sources} is {@code null}
   * @since 15.0
   */
  public static CharSource concat(CharSource... sources) {
    return concat(ImmutableList.copyOf(sources));
  }

  /**
   * Returns a view of the given character sequence as a {@link CharSource}. The behavior of the
   * returned {@code CharSource} and any {@code Reader} instances created by it is unspecified if
   * the {@code charSequence} is mutated while it is being read, so don't do that.
   *
   * @since 15.0 (since 14.0 as {@code CharStreams.asCharSource(String)})
   */
  public static CharSource wrap(CharSequence charSequence) {
    return charSequence instanceof String
        ? new StringCharSource((String) charSequence)
        : new CharSequenceCharSource(charSequence);
  }

  /**
   * Returns an immutable {@link CharSource} that contains no characters.
   *
   * @since 15.0
   */
  public static CharSource empty() {
    return EmptyCharSource.INSTANCE;
  }

  /** A byte source that reads chars from this source and encodes them as bytes using a charset. */
  private final class AsByteSource extends ByteSource {

    final Charset charset;

    AsByteSource(Charset charset) {
      this.charset = checkNotNull(charset);
    }

    @Override
    public CharSource asCharSource(Charset charset) {
<A NAME="1"></A>      if (charset.equals(this.charset)) {
        return CharSource.this;
      }
      <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match250916-0.html#1',2,'match250916-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return super.asCharSource(charset);
    }

    @Override
    public InputStream openStream() throws IOException {
      return new ReaderInputStream(CharSource.this.openStream(), charset, 8192);
    }

    @Override
    public String toString() {
      return CharSource.this.toString() + &quot;.asByteSource(&quot; + charset + &quot;)&quot;;
    }</B></FONT>
  }

  private static class CharSequenceCharSource extends CharSource {

    private static final Splitter LINE_SPLITTER = Splitter.onPattern(&quot;\r\n|\n|\r&quot;);

    protected final CharSequence seq;

    protected CharSequenceCharSource(CharSequence seq) {
      this.seq = checkNotNull(seq);
    }

<A NAME="0"></A>    @Override
    public Reader openStream() {
      return new CharSequenceReader(seq);
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match250916-0.html#0',2,'match250916-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public String read() {
      return seq.toString();
    }

    @Override
    public boolean isEmpty() {
      return seq.length() == 0;
    }

    @Override
    public long length() {
      return seq.length();
    }

    @</B></FONT>Override
    public Optional&lt;Long&gt; lengthIfKnown() {
      return Optional.of((long) seq.length());
    }

    /**
     * Returns an iterator over the lines in the string. If the string ends in a newline, a final
     * empty string is not included, to match the behavior of BufferedReader/LineReader.readLine().
     */
    private Iterator&lt;String&gt; linesIterator() {
      return new AbstractIterator&lt;String&gt;() {
        Iterator&lt;String&gt; lines = LINE_SPLITTER.split(seq).iterator();

        @Override
        @CheckForNull
        protected String computeNext() {
          if (lines.hasNext()) {
            String next = lines.next();
            // skip last line if it's empty
            if (lines.hasNext() || !next.isEmpty()) {
              return next;
            }
          }
          return endOfData();
        }
      };
    }

    @Override
<A NAME="5"></A>    @CheckForNull
    public String readFirstLine() {
      Iterator&lt;String&gt; lines = linesIterator();
      return <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match250916-0.html#5',2,'match250916-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>lines.hasNext() ? lines.next() : null;
    }

    @Override
    public ImmutableList&lt;String&gt; readLines() {
      return ImmutableList.copyOf</B></FONT>(linesIterator());
    }

    @Override
    @ParametricNullness
    public &lt;T extends @Nullable Object&gt; T readLines(LineProcessor&lt;T&gt; processor) throws IOException {
      Iterator&lt;String&gt; lines = linesIterator();
      while (lines.hasNext()) {
        if (!processor.processLine(lines.next())) {
<A NAME="3"></A>          break;
        }
      }
      <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match250916-0.html#3',2,'match250916-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return processor.getResult();
    }

    @Override
    public String toString() {
      return &quot;CharSource.wrap(&quot; + Ascii.truncate(seq, 30, &quot;...&quot;) + &quot;)&quot;;
    }</B></FONT>
  }

  /**
   * Subclass specialized for string instances.
   *
   * &lt;p&gt;Since Strings are immutable and built into the jdk we can optimize some operations
   *
   * &lt;ul&gt;
   *   &lt;li&gt;use {@link StringReader} instead of {@link CharSequenceReader}. It is faster since it can
   *       use {@link String#getChars(int, int, char[], int)} instead of copying characters one by
   *       one with {@link CharSequence#charAt(int)}.
   *   &lt;li&gt;use {@link Appendable#append(CharSequence)} in {@link #copyTo(Appendable)} and {@link
   *       #copyTo(CharSink)}. We know this is correct since strings are immutable and so the length
   *       can't change, and it is faster because many writers and appendables are optimized for
   *       appending string instances.
   * &lt;/ul&gt;
   */
  private static class StringCharSource extends CharSequenceCharSource {
    protected StringCharSource(String seq) {
      super(seq);
    }

    @Override
    public Reader openStream() {
      return new StringReader((String) seq);
    }

    @Override
    public long copyTo(Appendable appendable) throws IOException {
      appendable.append(seq);
      return seq.length();
    }

    @Override
    public long copyTo(CharSink sink) throws IOException {
      checkNotNull(sink);
      Closer closer = Closer.create();
      try {
        Writer writer = closer.register(sink.openStream());
        writer.write((String) seq);
        return seq.length();
      } catch (Throwable e) {
        throw closer.rethrow(e);
      } finally {
        closer.close();
      }
    }
  }

  private static final class EmptyCharSource extends StringCharSource {

    private static final EmptyCharSource INSTANCE = new EmptyCharSource();

    private EmptyCharSource() {
      super(&quot;&quot;);
    }

    @Override
    public String toString() {
      return &quot;CharSource.empty()&quot;;
    }
  }

  private static final class ConcatenatedCharSource extends CharSource {

    private final Iterable&lt;? extends CharSource&gt; sources;

    ConcatenatedCharSource(Iterable&lt;? extends CharSource&gt; sources) {
      this.sources = checkNotNull(sources);
    }

    @Override
    public Reader openStream() throws IOException {
      return new MultiReader(sources.iterator());
    }

    @Override
    public boolean isEmpty() throws IOException {
      for (CharSource source : sources) {
        if (!source.isEmpty()) {
          return false;
        }
      }
      return true;
    }

    @Override
    public Optional&lt;Long&gt; lengthIfKnown() {
      long result = 0L;
      for (CharSource source : sources) {
        Optional&lt;Long&gt; lengthIfKnown = source.lengthIfKnown();
<A NAME="6"></A>        if (!lengthIfKnown.isPresent()) {
          return Optional.absent();
        }
        result += <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match250916-0.html#6',2,'match250916-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>lengthIfKnown.get();
      }
      return Optional.of(result);
    }

    @</B></FONT>Override
    public long length() throws IOException {
      long result = 0L;
      for (CharSource source : sources) {
        result += source.length();
      }
      return result;
    }

    @Override
    public String toString() {
      return &quot;CharSource.concat(&quot; + sources + &quot;)&quot;;
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
