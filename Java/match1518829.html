<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for LinkedHashMultimap.java & MultimapsTest_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for LinkedHashMultimap.java & MultimapsTest_1.java
      </h3>
      <h1 align="center">
        4.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>LinkedHashMultimap.java (6.741573%)<TH>MultimapsTest_1.java (3.1662269%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1518829-0.html#0',2,'match1518829-1.html#0',3)" NAME="0">(19-81)<TD><A HREF="javascript:ZweiFrames('match1518829-0.html#0',2,'match1518829-1.html#0',3)" NAME="0">(38-66)</A><TD ALIGN=center><FONT COLOR="#ff0000">25</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1518829-0.html#1',2,'match1518829-1.html#1',3)" NAME="1">(581-594)<TD><A HREF="javascript:ZweiFrames('match1518829-0.html#1',2,'match1518829-1.html#1',3)" NAME="1">(106-114)</A><TD ALIGN=center><FONT COLOR="#840000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1518829-0.html#2',2,'match1518829-1.html#2',3)" NAME="2">(391-397)<TD><A HREF="javascript:ZweiFrames('match1518829-0.html#2',2,'match1518829-1.html#2',3)" NAME="2">(559-565)</A><TD ALIGN=center><FONT COLOR="#660000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LinkedHashMultimap.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="0"></A>
package com.google.common.collect;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1518829-1.html#0',3,'match1518829-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.j2objc.annotations.WeakOuter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Set;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Implementation of {@code Multimap} that does not allow duplicate key-value entries and that
 * returns collections whose iterators follow the ordering in which the data was added to the
 * multimap.
 *
 * &lt;p&gt;The collections returned by {@code keySet}, {@code keys}, and {@code asMap} iterate through
 * the keys in the order they were first added to the multimap. Similarly, {@code get}, {@code
 * removeAll}, and {@code replaceValues} return collections that iterate through the values in the
 * order they were added. The collections generated by {@code entries} and {@code values} iterate
 * across the key-value mappings in the order they were added to the multimap.
 *
 * &lt;p&gt;The iteration ordering of the collections generated by {@code keySet}, {@code keys}, and
 * {@code asMap} has a few subtleties. As long as the set of keys remains unchanged, adding or
 * removing mappings does not affect the key iteration order. However, if you remove all values
 * associated with a key and then add the key back to the multimap, that key will come last in the
 * key iteration order.
 *
 * &lt;p&gt;The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an
 * existing key-value pair has no effect.
 *
 * &lt;p&gt;Keys and values may be null. All optional multimap methods are supported, and all returned
 * views are modifiable.
 *
 * &lt;p&gt;This class is not threadsafe when any concurrent operations update the multimap. Concurrent
 * read operations will work correctly. To allow concurrent update operations, wrap your multimap
 * with a call to {@link Multimaps#synchronizedSetMultimap}.
 *
 * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Do not modify either a key &lt;i&gt;or a value&lt;/i&gt; of a {@code LinkedHashMultimap}
 * in a way that affects its {@link Object#equals} behavior. Undefined behavior and bugs will
 * result.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * &quot;https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap&quot;&gt;{@code Multimap}&lt;/a&gt;.
 *
 * @author Jared Levy
 * @author Louis Wasserman
 * @since 2.0
 */
@GwtCompatible(s</B></FONT>erializable = true, emulated = true)
@ElementTypesAreNonnullByDefault
public final class LinkedHashMultimap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
    extends LinkedHashMultimapGwtSerializationDependencies&lt;K, V&gt; {

  /** Creates a new, empty {@code LinkedHashMultimap} with the default initial capacities. */
  public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
      LinkedHashMultimap&lt;K, V&gt; create() {
    return new LinkedHashMultimap&lt;&gt;(DEFAULT_KEY_CAPACITY, DEFAULT_VALUE_SET_CAPACITY);
  }

  /**
   * Constructs an empty {@code LinkedHashMultimap} with enough capacity to hold the specified
   * numbers of keys and values without rehashing.
   *
   * @param expectedKeys the expected number of distinct keys
   * @param expectedValuesPerKey the expected average number of values per key
   * @throws IllegalArgumentException if {@code expectedKeys} or {@code expectedValuesPerKey} is
   *     negative
   */
  public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
      LinkedHashMultimap&lt;K, V&gt; create(int expectedKeys, int expectedValuesPerKey) {
    return new LinkedHashMultimap&lt;&gt;(
        Maps.capacity(expectedKeys), Maps.capacity(expectedValuesPerKey));
  }

  /**
   * Constructs a {@code LinkedHashMultimap} with the same mappings as the specified multimap. If a
   * key-value mapping appears multiple times in the input multimap, it only appears once in the
   * constructed multimap. The new multimap has the same {@link Multimap#entries()} iteration order
   * as the input multimap, except for excluding duplicate mappings.
   *
   * @param multimap the multimap whose contents are copied to this multimap
   */
  public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
      LinkedHashMultimap&lt;K, V&gt; create(Multimap&lt;? extends K, ? extends V&gt; multimap) {
    LinkedHashMultimap&lt;K, V&gt; result = create(multimap.keySet().size(), DEFAULT_VALUE_SET_CAPACITY);
    result.putAll(multimap);
    return result;
  }

  private interface ValueSetLink&lt;K extends @Nullable Object, V extends @Nullable Object&gt; {
    ValueSetLink&lt;K, V&gt; getPredecessorInValueSet();

    ValueSetLink&lt;K, V&gt; getSuccessorInValueSet();

    void setPredecessorInValueSet(ValueSetLink&lt;K, V&gt; entry);

    void setSuccessorInValueSet(ValueSetLink&lt;K, V&gt; entry);
  }

  private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; void succeedsInValueSet(
      ValueSetLink&lt;K, V&gt; pred, ValueSetLink&lt;K, V&gt; succ) {
    pred.setSuccessorInValueSet(succ);
    succ.setPredecessorInValueSet(pred);
  }

  private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; void succeedsInMultimap(
      ValueEntry&lt;K, V&gt; pred, ValueEntry&lt;K, V&gt; succ) {
    pred.setSuccessorInMultimap(succ);
    succ.setPredecessorInMultimap(pred);
  }

  private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; void deleteFromValueSet(
      ValueSetLink&lt;K, V&gt; entry) {
    succeedsInValueSet(entry.getPredecessorInValueSet(), entry.getSuccessorInValueSet());
  }

  private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; void deleteFromMultimap(
      ValueEntry&lt;K, V&gt; entry) {
    succeedsInMultimap(entry.getPredecessorInMultimap(), entry.getSuccessorInMultimap());
  }

  /**
   * LinkedHashMultimap entries are in no less than three coexisting linked lists: a bucket in the
   * hash table for a {@code Set&lt;V&gt;} associated with a key, the linked list of insertion-ordered
   * entries in that {@code Set&lt;V&gt;}, and the linked list of entries in the LinkedHashMultimap as a
   * whole.
   */
  @VisibleForTesting
  static final class ValueEntry&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
      extends ImmutableEntry&lt;K, V&gt; implements ValueSetLink&lt;K, V&gt; {
    final int smearedValueHash;

    @CheckForNull ValueEntry&lt;K, V&gt; nextInValueBucket;
    /*
     * The *InValueSet and *InMultimap fields below are null after construction, but we almost
     * always call succeedsIn*() to initialize them immediately thereafter.
     *
     * The exception is the *InValueSet fields of multimapHeaderEntry, which are never set. (That
     * works out fine as long as we continue to be careful not to try delete them or iterate past
     * them.)
     *
     * We could consider &quot;lying&quot; and omitting @CheckNotNull from all these fields. Normally, I'm not
     * a fan of that: What if we someday implement (presumably to be enabled during tests only)
     * bytecode rewriting that checks for any null value that passes through an API with a
     * known-non-null type? But that particular problem might not arise here, since we're not
     * actually reading from the fields in any case in which they might be null (as proven by the
     * requireNonNull checks below). Plus, we're *already* lying here, since newHeader passes a null
     * key and value, which we pass to the superconstructor, even though the key and value type for
     * a given entry might not include null. The right fix for the header problems is probably to
     * define a separate MultimapLink interface with a separate &quot;header&quot; implementation, which
     * hopefully could avoid implementing Entry or ValueSetLink at all. (But note that that approach
     * requires us to define extra classes -- unfortunate under Android.) *Then* we could consider
     * lying about the fields below on the grounds that we always initialize them just after the
     * constructor -- an example of the kind of lying that our hypotheticaly bytecode rewriter would
     * already have to deal with, thanks to DI frameworks that perform field and method injection,
     * frameworks like Android that define post-construct hooks like Activity.onCreate, etc.
     */

    @CheckForNull ValueSetLink&lt;K, V&gt; predecessorInValueSet;
    @CheckForNull ValueSetLink&lt;K, V&gt; successorInValueSet;

    @CheckForNull ValueEntry&lt;K, V&gt; predecessorInMultimap;
    @CheckForNull ValueEntry&lt;K, V&gt; successorInMultimap;

    ValueEntry(
        @ParametricNullness K key,
        @ParametricNullness V value,
        int smearedValueHash,
        @CheckForNull ValueEntry&lt;K, V&gt; nextInValueBucket) {
      super(key, value);
      this.smearedValueHash = smearedValueHash;
      this.nextInValueBucket = nextInValueBucket;
    }

    @SuppressWarnings(&quot;nullness&quot;) // see the comment on the class fields, especially about newHeader
    static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; ValueEntry&lt;K, V&gt; newHeader() {
      return new ValueEntry&lt;&gt;(null, null, 0, null);
    }

    boolean matchesValue(@CheckForNull Object v, int smearedVHash) {
      return smearedValueHash == smearedVHash &amp;&amp; Objects.equal(getValue(), v);
    }

    @Override
    public ValueSetLink&lt;K, V&gt; getPredecessorInValueSet() {
      return requireNonNull(predecessorInValueSet); // see the comment on the class fields
    }

    @Override
    public ValueSetLink&lt;K, V&gt; getSuccessorInValueSet() {
      return requireNonNull(successorInValueSet); // see the comment on the class fields
    }

    @Override
    public void setPredecessorInValueSet(ValueSetLink&lt;K, V&gt; entry) {
      predecessorInValueSet = entry;
    }

    @Override
    public void setSuccessorInValueSet(ValueSetLink&lt;K, V&gt; entry) {
      successorInValueSet = entry;
    }

    public ValueEntry&lt;K, V&gt; getPredecessorInMultimap() {
      return requireNonNull(predecessorInMultimap); // see the comment on the class fields
    }

    public ValueEntry&lt;K, V&gt; getSuccessorInMultimap() {
      return requireNonNull(successorInMultimap); // see the comment on the class fields
    }

    public void setSuccessorInMultimap(ValueEntry&lt;K, V&gt; multimapSuccessor) {
      this.successorInMultimap = multimapSuccessor;
    }

    public void setPredecessorInMultimap(ValueEntry&lt;K, V&gt; multimapPredecessor) {
      this.predecessorInMultimap = multimapPredecessor;
    }
  }

  private static final int DEFAULT_KEY_CAPACITY = 16;
  private static final int DEFAULT_VALUE_SET_CAPACITY = 2;
  @VisibleForTesting static final double VALUE_SET_LOAD_FACTOR = 1.0;

  @VisibleForTesting transient int valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
  private transient ValueEntry&lt;K, V&gt; multimapHeaderEntry;

  private LinkedHashMultimap(int keyCapacity, int valueSetCapacity) {
    super(Platform.&lt;K, Collection&lt;V&gt;&gt;newLinkedHashMapWithExpectedSize(keyCapacity));
    checkNonnegative(valueSetCapacity, &quot;expectedValuesPerKey&quot;);

    this.valueSetCapacity = valueSetCapacity;
    this.multimapHeaderEntry = ValueEntry.newHeader();
    succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;Creates an empty {@code LinkedHashSet} for a collection of values for one key.
   *
   * @return a new {@code LinkedHashSet} containing a collection of values for one key
   */
  @Override
  Set&lt;V&gt; createCollection() {
    return Platform.newLinkedHashSetWithExpectedSize(valueSetCapacity);
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;Creates a decorated insertion-ordered set that also keeps track of the order in which
   * key-value pairs are added to the multimap.
   *
   * @param key key to associate with values in the collection
   * @return a new decorated set containing a collection of values for one key
   */
  @Override
  Collection&lt;V&gt; createCollection(@ParametricNullness K key) {
    return new ValueSet(key, valueSetCapacity);
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;If {@code values} is not empty and the multimap already contains a mapping for {@code key},
   * the {@code keySet()} ordering is unchanged. However, the provided values always come last in
   * the {@link #entries()} and {@link #values()} iteration orderings.
   */
  @CanIgnoreReturnValue
  @Override
  public Set&lt;V&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
    return super.replaceValues(key, values);
  }

  /**
   * Returns a set of all key-value pairs. Changes to the returned set will update the underlying
   * multimap, and vice versa. The entries set does not support the {@code add} or {@code addAll}
   * operations.
   *
   * &lt;p&gt;The iterator generated by the returned set traverses the entries in the order they were
   * added to the multimap.
   *
   * &lt;p&gt;Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the
   * time the entry is returned by a method call to the collection or its iterator.
   */
  @Override
  public Set&lt;Entry&lt;K, V&gt;&gt; entries() {
    return super.entries();
  }

  /**
   * Returns a view collection of all &lt;i&gt;distinct&lt;/i&gt; keys contained in this multimap. Note that the
   * key set contains a key if and only if this multimap maps that key to at least one value.
   *
   * &lt;p&gt;The iterator generated by the returned set traverses the keys in the order they were first
   * added to the multimap.
   *
   * &lt;p&gt;Changes to the returned set will update the underlying multimap, and vice versa. However,
   * &lt;i&gt;adding&lt;/i&gt; to the returned set is not possible.
   */
  @Override
  public Set&lt;K&gt; keySet() {
    return super.keySet();
  }

  /**
   * Returns a collection of all values in the multimap. Changes to the returned collection will
   * update the underlying multimap, and vice versa.
   *
   * &lt;p&gt;The iterator generated by the returned collection traverses the values in the order they
   * were added to the multimap.
   */
  @Override
  public Collection&lt;V&gt; values() {
    return super.values();
  }

  @VisibleForTesting
  @WeakOuter
  final class ValueSet extends Sets.ImprovedAbstractSet&lt;V&gt; implements ValueSetLink&lt;K, V&gt; {
    /*
     * We currently use a fixed load factor of 1.0, a bit higher than normal to reduce memory
     * consumption.
     */

    @ParametricNullness private final K key;
    @VisibleForTesting @Nullable ValueEntry&lt;K, V&gt;[] hashTable;
    private int size = 0;
    private int modCount = 0;

    // We use the set object itself as the end of the linked list, avoiding an unnecessary
    // entry object per key.
    private ValueSetLink&lt;K, V&gt; firstEntry;
    private ValueSetLink&lt;K, V&gt; lastEntry;

    ValueSet(@ParametricNullness K key, int expectedValues) {
      this.key = key;
      this.firstEntry = this;
      this.lastEntry = this;
      // Round expected values up to a power of 2 to get the table size.
      int tableSize = Hashing.closedTableSize(expectedValues, VALUE_SET_LOAD_FACTOR);

      @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
      @Nullable
      ValueEntry&lt;K, V&gt;[] hashTable = new @Nullable ValueEntry[tableSize];
      this.hashTable = hashTable;
    }

    private int mask() {
      return hashTable.length - 1;
    }

    @Override
    public ValueSetLink&lt;K, V&gt; getPredecessorInValueSet() {
<A NAME="2"></A>      return lastEntry;
    }

    <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1518829-1.html#2',3,'match1518829-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
    public ValueSetLink&lt;K, V&gt; getSuccessorInValueSet() {
      return firstEntry;
    }

    @Override
    public void setPredecessorInValueSet(ValueSetLink&lt;K, V&gt; entry) {</B></FONT>
      lastEntry = entry;
    }

    @Override
    public void setSuccessorInValueSet(ValueSetLink&lt;K, V&gt; entry) {
      firstEntry = entry;
    }

    @Override
    public Iterator&lt;V&gt; iterator() {
      return new Iterator&lt;V&gt;() {
        ValueSetLink&lt;K, V&gt; nextEntry = firstEntry;
        @CheckForNull ValueEntry&lt;K, V&gt; toRemove;
        int expectedModCount = modCount;

        private void checkForComodification() {
          if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
          }
        }

        @Override
        public boolean hasNext() {
          checkForComodification();
          return nextEntry != ValueSet.this;
        }

        @Override
        @ParametricNullness
        public V next() {
          if (!hasNext()) {
            throw new NoSuchElementException();
          }
          ValueEntry&lt;K, V&gt; entry = (ValueEntry&lt;K, V&gt;) nextEntry;
          V result = entry.getValue();
          toRemove = entry;
          nextEntry = entry.getSuccessorInValueSet();
          return result;
        }

        @Override
        public void remove() {
          checkForComodification();
          checkState(toRemove != null, &quot;no calls to next() since the last call to remove()&quot;);
          ValueSet.this.remove(toRemove.getValue());
          expectedModCount = modCount;
          toRemove = null;
        }
      };
    }

    @Override
    public int size() {
      return size;
    }

    @Override
    public boolean contains(@CheckForNull Object o) {
      int smearedHash = Hashing.smearedHash(o);
      for (ValueEntry&lt;K, V&gt; entry = hashTable[smearedHash &amp; mask()];
          entry != null;
          entry = entry.nextInValueBucket) {
        if (entry.matchesValue(o, smearedHash)) {
          return true;
        }
      }
      return false;
    }

    @Override
    public boolean add(@ParametricNullness V value) {
      int smearedHash = Hashing.smearedHash(value);
      int bucket = smearedHash &amp; mask();
      ValueEntry&lt;K, V&gt; rowHead = hashTable[bucket];
      for (ValueEntry&lt;K, V&gt; entry = rowHead; entry != null; entry = entry.nextInValueBucket) {
        if (entry.matchesValue(value, smearedHash)) {
          return false;
        }
      }

      ValueEntry&lt;K, V&gt; newEntry = new ValueEntry&lt;&gt;(key, value, smearedHash, rowHead);
      succeedsInValueSet(lastEntry, newEntry);
      succeedsInValueSet(newEntry, this);
      succeedsInMultimap(multimapHeaderEntry.getPredecessorInMultimap(), newEntry);
      succeedsInMultimap(newEntry, multimapHeaderEntry);
      hashTable[bucket] = newEntry;
      size++;
      modCount++;
      rehashIfNecessary();
      return true;
    }

    private void rehashIfNecessary() {
      if (Hashing.needsResizing(size, hashTable.length, VALUE_SET_LOAD_FACTOR)) {
        @SuppressWarnings(&quot;unchecked&quot;)
        ValueEntry&lt;K, V&gt;[] hashTable = new ValueEntry[this.hashTable.length * 2];
        this.hashTable = hashTable;
        int mask = hashTable.length - 1;
        for (ValueSetLink&lt;K, V&gt; entry = firstEntry;
            entry != this;
            entry = entry.getSuccessorInValueSet()) {
          ValueEntry&lt;K, V&gt; valueEntry = (ValueEntry&lt;K, V&gt;) entry;
          int bucket = valueEntry.smearedValueHash &amp; mask;
          valueEntry.nextInValueBucket = hashTable[bucket];
          hashTable[bucket] = valueEntry;
        }
      }
    }

    @CanIgnoreReturnValue
    @Override
    public boolean remove(@CheckForNull Object o) {
      int smearedHash = Hashing.smearedHash(o);
      int bucket = smearedHash &amp; mask();
      ValueEntry&lt;K, V&gt; prev = null;
      for (ValueEntry&lt;K, V&gt; entry = hashTable[bucket];
          entry != null;
          prev = entry, entry = entry.nextInValueBucket) {
        if (entry.matchesValue(o, smearedHash)) {
          if (prev == null) {
            // first entry in the bucket
            hashTable[bucket] = entry.nextInValueBucket;
          } else {
            prev.nextInValueBucket = entry.nextInValueBucket;
          }
          deleteFromValueSet(entry);
          deleteFromMultimap(entry);
          size--;
          modCount++;
          return true;
        }
      }
      return false;
    }

    @Override
    public void clear() {
      Arrays.fill(hashTable, null);
      size = 0;
      for (ValueSetLink&lt;K, V&gt; entry = firstEntry;
          entry != this;
          entry = entry.getSuccessorInValueSet()) {
        ValueEntry&lt;K, V&gt; valueEntry = (ValueEntry&lt;K, V&gt;) entry;
        deleteFromMultimap(valueEntry);
      }
      succeedsInValueSet(this, this);
      modCount++;
    }
  }

  @Override
  Iterator&lt;Entry&lt;K, V&gt;&gt; entryIterator() {
    return new Iterator&lt;Entry&lt;K, V&gt;&gt;() {
      ValueEntry&lt;K, V&gt; nextEntry = multimapHeaderEntry.getSuccessorInMultimap();
      @CheckForNull ValueEntry&lt;K, V&gt; toRemove;

      @Override
      public boolean hasNext() {
        return nextEntry != multimapHeaderEntry;
      }

      @Override
      public Entry&lt;K, V&gt; next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        ValueEntry&lt;K, V&gt; result = nextEntry;
        toRemove = result;
        nextEntry = nextEntry.getSuccessorInMultimap();
        return result;
      }

      @Override
      public void remove() {
        checkState(toRemove != null, &quot;no calls to next() since the last call to remove()&quot;);
        LinkedHashMultimap.this.remove(toRemove.getKey(), toRemove.getValue());
        toRemove = null;
      }
    };
  }
<A NAME="1"></A>
  @Override
  Iterator&lt;V&gt; valueIterator() {
    return <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1518829-1.html#1',3,'match1518829-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Maps.valueIterator(entryIterator());
  }

  @Override
  public void clear() {
    super.clear();
    succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
  }

  /**
   * @serialData the expected values per key, the number of distinct keys, the number of entries,
   *     and the entries in order
   */
  @</B></FONT>GwtIncompatible // java.io.ObjectOutputStream
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeInt(keySet().size());
    for (K key : keySet()) {
      stream.writeObject(key);
    }
    stream.writeInt(size());
    for (Entry&lt;K, V&gt; entry : entries()) {
      stream.writeObject(entry.getKey());
      stream.writeObject(entry.getValue());
    }
  }

  @GwtIncompatible // java.io.ObjectInputStream
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    multimapHeaderEntry = ValueEntry.newHeader();
    succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
    valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
    int distinctKeys = stream.readInt();
    Map&lt;K, Collection&lt;V&gt;&gt; map = Platform.newLinkedHashMapWithExpectedSize(12);
    for (int i = 0; i &lt; distinctKeys; i++) {
      @SuppressWarnings(&quot;unchecked&quot;)
      K key = (K) stream.readObject();
      map.put(key, createCollection(key));
    }
    int entries = stream.readInt();
    for (int i = 0; i &lt; entries; i++) {
      @SuppressWarnings(&quot;unchecked&quot;)
      K key = (K) stream.readObject();
      @SuppressWarnings(&quot;unchecked&quot;)
      V value = (V) stream.readObject();
      /*
       * requireNonNull is safe for a properly serialized multimap: We've already inserted a
       * collection for each key that we expect.
       */
      requireNonNull(map.get(key)).add(value);
    }
    setMap(map);
  }

  @GwtIncompatible // java serialization not supported
  private static final long serialVersionUID = 1;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MultimapsTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Maps.immutableEntry;
import static com.google.common.collect.Sets.newHashSet;
import static com.google.common.collect.testing.Helpers.nefariousMapEntry;
import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
import static com.google.common.truth.Truth.assertThat;
import static java.util.Arrays.asList;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Predicates;
import com.google.common.base.Supplier;
import com.google.common.collect.Maps.EntryTransformer;
import com.google.common.collect.testing.IteratorTester;
<A NAME="0"></A>import com.google.common.collect.testing.google.UnmodifiableCollectionTests;
import com.google.common.testing.EqualsTester;
import com.google.common.testing.NullPointerTester;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1518829-0.html#0',2,'match1518829-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.google.common.testing.SerializableTester;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NavigableSet;
import java.util.Queue;
import java.util.RandomAccess;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeSet;
import javax.annotation.CheckForNull;
import junit.framework.TestCase;

/**
 * Unit test for {@code Multimaps}.
 *
 * @author Jared Levy
 */
@GwtCompatible(e</B></FONT>mulated = true)
public class MultimapsTest extends TestCase {

  private static final Comparator&lt;Integer&gt; INT_COMPARATOR =
      Ordering.&lt;Integer&gt;natural().reverse().nullsFirst();

  @SuppressWarnings(&quot;deprecation&quot;)
  public void testUnmodifiableListMultimapShortCircuit() {
    ListMultimap&lt;String, Integer&gt; mod = ArrayListMultimap.create();
    ListMultimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableListMultimap(mod);
    assertNotSame(mod, unmod);
    assertSame(unmod, Multimaps.unmodifiableListMultimap(unmod));
    ImmutableListMultimap&lt;String, Integer&gt; immutable =
        ImmutableListMultimap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;a&quot;, 3);
    assertSame(immutable, Multimaps.unmodifiableListMultimap(immutable));
    assertSame(
        immutable, Multimaps.unmodifiableListMultimap((ListMultimap&lt;String, Integer&gt;) immutable));
  }

  @SuppressWarnings(&quot;deprecation&quot;)
  public void testUnmodifiableSetMultimapShortCircuit() {
    SetMultimap&lt;String, Integer&gt; mod = HashMultimap.create();
    SetMultimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableSetMultimap(mod);
    assertNotSame(mod, unmod);
    assertSame(unmod, Multimaps.unmodifiableSetMultimap(unmod));
    ImmutableSetMultimap&lt;String, Integer&gt; immutable =
        ImmutableSetMultimap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;a&quot;, 3);
    assertSame(immutable, Multimaps.unmodifiableSetMultimap(immutable));
    assertSame(
        immutable, Multimaps.unmodifiableSetMultimap((SetMultimap&lt;String, Integer&gt;) immutable));
  }

  @SuppressWarnings(&quot;deprecation&quot;)
  public void testUnmodifiableMultimapShortCircuit() {
    Multimap&lt;String, Integer&gt; mod = HashMultimap.create();
    Multimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableMultimap(mod);
    assertNotSame(mod, unmod);
<A NAME="1"></A>    assertSame(unmod, Multimaps.unmodifiableMultimap(unmod));
    ImmutableMultimap&lt;String, Integer&gt; immutable = ImmutableMultimap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;a&quot;, 3);
    assertSame(immutable, Multimaps.unmodifiableMultimap(immutable));
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1518829-0.html#1',2,'match1518829-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertSame(immutable, Multimaps.unmodifiableMultimap((Multimap&lt;String, Integer&gt;) immutable));
  }

  @GwtIncompatible // slow (~10s)
  public void testUnmodifiableArrayListMultimap() {
    checkUnmodifiableMultimap(ArrayListMultimap.&lt;String, Integer&gt;create(), true);
  }

  @</B></FONT>GwtIncompatible // SerializableTester
  public void testSerializingUnmodifiableArrayListMultimap() {
    Multimap&lt;String, Integer&gt; unmodifiable =
        prepareUnmodifiableTests(ArrayListMultimap.&lt;String, Integer&gt;create(), true, null, null);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }

  public void testUnmodifiableArrayListMultimapRandomAccess() {
    ListMultimap&lt;String, Integer&gt; delegate = ArrayListMultimap.create();
    delegate.put(&quot;foo&quot;, 1);
    delegate.put(&quot;foo&quot;, 3);
    ListMultimap&lt;String, Integer&gt; multimap = Multimaps.unmodifiableListMultimap(delegate);
    assertTrue(multimap.get(&quot;foo&quot;) instanceof RandomAccess);
    assertTrue(multimap.get(&quot;bar&quot;) instanceof RandomAccess);
  }

  public void testUnmodifiableLinkedListMultimapRandomAccess() {
    ListMultimap&lt;String, Integer&gt; delegate = LinkedListMultimap.create();
    delegate.put(&quot;foo&quot;, 1);
    delegate.put(&quot;foo&quot;, 3);
    ListMultimap&lt;String, Integer&gt; multimap = Multimaps.unmodifiableListMultimap(delegate);
    assertFalse(multimap.get(&quot;foo&quot;) instanceof RandomAccess);
    assertFalse(multimap.get(&quot;bar&quot;) instanceof RandomAccess);
  }

  @GwtIncompatible // slow (~10s)
  public void testUnmodifiableHashMultimap() {
    checkUnmodifiableMultimap(HashMultimap.&lt;String, Integer&gt;create(), false);
  }

  @GwtIncompatible // SerializableTester
  public void testSerializingUnmodifiableHashMultimap() {
    Multimap&lt;String, Integer&gt; unmodifiable =
        prepareUnmodifiableTests(HashMultimap.&lt;String, Integer&gt;create(), false, null, null);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }

  @GwtIncompatible // slow (~10s)
  public void testUnmodifiableTreeMultimap() {
    checkUnmodifiableMultimap(TreeMultimap.&lt;String, Integer&gt;create(), false, &quot;null&quot;, 42);
  }

  @GwtIncompatible // SerializableTester
  public void testSerializingUnmodifiableTreeMultimap() {
    Multimap&lt;String, Integer&gt; unmodifiable =
        prepareUnmodifiableTests(TreeMultimap.&lt;String, Integer&gt;create(), false, &quot;null&quot;, 42);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }

  @GwtIncompatible // slow (~10s)
  public void testUnmodifiableSynchronizedArrayListMultimap() {
    checkUnmodifiableMultimap(
        Multimaps.synchronizedListMultimap(ArrayListMultimap.&lt;String, Integer&gt;create()), true);
  }

  @GwtIncompatible // SerializableTester
  public void testSerializingUnmodifiableSynchronizedArrayListMultimap() {
    Multimap&lt;String, Integer&gt; unmodifiable =
        prepareUnmodifiableTests(
            Multimaps.synchronizedListMultimap(ArrayListMultimap.&lt;String, Integer&gt;create()),
            true,
            null,
            null);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }

  @GwtIncompatible // slow (~10s)
  public void testUnmodifiableSynchronizedHashMultimap() {
    checkUnmodifiableMultimap(
        Multimaps.synchronizedSetMultimap(HashMultimap.&lt;String, Integer&gt;create()), false);
  }

  @GwtIncompatible // SerializableTester
  public void testSerializingUnmodifiableSynchronizedHashMultimap() {
    Multimap&lt;String, Integer&gt; unmodifiable =
        prepareUnmodifiableTests(
            Multimaps.synchronizedSetMultimap(HashMultimap.&lt;String, Integer&gt;create()),
            false,
            null,
            null);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }

  @GwtIncompatible // slow (~10s)
  public void testUnmodifiableSynchronizedTreeMultimap() {
    TreeMultimap&lt;String, Integer&gt; delegate =
        TreeMultimap.create(Ordering.&lt;String&gt;natural(), INT_COMPARATOR);
    SortedSetMultimap&lt;String, Integer&gt; multimap = Multimaps.synchronizedSortedSetMultimap(delegate);
    checkUnmodifiableMultimap(multimap, false, &quot;null&quot;, 42);
    assertSame(INT_COMPARATOR, multimap.valueComparator());
  }

  @GwtIncompatible // SerializableTester
  public void testSerializingUnmodifiableSynchronizedTreeMultimap() {
    TreeMultimap&lt;String, Integer&gt; delegate =
        TreeMultimap.create(Ordering.&lt;String&gt;natural(), INT_COMPARATOR);
    SortedSetMultimap&lt;String, Integer&gt; multimap = Multimaps.synchronizedSortedSetMultimap(delegate);
    Multimap&lt;String, Integer&gt; unmodifiable = prepareUnmodifiableTests(multimap, false, &quot;null&quot;, 42);
    SerializableTester.reserializeAndAssert(unmodifiable);
    assertSame(INT_COMPARATOR, multimap.valueComparator());
  }

  public void testUnmodifiableMultimapIsView() {
    Multimap&lt;String, Integer&gt; mod = HashMultimap.create();
    Multimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableMultimap(mod);
    assertEquals(mod, unmod);
    mod.put(&quot;foo&quot;, 1);
    assertTrue(unmod.containsEntry(&quot;foo&quot;, 1));
    assertEquals(mod, unmod);
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public void testUnmodifiableMultimapEntries() {
    Multimap&lt;String, Integer&gt; mod = HashMultimap.create();
    Multimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableMultimap(mod);
    mod.put(&quot;foo&quot;, 1);
    Entry&lt;String, Integer&gt; entry = unmod.entries().iterator().next();
    try {
      entry.setValue(2);
      fail(&quot;UnsupportedOperationException expected&quot;);
    } catch (UnsupportedOperationException expected) {
    }
    entry = (Entry&lt;String, Integer&gt;) unmod.entries().toArray()[0];
    try {
      entry.setValue(2);
      fail(&quot;UnsupportedOperationException expected&quot;);
    } catch (UnsupportedOperationException expected) {
    }
    Entry&lt;String, Integer&gt;[] array = (Entry&lt;String, Integer&gt;[]) new Entry&lt;?, ?&gt;[2];
    assertSame(array, unmod.entries().toArray(array));
    try {
      array[0].setValue(2);
      fail(&quot;UnsupportedOperationException expected&quot;);
    } catch (UnsupportedOperationException expected) {
    }
    assertFalse(unmod.entries().contains(nefariousMapEntry(&quot;pwnd&quot;, 2)));
    assertFalse(unmod.keys().contains(&quot;pwnd&quot;));
  }

  /**
   * The supplied multimap will be mutated and an unmodifiable instance used in its stead. The
   * multimap must support null keys and values.
   */
  private static void checkUnmodifiableMultimap(
      Multimap&lt;String, Integer&gt; multimap, boolean permitsDuplicates) {
    checkUnmodifiableMultimap(multimap, permitsDuplicates, null, null);
  }

  /**
   * The supplied multimap will be mutated and an unmodifiable instance used in its stead. If the
   * multimap does not support null keys or values, alternatives may be specified for tests
   * involving nulls.
   */
  private static void checkUnmodifiableMultimap(
      Multimap&lt;String, Integer&gt; multimap,
      boolean permitsDuplicates,
      @CheckForNull String nullKey,
      @CheckForNull Integer nullValue) {
    Multimap&lt;String, Integer&gt; unmodifiable =
        prepareUnmodifiableTests(multimap, permitsDuplicates, nullKey, nullValue);

    UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(unmodifiable, &quot;test&quot;, 123);

    assertUnmodifiableIterableInTandem(unmodifiable.keys(), multimap.keys());

    assertUnmodifiableIterableInTandem(unmodifiable.keySet(), multimap.keySet());

    assertUnmodifiableIterableInTandem(unmodifiable.entries(), multimap.entries());

    assertUnmodifiableIterableInTandem(
        unmodifiable.asMap().entrySet(), multimap.asMap().entrySet());

    assertEquals(multimap.toString(), unmodifiable.toString());
    assertEquals(multimap.hashCode(), unmodifiable.hashCode());
    assertEquals(multimap, unmodifiable);

    assertThat(unmodifiable.asMap().get(&quot;bar&quot;)).containsExactly(5, -1);
    assertNull(unmodifiable.asMap().get(&quot;missing&quot;));

    assertFalse(unmodifiable.entries() instanceof Serializable);
  }

  /** Prepares the multimap for unmodifiable tests, returning an unmodifiable view of the map. */
  private static Multimap&lt;String, Integer&gt; prepareUnmodifiableTests(
      Multimap&lt;String, Integer&gt; multimap,
      boolean permitsDuplicates,
      @CheckForNull String nullKey,
      @CheckForNull Integer nullValue) {
    multimap.clear();
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;foo&quot;, 2);
    multimap.put(&quot;foo&quot;, 3);
    multimap.put(&quot;bar&quot;, 5);
    multimap.put(&quot;bar&quot;, -1);
    multimap.put(nullKey, nullValue);
    multimap.put(&quot;foo&quot;, nullValue);
    multimap.put(nullKey, 5);
    multimap.put(&quot;foo&quot;, 2);

    if (permitsDuplicates) {
      assertEquals(9, multimap.size());
    } else {
      assertEquals(8, multimap.size());
    }

    Multimap&lt;String, Integer&gt; unmodifiable;
    if (multimap instanceof SortedSetMultimap) {
      unmodifiable =
          Multimaps.unmodifiableSortedSetMultimap((SortedSetMultimap&lt;String, Integer&gt;) multimap);
    } else if (multimap instanceof SetMultimap) {
      unmodifiable = Multimaps.unmodifiableSetMultimap((SetMultimap&lt;String, Integer&gt;) multimap);
    } else if (multimap instanceof ListMultimap) {
      unmodifiable = Multimaps.unmodifiableListMultimap((ListMultimap&lt;String, Integer&gt;) multimap);
    } else {
      unmodifiable = Multimaps.unmodifiableMultimap(multimap);
    }
    return unmodifiable;
  }

  private static &lt;T&gt; void assertUnmodifiableIterableInTandem(
      Iterable&lt;T&gt; unmodifiable, Iterable&lt;T&gt; modifiable) {
    UnmodifiableCollectionTests.assertIteratorIsUnmodifiable(unmodifiable.iterator());
    UnmodifiableCollectionTests.assertIteratorsInOrder(
        unmodifiable.iterator(), modifiable.iterator());
  }

  public void testInvertFrom() {
    ImmutableMultimap&lt;Integer, String&gt; empty = ImmutableMultimap.of();

    // typical usage example - sad that ArrayListMultimap.create() won't work
    Multimap&lt;String, Integer&gt; multimap =
        Multimaps.invertFrom(empty, ArrayListMultimap.&lt;String, Integer&gt;create());
    assertTrue(multimap.isEmpty());

    ImmutableMultimap&lt;Integer, String&gt; single =
        new ImmutableMultimap.Builder&lt;Integer, String&gt;().put(1, &quot;one&quot;).put(2, &quot;two&quot;).build();

    // copy into existing multimap
    assertSame(multimap, Multimaps.invertFrom(single, multimap));

    ImmutableMultimap&lt;String, Integer&gt; expected =
        new ImmutableMultimap.Builder&lt;String, Integer&gt;().put(&quot;one&quot;, 1).put(&quot;two&quot;, 2).build();

    assertEquals(expected, multimap);
  }

  public void testAsMap_multimap() {
    Multimap&lt;String, Integer&gt; multimap =
        Multimaps.newMultimap(new HashMap&lt;String, Collection&lt;Integer&gt;&gt;(), new QueueSupplier());
    Map&lt;String, Collection&lt;Integer&gt;&gt; map = Multimaps.asMap(multimap);
    assertSame(multimap.asMap(), map);
  }

  public void testAsMap_listMultimap() {
    ListMultimap&lt;String, Integer&gt; listMultimap = ArrayListMultimap.create();
    Map&lt;String, List&lt;Integer&gt;&gt; map = Multimaps.asMap(listMultimap);
    assertSame(listMultimap.asMap(), map);
  }

  public void testAsMap_setMultimap() {
    SetMultimap&lt;String, Integer&gt; setMultimap = LinkedHashMultimap.create();
    Map&lt;String, Set&lt;Integer&gt;&gt; map = Multimaps.asMap(setMultimap);
    assertSame(setMultimap.asMap(), map);
  }

  public void testAsMap_sortedSetMultimap() {
    SortedSetMultimap&lt;String, Integer&gt; sortedSetMultimap = TreeMultimap.create();
    Map&lt;String, SortedSet&lt;Integer&gt;&gt; map = Multimaps.asMap(sortedSetMultimap);
    assertSame(sortedSetMultimap.asMap(), map);
  }

  public void testForMap() {
    Map&lt;String, Integer&gt; map = Maps.newHashMap();
    map.put(&quot;foo&quot;, 1);
    map.put(&quot;bar&quot;, 2);
    Multimap&lt;String, Integer&gt; multimap = HashMultimap.create();
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;bar&quot;, 2);
    Multimap&lt;String, Integer&gt; multimapView = Multimaps.forMap(map);
    new EqualsTester().addEqualityGroup(multimap, multimapView).addEqualityGroup(map).testEquals();
    Multimap&lt;String, Integer&gt; multimap2 = HashMultimap.create();
    multimap2.put(&quot;foo&quot;, 1);
    assertFalse(multimapView.equals(multimap2));
    multimap2.put(&quot;bar&quot;, 1);
    assertFalse(multimapView.equals(multimap2));
    ListMultimap&lt;String, Integer&gt; listMultimap =
        new ImmutableListMultimap.Builder&lt;String, Integer&gt;().put(&quot;foo&quot;, 1).put(&quot;bar&quot;, 2).build();
    assertFalse(&quot;SetMultimap equals ListMultimap&quot;, multimapView.equals(listMultimap));
    assertEquals(multimap.hashCode(), multimapView.hashCode());
    assertEquals(multimap.size(), multimapView.size());
    assertTrue(multimapView.containsKey(&quot;foo&quot;));
    assertTrue(multimapView.containsValue(1));
    assertTrue(multimapView.containsEntry(&quot;bar&quot;, 2));
    assertEquals(Collections.singleton(1), multimapView.get(&quot;foo&quot;));
    assertEquals(Collections.singleton(2), multimapView.get(&quot;bar&quot;));
    try {
      multimapView.put(&quot;baz&quot;, 3);
      fail(&quot;UnsupportedOperationException expected&quot;);
    } catch (UnsupportedOperationException expected) {
    }
    try {
      multimapView.putAll(&quot;baz&quot;, Collections.singleton(3));
      fail(&quot;UnsupportedOperationException expected&quot;);
    } catch (UnsupportedOperationException expected) {
    }
    try {
      multimapView.putAll(multimap);
      fail(&quot;UnsupportedOperationException expected&quot;);
    } catch (UnsupportedOperationException expected) {
    }
    try {
      multimapView.replaceValues(&quot;foo&quot;, Collections.&lt;Integer&gt;emptySet());
      fail(&quot;UnsupportedOperationException expected&quot;);
    } catch (UnsupportedOperationException expected) {
    }
    multimapView.remove(&quot;bar&quot;, 2);
    assertFalse(multimapView.containsKey(&quot;bar&quot;));
    assertFalse(map.containsKey(&quot;bar&quot;));
    assertEquals(map.keySet(), multimapView.keySet());
    assertEquals(map.keySet(), multimapView.keys().elementSet());
    assertThat(multimapView.keys()).contains(&quot;foo&quot;);
    assertThat(multimapView.values()).contains(1);
    assertThat(multimapView.entries()).contains(Maps.immutableEntry(&quot;foo&quot;, 1));
    assertThat(multimapView.asMap().entrySet())
        .contains(Maps.immutableEntry(&quot;foo&quot;, (Collection&lt;Integer&gt;) Collections.singleton(1)));
    multimapView.clear();
    assertFalse(multimapView.containsKey(&quot;foo&quot;));
    assertFalse(map.containsKey(&quot;foo&quot;));
    assertTrue(map.isEmpty());
    assertTrue(multimapView.isEmpty());
    multimap.clear();
    assertEquals(multimap.toString(), multimapView.toString());
    assertEquals(multimap.hashCode(), multimapView.hashCode());
    assertEquals(multimap.size(), multimapView.size());
    assertEquals(multimapView, ArrayListMultimap.create());
  }

  @GwtIncompatible // SerializableTester
  public void testForMapSerialization() {
    Map&lt;String, Integer&gt; map = Maps.newHashMap();
    map.put(&quot;foo&quot;, 1);
    map.put(&quot;bar&quot;, 2);
    Multimap&lt;String, Integer&gt; multimapView = Multimaps.forMap(map);
    SerializableTester.reserializeAndAssert(multimapView);
  }

  public void testForMapRemoveAll() {
    Map&lt;String, Integer&gt; map = Maps.newHashMap();
    map.put(&quot;foo&quot;, 1);
    map.put(&quot;bar&quot;, 2);
    map.put(&quot;cow&quot;, 3);
    Multimap&lt;String, Integer&gt; multimap = Multimaps.forMap(map);
    assertEquals(3, multimap.size());
    assertEquals(Collections.emptySet(), multimap.removeAll(&quot;dog&quot;));
    assertEquals(3, multimap.size());
    assertTrue(multimap.containsKey(&quot;bar&quot;));
    assertEquals(Collections.singleton(2), multimap.removeAll(&quot;bar&quot;));
    assertEquals(2, multimap.size());
    assertFalse(multimap.containsKey(&quot;bar&quot;));
  }

  public void testForMapAsMap() {
    Map&lt;String, Integer&gt; map = Maps.newHashMap();
    map.put(&quot;foo&quot;, 1);
    map.put(&quot;bar&quot;, 2);
    Map&lt;String, Collection&lt;Integer&gt;&gt; asMap = Multimaps.forMap(map).asMap();
    assertEquals(Collections.singleton(1), asMap.get(&quot;foo&quot;));
    assertNull(asMap.get(&quot;cow&quot;));
    assertTrue(asMap.containsKey(&quot;foo&quot;));
    assertFalse(asMap.containsKey(&quot;cow&quot;));

    Set&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt; entries = asMap.entrySet();
    assertFalse(entries.contains((Object) 4.5));
    assertFalse(entries.remove((Object) 4.5));
    assertFalse(entries.contains(Maps.immutableEntry(&quot;foo&quot;, Collections.singletonList(1))));
    assertFalse(entries.remove(Maps.immutableEntry(&quot;foo&quot;, Collections.singletonList(1))));
    assertFalse(entries.contains(Maps.immutableEntry(&quot;foo&quot;, Sets.newLinkedHashSet(asList(1, 2)))));
    assertFalse(entries.remove(Maps.immutableEntry(&quot;foo&quot;, Sets.newLinkedHashSet(asList(1, 2)))));
    assertFalse(entries.contains(Maps.immutableEntry(&quot;foo&quot;, Collections.singleton(2))));
    assertFalse(entries.remove(Maps.immutableEntry(&quot;foo&quot;, Collections.singleton(2))));
    assertTrue(map.containsKey(&quot;foo&quot;));
    assertTrue(entries.contains(Maps.immutableEntry(&quot;foo&quot;, Collections.singleton(1))));
    assertTrue(entries.remove(Maps.immutableEntry(&quot;foo&quot;, Collections.singleton(1))));
    assertFalse(map.containsKey(&quot;foo&quot;));
  }

  public void testForMapGetIteration() {
    IteratorTester&lt;Integer&gt; tester =
        new IteratorTester&lt;Integer&gt;(
            4, MODIFIABLE, newHashSet(1), IteratorTester.KnownOrder.KNOWN_ORDER) {
          private Multimap&lt;String, Integer&gt; multimap;

          @Override
          protected Iterator&lt;Integer&gt; newTargetIterator() {
            Map&lt;String, Integer&gt; map = Maps.newHashMap();
            map.put(&quot;foo&quot;, 1);
            map.put(&quot;bar&quot;, 2);
            multimap = Multimaps.forMap(map);
            return multimap.get(&quot;foo&quot;).iterator();
          }

          @Override
          protected void verify(List&lt;Integer&gt; elements) {
            assertEquals(newHashSet(elements), multimap.get(&quot;foo&quot;));
          }
        };

    tester.test();
  }

  private enum Color {
    BLUE,
    RED,
    YELLOW,
    GREEN
  }

  private abstract static class CountingSupplier&lt;E&gt; implements Supplier&lt;E&gt;, Serializable {
    int count;

    abstract E getImpl();

    @Override
    public E get() {
      count++;
      return getImpl();
    }
  }

  private static class QueueSupplier extends CountingSupplier&lt;Queue&lt;Integer&gt;&gt; {
    @Override
    public Queue&lt;Integer&gt; getImpl() {
      return new LinkedList&lt;&gt;();
    }

    private static final long serialVersionUID = 0;
  }

  public void testNewMultimapWithCollectionRejectingNegativeElements() {
    CountingSupplier&lt;Set&lt;Integer&gt;&gt; factory =
        new SetSupplier() {
          @Override
<A NAME="2"></A>          public Set&lt;Integer&gt; getImpl() {
            final Set&lt;Integer&gt; backing = super.getImpl();
            return new ForwardingSet&lt;Integer&gt;() {
              <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1518829-0.html#2',2,'match1518829-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
              protected Set&lt;Integer&gt; delegate() {
                return backing;
              }

              @Override
              public boolean add(Integer element) {</B></FONT>
                checkArgument(element &gt;= 0);
                return super.add(element);
              }

              @Override
              public boolean addAll(Collection&lt;? extends Integer&gt; collection) {
                return standardAddAll(collection);
              }
            };
          }
        };

    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
    Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
    try {
      multimap.put(Color.BLUE, -1);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
    multimap.put(Color.RED, 1);
    multimap.put(Color.BLUE, 2);
    try {
      multimap.put(Color.GREEN, -1);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
    assertThat(multimap.entries())
        .containsExactly(Maps.immutableEntry(Color.RED, 1), Maps.immutableEntry(Color.BLUE, 2));
  }

  public void testNewMultimap() {
    // The ubiquitous EnumArrayBlockingQueueMultimap
    CountingSupplier&lt;Queue&lt;Integer&gt;&gt; factory = new QueueSupplier();

    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
    Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
    assertEquals(0, factory.count);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    assertEquals(1, factory.count);
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    assertEquals(2, factory.count);
    assertEquals(&quot;[3, 1, 4]&quot;, multimap.get(Color.BLUE).toString());

    Multimap&lt;Color, Integer&gt; ummodifiable = Multimaps.unmodifiableMultimap(multimap);
    assertEquals(&quot;[3, 1, 4]&quot;, ummodifiable.get(Color.BLUE).toString());

    Collection&lt;Integer&gt; collection = multimap.get(Color.BLUE);
    // Explicitly call `equals`; `assertEquals` might return fast
    assertTrue(collection.equals(collection));

    assertFalse(multimap.keySet() instanceof SortedSet);
    assertFalse(multimap.asMap() instanceof SortedMap);
  }

  public void testNewMultimapValueCollectionMatchesNavigableSet() {
    Supplier&lt;TreeSet&lt;Integer&gt;&gt; factory = new SortedSetSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
    Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
    assertTrue(multimap.get(Color.BLUE) instanceof NavigableSet);
  }

  public void testNewMultimapValueCollectionMatchesList() {
    Supplier&lt;LinkedList&lt;Integer&gt;&gt; factory = new ListSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
    Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
    assertTrue(multimap.get(Color.BLUE) instanceof List);
  }

  @GwtIncompatible // SerializableTester
  public void testNewMultimapSerialization() {
    CountingSupplier&lt;Queue&lt;Integer&gt;&gt; factory = new QueueSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
    Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    SerializableTester.reserializeAndAssert(multimap);
  }

  private static class ListSupplier extends CountingSupplier&lt;LinkedList&lt;Integer&gt;&gt; {
    @Override
    public LinkedList&lt;Integer&gt; getImpl() {
      return new LinkedList&lt;&gt;();
    }

    private static final long serialVersionUID = 0;
  }

  public void testNewListMultimap() {
    CountingSupplier&lt;LinkedList&lt;Integer&gt;&gt; factory = new ListSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newTreeMap();
    ListMultimap&lt;Color, Integer&gt; multimap = Multimaps.newListMultimap(map, factory);
    assertEquals(0, factory.count);
    multimap.putAll(Color.BLUE, asList(3, 1, 4, 1));
    assertEquals(1, factory.count);
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    assertEquals(2, factory.count);
    assertEquals(&quot;{BLUE=[3, 1, 4, 1], RED=[2, 7, 1, 8]}&quot;, multimap.toString());
    assertFalse(multimap.get(Color.BLUE) instanceof RandomAccess);

    assertTrue(multimap.keySet() instanceof SortedSet);
    assertTrue(multimap.asMap() instanceof SortedMap);
  }

  @GwtIncompatible // SerializableTester
  public void testNewListMultimapSerialization() {
    CountingSupplier&lt;LinkedList&lt;Integer&gt;&gt; factory = new ListSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newTreeMap();
    ListMultimap&lt;Color, Integer&gt; multimap = Multimaps.newListMultimap(map, factory);
    multimap.putAll(Color.BLUE, asList(3, 1, 4, 1));
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    SerializableTester.reserializeAndAssert(multimap);
  }

  private static class SetSupplier extends CountingSupplier&lt;Set&lt;Integer&gt;&gt; {
    @Override
    public Set&lt;Integer&gt; getImpl() {
      return new HashSet&lt;&gt;(4);
    }

    private static final long serialVersionUID = 0;
  }

  public void testNewSetMultimap() {
    CountingSupplier&lt;Set&lt;Integer&gt;&gt; factory = new SetSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newHashMap();
    SetMultimap&lt;Color, Integer&gt; multimap = Multimaps.newSetMultimap(map, factory);
    assertEquals(0, factory.count);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    assertEquals(1, factory.count);
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    assertEquals(2, factory.count);
    assertEquals(Sets.newHashSet(4, 3, 1), multimap.get(Color.BLUE));
  }

  @GwtIncompatible // SerializableTester
  public void testNewSetMultimapSerialization() {
    CountingSupplier&lt;Set&lt;Integer&gt;&gt; factory = new SetSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newHashMap();
    SetMultimap&lt;Color, Integer&gt; multimap = Multimaps.newSetMultimap(map, factory);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    SerializableTester.reserializeAndAssert(multimap);
  }

  private static class SortedSetSupplier extends CountingSupplier&lt;TreeSet&lt;Integer&gt;&gt; {
    @Override
    public TreeSet&lt;Integer&gt; getImpl() {
      return Sets.newTreeSet(INT_COMPARATOR);
    }

    private static final long serialVersionUID = 0;
  }

  public void testNewSortedSetMultimap() {
    CountingSupplier&lt;TreeSet&lt;Integer&gt;&gt; factory = new SortedSetSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
    SortedSetMultimap&lt;Color, Integer&gt; multimap = Multimaps.newSortedSetMultimap(map, factory);
    // newSortedSetMultimap calls the factory once to determine the comparator.
    assertEquals(1, factory.count);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    assertEquals(2, factory.count);
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    assertEquals(3, factory.count);
    assertEquals(&quot;[4, 3, 1]&quot;, multimap.get(Color.BLUE).toString());
    assertEquals(INT_COMPARATOR, multimap.valueComparator());
  }

  @GwtIncompatible // SerializableTester
  public void testNewSortedSetMultimapSerialization() {
    CountingSupplier&lt;TreeSet&lt;Integer&gt;&gt; factory = new SortedSetSupplier();
    Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
    SortedSetMultimap&lt;Color, Integer&gt; multimap = Multimaps.newSortedSetMultimap(map, factory);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    SerializableTester.reserializeAndAssert(multimap);
    assertEquals(INT_COMPARATOR, multimap.valueComparator());
  }

  public void testIndex() {
    final Multimap&lt;String, Object&gt; stringToObject =
        new ImmutableMultimap.Builder&lt;String, Object&gt;()
            .put(&quot;1&quot;, 1)
            .put(&quot;1&quot;, 1L)
            .put(&quot;1&quot;, &quot;1&quot;)
            .put(&quot;2&quot;, 2)
            .put(&quot;2&quot;, 2L)
            .build();

    ImmutableMultimap&lt;String, Object&gt; outputMap =
        Multimaps.index(stringToObject.values(), Functions.toStringFunction());
    assertEquals(stringToObject, outputMap);
  }

  public void testIndexIterator() {
    final Multimap&lt;String, Object&gt; stringToObject =
        new ImmutableMultimap.Builder&lt;String, Object&gt;()
            .put(&quot;1&quot;, 1)
            .put(&quot;1&quot;, 1L)
            .put(&quot;1&quot;, &quot;1&quot;)
            .put(&quot;2&quot;, 2)
            .put(&quot;2&quot;, 2L)
            .build();

    ImmutableMultimap&lt;String, Object&gt; outputMap =
        Multimaps.index(stringToObject.values().iterator(), Functions.toStringFunction());
    assertEquals(stringToObject, outputMap);
  }

  public void testIndex_ordering() {
    final Multimap&lt;Integer, String&gt; expectedIndex =
        new ImmutableListMultimap.Builder&lt;Integer, String&gt;()
            .put(4, &quot;Inky&quot;)
            .put(6, &quot;Blinky&quot;)
            .put(5, &quot;Pinky&quot;)
            .put(5, &quot;Pinky&quot;)
            .put(5, &quot;Clyde&quot;)
            .build();

    final List&lt;String&gt; badGuys = Arrays.asList(&quot;Inky&quot;, &quot;Blinky&quot;, &quot;Pinky&quot;, &quot;Pinky&quot;, &quot;Clyde&quot;);
    final Function&lt;String, Integer&gt; stringLengthFunction =
        new Function&lt;String, Integer&gt;() {
          @Override
          public Integer apply(String input) {
            return input.length();
          }
        };

    Multimap&lt;Integer, String&gt; index = Multimaps.index(badGuys, stringLengthFunction);

    assertEquals(expectedIndex, index);
  }

  public void testIndex_nullValue() {
    List&lt;Integer&gt; values = Arrays.asList(1, null);
    try {
      Multimaps.index(values, Functions.identity());
      fail();
    } catch (NullPointerException expected) {
    }
  }

  public void testIndex_nullKey() {
    List&lt;Integer&gt; values = Arrays.asList(1, 2);
    try {
      Multimaps.index(values, Functions.constant(null));
      fail();
    } catch (NullPointerException expected) {
    }
  }

  @GwtIncompatible(value = &quot;untested&quot;)
  public void testTransformValues() {
    SetMultimap&lt;String, Integer&gt; multimap =
        ImmutableSetMultimap.of(&quot;a&quot;, 2, &quot;b&quot;, -3, &quot;b&quot;, 3, &quot;a&quot;, 4, &quot;c&quot;, 6);
    Function&lt;Integer, Integer&gt; square =
        new Function&lt;Integer, Integer&gt;() {
          @Override
          public Integer apply(Integer in) {
            return in * in;
          }
        };
    Multimap&lt;String, Integer&gt; transformed = Multimaps.transformValues(multimap, square);
    assertThat(transformed.entries())
        .containsExactly(
            immutableEntry(&quot;a&quot;, 4),
            immutableEntry(&quot;a&quot;, 16),
            immutableEntry(&quot;b&quot;, 9),
            immutableEntry(&quot;b&quot;, 9),
            immutableEntry(&quot;c&quot;, 36))
        .inOrder();
  }

  @GwtIncompatible(value = &quot;untested&quot;)
  public void testTransformValuesIsView() {
    Multimap&lt;String, String&gt; multimap = LinkedListMultimap.create();
    multimap.put(&quot;a&quot;, &quot;a&quot;);
    Multimap&lt;String, Integer&gt; transformed =
        Multimaps.transformValues(
            multimap,
            new Function&lt;String, Integer&gt;() {

              @Override
              public Integer apply(String str) {
                return str.length();
              }
            });
    Entry&lt;String, String&gt; entry = multimap.entries().iterator().next();
    entry.setValue(&quot;bbb&quot;);
    assertThat(transformed.entries()).containsExactly(immutableEntry(&quot;a&quot;, 3));
  }

  @GwtIncompatible(value = &quot;untested&quot;)
  public void testTransformListValues() {
    ListMultimap&lt;String, Integer&gt; multimap =
        ImmutableListMultimap.of(&quot;a&quot;, 2, &quot;b&quot;, -3, &quot;b&quot;, 3, &quot;a&quot;, 4, &quot;c&quot;, 6);
    Function&lt;Integer, Integer&gt; square =
        new Function&lt;Integer, Integer&gt;() {
          @Override
          public Integer apply(Integer in) {
            return in * in;
          }
        };
    ListMultimap&lt;String, Integer&gt; transformed = Multimaps.transformValues(multimap, square);
    assertThat(transformed.entries())
        .containsExactly(
            immutableEntry(&quot;a&quot;, 4),
            immutableEntry(&quot;a&quot;, 16),
            immutableEntry(&quot;b&quot;, 9),
            immutableEntry(&quot;b&quot;, 9),
            immutableEntry(&quot;c&quot;, 36))
        .inOrder();
  }

  @GwtIncompatible(value = &quot;untested&quot;)
  public void testTransformEntries() {
    SetMultimap&lt;String, Integer&gt; multimap = ImmutableSetMultimap.of(&quot;a&quot;, 1, &quot;a&quot;, 4, &quot;b&quot;, -6);
    EntryTransformer&lt;String, Integer, String&gt; transformer =
        new EntryTransformer&lt;String, Integer, String&gt;() {
          @Override
          public String transformEntry(String key, Integer value) {
            return (value &gt;= 0) ? key : &quot;no&quot; + key;
          }
        };
    Multimap&lt;String, String&gt; transformed = Multimaps.transformEntries(multimap, transformer);
    assertThat(transformed.entries())
        .containsExactly(
            immutableEntry(&quot;a&quot;, &quot;a&quot;), immutableEntry(&quot;a&quot;, &quot;a&quot;), immutableEntry(&quot;b&quot;, &quot;nob&quot;))
        .inOrder();
  }

  @GwtIncompatible(value = &quot;untested&quot;)
  public void testTransformListEntries() {
    ListMultimap&lt;String, Integer&gt; multimap =
        ImmutableListMultimap.of(&quot;a&quot;, 1, &quot;a&quot;, 4, &quot;b&quot;, 6, &quot;a&quot;, 4);
    EntryTransformer&lt;String, Integer, String&gt; transformer =
        new EntryTransformer&lt;String, Integer, String&gt;() {
          @Override
          public String transformEntry(String key, Integer value) {
            return key + value;
          }
        };
    ListMultimap&lt;String, String&gt; transformed = Multimaps.transformEntries(multimap, transformer);
    assertEquals(ImmutableListMultimap.of(&quot;a&quot;, &quot;a1&quot;, &quot;a&quot;, &quot;a4&quot;, &quot;a&quot;, &quot;a4&quot;, &quot;b&quot;, &quot;b6&quot;), transformed);
    assertEquals(&quot;{a=[a1, a4, a4], b=[b6]}&quot;, transformed.toString());
  }

  public &lt;K, V&gt; void testSynchronizedMultimapSampleCodeCompilation() {
    K key = null;

    Multimap&lt;K, V&gt; multimap = Multimaps.synchronizedMultimap(HashMultimap.&lt;K, V&gt;create());
    Collection&lt;V&gt; values = multimap.get(key); // Needn't be in synchronized block
    synchronized (multimap) { // Synchronizing on multimap, not values!
      Iterator&lt;V&gt; i = values.iterator(); // Must be in synchronized block
      while (i.hasNext()) {
        foo(i.next());
      }
    }
  }

  private static void foo(Object o) {}

  public void testFilteredKeysSetMultimapReplaceValues() {
    SetMultimap&lt;String, Integer&gt; multimap = LinkedHashMultimap.create();
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;bar&quot;, 2);
    multimap.put(&quot;baz&quot;, 3);
    multimap.put(&quot;bar&quot;, 4);

    SetMultimap&lt;String, Integer&gt; filtered =
        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(&quot;foo&quot;, &quot;bar&quot;)));

    assertEquals(ImmutableSet.of(), filtered.replaceValues(&quot;baz&quot;, ImmutableSet.&lt;Integer&gt;of()));

    try {
      filtered.replaceValues(&quot;baz&quot;, ImmutableSet.of(5));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testFilteredKeysSetMultimapGetBadValue() {
    SetMultimap&lt;String, Integer&gt; multimap = LinkedHashMultimap.create();
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;bar&quot;, 2);
    multimap.put(&quot;baz&quot;, 3);
    multimap.put(&quot;bar&quot;, 4);

    SetMultimap&lt;String, Integer&gt; filtered =
        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(&quot;foo&quot;, &quot;bar&quot;)));
    Set&lt;Integer&gt; bazSet = filtered.get(&quot;baz&quot;);
    assertThat(bazSet).isEmpty();
    try {
      bazSet.add(5);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
    try {
      bazSet.addAll(ImmutableSet.of(6, 7));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testFilteredKeysListMultimapGetBadValue() {
    ListMultimap&lt;String, Integer&gt; multimap = ArrayListMultimap.create();
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;bar&quot;, 2);
    multimap.put(&quot;baz&quot;, 3);
    multimap.put(&quot;bar&quot;, 4);

    ListMultimap&lt;String, Integer&gt; filtered =
        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of(&quot;foo&quot;, &quot;bar&quot;)));
    List&lt;Integer&gt; bazList = filtered.get(&quot;baz&quot;);
    assertThat(bazList).isEmpty();
    try {
      bazList.add(5);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
    try {
      bazList.add(0, 6);
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
    try {
      bazList.addAll(ImmutableList.of(7, 8));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
    try {
      bazList.addAll(0, ImmutableList.of(9, 10));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @GwtIncompatible // NullPointerTester
  public void testNullPointers() {
    new NullPointerTester().testAllPublicStaticMethods(Multimaps.class);
  }
}
</PRE>
</div>
  </div>
</body>
</html>
