<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for LinkedHashMultimap.java &amp; MultimapsTest_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for LinkedHashMultimap.java &amp; MultimapsTest_1.java
      </h3>
<h1 align="center">
        4.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>LinkedHashMultimap.java (6.741573%)<th>MultimapsTest_1.java (3.1662269%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-81)<td><a href="#" name="0">(38-66)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(581-594)<td><a href="#" name="1">(106-114)</a><td align="center"><font color="#840000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(391-397)<td><a href="#" name="2">(559-565)</a><td align="center"><font color="#660000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LinkedHashMultimap.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.collect;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkState;
4 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
5 import static java.util.Objects.requireNonNull;
6 import com.google.common.annotations.GwtCompatible;
7 import com.google.common.annotations.GwtIncompatible;
8 import com.google.common.annotations.VisibleForTesting;
9 import com.google.common.base.Objects;
10 import com.google.errorprone.annotations.CanIgnoreReturnValue;
11 import com.google.j2objc.annotations.WeakOuter;
12 import java.io.IOException;
13 import java.io.ObjectInputStream;
14 import java.io.ObjectOutputStream;
15 import java.util.Arrays;
16 import java.util.Collection;
17 import java.util.ConcurrentModificationException;
18 import java.util.Iterator;
19 import java.util.Map;
20 import java.util.Map.Entry;
21 import java.util.NoSuchElementException;
22 import java.util.Set;
23 import javax.annotation.CheckForNull;
24 import org.checkerframework.checker.nullness.qual.Nullable;
25 @GwtCompatible(s</b></font>erializable = true, emulated = true)
26 @ElementTypesAreNonnullByDefault
27 public final class LinkedHashMultimap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
28     extends LinkedHashMultimapGwtSerializationDependencies&lt;K, V&gt; {
29   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
30       LinkedHashMultimap&lt;K, V&gt; create() {
31     return new LinkedHashMultimap&lt;&gt;(DEFAULT_KEY_CAPACITY, DEFAULT_VALUE_SET_CAPACITY);
32   }
33   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
34       LinkedHashMultimap&lt;K, V&gt; create(int expectedKeys, int expectedValuesPerKey) {
35     return new LinkedHashMultimap&lt;&gt;(
36         Maps.capacity(expectedKeys), Maps.capacity(expectedValuesPerKey));
37   }
38   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
39       LinkedHashMultimap&lt;K, V&gt; create(Multimap&lt;? extends K, ? extends V&gt; multimap) {
40     LinkedHashMultimap&lt;K, V&gt; result = create(multimap.keySet().size(), DEFAULT_VALUE_SET_CAPACITY);
41     result.putAll(multimap);
42     return result;
43   }
44   private interface ValueSetLink&lt;K extends @Nullable Object, V extends @Nullable Object&gt; {
45     ValueSetLink&lt;K, V&gt; getPredecessorInValueSet();
46     ValueSetLink&lt;K, V&gt; getSuccessorInValueSet();
47     void setPredecessorInValueSet(ValueSetLink&lt;K, V&gt; entry);
48     void setSuccessorInValueSet(ValueSetLink&lt;K, V&gt; entry);
49   }
50   private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; void succeedsInValueSet(
51       ValueSetLink&lt;K, V&gt; pred, ValueSetLink&lt;K, V&gt; succ) {
52     pred.setSuccessorInValueSet(succ);
53     succ.setPredecessorInValueSet(pred);
54   }
55   private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; void succeedsInMultimap(
56       ValueEntry&lt;K, V&gt; pred, ValueEntry&lt;K, V&gt; succ) {
57     pred.setSuccessorInMultimap(succ);
58     succ.setPredecessorInMultimap(pred);
59   }
60   private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; void deleteFromValueSet(
61       ValueSetLink&lt;K, V&gt; entry) {
62     succeedsInValueSet(entry.getPredecessorInValueSet(), entry.getSuccessorInValueSet());
63   }
64   private static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; void deleteFromMultimap(
65       ValueEntry&lt;K, V&gt; entry) {
66     succeedsInMultimap(entry.getPredecessorInMultimap(), entry.getSuccessorInMultimap());
67   }
68   @VisibleForTesting
69   static final class ValueEntry&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
70       extends ImmutableEntry&lt;K, V&gt; implements ValueSetLink&lt;K, V&gt; {
71     final int smearedValueHash;
72     @CheckForNull ValueEntry&lt;K, V&gt; nextInValueBucket;
73     @CheckForNull ValueSetLink&lt;K, V&gt; predecessorInValueSet;
74     @CheckForNull ValueSetLink&lt;K, V&gt; successorInValueSet;
75     @CheckForNull ValueEntry&lt;K, V&gt; predecessorInMultimap;
76     @CheckForNull ValueEntry&lt;K, V&gt; successorInMultimap;
77     ValueEntry(
78         @ParametricNullness K key,
79         @ParametricNullness V value,
80         int smearedValueHash,
81         @CheckForNull ValueEntry&lt;K, V&gt; nextInValueBucket) {
82       super(key, value);
83       this.smearedValueHash = smearedValueHash;
84       this.nextInValueBucket = nextInValueBucket;
85     }
86     @SuppressWarnings("nullness")     static &lt;K extends @Nullable Object, V extends @Nullable Object&gt; ValueEntry&lt;K, V&gt; newHeader() {
87       return new ValueEntry&lt;&gt;(null, null, 0, null);
88     }
89     boolean matchesValue(@CheckForNull Object v, int smearedVHash) {
90       return smearedValueHash == smearedVHash &amp;&amp; Objects.equal(getValue(), v);
91     }
92     @Override
93     public ValueSetLink&lt;K, V&gt; getPredecessorInValueSet() {
94       return requireNonNull(predecessorInValueSet);     }
95     @Override
96     public ValueSetLink&lt;K, V&gt; getSuccessorInValueSet() {
97       return requireNonNull(successorInValueSet);     }
98     @Override
99     public void setPredecessorInValueSet(ValueSetLink&lt;K, V&gt; entry) {
100       predecessorInValueSet = entry;
101     }
102     @Override
103     public void setSuccessorInValueSet(ValueSetLink&lt;K, V&gt; entry) {
104       successorInValueSet = entry;
105     }
106     public ValueEntry&lt;K, V&gt; getPredecessorInMultimap() {
107       return requireNonNull(predecessorInMultimap);     }
108     public ValueEntry&lt;K, V&gt; getSuccessorInMultimap() {
109       return requireNonNull(successorInMultimap);     }
110     public void setSuccessorInMultimap(ValueEntry&lt;K, V&gt; multimapSuccessor) {
111       this.successorInMultimap = multimapSuccessor;
112     }
113     public void setPredecessorInMultimap(ValueEntry&lt;K, V&gt; multimapPredecessor) {
114       this.predecessorInMultimap = multimapPredecessor;
115     }
116   }
117   private static final int DEFAULT_KEY_CAPACITY = 16;
118   private static final int DEFAULT_VALUE_SET_CAPACITY = 2;
119   @VisibleForTesting static final double VALUE_SET_LOAD_FACTOR = 1.0;
120   @VisibleForTesting transient int valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
121   private transient ValueEntry&lt;K, V&gt; multimapHeaderEntry;
122   private LinkedHashMultimap(int keyCapacity, int valueSetCapacity) {
123     super(Platform.&lt;K, Collection&lt;V&gt;&gt;newLinkedHashMapWithExpectedSize(keyCapacity));
124     checkNonnegative(valueSetCapacity, "expectedValuesPerKey");
125     this.valueSetCapacity = valueSetCapacity;
126     this.multimapHeaderEntry = ValueEntry.newHeader();
127     succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
128   }
129   @Override
130   Set&lt;V&gt; createCollection() {
131     return Platform.newLinkedHashSetWithExpectedSize(valueSetCapacity);
132   }
133   @Override
134   Collection&lt;V&gt; createCollection(@ParametricNullness K key) {
135     return new ValueSet(key, valueSetCapacity);
136   }
137   @CanIgnoreReturnValue
138   @Override
139   public Set&lt;V&gt; replaceValues(@ParametricNullness K key, Iterable&lt;? extends V&gt; values) {
140     return super.replaceValues(key, values);
141   }
142   @Override
143   public Set&lt;Entry&lt;K, V&gt;&gt; entries() {
144     return super.entries();
145   }
146   @Override
147   public Set&lt;K&gt; keySet() {
148     return super.keySet();
149   }
150   @Override
151   public Collection&lt;V&gt; values() {
152     return super.values();
153   }
154   @VisibleForTesting
155   @WeakOuter
156   final class ValueSet extends Sets.ImprovedAbstractSet&lt;V&gt; implements ValueSetLink&lt;K, V&gt; {
157     @ParametricNullness private final K key;
158     @VisibleForTesting @Nullable ValueEntry&lt;K, V&gt;[] hashTable;
159     private int size = 0;
160     private int modCount = 0;
161     private ValueSetLink&lt;K, V&gt; firstEntry;
162     private ValueSetLink&lt;K, V&gt; lastEntry;
163     ValueSet(@ParametricNullness K key, int expectedValues) {
164       this.key = key;
165       this.firstEntry = this;
166       this.lastEntry = this;
167       int tableSize = Hashing.closedTableSize(expectedValues, VALUE_SET_LOAD_FACTOR);
168       @SuppressWarnings({"rawtypes", "unchecked"})
169       @Nullable
170       ValueEntry&lt;K, V&gt;[] hashTable = new @Nullable ValueEntry[tableSize];
171       this.hashTable = hashTable;
172     }
173     private int mask() {
174       return hashTable.length - 1;
175     }
176     @Override
177     public ValueSetLink&lt;K, V&gt; getPredecessorInValueSet() {
178 <a name="2"></a>      return lastEntry;
179     }
180     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
181     public ValueSetLink&lt;K, V&gt; getSuccessorInValueSet() {
182       return firstEntry;
183     }
184     @Override
185     public void setPredecessorInValueSet(ValueSetLink&lt;K, V&gt; entry) {</b></font>
186       lastEntry = entry;
187     }
188     @Override
189     public void setSuccessorInValueSet(ValueSetLink&lt;K, V&gt; entry) {
190       firstEntry = entry;
191     }
192     @Override
193     public Iterator&lt;V&gt; iterator() {
194       return new Iterator&lt;V&gt;() {
195         ValueSetLink&lt;K, V&gt; nextEntry = firstEntry;
196         @CheckForNull ValueEntry&lt;K, V&gt; toRemove;
197         int expectedModCount = modCount;
198         private void checkForComodification() {
199           if (modCount != expectedModCount) {
200             throw new ConcurrentModificationException();
201           }
202         }
203         @Override
204         public boolean hasNext() {
205           checkForComodification();
206           return nextEntry != ValueSet.this;
207         }
208         @Override
209         @ParametricNullness
210         public V next() {
211           if (!hasNext()) {
212             throw new NoSuchElementException();
213           }
214           ValueEntry&lt;K, V&gt; entry = (ValueEntry&lt;K, V&gt;) nextEntry;
215           V result = entry.getValue();
216           toRemove = entry;
217           nextEntry = entry.getSuccessorInValueSet();
218           return result;
219         }
220         @Override
221         public void remove() {
222           checkForComodification();
223           checkState(toRemove != null, "no calls to next() since the last call to remove()");
224           ValueSet.this.remove(toRemove.getValue());
225           expectedModCount = modCount;
226           toRemove = null;
227         }
228       };
229     }
230     @Override
231     public int size() {
232       return size;
233     }
234     @Override
235     public boolean contains(@CheckForNull Object o) {
236       int smearedHash = Hashing.smearedHash(o);
237       for (ValueEntry&lt;K, V&gt; entry = hashTable[smearedHash &amp; mask()];
238           entry != null;
239           entry = entry.nextInValueBucket) {
240         if (entry.matchesValue(o, smearedHash)) {
241           return true;
242         }
243       }
244       return false;
245     }
246     @Override
247     public boolean add(@ParametricNullness V value) {
248       int smearedHash = Hashing.smearedHash(value);
249       int bucket = smearedHash &amp; mask();
250       ValueEntry&lt;K, V&gt; rowHead = hashTable[bucket];
251       for (ValueEntry&lt;K, V&gt; entry = rowHead; entry != null; entry = entry.nextInValueBucket) {
252         if (entry.matchesValue(value, smearedHash)) {
253           return false;
254         }
255       }
256       ValueEntry&lt;K, V&gt; newEntry = new ValueEntry&lt;&gt;(key, value, smearedHash, rowHead);
257       succeedsInValueSet(lastEntry, newEntry);
258       succeedsInValueSet(newEntry, this);
259       succeedsInMultimap(multimapHeaderEntry.getPredecessorInMultimap(), newEntry);
260       succeedsInMultimap(newEntry, multimapHeaderEntry);
261       hashTable[bucket] = newEntry;
262       size++;
263       modCount++;
264       rehashIfNecessary();
265       return true;
266     }
267     private void rehashIfNecessary() {
268       if (Hashing.needsResizing(size, hashTable.length, VALUE_SET_LOAD_FACTOR)) {
269         @SuppressWarnings("unchecked")
270         ValueEntry&lt;K, V&gt;[] hashTable = new ValueEntry[this.hashTable.length * 2];
271         this.hashTable = hashTable;
272         int mask = hashTable.length - 1;
273         for (ValueSetLink&lt;K, V&gt; entry = firstEntry;
274             entry != this;
275             entry = entry.getSuccessorInValueSet()) {
276           ValueEntry&lt;K, V&gt; valueEntry = (ValueEntry&lt;K, V&gt;) entry;
277           int bucket = valueEntry.smearedValueHash &amp; mask;
278           valueEntry.nextInValueBucket = hashTable[bucket];
279           hashTable[bucket] = valueEntry;
280         }
281       }
282     }
283     @CanIgnoreReturnValue
284     @Override
285     public boolean remove(@CheckForNull Object o) {
286       int smearedHash = Hashing.smearedHash(o);
287       int bucket = smearedHash &amp; mask();
288       ValueEntry&lt;K, V&gt; prev = null;
289       for (ValueEntry&lt;K, V&gt; entry = hashTable[bucket];
290           entry != null;
291           prev = entry, entry = entry.nextInValueBucket) {
292         if (entry.matchesValue(o, smearedHash)) {
293           if (prev == null) {
294             hashTable[bucket] = entry.nextInValueBucket;
295           } else {
296             prev.nextInValueBucket = entry.nextInValueBucket;
297           }
298           deleteFromValueSet(entry);
299           deleteFromMultimap(entry);
300           size--;
301           modCount++;
302           return true;
303         }
304       }
305       return false;
306     }
307     @Override
308     public void clear() {
309       Arrays.fill(hashTable, null);
310       size = 0;
311       for (ValueSetLink&lt;K, V&gt; entry = firstEntry;
312           entry != this;
313           entry = entry.getSuccessorInValueSet()) {
314         ValueEntry&lt;K, V&gt; valueEntry = (ValueEntry&lt;K, V&gt;) entry;
315         deleteFromMultimap(valueEntry);
316       }
317       succeedsInValueSet(this, this);
318       modCount++;
319     }
320   }
321   @Override
322   Iterator&lt;Entry&lt;K, V&gt;&gt; entryIterator() {
323     return new Iterator&lt;Entry&lt;K, V&gt;&gt;() {
324       ValueEntry&lt;K, V&gt; nextEntry = multimapHeaderEntry.getSuccessorInMultimap();
325       @CheckForNull ValueEntry&lt;K, V&gt; toRemove;
326       @Override
327       public boolean hasNext() {
328         return nextEntry != multimapHeaderEntry;
329       }
330       @Override
331       public Entry&lt;K, V&gt; next() {
332         if (!hasNext()) {
333           throw new NoSuchElementException();
334         }
335         ValueEntry&lt;K, V&gt; result = nextEntry;
336         toRemove = result;
337         nextEntry = nextEntry.getSuccessorInMultimap();
338         return result;
339       }
340       @Override
341       public void remove() {
342         checkState(toRemove != null, "no calls to next() since the last call to remove()");
343         LinkedHashMultimap.this.remove(toRemove.getKey(), toRemove.getValue());
344         toRemove = null;
345       }
346     };
347   }
348 <a name="1"></a>
349   @Override
350   Iterator&lt;V&gt; valueIterator() {
351     return <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Maps.valueIterator(entryIterator());
352   }
353   @Override
354   public void clear() {
355     super.clear();
356     succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
357   }
358   @</b></font>GwtIncompatible   private void writeObject(ObjectOutputStream stream) throws IOException {
359     stream.defaultWriteObject();
360     stream.writeInt(keySet().size());
361     for (K key : keySet()) {
362       stream.writeObject(key);
363     }
364     stream.writeInt(size());
365     for (Entry&lt;K, V&gt; entry : entries()) {
366       stream.writeObject(entry.getKey());
367       stream.writeObject(entry.getValue());
368     }
369   }
370   @GwtIncompatible   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
371     stream.defaultReadObject();
372     multimapHeaderEntry = ValueEntry.newHeader();
373     succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
374     valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
375     int distinctKeys = stream.readInt();
376     Map&lt;K, Collection&lt;V&gt;&gt; map = Platform.newLinkedHashMapWithExpectedSize(12);
377     for (int i = 0; i &lt; distinctKeys; i++) {
378       @SuppressWarnings("unchecked")
379       K key = (K) stream.readObject();
380       map.put(key, createCollection(key));
381     }
382     int entries = stream.readInt();
383     for (int i = 0; i &lt; entries; i++) {
384       @SuppressWarnings("unchecked")
385       K key = (K) stream.readObject();
386       @SuppressWarnings("unchecked")
387       V value = (V) stream.readObject();
388       requireNonNull(map.get(key)).add(value);
389     }
390     setMap(map);
391   }
392   @GwtIncompatible   private static final long serialVersionUID = 1;
393 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MultimapsTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.collect.Maps.immutableEntry;
4 import static com.google.common.collect.Sets.newHashSet;
5 import static com.google.common.collect.testing.Helpers.nefariousMapEntry;
6 import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
7 import static com.google.common.truth.Truth.assertThat;
8 import static java.util.Arrays.asList;
9 import com.google.common.annotations.GwtCompatible;
10 import com.google.common.annotations.GwtIncompatible;
11 import com.google.common.base.Function;
12 import com.google.common.base.Functions;
13 import com.google.common.base.Predicates;
14 import com.google.common.base.Supplier;
15 import com.google.common.collect.Maps.EntryTransformer;
16 import com.google.common.collect.testing.IteratorTester;
17 <a name="0"></a>import com.google.common.collect.testing.google.UnmodifiableCollectionTests;
18 import com.google.common.testing.EqualsTester;
19 import com.google.common.testing.NullPointerTester;
20 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.testing.SerializableTester;
21 import java.io.Serializable;
22 import java.util.Arrays;
23 import java.util.Collection;
24 import java.util.Collections;
25 import java.util.Comparator;
26 import java.util.HashMap;
27 import java.util.HashSet;
28 import java.util.Iterator;
29 import java.util.LinkedList;
30 import java.util.List;
31 import java.util.Map;
32 import java.util.Map.Entry;
33 import java.util.NavigableSet;
34 import java.util.Queue;
35 import java.util.RandomAccess;
36 import java.util.Set;
37 import java.util.SortedMap;
38 import java.util.SortedSet;
39 import java.util.TreeSet;
40 import javax.annotation.CheckForNull;
41 import junit.framework.TestCase;
42 @GwtCompatible(e</b></font>mulated = true)
43 public class MultimapsTest extends TestCase {
44   private static final Comparator&lt;Integer&gt; INT_COMPARATOR =
45       Ordering.&lt;Integer&gt;natural().reverse().nullsFirst();
46   @SuppressWarnings("deprecation")
47   public void testUnmodifiableListMultimapShortCircuit() {
48     ListMultimap&lt;String, Integer&gt; mod = ArrayListMultimap.create();
49     ListMultimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableListMultimap(mod);
50     assertNotSame(mod, unmod);
51     assertSame(unmod, Multimaps.unmodifiableListMultimap(unmod));
52     ImmutableListMultimap&lt;String, Integer&gt; immutable =
53         ImmutableListMultimap.of("a", 1, "b", 2, "a", 3);
54     assertSame(immutable, Multimaps.unmodifiableListMultimap(immutable));
55     assertSame(
56         immutable, Multimaps.unmodifiableListMultimap((ListMultimap&lt;String, Integer&gt;) immutable));
57   }
58   @SuppressWarnings("deprecation")
59   public void testUnmodifiableSetMultimapShortCircuit() {
60     SetMultimap&lt;String, Integer&gt; mod = HashMultimap.create();
61     SetMultimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableSetMultimap(mod);
62     assertNotSame(mod, unmod);
63     assertSame(unmod, Multimaps.unmodifiableSetMultimap(unmod));
64     ImmutableSetMultimap&lt;String, Integer&gt; immutable =
65         ImmutableSetMultimap.of("a", 1, "b", 2, "a", 3);
66     assertSame(immutable, Multimaps.unmodifiableSetMultimap(immutable));
67     assertSame(
68         immutable, Multimaps.unmodifiableSetMultimap((SetMultimap&lt;String, Integer&gt;) immutable));
69   }
70   @SuppressWarnings("deprecation")
71   public void testUnmodifiableMultimapShortCircuit() {
72     Multimap&lt;String, Integer&gt; mod = HashMultimap.create();
73     Multimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableMultimap(mod);
74     assertNotSame(mod, unmod);
75 <a name="1"></a>    assertSame(unmod, Multimaps.unmodifiableMultimap(unmod));
76     ImmutableMultimap&lt;String, Integer&gt; immutable = ImmutableMultimap.of("a", 1, "b", 2, "a", 3);
77     assertSame(immutable, Multimaps.unmodifiableMultimap(immutable));
78     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertSame(immutable, Multimaps.unmodifiableMultimap((Multimap&lt;String, Integer&gt;) immutable));
79   }
80   @GwtIncompatible   public void testUnmodifiableArrayListMultimap() {
81     checkUnmodifiableMultimap(ArrayListMultimap.&lt;String, Integer&gt;create(), true);
82   }
83   @</b></font>GwtIncompatible   public void testSerializingUnmodifiableArrayListMultimap() {
84     Multimap&lt;String, Integer&gt; unmodifiable =
85         prepareUnmodifiableTests(ArrayListMultimap.&lt;String, Integer&gt;create(), true, null, null);
86     SerializableTester.reserializeAndAssert(unmodifiable);
87   }
88   public void testUnmodifiableArrayListMultimapRandomAccess() {
89     ListMultimap&lt;String, Integer&gt; delegate = ArrayListMultimap.create();
90     delegate.put("foo", 1);
91     delegate.put("foo", 3);
92     ListMultimap&lt;String, Integer&gt; multimap = Multimaps.unmodifiableListMultimap(delegate);
93     assertTrue(multimap.get("foo") instanceof RandomAccess);
94     assertTrue(multimap.get("bar") instanceof RandomAccess);
95   }
96   public void testUnmodifiableLinkedListMultimapRandomAccess() {
97     ListMultimap&lt;String, Integer&gt; delegate = LinkedListMultimap.create();
98     delegate.put("foo", 1);
99     delegate.put("foo", 3);
100     ListMultimap&lt;String, Integer&gt; multimap = Multimaps.unmodifiableListMultimap(delegate);
101     assertFalse(multimap.get("foo") instanceof RandomAccess);
102     assertFalse(multimap.get("bar") instanceof RandomAccess);
103   }
104   @GwtIncompatible   public void testUnmodifiableHashMultimap() {
105     checkUnmodifiableMultimap(HashMultimap.&lt;String, Integer&gt;create(), false);
106   }
107   @GwtIncompatible   public void testSerializingUnmodifiableHashMultimap() {
108     Multimap&lt;String, Integer&gt; unmodifiable =
109         prepareUnmodifiableTests(HashMultimap.&lt;String, Integer&gt;create(), false, null, null);
110     SerializableTester.reserializeAndAssert(unmodifiable);
111   }
112   @GwtIncompatible   public void testUnmodifiableTreeMultimap() {
113     checkUnmodifiableMultimap(TreeMultimap.&lt;String, Integer&gt;create(), false, "null", 42);
114   }
115   @GwtIncompatible   public void testSerializingUnmodifiableTreeMultimap() {
116     Multimap&lt;String, Integer&gt; unmodifiable =
117         prepareUnmodifiableTests(TreeMultimap.&lt;String, Integer&gt;create(), false, "null", 42);
118     SerializableTester.reserializeAndAssert(unmodifiable);
119   }
120   @GwtIncompatible   public void testUnmodifiableSynchronizedArrayListMultimap() {
121     checkUnmodifiableMultimap(
122         Multimaps.synchronizedListMultimap(ArrayListMultimap.&lt;String, Integer&gt;create()), true);
123   }
124   @GwtIncompatible   public void testSerializingUnmodifiableSynchronizedArrayListMultimap() {
125     Multimap&lt;String, Integer&gt; unmodifiable =
126         prepareUnmodifiableTests(
127             Multimaps.synchronizedListMultimap(ArrayListMultimap.&lt;String, Integer&gt;create()),
128             true,
129             null,
130             null);
131     SerializableTester.reserializeAndAssert(unmodifiable);
132   }
133   @GwtIncompatible   public void testUnmodifiableSynchronizedHashMultimap() {
134     checkUnmodifiableMultimap(
135         Multimaps.synchronizedSetMultimap(HashMultimap.&lt;String, Integer&gt;create()), false);
136   }
137   @GwtIncompatible   public void testSerializingUnmodifiableSynchronizedHashMultimap() {
138     Multimap&lt;String, Integer&gt; unmodifiable =
139         prepareUnmodifiableTests(
140             Multimaps.synchronizedSetMultimap(HashMultimap.&lt;String, Integer&gt;create()),
141             false,
142             null,
143             null);
144     SerializableTester.reserializeAndAssert(unmodifiable);
145   }
146   @GwtIncompatible   public void testUnmodifiableSynchronizedTreeMultimap() {
147     TreeMultimap&lt;String, Integer&gt; delegate =
148         TreeMultimap.create(Ordering.&lt;String&gt;natural(), INT_COMPARATOR);
149     SortedSetMultimap&lt;String, Integer&gt; multimap = Multimaps.synchronizedSortedSetMultimap(delegate);
150     checkUnmodifiableMultimap(multimap, false, "null", 42);
151     assertSame(INT_COMPARATOR, multimap.valueComparator());
152   }
153   @GwtIncompatible   public void testSerializingUnmodifiableSynchronizedTreeMultimap() {
154     TreeMultimap&lt;String, Integer&gt; delegate =
155         TreeMultimap.create(Ordering.&lt;String&gt;natural(), INT_COMPARATOR);
156     SortedSetMultimap&lt;String, Integer&gt; multimap = Multimaps.synchronizedSortedSetMultimap(delegate);
157     Multimap&lt;String, Integer&gt; unmodifiable = prepareUnmodifiableTests(multimap, false, "null", 42);
158     SerializableTester.reserializeAndAssert(unmodifiable);
159     assertSame(INT_COMPARATOR, multimap.valueComparator());
160   }
161   public void testUnmodifiableMultimapIsView() {
162     Multimap&lt;String, Integer&gt; mod = HashMultimap.create();
163     Multimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableMultimap(mod);
164     assertEquals(mod, unmod);
165     mod.put("foo", 1);
166     assertTrue(unmod.containsEntry("foo", 1));
167     assertEquals(mod, unmod);
168   }
169   @SuppressWarnings("unchecked")
170   public void testUnmodifiableMultimapEntries() {
171     Multimap&lt;String, Integer&gt; mod = HashMultimap.create();
172     Multimap&lt;String, Integer&gt; unmod = Multimaps.unmodifiableMultimap(mod);
173     mod.put("foo", 1);
174     Entry&lt;String, Integer&gt; entry = unmod.entries().iterator().next();
175     try {
176       entry.setValue(2);
177       fail("UnsupportedOperationException expected");
178     } catch (UnsupportedOperationException expected) {
179     }
180     entry = (Entry&lt;String, Integer&gt;) unmod.entries().toArray()[0];
181     try {
182       entry.setValue(2);
183       fail("UnsupportedOperationException expected");
184     } catch (UnsupportedOperationException expected) {
185     }
186     Entry&lt;String, Integer&gt;[] array = (Entry&lt;String, Integer&gt;[]) new Entry&lt;?, ?&gt;[2];
187     assertSame(array, unmod.entries().toArray(array));
188     try {
189       array[0].setValue(2);
190       fail("UnsupportedOperationException expected");
191     } catch (UnsupportedOperationException expected) {
192     }
193     assertFalse(unmod.entries().contains(nefariousMapEntry("pwnd", 2)));
194     assertFalse(unmod.keys().contains("pwnd"));
195   }
196   private static void checkUnmodifiableMultimap(
197       Multimap&lt;String, Integer&gt; multimap, boolean permitsDuplicates) {
198     checkUnmodifiableMultimap(multimap, permitsDuplicates, null, null);
199   }
200   private static void checkUnmodifiableMultimap(
201       Multimap&lt;String, Integer&gt; multimap,
202       boolean permitsDuplicates,
203       @CheckForNull String nullKey,
204       @CheckForNull Integer nullValue) {
205     Multimap&lt;String, Integer&gt; unmodifiable =
206         prepareUnmodifiableTests(multimap, permitsDuplicates, nullKey, nullValue);
207     UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(unmodifiable, "test", 123);
208     assertUnmodifiableIterableInTandem(unmodifiable.keys(), multimap.keys());
209     assertUnmodifiableIterableInTandem(unmodifiable.keySet(), multimap.keySet());
210     assertUnmodifiableIterableInTandem(unmodifiable.entries(), multimap.entries());
211     assertUnmodifiableIterableInTandem(
212         unmodifiable.asMap().entrySet(), multimap.asMap().entrySet());
213     assertEquals(multimap.toString(), unmodifiable.toString());
214     assertEquals(multimap.hashCode(), unmodifiable.hashCode());
215     assertEquals(multimap, unmodifiable);
216     assertThat(unmodifiable.asMap().get("bar")).containsExactly(5, -1);
217     assertNull(unmodifiable.asMap().get("missing"));
218     assertFalse(unmodifiable.entries() instanceof Serializable);
219   }
220   private static Multimap&lt;String, Integer&gt; prepareUnmodifiableTests(
221       Multimap&lt;String, Integer&gt; multimap,
222       boolean permitsDuplicates,
223       @CheckForNull String nullKey,
224       @CheckForNull Integer nullValue) {
225     multimap.clear();
226     multimap.put("foo", 1);
227     multimap.put("foo", 2);
228     multimap.put("foo", 3);
229     multimap.put("bar", 5);
230     multimap.put("bar", -1);
231     multimap.put(nullKey, nullValue);
232     multimap.put("foo", nullValue);
233     multimap.put(nullKey, 5);
234     multimap.put("foo", 2);
235     if (permitsDuplicates) {
236       assertEquals(9, multimap.size());
237     } else {
238       assertEquals(8, multimap.size());
239     }
240     Multimap&lt;String, Integer&gt; unmodifiable;
241     if (multimap instanceof SortedSetMultimap) {
242       unmodifiable =
243           Multimaps.unmodifiableSortedSetMultimap((SortedSetMultimap&lt;String, Integer&gt;) multimap);
244     } else if (multimap instanceof SetMultimap) {
245       unmodifiable = Multimaps.unmodifiableSetMultimap((SetMultimap&lt;String, Integer&gt;) multimap);
246     } else if (multimap instanceof ListMultimap) {
247       unmodifiable = Multimaps.unmodifiableListMultimap((ListMultimap&lt;String, Integer&gt;) multimap);
248     } else {
249       unmodifiable = Multimaps.unmodifiableMultimap(multimap);
250     }
251     return unmodifiable;
252   }
253   private static &lt;T&gt; void assertUnmodifiableIterableInTandem(
254       Iterable&lt;T&gt; unmodifiable, Iterable&lt;T&gt; modifiable) {
255     UnmodifiableCollectionTests.assertIteratorIsUnmodifiable(unmodifiable.iterator());
256     UnmodifiableCollectionTests.assertIteratorsInOrder(
257         unmodifiable.iterator(), modifiable.iterator());
258   }
259   public void testInvertFrom() {
260     ImmutableMultimap&lt;Integer, String&gt; empty = ImmutableMultimap.of();
261     Multimap&lt;String, Integer&gt; multimap =
262         Multimaps.invertFrom(empty, ArrayListMultimap.&lt;String, Integer&gt;create());
263     assertTrue(multimap.isEmpty());
264     ImmutableMultimap&lt;Integer, String&gt; single =
265         new ImmutableMultimap.Builder&lt;Integer, String&gt;().put(1, "one").put(2, "two").build();
266     assertSame(multimap, Multimaps.invertFrom(single, multimap));
267     ImmutableMultimap&lt;String, Integer&gt; expected =
268         new ImmutableMultimap.Builder&lt;String, Integer&gt;().put("one", 1).put("two", 2).build();
269     assertEquals(expected, multimap);
270   }
271   public void testAsMap_multimap() {
272     Multimap&lt;String, Integer&gt; multimap =
273         Multimaps.newMultimap(new HashMap&lt;String, Collection&lt;Integer&gt;&gt;(), new QueueSupplier());
274     Map&lt;String, Collection&lt;Integer&gt;&gt; map = Multimaps.asMap(multimap);
275     assertSame(multimap.asMap(), map);
276   }
277   public void testAsMap_listMultimap() {
278     ListMultimap&lt;String, Integer&gt; listMultimap = ArrayListMultimap.create();
279     Map&lt;String, List&lt;Integer&gt;&gt; map = Multimaps.asMap(listMultimap);
280     assertSame(listMultimap.asMap(), map);
281   }
282   public void testAsMap_setMultimap() {
283     SetMultimap&lt;String, Integer&gt; setMultimap = LinkedHashMultimap.create();
284     Map&lt;String, Set&lt;Integer&gt;&gt; map = Multimaps.asMap(setMultimap);
285     assertSame(setMultimap.asMap(), map);
286   }
287   public void testAsMap_sortedSetMultimap() {
288     SortedSetMultimap&lt;String, Integer&gt; sortedSetMultimap = TreeMultimap.create();
289     Map&lt;String, SortedSet&lt;Integer&gt;&gt; map = Multimaps.asMap(sortedSetMultimap);
290     assertSame(sortedSetMultimap.asMap(), map);
291   }
292   public void testForMap() {
293     Map&lt;String, Integer&gt; map = Maps.newHashMap();
294     map.put("foo", 1);
295     map.put("bar", 2);
296     Multimap&lt;String, Integer&gt; multimap = HashMultimap.create();
297     multimap.put("foo", 1);
298     multimap.put("bar", 2);
299     Multimap&lt;String, Integer&gt; multimapView = Multimaps.forMap(map);
300     new EqualsTester().addEqualityGroup(multimap, multimapView).addEqualityGroup(map).testEquals();
301     Multimap&lt;String, Integer&gt; multimap2 = HashMultimap.create();
302     multimap2.put("foo", 1);
303     assertFalse(multimapView.equals(multimap2));
304     multimap2.put("bar", 1);
305     assertFalse(multimapView.equals(multimap2));
306     ListMultimap&lt;String, Integer&gt; listMultimap =
307         new ImmutableListMultimap.Builder&lt;String, Integer&gt;().put("foo", 1).put("bar", 2).build();
308     assertFalse("SetMultimap equals ListMultimap", multimapView.equals(listMultimap));
309     assertEquals(multimap.hashCode(), multimapView.hashCode());
310     assertEquals(multimap.size(), multimapView.size());
311     assertTrue(multimapView.containsKey("foo"));
312     assertTrue(multimapView.containsValue(1));
313     assertTrue(multimapView.containsEntry("bar", 2));
314     assertEquals(Collections.singleton(1), multimapView.get("foo"));
315     assertEquals(Collections.singleton(2), multimapView.get("bar"));
316     try {
317       multimapView.put("baz", 3);
318       fail("UnsupportedOperationException expected");
319     } catch (UnsupportedOperationException expected) {
320     }
321     try {
322       multimapView.putAll("baz", Collections.singleton(3));
323       fail("UnsupportedOperationException expected");
324     } catch (UnsupportedOperationException expected) {
325     }
326     try {
327       multimapView.putAll(multimap);
328       fail("UnsupportedOperationException expected");
329     } catch (UnsupportedOperationException expected) {
330     }
331     try {
332       multimapView.replaceValues("foo", Collections.&lt;Integer&gt;emptySet());
333       fail("UnsupportedOperationException expected");
334     } catch (UnsupportedOperationException expected) {
335     }
336     multimapView.remove("bar", 2);
337     assertFalse(multimapView.containsKey("bar"));
338     assertFalse(map.containsKey("bar"));
339     assertEquals(map.keySet(), multimapView.keySet());
340     assertEquals(map.keySet(), multimapView.keys().elementSet());
341     assertThat(multimapView.keys()).contains("foo");
342     assertThat(multimapView.values()).contains(1);
343     assertThat(multimapView.entries()).contains(Maps.immutableEntry("foo", 1));
344     assertThat(multimapView.asMap().entrySet())
345         .contains(Maps.immutableEntry("foo", (Collection&lt;Integer&gt;) Collections.singleton(1)));
346     multimapView.clear();
347     assertFalse(multimapView.containsKey("foo"));
348     assertFalse(map.containsKey("foo"));
349     assertTrue(map.isEmpty());
350     assertTrue(multimapView.isEmpty());
351     multimap.clear();
352     assertEquals(multimap.toString(), multimapView.toString());
353     assertEquals(multimap.hashCode(), multimapView.hashCode());
354     assertEquals(multimap.size(), multimapView.size());
355     assertEquals(multimapView, ArrayListMultimap.create());
356   }
357   @GwtIncompatible   public void testForMapSerialization() {
358     Map&lt;String, Integer&gt; map = Maps.newHashMap();
359     map.put("foo", 1);
360     map.put("bar", 2);
361     Multimap&lt;String, Integer&gt; multimapView = Multimaps.forMap(map);
362     SerializableTester.reserializeAndAssert(multimapView);
363   }
364   public void testForMapRemoveAll() {
365     Map&lt;String, Integer&gt; map = Maps.newHashMap();
366     map.put("foo", 1);
367     map.put("bar", 2);
368     map.put("cow", 3);
369     Multimap&lt;String, Integer&gt; multimap = Multimaps.forMap(map);
370     assertEquals(3, multimap.size());
371     assertEquals(Collections.emptySet(), multimap.removeAll("dog"));
372     assertEquals(3, multimap.size());
373     assertTrue(multimap.containsKey("bar"));
374     assertEquals(Collections.singleton(2), multimap.removeAll("bar"));
375     assertEquals(2, multimap.size());
376     assertFalse(multimap.containsKey("bar"));
377   }
378   public void testForMapAsMap() {
379     Map&lt;String, Integer&gt; map = Maps.newHashMap();
380     map.put("foo", 1);
381     map.put("bar", 2);
382     Map&lt;String, Collection&lt;Integer&gt;&gt; asMap = Multimaps.forMap(map).asMap();
383     assertEquals(Collections.singleton(1), asMap.get("foo"));
384     assertNull(asMap.get("cow"));
385     assertTrue(asMap.containsKey("foo"));
386     assertFalse(asMap.containsKey("cow"));
387     Set&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt; entries = asMap.entrySet();
388     assertFalse(entries.contains((Object) 4.5));
389     assertFalse(entries.remove((Object) 4.5));
390     assertFalse(entries.contains(Maps.immutableEntry("foo", Collections.singletonList(1))));
391     assertFalse(entries.remove(Maps.immutableEntry("foo", Collections.singletonList(1))));
392     assertFalse(entries.contains(Maps.immutableEntry("foo", Sets.newLinkedHashSet(asList(1, 2)))));
393     assertFalse(entries.remove(Maps.immutableEntry("foo", Sets.newLinkedHashSet(asList(1, 2)))));
394     assertFalse(entries.contains(Maps.immutableEntry("foo", Collections.singleton(2))));
395     assertFalse(entries.remove(Maps.immutableEntry("foo", Collections.singleton(2))));
396     assertTrue(map.containsKey("foo"));
397     assertTrue(entries.contains(Maps.immutableEntry("foo", Collections.singleton(1))));
398     assertTrue(entries.remove(Maps.immutableEntry("foo", Collections.singleton(1))));
399     assertFalse(map.containsKey("foo"));
400   }
401   public void testForMapGetIteration() {
402     IteratorTester&lt;Integer&gt; tester =
403         new IteratorTester&lt;Integer&gt;(
404             4, MODIFIABLE, newHashSet(1), IteratorTester.KnownOrder.KNOWN_ORDER) {
405           private Multimap&lt;String, Integer&gt; multimap;
406           @Override
407           protected Iterator&lt;Integer&gt; newTargetIterator() {
408             Map&lt;String, Integer&gt; map = Maps.newHashMap();
409             map.put("foo", 1);
410             map.put("bar", 2);
411             multimap = Multimaps.forMap(map);
412             return multimap.get("foo").iterator();
413           }
414           @Override
415           protected void verify(List&lt;Integer&gt; elements) {
416             assertEquals(newHashSet(elements), multimap.get("foo"));
417           }
418         };
419     tester.test();
420   }
421   private enum Color {
422     BLUE,
423     RED,
424     YELLOW,
425     GREEN
426   }
427   private abstract static class CountingSupplier&lt;E&gt; implements Supplier&lt;E&gt;, Serializable {
428     int count;
429     abstract E getImpl();
430     @Override
431     public E get() {
432       count++;
433       return getImpl();
434     }
435   }
436   private static class QueueSupplier extends CountingSupplier&lt;Queue&lt;Integer&gt;&gt; {
437     @Override
438     public Queue&lt;Integer&gt; getImpl() {
439       return new LinkedList&lt;&gt;();
440     }
441     private static final long serialVersionUID = 0;
442   }
443   public void testNewMultimapWithCollectionRejectingNegativeElements() {
444     CountingSupplier&lt;Set&lt;Integer&gt;&gt; factory =
445         new SetSupplier() {
446           @Override
447 <a name="2"></a>          public Set&lt;Integer&gt; getImpl() {
448             final Set&lt;Integer&gt; backing = super.getImpl();
449             return new ForwardingSet&lt;Integer&gt;() {
450               <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
451               protected Set&lt;Integer&gt; delegate() {
452                 return backing;
453               }
454               @Override
455               public boolean add(Integer element) {</b></font>
456                 checkArgument(element &gt;= 0);
457                 return super.add(element);
458               }
459               @Override
460               public boolean addAll(Collection&lt;? extends Integer&gt; collection) {
461                 return standardAddAll(collection);
462               }
463             };
464           }
465         };
466     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
467     Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
468     try {
469       multimap.put(Color.BLUE, -1);
470       fail("Expected IllegalArgumentException");
471     } catch (IllegalArgumentException expected) {
472     }
473     multimap.put(Color.RED, 1);
474     multimap.put(Color.BLUE, 2);
475     try {
476       multimap.put(Color.GREEN, -1);
477       fail("Expected IllegalArgumentException");
478     } catch (IllegalArgumentException expected) {
479     }
480     assertThat(multimap.entries())
481         .containsExactly(Maps.immutableEntry(Color.RED, 1), Maps.immutableEntry(Color.BLUE, 2));
482   }
483   public void testNewMultimap() {
484     CountingSupplier&lt;Queue&lt;Integer&gt;&gt; factory = new QueueSupplier();
485     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
486     Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
487     assertEquals(0, factory.count);
488     multimap.putAll(Color.BLUE, asList(3, 1, 4));
489     assertEquals(1, factory.count);
490     multimap.putAll(Color.RED, asList(2, 7, 1, 8));
491     assertEquals(2, factory.count);
492     assertEquals("[3, 1, 4]", multimap.get(Color.BLUE).toString());
493     Multimap&lt;Color, Integer&gt; ummodifiable = Multimaps.unmodifiableMultimap(multimap);
494     assertEquals("[3, 1, 4]", ummodifiable.get(Color.BLUE).toString());
495     Collection&lt;Integer&gt; collection = multimap.get(Color.BLUE);
496     assertTrue(collection.equals(collection));
497     assertFalse(multimap.keySet() instanceof SortedSet);
498     assertFalse(multimap.asMap() instanceof SortedMap);
499   }
500   public void testNewMultimapValueCollectionMatchesNavigableSet() {
501     Supplier&lt;TreeSet&lt;Integer&gt;&gt; factory = new SortedSetSupplier();
502     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
503     Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
504     assertTrue(multimap.get(Color.BLUE) instanceof NavigableSet);
505   }
506   public void testNewMultimapValueCollectionMatchesList() {
507     Supplier&lt;LinkedList&lt;Integer&gt;&gt; factory = new ListSupplier();
508     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
509     Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
510     assertTrue(multimap.get(Color.BLUE) instanceof List);
511   }
512   @GwtIncompatible   public void testNewMultimapSerialization() {
513     CountingSupplier&lt;Queue&lt;Integer&gt;&gt; factory = new QueueSupplier();
514     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
515     Multimap&lt;Color, Integer&gt; multimap = Multimaps.newMultimap(map, factory);
516     multimap.putAll(Color.BLUE, asList(3, 1, 4));
517     multimap.putAll(Color.RED, asList(2, 7, 1, 8));
518     SerializableTester.reserializeAndAssert(multimap);
519   }
520   private static class ListSupplier extends CountingSupplier&lt;LinkedList&lt;Integer&gt;&gt; {
521     @Override
522     public LinkedList&lt;Integer&gt; getImpl() {
523       return new LinkedList&lt;&gt;();
524     }
525     private static final long serialVersionUID = 0;
526   }
527   public void testNewListMultimap() {
528     CountingSupplier&lt;LinkedList&lt;Integer&gt;&gt; factory = new ListSupplier();
529     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newTreeMap();
530     ListMultimap&lt;Color, Integer&gt; multimap = Multimaps.newListMultimap(map, factory);
531     assertEquals(0, factory.count);
532     multimap.putAll(Color.BLUE, asList(3, 1, 4, 1));
533     assertEquals(1, factory.count);
534     multimap.putAll(Color.RED, asList(2, 7, 1, 8));
535     assertEquals(2, factory.count);
536     assertEquals("{BLUE=[3, 1, 4, 1], RED=[2, 7, 1, 8]}", multimap.toString());
537     assertFalse(multimap.get(Color.BLUE) instanceof RandomAccess);
538     assertTrue(multimap.keySet() instanceof SortedSet);
539     assertTrue(multimap.asMap() instanceof SortedMap);
540   }
541   @GwtIncompatible   public void testNewListMultimapSerialization() {
542     CountingSupplier&lt;LinkedList&lt;Integer&gt;&gt; factory = new ListSupplier();
543     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newTreeMap();
544     ListMultimap&lt;Color, Integer&gt; multimap = Multimaps.newListMultimap(map, factory);
545     multimap.putAll(Color.BLUE, asList(3, 1, 4, 1));
546     multimap.putAll(Color.RED, asList(2, 7, 1, 8));
547     SerializableTester.reserializeAndAssert(multimap);
548   }
549   private static class SetSupplier extends CountingSupplier&lt;Set&lt;Integer&gt;&gt; {
550     @Override
551     public Set&lt;Integer&gt; getImpl() {
552       return new HashSet&lt;&gt;(4);
553     }
554     private static final long serialVersionUID = 0;
555   }
556   public void testNewSetMultimap() {
557     CountingSupplier&lt;Set&lt;Integer&gt;&gt; factory = new SetSupplier();
558     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newHashMap();
559     SetMultimap&lt;Color, Integer&gt; multimap = Multimaps.newSetMultimap(map, factory);
560     assertEquals(0, factory.count);
561     multimap.putAll(Color.BLUE, asList(3, 1, 4));
562     assertEquals(1, factory.count);
563     multimap.putAll(Color.RED, asList(2, 7, 1, 8));
564     assertEquals(2, factory.count);
565     assertEquals(Sets.newHashSet(4, 3, 1), multimap.get(Color.BLUE));
566   }
567   @GwtIncompatible   public void testNewSetMultimapSerialization() {
568     CountingSupplier&lt;Set&lt;Integer&gt;&gt; factory = new SetSupplier();
569     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newHashMap();
570     SetMultimap&lt;Color, Integer&gt; multimap = Multimaps.newSetMultimap(map, factory);
571     multimap.putAll(Color.BLUE, asList(3, 1, 4));
572     multimap.putAll(Color.RED, asList(2, 7, 1, 8));
573     SerializableTester.reserializeAndAssert(multimap);
574   }
575   private static class SortedSetSupplier extends CountingSupplier&lt;TreeSet&lt;Integer&gt;&gt; {
576     @Override
577     public TreeSet&lt;Integer&gt; getImpl() {
578       return Sets.newTreeSet(INT_COMPARATOR);
579     }
580     private static final long serialVersionUID = 0;
581   }
582   public void testNewSortedSetMultimap() {
583     CountingSupplier&lt;TreeSet&lt;Integer&gt;&gt; factory = new SortedSetSupplier();
584     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
585     SortedSetMultimap&lt;Color, Integer&gt; multimap = Multimaps.newSortedSetMultimap(map, factory);
586     assertEquals(1, factory.count);
587     multimap.putAll(Color.BLUE, asList(3, 1, 4));
588     assertEquals(2, factory.count);
589     multimap.putAll(Color.RED, asList(2, 7, 1, 8));
590     assertEquals(3, factory.count);
591     assertEquals("[4, 3, 1]", multimap.get(Color.BLUE).toString());
592     assertEquals(INT_COMPARATOR, multimap.valueComparator());
593   }
594   @GwtIncompatible   public void testNewSortedSetMultimapSerialization() {
595     CountingSupplier&lt;TreeSet&lt;Integer&gt;&gt; factory = new SortedSetSupplier();
596     Map&lt;Color, Collection&lt;Integer&gt;&gt; map = Maps.newEnumMap(Color.class);
597     SortedSetMultimap&lt;Color, Integer&gt; multimap = Multimaps.newSortedSetMultimap(map, factory);
598     multimap.putAll(Color.BLUE, asList(3, 1, 4));
599     multimap.putAll(Color.RED, asList(2, 7, 1, 8));
600     SerializableTester.reserializeAndAssert(multimap);
601     assertEquals(INT_COMPARATOR, multimap.valueComparator());
602   }
603   public void testIndex() {
604     final Multimap&lt;String, Object&gt; stringToObject =
605         new ImmutableMultimap.Builder&lt;String, Object&gt;()
606             .put("1", 1)
607             .put("1", 1L)
608             .put("1", "1")
609             .put("2", 2)
610             .put("2", 2L)
611             .build();
612     ImmutableMultimap&lt;String, Object&gt; outputMap =
613         Multimaps.index(stringToObject.values(), Functions.toStringFunction());
614     assertEquals(stringToObject, outputMap);
615   }
616   public void testIndexIterator() {
617     final Multimap&lt;String, Object&gt; stringToObject =
618         new ImmutableMultimap.Builder&lt;String, Object&gt;()
619             .put("1", 1)
620             .put("1", 1L)
621             .put("1", "1")
622             .put("2", 2)
623             .put("2", 2L)
624             .build();
625     ImmutableMultimap&lt;String, Object&gt; outputMap =
626         Multimaps.index(stringToObject.values().iterator(), Functions.toStringFunction());
627     assertEquals(stringToObject, outputMap);
628   }
629   public void testIndex_ordering() {
630     final Multimap&lt;Integer, String&gt; expectedIndex =
631         new ImmutableListMultimap.Builder&lt;Integer, String&gt;()
632             .put(4, "Inky")
633             .put(6, "Blinky")
634             .put(5, "Pinky")
635             .put(5, "Pinky")
636             .put(5, "Clyde")
637             .build();
638     final List&lt;String&gt; badGuys = Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
639     final Function&lt;String, Integer&gt; stringLengthFunction =
640         new Function&lt;String, Integer&gt;() {
641           @Override
642           public Integer apply(String input) {
643             return input.length();
644           }
645         };
646     Multimap&lt;Integer, String&gt; index = Multimaps.index(badGuys, stringLengthFunction);
647     assertEquals(expectedIndex, index);
648   }
649   public void testIndex_nullValue() {
650     List&lt;Integer&gt; values = Arrays.asList(1, null);
651     try {
652       Multimaps.index(values, Functions.identity());
653       fail();
654     } catch (NullPointerException expected) {
655     }
656   }
657   public void testIndex_nullKey() {
658     List&lt;Integer&gt; values = Arrays.asList(1, 2);
659     try {
660       Multimaps.index(values, Functions.constant(null));
661       fail();
662     } catch (NullPointerException expected) {
663     }
664   }
665   @GwtIncompatible(value = "untested")
666   public void testTransformValues() {
667     SetMultimap&lt;String, Integer&gt; multimap =
668         ImmutableSetMultimap.of("a", 2, "b", -3, "b", 3, "a", 4, "c", 6);
669     Function&lt;Integer, Integer&gt; square =
670         new Function&lt;Integer, Integer&gt;() {
671           @Override
672           public Integer apply(Integer in) {
673             return in * in;
674           }
675         };
676     Multimap&lt;String, Integer&gt; transformed = Multimaps.transformValues(multimap, square);
677     assertThat(transformed.entries())
678         .containsExactly(
679             immutableEntry("a", 4),
680             immutableEntry("a", 16),
681             immutableEntry("b", 9),
682             immutableEntry("b", 9),
683             immutableEntry("c", 36))
684         .inOrder();
685   }
686   @GwtIncompatible(value = "untested")
687   public void testTransformValuesIsView() {
688     Multimap&lt;String, String&gt; multimap = LinkedListMultimap.create();
689     multimap.put("a", "a");
690     Multimap&lt;String, Integer&gt; transformed =
691         Multimaps.transformValues(
692             multimap,
693             new Function&lt;String, Integer&gt;() {
694               @Override
695               public Integer apply(String str) {
696                 return str.length();
697               }
698             });
699     Entry&lt;String, String&gt; entry = multimap.entries().iterator().next();
700     entry.setValue("bbb");
701     assertThat(transformed.entries()).containsExactly(immutableEntry("a", 3));
702   }
703   @GwtIncompatible(value = "untested")
704   public void testTransformListValues() {
705     ListMultimap&lt;String, Integer&gt; multimap =
706         ImmutableListMultimap.of("a", 2, "b", -3, "b", 3, "a", 4, "c", 6);
707     Function&lt;Integer, Integer&gt; square =
708         new Function&lt;Integer, Integer&gt;() {
709           @Override
710           public Integer apply(Integer in) {
711             return in * in;
712           }
713         };
714     ListMultimap&lt;String, Integer&gt; transformed = Multimaps.transformValues(multimap, square);
715     assertThat(transformed.entries())
716         .containsExactly(
717             immutableEntry("a", 4),
718             immutableEntry("a", 16),
719             immutableEntry("b", 9),
720             immutableEntry("b", 9),
721             immutableEntry("c", 36))
722         .inOrder();
723   }
724   @GwtIncompatible(value = "untested")
725   public void testTransformEntries() {
726     SetMultimap&lt;String, Integer&gt; multimap = ImmutableSetMultimap.of("a", 1, "a", 4, "b", -6);
727     EntryTransformer&lt;String, Integer, String&gt; transformer =
728         new EntryTransformer&lt;String, Integer, String&gt;() {
729           @Override
730           public String transformEntry(String key, Integer value) {
731             return (value &gt;= 0) ? key : "no" + key;
732           }
733         };
734     Multimap&lt;String, String&gt; transformed = Multimaps.transformEntries(multimap, transformer);
735     assertThat(transformed.entries())
736         .containsExactly(
737             immutableEntry("a", "a"), immutableEntry("a", "a"), immutableEntry("b", "nob"))
738         .inOrder();
739   }
740   @GwtIncompatible(value = "untested")
741   public void testTransformListEntries() {
742     ListMultimap&lt;String, Integer&gt; multimap =
743         ImmutableListMultimap.of("a", 1, "a", 4, "b", 6, "a", 4);
744     EntryTransformer&lt;String, Integer, String&gt; transformer =
745         new EntryTransformer&lt;String, Integer, String&gt;() {
746           @Override
747           public String transformEntry(String key, Integer value) {
748             return key + value;
749           }
750         };
751     ListMultimap&lt;String, String&gt; transformed = Multimaps.transformEntries(multimap, transformer);
752     assertEquals(ImmutableListMultimap.of("a", "a1", "a", "a4", "a", "a4", "b", "b6"), transformed);
753     assertEquals("{a=[a1, a4, a4], b=[b6]}", transformed.toString());
754   }
755   public &lt;K, V&gt; void testSynchronizedMultimapSampleCodeCompilation() {
756     K key = null;
757     Multimap&lt;K, V&gt; multimap = Multimaps.synchronizedMultimap(HashMultimap.&lt;K, V&gt;create());
758     Collection&lt;V&gt; values = multimap.get(key);     synchronized (multimap) {       Iterator&lt;V&gt; i = values.iterator();       while (i.hasNext()) {
759         foo(i.next());
760       }
761     }
762   }
763   private static void foo(Object o) {}
764   public void testFilteredKeysSetMultimapReplaceValues() {
765     SetMultimap&lt;String, Integer&gt; multimap = LinkedHashMultimap.create();
766     multimap.put("foo", 1);
767     multimap.put("bar", 2);
768     multimap.put("baz", 3);
769     multimap.put("bar", 4);
770     SetMultimap&lt;String, Integer&gt; filtered =
771         Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of("foo", "bar")));
772     assertEquals(ImmutableSet.of(), filtered.replaceValues("baz", ImmutableSet.&lt;Integer&gt;of()));
773     try {
774       filtered.replaceValues("baz", ImmutableSet.of(5));
775       fail("Expected IllegalArgumentException");
776     } catch (IllegalArgumentException expected) {
777     }
778   }
779   public void testFilteredKeysSetMultimapGetBadValue() {
780     SetMultimap&lt;String, Integer&gt; multimap = LinkedHashMultimap.create();
781     multimap.put("foo", 1);
782     multimap.put("bar", 2);
783     multimap.put("baz", 3);
784     multimap.put("bar", 4);
785     SetMultimap&lt;String, Integer&gt; filtered =
786         Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of("foo", "bar")));
787     Set&lt;Integer&gt; bazSet = filtered.get("baz");
788     assertThat(bazSet).isEmpty();
789     try {
790       bazSet.add(5);
791       fail("Expected IllegalArgumentException");
792     } catch (IllegalArgumentException expected) {
793     }
794     try {
795       bazSet.addAll(ImmutableSet.of(6, 7));
796       fail("Expected IllegalArgumentException");
797     } catch (IllegalArgumentException expected) {
798     }
799   }
800   public void testFilteredKeysListMultimapGetBadValue() {
801     ListMultimap&lt;String, Integer&gt; multimap = ArrayListMultimap.create();
802     multimap.put("foo", 1);
803     multimap.put("bar", 2);
804     multimap.put("baz", 3);
805     multimap.put("bar", 4);
806     ListMultimap&lt;String, Integer&gt; filtered =
807         Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of("foo", "bar")));
808     List&lt;Integer&gt; bazList = filtered.get("baz");
809     assertThat(bazList).isEmpty();
810     try {
811       bazList.add(5);
812       fail("Expected IllegalArgumentException");
813     } catch (IllegalArgumentException expected) {
814     }
815     try {
816       bazList.add(0, 6);
817       fail("Expected IllegalArgumentException");
818     } catch (IllegalArgumentException expected) {
819     }
820     try {
821       bazList.addAll(ImmutableList.of(7, 8));
822       fail("Expected IllegalArgumentException");
823     } catch (IllegalArgumentException expected) {
824     }
825     try {
826       bazList.addAll(0, ImmutableList.of(9, 10));
827       fail("Expected IllegalArgumentException");
828     } catch (IllegalArgumentException expected) {
829     }
830   }
831   @GwtIncompatible   public void testNullPointers() {
832     new NullPointerTester().testAllPublicStaticMethods(Multimaps.class);
833   }
834 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
