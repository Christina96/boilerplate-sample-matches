<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for DDLClusterStateHelpers.java &amp; Coordinator.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for DDLClusterStateHelpers.java &amp; Coordinator.java
      </h3>
<h1 align="center">
        3.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>DDLClusterStateHelpers.java (25.520834%)<th>Coordinator.java (2.0666385%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-51)<td><a href="#" name="0">(20-48)</a><td align="center"><font color="#ff0000">28</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(63-75)<td><a href="#" name="1">(847-857)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(116-120)<td><a href="#" name="2">(317-320)</a><td align="center"><font color="#510000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DDLClusterStateHelpers.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.metadata.cluster;
2 import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
3 import io.crate.Constants;
4 import io.crate.common.annotations.VisibleForTesting;
5 import io.crate.common.collections.MapBuilder;
6 import io.crate.metadata.PartitionName;
7 import io.crate.metadata.RelationName;
8 import org.elasticsearch.ElasticsearchException;
9 import org.elasticsearch.cluster.metadata.IndexMetadata;
10 import org.elasticsearch.cluster.metadata.IndexTemplateMetadata;
11 import org.elasticsearch.cluster.metadata.Metadata;
12 import org.elasticsearch.common.Strings;
13 import org.elasticsearch.common.compress.CompressedXContent;
14 import org.elasticsearch.common.settings.Settings;
15 import org.elasticsearch.common.xcontent.DeprecationHandler;
16 import org.elasticsearch.common.xcontent.NamedXContentRegistry;
17 import org.elasticsearch.common.xcontent.XContentFactory;
18 import org.elasticsearch.common.xcontent.XContentHelper;
19 import org.elasticsearch.common.xcontent.XContentParser;
20 import org.elasticsearch.common.xcontent.json.JsonXContent;
21 import javax.annotation.Nullable;
22 import java.io.IOException;
23 import java.util.HashMap;
24 import java.util.HashSet;
25 import java.util.Map;
26 import java.util.Set;
27 import java.util.function.BiConsumer;
28 import</b></font> java.util.function.Predicate;
29 public class DDLClusterStateHelpers {
30     public static IndexTemplateMetadata updateTemplate(IndexTemplateMetadata indexTemplateMetadata,
31                                                        Map&lt;String, Object&gt; newMappings,
32                                                        Map&lt;String, Object&gt; mappingsToRemove,
33                                                        Settings newSettings,
34                                                        BiConsumer&lt;String, Settings&gt; settingsValidator,
35 <a name="1"></a>                                                       Predicate&lt;String&gt; settingsFilter) {
36         Map&lt;String, Object&gt; mapping = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>removeFromMapping(
37             mergeTemplateMapping(indexTemplateMetadata, newMappings),
38             mappingsToRemove);
39         final Settings settings = Settings.builder()
40             .put(indexTemplateMetadata.settings())
41             .put(newSettings)
42             .normalizePrefix(IndexMetadata.INDEX_SETTING_PREFIX)
43             .build().filter(settingsFilter);
44         settingsValidator.accept(indexTemplateMetadata.getName</b></font>(), settings);
45         if (mapping.size() != 1 || mapping.containsKey(Constants.DEFAULT_MAPPING_TYPE) == false) {
46             mapping = MapBuilder.&lt;String, Object&gt;newMapBuilder().put(Constants.DEFAULT_MAPPING_TYPE, mapping).map();
47         }
48         try {
49             return new IndexTemplateMetadata.Builder(indexTemplateMetadata)
50                 .settings(settings)
51                 .putMapping(Constants.DEFAULT_MAPPING_TYPE, Strings.toString(XContentFactory.jsonBuilder().map(mapping)))
52                 .build();
53         } catch (IOException e) {
54             throw new RuntimeException(e);
55         }
56     }
57     static Set&lt;IndexMetadata&gt; indexMetadataSetFromIndexNames(Metadata metadata,
58                                                              String[] indices,
59                                                              IndexMetadata.State state) {
60         Set&lt;IndexMetadata&gt; indicesMetadata = new HashSet&lt;&gt;();
61         for (String indexName : indices) {
62             IndexMetadata indexMetadata = metadata.index(indexName);
63             if (indexMetadata != null &amp;&amp; indexMetadata.getState() != state) {
64                 indicesMetadata.add(indexMetadata);
65             }
66         }
67         return indicesMetadata;
68     }
69     @Nullable
70     static IndexTemplateMetadata templateMetadata(Metadata metadata, RelationName relationName) {
71         String templateName = PartitionName.templateName(relationName.schema(), relationName.name());
72         return metadata.templates().get(templateName);
73     }
74     private static Map&lt;String, Object&gt; removeFromMapping(Map&lt;String, Object&gt; mapping,
75                                                          Map&lt;String, Object&gt; mappingsToRemove) {
76         for (String key : mappingsToRemove.keySet()) {
77 <a name="2"></a>            if (mapping.containsKey(key)) {
78                 if (mapping.get(key) instanceof Map) {
79                     //noinspection unchecked
80                     mapping.put(key, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>removeFromMapping((Map&lt;String, Object&gt;) mapping.get(key),
81                         (Map&lt;String, Object&gt;) mappingsToRemove.get(key)));
82                 } else {
83                     mapping.remove(key);
84                 }</b></font>
85             }
86         }
87         return mapping;
88     }
89     @VisibleForTesting
90     static Map&lt;String, Object&gt; mergeTemplateMapping(IndexTemplateMetadata templateMetadata,
91                                                     Map&lt;String, Object&gt; newMapping) {
92         Map&lt;String, Object&gt; mergedMapping = new HashMap&lt;&gt;();
93         for (ObjectObjectCursor&lt;String, CompressedXContent&gt; cursor : templateMetadata.mappings()) {
94             Map&lt;String, Object&gt; mapping = parseMapping(cursor.value.toString());
95             Object o = mapping.get(Constants.DEFAULT_MAPPING_TYPE);
96             assert o instanceof Map :
97                 "o must not be null and must be instance of Map";
98             //noinspection unchecked
99             XContentHelper.update(mergedMapping, (Map) o, false);
100         }
101         XContentHelper.update(mergedMapping, newMapping, false);
102         return mergedMapping;
103     }
104     private static Map&lt;String, Object&gt; parseMapping(String mappingSource) {
105         try (XContentParser parser = JsonXContent.JSON_XCONTENT
106             .createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, mappingSource)) {
107             return parser.map();
108         } catch (IOException e) {
109             throw new ElasticsearchException("failed to parse mapping");
110         }
111     }
112 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Coordinator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.cluster.coordination;
2 import org.apache.logging.log4j.Level;
3 import org.apache.logging.log4j.LogManager;
4 import org.apache.logging.log4j.Logger;
5 import org.apache.logging.log4j.message.ParameterizedMessage;
6 import org.apache.lucene.util.SetOnce;
7 import org.elasticsearch.action.ActionListener;
8 import org.elasticsearch.cluster.ClusterChangedEvent;
9 import org.elasticsearch.cluster.ClusterName;
10 import org.elasticsearch.cluster.ClusterState;
11 import org.elasticsearch.cluster.ClusterStateTaskConfig;
12 import org.elasticsearch.cluster.ClusterStateUpdateTask;
13 import org.elasticsearch.cluster.LocalClusterUpdateTask;
14 import org.elasticsearch.cluster.block.ClusterBlocks;
15 import org.elasticsearch.cluster.coordination.ClusterFormationFailureHelper.ClusterFormationState;
16 import org.elasticsearch.cluster.coordination.CoordinationMetadata.VotingConfigExclusion;
17 import org.elasticsearch.cluster.coordination.CoordinationMetadata.VotingConfiguration;
18 import org.elasticsearch.cluster.coordination.FollowersChecker.FollowerCheckRequest;
19 import org.elasticsearch.cluster.coordination.JoinHelper.InitialJoinAccumulator;
20 import org.elasticsearch.cluster.metadata.Metadata;
21 import org.elasticsearch.cluster.node.DiscoveryNode;
22 import org.elasticsearch.cluster.node.DiscoveryNodes;
23 import org.elasticsearch.cluster.routing.RerouteService;
24 import org.elasticsearch.cluster.routing.allocation.AllocationService;
25 import org.elasticsearch.cluster.service.ClusterApplier;
26 import org.elasticsearch.cluster.service.ClusterApplier.ClusterApplyListener;
27 import org.elasticsearch.cluster.service.MasterService;
28 import</b></font> javax.annotation.Nullable;
29 import org.elasticsearch.common.Priority;
30 import org.elasticsearch.common.Strings;
31 import org.elasticsearch.common.component.AbstractLifecycleComponent;
32 import org.elasticsearch.common.io.stream.NamedWriteableRegistry;
33 import org.elasticsearch.common.lease.Releasable;
34 import org.elasticsearch.common.settings.ClusterSettings;
35 import org.elasticsearch.common.settings.Setting;
36 import org.elasticsearch.common.settings.Settings;
37 import org.elasticsearch.common.transport.TransportAddress;
38 import io.crate.common.unit.TimeValue;
39 import org.elasticsearch.common.util.concurrent.EsExecutors;
40 import org.elasticsearch.common.util.concurrent.ListenableFuture;
41 import org.elasticsearch.common.xcontent.XContentHelper;
42 import org.elasticsearch.common.xcontent.json.JsonXContent;
43 import org.elasticsearch.discovery.Discovery;
44 import org.elasticsearch.discovery.DiscoveryModule;
45 import org.elasticsearch.discovery.DiscoveryStats;
46 import org.elasticsearch.discovery.HandshakingTransportAddressConnector;
47 import org.elasticsearch.discovery.PeerFinder;
48 import org.elasticsearch.discovery.SeedHostsProvider;
49 import org.elasticsearch.discovery.SeedHostsResolver;
50 import org.elasticsearch.threadpool.Scheduler;
51 import org.elasticsearch.threadpool.ThreadPool.Names;
52 import org.elasticsearch.transport.TransportResponse.Empty;
53 import org.elasticsearch.transport.TransportService;
54 import java.io.IOException;
55 import java.util.ArrayList;
56 import java.util.Collection;
57 import java.util.Collections;
58 import java.util.HashSet;
59 import java.util.List;
60 import java.util.Optional;
61 import java.util.Random;
62 import java.util.Set;
63 import java.util.concurrent.atomic.AtomicBoolean;
64 import java.util.function.BiConsumer;
65 import java.util.function.Supplier;
66 import java.util.stream.Collectors;
67 import java.util.stream.Stream;
68 import java.util.stream.StreamSupport;
69 import static org.elasticsearch.cluster.coordination.NoMasterBlockService.NO_MASTER_BLOCK_ID;
70 import static org.elasticsearch.gateway.ClusterStateUpdaters.hideStateIfNotRecovered;
71 import static org.elasticsearch.gateway.GatewayService.STATE_NOT_RECOVERED_BLOCK;
72 public class Coordinator extends AbstractLifecycleComponent implements Discovery {
73     private static final Logger LOGGER = LogManager.getLogger(Coordinator.class);
74     public static final Setting&lt;TimeValue&gt; PUBLISH_INFO_TIMEOUT_SETTING =
75         Setting.timeSetting("cluster.publish.info_timeout",
76             TimeValue.timeValueMillis(10000), TimeValue.timeValueMillis(1), Setting.Property.NodeScope);
77     public static final Setting&lt;TimeValue&gt; PUBLISH_TIMEOUT_SETTING =
78         Setting.timeSetting("cluster.publish.timeout",
79             TimeValue.timeValueMillis(30000), TimeValue.timeValueMillis(1), Setting.Property.NodeScope);
80     private final Settings settings;
81     private final boolean singleNodeDiscovery;
82     private final TransportService transportService;
83     private final MasterService masterService;
84     private final AllocationService allocationService;
85     private final JoinHelper joinHelper;
86     private final NodeRemovalClusterStateTaskExecutor nodeRemovalExecutor;
87     private final Supplier&lt;CoordinationState.PersistedState&gt; persistedStateSupplier;
88     private final NoMasterBlockService noMasterBlockService;
89     final Object mutex = new Object();
90     private final SetOnce&lt;CoordinationState&gt; coordinationState = new SetOnce&lt;&gt;();     private volatile ClusterState applierState; 
91     private final PeerFinder peerFinder;
92     private final PreVoteCollector preVoteCollector;
93     private final Random random;
94     private final ElectionSchedulerFactory electionSchedulerFactory;
95     private final SeedHostsResolver configuredHostsResolver;
96     private final TimeValue publishTimeout;
97     private final TimeValue publishInfoTimeout;
98     private final PublicationTransportHandler publicationHandler;
99     private final LeaderChecker leaderChecker;
100     private final FollowersChecker followersChecker;
101     private final ClusterApplier clusterApplier;
102     private final Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; onJoinValidators;
103     @Nullable
104     private Releasable electionScheduler;
105     @Nullable
106     private Releasable prevotingRound;
107     private long maxTermSeen;
108     private final Reconfigurator reconfigurator;
109     private final ClusterBootstrapService clusterBootstrapService;
110     private final LagDetector lagDetector;
111     private final ClusterFormationFailureHelper clusterFormationFailureHelper;
112     private Mode mode;
113     private Optional&lt;DiscoveryNode&gt; lastKnownLeader;
114     private Optional&lt;Join&gt; lastJoin;
115     private JoinHelper.JoinAccumulator joinAccumulator;
116     private Optional&lt;CoordinatorPublication&gt; currentPublication = Optional.empty();
117     public Coordinator(String nodeName, Settings settings, ClusterSettings clusterSettings, TransportService transportService,
118                        NamedWriteableRegistry namedWriteableRegistry, AllocationService allocationService, MasterService masterService,
119                        Supplier&lt;CoordinationState.PersistedState&gt; persistedStateSupplier, SeedHostsProvider seedHostsProvider,
120                        ClusterApplier clusterApplier, Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; onJoinValidators, Random random,
121                        RerouteService rerouteService) {
122         this.settings = settings;
123         this.transportService = transportService;
124         this.masterService = masterService;
125         this.allocationService = allocationService;
126         this.onJoinValidators = JoinTaskExecutor.addBuiltInJoinValidators(onJoinValidators);
127         this.singleNodeDiscovery = DiscoveryModule.SINGLE_NODE_DISCOVERY_TYPE.equals(DiscoveryModule.DISCOVERY_TYPE_SETTING.get(settings));
128         this.joinHelper = new JoinHelper(settings, allocationService, masterService, transportService,
129             this::getCurrentTerm, this::getStateForMasterService, this::handleJoinRequest, this::joinLeaderInTerm, this.onJoinValidators,
130             rerouteService);
131         this.persistedStateSupplier = persistedStateSupplier;
132         this.noMasterBlockService = new NoMasterBlockService(settings, clusterSettings);
133         this.lastKnownLeader = Optional.empty();
134         this.lastJoin = Optional.empty();
135         this.joinAccumulator = new InitialJoinAccumulator();
136         this.publishTimeout = PUBLISH_TIMEOUT_SETTING.get(settings);
137         this.publishInfoTimeout = PUBLISH_INFO_TIMEOUT_SETTING.get(settings);
138         this.random = random;
139         this.electionSchedulerFactory = new ElectionSchedulerFactory(settings, random, transportService.getThreadPool());
140         this.preVoteCollector = new PreVoteCollector(transportService, this::startElection, this::updateMaxTermSeen);
141         configuredHostsResolver = new SeedHostsResolver(nodeName, settings, transportService, seedHostsProvider);
142         this.peerFinder = new CoordinatorPeerFinder(settings, transportService,
143             new HandshakingTransportAddressConnector(settings, transportService), configuredHostsResolver);
144         this.publicationHandler = new PublicationTransportHandler(transportService, namedWriteableRegistry,
145             this::handlePublishRequest, this::handleApplyCommit);
146         this.leaderChecker = new LeaderChecker(settings, transportService, this::onLeaderFailure);
147         this.followersChecker = new FollowersChecker(settings, transportService, this::onFollowerCheckRequest, this::removeNode);
148         this.nodeRemovalExecutor = new NodeRemovalClusterStateTaskExecutor(allocationService, LOGGER);
149         this.clusterApplier = clusterApplier;
150         masterService.setClusterStateSupplier(this::getStateForMasterService);
151         this.reconfigurator = new Reconfigurator(settings, clusterSettings);
152         this.clusterBootstrapService = new ClusterBootstrapService(settings, transportService, this::getFoundPeers,
153             this::isInitialConfigurationSet, this::setInitialConfiguration);
154         this.lagDetector = new LagDetector(settings, transportService.getThreadPool(), n -&gt; removeNode(n, "lagging"),
155             transportService::getLocalNode);
156         this.clusterFormationFailureHelper = new ClusterFormationFailureHelper(settings, this::getClusterFormationState,
157             transportService.getThreadPool(), joinHelper::logLastFailedJoinAttempt);
158     }
159     private ClusterFormationState getClusterFormationState() {
160         return new ClusterFormationState(settings, getStateForMasterService(), peerFinder.getLastResolvedAddresses(),
161             Stream.concat(Stream.of(getLocalNode()), StreamSupport.stream(peerFinder.getFoundPeers().spliterator(), false))
162                 .collect(Collectors.toList()), getCurrentTerm());
163     }
164     private void onLeaderFailure(Exception e) {
165         synchronized (mutex) {
166             if (mode != Mode.CANDIDATE) {
167                 assert lastKnownLeader.isPresent();
168                 LOGGER.info(new ParameterizedMessage("master node [{}] failed, restarting discovery", lastKnownLeader.get()), e);
169             }
170             becomeCandidate("onLeaderFailure");
171         }
172     }
173     private void removeNode(DiscoveryNode discoveryNode, String reason) {
174         synchronized (mutex) {
175             if (mode == Mode.LEADER) {
176                 masterService.submitStateUpdateTask("node-left",
177                     new NodeRemovalClusterStateTaskExecutor.Task(discoveryNode, reason),
178                     ClusterStateTaskConfig.build(Priority.IMMEDIATE),
179                     nodeRemovalExecutor,
180                     nodeRemovalExecutor);
181             }
182         }
183     }
184     void onFollowerCheckRequest(FollowerCheckRequest followerCheckRequest) {
185         synchronized (mutex) {
186             ensureTermAtLeast(followerCheckRequest.getSender(), followerCheckRequest.getTerm());
187             if (getCurrentTerm() != followerCheckRequest.getTerm()) {
188                 LOGGER.trace("onFollowerCheckRequest: current term is [{}], rejecting {}", getCurrentTerm(), followerCheckRequest);
189                 throw new CoordinationStateRejectedException("onFollowerCheckRequest: current term is ["
190                     + getCurrentTerm() + "], rejecting " + followerCheckRequest);
191             }
192             if (getLastAcceptedState().term() &lt; getCurrentTerm()) {
193                 becomeFollower("onFollowerCheckRequest", followerCheckRequest.getSender());
194             } else if (mode == Mode.FOLLOWER) {
195                 LOGGER.trace("onFollowerCheckRequest: responding successfully to {}", followerCheckRequest);
196             } else if (joinHelper.isJoinPending()) {
197                 LOGGER.trace("onFollowerCheckRequest: rejoining master, responding successfully to {}", followerCheckRequest);
198             } else {
199                 LOGGER.trace("onFollowerCheckRequest: received check from faulty master, rejecting {}", followerCheckRequest);
200                 throw new CoordinationStateRejectedException(
201                     "onFollowerCheckRequest: received check from faulty master, rejecting " + followerCheckRequest);
202             }
203         }
204     }
205     private void handleApplyCommit(ApplyCommitRequest applyCommitRequest, ActionListener&lt;Void&gt; applyListener) {
206         synchronized (mutex) {
207             LOGGER.trace("handleApplyCommit: applying commit {}", applyCommitRequest);
208             coordinationState.get().handleCommit(applyCommitRequest);
209             final ClusterState committedState = hideStateIfNotRecovered(coordinationState.get().getLastAcceptedState());
210             applierState = mode == Mode.CANDIDATE ? clusterStateWithNoMasterBlock(committedState) : committedState;
211             if (applyCommitRequest.getSourceNode().equals(getLocalNode())) {
212                 applyListener.onResponse(null);
213             } else {
214                 clusterApplier.onNewClusterState(applyCommitRequest.toString(), () -&gt; applierState,
215                     new ClusterApplyListener() {
216                         @Override
217                         public void onFailure(String source, Exception e) {
218                             applyListener.onFailure(e);
219                         }
220                         @Override
221                         public void onSuccess(String source) {
222                             applyListener.onResponse(null);
223                         }
224                     });
225             }
226         }
227     }
228     PublishWithJoinResponse handlePublishRequest(PublishRequest publishRequest) {
229         assert publishRequest.getAcceptedState().nodes().getLocalNode().equals(getLocalNode()) :
230             publishRequest.getAcceptedState().nodes().getLocalNode() + " != " + getLocalNode();
231         synchronized (mutex) {
232             final DiscoveryNode sourceNode = publishRequest.getAcceptedState().nodes().getMasterNode();
233             LOGGER.trace("handlePublishRequest: handling [{}] from [{}]", publishRequest, sourceNode);
234             if (sourceNode.equals(getLocalNode()) &amp;&amp; mode != Mode.LEADER) {
235                 throw new CoordinationStateRejectedException("no longer leading this publication's term: " + publishRequest);
236             }
237             final ClusterState localState = coordinationState.get().getLastAcceptedState();
238             if (localState.metadata().clusterUUIDCommitted() &amp;&amp;
239                 localState.metadata().clusterUUID().equals(publishRequest.getAcceptedState().metadata().clusterUUID()) == false) {
240                 LOGGER.warn("received cluster state from {} with a different cluster uuid {} than local cluster uuid {}, rejecting",
241                     sourceNode, publishRequest.getAcceptedState().metadata().clusterUUID(), localState.metadata().clusterUUID());
242                 throw new CoordinationStateRejectedException("received cluster state from " + sourceNode +
243                     " with a different cluster uuid " + publishRequest.getAcceptedState().metadata().clusterUUID() +
244                     " than local cluster uuid " + localState.metadata().clusterUUID() + ", rejecting");
245             }
246             if (publishRequest.getAcceptedState().term() &gt; localState.term()) {
247                 onJoinValidators.forEach(a -&gt; a.accept(getLocalNode(), publishRequest.getAcceptedState()));
248             }
249             ensureTermAtLeast(sourceNode, publishRequest.getAcceptedState().term());
250 <a name="2"></a>            final PublishResponse publishResponse = coordinationState.get().handlePublishRequest(publishRequest);
251             if (sourceNode.equals(getLocalNode())) {
252                 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>preVoteCollector.update(getPreVoteResponse(), getLocalNode());
253             } else {
254                 becomeFollower("handlePublishRequest", sourceNode);             }</b></font>
255             return new PublishWithJoinResponse(publishResponse,
256                 joinWithDestination(lastJoin, sourceNode, publishRequest.getAcceptedState().term()));
257         }
258     }
259     private static Optional&lt;Join&gt; joinWithDestination(Optional&lt;Join&gt; lastJoin, DiscoveryNode leader, long term) {
260         if (lastJoin.isPresent()
261             &amp;&amp; lastJoin.get().targetMatches(leader)
262             &amp;&amp; lastJoin.get().getTerm() == term) {
263             return lastJoin;
264         }
265         return Optional.empty();
266     }
267     private void closePrevotingAndElectionScheduler() {
268         if (prevotingRound != null) {
269             prevotingRound.close();
270             prevotingRound = null;
271         }
272         if (electionScheduler != null) {
273             electionScheduler.close();
274             electionScheduler = null;
275         }
276     }
277     private void updateMaxTermSeen(final long term) {
278         synchronized (mutex) {
279             maxTermSeen = Math.max(maxTermSeen, term);
280             final long currentTerm = getCurrentTerm();
281             if (mode == Mode.LEADER &amp;&amp; maxTermSeen &gt; currentTerm) {
282                 if (publicationInProgress()) {
283                     LOGGER.debug("updateMaxTermSeen: maxTermSeen = {} &gt; currentTerm = {}, enqueueing term bump", maxTermSeen, currentTerm);
284                 } else {
285                     try {
286                         LOGGER.debug("updateMaxTermSeen: maxTermSeen = {} &gt; currentTerm = {}, bumping term", maxTermSeen, currentTerm);
287                         ensureTermAtLeast(getLocalNode(), maxTermSeen);
288                         startElection();
289                     } catch (Exception e) {
290                         LOGGER.warn(new ParameterizedMessage("failed to bump term to {}", maxTermSeen), e);
291                         becomeCandidate("updateMaxTermSeen");
292                     }
293                 }
294             }
295         }
296     }
297     private void startElection() {
298         synchronized (mutex) {
299             if (mode == Mode.CANDIDATE) {
300                 if (localNodeMayWinElection(getLastAcceptedState()) == false) {
301                     LOGGER.trace("skip election as local node may not win it: {}", getLastAcceptedState().coordinationMetadata());
302                     return;
303                 }
304                 final StartJoinRequest startJoinRequest
305                     = new StartJoinRequest(getLocalNode(), Math.max(getCurrentTerm(), maxTermSeen) + 1);
306                 LOGGER.debug("starting election with {}", startJoinRequest);
307                 getDiscoveredNodes().forEach(node -&gt; joinHelper.sendStartJoinRequest(startJoinRequest, node));
308             }
309         }
310     }
311     private void abdicateTo(DiscoveryNode newMaster) {
312         assert Thread.holdsLock(mutex);
313         assert mode == Mode.LEADER : "expected to be leader on abdication but was " + mode;
314         assert newMaster.isMasterEligibleNode() : "should only abdicate to master-eligible node but was " + newMaster;
315         final StartJoinRequest startJoinRequest = new StartJoinRequest(newMaster, Math.max(getCurrentTerm(), maxTermSeen) + 1);
316         LOGGER.info("abdicating to {} with term {}", newMaster, startJoinRequest.getTerm());
317         getLastAcceptedState().nodes().mastersFirstStream().forEach(node -&gt; joinHelper.sendStartJoinRequest(startJoinRequest, node));
318         assert mode == Mode.LEADER : "should still be leader after sending abdication messages " + mode;
319         becomeCandidate("after abdicating to " + newMaster);
320     }
321     private static boolean localNodeMayWinElection(ClusterState lastAcceptedState) {
322         final DiscoveryNode localNode = lastAcceptedState.nodes().getLocalNode();
323         assert localNode != null;
324         return nodeMayWinElection(lastAcceptedState, localNode);
325     }
326     private static boolean nodeMayWinElection(ClusterState lastAcceptedState, DiscoveryNode node) {
327         final String nodeId = node.getId();
328         return lastAcceptedState.getLastCommittedConfiguration().getNodeIds().contains(nodeId)
329             || lastAcceptedState.getLastAcceptedConfiguration().getNodeIds().contains(nodeId)
330             || lastAcceptedState.getVotingConfigExclusions().stream().noneMatch(vce -&gt; vce.getNodeId().equals(nodeId));
331     }
332     private Optional&lt;Join&gt; ensureTermAtLeast(DiscoveryNode sourceNode, long targetTerm) {
333         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
334         if (getCurrentTerm() &lt; targetTerm) {
335             return Optional.of(joinLeaderInTerm(new StartJoinRequest(sourceNode, targetTerm)));
336         }
337         return Optional.empty();
338     }
339     private Join joinLeaderInTerm(StartJoinRequest startJoinRequest) {
340         synchronized (mutex) {
341             LOGGER.debug("joinLeaderInTerm: for [{}] with term {}", startJoinRequest.getSourceNode(), startJoinRequest.getTerm());
342             final Join join = coordinationState.get().handleStartJoin(startJoinRequest);
343             lastJoin = Optional.of(join);
344             peerFinder.setCurrentTerm(getCurrentTerm());
345             if (mode != Mode.CANDIDATE) {
346                 becomeCandidate("joinLeaderInTerm");             } else {
347                 followersChecker.updateFastResponseState(getCurrentTerm(), mode);
348                 preVoteCollector.update(getPreVoteResponse(), null);
349             }
350             return join;
351         }
352     }
353     private void handleJoinRequest(JoinRequest joinRequest, JoinHelper.JoinCallback joinCallback) {
354         assert Thread.holdsLock(mutex) == false;
355         assert getLocalNode().isMasterEligibleNode() : getLocalNode() + " received a join but is not master-eligible";
356         LOGGER.trace("handleJoinRequest: as {}, handling {}", mode, joinRequest);
357         if (singleNodeDiscovery &amp;&amp; joinRequest.getSourceNode().equals(getLocalNode()) == false) {
358             joinCallback.onFailure(new IllegalStateException("cannot join node with [" + DiscoveryModule.DISCOVERY_TYPE_SETTING.getKey() +
359                 "] set to [" + DiscoveryModule.SINGLE_NODE_DISCOVERY_TYPE + "] discovery"));
360             return;
361         }
362         transportService.connectToNode(joinRequest.getSourceNode(), ActionListener.wrap(ignore -&gt; {
363             final ClusterState stateForJoinValidation = getStateForMasterService();
364             if (stateForJoinValidation.nodes().isLocalNodeElectedMaster()) {
365                 onJoinValidators.forEach(a -&gt; a.accept(joinRequest.getSourceNode(), stateForJoinValidation));
366                 if (stateForJoinValidation.getBlocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK) == false) {
367                     JoinTaskExecutor.ensureMajorVersionBarrier(joinRequest.getSourceNode().getVersion(),
368                         stateForJoinValidation.getNodes().getMinNodeVersion());
369                 }
370                 sendValidateJoinRequest(stateForJoinValidation, joinRequest, joinCallback);
371             } else {
372                 processJoinRequest(joinRequest, joinCallback);
373             }
374         }, joinCallback::onFailure));
375     }
376     void sendValidateJoinRequest(ClusterState stateForJoinValidation, JoinRequest joinRequest,
377                                  JoinHelper.JoinCallback joinCallback) {
378         joinHelper.sendValidateJoinRequest(joinRequest.getSourceNode(), stateForJoinValidation, new ActionListener&lt;Empty&gt;() {
379             @Override
380             public void onResponse(Empty empty) {
381                 try {
382                     processJoinRequest(joinRequest, joinCallback);
383                 } catch (Exception e) {
384                     joinCallback.onFailure(e);
385                 }
386             }
387             @Override
388             public void onFailure(Exception e) {
389                 LOGGER.warn(() -&gt; new ParameterizedMessage("failed to validate incoming join request from node [{}]",
390                     joinRequest.getSourceNode()), e);
391                 joinCallback.onFailure(new IllegalStateException("failure when sending a validation request to node", e));
392             }
393         });
394     }
395     private void processJoinRequest(JoinRequest joinRequest, JoinHelper.JoinCallback joinCallback) {
396         final Optional&lt;Join&gt; optionalJoin = joinRequest.getOptionalJoin();
397         synchronized (mutex) {
398             final CoordinationState coordState = coordinationState.get();
399             final boolean prevElectionWon = coordState.electionWon();
400             optionalJoin.ifPresent(this::handleJoin);
401             joinAccumulator.handleJoinRequest(joinRequest.getSourceNode(), joinCallback);
402             if (prevElectionWon == false &amp;&amp; coordState.electionWon()) {
403                 becomeLeader("handleJoinRequest");
404             }
405         }
406     }
407     void becomeCandidate(String method) {
408         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
409         LOGGER.debug("{}: coordinator becoming CANDIDATE in term {} (was {}, lastKnownLeader was [{}])",
410             method, getCurrentTerm(), mode, lastKnownLeader);
411         if (mode != Mode.CANDIDATE) {
412             final Mode prevMode = mode;
413             mode = Mode.CANDIDATE;
414             cancelActivePublication("become candidate: " + method);
415             joinAccumulator.close(mode);
416             joinAccumulator = joinHelper.new CandidateJoinAccumulator();
417             peerFinder.activate(coordinationState.get().getLastAcceptedState().nodes());
418             clusterFormationFailureHelper.start();
419             leaderChecker.setCurrentNodes(DiscoveryNodes.EMPTY_NODES);
420             leaderChecker.updateLeader(null);
421             followersChecker.clearCurrentNodes();
422             followersChecker.updateFastResponseState(getCurrentTerm(), mode);
423             lagDetector.clearTrackedNodes();
424             if (prevMode == Mode.LEADER) {
425                 cleanMasterService();
426             }
427             if (applierState.nodes().getMasterNodeId() != null) {
428                 applierState = clusterStateWithNoMasterBlock(applierState);
429                 clusterApplier.onNewClusterState("becoming candidate: " + method, () -&gt; applierState, (source, e) -&gt; {
430                 });
431             }
432         }
433         preVoteCollector.update(getPreVoteResponse(), null);
434     }
435     void becomeLeader(String method) {
436         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
437         assert mode == Mode.CANDIDATE : "expected candidate but was " + mode;
438         assert getLocalNode().isMasterEligibleNode() : getLocalNode() + " became a leader but is not master-eligible";
439         LOGGER.debug("{}: coordinator becoming LEADER in term {} (was {}, lastKnownLeader was [{}])",
440             method, getCurrentTerm(), mode, lastKnownLeader);
441         mode = Mode.LEADER;
442         joinAccumulator.close(mode);
443         joinAccumulator = joinHelper.new LeaderJoinAccumulator();
444         lastKnownLeader = Optional.of(getLocalNode());
445         peerFinder.deactivate(getLocalNode());
446         clusterFormationFailureHelper.stop();
447         closePrevotingAndElectionScheduler();
448         preVoteCollector.update(getPreVoteResponse(), getLocalNode());
449         assert leaderChecker.leader() == null : leaderChecker.leader();
450         followersChecker.updateFastResponseState(getCurrentTerm(), mode);
451     }
452     void becomeFollower(String method, DiscoveryNode leaderNode) {
453         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
454         assert leaderNode.isMasterEligibleNode() : leaderNode + " became a leader but is not master-eligible";
455         assert mode != Mode.LEADER : "do not switch to follower from leader (should be candidate first)";
456         if (mode == Mode.FOLLOWER &amp;&amp; Optional.of(leaderNode).equals(lastKnownLeader)) {
457             LOGGER.trace("{}: coordinator remaining FOLLOWER of [{}] in term {}",
458                 method, leaderNode, getCurrentTerm());
459         } else {
460             LOGGER.debug("{}: coordinator becoming FOLLOWER of [{}] in term {} (was {}, lastKnownLeader was [{}])",
461                 method, leaderNode, getCurrentTerm(), mode, lastKnownLeader);
462         }
463         final boolean restartLeaderChecker = (mode == Mode.FOLLOWER &amp;&amp; Optional.of(leaderNode).equals(lastKnownLeader)) == false;
464         if (mode != Mode.FOLLOWER) {
465             mode = Mode.FOLLOWER;
466             joinAccumulator.close(mode);
467             joinAccumulator = new JoinHelper.FollowerJoinAccumulator();
468             leaderChecker.setCurrentNodes(DiscoveryNodes.EMPTY_NODES);
469         }
470         lastKnownLeader = Optional.of(leaderNode);
471         peerFinder.deactivate(leaderNode);
472         clusterFormationFailureHelper.stop();
473         closePrevotingAndElectionScheduler();
474         cancelActivePublication("become follower: " + method);
475         preVoteCollector.update(getPreVoteResponse(), leaderNode);
476         if (restartLeaderChecker) {
477             leaderChecker.updateLeader(leaderNode);
478         }
479         followersChecker.clearCurrentNodes();
480         followersChecker.updateFastResponseState(getCurrentTerm(), mode);
481         lagDetector.clearTrackedNodes();
482     }
483     private void cleanMasterService() {
484         masterService.submitStateUpdateTask("clean-up after stepping down as master",
485             new LocalClusterUpdateTask() {
486                 @Override
487                 public void onFailure(String source, Exception e) {
488                     LOGGER.trace("failed to clean-up after stepping down as master", e);
489                 }
490                 @Override
491                 public ClusterTasksResult&lt;LocalClusterUpdateTask&gt; execute(ClusterState currentState) {
492                     if (currentState.nodes().isLocalNodeElectedMaster() == false) {
493                         allocationService.cleanCaches();
494                     }
495                     return unchanged();
496                 }
497             });
498     }
499     private PreVoteResponse getPreVoteResponse() {
500         return new PreVoteResponse(getCurrentTerm(), coordinationState.get().getLastAcceptedTerm(),
501             coordinationState.get().getLastAcceptedState().version());
502     }
503     long getCurrentTerm() {
504         synchronized (mutex) {
505             return coordinationState.get().getCurrentTerm();
506         }
507     }
508     Mode getMode() {
509         synchronized (mutex) {
510             return mode;
511         }
512     }
513     DiscoveryNode getLocalNode() {
514         return transportService.getLocalNode();
515     }
516     boolean publicationInProgress() {
517         synchronized (mutex) {
518             return currentPublication.isPresent();
519         }
520     }
521     @Override
522     protected void doStart() {
523         synchronized (mutex) {
524             CoordinationState.PersistedState persistedState = persistedStateSupplier.get();
525             coordinationState.set(new CoordinationState(settings, getLocalNode(), persistedState));
526             peerFinder.setCurrentTerm(getCurrentTerm());
527             configuredHostsResolver.start();
528             final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState();
529             if (lastAcceptedState.metadata().clusterUUIDCommitted()) {
530                 LOGGER.info("cluster UUID [{}]", lastAcceptedState.metadata().clusterUUID());
531             }
532             final VotingConfiguration votingConfiguration = lastAcceptedState.getLastCommittedConfiguration();
533             if (singleNodeDiscovery &amp;&amp;
534                 votingConfiguration.isEmpty() == false &amp;&amp;
535                 votingConfiguration.hasQuorum(Collections.singleton(getLocalNode().getId())) == false) {
536                 throw new IllegalStateException("cannot start with [" + DiscoveryModule.DISCOVERY_TYPE_SETTING.getKey() + "] set to [" +
537                     DiscoveryModule.SINGLE_NODE_DISCOVERY_TYPE + "] when local node " + getLocalNode() +
538                     " does not have quorum in voting configuration " + votingConfiguration);
539             }
540             ClusterState initialState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.get(settings))
541                 .blocks(ClusterBlocks.builder()
542                     .addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)
543                     .addGlobalBlock(noMasterBlockService.getNoMasterBlock()))
544                 .nodes(DiscoveryNodes.builder().add(getLocalNode()).localNodeId(getLocalNode().getId()))
545                 .build();
546             applierState = initialState;
547             clusterApplier.setInitialState(initialState);
548         }
549     }
550     @Override
551     public DiscoveryStats stats() {
552         return new DiscoveryStats(new PendingClusterStateStats(0, 0, 0), publicationHandler.stats());
553     }
554     @Override
555     public void startInitialJoin() {
556         synchronized (mutex) {
557             becomeCandidate("startInitialJoin");
558         }
559         clusterBootstrapService.scheduleUnconfiguredBootstrap();
560     }
561     @Override
562     protected void doStop() {
563         configuredHostsResolver.stop();
564     }
565     @Override
566     protected void doClose() throws IOException {
567         final CoordinationState coordinationState = this.coordinationState.get();
568         if (coordinationState != null) {
569             synchronized (mutex) {
570                 coordinationState.close();
571             }
572         }
573     }
574     public void invariant() {
575         synchronized (mutex) {
576             final Optional&lt;DiscoveryNode&gt; peerFinderLeader = peerFinder.getLeader();
577             assert peerFinder.getCurrentTerm() == getCurrentTerm();
578             assert followersChecker.getFastResponseState().term == getCurrentTerm() : followersChecker.getFastResponseState();
579             assert followersChecker.getFastResponseState().mode == getMode() : followersChecker.getFastResponseState();
580             assert (applierState.nodes().getMasterNodeId() == null) == applierState.blocks().hasGlobalBlockWithId(NO_MASTER_BLOCK_ID);
581             assert preVoteCollector.getPreVoteResponse().equals(getPreVoteResponse())
582                 : preVoteCollector + " vs " + getPreVoteResponse();
583             assert lagDetector.getTrackedNodes().contains(getLocalNode()) == false : lagDetector.getTrackedNodes();
584             assert followersChecker.getKnownFollowers().equals(lagDetector.getTrackedNodes())
585                 : followersChecker.getKnownFollowers() + " vs " + lagDetector.getTrackedNodes();
586             if (mode == Mode.LEADER) {
587                 final boolean becomingMaster = getStateForMasterService().term() != getCurrentTerm();
588                 assert coordinationState.get().electionWon();
589                 assert lastKnownLeader.isPresent() &amp;&amp; lastKnownLeader.get().equals(getLocalNode());
590                 assert joinAccumulator instanceof JoinHelper.LeaderJoinAccumulator;
591                 assert peerFinderLeader.equals(lastKnownLeader) : peerFinderLeader;
592                 assert electionScheduler == null : electionScheduler;
593                 assert prevotingRound == null : prevotingRound;
594                 assert becomingMaster || getStateForMasterService().nodes().getMasterNodeId() != null : getStateForMasterService();
595                 assert leaderChecker.leader() == null : leaderChecker.leader();
596                 assert getLocalNode().equals(applierState.nodes().getMasterNode()) ||
597                     (applierState.nodes().getMasterNodeId() == null &amp;&amp; applierState.term() &lt; getCurrentTerm());
598                 assert preVoteCollector.getLeader() == getLocalNode() : preVoteCollector;
599                 assert clusterFormationFailureHelper.isRunning() == false;
600                 final boolean activePublication = currentPublication.map(CoordinatorPublication::isActiveForCurrentLeader).orElse(false);
601                 if (becomingMaster &amp;&amp; activePublication == false) {
602                     assert followersChecker.getKnownFollowers().isEmpty() : followersChecker.getKnownFollowers();
603                 } else {
604                     final ClusterState lastPublishedState;
605                     if (activePublication) {
606                         lastPublishedState = currentPublication.get().publishedState();
607                     } else {
608                         lastPublishedState = coordinationState.get().getLastAcceptedState();
609                     }
610                     final Set&lt;DiscoveryNode&gt; lastPublishedNodes = new HashSet&lt;&gt;();
611                     lastPublishedState.nodes().forEach(lastPublishedNodes::add);
612                     assert lastPublishedNodes.remove(getLocalNode());                     assert lastPublishedNodes.equals(followersChecker.getKnownFollowers()) :
613                         lastPublishedNodes + " != " + followersChecker.getKnownFollowers();
614                 }
615                 assert becomingMaster || activePublication ||
616                     coordinationState.get().getLastAcceptedConfiguration().equals(coordinationState.get().getLastCommittedConfiguration())
617                     : coordinationState.get().getLastAcceptedConfiguration() + " != "
618                     + coordinationState.get().getLastCommittedConfiguration();
619             } else if (mode == Mode.FOLLOWER) {
620                 assert coordinationState.get().electionWon() == false : getLocalNode() + " is FOLLOWER so electionWon() should be false";
621                 assert lastKnownLeader.isPresent() &amp;&amp; (lastKnownLeader.get().equals(getLocalNode()) == false);
622                 assert joinAccumulator instanceof JoinHelper.FollowerJoinAccumulator;
623                 assert peerFinderLeader.equals(lastKnownLeader) : peerFinderLeader;
624                 assert electionScheduler == null : electionScheduler;
625                 assert prevotingRound == null : prevotingRound;
626                 assert getStateForMasterService().nodes().getMasterNodeId() == null : getStateForMasterService();
627                 assert leaderChecker.currentNodeIsMaster() == false;
628                 assert lastKnownLeader.equals(Optional.of(leaderChecker.leader()));
629                 assert followersChecker.getKnownFollowers().isEmpty();
630                 assert lastKnownLeader.get().equals(applierState.nodes().getMasterNode()) ||
631                     (applierState.nodes().getMasterNodeId() == null &amp;&amp;
632                         (applierState.term() &lt; getCurrentTerm() || applierState.version() &lt; getLastAcceptedState().version()));
633                 assert currentPublication.map(Publication::isCommitted).orElse(true);
634                 assert preVoteCollector.getLeader().equals(lastKnownLeader.get()) : preVoteCollector;
635                 assert clusterFormationFailureHelper.isRunning() == false;
636             } else {
637                 assert mode == Mode.CANDIDATE;
638                 assert joinAccumulator instanceof JoinHelper.CandidateJoinAccumulator;
639                 assert peerFinderLeader.isPresent() == false : peerFinderLeader;
640                 assert prevotingRound == null || electionScheduler != null;
641                 assert getStateForMasterService().nodes().getMasterNodeId() == null : getStateForMasterService();
642                 assert leaderChecker.currentNodeIsMaster() == false;
643                 assert leaderChecker.leader() == null : leaderChecker.leader();
644                 assert followersChecker.getKnownFollowers().isEmpty();
645                 assert applierState.nodes().getMasterNodeId() == null;
646                 assert currentPublication.map(Publication::isCommitted).orElse(true);
647                 assert preVoteCollector.getLeader() == null : preVoteCollector;
648                 assert clusterFormationFailureHelper.isRunning();
649             }
650         }
651     }
652     public boolean isInitialConfigurationSet() {
653         return getStateForMasterService().getLastAcceptedConfiguration().isEmpty() == false;
654     }
655     public boolean setInitialConfiguration(final VotingConfiguration votingConfiguration) {
656         synchronized (mutex) {
657             final ClusterState currentState = getStateForMasterService();
658             if (isInitialConfigurationSet()) {
659                 LOGGER.debug("initial configuration already set, ignoring {}", votingConfiguration);
660                 return false;
661             }
662             if (getLocalNode().isMasterEligibleNode() == false) {
663                 LOGGER.debug("skip setting initial configuration as local node is not a master-eligible node");
664                 throw new CoordinationStateRejectedException(
665                     "this node is not master-eligible, but cluster bootstrapping can only happen on a master-eligible node");
666             }
667             if (votingConfiguration.getNodeIds().contains(getLocalNode().getId()) == false) {
668                 LOGGER.debug("skip setting initial configuration as local node is not part of initial configuration");
669                 throw new CoordinationStateRejectedException("local node is not part of initial configuration");
670             }
671             final List&lt;DiscoveryNode&gt; knownNodes = new ArrayList&lt;&gt;();
672             knownNodes.add(getLocalNode());
673             peerFinder.getFoundPeers().forEach(knownNodes::add);
674             if (votingConfiguration.hasQuorum(knownNodes.stream().map(DiscoveryNode::getId).collect(Collectors.toList())) == false) {
675                 LOGGER.debug("skip setting initial configuration as not enough nodes discovered to form a quorum in the " +
676                     "initial configuration [knownNodes={}, {}]", knownNodes, votingConfiguration);
677                 throw new CoordinationStateRejectedException("not enough nodes discovered to form a quorum in the initial configuration " +
678                     "[knownNodes=" + knownNodes + ", " + votingConfiguration + "]");
679 <a name="1"></a>            }
680             LOGGER.info("setting initial configuration to {}", votingConfiguration);
681             final CoordinationMetadata coordinationMetadata = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CoordinationMetadata.builder(currentState.coordinationMetadata())
682                 .lastAcceptedConfiguration(votingConfiguration)
683                 .lastCommittedConfiguration(votingConfiguration)
684                 .build();
685             Metadata.Builder metadataBuilder = Metadata.builder(currentState.metadata());
686             metadataBuilder.generateClusterUuidIfNeeded();             metadataBuilder.coordinationMetadata(coordinationMetadata);
687             coordinationState.get().setInitialState(ClusterState.builder</b></font>(currentState).metadata(metadataBuilder).build());
688             assert localNodeMayWinElection(getLastAcceptedState()) :
689                 "initial state does not allow local node to win election: " + getLastAcceptedState().coordinationMetadata();
690             preVoteCollector.update(getPreVoteResponse(), null);             startElectionScheduler();
691             return true;
692         }
693     }
694     ClusterState improveConfiguration(ClusterState clusterState) {
695         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
696         final Stream&lt;String&gt; excludedNodeIds = clusterState.getVotingConfigExclusions().stream().map(VotingConfigExclusion::getNodeId);
697         final Stream&lt;String&gt; masterIneligibleNodeIdsInVotingConfig = StreamSupport.stream(clusterState.nodes().spliterator(), false)
698             .filter(n -&gt; n.isMasterEligibleNode() == false
699                 &amp;&amp; (clusterState.getLastAcceptedConfiguration().getNodeIds().contains(n.getId())
700                 || clusterState.getLastCommittedConfiguration().getNodeIds().contains(n.getId())))
701             .map(DiscoveryNode::getId);
702         final Set&lt;DiscoveryNode&gt; liveNodes = StreamSupport.stream(clusterState.nodes().spliterator(), false)
703             .filter(DiscoveryNode::isMasterEligibleNode).filter(coordinationState.get()::containsJoinVoteFor).collect(Collectors.toSet());
704         final VotingConfiguration newConfig = reconfigurator.reconfigure(liveNodes,
705             Stream.concat(masterIneligibleNodeIdsInVotingConfig, excludedNodeIds).collect(Collectors.toSet()),
706             getLocalNode(), clusterState.getLastAcceptedConfiguration());
707         if (newConfig.equals(clusterState.getLastAcceptedConfiguration()) == false) {
708             assert coordinationState.get().joinVotesHaveQuorumFor(newConfig);
709             return ClusterState.builder(clusterState).metadata(Metadata.builder(clusterState.metadata())
710                 .coordinationMetadata(CoordinationMetadata.builder(clusterState.coordinationMetadata())
711                     .lastAcceptedConfiguration(newConfig).build())).build();
712         }
713         return clusterState;
714     }
715     private AtomicBoolean reconfigurationTaskScheduled = new AtomicBoolean();
716     private void scheduleReconfigurationIfNeeded() {
717         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
718         assert mode == Mode.LEADER : mode;
719         assert currentPublication.isPresent() == false : "Expected no publication in progress";
720         final ClusterState state = getLastAcceptedState();
721         if (improveConfiguration(state) != state &amp;&amp; reconfigurationTaskScheduled.compareAndSet(false, true)) {
722             LOGGER.trace("scheduling reconfiguration");
723             masterService.submitStateUpdateTask("reconfigure", new ClusterStateUpdateTask(Priority.URGENT) {
724                 @Override
725                 public ClusterState execute(ClusterState currentState) {
726                     reconfigurationTaskScheduled.set(false);
727                     synchronized (mutex) {
728                         return improveConfiguration(currentState);
729                     }
730                 }
731                 @Override
732                 public void onFailure(String source, Exception e) {
733                     reconfigurationTaskScheduled.set(false);
734                     LOGGER.debug("reconfiguration failed", e);
735                 }
736             });
737         }
738     }
739     boolean missingJoinVoteFrom(DiscoveryNode node) {
740         return node.isMasterEligibleNode() &amp;&amp; coordinationState.get().containsJoinVoteFor(node) == false;
741     }
742     private void handleJoin(Join join) {
743         synchronized (mutex) {
744             ensureTermAtLeast(getLocalNode(), join.getTerm()).ifPresent(this::handleJoin);
745             if (coordinationState.get().electionWon()) {
746                 final boolean isNewJoinFromMasterEligibleNode = handleJoinIgnoringExceptions(join);
747                 final boolean establishedAsMaster = mode == Mode.LEADER &amp;&amp; getLastAcceptedState().term() == getCurrentTerm();
748                 if (isNewJoinFromMasterEligibleNode &amp;&amp; establishedAsMaster &amp;&amp; publicationInProgress() == false) {
749                     scheduleReconfigurationIfNeeded();
750                 }
751             } else {
752                 coordinationState.get().handleJoin(join);             }
753         }
754     }
755     private boolean handleJoinIgnoringExceptions(Join join) {
756         try {
757             return coordinationState.get().handleJoin(join);
758         } catch (CoordinationStateRejectedException e) {
759             LOGGER.debug(new ParameterizedMessage("failed to add {} - ignoring", join), e);
760             return false;
761         }
762     }
763     public ClusterState getLastAcceptedState() {
764         synchronized (mutex) {
765             return coordinationState.get().getLastAcceptedState();
766         }
767     }
768     @Nullable
769     public ClusterState getApplierState() {
770         return applierState;
771     }
772     private List&lt;DiscoveryNode&gt; getDiscoveredNodes() {
773         final List&lt;DiscoveryNode&gt; nodes = new ArrayList&lt;&gt;();
774         nodes.add(getLocalNode());
775         peerFinder.getFoundPeers().forEach(nodes::add);
776         return nodes;
777     }
778     ClusterState getStateForMasterService() {
779         synchronized (mutex) {
780             final ClusterState clusterState = coordinationState.get().getLastAcceptedState();
781             if (mode != Mode.LEADER || clusterState.term() != getCurrentTerm()) {
782                 return clusterStateWithNoMasterBlock(clusterState);
783             }
784             return clusterState;
785         }
786     }
787     private ClusterState clusterStateWithNoMasterBlock(ClusterState clusterState) {
788         if (clusterState.nodes().getMasterNodeId() != null) {
789             assert clusterState.blocks().hasGlobalBlockWithId(NO_MASTER_BLOCK_ID) == false :
790                 "NO_MASTER_BLOCK should only be added by Coordinator";
791             final ClusterBlocks clusterBlocks = ClusterBlocks.builder().blocks(clusterState.blocks()).addGlobalBlock(
792                 noMasterBlockService.getNoMasterBlock()).build();
793             final DiscoveryNodes discoveryNodes = new DiscoveryNodes.Builder(clusterState.nodes()).masterNodeId(null).build();
794             return ClusterState.builder(clusterState).blocks(clusterBlocks).nodes(discoveryNodes).build();
795         } else {
796             return clusterState;
797         }
798     }
799     @Override
800     public void publish(ClusterChangedEvent clusterChangedEvent, ActionListener&lt;Void&gt; publishListener, AckListener ackListener) {
801         try {
802             synchronized (mutex) {
803                 if (mode != Mode.LEADER || getCurrentTerm() != clusterChangedEvent.state().term()) {
804                     LOGGER.debug(() -&gt; new ParameterizedMessage("[{}] failed publication as node is no longer master for term {}",
805                         clusterChangedEvent.source(), clusterChangedEvent.state().term()));
806                     publishListener.onFailure(new FailedToCommitClusterStateException("node is no longer master for term " +
807                         clusterChangedEvent.state().term() + " while handling publication"));
808                     return;
809                 }
810                 if (currentPublication.isPresent()) {
811                     assert false : "[" + currentPublication.get() + "] in progress, cannot start new publication";
812                     LOGGER.warn(() -&gt; new ParameterizedMessage("[{}] failed publication as already publication in progress",
813                         clusterChangedEvent.source()));
814                     publishListener.onFailure(new FailedToCommitClusterStateException("publication " + currentPublication.get() +
815                         " already in progress"));
816                     return;
817                 }
818                 assert assertPreviousStateConsistency(clusterChangedEvent);
819                 final ClusterState clusterState = clusterChangedEvent.state();
820                 assert getLocalNode().equals(clusterState.getNodes().get(getLocalNode().getId())) :
821                     getLocalNode() + " should be in published " + clusterState;
822                 final PublicationTransportHandler.PublicationContext publicationContext =
823                     publicationHandler.newPublicationContext(clusterChangedEvent);
824                 final PublishRequest publishRequest = coordinationState.get().handleClientValue(clusterState);
825                 final CoordinatorPublication publication = new CoordinatorPublication(publishRequest, publicationContext,
826                     new ListenableFuture&lt;&gt;(), ackListener, publishListener);
827                 currentPublication = Optional.of(publication);
828                 final DiscoveryNodes publishNodes = publishRequest.getAcceptedState().nodes();
829                 leaderChecker.setCurrentNodes(publishNodes);
830                 followersChecker.setCurrentNodes(publishNodes);
831                 lagDetector.setTrackedNodes(publishNodes);
832                 publication.start(followersChecker.getFaultyNodes());
833             }
834         } catch (Exception e) {
835             LOGGER.debug(() -&gt; new ParameterizedMessage("[{}] publishing failed", clusterChangedEvent.source()), e);
836             publishListener.onFailure(new FailedToCommitClusterStateException("publishing failed", e));
837         }
838     }
839     private boolean assertPreviousStateConsistency(ClusterChangedEvent event) {
840         assert event.previousState() == coordinationState.get().getLastAcceptedState() ||
841             XContentHelper.convertToMap(
842                 JsonXContent.JSON_XCONTENT, Strings.toString(event.previousState()), false
843             ).equals(
844                 XContentHelper.convertToMap(
845                     JsonXContent.JSON_XCONTENT,
846                     Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState())),
847                     false))
848             : Strings.toString(event.previousState()) + " vs "
849             + Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState()));
850         return true;
851     }
852     private &lt;T&gt; ActionListener&lt;T&gt; wrapWithMutex(ActionListener&lt;T&gt; listener) {
853         return new ActionListener&lt;T&gt;() {
854             @Override
855             public void onResponse(T t) {
856                 synchronized (mutex) {
857                     listener.onResponse(t);
858                 }
859             }
860             @Override
861             public void onFailure(Exception e) {
862                 synchronized (mutex) {
863                     listener.onFailure(e);
864                 }
865             }
866         };
867     }
868     private void cancelActivePublication(String reason) {
869         assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
870         if (currentPublication.isPresent()) {
871             currentPublication.get().cancel(reason);
872         }
873     }
874     public Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; getOnJoinValidators() {
875         return onJoinValidators;
876     }
877     public enum Mode {
878         CANDIDATE, LEADER, FOLLOWER
879     }
880     private class CoordinatorPeerFinder extends PeerFinder {
881         CoordinatorPeerFinder(Settings settings, TransportService transportService, TransportAddressConnector transportAddressConnector,
882                               ConfiguredHostsResolver configuredHostsResolver) {
883             super(settings, transportService, transportAddressConnector,
884                 singleNodeDiscovery ? hostsResolver -&gt; Collections.emptyList() : configuredHostsResolver);
885         }
886         @Override
887         protected void onActiveMasterFound(DiscoveryNode masterNode, long term) {
888             synchronized (mutex) {
889                 ensureTermAtLeast(masterNode, term);
890                 joinHelper.sendJoinRequest(masterNode, joinWithDestination(lastJoin, masterNode, term));
891             }
892         }
893         @Override
894         protected void startProbe(TransportAddress transportAddress) {
895             if (singleNodeDiscovery == false) {
896                 super.startProbe(transportAddress);
897             }
898         }
899         @Override
900         protected void onFoundPeersUpdated() {
901             synchronized (mutex) {
902                 final Iterable&lt;DiscoveryNode&gt; foundPeers = getFoundPeers();
903                 if (mode == Mode.CANDIDATE) {
904                     final CoordinationState.VoteCollection expectedVotes = new CoordinationState.VoteCollection();
905                     foundPeers.forEach(expectedVotes::addVote);
906                     expectedVotes.addVote(Coordinator.this.getLocalNode());
907                     final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState();
908                     final boolean foundQuorum = CoordinationState.isElectionQuorum(expectedVotes, lastAcceptedState);
909                     if (foundQuorum) {
910                         if (electionScheduler == null) {
911                             startElectionScheduler();
912                         }
913                     } else {
914                         closePrevotingAndElectionScheduler();
915                     }
916                 }
917             }
918             clusterBootstrapService.onFoundPeersUpdated();
919         }
920     }
921     private void startElectionScheduler() {
922         assert electionScheduler == null : electionScheduler;
923         if (getLocalNode().isMasterEligibleNode() == false) {
924             return;
925         }
926         final TimeValue gracePeriod = TimeValue.ZERO;         electionScheduler = electionSchedulerFactory.startElectionScheduler(gracePeriod, new Runnable() {
927             @Override
928             public void run() {
929                 synchronized (mutex) {
930                     if (mode == Mode.CANDIDATE) {
931                         final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState();
932                         if (localNodeMayWinElection(lastAcceptedState) == false) {
933                             LOGGER.trace("skip prevoting as local node may not win election: {}",
934                                 lastAcceptedState.coordinationMetadata());
935                             return;
936                         }
937                         if (prevotingRound != null) {
938                             prevotingRound.close();
939                         }
940                         prevotingRound = preVoteCollector.start(lastAcceptedState, getDiscoveredNodes());
941                     }
942                 }
943             }
944             @Override
945             public String toString() {
946                 return "scheduling of new prevoting round";
947             }
948         });
949     }
950     public Iterable&lt;DiscoveryNode&gt; getFoundPeers() {
951         return peerFinder.getFoundPeers();
952     }
953     boolean cancelCommittedPublication() {
954         synchronized (mutex) {
955             if (currentPublication.isPresent()) {
956                 final CoordinatorPublication publication = currentPublication.get();
957                 if (publication.isCommitted()) {
958                     publication.cancel("cancelCommittedPublication");
959                     LOGGER.debug("Cancelled publication of [{}].", publication);
960                     return true;
961                 }
962             }
963             return false;
964         }
965     }
966     class CoordinatorPublication extends Publication {
967         private final PublishRequest publishRequest;
968         private final ListenableFuture&lt;Void&gt; localNodeAckEvent;
969         private final AckListener ackListener;
970         private final ActionListener&lt;Void&gt; publishListener;
971         private final PublicationTransportHandler.PublicationContext publicationContext;
972         private final Scheduler.ScheduledCancellable timeoutHandler;
973         private final Scheduler.Cancellable infoTimeoutHandler;
974         private final List&lt;Join&gt; receivedJoins = new ArrayList&lt;&gt;();
975         private boolean receivedJoinsProcessed;
976         CoordinatorPublication(PublishRequest publishRequest, PublicationTransportHandler.PublicationContext publicationContext,
977                                ListenableFuture&lt;Void&gt; localNodeAckEvent, AckListener ackListener, ActionListener&lt;Void&gt; publishListener) {
978             super(publishRequest,
979                 new AckListener() {
980                     @Override
981                     public void onCommit(TimeValue commitTime) {
982                         ackListener.onCommit(commitTime);
983                     }
984                     @Override
985                     public void onNodeAck(DiscoveryNode node, Exception e) {
986                         if (node.equals(getLocalNode())) {
987                             synchronized (mutex) {
988                                 if (e == null) {
989                                     localNodeAckEvent.onResponse(null);
990                                 } else {
991                                     localNodeAckEvent.onFailure(e);
992                                 }
993                             }
994                         } else {
995                             ackListener.onNodeAck(node, e);
996                             if (e == null) {
997                                 lagDetector.setAppliedVersion(node, publishRequest.getAcceptedState().version());
998                             }
999                         }
1000                     }
1001                 },
1002                 transportService.getThreadPool()::relativeTimeInMillis);
1003             this.publishRequest = publishRequest;
1004             this.publicationContext = publicationContext;
1005             this.localNodeAckEvent = localNodeAckEvent;
1006             this.ackListener = ackListener;
1007             this.publishListener = publishListener;
1008             this.timeoutHandler = transportService.getThreadPool().schedule(new Runnable() {
1009                 @Override
1010                 public void run() {
1011                     synchronized (mutex) {
1012                         cancel("timed out after " + publishTimeout);
1013                     }
1014                 }
1015                 @Override
1016                 public String toString() {
1017                     return "scheduled timeout for " + this;
1018                 }
1019             }, publishTimeout, Names.GENERIC);
1020             this.infoTimeoutHandler = transportService.getThreadPool().schedule(new Runnable() {
1021                 @Override
1022                 public void run() {
1023                     synchronized (mutex) {
1024                         logIncompleteNodes(Level.INFO);
1025                     }
1026                 }
1027                 @Override
1028                 public String toString() {
1029                     return "scheduled timeout for reporting on " + CoordinatorPublication.this;
1030                 }
1031             }, publishInfoTimeout, Names.GENERIC);
1032         }
1033         private void removePublicationAndPossiblyBecomeCandidate(String reason) {
1034             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1035             assert currentPublication.get() == this;
1036             currentPublication = Optional.empty();
1037             logger.debug("publication ended unsuccessfully: {}", this);
1038             if (isActiveForCurrentLeader()) {
1039                 becomeCandidate(reason);
1040             }
1041         }
1042         boolean isActiveForCurrentLeader() {
1043             return mode == Mode.LEADER &amp;&amp; publishRequest.getAcceptedState().term() == getCurrentTerm();
1044         }
1045         @Override
1046         protected void onCompletion(boolean committed) {
1047             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1048             localNodeAckEvent.addListener(new ActionListener&lt;Void&gt;() {
1049                 @Override
1050                 public void onResponse(Void ignore) {
1051                     assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1052                     assert committed;
1053                     receivedJoins.forEach(CoordinatorPublication.this::handleAssociatedJoin);
1054                     assert receivedJoinsProcessed == false;
1055                     receivedJoinsProcessed = true;
1056                     clusterApplier.onNewClusterState(CoordinatorPublication.this.toString(), () -&gt; applierState,
1057                         new ClusterApplyListener() {
1058                             @Override
1059                             public void onFailure(String source, Exception e) {
1060                                 synchronized (mutex) {
1061                                     removePublicationAndPossiblyBecomeCandidate("clusterApplier#onNewClusterState");
1062                                 }
1063                                 timeoutHandler.cancel();
1064                                 infoTimeoutHandler.cancel();
1065                                 ackListener.onNodeAck(getLocalNode(), e);
1066                                 publishListener.onFailure(e);
1067                             }
1068                             @Override
1069                             public void onSuccess(String source) {
1070                                 synchronized (mutex) {
1071                                     assert currentPublication.get() == CoordinatorPublication.this;
1072                                     currentPublication = Optional.empty();
1073                                     logger.debug("publication ended successfully: {}", CoordinatorPublication.this);
1074                                     updateMaxTermSeen(getCurrentTerm());
1075                                     if (mode == Mode.LEADER) {
1076                                         boolean attemptReconfiguration = true;
1077                                         final ClusterState state = getLastAcceptedState();                                         if (localNodeMayWinElection(state) == false) {
1078                                             final List&lt;DiscoveryNode&gt; masterCandidates = completedNodes().stream()
1079                                                 .filter(DiscoveryNode::isMasterEligibleNode)
1080                                                 .filter(node -&gt; nodeMayWinElection(state, node))
1081                                                 .collect(Collectors.toList());
1082                                             if (masterCandidates.isEmpty() == false) {
1083                                                 abdicateTo(masterCandidates.get(random.nextInt(masterCandidates.size())));
1084                                                 attemptReconfiguration = false;
1085                                             }
1086                                         }
1087                                         if (attemptReconfiguration) {
1088                                             scheduleReconfigurationIfNeeded();
1089                                         }
1090                                     }
1091                                     lagDetector.startLagDetector(publishRequest.getAcceptedState().version());
1092                                     logIncompleteNodes(Level.WARN);
1093                                 }
1094                                 timeoutHandler.cancel();
1095                                 infoTimeoutHandler.cancel();
1096                                 ackListener.onNodeAck(getLocalNode(), null);
1097                                 publishListener.onResponse(null);
1098                             }
1099                         });
1100                 }
1101                 @Override
1102                 public void onFailure(Exception e) {
1103                     assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1104                     removePublicationAndPossiblyBecomeCandidate("Publication.onCompletion(false)");
1105                     timeoutHandler.cancel();
1106                     infoTimeoutHandler.cancel();
1107                     final FailedToCommitClusterStateException exception = new FailedToCommitClusterStateException("publication failed", e);
1108                     ackListener.onNodeAck(getLocalNode(), exception);                     publishListener.onFailure(exception);
1109                 }
1110             }, EsExecutors.directExecutor());
1111         }
1112         private void handleAssociatedJoin(Join join) {
1113             if (join.getTerm() == getCurrentTerm() &amp;&amp; missingJoinVoteFrom(join.getSourceNode())) {
1114                 logger.trace("handling {}", join);
1115                 handleJoin(join);
1116             }
1117         }
1118         @Override
1119         protected boolean isPublishQuorum(CoordinationState.VoteCollection votes) {
1120             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1121             return coordinationState.get().isPublishQuorum(votes);
1122         }
1123         @Override
1124         protected Optional&lt;ApplyCommitRequest&gt; handlePublishResponse(DiscoveryNode sourceNode,
1125                                                                      PublishResponse publishResponse) {
1126             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1127             assert getCurrentTerm() &gt;= publishResponse.getTerm();
1128             return coordinationState.get().handlePublishResponse(sourceNode, publishResponse);
1129         }
1130         @Override
1131         protected void onJoin(Join join) {
1132             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1133             if (receivedJoinsProcessed) {
1134                 handleAssociatedJoin(join);
1135             } else {
1136                 receivedJoins.add(join);
1137             }
1138         }
1139         @Override
1140         protected void onMissingJoin(DiscoveryNode discoveryNode) {
1141             assert Thread.holdsLock(mutex) : "Coordinator mutex not held";
1142             if (missingJoinVoteFrom(discoveryNode)) {
1143                 final long term = publishRequest.getAcceptedState().term();
1144                 logger.debug("onMissingJoin: no join vote from {}, bumping term to exceed {}", discoveryNode, term);
1145                 updateMaxTermSeen(term + 1);
1146             }
1147         }
1148         @Override
1149         protected void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest,
1150                                           ActionListener&lt;PublishWithJoinResponse&gt; responseActionListener) {
1151             publicationContext.sendPublishRequest(destination, publishRequest, wrapWithMutex(responseActionListener));
1152         }
1153         @Override
1154         protected void sendApplyCommit(DiscoveryNode destination, ApplyCommitRequest applyCommit,
1155                                        ActionListener&lt;Empty&gt; responseActionListener) {
1156             publicationContext.sendApplyCommit(destination, applyCommit, wrapWithMutex(responseActionListener));
1157         }
1158     }
1159 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
