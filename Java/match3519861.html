<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for OptimizeCollectWhereClauseAccess.java &amp; ObjectParser.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for OptimizeCollectWhereClauseAccess.java &amp; ObjectParser.java
      </h3>
<h1 align="center">
        5.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>OptimizeCollectWhereClauseAccess.java (22.222221%)<th>ObjectParser.java (3.3783784%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-44)<td><a href="#" name="0">(22-44)</a><td align="center"><font color="#ff0000">20</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>OptimizeCollectWhereClauseAccess.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.planner.optimizer.rule;
2 import io.crate.analyze.WhereClause;
3 import io.crate.analyze.relations.DocTableRelation;
4 import io.crate.analyze.where.DocKeys;
5 import io.crate.expression.eval.EvaluatingNormalizer;
6 import io.crate.expression.symbol.Symbols;
7 import io.crate.metadata.NodeContext;
8 import io.crate.metadata.RowGranularity;
9 import io.crate.metadata.TransactionContext;
10 import io.crate.metadata.doc.DocSysColumns;
11 import io.crate.planner.WhereClauseOptimizer;
12 import io.crate.planner.operators.Collect;
13 import io.crate.planner.operators.Get;
14 import io.crate.planner.operators.LogicalPlan;
15 import io.crate.planner.optimizer.Rule;
16 import io.crate.planner.optimizer.matcher.Captures;
17 import io.crate.planner.optimizer.matcher.Pattern;
18 import io.crate.statistics.TableStats;
19 import java.util.Optional;
20 import</b></font> static io.crate.planner.optimizer.matcher.Pattern.typeOf;
21 public final class OptimizeCollectWhereClauseAccess implements Rule&lt;Collect&gt; {
22     private final Pattern&lt;Collect&gt; pattern;
23     public OptimizeCollectWhereClauseAccess() {
24         this.pattern = typeOf(Collect.class)
25             .with(collect -&gt;
26                       collect.relation() instanceof DocTableRelation
27                       &amp;&amp; collect.where().hasQuery()
28                       &amp;&amp; !Symbols.containsColumn(collect.outputs(), DocSysColumns.FETCHID)
29             );
30     }
31     @Override
32     public Pattern&lt;Collect&gt; pattern() {
33         return pattern;
34     }
35     @Override
36     public LogicalPlan apply(Collect collect,
37                              Captures captures,
38                              TableStats tableStats,
39                              TransactionContext txnCtx,
40                              NodeContext nodeCtx) {
41         var relation = (DocTableRelation) collect.relation();
42         var normalizer = new EvaluatingNormalizer(nodeCtx, RowGranularity.CLUSTER, null, relation);
43         WhereClause where = collect.where();
44         var detailedQuery = WhereClauseOptimizer.optimize(
45             normalizer,
46             where.queryOrFallback(),
47             relation.tableInfo(),
48             txnCtx,
49             nodeCtx
50         );
51         Optional&lt;DocKeys&gt; docKeys = detailedQuery.docKeys();
52         //noinspection OptionalIsPresent no capturing lambda allocation
53         if (docKeys.isPresent()) {
54             return new Get(
55                 relation,
56                 docKeys.get(),
57                 detailedQuery.query(),
58                 collect.outputs(),
59                 tableStats.estimatedSizePerRow(relation.relationName())
60             );
61         } else if (!detailedQuery.clusteredBy().isEmpty() &amp;&amp; collect.detailedQuery() == null) {
62             return new Collect(collect, detailedQuery);
63         } else {
64             return null;
65         }
66     }
67 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ObjectParser.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.common.xcontent;
2 import javax.annotation.Nullable;
3 import org.elasticsearch.common.ParseField;
4 import java.io.IOException;
5 import java.util.ArrayList;
6 import java.util.Arrays;
7 import java.util.EnumSet;
8 import java.util.HashMap;
9 import java.util.List;
10 import java.util.Map;
11 import java.util.function.BiConsumer;
12 import java.util.function.BiFunction;
13 import java.util.function.Consumer;
14 import java.util.function.Supplier;
15 import static org.elasticsearch.common.xcontent.XContentParser.Token.START_ARRAY;
16 import static org.elasticsearch.common.xcontent.XContentParser.Token.START_OBJECT;
17 import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_BOOLEAN;
18 import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_EMBEDDED_OBJECT;
19 import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_NULL;
20 import</b></font> static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_NUMBER;
21 import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_STRING;
22 public final class ObjectParser&lt;Value, Context&gt; extends AbstractObjectParser&lt;Value, Context&gt; {
23     private final Map&lt;String, FieldParser&gt; fieldParserMap = new HashMap&lt;&gt;();
24     private final String name;
25     private final Supplier&lt;Value&gt; valueSupplier;
26     private final boolean ignoreUnknownFields;
27     public ObjectParser(String name) {
28         this(name, null);
29     }
30     public ObjectParser(String name, @Nullable Supplier&lt;Value&gt; valueSupplier) {
31         this(name, false, valueSupplier);
32     }
33     public ObjectParser(String name, boolean ignoreUnknownFields, @Nullable Supplier&lt;Value&gt; valueSupplier) {
34         this.name = name;
35         this.valueSupplier = valueSupplier;
36         this.ignoreUnknownFields = ignoreUnknownFields;
37     }
38     @Override
39     public Value parse(XContentParser parser, Context context) throws IOException {
40         if (valueSupplier == null) {
41             throw new NullPointerException("valueSupplier is not set");
42         }
43         return parse(parser, valueSupplier.get(), context);
44     }
45     public Value parse(XContentParser parser, Value value, Context context) throws IOException {
46         XContentParser.Token token;
47         if (parser.currentToken() == XContentParser.Token.START_OBJECT) {
48             token = parser.currentToken();
49         } else {
50             token = parser.nextToken();
51             if (token != XContentParser.Token.START_OBJECT) {
52                 throw new XContentParseException(parser.getTokenLocation(), "[" + name + "] Expected START_OBJECT but was: " + token);
53             }
54         }
55         FieldParser fieldParser = null;
56         String currentFieldName = null;
57         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
58             if (token == XContentParser.Token.FIELD_NAME) {
59                 currentFieldName = parser.currentName();
60                 fieldParser = getParser(currentFieldName, parser);
61             } else {
62                 if (currentFieldName == null) {
63                     throw new XContentParseException(parser.getTokenLocation(), "[" + name + "] no field found");
64                 }
65                 if (fieldParser == null) {
66                     assert ignoreUnknownFields : "this should only be possible if configured to ignore known fields";
67                     parser.skipChildren();                 } else {
68                     fieldParser.assertSupports(name, parser, currentFieldName);
69                     parseSub(parser, fieldParser, currentFieldName, value, context);
70                 }
71                 fieldParser = null;
72             }
73         }
74         return value;
75     }
76     @Override
77     public Value apply(XContentParser parser, Context context) {
78         if (valueSupplier == null) {
79             throw new NullPointerException("valueSupplier is not set");
80         }
81         try {
82             return parse(parser, valueSupplier.get(), context);
83         } catch (IOException e) {
84             throw new XContentParseException(parser.getTokenLocation(), "[" + name + "] failed to parse object", e);
85         }
86     }
87     public interface Parser&lt;Value, Context&gt; {
88         void parse(XContentParser parser, Value value, Context context) throws IOException;
89     }
90     public void declareField(Parser&lt;Value, Context&gt; p, ParseField parseField, ValueType type) {
91         if (parseField == null) {
92             throw new IllegalArgumentException("[parseField] is required");
93         }
94         if (type == null) {
95             throw new IllegalArgumentException("[type] is required");
96         }
97         FieldParser fieldParser = new FieldParser(p, type.supportedTokens(), parseField, type);
98         for (String fieldValue : parseField.getAllNamesIncludedDeprecated()) {
99             fieldParserMap.putIfAbsent(fieldValue, fieldParser);
100         }
101     }
102     @Override
103     public &lt;T&gt; void declareField(BiConsumer&lt;Value, T&gt; consumer, ContextParser&lt;Context, T&gt; parser, ParseField parseField,
104             ValueType type) {
105         if (consumer == null) {
106             throw new IllegalArgumentException("[consumer] is required");
107         }
108         if (parser == null) {
109             throw new IllegalArgumentException("[parser] is required");
110         }
111         declareField((p, v, c) -&gt; consumer.accept(v, parser.parse(p, c)), parseField, type);
112     }
113     @Override
114     public &lt;T&gt; void declareNamedObjects(BiConsumer&lt;Value, List&lt;T&gt;&gt; consumer, NamedObjectParser&lt;T, Context&gt; namedObjectParser,
115             Consumer&lt;Value&gt; orderedModeCallback, ParseField field) {
116         BiFunction&lt;XContentParser, Context, T&gt; objectParser = (XContentParser p, Context c) -&gt; {
117             if (p.currentToken() != XContentParser.Token.FIELD_NAME) {
118                 throw new XContentParseException(p.getTokenLocation(), "[" + field + "] can be a single object with any number of "
119                         + "fields or an array where each entry is an object with a single field");
120             }
121             try {
122                 String name = p.currentName();
123                 try {
124                     return namedObjectParser.parse(p, c, name);
125                 } catch (Exception e) {
126                     throw new XContentParseException(p.getTokenLocation(), "[" + field + "] failed to parse field [" + name + "]", e);
127                 }
128             } catch (IOException e) {
129                 throw new XContentParseException(p.getTokenLocation(), "[" + field + "] error while parsing", e);
130             }
131         };
132         declareField((XContentParser p, Value v, Context c) -&gt; {
133             List&lt;T&gt; fields = new ArrayList&lt;&gt;();
134             XContentParser.Token token;
135             if (p.currentToken() == XContentParser.Token.START_OBJECT) {
136                 while ((token = p.nextToken()) != XContentParser.Token.END_OBJECT) {
137                     fields.add(objectParser.apply(p, c));
138                 }
139             } else if (p.currentToken() == XContentParser.Token.START_ARRAY) {
140                 orderedModeCallback.accept(v);
141                 while ((token = p.nextToken()) != XContentParser.Token.END_ARRAY) {
142                     if (token != XContentParser.Token.START_OBJECT) {
143                         throw new XContentParseException(p.getTokenLocation(), "[" + field + "] can be a single object with any number of "
144                                 + "fields or an array where each entry is an object with a single field");
145                     }
146                     p.nextToken();                     fields.add(objectParser.apply(p, c));
147                     p.nextToken();                     if (p.currentToken() != XContentParser.Token.END_OBJECT) {
148                         throw new XContentParseException(p.getTokenLocation(), "[" + field + "] can be a single object with any number of "
149                                 + "fields or an array where each entry is an object with a single field");
150                     }
151                 }
152             }
153             consumer.accept(v, fields);
154         }, field, ValueType.OBJECT_ARRAY);
155     }
156     @Override
157     public &lt;T&gt; void declareNamedObjects(BiConsumer&lt;Value, List&lt;T&gt;&gt; consumer, NamedObjectParser&lt;T, Context&gt; namedObjectParser,
158             ParseField field) {
159         Consumer&lt;Value&gt; orderedModeCallback = (v) -&gt; {
160             throw new IllegalArgumentException("[" + field + "] doesn't support arrays. Use a single object with multiple fields.");
161         };
162         declareNamedObjects(consumer, namedObjectParser, orderedModeCallback, field);
163     }
164     @FunctionalInterface
165     public interface NamedObjectParser&lt;T, Context&gt; {
166         T parse(XContentParser p, Context c, String name) throws IOException;
167     }
168     @Override
169     public String getName() {
170         return name;
171     }
172     private void parseArray(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context)
173             throws IOException {
174         assert parser.currentToken() == XContentParser.Token.START_ARRAY : "Token was: " + parser.currentToken();
175         parseValue(parser, fieldParser, currentFieldName, value, context);
176     }
177     private void parseValue(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context)
178             throws IOException {
179         try {
180             fieldParser.parser.parse(parser, value, context);
181         } catch (Exception ex) {
182             throw new XContentParseException(parser.getTokenLocation(),
183                 "[" + name + "] failed to parse field [" + currentFieldName + "]", ex);
184         }
185     }
186     private void parseSub(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context)
187             throws IOException {
188         final XContentParser.Token token = parser.currentToken();
189         switch (token) {
190             case START_OBJECT:
191                 parseValue(parser, fieldParser, currentFieldName, value, context);
192                 break;
193             case START_ARRAY:
194                 parseArray(parser, fieldParser, currentFieldName, value, context);
195                 break;
196             case END_OBJECT:
197             case END_ARRAY:
198             case FIELD_NAME:
199                 throw new XContentParseException(parser.getTokenLocation(), "[" + name + "]" + token + " is unexpected");
200             case VALUE_STRING:
201             case VALUE_NUMBER:
202             case VALUE_BOOLEAN:
203             case VALUE_EMBEDDED_OBJECT:
204             case VALUE_NULL:
205                 parseValue(parser, fieldParser, currentFieldName, value, context);
206                 break;
207             default:
208                 throw new IllegalArgumentException("Unexpected token: " + token);
209         }
210     }
211     private FieldParser getParser(String fieldName, XContentParser xContentParser) {
212         FieldParser parser = fieldParserMap.get(fieldName);
213         if (parser == null &amp;&amp; false == ignoreUnknownFields) {
214             throw new XContentParseException(xContentParser.getTokenLocation(),
215                     "[" + name + "] unknown field [" + fieldName + "], parser not found");
216         }
217         return parser;
218     }
219     private class FieldParser {
220         private final Parser&lt;Value, Context&gt; parser;
221         private final EnumSet&lt;XContentParser.Token&gt; supportedTokens;
222         private final ParseField parseField;
223         private final ValueType type;
224         FieldParser(Parser&lt;Value, Context&gt; parser, EnumSet&lt;XContentParser.Token&gt; supportedTokens, ParseField parseField, ValueType type) {
225             this.parser = parser;
226             this.supportedTokens = supportedTokens;
227             this.parseField = parseField;
228             this.type = type;
229         }
230         void assertSupports(String parserName, XContentParser parser, String currentFieldName) {
231             if (parseField.match(currentFieldName, parser.getDeprecationHandler()) == false) {
232                 throw new XContentParseException(parser.getTokenLocation(),
233                         "[" + parserName + "] parsefield doesn't accept: " + currentFieldName);
234             }
235             if (supportedTokens.contains(parser.currentToken()) == false) {
236                 throw new XContentParseException(parser.getTokenLocation(),
237                         "[" + parserName + "] " + currentFieldName + " doesn't support values of type: " + parser.currentToken());
238             }
239         }
240         @Override
241         public String toString() {
242             String[] deprecatedNames = parseField.getDeprecatedNames();
243             String allReplacedWith = parseField.getAllReplacedWith();
244             String deprecated = "";
245             if (deprecatedNames != null &amp;&amp; deprecatedNames.length &gt; 0) {
246                 deprecated = ", deprecated_names=" + Arrays.toString(deprecatedNames);
247             }
248             return "FieldParser{" +
249                     "preferred_name=" + parseField.getPreferredName() +
250                     ", supportedTokens=" + supportedTokens +
251                     deprecated +
252                     (allReplacedWith == null ? "" : ", replaced_with=" + allReplacedWith) +
253                     ", type=" + type.name() +
254                     '}';
255         }
256     }
257     public enum ValueType {
258         STRING(VALUE_STRING),
259         STRING_OR_NULL(VALUE_STRING, VALUE_NULL),
260         FLOAT(VALUE_NUMBER, VALUE_STRING),
261         FLOAT_OR_NULL(VALUE_NUMBER, VALUE_STRING, VALUE_NULL),
262         DOUBLE(VALUE_NUMBER, VALUE_STRING),
263         DOUBLE_OR_NULL(VALUE_NUMBER, VALUE_STRING, VALUE_NULL),
264         LONG(VALUE_NUMBER, VALUE_STRING),
265         LONG_OR_NULL(VALUE_NUMBER, VALUE_STRING, VALUE_NULL),
266         INT(VALUE_NUMBER, VALUE_STRING),
267         INT_OR_NULL(VALUE_NUMBER, VALUE_STRING, VALUE_NULL),
268         BOOLEAN(VALUE_BOOLEAN, VALUE_STRING),
269         STRING_ARRAY(START_ARRAY, VALUE_STRING),
270         FLOAT_ARRAY(START_ARRAY, VALUE_NUMBER, VALUE_STRING),
271         DOUBLE_ARRAY(START_ARRAY, VALUE_NUMBER, VALUE_STRING),
272         LONG_ARRAY(START_ARRAY, VALUE_NUMBER, VALUE_STRING),
273         INT_ARRAY(START_ARRAY, VALUE_NUMBER, VALUE_STRING),
274         BOOLEAN_ARRAY(START_ARRAY, VALUE_BOOLEAN),
275         OBJECT(START_OBJECT),
276         OBJECT_OR_NULL(START_OBJECT, VALUE_NULL),
277         OBJECT_ARRAY(START_OBJECT, START_ARRAY),
278         OBJECT_OR_BOOLEAN(START_OBJECT, VALUE_BOOLEAN),
279         OBJECT_OR_STRING(START_OBJECT, VALUE_STRING),
280         OBJECT_ARRAY_BOOLEAN_OR_STRING(START_OBJECT, START_ARRAY, VALUE_BOOLEAN, VALUE_STRING),
281         OBJECT_ARRAY_OR_STRING(START_OBJECT, START_ARRAY, VALUE_STRING),
282         VALUE(VALUE_BOOLEAN, VALUE_NULL, VALUE_EMBEDDED_OBJECT, VALUE_NUMBER, VALUE_STRING),
283         VALUE_OBJECT_ARRAY(VALUE_BOOLEAN, VALUE_NULL, VALUE_EMBEDDED_OBJECT, VALUE_NUMBER, VALUE_STRING, START_OBJECT, START_ARRAY),
284         VALUE_ARRAY(VALUE_BOOLEAN, VALUE_NULL, VALUE_NUMBER, VALUE_STRING, START_ARRAY);
285         private final EnumSet&lt;XContentParser.Token&gt; tokens;
286         ValueType(XContentParser.Token first, XContentParser.Token... rest) {
287             this.tokens = EnumSet.of(first, rest);
288         }
289         public EnumSet&lt;XContentParser.Token&gt; supportedTokens() {
290             return this.tokens;
291         }
292     }
293     @Override
294     public String toString() {
295         return "ObjectParser{" +
296                 "name='" + name + '\'' +
297                 ", fields=" + fieldParserMap.values() +
298                 '}';
299     }
300 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
