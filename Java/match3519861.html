<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for OptimizeCollectWhereClauseAccess.java & ObjectParser.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for OptimizeCollectWhereClauseAccess.java & ObjectParser.java
      </h3>
      <h1 align="center">
        5.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>OptimizeCollectWhereClauseAccess.java (22.222221%)<TH>ObjectParser.java (3.3783784%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3519861-0.html#0',2,'match3519861-1.html#0',3)" NAME="0">(22-44)<TD><A HREF="javascript:ZweiFrames('match3519861-0.html#0',2,'match3519861-1.html#0',3)" NAME="0">(22-44)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>OptimizeCollectWhereClauseAccess.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3519861-1.html#0',3,'match3519861-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.crate.planner.optimizer.rule;

import io.crate.analyze.WhereClause;
import io.crate.analyze.relations.DocTableRelation;
import io.crate.analyze.where.DocKeys;
import io.crate.expression.eval.EvaluatingNormalizer;
import io.crate.expression.symbol.Symbols;
import io.crate.metadata.NodeContext;
import io.crate.metadata.RowGranularity;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.doc.DocSysColumns;
import io.crate.planner.WhereClauseOptimizer;
import io.crate.planner.operators.Collect;
import io.crate.planner.operators.Get;
import io.crate.planner.operators.LogicalPlan;
import io.crate.planner.optimizer.Rule;
import io.crate.planner.optimizer.matcher.Captures;
import io.crate.planner.optimizer.matcher.Pattern;
import io.crate.statistics.TableStats;

import java.util.Optional;

import</B></FONT> static io.crate.planner.optimizer.matcher.Pattern.typeOf;

public final class OptimizeCollectWhereClauseAccess implements Rule&lt;Collect&gt; {

    private final Pattern&lt;Collect&gt; pattern;

    public OptimizeCollectWhereClauseAccess() {
        this.pattern = typeOf(Collect.class)
            .with(collect -&gt;
                      collect.relation() instanceof DocTableRelation
                      &amp;&amp; collect.where().hasQuery()
                      &amp;&amp; !Symbols.containsColumn(collect.outputs(), DocSysColumns.FETCHID)
            );
    }

    @Override
    public Pattern&lt;Collect&gt; pattern() {
        return pattern;
    }

    @Override
    public LogicalPlan apply(Collect collect,
                             Captures captures,
                             TableStats tableStats,
                             TransactionContext txnCtx,
                             NodeContext nodeCtx) {
        var relation = (DocTableRelation) collect.relation();
        var normalizer = new EvaluatingNormalizer(nodeCtx, RowGranularity.CLUSTER, null, relation);
        WhereClause where = collect.where();
        var detailedQuery = WhereClauseOptimizer.optimize(
            normalizer,
            where.queryOrFallback(),
            relation.tableInfo(),
            txnCtx,
            nodeCtx
        );
        Optional&lt;DocKeys&gt; docKeys = detailedQuery.docKeys();
        //noinspection OptionalIsPresent no capturing lambda allocation
        if (docKeys.isPresent()) {
            return new Get(
                relation,
                docKeys.get(),
                detailedQuery.query(),
                collect.outputs(),
                tableStats.estimatedSizePerRow(relation.relationName())
            );
        } else if (!detailedQuery.clusteredBy().isEmpty() &amp;&amp; collect.detailedQuery() == null) {
            return new Collect(collect, detailedQuery);
        } else {
            return null;
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ObjectParser.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3519861-0.html#0',2,'match3519861-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package org.elasticsearch.common.xcontent;

import javax.annotation.Nullable;
import org.elasticsearch.common.ParseField;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static org.elasticsearch.common.xcontent.XContentParser.Token.START_ARRAY;
import static org.elasticsearch.common.xcontent.XContentParser.Token.START_OBJECT;
import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_BOOLEAN;
import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_EMBEDDED_OBJECT;
import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_NULL;
import</B></FONT> static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_NUMBER;
import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_STRING;

/**
 * A declarative, stateless parser that turns XContent into setter calls. A single parser should be defined for each object being parsed,
 * nested elements can be added via {@link #declareObject(BiConsumer, ContextParser, ParseField)} which should be satisfied where possible
 * by passing another instance of {@link ObjectParser}, this one customized for that Object.
 * &lt;p&gt;
 * This class works well for object that do have a constructor argument or that can be built using information available from earlier in the
 * XContent. For objects that have constructors with required arguments that are specified on the same level as other fields see
 * {@link ConstructingObjectParser}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Instances of {@link ObjectParser} should be setup by declaring a constant field for the parsers and declaring all fields in a static
 * block just below the creation of the parser. Like this:
 * &lt;/p&gt;
 * &lt;pre&gt;{@code
 *   private static final ObjectParser&lt;Thing, SomeContext&gt; PARSER = new ObjectParser&lt;&gt;(&quot;thing&quot;, Thing::new));
 *   static {
 *       PARSER.declareInt(Thing::setMineral, new ParseField(&quot;mineral&quot;));
 *       PARSER.declareInt(Thing::setFruit, new ParseField(&quot;fruit&quot;));
 *   }
 * }&lt;/pre&gt;
 * It's highly recommended to use the high level declare methods like {@link #declareString(BiConsumer, ParseField)} instead of
 * {@link #declareField} which can be used to implement exceptional parsing operations not covered by the high level methods.
 */
public final class ObjectParser&lt;Value, Context&gt; extends AbstractObjectParser&lt;Value, Context&gt; {

    private final Map&lt;String, FieldParser&gt; fieldParserMap = new HashMap&lt;&gt;();
    private final String name;
    private final Supplier&lt;Value&gt; valueSupplier;
    /**
     * Should this parser ignore unknown fields? This should generally be set to true only when parsing responses from external systems,
     * never when parsing requests from users.
     */
    private final boolean ignoreUnknownFields;

    /**
     * Creates a new ObjectParser instance with a name. This name is used to reference the parser in exceptions and messages.
     */
    public ObjectParser(String name) {
        this(name, null);
    }

    /**
     * Creates a new ObjectParser instance which a name.
     * @param name the parsers name, used to reference the parser in exceptions and messages.
     * @param valueSupplier a supplier that creates a new Value instance used when the parser is used as an inner object parser.
     */
    public ObjectParser(String name, @Nullable Supplier&lt;Value&gt; valueSupplier) {
        this(name, false, valueSupplier);
    }

    /**
     * Creates a new ObjectParser instance which a name.
     * @param name the parsers name, used to reference the parser in exceptions and messages.
     * @param ignoreUnknownFields Should this parser ignore unknown fields? This should generally be set to true only when parsing
     *      responses from external systems, never when parsing requests from users.
     * @param valueSupplier a supplier that creates a new Value instance used when the parser is used as an inner object parser.
     */
    public ObjectParser(String name, boolean ignoreUnknownFields, @Nullable Supplier&lt;Value&gt; valueSupplier) {
        this.name = name;
        this.valueSupplier = valueSupplier;
        this.ignoreUnknownFields = ignoreUnknownFields;
    }

    /**
     * Parses a Value from the given {@link XContentParser}
     * @param parser the parser to build a value from
     * @param context context needed for parsing
     * @return a new value instance drawn from the provided value supplier on {@link #ObjectParser(String, Supplier)}
     * @throws IOException if an IOException occurs.
     */
    @Override
    public Value parse(XContentParser parser, Context context) throws IOException {
        if (valueSupplier == null) {
            throw new NullPointerException(&quot;valueSupplier is not set&quot;);
        }
        return parse(parser, valueSupplier.get(), context);
    }

    /**
     * Parses a Value from the given {@link XContentParser}
     * @param parser the parser to build a value from
     * @param value the value to fill from the parser
     * @param context a context that is passed along to all declared field parsers
     * @return the parsed value
     * @throws IOException if an IOException occurs.
     */
    public Value parse(XContentParser parser, Value value, Context context) throws IOException {
        XContentParser.Token token;
        if (parser.currentToken() == XContentParser.Token.START_OBJECT) {
            token = parser.currentToken();
        } else {
            token = parser.nextToken();
            if (token != XContentParser.Token.START_OBJECT) {
                throw new XContentParseException(parser.getTokenLocation(), &quot;[&quot; + name + &quot;] Expected START_OBJECT but was: &quot; + token);
            }
        }

        FieldParser fieldParser = null;
        String currentFieldName = null;
        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
                fieldParser = getParser(currentFieldName, parser);
            } else {
                if (currentFieldName == null) {
                    throw new XContentParseException(parser.getTokenLocation(), &quot;[&quot; + name + &quot;] no field found&quot;);
                }
                if (fieldParser == null) {
                    assert ignoreUnknownFields : &quot;this should only be possible if configured to ignore known fields&quot;;
                    parser.skipChildren(); // noop if parser points to a value, skips children if parser is start object or start array
                } else {
                    fieldParser.assertSupports(name, parser, currentFieldName);
                    parseSub(parser, fieldParser, currentFieldName, value, context);
                }
                fieldParser = null;
            }
        }
        return value;
    }

    @Override
    public Value apply(XContentParser parser, Context context) {
        if (valueSupplier == null) {
            throw new NullPointerException(&quot;valueSupplier is not set&quot;);
        }
        try {
            return parse(parser, valueSupplier.get(), context);
        } catch (IOException e) {
            throw new XContentParseException(parser.getTokenLocation(), &quot;[&quot; + name + &quot;] failed to parse object&quot;, e);
        }
    }

    public interface Parser&lt;Value, Context&gt; {
        void parse(XContentParser parser, Value value, Context context) throws IOException;
    }

    public void declareField(Parser&lt;Value, Context&gt; p, ParseField parseField, ValueType type) {
        if (parseField == null) {
            throw new IllegalArgumentException(&quot;[parseField] is required&quot;);
        }
        if (type == null) {
            throw new IllegalArgumentException(&quot;[type] is required&quot;);
        }
        FieldParser fieldParser = new FieldParser(p, type.supportedTokens(), parseField, type);
        for (String fieldValue : parseField.getAllNamesIncludedDeprecated()) {
            fieldParserMap.putIfAbsent(fieldValue, fieldParser);
        }
    }

    @Override
    public &lt;T&gt; void declareField(BiConsumer&lt;Value, T&gt; consumer, ContextParser&lt;Context, T&gt; parser, ParseField parseField,
            ValueType type) {
        if (consumer == null) {
            throw new IllegalArgumentException(&quot;[consumer] is required&quot;);
        }
        if (parser == null) {
            throw new IllegalArgumentException(&quot;[parser] is required&quot;);
        }
        declareField((p, v, c) -&gt; consumer.accept(v, parser.parse(p, c)), parseField, type);
    }

    @Override
    public &lt;T&gt; void declareNamedObjects(BiConsumer&lt;Value, List&lt;T&gt;&gt; consumer, NamedObjectParser&lt;T, Context&gt; namedObjectParser,
            Consumer&lt;Value&gt; orderedModeCallback, ParseField field) {
        // This creates and parses the named object
        BiFunction&lt;XContentParser, Context, T&gt; objectParser = (XContentParser p, Context c) -&gt; {
            if (p.currentToken() != XContentParser.Token.FIELD_NAME) {
                throw new XContentParseException(p.getTokenLocation(), &quot;[&quot; + field + &quot;] can be a single object with any number of &quot;
                        + &quot;fields or an array where each entry is an object with a single field&quot;);
            }
            // This messy exception nesting has the nice side effect of telling the use which field failed to parse
            try {
                String name = p.currentName();
                try {
                    return namedObjectParser.parse(p, c, name);
                } catch (Exception e) {
                    throw new XContentParseException(p.getTokenLocation(), &quot;[&quot; + field + &quot;] failed to parse field [&quot; + name + &quot;]&quot;, e);
                }
            } catch (IOException e) {
                throw new XContentParseException(p.getTokenLocation(), &quot;[&quot; + field + &quot;] error while parsing&quot;, e);
            }
        };
        declareField((XContentParser p, Value v, Context c) -&gt; {
            List&lt;T&gt; fields = new ArrayList&lt;&gt;();
            XContentParser.Token token;
            if (p.currentToken() == XContentParser.Token.START_OBJECT) {
                // Fields are just named entries in a single object
                while ((token = p.nextToken()) != XContentParser.Token.END_OBJECT) {
                    fields.add(objectParser.apply(p, c));
                }
            } else if (p.currentToken() == XContentParser.Token.START_ARRAY) {
                // Fields are objects in an array. Each object contains a named field.
                orderedModeCallback.accept(v);
                while ((token = p.nextToken()) != XContentParser.Token.END_ARRAY) {
                    if (token != XContentParser.Token.START_OBJECT) {
                        throw new XContentParseException(p.getTokenLocation(), &quot;[&quot; + field + &quot;] can be a single object with any number of &quot;
                                + &quot;fields or an array where each entry is an object with a single field&quot;);
                    }
                    p.nextToken(); // Move to the first field in the object
                    fields.add(objectParser.apply(p, c));
                    p.nextToken(); // Move past the object, should be back to into the array
                    if (p.currentToken() != XContentParser.Token.END_OBJECT) {
                        throw new XContentParseException(p.getTokenLocation(), &quot;[&quot; + field + &quot;] can be a single object with any number of &quot;
                                + &quot;fields or an array where each entry is an object with a single field&quot;);
                    }
                }
            }
            consumer.accept(v, fields);
        }, field, ValueType.OBJECT_ARRAY);
    }

    @Override
    public &lt;T&gt; void declareNamedObjects(BiConsumer&lt;Value, List&lt;T&gt;&gt; consumer, NamedObjectParser&lt;T, Context&gt; namedObjectParser,
            ParseField field) {
        Consumer&lt;Value&gt; orderedModeCallback = (v) -&gt; {
            throw new IllegalArgumentException(&quot;[&quot; + field + &quot;] doesn't support arrays. Use a single object with multiple fields.&quot;);
        };
        declareNamedObjects(consumer, namedObjectParser, orderedModeCallback, field);
    }

    /**
     * Functional interface for instantiating and parsing named objects. See ObjectParserTests#NamedObject for the canonical way to
     * implement this for objects that themselves have a parser.
     */
    @FunctionalInterface
    public interface NamedObjectParser&lt;T, Context&gt; {
        T parse(XContentParser p, Context c, String name) throws IOException;
    }

    /**
     * Get the name of the parser.
     */
    @Override
    public String getName() {
        return name;
    }

    private void parseArray(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context)
            throws IOException {
        assert parser.currentToken() == XContentParser.Token.START_ARRAY : &quot;Token was: &quot; + parser.currentToken();
        parseValue(parser, fieldParser, currentFieldName, value, context);
    }

    private void parseValue(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context)
            throws IOException {
        try {
            fieldParser.parser.parse(parser, value, context);
        } catch (Exception ex) {
            throw new XContentParseException(parser.getTokenLocation(),
                &quot;[&quot; + name + &quot;] failed to parse field [&quot; + currentFieldName + &quot;]&quot;, ex);
        }
    }

    private void parseSub(XContentParser parser, FieldParser fieldParser, String currentFieldName, Value value, Context context)
            throws IOException {
        final XContentParser.Token token = parser.currentToken();
        switch (token) {
            case START_OBJECT:
                parseValue(parser, fieldParser, currentFieldName, value, context);
                break;
            case START_ARRAY:
                parseArray(parser, fieldParser, currentFieldName, value, context);
                break;
            case END_OBJECT:
            case END_ARRAY:
            case FIELD_NAME:
                throw new XContentParseException(parser.getTokenLocation(), &quot;[&quot; + name + &quot;]&quot; + token + &quot; is unexpected&quot;);
            case VALUE_STRING:
            case VALUE_NUMBER:
            case VALUE_BOOLEAN:
            case VALUE_EMBEDDED_OBJECT:
            case VALUE_NULL:
                parseValue(parser, fieldParser, currentFieldName, value, context);
                break;

            default:
                throw new IllegalArgumentException(&quot;Unexpected token: &quot; + token);
        }
    }

    private FieldParser getParser(String fieldName, XContentParser xContentParser) {
        FieldParser parser = fieldParserMap.get(fieldName);
        if (parser == null &amp;&amp; false == ignoreUnknownFields) {
            throw new XContentParseException(xContentParser.getTokenLocation(),
                    &quot;[&quot; + name + &quot;] unknown field [&quot; + fieldName + &quot;], parser not found&quot;);
        }
        return parser;
    }

    private class FieldParser {
        private final Parser&lt;Value, Context&gt; parser;
        private final EnumSet&lt;XContentParser.Token&gt; supportedTokens;
        private final ParseField parseField;
        private final ValueType type;

        FieldParser(Parser&lt;Value, Context&gt; parser, EnumSet&lt;XContentParser.Token&gt; supportedTokens, ParseField parseField, ValueType type) {
            this.parser = parser;
            this.supportedTokens = supportedTokens;
            this.parseField = parseField;
            this.type = type;
        }

        void assertSupports(String parserName, XContentParser parser, String currentFieldName) {
            if (parseField.match(currentFieldName, parser.getDeprecationHandler()) == false) {
                throw new XContentParseException(parser.getTokenLocation(),
                        &quot;[&quot; + parserName + &quot;] parsefield doesn't accept: &quot; + currentFieldName);
            }
            if (supportedTokens.contains(parser.currentToken()) == false) {
                throw new XContentParseException(parser.getTokenLocation(),
                        &quot;[&quot; + parserName + &quot;] &quot; + currentFieldName + &quot; doesn't support values of type: &quot; + parser.currentToken());
            }
        }

        @Override
        public String toString() {
            String[] deprecatedNames = parseField.getDeprecatedNames();
            String allReplacedWith = parseField.getAllReplacedWith();
            String deprecated = &quot;&quot;;
            if (deprecatedNames != null &amp;&amp; deprecatedNames.length &gt; 0) {
                deprecated = &quot;, deprecated_names=&quot; + Arrays.toString(deprecatedNames);
            }
            return &quot;FieldParser{&quot; +
                    &quot;preferred_name=&quot; + parseField.getPreferredName() +
                    &quot;, supportedTokens=&quot; + supportedTokens +
                    deprecated +
                    (allReplacedWith == null ? &quot;&quot; : &quot;, replaced_with=&quot; + allReplacedWith) +
                    &quot;, type=&quot; + type.name() +
                    '}';
        }
    }

    public enum ValueType {
        STRING(VALUE_STRING),
        STRING_OR_NULL(VALUE_STRING, VALUE_NULL),
        FLOAT(VALUE_NUMBER, VALUE_STRING),
        FLOAT_OR_NULL(VALUE_NUMBER, VALUE_STRING, VALUE_NULL),
        DOUBLE(VALUE_NUMBER, VALUE_STRING),
        DOUBLE_OR_NULL(VALUE_NUMBER, VALUE_STRING, VALUE_NULL),
        LONG(VALUE_NUMBER, VALUE_STRING),
        LONG_OR_NULL(VALUE_NUMBER, VALUE_STRING, VALUE_NULL),
        INT(VALUE_NUMBER, VALUE_STRING),
        INT_OR_NULL(VALUE_NUMBER, VALUE_STRING, VALUE_NULL),
        BOOLEAN(VALUE_BOOLEAN, VALUE_STRING),
        STRING_ARRAY(START_ARRAY, VALUE_STRING),
        FLOAT_ARRAY(START_ARRAY, VALUE_NUMBER, VALUE_STRING),
        DOUBLE_ARRAY(START_ARRAY, VALUE_NUMBER, VALUE_STRING),
        LONG_ARRAY(START_ARRAY, VALUE_NUMBER, VALUE_STRING),
        INT_ARRAY(START_ARRAY, VALUE_NUMBER, VALUE_STRING),
        BOOLEAN_ARRAY(START_ARRAY, VALUE_BOOLEAN),
        OBJECT(START_OBJECT),
        OBJECT_OR_NULL(START_OBJECT, VALUE_NULL),
        OBJECT_ARRAY(START_OBJECT, START_ARRAY),
        OBJECT_OR_BOOLEAN(START_OBJECT, VALUE_BOOLEAN),
        OBJECT_OR_STRING(START_OBJECT, VALUE_STRING),
        OBJECT_ARRAY_BOOLEAN_OR_STRING(START_OBJECT, START_ARRAY, VALUE_BOOLEAN, VALUE_STRING),
        OBJECT_ARRAY_OR_STRING(START_OBJECT, START_ARRAY, VALUE_STRING),
        VALUE(VALUE_BOOLEAN, VALUE_NULL, VALUE_EMBEDDED_OBJECT, VALUE_NUMBER, VALUE_STRING),
        VALUE_OBJECT_ARRAY(VALUE_BOOLEAN, VALUE_NULL, VALUE_EMBEDDED_OBJECT, VALUE_NUMBER, VALUE_STRING, START_OBJECT, START_ARRAY),
        VALUE_ARRAY(VALUE_BOOLEAN, VALUE_NULL, VALUE_NUMBER, VALUE_STRING, START_ARRAY);

        private final EnumSet&lt;XContentParser.Token&gt; tokens;

        ValueType(XContentParser.Token first, XContentParser.Token... rest) {
            this.tokens = EnumSet.of(first, rest);
        }

        public EnumSet&lt;XContentParser.Token&gt; supportedTokens() {
            return this.tokens;
        }
    }

    @Override
    public String toString() {
        return &quot;ObjectParser{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, fields=&quot; + fieldParserMap.values() +
                '}';
    }
}
</PRE>
</div>
  </div>
</body>
</html>
