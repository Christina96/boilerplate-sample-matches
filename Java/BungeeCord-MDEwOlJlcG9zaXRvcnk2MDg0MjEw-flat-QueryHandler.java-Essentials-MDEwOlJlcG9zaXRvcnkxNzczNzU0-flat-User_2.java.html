
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.15032679738562%, Tokens: 17</h2>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-QueryHandler.java</h3>
            <pre><code>1  package net.md_5.bungee.query;
2  import com.google.common.cache.Cache;
3  import com.google.common.cache.CacheBuilder;
4  import io.netty.buffer.ByteBuf;
5  import io.netty.channel.AddressedEnvelope;
6  import io.netty.channel.ChannelHandlerContext;
7  import io.netty.channel.SimpleChannelInboundHandler;
8  import io.netty.channel.socket.DatagramPacket;
9  import java.net.InetAddress;
10  import java.util.LinkedHashMap;
11  import java.util.Map;
12  import java.util.Random;
13  import java.util.concurrent.TimeUnit;
14  import java.util.logging.Level;
15  import lombok.Data;
16  import lombok.RequiredArgsConstructor;
17  import net.md_5.bungee.api.ProxyServer;
18  import net.md_5.bungee.api.config.ListenerInfo;
19  import net.md_5.bungee.api.connection.ProxiedPlayer;
20  @RequiredArgsConstructor
21  public class QueryHandler extends SimpleChannelInboundHandler<DatagramPacket>
22  {
23      private final ProxyServer bungee;
24      private final ListenerInfo listener;
25      private final Random random = new Random();
26      private final Cache<InetAddress, QuerySession> sessions = CacheBuilder.newBuilder().expireAfterWrite( 30, TimeUnit.SECONDS ).build();
27      private void writeShort(ByteBuf buf, int s)
28      {
29          buf.writeShortLE( s );
30      }
31      private void writeNumber(ByteBuf buf, int i)
32      {
33          writeString( buf, Integer.toString( i ) );
34      }
35      private void writeString(ByteBuf buf, String s)
36      {
37          for ( char c : s.toCharArray() )
38          {
39              buf.writeByte( c );
40          }
41          buf.writeByte( 0x00 );
42      }
43      @Override
44      protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception
45      {
46          try
47          {
48              handleMessage( ctx, msg );
49          } catch ( Throwable t )
50          {
51              bungee.getLogger().log( Level.WARNING, "Error whilst handling query packet from " + msg.sender(), t );
52          }
53      }
54      private void handleMessage(ChannelHandlerContext ctx, DatagramPacket msg)
55      {
56          ByteBuf in = msg.content();
57          if ( in.readUnsignedByte() != 0xFE || in.readUnsignedByte() != 0xFD )
58          {
59              bungee.getLogger().log( Level.WARNING, "Query - Incorrect magic!: {0}", msg.sender() );
60              return;
61          }
62          ByteBuf out = ctx.alloc().buffer();
63          AddressedEnvelope response = new DatagramPacket( out, msg.sender() );
64          byte type = in.readByte();
65          int sessionId = in.readInt();
66          if ( type == 0x09 )
67          {
68              out.writeByte( 0x09 );
69              out.writeInt( sessionId );
70              int challengeToken = random.nextInt();
71              sessions.put( msg.sender().getAddress(), new QuerySession( challengeToken, System.currentTimeMillis() ) );
72              writeNumber( out, challengeToken );
73          }
74          if ( type == 0x00 )
75          {
76              int challengeToken = in.readInt();
77              QuerySession session = sessions.getIfPresent( msg.sender().getAddress() );
78              if ( session == null || session.getToken() != challengeToken )
79              {
80                  throw new IllegalStateException( "No session!" );
81              }
82              out.writeByte( 0x00 );
83              out.writeInt( sessionId );
<span onclick='openModal()' class='match'>84              if ( in.readableBytes() == 0 )
85              {
86                  writeString( out, listener.getMotd() ); 
87                  writeString( out, "SMP" ); 
88                  writeString( out, "BungeeCord_Proxy" ); 
89                  writeNumber( out, bungee.getOnlineCount() ); 
90                  writeNumber( out, listener.getMaxPlayers() ); 
91                  writeShort( out, listener.getHost().getPort() ); 
92                  writeString( out, listener.getHost().getHostString() ); 
93              } else if ( in.readableBytes() == 4 )
</span>94              {
95                  out.writeBytes( new byte[]
96                  {
97                      0x73, 0x70, 0x6C, 0x69, 0x74, 0x6E, 0x75, 0x6D, 0x00, (byte) 0x80, 0x00
98                  } );
99                  Map<String, String> data = new LinkedHashMap<>();
100                  data.put( "hostname", listener.getMotd() );
101                  data.put( "gametype", "SMP" );
102                  data.put( "game_id", "MINECRAFT" );
103                  data.put( "version", bungee.getGameVersion() );
104                  data.put( "plugins", "" );
105                  data.put( "map", "BungeeCord_Proxy" );
106                  data.put( "numplayers", Integer.toString( bungee.getOnlineCount() ) );
107                  data.put( "maxplayers", Integer.toString( listener.getMaxPlayers() ) );
108                  data.put( "hostport", Integer.toString( listener.getHost().getPort() ) );
109                  data.put( "hostip", listener.getHost().getHostString() );
110                  for ( Map.Entry<String, String> entry : data.entrySet() )
111                  {
112                      writeString( out, entry.getKey() );
113                      writeString( out, entry.getValue() );
114                  }
115                  out.writeByte( 0x00 ); 
116                  writeString( out, "\01player_\00" );
117                  for ( ProxiedPlayer p : bungee.getPlayers() )
118                  {
119                      writeString( out, p.getName() );
120                  }
121                  out.writeByte( 0x00 ); 
122              } else
123              {
124                  throw new IllegalStateException( "Invalid data request packet" );
125              }
126          }
127          ctx.writeAndFlush( response );
128      }
129      @Override
130      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
131      {
132          bungee.getLogger().log( Level.WARNING, "Error whilst handling query packet from " + ctx.channel().remoteAddress(), cause );
133      }
134      @Data
135      private static class QuerySession
136      {
137          private final int token;
138          private final long time;
139      }
140  }
</code></pre>
        </div>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-User_2.java</h3>
            <pre><code>1  package com.earth2me.essentials;
2  import static com.earth2me.essentials.I18n.tl;
3  import com.earth2me.essentials.commands.IEssentialsCommand;
4  import com.earth2me.essentials.register.payment.Method;
5  import com.earth2me.essentials.register.payment.Methods;
6  import com.earth2me.essentials.utils.DateUtil;
7  import com.earth2me.essentials.utils.FormatUtil;
8  import com.earth2me.essentials.utils.NumberUtil;
9  import java.math.BigDecimal;
10  import java.util.Calendar;
11  import java.util.GregorianCalendar;
12  import java.util.UUID;
13  import java.util.logging.Level;
14  import java.util.logging.Logger;
15  import net.ess3.api.IEssentials;
16  import net.ess3.api.MaxMoneyException;
17  import net.ess3.api.events.AfkStatusChangeEvent;
18  import net.ess3.api.events.UserBalanceUpdateEvent;
19  import org.bukkit.ChatColor;
20  import org.bukkit.Location;
21  import org.bukkit.entity.Player;
22  import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
23  import org.bukkit.potion.PotionEffect;
24  import org.bukkit.potion.PotionEffectType;
25  public class User extends UserData implements Comparable<User>, IReplyTo, net.ess3.api.IUser
26  {
27  	private static final Logger logger = Logger.getLogger("Essentials");
28  	private CommandSource replyTo = null;
29  	private transient UUID teleportRequester;
30  	private transient boolean teleportRequestHere;
31  	private transient Location teleportLocation;
32  	private transient boolean vanished;
33  	private transient final Teleport teleport;
34  	private transient long teleportRequestTime;
35  	private transient long lastOnlineActivity;
36  	private transient long lastThrottledAction;
37  	private transient long lastActivity = System.currentTimeMillis();
38  	private boolean hidden = false;
39  	private boolean rightClickJump = false;
40  	private transient Location afkPosition = null;
41  	private boolean invSee = false;
42  	private boolean recipeSee = false;
43  	private boolean enderSee = false;
44  	private transient long teleportInvulnerabilityTimestamp = 0;
45  	public User(final Player base, final IEssentials ess)
46  	{
47  		super(base, ess);
48  		teleport = new Teleport(this, ess);
49  		if (isAfk())
50  		{
51  			afkPosition = this.getLocation();
52  		}
53  		if (this.getBase().isOnline())
54  		{
55  			lastOnlineActivity = System.currentTimeMillis();
56  		}
57  	}
58  	User update(final Player base)
59  	{
60  		setBase(base);
61  		return this;
62  	}
63  	@Override
64  	public boolean isAuthorized(final IEssentialsCommand cmd)
65  	{
66  		return isAuthorized(cmd, "essentials.");
67  	}
68  	@Override
69  	public boolean isAuthorized(final IEssentialsCommand cmd, final String permissionPrefix)
70  	{
71  		return isAuthorized(permissionPrefix + (cmd.getName().equals("r") ? "msg" : cmd.getName()));
72  	}
73  	@Override
74  	public boolean isAuthorized(final String node)
75  	{
76  		final boolean result = isAuthorizedCheck(node);
77  		if (ess.getSettings().isDebug())
78  		{
79  			ess.getLogger().log(Level.INFO, "checking if " + base.getName() + " has " + node + " - " + result);
80  		}
81  		return result;
82  	}
83  	private boolean isAuthorizedCheck(final String node)
84  	{
85  		if (base instanceof OfflinePlayer)
86  		{
87  			return false;
88  		}
89  		try
90  		{
91  			return ess.getPermissionsHandler().hasPermission(base, node);
92  		}
93  		catch (Exception ex)
94  		{
95  			if (ess.getSettings().isDebug())
96  			{
97  				ess.getLogger().log(Level.SEVERE, "Permission System Error: " + ess.getPermissionsHandler().getName() + " returned: " + ex.getMessage(), ex);
98  			}
99  			else
100  			{
101  				ess.getLogger().log(Level.SEVERE, "Permission System Error: " + ess.getPermissionsHandler().getName() + " returned: " + ex.getMessage());
102  			}
103  			return false;
104  		}
105  	}
106  	@Override
107  	public void healCooldown() throws Exception
108  	{
109  		final Calendar now = new GregorianCalendar();
110  		if (getLastHealTimestamp() > 0)
111  		{
112  			final double cooldown = ess.getSettings().getHealCooldown();
113  			final Calendar cooldownTime = new GregorianCalendar();
114  			cooldownTime.setTimeInMillis(getLastHealTimestamp());
115  			cooldownTime.add(Calendar.SECOND, (int)cooldown);
116  			cooldownTime.add(Calendar.MILLISECOND, (int)((cooldown * 1000.0) % 1000.0));
117  			if (cooldownTime.after(now) && !isAuthorized("essentials.heal.cooldown.bypass"))
118  			{
119  				throw new Exception(tl("timeBeforeHeal", DateUtil.formatDateDiff(cooldownTime.getTimeInMillis())));
120  			}
121  		}
122  		setLastHealTimestamp(now.getTimeInMillis());
123  	}
124  	@Override
125  	public void giveMoney(final BigDecimal value) throws MaxMoneyException
126  	{
127  		giveMoney(value, (CommandSource)null);
128  	}
129  	@Override
130  	public void giveMoney(final BigDecimal value, final CommandSource initiator) throws MaxMoneyException
131  	{
132  		if (value.signum() == 0)
133  		{
134  			return;
135  		}
136  		setMoney(getMoney().add(value));
137  		sendMessage(tl("addedToAccount", NumberUtil.displayCurrency(value, ess)));
138  		if (initiator != null)
139  		{
140  			initiator.sendMessage(tl("addedToOthersAccount", NumberUtil.displayCurrency(value, ess), this.getDisplayName(), NumberUtil.displayCurrency(getMoney(), ess)));
141  		}
142  	}
143  	@Override
144  	public void payUser(final User reciever, final BigDecimal value) throws ChargeException, MaxMoneyException
145  	{
146  		if (value.signum() == 0)
147  		{
148  			return;
149  		}
<span onclick='openModal()' class='match'>150  		if (canAfford(value))
151  		{
152  			setMoney(getMoney().subtract(value));
153  			reciever.setMoney(reciever.getMoney().add(value));
154  			sendMessage(tl("moneySentTo", NumberUtil.displayCurrency(value, ess), reciever.getDisplayName()));
155  			reciever.sendMessage(tl("moneyRecievedFrom", NumberUtil.displayCurrency(value, ess), getDisplayName()));
156  		}
157  		else
158  		{
</span>159  			throw new ChargeException(tl("notEnoughMoney", NumberUtil.displayCurrency(value, ess)));
160  		}
161  	}
162  	@Override
163  	public void takeMoney(final BigDecimal value)
164  	{
165  		takeMoney(value, (CommandSource)null);
166  	}
167  	@Override
168  	public void takeMoney(final BigDecimal value, final CommandSource initiator)
169  	{
170  		if (value.signum() == 0)
171  		{
172  			return;
173  		}
174  		try
175  		{
176  			setMoney(getMoney().subtract(value));
177  		}
178  		catch (MaxMoneyException ex)
179  		{
180  			ess.getLogger().log(Level.WARNING, "Invalid call to takeMoney, total balance can't be more than the max-money limit.", ex);
181  		}
182  		sendMessage(tl("takenFromAccount", NumberUtil.displayCurrency(value, ess)));
183  		if (initiator != null)
184  		{
185  			initiator.sendMessage(tl("takenFromOthersAccount", NumberUtil.displayCurrency(value, ess), this.getDisplayName(), NumberUtil.displayCurrency(getMoney(), ess)));
186  		}
187  	}
188  	@Override
189  	public boolean canAfford(final BigDecimal cost)
190  	{
191  		return canAfford(cost, true);
192  	}
193  	public boolean canAfford(final BigDecimal cost, final boolean permcheck)
194  	{
195  		if (cost.signum() <= 0)
196  		{
197  			return true;
198  		}
199  		final BigDecimal remainingBalance = getMoney().subtract(cost);
200  		if (!permcheck || isAuthorized("essentials.eco.loan"))
201  		{
202  			return (remainingBalance.compareTo(ess.getSettings().getMinMoney()) >= 0);
203  		}
204  		return (remainingBalance.signum() >= 0);
205  	}
206  	public void dispose()
207  	{
208  		ess.runTaskAsynchronously(new Runnable()
209  		{
210  			@Override
211  			public void run()
212  			{
213  				_dispose();
214  			}
215  		});
216  	}
217  	private void _dispose()
218  	{
219  		if (!base.isOnline())
220  		{
221  			this.base = new OfflinePlayer(getConfigUUID(), ess.getServer());
222  		}
223  		cleanup();
224  	}
225  	@Override
226  	public Boolean canSpawnItem(final int itemId)
227  	{
228  		return !ess.getSettings().itemSpawnBlacklist().contains(itemId);
229  	}
230  	@Override
231  	public void setLastLocation()
232  	{
233  		setLastLocation(this.getLocation());
234  	}
235  	@Override
236  	public void setLogoutLocation()
237  	{
238  		setLogoutLocation(this.getLocation());
239  	}
240  	@Override
241  	public void requestTeleport(final User player, final boolean here)
242  	{
243  		teleportRequestTime = System.currentTimeMillis();
244  		teleportRequester = player == null ? null : player.getBase().getUniqueId();
245  		teleportRequestHere = here;
246  		if (player == null)
247  		{
248  			teleportLocation = null;
249  		}
250  		else
251  		{
252  			teleportLocation = here ? player.getLocation() : this.getLocation();
253  		}
254  	}
255  	public UUID getTeleportRequest()
256  	{
257  		return teleportRequester;
258  	}
259  	public boolean isTpRequestHere()
260  	{
261  		return teleportRequestHere;
262  	}
263  	public Location getTpRequestLocation()
264  	{
265  		return teleportLocation;
266  	}
267  	public String getNick(final boolean longnick)
268  	{
269  		final StringBuilder prefix = new StringBuilder();
270  		String nickname;
271  		String suffix = "";
272  		final String nick = getNickname();
273  		if (ess.getSettings().isCommandDisabled("nick") || nick == null || nick.isEmpty() || nick.equals(getName()))
274  		{
275  			nickname = getName();
276  		}
277  		else if (nick.equalsIgnoreCase(getName())) {
278  			nickname = nick;
279  		}
280  		else
281  		{
282  			nickname = ess.getSettings().getNicknamePrefix() + nick;
283  			suffix = "§r";
284  		}
285  		if (this.getBase().isOp())
286  		{
287  			try
288  			{
289  				final ChatColor opPrefix = ess.getSettings().getOperatorColor();
290  				if (opPrefix != null && opPrefix.toString().length() > 0)
291  				{
292  					prefix.insert(0, opPrefix.toString());
293  					suffix = "§r";
294  				}
295  			}
296  			catch (Exception e)
297  			{
298  			}
299  		}
300  		if (ess.getSettings().addPrefixSuffix())
301  		{
302  			if (!ess.getSettings().disablePrefix())
303  			{
304  				final String ptext = ess.getPermissionsHandler().getPrefix(base).replace('&', '§');
305  				prefix.insert(0, ptext);
306  				suffix = "§r";
307  			}
308  			if (!ess.getSettings().disableSuffix())
309  			{
310  				final String stext = ess.getPermissionsHandler().getSuffix(base).replace('&', '§');
311  				suffix = stext + "§r";
312  				suffix = suffix.replace("§f§f", "§f").replace("§f§r", "§r").replace("§r§r", "§r");
313  			}
314  		}
315  		final String strPrefix = prefix.toString();
316  		String output = strPrefix + nickname + suffix;
317  		if (!longnick && output.length() > 16)
318  		{
319  			output = strPrefix + nickname;
320  		}
321  		if (!longnick && output.length() > 16)
322  		{
323  			output = FormatUtil.lastCode(strPrefix) + nickname;
324  		}
325  		if (!longnick && output.length() > 16)
326  		{
327  			output = FormatUtil.lastCode(strPrefix) + nickname.substring(0, 14);
328  		}
329  		if (output.charAt(output.length() - 1) == '§')
330  		{
331  			output = output.substring(0, output.length() - 1);
332  		}
333  		return output;
334  	}
335  	public void setDisplayNick()
336  	{
337  		if (base.isOnline() && ess.getSettings().changeDisplayName())
338  		{
339  			this.getBase().setDisplayName(getNick(true));
340  			if (ess.getSettings().changePlayerListName())
341  			{
342  				String name = getNick(false);
343  				try
344  				{
345  					this.getBase().setPlayerListName(name);
346  				}
347  				catch (IllegalArgumentException e)
348  				{
349  					if (ess.getSettings().isDebug())
350  					{
351  						logger.log(Level.INFO, "Playerlist for " + name + " was not updated. Name clashed with another online player.");
352  					}
353  				}
354  			}
355  		}
356  	}
357  	public String getDisplayName()
358  	{
359  		return super.getBase().getDisplayName() == null ? super.getBase().getName() : super.getBase().getDisplayName();
360  	}
361  	@Override
362  	public Teleport getTeleport()
363  	{
364  		return teleport;
365  	}
366  	public long getLastOnlineActivity()
367  	{
368  		return lastOnlineActivity;
369  	}
370  	public void setLastOnlineActivity(final long timestamp)
371  	{
372  		lastOnlineActivity = timestamp;
373  	}
374  	@Override
375  	public BigDecimal getMoney()
376  	{
377  		final long start = System.nanoTime();
378  		final BigDecimal value = _getMoney();
379  		final long elapsed = System.nanoTime() - start;
380  		if (elapsed > ess.getSettings().getEconomyLagWarning())
381  		{
382  			ess.getLogger().log(Level.INFO, "Lag Notice - Slow Economy Response - Request took over {0}ms!", elapsed / 1000000.0);
383  		}
384  		return value;
385  	}
386  	private BigDecimal _getMoney()
387  	{
388  		if (ess.getSettings().isEcoDisabled())
389  		{
390  			if (ess.getSettings().isDebug())
391  			{
392  				ess.getLogger().info("Internal economy functions disabled, aborting balance check.");
393  			}
394  			return BigDecimal.ZERO;
395  		}
396  		if (Methods.hasMethod())
397  		{
398  			try
399  			{
400  				final Method method = Methods.getMethod();
401  				if (!method.hasAccount(this.getName()))
402  				{
403  					throw new Exception();
404  				}
405  				final Method.MethodAccount account = Methods.getMethod().getAccount(this.getName());
406  				return BigDecimal.valueOf(account.balance());
407  			}
408  			catch (Exception ex)
409  			{
410  			}
411  		}
412  		return super.getMoney();
413  	}
414  	@Override
415  	public void setMoney(final BigDecimal value) throws MaxMoneyException
416  	{
417  		if (ess.getSettings().isEcoDisabled())
418  		{
419  			if (ess.getSettings().isDebug())
420  			{
421  				ess.getLogger().info("Internal economy functions disabled, aborting balance change.");
422  			}
423  			return;
424  		}
425  		final BigDecimal oldBalance = _getMoney();
426  		if (Methods.hasMethod())
427  		{
428  			try
429  			{
430  				final Method method = Methods.getMethod();
431  				if (!method.hasAccount(this.getName()))
432  				{
433  					throw new Exception();
434  				}
435  				final Method.MethodAccount account = Methods.getMethod().getAccount(this.getName());
436  				account.set(value.doubleValue());
437  			}
438  			catch (Exception ex)
439  			{
440  			}
441  		}
442  		super.setMoney(value, true);
443  		ess.getServer().getPluginManager().callEvent(new UserBalanceUpdateEvent(this.getBase(), oldBalance, value));
444  		Trade.log("Update", "Set", "API", getName(), new Trade(value, ess), null, null, null, ess);
445  	}
446  	public void updateMoneyCache(final BigDecimal value)
447  	{
448  		if (ess.getSettings().isEcoDisabled())
449  		{
450  			return;
451  		}
452  		if (Methods.hasMethod() && super.getMoney() != value)
453  		{
454  			try
455  			{
456  				super.setMoney(value, false);
457  			}
458  			catch (MaxMoneyException ex)
459  			{
460  			}
461  		}
462  	}
463  	@Override
464  	public void setAfk(final boolean set)
465  	{
466  		final AfkStatusChangeEvent afkEvent = new AfkStatusChangeEvent(this, set);
467  		ess.getServer().getPluginManager().callEvent(afkEvent);
468  		if (afkEvent.isCancelled())
469  		{
470  			return;
471  		}
472  		this.getBase().setSleepingIgnored(this.isAuthorized("essentials.sleepingignored") ? true : set);
473  		if (set && !isAfk())
474  		{
475  			afkPosition = this.getLocation();
476  		}
477  		else if (!set && isAfk())
478  		{
479  			afkPosition = null;
480  		}
481  		_setAfk(set);
482  	}
483  	public boolean toggleAfk()
484  	{
485  		setAfk(!isAfk());
486  		return isAfk();
487  	}
488  	@Override
489  	public boolean isHidden()
490  	{
491  		return hidden;
492  	}
493  	public boolean isHidden(final Player player)
494  	{
495  		return hidden || !player.canSee(getBase());
496  	}
497  	@Override
498  	public void setHidden(final boolean hidden)
499  	{
500  		this.hidden = hidden;
501  		if (hidden == true)
502  		{
503  			setLastLogout(getLastOnlineActivity());
504  		}
505  	}
506  	public boolean checkJailTimeout(final long currentTime)
507  	{
508  		if (getJailTimeout() > 0 && getJailTimeout() < currentTime && isJailed())
509  		{
510  			setJailTimeout(0);
511  			setJailed(false);
512  			sendMessage(tl("haveBeenReleased"));
513  			setJail(null);
514  			try
515  			{
516  				getTeleport().back();
517  			}
518  			catch (Exception ex)
519  			{
520  				try
521  				{
522  					getTeleport().respawn(null, TeleportCause.PLUGIN);
523  				}
524  				catch (Exception ex1)
525  				{
526  				}
527  			}
528  			return true;
529  		}
530  		return false;
531  	}
532  	public boolean checkMuteTimeout(final long currentTime)
533  	{
534  		if (getMuteTimeout() > 0 && getMuteTimeout() < currentTime && isMuted())
535  		{
536  			setMuteTimeout(0);
537  			sendMessage(tl("canTalkAgain"));
538  			setMuted(false);
539  			return true;
540  		}
541  		return false;
542  	}
543  	public void updateActivity(final boolean broadcast)
544  	{
545  		if (isAfk() && ess.getSettings().cancelAfkOnInteract())
546  		{
547  			setAfk(false);
548  			if (broadcast && !isHidden())
549  			{
550  				setDisplayNick();
551  				final String msg = tl("userIsNotAway", getDisplayName());
552  				if (!msg.isEmpty())
553  				{
554  					ess.broadcastMessage(this, msg);
555  				}
556  			}
557  		}
558  		lastActivity = System.currentTimeMillis();
559  	}
560  	public void checkActivity()
561  	{
562  		final long autoafkkick = ess.getSettings().getAutoAfkKick();
563  		if (autoafkkick > 0 && lastActivity > 0 && (lastActivity + (autoafkkick * 1000)) < System.currentTimeMillis()
564  			&& !isHidden() && !isAuthorized("essentials.kick.exempt") && !isAuthorized("essentials.afk.kickexempt"))
565  		{
566  			final String kickReason = tl("autoAfkKickReason", autoafkkick / 60.0);
567  			lastActivity = 0;
568  			this.getBase().kickPlayer(kickReason);
569  			for (User user : ess.getOnlineUsers())
570  			{
571  				if (user.isAuthorized("essentials.kick.notify"))
572  				{
573  					user.sendMessage(tl("playerKicked", Console.NAME, getName(), kickReason));
574  				}
575  			}
576  		}
577  		final long autoafk = ess.getSettings().getAutoAfk();
578  		if (!isAfk() && autoafk > 0 && lastActivity + autoafk * 1000 < System.currentTimeMillis() && isAuthorized("essentials.afk.auto"))
579  		{
580  			setAfk(true);
581  			if (!isHidden())
582  			{
583  				setDisplayNick();
584  				final String msg = tl("userIsAway", getDisplayName());
585  				if (!msg.isEmpty())
586  				{
587  					ess.broadcastMessage(this, msg);
588  				}
589  			}
590  		}
591  	}
592  	public Location getAfkPosition()
593  	{
594  		return afkPosition;
595  	}
596  	@Override
597  	public boolean isGodModeEnabled()
598  	{
599  		return (super.isGodModeEnabled() && !ess.getSettings().getNoGodWorlds().contains(this.getLocation().getWorld().getName()))
600  			   || (isAfk() && ess.getSettings().getFreezeAfkPlayers());
601  	}
602  	public boolean isGodModeEnabledRaw()
603  	{
604  		return super.isGodModeEnabled();
605  	}
606  	@Override
607  	public String getGroup()
608  	{
609  		final String result = ess.getPermissionsHandler().getGroup(base);
610  		if (ess.getSettings().isDebug())
611  		{
612  			ess.getLogger().log(Level.INFO, "looking up groupname of " + base.getName() + " - " + result);
613  		}
614  		return result;
615  	}
616  	@Override
617  	public boolean inGroup(final String group)
618  	{
619  		final boolean result = ess.getPermissionsHandler().inGroup(base, group);
620  		if (ess.getSettings().isDebug())
621  		{
622  			ess.getLogger().log(Level.INFO, "checking if " + base.getName() + " is in group " + group + " - " + result);
623  		}
624  		return result;
625  	}
626  	@Override
627  	public boolean canBuild()
628  	{
629  		if (this.getBase().isOp())
630  		{
631  			return true;
632  		}
633  		return ess.getPermissionsHandler().canBuild(base, getGroup());
634  	}
635  	public long getTeleportRequestTime()
636  	{
637  		return teleportRequestTime;
638  	}
639  	public boolean isInvSee()
640  	{
641  		return invSee;
642  	}
643  	public void setInvSee(final boolean set)
644  	{
645  		invSee = set;
646  	}
647  	public boolean isEnderSee()
648  	{
649  		return enderSee;
650  	}
651  	public void setEnderSee(final boolean set)
652  	{
653  		enderSee = set;
654  	}
655  	@Override
656  	public void enableInvulnerabilityAfterTeleport()
657  	{
658  		final long time = ess.getSettings().getTeleportInvulnerability();
659  		if (time > 0)
660  		{
661  			teleportInvulnerabilityTimestamp = System.currentTimeMillis() + time;
662  		}
663  	}
664  	@Override
665  	public void resetInvulnerabilityAfterTeleport()
666  	{
667  		if (teleportInvulnerabilityTimestamp != 0
668  			&& teleportInvulnerabilityTimestamp < System.currentTimeMillis())
669  		{
670  			teleportInvulnerabilityTimestamp = 0;
671  		}
672  	}
673  	@Override
674  	public boolean hasInvulnerabilityAfterTeleport()
675  	{
676  		return teleportInvulnerabilityTimestamp != 0 && teleportInvulnerabilityTimestamp >= System.currentTimeMillis();
677  	}
678  	public boolean canInteractVanished()
679  	{
680  		return isAuthorized("essentials.vanish.interact");
681  	}
682  	@Override
683  	public boolean isVanished()
684  	{
685  		return vanished;
686  	}
687  	@Override
688  	public void setVanished(final boolean set)
689  	{
690  		vanished = set;
691  		if (set)
692  		{
693  			for (User user : ess.getOnlineUsers())
694  			{
695  				if (!user.isAuthorized("essentials.vanish.see"))
696  				{
697  					user.getBase().hidePlayer(getBase());
698  				}
699  			}
700  			setHidden(true);
701  			ess.getVanishedPlayers().add(getName());
702  			if (isAuthorized("essentials.vanish.effect"))
703  			{
704  				this.getBase().addPotionEffect(new PotionEffect(PotionEffectType.INVISIBILITY, Integer.MAX_VALUE, 1, false));
705  			}
706  		}
707  		else
708  		{
709  			for (Player p : ess.getOnlinePlayers())
710  			{
711  				p.showPlayer(getBase());
712  			}
713  			setHidden(false);
714  			ess.getVanishedPlayers().remove(getName());
715  			if (isAuthorized("essentials.vanish.effect"))
716  			{
717  				this.getBase().removePotionEffect(PotionEffectType.INVISIBILITY);
718  			}
719  		}
720  	}
721  	public boolean checkSignThrottle()
722  	{
723  		if (isSignThrottled())
724  		{
725  			return true;
726  		}
727  		updateThrottle();
728  		return false;
729  	}
730  	public boolean isSignThrottled()
731  	{
732  		final long minTime = lastThrottledAction + (1000 / ess.getSettings().getSignUsePerSecond());
733  		return (System.currentTimeMillis() < minTime);
734  	}
735  	public void updateThrottle()
736  	{
737  		lastThrottledAction = System.currentTimeMillis();
738  	}
739  	public boolean isFlyClickJump()
740  	{
741  		return rightClickJump;
742  	}
743  	public void setRightClickJump(boolean rightClickJump)
744  	{
745  		this.rightClickJump = rightClickJump;
746  	}
747  	@Override
748  	public boolean isIgnoreExempt()
749  	{
750  		return this.isAuthorized("essentials.chat.ignoreexempt");
751  	}
752  	public boolean isRecipeSee()
753  	{
754  		return recipeSee;
755  	}
756  	public void setRecipeSee(boolean recipeSee)
757  	{
758  		this.recipeSee = recipeSee;
759  	}
760  	@Override
761  	public void sendMessage(String message)
762  	{
763  		if (!message.isEmpty())
764  		{
765  			base.sendMessage(message);
766  		}
767  	}
768  	@Override
769  	public void setReplyTo(final CommandSource user)
770  	{
771  		replyTo = user;
772  	}
773  	@Override
774  	public CommandSource getReplyTo()
775  	{
776  		return replyTo;
777  	}
778  	@Override
779  	public int compareTo(final User other)
780  	{
781  		return FormatUtil.stripFormat(getDisplayName()).compareToIgnoreCase(FormatUtil.stripFormat(other.getDisplayName()));
782  	}
783  	@Override
784  	public boolean equals(final Object object)
785  	{
786  		if (!(object instanceof User))
787  		{
788  			return false;
789  		}
790  		return this.getName().equalsIgnoreCase(((User)object).getName());
791  	}
792  	@Override
793  	public int hashCode()
794  	{
795  		return this.getName().hashCode();
796  	}
797  	@Override
798  	public CommandSource getSource()
799  	{
800  		return new CommandSource(getBase());
801  	}
802  	@Override
803  	public String getName()
804  	{
805  		return this.getBase().getName();
806  	}
807  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-QueryHandler.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-User_2.java</div>
                <div class="column column_space"><pre><code>84              if ( in.readableBytes() == 0 )
85              {
86                  writeString( out, listener.getMotd() ); 
87                  writeString( out, "SMP" ); 
88                  writeString( out, "BungeeCord_Proxy" ); 
89                  writeNumber( out, bungee.getOnlineCount() ); 
90                  writeNumber( out, listener.getMaxPlayers() ); 
91                  writeShort( out, listener.getHost().getPort() ); 
92                  writeString( out, listener.getHost().getHostString() ); 
93              } else if ( in.readableBytes() == 4 )
</pre></code></div>
                <div class="column column_space"><pre><code>150  		if (canAfford(value))
151  		{
152  			setMoney(getMoney().subtract(value));
153  			reciever.setMoney(reciever.getMoney().add(value));
154  			sendMessage(tl("moneySentTo", NumberUtil.displayCurrency(value, ess), reciever.getDisplayName()));
155  			reciever.sendMessage(tl("moneyRecievedFrom", NumberUtil.displayCurrency(value, ess), getDisplayName()));
156  		}
157  		else
158  		{
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    