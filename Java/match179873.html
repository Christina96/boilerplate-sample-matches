<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ExecutionSequencerTest.java & LinkedListMultimapTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ExecutionSequencerTest.java & LinkedListMultimapTest.java
      </h3>
      <h1 align="center">
        21.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ExecutionSequencerTest.java (22.37443%)<TH>LinkedListMultimapTest.java (20.704226%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#0',2,'match179873-1.html#0',3)" NAME="0">(15-39)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#0',2,'match179873-1.html#0',3)" NAME="0">(17-41)</A><TD ALIGN=center><FONT COLOR="#ff0000">23</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#1',2,'match179873-1.html#1',3)" NAME="1">(129-151)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#1',2,'match179873-1.html#1',3)" NAME="1">(324-335)</A><TD ALIGN=center><FONT COLOR="#d20000">19</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#2',2,'match179873-1.html#2',3)" NAME="2">(102-119)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#2',2,'match179873-1.html#2',3)" NAME="2">(207-218)</A><TD ALIGN=center><FONT COLOR="#c70000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#3',2,'match179873-1.html#3',3)" NAME="3">(82-92)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#3',2,'match179873-1.html#3',3)" NAME="3">(225-234)</A><TD ALIGN=center><FONT COLOR="#bc0000">17</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#4',2,'match179873-1.html#4',3)" NAME="4">(412-417)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#4',2,'match179873-1.html#4',3)" NAME="4">(248-254)</A><TD ALIGN=center><FONT COLOR="#a60000">15</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#5',2,'match179873-1.html#5',3)" NAME="5">(68-76)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#5',2,'match179873-1.html#5',3)" NAME="5">(119-127)</A><TD ALIGN=center><FONT COLOR="#9b0000">14</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#6',2,'match179873-1.html#6',3)" NAME="6">(266-273)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#6',2,'match179873-1.html#6',3)" NAME="6">(95-107)</A><TD ALIGN=center><FONT COLOR="#900000">13</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#7',2,'match179873-1.html#7',3)" NAME="7">(295-301)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#7',2,'match179873-1.html#7',3)" NAME="7">(131-136)</A><TD ALIGN=center><FONT COLOR="#6e0000">10</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#8',2,'match179873-1.html#8',3)" NAME="8">(240-245)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#8',2,'match179873-1.html#8',3)" NAME="8">(173-177)</A><TD ALIGN=center><FONT COLOR="#630000">9</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match179873-0.html#9',2,'match179873-1.html#9',3)" NAME="9">(222-226)<TD><A HREF="javascript:ZweiFrames('match179873-0.html#9',2,'match179873-1.html#9',3)" NAME="9">(161-165)</A><TD ALIGN=center><FONT COLOR="#630000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ExecutionSequencerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2018 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
<A NAME="0"></A> * the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match179873-1.html#0',3,'match179873-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.util.concurrent;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.util.concurrent.Futures.allAsList;
import static com.google.common.util.concurrent.Futures.getDone;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static java.util.concurrent.TimeUnit.SECONDS;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Function;
import com.google.common.testing.GcFinalization;
import com.google.common.testing.TestLogHandler;
import com.google.j2objc.annotations.J2ObjCIncompatible;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;
import</B></FONT> junit.framework.TestCase;

/** Tests for {@link ExecutionSequencer} */
public class ExecutionSequencerTest extends TestCase {

  ExecutorService executor;

  private ExecutionSequencer serializer;
  private SettableFuture&lt;Void&gt; firstFuture;
  private TestCallable firstCallable;

  @Override
  public void setUp() throws Exception {
    executor = Executors.newCachedThreadPool();
    serializer = ExecutionSequencer.create();
    firstFuture = SettableFuture.create();
    firstCallable = new TestCallable(firstFuture);
  }

  @Override
  public void tearDown() throws Exception {
    executor.shutdown();
  }

  public void testCallableStartsAfterFirstFutureCompletes() {
    @SuppressWarnings({&quot;unused&quot;, &quot;nullness&quot;})
<A NAME="5"></A>    Future&lt;?&gt; possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
    @SuppressWarnings({&quot;unused&quot;, &quot;nullness&quot;})
    Future&lt;?&gt; possiblyIgnoredError1 = <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match179873-1.html#5',3,'match179873-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>serializer.submitAsync(secondCallable, directExecutor());
    assertThat(firstCallable.called).isTrue();
    assertThat(secondCallable.called).isFalse();
    firstFuture.set(null);
    assertThat(secondCallable.called).isTrue();
  }

  public void testCancellationDoesNotViolateSerialization() {
    @SuppressWarnings({&quot;unused&quot;, &quot;nullness&quot;})</B></FONT>
    Future&lt;?&gt; possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
<A NAME="3"></A>    ListenableFuture&lt;Void&gt; secondFuture = serializer.submitAsync(secondCallable, directExecutor());
    TestCallable thirdCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
    @SuppressWarnings({&quot;unused&quot;, &quot;nullness&quot;})
    Future&lt;?&gt; possiblyIgnoredError1 = <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match179873-1.html#3',3,'match179873-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>serializer.submitAsync(thirdCallable, directExecutor());
    secondFuture.cancel(true);
    assertThat(secondCallable.called).isFalse();
    assertThat(thirdCallable.called).isFalse();
    firstFuture.set(null);
    assertThat(secondCallable.called).isFalse();
    assertThat(thirdCallable.called).isTrue();
  }

  public void testCancellationMultipleThreads() throws Exception {
    final BlockingCallable blockingCallable = new BlockingCallable()</B></FONT>;
    ListenableFuture&lt;Void&gt; unused = serializer.submit(blockingCallable, executor);
    ListenableFuture&lt;Boolean&gt; future2 =
        serializer.submit(
            new Callable&lt;Boolean&gt;() {
              @Override
              public Boolean call() {
<A NAME="2"></A>                return blockingCallable.isRunning();
              }
            },
            <FONT color="#980517"><A HREF="javascript:ZweiFrames('match179873-1.html#2',3,'match179873-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>directExecutor());

    // Wait for the first task to be started in the background. It will block until we explicitly
    // stop it.
    blockingCallable.waitForStart();

    // Give the second task a chance to (incorrectly) start up while the first task is running.
    assertThat(future2.isDone()).isFalse();

    // Stop the first task. The second task should then run.
    blockingCallable.stop();
    executor.shutdown();
    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
    assertThat(getDone(future2)).isFalse();
  }

  public void testSecondTaskWaitsForFirstEvenIfCancelled() throws Exception {
    final BlockingCallable blockingCallable = new BlockingCallable()</B></FONT>;
    ListenableFuture&lt;Void&gt; future1 = serializer.submit(blockingCallable, executor);
    ListenableFuture&lt;Boolean&gt; future2 =
        serializer.submit(
            new Callable&lt;Boolean&gt;() {
              @Override
              public Boolean call() {
<A NAME="1"></A>                return blockingCallable.isRunning();
              }
            },
            <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match179873-1.html#1',3,'match179873-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>directExecutor());

    // Wait for the first task to be started in the background. It will block until we explicitly
    // stop it.
    blockingCallable.waitForStart();

    // This time, cancel the future for the first task. The task remains running, only the future
    // is cancelled.
    future1.cancel(false);

    // Give the second task a chance to (incorrectly) start up while the first task is running.
    // (This is the assertion that fails.)
    assertThat(future2.isDone()).isFalse();

    // Stop the first task. The second task should then run.
    blockingCallable.stop();
    executor.shutdown();
    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
    assertThat(getDone(future2)).isFalse();
  }

  @GwtIncompatible
  @</B></FONT>J2ObjCIncompatible // gc
  @AndroidIncompatible
  public void testCancellationWithReferencedObject() throws Exception {
    Object toBeGCed = new Object();
    WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(toBeGCed);
    final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
    ListenableFuture&lt;?&gt; ignored =
        serializer.submitAsync(
            new AsyncCallable&lt;Void&gt;() {
              @Override
              public ListenableFuture&lt;Void&gt; call() {
                return settableFuture;
              }
            },
            directExecutor());
    serializer.submit(toStringCallable(toBeGCed), directExecutor()).cancel(true);
    toBeGCed = null;
    GcFinalization.awaitClear(ref);
  }

  private static Callable&lt;String&gt; toStringCallable(final Object object) {
    return new Callable&lt;String&gt;() {
      @Override
      public String call() {
        return object.toString();
      }
    };
  }

  public void testCancellationDuringReentrancy() throws Exception {
    TestLogHandler logHandler = new TestLogHandler();
    Logger.getLogger(AbstractFuture.class.getName()).addHandler(logHandler);

    List&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;&gt;();
    final Runnable[] manualExecutorTask = new Runnable[1];
    Executor manualExecutor =
        new Executor() {
          @Override
          public void execute(Runnable task) {
            manualExecutorTask[0] = task;
          }
        };

    results.add(serializer.submit(Callables.returning(null), manualExecutor));
    final Future&lt;?&gt;[] thingToCancel = new Future&lt;?&gt;[1];
    results.add(
        serializer.submit(
            new Callable&lt;Void&gt;() {
              @Override
              public Void call() {
                thingToCancel[0].cancel(false);
                return null;
              }
            },
            directExecutor()));
    thingToCancel[0] = serializer.submit(Callables.returning(null), directExecutor());
    results.add(thingToCancel[0]);
    // Enqueue more than enough tasks to force reentrancy.
    for (int i = 0; i &lt; 5; i++) {
      results.add(serializer.submit(Callables.returning(null), directExecutor()));
    }

    manualExecutorTask[0].run();

    for (Future&lt;?&gt; result : results) {
      if (!result.isCancelled()) {
        result.get(10, SECONDS);
      }
<A NAME="9"></A>      // TODO(cpovirk): Verify that the cancelled futures are exactly ones that we expect.
    }

    <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match179873-1.html#9',3,'match179873-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(logHandler.getStoredLogRecords()).isEmpty();
  }

  public void testAvoidsStackOverflow_manySubmitted() throws Exception {
    final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create</B></FONT>();
    ArrayList&lt;ListenableFuture&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;(50_001);
    results.add(
        serializer.submitAsync(
            new AsyncCallable&lt;Void&gt;() {
              @Override
              public ListenableFuture&lt;Void&gt; call() {
                return settableFuture;
              }
            },
            directExecutor()));
<A NAME="8"></A>    for (int i = 0; i &lt; 50_000; i++) {
      results.add(serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()));
    }
    <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match179873-1.html#8',3,'match179873-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>settableFuture.set(null);
    getDone(allAsList(results));
  }

  public void testAvoidsStackOverflow_manyCancelled() throws Exception {
    final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create</B></FONT>();
    ListenableFuture&lt;Void&gt; unused =
        serializer.submitAsync(
            new AsyncCallable&lt;Void&gt;() {
              @Override
              public ListenableFuture&lt;Void&gt; call() {
                return settableFuture;
              }
            },
            directExecutor());
    for (int i = 0; i &lt; 50_000; i++) {
      serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()).cancel(true);
    }
    ListenableFuture&lt;Integer&gt; stackDepthCheck =
        serializer.submit(
            new Callable&lt;Integer&gt;() {
              @Override
              public Integer call() {
<A NAME="6"></A>                return Thread.currentThread().getStackTrace().length;
              }
            },
            <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match179873-1.html#6',3,'match179873-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>directExecutor());
    settableFuture.set(null);
    assertThat(getDone(stackDepthCheck))
        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
  }

  public void testAvoidsStackOverflow_alternatingCancelledAndSubmitted() throws Exception {
    final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create</B></FONT>();
    ListenableFuture&lt;Void&gt; unused =
        serializer.submitAsync(
            new AsyncCallable&lt;Void&gt;() {
              @Override
              public ListenableFuture&lt;Void&gt; call() {
                return settableFuture;
              }
            },
            directExecutor());
    for (int i = 0; i &lt; 25_000; i++) {
      serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()).cancel(true);
      unused = serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor());
    }
    ListenableFuture&lt;Integer&gt; stackDepthCheck =
        serializer.submit(
            new Callable&lt;Integer&gt;() {
              @Override
              public Integer call() {
<A NAME="7"></A>                return Thread.currentThread().getStackTrace().length;
              }
            },
            <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match179873-1.html#7',3,'match179873-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>directExecutor());
    settableFuture.set(null);
    assertThat(getDone(stackDepthCheck))
        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
  }

  pri</B></FONT>vate static Function&lt;Integer, Integer&gt; add(final int delta) {
    return new Function&lt;Integer, Integer&gt;() {
      @Override
      public Integer apply(Integer input) {
        return input + delta;
      }
    };
  }

  private static AsyncCallable&lt;Integer&gt; asyncAdd(
      final ListenableFuture&lt;Integer&gt; future, final int delta, final Executor executor) {
    return new AsyncCallable&lt;Integer&gt;() {
      @Override
      public ListenableFuture&lt;Integer&gt; call() throws Exception {
        return Futures.transform(future, add(delta), executor);
      }
    };
  }

  private static final class LongHolder {
    long count;
  }

  private static final int ITERATION_COUNT = 50_000;
  private static final int DIRECT_EXECUTIONS_PER_THREAD = 100;

  @GwtIncompatible // threads
  public void testAvoidsStackOverflow_multipleThreads() throws Exception {
    final LongHolder holder = new LongHolder();
    final ArrayList&lt;ListenableFuture&lt;Integer&gt;&gt; lengthChecks = new ArrayList&lt;&gt;();
    final List&lt;Integer&gt; completeLengthChecks;
    final int baseStackDepth;
    ExecutorService service = Executors.newFixedThreadPool(5);
    try {
      // Avoid counting frames from the executor itself, or the ExecutionSequencer
      baseStackDepth =
          serializer
              .submit(
                  new Callable&lt;Integer&gt;() {
                    @Override
                    public Integer call() {
                      return Thread.currentThread().getStackTrace().length;
                    }
                  },
                  service)
              .get();
      final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
      ListenableFuture&lt;?&gt; unused =
          serializer.submitAsync(
              new AsyncCallable&lt;Void&gt;() {
                @Override
                public ListenableFuture&lt;Void&gt; call() {
                  return settableFuture;
                }
              },
              directExecutor());
      for (int i = 0; i &lt; 50_000; i++) {
        if (i % DIRECT_EXECUTIONS_PER_THREAD == 0) {
          // after some number of iterations, switch threads
          unused =
              serializer.submit(
                  new Callable&lt;Void&gt;() {
                    @Override
                    public Void call() {
                      holder.count++;
                      return null;
                    }
                  },
                  service);
        } else if (i % DIRECT_EXECUTIONS_PER_THREAD == DIRECT_EXECUTIONS_PER_THREAD - 1) {
          // When at max depth, record stack trace depth
          lengthChecks.add(
              serializer.submit(
                  new Callable&lt;Integer&gt;() {
                    @Override
                    public Integer call() {
                      holder.count++;
                      return Thread.currentThread().getStackTrace().length;
                    }
                  },
                  directExecutor()));
        } else {
          // Otherwise, schedule a task on directExecutor
          unused =
              serializer.submit(
                  new Callable&lt;Void&gt;() {
                    @Override
                    public Void call() {
                      holder.count++;
                      return null;
                    }
                  },
                  directExecutor());
        }
      }
      settableFuture.set(null);
      completeLengthChecks = allAsList(lengthChecks).get();
    } finally {
      service.shutdown();
    }
    assertThat(holder.count).isEqualTo(ITERATION_COUNT);
    for (int length : completeLengthChecks) {
      // Verify that at max depth, less than one stack frame per submitted task was consumed
      assertThat(length - baseStackDepth).isLessThan(DIRECT_EXECUTIONS_PER_THREAD / 2);
    }
  }

  @SuppressWarnings(&quot;ObjectToString&quot;) // Intended behavior
<A NAME="4"></A>  public void testToString() {
    Future&lt;?&gt; unused = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(SettableFuture.&lt;Void&gt;create());
    Future&lt;?&gt; second = <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match179873-1.html#4',3,'match179873-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>serializer.submitAsync(secondCallable, directExecutor());
    assertThat(secondCallable.called).isFalse();
    assertThat(second.toString()).contains(secondCallable.toString());
    firstFuture.set(null);
    assertThat(second.toString()).contains(secondCallable.future.toString());
  }</B></FONT>

  private static class BlockingCallable implements Callable&lt;Void&gt; {
    private final CountDownLatch startLatch = new CountDownLatch(1);
    private final CountDownLatch stopLatch = new CountDownLatch(1);

    private volatile boolean running = false;

    @Override
    public Void call() throws InterruptedException {
      running = true;
      startLatch.countDown();
      stopLatch.await();
      running = false;
      return null;
    }

    public void waitForStart() throws InterruptedException {
      startLatch.await();
    }

    public void stop() {
      stopLatch.countDown();
    }

    public boolean isRunning() {
      return running;
    }
  }

  private static final class TestCallable implements AsyncCallable&lt;Void&gt; {

    private final ListenableFuture&lt;Void&gt; future;
    private boolean called = false;

    private TestCallable(ListenableFuture&lt;Void&gt; future) {
      this.future = future;
    }

    @Override
    public ListenableFuture&lt;Void&gt; call() throws Exception {
      called = true;
      return future;
    }
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>LinkedListMultimapTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="0"></A> * limitations under the License.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#0',2,'match179873-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.collect;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;
import static com.google.common.collect.Sets.newLinkedHashSet;
import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
import static com.google.common.collect.testing.IteratorFeature.SUPPORTS_REMOVE;
import static com.google.common.collect.testing.IteratorFeature.SUPPORTS_SET;
import static com.google.common.truth.Truth.assertThat;
import static java.util.Arrays.asList;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.testing.IteratorTester;
import com.google.common.collect.testing.ListIteratorTester;
import com.google.common.collect.testing.features.CollectionFeature;
import com.google.common.collect.testing.features.CollectionSize;
import com.google.common.collect.testing.features.MapFeature;
import com.google.common.collect.testing.google.ListMultimapTestSuiteBuilder;
import com.google.common.collect.testing.google.TestStringListMultimapGenerator;
import com.google.common.testing.EqualsTester;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import</B></FONT> java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map.Entry;
import java.util.RandomAccess;
import java.util.Set;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

/**
 * Tests for {@code LinkedListMultimap}.
 *
 * @author Mike Bostock
 */
@GwtCompatible(emulated = true)
public class LinkedListMultimapTest extends TestCase {

  @GwtIncompatible // suite
  public static Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(
        ListMultimapTestSuiteBuilder.using(
                new TestStringListMultimapGenerator() {
                  @Override
                  protected ListMultimap&lt;String, String&gt; create(Entry&lt;String, String&gt;[] entries) {
                    ListMultimap&lt;String, String&gt; multimap = LinkedListMultimap.create();
                    for (Entry&lt;String, String&gt; entry : entries) {
                      multimap.put(entry.getKey(), entry.getValue());
                    }
                    return multimap;
                  }
                })
            .named(&quot;LinkedListMultimap&quot;)
            .withFeatures(
                MapFeature.ALLOWS_NULL_KEYS,
                MapFeature.ALLOWS_NULL_VALUES,
                MapFeature.ALLOWS_ANY_NULL_QUERIES,
                MapFeature.GENERAL_PURPOSE,
                CollectionFeature.SUPPORTS_ITERATOR_REMOVE,
                CollectionFeature.SERIALIZABLE,
                CollectionFeature.KNOWN_ORDER,
                CollectionSize.ANY)
            .createTestSuite());
    suite.addTestSuite(LinkedListMultimapTest.class);
    return suite;
  }

  protected LinkedListMultimap&lt;String, Integer&gt; create() {
    return LinkedListMultimap.create();
  }
<A NAME="6"></A>
  /** Confirm that get() returns a List that doesn't implement RandomAccess. */
  public void testGetRandomAccess() {
    Multimap&lt;String, Integer&gt; multimap = <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#6',2,'match179873-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>create();
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;foo&quot;, 3);
    assertFalse(multimap.get(&quot;foo&quot;) instanceof RandomAccess);
    assertFalse(multimap.get(&quot;bar&quot;) instanceof RandomAccess);
  }

  /**
   * Confirm that removeAll() returns a List that implements RandomAccess, even though get()
   * doesn't.
   */
  public void testRemoveAllRandomAccess() {
    Multimap&lt;String, Integer&gt; multimap = create</B></FONT>();
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;foo&quot;, 3);
    assertTrue(multimap.removeAll(&quot;foo&quot;) instanceof RandomAccess);
    assertTrue(multimap.removeAll(&quot;bar&quot;) instanceof RandomAccess);
  }

  /**
   * Confirm that replaceValues() returns a List that implements RandomAccess, even though get()
<A NAME="5"></A>   * doesn't.
   */
  public void testReplaceValuesRandomAccess() {
    Multimap&lt;String, Integer&gt; multimap = <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#5',2,'match179873-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>create();
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;foo&quot;, 3);
    assertTrue(multimap.replaceValues(&quot;foo&quot;, Arrays.asList(2, 4)) instanceof RandomAccess);
    assertTrue(multimap.replaceValues(&quot;bar&quot;, Arrays.asList(2, 4)) instanceof RandomAccess);
  }

  public void testCreateFromMultimap() {
    Multimap&lt;String, Integer&gt; multimap = LinkedListMultimap.create()</B></FONT>;
<A NAME="7"></A>    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;bar&quot;, 3);
    multimap.put(&quot;foo&quot;, 2);
    LinkedListMultimap&lt;String, Integer&gt; copy = <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#7',2,'match179873-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>LinkedListMultimap.create(multimap);
    assertEquals(multimap, copy);
    assertThat(copy.entries()).containsExactlyElementsIn(multimap.entries()).inOrder();
  }

  public void testCr</B></FONT>eateFromSize() {
    LinkedListMultimap&lt;String, Integer&gt; multimap = LinkedListMultimap.create(20);
    multimap.put(&quot;foo&quot;, 1);
    multimap.put(&quot;bar&quot;, 2);
    multimap.put(&quot;foo&quot;, 3);
    assertEquals(ImmutableList.of(1, 3), multimap.get(&quot;foo&quot;));
  }

  public void testCreateFromIllegalSize() {
    try {
      LinkedListMultimap.create(-20);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }

  public void testLinkedGetAdd() {
    LinkedListMultimap&lt;String, Integer&gt; map = create();
    map.put(&quot;bar&quot;, 1);
    Collection&lt;Integer&gt; foos = map.get(&quot;foo&quot;);
    foos.add(2);
    foos.add(3);
<A NAME="9"></A>    map.put(&quot;bar&quot;, 4);
    map.put(&quot;foo&quot;, 5);
    assertEquals(&quot;{bar=[1, 4], foo=[2, 3, 5]}&quot;, map.toString());
    <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#9',2,'match179873-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(&quot;[bar=1, foo=2, foo=3, bar=4, foo=5]&quot;, map.entries().toString());
  }

  public void testLinkedGetInsert() {
    ListMultimap&lt;String, Integer&gt; map = create</B></FONT>();
    map.put(&quot;bar&quot;, 1);
    List&lt;Integer&gt; foos = map.get(&quot;foo&quot;);
    foos.add(2);
    foos.add(0, 3);
<A NAME="8"></A>    map.put(&quot;bar&quot;, 4);
    map.put(&quot;foo&quot;, 5);
    assertEquals(&quot;{bar=[1, 4], foo=[3, 2, 5]}&quot;, map.toString());
    <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#8',2,'match179873-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(&quot;[bar=1, foo=3, foo=2, bar=4, foo=5]&quot;, map.entries().toString());
  }

  public void testLinkedPutInOrder() {
    Multimap&lt;String, Integer&gt; map = create</B></FONT>();
    map.put(&quot;foo&quot;, 1);
    map.put(&quot;bar&quot;, 2);
    map.put(&quot;bar&quot;, 3);
    assertEquals(&quot;{foo=[1], bar=[2, 3]}&quot;, map.toString());
    assertEquals(&quot;[foo=1, bar=2, bar=3]&quot;, map.entries().toString());
  }

  public void testLinkedPutOutOfOrder() {
    Multimap&lt;String, Integer&gt; map = create();
    map.put(&quot;bar&quot;, 1);
    map.put(&quot;foo&quot;, 2);
    map.put(&quot;bar&quot;, 3);
    assertEquals(&quot;{bar=[1, 3], foo=[2]}&quot;, map.toString());
    assertEquals(&quot;[bar=1, foo=2, bar=3]&quot;, map.entries().toString());
  }

  public void testLinkedPutAllMultimap() {
    Multimap&lt;String, Integer&gt; src = create();
    src.put(&quot;bar&quot;, 1);
    src.put(&quot;foo&quot;, 2);
    src.put(&quot;bar&quot;, 3);
    Multimap&lt;String, Integer&gt; dst = create();
    dst.putAll(src);
    assertEquals(&quot;{bar=[1, 3], foo=[2]}&quot;, dst.toString());
    assertEquals(&quot;[bar=1, foo=2, bar=3]&quot;, src.entries().toString());
  }
<A NAME="2"></A>
  public void testLinkedReplaceValues() {
    Multimap&lt;String, Integer&gt; map = create();
    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#2',2,'match179873-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.put(&quot;bar&quot;, 1);
    map.put(&quot;foo&quot;, 2);
    map.put(&quot;bar&quot;, 3);
    map.put(&quot;bar&quot;, 4);
    assertEquals(&quot;{bar=[1, 3, 4], foo=[2]}&quot;, map.toString());
    map.replaceValues(&quot;bar&quot;, asList(1, 2));
    assertEquals(&quot;[bar=1, foo=2, bar=2]&quot;, map.entries().toString());
    assertEquals(&quot;{bar=[1, 2], foo=[2]}&quot;, map.toString());
  }

  public void testLinkedClear() {
    ListMultimap&lt;String, Integer&gt; map = create()</B></FONT>;
    map.put(&quot;foo&quot;, 1);
    map.put(&quot;foo&quot;, 2);
    map.put(&quot;bar&quot;, 3);
<A NAME="3"></A>    List&lt;Integer&gt; foos = map.get(&quot;foo&quot;);
    Collection&lt;Integer&gt; values = map.values();
    assertEquals(asList(1, 2), foos);
    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#3',2,'match179873-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(values).containsExactly(1, 2, 3).inOrder();
    map.clear();
    assertEquals(Collections.emptyList(), foos);
    assertThat(values).isEmpty();
    assertEquals(&quot;[]&quot;, map.entries().toString());
    assertEquals(&quot;{}&quot;, map.toString());
  }

  public void testLinkedKeySet() {
    Multimap&lt;String, Integer&gt; map = create()</B></FONT>;
    map.put(&quot;bar&quot;, 1);
    map.put(&quot;foo&quot;, 2);
    map.put(&quot;bar&quot;, 3);
    map.put(&quot;bar&quot;, 4);
    assertEquals(&quot;[bar, foo]&quot;, map.keySet().toString());
    map.keySet().remove(&quot;bar&quot;);
    assertEquals(&quot;{foo=[2]}&quot;, map.toString());
  }

  public void testLinkedKeys() {
<A NAME="4"></A>    Multimap&lt;String, Integer&gt; map = create();
    map.put(&quot;bar&quot;, 1);
    map.put(&quot;foo&quot;, 2);
    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#4',2,'match179873-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>map.put(&quot;bar&quot;, 3);
    map.put(&quot;bar&quot;, 4);
    assertEquals(&quot;[bar=1, foo=2, bar=3, bar=4]&quot;, map.entries().toString());
    assertThat(map.keys()).containsExactly(&quot;bar&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;bar&quot;).inOrder();
    map.keys().remove(&quot;bar&quot;); // bar is no longer the first key!
    assertEquals(&quot;{foo=[2], bar=[3, 4]}&quot;, map.toString());
  }</B></FONT>

  public void testLinkedValues() {
    Multimap&lt;String, Integer&gt; map = create();
    map.put(&quot;bar&quot;, 1);
    map.put(&quot;foo&quot;, 2);
    map.put(&quot;bar&quot;, 3);
    map.put(&quot;bar&quot;, 4);
    assertEquals(&quot;[1, 2, 3, 4]&quot;, map.values().toString());
    map.values().remove(2);
    assertEquals(&quot;{bar=[1, 3, 4]}&quot;, map.toString());
  }

  public void testLinkedEntries() {
    Multimap&lt;String, Integer&gt; map = create();
    map.put(&quot;bar&quot;, 1);
    map.put(&quot;foo&quot;, 2);
    map.put(&quot;bar&quot;, 3);
    Iterator&lt;Entry&lt;String, Integer&gt;&gt; entries = map.entries().iterator();
    Entry&lt;String, Integer&gt; entry = entries.next();
    assertEquals(&quot;bar&quot;, entry.getKey());
    assertEquals(1, (int) entry.getValue());
    entry = entries.next();
    assertEquals(&quot;foo&quot;, entry.getKey());
    assertEquals(2, (int) entry.getValue());
    entry.setValue(4);
    entry = entries.next();
    assertEquals(&quot;bar&quot;, entry.getKey());
    assertEquals(3, (int) entry.getValue());
    assertFalse(entries.hasNext());
    entries.remove();
    assertEquals(&quot;{bar=[1], foo=[4]}&quot;, map.toString());
  }

  public void testLinkedAsMapEntries() {
    Multimap&lt;String, Integer&gt; map = create();
    map.put(&quot;bar&quot;, 1);
    map.put(&quot;foo&quot;, 2);
    map.put(&quot;bar&quot;, 3);
    Iterator&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt; entries = map.asMap().entrySet().iterator();
    Entry&lt;String, Collection&lt;Integer&gt;&gt; entry = entries.next();
    assertEquals(&quot;bar&quot;, entry.getKey());
    assertThat(entry.getValue()).containsExactly(1, 3).inOrder();
    try {
      entry.setValue(Arrays.&lt;Integer&gt;asList());
      fail(&quot;UnsupportedOperationException expected&quot;);
    } catch (UnsupportedOperationException expected) {
    }
    entries.remove(); // clear
    entry = entries.next();
    assertEquals(&quot;foo&quot;, entry.getKey());
    assertThat(entry.getValue()).contains(2);
    assertFalse(entries.hasNext());
    assertEquals(&quot;{foo=[2]}&quot;, map.toString());
  }

  public void testEntriesAfterMultimapUpdate() {
    ListMultimap&lt;String, Integer&gt; multimap = create();
    multimap.put(&quot;foo&quot;, 2);
    multimap.put(&quot;bar&quot;, 3);
    Collection&lt;Entry&lt;String, Integer&gt;&gt; entries = multimap.entries();
    Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator();
    Entry&lt;String, Integer&gt; entrya = iterator.next();
    Entry&lt;String, Integer&gt; entryb = iterator.next();

    assertEquals(2, (int) multimap.get(&quot;foo&quot;).set(0, 4));
    assertFalse(multimap.containsEntry(&quot;foo&quot;, 2));
<A NAME="1"></A>    assertTrue(multimap.containsEntry(&quot;foo&quot;, 4));
    assertTrue(multimap.containsEntry(&quot;bar&quot;, 3));
    assertEquals(4, (int) entrya.getValue());
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match179873-0.html#1',2,'match179873-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(3, (int) entryb.getValue());

    assertTrue(multimap.put(&quot;foo&quot;, 5));
    assertTrue(multimap.containsEntry(&quot;foo&quot;, 5));
    assertTrue(multimap.containsEntry(&quot;foo&quot;, 4));
    assertTrue(multimap.containsEntry(&quot;bar&quot;, 3));
    assertEquals(4, (int) entrya.getValue());
    assertEquals(3, (int) entryb.getValue());
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @</B></FONT>GwtIncompatible // unreasonably slow
  public void testEntriesIteration() {
    List&lt;Entry&lt;String, Integer&gt;&gt; addItems =
        ImmutableList.of(
            Maps.immutableEntry(&quot;foo&quot;, 99),
            Maps.immutableEntry(&quot;foo&quot;, 88),
            Maps.immutableEntry(&quot;bar&quot;, 77));

    for (final int startIndex : new int[] {0, 3, 5}) {
      List&lt;Entry&lt;String, Integer&gt;&gt; list =
          Lists.newArrayList(
              Maps.immutableEntry(&quot;foo&quot;, 2),
              Maps.immutableEntry(&quot;foo&quot;, 3),
              Maps.immutableEntry(&quot;bar&quot;, 4),
              Maps.immutableEntry(&quot;bar&quot;, 5),
              Maps.immutableEntry(&quot;foo&quot;, 6));
      new ListIteratorTester&lt;Entry&lt;String, Integer&gt;&gt;(
          3, addItems, ImmutableList.of(SUPPORTS_REMOVE), list, startIndex) {
        private LinkedListMultimap&lt;String, Integer&gt; multimap;

        @Override
        protected ListIterator&lt;Entry&lt;String, Integer&gt;&gt; newTargetIterator() {
          multimap = create();
          multimap.putAll(&quot;foo&quot;, asList(2, 3));
          multimap.putAll(&quot;bar&quot;, asList(4, 5));
          multimap.put(&quot;foo&quot;, 6);
          return multimap.entries().listIterator(startIndex);
        }

        @Override
        protected void verify(List&lt;Entry&lt;String, Integer&gt;&gt; elements) {
          assertEquals(elements, multimap.entries());
        }
      }.test();
    }
  }

  @GwtIncompatible // unreasonably slow
  public void testKeysIteration() {
    new IteratorTester&lt;String&gt;(
        6,
        MODIFIABLE,
        newArrayList(&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;foo&quot;),
        IteratorTester.KnownOrder.KNOWN_ORDER) {
      private Multimap&lt;String, Integer&gt; multimap;

      @Override
      protected Iterator&lt;String&gt; newTargetIterator() {
        multimap = create();
        multimap.putAll(&quot;foo&quot;, asList(2, 3));
        multimap.putAll(&quot;bar&quot;, asList(4, 5));
        multimap.putAll(&quot;foo&quot;, asList(6));
        return multimap.keys().iterator();
      }

      @Override
      protected void verify(List&lt;String&gt; elements) {
        assertEquals(elements, Lists.newArrayList(multimap.keys()));
      }
    }.test();
  }

  @GwtIncompatible // unreasonably slow
  public void testValuesIteration() {
    List&lt;Integer&gt; addItems = ImmutableList.of(99, 88, 77);

    for (final int startIndex : new int[] {0, 3, 5}) {
      new ListIteratorTester&lt;Integer&gt;(
          3,
          addItems,
          ImmutableList.of(SUPPORTS_REMOVE, SUPPORTS_SET),
          Lists.newArrayList(2, 3, 4, 5, 6),
          startIndex) {
        private LinkedListMultimap&lt;String, Integer&gt; multimap;

        @Override
        protected ListIterator&lt;Integer&gt; newTargetIterator() {
          multimap = create();
          multimap.put(&quot;bar&quot;, 2);
          multimap.putAll(&quot;foo&quot;, Arrays.asList(3, 4));
          multimap.put(&quot;bar&quot;, 5);
          multimap.put(&quot;foo&quot;, 6);
          return multimap.values().listIterator(startIndex);
        }

        @Override
        protected void verify(List&lt;Integer&gt; elements) {
          assertEquals(elements, multimap.values());
        }
      }.test();
    }
  }

  @GwtIncompatible // unreasonably slow
  public void testKeySetIteration() {
    new IteratorTester&lt;String&gt;(
        6,
        MODIFIABLE,
        newLinkedHashSet(asList(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;dog&quot;, &quot;cat&quot;)),
        IteratorTester.KnownOrder.KNOWN_ORDER) {
      private Multimap&lt;String, Integer&gt; multimap;

      @Override
      protected Iterator&lt;String&gt; newTargetIterator() {
        multimap = create();
        multimap.putAll(&quot;foo&quot;, asList(2, 3));
        multimap.putAll(&quot;bar&quot;, asList(4, 5));
        multimap.putAll(&quot;foo&quot;, asList(6));
        multimap.putAll(&quot;baz&quot;, asList(7, 8));
        multimap.putAll(&quot;dog&quot;, asList(9));
        multimap.putAll(&quot;bar&quot;, asList(10, 11));
        multimap.putAll(&quot;cat&quot;, asList(12, 13, 14));
        return multimap.keySet().iterator();
      }

      @Override
      protected void verify(List&lt;String&gt; elements) {
        assertEquals(newHashSet(elements), multimap.keySet());
      }
    }.test();
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @GwtIncompatible // unreasonably slow
  public void testAsSetIteration() {
    Set&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt; set =
        Sets.newLinkedHashSet(
            asList(
                Maps.immutableEntry(&quot;foo&quot;, (Collection&lt;Integer&gt;) asList(2, 3, 6)),
                Maps.immutableEntry(&quot;bar&quot;, (Collection&lt;Integer&gt;) asList(4, 5, 10, 11)),
                Maps.immutableEntry(&quot;baz&quot;, (Collection&lt;Integer&gt;) asList(7, 8)),
                Maps.immutableEntry(&quot;dog&quot;, (Collection&lt;Integer&gt;) asList(9)),
                Maps.immutableEntry(&quot;cat&quot;, (Collection&lt;Integer&gt;) asList(12, 13, 14))));

    new IteratorTester&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt;(
        6, MODIFIABLE, set, IteratorTester.KnownOrder.KNOWN_ORDER) {
      private Multimap&lt;String, Integer&gt; multimap;

      @Override
      protected Iterator&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt; newTargetIterator() {
        multimap = create();
        multimap.putAll(&quot;foo&quot;, asList(2, 3));
        multimap.putAll(&quot;bar&quot;, asList(4, 5));
        multimap.putAll(&quot;foo&quot;, asList(6));
        multimap.putAll(&quot;baz&quot;, asList(7, 8));
        multimap.putAll(&quot;dog&quot;, asList(9));
        multimap.putAll(&quot;bar&quot;, asList(10, 11));
        multimap.putAll(&quot;cat&quot;, asList(12, 13, 14));
        return multimap.asMap().entrySet().iterator();
      }

      @Override
      protected void verify(List&lt;Entry&lt;String, Collection&lt;Integer&gt;&gt;&gt; elements) {
        assertEquals(newHashSet(elements), multimap.asMap().entrySet());
      }
    }.test();
  }

  public void testEquals() {
    new EqualsTester()
        .addEqualityGroup(
            LinkedListMultimap.create(), LinkedListMultimap.create(), LinkedListMultimap.create(1))
        .testEquals();
  }
}
</PRE>
</div>
  </div>
</body>
</html>
