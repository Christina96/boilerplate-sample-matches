
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-SimpleSerialization.java</h3>
            <pre><code>1  package com.weibo.api.motan.serialize;
2  import com.weibo.api.motan.codec.Serialization;
3  import com.weibo.api.motan.core.extension.SpiMeta;
4  import com.weibo.api.motan.exception.MotanServiceException;
5  import com.weibo.api.motan.protocol.v2motan.GrowableByteBuffer;
6  import java.io.IOException;
7  import java.nio.ByteBuffer;
8  import java.util.*;
9  import static com.weibo.api.motan.serialize.SimpleSerialization.SimpleType.*;
10  @SpiMeta(name = &quot;simple&quot;)
11  public class SimpleSerialization implements Serialization {
12      public static final class SimpleType {
13          public static final byte NULL = 0;
14          public static final byte STRING = 1;
15          public static final byte STRING_MAP = 2;
16          public static final byte BYTE_ARRAY = 3;
17          public static final byte STRING_ARRAY = 4;
18          public static final byte BOOL = 5;
19          public static final byte BYTE = 6;
20          public static final byte INT16 = 7;
21          public static final byte INT32 = 8;
22          public static final byte INT64 = 9;
23          public static final byte FLOAT32 = 10;
24          public static final byte FLOAT64 = 11;
25          public static final byte MAP = 20;
26          public static final byte ARRAY = 21;
27      }
28      private static final int DEFAULT_MAP_SIZE = 16;
29      private static final int DEFAULT_ARRAY_SIZE = 16;
30      public static boolean isStringCollection(Collection&lt;?&gt; obj) {
31          if (obj.isEmpty()) {
32              return false;
33          }
34          for (Object v : obj) {
35              if (v == null) {
36                  continue;
37              }
38              if (!(v instanceof String)) {
39                  return false;
40              }
41          }
42          return true;
43      }
44      public static boolean isStringMap(Map&lt;?, ?&gt; obj) {
45          if (obj.isEmpty()) {
46              return false;
47          }
48          for (Map.Entry&lt;?, ?&gt; entry : obj.entrySet()) {
49              if (entry.getKey() == null || entry.getValue() == null) {
50                  continue;
51              }
52              if (!(entry.getKey() instanceof String) || !(entry.getValue() instanceof String)) {
53                  return false;
54              }
55          }
56          return true;
57      }
58      @Override
59      public byte[] serialize(Object obj) throws IOException {
60          GrowableByteBuffer buffer = new GrowableByteBuffer(4096);
61          serialize(obj, buffer);
62          buffer.flip();
63          byte[] result = new byte[buffer.remaining()];
64          buffer.get(result);
65          return result;
66      }
67      private void serialize(Object obj, GrowableByteBuffer buffer) throws IOException {
68          if (obj == null) {
69              buffer.put(NULL);
70              return;
71          }
72          Class&lt;?&gt; clz = obj.getClass();
73          if (clz == String.class) {
74              writeString(buffer, (String) obj);
75              return;
76          }
77          if (clz == Byte.class || clz == byte.class) {
78              writeByte(buffer, (Byte) obj);
79              return;
80          }
81          if (clz == Boolean.class || clz == boolean.class) {
82              writeBool(buffer, (Boolean) obj);
83              return;
84          }
85          if (clz == Short.class || clz == short.class) {
86              writeInt16(buffer, (Short) obj);
87              return;
88          }
89          if (clz == Integer.class || clz == int.class) {
90              writeInt32(buffer, (Integer) obj);
91              return;
92          }
93          if (clz == Long.class || clz == long.class) {
94              writeInt64(buffer, (Long) obj);
95              return;
96          }
97          if (clz == Float.class || clz == float.class) {
98              writeFloat32(buffer, (Float) obj);
99              return;
100          }
101          if (clz == Double.class || clz == double.class) {
102              writeFloat64(buffer, (Double) obj);
103              return;
104          }
105          if (obj instanceof Map) {
106              if (isStringMap((Map) obj)) {
107                  writeStringMap(buffer, (Map&lt;String, String&gt;) obj);
108              } else {
109                  writeMap(buffer, (Map) obj);
110              }
111              return;
112          }
113          if (clz.isArray()) {
114              if (clz.getComponentType() == String.class) {
115                  writeStringArray(buffer, (String[]) obj);
116              } else if (clz.getComponentType() == byte.class) {
117                  writeBytes(buffer, (byte[]) obj);
118              } else {
119                  writeArray(buffer, (Object[]) obj);
120              }
121              return;
122          }
123          if (obj instanceof List || obj instanceof Set) {
124              if (isStringCollection((Collection) obj)) {
125                  writeStringArray(buffer, (Collection&lt;String&gt;) obj);
126              } else {
127                  writeArray(buffer, (Collection) obj);
128              }
129              return;
130          }
131          throw new MotanServiceException(&quot;SimpleSerialization unsupported type: &quot; + clz);
132      }
133      @Override
134      public &lt;T&gt; T deserialize(byte[] bytes, Class&lt;T&gt; clz) throws IOException {
135          GrowableByteBuffer buffer = new GrowableByteBuffer(ByteBuffer.wrap(bytes));
136          return deserialize(buffer, clz);
137      }
138      private &lt;T&gt; T deserialize(GrowableByteBuffer buffer, Class&lt;T&gt; clz) throws IOException {
139          byte type = buffer.get();
140          switch (type) {
141              default:
142                  break;
143              case NULL:
144                  return null;
145              case STRING:
146                  if (clz == String.class || clz == Object.class) {
147                      return (T) readString(buffer);
148                  }
149                  break;
150              case STRING_MAP:
151                  if (clz.isAssignableFrom(HashMap.class)) {
152                      return (T) readStringMap(buffer);
153                  }
154                  break;
155              case BYTE_ARRAY:
156                  if (clz == byte[].class || clz == Object.class) {
157                      return (T) readBytes(buffer);
158                  }
159                  break;
160              case STRING_ARRAY:
161                  if ((clz.isArray() &amp;&amp; clz.getComponentType() == String.class)) {
162                      return (T) readStringArray(buffer);
163                  } else if (clz.isAssignableFrom(ArrayList.class)) {
164                      return (T) readStringList(buffer);
165                  } else if (clz.isAssignableFrom(HashSet.class)) {
166                      return (T) readStringSet(buffer);
167                  }
168                  break;
169              case BOOL:
170                  if (clz == boolean.class || clz == Boolean.class || clz == Object.class) {
171                      return (T) readBool(buffer);
172                  }
173                  break;
174              case BYTE:
175                  if (clz == byte.class || clz == Byte.class || clz == Object.class) {
176                      return (T) readByte(buffer);
177                  }
178              case INT16:
179                  if (clz == short.class || clz == Short.class || clz == Object.class) {
180                      return (T) readInt16(buffer);
181                  }
182                  break;
183              case INT32:
184                  if (clz == int.class || clz == Integer.class || clz == Object.class) {
185                      return (T) readInt32(buffer);
186                  }
187                  break;
188              case INT64:
189                  if (clz == long.class || clz == Long.class || clz == Object.class) {
190                      return (T) readInt64(buffer);
191                  }
192                  break;
193              case FLOAT32:
194                  if (clz == float.class || clz == Float.class || clz == Object.class) {
195                      return (T) readFloat32(buffer);
196                  }
197                  break;
198              case FLOAT64:
199                  if (clz == double.class || clz == Double.class || clz == Object.class) {
200                      return (T) readFloat64(buffer);
201                  }
202                  break;
203              case MAP:
204                  if (clz.isAssignableFrom(HashMap.class)) {
205                      return (T) readMap(buffer);
206                  }
207                  break;
208              case ARRAY:
209                  if (clz.isArray()) {
210                      return (T) readArray(buffer);
211                  } else if (clz.isAssignableFrom(ArrayList.class)) {
212                      return (T) readList(buffer);
213                  } else if (clz.isAssignableFrom(HashSet.class)) {
214                      return (T) readSet(buffer);
215                  }
216                  break;
217          }
218          throw new MotanServiceException(&quot;SimpleSerialization not support &quot; + type + &quot; with receiver type:&quot; + clz);
219      }
220      @Override
221      public byte[] serializeMulti(Object[] data) throws IOException {
222          GrowableByteBuffer buffer = new GrowableByteBuffer(4096);
223          for (Object o : data) {
224              serialize(o, buffer);
225          }
226          buffer.flip();
227          byte[] result = new byte[buffer.remaining()];
228          buffer.get(result);
229          return result;
230      }
231      @Override
232      public Object[] deserializeMulti(byte[] data, Class&lt;?&gt;[] classes) throws IOException {
233          GrowableByteBuffer buffer = new GrowableByteBuffer(ByteBuffer.wrap(data));
234          Object[] result = new Object[classes.length];
235          for (int i = 0; i &lt; classes.length; i++) {
236              result[i] = deserialize(buffer, classes[i]);
237          }
238          return result;
239      }
240      @Override
241      public int getSerializationNumber() {
242          return 6;
243      }
244      private void putString(GrowableByteBuffer buffer, String str) throws IOException {
245          byte[] b = str.getBytes(&quot;UTF-8&quot;);
246          buffer.putInt(b.length);
247          buffer.put(b);
248      }
249      private void writeString(GrowableByteBuffer buffer, String str) throws IOException {
250          buffer.put(STRING);
251          putString(buffer, str);
252      }
253      private void writeStringMap(GrowableByteBuffer buffer, Map&lt;String, String&gt; value) throws IOException {
254          buffer.put(STRING_MAP);
255          int pos = buffer.position();
256          buffer.position(pos + 4);
257          for (Map.Entry&lt;String, String&gt; entry : value.entrySet()) {
258              if (entry.getKey() == null || entry.getValue() == null) {
259                  continue;
260              }
261              putString(buffer, entry.getKey());
262              putString(buffer, entry.getValue());
263          }
264          int npos = buffer.position();
265          buffer.position(pos);
266          buffer.putInt(npos - pos - 4);
267          buffer.position(npos);
268      }
269      private void writeBytes(GrowableByteBuffer buffer, byte[] value) {
270          buffer.put(BYTE_ARRAY);
271          buffer.putInt(value.length);
272          buffer.put(value);
273      }
274      private void writeStringArray(GrowableByteBuffer buffer, String[] value) throws IOException {
275          buffer.put(STRING_ARRAY);
276          int pos = buffer.position();
277          buffer.position(pos + 4);
278          for (int i = 0; i &lt; value.length; i++) {
279              if (value[i] == null) {
280                  continue;
281              }
282              putString(buffer, value[i]);
283          }
284          int npos = buffer.position();
285          buffer.position(pos);
286          buffer.putInt(npos - pos - 4);
287          buffer.position(npos);
288      }
289      private void writeStringArray(GrowableByteBuffer buffer, Collection&lt;String&gt; value) throws IOException {
290          buffer.put(STRING_ARRAY);
291          int pos = buffer.position();
292          buffer.position(pos + 4);
293          for (String s : value) {
294              if (s == null) {
295                  continue;
296              }
297              putString(buffer, s);
298          }
299          int npos = buffer.position();
300          buffer.position(pos);
301          buffer.putInt(npos - pos - 4);
302          buffer.position(npos);
303      }
304      private void writeBool(GrowableByteBuffer buffer, boolean value) {
305          buffer.put(BOOL);
306          if (value) {
307              buffer.put((byte) 1);
308          } else {
309              buffer.put((byte) 0);
310          }
311      }
312      private void writeByte(GrowableByteBuffer buffer, byte value) {
313          buffer.put(BYTE);
314          buffer.put(value);
315      }
316      private void writeInt16(GrowableByteBuffer buffer, short value) {
317          buffer.put(INT16);
318          buffer.putShort(value);
319      }
320      private void writeInt32(GrowableByteBuffer buffer, int value) {
321          buffer.put(INT32);
322          buffer.putZigzag32(value);
323      }
324      private void writeInt64(GrowableByteBuffer buffer, long value) {
325          buffer.put(INT64);
326          buffer.putZigzag64(value);
327      }
328      private void writeFloat32(GrowableByteBuffer buffer, float value) {
329          buffer.put(FLOAT32);
330          buffer.putFloat(value);
331      }
332      private void writeFloat64(GrowableByteBuffer buffer, double value) {
333          buffer.put(FLOAT64);
334          buffer.putDouble(value);
335      }
336      private void writeArray(GrowableByteBuffer buffer, Object[] value) throws IOException {
337          buffer.put(ARRAY);
338          int pos = buffer.position();
339          buffer.position(pos + 4);
340          for (int i = 0; i &lt; value.length; i++) {
341              serialize(value[i], buffer);
342          }
343          int npos = buffer.position();
344          buffer.position(pos);
345          buffer.putInt(npos - pos - 4);
346          buffer.position(npos);
347      }
348      private void writeArray(GrowableByteBuffer buffer, Collection&lt;?&gt; value) throws IOException {
349          buffer.put(ARRAY);
350          int pos = buffer.position();
351          buffer.position(pos + 4);
352          for (Object v : value) {
353              serialize(v, buffer);
354          }
355          int npos = buffer.position();
356          buffer.position(pos);
357          buffer.putInt(npos - pos - 4);
358          buffer.position(npos);
359      }
360      private void writeMap(GrowableByteBuffer buffer, Map&lt;?, ?&gt; value) throws IOException {
361          buffer.put(MAP);
362          int pos = buffer.position();
363          buffer.position(pos + 4);
364          for (Map.Entry&lt;?, ?&gt; entry : value.entrySet()) {
365              serialize(entry.getKey(), buffer);
366              serialize(entry.getValue(), buffer);
367          }
368          int npos = buffer.position();
369          buffer.position(pos);
<span onclick='openModal()' class='match'>370          buffer.putInt(npos - pos - 4);
371          buffer.position(npos);
372      }
373      private int getAndCheckSize(GrowableByteBuffer buffer) {
</span>374          int size = buffer.getInt();
375          if (size &gt; buffer.remaining()) {
376              throw new MotanServiceException(&quot;SimpleSerialization deserialize fail! buffer not enough!need size:&quot; + size);
377          }
378          return size;
379      }
380      private String readString(GrowableByteBuffer buffer) throws IOException {
381          return new String(readBytes(buffer), &quot;UTF-8&quot;);
382      }
383      private Map&lt;String, String&gt; readStringMap(GrowableByteBuffer buffer) throws IOException {
384          Map&lt;String, String&gt; map = new HashMap&lt;&gt;(DEFAULT_MAP_SIZE);
385          int size = getAndCheckSize(buffer);
386          int startPos = buffer.position();
387          int endPos = startPos + size;
388          while (buffer.position() &lt; endPos) {
389              map.put(readString(buffer), readString(buffer));
390          }
391          if (buffer.position() != endPos) {
392              throw new MotanServiceException(&quot;SimpleSerialization deserialize wrong map size, except: &quot; + size + &quot; actual: &quot; + (buffer.position() - startPos));
393          }
394          return map;
395      }
396      private byte[] readBytes(GrowableByteBuffer buffer) {
397          int size = getAndCheckSize(buffer);
398          if (size == 0) {
399              return new byte[]{};
400          } else {
401              byte[] b = new byte[size];
402              buffer.get(b);
403              return b;
404          }
405      }
406      private String[] readStringArray(GrowableByteBuffer buffer) throws IOException {
407          List&lt;String&gt; values = readStringList(buffer);
408          String[] result = new String[values.size()];
409          return values.toArray(result);
410      }
411      private List&lt;String&gt; readStringList(GrowableByteBuffer buffer) throws IOException {
412          List&lt;String&gt; result = new ArrayList&lt;&gt;(DEFAULT_ARRAY_SIZE);
413          return readStringCollection(buffer, result);
414      }
415      private Set&lt;String&gt; readStringSet(GrowableByteBuffer buffer) throws IOException {
416          Set&lt;String&gt; result = new HashSet&lt;&gt;(DEFAULT_ARRAY_SIZE);
417          return readStringCollection(buffer, result);
418      }
419      private &lt;T extends Collection&gt; T readStringCollection(GrowableByteBuffer buffer, T collection) throws IOException {
420          int size = getAndCheckSize(buffer);
421          if (size == 0) {
422              return collection;
423          }
424          int startPos = buffer.position();
425          int endPos = startPos + size;
426          while (buffer.position() &lt; endPos) {
427              collection.add(readString(buffer));
428          }
429          if (buffer.position() != endPos) {
430              throw new MotanServiceException(&quot;SimpleSerialization deserialize wrong array size, except: &quot; + size + &quot; actual: &quot; + (buffer.position() - startPos));
431          }
432          return collection;
433      }
434      private Boolean readBool(GrowableByteBuffer buffer) {
435          return buffer.get() == 1;
436      }
437      private Byte readByte(GrowableByteBuffer buffer) {
438          return buffer.get();
439      }
440      private Short readInt16(GrowableByteBuffer buffer) {
441          return buffer.getShort();
442      }
443      private Integer readInt32(GrowableByteBuffer buffer) {
444          return buffer.getZigZag32();
445      }
446      private Long readInt64(GrowableByteBuffer buffer) {
447          return buffer.getZigZag64();
448      }
449      private Float readFloat32(GrowableByteBuffer buffer) {
450          return buffer.getFloat();
451      }
452      private Double readFloat64(GrowableByteBuffer buffer) {
453          return buffer.getDouble();
454      }
455      private Map readMap(GrowableByteBuffer buffer) throws IOException {
456          Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(DEFAULT_MAP_SIZE);
457          int size = getAndCheckSize(buffer);
458          int startPos = buffer.position();
459          int endPos = startPos + size;
460          while (buffer.position() &lt; endPos) {
461              map.put(deserialize(buffer, Object.class), deserialize(buffer, Object.class));
462          }
463          if (buffer.position() != endPos) {
464              throw new MotanServiceException(&quot;SimpleSerialization deserialize wrong map size, except: &quot; + size + &quot; actual: &quot; + (buffer.position() - startPos));
465          }
466          return map;
467      }
468      private Object[] readArray(GrowableByteBuffer buffer) throws IOException {
469          List&lt;Object&gt; values = readList(buffer);
470          Object[] result = new Object[values.size()];
471          return values.toArray(result);
472      }
473      private List&lt;Object&gt; readList(GrowableByteBuffer buffer) throws IOException {
474          List&lt;Object&gt; result = new ArrayList&lt;&gt;(DEFAULT_ARRAY_SIZE);
475          return readCollection(buffer, result);
476      }
477      private Set&lt;Object&gt; readSet(GrowableByteBuffer buffer) throws IOException {
478          Set&lt;Object&gt; result = new HashSet&lt;&gt;(DEFAULT_ARRAY_SIZE);
479          return readCollection(buffer, result);
480      }
481      private &lt;T extends Collection&gt; T readCollection(GrowableByteBuffer buffer, T collection) throws IOException {
482          int size = getAndCheckSize(buffer);
483          if (size == 0) {
484              return collection;
485          }
486          int startPos = buffer.position();
487          int endPos = startPos + size;
488          while (buffer.position() &lt; endPos) {
489              collection.add(deserialize(buffer, Object.class));
490          }
491          if (buffer.position() != endPos) {
492              throw new MotanServiceException(&quot;SimpleSerialization deserialize wrong array size, except: &quot; + size + &quot; actual: &quot; + (buffer.position() - startPos));
493          }
494          return collection;
495      }
496  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-SimpleSerialization.java</h3>
            <pre><code>1  package com.weibo.api.motan.serialize;
2  import com.weibo.api.motan.codec.Serialization;
3  import com.weibo.api.motan.core.extension.SpiMeta;
4  import com.weibo.api.motan.exception.MotanServiceException;
5  import com.weibo.api.motan.protocol.v2motan.GrowableByteBuffer;
6  import java.io.IOException;
7  import java.nio.ByteBuffer;
8  import java.util.*;
9  import static com.weibo.api.motan.serialize.SimpleSerialization.SimpleType.*;
10  @SpiMeta(name = &quot;simple&quot;)
11  public class SimpleSerialization implements Serialization {
12      public static final class SimpleType {
13          public static final byte NULL = 0;
14          public static final byte STRING = 1;
15          public static final byte STRING_MAP = 2;
16          public static final byte BYTE_ARRAY = 3;
17          public static final byte STRING_ARRAY = 4;
18          public static final byte BOOL = 5;
19          public static final byte BYTE = 6;
20          public static final byte INT16 = 7;
21          public static final byte INT32 = 8;
22          public static final byte INT64 = 9;
23          public static final byte FLOAT32 = 10;
24          public static final byte FLOAT64 = 11;
25          public static final byte MAP = 20;
26          public static final byte ARRAY = 21;
27      }
28      private static final int DEFAULT_MAP_SIZE = 16;
29      private static final int DEFAULT_ARRAY_SIZE = 16;
30      public static boolean isStringCollection(Collection&lt;?&gt; obj) {
31          if (obj.isEmpty()) {
32              return false;
33          }
34          for (Object v : obj) {
35              if (v == null) {
36                  continue;
37              }
38              if (!(v instanceof String)) {
39                  return false;
40              }
41          }
42          return true;
43      }
44      public static boolean isStringMap(Map&lt;?, ?&gt; obj) {
45          if (obj.isEmpty()) {
46              return false;
47          }
48          for (Map.Entry&lt;?, ?&gt; entry : obj.entrySet()) {
49              if (entry.getKey() == null || entry.getValue() == null) {
50                  continue;
51              }
52              if (!(entry.getKey() instanceof String) || !(entry.getValue() instanceof String)) {
53                  return false;
54              }
55          }
56          return true;
57      }
58      @Override
59      public byte[] serialize(Object obj) throws IOException {
60          GrowableByteBuffer buffer = new GrowableByteBuffer(4096);
61          serialize(obj, buffer);
62          buffer.flip();
63          byte[] result = new byte[buffer.remaining()];
64          buffer.get(result);
65          return result;
66      }
67      private void serialize(Object obj, GrowableByteBuffer buffer) throws IOException {
68          if (obj == null) {
69              buffer.put(NULL);
70              return;
71          }
72          Class&lt;?&gt; clz = obj.getClass();
73          if (clz == String.class) {
74              writeString(buffer, (String) obj);
75              return;
76          }
77          if (clz == Byte.class || clz == byte.class) {
78              writeByte(buffer, (Byte) obj);
79              return;
80          }
81          if (clz == Boolean.class || clz == boolean.class) {
82              writeBool(buffer, (Boolean) obj);
83              return;
84          }
85          if (clz == Short.class || clz == short.class) {
86              writeInt16(buffer, (Short) obj);
87              return;
88          }
89          if (clz == Integer.class || clz == int.class) {
90              writeInt32(buffer, (Integer) obj);
91              return;
92          }
93          if (clz == Long.class || clz == long.class) {
94              writeInt64(buffer, (Long) obj);
95              return;
96          }
97          if (clz == Float.class || clz == float.class) {
98              writeFloat32(buffer, (Float) obj);
99              return;
100          }
101          if (clz == Double.class || clz == double.class) {
102              writeFloat64(buffer, (Double) obj);
103              return;
104          }
105          if (obj instanceof Map) {
106              if (isStringMap((Map) obj)) {
107                  writeStringMap(buffer, (Map&lt;String, String&gt;) obj);
108              } else {
109                  writeMap(buffer, (Map) obj);
110              }
111              return;
112          }
113          if (clz.isArray()) {
114              if (clz.getComponentType() == String.class) {
115                  writeStringArray(buffer, (String[]) obj);
116              } else if (clz.getComponentType() == byte.class) {
117                  writeBytes(buffer, (byte[]) obj);
118              } else {
119                  writeArray(buffer, (Object[]) obj);
120              }
121              return;
122          }
123          if (obj instanceof List || obj instanceof Set) {
124              if (isStringCollection((Collection) obj)) {
125                  writeStringArray(buffer, (Collection&lt;String&gt;) obj);
126              } else {
127                  writeArray(buffer, (Collection) obj);
128              }
129              return;
130          }
131          throw new MotanServiceException(&quot;SimpleSerialization unsupported type: &quot; + clz);
132      }
133      @Override
134      public &lt;T&gt; T deserialize(byte[] bytes, Class&lt;T&gt; clz) throws IOException {
135          GrowableByteBuffer buffer = new GrowableByteBuffer(ByteBuffer.wrap(bytes));
136          return deserialize(buffer, clz);
137      }
138      private &lt;T&gt; T deserialize(GrowableByteBuffer buffer, Class&lt;T&gt; clz) throws IOException {
139          byte type = buffer.get();
140          switch (type) {
141              default:
142                  break;
143              case NULL:
144                  return null;
145              case STRING:
146                  if (clz == String.class || clz == Object.class) {
147                      return (T) readString(buffer);
148                  }
149                  break;
150              case STRING_MAP:
151                  if (clz.isAssignableFrom(HashMap.class)) {
152                      return (T) readStringMap(buffer);
153                  }
154                  break;
155              case BYTE_ARRAY:
156                  if (clz == byte[].class || clz == Object.class) {
157                      return (T) readBytes(buffer);
158                  }
159                  break;
160              case STRING_ARRAY:
161                  if ((clz.isArray() &amp;&amp; clz.getComponentType() == String.class)) {
162                      return (T) readStringArray(buffer);
163                  } else if (clz.isAssignableFrom(ArrayList.class)) {
164                      return (T) readStringList(buffer);
165                  } else if (clz.isAssignableFrom(HashSet.class)) {
166                      return (T) readStringSet(buffer);
167                  }
168                  break;
169              case BOOL:
170                  if (clz == boolean.class || clz == Boolean.class || clz == Object.class) {
171                      return (T) readBool(buffer);
172                  }
173                  break;
174              case BYTE:
175                  if (clz == byte.class || clz == Byte.class || clz == Object.class) {
176                      return (T) readByte(buffer);
177                  }
178              case INT16:
179                  if (clz == short.class || clz == Short.class || clz == Object.class) {
180                      return (T) readInt16(buffer);
181                  }
182                  break;
183              case INT32:
184                  if (clz == int.class || clz == Integer.class || clz == Object.class) {
185                      return (T) readInt32(buffer);
186                  }
187                  break;
188              case INT64:
189                  if (clz == long.class || clz == Long.class || clz == Object.class) {
190                      return (T) readInt64(buffer);
191                  }
192                  break;
193              case FLOAT32:
194                  if (clz == float.class || clz == Float.class || clz == Object.class) {
195                      return (T) readFloat32(buffer);
196                  }
197                  break;
198              case FLOAT64:
199                  if (clz == double.class || clz == Double.class || clz == Object.class) {
200                      return (T) readFloat64(buffer);
201                  }
202                  break;
203              case MAP:
204                  if (clz.isAssignableFrom(HashMap.class)) {
205                      return (T) readMap(buffer);
206                  }
207                  break;
208              case ARRAY:
209                  if (clz.isArray()) {
210                      return (T) readArray(buffer);
211                  } else if (clz.isAssignableFrom(ArrayList.class)) {
212                      return (T) readList(buffer);
213                  } else if (clz.isAssignableFrom(HashSet.class)) {
214                      return (T) readSet(buffer);
215                  }
216                  break;
217          }
218          throw new MotanServiceException(&quot;SimpleSerialization not support &quot; + type + &quot; with receiver type:&quot; + clz);
219      }
220      @Override
221      public byte[] serializeMulti(Object[] data) throws IOException {
222          GrowableByteBuffer buffer = new GrowableByteBuffer(4096);
223          for (Object o : data) {
224              serialize(o, buffer);
225          }
226          buffer.flip();
227          byte[] result = new byte[buffer.remaining()];
228          buffer.get(result);
229          return result;
230      }
231      @Override
232      public Object[] deserializeMulti(byte[] data, Class&lt;?&gt;[] classes) throws IOException {
233          GrowableByteBuffer buffer = new GrowableByteBuffer(ByteBuffer.wrap(data));
234          Object[] result = new Object[classes.length];
235          for (int i = 0; i &lt; classes.length; i++) {
236              result[i] = deserialize(buffer, classes[i]);
237          }
238          return result;
239      }
240      @Override
241      public int getSerializationNumber() {
242          return 6;
243      }
244      private void putString(GrowableByteBuffer buffer, String str) throws IOException {
245          byte[] b = str.getBytes(&quot;UTF-8&quot;);
246          buffer.putInt(b.length);
247          buffer.put(b);
248      }
249      private void writeString(GrowableByteBuffer buffer, String str) throws IOException {
250          buffer.put(STRING);
251          putString(buffer, str);
252      }
253      private void writeStringMap(GrowableByteBuffer buffer, Map&lt;String, String&gt; value) throws IOException {
254          buffer.put(STRING_MAP);
255          int pos = buffer.position();
256          buffer.position(pos + 4);
257          for (Map.Entry&lt;String, String&gt; entry : value.entrySet()) {
258              if (entry.getKey() == null || entry.getValue() == null) {
259                  continue;
260              }
261              putString(buffer, entry.getKey());
262              putString(buffer, entry.getValue());
263          }
264          int npos = buffer.position();
265          buffer.position(pos);
266          buffer.putInt(npos - pos - 4);
267          buffer.position(npos);
268      }
269      private void writeBytes(GrowableByteBuffer buffer, byte[] value) {
270          buffer.put(BYTE_ARRAY);
271          buffer.putInt(value.length);
272          buffer.put(value);
273      }
274      private void writeStringArray(GrowableByteBuffer buffer, String[] value) throws IOException {
275          buffer.put(STRING_ARRAY);
276          int pos = buffer.position();
277          buffer.position(pos + 4);
278          for (int i = 0; i &lt; value.length; i++) {
279              if (value[i] == null) {
280                  continue;
281              }
282              putString(buffer, value[i]);
283          }
284          int npos = buffer.position();
285          buffer.position(pos);
286          buffer.putInt(npos - pos - 4);
287          buffer.position(npos);
288      }
289      private void writeStringArray(GrowableByteBuffer buffer, Collection&lt;String&gt; value) throws IOException {
290          buffer.put(STRING_ARRAY);
291          int pos = buffer.position();
292          buffer.position(pos + 4);
293          for (String s : value) {
294              if (s == null) {
295                  continue;
296              }
297              putString(buffer, s);
298          }
299          int npos = buffer.position();
300          buffer.position(pos);
301          buffer.putInt(npos - pos - 4);
302          buffer.position(npos);
303      }
304      private void writeBool(GrowableByteBuffer buffer, boolean value) {
305          buffer.put(BOOL);
306          if (value) {
307              buffer.put((byte) 1);
308          } else {
309              buffer.put((byte) 0);
310          }
311      }
312      private void writeByte(GrowableByteBuffer buffer, byte value) {
313          buffer.put(BYTE);
314          buffer.put(value);
315      }
316      private void writeInt16(GrowableByteBuffer buffer, short value) {
317          buffer.put(INT16);
318          buffer.putShort(value);
319      }
320      private void writeInt32(GrowableByteBuffer buffer, int value) {
321          buffer.put(INT32);
322          buffer.putZigzag32(value);
323      }
324      private void writeInt64(GrowableByteBuffer buffer, long value) {
325          buffer.put(INT64);
326          buffer.putZigzag64(value);
327      }
328      private void writeFloat32(GrowableByteBuffer buffer, float value) {
329          buffer.put(FLOAT32);
330          buffer.putFloat(value);
331      }
332      private void writeFloat64(GrowableByteBuffer buffer, double value) {
333          buffer.put(FLOAT64);
334          buffer.putDouble(value);
335      }
336      private void writeArray(GrowableByteBuffer buffer, Object[] value) throws IOException {
337          buffer.put(ARRAY);
338          int pos = buffer.position();
339          buffer.position(pos + 4);
340          for (int i = 0; i &lt; value.length; i++) {
341              serialize(value[i], buffer);
342          }
343          int npos = buffer.position();
344          buffer.position(pos);
345          buffer.putInt(npos - pos - 4);
346          buffer.position(npos);
347      }
348      private void writeArray(GrowableByteBuffer buffer, Collection&lt;?&gt; value) throws IOException {
349          buffer.put(ARRAY);
350          int pos = buffer.position();
351          buffer.position(pos + 4);
352          for (Object v : value) {
353              serialize(v, buffer);
354          }
355          int npos = buffer.position();
356          buffer.position(pos);
<span onclick='openModal()' class='match'>357          buffer.putInt(npos - pos - 4);
358          buffer.position(npos);
359      }
360      private void writeMap(GrowableByteBuffer buffer, Map&lt;?, ?&gt; value) throws IOException {
</span>361          buffer.put(MAP);
362          int pos = buffer.position();
363          buffer.position(pos + 4);
364          for (Map.Entry&lt;?, ?&gt; entry : value.entrySet()) {
365              serialize(entry.getKey(), buffer);
366              serialize(entry.getValue(), buffer);
367          }
368          int npos = buffer.position();
369          buffer.position(pos);
370          buffer.putInt(npos - pos - 4);
371          buffer.position(npos);
372      }
373      private int getAndCheckSize(GrowableByteBuffer buffer) {
374          int size = buffer.getInt();
375          if (size &gt; buffer.remaining()) {
376              throw new MotanServiceException(&quot;SimpleSerialization deserialize fail! buffer not enough!need size:&quot; + size);
377          }
378          return size;
379      }
380      private String readString(GrowableByteBuffer buffer) throws IOException {
381          return new String(readBytes(buffer), &quot;UTF-8&quot;);
382      }
383      private Map&lt;String, String&gt; readStringMap(GrowableByteBuffer buffer) throws IOException {
384          Map&lt;String, String&gt; map = new HashMap&lt;&gt;(DEFAULT_MAP_SIZE);
385          int size = getAndCheckSize(buffer);
386          int startPos = buffer.position();
387          int endPos = startPos + size;
388          while (buffer.position() &lt; endPos) {
389              map.put(readString(buffer), readString(buffer));
390          }
391          if (buffer.position() != endPos) {
392              throw new MotanServiceException(&quot;SimpleSerialization deserialize wrong map size, except: &quot; + size + &quot; actual: &quot; + (buffer.position() - startPos));
393          }
394          return map;
395      }
396      private byte[] readBytes(GrowableByteBuffer buffer) {
397          int size = getAndCheckSize(buffer);
398          if (size == 0) {
399              return new byte[]{};
400          } else {
401              byte[] b = new byte[size];
402              buffer.get(b);
403              return b;
404          }
405      }
406      private String[] readStringArray(GrowableByteBuffer buffer) throws IOException {
407          List&lt;String&gt; values = readStringList(buffer);
408          String[] result = new String[values.size()];
409          return values.toArray(result);
410      }
411      private List&lt;String&gt; readStringList(GrowableByteBuffer buffer) throws IOException {
412          List&lt;String&gt; result = new ArrayList&lt;&gt;(DEFAULT_ARRAY_SIZE);
413          return readStringCollection(buffer, result);
414      }
415      private Set&lt;String&gt; readStringSet(GrowableByteBuffer buffer) throws IOException {
416          Set&lt;String&gt; result = new HashSet&lt;&gt;(DEFAULT_ARRAY_SIZE);
417          return readStringCollection(buffer, result);
418      }
419      private &lt;T extends Collection&gt; T readStringCollection(GrowableByteBuffer buffer, T collection) throws IOException {
420          int size = getAndCheckSize(buffer);
421          if (size == 0) {
422              return collection;
423          }
424          int startPos = buffer.position();
425          int endPos = startPos + size;
426          while (buffer.position() &lt; endPos) {
427              collection.add(readString(buffer));
428          }
429          if (buffer.position() != endPos) {
430              throw new MotanServiceException(&quot;SimpleSerialization deserialize wrong array size, except: &quot; + size + &quot; actual: &quot; + (buffer.position() - startPos));
431          }
432          return collection;
433      }
434      private Boolean readBool(GrowableByteBuffer buffer) {
435          return buffer.get() == 1;
436      }
437      private Byte readByte(GrowableByteBuffer buffer) {
438          return buffer.get();
439      }
440      private Short readInt16(GrowableByteBuffer buffer) {
441          return buffer.getShort();
442      }
443      private Integer readInt32(GrowableByteBuffer buffer) {
444          return buffer.getZigZag32();
445      }
446      private Long readInt64(GrowableByteBuffer buffer) {
447          return buffer.getZigZag64();
448      }
449      private Float readFloat32(GrowableByteBuffer buffer) {
450          return buffer.getFloat();
451      }
452      private Double readFloat64(GrowableByteBuffer buffer) {
453          return buffer.getDouble();
454      }
455      private Map readMap(GrowableByteBuffer buffer) throws IOException {
456          Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(DEFAULT_MAP_SIZE);
457          int size = getAndCheckSize(buffer);
458          int startPos = buffer.position();
459          int endPos = startPos + size;
460          while (buffer.position() &lt; endPos) {
461              map.put(deserialize(buffer, Object.class), deserialize(buffer, Object.class));
462          }
463          if (buffer.position() != endPos) {
464              throw new MotanServiceException(&quot;SimpleSerialization deserialize wrong map size, except: &quot; + size + &quot; actual: &quot; + (buffer.position() - startPos));
465          }
466          return map;
467      }
468      private Object[] readArray(GrowableByteBuffer buffer) throws IOException {
469          List&lt;Object&gt; values = readList(buffer);
470          Object[] result = new Object[values.size()];
471          return values.toArray(result);
472      }
473      private List&lt;Object&gt; readList(GrowableByteBuffer buffer) throws IOException {
474          List&lt;Object&gt; result = new ArrayList&lt;&gt;(DEFAULT_ARRAY_SIZE);
475          return readCollection(buffer, result);
476      }
477      private Set&lt;Object&gt; readSet(GrowableByteBuffer buffer) throws IOException {
478          Set&lt;Object&gt; result = new HashSet&lt;&gt;(DEFAULT_ARRAY_SIZE);
479          return readCollection(buffer, result);
480      }
481      private &lt;T extends Collection&gt; T readCollection(GrowableByteBuffer buffer, T collection) throws IOException {
482          int size = getAndCheckSize(buffer);
483          if (size == 0) {
484              return collection;
485          }
486          int startPos = buffer.position();
487          int endPos = startPos + size;
488          while (buffer.position() &lt; endPos) {
489              collection.add(deserialize(buffer, Object.class));
490          }
491          if (buffer.position() != endPos) {
492              throw new MotanServiceException(&quot;SimpleSerialization deserialize wrong array size, except: &quot; + size + &quot; actual: &quot; + (buffer.position() - startPos));
493          }
494          return collection;
495      }
496  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-SimpleSerialization.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-SimpleSerialization.java</div>
                </div>
                <div class="column column_space"><pre><code>370          buffer.putInt(npos - pos - 4);
371          buffer.position(npos);
372      }
373      private int getAndCheckSize(GrowableByteBuffer buffer) {
</pre></code></div>
                <div class="column column_space"><pre><code>357          buffer.putInt(npos - pos - 4);
358          buffer.position(npos);
359      }
360      private void writeMap(GrowableByteBuffer buffer, Map&lt;?, ?&gt; value) throws IOException {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    