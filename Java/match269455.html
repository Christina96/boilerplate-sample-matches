<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Multisets_1.java & FreshValueGenerator.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Multisets_1.java & FreshValueGenerator.java
      </h3>
      <h1 align="center">
        17.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Multisets_1.java (18.234165%)<TH>FreshValueGenerator.java (17.241379%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#0',2,'match269455-1.html#0',3)" NAME="0">(19-62)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#0',2,'match269455-1.html#0',3)" NAME="0">(97-132)</A><TD ALIGN=center><FONT COLOR="#ff0000">31</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#1',2,'match269455-1.html#1',3)" NAME="1">(554-567)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#1',2,'match269455-1.html#1',3)" NAME="1">(488-501)</A><TD ALIGN=center><FONT COLOR="#b40000">22</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#2',2,'match269455-1.html#2',3)" NAME="2">(326-340)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#2',2,'match269455-1.html#2',3)" NAME="2">(453-467)</A><TD ALIGN=center><FONT COLOR="#b40000">22</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#3',2,'match269455-1.html#3',3)" NAME="3">(1196-1207)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#3',2,'match269455-1.html#3',3)" NAME="3">(473-484)</A><TD ALIGN=center><FONT COLOR="#9c0000">19</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#4',2,'match269455-1.html#4',3)" NAME="4">(422-431)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#4',2,'match269455-1.html#4',3)" NAME="4">(551-561)</A><TD ALIGN=center><FONT COLOR="#8b0000">17</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#5',2,'match269455-1.html#5',3)" NAME="5">(1003-1012)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#5',2,'match269455-1.html#5',3)" NAME="5">(578-587)</A><TD ALIGN=center><FONT COLOR="#830000">16</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#6',2,'match269455-1.html#6',3)" NAME="6">(159-168)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#6',2,'match269455-1.html#6',3)" NAME="6">(1011-1019)</A><TD ALIGN=center><FONT COLOR="#730000">14</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#7',2,'match269455-1.html#7',3)" NAME="7">(1016-1022)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#7',2,'match269455-1.html#7',3)" NAME="7">(1034-1041)</A><TD ALIGN=center><FONT COLOR="#6a0000">13</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#8',2,'match269455-1.html#8',3)" NAME="8">(568-574)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#8',2,'match269455-1.html#8',3)" NAME="8">(1024-1031)</A><TD ALIGN=center><FONT COLOR="#6a0000">13</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#9',2,'match269455-1.html#9',3)" NAME="9">(109-121)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#9',2,'match269455-1.html#9',3)" NAME="9">(543-549)</A><TD ALIGN=center><FONT COLOR="#620000">12</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#10',2,'match269455-1.html#10',3)" NAME="10">(1093-1100)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#10',2,'match269455-1.html#10',3)" NAME="10">(364-371)</A><TD ALIGN=center><FONT COLOR="#5a0000">11</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#11',2,'match269455-1.html#11',3)" NAME="11">(1189-1195)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#11',2,'match269455-1.html#11',3)" NAME="11">(376-382)</A><TD ALIGN=center><FONT COLOR="#520000">10</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#12',2,'match269455-1.html#12',3)" NAME="12">(1159-1169)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#12',2,'match269455-1.html#12',3)" NAME="12">(745-750)</A><TD ALIGN=center><FONT COLOR="#520000">10</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#13',2,'match269455-1.html#13',3)" NAME="13">(678-683)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#13',2,'match269455-1.html#13',3)" NAME="13">(434-439)</A><TD ALIGN=center><FONT COLOR="#520000">10</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#14',2,'match269455-1.html#14',3)" NAME="14">(267-274)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#14',2,'match269455-1.html#14',3)" NAME="14">(296-303)</A><TD ALIGN=center><FONT COLOR="#520000">10</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#15',2,'match269455-1.html#15',3)" NAME="15">(84-102)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#15',2,'match269455-1.html#15',3)" NAME="15">(948-953)</A><TD ALIGN=center><FONT COLOR="#520000">10</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#16',2,'match269455-1.html#16',3)" NAME="16">(918-921)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#16',2,'match269455-1.html#16',3)" NAME="16">(327-330)</A><TD ALIGN=center><FONT COLOR="#4a0000">9</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#17',2,'match269455-1.html#17',3)" NAME="17">(433-438)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#17',2,'match269455-1.html#17',3)" NAME="17">(964-970)</A><TD ALIGN=center><FONT COLOR="#4a0000">9</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#18',2,'match269455-1.html#18',3)" NAME="18">(397-415)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#18',2,'match269455-1.html#18',3)" NAME="18">(185-190)</A><TD ALIGN=center><FONT COLOR="#4a0000">9</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#19',2,'match269455-1.html#19',3)" NAME="19">(140-145)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#19',2,'match269455-1.html#19',3)" NAME="19">(502-507)</A><TD ALIGN=center><FONT COLOR="#4a0000">9</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match269455-0.html#20',2,'match269455-1.html#20',3)" NAME="20">(125-131)<TD><A HREF="javascript:ZweiFrames('match269455-0.html#20',2,'match269455-1.html#20',3)" NAME="20">(287-293)</A><TD ALIGN=center><FONT COLOR="#4a0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Multisets_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="0"></A>
package com.google.common.collect;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match269455-1.html#0',3,'match269455-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import static com.google.common.collect.CollectPreconditions.checkRemove;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Multiset.Entry;
import com.google.common.math.IntMath;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.function.ToIntFunction;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Provides static utility methods for creating and working with {@link Multiset} instances.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * &quot;https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets&quot;&gt;{@code
 * Multisets}&lt;/a&gt;.
 *
 * @author Kevin Bourrillion
 * @author Mike Bostock
 * @author Louis Wasserman
 * @since 2.0
 */
@</B></FONT>GwtCompatible
@ElementTypesAreNonnullByDefault
public final class Multisets {
  private Multisets() {}

  /**
   * Returns a {@code Collector} that accumulates elements into a multiset created via the specified
   * {@code Supplier}, whose elements are the result of applying {@code elementFunction} to the
   * inputs, with counts equal to the result of applying {@code countFunction} to the inputs.
   * Elements are added in encounter order.
   *
   * &lt;p&gt;If the mapped elements contain duplicates (according to {@link Object#equals}), the element
   * will be added more than once, with the count summed over all appearances of the element.
   *
   * &lt;p&gt;Note that {@code stream.collect(toMultiset(function, e -&gt; 1, supplier))} is equivalent to
   * {@code stream.map(function).collect(Collectors.toCollection(supplier))}.
   *
   * &lt;p&gt;To collect to an {@link ImmutableMultiset}, use {@link
   * ImmutableMultiset#toImmutableMultiset}.
<A NAME="15"></A>   *
   * @since 22.0
   */
  public static &lt;T extends @Nullable Object, E extends @Nullable Object, <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match269455-1.html#15',3,'match269455-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>M extends Multiset&lt;E&gt;&gt;
      Collector&lt;T, ?, M&gt; toMultiset(
          Function&lt;? super T, E&gt; elementFunction,
          ToIntFunction&lt;? super T&gt; countFunction,
          Supplier&lt;M&gt; multisetSupplier) {
    return CollectCollectors.toMultiset(elementFunction, countFunction, multisetSupplier);
  }

  /**
   * Returns an unmodifiable view of the specified multiset. Query operations on the returned
   * multiset &quot;read through&quot; to the specified multiset, and attempts to modify the returned multiset
   * result in an {@link UnsupportedOperationException}.
   *
   * &lt;p&gt;The returned multiset will be serializable if the specified multiset is serializable.
   *
   * @param multiset the multiset for which an unmodifiable view is to be generated
   * @return an unmodifiable view of the multiset
   */
  public static &lt;E ext</B></FONT>ends @Nullable Object&gt; Multiset&lt;E&gt; unmodifiableMultiset(
      Multiset&lt;? extends E&gt; multiset) {
    if (multiset instanceof UnmodifiableMultiset || multiset instanceof ImmutableMultiset) {
      @SuppressWarnings(&quot;unchecked&quot;) // Since it's unmodifiable, the covariant cast is safe
<A NAME="9"></A>      Multiset&lt;E&gt; result = (Multiset&lt;E&gt;) multiset;
      return result;
    }
    return new UnmodifiableMultiset&lt;E&gt;(<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match269455-1.html#9',3,'match269455-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkNotNull(multiset));
  }

  /**
   * Simply returns its argument.
   *
   * @deprecated no need to use this
   * @since 10.0
   */
  @Deprecated
  public static &lt;E&gt; Multiset&lt;E&gt; unmodifiableMultiset(ImmutableMultiset&lt;E&gt; multiset) {
    return checkNotNull(multiset);
  }</B></FONT>
<A NAME="20"></A>
  static class UnmodifiableMultiset&lt;E extends @Nullable Object&gt; extends ForwardingMultiset&lt;E&gt;
      implements Serializable {
    <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match269455-1.html#20',3,'match269455-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>final Multiset&lt;? extends E&gt; delegate;

    UnmodifiableMultiset(Multiset&lt;? extends E&gt; delegate) {
      this.delegate = delegate;
    }

    @</B></FONT>SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected Multiset&lt;E&gt; delegate() {
      // This is safe because all non-covariant methods are overridden
      return (Multiset&lt;E&gt;) delegate;
    }
<A NAME="19"></A>
    @CheckForNull transient Set&lt;E&gt; elementSet;

    Set&lt;E&gt; createElementSet() <FONT color="#f62817"><A HREF="javascript:ZweiFrames('match269455-1.html#19',3,'match269455-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
      return Collections.&lt;E&gt;unmodifiableSet(delegate.elementSet());
    }

    @Override
    public Set&lt;E&gt; elementSet() {</B></FONT>
      Set&lt;E&gt; es = elementSet;
      return (es == null) ? elementSet = createElementSet() : es;
    }

    @CheckForNull transient Set&lt;Multiset.Entry&lt;E&gt;&gt; entrySet;

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Set&lt;Multiset.Entry&lt;E&gt;&gt; entrySet() {
      Set&lt;Multiset.Entry&lt;E&gt;&gt; es = entrySet;
<A NAME="6"></A>      return (es == null)
          // Safe because the returned set is made unmodifiable and Entry
          // itself is readonly
          ? entrySet = (Set) <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match269455-1.html#6',3,'match269455-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Collections.unmodifiableSet(delegate.entrySet())
          : es;
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
      return Iterators.&lt;E&gt;unmodifiableIterator(delegate.iterator());
    }

    @</B></FONT>Override
    public boolean add(@ParametricNullness E element) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int add(@ParametricNullness E element, int occurrences) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; elementsToAdd) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean remove(@CheckForNull Object element) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int remove(@CheckForNull Object element, int occurrences) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean removeAll(Collection&lt;?&gt; elementsToRemove) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; elementsToRetain) {
      throw new UnsupportedOperationException();
    }

    @Override
    public void clear() {
      throw new UnsupportedOperationException();
    }

    @Override
    public int setCount(@ParametricNullness E element, int count) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
      throw new UnsupportedOperationException();
    }

    private static final long serialVersionUID = 0;
  }

  /**
   * Returns an unmodifiable view of the specified sorted multiset. Query operations on the returned
   * multiset &quot;read through&quot; to the specified multiset, and attempts to modify the returned multiset
   * result in an {@link UnsupportedOperationException}.
   *
   * &lt;p&gt;The returned multiset will be serializable if the specified multiset is serializable.
   *
   * @param sortedMultiset the sorted multiset for which an unmodifiable view is to be generated
   * @return an unmodifiable view of the multiset
   * @since 11.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; SortedMultiset&lt;E&gt; unmodifiableSortedMultiset(
      SortedMultiset&lt;E&gt; sortedMultiset) {
    // it's in its own file so it can be emulated for GWT
    return new UnmodifiableSortedMultiset&lt;E&gt;(checkNotNull(sortedMultiset));
  }

  /**
   * Returns an immutable multiset entry with the specified element and count. The entry will be
   * serializable if {@code e} is.
   *
   * @param e the element to be associated with the returned entry
   * @param n the count to be associated with the returned entry
   * @throws IllegalArgumentException if {@code n} is negative
   */
  public static &lt;E extends @Nullable Object&gt; Multiset.Entry&lt;E&gt; immutableEntry(
      @ParametricNullness E e, int n) {
    return new ImmutableEntry&lt;E&gt;(e, n);
  }

  static class ImmutableEntry&lt;E extends @Nullable Object&gt; extends AbstractEntry&lt;E&gt;
      implements Serializable {
    @ParametricNullness private final E element;
    private final int count;

    ImmutableEntry(@ParametricNullness E element, int count) {
      this.element = element;
      this.count = count;
      checkNonnegative(count, &quot;count&quot;);
    }

    @Override
<A NAME="14"></A>    @ParametricNullness
    public final E getElement() {
      return element;
    <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match269455-1.html#14',3,'match269455-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public final int getCount() {
      return count;
    }

    @</B></FONT>CheckForNull
    public ImmutableEntry&lt;E&gt; nextInBucket() {
      return null;
    }

    private static final long serialVersionUID = 0;
  }

  /**
   * Returns a view of the elements of {@code unfiltered} that satisfy a predicate. The returned
   * multiset is a live view of {@code unfiltered}; changes to one affect the other.
   *
   * &lt;p&gt;The resulting multiset's iterators, and those of its {@code entrySet()} and {@code
   * elementSet()}, do not support {@code remove()}. However, all other multiset methods supported
   * by {@code unfiltered} are supported by the returned multiset. When given an element that
   * doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods throw
   * an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and {@code
   * clear()} are called on the filtered multiset, only elements that satisfy the filter will be
   * removed from the underlying multiset.
   *
   * &lt;p&gt;The returned multiset isn't threadsafe or serializable, even if {@code unfiltered} is.
   *
   * &lt;p&gt;Many of the filtered multiset's methods, such as {@code size()}, iterate across every
   * element in the underlying multiset and determine which elements satisfy the filter. When a live
   * view is &lt;i&gt;not&lt;/i&gt; needed, it may be faster to copy the returned multiset and use the copy.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; {@code predicate} must be &lt;i&gt;consistent with equals&lt;/i&gt;, as documented at
   * {@link Predicate#apply}. Do not provide a predicate such as {@code
   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
   * Iterables#filter(Iterable, Class)} for related functionality.)
   *
   * @since 14.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; Multiset&lt;E&gt; filter(
      Multiset&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    if (unfiltered instanceof FilteredMultiset) {
      // Support clear(), removeAll(), and retainAll() when filtering a filtered
      // collection.
      FilteredMultiset&lt;E&gt; filtered = (FilteredMultiset&lt;E&gt;) unfiltered;
      Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
      return new FilteredMultiset&lt;E&gt;(filtered.unfiltered, combinedPredicate);
    }
    return new FilteredMultiset&lt;E&gt;(unfiltered, predicate);
  }

  private static final class FilteredMultiset&lt;E extends @Nullable Object&gt; extends ViewMultiset&lt;E&gt; {
    final Multiset&lt;E&gt; unfiltered;
    final Predicate&lt;? super E&gt; predicate;
<A NAME="2"></A>
    FilteredMultiset(Multiset&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
      this.unfiltered = checkNotNull(unfiltered);
      this.predicate = <FONT color="#980517"><A HREF="javascript:ZweiFrames('match269455-1.html#2',3,'match269455-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkNotNull(predicate);
    }

    @Override
    public UnmodifiableIterator&lt;E&gt; iterator() {
      return Iterators.filter(unfiltered.iterator(), predicate);
    }

    @Override
    Set&lt;E&gt; createElementSet() {
      return Sets.filter(unfiltered.elementSet(), predicate);
    }

    @Override
    Iterator&lt;E&gt; elementIterator() {</B></FONT>
      throw new AssertionError(&quot;should never be called&quot;);
    }

    @Override
    Set&lt;Entry&lt;E&gt;&gt; createEntrySet() {
      return Sets.filter(
          unfiltered.entrySet(),
          new Predicate&lt;Entry&lt;E&gt;&gt;() {
            @Override
            public boolean apply(Entry&lt;E&gt; entry) {
              return predicate.apply(entry.getElement());
            }
          });
    }

    @Override
    Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
      throw new AssertionError(&quot;should never be called&quot;);
    }

    @Override
    public int count(@CheckForNull Object element) {
      int count = unfiltered.count(element);
      if (count &gt; 0) {
        @SuppressWarnings(&quot;unchecked&quot;) // element is equal to an E
        E e = (E) element;
        return predicate.apply(e) ? count : 0;
      }
      return 0;
    }

    @Override
    public int add(@ParametricNullness E element, int occurrences) {
      checkArgument(
          predicate.apply(element), &quot;Element %s does not match predicate %s&quot;, element, predicate);
      return unfiltered.add(element, occurrences);
    }

    @Override
    public int remove(@CheckForNull Object element, int occurrences) {
      checkNonnegative(occurrences, &quot;occurrences&quot;);
      if (occurrences == 0) {
        return count(element);
      } else {
        return contains(element) ? unfiltered.remove(element, occurrences) : 0;
      }
    }
  }

  /**
   * Returns the expected number of distinct elements given the specified elements. The number of
   * distinct elements is only computed if {@code elements} is an instance of {@code Multiset};
   * otherwise the default value of 11 is returned.
<A NAME="18"></A>   */
  static int inferDistinctElements(Iterable&lt;?&gt; elements) {
    if (elements instanceof Multiset) {
      return <FONT color="#800517"><A HREF="javascript:ZweiFrames('match269455-1.html#18',3,'match269455-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>((Multiset&lt;?&gt;) elements).elementSet().size();
    }
    return 11; // initial capacity will be rounded up to 16
  }

  /**
   * Returns an unmodifiable view of the union of two multisets. In the returned multiset, the count
   * of each element is the &lt;i&gt;maximum&lt;/i&gt; of its counts in the two backing multisets. The iteration
   * order of the returned multiset matches that of the element set of {@code multiset1} followed by
   * the members of the element set of {@code multiset2} that are not contained in {@code
   * multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * &lt;p&gt;Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  @Beta
  public static &lt;E</B></FONT> extends @Nullable Object&gt; Multiset&lt;E&gt; union(
      final Multiset&lt;? extends E&gt; multiset1, final Multiset&lt;? extends E&gt; multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);
<A NAME="4"></A>
    return new ViewMultiset&lt;E&gt;() {
      @Override
      public boolean contains(<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match269455-1.html#4',3,'match269455-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@CheckForNull Object element) {
        return multiset1.contains(element) || multiset2.contains(element);
      }

      @Override
      public boolean isEmpty() {
        return multiset1.isEmpty() &amp;&amp; multiset2.isEmpty();
      }
<A NAME="17"></A>
      @</B></FONT>Override
      public int count(@CheckForNull Object element) {
        return Math.max(multiset1.count(element), <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match269455-1.html#17',3,'match269455-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>multiset2.count(element));
      }

      @Override
      Set&lt;E&gt; createElementSet() {
        return Sets.union(multiset1.elementSet</B></FONT>(), multiset2.elementSet());
      }

      @Override
      Iterator&lt;E&gt; elementIterator() {
        throw new AssertionError(&quot;should never be called&quot;);
      }

      @Override
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
        final Iterator&lt;? extends Entry&lt;? extends E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        final Iterator&lt;? extends Entry&lt;? extends E&gt;&gt; iterator2 = multiset2.entrySet().iterator();
        // TODO(lowasser): consider making the entries live views
        return new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            if (iterator1.hasNext()) {
              Entry&lt;? extends E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = Math.max(entry1.getCount(), multiset2.count(element));
              return immutableEntry(element, count);
            }
            while (iterator2.hasNext()) {
              Entry&lt;? extends E&gt; entry2 = iterator2.next();
              E element = entry2.getElement();
              if (!multiset1.contains(element)) {
                return immutableEntry(element, entry2.getCount());
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the intersection of two multisets. In the returned multiset,
   * the count of each element is the &lt;i&gt;minimum&lt;/i&gt; of its counts in the two backing multisets,
   * with elements that would have a count of 0 not included. The iteration order of the returned
   * multiset matches that of the element set of {@code multiset1}, with repeated occurrences of the
   * same element appearing consecutively.
   *
   * &lt;p&gt;Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 2.0
   */
  public static &lt;E extends @Nullable Object&gt; Multiset&lt;E&gt; intersection(
      final Multiset&lt;E&gt; multiset1, final Multiset&lt;?&gt; multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    return new ViewMultiset&lt;E&gt;() {
      @Override
      public int count(@CheckForNull Object element) {
        int count1 = multiset1.count(element);
        return (count1 == 0) ? 0 : Math.min(count1, multiset2.count(element));
      }

      @Override
      Set&lt;E&gt; createElementSet() {
        return Sets.intersection(multiset1.elementSet(), multiset2.elementSet());
      }

      @Override
      Iterator&lt;E&gt; elementIterator() {
        throw new AssertionError(&quot;should never be called&quot;);
      }

      @Override
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
        final Iterator&lt;Entry&lt;E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        // TODO(lowasser): consider making the entries live views
        return new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            while (iterator1.hasNext()) {
              Entry&lt;E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = Math.min(entry1.getCount(), multiset2.count(element));
              if (count &gt; 0) {
                return immutableEntry(element, count);
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the sum of two multisets. In the returned multiset, the count
   * of each element is the &lt;i&gt;sum&lt;/i&gt; of its counts in the two backing multisets. The iteration
   * order of the returned multiset matches that of the element set of {@code multiset1} followed by
   * the members of the element set of {@code multiset2} that are not contained in {@code
   * multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * &lt;p&gt;Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; Multiset&lt;E&gt; sum(
      final Multiset&lt;? extends E&gt; multiset1, final Multiset&lt;? extends E&gt; multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    // TODO(lowasser): consider making the entries live views
<A NAME="1"></A>    return new ViewMultiset&lt;E&gt;() {
      @Override
      public boolean contains(@CheckForNull Object element) {
        return multiset1.contains(element) || <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match269455-1.html#1',3,'match269455-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>multiset2.contains(element);
      }

      @Override
      public boolean isEmpty() {
        return multiset1.isEmpty() &amp;&amp; multiset2.isEmpty();
      }

      @Override
      public int size() {
        return IntMath.saturatedAdd(multiset1.size(), multiset2.size());
<A NAME="8"></A>      }

      @</B></FONT>Override
      public int count(<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match269455-1.html#8',3,'match269455-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@CheckForNull Object element) {
        return multiset1.count(element) + multiset2.count(element);
      }

      @Override
      Set&lt;E&gt; createElementSet() {
        return Sets.union(multiset1.elementSet</B></FONT>(), multiset2.elementSet());
      }

      @Override
      Iterator&lt;E&gt; elementIterator() {
        throw new AssertionError(&quot;should never be called&quot;);
      }

      @Override
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
        final Iterator&lt;? extends Entry&lt;? extends E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        final Iterator&lt;? extends Entry&lt;? extends E&gt;&gt; iterator2 = multiset2.entrySet().iterator();
        return new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            if (iterator1.hasNext()) {
              Entry&lt;? extends E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = entry1.getCount() + multiset2.count(element);
              return immutableEntry(element, count);
            }
            while (iterator2.hasNext()) {
              Entry&lt;? extends E&gt; entry2 = iterator2.next();
              E element = entry2.getElement();
              if (!multiset1.contains(element)) {
                return immutableEntry(element, entry2.getCount());
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the difference of two multisets. In the returned multiset, the
   * count of each element is the result of the &lt;i&gt;zero-truncated subtraction&lt;/i&gt; of its count in
   * the second multiset from its count in the first multiset, with elements that would have a count
   * of 0 not included. The iteration order of the returned multiset matches that of the element set
   * of {@code multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * &lt;p&gt;Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; Multiset&lt;E&gt; difference(
      final Multiset&lt;E&gt; multiset1, final Multiset&lt;?&gt; multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    // TODO(lowasser): consider making the entries live views
    return new ViewMultiset&lt;E&gt;() {
      @Override
      public int count(@CheckForNull Object element) {
        int count1 = multiset1.count(element);
        return (count1 == 0) ? 0 : Math.max(0, count1 - multiset2.count(element));
      }

      @Override
      public void clear() {
        throw new UnsupportedOperationException();
      }

      @Override
      Iterator&lt;E&gt; elementIterator() {
        final Iterator&lt;Entry&lt;E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        return new AbstractIterator&lt;E&gt;() {
          @Override
          @CheckForNull
          protected E computeNext() {
            while (iterator1.hasNext()) {
              Entry&lt;E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              if (entry1.getCount() &gt; multiset2.count(element)) {
                return element;
              }
            }
            return endOfData();
          }
        };
      }

      @Override
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
        final Iterator&lt;Entry&lt;E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        return new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            while (iterator1.hasNext()) {
              Entry&lt;E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = entry1.getCount() - multiset2.count(element);
              if (count &gt; 0) {
                return immutableEntry(element, count);
              }
            }
<A NAME="13"></A>            return endOfData();
          }
        };
      <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match269455-1.html#13',3,'match269455-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

      @Override
      int distinctElements() {
        return Iterators.size(entryIterator());
      }</B></FONT>
    };
  }

  /**
   * Returns {@code true} if {@code subMultiset.count(o) &lt;= superMultiset.count(o)} for all {@code
   * o}.
   *
   * @since 10.0
   */
  @CanIgnoreReturnValue
  public static boolean containsOccurrences(Multiset&lt;?&gt; superMultiset, Multiset&lt;?&gt; subMultiset) {
    checkNotNull(superMultiset);
    checkNotNull(subMultiset);
    for (Entry&lt;?&gt; entry : subMultiset.entrySet()) {
      int superCount = superMultiset.count(entry.getElement());
      if (superCount &lt; entry.getCount()) {
        return false;
      }
    }
    return true;
  }

  /**
   * Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code
   * multisetToRetain.count(e)}.
   *
   * &lt;p&gt;To be precise, {@code multisetToModify.count(e)} is set to {@code
   * Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link
   * #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},
   * but mutates {@code multisetToModify} instead of returning a view.
   *
   * &lt;p&gt;In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of
   * elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all
   * other elements.
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 10.0
   */
  @CanIgnoreReturnValue
  public static boolean retainOccurrences(
      Multiset&lt;?&gt; multisetToModify, Multiset&lt;?&gt; multisetToRetain) {
    return retainOccurrencesImpl(multisetToModify, multisetToRetain);
  }

  /** Delegate implementation which cares about the element type. */
  private static &lt;E extends @Nullable Object&gt; boolean retainOccurrencesImpl(
      Multiset&lt;E&gt; multisetToModify, Multiset&lt;?&gt; occurrencesToRetain) {
    checkNotNull(multisetToModify);
    checkNotNull(occurrencesToRetain);
    // Avoiding ConcurrentModificationExceptions is tricky.
    Iterator&lt;Entry&lt;E&gt;&gt; entryIterator = multisetToModify.entrySet().iterator();
    boolean changed = false;
    while (entryIterator.hasNext()) {
      Entry&lt;E&gt; entry = entryIterator.next();
      int retainCount = occurrencesToRetain.count(entry.getElement());
      if (retainCount == 0) {
        entryIterator.remove();
        changed = true;
      } else if (retainCount &lt; entry.getCount()) {
        multisetToModify.setCount(entry.getElement(), retainCount);
        changed = true;
      }
    }
    return changed;
  }

  /**
   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one
   * occurrence of {@code e} in {@code multisetToModify}.
   *
   * &lt;p&gt;Equivalently, this method modifies {@code multisetToModify} so that {@code
   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -
   * Iterables.frequency(occurrencesToRemove, e))}.
   *
   * &lt;p&gt;This is &lt;i&gt;not&lt;/i&gt; the same as {@code multisetToModify.} {@link Multiset#removeAll
   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear
   * in {@code occurrencesToRemove}. However, this operation &lt;i&gt;is&lt;/i&gt; equivalent to, albeit
   * sometimes more efficient than, the following:
   *
   * &lt;pre&gt;{@code
   * for (E e : occurrencesToRemove) {
   *   multisetToModify.remove(e);
   * }
   * }&lt;/pre&gt;
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code
   *     Multiset})
   */
  @CanIgnoreReturnValue
  public static boolean removeOccurrences(
      Multiset&lt;?&gt; multisetToModify, Iterable&lt;?&gt; occurrencesToRemove) {
    if (occurrencesToRemove instanceof Multiset) {
      return removeOccurrences(multisetToModify, (Multiset&lt;?&gt;) occurrencesToRemove);
    } else {
      checkNotNull(multisetToModify);
      checkNotNull(occurrencesToRemove);
      boolean changed = false;
      for (Object o : occurrencesToRemove) {
        changed |= multisetToModify.remove(o);
      }
      return changed;
    }
  }

  /**
   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one
   * occurrence of {@code e} in {@code multisetToModify}.
   *
   * &lt;p&gt;Equivalently, this method modifies {@code multisetToModify} so that {@code
   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -
   * occurrencesToRemove.count(e))}.
   *
   * &lt;p&gt;This is &lt;i&gt;not&lt;/i&gt; the same as {@code multisetToModify.} {@link Multiset#removeAll
   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear
   * in {@code occurrencesToRemove}. However, this operation &lt;i&gt;is&lt;/i&gt; equivalent to, albeit
   * sometimes more efficient than, the following:
   *
   * &lt;pre&gt;{@code
   * for (E e : occurrencesToRemove) {
   *   multisetToModify.remove(e);
   * }
   * }&lt;/pre&gt;
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 10.0 (missing in 18.0 when only the overload taking an {@code Iterable} was present)
   */
  @CanIgnoreReturnValue
  public static boolean removeOccurrences(
      Multiset&lt;?&gt; multisetToModify, Multiset&lt;?&gt; occurrencesToRemove) {
    checkNotNull(multisetToModify);
    checkNotNull(occurrencesToRemove);

    boolean changed = false;
    Iterator&lt;? extends Entry&lt;?&gt;&gt; entryIterator = multisetToModify.entrySet().iterator();
    while (entryIterator.hasNext()) {
      Entry&lt;?&gt; entry = entryIterator.next();
      int removeCount = occurrencesToRemove.count(entry.getElement());
      if (removeCount &gt;= entry.getCount()) {
        entryIterator.remove();
        changed = true;
      } else if (removeCount &gt; 0) {
        multisetToModify.remove(entry.getElement(), removeCount);
        changed = true;
      }
    }
    return changed;
  }

  /**
   * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@link
   * Multiset.Entry}.
   */
  abstract static class AbstractEntry&lt;E extends @Nullable Object&gt; implements Multiset.Entry&lt;E&gt; {
    /**
     * Indicates whether an object equals this entry, following the behavior specified in {@link
     * Multiset.Entry#equals}.
     */
    @Override
    public boolean equals(@CheckForNull Object object) {
      if (object instanceof Multiset.Entry) {
        Multiset.Entry&lt;?&gt; that = (Multiset.Entry&lt;?&gt;) object;
        return this.getCount() == that.getCount()
            &amp;&amp; Objects.equal(this.getElement(), that.getElement());
      }
      return false;
    }

    /**
     * Return this entry's hash code, following the behavior specified in {@link
     * Multiset.Entry#hashCode}.
     */
    @Override
    public int hashCode() {
      E e = getElement();
      return ((e == null) ? 0 : e.hashCode()) ^ getCount();
    }

    /**
     * Returns a string representation of this multiset entry. The string representation consists of
     * the associated element if the associated count is one, and otherwise the associated element
     * followed by the characters &quot; x &quot; (space, x and space) followed by the count. Elements and
     * counts are converted to strings as by {@code String.valueOf}.
     */
    @Override
    public String toString() {
      String text = String.valueOf(getElement());
      int n = getCount();
      return (n == 1) ? text : (text + &quot; x &quot; + n);
    }
  }

  /** An implementation of {@link Multiset#equals}. */
  static boolean equalsImpl(Multiset&lt;?&gt; multiset, @CheckForNull Object object) {
    if (object == multiset) {
      return true;
    }
    if (object instanceof Multiset) {
      Multiset&lt;?&gt; that = (Multiset&lt;?&gt;) object;
      /*
       * We can't simply check whether the entry sets are equal, since that
       * approach fails when a TreeMultiset has a comparator that returns 0
       * when passed unequal elements.
       */

      if (multiset.size() != that.size() || multiset.entrySet().size() != that.entrySet().size()) {
        return false;
      }
      for (Entry&lt;?&gt; entry : that.entrySet()) {
        if (multiset.count(entry.getElement()) != entry.getCount()) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  /** An implementation of {@link Multiset#addAll}. */
  static &lt;E extends @Nullable Object&gt; boolean addAllImpl(
      Multiset&lt;E&gt; self, Collection&lt;? extends E&gt; elements) {
    checkNotNull(self);
    checkNotNull(elements);
    if (elements instanceof Multiset) {
      return addAllImpl(self, cast(elements));
    } else if (elements.isEmpty()) {
      return false;
    } else {
      return Iterators.addAll(self, elements.iterator());
    }
  }
<A NAME="16"></A>
  /** A specialization of {@code addAllImpl} for when {@code elements} is itself a Multiset. */
  private static &lt;E extends @Nullable Object&gt; boolean addAllImpl(
      <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match269455-1.html#16',3,'match269455-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Multiset&lt;E&gt; self, Multiset&lt;? extends E&gt; elements) {
    if (elements.isEmpty()) {
      return false;
    }</B></FONT>
    elements.forEachEntry(self::add);
    return true;
  }

  /** An implementation of {@link Multiset#removeAll}. */
  static boolean removeAllImpl(Multiset&lt;?&gt; self, Collection&lt;?&gt; elementsToRemove) {
    Collection&lt;?&gt; collection =
        (elementsToRemove instanceof Multiset)
            ? ((Multiset&lt;?&gt;) elementsToRemove).elementSet()
            : elementsToRemove;

    return self.elementSet().removeAll(collection);
  }

  /** An implementation of {@link Multiset#retainAll}. */
  static boolean retainAllImpl(Multiset&lt;?&gt; self, Collection&lt;?&gt; elementsToRetain) {
    checkNotNull(elementsToRetain);
    Collection&lt;?&gt; collection =
        (elementsToRetain instanceof Multiset)
            ? ((Multiset&lt;?&gt;) elementsToRetain).elementSet()
            : elementsToRetain;

    return self.elementSet().retainAll(collection);
  }

  /** An implementation of {@link Multiset#setCount(Object, int)}. */
  static &lt;E extends @Nullable Object&gt; int setCountImpl(
      Multiset&lt;E&gt; self, @ParametricNullness E element, int count) {
    checkNonnegative(count, &quot;count&quot;);

    int oldCount = self.count(element);

    int delta = count - oldCount;
    if (delta &gt; 0) {
      self.add(element, delta);
    } else if (delta &lt; 0) {
      self.remove(element, -delta);
    }

    return oldCount;
  }

  /** An implementation of {@link Multiset#setCount(Object, int, int)}. */
  static &lt;E extends @Nullable Object&gt; boolean setCountImpl(
      Multiset&lt;E&gt; self, @ParametricNullness E element, int oldCount, int newCount) {
    checkNonnegative(oldCount, &quot;oldCount&quot;);
    checkNonnegative(newCount, &quot;newCount&quot;);

    if (self.count(element) == oldCount) {
      self.setCount(element, newCount);
      return true;
    } else {
      return false;
    }
  }

  static &lt;E extends @Nullable Object&gt; Iterator&lt;E&gt; elementIterator(
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator) {
    return new TransformedIterator&lt;Entry&lt;E&gt;, E&gt;(entryIterator) {
      @Override
      @ParametricNullness
      E transform(Entry&lt;E&gt; entry) {
        return entry.getElement();
      }
    };
  }

  abstract static class ElementSet&lt;E extends @Nullable Object&gt; extends Sets.ImprovedAbstractSet&lt;E&gt; {
    abstract Multiset&lt;E&gt; multiset();

    @Override
    public void clear() {
      multiset().clear();
    }

    @Override
    public boolean contains(@CheckForNull Object o) {
      return multiset().contains(o);
<A NAME="5"></A>    }

    @Override
    public boolean containsAll(Collection&lt;?&gt; c) <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match269455-1.html#5',3,'match269455-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
      return multiset().containsAll(c);
    }

    @Override
    public boolean isEmpty() {
      return multiset().isEmpty();
    }

    @</B></FONT>Override
<A NAME="7"></A>    public abstract Iterator&lt;E&gt; iterator();

    @Override
    public boolean remove(<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match269455-1.html#7',3,'match269455-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@CheckForNull Object o) {
      return multiset().remove(o, Integer.MAX_VALUE) &gt; 0;
    }

    @Override
    public int size() {
      return multiset().entrySet</B></FONT>().size();
    }
  }

  abstract static class EntrySet&lt;E extends @Nullable Object&gt;
      extends Sets.ImprovedAbstractSet&lt;Entry&lt;E&gt;&gt; {
    abstract Multiset&lt;E&gt; multiset();

    @Override
    public boolean contains(@CheckForNull Object o) {
      if (o instanceof Entry) {
        /*
         * The GWT compiler wrongly issues a warning here.
         */
        @SuppressWarnings(&quot;cast&quot;)
        Entry&lt;?&gt; entry = (Entry&lt;?&gt;) o;
        if (entry.getCount() &lt;= 0) {
          return false;
        }
        int count = multiset().count(entry.getElement());
        return count == entry.getCount();
      }
      return false;
    }

    // GWT compiler warning; see contains().
    @SuppressWarnings(&quot;cast&quot;)
    @Override
    public boolean remove(@CheckForNull Object object) {
      if (object instanceof Multiset.Entry) {
        Entry&lt;?&gt; entry = (Entry&lt;?&gt;) object;
        Object element = entry.getElement();
        int entryCount = entry.getCount();
        if (entryCount != 0) {
          // Safe as long as we never add a new entry, which we won't.
          // (Presumably it can still throw CCE/NPE but only if the underlying Multiset does.)
          @SuppressWarnings({&quot;unchecked&quot;, &quot;nullness&quot;})
          Multiset&lt;@Nullable Object&gt; multiset = (Multiset&lt;@Nullable Object&gt;) multiset();
          return multiset.setCount(element, entryCount, 0);
        }
      }
      return false;
    }

    @Override
    public void clear() {
      multiset().clear();
    }
  }

  /** An implementation of {@link Multiset#iterator}. */
  static &lt;E extends @Nullable Object&gt; Iterator&lt;E&gt; iteratorImpl(Multiset&lt;E&gt; multiset) {
    return new MultisetIteratorImpl&lt;E&gt;(multiset, multiset.entrySet().iterator());
  }

  static final class MultisetIteratorImpl&lt;E extends @Nullable Object&gt; implements Iterator&lt;E&gt; {
    private final Multiset&lt;E&gt; multiset;
    private final Iterator&lt;Entry&lt;E&gt;&gt; entryIterator;
    @CheckForNull private Entry&lt;E&gt; currentEntry;

    /** Count of subsequent elements equal to current element */
    private int laterCount;

    /** Count of all elements equal to current element */
    private int totalCount;

    private boolean canRemove;

<A NAME="10"></A>    MultisetIteratorImpl(Multiset&lt;E&gt; multiset, Iterator&lt;Entry&lt;E&gt;&gt; entryIterator) {
      this.multiset = multiset;
      this.entryIterator = entryIterator;
    <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match269455-1.html#10',3,'match269455-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public boolean hasNext() {
      return laterCount &gt; 0 || entryIterator.hasNext();
    }

    @</B></FONT>Override
    @ParametricNullness
    public E next() {
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      if (laterCount == 0) {
        currentEntry = entryIterator.next();
        totalCount = laterCount = currentEntry.getCount();
      }
      laterCount--;
      canRemove = true;
      /*
       * requireNonNull is safe because laterCount starts at 0, forcing us to initialize
       * currentEntry above. After that, we never clear it.
       */
      return requireNonNull(currentEntry).getElement();
    }

    @Override
    public void remove() {
      checkRemove(canRemove);
      if (totalCount == 1) {
        entryIterator.remove();
      } else {
        /*
         * requireNonNull is safe because canRemove is set to true only after we initialize
         * currentEntry (which we never subsequently clear).
         */
        multiset.remove(requireNonNull(currentEntry).getElement());
      }
      totalCount--;
      canRemove = false;
    }
  }

  static &lt;E extends @Nullable Object&gt; Spliterator&lt;E&gt; spliteratorImpl(Multiset&lt;E&gt; multiset) {
    Spliterator&lt;Entry&lt;E&gt;&gt; entrySpliterator = multiset.entrySet().spliterator();
    return CollectSpliterators.flatMap(
        entrySpliterator,
        entry -&gt; Collections.nCopies(entry.getCount(), entry.getElement()).spliterator(),
        Spliterator.SIZED
            | (entrySpliterator.characteristics()
                &amp; (Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.IMMUTABLE)),
        multiset.size());
  }

  /** An implementation of {@link Multiset#size}. */
  static int linearTimeSizeImpl(Multiset&lt;?&gt; multiset) {
    long size = 0;
    for (Entry&lt;?&gt; entry : multiset.entrySet()) {
      size += entry.getCount();
    }
    return Ints.saturatedCast(size);
  }

<A NAME="12"></A>  /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
  static &lt;T extends @Nullable Object&gt; Multiset&lt;T&gt; cast(Iterable&lt;T&gt; iterable) {
    return (Multiset&lt;T&gt;) iterable;
  <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match269455-1.html#12',3,'match269455-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

  /**
   * Returns a copy of {@code multiset} as an {@link ImmutableMultiset} whose iteration order is
   * highest count first, with ties broken by the iteration order of the original multiset.
   *
   * @since 11.0
   */
  @Beta
  public static &lt;E&gt; ImmutableMultiset&lt;E&gt; copyHighestCountFirst(Multiset&lt;E&gt; multiset) {
    Entry&lt;E&gt;[] entries = (Entry&lt;E&gt;[]) multiset.entrySet</B></FONT>().toArray(new Entry[0]);
    Arrays.sort(entries, DecreasingCount.INSTANCE);
    return ImmutableMultiset.copyFromEntries(Arrays.asList(entries));
  }

  private static final class DecreasingCount implements Comparator&lt;Entry&lt;?&gt;&gt; {
    static final DecreasingCount INSTANCE = new DecreasingCount();

    @Override
    public int compare(Entry&lt;?&gt; entry1, Entry&lt;?&gt; entry2) {
      return entry2.getCount() - entry1.getCount(); // subtracting two nonnegative integers
    }
  }

  /**
   * An {@link AbstractMultiset} with additional default implementations, some of them linear-time
   * implementations in terms of {@code elementSet} and {@code entrySet}.
<A NAME="11"></A>   */
  private abstract static class ViewMultiset&lt;E extends @Nullable Object&gt;
      extends AbstractMultiset&lt;E&gt; {
    <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match269455-1.html#11',3,'match269455-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
    public int size() {
      return linearTimeSizeImpl(this);
    }
<A NAME="3"></A>
    @Override
    public void clear() {</B></FONT>
      <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match269455-1.html#3',3,'match269455-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>elementSet().clear();
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
      return iteratorImpl(this);
    }

    @Override
    int distinctElements() {
      return elementSet().size();
    }</B></FONT>
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>FreshValueGenerator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.testing;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Throwables.throwIfUnchecked;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.CharMatcher;
import com.google.common.base.Charsets;
import com.google.common.base.Equivalence;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.base.Ticker;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedMultiset;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.LinkedHashMultiset;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multiset;
import com.google.common.collect.Ordering;
import com.google.common.collect.Range;
import com.google.common.collect.RowSortedTable;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;
import com.google.common.collect.SortedMultiset;
import com.google.common.collect.Table;
import com.google.common.collect.TreeBasedTable;
import com.google.common.collect.TreeMultiset;
import com.google.common.primitives.Primitives;
import com.google.common.primitives.UnsignedInteger;
import com.google.common.primitives.UnsignedLong;
import com.google.common.reflect.AbstractInvocationHandler;
import com.google.common.reflect.Invokable;
import com.google.common.reflect.Parameter;
import com.google.common.reflect.Reflection;
import com.google.common.reflect.TypeToken;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
<A NAME="0"></A>import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#0',2,'match269455-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Currency;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Generates fresh instances of types that are different from each other (if possible).
 *
 * @author Ben Yu
 */
@</B></FONT>GwtIncompatible
class FreshValueGenerator {

  private static final ImmutableMap&lt;Class&lt;?&gt;, Method&gt; GENERATORS;

  static {
    ImmutableMap.Builder&lt;Class&lt;?&gt;, Method&gt; builder = ImmutableMap.builder();
    for (Method method : FreshValueGenerator.class.getDeclaredMethods()) {
      if (method.isAnnotationPresent(Generates.class)) {
        builder.put(method.getReturnType(), method);
      }
    }
    GENERATORS = builder.buildOrThrow();
  }

  private static final ImmutableMap&lt;Class&lt;?&gt;, Method&gt; EMPTY_GENERATORS;

  static {
    ImmutableMap.Builder&lt;Class&lt;?&gt;, Method&gt; builder = ImmutableMap.builder();
    for (Method method : FreshValueGenerator.class.getDeclaredMethods()) {
      if (method.isAnnotationPresent(Empty.class)) {
        builder.put(method.getReturnType(), method);
      }
    }
    EMPTY_GENERATORS = builder.buildOrThrow();
  }

  private final AtomicInteger freshness = new AtomicInteger(1);
  private final ListMultimap&lt;Class&lt;?&gt;, Object&gt; sampleInstances = ArrayListMultimap.create();

  /**
   * The freshness level at which the {@link Empty @Empty} annotated method was invoked to generate
   * instance.
   */
  private final Map&lt;Type, Integer&gt; emptyInstanceGenerated = new HashMap&lt;&gt;();

  final &lt;T&gt; void addSampleInstances(Class&lt;T&gt; type, Iterable&lt;? extends T&gt; instances) {
    sampleInstances.putAll(checkNotNull(type), checkNotNull(instances));
  }

  /**
   * Returns a fresh instance for {@code type} if possible. The returned instance could be:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;exactly of the given type, including generic type parameters, such as {@code
   *       ImmutableList&lt;String&gt;};
   *   &lt;li&gt;of the raw type;
   *   &lt;li&gt;null if no value can be generated.
   * &lt;/ul&gt;
   */
<A NAME="18"></A>  final @Nullable Object generateFresh(TypeToken&lt;?&gt; type) {
    Object generated = generate(type);
    if (generated != null) {
      <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#18',2,'match269455-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>freshness.incrementAndGet();
    }
    return generated;
  }

  final &lt;T</B></FONT>&gt; @Nullable T generateFresh(Class&lt;T&gt; type) {
    return Primitives.wrap(type).cast(generateFresh(TypeToken.of(type)));
  }

  final &lt;T&gt; T newFreshProxy(final Class&lt;T&gt; interfaceType) {
    T proxy = newProxy(interfaceType);
    freshness.incrementAndGet();
    return proxy;
  }

  /**
   * Generates an instance for {@code type} using the current {@link #freshness}. The generated
   * instance may or may not be unique across different calls.
   */
  private Object generate(TypeToken&lt;?&gt; type) {
    Class&lt;?&gt; rawType = type.getRawType();
    List&lt;Object&gt; samples = sampleInstances.get(rawType);
    Object sample = pickInstance(samples, null);
    if (sample != null) {
      return sample;
    }
    if (rawType.isEnum()) {
      return pickInstance(rawType.getEnumConstants(), null);
    }
    if (type.isArray()) {
      TypeToken&lt;?&gt; componentType = type.getComponentType();
      Object array = Array.newInstance(componentType.getRawType(), 1);
      Array.set(array, 0, generate(componentType));
      return array;
    }
    Method emptyGenerate = EMPTY_GENERATORS.get(rawType);
    if (emptyGenerate != null) {
      if (emptyInstanceGenerated.containsKey(type.getType())) {
        // empty instance already generated
        if (emptyInstanceGenerated.get(type.getType()).intValue() == freshness.get()) {
          // same freshness, generate again.
          return invokeGeneratorMethod(emptyGenerate);
        } else {
          // Cannot use empty generator. Proceed with other generators.
        }
      } else {
        // never generated empty instance for this type before.
        Object emptyInstance = invokeGeneratorMethod(emptyGenerate);
        emptyInstanceGenerated.put(type.getType(), freshness.get());
        return emptyInstance;
      }
    }
    Method generate = GENERATORS.get(rawType);
    if (generate != null) {
      ImmutableList&lt;Parameter&gt; params = Invokable.from(generate).getParameters();
      List&lt;Object&gt; args = Lists.newArrayListWithCapacity(params.size());
      TypeVariable&lt;?&gt;[] typeVars = rawType.getTypeParameters();
      for (int i = 0; i &lt; params.size(); i++) {
        TypeToken&lt;?&gt; paramType = type.resolveType(typeVars[i]);
        // We require all @Generates methods to either be parameter-less or accept non-null
        // values for their generic parameter types.
        Object argValue = generate(paramType);
        if (argValue == null) {
          // When a parameter of a @Generates method cannot be created,
          // The type most likely is a collection.
          // Our distinct proxy doesn't work for collections.
          // So just refuse to generate.
          return null;
        }
        args.add(argValue);
      }
      return invokeGeneratorMethod(generate, args.toArray());
    }
    return defaultGenerate(rawType);
  }

  private &lt;T&gt; T defaultGenerate(Class&lt;T&gt; rawType) {
    if (rawType.isInterface()) {
      // always create a new proxy
      return newProxy(rawType);
    }
    return ArbitraryInstances.get(rawType);
  }

  private &lt;T&gt; T newProxy(final Class&lt;T&gt; interfaceType) {
    return Reflection.newProxy(interfaceType, new FreshInvocationHandler(interfaceType));
  }

  private Object invokeGeneratorMethod(Method generator, Object... args) {
    try {
      return generator.invoke(this, args);
    } catch (InvocationTargetException e) {
      throwIfUnchecked(e.getCause());
      throw new RuntimeException(e.getCause());
    } catch (Exception e) {
      throwIfUnchecked(e);
      throw new RuntimeException(e);
    }
  }
<A NAME="20"></A>
  private final class FreshInvocationHandler extends AbstractInvocationHandler {
    private final int identity = generateInt();
    <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#20',2,'match269455-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private final Class&lt;?&gt; interfaceType;

    FreshInvocationHandler(Class&lt;?&gt; interfaceType) {
      this.interfaceType = interfaceType;
    }

<A NAME="14"></A>    @</B></FONT>Override
    protected Object handleInvocation(Object proxy, Method method, Object[] args) {
      return interfaceMethodCalled(interfaceType, method);
    <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#14',2,'match269455-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Override
    public int hashCode() {
      return identity;
    }

    @</B></FONT>Override
    public boolean equals(@Nullable Object obj) {
      if (obj instanceof FreshInvocationHandler) {
        FreshInvocationHandler that = (FreshInvocationHandler) obj;
        return identity == that.identity;
      }
      return false;
    }

    @Override
    public String toString() {
      return paramString(interfaceType, identity);
    }
  }

  /** Subclasses can override to provide different return value for proxied interface methods. */
  Object interfaceMethodCalled(Class&lt;?&gt; interfaceType, Method method) {
    throw new UnsupportedOperationException();
  }

  private &lt;T&gt; T pickInstance(T[] instances, T defaultValue) {
<A NAME="16"></A>    return pickInstance(Arrays.asList(instances), defaultValue);
  }

  private &lt;T&gt; T pickInstance(<FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#16',2,'match269455-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Collection&lt;T&gt; instances, T defaultValue) {
    if (instances.isEmpty()) {
      return defaultValue;
    }</B></FONT>
    // generateInt() is 1-based.
    return Iterables.get(instances, (generateInt() - 1) % instances.size());
  }

  private static String paramString(Class&lt;?&gt; type, int i) {
    return type.getSimpleName() + '@' + i;
  }

  /**
   * Annotates a method to be the instance generator of a certain type. The return type is the
   * generated type. The method parameters correspond to the generated type's type parameters. For
   * example, if the annotated method returns {@code Map&lt;K, V&gt;}, the method signature should be:
   * {@code Map&lt;K, V&gt; generateMap(K key, V value)}.
   */
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  private @interface Generates {}

  /**
   * Annotates a method to generate the &quot;empty&quot; instance of a collection. This method should accept
   * no parameter. The value it generates should be unequal to the values generated by methods
   * annotated with {@link Generates}.
   */
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  private @interface Empty {}

  @Generates
  Class&lt;?&gt; generateClass() {
    return pickInstance(
<A NAME="10"></A>        ImmutableList.of(
            int.class, long.class, void.class, Object.class, Object[].class, Iterable.class),
        Object.class);
  <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#10',2,'match269455-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  @Generates
  Object generateObject() {
    return generateString();
  }

  @</B></FONT>Generates
  Number generateNumber() {
<A NAME="11"></A>    return generateInt();
  }

  <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#11',2,'match269455-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Generates
  int generateInt() {
    return freshness.get();
  }

  @Generates
  Integer generateInteger() {</B></FONT>
    return new Integer(generateInt());
  }

  @Generates
  long generateLong() {
    return generateInt();
  }

  @Generates
  Long generateLongObject() {
    return new Long(generateLong());
  }

  @Generates
  float generateFloat() {
    return generateInt();
  }

  @Generates
  Float generateFloatObject() {
    return new Float(generateFloat());
  }

  @Generates
  double generateDouble() {
    return generateInt();
  }

  @Generates
  Double generateDoubleObject() {
    return new Double(generateDouble());
  }

  @Generates
  short generateShort() {
    return (short) generateInt();
  }

  @Generates
  Short generateShortObject() {
    return new Short(generateShort());
  }

  @Generates
  byte generateByte() {
    return (byte) generateInt();
  }

<A NAME="13"></A>  @Generates
  Byte generateByteObject() {
    return new Byte(generateByte());
  <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#13',2,'match269455-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  @Generates
  char generateChar() {
    return generateString().charAt(0);
  }</B></FONT>

  @Generates
  Character generateCharacter() {
    return new Character(generateChar());
  }

  @Generates
  boolean generateBoolean() {
    return generateInt() % 2 == 0;
  }
<A NAME="2"></A>
  @Generates
  Boolean generateBooleanObject() {
    return new Boolean(<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#2',2,'match269455-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>generateBoolean());
  }

  @Generates
  UnsignedInteger generateUnsignedInteger() {
    return UnsignedInteger.fromIntBits(generateInt());
  }

  @Generates
  UnsignedLong generateUnsignedLong() {
    return UnsignedLong.fromLongBits(generateLong());
  }

  @Generates
  BigInteger generateBigInteger() {</B></FONT>
    return BigInteger.valueOf(generateInt());
  }
<A NAME="3"></A>
  @Generates
  BigDecimal generateBigDecimal() {
    return <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#3',2,'match269455-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BigDecimal.valueOf(generateInt());
  }

  @Generates
  CharSequence generateCharSequence() {
    return generateString();
  }

  @Generates
  String generateString() {
    return Integer.toString(generateInt());
  }</B></FONT>
<A NAME="1"></A>
  @Generates
  Comparable&lt;?&gt; generateComparable() {
    return <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#1',2,'match269455-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>generateString();
  }

  @Generates
  Pattern generatePattern() {
    return Pattern.compile(generateString());
  }

  @Generates
  Charset generateCharset() {
    return pickInstance(Charset.availableCharsets().values(), Charsets.UTF_8);
<A NAME="19"></A>  }

  @</B></FONT>Generates
  Locale generateLocale() <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#19',2,'match269455-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    return pickInstance(Locale.getAvailableLocales(), Locale.US);
  }

  @Generates
  Currency generateCurrency() {</B></FONT>
    try {
      Method method = Currency.class.getMethod(&quot;getAvailableCurrencies&quot;);
      @SuppressWarnings(&quot;unchecked&quot;) // getAvailableCurrencies() returns Set&lt;Currency&gt;.
      Set&lt;Currency&gt; currencies = (Set&lt;Currency&gt;) method.invoke(null);
      return pickInstance(currencies, Currency.getInstance(Locale.US));
      /*
       * Do not merge the 2 catch blocks below. javac would infer a type of
       * ReflectiveOperationException, which Animal Sniffer would reject. (Old versions of
       * Android don't *seem* to mind, but there might be edge cases of which we're unaware.)
       */
    } catch (NoSuchMethodException notJava7) {
      return preJava7FreshCurrency();
    } catch (InvocationTargetException notJava7) {
      return preJava7FreshCurrency();
    } catch (IllegalAccessException impossible) {
      throw new AssertionError(impossible);
    }
  }

  private Currency preJava7FreshCurrency() {
    for (Set&lt;Locale&gt; uselessLocales = Sets.newHashSet(); ; ) {
      Locale locale = generateLocale();
      if (uselessLocales.contains(locale)) { // exhausted all locales
        return Currency.getInstance(Locale.US);
      }
      try {
        return Currency.getInstance(locale);
      } catch (IllegalArgumentException e) {
        uselessLocales.add(locale);
      }
    }
  }
<A NAME="9"></A>
  @Empty
  &lt;T&gt; Optional&lt;T&gt; generateJavaOptional() {
    return <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#9',2,'match269455-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Optional.empty();
  }

  @Generates
  &lt;T&gt; Optional&lt;T&gt; generateJavaOptional(T value) {
<A NAME="4"></A>    return Optional.of(value);
  }</B></FONT>

  <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#4',2,'match269455-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Generates
  OptionalInt generateOptionalInt() {
    return OptionalInt.of(generateInt());
  }

  @Generates
  OptionalLong generateOptionalLong() {
    return OptionalLong.of(generateLong());
  }

  @</B></FONT>Generates
  OptionalDouble generateOptionalDouble() {
    return OptionalDouble.of(generateDouble());
  }

  // common.base
  @Empty
  &lt;T&gt; com.google.common.base.Optional&lt;T&gt; generateGoogleOptional() {
    return com.google.common.base.Optional.absent();
  }

  @Generates
  &lt;T&gt; com.google.common.base.Optional&lt;T&gt; generateGoogleOptional(T value) {
    return com.google.common.base.Optional.of(value);
<A NAME="5"></A>  }

  @Generates
  Joiner generateJoiner() <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#5',2,'match269455-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    return Joiner.on(generateString());
  }

  @Generates
  Splitter generateSplitter() {
    return Splitter.on(generateString());
  }

  @</B></FONT>Generates
  &lt;T&gt; Equivalence&lt;T&gt; generateEquivalence() {
    return new Equivalence&lt;T&gt;() {
      @Override
      protected boolean doEquivalent(T a, T b) {
        return false;
      }

      @Override
      protected int doHash(T t) {
        return 0;
      }

      final String string = paramString(Equivalence.class, generateInt());

      @Override
      public String toString() {
        return string;
      }
    };
  }

  @Generates
  CharMatcher generateCharMatcher() {
    return new CharMatcher() {
      @Override
      public boolean matches(char c) {
        return false;
      }

      final String string = paramString(CharMatcher.class, generateInt());

      @Override
      public String toString() {
        return string;
      }
    };
  }

  @Generates
  Ticker generateTicker() {
    return new Ticker() {
      @Override
      public long read() {
        return 0;
      }

      final String string = paramString(Ticker.class, generateInt());

      @Override
      public String toString() {
        return string;
      }
    };
  }

  // collect
  @Generates
  &lt;T&gt; Comparator&lt;T&gt; generateComparator() {
    return generateOrdering();
  }

  @Generates
  &lt;T&gt; Ordering&lt;T&gt; generateOrdering() {
    return new Ordering&lt;T&gt;() {
      @Override
      public int compare(T left, T right) {
        return 0;
      }

      final String string = paramString(Ordering.class, generateInt());

      @Override
      public String toString() {
        return string;
      }
    };
  }

  @Empty
  static &lt;C extends Comparable&lt;?&gt;&gt; Range&lt;C&gt; generateRange() {
    return Range.all();
  }

  @Generates
  static &lt;C extends Comparable&lt;?&gt;&gt; Range&lt;C&gt; generateRange(C freshElement) {
    return Range.singleton(freshElement);
  }

  @Generates
  static &lt;E&gt; Iterable&lt;E&gt; generateIterable(@Nullable E freshElement) {
    return generateList(freshElement);
  }

  @Generates
  static &lt;E&gt; Collection&lt;E&gt; generateCollection(@Nullable E freshElement) {
    return generateList(freshElement);
  }

  @Generates
  static &lt;E&gt; List&lt;E&gt; generateList(@Nullable E freshElement) {
    return generateArrayList(freshElement);
  }

  @Generates
  static &lt;E&gt; ArrayList&lt;E&gt; generateArrayList(@Nullable E freshElement) {
    ArrayList&lt;E&gt; list = Lists.newArrayList();
    list.add(freshElement);
    return list;
  }

  @Generates
  static &lt;E&gt; LinkedList&lt;E&gt; generateLinkedList(@Nullable E freshElement) {
    LinkedList&lt;E&gt; list = Lists.newLinkedList();
    list.add(freshElement);
    return list;
  }

  @Generates
  static &lt;E&gt; ImmutableList&lt;E&gt; generateImmutableList(E freshElement) {
    return ImmutableList.of(freshElement);
  }

  @Generates
  static &lt;E&gt; ImmutableCollection&lt;E&gt; generateImmutableCollection(E freshElement) {
    return generateImmutableList(freshElement);
  }

  @Generates
  static &lt;E&gt; Set&lt;E&gt; generateSet(@Nullable E freshElement) {
    return generateHashSet(freshElement);
  }

  @Generates
  static &lt;E&gt; HashSet&lt;E&gt; generateHashSet(@Nullable E freshElement) {
    return generateLinkedHashSet(freshElement);
  }

  @Generates
  static &lt;E&gt; LinkedHashSet&lt;E&gt; generateLinkedHashSet(@Nullable E freshElement) {
    LinkedHashSet&lt;E&gt; set = Sets.newLinkedHashSet();
    set.add(freshElement);
    return set;
  }

  @Generates
  static &lt;E&gt; ImmutableSet&lt;E&gt; generateImmutableSet(E freshElement) {
    return ImmutableSet.of(freshElement);
  }

  @Generates
  static &lt;E extends Comparable&lt;? super E&gt;&gt; SortedSet&lt;E&gt; generateSortedSet(E freshElement) {
    return generateNavigableSet(freshElement);
  }

<A NAME="12"></A>  @Generates
  static &lt;E extends Comparable&lt;? super E&gt;&gt; NavigableSet&lt;E&gt; generateNavigableSet(E freshElement) {
    return generateTreeSet(freshElement);
  <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#12',2,'match269455-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  @Generates
  static &lt;E extends Comparable&lt;? super E&gt;&gt; TreeSet&lt;E&gt; generateTreeSet(E freshElement) {
    TreeSet&lt;E&gt; set = Sets.newTreeSet();
    set.add</B></FONT>(freshElement);
    return set;
  }

  @Generates
  static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; generateImmutableSortedSet(
      E freshElement) {
    return ImmutableSortedSet.of(freshElement);
  }

  @Generates
  static &lt;E&gt; Multiset&lt;E&gt; generateMultiset(@Nullable E freshElement) {
    return generateHashMultiset(freshElement);
  }

  @Generates
  static &lt;E&gt; HashMultiset&lt;E&gt; generateHashMultiset(@Nullable E freshElement) {
    HashMultiset&lt;E&gt; multiset = HashMultiset.create();
    multiset.add(freshElement);
    return multiset;
  }

  @Generates
  static &lt;E&gt; LinkedHashMultiset&lt;E&gt; generateLinkedHashMultiset(@Nullable E freshElement) {
    LinkedHashMultiset&lt;E&gt; multiset = LinkedHashMultiset.create();
    multiset.add(freshElement);
    return multiset;
  }

  @Generates
  static &lt;E&gt; ImmutableMultiset&lt;E&gt; generateImmutableMultiset(E freshElement) {
    return ImmutableMultiset.of(freshElement);
  }

  @Generates
  static &lt;E extends Comparable&lt;E&gt;&gt; SortedMultiset&lt;E&gt; generateSortedMultiset(E freshElement) {
    return generateTreeMultiset(freshElement);
  }

  @Generates
  static &lt;E extends Comparable&lt;E&gt;&gt; TreeMultiset&lt;E&gt; generateTreeMultiset(E freshElement) {
    TreeMultiset&lt;E&gt; multiset = TreeMultiset.create();
    multiset.add(freshElement);
    return multiset;
  }

  @Generates
  static &lt;E extends Comparable&lt;E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; generateImmutableSortedMultiset(
      E freshElement) {
    return ImmutableSortedMultiset.of(freshElement);
  }

  @Generates
  static &lt;K, V&gt; Map&lt;K, V&gt; generateMap(@Nullable K key, @Nullable V value) {
    return generateHashdMap(key, value);
  }

  @Generates
  static &lt;K, V&gt; HashMap&lt;K, V&gt; generateHashdMap(@Nullable K key, @Nullable V value) {
    return generateLinkedHashMap(key, value);
  }

  @Generates
  static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; generateLinkedHashMap(@Nullable K key, @Nullable V value) {
    LinkedHashMap&lt;K, V&gt; map = Maps.newLinkedHashMap();
    map.put(key, value);
    return map;
  }

  @Generates
  static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; generateImmutableMap(K key, V value) {
    return ImmutableMap.of(key, value);
  }

  @Empty
  static &lt;K, V&gt; ConcurrentMap&lt;K, V&gt; generateConcurrentMap() {
    return Maps.newConcurrentMap();
  }

  @Generates
  static &lt;K, V&gt; ConcurrentMap&lt;K, V&gt; generateConcurrentMap(K key, V value) {
    ConcurrentMap&lt;K, V&gt; map = Maps.newConcurrentMap();
    map.put(key, value);
    return map;
  }

  @Generates
  static &lt;K extends Comparable&lt;? super K&gt;, V&gt; SortedMap&lt;K, V&gt; generateSortedMap(
      K key, @Nullable V value) {
    return generateNavigableMap(key, value);
  }

  @Generates
  static &lt;K extends Comparable&lt;? super K&gt;, V&gt; NavigableMap&lt;K, V&gt; generateNavigableMap(
      K key, @Nullable V value) {
    return generateTreeMap(key, value);
  }

  @Generates
  static &lt;K extends Comparable&lt;? super K&gt;, V&gt; TreeMap&lt;K, V&gt; generateTreeMap(
      K key, @Nullable V value) {
    TreeMap&lt;K, V&gt; map = Maps.newTreeMap();
    map.put(key, value);
    return map;
  }

  @Generates
  static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; generateImmutableSortedMap(
      K key, V value) {
    return ImmutableSortedMap.of(key, value);
  }

  @Generates
  static &lt;K, V&gt; Multimap&lt;K, V&gt; generateMultimap(@Nullable K key, @Nullable V value) {
    return generateListMultimap(key, value);
  }

  @Generates
  static &lt;K, V&gt; ImmutableMultimap&lt;K, V&gt; generateImmutableMultimap(K key, V value) {
    return ImmutableMultimap.of(key, value);
  }

  @Generates
  static &lt;K, V&gt; ListMultimap&lt;K, V&gt; generateListMultimap(@Nullable K key, @Nullable V value) {
    return generateArrayListMultimap(key, value);
  }

  @Generates
  static &lt;K, V&gt; ArrayListMultimap&lt;K, V&gt; generateArrayListMultimap(
      @Nullable K key, @Nullable V value) {
    ArrayListMultimap&lt;K, V&gt; multimap = ArrayListMultimap.create();
    multimap.put(key, value);
    return multimap;
  }

  @Generates
  static &lt;K, V&gt; ImmutableListMultimap&lt;K, V&gt; generateImmutableListMultimap(K key, V value) {
    return ImmutableListMultimap.of(key, value);
  }

  @Generates
  static &lt;K, V&gt; SetMultimap&lt;K, V&gt; generateSetMultimap(@Nullable K key, @Nullable V value) {
    return generateLinkedHashMultimap(key, value);
  }

  @Generates
  static &lt;K, V&gt; HashMultimap&lt;K, V&gt; generateHashMultimap(@Nullable K key, @Nullable V value) {
    HashMultimap&lt;K, V&gt; multimap = HashMultimap.create();
    multimap.put(key, value);
    return multimap;
  }

  @Generates
  static &lt;K, V&gt; LinkedHashMultimap&lt;K, V&gt; generateLinkedHashMultimap(
      @Nullable K key, @Nullable V value) {
    LinkedHashMultimap&lt;K, V&gt; multimap = LinkedHashMultimap.create();
    multimap.put(key, value);
    return multimap;
  }

  @Generates
  static &lt;K, V&gt; ImmutableSetMultimap&lt;K, V&gt; generateImmutableSetMultimap(K key, V value) {
    return ImmutableSetMultimap.of(key, value);
  }

  @Generates
  static &lt;K, V&gt; BiMap&lt;K, V&gt; generateBimap(@Nullable K key, @Nullable V value) {
    return generateHashBiMap(key, value);
  }

  @Generates
  static &lt;K, V&gt; HashBiMap&lt;K, V&gt; generateHashBiMap(@Nullable K key, @Nullable V value) {
    HashBiMap&lt;K, V&gt; bimap = HashBiMap.create();
    bimap.put(key, value);
    return bimap;
  }

  @Generates
  static &lt;K, V&gt; ImmutableBiMap&lt;K, V&gt; generateImmutableBimap(K key, V value) {
    return ImmutableBiMap.of(key, value);
  }

  @Generates
  static &lt;R, C, V&gt; Table&lt;R, C, V&gt; generateTable(
      @Nullable R row, @Nullable C column, @Nullable V value) {
    return generateHashBasedTable(row, column, value);
  }

  @Generates
  static &lt;R, C, V&gt; HashBasedTable&lt;R, C, V&gt; generateHashBasedTable(
      @Nullable R row, @Nullable C column, @Nullable V value) {
    HashBasedTable&lt;R, C, V&gt; table = HashBasedTable.create();
    table.put(row, column, value);
    return table;
  }
<A NAME="15"></A>
  @SuppressWarnings(&quot;rawtypes&quot;) // TreeBasedTable.create() is defined as such
  @Generates
  static &lt;R extends Comparable, C extends Comparable, <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#15',2,'match269455-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>V&gt;
      RowSortedTable&lt;R, C, V&gt; generateRowSortedTable(R row, C column, V value) {
    return generateTreeBasedTable(row, column, value);
  }

  @SuppressWarnings(&quot;raw</B></FONT>types&quot;) // TreeBasedTable.create() is defined as such
  @Generates
  static &lt;R extends Comparable, C extends Comparable, V&gt;
      TreeBasedTable&lt;R, C, V&gt; generateTreeBasedTable(R row, C column, V value) {
    TreeBasedTable&lt;R, C, V&gt; table = TreeBasedTable.create();
    table.put(row, column, value);
    return table;
  }
<A NAME="17"></A>
  @Generates
  static &lt;R, C, V&gt; ImmutableTable&lt;R, C, V&gt; generateImmutableTable(R row, C column, V value) {
    return <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#17',2,'match269455-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ImmutableTable.of(row, column, value);
  }

  // common.reflect
  @Generates
  TypeToken&lt;?&gt; generateTypeToken() {
    return TypeToken.of(generateClass</B></FONT>());
  }

  // io types
  @Generates
  File generateFile() {
    return new File(generateString());
  }

  @Generates
  static ByteArrayInputStream generateByteArrayInputStream() {
    return new ByteArrayInputStream(new byte[0]);
  }

  @Generates
  static InputStream generateInputStream() {
    return generateByteArrayInputStream();
  }

  @Generates
  StringReader generateStringReader() {
    return new StringReader(generateString());
  }

  @Generates
  Reader generateReader() {
    return generateStringReader();
  }

  @Generates
  Readable generateReadable() {
    return generateReader();
  }

  @Generates
  Buffer generateBuffer() {
    return generateCharBuffer();
  }
<A NAME="6"></A>
  @Generates
  CharBuffer generateCharBuffer() {
    return <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#6',2,'match269455-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CharBuffer.allocate(generateInt());
  }

  @Generates
  ByteBuffer generateByteBuffer() {
    return ByteBuffer.allocate(generateInt());
  }

  @</B></FONT>Generates
  ShortBuffer generateShortBuffer() {
<A NAME="8"></A>    return ShortBuffer.allocate(generateInt());
  }

  <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#8',2,'match269455-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Generates
  IntBuffer generateIntBuffer() {
    return IntBuffer.allocate(generateInt());
  }

  @Generates
  LongBuffer generateLongBuffer() {
<A NAME="7"></A>    return LongBuffer.allocate(generateInt</B></FONT>());
  }

  <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match269455-0.html#7',2,'match269455-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Generates
  FloatBuffer generateFloatBuffer() {
    return FloatBuffer.allocate(generateInt());
  }

  @Generates
  DoubleBuffer generateDoubleBuffer() {
    return DoubleBuffer.allocate(generateInt</B></FONT>());
  }
}
</PRE>
</div>
  </div>
</body>
</html>
