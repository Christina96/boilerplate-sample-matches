<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for Multisets_1.java &amp; FreshValueGenerator.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Multisets_1.java &amp; FreshValueGenerator.java
      </h3>
<h1 align="center">
        17.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Multisets_1.java (18.234165%)<th>FreshValueGenerator.java (17.241379%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-62)<td><a href="#" name="0">(97-132)</a><td align="center"><font color="#ff0000">31</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(554-567)<td><a href="#" name="1">(488-501)</a><td align="center"><font color="#b40000">22</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(326-340)<td><a href="#" name="2">(453-467)</a><td align="center"><font color="#b40000">22</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1196-1207)<td><a href="#" name="3">(473-484)</a><td align="center"><font color="#9c0000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(422-431)<td><a href="#" name="4">(551-561)</a><td align="center"><font color="#8b0000">17</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1003-1012)<td><a href="#" name="5">(578-587)</a><td align="center"><font color="#830000">16</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(159-168)<td><a href="#" name="6">(1011-1019)</a><td align="center"><font color="#730000">14</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1016-1022)<td><a href="#" name="7">(1034-1041)</a><td align="center"><font color="#6a0000">13</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(568-574)<td><a href="#" name="8">(1024-1031)</a><td align="center"><font color="#6a0000">13</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(109-121)<td><a href="#" name="9">(543-549)</a><td align="center"><font color="#620000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1093-1100)<td><a href="#" name="10">(364-371)</a><td align="center"><font color="#5a0000">11</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1189-1195)<td><a href="#" name="11">(376-382)</a><td align="center"><font color="#520000">10</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(1159-1169)<td><a href="#" name="12">(745-750)</a><td align="center"><font color="#520000">10</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(678-683)<td><a href="#" name="13">(434-439)</a><td align="center"><font color="#520000">10</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(267-274)<td><a href="#" name="14">(296-303)</a><td align="center"><font color="#520000">10</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(84-102)<td><a href="#" name="15">(948-953)</a><td align="center"><font color="#520000">10</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(918-921)<td><a href="#" name="16">(327-330)</a><td align="center"><font color="#4a0000">9</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(433-438)<td><a href="#" name="17">(964-970)</a><td align="center"><font color="#4a0000">9</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(397-415)<td><a href="#" name="18">(185-190)</a><td align="center"><font color="#4a0000">9</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(140-145)<td><a href="#" name="19">(502-507)</a><td align="center"><font color="#4a0000">9</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(125-131)<td><a href="#" name="20">(287-293)</a><td align="center"><font color="#4a0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Multisets_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<a name="0"></a>
package com.google.common.collect;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
import static com.google.common.collect.CollectPreconditions.checkRemove;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Multiset.Entry;
import com.google.common.math.IntMath;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.function.ToIntFunction;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Provides static utility methods for creating and working with {@link Multiset} instances.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets"&gt;{@code
 * Multisets}&lt;/a&gt;.
 *
 * @author Kevin Bourrillion
 * @author Mike Bostock
 * @author Louis Wasserman
 * @since 2.0
 */
@</b></font>GwtCompatible
@ElementTypesAreNonnullByDefault
public final class Multisets {
  private Multisets() {}

  /**
   * Returns a {@code Collector} that accumulates elements into a multiset created via the specified
   * {@code Supplier}, whose elements are the result of applying {@code elementFunction} to the
   * inputs, with counts equal to the result of applying {@code countFunction} to the inputs.
   * Elements are added in encounter order.
   *
   * &lt;p&gt;If the mapped elements contain duplicates (according to {@link Object#equals}), the element
   * will be added more than once, with the count summed over all appearances of the element.
   *
   * &lt;p&gt;Note that {@code stream.collect(toMultiset(function, e -&gt; 1, supplier))} is equivalent to
   * {@code stream.map(function).collect(Collectors.toCollection(supplier))}.
   *
   * &lt;p&gt;To collect to an {@link ImmutableMultiset}, use {@link
   * ImmutableMultiset#toImmutableMultiset}.
<a name="15"></a>   *
   * @since 22.0
   */
  public static &lt;T extends @Nullable Object, E extends @Nullable Object, <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>M extends Multiset&lt;E&gt;&gt;
      Collector&lt;T, ?, M&gt; toMultiset(
          Function&lt;? super T, E&gt; elementFunction,
          ToIntFunction&lt;? super T&gt; countFunction,
          Supplier&lt;M&gt; multisetSupplier) {
    return CollectCollectors.toMultiset(elementFunction, countFunction, multisetSupplier);
  }

  /**
   * Returns an unmodifiable view of the specified multiset. Query operations on the returned
   * multiset "read through" to the specified multiset, and attempts to modify the returned multiset
   * result in an {@link UnsupportedOperationException}.
   *
   * &lt;p&gt;The returned multiset will be serializable if the specified multiset is serializable.
   *
   * @param multiset the multiset for which an unmodifiable view is to be generated
   * @return an unmodifiable view of the multiset
   */
  public static &lt;E ext</b></font>ends @Nullable Object&gt; Multiset&lt;E&gt; unmodifiableMultiset(
      Multiset&lt;? extends E&gt; multiset) {
    if (multiset instanceof UnmodifiableMultiset || multiset instanceof ImmutableMultiset) {
      @SuppressWarnings("unchecked") // Since it's unmodifiable, the covariant cast is safe
<a name="9"></a>      Multiset&lt;E&gt; result = (Multiset&lt;E&gt;) multiset;
      return result;
    }
    return new UnmodifiableMultiset&lt;E&gt;(<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>checkNotNull(multiset));
  }

  /**
   * Simply returns its argument.
   *
   * @deprecated no need to use this
   * @since 10.0
   */
  @Deprecated
  public static &lt;E&gt; Multiset&lt;E&gt; unmodifiableMultiset(ImmutableMultiset&lt;E&gt; multiset) {
    return checkNotNull(multiset);
  }</b></font>
<a name="20"></a>
  static class UnmodifiableMultiset&lt;E extends @Nullable Object&gt; extends ForwardingMultiset&lt;E&gt;
      implements Serializable {
    <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final Multiset&lt;? extends E&gt; delegate;

    UnmodifiableMultiset(Multiset&lt;? extends E&gt; delegate) {
      this.delegate = delegate;
    }

    @</b></font>SuppressWarnings("unchecked")
    @Override
    protected Multiset&lt;E&gt; delegate() {
      // This is safe because all non-covariant methods are overridden
      return (Multiset&lt;E&gt;) delegate;
    }
<a name="19"></a>
    @CheckForNull transient Set&lt;E&gt; elementSet;

    Set&lt;E&gt; createElementSet() <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
      return Collections.&lt;E&gt;unmodifiableSet(delegate.elementSet());
    }

    @Override
    public Set&lt;E&gt; elementSet() {</b></font>
      Set&lt;E&gt; es = elementSet;
      return (es == null) ? elementSet = createElementSet() : es;
    }

    @CheckForNull transient Set&lt;Multiset.Entry&lt;E&gt;&gt; entrySet;

    @SuppressWarnings("unchecked")
    @Override
    public Set&lt;Multiset.Entry&lt;E&gt;&gt; entrySet() {
      Set&lt;Multiset.Entry&lt;E&gt;&gt; es = entrySet;
<a name="6"></a>      return (es == null)
          // Safe because the returned set is made unmodifiable and Entry
          // itself is readonly
          ? entrySet = (Set) <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Collections.unmodifiableSet(delegate.entrySet())
          : es;
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
      return Iterators.&lt;E&gt;unmodifiableIterator(delegate.iterator());
    }

    @</b></font>Override
    public boolean add(@ParametricNullness E element) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int add(@ParametricNullness E element, int occurrences) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; elementsToAdd) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean remove(@CheckForNull Object element) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int remove(@CheckForNull Object element, int occurrences) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean removeAll(Collection&lt;?&gt; elementsToRemove) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; elementsToRetain) {
      throw new UnsupportedOperationException();
    }

    @Override
    public void clear() {
      throw new UnsupportedOperationException();
    }

    @Override
    public int setCount(@ParametricNullness E element, int count) {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
      throw new UnsupportedOperationException();
    }

    private static final long serialVersionUID = 0;
  }

  /**
   * Returns an unmodifiable view of the specified sorted multiset. Query operations on the returned
   * multiset "read through" to the specified multiset, and attempts to modify the returned multiset
   * result in an {@link UnsupportedOperationException}.
   *
   * &lt;p&gt;The returned multiset will be serializable if the specified multiset is serializable.
   *
   * @param sortedMultiset the sorted multiset for which an unmodifiable view is to be generated
   * @return an unmodifiable view of the multiset
   * @since 11.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; SortedMultiset&lt;E&gt; unmodifiableSortedMultiset(
      SortedMultiset&lt;E&gt; sortedMultiset) {
    // it's in its own file so it can be emulated for GWT
    return new UnmodifiableSortedMultiset&lt;E&gt;(checkNotNull(sortedMultiset));
  }

  /**
   * Returns an immutable multiset entry with the specified element and count. The entry will be
   * serializable if {@code e} is.
   *
   * @param e the element to be associated with the returned entry
   * @param n the count to be associated with the returned entry
   * @throws IllegalArgumentException if {@code n} is negative
   */
  public static &lt;E extends @Nullable Object&gt; Multiset.Entry&lt;E&gt; immutableEntry(
      @ParametricNullness E e, int n) {
    return new ImmutableEntry&lt;E&gt;(e, n);
  }

  static class ImmutableEntry&lt;E extends @Nullable Object&gt; extends AbstractEntry&lt;E&gt;
      implements Serializable {
    @ParametricNullness private final E element;
    private final int count;

    ImmutableEntry(@ParametricNullness E element, int count) {
      this.element = element;
      this.count = count;
      checkNonnegative(count, "count");
    }

    @Override
<a name="14"></a>    @ParametricNullness
    public final E getElement() {
      return element;
    <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    @Override
    public final int getCount() {
      return count;
    }

    @</b></font>CheckForNull
    public ImmutableEntry&lt;E&gt; nextInBucket() {
      return null;
    }

    private static final long serialVersionUID = 0;
  }

  /**
   * Returns a view of the elements of {@code unfiltered} that satisfy a predicate. The returned
   * multiset is a live view of {@code unfiltered}; changes to one affect the other.
   *
   * &lt;p&gt;The resulting multiset's iterators, and those of its {@code entrySet()} and {@code
   * elementSet()}, do not support {@code remove()}. However, all other multiset methods supported
   * by {@code unfiltered} are supported by the returned multiset. When given an element that
   * doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods throw
   * an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and {@code
   * clear()} are called on the filtered multiset, only elements that satisfy the filter will be
   * removed from the underlying multiset.
   *
   * &lt;p&gt;The returned multiset isn't threadsafe or serializable, even if {@code unfiltered} is.
   *
   * &lt;p&gt;Many of the filtered multiset's methods, such as {@code size()}, iterate across every
   * element in the underlying multiset and determine which elements satisfy the filter. When a live
   * view is &lt;i&gt;not&lt;/i&gt; needed, it may be faster to copy the returned multiset and use the copy.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; {@code predicate} must be &lt;i&gt;consistent with equals&lt;/i&gt;, as documented at
   * {@link Predicate#apply}. Do not provide a predicate such as {@code
   * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
   * Iterables#filter(Iterable, Class)} for related functionality.)
   *
   * @since 14.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; Multiset&lt;E&gt; filter(
      Multiset&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
    if (unfiltered instanceof FilteredMultiset) {
      // Support clear(), removeAll(), and retainAll() when filtering a filtered
      // collection.
      FilteredMultiset&lt;E&gt; filtered = (FilteredMultiset&lt;E&gt;) unfiltered;
      Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
      return new FilteredMultiset&lt;E&gt;(filtered.unfiltered, combinedPredicate);
    }
    return new FilteredMultiset&lt;E&gt;(unfiltered, predicate);
  }

  private static final class FilteredMultiset&lt;E extends @Nullable Object&gt; extends ViewMultiset&lt;E&gt; {
    final Multiset&lt;E&gt; unfiltered;
    final Predicate&lt;? super E&gt; predicate;
<a name="2"></a>
    FilteredMultiset(Multiset&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
      this.unfiltered = checkNotNull(unfiltered);
      this.predicate = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>checkNotNull(predicate);
    }

    @Override
    public UnmodifiableIterator&lt;E&gt; iterator() {
      return Iterators.filter(unfiltered.iterator(), predicate);
    }

    @Override
    Set&lt;E&gt; createElementSet() {
      return Sets.filter(unfiltered.elementSet(), predicate);
    }

    @Override
    Iterator&lt;E&gt; elementIterator() {</b></font>
      throw new AssertionError("should never be called");
    }

    @Override
    Set&lt;Entry&lt;E&gt;&gt; createEntrySet() {
      return Sets.filter(
          unfiltered.entrySet(),
          new Predicate&lt;Entry&lt;E&gt;&gt;() {
            @Override
            public boolean apply(Entry&lt;E&gt; entry) {
              return predicate.apply(entry.getElement());
            }
          });
    }

    @Override
    Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
      throw new AssertionError("should never be called");
    }

    @Override
    public int count(@CheckForNull Object element) {
      int count = unfiltered.count(element);
      if (count &gt; 0) {
        @SuppressWarnings("unchecked") // element is equal to an E
        E e = (E) element;
        return predicate.apply(e) ? count : 0;
      }
      return 0;
    }

    @Override
    public int add(@ParametricNullness E element, int occurrences) {
      checkArgument(
          predicate.apply(element), "Element %s does not match predicate %s", element, predicate);
      return unfiltered.add(element, occurrences);
    }

    @Override
    public int remove(@CheckForNull Object element, int occurrences) {
      checkNonnegative(occurrences, "occurrences");
      if (occurrences == 0) {
        return count(element);
      } else {
        return contains(element) ? unfiltered.remove(element, occurrences) : 0;
      }
    }
  }

  /**
   * Returns the expected number of distinct elements given the specified elements. The number of
   * distinct elements is only computed if {@code elements} is an instance of {@code Multiset};
   * otherwise the default value of 11 is returned.
<a name="18"></a>   */
  static int inferDistinctElements(Iterable&lt;?&gt; elements) {
    if (elements instanceof Multiset) {
      return <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>((Multiset&lt;?&gt;) elements).elementSet().size();
    }
    return 11; // initial capacity will be rounded up to 16
  }

  /**
   * Returns an unmodifiable view of the union of two multisets. In the returned multiset, the count
   * of each element is the &lt;i&gt;maximum&lt;/i&gt; of its counts in the two backing multisets. The iteration
   * order of the returned multiset matches that of the element set of {@code multiset1} followed by
   * the members of the element set of {@code multiset2} that are not contained in {@code
   * multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * &lt;p&gt;Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  @Beta
  public static &lt;E</b></font> extends @Nullable Object&gt; Multiset&lt;E&gt; union(
      final Multiset&lt;? extends E&gt; multiset1, final Multiset&lt;? extends E&gt; multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);
<a name="4"></a>
    return new ViewMultiset&lt;E&gt;() {
      @Override
      public boolean contains(<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@CheckForNull Object element) {
        return multiset1.contains(element) || multiset2.contains(element);
      }

      @Override
      public boolean isEmpty() {
        return multiset1.isEmpty() &amp;&amp; multiset2.isEmpty();
      }
<a name="17"></a>
      @</b></font>Override
      public int count(@CheckForNull Object element) {
        return Math.max(multiset1.count(element), <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>multiset2.count(element));
      }

      @Override
      Set&lt;E&gt; createElementSet() {
        return Sets.union(multiset1.elementSet</b></font>(), multiset2.elementSet());
      }

      @Override
      Iterator&lt;E&gt; elementIterator() {
        throw new AssertionError("should never be called");
      }

      @Override
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
        final Iterator&lt;? extends Entry&lt;? extends E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        final Iterator&lt;? extends Entry&lt;? extends E&gt;&gt; iterator2 = multiset2.entrySet().iterator();
        // TODO(lowasser): consider making the entries live views
        return new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            if (iterator1.hasNext()) {
              Entry&lt;? extends E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = Math.max(entry1.getCount(), multiset2.count(element));
              return immutableEntry(element, count);
            }
            while (iterator2.hasNext()) {
              Entry&lt;? extends E&gt; entry2 = iterator2.next();
              E element = entry2.getElement();
              if (!multiset1.contains(element)) {
                return immutableEntry(element, entry2.getCount());
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the intersection of two multisets. In the returned multiset,
   * the count of each element is the &lt;i&gt;minimum&lt;/i&gt; of its counts in the two backing multisets,
   * with elements that would have a count of 0 not included. The iteration order of the returned
   * multiset matches that of the element set of {@code multiset1}, with repeated occurrences of the
   * same element appearing consecutively.
   *
   * &lt;p&gt;Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 2.0
   */
  public static &lt;E extends @Nullable Object&gt; Multiset&lt;E&gt; intersection(
      final Multiset&lt;E&gt; multiset1, final Multiset&lt;?&gt; multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    return new ViewMultiset&lt;E&gt;() {
      @Override
      public int count(@CheckForNull Object element) {
        int count1 = multiset1.count(element);
        return (count1 == 0) ? 0 : Math.min(count1, multiset2.count(element));
      }

      @Override
      Set&lt;E&gt; createElementSet() {
        return Sets.intersection(multiset1.elementSet(), multiset2.elementSet());
      }

      @Override
      Iterator&lt;E&gt; elementIterator() {
        throw new AssertionError("should never be called");
      }

      @Override
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
        final Iterator&lt;Entry&lt;E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        // TODO(lowasser): consider making the entries live views
        return new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            while (iterator1.hasNext()) {
              Entry&lt;E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = Math.min(entry1.getCount(), multiset2.count(element));
              if (count &gt; 0) {
                return immutableEntry(element, count);
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the sum of two multisets. In the returned multiset, the count
   * of each element is the &lt;i&gt;sum&lt;/i&gt; of its counts in the two backing multisets. The iteration
   * order of the returned multiset matches that of the element set of {@code multiset1} followed by
   * the members of the element set of {@code multiset2} that are not contained in {@code
   * multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * &lt;p&gt;Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; Multiset&lt;E&gt; sum(
      final Multiset&lt;? extends E&gt; multiset1, final Multiset&lt;? extends E&gt; multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    // TODO(lowasser): consider making the entries live views
<a name="1"></a>    return new ViewMultiset&lt;E&gt;() {
      @Override
      public boolean contains(@CheckForNull Object element) {
        return multiset1.contains(element) || <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>multiset2.contains(element);
      }

      @Override
      public boolean isEmpty() {
        return multiset1.isEmpty() &amp;&amp; multiset2.isEmpty();
      }

      @Override
      public int size() {
        return IntMath.saturatedAdd(multiset1.size(), multiset2.size());
<a name="8"></a>      }

      @</b></font>Override
      public int count(<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@CheckForNull Object element) {
        return multiset1.count(element) + multiset2.count(element);
      }

      @Override
      Set&lt;E&gt; createElementSet() {
        return Sets.union(multiset1.elementSet</b></font>(), multiset2.elementSet());
      }

      @Override
      Iterator&lt;E&gt; elementIterator() {
        throw new AssertionError("should never be called");
      }

      @Override
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
        final Iterator&lt;? extends Entry&lt;? extends E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        final Iterator&lt;? extends Entry&lt;? extends E&gt;&gt; iterator2 = multiset2.entrySet().iterator();
        return new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            if (iterator1.hasNext()) {
              Entry&lt;? extends E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = entry1.getCount() + multiset2.count(element);
              return immutableEntry(element, count);
            }
            while (iterator2.hasNext()) {
              Entry&lt;? extends E&gt; entry2 = iterator2.next();
              E element = entry2.getElement();
              if (!multiset1.contains(element)) {
                return immutableEntry(element, entry2.getCount());
              }
            }
            return endOfData();
          }
        };
      }
    };
  }

  /**
   * Returns an unmodifiable view of the difference of two multisets. In the returned multiset, the
   * count of each element is the result of the &lt;i&gt;zero-truncated subtraction&lt;/i&gt; of its count in
   * the second multiset from its count in the first multiset, with elements that would have a count
   * of 0 not included. The iteration order of the returned multiset matches that of the element set
   * of {@code multiset1}, with repeated occurrences of the same element appearing consecutively.
   *
   * &lt;p&gt;Results are undefined if {@code multiset1} and {@code multiset2} are based on different
   * equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).
   *
   * @since 14.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; Multiset&lt;E&gt; difference(
      final Multiset&lt;E&gt; multiset1, final Multiset&lt;?&gt; multiset2) {
    checkNotNull(multiset1);
    checkNotNull(multiset2);

    // TODO(lowasser): consider making the entries live views
    return new ViewMultiset&lt;E&gt;() {
      @Override
      public int count(@CheckForNull Object element) {
        int count1 = multiset1.count(element);
        return (count1 == 0) ? 0 : Math.max(0, count1 - multiset2.count(element));
      }

      @Override
      public void clear() {
        throw new UnsupportedOperationException();
      }

      @Override
      Iterator&lt;E&gt; elementIterator() {
        final Iterator&lt;Entry&lt;E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        return new AbstractIterator&lt;E&gt;() {
          @Override
          @CheckForNull
          protected E computeNext() {
            while (iterator1.hasNext()) {
              Entry&lt;E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              if (entry1.getCount() &gt; multiset2.count(element)) {
                return element;
              }
            }
            return endOfData();
          }
        };
      }

      @Override
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
        final Iterator&lt;Entry&lt;E&gt;&gt; iterator1 = multiset1.entrySet().iterator();
        return new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            while (iterator1.hasNext()) {
              Entry&lt;E&gt; entry1 = iterator1.next();
              E element = entry1.getElement();
              int count = entry1.getCount() - multiset2.count(element);
              if (count &gt; 0) {
                return immutableEntry(element, count);
              }
            }
<a name="13"></a>            return endOfData();
          }
        };
      <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

      @Override
      int distinctElements() {
        return Iterators.size(entryIterator());
      }</b></font>
    };
  }

  /**
   * Returns {@code true} if {@code subMultiset.count(o) &lt;= superMultiset.count(o)} for all {@code
   * o}.
   *
   * @since 10.0
   */
  @CanIgnoreReturnValue
  public static boolean containsOccurrences(Multiset&lt;?&gt; superMultiset, Multiset&lt;?&gt; subMultiset) {
    checkNotNull(superMultiset);
    checkNotNull(subMultiset);
    for (Entry&lt;?&gt; entry : subMultiset.entrySet()) {
      int superCount = superMultiset.count(entry.getElement());
      if (superCount &lt; entry.getCount()) {
        return false;
      }
    }
    return true;
  }

  /**
   * Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code
   * multisetToRetain.count(e)}.
   *
   * &lt;p&gt;To be precise, {@code multisetToModify.count(e)} is set to {@code
   * Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link
   * #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},
   * but mutates {@code multisetToModify} instead of returning a view.
   *
   * &lt;p&gt;In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of
   * elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all
   * other elements.
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 10.0
   */
  @CanIgnoreReturnValue
  public static boolean retainOccurrences(
      Multiset&lt;?&gt; multisetToModify, Multiset&lt;?&gt; multisetToRetain) {
    return retainOccurrencesImpl(multisetToModify, multisetToRetain);
  }

  /** Delegate implementation which cares about the element type. */
  private static &lt;E extends @Nullable Object&gt; boolean retainOccurrencesImpl(
      Multiset&lt;E&gt; multisetToModify, Multiset&lt;?&gt; occurrencesToRetain) {
    checkNotNull(multisetToModify);
    checkNotNull(occurrencesToRetain);
    // Avoiding ConcurrentModificationExceptions is tricky.
    Iterator&lt;Entry&lt;E&gt;&gt; entryIterator = multisetToModify.entrySet().iterator();
    boolean changed = false;
    while (entryIterator.hasNext()) {
      Entry&lt;E&gt; entry = entryIterator.next();
      int retainCount = occurrencesToRetain.count(entry.getElement());
      if (retainCount == 0) {
        entryIterator.remove();
        changed = true;
      } else if (retainCount &lt; entry.getCount()) {
        multisetToModify.setCount(entry.getElement(), retainCount);
        changed = true;
      }
    }
    return changed;
  }

  /**
   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one
   * occurrence of {@code e} in {@code multisetToModify}.
   *
   * &lt;p&gt;Equivalently, this method modifies {@code multisetToModify} so that {@code
   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -
   * Iterables.frequency(occurrencesToRemove, e))}.
   *
   * &lt;p&gt;This is &lt;i&gt;not&lt;/i&gt; the same as {@code multisetToModify.} {@link Multiset#removeAll
   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear
   * in {@code occurrencesToRemove}. However, this operation &lt;i&gt;is&lt;/i&gt; equivalent to, albeit
   * sometimes more efficient than, the following:
   *
   * &lt;pre&gt;{@code
   * for (E e : occurrencesToRemove) {
   *   multisetToModify.remove(e);
   * }
   * }&lt;/pre&gt;
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code
   *     Multiset})
   */
  @CanIgnoreReturnValue
  public static boolean removeOccurrences(
      Multiset&lt;?&gt; multisetToModify, Iterable&lt;?&gt; occurrencesToRemove) {
    if (occurrencesToRemove instanceof Multiset) {
      return removeOccurrences(multisetToModify, (Multiset&lt;?&gt;) occurrencesToRemove);
    } else {
      checkNotNull(multisetToModify);
      checkNotNull(occurrencesToRemove);
      boolean changed = false;
      for (Object o : occurrencesToRemove) {
        changed |= multisetToModify.remove(o);
      }
      return changed;
    }
  }

  /**
   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one
   * occurrence of {@code e} in {@code multisetToModify}.
   *
   * &lt;p&gt;Equivalently, this method modifies {@code multisetToModify} so that {@code
   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -
   * occurrencesToRemove.count(e))}.
   *
   * &lt;p&gt;This is &lt;i&gt;not&lt;/i&gt; the same as {@code multisetToModify.} {@link Multiset#removeAll
   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear
   * in {@code occurrencesToRemove}. However, this operation &lt;i&gt;is&lt;/i&gt; equivalent to, albeit
   * sometimes more efficient than, the following:
   *
   * &lt;pre&gt;{@code
   * for (E e : occurrencesToRemove) {
   *   multisetToModify.remove(e);
   * }
   * }&lt;/pre&gt;
   *
   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation
   * @since 10.0 (missing in 18.0 when only the overload taking an {@code Iterable} was present)
   */
  @CanIgnoreReturnValue
  public static boolean removeOccurrences(
      Multiset&lt;?&gt; multisetToModify, Multiset&lt;?&gt; occurrencesToRemove) {
    checkNotNull(multisetToModify);
    checkNotNull(occurrencesToRemove);

    boolean changed = false;
    Iterator&lt;? extends Entry&lt;?&gt;&gt; entryIterator = multisetToModify.entrySet().iterator();
    while (entryIterator.hasNext()) {
      Entry&lt;?&gt; entry = entryIterator.next();
      int removeCount = occurrencesToRemove.count(entry.getElement());
      if (removeCount &gt;= entry.getCount()) {
        entryIterator.remove();
        changed = true;
      } else if (removeCount &gt; 0) {
        multisetToModify.remove(entry.getElement(), removeCount);
        changed = true;
      }
    }
    return changed;
  }

  /**
   * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@link
   * Multiset.Entry}.
   */
  abstract static class AbstractEntry&lt;E extends @Nullable Object&gt; implements Multiset.Entry&lt;E&gt; {
    /**
     * Indicates whether an object equals this entry, following the behavior specified in {@link
     * Multiset.Entry#equals}.
     */
    @Override
    public boolean equals(@CheckForNull Object object) {
      if (object instanceof Multiset.Entry) {
        Multiset.Entry&lt;?&gt; that = (Multiset.Entry&lt;?&gt;) object;
        return this.getCount() == that.getCount()
            &amp;&amp; Objects.equal(this.getElement(), that.getElement());
      }
      return false;
    }

    /**
     * Return this entry's hash code, following the behavior specified in {@link
     * Multiset.Entry#hashCode}.
     */
    @Override
    public int hashCode() {
      E e = getElement();
      return ((e == null) ? 0 : e.hashCode()) ^ getCount();
    }

    /**
     * Returns a string representation of this multiset entry. The string representation consists of
     * the associated element if the associated count is one, and otherwise the associated element
     * followed by the characters " x " (space, x and space) followed by the count. Elements and
     * counts are converted to strings as by {@code String.valueOf}.
     */
    @Override
    public String toString() {
      String text = String.valueOf(getElement());
      int n = getCount();
      return (n == 1) ? text : (text + " x " + n);
    }
  }

  /** An implementation of {@link Multiset#equals}. */
  static boolean equalsImpl(Multiset&lt;?&gt; multiset, @CheckForNull Object object) {
    if (object == multiset) {
      return true;
    }
    if (object instanceof Multiset) {
      Multiset&lt;?&gt; that = (Multiset&lt;?&gt;) object;
      /*
       * We can't simply check whether the entry sets are equal, since that
       * approach fails when a TreeMultiset has a comparator that returns 0
       * when passed unequal elements.
       */

      if (multiset.size() != that.size() || multiset.entrySet().size() != that.entrySet().size()) {
        return false;
      }
      for (Entry&lt;?&gt; entry : that.entrySet()) {
        if (multiset.count(entry.getElement()) != entry.getCount()) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  /** An implementation of {@link Multiset#addAll}. */
  static &lt;E extends @Nullable Object&gt; boolean addAllImpl(
      Multiset&lt;E&gt; self, Collection&lt;? extends E&gt; elements) {
    checkNotNull(self);
    checkNotNull(elements);
    if (elements instanceof Multiset) {
      return addAllImpl(self, cast(elements));
    } else if (elements.isEmpty()) {
      return false;
    } else {
      return Iterators.addAll(self, elements.iterator());
    }
  }
<a name="16"></a>
  /** A specialization of {@code addAllImpl} for when {@code elements} is itself a Multiset. */
  private static &lt;E extends @Nullable Object&gt; boolean addAllImpl(
      <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Multiset&lt;E&gt; self, Multiset&lt;? extends E&gt; elements) {
    if (elements.isEmpty()) {
      return false;
    }</b></font>
    elements.forEachEntry(self::add);
    return true;
  }

  /** An implementation of {@link Multiset#removeAll}. */
  static boolean removeAllImpl(Multiset&lt;?&gt; self, Collection&lt;?&gt; elementsToRemove) {
    Collection&lt;?&gt; collection =
        (elementsToRemove instanceof Multiset)
            ? ((Multiset&lt;?&gt;) elementsToRemove).elementSet()
            : elementsToRemove;

    return self.elementSet().removeAll(collection);
  }

  /** An implementation of {@link Multiset#retainAll}. */
  static boolean retainAllImpl(Multiset&lt;?&gt; self, Collection&lt;?&gt; elementsToRetain) {
    checkNotNull(elementsToRetain);
    Collection&lt;?&gt; collection =
        (elementsToRetain instanceof Multiset)
            ? ((Multiset&lt;?&gt;) elementsToRetain).elementSet()
            : elementsToRetain;

    return self.elementSet().retainAll(collection);
  }

  /** An implementation of {@link Multiset#setCount(Object, int)}. */
  static &lt;E extends @Nullable Object&gt; int setCountImpl(
      Multiset&lt;E&gt; self, @ParametricNullness E element, int count) {
    checkNonnegative(count, "count");

    int oldCount = self.count(element);

    int delta = count - oldCount;
    if (delta &gt; 0) {
      self.add(element, delta);
    } else if (delta &lt; 0) {
      self.remove(element, -delta);
    }

    return oldCount;
  }

  /** An implementation of {@link Multiset#setCount(Object, int, int)}. */
  static &lt;E extends @Nullable Object&gt; boolean setCountImpl(
      Multiset&lt;E&gt; self, @ParametricNullness E element, int oldCount, int newCount) {
    checkNonnegative(oldCount, "oldCount");
    checkNonnegative(newCount, "newCount");

    if (self.count(element) == oldCount) {
      self.setCount(element, newCount);
      return true;
    } else {
      return false;
    }
  }

  static &lt;E extends @Nullable Object&gt; Iterator&lt;E&gt; elementIterator(
      Iterator&lt;Entry&lt;E&gt;&gt; entryIterator) {
    return new TransformedIterator&lt;Entry&lt;E&gt;, E&gt;(entryIterator) {
      @Override
      @ParametricNullness
      E transform(Entry&lt;E&gt; entry) {
        return entry.getElement();
      }
    };
  }

  abstract static class ElementSet&lt;E extends @Nullable Object&gt; extends Sets.ImprovedAbstractSet&lt;E&gt; {
    abstract Multiset&lt;E&gt; multiset();

    @Override
    public void clear() {
      multiset().clear();
    }

    @Override
    public boolean contains(@CheckForNull Object o) {
      return multiset().contains(o);
<a name="5"></a>    }

    @Override
    public boolean containsAll(Collection&lt;?&gt; c) <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
      return multiset().containsAll(c);
    }

    @Override
    public boolean isEmpty() {
      return multiset().isEmpty();
    }

    @</b></font>Override
<a name="7"></a>    public abstract Iterator&lt;E&gt; iterator();

    @Override
    public boolean remove(<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@CheckForNull Object o) {
      return multiset().remove(o, Integer.MAX_VALUE) &gt; 0;
    }

    @Override
    public int size() {
      return multiset().entrySet</b></font>().size();
    }
  }

  abstract static class EntrySet&lt;E extends @Nullable Object&gt;
      extends Sets.ImprovedAbstractSet&lt;Entry&lt;E&gt;&gt; {
    abstract Multiset&lt;E&gt; multiset();

    @Override
    public boolean contains(@CheckForNull Object o) {
      if (o instanceof Entry) {
        /*
         * The GWT compiler wrongly issues a warning here.
         */
        @SuppressWarnings("cast")
        Entry&lt;?&gt; entry = (Entry&lt;?&gt;) o;
        if (entry.getCount() &lt;= 0) {
          return false;
        }
        int count = multiset().count(entry.getElement());
        return count == entry.getCount();
      }
      return false;
    }

    // GWT compiler warning; see contains().
    @SuppressWarnings("cast")
    @Override
    public boolean remove(@CheckForNull Object object) {
      if (object instanceof Multiset.Entry) {
        Entry&lt;?&gt; entry = (Entry&lt;?&gt;) object;
        Object element = entry.getElement();
        int entryCount = entry.getCount();
        if (entryCount != 0) {
          // Safe as long as we never add a new entry, which we won't.
          // (Presumably it can still throw CCE/NPE but only if the underlying Multiset does.)
          @SuppressWarnings({"unchecked", "nullness"})
          Multiset&lt;@Nullable Object&gt; multiset = (Multiset&lt;@Nullable Object&gt;) multiset();
          return multiset.setCount(element, entryCount, 0);
        }
      }
      return false;
    }

    @Override
    public void clear() {
      multiset().clear();
    }
  }

  /** An implementation of {@link Multiset#iterator}. */
  static &lt;E extends @Nullable Object&gt; Iterator&lt;E&gt; iteratorImpl(Multiset&lt;E&gt; multiset) {
    return new MultisetIteratorImpl&lt;E&gt;(multiset, multiset.entrySet().iterator());
  }

  static final class MultisetIteratorImpl&lt;E extends @Nullable Object&gt; implements Iterator&lt;E&gt; {
    private final Multiset&lt;E&gt; multiset;
    private final Iterator&lt;Entry&lt;E&gt;&gt; entryIterator;
    @CheckForNull private Entry&lt;E&gt; currentEntry;

    /** Count of subsequent elements equal to current element */
    private int laterCount;

    /** Count of all elements equal to current element */
    private int totalCount;

    private boolean canRemove;

<a name="10"></a>    MultisetIteratorImpl(Multiset&lt;E&gt; multiset, Iterator&lt;Entry&lt;E&gt;&gt; entryIterator) {
      this.multiset = multiset;
      this.entryIterator = entryIterator;
    <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

    @Override
    public boolean hasNext() {
      return laterCount &gt; 0 || entryIterator.hasNext();
    }

    @</b></font>Override
    @ParametricNullness
    public E next() {
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      if (laterCount == 0) {
        currentEntry = entryIterator.next();
        totalCount = laterCount = currentEntry.getCount();
      }
      laterCount--;
      canRemove = true;
      /*
       * requireNonNull is safe because laterCount starts at 0, forcing us to initialize
       * currentEntry above. After that, we never clear it.
       */
      return requireNonNull(currentEntry).getElement();
    }

    @Override
    public void remove() {
      checkRemove(canRemove);
      if (totalCount == 1) {
        entryIterator.remove();
      } else {
        /*
         * requireNonNull is safe because canRemove is set to true only after we initialize
         * currentEntry (which we never subsequently clear).
         */
        multiset.remove(requireNonNull(currentEntry).getElement());
      }
      totalCount--;
      canRemove = false;
    }
  }

  static &lt;E extends @Nullable Object&gt; Spliterator&lt;E&gt; spliteratorImpl(Multiset&lt;E&gt; multiset) {
    Spliterator&lt;Entry&lt;E&gt;&gt; entrySpliterator = multiset.entrySet().spliterator();
    return CollectSpliterators.flatMap(
        entrySpliterator,
        entry -&gt; Collections.nCopies(entry.getCount(), entry.getElement()).spliterator(),
        Spliterator.SIZED
            | (entrySpliterator.characteristics()
                &amp; (Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.IMMUTABLE)),
        multiset.size());
  }

  /** An implementation of {@link Multiset#size}. */
  static int linearTimeSizeImpl(Multiset&lt;?&gt; multiset) {
    long size = 0;
    for (Entry&lt;?&gt; entry : multiset.entrySet()) {
      size += entry.getCount();
    }
    return Ints.saturatedCast(size);
  }

<a name="12"></a>  /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
  static &lt;T extends @Nullable Object&gt; Multiset&lt;T&gt; cast(Iterable&lt;T&gt; iterable) {
    return (Multiset&lt;T&gt;) iterable;
  <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

  /**
   * Returns a copy of {@code multiset} as an {@link ImmutableMultiset} whose iteration order is
   * highest count first, with ties broken by the iteration order of the original multiset.
   *
   * @since 11.0
   */
  @Beta
  public static &lt;E&gt; ImmutableMultiset&lt;E&gt; copyHighestCountFirst(Multiset&lt;E&gt; multiset) {
    Entry&lt;E&gt;[] entries = (Entry&lt;E&gt;[]) multiset.entrySet</b></font>().toArray(new Entry[0]);
    Arrays.sort(entries, DecreasingCount.INSTANCE);
    return ImmutableMultiset.copyFromEntries(Arrays.asList(entries));
  }

  private static final class DecreasingCount implements Comparator&lt;Entry&lt;?&gt;&gt; {
    static final DecreasingCount INSTANCE = new DecreasingCount();

    @Override
    public int compare(Entry&lt;?&gt; entry1, Entry&lt;?&gt; entry2) {
      return entry2.getCount() - entry1.getCount(); // subtracting two nonnegative integers
    }
  }

  /**
   * An {@link AbstractMultiset} with additional default implementations, some of them linear-time
   * implementations in terms of {@code elementSet} and {@code entrySet}.
<a name="11"></a>   */
  private abstract static class ViewMultiset&lt;E extends @Nullable Object&gt;
      extends AbstractMultiset&lt;E&gt; {
    <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
    public int size() {
      return linearTimeSizeImpl(this);
    }
<a name="3"></a>
    @Override
    public void clear() {</b></font>
      <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>elementSet().clear();
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
      return iteratorImpl(this);
    }

    @Override
    int distinctElements() {
      return elementSet().size();
    }</b></font>
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>FreshValueGenerator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.testing;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Throwables.throwIfUnchecked;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.CharMatcher;
import com.google.common.base.Charsets;
import com.google.common.base.Equivalence;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.base.Ticker;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedMultiset;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.LinkedHashMultiset;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multiset;
import com.google.common.collect.Ordering;
import com.google.common.collect.Range;
import com.google.common.collect.RowSortedTable;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;
import com.google.common.collect.SortedMultiset;
import com.google.common.collect.Table;
import com.google.common.collect.TreeBasedTable;
import com.google.common.collect.TreeMultiset;
import com.google.common.primitives.Primitives;
import com.google.common.primitives.UnsignedInteger;
import com.google.common.primitives.UnsignedLong;
import com.google.common.reflect.AbstractInvocationHandler;
import com.google.common.reflect.Invokable;
import com.google.common.reflect.Parameter;
import com.google.common.reflect.Reflection;
import com.google.common.reflect.TypeToken;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
<a name="0"></a>import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Currency;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Generates fresh instances of types that are different from each other (if possible).
 *
 * @author Ben Yu
 */
@</b></font>GwtIncompatible
class FreshValueGenerator {

  private static final ImmutableMap&lt;Class&lt;?&gt;, Method&gt; GENERATORS;

  static {
    ImmutableMap.Builder&lt;Class&lt;?&gt;, Method&gt; builder = ImmutableMap.builder();
    for (Method method : FreshValueGenerator.class.getDeclaredMethods()) {
      if (method.isAnnotationPresent(Generates.class)) {
        builder.put(method.getReturnType(), method);
      }
    }
    GENERATORS = builder.buildOrThrow();
  }

  private static final ImmutableMap&lt;Class&lt;?&gt;, Method&gt; EMPTY_GENERATORS;

  static {
    ImmutableMap.Builder&lt;Class&lt;?&gt;, Method&gt; builder = ImmutableMap.builder();
    for (Method method : FreshValueGenerator.class.getDeclaredMethods()) {
      if (method.isAnnotationPresent(Empty.class)) {
        builder.put(method.getReturnType(), method);
      }
    }
    EMPTY_GENERATORS = builder.buildOrThrow();
  }

  private final AtomicInteger freshness = new AtomicInteger(1);
  private final ListMultimap&lt;Class&lt;?&gt;, Object&gt; sampleInstances = ArrayListMultimap.create();

  /**
   * The freshness level at which the {@link Empty @Empty} annotated method was invoked to generate
   * instance.
   */
  private final Map&lt;Type, Integer&gt; emptyInstanceGenerated = new HashMap&lt;&gt;();

  final &lt;T&gt; void addSampleInstances(Class&lt;T&gt; type, Iterable&lt;? extends T&gt; instances) {
    sampleInstances.putAll(checkNotNull(type), checkNotNull(instances));
  }

  /**
   * Returns a fresh instance for {@code type} if possible. The returned instance could be:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;exactly of the given type, including generic type parameters, such as {@code
   *       ImmutableList&lt;String&gt;};
   *   &lt;li&gt;of the raw type;
   *   &lt;li&gt;null if no value can be generated.
   * &lt;/ul&gt;
   */
<a name="18"></a>  final @Nullable Object generateFresh(TypeToken&lt;?&gt; type) {
    Object generated = generate(type);
    if (generated != null) {
      <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>freshness.incrementAndGet();
    }
    return generated;
  }

  final &lt;T</b></font>&gt; @Nullable T generateFresh(Class&lt;T&gt; type) {
    return Primitives.wrap(type).cast(generateFresh(TypeToken.of(type)));
  }

  final &lt;T&gt; T newFreshProxy(final Class&lt;T&gt; interfaceType) {
    T proxy = newProxy(interfaceType);
    freshness.incrementAndGet();
    return proxy;
  }

  /**
   * Generates an instance for {@code type} using the current {@link #freshness}. The generated
   * instance may or may not be unique across different calls.
   */
  private Object generate(TypeToken&lt;?&gt; type) {
    Class&lt;?&gt; rawType = type.getRawType();
    List&lt;Object&gt; samples = sampleInstances.get(rawType);
    Object sample = pickInstance(samples, null);
    if (sample != null) {
      return sample;
    }
    if (rawType.isEnum()) {
      return pickInstance(rawType.getEnumConstants(), null);
    }
    if (type.isArray()) {
      TypeToken&lt;?&gt; componentType = type.getComponentType();
      Object array = Array.newInstance(componentType.getRawType(), 1);
      Array.set(array, 0, generate(componentType));
      return array;
    }
    Method emptyGenerate = EMPTY_GENERATORS.get(rawType);
    if (emptyGenerate != null) {
      if (emptyInstanceGenerated.containsKey(type.getType())) {
        // empty instance already generated
        if (emptyInstanceGenerated.get(type.getType()).intValue() == freshness.get()) {
          // same freshness, generate again.
          return invokeGeneratorMethod(emptyGenerate);
        } else {
          // Cannot use empty generator. Proceed with other generators.
        }
      } else {
        // never generated empty instance for this type before.
        Object emptyInstance = invokeGeneratorMethod(emptyGenerate);
        emptyInstanceGenerated.put(type.getType(), freshness.get());
        return emptyInstance;
      }
    }
    Method generate = GENERATORS.get(rawType);
    if (generate != null) {
      ImmutableList&lt;Parameter&gt; params = Invokable.from(generate).getParameters();
      List&lt;Object&gt; args = Lists.newArrayListWithCapacity(params.size());
      TypeVariable&lt;?&gt;[] typeVars = rawType.getTypeParameters();
      for (int i = 0; i &lt; params.size(); i++) {
        TypeToken&lt;?&gt; paramType = type.resolveType(typeVars[i]);
        // We require all @Generates methods to either be parameter-less or accept non-null
        // values for their generic parameter types.
        Object argValue = generate(paramType);
        if (argValue == null) {
          // When a parameter of a @Generates method cannot be created,
          // The type most likely is a collection.
          // Our distinct proxy doesn't work for collections.
          // So just refuse to generate.
          return null;
        }
        args.add(argValue);
      }
      return invokeGeneratorMethod(generate, args.toArray());
    }
    return defaultGenerate(rawType);
  }

  private &lt;T&gt; T defaultGenerate(Class&lt;T&gt; rawType) {
    if (rawType.isInterface()) {
      // always create a new proxy
      return newProxy(rawType);
    }
    return ArbitraryInstances.get(rawType);
  }

  private &lt;T&gt; T newProxy(final Class&lt;T&gt; interfaceType) {
    return Reflection.newProxy(interfaceType, new FreshInvocationHandler(interfaceType));
  }

  private Object invokeGeneratorMethod(Method generator, Object... args) {
    try {
      return generator.invoke(this, args);
    } catch (InvocationTargetException e) {
      throwIfUnchecked(e.getCause());
      throw new RuntimeException(e.getCause());
    } catch (Exception e) {
      throwIfUnchecked(e);
      throw new RuntimeException(e);
    }
  }
<a name="20"></a>
  private final class FreshInvocationHandler extends AbstractInvocationHandler {
    private final int identity = generateInt();
    <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private final Class&lt;?&gt; interfaceType;

    FreshInvocationHandler(Class&lt;?&gt; interfaceType) {
      this.interfaceType = interfaceType;
    }

<a name="14"></a>    @</b></font>Override
    protected Object handleInvocation(Object proxy, Method method, Object[] args) {
      return interfaceMethodCalled(interfaceType, method);
    <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

    @Override
    public int hashCode() {
      return identity;
    }

    @</b></font>Override
    public boolean equals(@Nullable Object obj) {
      if (obj instanceof FreshInvocationHandler) {
        FreshInvocationHandler that = (FreshInvocationHandler) obj;
        return identity == that.identity;
      }
      return false;
    }

    @Override
    public String toString() {
      return paramString(interfaceType, identity);
    }
  }

  /** Subclasses can override to provide different return value for proxied interface methods. */
  Object interfaceMethodCalled(Class&lt;?&gt; interfaceType, Method method) {
    throw new UnsupportedOperationException();
  }

  private &lt;T&gt; T pickInstance(T[] instances, T defaultValue) {
<a name="16"></a>    return pickInstance(Arrays.asList(instances), defaultValue);
  }

  private &lt;T&gt; T pickInstance(<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Collection&lt;T&gt; instances, T defaultValue) {
    if (instances.isEmpty()) {
      return defaultValue;
    }</b></font>
    // generateInt() is 1-based.
    return Iterables.get(instances, (generateInt() - 1) % instances.size());
  }

  private static String paramString(Class&lt;?&gt; type, int i) {
    return type.getSimpleName() + '@' + i;
  }

  /**
   * Annotates a method to be the instance generator of a certain type. The return type is the
   * generated type. The method parameters correspond to the generated type's type parameters. For
   * example, if the annotated method returns {@code Map&lt;K, V&gt;}, the method signature should be:
   * {@code Map&lt;K, V&gt; generateMap(K key, V value)}.
   */
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  private @interface Generates {}

  /**
   * Annotates a method to generate the "empty" instance of a collection. This method should accept
   * no parameter. The value it generates should be unequal to the values generated by methods
   * annotated with {@link Generates}.
   */
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  private @interface Empty {}

  @Generates
  Class&lt;?&gt; generateClass() {
    return pickInstance(
<a name="10"></a>        ImmutableList.of(
            int.class, long.class, void.class, Object.class, Object[].class, Iterable.class),
        Object.class);
  <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

  @Generates
  Object generateObject() {
    return generateString();
  }

  @</b></font>Generates
  Number generateNumber() {
<a name="11"></a>    return generateInt();
  }

  <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Generates
  int generateInt() {
    return freshness.get();
  }

  @Generates
  Integer generateInteger() {</b></font>
    return new Integer(generateInt());
  }

  @Generates
  long generateLong() {
    return generateInt();
  }

  @Generates
  Long generateLongObject() {
    return new Long(generateLong());
  }

  @Generates
  float generateFloat() {
    return generateInt();
  }

  @Generates
  Float generateFloatObject() {
    return new Float(generateFloat());
  }

  @Generates
  double generateDouble() {
    return generateInt();
  }

  @Generates
  Double generateDoubleObject() {
    return new Double(generateDouble());
  }

  @Generates
  short generateShort() {
    return (short) generateInt();
  }

  @Generates
  Short generateShortObject() {
    return new Short(generateShort());
  }

  @Generates
  byte generateByte() {
    return (byte) generateInt();
  }

<a name="13"></a>  @Generates
  Byte generateByteObject() {
    return new Byte(generateByte());
  <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

  @Generates
  char generateChar() {
    return generateString().charAt(0);
  }</b></font>

  @Generates
  Character generateCharacter() {
    return new Character(generateChar());
  }

  @Generates
  boolean generateBoolean() {
    return generateInt() % 2 == 0;
  }
<a name="2"></a>
  @Generates
  Boolean generateBooleanObject() {
    return new Boolean(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>generateBoolean());
  }

  @Generates
  UnsignedInteger generateUnsignedInteger() {
    return UnsignedInteger.fromIntBits(generateInt());
  }

  @Generates
  UnsignedLong generateUnsignedLong() {
    return UnsignedLong.fromLongBits(generateLong());
  }

  @Generates
  BigInteger generateBigInteger() {</b></font>
    return BigInteger.valueOf(generateInt());
  }
<a name="3"></a>
  @Generates
  BigDecimal generateBigDecimal() {
    return <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BigDecimal.valueOf(generateInt());
  }

  @Generates
  CharSequence generateCharSequence() {
    return generateString();
  }

  @Generates
  String generateString() {
    return Integer.toString(generateInt());
  }</b></font>
<a name="1"></a>
  @Generates
  Comparable&lt;?&gt; generateComparable() {
    return <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>generateString();
  }

  @Generates
  Pattern generatePattern() {
    return Pattern.compile(generateString());
  }

  @Generates
  Charset generateCharset() {
    return pickInstance(Charset.availableCharsets().values(), Charsets.UTF_8);
<a name="19"></a>  }

  @</b></font>Generates
  Locale generateLocale() <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
    return pickInstance(Locale.getAvailableLocales(), Locale.US);
  }

  @Generates
  Currency generateCurrency() {</b></font>
    try {
      Method method = Currency.class.getMethod("getAvailableCurrencies");
      @SuppressWarnings("unchecked") // getAvailableCurrencies() returns Set&lt;Currency&gt;.
      Set&lt;Currency&gt; currencies = (Set&lt;Currency&gt;) method.invoke(null);
      return pickInstance(currencies, Currency.getInstance(Locale.US));
      /*
       * Do not merge the 2 catch blocks below. javac would infer a type of
       * ReflectiveOperationException, which Animal Sniffer would reject. (Old versions of
       * Android don't *seem* to mind, but there might be edge cases of which we're unaware.)
       */
    } catch (NoSuchMethodException notJava7) {
      return preJava7FreshCurrency();
    } catch (InvocationTargetException notJava7) {
      return preJava7FreshCurrency();
    } catch (IllegalAccessException impossible) {
      throw new AssertionError(impossible);
    }
  }

  private Currency preJava7FreshCurrency() {
    for (Set&lt;Locale&gt; uselessLocales = Sets.newHashSet(); ; ) {
      Locale locale = generateLocale();
      if (uselessLocales.contains(locale)) { // exhausted all locales
        return Currency.getInstance(Locale.US);
      }
      try {
        return Currency.getInstance(locale);
      } catch (IllegalArgumentException e) {
        uselessLocales.add(locale);
      }
    }
  }
<a name="9"></a>
  @Empty
  &lt;T&gt; Optional&lt;T&gt; generateJavaOptional() {
    return <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Optional.empty();
  }

  @Generates
  &lt;T&gt; Optional&lt;T&gt; generateJavaOptional(T value) {
<a name="4"></a>    return Optional.of(value);
  }</b></font>

  <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Generates
  OptionalInt generateOptionalInt() {
    return OptionalInt.of(generateInt());
  }

  @Generates
  OptionalLong generateOptionalLong() {
    return OptionalLong.of(generateLong());
  }

  @</b></font>Generates
  OptionalDouble generateOptionalDouble() {
    return OptionalDouble.of(generateDouble());
  }

  // common.base
  @Empty
  &lt;T&gt; com.google.common.base.Optional&lt;T&gt; generateGoogleOptional() {
    return com.google.common.base.Optional.absent();
  }

  @Generates
  &lt;T&gt; com.google.common.base.Optional&lt;T&gt; generateGoogleOptional(T value) {
    return com.google.common.base.Optional.of(value);
<a name="5"></a>  }

  @Generates
  Joiner generateJoiner() <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
    return Joiner.on(generateString());
  }

  @Generates
  Splitter generateSplitter() {
    return Splitter.on(generateString());
  }

  @</b></font>Generates
  &lt;T&gt; Equivalence&lt;T&gt; generateEquivalence() {
    return new Equivalence&lt;T&gt;() {
      @Override
      protected boolean doEquivalent(T a, T b) {
        return false;
      }

      @Override
      protected int doHash(T t) {
        return 0;
      }

      final String string = paramString(Equivalence.class, generateInt());

      @Override
      public String toString() {
        return string;
      }
    };
  }

  @Generates
  CharMatcher generateCharMatcher() {
    return new CharMatcher() {
      @Override
      public boolean matches(char c) {
        return false;
      }

      final String string = paramString(CharMatcher.class, generateInt());

      @Override
      public String toString() {
        return string;
      }
    };
  }

  @Generates
  Ticker generateTicker() {
    return new Ticker() {
      @Override
      public long read() {
        return 0;
      }

      final String string = paramString(Ticker.class, generateInt());

      @Override
      public String toString() {
        return string;
      }
    };
  }

  // collect
  @Generates
  &lt;T&gt; Comparator&lt;T&gt; generateComparator() {
    return generateOrdering();
  }

  @Generates
  &lt;T&gt; Ordering&lt;T&gt; generateOrdering() {
    return new Ordering&lt;T&gt;() {
      @Override
      public int compare(T left, T right) {
        return 0;
      }

      final String string = paramString(Ordering.class, generateInt());

      @Override
      public String toString() {
        return string;
      }
    };
  }

  @Empty
  static &lt;C extends Comparable&lt;?&gt;&gt; Range&lt;C&gt; generateRange() {
    return Range.all();
  }

  @Generates
  static &lt;C extends Comparable&lt;?&gt;&gt; Range&lt;C&gt; generateRange(C freshElement) {
    return Range.singleton(freshElement);
  }

  @Generates
  static &lt;E&gt; Iterable&lt;E&gt; generateIterable(@Nullable E freshElement) {
    return generateList(freshElement);
  }

  @Generates
  static &lt;E&gt; Collection&lt;E&gt; generateCollection(@Nullable E freshElement) {
    return generateList(freshElement);
  }

  @Generates
  static &lt;E&gt; List&lt;E&gt; generateList(@Nullable E freshElement) {
    return generateArrayList(freshElement);
  }

  @Generates
  static &lt;E&gt; ArrayList&lt;E&gt; generateArrayList(@Nullable E freshElement) {
    ArrayList&lt;E&gt; list = Lists.newArrayList();
    list.add(freshElement);
    return list;
  }

  @Generates
  static &lt;E&gt; LinkedList&lt;E&gt; generateLinkedList(@Nullable E freshElement) {
    LinkedList&lt;E&gt; list = Lists.newLinkedList();
    list.add(freshElement);
    return list;
  }

  @Generates
  static &lt;E&gt; ImmutableList&lt;E&gt; generateImmutableList(E freshElement) {
    return ImmutableList.of(freshElement);
  }

  @Generates
  static &lt;E&gt; ImmutableCollection&lt;E&gt; generateImmutableCollection(E freshElement) {
    return generateImmutableList(freshElement);
  }

  @Generates
  static &lt;E&gt; Set&lt;E&gt; generateSet(@Nullable E freshElement) {
    return generateHashSet(freshElement);
  }

  @Generates
  static &lt;E&gt; HashSet&lt;E&gt; generateHashSet(@Nullable E freshElement) {
    return generateLinkedHashSet(freshElement);
  }

  @Generates
  static &lt;E&gt; LinkedHashSet&lt;E&gt; generateLinkedHashSet(@Nullable E freshElement) {
    LinkedHashSet&lt;E&gt; set = Sets.newLinkedHashSet();
    set.add(freshElement);
    return set;
  }

  @Generates
  static &lt;E&gt; ImmutableSet&lt;E&gt; generateImmutableSet(E freshElement) {
    return ImmutableSet.of(freshElement);
  }

  @Generates
  static &lt;E extends Comparable&lt;? super E&gt;&gt; SortedSet&lt;E&gt; generateSortedSet(E freshElement) {
    return generateNavigableSet(freshElement);
  }

<a name="12"></a>  @Generates
  static &lt;E extends Comparable&lt;? super E&gt;&gt; NavigableSet&lt;E&gt; generateNavigableSet(E freshElement) {
    return generateTreeSet(freshElement);
  <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

  @Generates
  static &lt;E extends Comparable&lt;? super E&gt;&gt; TreeSet&lt;E&gt; generateTreeSet(E freshElement) {
    TreeSet&lt;E&gt; set = Sets.newTreeSet();
    set.add</b></font>(freshElement);
    return set;
  }

  @Generates
  static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; generateImmutableSortedSet(
      E freshElement) {
    return ImmutableSortedSet.of(freshElement);
  }

  @Generates
  static &lt;E&gt; Multiset&lt;E&gt; generateMultiset(@Nullable E freshElement) {
    return generateHashMultiset(freshElement);
  }

  @Generates
  static &lt;E&gt; HashMultiset&lt;E&gt; generateHashMultiset(@Nullable E freshElement) {
    HashMultiset&lt;E&gt; multiset = HashMultiset.create();
    multiset.add(freshElement);
    return multiset;
  }

  @Generates
  static &lt;E&gt; LinkedHashMultiset&lt;E&gt; generateLinkedHashMultiset(@Nullable E freshElement) {
    LinkedHashMultiset&lt;E&gt; multiset = LinkedHashMultiset.create();
    multiset.add(freshElement);
    return multiset;
  }

  @Generates
  static &lt;E&gt; ImmutableMultiset&lt;E&gt; generateImmutableMultiset(E freshElement) {
    return ImmutableMultiset.of(freshElement);
  }

  @Generates
  static &lt;E extends Comparable&lt;E&gt;&gt; SortedMultiset&lt;E&gt; generateSortedMultiset(E freshElement) {
    return generateTreeMultiset(freshElement);
  }

  @Generates
  static &lt;E extends Comparable&lt;E&gt;&gt; TreeMultiset&lt;E&gt; generateTreeMultiset(E freshElement) {
    TreeMultiset&lt;E&gt; multiset = TreeMultiset.create();
    multiset.add(freshElement);
    return multiset;
  }

  @Generates
  static &lt;E extends Comparable&lt;E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; generateImmutableSortedMultiset(
      E freshElement) {
    return ImmutableSortedMultiset.of(freshElement);
  }

  @Generates
  static &lt;K, V&gt; Map&lt;K, V&gt; generateMap(@Nullable K key, @Nullable V value) {
    return generateHashdMap(key, value);
  }

  @Generates
  static &lt;K, V&gt; HashMap&lt;K, V&gt; generateHashdMap(@Nullable K key, @Nullable V value) {
    return generateLinkedHashMap(key, value);
  }

  @Generates
  static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; generateLinkedHashMap(@Nullable K key, @Nullable V value) {
    LinkedHashMap&lt;K, V&gt; map = Maps.newLinkedHashMap();
    map.put(key, value);
    return map;
  }

  @Generates
  static &lt;K, V&gt; ImmutableMap&lt;K, V&gt; generateImmutableMap(K key, V value) {
    return ImmutableMap.of(key, value);
  }

  @Empty
  static &lt;K, V&gt; ConcurrentMap&lt;K, V&gt; generateConcurrentMap() {
    return Maps.newConcurrentMap();
  }

  @Generates
  static &lt;K, V&gt; ConcurrentMap&lt;K, V&gt; generateConcurrentMap(K key, V value) {
    ConcurrentMap&lt;K, V&gt; map = Maps.newConcurrentMap();
    map.put(key, value);
    return map;
  }

  @Generates
  static &lt;K extends Comparable&lt;? super K&gt;, V&gt; SortedMap&lt;K, V&gt; generateSortedMap(
      K key, @Nullable V value) {
    return generateNavigableMap(key, value);
  }

  @Generates
  static &lt;K extends Comparable&lt;? super K&gt;, V&gt; NavigableMap&lt;K, V&gt; generateNavigableMap(
      K key, @Nullable V value) {
    return generateTreeMap(key, value);
  }

  @Generates
  static &lt;K extends Comparable&lt;? super K&gt;, V&gt; TreeMap&lt;K, V&gt; generateTreeMap(
      K key, @Nullable V value) {
    TreeMap&lt;K, V&gt; map = Maps.newTreeMap();
    map.put(key, value);
    return map;
  }

  @Generates
  static &lt;K extends Comparable&lt;? super K&gt;, V&gt; ImmutableSortedMap&lt;K, V&gt; generateImmutableSortedMap(
      K key, V value) {
    return ImmutableSortedMap.of(key, value);
  }

  @Generates
  static &lt;K, V&gt; Multimap&lt;K, V&gt; generateMultimap(@Nullable K key, @Nullable V value) {
    return generateListMultimap(key, value);
  }

  @Generates
  static &lt;K, V&gt; ImmutableMultimap&lt;K, V&gt; generateImmutableMultimap(K key, V value) {
    return ImmutableMultimap.of(key, value);
  }

  @Generates
  static &lt;K, V&gt; ListMultimap&lt;K, V&gt; generateListMultimap(@Nullable K key, @Nullable V value) {
    return generateArrayListMultimap(key, value);
  }

  @Generates
  static &lt;K, V&gt; ArrayListMultimap&lt;K, V&gt; generateArrayListMultimap(
      @Nullable K key, @Nullable V value) {
    ArrayListMultimap&lt;K, V&gt; multimap = ArrayListMultimap.create();
    multimap.put(key, value);
    return multimap;
  }

  @Generates
  static &lt;K, V&gt; ImmutableListMultimap&lt;K, V&gt; generateImmutableListMultimap(K key, V value) {
    return ImmutableListMultimap.of(key, value);
  }

  @Generates
  static &lt;K, V&gt; SetMultimap&lt;K, V&gt; generateSetMultimap(@Nullable K key, @Nullable V value) {
    return generateLinkedHashMultimap(key, value);
  }

  @Generates
  static &lt;K, V&gt; HashMultimap&lt;K, V&gt; generateHashMultimap(@Nullable K key, @Nullable V value) {
    HashMultimap&lt;K, V&gt; multimap = HashMultimap.create();
    multimap.put(key, value);
    return multimap;
  }

  @Generates
  static &lt;K, V&gt; LinkedHashMultimap&lt;K, V&gt; generateLinkedHashMultimap(
      @Nullable K key, @Nullable V value) {
    LinkedHashMultimap&lt;K, V&gt; multimap = LinkedHashMultimap.create();
    multimap.put(key, value);
    return multimap;
  }

  @Generates
  static &lt;K, V&gt; ImmutableSetMultimap&lt;K, V&gt; generateImmutableSetMultimap(K key, V value) {
    return ImmutableSetMultimap.of(key, value);
  }

  @Generates
  static &lt;K, V&gt; BiMap&lt;K, V&gt; generateBimap(@Nullable K key, @Nullable V value) {
    return generateHashBiMap(key, value);
  }

  @Generates
  static &lt;K, V&gt; HashBiMap&lt;K, V&gt; generateHashBiMap(@Nullable K key, @Nullable V value) {
    HashBiMap&lt;K, V&gt; bimap = HashBiMap.create();
    bimap.put(key, value);
    return bimap;
  }

  @Generates
  static &lt;K, V&gt; ImmutableBiMap&lt;K, V&gt; generateImmutableBimap(K key, V value) {
    return ImmutableBiMap.of(key, value);
  }

  @Generates
  static &lt;R, C, V&gt; Table&lt;R, C, V&gt; generateTable(
      @Nullable R row, @Nullable C column, @Nullable V value) {
    return generateHashBasedTable(row, column, value);
  }

  @Generates
  static &lt;R, C, V&gt; HashBasedTable&lt;R, C, V&gt; generateHashBasedTable(
      @Nullable R row, @Nullable C column, @Nullable V value) {
    HashBasedTable&lt;R, C, V&gt; table = HashBasedTable.create();
    table.put(row, column, value);
    return table;
  }
<a name="15"></a>
  @SuppressWarnings("rawtypes") // TreeBasedTable.create() is defined as such
  @Generates
  static &lt;R extends Comparable, C extends Comparable, <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>V&gt;
      RowSortedTable&lt;R, C, V&gt; generateRowSortedTable(R row, C column, V value) {
    return generateTreeBasedTable(row, column, value);
  }

  @SuppressWarnings("raw</b></font>types") // TreeBasedTable.create() is defined as such
  @Generates
  static &lt;R extends Comparable, C extends Comparable, V&gt;
      TreeBasedTable&lt;R, C, V&gt; generateTreeBasedTable(R row, C column, V value) {
    TreeBasedTable&lt;R, C, V&gt; table = TreeBasedTable.create();
    table.put(row, column, value);
    return table;
  }
<a name="17"></a>
  @Generates
  static &lt;R, C, V&gt; ImmutableTable&lt;R, C, V&gt; generateImmutableTable(R row, C column, V value) {
    return <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ImmutableTable.of(row, column, value);
  }

  // common.reflect
  @Generates
  TypeToken&lt;?&gt; generateTypeToken() {
    return TypeToken.of(generateClass</b></font>());
  }

  // io types
  @Generates
  File generateFile() {
    return new File(generateString());
  }

  @Generates
  static ByteArrayInputStream generateByteArrayInputStream() {
    return new ByteArrayInputStream(new byte[0]);
  }

  @Generates
  static InputStream generateInputStream() {
    return generateByteArrayInputStream();
  }

  @Generates
  StringReader generateStringReader() {
    return new StringReader(generateString());
  }

  @Generates
  Reader generateReader() {
    return generateStringReader();
  }

  @Generates
  Readable generateReadable() {
    return generateReader();
  }

  @Generates
  Buffer generateBuffer() {
    return generateCharBuffer();
  }
<a name="6"></a>
  @Generates
  CharBuffer generateCharBuffer() {
    return <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CharBuffer.allocate(generateInt());
  }

  @Generates
  ByteBuffer generateByteBuffer() {
    return ByteBuffer.allocate(generateInt());
  }

  @</b></font>Generates
  ShortBuffer generateShortBuffer() {
<a name="8"></a>    return ShortBuffer.allocate(generateInt());
  }

  <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Generates
  IntBuffer generateIntBuffer() {
    return IntBuffer.allocate(generateInt());
  }

  @Generates
  LongBuffer generateLongBuffer() {
<a name="7"></a>    return LongBuffer.allocate(generateInt</b></font>());
  }

  <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Generates
  FloatBuffer generateFloatBuffer() {
    return FloatBuffer.allocate(generateInt());
  }

  @Generates
  DoubleBuffer generateDoubleBuffer() {
    return DoubleBuffer.allocate(generateInt</b></font>());
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
