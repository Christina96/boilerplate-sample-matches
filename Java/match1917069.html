<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TraverserTest.java & ImmutableNetwork_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TraverserTest.java & ImmutableNetwork_1.java
      </h3>
      <h1 align="center">
        2.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TraverserTest.java (1.2425716%)<TH>ImmutableNetwork_1.java (10.599078%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1917069-0.html#0',2,'match1917069-1.html#0',3)" NAME="0">(1259-1266)<TD><A HREF="javascript:ZweiFrames('match1917069-0.html#0',2,'match1917069-1.html#0',3)" NAME="0">(157-171)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1917069-0.html#1',2,'match1917069-1.html#1',3)" NAME="1">(28-37)<TD><A HREF="javascript:ZweiFrames('match1917069-0.html#1',2,'match1917069-1.html#1',3)" NAME="1">(19-46)</A><TD ALIGN=center><FONT COLOR="#c40000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TraverserTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*

* Copyright (C) 2017 The Guava Authors
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.google.common.graph;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.Lists.charactersOf;
import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.fail;
<A NAME="1"></A>
import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableList;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1917069-1.html#1',3,'match1917069-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Multiset;
import com.google.common.collect.Ordering;
import com.google.common.primitives.Chars;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

@</B></FONT>RunWith(JUnit4.class)
public class TraverserTest {

  /**
   * The undirected graph in the {@link Traverser#breadthFirst(Object)} javadoc:
   *
   * &lt;pre&gt;{@code
   * b ---- a ---- d
   * |      |
   * |      |
   * e ---- c ---- f
   * }&lt;/pre&gt;
   */
  private static final SuccessorsFunction&lt;Character&gt; JAVADOC_GRAPH =
      createUndirectedGraph(&quot;ba&quot;, &quot;ad&quot;, &quot;be&quot;, &quot;ac&quot;, &quot;ec&quot;, &quot;cf&quot;);

  /**
   * A diamond shaped directed graph (arrows going down):
   *
   * &lt;pre&gt;{@code
   *   a
   *  / \
   * b   c
   *  \ /
   *   d
   * }&lt;/pre&gt;
   */
  private static final SuccessorsFunction&lt;Character&gt; DIAMOND_GRAPH =
      createDirectedGraph(&quot;ab&quot;, &quot;ac&quot;, &quot;bd&quot;, &quot;cd&quot;);

  /**
   * Same as {@link #DIAMOND_GRAPH}, but with an extra c-&gt;a edge and some self edges:
   *
   * &lt;pre&gt;{@code
   *   a&lt;&gt;
   *  / \\
   * b   c
   *  \ /
   *   d&lt;&gt;
   * }&lt;/pre&gt;
   *
   * {@code &lt;&gt;} indicates a self-loop
   */
  private static final SuccessorsFunction&lt;Character&gt; MULTI_GRAPH =
      createDirectedGraph(&quot;aa&quot;, &quot;dd&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;ca&quot;, &quot;cd&quot;, &quot;bd&quot;);

  /** A directed graph with a single cycle: a -&gt; b -&gt; c -&gt; d -&gt; a. */
  private static final SuccessorsFunction&lt;Character&gt; CYCLE_GRAPH =
      createDirectedGraph(&quot;ab&quot;, &quot;bc&quot;, &quot;cd&quot;, &quot;da&quot;);

  /**
   * Same as {@link #CYCLE_GRAPH}, but with an extra a-&gt;c edge.
   *
   * &lt;pre&gt;{@code
   * |--------------|
   * v              |
   * a -&gt; b -&gt; c -&gt; d
   * |         ^
   * |---------|
   * }&lt;/pre&gt;
   */
  private static final SuccessorsFunction&lt;Character&gt; TWO_CYCLES_GRAPH =
      createDirectedGraph(&quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, &quot;cd&quot;, &quot;da&quot;);

  /**
   * A tree-shaped graph that looks as follows (all edges are directed facing downwards):
   *
   * &lt;pre&gt;{@code
   *        h
   *       /|\
   *      / | \
   *     /  |  \
   *    d   e   g
   *   /|\      |
   *  / | \     |
   * a  b  c    f
   * }&lt;/pre&gt;
   */
  private static final SuccessorsFunction&lt;Character&gt; TREE =
      createDirectedGraph(&quot;hd&quot;, &quot;he&quot;, &quot;hg&quot;, &quot;da&quot;, &quot;db&quot;, &quot;dc&quot;, &quot;gf&quot;);

  /**
   * Two disjoint tree-shaped graphs that look as follows (all edges are directed facing downwards):
   *
   * &lt;pre&gt;{@code
   * a   c
   * |   |
   * |   |
   * b   d
   * }&lt;/pre&gt;
   */
  private static final SuccessorsFunction&lt;Character&gt; TWO_TREES = createDirectedGraph(&quot;ab&quot;, &quot;cd&quot;);

  /**
   * A graph consisting of a single root {@code a}:
   *
   * &lt;pre&gt;{@code
   * a
   * }&lt;/pre&gt;
   */
  private static final SuccessorsFunction&lt;Character&gt; SINGLE_ROOT = createSingleRootGraph();

  /**
   * A graph that is not a tree (for example, it has two antiparallel edge between {@code e} and
   * {@code f} and thus has a cycle) but is a valid input to {@link Traverser#forTree} when starting
   * e.g. at node {@code a} (all edges without an arrow are directed facing downwards):
   *
   * &lt;pre&gt;{@code
   *     a
   *    /
   *   b   e &lt;----&gt; f
   *  / \ /
   * c   d
   * }&lt;/pre&gt;
   */
  private static final SuccessorsFunction&lt;Character&gt; CYCLIC_GRAPH_CONTAINING_TREE =
      createDirectedGraph(&quot;ab&quot;, &quot;bc&quot;, &quot;bd&quot;, &quot;ed&quot;, &quot;ef&quot;, &quot;fe&quot;);

  /**
   * A graph that is not a tree (for example, {@code h} is reachable from {@code f} via both {@code
   * e} and {@code g}) but is a valid input to {@link Traverser#forTree} when starting e.g. at node
   * {@code a} (all edges are directed facing downwards):
   *
   * &lt;pre&gt;{@code
   *     a   f
   *    /   / \
   *   b   e   g
   *  / \ / \ /
   * c   d   h
   * }&lt;/pre&gt;
   */
  private static final SuccessorsFunction&lt;Character&gt; GRAPH_CONTAINING_TREE_AND_DIAMOND =
      createDirectedGraph(&quot;ab&quot;, &quot;fe&quot;, &quot;fg&quot;, &quot;bc&quot;, &quot;bd&quot;, &quot;ed&quot;, &quot;eh&quot;, &quot;gh&quot;);

  @Test
  public void forGraph_breadthFirst_javadocExample_canBeIteratedMultipleTimes() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(JAVADOC_GRAPH).breadthFirst('a');

    assertEqualCharNodes(result, &quot;abcdef&quot;);
    assertEqualCharNodes(result, &quot;abcdef&quot;);
  }

  @Test
  public void forGraph_breadthFirstIterable_javadocExample_canBeIteratedMultipleTimes() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(JAVADOC_GRAPH).breadthFirst(charactersOf(&quot;bf&quot;));

    assertEqualCharNodes(result, &quot;bfaecd&quot;);
    assertEqualCharNodes(result, &quot;bfaecd&quot;);
  }

  @Test
  public void forGraph_breadthFirst_infinite() {
    Iterable&lt;Integer&gt; result =
        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
    assertThat(Iterables.limit(result, 4)).containsExactly(0, 1, 2, 3).inOrder();
  }

  @Test
  public void forGraph_breadthFirst_diamond() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(DIAMOND_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('b'), &quot;bd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('c'), &quot;cd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('d'), &quot;d&quot;);
  }

  @Test
  public void forGraph_breadthFirstIterable_diamond() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(DIAMOND_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;&quot;)), &quot;&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;bc&quot;)), &quot;bcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;acdb&quot;)), &quot;acdb&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;db&quot;)), &quot;db&quot;);
  }

  @Test
  public void forGraph_breadthFirst_multiGraph() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('b'), &quot;bd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('c'), &quot;cadb&quot;);
    assertEqualCharNodes(traverser.breadthFirst('d'), &quot;d&quot;);
  }

  @Test
  public void forGraph_breadthFirstIterable_multiGraph() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;ac&quot;)), &quot;acbd&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;cb&quot;)), &quot;cbad&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;db&quot;)), &quot;db&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;d&quot;)), &quot;d&quot;);
  }

  @Test
  public void forGraph_breadthFirst_cycle() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(CYCLE_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('b'), &quot;bcda&quot;);
    assertEqualCharNodes(traverser.breadthFirst('c'), &quot;cdab&quot;);
    assertEqualCharNodes(traverser.breadthFirst('d'), &quot;dabc&quot;);
  }

  @Test
  public void forGraph_breadthFirstIterable_cycle() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(CYCLE_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;bd&quot;)), &quot;bdca&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;dc&quot;)), &quot;dcab&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;bc&quot;)), &quot;bcda&quot;);
  }

  @Test
  public void forGraph_breadthFirst_twoCycles() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('b'), &quot;bcda&quot;);
    assertEqualCharNodes(traverser.breadthFirst('c'), &quot;cdab&quot;);
    assertEqualCharNodes(traverser.breadthFirst('d'), &quot;dabc&quot;);
  }

  @Test
  public void forGraph_breadthFirstIterable_twoCycles() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;bd&quot;)), &quot;bdca&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;dc&quot;)), &quot;dcab&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;bc&quot;)), &quot;bcda&quot;);
  }

  @Test
  public void forGraph_breadthFirst_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TREE);

    assertEqualCharNodes(traverser.breadthFirst('h'), &quot;hdegabcf&quot;);
    assertEqualCharNodes(traverser.breadthFirst('d'), &quot;dabc&quot;);
    assertEqualCharNodes(traverser.breadthFirst('a'), &quot;a&quot;);
  }

  @Test
  public void forGraph_breadthFirstIterable_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TREE);

    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;hg&quot;)), &quot;hgdefabc&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;gd&quot;)), &quot;gdfabc&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;bdgh&quot;)), &quot;bdghacfe&quot;);
  }

  @Test
  public void forGraph_breadthFirst_twoTrees() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(TWO_TREES).breadthFirst('a');

    assertEqualCharNodes(result, &quot;ab&quot;);
  }

  @Test
  public void forGraph_breadthFirstIterable_twoTrees() {
    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).breadthFirst(charactersOf(&quot;a&quot;)), &quot;ab&quot;);
    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).breadthFirst(charactersOf(&quot;ac&quot;)), &quot;acbd&quot;);
  }

  @Test
  public void forGraph_breadthFirst_singleRoot() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(SINGLE_ROOT).breadthFirst('a');

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forGraph_breadthFirstIterable_singleRoot() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(SINGLE_ROOT).breadthFirst(charactersOf(&quot;a&quot;));

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forGraph_breadthFirst_emptyGraph() {
    try {
      Traverser.forGraph(createDirectedGraph()).breadthFirst('a');
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  /**
   * Checks that the elements of the iterable are calculated on the fly. Concretely, that means that
   * {@link SuccessorsFunction#successors(Object)} can only be called for a subset of all nodes.
   */
  @Test
  public void forGraph_breadthFirstIterable_emptyGraph() {
    assertEqualCharNodes(
        Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(&quot;&quot;)), &quot;&quot;);
    try {
      Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(&quot;a&quot;));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  /**
   * Checks that the elements of the iterable are calculated on the fly. Concretely, that means that
   * {@link SuccessorsFunction#successors(Object)} can only be called for a subset of all nodes.
   */
  @Test
  public void forGraph_breadthFirst_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).breadthFirst('a');

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');
  }

  @Test
  public void forGraph_breadthFirstIterable_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).breadthFirst(charactersOf(&quot;ab&quot;));

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'b');
  }

  @Test
  public void forGraph_depthFirstPreOrder_javadocExample_canBeIteratedMultipleTimes() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(JAVADOC_GRAPH).depthFirstPreOrder('a');

    assertEqualCharNodes(result, &quot;abecfd&quot;);
    assertEqualCharNodes(result, &quot;abecfd&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_javadocExample_canBeIteratedMultipleTimes() {
    Iterable&lt;Character&gt; result =
        Traverser.forGraph(JAVADOC_GRAPH).depthFirstPreOrder(charactersOf(&quot;bc&quot;));

    assertEqualCharNodes(result, &quot;bacefd&quot;);
    assertEqualCharNodes(result, &quot;bacefd&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrder_infinite() {
    Iterable&lt;Integer&gt; result =
        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).depthFirstPreOrder(0);
    assertThat(Iterables.limit(result, 3)).containsExactly(0, 1, 2).inOrder();
  }

  @Test
  public void forGraph_depthFirstPreOrder_diamond() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(DIAMOND_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), &quot;abdc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('b'), &quot;bd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('c'), &quot;cd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), &quot;d&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_diamond() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(DIAMOND_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;&quot;)), &quot;&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;bc&quot;)), &quot;bdc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;a&quot;)), &quot;abdc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;acdb&quot;)), &quot;abdc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;db&quot;)), &quot;db&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrder_multigraph() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), &quot;abdc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('b'), &quot;bd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('c'), &quot;cabd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), &quot;d&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_multigraph() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;ac&quot;)), &quot;abdc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;cb&quot;)), &quot;cabd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;db&quot;)), &quot;db&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;d&quot;)), &quot;d&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrder_cycle() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(CYCLE_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('b'), &quot;bcda&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('c'), &quot;cdab&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), &quot;dabc&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_cycle() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(CYCLE_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;bd&quot;)), &quot;bcda&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;dc&quot;)), &quot;dabc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;bc&quot;)), &quot;bcda&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrder_twoCycles() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('b'), &quot;bcda&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('c'), &quot;cdab&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), &quot;dabc&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_twoCycles() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;bd&quot;)), &quot;bcda&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;dc&quot;)), &quot;dabc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;bc&quot;)), &quot;bcda&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrder_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TREE);

    assertEqualCharNodes(traverser.depthFirstPreOrder('h'), &quot;hdabcegf&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), &quot;dabc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), &quot;a&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TREE);

    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;hg&quot;)), &quot;hdabcegf&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;gd&quot;)), &quot;gfdabc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;bdgh&quot;)), &quot;bdacgfhe&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrder_twoTrees() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(TWO_TREES).depthFirstPreOrder('a');

    assertEqualCharNodes(result, &quot;ab&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_twoTrees() {
    assertEqualCharNodes(Traverser.forGraph(TWO_TREES).depthFirstPreOrder(charactersOf(&quot;a&quot;)), &quot;ab&quot;);
    assertEqualCharNodes(
        Traverser.forGraph(TWO_TREES).depthFirstPreOrder(charactersOf(&quot;ac&quot;)), &quot;abcd&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrder_singleRoot() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(SINGLE_ROOT).depthFirstPreOrder('a');

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_singleRoot() {
    Iterable&lt;Character&gt; result =
        Traverser.forGraph(SINGLE_ROOT).depthFirstPreOrder(charactersOf(&quot;a&quot;));

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forGraph_depthFirstPreOrder_emptyGraph() {
    try {
      Traverser.forGraph(createDirectedGraph()).depthFirstPreOrder('a');
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_emptyGraph() {
    assertEqualCharNodes(
        Traverser.forGraph(createDirectedGraph()).depthFirstPreOrder(charactersOf(&quot;&quot;)), &quot;&quot;);
    try {
      Traverser.forGraph(createDirectedGraph()).depthFirstPreOrder(charactersOf(&quot;a&quot;));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forGraph_depthFirstPreOrder_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).depthFirstPreOrder('a');

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');
  }

  @Test
  public void forGraph_depthFirstPreOrderIterable_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(&quot;ac&quot;));

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c');
  }

  @Test
  public void forGraph_depthFirstPostOrder_javadocExample_canBeIteratedMultipleTimes() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(JAVADOC_GRAPH).depthFirstPostOrder('a');
    assertEqualCharNodes(result, &quot;fcebda&quot;);
    assertEqualCharNodes(result, &quot;fcebda&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_javadocExample_canBeIteratedMultipleTimes() {
    Iterable&lt;Character&gt; result =
        Traverser.forGraph(JAVADOC_GRAPH).depthFirstPostOrder(charactersOf(&quot;bf&quot;));
    assertEqualCharNodes(result, &quot;efcdab&quot;);
    assertEqualCharNodes(result, &quot;efcdab&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrder_diamond() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(DIAMOND_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), &quot;dbca&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('b'), &quot;db&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('c'), &quot;dc&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), &quot;d&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_diamond() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(DIAMOND_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;&quot;)), &quot;&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;bc&quot;)), &quot;dbc&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;a&quot;)), &quot;dbca&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;acdb&quot;)), &quot;dbca&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;db&quot;)), &quot;db&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrder_multigraph() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), &quot;dbca&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('b'), &quot;db&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('c'), &quot;dbac&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), &quot;d&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_multigraph() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;ac&quot;)), &quot;dbca&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;cb&quot;)), &quot;dbac&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;db&quot;)), &quot;db&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;d&quot;)), &quot;d&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrder_cycle() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(CYCLE_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), &quot;dcba&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('b'), &quot;adcb&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('c'), &quot;badc&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), &quot;cbad&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_cycle() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(CYCLE_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;a&quot;)), &quot;dcba&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;bd&quot;)), &quot;adcb&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;dc&quot;)), &quot;cbad&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;bc&quot;)), &quot;adcb&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrder_twoCycles() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), &quot;dcba&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('b'), &quot;adcb&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('c'), &quot;badc&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), &quot;cbad&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_twoCycles() {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;a&quot;)), &quot;dcba&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;bd&quot;)), &quot;adcb&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;dc&quot;)), &quot;cbad&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;bc&quot;)), &quot;adcb&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrder_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TREE);

    assertEqualCharNodes(traverser.depthFirstPostOrder('h'), &quot;abcdefgh&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), &quot;a&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forGraph(TREE);

    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;hg&quot;)), &quot;abcdefgh&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;gd&quot;)), &quot;fgabcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;bdgh&quot;)), &quot;bacdfgeh&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrder_twoTrees() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(TWO_TREES).depthFirstPostOrder('a');

    assertEqualCharNodes(result, &quot;ba&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_twoTrees() {
    assertEqualCharNodes(
        Traverser.forGraph(TWO_TREES).depthFirstPostOrder(charactersOf(&quot;a&quot;)), &quot;ba&quot;);
    assertEqualCharNodes(
        Traverser.forGraph(TWO_TREES).depthFirstPostOrder(charactersOf(&quot;ac&quot;)), &quot;badc&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrder_singleRoot() {
    Iterable&lt;Character&gt; result = Traverser.forGraph(SINGLE_ROOT).depthFirstPostOrder('a');

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_singleRoot() {
    Iterable&lt;Character&gt; result =
        Traverser.forGraph(SINGLE_ROOT).depthFirstPostOrder(charactersOf(&quot;a&quot;));

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forGraph_depthFirstPostOrder_emptyGraph() {
    try {
      Traverser.forGraph(createDirectedGraph()).depthFirstPostOrder('a');
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_emptyGraph() {
    assertEqualCharNodes(
        Traverser.forGraph(createDirectedGraph()).depthFirstPostOrder(charactersOf(&quot;&quot;)), &quot;&quot;);
    try {
      Traverser.forGraph(createDirectedGraph()).depthFirstPostOrder(charactersOf(&quot;a&quot;));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forGraph_depthFirstPostOrder_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).depthFirstPostOrder('a');

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;db&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'd');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;db&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'd', 'd');
  }

  @Test
  public void forGraph_depthFirstPostOrderIterable_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(&quot;ac&quot;));

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;db&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;db&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');
  }

  @Test
  @SuppressWarnings(&quot;CheckReturnValue&quot;)
  public void forTree_acceptsDirectedGraph() throws Exception {
    MutableGraph&lt;String&gt; graph = GraphBuilder.directed().build();
    graph.putEdge(&quot;a&quot;, &quot;b&quot;);

    Traverser.forTree(graph); // Does not throw
  }

  @Test
  public void forTree_withUndirectedGraph_throws() throws Exception {
    MutableGraph&lt;String&gt; graph = GraphBuilder.undirected().build();
    graph.putEdge(&quot;a&quot;, &quot;b&quot;);

    try {
      Traverser.forTree(graph);
      fail(&quot;Expected exception&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  @SuppressWarnings(&quot;CheckReturnValue&quot;)
  public void forTree_acceptsDirectedValueGraph() throws Exception {
    MutableValueGraph&lt;String, Integer&gt; valueGraph = ValueGraphBuilder.directed().build();
    valueGraph.putEdgeValue(&quot;a&quot;, &quot;b&quot;, 11);

    Traverser.forTree(valueGraph); // Does not throw
  }

  @Test
  public void forTree_withUndirectedValueGraph_throws() throws Exception {
    MutableValueGraph&lt;String, Integer&gt; valueGraph = ValueGraphBuilder.undirected().build();
    valueGraph.putEdgeValue(&quot;a&quot;, &quot;b&quot;, 11);

    try {
      Traverser.forTree(valueGraph);
      fail(&quot;Expected exception&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  @SuppressWarnings(&quot;CheckReturnValue&quot;)
  public void forTree_acceptsDirectedNetwork() throws Exception {
    MutableNetwork&lt;String, Integer&gt; network = NetworkBuilder.directed().build();
    network.addEdge(&quot;a&quot;, &quot;b&quot;, 11);

    Traverser.forTree(network); // Does not throw
  }

  @Test
  public void forTree_withUndirectedNetwork_throws() throws Exception {
    MutableNetwork&lt;String, Integer&gt; network = NetworkBuilder.undirected().build();
    network.addEdge(&quot;a&quot;, &quot;b&quot;, 11);

    try {
      Traverser.forTree(network);
      fail(&quot;Expected exception&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forTree_breadthFirst_infinite() {
    Iterable&lt;Integer&gt; result =
        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
    assertThat(Iterables.limit(result, 8)).containsExactly(0, 1, 2, 3, 1, 2, 3, 1).inOrder();
  }

  @Test
  public void forTree_breadthFirst_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(TREE);

    assertEqualCharNodes(traverser.breadthFirst('h'), &quot;hdegabcf&quot;);
    assertEqualCharNodes(traverser.breadthFirst('d'), &quot;dabc&quot;);
    assertEqualCharNodes(traverser.breadthFirst('a'), &quot;a&quot;);
  }

  @Test
  public void forTree_breadthFirstIterable_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(TREE);

    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;&quot;)), &quot;&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;h&quot;)), &quot;hdegabcf&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;gd&quot;)), &quot;gdfabc&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;age&quot;)), &quot;agef&quot;);
  }

  @Test
  public void forTree_breadthFirst_cyclicGraphContainingTree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);

    assertEqualCharNodes(traverser.breadthFirst('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('b'), &quot;bcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('d'), &quot;d&quot;);
  }

  @Test
  public void forTree_breadthFirstIterable_cyclicGraphContainingTree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);

    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;b&quot;)), &quot;bcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;cd&quot;)), &quot;cd&quot;);
  }

  @Test
  public void forTree_breadthFirst_graphContainingTreeAndDiamond() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);

    assertEqualCharNodes(traverser.breadthFirst('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('b'), &quot;bcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst('d'), &quot;d&quot;);
  }

  @Test
  public void forTree_breadthFirstIterable_graphContainingTreeAndDiamond() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);

    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;bg&quot;)), &quot;bgcdh&quot;);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf(&quot;ga&quot;)), &quot;gahbcd&quot;);
  }

  @Test
  public void forTree_breadthFirst_twoTrees() {
    Iterable&lt;Character&gt; result = Traverser.forTree(TWO_TREES).breadthFirst('a');

    assertEqualCharNodes(result, &quot;ab&quot;);
  }

  @Test
  public void forTree_breadthFirstIterable_twoTrees() {
    assertEqualCharNodes(Traverser.forTree(TWO_TREES).breadthFirst(charactersOf(&quot;a&quot;)), &quot;ab&quot;);
    assertEqualCharNodes(Traverser.forTree(TWO_TREES).breadthFirst(charactersOf(&quot;ca&quot;)), &quot;cadb&quot;);
  }

  @Test
  public void forTree_breadthFirst_singleRoot() {
    Iterable&lt;Character&gt; result = Traverser.forTree(SINGLE_ROOT).breadthFirst('a');

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forTree_breadthFirstIterable_singleRoot() {
    Iterable&lt;Character&gt; result = Traverser.forTree(SINGLE_ROOT).breadthFirst(charactersOf(&quot;a&quot;));

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forTree_breadthFirst_emptyGraph() {
    try {
      Traverser.forTree(createDirectedGraph()).breadthFirst('a');
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forTree_breadthFirstIterable_emptyGraph() {
    assertEqualCharNodes(
        Traverser.forTree(createDirectedGraph()).breadthFirst(charactersOf(&quot;&quot;)), &quot;&quot;);
    try {
      Traverser.forTree(createDirectedGraph()).breadthFirst(charactersOf(&quot;a&quot;));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forTree_breadthFirst_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).breadthFirst('h');

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;hd&quot;);
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;hd&quot;);
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');
  }

  @Test
  public void forTree_breadthFirstIterable_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).breadthFirst(charactersOf(&quot;dg&quot;));

    assertEqualCharNodes(Iterables.limit(result, 3), &quot;dga&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'd', 'd', 'g', 'g');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 3), &quot;dga&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g', 'g', 'g');
  }

  @Test
  public void forTree_depthFirstPreOrder_infinite() {
    Iterable&lt;Integer&gt; result =
        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).depthFirstPreOrder(0);
    assertThat(Iterables.limit(result, 3)).containsExactly(0, 1, 1).inOrder();
  }

  @Test
  public void forTree_depthFirstPreOrderIterable_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(TREE);

    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;h&quot;)), &quot;hdabcegf&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;d&quot;)), &quot;dabc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;a&quot;)), &quot;a&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrderIterableIterable_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(TREE);

    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;&quot;)), &quot;&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;h&quot;)), &quot;hdabcegf&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;gd&quot;)), &quot;gfdabc&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;age&quot;)), &quot;agfe&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrder_cyclicGraphContainingTree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);

    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('b'), &quot;bcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), &quot;d&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrderIterable_cyclicGraphContainingTree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);

    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;b&quot;)), &quot;bcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;cd&quot;)), &quot;cd&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrder_graphContainingTreeAndDiamond() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);

    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('b'), &quot;bcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), &quot;d&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrderIterable_graphContainingTreeAndDiamond() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);

    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;a&quot;)), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;bg&quot;)), &quot;bcdgh&quot;);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf(&quot;ga&quot;)), &quot;ghabcd&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrder_twoTrees() {
    Iterable&lt;Character&gt; result = Traverser.forTree(TWO_TREES).depthFirstPreOrder('a');

    assertEqualCharNodes(result, &quot;ab&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrderIterable_twoTrees() {
    assertEqualCharNodes(Traverser.forTree(TWO_TREES).depthFirstPreOrder(charactersOf(&quot;a&quot;)), &quot;ab&quot;);
    assertEqualCharNodes(
        Traverser.forTree(TWO_TREES).depthFirstPreOrder(charactersOf(&quot;ca&quot;)), &quot;cdab&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrder_singleRoot() {
    Iterable&lt;Character&gt; result = Traverser.forTree(SINGLE_ROOT).depthFirstPreOrder('a');

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrderIterable_singleRoot() {
    Iterable&lt;Character&gt; result =
        Traverser.forTree(SINGLE_ROOT).depthFirstPreOrder(charactersOf(&quot;a&quot;));

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forTree_depthFirstPreOrder_emptyGraph() {
    try {
      Traverser.forTree(createDirectedGraph()).depthFirstPreOrder('a');
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forTree_depthFirstPreOrderIterable_emptyGraph() {
    assertEqualCharNodes(
        Traverser.forTree(createDirectedGraph()).depthFirstPreOrder(charactersOf(&quot;&quot;)), &quot;&quot;);
    try {
      Traverser.forTree(createDirectedGraph()).depthFirstPreOrder(charactersOf(&quot;a&quot;));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forTree_depthFirstPreOrder_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).depthFirstPreOrder('h');

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;hd&quot;);
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;hd&quot;);
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');
  }

  @Test
  public void forTree_depthFirstPreOrderIterable_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(&quot;dg&quot;));

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;da&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'd', 'd', 'g');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;da&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g');
  }

  @Test
  public void forTree_depthFirstPostOrder_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(TREE);

    assertEqualCharNodes(traverser.depthFirstPostOrder('h'), &quot;abcdefgh&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), &quot;abcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), &quot;a&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrderIterable_tree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(TREE);

    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;&quot;)), &quot;&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;h&quot;)), &quot;abcdefgh&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;gd&quot;)), &quot;fgabcd&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;age&quot;)), &quot;afge&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrder_cyclicGraphContainingTree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);

    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), &quot;cdba&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('b'), &quot;cdb&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), &quot;d&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrderIterable_cyclicGraphContainingTree() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(CYCLIC_GRAPH_CONTAINING_TREE);

    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;a&quot;)), &quot;cdba&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;b&quot;)), &quot;cdb&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;cd&quot;)), &quot;cd&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrder_graphContainingTreeAndDiamond() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);

    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), &quot;cdba&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('b'), &quot;cdb&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), &quot;d&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrderIterable_graphContainingTreeAndDiamond() throws Exception {
    Traverser&lt;Character&gt; traverser = Traverser.forTree(GRAPH_CONTAINING_TREE_AND_DIAMOND);

    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;a&quot;)), &quot;cdba&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;bg&quot;)), &quot;cdbhg&quot;);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf(&quot;ga&quot;)), &quot;hgcdba&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrder_twoTrees() {
    Iterable&lt;Character&gt; result = Traverser.forTree(TWO_TREES).depthFirstPostOrder('a');

    assertEqualCharNodes(result, &quot;ba&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrderIterable_twoTrees() {
    assertEqualCharNodes(Traverser.forTree(TWO_TREES).depthFirstPostOrder(charactersOf(&quot;a&quot;)), &quot;ba&quot;);
    assertEqualCharNodes(
        Traverser.forTree(TWO_TREES).depthFirstPostOrder(charactersOf(&quot;ca&quot;)), &quot;dcba&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrder_singleRoot() {
    Iterable&lt;Character&gt; result = Traverser.forTree(SINGLE_ROOT).depthFirstPostOrder('a');

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrderIterable_singleRoot() {
    Iterable&lt;Character&gt; result =
        Traverser.forTree(SINGLE_ROOT).depthFirstPostOrder(charactersOf(&quot;a&quot;));

    assertEqualCharNodes(result, &quot;a&quot;);
  }

  @Test
  public void forTree_depthFirstPostOrder_emptyGraph() {
    try {
      Traverser.forTree(createDirectedGraph()).depthFirstPostOrder('a');
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forTree_depthFirstPostOrderIterable_emptyGraph() {
    assertEqualCharNodes(
        Traverser.forTree(createDirectedGraph()).depthFirstPostOrder(charactersOf(&quot;&quot;)), &quot;&quot;);
    try {
      Traverser.forTree(createDirectedGraph()).depthFirstPostOrder(charactersOf(&quot;a&quot;));
      fail(&quot;Expected IllegalArgumentException&quot;);
    } catch (IllegalArgumentException expected) {
    }
  }

  @Test
  public void forTree_depthFirstPostOrder_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).depthFirstPostOrder('h');

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a', 'b');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a', 'b', 'b');
  }

  @Test
  public void forTree_depthFirstPostOrderIterable_iterableIsLazy() {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable&lt;Character&gt; result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(&quot;dg&quot;));

    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'b', 'd', 'd', 'g');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), &quot;ab&quot;);
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b', 'd', 'd', 'd', 'g');
  }

  private static SuccessorsFunction&lt;Character&gt; createDirectedGraph(String... edges) {
    return createGraph(/* directed = */ true, edges);
  }

  private static SuccessorsFunction&lt;Character&gt; createUndirectedGraph(String... edges) {
    return createGraph(/* directed = */ false, edges);
  }

  /**
   * Creates a graph from a list of node pairs (encoded as strings, e.g. &quot;ab&quot; means that this graph
   * has an edge between 'a' and 'b').
   *
   * &lt;p&gt;The {@code successors} are always returned in alphabetical order.
   */
  private static SuccessorsFunction&lt;Character&gt; createGraph(boolean directed, String... edges) {
    ImmutableMultimap.Builder&lt;Character, Character&gt; graphMapBuilder = ImmutableMultimap.builder();
    for (String edge : edges) {
      checkArgument(
          edge.length() == 2, &quot;Expecting each edge to consist of 2 characters but got %s&quot;, edge);
      char node1 = edge.charAt(0);
      char node2 = edge.charAt(1);
      graphMapBuilder.put(node1, node2);
      if (!directed) {
        graphMapBuilder.put(node2, node1);
      }
    }
    final ImmutableMultimap&lt;Character, Character&gt; graphMap = graphMapBuilder.build();

    return new SuccessorsFunction&lt;Character&gt;() {
      @Override
      public Iterable&lt;? extends Character&gt; successors(Character node) {
        checkArgument(
            graphMap.containsKey(node) || graphMap.containsValue(node),
            &quot;Node %s is not an element of this graph&quot;,
            node);
        return Ordering.natural().immutableSortedCopy(graphMap.get(node));
      }
    };
  }

  private static ImmutableGraph&lt;Character&gt; createSingleRootGraph() {
    MutableGraph&lt;Character&gt; graph = GraphBuilder.directed().build();
    graph.addNode('a');
    return ImmutableGraph.copyOf(graph);
  }

  private static void assertEqualCharNodes(Iterable&lt;Character&gt; result, String expectedCharacters) {
    assertThat(ImmutableList.copyOf(result))
        .containsExactlyElementsIn(Chars.asList(expectedCharacters.toCharArray()))
        .inOrder();
  }

  private static class RequestSavingGraph implements SuccessorsFunction&lt;Character&gt; {
<A NAME="0"></A>    private final SuccessorsFunction&lt;Character&gt; delegate;
    final Multiset&lt;Character&gt; requestedNodes = HashMultiset.create();

    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1917069-1.html#0',3,'match1917069-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>RequestSavingGraph(SuccessorsFunction&lt;Character&gt; delegate) {
      this.delegate = checkNotNull(delegate);
    }

    @Override
    public Iterable&lt;? extends Character&gt; successors(Character node) {
      requestedNodes.add(node);
      return</B></FONT> delegate.successors(node);
    }
  }

  private static &lt;N&gt; SuccessorsFunction&lt;N&gt; fixedSuccessors(final Iterable&lt;N&gt; successors) {
    return new SuccessorsFunction&lt;N&gt;() {
      @Override
      public Iterable&lt;N&gt; successors(N n) {
        return successors;
      }
    };
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableNetwork_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2014 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="1"></A>
package com.google.common.graph;

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1917069-0.html#1',2,'match1917069-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.Beta;
import com.google.common.base.Function;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.Immutable;
import java.util.Map;

/**
 * A {@link Network} whose elements and structural relationships will never change. Instances of
 * this class may be obtained with {@link #copyOf(Network)}.
 *
 * &lt;p&gt;See the Guava User's Guide's &lt;a
 * href=&quot;https://github.com/google/guava/wiki/GraphsExplained#immutable-implementations&quot;&gt;discussion
 * of the {@code Immutable*} types&lt;/a&gt; for more information on the properties and guarantees
 * provided by this class.
 *
 * @author James Sexton
 * @author Joshua O'Madadhain
 * @author Omar Darwish
 * @author Jens Nyman
 * @param &lt;N&gt; Node parameter type
 * @param &lt;E&gt; Edge parameter type
 * @since 20.0
 */
@</B></FONT>Beta
@Immutable(containerOf = {&quot;N&quot;, &quot;E&quot;})
@SuppressWarnings(&quot;Immutable&quot;) // Extends StandardNetwork but uses ImmutableMaps.
@ElementTypesAreNonnullByDefault
public final class ImmutableNetwork&lt;N, E&gt; extends StandardNetwork&lt;N, E&gt; {

  private ImmutableNetwork(Network&lt;N, E&gt; network) {
    super(
        NetworkBuilder.from(network), getNodeConnections(network), getEdgeToReferenceNode(network));
  }

  /** Returns an immutable copy of {@code network}. */
  public static &lt;N, E&gt; ImmutableNetwork&lt;N, E&gt; copyOf(Network&lt;N, E&gt; network) {
    return (network instanceof ImmutableNetwork)
        ? (ImmutableNetwork&lt;N, E&gt;) network
        : new ImmutableNetwork&lt;N, E&gt;(network);
  }

  /**
   * Simply returns its argument.
   *
   * @deprecated no need to use this
   */
  @Deprecated
  public static &lt;N, E&gt; ImmutableNetwork&lt;N, E&gt; copyOf(ImmutableNetwork&lt;N, E&gt; network) {
    return checkNotNull(network);
  }

  @Override
  public ImmutableGraph&lt;N&gt; asGraph() {
    return new ImmutableGraph&lt;&gt;(super.asGraph()); // safe because the view is effectively immutable
  }

  private static &lt;N, E&gt; Map&lt;N, NetworkConnections&lt;N, E&gt;&gt; getNodeConnections(Network&lt;N, E&gt; network) {
    // ImmutableMap.Builder maintains the order of the elements as inserted, so the map will have
    // whatever ordering the network's nodes do, so ImmutableSortedMap is unnecessary even if the
    // input nodes are sorted.
    ImmutableMap.Builder&lt;N, NetworkConnections&lt;N, E&gt;&gt; nodeConnections = ImmutableMap.builder();
    for (N node : network.nodes()) {
      nodeConnections.put(node, connectionsOf(network, node));
    }
    return nodeConnections.buildOrThrow();
  }

  private static &lt;N, E&gt; Map&lt;E, N&gt; getEdgeToReferenceNode(Network&lt;N, E&gt; network) {
    // ImmutableMap.Builder maintains the order of the elements as inserted, so the map will have
    // whatever ordering the network's edges do, so ImmutableSortedMap is unnecessary even if the
    // input edges are sorted.
    ImmutableMap.Builder&lt;E, N&gt; edgeToReferenceNode = ImmutableMap.builder();
    for (E edge : network.edges()) {
      edgeToReferenceNode.put(edge, network.incidentNodes(edge).nodeU());
    }
    return edgeToReferenceNode.buildOrThrow();
  }

  private static &lt;N, E&gt; NetworkConnections&lt;N, E&gt; connectionsOf(Network&lt;N, E&gt; network, N node) {
    if (network.isDirected()) {
      Map&lt;E, N&gt; inEdgeMap = Maps.asMap(network.inEdges(node), sourceNodeFn(network));
      Map&lt;E, N&gt; outEdgeMap = Maps.asMap(network.outEdges(node), targetNodeFn(network));
      int selfLoopCount = network.edgesConnecting(node, node).size();
      return network.allowsParallelEdges()
          ? DirectedMultiNetworkConnections.ofImmutable(inEdgeMap, outEdgeMap, selfLoopCount)
          : DirectedNetworkConnections.ofImmutable(inEdgeMap, outEdgeMap, selfLoopCount);
    } else {
      Map&lt;E, N&gt; incidentEdgeMap =
          Maps.asMap(network.incidentEdges(node), adjacentNodeFn(network, node));
      return network.allowsParallelEdges()
          ? UndirectedMultiNetworkConnections.ofImmutable(incidentEdgeMap)
          : UndirectedNetworkConnections.ofImmutable(incidentEdgeMap);
    }
  }

  private static &lt;N, E&gt; Function&lt;E, N&gt; sourceNodeFn(Network&lt;N, E&gt; network) {
    return (E edge) -&gt; network.incidentNodes(edge).source();
  }

  private static &lt;N, E&gt; Function&lt;E, N&gt; targetNodeFn(Network&lt;N, E&gt; network) {
    return (E edge) -&gt; network.incidentNodes(edge).target();
  }

  private static &lt;N, E&gt; Function&lt;E, N&gt; adjacentNodeFn(Network&lt;N, E&gt; network, N node) {
    return (E edge) -&gt; network.incidentNodes(edge).adjacentNode(node);
  }

  /**
   * A builder for creating {@link ImmutableNetwork} instances, especially {@code static final}
   * networks. Example:
   *
   * &lt;pre&gt;{@code
   * static final ImmutableNetwork&lt;City, Train&gt; TRAIN_NETWORK =
   *     NetworkBuilder.undirected()
   *         .allowsParallelEdges(true)
   *         .&lt;City, Train&gt;immutable()
   *         .addEdge(PARIS, BRUSSELS, Thalys.trainNumber(&quot;1111&quot;))
   *         .addEdge(PARIS, BRUSSELS, RegionalTrain.trainNumber(&quot;2222&quot;))
   *         .addEdge(LONDON, PARIS, Eurostar.trainNumber(&quot;3333&quot;))
   *         .addEdge(LONDON, BRUSSELS, Eurostar.trainNumber(&quot;4444&quot;))
   *         .addNode(REYKJAVIK)
   *         .build();
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;Builder instances can be reused; it is safe to call {@link #build} multiple times to build
   * multiple networks in series. Each new network contains all the elements of the ones created
   * before it.
   *
   * @since 28.0
   */
  public static class Builder&lt;N, E&gt; {
<A NAME="0"></A>
    private final MutableNetwork&lt;N, E&gt; mutableNetwork;

    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1917069-0.html#0',2,'match1917069-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Builder(NetworkBuilder&lt;N, E&gt; networkBuilder) {
      this.mutableNetwork = networkBuilder.build();
    }

    /**
     * Adds {@code node} if it is not already present.
     *
     * &lt;p&gt;&lt;b&gt;Nodes must be unique&lt;/b&gt;, just as {@code Map} keys must be. They must also be non-null.
     *
     * @return this {@code Builder} object
     */
    @CanIgnoreReturnValue
    public ImmutableNetwork.Builder&lt;N, E&gt; addNode(N node) {
      mutableNetwork.addNode(node);
      return</B></FONT> this;
    }

    /**
     * Adds {@code edge} connecting {@code nodeU} to {@code nodeV}.
     *
     * &lt;p&gt;If the network is directed, {@code edge} will be directed in this network; otherwise, it
     * will be undirected.
     *
     * &lt;p&gt;&lt;b&gt;{@code edge} must be unique to this network&lt;/b&gt;, just as a {@code Map} key must be. It
     * must also be non-null.
     *
     * &lt;p&gt;If {@code nodeU} and {@code nodeV} are not already present in this network, this method
     * will silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the network.
     *
     * &lt;p&gt;If {@code edge} already connects {@code nodeU} to {@code nodeV} (in the specified order if
     * this network {@link #isDirected()}, else in any order), then this method will have no effect.
     *
     * @return this {@code Builder} object
     * @throws IllegalArgumentException if {@code edge} already exists in the network and does not
     *     connect {@code nodeU} to {@code nodeV}
     * @throws IllegalArgumentException if the introduction of the edge would violate {@link
     *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
     */
    @CanIgnoreReturnValue
    public ImmutableNetwork.Builder&lt;N, E&gt; addEdge(N nodeU, N nodeV, E edge) {
      mutableNetwork.addEdge(nodeU, nodeV, edge);
      return this;
    }

    /**
     * Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will
     * also connect {@code nodeV} to {@code nodeU}.
     *
     * &lt;p&gt;If this network is directed, {@code edge} will be directed in this network; if it is
     * undirected, {@code edge} will be undirected in this network.
     *
     * &lt;p&gt;If this network is directed, {@code endpoints} must be ordered.
     *
     * &lt;p&gt;&lt;b&gt;{@code edge} must be unique to this network&lt;/b&gt;, just as a {@code Map} key must be. It
     * must also be non-null.
     *
     * &lt;p&gt;If either or both endpoints are not already present in this network, this method will
     * silently {@link #addNode(Object) add} each missing endpoint to the network.
     *
     * &lt;p&gt;If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this
     * method will have no effect.
     *
     * @return this {@code Builder} object
     * @throws IllegalArgumentException if {@code edge} already exists in the network and connects
     *     some other endpoint pair that is not equal to {@code endpoints}
     * @throws IllegalArgumentException if the introduction of the edge would violate {@link
     *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
     * @throws IllegalArgumentException if the endpoints are unordered and the network is directed
     */
    @CanIgnoreReturnValue
    public ImmutableNetwork.Builder&lt;N, E&gt; addEdge(EndpointPair&lt;N&gt; endpoints, E edge) {
      mutableNetwork.addEdge(endpoints, edge);
      return this;
    }

    /**
     * Returns a newly-created {@code ImmutableNetwork} based on the contents of this {@code
     * Builder}.
     */
    public ImmutableNetwork&lt;N, E&gt; build() {
      return ImmutableNetwork.copyOf(mutableNetwork);
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
