
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.280193236714976%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-RpcCommandUtil.java</h3>
            <pre><code>1  package com.weibo.api.motan.registry.support.command;
2  import com.alibaba.fastjson.JSONObject;
3  import com.google.common.collect.ImmutableMap;
4  import com.google.common.collect.ImmutableSet;
5  import com.weibo.api.motan.util.LoggerUtil;
6  import java.util.LinkedList;
7  import java.util.Map;
8  import java.util.Set;
9  import java.util.regex.Matcher;
10  import java.util.regex.Pattern;
11  public class RpcCommandUtil {
12      public static RpcCommand stringToCommand(String commandString) {
13          try {
14              RpcCommand rpcCommand = JSONObject.parseObject(commandString, RpcCommand.class);
15              if (rpcCommand != null) {
16                  rpcCommand.sort();
17              }
18              return rpcCommand;
19          } catch (Exception e) {
20              LoggerUtil.error("指令配置错误：不是合法的JSON格式!");
21              return null;
22          }
23      }
24      public static String commandToString(RpcCommand command) {
25          if (command == null) {
26              return null;
27          }
28          return JSONObject.toJSONString(command);
29      }
30      private static PatternEvaluator evaluator = new PatternEvaluator();
31      public static boolean match(String expression, String path) {
32          if (expression == null || expression.length() == 0) {
33              return false;
34          }
35          return evaluator.match(expression, path);
36      }
37      private static class PatternEvaluator {
<span onclick='openModal()' class='match'>38          Pattern pattern = Pattern.compile("[a-zA-Z0-9_$.*]+");
39          Set<Character> all = ImmutableSet.of('(', ')', '0', '1', '!', '&', '|');
40          Map<Character, ImmutableSet<Character>> following = ImmutableMap.<Character, ImmutableSet<Character>>builder()
41                  .put('(', ImmutableSet.of('0', '1', '!')).put(')', ImmutableSet.of('|', '&', ')')).put('0', ImmutableSet.of('|', '&', ')'))
</span>42                  .put('1', ImmutableSet.of('|', '&', ')')).put('!', ImmutableSet.of('(', '0', '1', '!'))
43                  .put('&', ImmutableSet.of('(', '0', '1', '!')).put('|', ImmutableSet.of('(', '0', '1', '!')).build();
44          boolean match(String expression, String path) {
45              Matcher matcher = pattern.matcher(expression.replaceAll("\\s+", ""));
46              StringBuffer buffer = new StringBuffer();
47              while (matcher.find()) {
48                  String s = matcher.group();
49                  int idx = s.indexOf('*');
50                  if (idx != -1) {
51                      matcher.appendReplacement(buffer, path.startsWith(s.substring(0, idx)) ? "1" : "0");
52                  } else {
53                      matcher.appendReplacement(buffer, s.equals(path) ? "1" : "0");
54                  }
55              }
56              matcher.appendTail(buffer);
57              String result1 = buffer.toString();
58              LinkedList<LinkedList<Character>> outer = new LinkedList<>();
59              LinkedList<Character> inner = new LinkedList<>();
60              inner.push('#');
61              outer.push(inner);
62              int i = 0;
63              int len = result1.length();
64              while (outer.size() > 0 && i < len) {
65                  LinkedList<Character> sub = outer.peekLast();
66                  while (sub.size() > 0 && i < len) {
67                      char curr = result1.charAt(i++);
68                      support(curr);
69                      char prev = sub.peekFirst();
70                      if (prev != '#') {
71                          supportFollowing(prev, curr);
72                      }
73                      switch (curr) {
74                          case '(':
75                              sub = new LinkedList<>();
76                              sub.push('#');
77                              outer.push(sub);
78                              break;
79                          case ')':
80                              outer.removeFirst();
81                              outer.peekFirst().push(evalWithinParentheses(sub));
82                              sub = outer.peekFirst();
83                              break;
84                          default:
85                              sub.push(curr);
86                      }
87                  }
88              }
89              if (outer.size() != 1) {
90                  throw new IllegalArgumentException("语法错误, 可能圆括号没有闭合");
91              }
92              char result = evalWithinParentheses(outer.peekLast());
93              return result == '1';
94          }
95          char evalWithinParentheses(LinkedList<Character> list) {
96              char operand = list.pop();
97              if (operand != '0' && operand != '1') {
98                  syntaxError();
99              }
100              while (!list.isEmpty()) {
101                  char curr = list.pop();
102                  if (curr == '!') {
103                      operand = operand == '0' ? '1' : '0';
104                  } else if (curr == '#') {
105                      break;
106                  } else {
107                      if (operand == '0' || operand == '1') {
108                          list.addLast(operand);
109                          list.addLast(curr);
110                          operand = '\0';
111                      } else {
112                          operand = curr;
113                      }
114                  }
115              }
116              list.addLast(operand);
117              list.addLast('#');
118              operand = list.pop();
119              while (!list.isEmpty()) {
120                  char curr = list.pop();
121                  if (curr == '&') {
122                      char c = list.pop();
123                      operand = (operand == '1' && c == '1') ? '1' : '0';
124                  } else if (curr == '#') {
125                      break;
126                  } else {
127                      if (operand == '0' || operand == '1') {
128                          list.addLast(operand);
129                          list.addLast(curr);
130                          operand = '\0';
131                      } else {
132                          operand = curr;
133                      }
134                  }
135              }
136              list.addLast(operand);
137              operand = '0';
138              while (!list.isEmpty() && (operand = list.pop()) != '1') ;
139              return operand;
140          }
141          void syntaxError() {
142              throw new IllegalArgumentException("语法错误, 仅支持括号(),非!,与&,或|这几个运算符, 优先级依次递减.");
143          }
144          void syntaxError(String s) {
145              throw new IllegalArgumentException("语法错误: " + s);
146          }
147          void support(char c) {
148              if (!all.contains(c)) {
149                  syntaxError("不支持字符 " + c);
150              }
151          }
152          void supportFollowing(char prev, char c) {
153              if (!following.get(prev).contains(c)) {
154                  syntaxError("prev=" + prev + ", c=" + c);
155              }
156          }
157      }
158  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RibbonTest.java</h3>
            <pre><code>1  package com.netflix.ribbon;
2  import com.google.mockwebserver.MockResponse;
3  import com.google.mockwebserver.MockWebServer;
4  import com.netflix.hystrix.HystrixInvokableInfo;
5  import com.netflix.hystrix.exception.HystrixBadRequestException;
6  import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
7  import com.netflix.ribbon.http.HttpRequestTemplate;
8  import com.netflix.ribbon.http.HttpResourceGroup;
9  import com.netflix.ribbon.hystrix.FallbackHandler;
10  import io.netty.buffer.ByteBuf;
11  import io.netty.buffer.Unpooled;
12  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
13  import org.apache.log4j.Level;
14  import org.apache.log4j.LogManager;
15  import org.junit.BeforeClass;
16  import org.junit.Ignore;
17  import org.junit.Test;
18  import rx.Observable;
19  import rx.functions.Action0;
20  import rx.functions.Action1;
21  import rx.functions.Func1;
22  import java.io.IOException;
23  import java.io.UnsupportedEncodingException;
24  import java.nio.charset.Charset;
25  import java.util.Map;
26  import java.util.concurrent.CountDownLatch;
27  import java.util.concurrent.ExecutionException;
28  import java.util.concurrent.Future;
29  import java.util.concurrent.atomic.AtomicBoolean;
30  import java.util.concurrent.atomic.AtomicReference;
31  import static org.junit.Assert.*;
32  public class RibbonTest {
33      private static String toStringBlocking(RibbonRequest<ByteBuf> request) {
34          return request.toObservable().map(new Func1<ByteBuf, String>() {
35              @Override
36              public String call(ByteBuf t1) {
37                  return t1.toString(Charset.defaultCharset());
38              }
39          }).toBlocking().single();
40      }
41      @BeforeClass
42      public static void init() {
43          LogManager.getRootLogger().setLevel(Level.DEBUG);
44      }
45      @Test
46      public void testCommand() throws IOException, InterruptedException, ExecutionException {
47          MockWebServer server = new MockWebServer();
48          String content = "Hello world";
49          MockResponse response = new MockResponse()
50              .setResponseCode(200)
51              .setHeader("Content-type", "text/plain")
52              .setBody(content);
53          server.enqueue(response);        
54          server.enqueue(response);       
55          server.enqueue(response);       
56          server.play();
57          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient",
58                  ClientOptions.create()
59                  .withMaxAutoRetriesNextServer(3)
60                  .withReadTimeout(300000)
61                  .withConfigurationBasedServerList("localhost:12345, localhost:10092, localhost:" + server.getPort()));
62          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
63                  .withUriTemplate("/")
64                  .withMethod("GET")
65                  .build();
66          RibbonRequest<ByteBuf> request = template.requestBuilder().build();
67          String result = request.execute().toString(Charset.defaultCharset());
68          assertEquals(content, result);
69          ByteBuf raw = request.execute();
70          result = raw.toString(Charset.defaultCharset());
71          raw.release();
72          assertEquals(content, result);
73          result = request.queue().get().toString(Charset.defaultCharset());
74          assertEquals(content, result);
75      }
76      @Test
77      public void testHystrixCache() throws IOException {
78          MockWebServer server = new MockWebServer();
79          String content = "Hello world";
80          MockResponse response = new MockResponse()
81              .setResponseCode(200)
82              .setHeader("Content-type", "text/plain")
83              .setBody(content);
84          server.enqueue(response);
85          server.enqueue(response);       
86          server.play();
87          HttpResourceGroup group = Ribbon.createHttpResourceGroupBuilder("myclient").build();
88          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
89                  .withUriTemplate("http:&bsol;&bsol;localhost:" + server.getPort())
90                  .withMethod("GET")
91                  .withRequestCacheKey("xyz")
92                  .build();
93          RibbonRequest<ByteBuf> request = template
94                  .requestBuilder().build();
95          HystrixRequestContext context = HystrixRequestContext.initializeContext();
96          try {
97              RibbonResponse<ByteBuf> ribbonResponse = request.withMetadata().execute();
98              assertFalse(ribbonResponse.getHystrixInfo().isResponseFromCache());
99              ribbonResponse = request.withMetadata().execute();
100              assertTrue(ribbonResponse.getHystrixInfo().isResponseFromCache());
101          } finally {
102              context.shutdown();
103          }
104      }
105      @Test
106      @Ignore
107      public void testCommandWithMetaData() throws IOException, InterruptedException, ExecutionException {
108          MockWebServer server = new MockWebServer();
109          String content = "Hello world";
110          for (int i = 0; i < 6; i++) {
111              server.enqueue(new MockResponse()
112                  .setResponseCode(200)
113                  .setHeader("Content-type", "text/plain")
114                  .setBody(content));
115          }
116          server.play();
117          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
118                  .withConfigurationBasedServerList("localhost:" + server.getPort())
119                  .withMaxAutoRetriesNextServer(3));
120          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test")
121                  .withUriTemplate("/")
122                  .withMethod("GET")
123                  .withCacheProvider("somekey", new CacheProvider<ByteBuf>(){
124                      @Override
125                      public Observable<ByteBuf> get(String key, Map<String, Object> vars) {
126                          return Observable.error(new Exception("Cache miss"));
127                      }
128                  }).build();
129          RibbonRequest<ByteBuf> request = template
130                  .requestBuilder().build();
131          final AtomicBoolean success = new AtomicBoolean(false);
132          RequestWithMetaData<ByteBuf> metaRequest = request.withMetadata();
133          Observable<String> result = metaRequest.toObservable().flatMap(new Func1<RibbonResponse<Observable<ByteBuf>>, Observable<String>>(){
134              @Override
135              public Observable<String> call(
136                      final RibbonResponse<Observable<ByteBuf>> response) {
137                  success.set(response.getHystrixInfo().isSuccessfulExecution());
138                  return response.content().map(new Func1<ByteBuf, String>(){
139                      @Override
140                      public String call(ByteBuf t1) {
141                          return t1.toString(Charset.defaultCharset());
142                      }
143                  });
144              }
145          });
146          String s = result.toBlocking().single();
147          assertEquals(content, s);
<span onclick='openModal()' class='match'>148          assertTrue(success.get());
149          Future<RibbonResponse<ByteBuf>> future = metaRequest.queue();
150          RibbonResponse<ByteBuf> response = future.get();
151          assertTrue(future.isDone());
152          assertEquals(content, response.content().toString(Charset.defaultCharset()));
153          assertTrue(response.getHystrixInfo().isSuccessfulExecution()); 
</span>154          RibbonResponse<ByteBuf> result1 = metaRequest.execute();
155          assertEquals(content, result1.content().toString(Charset.defaultCharset()));
156          assertTrue(result1.getHystrixInfo().isSuccessfulExecution());
157      }
158      @Test
159      public void testValidator() throws IOException, InterruptedException {
160          MockWebServer server = new MockWebServer();
161          String content = "Hello world";
162          server.enqueue(new MockResponse()
163                  .setResponseCode(200)
164                  .setHeader("Content-type", "text/plain")
165                  .setBody(content));       
166          server.play();
167          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
168                  .withConfigurationBasedServerList("localhost:" + server.getPort()));
169          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
170                  .withUriTemplate("/")
171                  .withMethod("GET")
172                  .withResponseValidator(new ResponseValidator<HttpClientResponse<ByteBuf>>() {
173                      @Override
174                      public void validate(HttpClientResponse<ByteBuf> t1) throws UnsuccessfulResponseException {
175                          throw new UnsuccessfulResponseException("error", new IllegalArgumentException());
176                      }
177                  }).build();
178          RibbonRequest<ByteBuf> request = template.requestBuilder().build();
179          final CountDownLatch latch = new CountDownLatch(1);
180          final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
181          request.toObservable().subscribe(new Action1<ByteBuf>() {
182              @Override
183              public void call(ByteBuf t1) {
184              }
185          }, 
186          new Action1<Throwable>(){
187              @Override
188              public void call(Throwable t1) {
189                  error.set(t1);
190                  latch.countDown();
191              }
192          }, 
193          new Action0() {
194              @Override
195              public void call() {
196              }
197          });
198          latch.await();
199          assertTrue(error.get() instanceof HystrixBadRequestException);
200          assertTrue(error.get().getCause() instanceof UnsuccessfulResponseException);
201      }
202      @Test
203      public void testFallback() throws IOException {
204          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
205                  .withConfigurationBasedServerList("localhost:12345")
206                  .withMaxAutoRetriesNextServer(1));
207          final String fallback = "fallback";
208          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
209                  .withUriTemplate("/")
210                  .withMethod("GET")
211                  .withFallbackProvider(new FallbackHandler<ByteBuf>() {
212                      @Override
213                      public Observable<ByteBuf> getFallback(
214                              HystrixInvokableInfo<?> hystrixInfo,
215                              Map<String, Object> requestProperties) {
216                          try {
217                              return Observable.just(Unpooled.buffer().writeBytes(fallback.getBytes("UTF-8")));
218                          } catch (UnsupportedEncodingException e) {
219                              return Observable.error(e);
220                          }
221                      }
222                  }).build();
223          RibbonRequest<ByteBuf> request = template
224                  .requestBuilder().build();
225          final AtomicReference<HystrixInvokableInfo<?>> hystrixInfo = new AtomicReference<HystrixInvokableInfo<?>>();
226          final AtomicBoolean failed = new AtomicBoolean(false);
227          Observable<String> result = request.withMetadata().toObservable().flatMap(new Func1<RibbonResponse<Observable<ByteBuf>>, Observable<String>>(){
228              @Override
229              public Observable<String> call(
230                      final RibbonResponse<Observable<ByteBuf>> response) {
231                  hystrixInfo.set(response.getHystrixInfo());
232                  failed.set(response.getHystrixInfo().isFailedExecution());
233                  return response.content().map(new Func1<ByteBuf, String>(){
234                      @Override
235                      public String call(ByteBuf t1) {
236                          return t1.toString(Charset.defaultCharset());
237                      }
238                  });
239              }
240          });
241          String s = result.toBlocking().single();
242          assertTrue(hystrixInfo.get().isResponseFromFallback());
243          assertTrue(failed.get());
244          assertEquals(fallback, s);
245      }
246      @Test
247      public void testCacheHit() {
248          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
249                  .withConfigurationBasedServerList("localhost:12345")
250                  .withMaxAutoRetriesNextServer(1));
251          final String content = "from cache";
252          final String cacheKey = "somekey";
253          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test")
254          .withCacheProvider(cacheKey, new CacheProvider<ByteBuf>(){
255              @Override
256              public Observable<ByteBuf> get(String key, Map<String, Object> vars) {
257                  if (key.equals(cacheKey)) {
258                      try {
259                          return Observable.just(Unpooled.buffer().writeBytes(content.getBytes("UTF-8")));
260                      } catch (UnsupportedEncodingException e) {
261                          return Observable.error(e);
262                      }
263                  } else {
264                      return Observable.error(new Exception("Cache miss"));
265                  }
266              }
267          }).withUriTemplate("/")
268                  .withMethod("GET").build();
269          RibbonRequest<ByteBuf> request = template
270                  .requestBuilder().build();
271          String result = request.execute().toString(Charset.defaultCharset());
272          assertEquals(content, result);
273      }
274      @Test
275      public void testObserve() throws IOException, InterruptedException {
276          MockWebServer server = new MockWebServer();
277          String content = "Hello world";
278          server.enqueue(new MockResponse()
279                  .setResponseCode(200)
280                  .setHeader("Content-type", "text/plain")
281                  .setBody(content));       
282          server.enqueue(new MockResponse()
283                  .setResponseCode(200)
284                  .setHeader("Content-type", "text/plain")
285                  .setBody(content));       
286          server.play();
287          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient",
288                  ClientOptions.create()
289                  .withMaxAutoRetriesNextServer(3)
290                  .withReadTimeout(300000)
291                  .withConfigurationBasedServerList("localhost:12345, localhost:10092, localhost:" + server.getPort()));
292          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test", ByteBuf.class)
293                  .withUriTemplate("/")
294                  .withMethod("GET").build();
295          RibbonRequest<ByteBuf> request = template
296                  .requestBuilder().build();
297          Observable<ByteBuf> result = request.observe();
298          final CountDownLatch latch = new CountDownLatch(1);
299          final AtomicReference<String> fromCommand = new AtomicReference<String>();
300          result.toBlocking().last();
301          result.subscribe(new Action1<ByteBuf>() {
302              @Override
303              public void call(ByteBuf t1) {
304                  try {
305                      fromCommand.set(t1.toString(Charset.defaultCharset()));
306                  } catch (Exception e) {
307                      e.printStackTrace();
308                  }
309                  latch.countDown();
310              }
311          });
312          latch.await();
313          assertEquals(content, fromCommand.get());
314          Observable<RibbonResponse<Observable<ByteBuf>>> metaResult = request.withMetadata().observe();
315          String result2 = "";
316          metaResult.toBlocking().last();
317          result2 = metaResult.flatMap(new Func1<RibbonResponse<Observable<ByteBuf>>, Observable<ByteBuf>>(){
318              @Override
319              public Observable<ByteBuf> call(
320                      RibbonResponse<Observable<ByteBuf>> t1) {
321                  return t1.content();
322              }
323          }).map(new Func1<ByteBuf, String>(){
324              @Override
325              public String call(ByteBuf t1) {
326                  return t1.toString(Charset.defaultCharset());
327              }
328          }).toBlocking().single();
329          assertEquals(content, result2);
330      }
331      @Test
332      public void testCacheMiss() throws IOException, InterruptedException {
333          MockWebServer server = new MockWebServer();
334          String content = "Hello world";
335          server.enqueue(new MockResponse()
336                  .setResponseCode(200)
337                  .setHeader("Content-type", "text/plain")
338                  .setBody(content));       
339          server.play();
340          HttpResourceGroup group = Ribbon.createHttpResourceGroup("myclient", ClientOptions.create()
341                  .withConfigurationBasedServerList("localhost:" + server.getPort())
342                  .withMaxAutoRetriesNextServer(1));
343          final String cacheKey = "somekey";
344          HttpRequestTemplate<ByteBuf> template = group.newTemplateBuilder("test")
345                  .withCacheProvider(cacheKey, new CacheProvider<ByteBuf>(){
346                      @Override
347                      public Observable<ByteBuf> get(String key, Map<String, Object> vars) {
348                          return Observable.error(new Exception("Cache miss again"));
349                      }
350                  })
351                  .withMethod("GET")
352                  .withUriTemplate("/").build();
353          RibbonRequest<ByteBuf> request = template
354                  .requestBuilder().build();
355          String result = toStringBlocking(request);
356          assertEquals(content, result);
357      } 
358  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-RpcCommandUtil.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RibbonTest.java</div>
                </div>
                <div class="column column_space"><pre><code>38          Pattern pattern = Pattern.compile("[a-zA-Z0-9_$.*]+");
39          Set<Character> all = ImmutableSet.of('(', ')', '0', '1', '!', '&', '|');
40          Map<Character, ImmutableSet<Character>> following = ImmutableMap.<Character, ImmutableSet<Character>>builder()
41                  .put('(', ImmutableSet.of('0', '1', '!')).put(')', ImmutableSet.of('|', '&', ')')).put('0', ImmutableSet.of('|', '&', ')'))
</pre></code></div>
                <div class="column column_space"><pre><code>148          assertTrue(success.get());
149          Future<RibbonResponse<ByteBuf>> future = metaRequest.queue();
150          RibbonResponse<ByteBuf> response = future.get();
151          assertTrue(future.isDone());
152          assertEquals(content, response.content().toString(Charset.defaultCharset()));
153          assertTrue(response.getHystrixInfo().isSuccessfulExecution()); 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    