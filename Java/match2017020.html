<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Sets.java &amp; Murmur3Hash32Test_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Sets.java &amp; Murmur3Hash32Test_1.java
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Sets.java (0.9532456%)<th>Murmur3Hash32Test_1.java (5.982906%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1390-1398)<td><a href="#" name="0">(98-105)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1214-1217)<td><a href="#" name="1">(151-154)</a><td align="center"><font color="#bf0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Sets.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
5 import com.google.common.annotations.Beta;
6 import com.google.common.annotations.GwtCompatible;
7 import com.google.common.annotations.GwtIncompatible;
8 import com.google.common.base.Predicate;
9 import com.google.common.base.Predicates;
10 import com.google.common.collect.Collections2.FilteredCollection;
11 import com.google.common.math.IntMath;
12 import com.google.errorprone.annotations.CanIgnoreReturnValue;
13 import com.google.errorprone.annotations.DoNotCall;
14 import java.io.Serializable;
15 import java.util.AbstractSet;
16 import java.util.Arrays;
17 import java.util.BitSet;
18 import java.util.Collection;
19 import java.util.Collections;
20 import java.util.Comparator;
21 import java.util.EnumSet;
22 import java.util.HashSet;
23 import java.util.Iterator;
24 import java.util.LinkedHashSet;
25 import java.util.List;
26 import java.util.Map;
27 import java.util.NavigableSet;
28 import java.util.NoSuchElementException;
29 import java.util.Set;
30 import java.util.SortedSet;
31 import java.util.TreeSet;
32 import java.util.concurrent.ConcurrentHashMap;
33 import java.util.concurrent.CopyOnWriteArraySet;
34 import javax.annotation.CheckForNull;
35 import org.checkerframework.checker.nullness.qual.Nullable;
36 @GwtCompatible(emulated = true)
37 @ElementTypesAreNonnullByDefault
38 public final class Sets {
39   private Sets() {}
40   abstract static class ImprovedAbstractSet&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
41     @Override
42     public boolean removeAll(Collection&lt;?&gt; c) {
43       return removeAllImpl(this, c);
44     }
45     @Override
46     public boolean retainAll(Collection&lt;?&gt; c) {
47       return super.retainAll(checkNotNull(c));     }
48   }
49   @GwtCompatible(serializable = true)
50   public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(
51       E anElement, E... otherElements) {
52     return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements));
53   }
54   @GwtCompatible(serializable = true)
55   public static &lt;E extends Enum&lt;E&gt;&gt; ImmutableSet&lt;E&gt; immutableEnumSet(Iterable&lt;E&gt; elements) {
56     if (elements instanceof ImmutableEnumSet) {
57       return (ImmutableEnumSet&lt;E&gt;) elements;
58     } else if (elements instanceof Collection) {
59       Collection&lt;E&gt; collection = (Collection&lt;E&gt;) elements;
60       if (collection.isEmpty()) {
61         return ImmutableSet.of();
62       } else {
63         return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));
64       }
65     } else {
66       Iterator&lt;E&gt; itr = elements.iterator();
67       if (itr.hasNext()) {
68         EnumSet&lt;E&gt; enumSet = EnumSet.of(itr.next());
69         Iterators.addAll(enumSet, itr);
70         return ImmutableEnumSet.asImmutable(enumSet);
71       } else {
72         return ImmutableSet.of();
73       }
74     }
75   }
76   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; newEnumSet(
77       Iterable&lt;E&gt; iterable, Class&lt;E&gt; elementType) {
78     EnumSet&lt;E&gt; set = EnumSet.noneOf(elementType);
79     Iterables.addAll(set, iterable);
80     return set;
81   }
82   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet() {
83     return new HashSet&lt;E&gt;();
84   }
85   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(E... elements) {
86     HashSet&lt;E&gt; set = newHashSetWithExpectedSize(elements.length);
87     Collections.addAll(set, elements);
88     return set;
89   }
90   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterable&lt;? extends E&gt; elements) {
91     return (elements instanceof Collection)
92         ? new HashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements)
93         : newHashSet(elements.iterator());
94   }
95   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSet(Iterator&lt;? extends E&gt; elements) {
96     HashSet&lt;E&gt; set = newHashSet();
97     Iterators.addAll(set, elements);
98     return set;
99   }
100   public static &lt;E extends @Nullable Object&gt; HashSet&lt;E&gt; newHashSetWithExpectedSize(
101       int expectedSize) {
102     return new HashSet&lt;E&gt;(Maps.capacity(expectedSize));
103   }
104   public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet() {
105     return Collections.newSetFromMap(new ConcurrentHashMap&lt;E, Boolean&gt;());
106   }
107   public static &lt;E&gt; Set&lt;E&gt; newConcurrentHashSet(Iterable&lt;? extends E&gt; elements) {
108     Set&lt;E&gt; set = newConcurrentHashSet();
109     Iterables.addAll(set, elements);
110     return set;
111   }
112   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet() {
113     return new LinkedHashSet&lt;E&gt;();
114   }
115   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSet(
116       Iterable&lt;? extends E&gt; elements) {
117     if (elements instanceof Collection) {
118       return new LinkedHashSet&lt;E&gt;((Collection&lt;? extends E&gt;) elements);
119     }
120     LinkedHashSet&lt;E&gt; set = newLinkedHashSet();
121     Iterables.addAll(set, elements);
122     return set;
123   }
124   public static &lt;E extends @Nullable Object&gt; LinkedHashSet&lt;E&gt; newLinkedHashSetWithExpectedSize(
125       int expectedSize) {
126     return new LinkedHashSet&lt;E&gt;(Maps.capacity(expectedSize));
127   }
128   public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet() {
129     return new TreeSet&lt;E&gt;();
130   }
131   public static &lt;E extends Comparable&gt; TreeSet&lt;E&gt; newTreeSet(Iterable&lt;? extends E&gt; elements) {
132     TreeSet&lt;E&gt; set = newTreeSet();
133     Iterables.addAll(set, elements);
134     return set;
135   }
136   public static &lt;E extends @Nullable Object&gt; TreeSet&lt;E&gt; newTreeSet(
137       Comparator&lt;? super E&gt; comparator) {
138     return new TreeSet&lt;E&gt;(checkNotNull(comparator));
139   }
140   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newIdentityHashSet() {
141     return Collections.newSetFromMap(Maps.&lt;E, Boolean&gt;newIdentityHashMap());
142   }
143   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet() {
144     return new CopyOnWriteArraySet&lt;E&gt;();
145   }
146   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; CopyOnWriteArraySet&lt;E&gt; newCopyOnWriteArraySet(
147       Iterable&lt;? extends E&gt; elements) {
148     Collection&lt;? extends E&gt; elementsCollection =
149         (elements instanceof Collection)
150             ? (Collection&lt;? extends E&gt;) elements
151             : Lists.newArrayList(elements);
152     return new CopyOnWriteArraySet&lt;E&gt;(elementsCollection);
153   }
154   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(Collection&lt;E&gt; collection) {
155     if (collection instanceof EnumSet) {
156       return EnumSet.complementOf((EnumSet&lt;E&gt;) collection);
157     }
158     checkArgument(
159         !collection.isEmpty(), "collection is empty; use the other version of this method");
160     Class&lt;E&gt; type = collection.iterator().next().getDeclaringClass();
161     return makeComplementByHand(collection, type);
162   }
163   public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(
164       Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
165     checkNotNull(collection);
166     return (collection instanceof EnumSet)
167         ? EnumSet.complementOf((EnumSet&lt;E&gt;) collection)
168         : makeComplementByHand(collection, type);
169   }
170   private static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; makeComplementByHand(
171       Collection&lt;E&gt; collection, Class&lt;E&gt; type) {
172     EnumSet&lt;E&gt; result = EnumSet.allOf(type);
173     result.removeAll(collection);
174     return result;
175   }
176   @Deprecated
177   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; newSetFromMap(
178       Map&lt;E, Boolean&gt; map) {
179     return Collections.newSetFromMap(map);
180   }
181   public abstract static class SetView&lt;E extends @Nullable Object&gt; extends AbstractSet&lt;E&gt; {
182     private SetView() {} 
183     @SuppressWarnings("nullness")     public ImmutableSet&lt;E&gt; immutableCopy() {
184       return ImmutableSet.copyOf(this);
185     }
186     @CanIgnoreReturnValue
187     public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
188       set.addAll(this);
189       return set;
190     }
191     @CanIgnoreReturnValue
192     @Deprecated
193     @Override
194     @DoNotCall("Always throws UnsupportedOperationException")
195     public final boolean add(@ParametricNullness E e) {
196       throw new UnsupportedOperationException();
197     }
198     @CanIgnoreReturnValue
199     @Deprecated
200     @Override
201     @DoNotCall("Always throws UnsupportedOperationException")
202     public final boolean remove(@CheckForNull Object object) {
203       throw new UnsupportedOperationException();
204     }
205     @CanIgnoreReturnValue
206     @Deprecated
207     @Override
208     @DoNotCall("Always throws UnsupportedOperationException")
209     public final boolean addAll(Collection&lt;? extends E&gt; newElements) {
210       throw new UnsupportedOperationException();
211     }
212     @CanIgnoreReturnValue
213     @Deprecated
214     @Override
215     @DoNotCall("Always throws UnsupportedOperationException")
216     public final boolean removeAll(Collection&lt;?&gt; oldElements) {
217       throw new UnsupportedOperationException();
218     }
219     @CanIgnoreReturnValue
220     @Deprecated
221     @Override
222     @DoNotCall("Always throws UnsupportedOperationException")
223     public final boolean retainAll(Collection&lt;?&gt; elementsToKeep) {
224       throw new UnsupportedOperationException();
225     }
226     @Deprecated
227     @Override
228     @DoNotCall("Always throws UnsupportedOperationException")
229     public final void clear() {
230       throw new UnsupportedOperationException();
231     }
232     @Override
233     public abstract UnmodifiableIterator&lt;E&gt; iterator();
234   }
235   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; union(
236       final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
237     checkNotNull(set1, "set1");
238     checkNotNull(set2, "set2");
239     return new SetView&lt;E&gt;() {
240       @Override
241       public int size() {
242         int size = set1.size();
243         for (E e : set2) {
244           if (!set1.contains(e)) {
245             size++;
246           }
247         }
248         return size;
249       }
250       @Override
251       public boolean isEmpty() {
252         return set1.isEmpty() &amp;&amp; set2.isEmpty();
253       }
254       @Override
255       public UnmodifiableIterator&lt;E&gt; iterator() {
256         return new AbstractIterator&lt;E&gt;() {
257           final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
258           final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
259           @Override
260           @CheckForNull
261           protected E computeNext() {
262             if (itr1.hasNext()) {
263               return itr1.next();
264             }
265             while (itr2.hasNext()) {
266               E e = itr2.next();
267               if (!set1.contains(e)) {
268                 return e;
269               }
270             }
271             return endOfData();
272           }
273         };
274       }
275       @Override
276       public boolean contains(@CheckForNull Object object) {
277         return set1.contains(object) || set2.contains(object);
278       }
279       @Override
280       public &lt;S extends Set&lt;E&gt;&gt; S copyInto(S set) {
281         set.addAll(set1);
282         set.addAll(set2);
283         return set;
284       }
285       @Override
286       @SuppressWarnings("nullness")       public ImmutableSet&lt;E&gt; immutableCopy() {
287         return new ImmutableSet.Builder&lt;E&gt;().addAll(set1).addAll(set2).build();
288       }
289     };
290   }
291   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; intersection(
292       final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
293     checkNotNull(set1, "set1");
294     checkNotNull(set2, "set2");
295     return new SetView&lt;E&gt;() {
296       @Override
297       public UnmodifiableIterator&lt;E&gt; iterator() {
298         return new AbstractIterator&lt;E&gt;() {
299           final Iterator&lt;E&gt; itr = set1.iterator();
300           @Override
301           @CheckForNull
302           protected E computeNext() {
303             while (itr.hasNext()) {
304               E e = itr.next();
305               if (set2.contains(e)) {
306                 return e;
307               }
308             }
309             return endOfData();
310           }
311         };
312       }
313       @Override
314       public int size() {
315         int size = 0;
316         for (E e : set1) {
317           if (set2.contains(e)) {
318             size++;
319           }
320         }
321         return size;
322       }
323       @Override
324       public boolean isEmpty() {
325         return Collections.disjoint(set2, set1);
326       }
327       @Override
328       public boolean contains(@CheckForNull Object object) {
329         return set1.contains(object) &amp;&amp; set2.contains(object);
330       }
331       @Override
332       public boolean containsAll(Collection&lt;?&gt; collection) {
333         return set1.containsAll(collection) &amp;&amp; set2.containsAll(collection);
334       }
335     };
336   }
337   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; difference(
338       final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) {
339     checkNotNull(set1, "set1");
340     checkNotNull(set2, "set2");
341     return new SetView&lt;E&gt;() {
342       @Override
343       public UnmodifiableIterator&lt;E&gt; iterator() {
344         return new AbstractIterator&lt;E&gt;() {
345           final Iterator&lt;E&gt; itr = set1.iterator();
346           @Override
347           @CheckForNull
348           protected E computeNext() {
349             while (itr.hasNext()) {
350               E e = itr.next();
351               if (!set2.contains(e)) {
352                 return e;
353               }
354             }
355             return endOfData();
356           }
357         };
358       }
359       @Override
360       public int size() {
361         int size = 0;
362         for (E e : set1) {
363           if (!set2.contains(e)) {
364             size++;
365           }
366         }
367         return size;
368       }
369       @Override
370       public boolean isEmpty() {
371         return set2.containsAll(set1);
372       }
373       @Override
374       public boolean contains(@CheckForNull Object element) {
375         return set1.contains(element) &amp;&amp; !set2.contains(element);
376       }
377     };
378   }
379   public static &lt;E extends @Nullable Object&gt; SetView&lt;E&gt; symmetricDifference(
380       final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) {
381     checkNotNull(set1, "set1");
382     checkNotNull(set2, "set2");
383     return new SetView&lt;E&gt;() {
384       @Override
385       public UnmodifiableIterator&lt;E&gt; iterator() {
386         final Iterator&lt;? extends E&gt; itr1 = set1.iterator();
387         final Iterator&lt;? extends E&gt; itr2 = set2.iterator();
388         return new AbstractIterator&lt;E&gt;() {
389           @Override
390           @CheckForNull
391           public E computeNext() {
392             while (itr1.hasNext()) {
393               E elem1 = itr1.next();
394               if (!set2.contains(elem1)) {
395                 return elem1;
396               }
397             }
398             while (itr2.hasNext()) {
399               E elem2 = itr2.next();
400               if (!set1.contains(elem2)) {
401                 return elem2;
402               }
403             }
404             return endOfData();
405           }
406         };
407       }
408       @Override
409       public int size() {
410         int size = 0;
411         for (E e : set1) {
412           if (!set2.contains(e)) {
413             size++;
414           }
415         }
416         for (E e : set2) {
417           if (!set1.contains(e)) {
418             size++;
419           }
420         }
421         return size;
422       }
423       @Override
424       public boolean isEmpty() {
425         return set1.equals(set2);
426       }
427       @Override
428       public boolean contains(@CheckForNull Object element) {
429         return set1.contains(element) ^ set2.contains(element);
430       }
431     };
432   }
433   public static &lt;E extends @Nullable Object&gt; Set&lt;E&gt; filter(
434       Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
435     if (unfiltered instanceof SortedSet) {
436       return filter((SortedSet&lt;E&gt;) unfiltered, predicate);
437     }
438     if (unfiltered instanceof FilteredSet) {
439       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
440       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
441       return new FilteredSet&lt;E&gt;((Set&lt;E&gt;) filtered.unfiltered, combinedPredicate);
442     }
443     return new FilteredSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
444   }
445   public static &lt;E extends @Nullable Object&gt; SortedSet&lt;E&gt; filter(
446       SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
447     if (unfiltered instanceof FilteredSet) {
448       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
449       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
450       return new FilteredSortedSet&lt;E&gt;((SortedSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
451     }
452     return new FilteredSortedSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
453   }
454   @GwtIncompatible   @SuppressWarnings("unchecked")
455   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; filter(
456       NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
457     if (unfiltered instanceof FilteredSet) {
458       FilteredSet&lt;E&gt; filtered = (FilteredSet&lt;E&gt;) unfiltered;
459       Predicate&lt;E&gt; combinedPredicate = Predicates.&lt;E&gt;and(filtered.predicate, predicate);
460       return new FilteredNavigableSet&lt;E&gt;((NavigableSet&lt;E&gt;) filtered.unfiltered, combinedPredicate);
461     }
462     return new FilteredNavigableSet&lt;E&gt;(checkNotNull(unfiltered), checkNotNull(predicate));
463   }
464   private static class FilteredSet&lt;E extends @Nullable Object&gt; extends FilteredCollection&lt;E&gt;
465       implements Set&lt;E&gt; {
466     FilteredSet(Set&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
467       super(unfiltered, predicate);
468     }
469     @Override
470     public boolean equals(@CheckForNull Object object) {
471       return equalsImpl(this, object);
472     }
473     @Override
474     public int hashCode() {
475       return hashCodeImpl(this);
476     }
477   }
478   private static class FilteredSortedSet&lt;E extends @Nullable Object&gt; extends FilteredSet&lt;E&gt;
479       implements SortedSet&lt;E&gt; {
480     FilteredSortedSet(SortedSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
481       super(unfiltered, predicate);
482     }
483     @Override
484     @CheckForNull
485     public Comparator&lt;? super E&gt; comparator() {
486       return ((SortedSet&lt;E&gt;) unfiltered).comparator();
487     }
488     @Override
489     public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
490       return new FilteredSortedSet&lt;E&gt;(
491           ((SortedSet&lt;E&gt;) unfiltered).subSet(fromElement, toElement), predicate);
492     }
493     @Override
494     public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
495       return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).headSet(toElement), predicate);
496     }
497     @Override
498     public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
499       return new FilteredSortedSet&lt;E&gt;(((SortedSet&lt;E&gt;) unfiltered).tailSet(fromElement), predicate);
500     }
501     @Override
502     @ParametricNullness
503     public E first() {
504       return Iterators.find(unfiltered.iterator(), predicate);
505     }
506     @Override
507     @ParametricNullness
508     public E last() {
509       SortedSet&lt;E&gt; sortedUnfiltered = (SortedSet&lt;E&gt;) unfiltered;
510       while (true) {
511         E element = sortedUnfiltered.last();
512         if (predicate.apply(element)) {
513           return element;
514         }
515         sortedUnfiltered = sortedUnfiltered.headSet(element);
516       }
517     }
518   }
519   @GwtIncompatible   private static class FilteredNavigableSet&lt;E extends @Nullable Object&gt; extends FilteredSortedSet&lt;E&gt;
520       implements NavigableSet&lt;E&gt; {
521     FilteredNavigableSet(NavigableSet&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) {
522       super(unfiltered, predicate);
523     }
524     NavigableSet&lt;E&gt; unfiltered() {
525       return (NavigableSet&lt;E&gt;) unfiltered;
526     }
527     @Override
528     @CheckForNull
529     public E lower(@ParametricNullness E e) {
530       return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);
531     }
532     @Override
533     @CheckForNull
534     public E floor(@ParametricNullness E e) {
535       return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);
536     }
537     @Override
538     @CheckForNull
539     public E ceiling(@ParametricNullness E e) {
540       return Iterables.find(unfiltered().tailSet(e, true), predicate, null);
541     }
542     @Override
543     @CheckForNull
544     public E higher(@ParametricNullness E e) {
545       return Iterables.find(unfiltered().tailSet(e, false), predicate, null);
546     }
547     @Override
548     @CheckForNull
549     public E pollFirst() {
550       return Iterables.removeFirstMatching(unfiltered(), predicate);
551     }
552     @Override
553     @CheckForNull
554     public E pollLast() {
555       return Iterables.removeFirstMatching(unfiltered().descendingSet(), predicate);
556     }
557     @Override
558     public NavigableSet&lt;E&gt; descendingSet() {
559       return Sets.filter(unfiltered().descendingSet(), predicate);
560     }
561     @Override
562     public Iterator&lt;E&gt; descendingIterator() {
563       return Iterators.filter(unfiltered().descendingIterator(), predicate);
564     }
565     @Override
566     @ParametricNullness
567     public E last() {
568       return Iterators.find(unfiltered().descendingIterator(), predicate);
569     }
570     @Override
571     public NavigableSet&lt;E&gt; subSet(
572         @ParametricNullness E fromElement,
573         boolean fromInclusive,
574         @ParametricNullness E toElement,
575         boolean toInclusive) {
576       return filter(
577           unfiltered().subSet(fromElement, fromInclusive, toElement, toInclusive), predicate);
578     }
579     @Override
580     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
581       return filter(unfiltered().headSet(toElement, inclusive), predicate);
582 <a name="1"></a>    }
583     @Override
584     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>boolean inclusive) {
585       return filter(unfiltered().tailSet(fromElement, inclusive), predicate);
586     }
587   }</b></font>
588   public static &lt;B&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(List&lt;? extends Set&lt;? extends B&gt;&gt; sets) {
589     return CartesianSet.create(sets);
590   }
591   @SafeVarargs
592   public static &lt;B&gt; Set&lt;List&lt;B&gt;&gt; cartesianProduct(Set&lt;? extends B&gt;... sets) {
593     return cartesianProduct(Arrays.asList(sets));
594   }
595   private static final class CartesianSet&lt;E&gt; extends ForwardingCollection&lt;List&lt;E&gt;&gt;
596       implements Set&lt;List&lt;E&gt;&gt; {
597     private final transient ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes;
598     private final transient CartesianList&lt;E&gt; delegate;
599     static &lt;E&gt; Set&lt;List&lt;E&gt;&gt; create(List&lt;? extends Set&lt;? extends E&gt;&gt; sets) {
600       ImmutableList.Builder&lt;ImmutableSet&lt;E&gt;&gt; axesBuilder = new ImmutableList.Builder&lt;&gt;(sets.size());
601       for (Set&lt;? extends E&gt; set : sets) {
602         ImmutableSet&lt;E&gt; copy = ImmutableSet.copyOf(set);
603         if (copy.isEmpty()) {
604           return ImmutableSet.of();
605         }
606         axesBuilder.add(copy);
607       }
608       final ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes = axesBuilder.build();
609       ImmutableList&lt;List&lt;E&gt;&gt; listAxes =
610           new ImmutableList&lt;List&lt;E&gt;&gt;() {
611             @Override
612             public int size() {
613               return axes.size();
614             }
615             @Override
616             public List&lt;E&gt; get(int index) {
617               return axes.get(index).asList();
618             }
619             @Override
620             boolean isPartialView() {
621               return true;
622             }
623           };
624       return new CartesianSet&lt;E&gt;(axes, new CartesianList&lt;E&gt;(listAxes));
625     }
626     private CartesianSet(ImmutableList&lt;ImmutableSet&lt;E&gt;&gt; axes, CartesianList&lt;E&gt; delegate) {
627       this.axes = axes;
628       this.delegate = delegate;
629     }
630     @Override
631     protected Collection&lt;List&lt;E&gt;&gt; delegate() {
632       return delegate;
633     }
634     @Override
635     public boolean contains(@CheckForNull Object object) {
636       if (!(object instanceof List)) {
637         return false;
638       }
639       List&lt;?&gt; list = (List&lt;?&gt;) object;
640       if (list.size() != axes.size()) {
641         return false;
642 <a name="0"></a>      }
643       int i = 0;
644       for (Object o : list) {
645         if (!<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>axes.get(i).contains(o)) {
646           return false;
647         }
648         i++;
649       }
650       return true;
651     }
652     @</b></font>Override
653     public boolean equals(@CheckForNull Object object) {
654       if (object instanceof CartesianSet) {
655         CartesianSet&lt;?&gt; that = (CartesianSet&lt;?&gt;) object;
656         return this.axes.equals(that.axes);
657       }
658       return super.equals(object);
659     }
660     @Override
661     public int hashCode() {
662       int adjust = size() - 1;
663       for (int i = 0; i &lt; axes.size(); i++) {
664         adjust *= 31;
665         adjust = ~~adjust;
666       }
667       int hash = 1;
668       for (Set&lt;E&gt; axis : axes) {
669         hash = 31 * hash + (size() / axis.size() * axis.hashCode());
670         hash = ~~hash;
671       }
672       hash += adjust;
673       return ~~hash;
674     }
675   }
676   @GwtCompatible(serializable = false)
677   public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; powerSet(Set&lt;E&gt; set) {
678     return new PowerSet&lt;E&gt;(set);
679   }
680   private static final class SubSet&lt;E&gt; extends AbstractSet&lt;E&gt; {
681     private final ImmutableMap&lt;E, Integer&gt; inputSet;
682     private final int mask;
683     SubSet(ImmutableMap&lt;E, Integer&gt; inputSet, int mask) {
684       this.inputSet = inputSet;
685       this.mask = mask;
686     }
687     @Override
688     public Iterator&lt;E&gt; iterator() {
689       return new UnmodifiableIterator&lt;E&gt;() {
690         final ImmutableList&lt;E&gt; elements = inputSet.keySet().asList();
691         int remainingSetBits = mask;
692         @Override
693         public boolean hasNext() {
694           return remainingSetBits != 0;
695         }
696         @Override
697         public E next() {
698           int index = Integer.numberOfTrailingZeros(remainingSetBits);
699           if (index == 32) {
700             throw new NoSuchElementException();
701           }
702           remainingSetBits &amp;= ~(1 &lt;&lt; index);
703           return elements.get(index);
704         }
705       };
706     }
707     @Override
708     public int size() {
709       return Integer.bitCount(mask);
710     }
711     @Override
712     public boolean contains(@CheckForNull Object o) {
713       Integer index = inputSet.get(o);
714       return index != null &amp;&amp; (mask &amp; (1 &lt;&lt; index)) != 0;
715     }
716   }
717   private static final class PowerSet&lt;E&gt; extends AbstractSet&lt;Set&lt;E&gt;&gt; {
718     final ImmutableMap&lt;E, Integer&gt; inputSet;
719     PowerSet(Set&lt;E&gt; input) {
720       checkArgument(
721           input.size() &lt;= 30, "Too many elements to create power set: %s &gt; 30", input.size());
722       this.inputSet = Maps.indexMap(input);
723     }
724     @Override
725     public int size() {
726       return 1 &lt;&lt; inputSet.size();
727     }
728     @Override
729     public boolean isEmpty() {
730       return false;
731     }
732     @Override
733     public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
734       return new AbstractIndexedListIterator&lt;Set&lt;E&gt;&gt;(size()) {
735         @Override
736         protected Set&lt;E&gt; get(final int setBits) {
737           return new SubSet&lt;E&gt;(inputSet, setBits);
738         }
739       };
740     }
741     @Override
742     public boolean contains(@CheckForNull Object obj) {
743       if (obj instanceof Set) {
744         Set&lt;?&gt; set = (Set&lt;?&gt;) obj;
745         return inputSet.keySet().containsAll(set);
746       }
747       return false;
748     }
749     @Override
750     public boolean equals(@CheckForNull Object obj) {
751       if (obj instanceof PowerSet) {
752         PowerSet&lt;?&gt; that = (PowerSet&lt;?&gt;) obj;
753         return inputSet.keySet().equals(that.inputSet.keySet());
754       }
755       return super.equals(obj);
756     }
757     @Override
758     public int hashCode() {
759       return inputSet.keySet().hashCode() &lt;&lt; (inputSet.size() - 1);
760     }
761     @Override
762     public String toString() {
763       return "powerSet(" + inputSet + ")";
764     }
765   }
766   @Beta
767   public static &lt;E&gt; Set&lt;Set&lt;E&gt;&gt; combinations(Set&lt;E&gt; set, final int size) {
768     final ImmutableMap&lt;E, Integer&gt; index = Maps.indexMap(set);
769     checkNonnegative(size, "size");
770     checkArgument(size &lt;= index.size(), "size (%s) must be &lt;= set.size() (%s)", size, index.size());
771     if (size == 0) {
772       return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(ImmutableSet.&lt;E&gt;of());
773     } else if (size == index.size()) {
774       return ImmutableSet.&lt;Set&lt;E&gt;&gt;of(index.keySet());
775     }
776     return new AbstractSet&lt;Set&lt;E&gt;&gt;() {
777       @Override
778       public boolean contains(@CheckForNull Object o) {
779         if (o instanceof Set) {
780           Set&lt;?&gt; s = (Set&lt;?&gt;) o;
781           return s.size() == size &amp;&amp; index.keySet().containsAll(s);
782         }
783         return false;
784       }
785       @Override
786       public Iterator&lt;Set&lt;E&gt;&gt; iterator() {
787         return new AbstractIterator&lt;Set&lt;E&gt;&gt;() {
788           final BitSet bits = new BitSet(index.size());
789           @Override
790           @CheckForNull
791           protected Set&lt;E&gt; computeNext() {
792             if (bits.isEmpty()) {
793               bits.set(0, size);
794             } else {
795               int firstSetBit = bits.nextSetBit(0);
796               int bitToFlip = bits.nextClearBit(firstSetBit);
797               if (bitToFlip == index.size()) {
798                 return endOfData();
799               }
800               bits.set(0, bitToFlip - firstSetBit - 1);
801               bits.clear(bitToFlip - firstSetBit - 1, bitToFlip);
802               bits.set(bitToFlip);
803             }
804             final BitSet copy = (BitSet) bits.clone();
805             return new AbstractSet&lt;E&gt;() {
806               @Override
807               public boolean contains(@CheckForNull Object o) {
808                 Integer i = index.get(o);
809                 return i != null &amp;&amp; copy.get(i);
810               }
811               @Override
812               public Iterator&lt;E&gt; iterator() {
813                 return new AbstractIterator&lt;E&gt;() {
814                   int i = -1;
815                   @Override
816                   @CheckForNull
817                   protected E computeNext() {
818                     i = copy.nextSetBit(i + 1);
819                     if (i == -1) {
820                       return endOfData();
821                     }
822                     return index.keySet().asList().get(i);
823                   }
824                 };
825               }
826               @Override
827               public int size() {
828                 return size;
829               }
830             };
831           }
832         };
833       }
834       @Override
835       public int size() {
836         return IntMath.binomial(index.size(), size);
837       }
838       @Override
839       public String toString() {
840         return "Sets.combinations(" + index.keySet() + ", " + size + ")";
841       }
842     };
843   }
844   static int hashCodeImpl(Set&lt;?&gt; s) {
845     int hashCode = 0;
846     for (Object o : s) {
847       hashCode += o != null ? o.hashCode() : 0;
848       hashCode = ~~hashCode;
849     }
850     return hashCode;
851   }
852   static boolean equalsImpl(Set&lt;?&gt; s, @CheckForNull Object object) {
853     if (s == object) {
854       return true;
855     }
856     if (object instanceof Set) {
857       Set&lt;?&gt; o = (Set&lt;?&gt;) object;
858       try {
859         return s.size() == o.size() &amp;&amp; s.containsAll(o);
860       } catch (NullPointerException | ClassCastException ignored) {
861         return false;
862       }
863     }
864     return false;
865   }
866   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; unmodifiableNavigableSet(
867       NavigableSet&lt;E&gt; set) {
868     if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet) {
869       return set;
870     }
871     return new UnmodifiableNavigableSet&lt;E&gt;(set);
872   }
873   static final class UnmodifiableNavigableSet&lt;E extends @Nullable Object&gt;
874       extends ForwardingSortedSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Serializable {
875     private final NavigableSet&lt;E&gt; delegate;
876     private final SortedSet&lt;E&gt; unmodifiableDelegate;
877     UnmodifiableNavigableSet(NavigableSet&lt;E&gt; delegate) {
878       this.delegate = checkNotNull(delegate);
879       this.unmodifiableDelegate = Collections.unmodifiableSortedSet(delegate);
880     }
881     @Override
882     protected SortedSet&lt;E&gt; delegate() {
883       return unmodifiableDelegate;
884     }
885     @Override
886     @CheckForNull
887     public E lower(@ParametricNullness E e) {
888       return delegate.lower(e);
889     }
890     @Override
891     @CheckForNull
892     public E floor(@ParametricNullness E e) {
893       return delegate.floor(e);
894     }
895     @Override
896     @CheckForNull
897     public E ceiling(@ParametricNullness E e) {
898       return delegate.ceiling(e);
899     }
900     @Override
901     @CheckForNull
902     public E higher(@ParametricNullness E e) {
903       return delegate.higher(e);
904     }
905     @Override
906     @CheckForNull
907     public E pollFirst() {
908       throw new UnsupportedOperationException();
909     }
910     @Override
911     @CheckForNull
912     public E pollLast() {
913       throw new UnsupportedOperationException();
914     }
915     @CheckForNull private transient UnmodifiableNavigableSet&lt;E&gt; descendingSet;
916     @Override
917     public NavigableSet&lt;E&gt; descendingSet() {
918       UnmodifiableNavigableSet&lt;E&gt; result = descendingSet;
919       if (result == null) {
920         result = descendingSet = new UnmodifiableNavigableSet&lt;E&gt;(delegate.descendingSet());
921         result.descendingSet = this;
922       }
923       return result;
924     }
925     @Override
926     public Iterator&lt;E&gt; descendingIterator() {
927       return Iterators.unmodifiableIterator(delegate.descendingIterator());
928     }
929     @Override
930     public NavigableSet&lt;E&gt; subSet(
931         @ParametricNullness E fromElement,
932         boolean fromInclusive,
933         @ParametricNullness E toElement,
934         boolean toInclusive) {
935       return unmodifiableNavigableSet(
936           delegate.subSet(fromElement, fromInclusive, toElement, toInclusive));
937     }
938     @Override
939     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
940       return unmodifiableNavigableSet(delegate.headSet(toElement, inclusive));
941     }
942     @Override
943     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
944       return unmodifiableNavigableSet(delegate.tailSet(fromElement, inclusive));
945     }
946     private static final long serialVersionUID = 0;
947   }
948   @GwtIncompatible   public static &lt;E extends @Nullable Object&gt; NavigableSet&lt;E&gt; synchronizedNavigableSet(
949       NavigableSet&lt;E&gt; navigableSet) {
950     return Synchronized.navigableSet(navigableSet);
951   }
952   static boolean removeAllImpl(Set&lt;?&gt; set, Iterator&lt;?&gt; iterator) {
953     boolean changed = false;
954     while (iterator.hasNext()) {
955       changed |= set.remove(iterator.next());
956     }
957     return changed;
958   }
959   static boolean removeAllImpl(Set&lt;?&gt; set, Collection&lt;?&gt; collection) {
960     checkNotNull(collection);     if (collection instanceof Multiset) {
961       collection = ((Multiset&lt;?&gt;) collection).elementSet();
962     }
963     if (collection instanceof Set &amp;&amp; collection.size() &gt; set.size()) {
964       return Iterators.removeAll(set.iterator(), collection);
965     } else {
966       return removeAllImpl(set, collection.iterator());
967     }
968   }
969   @GwtIncompatible   static class DescendingSet&lt;E extends @Nullable Object&gt; extends ForwardingNavigableSet&lt;E&gt; {
970     private final NavigableSet&lt;E&gt; forward;
971     DescendingSet(NavigableSet&lt;E&gt; forward) {
972       this.forward = forward;
973     }
974     @Override
975     protected NavigableSet&lt;E&gt; delegate() {
976       return forward;
977     }
978     @Override
979     @CheckForNull
980     public E lower(@ParametricNullness E e) {
981       return forward.higher(e);
982     }
983     @Override
984     @CheckForNull
985     public E floor(@ParametricNullness E e) {
986       return forward.ceiling(e);
987     }
988     @Override
989     @CheckForNull
990     public E ceiling(@ParametricNullness E e) {
991       return forward.floor(e);
992     }
993     @Override
994     @CheckForNull
995     public E higher(@ParametricNullness E e) {
996       return forward.lower(e);
997     }
998     @Override
999     @CheckForNull
1000     public E pollFirst() {
1001       return forward.pollLast();
1002     }
1003     @Override
1004     @CheckForNull
1005     public E pollLast() {
1006       return forward.pollFirst();
1007     }
1008     @Override
1009     public NavigableSet&lt;E&gt; descendingSet() {
1010       return forward;
1011     }
1012     @Override
1013     public Iterator&lt;E&gt; descendingIterator() {
1014       return forward.iterator();
1015     }
1016     @Override
1017     public NavigableSet&lt;E&gt; subSet(
1018         @ParametricNullness E fromElement,
1019         boolean fromInclusive,
1020         @ParametricNullness E toElement,
1021         boolean toInclusive) {
1022       return forward.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();
1023     }
1024     @Override
1025     public SortedSet&lt;E&gt; subSet(@ParametricNullness E fromElement, @ParametricNullness E toElement) {
1026       return standardSubSet(fromElement, toElement);
1027     }
1028     @Override
1029     public NavigableSet&lt;E&gt; headSet(@ParametricNullness E toElement, boolean inclusive) {
1030       return forward.tailSet(toElement, inclusive).descendingSet();
1031     }
1032     @Override
1033     public SortedSet&lt;E&gt; headSet(@ParametricNullness E toElement) {
1034       return standardHeadSet(toElement);
1035     }
1036     @Override
1037     public NavigableSet&lt;E&gt; tailSet(@ParametricNullness E fromElement, boolean inclusive) {
1038       return forward.headSet(fromElement, inclusive).descendingSet();
1039     }
1040     @Override
1041     public SortedSet&lt;E&gt; tailSet(@ParametricNullness E fromElement) {
1042       return standardTailSet(fromElement);
1043     }
1044     @SuppressWarnings("unchecked")
1045     @Override
1046     public Comparator&lt;? super E&gt; comparator() {
1047       Comparator&lt;? super E&gt; forwardComparator = forward.comparator();
1048       if (forwardComparator == null) {
1049         return (Comparator) Ordering.natural().reverse();
1050       } else {
1051         return reverse(forwardComparator);
1052       }
1053     }
1054     private static &lt;T extends @Nullable Object&gt; Ordering&lt;T&gt; reverse(Comparator&lt;T&gt; forward) {
1055       return Ordering.from(forward).reverse();
1056     }
1057     @Override
1058     @ParametricNullness
1059     public E first() {
1060       return forward.last();
1061     }
1062     @Override
1063     @ParametricNullness
1064     public E last() {
1065       return forward.first();
1066     }
1067     @Override
1068     public Iterator&lt;E&gt; iterator() {
1069       return forward.descendingIterator();
1070     }
1071     @Override
1072     public @Nullable Object[] toArray() {
1073       return standardToArray();
1074     }
1075     @Override
1076     @SuppressWarnings("nullness")     public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
1077       return standardToArray(array);
1078     }
1079     @Override
1080     public String toString() {
1081       return standardToString();
1082     }
1083   }
1084   @Beta
1085   @GwtIncompatible   public static &lt;K extends Comparable&lt;? super K&gt;&gt; NavigableSet&lt;K&gt; subSet(
1086       NavigableSet&lt;K&gt; set, Range&lt;K&gt; range) {
1087     if (set.comparator() != null
1088         &amp;&amp; set.comparator() != Ordering.natural()
1089         &amp;&amp; range.hasLowerBound()
1090         &amp;&amp; range.hasUpperBound()) {
1091       checkArgument(
1092           set.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) &lt;= 0,
1093           "set is using a custom comparator which is inconsistent with the natural ordering.");
1094     }
1095     if (range.hasLowerBound() &amp;&amp; range.hasUpperBound()) {
1096       return set.subSet(
1097           range.lowerEndpoint(),
1098           range.lowerBoundType() == BoundType.CLOSED,
1099           range.upperEndpoint(),
1100           range.upperBoundType() == BoundType.CLOSED);
1101     } else if (range.hasLowerBound()) {
1102       return set.tailSet(range.lowerEndpoint(), range.lowerBoundType() == BoundType.CLOSED);
1103     } else if (range.hasUpperBound()) {
1104       return set.headSet(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);
1105     }
1106     return checkNotNull(set);
1107   }
1108 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Murmur3Hash32Test_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright (C) 2011 The Guava Authors
3  *
4  * Licensed under the Apache License, Version 2.0 (the "License");
5  * you may not use this file except in compliance with the License.
6  * You may obtain a copy of the License at
7  *
8  * http://www.apache.org/licenses/LICENSE-2.0
9  *
10  * Unless required by applicable law or agreed to in writing, software
11  * distributed under the License is distributed on an "AS IS" BASIS,
12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13  * See the License for the specific language governing permissions and
14  * limitations under the License.
15  */
16 package com.google.common.hash;
17 import static com.google.common.hash.Hashing.murmur3_32;
18 import static com.google.common.hash.Hashing.murmur3_32_fixed;
19 import com.google.common.base.Charsets;
20 import com.google.common.hash.HashTestUtils.HashFn;
21 import java.nio.charset.Charset;
22 import java.util.Random;
23 import junit.framework.TestCase;
24 public class Murmur3Hash32Test extends TestCase {
25   public void testKnownIntegerInputs() {
26     assertHash(593689054, murmur3_32().hashInt(0));
27     assertHash(-189366624, murmur3_32().hashInt(-42));
28     assertHash(-1134849565, murmur3_32().hashInt(42));
29     assertHash(-1718298732, murmur3_32().hashInt(Integer.MIN_VALUE));
30     assertHash(-1653689534, murmur3_32().hashInt(Integer.MAX_VALUE));
31   }
32   public void testKnownLongInputs() {
33     assertHash(1669671676, murmur3_32().hashLong(0L));
34     assertHash(-846261623, murmur3_32().hashLong(-42L));
35     assertHash(1871679806, murmur3_32().hashLong(42L));
36     assertHash(1366273829, murmur3_32().hashLong(Long.MIN_VALUE));
37     assertHash(-2106506049, murmur3_32().hashLong(Long.MAX_VALUE));
38   }
39   public void testKnownStringInputs() {
40     assertHash(0, murmur3_32().hashUnencodedChars(""));
41     assertHash(679745764, murmur3_32().hashUnencodedChars("k"));
42     assertHash(1510782915, murmur3_32().hashUnencodedChars("hell"));
43     assertHash(-675079799, murmur3_32().hashUnencodedChars("hello"));
44     assertHash(1935035788, murmur3_32().hashUnencodedChars("http://www.google.com/"));
45     assertHash(
46         -528633700, murmur3_32().hashUnencodedChars("The quick brown fox jumps over the lazy dog"));
47   }
48   @SuppressWarnings("deprecation")
49   public void testKnownEncodedStringInputs() {
50     assertStringHash(0, "", Charsets.UTF_8);
51     assertStringHash(0xcfbda5d1, "k", Charsets.UTF_8);
52     assertStringHash(0xa167dbf3, "hell", Charsets.UTF_8);
53     assertStringHash(0x248bfa47, "hello", Charsets.UTF_8);
54     assertStringHash(0x3d41b97c, "http://www.google.com/", Charsets.UTF_8);
55     assertStringHash(0x2e4ff723, "The quick brown fox jumps over the lazy dog", Charsets.UTF_8);
56     assertStringHash(0xb5a4be05, "ABCDefGHI\u0799", Charsets.UTF_8);
57     assertStringHash(0xfc5ba834, "毎月１日,毎週月曜日", Charsets.UTF_8);
58     assertStringHash(0x8a5c3699, "surrogate pair: \uD83D\uDCB0", Charsets.UTF_8);
59     assertStringHash(0, "", Charsets.UTF_16LE);
60     assertStringHash(0x288418e4, "k", Charsets.UTF_16LE);
61     assertStringHash(0x5a0cb7c3, "hell", Charsets.UTF_16LE);
62     assertStringHash(0xd7c31989, "hello", Charsets.UTF_16LE);
63     assertStringHash(0x73564d8c, "http://www.google.com/", Charsets.UTF_16LE);
64     assertStringHash(0xe07db09c, "The quick brown fox jumps over the lazy dog", Charsets.UTF_16LE);
65     assertStringHash(0xfefa3e76, "ABCDefGHI\u0799", Charsets.UTF_16LE);
66     assertStringHash(0x6a7be132, "毎月１日,毎週月曜日", Charsets.UTF_16LE);
67     assertStringHash(0x5a2d41c7, "surrogate pair: \uD83D\uDCB0", Charsets.UTF_16LE);
68   }
69   @SuppressWarnings("deprecation")
70   private void assertStringHash(int expected, String string, Charset charset) {
71     if (allBmp(string)) {
72       assertHash(expected, murmur3_32().hashString(string, charset));
73     }
74     assertHash(expected, murmur3_32_fixed().hashString(string, charset));
75     assertHash(expected, murmur3_32().newHasher().putString(string, charset).hash());
76     assertHash(expected, murmur3_32_fixed().newHasher().putString(string, charset).hash());
77     assertHash(expected, murmur3_32().hashBytes(string.getBytes(charset)));
78     assertHash(expected, murmur3_32_fixed().hashBytes(string.getBytes(charset)));
79     assertHash(expected, murmur3_32().newHasher().putBytes(string.getBytes(charset)).hash());
80     assertHash(expected, murmur3_32_fixed().newHasher().putBytes(string.getBytes(charset)).hash());
81   }
82   private boolean allBmp(String string) {
83 <a name="0"></a>        for (int i = 0; i &lt; string.length(); i++) {
84       if (<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>string.codePointAt(i) &gt; 0xffff) {
85         return false;
86       }
87     }
88     return true;
89   }
90   @</b></font>SuppressWarnings("deprecation")
91   public void testSimpleStringUtf8() {
92     assertEquals(
93         murmur3_32().hashBytes("ABCDefGHI\u0799".getBytes(Charsets.UTF_8)),
94         murmur3_32().hashString("ABCDefGHI\u0799", Charsets.UTF_8));
95   }
96   @SuppressWarnings("deprecation")
97   public void testEncodedStringInputs() {
98     Random rng = new Random(0);
99     for (int z = 0; z &lt; 100; z++) {
100       String str;
101       int[] codePoints = new int[rng.nextInt(8)];
102       for (int i = 0; i &lt; codePoints.length; i++) {
103         do {
104           codePoints[i] = rng.nextInt(0x800);
105         } while (!Character.isValidCodePoint(codePoints[i])
106             || (codePoints[i] &gt;= Character.MIN_SURROGATE
107                 &amp;&amp; codePoints[i] &lt;= Character.MAX_SURROGATE));
108       }
109       StringBuilder builder = new StringBuilder();
110       for (int i = 0; i &lt; codePoints.length; i++) {
111         builder.appendCodePoint(codePoints[i]);
112       }
113       str = builder.toString();
114       HashCode hashUtf8 = murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8));
115       assertEquals(
116           hashUtf8, murmur3_32().newHasher().putBytes(str.getBytes(Charsets.UTF_8)).hash());
117       assertEquals(hashUtf8, murmur3_32().hashString(str, Charsets.UTF_8));
118       assertEquals(hashUtf8, murmur3_32().newHasher().putString(str, Charsets.UTF_8).hash());
119       HashCode hashUtf16 = murmur3_32().hashBytes(str.getBytes(Charsets.UTF_16));
120       assertEquals(
121           hashUtf16, murmur3_32().newHasher().putBytes(str.getBytes(Charsets.UTF_16)).hash());
122       assertEquals(hashUtf16, murmur3_32().hashString(str, Charsets.UTF_16));
123       assertEquals(hashUtf16, murmur3_32().newHasher().putString(str, Charsets.UTF_16).hash());
124     }
125   }
126   private static void assertHash(int expected, HashCode actual) {
127     assertEquals(HashCode.fromInt(expected), actual);
128   }
129   public void testParanoidHashBytes() {
130 <a name="1"></a>    HashFn hf =
131         new HashFn() {
132           @Override
133           public byte[] hash(byte[] input, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>int seed) {
134             return murmur3_32(seed).hashBytes(input).asBytes();
135           }
136         }</b></font>;
137     HashTestUtils.verifyHashFunction(hf, 32, 0xB0F57EE3);
138   }
139   public void testParanoid() {
140     HashFn hf =
141         new HashFn() {
142           @Override
143           public byte[] hash(byte[] input, int seed) {
144             Hasher hasher = murmur3_32(seed).newHasher();
145             Funnels.byteArrayFunnel().funnel(input, hasher);
146             return hasher.hash().asBytes();
147           }
148         };
149     HashTestUtils.verifyHashFunction(hf, 32, 0xB0F57EE3);
150   }
151   public void testInvariants() {
152     HashTestUtils.assertInvariants(murmur3_32());
153   }
154   @SuppressWarnings("deprecation")
155   public void testInvalidUnicodeHashString() {
156     String str =
157         new String(
158             new char[] {'a', Character.MIN_HIGH_SURROGATE, Character.MIN_HIGH_SURROGATE, 'z'});
159     assertEquals(
160         murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)),
161         murmur3_32().hashString(str, Charsets.UTF_8));
162     assertEquals(
163         murmur3_32_fixed().hashBytes(str.getBytes(Charsets.UTF_8)),
164         murmur3_32().hashString(str, Charsets.UTF_8));
165   }
166   @SuppressWarnings("deprecation")
167   public void testInvalidUnicodeHasherPutString() {
168     String str =
169         new String(
170             new char[] {'a', Character.MIN_HIGH_SURROGATE, Character.MIN_HIGH_SURROGATE, 'z'});
171     assertEquals(
172         murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)),
173         murmur3_32().newHasher().putString(str, Charsets.UTF_8).hash());
174     assertEquals(
175         murmur3_32_fixed().hashBytes(str.getBytes(Charsets.UTF_8)),
176         murmur3_32_fixed().newHasher().putString(str, Charsets.UTF_8).hash());
177   }
178 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
