<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for JsonParseExceptionTest.java &amp; ScramSaslClient.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for JsonParseExceptionTest.java &amp; ScramSaslClient.java
      </h3>
<h1 align="center">
        3.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>JsonParseExceptionTest.java (20.38835%)<th>ScramSaslClient.java (2.145046%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(41-46)<td><a href="#" name="0">(117-124)</a><td align="center"><font color="#ff0000">11</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(54-58)<td><a href="#" name="1">(170-176)</a><td align="center"><font color="#e70000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>JsonParseExceptionTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.allanbank.mongodb.error;
2 import static org.junit.Assert.assertEquals;
3 import static org.junit.Assert.assertNull;
4 import static org.junit.Assert.assertSame;
5 import org.junit.Test;
6 public class JsonParseExceptionTest {
7     @Test
8     public void testJsonParseException() <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
9         final JsonParseException exception = new JsonParseException();
10         assertNull(exception.getCause());
11         assertNull(exception.getMessage());
12         assertEquals(-1, exception.getColumn());
13         assertEquals(-1, exception.getLine</b></font>());
14     }
15     @Test
16     public void testJsonParseExceptionString() {
17         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final JsonParseException exception = new JsonParseException("foo");
18         assertNull(exception.getCause());
19         assertEquals("foo", exception.getMessage());
20         assertEquals(-1, exception.getColumn());
21         assertEquals(-1, exception.getLine</b></font>());
22     }
23     @Test
24     public void testJsonParseExceptionStringIntInt() {
25         final JsonParseException exception = new JsonParseException("foo", 41,
26                 51);
27         assertNull(exception.getCause());
28         assertEquals("foo", exception.getMessage());
29         assertEquals(51, exception.getColumn());
30         assertEquals(41, exception.getLine());
31     }
32     @Test
33     public void testJsonParseExceptionStringThrowable() {
34         final Throwable t = new Throwable();
35         final JsonParseException exception = new JsonParseException("foo", t);
36         assertSame(t, exception.getCause());
37         assertEquals("foo", exception.getMessage());
38         assertEquals(-1, exception.getColumn());
39         assertEquals(-1, exception.getLine());
40     }
41     @Test
42     public void testJsonParseExceptionStringThrowableIntInt() {
43         final Throwable t = new Throwable();
44         final JsonParseException exception = new JsonParseException("foo", t,
45                 123, 456);
46         assertSame(t, exception.getCause());
47         assertEquals("foo", exception.getMessage());
48         assertEquals(456, exception.getColumn());
49         assertEquals(123, exception.getLine());
50     }
51     @Test
52     public void testJsonParseExceptionThrowable() {
53         final Throwable t = new Throwable("foo");
54         final JsonParseException exception = new JsonParseException(t);
55         assertSame(t, exception.getCause());
56         assertEquals("foo", exception.getMessage());
57         assertEquals(-1, exception.getColumn());
58         assertEquals(-1, exception.getLine());
59     }
60 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ScramSaslClient.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.allanbank.mongodb.client.connection.auth;
2 import java.io.IOException;
3 import java.nio.ByteBuffer;
4 import java.nio.CharBuffer;
5 import java.nio.charset.Charset;
6 import java.security.InvalidKeyException;
7 import java.security.MessageDigest;
8 import java.security.NoSuchAlgorithmException;
9 import java.security.SecureRandom;
10 import java.text.Normalizer;
11 import java.util.Arrays;
12 import java.util.Collections;
13 import java.util.HashMap;
14 import java.util.HashSet;
15 import java.util.Map;
16 import java.util.Set;
17 import java.util.StringTokenizer;
18 import javax.crypto.Mac;
19 import javax.crypto.spec.SecretKeySpec;
20 import javax.security.auth.callback.Callback;
21 import javax.security.auth.callback.CallbackHandler;
22 import javax.security.auth.callback.NameCallback;
23 import javax.security.auth.callback.PasswordCallback;
24 import javax.security.auth.callback.UnsupportedCallbackException;
25 import javax.security.sasl.SaslClient;
26 import javax.security.sasl.SaslException;
27 import com.allanbank.mongodb.util.IOUtils;
28         implements SaslClient {
29     public static final String MECHANISM = "SCRAM-SHA-1";
30     protected static final Charset ASCII = Charset.forName("US-ASCII");
31     protected static final int RANDOM_BYTES = 24;
32     protected static final Set&lt;Integer&gt; SASL_PREP_DISALLOWED;
33     protected static final Map&lt;Character, String&gt; SASL_PREP_MAPPINGS;
34     protected static final Charset UTF_8 = Charset.forName("UTF-8");
35     private static final String DIGEST_NAME = "SHA-1";
36     private static final byte[] EMPTY_BYTES = new byte[0];
37     private static final char[] EMPTY_CHARS = new char[0];
38     private static final String GS2_HEADER = "n,,";
39     private static final String HMAC_NAME = "HmacSHA1";
40 <a name="0"></a>        private static final byte[] ONE_UINT32_BE = new byte[] { 0, 0, 0, 1 };
41     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static {
42         final Map&lt;Character, String&gt; saslPrepMappings = new HashMap&lt;Character, String&gt;();
43         saslPrepMappings.put(Character.valueOf('\u00AD'), "");
44         saslPrepMappings.put(Character.valueOf('\u034F'), "");
45         saslPrepMappings.put(Character.valueOf('\u1806'), "");
46         saslPrepMappings.put(Character.valueOf</b></font>('\u180B'), "");
47         saslPrepMappings.put(Character.valueOf('\u180C'), "");
48         saslPrepMappings.put(Character.valueOf('\u180D'), "");
49         saslPrepMappings.put(Character.valueOf('\u200B'), "");
50         saslPrepMappings.put(Character.valueOf('\u200C'), "");
51         saslPrepMappings.put(Character.valueOf('\u200D'), "");
52         saslPrepMappings.put(Character.valueOf('\u2060'), "");
53         saslPrepMappings.put(Character.valueOf('\uFE00'), "");
54         saslPrepMappings.put(Character.valueOf('\uFE01'), "");
55         saslPrepMappings.put(Character.valueOf('\uFE02'), "");
56         saslPrepMappings.put(Character.valueOf('\uFE03'), "");
57         saslPrepMappings.put(Character.valueOf('\uFE04'), "");
58         saslPrepMappings.put(Character.valueOf('\uFE05'), "");
59         saslPrepMappings.put(Character.valueOf('\uFE06'), "");
60         saslPrepMappings.put(Character.valueOf('\uFE07'), "");
61         saslPrepMappings.put(Character.valueOf('\uFE08'), "");
62         saslPrepMappings.put(Character.valueOf('\uFE09'), "");
63         saslPrepMappings.put(Character.valueOf('\uFE0A'), "");
64         saslPrepMappings.put(Character.valueOf('\uFE0B'), "");
65         saslPrepMappings.put(Character.valueOf('\uFE0C'), "");
66         saslPrepMappings.put(Character.valueOf('\uFE0D'), "");
67         saslPrepMappings.put(Character.valueOf('\uFE0E'), "");
68         saslPrepMappings.put(Character.valueOf('\uFE0F'), "");
69         saslPrepMappings.put(Character.valueOf('\uFEFF'), "");
70         saslPrepMappings.put(Character.valueOf('\u00A0'), " ");
71         saslPrepMappings.put(Character.valueOf('\u1680'), " ");
72         saslPrepMappings.put(Character.valueOf('\u2000'), " ");
73         saslPrepMappings.put(Character.valueOf('\u2001'), " ");
74         saslPrepMappings.put(Character.valueOf('\u2002'), " ");
75         saslPrepMappings.put(Character.valueOf('\u2003'), " ");
76         saslPrepMappings.put(Character.valueOf('\u2004'), " ");
77         saslPrepMappings.put(Character.valueOf('\u2005'), " ");
78         saslPrepMappings.put(Character.valueOf('\u2006'), " ");
79         saslPrepMappings.put(Character.valueOf('\u2007'), " ");
80         saslPrepMappings.put(Character.valueOf('\u2008'), " ");
81         saslPrepMappings.put(Character.valueOf('\u2009'), " ");
82         saslPrepMappings.put(Character.valueOf('\u200A'), " ");
83         saslPrepMappings.put(Character.valueOf('\u200B'), " ");
84         saslPrepMappings.put(Character.valueOf('\u202F'), " ");
85         saslPrepMappings.put(Character.valueOf('\u205F'), " ");
86         saslPrepMappings.put(Character.valueOf('\u3000'), " ");
87 <a name="1"></a>
88         SASL_PREP_MAPPINGS = Collections.unmodifiableMap(saslPrepMappings);
89         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final Set&lt;Integer&gt; disallowed = new HashSet&lt;Integer&gt;();
90         disallowed.add(Integer.valueOf(0x00A0));
91         disallowed.add(Integer.valueOf(0x1680));
92         disallowed.add(Integer.valueOf(0x2000));
93         disallowed.add(Integer.valueOf</b></font>(0x2001));
94         disallowed.add(Integer.valueOf(0x2002));
95         disallowed.add(Integer.valueOf(0x2003));
96         disallowed.add(Integer.valueOf(0x2004));
97         disallowed.add(Integer.valueOf(0x2005));
98         disallowed.add(Integer.valueOf(0x2006));
99         disallowed.add(Integer.valueOf(0x2007));
100         disallowed.add(Integer.valueOf(0x2008));
101         disallowed.add(Integer.valueOf(0x2009));
102         disallowed.add(Integer.valueOf(0x200A));
103         disallowed.add(Integer.valueOf(0x200B));
104         disallowed.add(Integer.valueOf(0x202F));
105         disallowed.add(Integer.valueOf(0x205F));
106         disallowed.add(Integer.valueOf(0x3000));
107         addRange(disallowed, 0x0000, 0x001F);
108         disallowed.add(Integer.valueOf(0x007F));
109         addRange(disallowed, 0x0080, 0x009F);
110         disallowed.add(Integer.valueOf(0x06DD));
111         disallowed.add(Integer.valueOf(0x070F));
112         disallowed.add(Integer.valueOf(0x180E));
113         disallowed.add(Integer.valueOf(0x200C));
114         disallowed.add(Integer.valueOf(0x200D));
115         disallowed.add(Integer.valueOf(0x2028));
116         disallowed.add(Integer.valueOf(0x2029));
117         disallowed.add(Integer.valueOf(0x2060));
118         disallowed.add(Integer.valueOf(0x2061));
119         disallowed.add(Integer.valueOf(0x2062));
120         disallowed.add(Integer.valueOf(0x2063));
121         addRange(disallowed, 0x206A, 0x206F);
122         disallowed.add(Integer.valueOf(0xFEFF));
123         addRange(disallowed, 0xFFF9, 0xFFFC);
124         addRange(disallowed, 0x1D173, 0x1D17A);
125         addRange(disallowed, 0xFDD0, 0xFDEF);
126         addRange(disallowed, 0xFFFE, 0xFFFF);
127         addRange(disallowed, 0x1FFFE, 0x1FFFF);
128         addRange(disallowed, 0x2FFFE, 0x2FFFF);
129         addRange(disallowed, 0x3FFFE, 0x3FFFF);
130         addRange(disallowed, 0x4FFFE, 0x4FFFF);
131         addRange(disallowed, 0x5FFFE, 0x5FFFF);
132         addRange(disallowed, 0x6FFFE, 0x6FFFF);
133         addRange(disallowed, 0x7FFFE, 0x7FFFF);
134         addRange(disallowed, 0x8FFFE, 0x8FFFF);
135         addRange(disallowed, 0x9FFFE, 0x9FFFF);
136         addRange(disallowed, 0xAFFFE, 0xAFFFF);
137         addRange(disallowed, 0xBFFFE, 0xBFFFF);
138         addRange(disallowed, 0xCFFFE, 0xCFFFF);
139         addRange(disallowed, 0xDFFFE, 0xDFFFF);
140         addRange(disallowed, 0xEFFFE, 0xEFFFF);
141         addRange(disallowed, 0xFFFFE, 0xFFFFF);
142         addRange(disallowed, 0x10FFFE, 0x10FFFF);
143         disallowed.add(Integer.valueOf(0xFFF9));
144         disallowed.add(Integer.valueOf(0xFFFA));
145         disallowed.add(Integer.valueOf(0xFFFB));
146         disallowed.add(Integer.valueOf(0xFFFC));
147         disallowed.add(Integer.valueOf(0xFFFD));
148         addRange(disallowed, 0x2FF0, 0x2FFB);
149         disallowed.add(Integer.valueOf(0x0340));
150         disallowed.add(Integer.valueOf(0x0341));
151         disallowed.add(Integer.valueOf(0x200E));
152         disallowed.add(Integer.valueOf(0x200F));
153         disallowed.add(Integer.valueOf(0x202A));
154         disallowed.add(Integer.valueOf(0x202B));
155         disallowed.add(Integer.valueOf(0x202C));
156         disallowed.add(Integer.valueOf(0x202D));
157         disallowed.add(Integer.valueOf(0x202E));
158         disallowed.add(Integer.valueOf(0x206A));
159         disallowed.add(Integer.valueOf(0x206B));
160         disallowed.add(Integer.valueOf(0x206C));
161         disallowed.add(Integer.valueOf(0x206D));
162         disallowed.add(Integer.valueOf(0x206E));
163         disallowed.add(Integer.valueOf(0x206F));
164         disallowed.add(Integer.valueOf(0xE0001));
165         addRange(disallowed, 0xE0020, 0xE007F);
166         SASL_PREP_DISALLOWED = Collections.unmodifiableSet(disallowed);
167     }
168     static private void addRange(final Set&lt;Integer&gt; codepoints,
169             final int start, final int end) {
170         for (int codepoint = start; codepoint &lt;= end; ++codepoint) {
171             codepoints.add(Integer.valueOf(codepoint));
172         }
173     }
174     private final CallbackHandler myCallbackHandler;
175     private String myClientFirstMessageBare;
176     private String myClientNonce;
177     private int myIterationCount;
178     private byte[] mySalt;
179     private String myServerNonce;
180     private String myServerSignature;
181     private State myState;
182     private String myUsername;
183     public ScramSaslClient(final CallbackHandler callbackHandler) {
184         myCallbackHandler = callbackHandler;
185         dispose();
186     }
187     @Override
188     public void dispose() {
189         myClientFirstMessageBare = null;
190         myClientNonce = null;
191         myIterationCount = 0;
192         mySalt = null;
193         myServerNonce = null;
194         myServerSignature = null;
195         myUsername = null;
196         myState = State.INITIAL;
197     }
198     @Override
199     public byte[] evaluateChallenge(final byte[] challenge)
200             throws SaslException {
201         byte[] response = EMPTY_BYTES;
202         switch (myState) {
203         case INITIAL:
204             response = createInitialMessage();
205             myState = State.FIRST_SENT;
206             break;
207         case FIRST_SENT:
208             response = createProof(challenge);
209             myState = State.PROOF_SENT;
210             break;
211         case PROOF_SENT:
212             evaluateFinalResult(challenge);
213             myState = State.COMPLETE;
214             break;
215         default:
216             throw new SaslException("No challenge expected in state " + myState);
217         }
218         return response;
219     }
220     @Override
221     public String getMechanismName() {
222         return MECHANISM;
223     }
224     @Override
225     public Object getNegotiatedProperty(final String propName) {
226         return null;
227     }
228     @Override
229     public boolean hasInitialResponse() {
230         return true;
231     }
232     @Override
233     public boolean isComplete() {
234         return myState == State.COMPLETE;
235     }
236     @Override
237     public byte[] unwrap(final byte[] incoming, final int offset, final int len) {
238         throw new IllegalStateException(MECHANISM
239                 + " does not support integrity and/or "
240                 + "privacy as the quality of protection.");
241     }
242     @Override
243     public byte[] wrap(final byte[] outgoing, final int offset, final int len) {
244         throw new IllegalStateException(MECHANISM
245                 + " does not support integrity and/or "
246                 + "privacy as the quality of protection.");
247     }
248     protected final byte[] createInitialMessage() throws SaslException {
249         try {
250             final NameCallback nameCallback = new NameCallback("Username?");
251             myCallbackHandler.handle(new Callback[] { nameCallback });
252             myUsername = nameCallback.getName();
253             myClientNonce = createNonce();
254             final StringBuilder buffer = new StringBuilder(GS2_HEADER);
255             buffer.append("n=");
256             buffer.append(saslName(myUsername));
257             buffer.append(",r=");
258             buffer.append(myClientNonce);
259             myClientFirstMessageBare = buffer.substring(GS2_HEADER.length());
260             return buffer.toString().getBytes(UTF_8);
261         }
262         catch (final UnsupportedCallbackException e) {
263             throw new SaslException(e.getMessage(), e);
264         }
265         catch (final IOException e) {
266             throw new SaslException(e.getMessage(), e);
267         }
268     }
269     protected String createNonce() {
270         final SecureRandom random = new SecureRandom();
271         final byte[] nonce = new byte[RANDOM_BYTES];
272         random.nextBytes(nonce);
273         return IOUtils.toBase64(nonce);
274     }
275     protected final byte[] createProof(final byte[] challenge)
276             throws SaslException {
277         final String message = new String(challenge, UTF_8);
278         try {
279             final Map&lt;String, String&gt; content = parse(message);
280             final String serverNonce = content.get("r");
281             final String base64Salt = content.get("s");
282             final String iterCountString = content.get("i");
283             int iterationCount = 0;
284             if (content.containsKey("m")) {
285                 throw new SaslException(
286                         "The server required mandatory extension is not supported: m="
287                                 + content.get("m"));
288             }
289             else if (serverNonce == null) {
290                 throw new SaslException("Could not find the server's nonce: '"
291                         + message + "'.");
292             }
293             else if (!serverNonce.startsWith(myClientNonce)) {
294                 throw new SaslException("The server's nonce '" + serverNonce
295                         + "' must start with the client's nonce '"
296                         + myClientNonce + "'.");
297             }
298             else if (base64Salt == null) {
299                 throw new SaslException("Could not find the server's salt: '"
300                         + message + "'.");
301             }
302             else if ((base64Salt.length() % 4) != 0) {
303                 throw new SaslException(
304                         "The server's salt is not a valid Base64 value: '"
305                                 + base64Salt + "'.");
306             }
307             else if (iterCountString == null) {
308                 throw new SaslException("Could not find the iteration count: '"
309                         + message + "'.");
310             }
311             else {
312                 iterationCount = Integer.parseInt(iterCountString);
313                 if (iterationCount &lt;= 0) {
314                     throw new SaslException("Iteration count " + iterationCount
315                             + " must be a positive integer.");
316                 }
317             }
318             myServerNonce = serverNonce;
319             mySalt = IOUtils.base64ToBytes(base64Salt);
320             myIterationCount = iterationCount;
321             final PasswordCallback passwordCallback = new PasswordCallback(
322                     "Password", false);
323             char[] password = EMPTY_CHARS;
324             char[] passwordPrep = EMPTY_CHARS;
325             ByteBuffer passwordBuffer = null;
326             byte[] passwordBytes = EMPTY_BYTES;
327             byte[] saltedPassword = EMPTY_BYTES;
328             byte[] clientKey = EMPTY_BYTES;
329             byte[] storedKey = EMPTY_BYTES;
330             byte[] clientSignature = EMPTY_BYTES;
331             byte[] clientProof = EMPTY_BYTES;
332             byte[] serverKey = EMPTY_BYTES;
333             try {
334                 myCallbackHandler.handle(new Callback[] { passwordCallback });
335                 password = passwordCallback.getPassword();
336                 passwordPrep = saslPrep(password);
337                 passwordBuffer = UTF_8.encode(CharBuffer.wrap(passwordPrep));
338                 passwordBytes = new byte[passwordBuffer.remaining()];
339                 passwordBuffer.get(passwordBytes);
340                 saltedPassword = generateSaltedPassword(passwordBytes);
341                 clientKey = computeHmac(saltedPassword, "Client Key");
342                 storedKey = MessageDigest.getInstance(DIGEST_NAME).digest(
343                         clientKey);
344                 final String clientFinalMessageWithoutProof = "c="
345                         + IOUtils.toBase64(GS2_HEADER.getBytes(ASCII)) + ",r="
346                         + myServerNonce;
347                 final String authMessage = myClientFirstMessageBare + ","
348                         + message + "," + clientFinalMessageWithoutProof;
349                 clientSignature = computeHmac(storedKey, authMessage);
350                 clientProof = clientKey.clone();
351                 for (int i = 0; i &lt; clientProof.length; i++) {
352                     clientProof[i] ^= clientSignature[i];
353                 }
354                 serverKey = computeHmac(saltedPassword, "Server Key");
355                 myServerSignature = IOUtils.toBase64(computeHmac(serverKey,
356                         authMessage));
357                 final String finalMessageWithProof = clientFinalMessageWithoutProof
358                         + ",p=" + IOUtils.toBase64(clientProof);
359                 return finalMessageWithProof.getBytes(ASCII);
360             }
361             finally {
362                 passwordCallback.clearPassword();
363                 Arrays.fill(password, '\u0000');
364                 Arrays.fill(passwordPrep, '\u0000');
365                 if ((passwordBuffer != null) &amp;&amp; passwordBuffer.isReadOnly()) {
366                     passwordBuffer.rewind();
367                     passwordBuffer.limit(passwordBuffer.capacity());
368                     while (passwordBuffer.hasRemaining()) {
369                         passwordBuffer.put((byte) 0);
370                     }
371                 }
372                 Arrays.fill(passwordBytes, (byte) 0);
373                 Arrays.fill(saltedPassword, (byte) 0);
374                 Arrays.fill(clientKey, (byte) 0);
375                 Arrays.fill(storedKey, (byte) 0);
376                 Arrays.fill(clientSignature, (byte) 0);
377                 Arrays.fill(clientProof, (byte) 0);
378                 Arrays.fill(serverKey, (byte) 0);
379             }
380         }
381         catch (final IllegalArgumentException e) {
382             throw new SaslException(e.getMessage(), e);
383         }
384         catch (final UnsupportedCallbackException e) {
385             throw new SaslException(e.getMessage(), e);
386         }
387         catch (final IOException e) {
388             throw new SaslException(e.getMessage(), e);
389         }
390         catch (final NoSuchAlgorithmException e) {
391             throw new SaslException(e.getMessage(), e);
392         }
393     }
394     protected final void evaluateFinalResult(final byte[] challenge)
395             throws SaslException {
396         final String message = new String(challenge, ASCII);
397         final Map&lt;String, String&gt; content = parse(message);
398         final String verifier = content.get("v");
399         if (verifier == null) {
400             throw new SaslException(
401                     "The Server's final message did not contain a verifier: '"
402                             + message + "'");
403         }
404         if (!verifier.equals(myServerSignature)) {
405             throw new SaslException("The server's signature ('" + verifier
406                     + "') does not match the expected signature: '"
407                     + myServerSignature + "'.");
408         }
409     }
410     protected String saslName(final String name) throws SaslException {
411         final char[] prepared = saslPrep(name.toCharArray());
412         final StringBuilder builder = new StringBuilder(prepared.length);
413         for (final char c : prepared) {
414             if (c == '=') {
415                 builder.append("=3D");
416             }
417             else if (c == ',') {
418                 builder.append("=2C");
419             }
420             else {
421                 builder.append(c);
422             }
423         }
424         return builder.toString();
425     }
426     protected char[] saslPrep(final char[] text) throws SaslException {
427         if (ASCII.newEncoder().canEncode(CharBuffer.wrap(text))) {
428             saslPrepCheckProhibited(new String(text));
429             return text;
430         }
431         final CharSequence mapped = saslPrepMap(text);
432         final String nfkc = Normalizer.normalize(mapped, Normalizer.Form.NFKC);
433         saslPrepCheckProhibited(nfkc);
434         saslPrepCheckBidi(nfkc);
435         saslPrepCheckUnassigned(nfkc);
436         return nfkc.toCharArray();
437     }
438     private byte[] computeHmac(final byte[] keyBytes, final String string)
439             throws SaslException {
440         final Mac mac = initMac(keyBytes);
441         return mac.doFinal(string.getBytes(ASCII));
442     }
443     private byte[] generateSaltedPassword(final byte[] passwordBytes)
444             throws SaslException {
445         final Mac mac = initMac(passwordBytes);
446         mac.update(mySalt);
447         mac.update(ONE_UINT32_BE);
448         final byte[] result = mac.doFinal();
449         byte[] previous = result;
450         for (int i = 1; i &lt; myIterationCount; i++) {
451             previous = mac.doFinal(previous);
452             for (int x = 0; x &lt; result.length; x++) {
453                 result[x] ^= previous[x];
454             }
455         }
456         return result;
457     }
458     private Mac initMac(final byte[] keyBytes) throws SaslException {
459         try {
460             final SecretKeySpec key = new SecretKeySpec(keyBytes, HMAC_NAME);
461             final Mac mac = Mac.getInstance(HMAC_NAME);
462             mac.init(key);
463             return mac;
464         }
465         catch (final NoSuchAlgorithmException e) {
466             throw new SaslException(e.getMessage(), e);
467         }
468         catch (final InvalidKeyException e) {
469             throw new SaslException(e.getMessage(), e);
470         }
471     }
472     private Map&lt;String, String&gt; parse(final String message)
473             throws SaslException {
474         final Map&lt;String, String&gt; results = new HashMap&lt;String, String&gt;();
475         final StringTokenizer tokens = new StringTokenizer(message, ",");
476         while (tokens.hasMoreTokens()) {
477             final String token = tokens.nextToken();
478             if ((token.length() &gt; 1) &amp;&amp; (token.charAt(1) == '=')) {
479                 results.put(token.substring(0, 1), token.substring(2));
480             }
481             else {
482                 throw new SaslException("Invalid field ('" + token
483                         + "') in the message: '" + message + "'.");
484             }
485         }
486         return results;
487     }
488     private void saslPrepCheckBidi(final String text) throws SaslException {
489         final int length = text.length();
490         int codePoint;
491         if (!text.isEmpty()) {
492             final int first = Character.codePointAt(text, 0);
493             final int firstDir = Character.getDirectionality(first);
494             if ((firstDir == Character.DIRECTIONALITY_RIGHT_TO_LEFT)
495                     || (firstDir == Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC)) {
496                 int lastCodePoint = 0;
497                 int lastDir = 0;
498                 for (int i = 0; i &lt; length; i += Character
499                         .charCount(lastCodePoint)) {
500                     lastCodePoint = Character.codePointAt(text, i);
501                     lastDir = Character.getDirectionality(lastCodePoint);
502                     if (lastDir == Character.DIRECTIONALITY_LEFT_TO_RIGHT) {
503                         throw new SaslException(
504                                 "SaslPrep does not allow mixing "
505                                         + "left-to-right ("
506                                         + String.valueOf(Character
507                                                 .toChars(lastCodePoint))
508                                         + ") and right-to-left ("
509                                         + String.valueOf(Character
510                                                 .toChars(first)) + ") text. "
511                                         + "See RFC 4013 section 2.4.");
512                     }
513                 }
514                 if ((lastDir != Character.DIRECTIONALITY_RIGHT_TO_LEFT)
515                         &amp;&amp; (lastDir != Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC)) {
516                     throw new SaslException(
517                             "SaslPrep does not allow text with a leading "
518                                     + "left-to-right character ("
519                                     + String.valueOf(Character.toChars(first))
520                                     + ") to not end with a non-left-to-right "
521                                     + "character ("
522                                     + String.valueOf(Character
523                                             .toChars(lastCodePoint)) + "). "
524                                     + "See RFC 4013 section 2.4.");
525                 }
526             }
527             else {
528                 for (int i = 0; i &lt; length; i += Character.charCount(codePoint)) {
529                     codePoint = Character.codePointAt(text, i);
530                     final int dir = Character.getDirectionality(codePoint);
531                     if ((dir == Character.DIRECTIONALITY_RIGHT_TO_LEFT)
532                             || (dir == Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC)) {
533                         throw new SaslException(
534                                 "SaslPrep does not allow left-to-right ("
535                                         + String.valueOf(Character
536                                                 .toChars(codePoint))
537                                         + ") characters without an initial left-to-right "
538                                         + "character. See RFC 4013 section 2.4.");
539                     }
540                 }
541             }
542         }
543     }
544     private void saslPrepCheckProhibited(final String text)
545             throws SaslException {
546         final int length = text.length();
547         int codePoint;
548         for (int i = 0; i &lt; length; i += Character.charCount(codePoint)) {
549             codePoint = Character.codePointAt(text, i);
550             if (SASL_PREP_DISALLOWED.contains(Integer.valueOf(codePoint))
551                     || ((0xE000 &lt;= codePoint) &amp;&amp; (codePoint &lt;= 0xF8FF))
552                     || ((0xF0000 &lt;= codePoint) &amp;&amp; (codePoint &lt;= 0xFFFFD))
553                     || ((0x100000 &lt;= codePoint) &amp;&amp; (codePoint &lt;= 0x10FFFD)) ||
554                     ((0xD800 &lt;= codePoint) &amp;&amp; (codePoint &lt;= 0xDFFF))) {
555                 throw new SaslException("SaslPrep disallowed character '"
556                         + String.valueOf(Character.toChars(codePoint))
557                         + "' (0x" + Integer.toHexString(codePoint)
558                         + "). See RFC 4013 section 2.3.");
559             }
560         }
561     }
562     private void saslPrepCheckUnassigned(final String text)
563             throws SaslException {
564         final int nfkcLength = text.length();
565         int codePoint;
566         for (int i = 0; i &lt; nfkcLength; i += Character.charCount(codePoint)) {
567             codePoint = Character.codePointAt(text, i);
568             final int type = Character.getType(codePoint);
569             if (type == Character.UNASSIGNED) {
570                 throw new SaslException(
571                         "SaslPrep does not allow unassigned unicode characters. "
572                                 + "See RFC 4013 section 2.5.");
573             }
574         }
575     }
576     private StringBuilder saslPrepMap(final char[] text) {
577         final StringBuilder builder = new StringBuilder(text.length);
578         for (final char c : text) {
579             final String replacement = SASL_PREP_MAPPINGS.get(Character
580                     .valueOf(c));
581             if (replacement == null) {
582                 builder.append(c);
583             }
584             else {
585                 builder.append(replacement);
586             }
587         }
588         return builder;
589     }
590     public static enum State {
591         COMPLETE,
592         FIRST_SENT,
593         INITIAL,
594         PROOF_SENT
595     }
596 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
