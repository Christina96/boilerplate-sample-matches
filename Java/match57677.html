<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for JsonParseExceptionTest.java &amp; ScramSaslClient.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for JsonParseExceptionTest.java &amp; ScramSaslClient.java
      </h3>
<h1 align="center">
        3.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>JsonParseExceptionTest.java (20.38835%)<th>ScramSaslClient.java (2.145046%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(41-46)<td><a href="#" name="0">(117-124)</a><td align="center"><font color="#ff0000">11</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(54-58)<td><a href="#" name="1">(170-176)</a><td align="center"><font color="#e70000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>JsonParseExceptionTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.allanbank.mongodb.error;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import org.junit.Test;
public class JsonParseExceptionTest {
    @Test
    public void testJsonParseException() <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
        final JsonParseException exception = new JsonParseException();
        assertNull(exception.getCause());
        assertNull(exception.getMessage());
        assertEquals(-1, exception.getColumn());
        assertEquals(-1, exception.getLine</b></font>());
    }
    @Test
    public void testJsonParseExceptionString() {
        <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>final JsonParseException exception = new JsonParseException("foo");
        assertNull(exception.getCause());
        assertEquals("foo", exception.getMessage());
        assertEquals(-1, exception.getColumn());
        assertEquals(-1, exception.getLine</b></font>());
    }
    @Test
    public void testJsonParseExceptionStringIntInt() {
        final JsonParseException exception = new JsonParseException("foo", 41,
                51);
        assertNull(exception.getCause());
        assertEquals("foo", exception.getMessage());
        assertEquals(51, exception.getColumn());
        assertEquals(41, exception.getLine());
    }
    @Test
    public void testJsonParseExceptionStringThrowable() {
        final Throwable t = new Throwable();
        final JsonParseException exception = new JsonParseException("foo", t);
        assertSame(t, exception.getCause());
        assertEquals("foo", exception.getMessage());
        assertEquals(-1, exception.getColumn());
        assertEquals(-1, exception.getLine());
    }
    @Test
    public void testJsonParseExceptionStringThrowableIntInt() {
        final Throwable t = new Throwable();
        final JsonParseException exception = new JsonParseException("foo", t,
                123, 456);
        assertSame(t, exception.getCause());
        assertEquals("foo", exception.getMessage());
        assertEquals(456, exception.getColumn());
        assertEquals(123, exception.getLine());
    }
    @Test
    public void testJsonParseExceptionThrowable() {
        final Throwable t = new Throwable("foo");
        final JsonParseException exception = new JsonParseException(t);
        assertSame(t, exception.getCause());
        assertEquals("foo", exception.getMessage());
        assertEquals(-1, exception.getColumn());
        assertEquals(-1, exception.getLine());
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ScramSaslClient.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.allanbank.mongodb.client.connection.auth;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.text.Normalizer;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.callback.UnsupportedCallbackException;
import javax.security.sasl.SaslClient;
import javax.security.sasl.SaslException;
import com.allanbank.mongodb.util.IOUtils;
        implements SaslClient {
    public static final String MECHANISM = "SCRAM-SHA-1";
    protected static final Charset ASCII = Charset.forName("US-ASCII");
    protected static final int RANDOM_BYTES = 24;
    protected static final Set&lt;Integer&gt; SASL_PREP_DISALLOWED;
    protected static final Map&lt;Character, String&gt; SASL_PREP_MAPPINGS;
    protected static final Charset UTF_8 = Charset.forName("UTF-8");
    private static final String DIGEST_NAME = "SHA-1";
    private static final byte[] EMPTY_BYTES = new byte[0];
    private static final char[] EMPTY_CHARS = new char[0];
    private static final String GS2_HEADER = "n,,";
    private static final String HMAC_NAME = "HmacSHA1";
<a name="0"></a>        private static final byte[] ONE_UINT32_BE = new byte[] { 0, 0, 0, 1 };
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static {
        final Map&lt;Character, String&gt; saslPrepMappings = new HashMap&lt;Character, String&gt;();
        saslPrepMappings.put(Character.valueOf('\u00AD'), "");
        saslPrepMappings.put(Character.valueOf('\u034F'), "");
        saslPrepMappings.put(Character.valueOf('\u1806'), "");
        saslPrepMappings.put(Character.valueOf</b></font>('\u180B'), "");
        saslPrepMappings.put(Character.valueOf('\u180C'), "");
        saslPrepMappings.put(Character.valueOf('\u180D'), "");
        saslPrepMappings.put(Character.valueOf('\u200B'), "");
        saslPrepMappings.put(Character.valueOf('\u200C'), "");
        saslPrepMappings.put(Character.valueOf('\u200D'), "");
        saslPrepMappings.put(Character.valueOf('\u2060'), "");
        saslPrepMappings.put(Character.valueOf('\uFE00'), "");
        saslPrepMappings.put(Character.valueOf('\uFE01'), "");
        saslPrepMappings.put(Character.valueOf('\uFE02'), "");
        saslPrepMappings.put(Character.valueOf('\uFE03'), "");
        saslPrepMappings.put(Character.valueOf('\uFE04'), "");
        saslPrepMappings.put(Character.valueOf('\uFE05'), "");
        saslPrepMappings.put(Character.valueOf('\uFE06'), "");
        saslPrepMappings.put(Character.valueOf('\uFE07'), "");
        saslPrepMappings.put(Character.valueOf('\uFE08'), "");
        saslPrepMappings.put(Character.valueOf('\uFE09'), "");
        saslPrepMappings.put(Character.valueOf('\uFE0A'), "");
        saslPrepMappings.put(Character.valueOf('\uFE0B'), "");
        saslPrepMappings.put(Character.valueOf('\uFE0C'), "");
        saslPrepMappings.put(Character.valueOf('\uFE0D'), "");
        saslPrepMappings.put(Character.valueOf('\uFE0E'), "");
        saslPrepMappings.put(Character.valueOf('\uFE0F'), "");
        saslPrepMappings.put(Character.valueOf('\uFEFF'), "");
        saslPrepMappings.put(Character.valueOf('\u00A0'), " ");
        saslPrepMappings.put(Character.valueOf('\u1680'), " ");
        saslPrepMappings.put(Character.valueOf('\u2000'), " ");
        saslPrepMappings.put(Character.valueOf('\u2001'), " ");
        saslPrepMappings.put(Character.valueOf('\u2002'), " ");
        saslPrepMappings.put(Character.valueOf('\u2003'), " ");
        saslPrepMappings.put(Character.valueOf('\u2004'), " ");
        saslPrepMappings.put(Character.valueOf('\u2005'), " ");
        saslPrepMappings.put(Character.valueOf('\u2006'), " ");
        saslPrepMappings.put(Character.valueOf('\u2007'), " ");
        saslPrepMappings.put(Character.valueOf('\u2008'), " ");
        saslPrepMappings.put(Character.valueOf('\u2009'), " ");
        saslPrepMappings.put(Character.valueOf('\u200A'), " ");
        saslPrepMappings.put(Character.valueOf('\u200B'), " ");
        saslPrepMappings.put(Character.valueOf('\u202F'), " ");
        saslPrepMappings.put(Character.valueOf('\u205F'), " ");
        saslPrepMappings.put(Character.valueOf('\u3000'), " ");
<a name="1"></a>
        SASL_PREP_MAPPINGS = Collections.unmodifiableMap(saslPrepMappings);
        <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final Set&lt;Integer&gt; disallowed = new HashSet&lt;Integer&gt;();
        disallowed.add(Integer.valueOf(0x00A0));
        disallowed.add(Integer.valueOf(0x1680));
        disallowed.add(Integer.valueOf(0x2000));
        disallowed.add(Integer.valueOf</b></font>(0x2001));
        disallowed.add(Integer.valueOf(0x2002));
        disallowed.add(Integer.valueOf(0x2003));
        disallowed.add(Integer.valueOf(0x2004));
        disallowed.add(Integer.valueOf(0x2005));
        disallowed.add(Integer.valueOf(0x2006));
        disallowed.add(Integer.valueOf(0x2007));
        disallowed.add(Integer.valueOf(0x2008));
        disallowed.add(Integer.valueOf(0x2009));
        disallowed.add(Integer.valueOf(0x200A));
        disallowed.add(Integer.valueOf(0x200B));
        disallowed.add(Integer.valueOf(0x202F));
        disallowed.add(Integer.valueOf(0x205F));
        disallowed.add(Integer.valueOf(0x3000));
        addRange(disallowed, 0x0000, 0x001F);
        disallowed.add(Integer.valueOf(0x007F));
        addRange(disallowed, 0x0080, 0x009F);
        disallowed.add(Integer.valueOf(0x06DD));
        disallowed.add(Integer.valueOf(0x070F));
        disallowed.add(Integer.valueOf(0x180E));
        disallowed.add(Integer.valueOf(0x200C));
        disallowed.add(Integer.valueOf(0x200D));
        disallowed.add(Integer.valueOf(0x2028));
        disallowed.add(Integer.valueOf(0x2029));
        disallowed.add(Integer.valueOf(0x2060));
        disallowed.add(Integer.valueOf(0x2061));
        disallowed.add(Integer.valueOf(0x2062));
        disallowed.add(Integer.valueOf(0x2063));
        addRange(disallowed, 0x206A, 0x206F);
        disallowed.add(Integer.valueOf(0xFEFF));
        addRange(disallowed, 0xFFF9, 0xFFFC);
        addRange(disallowed, 0x1D173, 0x1D17A);
        addRange(disallowed, 0xFDD0, 0xFDEF);
        addRange(disallowed, 0xFFFE, 0xFFFF);
        addRange(disallowed, 0x1FFFE, 0x1FFFF);
        addRange(disallowed, 0x2FFFE, 0x2FFFF);
        addRange(disallowed, 0x3FFFE, 0x3FFFF);
        addRange(disallowed, 0x4FFFE, 0x4FFFF);
        addRange(disallowed, 0x5FFFE, 0x5FFFF);
        addRange(disallowed, 0x6FFFE, 0x6FFFF);
        addRange(disallowed, 0x7FFFE, 0x7FFFF);
        addRange(disallowed, 0x8FFFE, 0x8FFFF);
        addRange(disallowed, 0x9FFFE, 0x9FFFF);
        addRange(disallowed, 0xAFFFE, 0xAFFFF);
        addRange(disallowed, 0xBFFFE, 0xBFFFF);
        addRange(disallowed, 0xCFFFE, 0xCFFFF);
        addRange(disallowed, 0xDFFFE, 0xDFFFF);
        addRange(disallowed, 0xEFFFE, 0xEFFFF);
        addRange(disallowed, 0xFFFFE, 0xFFFFF);
        addRange(disallowed, 0x10FFFE, 0x10FFFF);
        disallowed.add(Integer.valueOf(0xFFF9));
        disallowed.add(Integer.valueOf(0xFFFA));
        disallowed.add(Integer.valueOf(0xFFFB));
        disallowed.add(Integer.valueOf(0xFFFC));
        disallowed.add(Integer.valueOf(0xFFFD));
        addRange(disallowed, 0x2FF0, 0x2FFB);
        disallowed.add(Integer.valueOf(0x0340));
        disallowed.add(Integer.valueOf(0x0341));
        disallowed.add(Integer.valueOf(0x200E));
        disallowed.add(Integer.valueOf(0x200F));
        disallowed.add(Integer.valueOf(0x202A));
        disallowed.add(Integer.valueOf(0x202B));
        disallowed.add(Integer.valueOf(0x202C));
        disallowed.add(Integer.valueOf(0x202D));
        disallowed.add(Integer.valueOf(0x202E));
        disallowed.add(Integer.valueOf(0x206A));
        disallowed.add(Integer.valueOf(0x206B));
        disallowed.add(Integer.valueOf(0x206C));
        disallowed.add(Integer.valueOf(0x206D));
        disallowed.add(Integer.valueOf(0x206E));
        disallowed.add(Integer.valueOf(0x206F));
        disallowed.add(Integer.valueOf(0xE0001));
        addRange(disallowed, 0xE0020, 0xE007F);
        SASL_PREP_DISALLOWED = Collections.unmodifiableSet(disallowed);
    }
    static private void addRange(final Set&lt;Integer&gt; codepoints,
            final int start, final int end) {
        for (int codepoint = start; codepoint &lt;= end; ++codepoint) {
            codepoints.add(Integer.valueOf(codepoint));
        }
    }
    private final CallbackHandler myCallbackHandler;
    private String myClientFirstMessageBare;
    private String myClientNonce;
    private int myIterationCount;
    private byte[] mySalt;
    private String myServerNonce;
    private String myServerSignature;
    private State myState;
    private String myUsername;
    public ScramSaslClient(final CallbackHandler callbackHandler) {
        myCallbackHandler = callbackHandler;
        dispose();
    }
    @Override
    public void dispose() {
        myClientFirstMessageBare = null;
        myClientNonce = null;
        myIterationCount = 0;
        mySalt = null;
        myServerNonce = null;
        myServerSignature = null;
        myUsername = null;
        myState = State.INITIAL;
    }
    @Override
    public byte[] evaluateChallenge(final byte[] challenge)
            throws SaslException {
        byte[] response = EMPTY_BYTES;
        switch (myState) {
        case INITIAL:
            response = createInitialMessage();
            myState = State.FIRST_SENT;
            break;
        case FIRST_SENT:
            response = createProof(challenge);
            myState = State.PROOF_SENT;
            break;
        case PROOF_SENT:
            evaluateFinalResult(challenge);
            myState = State.COMPLETE;
            break;
        default:
            throw new SaslException("No challenge expected in state " + myState);
        }
        return response;
    }
    @Override
    public String getMechanismName() {
        return MECHANISM;
    }
    @Override
    public Object getNegotiatedProperty(final String propName) {
        return null;
    }
    @Override
    public boolean hasInitialResponse() {
        return true;
    }
    @Override
    public boolean isComplete() {
        return myState == State.COMPLETE;
    }
    @Override
    public byte[] unwrap(final byte[] incoming, final int offset, final int len) {
        throw new IllegalStateException(MECHANISM
                + " does not support integrity and/or "
                + "privacy as the quality of protection.");
    }
    @Override
    public byte[] wrap(final byte[] outgoing, final int offset, final int len) {
        throw new IllegalStateException(MECHANISM
                + " does not support integrity and/or "
                + "privacy as the quality of protection.");
    }
    protected final byte[] createInitialMessage() throws SaslException {
        try {
            final NameCallback nameCallback = new NameCallback("Username?");
            myCallbackHandler.handle(new Callback[] { nameCallback });
            myUsername = nameCallback.getName();
            myClientNonce = createNonce();
            final StringBuilder buffer = new StringBuilder(GS2_HEADER);
            buffer.append("n=");
            buffer.append(saslName(myUsername));
            buffer.append(",r=");
            buffer.append(myClientNonce);
            myClientFirstMessageBare = buffer.substring(GS2_HEADER.length());
            return buffer.toString().getBytes(UTF_8);
        }
        catch (final UnsupportedCallbackException e) {
            throw new SaslException(e.getMessage(), e);
        }
        catch (final IOException e) {
            throw new SaslException(e.getMessage(), e);
        }
    }
    protected String createNonce() {
        final SecureRandom random = new SecureRandom();
        final byte[] nonce = new byte[RANDOM_BYTES];
        random.nextBytes(nonce);
        return IOUtils.toBase64(nonce);
    }
    protected final byte[] createProof(final byte[] challenge)
            throws SaslException {
        final String message = new String(challenge, UTF_8);
        try {
            final Map&lt;String, String&gt; content = parse(message);
            final String serverNonce = content.get("r");
            final String base64Salt = content.get("s");
            final String iterCountString = content.get("i");
            int iterationCount = 0;
            if (content.containsKey("m")) {
                throw new SaslException(
                        "The server required mandatory extension is not supported: m="
                                + content.get("m"));
            }
            else if (serverNonce == null) {
                throw new SaslException("Could not find the server's nonce: '"
                        + message + "'.");
            }
            else if (!serverNonce.startsWith(myClientNonce)) {
                throw new SaslException("The server's nonce '" + serverNonce
                        + "' must start with the client's nonce '"
                        + myClientNonce + "'.");
            }
            else if (base64Salt == null) {
                throw new SaslException("Could not find the server's salt: '"
                        + message + "'.");
            }
            else if ((base64Salt.length() % 4) != 0) {
                throw new SaslException(
                        "The server's salt is not a valid Base64 value: '"
                                + base64Salt + "'.");
            }
            else if (iterCountString == null) {
                throw new SaslException("Could not find the iteration count: '"
                        + message + "'.");
            }
            else {
                iterationCount = Integer.parseInt(iterCountString);
                if (iterationCount &lt;= 0) {
                    throw new SaslException("Iteration count " + iterationCount
                            + " must be a positive integer.");
                }
            }
            myServerNonce = serverNonce;
            mySalt = IOUtils.base64ToBytes(base64Salt);
            myIterationCount = iterationCount;
            final PasswordCallback passwordCallback = new PasswordCallback(
                    "Password", false);
            char[] password = EMPTY_CHARS;
            char[] passwordPrep = EMPTY_CHARS;
            ByteBuffer passwordBuffer = null;
            byte[] passwordBytes = EMPTY_BYTES;
            byte[] saltedPassword = EMPTY_BYTES;
            byte[] clientKey = EMPTY_BYTES;
            byte[] storedKey = EMPTY_BYTES;
            byte[] clientSignature = EMPTY_BYTES;
            byte[] clientProof = EMPTY_BYTES;
            byte[] serverKey = EMPTY_BYTES;
            try {
                myCallbackHandler.handle(new Callback[] { passwordCallback });
                password = passwordCallback.getPassword();
                passwordPrep = saslPrep(password);
                passwordBuffer = UTF_8.encode(CharBuffer.wrap(passwordPrep));
                passwordBytes = new byte[passwordBuffer.remaining()];
                passwordBuffer.get(passwordBytes);
                saltedPassword = generateSaltedPassword(passwordBytes);
                clientKey = computeHmac(saltedPassword, "Client Key");
                storedKey = MessageDigest.getInstance(DIGEST_NAME).digest(
                        clientKey);
                final String clientFinalMessageWithoutProof = "c="
                        + IOUtils.toBase64(GS2_HEADER.getBytes(ASCII)) + ",r="
                        + myServerNonce;
                final String authMessage = myClientFirstMessageBare + ","
                        + message + "," + clientFinalMessageWithoutProof;
                clientSignature = computeHmac(storedKey, authMessage);
                clientProof = clientKey.clone();
                for (int i = 0; i &lt; clientProof.length; i++) {
                    clientProof[i] ^= clientSignature[i];
                }
                serverKey = computeHmac(saltedPassword, "Server Key");
                myServerSignature = IOUtils.toBase64(computeHmac(serverKey,
                        authMessage));
                final String finalMessageWithProof = clientFinalMessageWithoutProof
                        + ",p=" + IOUtils.toBase64(clientProof);
                return finalMessageWithProof.getBytes(ASCII);
            }
            finally {
                passwordCallback.clearPassword();
                Arrays.fill(password, '\u0000');
                Arrays.fill(passwordPrep, '\u0000');
                if ((passwordBuffer != null) &amp;&amp; passwordBuffer.isReadOnly()) {
                    passwordBuffer.rewind();
                    passwordBuffer.limit(passwordBuffer.capacity());
                    while (passwordBuffer.hasRemaining()) {
                        passwordBuffer.put((byte) 0);
                    }
                }
                Arrays.fill(passwordBytes, (byte) 0);
                Arrays.fill(saltedPassword, (byte) 0);
                Arrays.fill(clientKey, (byte) 0);
                Arrays.fill(storedKey, (byte) 0);
                Arrays.fill(clientSignature, (byte) 0);
                Arrays.fill(clientProof, (byte) 0);
                Arrays.fill(serverKey, (byte) 0);
            }
        }
        catch (final IllegalArgumentException e) {
            throw new SaslException(e.getMessage(), e);
        }
        catch (final UnsupportedCallbackException e) {
            throw new SaslException(e.getMessage(), e);
        }
        catch (final IOException e) {
            throw new SaslException(e.getMessage(), e);
        }
        catch (final NoSuchAlgorithmException e) {
            throw new SaslException(e.getMessage(), e);
        }
    }
    protected final void evaluateFinalResult(final byte[] challenge)
            throws SaslException {
        final String message = new String(challenge, ASCII);
        final Map&lt;String, String&gt; content = parse(message);
        final String verifier = content.get("v");
        if (verifier == null) {
            throw new SaslException(
                    "The Server's final message did not contain a verifier: '"
                            + message + "'");
        }
        if (!verifier.equals(myServerSignature)) {
            throw new SaslException("The server's signature ('" + verifier
                    + "') does not match the expected signature: '"
                    + myServerSignature + "'.");
        }
    }
    protected String saslName(final String name) throws SaslException {
        final char[] prepared = saslPrep(name.toCharArray());
        final StringBuilder builder = new StringBuilder(prepared.length);
        for (final char c : prepared) {
            if (c == '=') {
                builder.append("=3D");
            }
            else if (c == ',') {
                builder.append("=2C");
            }
            else {
                builder.append(c);
            }
        }
        return builder.toString();
    }
    protected char[] saslPrep(final char[] text) throws SaslException {
        if (ASCII.newEncoder().canEncode(CharBuffer.wrap(text))) {
            saslPrepCheckProhibited(new String(text));
            return text;
        }
        final CharSequence mapped = saslPrepMap(text);
        final String nfkc = Normalizer.normalize(mapped, Normalizer.Form.NFKC);
        saslPrepCheckProhibited(nfkc);
        saslPrepCheckBidi(nfkc);
        saslPrepCheckUnassigned(nfkc);
        return nfkc.toCharArray();
    }
    private byte[] computeHmac(final byte[] keyBytes, final String string)
            throws SaslException {
        final Mac mac = initMac(keyBytes);
        return mac.doFinal(string.getBytes(ASCII));
    }
    private byte[] generateSaltedPassword(final byte[] passwordBytes)
            throws SaslException {
        final Mac mac = initMac(passwordBytes);
        mac.update(mySalt);
        mac.update(ONE_UINT32_BE);
        final byte[] result = mac.doFinal();
        byte[] previous = result;
        for (int i = 1; i &lt; myIterationCount; i++) {
            previous = mac.doFinal(previous);
            for (int x = 0; x &lt; result.length; x++) {
                result[x] ^= previous[x];
            }
        }
        return result;
    }
    private Mac initMac(final byte[] keyBytes) throws SaslException {
        try {
            final SecretKeySpec key = new SecretKeySpec(keyBytes, HMAC_NAME);
            final Mac mac = Mac.getInstance(HMAC_NAME);
            mac.init(key);
            return mac;
        }
        catch (final NoSuchAlgorithmException e) {
            throw new SaslException(e.getMessage(), e);
        }
        catch (final InvalidKeyException e) {
            throw new SaslException(e.getMessage(), e);
        }
    }
    private Map&lt;String, String&gt; parse(final String message)
            throws SaslException {
        final Map&lt;String, String&gt; results = new HashMap&lt;String, String&gt;();
        final StringTokenizer tokens = new StringTokenizer(message, ",");
        while (tokens.hasMoreTokens()) {
            final String token = tokens.nextToken();
            if ((token.length() &gt; 1) &amp;&amp; (token.charAt(1) == '=')) {
                results.put(token.substring(0, 1), token.substring(2));
            }
            else {
                throw new SaslException("Invalid field ('" + token
                        + "') in the message: '" + message + "'.");
            }
        }
        return results;
    }
    private void saslPrepCheckBidi(final String text) throws SaslException {
        final int length = text.length();
        int codePoint;
        if (!text.isEmpty()) {
            final int first = Character.codePointAt(text, 0);
            final int firstDir = Character.getDirectionality(first);
            if ((firstDir == Character.DIRECTIONALITY_RIGHT_TO_LEFT)
                    || (firstDir == Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC)) {
                int lastCodePoint = 0;
                int lastDir = 0;
                for (int i = 0; i &lt; length; i += Character
                        .charCount(lastCodePoint)) {
                    lastCodePoint = Character.codePointAt(text, i);
                    lastDir = Character.getDirectionality(lastCodePoint);
                    if (lastDir == Character.DIRECTIONALITY_LEFT_TO_RIGHT) {
                        throw new SaslException(
                                "SaslPrep does not allow mixing "
                                        + "left-to-right ("
                                        + String.valueOf(Character
                                                .toChars(lastCodePoint))
                                        + ") and right-to-left ("
                                        + String.valueOf(Character
                                                .toChars(first)) + ") text. "
                                        + "See RFC 4013 section 2.4.");
                    }
                }
                if ((lastDir != Character.DIRECTIONALITY_RIGHT_TO_LEFT)
                        &amp;&amp; (lastDir != Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC)) {
                    throw new SaslException(
                            "SaslPrep does not allow text with a leading "
                                    + "left-to-right character ("
                                    + String.valueOf(Character.toChars(first))
                                    + ") to not end with a non-left-to-right "
                                    + "character ("
                                    + String.valueOf(Character
                                            .toChars(lastCodePoint)) + "). "
                                    + "See RFC 4013 section 2.4.");
                }
            }
            else {
                for (int i = 0; i &lt; length; i += Character.charCount(codePoint)) {
                    codePoint = Character.codePointAt(text, i);
                    final int dir = Character.getDirectionality(codePoint);
                    if ((dir == Character.DIRECTIONALITY_RIGHT_TO_LEFT)
                            || (dir == Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC)) {
                        throw new SaslException(
                                "SaslPrep does not allow left-to-right ("
                                        + String.valueOf(Character
                                                .toChars(codePoint))
                                        + ") characters without an initial left-to-right "
                                        + "character. See RFC 4013 section 2.4.");
                    }
                }
            }
        }
    }
    private void saslPrepCheckProhibited(final String text)
            throws SaslException {
        final int length = text.length();
        int codePoint;
        for (int i = 0; i &lt; length; i += Character.charCount(codePoint)) {
            codePoint = Character.codePointAt(text, i);
            if (SASL_PREP_DISALLOWED.contains(Integer.valueOf(codePoint))
                    || ((0xE000 &lt;= codePoint) &amp;&amp; (codePoint &lt;= 0xF8FF))
                    || ((0xF0000 &lt;= codePoint) &amp;&amp; (codePoint &lt;= 0xFFFFD))
                    || ((0x100000 &lt;= codePoint) &amp;&amp; (codePoint &lt;= 0x10FFFD)) ||
                    ((0xD800 &lt;= codePoint) &amp;&amp; (codePoint &lt;= 0xDFFF))) {
                throw new SaslException("SaslPrep disallowed character '"
                        + String.valueOf(Character.toChars(codePoint))
                        + "' (0x" + Integer.toHexString(codePoint)
                        + "). See RFC 4013 section 2.3.");
            }
        }
    }
    private void saslPrepCheckUnassigned(final String text)
            throws SaslException {
        final int nfkcLength = text.length();
        int codePoint;
        for (int i = 0; i &lt; nfkcLength; i += Character.charCount(codePoint)) {
            codePoint = Character.codePointAt(text, i);
            final int type = Character.getType(codePoint);
            if (type == Character.UNASSIGNED) {
                throw new SaslException(
                        "SaslPrep does not allow unassigned unicode characters. "
                                + "See RFC 4013 section 2.5.");
            }
        }
    }
    private StringBuilder saslPrepMap(final char[] text) {
        final StringBuilder builder = new StringBuilder(text.length);
        for (final char c : text) {
            final String replacement = SASL_PREP_MAPPINGS.get(Character
                    .valueOf(c));
            if (replacement == null) {
                builder.append(c);
            }
            else {
                builder.append(replacement);
            }
        }
        return builder;
    }
    public static enum State {
        COMPLETE,
        FIRST_SENT,
        INITIAL,
        PROOF_SENT
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
