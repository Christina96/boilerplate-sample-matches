<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ObjectArraysTest.java & HashTestUtils_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ObjectArraysTest.java & HashTestUtils_1.java
      </h3>
      <h1 align="center">
        13.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ObjectArraysTest.java (26.27551%)<TH>HashTestUtils_1.java (9.423605%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#0',2,'match419833-1.html#0',3)" NAME="0">(149-156)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#0',2,'match419833-1.html#0',3)" NAME="0">(468-473)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#1',2,'match419833-1.html#1',3)" NAME="1">(216-228)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#1',2,'match419833-1.html#1',3)" NAME="1">(599-605)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#2',2,'match419833-1.html#2',3)" NAME="2">(122-128)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#2',2,'match419833-1.html#2',3)" NAME="2">(492-498)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#3',2,'match419833-1.html#3',3)" NAME="3">(51-58)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#3',2,'match419833-1.html#3',3)" NAME="3">(619-624)</A><TD ALIGN=center><FONT COLOR="#d70000">11</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#4',2,'match419833-1.html#4',3)" NAME="4">(59-64)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#4',2,'match419833-1.html#4',3)" NAME="4">(624-627)</A><TD ALIGN=center><FONT COLOR="#c40000">10</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#5',2,'match419833-1.html#5',3)" NAME="5">(145-148)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#5',2,'match419833-1.html#5',3)" NAME="5">(570-573)</A><TD ALIGN=center><FONT COLOR="#b00000">9</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#6',2,'match419833-1.html#6',3)" NAME="6">(111-115)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#6',2,'match419833-1.html#6',3)" NAME="6">(615-619)</A><TD ALIGN=center><FONT COLOR="#b00000">9</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#7',2,'match419833-1.html#7',3)" NAME="7">(103-107)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#7',2,'match419833-1.html#7',3)" NAME="7">(525-530)</A><TD ALIGN=center><FONT COLOR="#b00000">9</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#8',2,'match419833-1.html#8',3)" NAME="8">(96-100)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#8',2,'match419833-1.html#8',3)" NAME="8">(512-517)</A><TD ALIGN=center><FONT COLOR="#b00000">9</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match419833-0.html#9',2,'match419833-1.html#9',3)" NAME="9">(17-27)<TD><A HREF="javascript:ZweiFrames('match419833-0.html#9',2,'match419833-1.html#9',3)" NAME="9">(17-27)</A><TD ALIGN=center><FONT COLOR="#b00000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ObjectArraysTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="9"></A> * limitations under the License.
 */

<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match419833-1.html#9',3,'match419833-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.collect;

import static com.google.common.truth.Truth.assertThat;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.testing.NullPointerTester;
import java.io.Serializable;
import java.util.Arrays;
import java.util.List;
import</B></FONT> junit.framework.TestCase;

/**
 * Unit test for {@code ObjectArrays}.
 *
 * @author Kevin Bourrillion
 */
@GwtCompatible(emulated = true)
public class ObjectArraysTest extends TestCase {

  @GwtIncompatible // NullPointerTester
  public void testNullPointerExceptions() {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicStaticMethods(ObjectArrays.class);
  }

  @GwtIncompatible // ObjectArrays.newArray(Class, int)
  public void testNewArray_fromClass_Empty() {
    String[] empty = ObjectArrays.newArray(String.class, 0);
    assertEquals(String[].class, empty.getClass());
    assertThat(empty).isEmpty();
<A NAME="3"></A>  }

  @GwtIncompatible // ObjectArrays.newArray(Class, int)
  public void testNewArray_fromClass_Nonempty() <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match419833-1.html#3',3,'match419833-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    String[] array = ObjectArrays.newArray(String.class, 2);
    assertEquals(String[].class, array.getClass());
    assertThat(array).hasLength(2);
    assertNull(array[0]);
<A NAME="4"></A>  }

  @GwtIncompatible // ObjectArra</B></FONT>ys.newArray(Class, int)
  public void testNewArray_fromClass_OfArray() <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match419833-1.html#4',3,'match419833-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    String[][] array = ObjectArrays.newArray(String[].class, 1);
    assertEquals(String[][].class, array.getClass());
    assertThat(array).hasLength(1);
    assertNull(array[0]);
  }</B></FONT>

  public void testNewArray_fromArray_Empty() {
    String[] in = new String[0];
    String[] empty = ObjectArrays.newArray(in, 0);
    assertThat(empty).isEmpty();
  }

  public void testNewArray_fromArray_Nonempty() {
    String[] array = ObjectArrays.newArray(new String[0], 2);
    assertEquals(String[].class, array.getClass());
    assertThat(array).hasLength(2);
    assertNull(array[0]);
  }

  public void testNewArray_fromArray_OfArray() {
    String[][] array = ObjectArrays.newArray(new String[0][0], 1);
    assertEquals(String[][].class, array.getClass());
    assertThat(array).hasLength(1);
    assertNull(array[0]);
  }

  @GwtIncompatible // ObjectArrays.concat(Object[], Object[], Class)
  public void testConcatEmptyEmpty() {
    String[] result = ObjectArrays.concat(new String[0], new String[0], String.class);
    assertEquals(String[].class, result.getClass());
    assertThat(result).isEmpty();
  }

<A NAME="8"></A>  @GwtIncompatible // ObjectArrays.concat(Object[], Object[], Class)
  public void testConcatEmptyNonempty() {
    String[] result = ObjectArrays.concat(new String[0], new String[] {&quot;a&quot;, &quot;b&quot;}, String.class);
    <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match419833-1.html#8',3,'match419833-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly(&quot;a&quot;, &quot;b&quot;).inOrder();
  }

<A NAME="7"></A>  @GwtIncompatible // Obj</B></FONT>ectArrays.concat(Object[], Object[], Class)
  public void testConcatNonemptyEmpty() {
    String[] result = ObjectArrays.concat(new String[] {&quot;a&quot;, &quot;b&quot;}, new String[0], String.class);
    <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match419833-1.html#7',3,'match419833-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly(&quot;a&quot;, &quot;b&quot;).inOrder();
  }

  @GwtIncompatibl</B></FONT>e // ObjectArrays.concat(Object[], Object[], Class)
<A NAME="6"></A>  public void testConcatBasic() {
    String[] result =
        ObjectArrays.concat(new String[] {&quot;a&quot;, &quot;b&quot;}, new String[] {&quot;c&quot;, &quot;d&quot;}, String.class);
    <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match419833-1.html#6',3,'match419833-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;).inOrder();
  }

  @GwtIncompatible // ObjectArr</B></FONT>ays.concat(Object[], Object[], Class)
  public void testConcatWithMoreGeneralType() {
    Serializable[] result = ObjectArrays.concat(new String[0], new String[0], Serializable.class);
    assertEquals(Serializable[].class, result.getClass());
<A NAME="2"></A>  }

  public void testToArrayImpl1() {
    <FONT color="#980517"><A HREF="javascript:ZweiFrames('match419833-1.html#2',3,'match419833-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>doTestToArrayImpl1(Lists.&lt;Integer&gt;newArrayList());
    doTestToArrayImpl1(Lists.newArrayList(1));
    doTestToArrayImpl1(Lists.newArrayList(1, null, 3));
  }

  private void doTestToArrayImpl1(List&lt;Integer&gt; list) {
    Object[] reference = list.toArray()</B></FONT>;
    Object[] target = ObjectArrays.toArrayImpl(list);
    assertEquals(reference.getClass(), target.getClass());
    assertTrue(Arrays.equals(reference, target));
  }

  public void testToArrayImpl2() {
    doTestToArrayImpl2(Lists.&lt;Integer&gt;newArrayList(), new Integer[0], false);
    doTestToArrayImpl2(Lists.&lt;Integer&gt;newArrayList(), new Integer[1], true);

    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[0], false);
    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[1], true);
    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[] {2, 3}, true);

<A NAME="5"></A>    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[0], false);
    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[2], false);
    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[3], true);
  <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match419833-1.html#5',3,'match419833-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
<A NAME="0"></A>
  private void doTestToArrayImpl2(List&lt;Integer&gt; list, Integer[] array1, boolean expectModify) {
    Integer[] starting = Arrays.copyOf</B></FONT>(array1, array1.length);
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match419833-1.html#0',3,'match419833-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Integer[] array2 = Arrays.copyOf(array1, array1.length);
    Object[] reference = list.toArray(array1);

    Object[] target = ObjectArrays.toArrayImpl(list, array2);

    assertEquals(reference.getClass(), target.getClass());
    assertTrue(Arrays.equals(reference, target));
    assertTrue(Arrays.equals</B></FONT>(reference, target));

    Object[] expectedArray1 = expectModify ? reference : starting;
    Object[] expectedArray2 = expectModify ? target : starting;
    assertTrue(Arrays.equals(expectedArray1, array1));
    assertTrue(Arrays.equals(expectedArray2, array2));
  }

  public void testPrependZeroElements() {
    String[] result = ObjectArrays.concat(&quot;foo&quot;, new String[] {});
    assertThat(result).asList().contains(&quot;foo&quot;);
  }

  public void testPrependOneElement() {
    String[] result = ObjectArrays.concat(&quot;foo&quot;, new String[] {&quot;bar&quot;});
    assertThat(result).asList().containsExactly(&quot;foo&quot;, &quot;bar&quot;).inOrder();
  }

  public void testPrependTwoElements() {
    String[] result = ObjectArrays.concat(&quot;foo&quot;, new String[] {&quot;bar&quot;, &quot;baz&quot;});
    assertThat(result).asList().containsExactly(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;).inOrder();
  }

  public void testAppendZeroElements() {
    String[] result = ObjectArrays.concat(new String[] {}, &quot;foo&quot;);
    assertThat(result).asList().contains(&quot;foo&quot;);
  }

  public void testAppendOneElement() {
    String[] result = ObjectArrays.concat(new String[] {&quot;foo&quot;}, &quot;bar&quot;);
    assertThat(result).asList().containsExactly(&quot;foo&quot;, &quot;bar&quot;).inOrder();
  }

  public void testAppendTwoElements() {
    String[] result = ObjectArrays.concat(new String[] {&quot;foo&quot;, &quot;bar&quot;}, &quot;baz&quot;);
    assertThat(result).asList().containsExactly(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;).inOrder();
  }

  public void testEmptyArrayToEmpty() {
    doTestNewArrayEquals(new Object[0], 0);
  }

  public void testEmptyArrayToNonEmpty() {
    checkArrayEquals(new Long[5], ObjectArrays.newArray(new Long[0], 5));
  }

  public void testNonEmptyToShorter() {
    checkArrayEquals(new String[9], ObjectArrays.newArray(new String[10], 9));
  }

  public void testNonEmptyToSameLength() {
    doTestNewArrayEquals(new String[10], 10);
  }

  public void testNonEmptyToLonger() {
    checkArrayEquals(
        new String[10], ObjectArrays.newArray(new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;}, 10));
<A NAME="1"></A>  }

  private static void checkArrayEquals(Object[] expected, Object[] actual) {
    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match419833-1.html#1',3,'match419833-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertTrue(
        &quot;expected(&quot;
            + expected.getClass()
            + &quot;): &quot;
            + Arrays.toString(expected)
            + &quot; actual(&quot;
            + actual.getClass()
            + &quot;): &quot;
            + Arrays.toString(actual),
        arrayEquals(expected, actual));
  }

  private static boolean arrayEquals(Object[] array1, Object[] array2) {</B></FONT>
    assertSame(array1.getClass(), array2.getClass());
    return Arrays.equals(array1, array2);
  }

  private static void doTestNewArrayEquals(Object[] expected, int length) {
    checkArrayEquals(expected, ObjectArrays.newArray(expected, length));
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HashTestUtils_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="9"></A> * limitations under the License.
 */

<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#9',2,'match419833-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.hash;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

import com.google.common.base.Charsets;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.google.common.primitives.Ints;
import com.google.common.testing.EqualsTester;
import</B></FONT> java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.Random;
import java.util.Set;
import org.junit.Assert;

/**
 * Various utilities for testing {@link HashFunction}s.
 *
 * @author Dimitris Andreou
 * @author Kurt Alfred Kluever
 */
final class HashTestUtils {
  private HashTestUtils() {}

  /** Converts a string, which should contain only ascii-representable characters, to a byte[]. */
  static byte[] ascii(String string) {
    byte[] bytes = new byte[string.length()];
    for (int i = 0; i &lt; string.length(); i++) {
      bytes[i] = (byte) string.charAt(i);
    }
    return bytes;
  }

  interface HashFn {
    byte[] hash(byte[] input, int seed);
  }

  static void verifyHashFunction(HashFn hashFunction, int hashbits, int expected) {
    int hashBytes = hashbits / 8;

    byte[] key = new byte[256];
    byte[] hashes = new byte[hashBytes * 256];

    // Hash keys of the form {}, {0}, {0,1}, {0,1,2}... up to N=255,using 256-N as the seed
    for (int i = 0; i &lt; 256; i++) {
      key[i] = (byte) i;
      int seed = 256 - i;
      byte[] hash = hashFunction.hash(Arrays.copyOf(key, i), seed);
      System.arraycopy(hash, 0, hashes, i * hashBytes, hash.length);
    }

    // Then hash the result array
    byte[] result = hashFunction.hash(hashes, 0);

    // interpreted in little-endian order.
    int verification = Integer.reverseBytes(Ints.fromByteArray(result));

    if (expected != verification) {
      throw new AssertionError(
          &quot;Expected: &quot;
              + Integer.toHexString(expected)
              + &quot; got: &quot;
              + Integer.toHexString(verification));
    }
  }

  static final Funnel&lt;Object&gt; BAD_FUNNEL =
      new Funnel&lt;Object&gt;() {
        @Override
        public void funnel(Object object, PrimitiveSink bytePrimitiveSink) {
          bytePrimitiveSink.putInt(object.hashCode());
        }
      };

  enum RandomHasherAction {
    PUT_BOOLEAN() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        boolean value = random.nextBoolean();
        for (PrimitiveSink sink : sinks) {
          sink.putBoolean(value);
        }
      }
    },
    PUT_BYTE() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        int value = random.nextInt();
        for (PrimitiveSink sink : sinks) {
          sink.putByte((byte) value);
        }
      }
    },
    PUT_SHORT() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        short value = (short) random.nextInt();
        for (PrimitiveSink sink : sinks) {
          sink.putShort(value);
        }
      }
    },
    PUT_CHAR() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        char value = (char) random.nextInt();
        for (PrimitiveSink sink : sinks) {
          sink.putChar(value);
        }
      }
    },
    PUT_INT() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        int value = random.nextInt();
        for (PrimitiveSink sink : sinks) {
          sink.putInt(value);
        }
      }
    },
    PUT_LONG() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        long value = random.nextLong();
        for (PrimitiveSink sink : sinks) {
          sink.putLong(value);
        }
      }
    },
    PUT_FLOAT() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        float value = random.nextFloat();
        for (PrimitiveSink sink : sinks) {
          sink.putFloat(value);
        }
      }
    },
    PUT_DOUBLE() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        double value = random.nextDouble();
        for (PrimitiveSink sink : sinks) {
          sink.putDouble(value);
        }
      }
    },
    PUT_BYTES() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        byte[] value = new byte[random.nextInt(128)];
        random.nextBytes(value);
        for (PrimitiveSink sink : sinks) {
          sink.putBytes(value);
        }
      }
    },
    PUT_BYTES_INT_INT() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        byte[] value = new byte[random.nextInt(128)];
        random.nextBytes(value);
        int off = random.nextInt(value.length + 1);
        int len = random.nextInt(value.length - off + 1);
        for (PrimitiveSink sink : sinks) {
          sink.putBytes(value, off, len);
        }
      }
    },
    PUT_BYTE_BUFFER() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        byte[] value = new byte[random.nextInt(128)];
        random.nextBytes(value);
        int pos = random.nextInt(value.length + 1);
        int limit = pos + random.nextInt(value.length - pos + 1);
        for (PrimitiveSink sink : sinks) {
          ByteBuffer buffer = ByteBuffer.wrap(value);
          Java8Compatibility.position(buffer, pos);
          Java8Compatibility.limit(buffer, limit);
          sink.putBytes(buffer);
          assertEquals(limit, buffer.limit());
          assertEquals(limit, buffer.position());
        }
      }
    },
    PUT_STRING() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        char[] value = new char[random.nextInt(128)];
        for (int i = 0; i &lt; value.length; i++) {
          value[i] = (char) random.nextInt();
        }
        String s = new String(value);
        for (PrimitiveSink sink : sinks) {
          sink.putUnencodedChars(s);
        }
      }
    },
    PUT_STRING_LOW_SURROGATE() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        String s = new String(new char[] {randomLowSurrogate(random)});
        for (PrimitiveSink sink : sinks) {
          sink.putUnencodedChars(s);
        }
      }
    },
    PUT_STRING_HIGH_SURROGATE() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        String s = new String(new char[] {randomHighSurrogate(random)});
        for (PrimitiveSink sink : sinks) {
          sink.putUnencodedChars(s);
        }
      }
    },
    PUT_STRING_LOW_HIGH_SURROGATE() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        String s = new String(new char[] {randomLowSurrogate(random), randomHighSurrogate(random)});
        for (PrimitiveSink sink : sinks) {
          sink.putUnencodedChars(s);
        }
      }
    },
    PUT_STRING_HIGH_LOW_SURROGATE() {
      @Override
      void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks) {
        String s = new String(new char[] {randomHighSurrogate(random), randomLowSurrogate(random)});
        for (PrimitiveSink sink : sinks) {
          sink.putUnencodedChars(s);
        }
      }
    };

    abstract void performAction(Random random, Iterable&lt;? extends PrimitiveSink&gt; sinks);

    private static final RandomHasherAction[] actions = values();

    static RandomHasherAction pickAtRandom(Random random) {
      return actions[random.nextInt(actions.length)];
    }
  }

  /**
   * Test that the hash function contains no funnels. A funnel is a situation where a set of input
   * (key) bits 'affects' a strictly smaller set of output bits. Funneling is bad because it can
   * result in more-than-ideal collisions for a non-uniformly distributed key space. In practice,
   * most key spaces are ANYTHING BUT uniformly distributed. A bit(i) in the input is said to
   * 'affect' a bit(j) in the output if two inputs, identical but for bit(i), will differ at output
   * bit(j) about half the time
   *
   * &lt;p&gt;Funneling is pretty simple to detect. The key idea is to find example keys which
   * unequivocally demonstrate that funneling cannot be occurring. This is done bit-by-bit. For each
   * input bit(i) and output bit(j), two pairs of keys must be found with all bits identical except
   * bit(i). One pair must differ in output bit(j), and one pair must not. This proves that input
   * bit(i) can alter output bit(j).
   */
  static void checkNoFunnels(HashFunction function) {
    Random rand = new Random(0);
    int keyBits = 32;
    int hashBits = function.bits();

    // output loop tests input bit
    for (int i = 0; i &lt; keyBits; i++) {
      int same = 0x0; // bitset for output bits with same values
      int diff = 0x0; // bitset for output bits with different values
      int count = 0;
      // originally was 2 * Math.log(...), making it try more times to avoid flakiness issues
      int maxCount = (int) (4 * Math.log(2 * keyBits * hashBits) + 1);
      while (same != 0xffffffff || diff != 0xffffffff) {
        int key1 = rand.nextInt();
        // flip input bit for key2
        int key2 = key1 ^ (1 &lt;&lt; i);
        // get hashes
        int hash1 = function.hashInt(key1).asInt();
        int hash2 = function.hashInt(key2).asInt();
        // test whether the hash values have same output bits
        same |= ~(hash1 ^ hash2);
        // test whether the hash values have different output bits
        diff |= (hash1 ^ hash2);

        count++;
        // check whether we've exceeded the probabilistically
        // likely number of trials to have proven no funneling
        if (count &gt; maxCount) {
          Assert.fail(
              &quot;input bit(&quot;
                  + i
                  + &quot;) was found not to affect all &quot;
                  + hashBits
                  + &quot; output bits; The unaffected bits are &quot;
                  + &quot;as follows: &quot;
                  + ~(same &amp; diff)
                  + &quot;. This was &quot;
                  + &quot;determined after &quot;
                  + count
                  + &quot; trials.&quot;);
        }
      }
    }
  }

  /**
   * Test for avalanche. Avalanche means that output bits differ with roughly 1/2 probability on
   * different input keys. This test verifies that each possible 1-bit key delta achieves avalanche.
   *
   * &lt;p&gt;For more information: http://burtleburtle.net/bob/hash/avalanche.html
   */
  static void checkAvalanche(HashFunction function, int trials, double epsilon) {
    Random rand = new Random(0);
    int keyBits = 32;
    int hashBits = function.bits();
    for (int i = 0; i &lt; keyBits; i++) {
      int[] same = new int[hashBits];
      int[] diff = new int[hashBits];
      // go through trials to compute probability
      for (int j = 0; j &lt; trials; j++) {
        int key1 = rand.nextInt();
        // flip input bit for key2
        int key2 = key1 ^ (1 &lt;&lt; i);
        // compute hash values
        int hash1 = function.hashInt(key1).asInt();
        int hash2 = function.hashInt(key2).asInt();
        for (int k = 0; k &lt; hashBits; k++) {
          if ((hash1 &amp; (1 &lt;&lt; k)) == (hash2 &amp; (1 &lt;&lt; k))) {
            same[k] += 1;
          } else {
            diff[k] += 1;
          }
        }
      }
      // measure probability and assert it's within margin of error
      for (int j = 0; j &lt; hashBits; j++) {
        double prob = (double) diff[j] / (double) (diff[j] + same[j]);
        Assert.assertEquals(0.50d, prob, epsilon);
      }
    }
  }

  /**
   * Test for 2-bit characteristics. A characteristic is a delta in the input which is repeated in
   * the output. For example, if f() is a block cipher and c is a characteristic, then f(x^c) =
   * f(x)^c with greater than expected probability. The test for funneling is merely a test for
   * 1-bit characteristics.
   *
   * &lt;p&gt;There is more general code provided by Bob Jenkins to test arbitrarily sized characteristics
   * using the magic of gaussian elimination: http://burtleburtle.net/bob/crypto/findingc.html.
   */
  static void checkNo2BitCharacteristics(HashFunction function) {
    Random rand = new Random(0);
    int keyBits = 32;

    // get every one of (keyBits choose 2) deltas:
    for (int i = 0; i &lt; keyBits; i++) {
      for (int j = 0; j &lt; keyBits; j++) {
        if (j &lt;= i) continue;
        int count = 0;
        int maxCount = 20; // the probability of error here is miniscule
        boolean diff = false;

        while (!diff) {
          int delta = (1 &lt;&lt; i) | (1 &lt;&lt; j);
          int key1 = rand.nextInt();
          // apply delta
          int key2 = key1 ^ delta;

          // get hashes
          int hash1 = function.hashInt(key1).asInt();
          int hash2 = function.hashInt(key2).asInt();

          // this 2-bit candidate delta is not a characteristic
          // if deltas are different
          if ((hash1 ^ hash2) != delta) {
            diff = true;
            continue;
          }

          // check if we've exceeded the probabilistically
          // likely number of trials to have proven 2-bit candidate
          // is not a characteristic
          count++;
          if (count &gt; maxCount) {
            Assert.fail(
                &quot;2-bit delta (&quot;
                    + i
                    + &quot;, &quot;
                    + j
                    + &quot;) is likely a &quot;
                    + &quot;characteristic for this hash. This was &quot;
                    + &quot;determined after &quot;
                    + count
                    + &quot; trials&quot;);
          }
        }
      }
    }
  }

  /**
   * Test for avalanche with 2-bit deltas. Most probabilities of output bit(j) differing are well
   * within 50%.
   */
  static void check2BitAvalanche(HashFunction function, int trials, double epsilon) {
    Random rand = new Random(0);
    int keyBits = 32;
    int hashBits = function.bits();
    for (int bit1 = 0; bit1 &lt; keyBits; bit1++) {
      for (int bit2 = 0; bit2 &lt; keyBits; bit2++) {
        if (bit2 &lt;= bit1) continue;
        int delta = (1 &lt;&lt; bit1) | (1 &lt;&lt; bit2);
        int[] same = new int[hashBits];
        int[] diff = new int[hashBits];
        // go through trials to compute probability
        for (int j = 0; j &lt; trials; j++) {
          int key1 = rand.nextInt();
          // flip input bit for key2
          int key2 = key1 ^ delta;
          // compute hash values
          int hash1 = function.hashInt(key1).asInt();
          int hash2 = function.hashInt(key2).asInt();
          for (int k = 0; k &lt; hashBits; k++) {
            if ((hash1 &amp; (1 &lt;&lt; k)) == (hash2 &amp; (1 &lt;&lt; k))) {
              same[k] += 1;
            } else {
              diff[k] += 1;
            }
          }
        }
        // measure probability and assert it's within margin of error
        for (int j = 0; j &lt; hashBits; j++) {
          double prob = (double) diff[j] / (double) (diff[j] + same[j]);
          Assert.assertEquals(0.50d, prob, epsilon);
        }
      }
    }
  }

  /**
   * Checks that a Hasher returns the same HashCode when given the same input, and also that the
   * collision rate looks sane.
   */
  static void assertInvariants(HashFunction hashFunction) {
    int objects = 100;
<A NAME="0"></A>    Set&lt;HashCode&gt; hashcodes = Sets.newHashSetWithExpectedSize(objects);
    Random random = new Random(314159);
    for (int i = 0; i &lt; objects; i++) {
      <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#0',2,'match419833-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int value = random.nextInt();
      HashCode hashcode1 = hashFunction.hashInt(value);
      HashCode hashcode2 = hashFunction.hashInt(value);
      Assert.assertEquals(hashcode1, hashcode2); // idempotent
      Assert.assertEquals(hashFunction.bits(), hashcode1.bits());
      Assert.assertEquals(hashFunction.bits(), hashcode1.asBytes</B></FONT>().length * 8);
      hashcodes.add(hashcode1);
    }
    Assert.assertTrue(hashcodes.size() &gt; objects * 0.95); // quite relaxed test

    assertHashBytesThrowsCorrectExceptions(hashFunction);
    assertIndependentHashers(hashFunction);
    assertShortcutsAreEquivalent(hashFunction, 512);
  }

  static void assertHashByteBufferInvariants(HashFunction hashFunction) {
    assertHashByteBufferMatchesBytes(hashFunction);
    assertHashByteBufferExhaustsBuffer(hashFunction);
    assertHashByteBufferPreservesByteOrder(hashFunction);
    assertHasherByteBufferPreservesByteOrder(hashFunction);
  }
<A NAME="2"></A>
  static void assertHashByteBufferMatchesBytes(HashFunction hashFunction) {
    Random rng = new Random(0L);
    byte[] bytes = new byte[<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#2',2,'match419833-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>rng.nextInt(256) + 1];
    rng.nextBytes(bytes);
    assertEquals(hashFunction.hashBytes(bytes), hashFunction.hashBytes(ByteBuffer.wrap(bytes)));
  }

  static void assertHashByteBufferExhaustsBuffer(HashFunction hashFunction) {
    Random rng = new Random(0L)</B></FONT>;
    byte[] bytes = new byte[rng.nextInt(256) + 1];
    rng.nextBytes(bytes);
    ByteBuffer buffer = ByteBuffer.wrap(bytes);
    HashCode unused = hashFunction.hashBytes(buffer);
    assertFalse(buffer.hasRemaining());
  }

  static void assertHashByteBufferPreservesByteOrder(HashFunction hashFunction) {
    Random rng = new Random(0L);
    byte[] bytes = new byte[rng.nextInt(256) + 1];
<A NAME="8"></A>    rng.nextBytes(bytes);
    ByteBuffer littleEndian = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);
    ByteBuffer bigEndian = ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN);
    assertEquals(<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#8',2,'match419833-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>hashFunction.hashBytes(littleEndian), hashFunction.hashBytes(bigEndian));
    assertEquals(ByteOrder.LITTLE_ENDIAN, littleEndian.order());
    assertEquals(ByteOrder.BIG_ENDIAN, bigEndian.order());
  }

  static void assertHasherByteBufferPreser</B></FONT>vesByteOrder(HashFunction hashFunction) {
    Random rng = new Random(0L);
    byte[] bytes = new byte[rng.nextInt(256) + 1];
    rng.nextBytes(bytes);
    ByteBuffer littleEndian = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);
<A NAME="7"></A>    ByteBuffer bigEndian = ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN);
    assertEquals(
        hashFunction.newHasher().putBytes(littleEndian).hash(),
        <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#7',2,'match419833-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>hashFunction.newHasher().putBytes(bigEndian).hash());
    assertEquals(ByteOrder.LITTLE_ENDIAN, littleEndian.order());
    assertEquals(ByteOrder.BIG_ENDIAN, bigEndian.order());
  }

  static void assertHashBytesThrowsCorre</B></FONT>ctExceptions(HashFunction hashFunction) {
    {
      HashCode unused = hashFunction.hashBytes(new byte[64], 0, 0);
    }

    try {
      hashFunction.hashBytes(new byte[128], -1, 128);
      Assert.fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      hashFunction.hashBytes(new byte[128], 64, 256 /* too long len */);
      Assert.fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      hashFunction.hashBytes(new byte[64], 0, -1);
      Assert.fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }

  static void assertIndependentHashers(HashFunction hashFunction) {
    int numActions = 100;
    // hashcodes from non-overlapping hash computations
    HashCode expected1 = randomHash(hashFunction, new Random(1L), numActions);
    HashCode expected2 = randomHash(hashFunction, new Random(2L), numActions);

    // equivalent, but overlapping, computations (should produce the same results as above)
    Random random1 = new Random(1L);
    Random random2 = new Random(2L);
    Hasher hasher1 = hashFunction.newHasher();
    Hasher hasher2 = hashFunction.newHasher();
    for (int i = 0; i &lt; numActions; i++) {
      RandomHasherAction.pickAtRandom(random1).performAction(random1, ImmutableSet.of(hasher1));
      RandomHasherAction.pickAtRandom(random2).performAction(random2, ImmutableSet.of(hasher2));
    }
<A NAME="5"></A>
    Assert.assertEquals(expected1, hasher1.hash());
    Assert.assertEquals(expected2, hasher2.hash());
  <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#5',2,'match419833-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  static HashCode randomHash(HashFunction hashFunction, Random random, int numActions) {
    Hasher hasher = hashFunction.newHasher</B></FONT>();
    for (int i = 0; i &lt; numActions; i++) {
      RandomHasherAction.pickAtRandom(random).performAction(random, ImmutableSet.of(hasher));
    }
    return hasher.hash();
  }

  private static void assertShortcutsAreEquivalent(HashFunction hashFunction, int trials) {
    Random random = new Random(42085L);
    for (int i = 0; i &lt; trials; i++) {
      assertHashBytesEquivalence(hashFunction, random);
      assertHashByteBufferEquivalence(hashFunction, random);
      assertHashIntEquivalence(hashFunction, random);
      assertHashLongEquivalence(hashFunction, random);
      assertHashStringEquivalence(hashFunction, random);
      assertHashStringWithSurrogatesEquivalence(hashFunction, random);
    }
  }

  private static void assertHashBytesEquivalence(HashFunction hashFunction, Random random) {
    int size = random.nextInt(2048);
    byte[] bytes = new byte[size];
    random.nextBytes(bytes);
<A NAME="1"></A>    assertEquals(
        hashFunction.hashBytes(bytes), hashFunction.newHasher(size).putBytes(bytes).hash());
    int off = random.nextInt(size);
    int len = <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#1',2,'match419833-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>random.nextInt(size - off);
    assertEquals(
        hashFunction.hashBytes(bytes, off, len),
        hashFunction.newHasher(size).putBytes(bytes, off, len).hash());
  }

  private static void assertHashByteBufferEquivalence(HashFunction hashFunction, Random random) {</B></FONT>
    int size = random.nextInt(2048);
    byte[] bytes = new byte[size];
    random.nextBytes(bytes);
    assertEquals(
        hashFunction.hashBytes(ByteBuffer.wrap(bytes)),
        hashFunction.newHasher(size).putBytes(ByteBuffer.wrap(bytes)).hash());
<A NAME="6"></A>    int off = random.nextInt(size);
    int len = random.nextInt(size - off);
    assertEquals(
        <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#6',2,'match419833-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>hashFunction.hashBytes(ByteBuffer.wrap(bytes, off, len)),
<A NAME="3"></A>        hashFunction.newHasher(size).putBytes(ByteBuffer.wrap(bytes, off, len)).hash());
  }

  private static void asse</B></FONT>rtHashIntEquivalence(HashFunction hashFunction, Random random) <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#3',2,'match419833-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    int i = random.nextInt();
<A NAME="4"></A>    assertEquals(hashFunction.hashInt(i), hashFunction.newHasher().putInt(i).hash());
  }

  private static void asser</B></FONT>tHashLongEquivalence(HashFunction hashFunction, Random random) <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match419833-0.html#4',2,'match419833-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    long l = random.nextLong();
    assertEquals(hashFunction.hashLong(l), hashFunction.newHasher().putLong(l).hash());
  }</B></FONT>

  private static final ImmutableSet&lt;Charset&gt; CHARSETS =
      ImmutableSet.of(
          Charsets.ISO_8859_1,
          Charsets.US_ASCII,
          Charsets.UTF_16,
          Charsets.UTF_16BE,
          Charsets.UTF_16LE,
          Charsets.UTF_8);

  private static void assertHashStringEquivalence(HashFunction hashFunction, Random random) {
    // Test that only data and data-order is important, not the individual operations.
    new EqualsTester()
        .addEqualityGroup(
            hashFunction.hashUnencodedChars(&quot;abc&quot;),
            hashFunction.newHasher().putUnencodedChars(&quot;abc&quot;).hash(),
            hashFunction.newHasher().putUnencodedChars(&quot;ab&quot;).putUnencodedChars(&quot;c&quot;).hash(),
            hashFunction.newHasher().putUnencodedChars(&quot;a&quot;).putUnencodedChars(&quot;bc&quot;).hash(),
            hashFunction
                .newHasher()
                .putUnencodedChars(&quot;a&quot;)
                .putUnencodedChars(&quot;b&quot;)
                .putUnencodedChars(&quot;c&quot;)
                .hash(),
            hashFunction.newHasher().putChar('a').putUnencodedChars(&quot;bc&quot;).hash(),
            hashFunction.newHasher().putUnencodedChars(&quot;ab&quot;).putChar('c').hash(),
            hashFunction.newHasher().putChar('a').putChar('b').putChar('c').hash())
        .testEquals();

    int size = random.nextInt(2048);
    byte[] bytes = new byte[size];
    random.nextBytes(bytes);
    String string = new String(bytes, Charsets.US_ASCII);
    assertEquals(
        hashFunction.hashUnencodedChars(string),
        hashFunction.newHasher().putUnencodedChars(string).hash());
    for (Charset charset : CHARSETS) {
      assertEquals(
          hashFunction.hashString(string, charset),
          hashFunction.newHasher().putString(string, charset).hash());
    }
  }

  /**
   * This verifies that putUnencodedChars(String) and hashUnencodedChars(String) are equivalent,
   * even for funny strings composed by (possibly unmatched, and mostly illegal) surrogate
   * characters. (But doesn't test that they do the right thing - just their consistency).
   */
  private static void assertHashStringWithSurrogatesEquivalence(
      HashFunction hashFunction, Random random) {
    int size = random.nextInt(8) + 1;
    char[] chars = new char[size];
    for (int i = 0; i &lt; chars.length; i++) {
      chars[i] = random.nextBoolean() ? randomLowSurrogate(random) : randomHighSurrogate(random);
    }
    String string = new String(chars);
    assertEquals(
        hashFunction.hashUnencodedChars(string),
        hashFunction.newHasher().putUnencodedChars(string).hash());
  }

  static char randomLowSurrogate(Random random) {
    return (char)
        (Character.MIN_LOW_SURROGATE
            + random.nextInt(Character.MAX_LOW_SURROGATE - Character.MIN_LOW_SURROGATE + 1));
  }

  static char randomHighSurrogate(Random random) {
    return (char)
        (Character.MIN_HIGH_SURROGATE
            + random.nextInt(Character.MAX_HIGH_SURROGATE - Character.MIN_HIGH_SURROGATE + 1));
  }
}
</PRE>
</div>
  </div>
</body>
</html>
