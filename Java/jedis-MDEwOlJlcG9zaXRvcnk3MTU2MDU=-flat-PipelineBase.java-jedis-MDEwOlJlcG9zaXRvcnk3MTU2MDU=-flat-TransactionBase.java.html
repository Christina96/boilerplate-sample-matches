
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 34, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-PipelineBase.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import java.io.Closeable;
3  import java.util.List;
4  import java.util.Map;
5  import java.util.Set;
6  import org.json.JSONArray;
7  import redis.clients.jedis.args.*;
8  import redis.clients.jedis.bloom.*;
9  import redis.clients.jedis.commands.PipelineBinaryCommands;
10  import redis.clients.jedis.commands.PipelineCommands;
11  import redis.clients.jedis.commands.ProtocolCommand;
12  import redis.clients.jedis.commands.RedisModulePipelineCommands;
13  import redis.clients.jedis.graph.GraphCommandObjects;
14  import redis.clients.jedis.graph.ResultSet;
15  import redis.clients.jedis.json.JsonSetParams;
16  import redis.clients.jedis.json.Path;
17  import redis.clients.jedis.json.Path2;
18  import redis.clients.jedis.json.JsonObjectMapper;
19  import redis.clients.jedis.params.*;
20  import redis.clients.jedis.resps.*;
21  import redis.clients.jedis.search.*;
22  import redis.clients.jedis.search.aggr.AggregationBuilder;
23  import redis.clients.jedis.search.aggr.AggregationResult;
24  import redis.clients.jedis.search.schemafields.SchemaField;
25  import redis.clients.jedis.timeseries.*;
26  import redis.clients.jedis.util.KeyValue;
27  public abstract class PipelineBase implements PipelineCommands, PipelineBinaryCommands,
28      RedisModulePipelineCommands, Closeable {
29    protected final CommandObjects commandObjects;
30    private GraphCommandObjects graphCommandObjects;
31    public PipelineBase(CommandObjects commandObjects) {
32      this.commandObjects = commandObjects;
33    }
34    protected final void setGraphCommands(GraphCommandObjects graphCommandObjects) {
35      this.graphCommandObjects = graphCommandObjects;
36    }
37    protected abstract <T> Response<T> appendCommand(CommandObject<T> commandObject);
38    @Override
39    public abstract void close();
40    public abstract void sync();
41    @Override
42    public Response<Boolean> exists(String key) {
43      return appendCommand(commandObjects.exists(key));
44    }
45    @Override
46    public Response<Long> exists(String... keys) {
47      return appendCommand(commandObjects.exists(keys));
48    }
49    @Override
50    public Response<Long> persist(String key) {
51      return appendCommand(commandObjects.persist(key));
52    }
53    @Override
54    public Response<String> type(String key) {
55      return appendCommand(commandObjects.type(key));
56    }
57    @Override
58    public Response<byte[]> dump(String key) {
59      return appendCommand(commandObjects.dump(key));
60    }
61    @Override
62    public Response<String> restore(String key, long ttl, byte[] serializedValue) {
63      return appendCommand(commandObjects.restore(key, ttl, serializedValue));
64    }
65    @Override
66    public Response<String> restore(String key, long ttl, byte[] serializedValue, RestoreParams params) {
67      return appendCommand(commandObjects.restore(key, ttl, serializedValue, params));
68    }
69    @Override
70    public Response<Long> expire(String key, long seconds) {
71      return appendCommand(commandObjects.expire(key, seconds));
72    }
73    @Override
74    public Response<Long> expire(String key, long seconds, ExpiryOption expiryOption) {
75      return appendCommand(commandObjects.expire(key, seconds, expiryOption));
76    }
77    @Override
78    public Response<Long> pexpire(String key, long milliseconds) {
79      return appendCommand(commandObjects.pexpire(key, milliseconds));
80    }
81    @Override
82    public Response<Long> pexpire(String key, long milliseconds, ExpiryOption expiryOption) {
83      return appendCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
84    }
85    @Override
86    public Response<Long> expireTime(String key) {
87      return appendCommand(commandObjects.expireTime(key));
88    }
89    @Override
90    public Response<Long> pexpireTime(String key) {
91      return appendCommand(commandObjects.pexpireTime(key));
92    }
93    @Override
94    public Response<Long> expireAt(String key, long unixTime) {
95      return appendCommand(commandObjects.expireAt(key, unixTime));
96    }
97    @Override
98    public Response<Long> expireAt(String key, long unixTime, ExpiryOption expiryOption) {
99      return appendCommand(commandObjects.expireAt(key, unixTime, expiryOption));
100    }
101    @Override
102    public Response<Long> pexpireAt(String key, long millisecondsTimestamp) {
103      return appendCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
104    }
105    @Override
106    public Response<Long> pexpireAt(String key, long millisecondsTimestamp, ExpiryOption expiryOption) {
107      return appendCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
108    }
109    @Override
110    public Response<Long> ttl(String key) {
111      return appendCommand(commandObjects.ttl(key));
112    }
113    @Override
114    public Response<Long> pttl(String key) {
115      return appendCommand(commandObjects.pttl(key));
116    }
117    @Override
118    public Response<Long> touch(String key) {
119      return appendCommand(commandObjects.touch(key));
120    }
121    @Override
122    public Response<Long> touch(String... keys) {
123      return appendCommand(commandObjects.touch(keys));
124    }
125    @Override
126    public Response<List<String>> sort(String key) {
127      return appendCommand(commandObjects.sort(key));
128    }
129    @Override
130    public Response<Long> sort(String key, String dstKey) {
131      return appendCommand(commandObjects.sort(key, dstKey));
132    }
133    @Override
134    public Response<List<String>> sort(String key, SortingParams sortingParams) {
135      return appendCommand(commandObjects.sort(key, sortingParams));
136    }
137    @Override
138    public Response<Long> sort(String key, SortingParams sortingParams, String dstKey) {
139      return appendCommand(commandObjects.sort(key, sortingParams, dstKey));
140    }
141    @Override
142    public Response<List<String>> sortReadonly(String key, SortingParams sortingParams) {
143      return appendCommand(commandObjects.sortReadonly(key, sortingParams));
144    }
145    @Override
146    public Response<Long> del(String key) {
147      return appendCommand(commandObjects.del(key));
148    }
149    @Override
150    public Response<Long> del(String... keys) {
151      return appendCommand(commandObjects.del(keys));
152    }
153    @Override
154    public Response<Long> unlink(String key) {
155      return appendCommand(commandObjects.unlink(key));
156    }
157    @Override
158    public Response<Long> unlink(String... keys) {
159      return appendCommand(commandObjects.unlink(keys));
160    }
161    @Override
162    public Response<Boolean> copy(String srcKey, String dstKey, boolean replace) {
163      return appendCommand(commandObjects.copy(srcKey, dstKey, replace));
164    }
165    @Override
166    public Response<String> rename(String oldkey, String newkey) {
167      return appendCommand(commandObjects.rename(oldkey, newkey));
168    }
169    @Override
170    public Response<Long> renamenx(String oldkey, String newkey) {
171      return appendCommand(commandObjects.renamenx(oldkey, newkey));
172    }
173    @Override
174    public Response<Long> memoryUsage(String key) {
175      return appendCommand(commandObjects.memoryUsage(key));
176    }
177    @Override
178    public Response<Long> memoryUsage(String key, int samples) {
179      return appendCommand(commandObjects.memoryUsage(key, samples));
180    }
181    @Override
182    public Response<Long> objectRefcount(String key) {
183      return appendCommand(commandObjects.objectRefcount(key));
184    }
185    @Override
186    public Response<String> objectEncoding(String key) {
187      return appendCommand(commandObjects.objectEncoding(key));
188    }
189    @Override
190    public Response<Long> objectIdletime(String key) {
191      return appendCommand(commandObjects.objectIdletime(key));
192    }
193    @Override
194    public Response<Long> objectFreq(String key) {
195      return appendCommand(commandObjects.objectFreq(key));
196    }
197    @Override
198    public Response<String> migrate(String host, int port, String key, int timeout) {
199      return appendCommand(commandObjects.migrate(host, port, key, timeout));
200    }
201    @Override
202    public Response<String> migrate(String host, int port, int timeout, MigrateParams params, String... keys) {
203      return appendCommand(commandObjects.migrate(host, port, timeout, params, keys));
204    }
205    @Override
206    public Response<Set<String>> keys(String pattern) {
207      return appendCommand(commandObjects.keys(pattern));
208    }
209    @Override
210    public Response<ScanResult<String>> scan(String cursor) {
211      return appendCommand(commandObjects.scan(cursor));
212    }
213    @Override
214    public Response<ScanResult<String>> scan(String cursor, ScanParams params) {
215      return appendCommand(commandObjects.scan(cursor, params));
216    }
217    @Override
218    public Response<ScanResult<String>> scan(String cursor, ScanParams params, String type) {
219      return appendCommand(commandObjects.scan(cursor, params, type));
220    }
221    @Override
222    public Response<String> randomKey() {
223      return appendCommand(commandObjects.randomKey());
224    }
225    @Override
226    public Response<String> get(String key) {
227      return appendCommand(commandObjects.get(key));
228    }
229    @Override
230    public Response<String> setGet(String key, String value, SetParams params) {
231      return appendCommand(commandObjects.setGet(key, value, params));
232    }
233    @Override
234    public Response<String> getDel(String key) {
235      return appendCommand(commandObjects.getDel(key));
236    }
237    @Override
238    public Response<String> getEx(String key, GetExParams params) {
239      return appendCommand(commandObjects.getEx(key, params));
240    }
241    @Override
242    public Response<Boolean> setbit(String key, long offset, boolean value) {
243      return appendCommand(commandObjects.setbit(key, offset, value));
244    }
245    @Override
246    public Response<Boolean> getbit(String key, long offset) {
247      return appendCommand(commandObjects.getbit(key, offset));
248    }
249    @Override
250    public Response<Long> setrange(String key, long offset, String value) {
251      return appendCommand(commandObjects.setrange(key, offset, value));
252    }
253    @Override
254    public Response<String> getrange(String key, long startOffset, long endOffset) {
255      return appendCommand(commandObjects.getrange(key, startOffset, endOffset));
256    }
257    @Override
258    public Response<String> getSet(String key, String value) {
259      return appendCommand(commandObjects.getSet(key, value));
260    }
261    @Override
262    public Response<Long> setnx(String key, String value) {
263      return appendCommand(commandObjects.setnx(key, value));
264    }
265    @Override
266    public Response<String> setex(String key, long seconds, String value) {
267      return appendCommand(commandObjects.setex(key, seconds, value));
268    }
269    @Override
270    public Response<String> psetex(String key, long milliseconds, String value) {
271      return appendCommand(commandObjects.psetex(key, milliseconds, value));
272    }
273    @Override
274    public Response<List<String>> mget(String... keys) {
275      return appendCommand(commandObjects.mget(keys));
276    }
277    @Override
278    public Response<String> mset(String... keysvalues) {
279      return appendCommand(commandObjects.mset(keysvalues));
280    }
281    @Override
282    public Response<Long> msetnx(String... keysvalues) {
283      return appendCommand(commandObjects.msetnx(keysvalues));
284    }
285    @Override
286    public Response<Long> incr(String key) {
287      return appendCommand(commandObjects.incr(key));
288    }
289    @Override
290    public Response<Long> incrBy(String key, long increment) {
291      return appendCommand(commandObjects.incrBy(key, increment));
292    }
293    @Override
294    public Response<Double> incrByFloat(String key, double increment) {
295      return appendCommand(commandObjects.incrByFloat(key, increment));
296    }
297    @Override
298    public Response<Long> decr(String key) {
299      return appendCommand(commandObjects.decr(key));
300    }
301    @Override
302    public Response<Long> decrBy(String key, long decrement) {
303      return appendCommand(commandObjects.decrBy(key, decrement));
304    }
305    @Override
306    public Response<Long> append(String key, String value) {
307      return appendCommand(commandObjects.append(key, value));
308    }
309    @Override
310    public Response<String> substr(String key, int start, int end) {
311      return appendCommand(commandObjects.substr(key, start, end));
312    }
313    @Override
314    public Response<Long> strlen(String key) {
315      return appendCommand(commandObjects.strlen(key));
316    }
317    @Override
318    public Response<Long> bitcount(String key) {
319      return appendCommand(commandObjects.bitcount(key));
320    }
321    @Override
322    public Response<Long> bitcount(String key, long start, long end) {
323      return appendCommand(commandObjects.bitcount(key, start, end));
324    }
325    @Override
326    public Response<Long> bitcount(String key, long start, long end, BitCountOption option) {
327      return appendCommand(commandObjects.bitcount(key, start, end, option));
328    }
329    @Override
330    public Response<Long> bitpos(String key, boolean value) {
331      return appendCommand(commandObjects.bitpos(key, value));
332    }
333    @Override
334    public Response<Long> bitpos(String key, boolean value, BitPosParams params) {
335      return appendCommand(commandObjects.bitpos(key, value, params));
336    }
337    @Override
338    public Response<List<Long>> bitfield(String key, String... arguments) {
339      return appendCommand(commandObjects.bitfield(key, arguments));
340    }
341    @Override
342    public Response<List<Long>> bitfieldReadonly(String key, String... arguments) {
343      return appendCommand(commandObjects.bitfieldReadonly(key, arguments));
344    }
345    @Override
346    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
347      return appendCommand(commandObjects.bitop(op, destKey, srcKeys));
348    }
349    @Override
350    public Response<LCSMatchResult> lcs(String keyA, String keyB, LCSParams params) {
351      return appendCommand(commandObjects.lcs(keyA, keyB, params));
352    }
353    @Override
354    public Response<String> set(String key, String value) {
355      return appendCommand(commandObjects.set(key, value));
356    }
357    @Override
358    public Response<String> set(String key, String value, SetParams params) {
359      return appendCommand(commandObjects.set(key, value, params));
360    }
361    @Override
362    public Response<Long> rpush(String key, String... string) {
363      return appendCommand(commandObjects.rpush(key, string));
364    }
365    @Override
366    public Response<Long> lpush(String key, String... string) {
367      return appendCommand(commandObjects.lpush(key, string));
368    }
369    @Override
370    public Response<Long> llen(String key) {
371      return appendCommand(commandObjects.llen(key));
372    }
373    @Override
374    public Response<List<String>> lrange(String key, long start, long stop) {
375      return appendCommand(commandObjects.lrange(key, start, stop));
376    }
377    @Override
378    public Response<String> ltrim(String key, long start, long stop) {
379      return appendCommand(commandObjects.ltrim(key, start, stop));
380    }
381    @Override
382    public Response<String> lindex(String key, long index) {
383      return appendCommand(commandObjects.lindex(key, index));
384    }
385    @Override
386    public Response<String> lset(String key, long index, String value) {
387      return appendCommand(commandObjects.lset(key, index, value));
388    }
389    @Override
390    public Response<Long> lrem(String key, long count, String value) {
391      return appendCommand(commandObjects.lrem(key, count, value));
392    }
393    @Override
394    public Response<String> lpop(String key) {
395      return appendCommand(commandObjects.lpop(key));
396    }
397    @Override
398    public Response<List<String>> lpop(String key, int count) {
399      return appendCommand(commandObjects.lpop(key, count));
400    }
401    @Override
402    public Response<Long> lpos(String key, String element) {
403      return appendCommand(commandObjects.lpos(key, element));
404    }
405    @Override
406    public Response<Long> lpos(String key, String element, LPosParams params) {
407      return appendCommand(commandObjects.lpos(key, element, params));
408    }
409    @Override
410    public Response<List<Long>> lpos(String key, String element, LPosParams params, long count) {
411      return appendCommand(commandObjects.lpos(key, element, params, count));
412    }
413    @Override
414    public Response<String> rpop(String key) {
415      return appendCommand(commandObjects.rpop(key));
416    }
417    @Override
418    public Response<List<String>> rpop(String key, int count) {
419      return appendCommand(commandObjects.rpop(key, count));
420    }
421    @Override
422    public Response<Long> linsert(String key, ListPosition where, String pivot, String value) {
423      return appendCommand(commandObjects.linsert(key, where, pivot, value));
424    }
425    @Override
426    public Response<Long> lpushx(String key, String... strings) {
427      return appendCommand(commandObjects.lpushx(key, strings));
428    }
429    @Override
430    public Response<Long> rpushx(String key, String... strings) {
431      return appendCommand(commandObjects.rpushx(key, strings));
432    }
433    @Override
434    public Response<List<String>> blpop(int timeout, String key) {
435      return appendCommand(commandObjects.blpop(timeout, key));
436    }
437    @Override
<span onclick='openModal()' class='match'>438    public Response<KeyValue<String, String>> blpop(double timeout, String key) {
439      return appendCommand(commandObjects.blpop(timeout, key));
440    }
441    @Override
442    public Response<List<String>> brpop(int timeout, String key) {
</span>443      return appendCommand(commandObjects.brpop(timeout, key));
444    }
445    @Override
446    public Response<KeyValue<String, String>> brpop(double timeout, String key) {
447      return appendCommand(commandObjects.brpop(timeout, key));
448    }
449    @Override
450    public Response<List<String>> blpop(int timeout, String... keys) {
451      return appendCommand(commandObjects.blpop(timeout, keys));
452    }
453    @Override
454    public Response<KeyValue<String, String>> blpop(double timeout, String... keys) {
455      return appendCommand(commandObjects.blpop(timeout, keys));
456    }
457    @Override
458    public Response<List<String>> brpop(int timeout, String... keys) {
459      return appendCommand(commandObjects.brpop(timeout, keys));
460    }
461    @Override
462    public Response<KeyValue<String, String>> brpop(double timeout, String... keys) {
463      return appendCommand(commandObjects.brpop(timeout, keys));
464    }
465    @Override
466    public Response<String> rpoplpush(String srcKey, String dstKey) {
467      return appendCommand(commandObjects.rpoplpush(srcKey, dstKey));
468    }
469    @Override
470    public Response<String> brpoplpush(String source, String destination, int timeout) {
471      return appendCommand(commandObjects.brpoplpush(source, destination, timeout));
472    }
473    @Override
474    public Response<String> lmove(String srcKey, String dstKey, ListDirection from, ListDirection to) {
475      return appendCommand(commandObjects.lmove(srcKey, dstKey, from, to));
476    }
477    @Override
478    public Response<String> blmove(String srcKey, String dstKey, ListDirection from, ListDirection to, double timeout) {
479      return appendCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
480    }
481    @Override
482    public Response<KeyValue<String, List<String>>> lmpop(ListDirection direction, String... keys) {
483      return appendCommand(commandObjects.lmpop(direction, keys));
484    }
485    @Override
486    public Response<KeyValue<String, List<String>>> lmpop(ListDirection direction, int count, String... keys) {
487      return appendCommand(commandObjects.lmpop(direction, count, keys));
488    }
489    @Override
490    public Response<KeyValue<String, List<String>>> blmpop(double timeout, ListDirection direction, String... keys) {
491      return appendCommand(commandObjects.blmpop(timeout, direction, keys));
492    }
493    @Override
494    public Response<KeyValue<String, List<String>>> blmpop(double timeout, ListDirection direction, int count, String... keys) {
495      return appendCommand(commandObjects.blmpop(timeout, direction, count, keys));
496    }
497    @Override
498    public Response<Long> hset(String key, String field, String value) {
499      return appendCommand(commandObjects.hset(key, field, value));
500    }
501    @Override
502    public Response<Long> hset(String key, Map<String, String> hash) {
503      return appendCommand(commandObjects.hset(key, hash));
504    }
505    @Override
506    public Response<String> hget(String key, String field) {
507      return appendCommand(commandObjects.hget(key, field));
508    }
509    @Override
510    public Response<Long> hsetnx(String key, String field, String value) {
511      return appendCommand(commandObjects.hsetnx(key, field, value));
512    }
513    @Override
514    public Response<String> hmset(String key, Map<String, String> hash) {
515      return appendCommand(commandObjects.hmset(key, hash));
516    }
517    @Override
518    public Response<List<String>> hmget(String key, String... fields) {
519      return appendCommand(commandObjects.hmget(key, fields));
520    }
521    @Override
522    public Response<Long> hincrBy(String key, String field, long value) {
523      return appendCommand(commandObjects.hincrBy(key, field, value));
524    }
525    @Override
526    public Response<Double> hincrByFloat(String key, String field, double value) {
527      return appendCommand(commandObjects.hincrByFloat(key, field, value));
528    }
529    @Override
530    public Response<Boolean> hexists(String key, String field) {
531      return appendCommand(commandObjects.hexists(key, field));
532    }
533    @Override
534    public Response<Long> hdel(String key, String... field) {
535      return appendCommand(commandObjects.hdel(key, field));
536    }
537    @Override
538    public Response<Long> hlen(String key) {
539      return appendCommand(commandObjects.hlen(key));
540    }
541    @Override
542    public Response<Set<String>> hkeys(String key) {
543      return appendCommand(commandObjects.hkeys(key));
544    }
545    @Override
546    public Response<List<String>> hvals(String key) {
547      return appendCommand(commandObjects.hvals(key));
548    }
549    @Override
550    public Response<Map<String, String>> hgetAll(String key) {
551      return appendCommand(commandObjects.hgetAll(key));
552    }
553    @Override
554    public Response<String> hrandfield(String key) {
555      return appendCommand(commandObjects.hrandfield(key));
556    }
557    @Override
558    public Response<List<String>> hrandfield(String key, long count) {
559      return appendCommand(commandObjects.hrandfield(key, count));
560    }
561    @Override
562    public Response<List<Map.Entry<String, String>>> hrandfieldWithValues(String key, long count) {
563      return appendCommand(commandObjects.hrandfieldWithValues(key, count));
564    }
565    @Override
566    public Response<ScanResult<Map.Entry<String, String>>> hscan(String key, String cursor, ScanParams params) {
567      return appendCommand(commandObjects.hscan(key, cursor, params));
568    }
569    @Override
570    public Response<Long> hstrlen(String key, String field) {
571      return appendCommand(commandObjects.hstrlen(key, field));
572    }
573    @Override
574    public Response<Long> sadd(String key, String... members) {
575      return appendCommand(commandObjects.sadd(key, members));
576    }
577    @Override
578    public Response<Set<String>> smembers(String key) {
579      return appendCommand(commandObjects.smembers(key));
580    }
581    @Override
582    public Response<Long> srem(String key, String... members) {
583      return appendCommand(commandObjects.srem(key, members));
584    }
585    @Override
586    public Response<String> spop(String key) {
587      return appendCommand(commandObjects.spop(key));
588    }
589    @Override
590    public Response<Set<String>> spop(String key, long count) {
591      return appendCommand(commandObjects.spop(key, count));
592    }
593    @Override
594    public Response<Long> scard(String key) {
595      return appendCommand(commandObjects.scard(key));
596    }
597    @Override
598    public Response<Boolean> sismember(String key, String member) {
599      return appendCommand(commandObjects.sismember(key, member));
600    }
601    @Override
602    public Response<List<Boolean>> smismember(String key, String... members) {
603      return appendCommand(commandObjects.smismember(key, members));
604    }
605    @Override
606    public Response<String> srandmember(String key) {
607      return appendCommand(commandObjects.srandmember(key));
608    }
609    @Override
610    public Response<List<String>> srandmember(String key, int count) {
611      return appendCommand(commandObjects.srandmember(key, count));
612    }
613    @Override
614    public Response<ScanResult<String>> sscan(String key, String cursor, ScanParams params) {
615      return appendCommand(commandObjects.sscan(key, cursor, params));
616    }
617    @Override
618    public Response<Set<String>> sdiff(String... keys) {
619      return appendCommand(commandObjects.sdiff(keys));
620    }
621    @Override
622    public Response<Long> sdiffStore(String dstKey, String... keys) {
623      return appendCommand(commandObjects.sdiffstore(dstKey, keys));
624    }
625    @Override
626    public Response<Set<String>> sinter(String... keys) {
627      return appendCommand(commandObjects.sinter(keys));
628    }
629    @Override
630    public Response<Long> sinterstore(String dstKey, String... keys) {
631      return appendCommand(commandObjects.sinterstore(dstKey, keys));
632    }
633    @Override
634    public Response<Long> sintercard(String... keys) {
635      return appendCommand(commandObjects.sintercard(keys));
636    }
637    @Override
638    public Response<Long> sintercard(int limit, String... keys) {
639      return appendCommand(commandObjects.sintercard(limit, keys));
640    }
641    @Override
642    public Response<Set<String>> sunion(String... keys) {
643      return appendCommand(commandObjects.sunion(keys));
644    }
645    @Override
646    public Response<Long> sunionstore(String dstKey, String... keys) {
647      return appendCommand(commandObjects.sunionstore(dstKey, keys));
648    }
649    @Override
650    public Response<Long> smove(String srcKey, String dstKey, String member) {
651      return appendCommand(commandObjects.smove(srcKey, dstKey, member));
652    }
653    @Override
654    public Response<Long> zadd(String key, double score, String member) {
655      return appendCommand(commandObjects.zadd(key, score, member));
656    }
657    @Override
658    public Response<Long> zadd(String key, double score, String member, ZAddParams params) {
659      return appendCommand(commandObjects.zadd(key, score, member, params));
660    }
661    @Override
662    public Response<Long> zadd(String key, Map<String, Double> scoreMembers) {
663      return appendCommand(commandObjects.zadd(key, scoreMembers));
664    }
665    @Override
666    public Response<Long> zadd(String key, Map<String, Double> scoreMembers, ZAddParams params) {
667      return appendCommand(commandObjects.zadd(key, scoreMembers, params));
668    }
669    @Override
670    public Response<Double> zaddIncr(String key, double score, String member, ZAddParams params) {
671      return appendCommand(commandObjects.zaddIncr(key, score, member, params));
672    }
673    @Override
674    public Response<Long> zrem(String key, String... members) {
675      return appendCommand(commandObjects.zrem(key, members));
676    }
677    @Override
678    public Response<Double> zincrby(String key, double increment, String member) {
679      return appendCommand(commandObjects.zincrby(key, increment, member));
680    }
681    @Override
682    public Response<Double> zincrby(String key, double increment, String member, ZIncrByParams params) {
683      return appendCommand(commandObjects.zincrby(key, increment, member, params));
684    }
685    @Override
686    public Response<Long> zrank(String key, String member) {
687      return appendCommand(commandObjects.zrank(key, member));
688    }
689    @Override
690    public Response<Long> zrevrank(String key, String member) {
691      return appendCommand(commandObjects.zrevrank(key, member));
692    }
693    @Override
694    public Response<KeyValue<Long, Double>> zrankWithScore(String key, String member) {
695      return appendCommand(commandObjects.zrankWithScore(key, member));
696    }
697    @Override
698    public Response<KeyValue<Long, Double>> zrevrankWithScore(String key, String member) {
699      return appendCommand(commandObjects.zrevrankWithScore(key, member));
700    }
701    @Override
702    public Response<List<String>> zrange(String key, long start, long stop) {
703      return appendCommand(commandObjects.zrange(key, start, stop));
704    }
705    @Override
706    public Response<List<String>> zrevrange(String key, long start, long stop) {
707      return appendCommand(commandObjects.zrevrange(key, start, stop));
708    }
709    @Override
710    public Response<List<Tuple>> zrangeWithScores(String key, long start, long stop) {
711      return appendCommand(commandObjects.zrangeWithScores(key, start, stop));
712    }
713    @Override
714    public Response<List<Tuple>> zrevrangeWithScores(String key, long start, long stop) {
715      return appendCommand(commandObjects.zrevrangeWithScores(key, start, stop));
716    }
717    @Override
718    public Response<String> zrandmember(String key) {
719      return appendCommand(commandObjects.zrandmember(key));
720    }
721    @Override
722    public Response<List<String>> zrandmember(String key, long count) {
723      return appendCommand(commandObjects.zrandmember(key, count));
724    }
725    @Override
726    public Response<List<Tuple>> zrandmemberWithScores(String key, long count) {
727      return appendCommand(commandObjects.zrandmemberWithScores(key, count));
728    }
729    @Override
730    public Response<Long> zcard(String key) {
731      return appendCommand(commandObjects.zcard(key));
732    }
733    @Override
734    public Response<Double> zscore(String key, String member) {
735      return appendCommand(commandObjects.zscore(key, member));
736    }
737    @Override
738    public Response<List<Double>> zmscore(String key, String... members) {
739      return appendCommand(commandObjects.zmscore(key, members));
740    }
741    @Override
742    public Response<Tuple> zpopmax(String key) {
743      return appendCommand(commandObjects.zpopmax(key));
744    }
745    @Override
746    public Response<List<Tuple>> zpopmax(String key, int count) {
747      return appendCommand(commandObjects.zpopmax(key, count));
748    }
749    @Override
750    public Response<Tuple> zpopmin(String key) {
751      return appendCommand(commandObjects.zpopmin(key));
752    }
753    @Override
754    public Response<List<Tuple>> zpopmin(String key, int count) {
755      return appendCommand(commandObjects.zpopmin(key, count));
756    }
757    @Override
758    public Response<Long> zcount(String key, double min, double max) {
759      return appendCommand(commandObjects.zcount(key, min, max));
760    }
761    @Override
762    public Response<Long> zcount(String key, String min, String max) {
763      return appendCommand(commandObjects.zcount(key, min, max));
764    }
765    @Override
766    public Response<List<String>> zrangeByScore(String key, double min, double max) {
767      return appendCommand(commandObjects.zrangeByScore(key, min, max));
768    }
769    @Override
770    public Response<List<String>> zrangeByScore(String key, String min, String max) {
771      return appendCommand(commandObjects.zrangeByScore(key, min, max));
772    }
773    @Override
774    public Response<List<String>> zrevrangeByScore(String key, double max, double min) {
775      return appendCommand(commandObjects.zrevrangeByScore(key, max, min));
776    }
777    @Override
778    public Response<List<String>> zrangeByScore(String key, double min, double max, int offset, int count) {
779      return appendCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
780    }
781    @Override
782    public Response<List<String>> zrevrangeByScore(String key, String max, String min) {
783      return appendCommand(commandObjects.zrevrangeByScore(key, max, min));
784    }
785    @Override
786    public Response<List<String>> zrangeByScore(String key, String min, String max, int offset, int count) {
787      return appendCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
788    }
789    @Override
790    public Response<List<String>> zrevrangeByScore(String key, double max, double min, int offset, int count) {
791      return appendCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
792    }
793    @Override
794    public Response<List<Tuple>> zrangeByScoreWithScores(String key, double min, double max) {
795      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
796    }
797    @Override
798    public Response<List<Tuple>> zrevrangeByScoreWithScores(String key, double max, double min) {
799      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
800    }
801    @Override
802    public Response<List<Tuple>> zrangeByScoreWithScores(String key, double min, double max, int offset, int count) {
803      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
804    }
805    @Override
806    public Response<List<String>> zrevrangeByScore(String key, String max, String min, int offset, int count) {
807      return appendCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
808    }
809    @Override
810    public Response<List<Tuple>> zrangeByScoreWithScores(String key, String min, String max) {
811      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
812    }
813    @Override
814    public Response<List<Tuple>> zrevrangeByScoreWithScores(String key, String max, String min) {
815      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
816    }
817    @Override
818    public Response<List<Tuple>> zrangeByScoreWithScores(String key, String min, String max, int offset, int count) {
819      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
820    }
821    @Override
822    public Response<List<Tuple>> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count) {
823      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
824    }
825    @Override
826    public Response<List<Tuple>> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count) {
827      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
828    }
829    @Override
830    public Response<List<String>> zrange(String key, ZRangeParams zRangeParams) {
831      return appendCommand(commandObjects.zrange(key, zRangeParams));
832    }
833    @Override
834    public Response<List<Tuple>> zrangeWithScores(String key, ZRangeParams zRangeParams) {
835      return appendCommand(commandObjects.zrangeWithScores(key, zRangeParams));
836    }
837    @Override
838    public Response<Long> zrangestore(String dest, String src, ZRangeParams zRangeParams) {
839      return appendCommand(commandObjects.zrangestore(dest, src, zRangeParams));
840    }
841    @Override
842    public Response<Long> zremrangeByRank(String key, long start, long stop) {
843      return appendCommand(commandObjects.zremrangeByRank(key, start, stop));
844    }
845    @Override
846    public Response<Long> zremrangeByScore(String key, double min, double max) {
847      return appendCommand(commandObjects.zremrangeByScore(key, min, max));
848    }
849    @Override
850    public Response<Long> zremrangeByScore(String key, String min, String max) {
851      return appendCommand(commandObjects.zremrangeByScore(key, min, max));
852    }
853    @Override
854    public Response<Long> zlexcount(String key, String min, String max) {
855      return appendCommand(commandObjects.zlexcount(key, min, max));
856    }
857    @Override
858    public Response<List<String>> zrangeByLex(String key, String min, String max) {
859      return appendCommand(commandObjects.zrangeByLex(key, min, max));
860    }
861    @Override
862    public Response<List<String>> zrangeByLex(String key, String min, String max, int offset, int count) {
863      return appendCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
864    }
865    @Override
866    public Response<List<String>> zrevrangeByLex(String key, String max, String min) {
867      return appendCommand(commandObjects.zrevrangeByLex(key, max, min));
868    }
869    @Override
870    public Response<List<String>> zrevrangeByLex(String key, String max, String min, int offset, int count) {
871      return appendCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
872    }
873    @Override
874    public Response<Long> zremrangeByLex(String key, String min, String max) {
875      return appendCommand(commandObjects.zremrangeByLex(key, min, max));
876    }
877    @Override
878    public Response<ScanResult<Tuple>> zscan(String key, String cursor, ScanParams params) {
879      return appendCommand(commandObjects.zscan(key, cursor, params));
880    }
881    @Override
882    public Response<KeyValue<String, Tuple>> bzpopmax(double timeout, String... keys) {
883      return appendCommand(commandObjects.bzpopmax(timeout, keys));
884    }
885    @Override
886    public Response<KeyValue<String, Tuple>> bzpopmin(double timeout, String... keys) {
887      return appendCommand(commandObjects.bzpopmin(timeout, keys));
888    }
889    @Override
890    public Response<KeyValue<String, List<Tuple>>> zmpop(SortedSetOption option, String... keys) {
891      return appendCommand(commandObjects.zmpop(option, keys));
892    }
893    @Override
894    public Response<KeyValue<String, List<Tuple>>> zmpop(SortedSetOption option, int count, String... keys) {
895      return appendCommand(commandObjects.zmpop(option, count, keys));
896    }
897    @Override
898    public Response<KeyValue<String, List<Tuple>>> bzmpop(double timeout, SortedSetOption option, String... keys) {
899      return appendCommand(commandObjects.bzmpop(timeout, option, keys));
900    }
901    @Override
902    public Response<KeyValue<String, List<Tuple>>> bzmpop(double timeout, SortedSetOption option, int count, String... keys) {
903      return appendCommand(commandObjects.bzmpop(timeout, option, count, keys));
904    }
905    @Override
906    public Response<List<String>> zdiff(String... keys) {
907      return appendCommand(commandObjects.zdiff(keys));
908    }
909    @Override
910    public Response<List<Tuple>> zdiffWithScores(String... keys) {
911      return appendCommand(commandObjects.zdiffWithScores(keys));
912    }
913    @Override
914    @Deprecated
915    public Response<Long> zdiffStore(String dstKey, String... keys) {
916      return appendCommand(commandObjects.zdiffStore(dstKey, keys));
917    }
918    @Override
919    public Response<Long> zdiffstore(String dstKey, String... keys) {
920      return appendCommand(commandObjects.zdiffstore(dstKey, keys));
921    }
922    @Override
923    public Response<Long> zinterstore(String dstKey, String... sets) {
924      return appendCommand(commandObjects.zinterstore(dstKey, sets));
925    }
926    @Override
927    public Response<Long> zinterstore(String dstKey, ZParams params, String... sets) {
928      return appendCommand(commandObjects.zinterstore(dstKey, params, sets));
929    }
930    @Override
931    public Response<List<String>> zinter(ZParams params, String... keys) {
932      return appendCommand(commandObjects.zinter(params, keys));
933    }
934    @Override
935    public Response<List<Tuple>> zinterWithScores(ZParams params, String... keys) {
936      return appendCommand(commandObjects.zinterWithScores(params, keys));
937    }
938    @Override
939    public Response<Long> zintercard(String... keys) {
940      return appendCommand(commandObjects.zintercard(keys));
941    }
942    @Override
943    public Response<Long> zintercard(long limit, String... keys) {
944      return appendCommand(commandObjects.zintercard(limit, keys));
945    }
946    @Override
947    public Response<List<String>> zunion(ZParams params, String... keys) {
948      return appendCommand(commandObjects.zunion(params, keys));
949    }
950    @Override
951    public Response<List<Tuple>> zunionWithScores(ZParams params, String... keys) {
952      return appendCommand(commandObjects.zunionWithScores(params, keys));
953    }
954    @Override
955    public Response<Long> zunionstore(String dstKey, String... sets) {
956      return appendCommand(commandObjects.zunionstore(dstKey, sets));
957    }
958    @Override
959    public Response<Long> zunionstore(String dstKey, ZParams params, String... sets) {
960      return appendCommand(commandObjects.zunionstore(dstKey, params, sets));
961    }
962    @Override
963    public Response<Long> geoadd(String key, double longitude, double latitude, String member) {
964      return appendCommand(commandObjects.geoadd(key, longitude, latitude, member));
965    }
966    @Override
967    public Response<Long> geoadd(String key, Map<String, GeoCoordinate> memberCoordinateMap) {
968      return appendCommand(commandObjects.geoadd(key, memberCoordinateMap));
969    }
970    @Override
971    public Response<Long> geoadd(String key, GeoAddParams params, Map<String, GeoCoordinate> memberCoordinateMap) {
972      return appendCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
973    }
974    @Override
975    public Response<Double> geodist(String key, String member1, String member2) {
976      return appendCommand(commandObjects.geodist(key, member1, member2));
977    }
978    @Override
979    public Response<Double> geodist(String key, String member1, String member2, GeoUnit unit) {
980      return appendCommand(commandObjects.geodist(key, member1, member2, unit));
981    }
982    @Override
983    public Response<List<String>> geohash(String key, String... members) {
984      return appendCommand(commandObjects.geohash(key, members));
985    }
986    @Override
987    public Response<List<GeoCoordinate>> geopos(String key, String... members) {
988      return appendCommand(commandObjects.geopos(key, members));
989    }
990    @Override
991    public Response<List<GeoRadiusResponse>> georadius(String key, double longitude, double latitude, double radius, GeoUnit unit) {
992      return appendCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
993    }
994    @Override
995    public Response<List<GeoRadiusResponse>> georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit) {
996      return appendCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
997    }
998    @Override
999    public Response<List<GeoRadiusResponse>> georadius(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
1000      return appendCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
1001    }
1002    @Override
1003    public Response<List<GeoRadiusResponse>> georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
1004      return appendCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
1005    }
1006    @Override
1007    public Response<List<GeoRadiusResponse>> georadiusByMember(String key, String member, double radius, GeoUnit unit) {
1008      return appendCommand(commandObjects.georadiusByMember(key, member, radius, unit));
1009    }
1010    @Override
1011    public Response<List<GeoRadiusResponse>> georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit) {
1012      return appendCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
1013    }
1014    @Override
1015    public Response<List<GeoRadiusResponse>> georadiusByMember(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
1016      return appendCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
1017    }
1018    @Override
1019    public Response<List<GeoRadiusResponse>> georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
1020      return appendCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
1021    }
1022    @Override
1023    public Response<Long> georadiusStore(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
1024      return appendCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
1025    }
1026    @Override
1027    public Response<Long> georadiusByMemberStore(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
1028      return appendCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
1029    }
1030    @Override
1031    public Response<List<GeoRadiusResponse>> geosearch(String key, String member, double radius, GeoUnit unit) {
1032      return appendCommand(commandObjects.geosearch(key, member, radius, unit));
1033    }
1034    @Override
1035    public Response<List<GeoRadiusResponse>> geosearch(String key, GeoCoordinate coord, double radius, GeoUnit unit) {
1036      return appendCommand(commandObjects.geosearch(key, coord, radius, unit));
1037    }
1038    @Override
1039    public Response<List<GeoRadiusResponse>> geosearch(String key, String member, double width, double height, GeoUnit unit) {
1040      return appendCommand(commandObjects.geosearch(key, member, width, height, unit));
1041    }
1042    @Override
1043    public Response<List<GeoRadiusResponse>> geosearch(String key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
1044      return appendCommand(commandObjects.geosearch(key, coord, width, height, unit));
1045    }
1046    @Override
1047    public Response<List<GeoRadiusResponse>> geosearch(String key, GeoSearchParam params) {
1048      return appendCommand(commandObjects.geosearch(key, params));
1049    }
1050    @Override
1051    public Response<Long> geosearchStore(String dest, String src, String member, double radius, GeoUnit unit) {
1052      return appendCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
1053    }
1054    @Override
1055    public Response<Long> geosearchStore(String dest, String src, GeoCoordinate coord, double radius, GeoUnit unit) {
1056      return appendCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
1057    }
1058    @Override
1059    public Response<Long> geosearchStore(String dest, String src, String member, double width, double height, GeoUnit unit) {
1060      return appendCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
1061    }
1062    @Override
1063    public Response<Long> geosearchStore(String dest, String src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
1064      return appendCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
1065    }
1066    @Override
1067    public Response<Long> geosearchStore(String dest, String src, GeoSearchParam params) {
1068      return appendCommand(commandObjects.geosearchStore(dest, src, params));
1069    }
1070    @Override
1071    public Response<Long> geosearchStoreStoreDist(String dest, String src, GeoSearchParam params) {
1072      return appendCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
1073    }
1074    @Override
1075    public Response<Long> pfadd(String key, String... elements) {
1076      return appendCommand(commandObjects.pfadd(key, elements));
1077    }
1078    @Override
1079    public Response<String> pfmerge(String destkey, String... sourcekeys) {
1080      return appendCommand(commandObjects.pfmerge(destkey, sourcekeys));
1081    }
1082    @Override
1083    public Response<Long> pfcount(String key) {
1084      return appendCommand(commandObjects.pfcount(key));
1085    }
1086    @Override
1087    public Response<Long> pfcount(String... keys) {
1088      return appendCommand(commandObjects.pfcount(keys));
1089    }
1090    @Override
1091    public Response<StreamEntryID> xadd(String key, StreamEntryID id, Map<String, String> hash) {
1092      return appendCommand(commandObjects.xadd(key, id, hash));
1093    }
1094    @Override
1095    public Response<StreamEntryID> xadd(String key, XAddParams params, Map<String, String> hash) {
1096      return appendCommand(commandObjects.xadd(key, params, hash));
1097    }
1098    @Override
1099    public Response<Long> xlen(String key) {
1100      return appendCommand(commandObjects.xlen(key));
1101    }
1102    @Override
1103    public Response<List<StreamEntry>> xrange(String key, StreamEntryID start, StreamEntryID end) {
1104      return appendCommand(commandObjects.xrange(key, start, end));
1105    }
1106    @Override
1107    public Response<List<StreamEntry>> xrange(String key, StreamEntryID start, StreamEntryID end, int count) {
1108      return appendCommand(commandObjects.xrange(key, start, end, count));
1109    }
1110    @Override
1111    public Response<List<StreamEntry>> xrevrange(String key, StreamEntryID end, StreamEntryID start) {
1112      return appendCommand(commandObjects.xrevrange(key, end, start));
1113    }
1114    @Override
1115    public Response<List<StreamEntry>> xrevrange(String key, StreamEntryID end, StreamEntryID start, int count) {
1116      return appendCommand(commandObjects.xrevrange(key, end, start, count));
1117    }
1118    @Override
1119    public Response<List<StreamEntry>> xrange(String key, String start, String end) {
1120      return appendCommand(commandObjects.xrange(key, start, end));
1121    }
1122    @Override
1123    public Response<List<StreamEntry>> xrange(String key, String start, String end, int count) {
1124      return appendCommand(commandObjects.xrange(key, start, end, count));
1125    }
1126    @Override
1127    public Response<List<StreamEntry>> xrevrange(String key, String end, String start) {
1128      return appendCommand(commandObjects.xrevrange(key, end, start));
1129    }
1130    @Override
1131    public Response<List<StreamEntry>> xrevrange(String key, String end, String start, int count) {
1132      return appendCommand(commandObjects.xrevrange(key, end, start, count));
1133    }
1134    @Override
1135    public Response<Long> xack(String key, String group, StreamEntryID... ids) {
1136      return appendCommand(commandObjects.xack(key, group, ids));
1137    }
1138    @Override
1139    public Response<String> xgroupCreate(String key, String groupName, StreamEntryID id, boolean makeStream) {
1140      return appendCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
1141    }
1142    @Override
1143    public Response<String> xgroupSetID(String key, String groupName, StreamEntryID id) {
1144      return appendCommand(commandObjects.xgroupSetID(key, groupName, id));
1145    }
1146    @Override
1147    public Response<Long> xgroupDestroy(String key, String groupName) {
1148      return appendCommand(commandObjects.xgroupDestroy(key, groupName));
1149    }
1150    @Override
1151    public Response<Boolean> xgroupCreateConsumer(String key, String groupName, String consumerName) {
1152      return appendCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
1153    }
1154    @Override
1155    public Response<Long> xgroupDelConsumer(String key, String groupName, String consumerName) {
1156      return appendCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
1157    }
1158    @Override
1159    public Response<StreamPendingSummary> xpending(String key, String groupName) {
1160      return appendCommand(commandObjects.xpending(key, groupName));
1161    }
1162    @Override
1163    public Response<List<StreamPendingEntry>> xpending(String key, String groupName, XPendingParams params) {
1164      return appendCommand(commandObjects.xpending(key, groupName, params));
1165    }
1166    @Override
1167    public Response<Long> xdel(String key, StreamEntryID... ids) {
1168      return appendCommand(commandObjects.xdel(key, ids));
1169    }
1170    @Override
1171    public Response<Long> xtrim(String key, long maxLen, boolean approximate) {
1172      return appendCommand(commandObjects.xtrim(key, maxLen, approximate));
1173    }
1174    @Override
1175    public Response<Long> xtrim(String key, XTrimParams params) {
1176      return appendCommand(commandObjects.xtrim(key, params));
1177    }
1178    @Override
1179    public Response<List<StreamEntry>> xclaim(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
1180      return appendCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
1181    }
1182    @Override
1183    public Response<List<StreamEntryID>> xclaimJustId(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
1184      return appendCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
1185    }
1186    @Override
1187    public Response<Map.Entry<StreamEntryID, List<StreamEntry>>> xautoclaim(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
1188      return appendCommand(commandObjects.xautoclaim(key, group, consumerName, minIdleTime, start, params));
1189    }
1190    @Override
1191    public Response<Map.Entry<StreamEntryID, List<StreamEntryID>>> xautoclaimJustId(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
1192      return appendCommand(commandObjects.xautoclaimJustId(key, group, consumerName, minIdleTime, start, params));
1193    }
1194    @Override
1195    public Response<StreamInfo> xinfoStream(String key) {
1196      return appendCommand(commandObjects.xinfoStream(key));
1197    }
1198    @Override
1199    public Response<StreamFullInfo> xinfoStreamFull(String key) {
1200      return appendCommand(commandObjects.xinfoStreamFull(key));
1201    }
1202    @Override
1203    public Response<StreamFullInfo> xinfoStreamFull(String key, int count) {
1204      return appendCommand(commandObjects.xinfoStreamFull(key, count));
1205    }
1206    @Override
1207    public Response<List<StreamGroupInfo>> xinfoGroups(String key) {
1208      return appendCommand(commandObjects.xinfoGroups(key));
1209    }
1210    @Override
1211    public Response<List<StreamConsumersInfo>> xinfoConsumers(String key, String group) {
1212      return appendCommand(commandObjects.xinfoConsumers(key, group));
1213    }
1214    @Override
1215    public Response<List<StreamConsumerInfo>> xinfoConsumers2(String key, String group) {
1216      return appendCommand(commandObjects.xinfoConsumers2(key, group));
1217    }
1218    @Override
1219    public Response<List<Map.Entry<String, List<StreamEntry>>>> xread(XReadParams xReadParams, Map<String, StreamEntryID> streams) {
1220      return appendCommand(commandObjects.xread(xReadParams, streams));
1221    }
1222    @Override
1223    public Response<List<Map.Entry<String, List<StreamEntry>>>> xreadGroup(String groupName, String consumer, XReadGroupParams xReadGroupParams, Map<String, StreamEntryID> streams) {
1224      return appendCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
1225    }
1226    @Override
1227    public Response<Object> eval(String script) {
1228      return appendCommand(commandObjects.eval(script));
1229    }
1230    @Override
1231    public Response<Object> eval(String script, int keyCount, String... params) {
1232      return appendCommand(commandObjects.eval(script, keyCount, params));
1233    }
1234    @Override
1235    public Response<Object> eval(String script, List<String> keys, List<String> args) {
1236      return appendCommand(commandObjects.eval(script, keys, args));
1237    }
1238    @Override
1239    public Response<Object> evalReadonly(String script, List<String> keys, List<String> args) {
1240      return appendCommand(commandObjects.evalReadonly(script, keys, args));
1241    }
1242    @Override
1243    public Response<Object> evalsha(String sha1) {
1244      return appendCommand(commandObjects.evalsha(sha1));
1245    }
1246    @Override
1247    public Response<Object> evalsha(String sha1, int keyCount, String... params) {
1248      return appendCommand(commandObjects.evalsha(sha1, keyCount, params));
1249    }
1250    @Override
1251    public Response<Object> evalsha(String sha1, List<String> keys, List<String> args) {
1252      return appendCommand(commandObjects.evalsha(sha1, keys, args));
1253    }
1254    @Override
1255    public Response<Object> evalshaReadonly(String sha1, List<String> keys, List<String> args) {
1256      return appendCommand(commandObjects.evalshaReadonly(sha1, keys, args));
1257    }
1258    @Override
1259    public Response<Long> waitReplicas(String sampleKey, int replicas, long timeout) {
1260      return appendCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
1261    }
1262    @Override
1263    public Response<KeyValue<Long, Long>> waitAOF(String sampleKey, long numLocal, long numReplicas, long timeout) {
1264      return appendCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
1265    }
1266    @Override
1267    public Response<Object> eval(String script, String sampleKey) {
1268      return appendCommand(commandObjects.eval(script, sampleKey));
1269    }
1270    @Override
1271    public Response<Object> evalsha(String sha1, String sampleKey) {
1272      return appendCommand(commandObjects.evalsha(sha1, sampleKey));
1273    }
1274    @Override
1275    public Response<List<Boolean>> scriptExists(String sampleKey, String... sha1) {
1276      return appendCommand(commandObjects.scriptExists(sampleKey, sha1));
1277    }
1278    @Override
1279    public Response<String> scriptLoad(String script, String sampleKey) {
1280      return appendCommand(commandObjects.scriptLoad(script, sampleKey));
1281    }
1282    @Override
1283    public Response<String> scriptFlush(String sampleKey) {
1284      return appendCommand(commandObjects.scriptFlush(sampleKey));
1285    }
1286    @Override
1287    public Response<String> scriptFlush(String sampleKey, FlushMode flushMode) {
1288      return appendCommand(commandObjects.scriptFlush(sampleKey, flushMode));
1289    }
1290    @Override
1291    public Response<String> scriptKill(String sampleKey) {
1292      return appendCommand(commandObjects.scriptKill(sampleKey));
1293    }
1294    @Override
1295    public Response<Object> fcall(byte[] name, List<byte[]> keys, List<byte[]> args) {
1296      return appendCommand(commandObjects.fcall(name, keys, args));
1297    }
1298    @Override
1299    public Response<Object> fcall(String name, List<String> keys, List<String> args) {
1300      return appendCommand(commandObjects.fcall(name, keys, args));
1301    }
1302    @Override
1303    public Response<Object> fcallReadonly(byte[] name, List<byte[]> keys, List<byte[]> args) {
1304      return appendCommand(commandObjects.fcallReadonly(name, keys, args));
1305    }
1306    @Override
1307    public Response<Object> fcallReadonly(String name, List<String> keys, List<String> args) {
1308      return appendCommand(commandObjects.fcallReadonly(name, keys, args));
1309    }
1310    @Override
1311    public Response<String> functionDelete(byte[] libraryName) {
1312      return appendCommand(commandObjects.functionDelete(libraryName));
1313    }
1314    @Override
1315    public Response<String> functionDelete(String libraryName) {
1316      return appendCommand(commandObjects.functionDelete(libraryName));
1317    }
1318    @Override
1319    public Response<byte[]> functionDump() {
1320      return appendCommand(commandObjects.functionDump());
1321    }
1322    @Override
1323    public Response<List<LibraryInfo>> functionList(String libraryNamePattern) {
1324      return appendCommand(commandObjects.functionList(libraryNamePattern));
1325    }
1326    @Override
1327    public Response<List<LibraryInfo>> functionList() {
1328      return appendCommand(commandObjects.functionList());
1329    }
1330    @Override
1331    public Response<List<LibraryInfo>> functionListWithCode(String libraryNamePattern) {
1332      return appendCommand(commandObjects.functionListWithCode(libraryNamePattern));
1333    }
1334    @Override
1335    public Response<List<LibraryInfo>> functionListWithCode() {
1336      return appendCommand(commandObjects.functionListWithCode());
1337    }
1338    @Override
1339    public Response<List<Object>> functionListBinary() {
1340      return appendCommand(commandObjects.functionListBinary());
1341    }
1342    @Override
1343    public Response<List<Object>> functionList(final byte[] libraryNamePattern) {
1344      return appendCommand(commandObjects.functionList(libraryNamePattern));
1345    }
1346    @Override
1347    public Response<List<Object>> functionListWithCodeBinary() {
1348      return appendCommand(commandObjects.functionListWithCodeBinary());
1349    }
1350    @Override
1351    public Response<List<Object>> functionListWithCode(final byte[] libraryNamePattern) {
1352      return appendCommand(commandObjects.functionListWithCode(libraryNamePattern));
1353    }
1354    @Override
1355    public Response<String> functionLoad(byte[] functionCode) {
1356      return appendCommand(commandObjects.functionLoad(functionCode));
1357    }
1358    @Override
1359    public Response<String> functionLoad(String functionCode) {
1360      return appendCommand(commandObjects.functionLoad(functionCode));
1361    }
1362    @Override
1363    public Response<String> functionLoadReplace(byte[] functionCode) {
1364      return appendCommand(commandObjects.functionLoadReplace(functionCode));
1365    }
1366    @Override
1367    public Response<String> functionLoadReplace(String functionCode) {
1368      return appendCommand(commandObjects.functionLoadReplace(functionCode));
1369    }
1370    @Override
1371    public Response<String> functionRestore(byte[] serializedValue) {
1372      return appendCommand(commandObjects.functionRestore(serializedValue));
1373    }
1374    @Override
1375    public Response<String> functionRestore(byte[] serializedValue, FunctionRestorePolicy policy) {
1376      return appendCommand(commandObjects.functionRestore(serializedValue, policy));
1377    }
1378    @Override
1379    public Response<String> functionFlush() {
1380      return appendCommand(commandObjects.functionFlush());
1381    }
1382    @Override
1383    public Response<String> functionFlush(FlushMode mode) {
1384      return appendCommand(commandObjects.functionFlush(mode));
1385    }
1386    @Override
1387    public Response<String> functionKill() {
1388      return appendCommand(commandObjects.functionKill());
1389    }
1390    @Override
1391    public Response<FunctionStats> functionStats() {
1392      return appendCommand(commandObjects.functionStats());
1393    }
1394    @Override
1395    public Response<Object> functionStatsBinary() {
1396      return appendCommand(commandObjects.functionStatsBinary());
1397    }
1398    @Override
1399    public Response<Long> geoadd(byte[] key, double longitude, double latitude, byte[] member) {
1400      return appendCommand(commandObjects.geoadd(key, longitude, latitude, member));
1401    }
1402    @Override
1403    public Response<Long> geoadd(byte[] key, Map<byte[], GeoCoordinate> memberCoordinateMap) {
1404      return appendCommand(commandObjects.geoadd(key, memberCoordinateMap));
1405    }
1406    @Override
1407    public Response<Long> geoadd(byte[] key, GeoAddParams params, Map<byte[], GeoCoordinate> memberCoordinateMap) {
1408      return appendCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
1409    }
1410    @Override
1411    public Response<Double> geodist(byte[] key, byte[] member1, byte[] member2) {
1412      return appendCommand(commandObjects.geodist(key, member1, member2));
1413    }
1414    @Override
1415    public Response<Double> geodist(byte[] key, byte[] member1, byte[] member2, GeoUnit unit) {
1416      return appendCommand(commandObjects.geodist(key, member1, member2, unit));
1417    }
1418    @Override
1419    public Response<List<byte[]>> geohash(byte[] key, byte[]... members) {
1420      return appendCommand(commandObjects.geohash(key, members));
1421    }
1422    @Override
1423    public Response<List<GeoCoordinate>> geopos(byte[] key, byte[]... members) {
1424      return appendCommand(commandObjects.geopos(key, members));
1425    }
1426    @Override
1427    public Response<List<GeoRadiusResponse>> georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
1428      return appendCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
1429    }
1430    @Override
1431    public Response<List<GeoRadiusResponse>> georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
1432      return appendCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
1433    }
1434    @Override
1435    public Response<List<GeoRadiusResponse>> georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
1436      return appendCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
1437    }
1438    @Override
1439    public Response<List<GeoRadiusResponse>> georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
1440      return appendCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
1441    }
1442    @Override
1443    public Response<List<GeoRadiusResponse>> georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit) {
1444      return appendCommand(commandObjects.georadiusByMember(key, member, radius, unit));
1445    }
1446    @Override
1447    public Response<List<GeoRadiusResponse>> georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit) {
1448      return appendCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
1449    }
1450    @Override
1451    public Response<List<GeoRadiusResponse>> georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
1452      return appendCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
1453    }
1454    @Override
1455    public Response<List<GeoRadiusResponse>> georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
1456      return appendCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
1457    }
1458    @Override
1459    public Response<Long> georadiusStore(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
1460      return appendCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
1461    }
1462    @Override
1463    public Response<Long> georadiusByMemberStore(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
1464      return appendCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
1465    }
1466    @Override
1467    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, byte[] member, double radius, GeoUnit unit) {
1468      return appendCommand(commandObjects.geosearch(key, member, radius, unit));
1469    }
1470    @Override
1471    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, GeoCoordinate coord, double radius, GeoUnit unit) {
1472      return appendCommand(commandObjects.geosearch(key, coord, radius, unit));
1473    }
1474    @Override
1475    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, byte[] member, double width, double height, GeoUnit unit) {
1476      return appendCommand(commandObjects.geosearch(key, member, width, height, unit));
1477    }
1478    @Override
1479    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
1480      return appendCommand(commandObjects.geosearch(key, coord, width, height, unit));
1481    }
1482    @Override
1483    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, GeoSearchParam params) {
1484      return appendCommand(commandObjects.geosearch(key, params));
1485    }
1486    @Override
1487    public Response<Long> geosearchStore(byte[] dest, byte[] src, byte[] member, double radius, GeoUnit unit) {
1488      return appendCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
1489    }
1490    @Override
1491    public Response<Long> geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double radius, GeoUnit unit) {
1492      return appendCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
1493    }
1494    @Override
1495    public Response<Long> geosearchStore(byte[] dest, byte[] src, byte[] member, double width, double height, GeoUnit unit) {
1496      return appendCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
1497    }
1498    @Override
1499    public Response<Long> geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
1500      return appendCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
1501    }
1502    @Override
1503    public Response<Long> geosearchStore(byte[] dest, byte[] src, GeoSearchParam params) {
1504      return appendCommand(commandObjects.geosearchStore(dest, src, params));
1505    }
1506    @Override
1507    public Response<Long> geosearchStoreStoreDist(byte[] dest, byte[] src, GeoSearchParam params) {
1508      return appendCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
1509    }
1510    @Override
1511    public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
1512      return appendCommand(commandObjects.hset(key, field, value));
1513    }
1514    @Override
1515    public Response<Long> hset(byte[] key, Map<byte[], byte[]> hash) {
1516      return appendCommand(commandObjects.hset(key, hash));
1517    }
1518    @Override
1519    public Response<byte[]> hget(byte[] key, byte[] field) {
1520      return appendCommand(commandObjects.hget(key, field));
1521    }
1522    @Override
1523    public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
1524      return appendCommand(commandObjects.hsetnx(key, field, value));
1525    }
1526    @Override
1527    public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
1528      return appendCommand(commandObjects.hmset(key, hash));
1529    }
1530    @Override
1531    public Response<List<byte[]>> hmget(byte[] key, byte[]... fields) {
1532      return appendCommand(commandObjects.hmget(key, fields));
1533    }
1534    @Override
1535    public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
1536      return appendCommand(commandObjects.hincrBy(key, field, value));
1537    }
1538    @Override
1539    public Response<Double> hincrByFloat(byte[] key, byte[] field, double value) {
1540      return appendCommand(commandObjects.hincrByFloat(key, field, value));
1541    }
1542    @Override
1543    public Response<Boolean> hexists(byte[] key, byte[] field) {
1544      return appendCommand(commandObjects.hexists(key, field));
1545    }
1546    @Override
1547    public Response<Long> hdel(byte[] key, byte[]... field) {
1548      return appendCommand(commandObjects.hdel(key, field));
1549    }
1550    @Override
1551    public Response<Long> hlen(byte[] key) {
1552      return appendCommand(commandObjects.hlen(key));
1553    }
1554    @Override
1555    public Response<Set<byte[]>> hkeys(byte[] key) {
1556      return appendCommand(commandObjects.hkeys(key));
1557    }
1558    @Override
1559    public Response<List<byte[]>> hvals(byte[] key) {
1560      return appendCommand(commandObjects.hvals(key));
1561    }
1562    @Override
1563    public Response<Map<byte[], byte[]>> hgetAll(byte[] key) {
1564      return appendCommand(commandObjects.hgetAll(key));
1565    }
1566    @Override
1567    public Response<byte[]> hrandfield(byte[] key) {
1568      return appendCommand(commandObjects.hrandfield(key));
1569    }
1570    @Override
1571    public Response<List<byte[]>> hrandfield(byte[] key, long count) {
1572      return appendCommand(commandObjects.hrandfield(key, count));
1573    }
1574    @Override
1575    public Response<List<Map.Entry<byte[], byte[]>>> hrandfieldWithValues(byte[] key, long count) {
1576      return appendCommand(commandObjects.hrandfieldWithValues(key, count));
1577    }
1578    @Override
1579    public Response<ScanResult<Map.Entry<byte[], byte[]>>> hscan(byte[] key, byte[] cursor, ScanParams params) {
1580      return appendCommand(commandObjects.hscan(key, cursor, params));
1581    }
1582    @Override
1583    public Response<Long> hstrlen(byte[] key, byte[] field) {
1584      return appendCommand(commandObjects.hstrlen(key, field));
1585    }
1586    @Override
1587    public Response<Long> pfadd(byte[] key, byte[]... elements) {
1588      return appendCommand(commandObjects.pfadd(key, elements));
1589    }
1590    @Override
1591    public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
1592      return appendCommand(commandObjects.pfmerge(destkey, sourcekeys));
1593    }
1594    @Override
1595    public Response<Long> pfcount(byte[] key) {
1596      return appendCommand(commandObjects.pfcount(key));
1597    }
1598    @Override
1599    public Response<Long> pfcount(byte[]... keys) {
1600      return appendCommand(commandObjects.pfcount(keys));
1601    }
1602    @Override
1603    public Response<Boolean> exists(byte[] key) {
1604      return appendCommand(commandObjects.exists(key));
1605    }
1606    @Override
1607    public Response<Long> exists(byte[]... keys) {
1608      return appendCommand(commandObjects.exists(keys));
1609    }
1610    @Override
1611    public Response<Long> persist(byte[] key) {
1612      return appendCommand(commandObjects.persist(key));
1613    }
1614    @Override
1615    public Response<String> type(byte[] key) {
1616      return appendCommand(commandObjects.type(key));
1617    }
1618    @Override
1619    public Response<byte[]> dump(byte[] key) {
1620      return appendCommand(commandObjects.dump(key));
1621    }
1622    @Override
1623    public Response<String> restore(byte[] key, long ttl, byte[] serializedValue) {
1624      return appendCommand(commandObjects.restore(key, ttl, serializedValue));
1625    }
1626    @Override
1627    public Response<String> restore(byte[] key, long ttl, byte[] serializedValue, RestoreParams params) {
1628      return appendCommand(commandObjects.restore(key, ttl, serializedValue, params));
1629    }
1630    @Override
1631    public Response<Long> expire(byte[] key, long seconds) {
1632      return appendCommand(commandObjects.expire(key, seconds));
1633    }
1634    @Override
1635    public Response<Long> expire(byte[] key, long seconds, ExpiryOption expiryOption) {
1636      return appendCommand(commandObjects.expire(key, seconds, expiryOption));
1637    }
1638    @Override
1639    public Response<Long> pexpire(byte[] key, long milliseconds) {
1640      return appendCommand(commandObjects.pexpire(key, milliseconds));
1641    }
1642    @Override
1643    public Response<Long> pexpire(byte[] key, long milliseconds, ExpiryOption expiryOption) {
1644      return appendCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
1645    }
1646    @Override
1647    public Response<Long> expireTime(byte[] key) {
1648      return appendCommand(commandObjects.expireTime(key));
1649    }
1650    @Override
1651    public Response<Long> pexpireTime(byte[] key) {
1652      return appendCommand(commandObjects.pexpireTime(key));
1653    }
1654    @Override
1655    public Response<Long> expireAt(byte[] key, long unixTime) {
1656      return appendCommand(commandObjects.expireAt(key, unixTime));
1657    }
1658    @Override
1659    public Response<Long> expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {
1660      return appendCommand(commandObjects.expireAt(key, unixTime));
1661    }
1662    @Override
1663    public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp) {
1664      return appendCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
1665    }
1666    @Override
1667    public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp, ExpiryOption expiryOption) {
1668      return appendCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
1669    }
1670    @Override
1671    public Response<Long> ttl(byte[] key) {
1672      return appendCommand(commandObjects.ttl(key));
1673    }
1674    @Override
1675    public Response<Long> pttl(byte[] key) {
1676      return appendCommand(commandObjects.pttl(key));
1677    }
1678    @Override
1679    public Response<Long> touch(byte[] key) {
1680      return appendCommand(commandObjects.touch(key));
1681    }
1682    @Override
1683    public Response<Long> touch(byte[]... keys) {
1684      return appendCommand(commandObjects.touch(keys));
1685    }
1686    @Override
1687    public Response<List<byte[]>> sort(byte[] key) {
1688      return appendCommand(commandObjects.sort(key));
1689    }
1690    @Override
1691    public Response<List<byte[]>> sort(byte[] key, SortingParams sortingParams) {
1692      return appendCommand(commandObjects.sort(key, sortingParams));
1693    }
1694    @Override
1695    public Response<List<byte[]>> sortReadonly(byte[] key, SortingParams sortingParams) {
1696      return appendCommand(commandObjects.sortReadonly(key, sortingParams));
1697    }
1698    @Override
1699    public Response<Long> del(byte[] key) {
1700      return appendCommand(commandObjects.del(key));
1701    }
1702    @Override
1703    public Response<Long> del(byte[]... keys) {
1704      return appendCommand(commandObjects.del(keys));
1705    }
1706    @Override
1707    public Response<Long> unlink(byte[] key) {
1708      return appendCommand(commandObjects.unlink(key));
1709    }
1710    @Override
1711    public Response<Long> unlink(byte[]... keys) {
1712      return appendCommand(commandObjects.unlink(keys));
1713    }
1714    @Override
1715    public Response<Boolean> copy(byte[] srcKey, byte[] dstKey, boolean replace) {
1716      return appendCommand(commandObjects.copy(srcKey, dstKey, replace));
1717    }
1718    @Override
1719    public Response<String> rename(byte[] oldkey, byte[] newkey) {
1720      return appendCommand(commandObjects.rename(oldkey, newkey));
1721    }
1722    @Override
1723    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
1724      return appendCommand(commandObjects.renamenx(oldkey, newkey));
1725    }
1726    @Override
1727    public Response<Long> sort(byte[] key, SortingParams sortingParams, byte[] dstkey) {
1728      return appendCommand(commandObjects.sort(key, sortingParams, dstkey));
1729    }
1730    @Override
1731    public Response<Long> sort(byte[] key, byte[] dstkey) {
1732      return appendCommand(commandObjects.sort(key, dstkey));
1733    }
1734    @Override
1735    public Response<Long> memoryUsage(byte[] key) {
1736      return appendCommand(commandObjects.memoryUsage(key));
1737    }
1738    @Override
1739    public Response<Long> memoryUsage(byte[] key, int samples) {
1740      return appendCommand(commandObjects.memoryUsage(key, samples));
1741    }
1742    @Override
1743    public Response<Long> objectRefcount(byte[] key) {
1744      return appendCommand(commandObjects.objectRefcount(key));
1745    }
1746    @Override
1747    public Response<byte[]> objectEncoding(byte[] key) {
1748      return appendCommand(commandObjects.objectEncoding(key));
1749    }
1750    @Override
1751    public Response<Long> objectIdletime(byte[] key) {
1752      return appendCommand(commandObjects.objectIdletime(key));
1753    }
1754    @Override
1755    public Response<Long> objectFreq(byte[] key) {
1756      return appendCommand(commandObjects.objectFreq(key));
1757    }
1758    @Override
1759    public Response<String> migrate(String host, int port, byte[] key, int timeout) {
1760      return appendCommand(commandObjects.migrate(host, port, key, timeout));
1761    }
1762    @Override
1763    public Response<String> migrate(String host, int port, int timeout, MigrateParams params, byte[]... keys) {
1764      return appendCommand(commandObjects.migrate(host, port, timeout, params, keys));
1765    }
1766    @Override
1767    public Response<Set<byte[]>> keys(byte[] pattern) {
1768      return appendCommand(commandObjects.keys(pattern));
1769    }
1770    @Override
1771    public Response<ScanResult<byte[]>> scan(byte[] cursor) {
1772      return appendCommand(commandObjects.scan(cursor));
1773    }
1774    @Override
1775    public Response<ScanResult<byte[]>> scan(byte[] cursor, ScanParams params) {
1776      return appendCommand(commandObjects.scan(cursor, params));
1777    }
1778    @Override
1779    public Response<ScanResult<byte[]>> scan(byte[] cursor, ScanParams params, byte[] type) {
1780      return appendCommand(commandObjects.scan(cursor, params, type));
1781    }
1782    @Override
1783    public Response<byte[]> randomBinaryKey() {
1784      return appendCommand(commandObjects.randomBinaryKey());
1785    }
1786    @Override
1787    public Response<Long> rpush(byte[] key, byte[]... args) {
1788      return appendCommand(commandObjects.rpush(key, args));
1789    }
1790    @Override
1791    public Response<Long> lpush(byte[] key, byte[]... args) {
1792      return appendCommand(commandObjects.lpush(key, args));
1793    }
1794    @Override
1795    public Response<Long> llen(byte[] key) {
1796      return appendCommand(commandObjects.llen(key));
1797    }
1798    @Override
1799    public Response<List<byte[]>> lrange(byte[] key, long start, long stop) {
1800      return appendCommand(commandObjects.lrange(key, start, stop));
1801    }
1802    @Override
1803    public Response<String> ltrim(byte[] key, long start, long stop) {
1804      return appendCommand(commandObjects.ltrim(key, start, stop));
1805    }
1806    @Override
1807    public Response<byte[]> lindex(byte[] key, long index) {
1808      return appendCommand(commandObjects.lindex(key, index));
1809    }
1810    @Override
1811    public Response<String> lset(byte[] key, long index, byte[] value) {
1812      return appendCommand(commandObjects.lset(key, index, value));
1813    }
1814    @Override
1815    public Response<Long> lrem(byte[] key, long count, byte[] value) {
1816      return appendCommand(commandObjects.lrem(key, count, value));
1817    }
1818    @Override
1819    public Response<byte[]> lpop(byte[] key) {
1820      return appendCommand(commandObjects.lpop(key));
1821    }
1822    @Override
1823    public Response<List<byte[]>> lpop(byte[] key, int count) {
1824      return appendCommand(commandObjects.lpop(key, count));
1825    }
1826    @Override
1827    public Response<Long> lpos(byte[] key, byte[] element) {
1828      return appendCommand(commandObjects.lpos(key, element));
1829    }
1830    @Override
1831    public Response<Long> lpos(byte[] key, byte[] element, LPosParams params) {
1832      return appendCommand(commandObjects.lpos(key, element, params));
1833    }
1834    @Override
1835    public Response<List<Long>> lpos(byte[] key, byte[] element, LPosParams params, long count) {
1836      return appendCommand(commandObjects.lpos(key, element, params, count));
1837    }
1838    @Override
1839    public Response<byte[]> rpop(byte[] key) {
1840      return appendCommand(commandObjects.rpop(key));
1841    }
1842    @Override
1843    public Response<List<byte[]>> rpop(byte[] key, int count) {
1844      return appendCommand(commandObjects.rpop(key, count));
1845    }
1846    @Override
1847    public Response<Long> linsert(byte[] key, ListPosition where, byte[] pivot, byte[] value) {
1848      return appendCommand(commandObjects.linsert(key, where, pivot, value));
1849    }
1850    @Override
1851    public Response<Long> lpushx(byte[] key, byte[]... args) {
1852      return appendCommand(commandObjects.lpushx(key, args));
1853    }
1854    @Override
1855    public Response<Long> rpushx(byte[] key, byte[]... args) {
1856      return appendCommand(commandObjects.rpushx(key, args));
1857    }
1858    @Override
1859    public Response<List<byte[]>> blpop(int timeout, byte[]... keys) {
1860      return appendCommand(commandObjects.blpop(timeout, keys));
1861    }
1862    @Override
1863    public Response<KeyValue<byte[], byte[]>> blpop(double timeout, byte[]... keys) {
1864      return appendCommand(commandObjects.blpop(timeout, keys));
1865    }
1866    @Override
1867    public Response<List<byte[]>> brpop(int timeout, byte[]... keys) {
1868      return appendCommand(commandObjects.brpop(timeout, keys));
1869    }
1870    @Override
1871    public Response<KeyValue<byte[], byte[]>> brpop(double timeout, byte[]... keys) {
1872      return appendCommand(commandObjects.brpop(timeout, keys));
1873    }
1874    @Override
1875    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
1876      return appendCommand(commandObjects.rpoplpush(srckey, dstkey));
1877    }
1878    @Override
1879    public Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout) {
1880      return appendCommand(commandObjects.brpoplpush(source, destination, timeout));
1881    }
1882    @Override
1883    public Response<byte[]> lmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to) {
1884      return appendCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1885    }
1886    @Override
1887    public Response<byte[]> blmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to, double timeout) {
1888      return appendCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1889    }
1890    @Override
1891    public Response<KeyValue<byte[], List<byte[]>>> lmpop(ListDirection direction, byte[]... keys) {
1892      return appendCommand(commandObjects.lmpop(direction, keys));
1893    }
1894    @Override
1895    public Response<KeyValue<byte[], List<byte[]>>> lmpop(ListDirection direction, int count, byte[]... keys) {
1896      return appendCommand(commandObjects.lmpop(direction, count, keys));
1897    }
1898    @Override
1899    public Response<KeyValue<byte[], List<byte[]>>> blmpop(double timeout, ListDirection direction, byte[]... keys) {
1900      return appendCommand(commandObjects.blmpop(timeout, direction, keys));
1901    }
1902    @Override
1903    public Response<KeyValue<byte[], List<byte[]>>> blmpop(double timeout, ListDirection direction, int count, byte[]... keys) {
1904      return appendCommand(commandObjects.blmpop(timeout, direction, count, keys));
1905    }
1906    @Override
1907    public Response<Long> waitReplicas(byte[] sampleKey, int replicas, long timeout) {
1908      return appendCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
1909    }
1910    @Override
1911    public Response<KeyValue<Long, Long>> waitAOF(byte[] sampleKey, long numLocal, long numReplicas, long timeout) {
1912      return appendCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
1913    }
1914    @Override
1915    public Response<Object> eval(byte[] script, byte[] sampleKey) {
1916      return appendCommand(commandObjects.eval(script, sampleKey));
1917    }
1918    @Override
1919    public Response<Object> evalsha(byte[] sha1, byte[] sampleKey) {
1920      return appendCommand(commandObjects.evalsha(sha1, sampleKey));
1921    }
1922    @Override
1923    public Response<List<Boolean>> scriptExists(byte[] sampleKey, byte[]... sha1s) {
1924      return appendCommand(commandObjects.scriptExists(sampleKey, sha1s));
1925    }
1926    @Override
1927    public Response<byte[]> scriptLoad(byte[] script, byte[] sampleKey) {
1928      return appendCommand(commandObjects.scriptLoad(script, sampleKey));
1929    }
1930    @Override
1931    public Response<String> scriptFlush(byte[] sampleKey) {
1932      return appendCommand(commandObjects.scriptFlush(sampleKey));
1933    }
1934    @Override
1935    public Response<String> scriptFlush(byte[] sampleKey, FlushMode flushMode) {
1936      return appendCommand(commandObjects.scriptFlush(sampleKey, flushMode));
1937    }
1938    @Override
1939    public Response<String> scriptKill(byte[] sampleKey) {
1940      return appendCommand(commandObjects.scriptKill(sampleKey));
1941    }
1942    @Override
1943    public Response<Object> eval(byte[] script) {
1944      return appendCommand(commandObjects.eval(script));
1945    }
1946    @Override
1947    public Response<Object> eval(byte[] script, int keyCount, byte[]... params) {
1948      return appendCommand(commandObjects.eval(script, keyCount, params));
1949    }
1950    @Override
1951    public Response<Object> eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
1952      return appendCommand(commandObjects.eval(script, keys, args));
1953    }
1954    @Override
1955    public Response<Object> evalReadonly(byte[] script, List<byte[]> keys, List<byte[]> args) {
1956      return appendCommand(commandObjects.evalReadonly(script, keys, args));
1957    }
1958    @Override
1959    public Response<Object> evalsha(byte[] sha1) {
1960      return appendCommand(commandObjects.evalsha(sha1));
1961    }
1962    @Override
1963    public Response<Object> evalsha(byte[] sha1, int keyCount, byte[]... params) {
1964      return appendCommand(commandObjects.evalsha(sha1, keyCount, params));
1965    }
1966    @Override
1967    public Response<Object> evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
1968      return appendCommand(commandObjects.evalsha(sha1, keys, args));
1969    }
1970    @Override
1971    public Response<Object> evalshaReadonly(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
1972      return appendCommand(commandObjects.evalshaReadonly(sha1, keys, args));
1973    }
1974    @Override
1975    public Response<Long> sadd(byte[] key, byte[]... members) {
1976      return appendCommand(commandObjects.sadd(key, members));
1977    }
1978    @Override
1979    public Response<Set<byte[]>> smembers(byte[] key) {
1980      return appendCommand(commandObjects.smembers(key));
1981    }
1982    @Override
1983    public Response<Long> srem(byte[] key, byte[]... members) {
1984      return appendCommand(commandObjects.srem(key, members));
1985    }
1986    @Override
1987    public Response<byte[]> spop(byte[] key) {
1988      return appendCommand(commandObjects.spop(key));
1989    }
1990    @Override
1991    public Response<Set<byte[]>> spop(byte[] key, long count) {
1992      return appendCommand(commandObjects.spop(key, count));
1993    }
1994    @Override
1995    public Response<Long> scard(byte[] key) {
1996      return appendCommand(commandObjects.scard(key));
1997    }
1998    @Override
1999    public Response<Boolean> sismember(byte[] key, byte[] member) {
2000      return appendCommand(commandObjects.sismember(key, member));
2001    }
2002    @Override
2003    public Response<List<Boolean>> smismember(byte[] key, byte[]... members) {
2004      return appendCommand(commandObjects.smismember(key, members));
2005    }
2006    @Override
2007    public Response<byte[]> srandmember(byte[] key) {
2008      return appendCommand(commandObjects.srandmember(key));
2009    }
2010    @Override
2011    public Response<List<byte[]>> srandmember(byte[] key, int count) {
2012      return appendCommand(commandObjects.srandmember(key, count));
2013    }
2014    @Override
2015    public Response<ScanResult<byte[]>> sscan(byte[] key, byte[] cursor, ScanParams params) {
2016      return appendCommand(commandObjects.sscan(key, cursor, params));
2017    }
2018    @Override
2019    public Response<Set<byte[]>> sdiff(byte[]... keys) {
2020      return appendCommand(commandObjects.sdiff(keys));
2021    }
2022    @Override
2023    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
2024      return appendCommand(commandObjects.sdiffstore(dstkey, keys));
2025    }
2026    @Override
2027    public Response<Set<byte[]>> sinter(byte[]... keys) {
2028      return appendCommand(commandObjects.sinter(keys));
2029    }
2030    @Override
2031    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
2032      return appendCommand(commandObjects.sinterstore(dstkey, keys));
2033    }
2034    @Override
2035    public Response<Long> sintercard(byte[]... keys) {
2036      return appendCommand(commandObjects.sintercard(keys));
2037    }
2038    @Override
2039    public Response<Long> sintercard(int limit, byte[]... keys) {
2040      return appendCommand(commandObjects.sintercard(limit, keys));
2041    }
2042    @Override
2043    public Response<Set<byte[]>> sunion(byte[]... keys) {
2044      return appendCommand(commandObjects.sunion(keys));
2045    }
2046    @Override
2047    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
2048      return appendCommand(commandObjects.sunionstore(dstkey, keys));
2049    }
2050    @Override
2051    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
2052      return appendCommand(commandObjects.smove(srckey, dstkey, member));
2053    }
2054    @Override
2055    public Response<Long> zadd(byte[] key, double score, byte[] member) {
2056      return appendCommand(commandObjects.zadd(key, score, member));
2057    }
2058    @Override
2059    public Response<Long> zadd(byte[] key, double score, byte[] member, ZAddParams params) {
2060      return appendCommand(commandObjects.zadd(key, score, member, params));
2061    }
2062    @Override
2063    public Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers) {
2064      return appendCommand(commandObjects.zadd(key, scoreMembers));
2065    }
2066    @Override
2067    public Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params) {
2068      return appendCommand(commandObjects.zadd(key, scoreMembers, params));
2069    }
2070    @Override
2071    public Response<Double> zaddIncr(byte[] key, double score, byte[] member, ZAddParams params) {
2072      return appendCommand(commandObjects.zaddIncr(key, score, member, params));
2073    }
2074    @Override
2075    public Response<Long> zrem(byte[] key, byte[]... members) {
2076      return appendCommand(commandObjects.zrem(key, members));
2077    }
2078    @Override
2079    public Response<Double> zincrby(byte[] key, double increment, byte[] member) {
2080      return appendCommand(commandObjects.zincrby(key, increment, member));
2081    }
2082    @Override
2083    public Response<Double> zincrby(byte[] key, double increment, byte[] member, ZIncrByParams params) {
2084      return appendCommand(commandObjects.zincrby(key, increment, member, params));
2085    }
2086    @Override
2087    public Response<Long> zrank(byte[] key, byte[] member) {
2088      return appendCommand(commandObjects.zrank(key, member));
2089    }
2090    @Override
2091    public Response<Long> zrevrank(byte[] key, byte[] member) {
2092      return appendCommand(commandObjects.zrevrank(key, member));
2093    }
2094    @Override
2095    public Response<KeyValue<Long, Double>> zrankWithScore(byte[] key, byte[] member) {
2096      return appendCommand(commandObjects.zrankWithScore(key, member));
2097    }
2098    @Override
2099    public Response<KeyValue<Long, Double>> zrevrankWithScore(byte[] key, byte[] member) {
2100      return appendCommand(commandObjects.zrevrankWithScore(key, member));
2101    }
2102    @Override
2103    public Response<List<byte[]>> zrange(byte[] key, long start, long stop) {
2104      return appendCommand(commandObjects.zrange(key, start, stop));
2105    }
2106    @Override
2107    public Response<List<byte[]>> zrevrange(byte[] key, long start, long stop) {
2108      return appendCommand(commandObjects.zrevrange(key, start, stop));
2109    }
2110    @Override
2111    public Response<List<Tuple>> zrangeWithScores(byte[] key, long start, long stop) {
2112      return appendCommand(commandObjects.zrangeWithScores(key, start, stop));
2113    }
2114    @Override
2115    public Response<List<Tuple>> zrevrangeWithScores(byte[] key, long start, long stop) {
2116      return appendCommand(commandObjects.zrevrangeWithScores(key, start, stop));
2117    }
2118    @Override
2119    public Response<byte[]> zrandmember(byte[] key) {
2120      return appendCommand(commandObjects.zrandmember(key));
2121    }
2122    @Override
2123    public Response<List<byte[]>> zrandmember(byte[] key, long count) {
2124      return appendCommand(commandObjects.zrandmember(key, count));
2125    }
2126    @Override
2127    public Response<List<Tuple>> zrandmemberWithScores(byte[] key, long count) {
2128      return appendCommand(commandObjects.zrandmemberWithScores(key, count));
2129    }
2130    @Override
2131    public Response<Long> zcard(byte[] key) {
2132      return appendCommand(commandObjects.zcard(key));
2133    }
2134    @Override
2135    public Response<Double> zscore(byte[] key, byte[] member) {
2136      return appendCommand(commandObjects.zscore(key, member));
2137    }
2138    @Override
2139    public Response<List<Double>> zmscore(byte[] key, byte[]... members) {
2140      return appendCommand(commandObjects.zmscore(key, members));
2141    }
2142    @Override
2143    public Response<Tuple> zpopmax(byte[] key) {
2144      return appendCommand(commandObjects.zpopmax(key));
2145    }
2146    @Override
2147    public Response<List<Tuple>> zpopmax(byte[] key, int count) {
2148      return appendCommand(commandObjects.zpopmax(key, count));
2149    }
2150    @Override
2151    public Response<Tuple> zpopmin(byte[] key) {
2152      return appendCommand(commandObjects.zpopmin(key));
2153    }
2154    @Override
2155    public Response<List<Tuple>> zpopmin(byte[] key, int count) {
2156      return appendCommand(commandObjects.zpopmin(key, count));
2157    }
2158    @Override
2159    public Response<Long> zcount(byte[] key, double min, double max) {
2160      return appendCommand(commandObjects.zcount(key, min, max));
2161    }
2162    @Override
2163    public Response<Long> zcount(byte[] key, byte[] min, byte[] max) {
2164      return appendCommand(commandObjects.zcount(key, min, max));
2165    }
2166    @Override
2167    public Response<List<byte[]>> zrangeByScore(byte[] key, double min, double max) {
2168      return appendCommand(commandObjects.zrangeByScore(key, min, max));
2169    }
2170    @Override
2171    public Response<List<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max) {
2172      return appendCommand(commandObjects.zrangeByScore(key, min, max));
2173    }
2174    @Override
2175    public Response<List<byte[]>> zrevrangeByScore(byte[] key, double max, double min) {
2176      return appendCommand(commandObjects.zrevrangeByScore(key, max, min));
2177    }
2178    @Override
2179    public Response<List<byte[]>> zrangeByScore(byte[] key, double min, double max, int offset, int count) {
2180      return appendCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
2181    }
2182    @Override
2183    public Response<List<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
2184      return appendCommand(commandObjects.zrevrangeByScore(key, max, min));
2185    }
2186    @Override
2187    public Response<List<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count) {
2188      return appendCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
2189    }
2190    @Override
2191    public Response<List<byte[]>> zrevrangeByScore(byte[] key, double max, double min, int offset, int count) {
2192      return appendCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
2193    }
2194    @Override
2195    public Response<List<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max) {
2196      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
2197    }
2198    @Override
2199    public Response<List<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min) {
2200      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
2201    }
2202    @Override
2203    public Response<List<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count) {
2204      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
2205    }
2206    @Override
2207    public Response<List<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count) {
2208      return appendCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
2209    }
2210    @Override
2211    public Response<List<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max) {
2212      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
2213    }
2214    @Override
2215    public Response<List<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min) {
2216      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
2217    }
2218    @Override
2219    public Response<List<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count) {
2220      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
2221    }
2222    @Override
2223    public Response<List<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count) {
2224      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
2225    }
2226    @Override
2227    public Response<List<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count) {
2228      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
2229    }
2230    @Override
2231    public Response<Long> zremrangeByRank(byte[] key, long start, long stop) {
2232      return appendCommand(commandObjects.zremrangeByRank(key, start, stop));
2233    }
2234    @Override
2235    public Response<Long> zremrangeByScore(byte[] key, double min, double max) {
2236      return appendCommand(commandObjects.zremrangeByScore(key, min, max));
2237    }
2238    @Override
2239    public Response<Long> zremrangeByScore(byte[] key, byte[] min, byte[] max) {
2240      return appendCommand(commandObjects.zremrangeByScore(key, min, max));
2241    }
2242    @Override
2243    public Response<Long> zlexcount(byte[] key, byte[] min, byte[] max) {
2244      return appendCommand(commandObjects.zlexcount(key, min, max));
2245    }
2246    @Override
2247    public Response<List<byte[]>> zrangeByLex(byte[] key, byte[] min, byte[] max) {
2248      return appendCommand(commandObjects.zrangeByLex(key, min, max));
2249    }
2250    @Override
2251    public Response<List<byte[]>> zrangeByLex(byte[] key, byte[] min, byte[] max, int offset, int count) {
2252      return appendCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
2253    }
2254    @Override
2255    public Response<List<byte[]>> zrevrangeByLex(byte[] key, byte[] max, byte[] min) {
2256      return appendCommand(commandObjects.zrevrangeByLex(key, max, min));
2257    }
2258    @Override
2259    public Response<List<byte[]>> zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count) {
2260      return appendCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
2261    }
2262    @Override
2263    public Response<List<byte[]>> zrange(byte[] key, ZRangeParams zRangeParams) {
2264      return appendCommand(commandObjects.zrange(key, zRangeParams));
2265    }
2266    @Override
2267    public Response<List<Tuple>> zrangeWithScores(byte[] key, ZRangeParams zRangeParams) {
2268      return appendCommand(commandObjects.zrangeWithScores(key, zRangeParams));
2269    }
2270    @Override
2271    public Response<Long> zrangestore(byte[] dest, byte[] src, ZRangeParams zRangeParams) {
2272      return appendCommand(commandObjects.zrangestore(dest, src, zRangeParams));
2273    }
2274    @Override
2275    public Response<Long> zremrangeByLex(byte[] key, byte[] min, byte[] max) {
2276      return appendCommand(commandObjects.zremrangeByLex(key, min, max));
2277    }
2278    @Override
2279    public Response<ScanResult<Tuple>> zscan(byte[] key, byte[] cursor, ScanParams params) {
2280      return appendCommand(commandObjects.zscan(key, cursor, params));
2281    }
2282    @Override
2283    public Response<KeyValue<byte[], Tuple>> bzpopmax(double timeout, byte[]... keys) {
2284      return appendCommand(commandObjects.bzpopmax(timeout, keys));
2285    }
2286    @Override
2287    public Response<KeyValue<byte[], Tuple>> bzpopmin(double timeout, byte[]... keys) {
2288      return appendCommand(commandObjects.bzpopmin(timeout, keys));
2289    }
2290    @Override
2291    public Response<KeyValue<byte[], List<Tuple>>> zmpop(SortedSetOption option, byte[]... keys) {
2292      return appendCommand(commandObjects.zmpop(option, keys));
2293    }
2294    @Override
2295    public Response<KeyValue<byte[], List<Tuple>>> zmpop(SortedSetOption option, int count, byte[]... keys) {
2296      return appendCommand(commandObjects.zmpop(option, count, keys));
2297    }
2298    @Override
2299    public Response<KeyValue<byte[], List<Tuple>>> bzmpop(double timeout, SortedSetOption option, byte[]... keys) {
2300      return appendCommand(commandObjects.bzmpop(timeout, option, keys));
2301    }
2302    @Override
2303    public Response<KeyValue<byte[], List<Tuple>>> bzmpop(double timeout, SortedSetOption option, int count, byte[]... keys) {
2304      return appendCommand(commandObjects.bzmpop(timeout, option, count, keys));
2305    }
2306    @Override
2307    public Response<List<byte[]>> zdiff(byte[]... keys) {
2308      return appendCommand(commandObjects.zdiff(keys));
2309    }
2310    @Override
2311    public Response<List<Tuple>> zdiffWithScores(byte[]... keys) {
2312      return appendCommand(commandObjects.zdiffWithScores(keys));
2313    }
2314    @Override
2315    @Deprecated
2316    public Response<Long> zdiffStore(byte[] dstkey, byte[]... keys) {
2317      return appendCommand(commandObjects.zdiffStore(dstkey, keys));
2318    }
2319    @Override
2320    public Response<Long> zdiffstore(byte[] dstkey, byte[]... keys) {
2321      return appendCommand(commandObjects.zdiffstore(dstkey, keys));
2322    }
2323    @Override
2324    public Response<List<byte[]>> zinter(ZParams params, byte[]... keys) {
2325      return appendCommand(commandObjects.zinter(params, keys));
2326    }
2327    @Override
2328    public Response<List<Tuple>> zinterWithScores(ZParams params, byte[]... keys) {
2329      return appendCommand(commandObjects.zinterWithScores(params, keys));
2330    }
2331    @Override
2332    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
2333      return appendCommand(commandObjects.zinterstore(dstkey, sets));
2334    }
2335    @Override
2336    public Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
2337      return appendCommand(commandObjects.zinterstore(dstkey, params, sets));
2338    }
2339    @Override
2340    public Response<Long> zintercard(byte[]... keys) {
2341      return appendCommand(commandObjects.zintercard(keys));
2342    }
2343    @Override
2344    public Response<Long> zintercard(long limit, byte[]... keys) {
2345      return appendCommand(commandObjects.zintercard(limit, keys));
2346    }
2347    @Override
2348    public Response<List<byte[]>> zunion(ZParams params, byte[]... keys) {
2349      return appendCommand(commandObjects.zunion(params, keys));
2350    }
2351    @Override
2352    public Response<List<Tuple>> zunionWithScores(ZParams params, byte[]... keys) {
2353      return appendCommand(commandObjects.zunionWithScores(params, keys));
2354    }
2355    @Override
2356    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
2357      return appendCommand(commandObjects.zunionstore(dstkey, sets));
2358    }
2359    @Override
2360    public Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
2361      return appendCommand(commandObjects.zunionstore(dstkey, params, sets));
2362    }
2363    @Override
2364    public Response<byte[]> xadd(byte[] key, XAddParams params, Map<byte[], byte[]> hash) {
2365      return appendCommand(commandObjects.xadd(key, params, hash));
2366    }
2367    @Override
2368    public Response<Long> xlen(byte[] key) {
2369      return appendCommand(commandObjects.xlen(key));
2370    }
2371    @Override
2372    public Response<List<byte[]>> xrange(byte[] key, byte[] start, byte[] end) {
2373      return appendCommand(commandObjects.xrange(key, start, end));
2374    }
2375    @Override
2376    public Response<List<byte[]>> xrange(byte[] key, byte[] start, byte[] end, int count) {
2377      return appendCommand(commandObjects.xrange(key, start, end, count));
2378    }
2379    @Override
2380    public Response<List<byte[]>> xrevrange(byte[] key, byte[] end, byte[] start) {
2381      return appendCommand(commandObjects.xrevrange(key, end, start));
2382    }
2383    @Override
2384    public Response<List<byte[]>> xrevrange(byte[] key, byte[] end, byte[] start, int count) {
2385      return appendCommand(commandObjects.xrevrange(key, end, start, count));
2386    }
2387    @Override
2388    public Response<Long> xack(byte[] key, byte[] group, byte[]... ids) {
2389      return appendCommand(commandObjects.xack(key, group, ids));
2390    }
2391    @Override
2392    public Response<String> xgroupCreate(byte[] key, byte[] groupName, byte[] id, boolean makeStream) {
2393      return appendCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
2394    }
2395    @Override
2396    public Response<String> xgroupSetID(byte[] key, byte[] groupName, byte[] id) {
2397      return appendCommand(commandObjects.xgroupSetID(key, groupName, id));
2398    }
2399    @Override
2400    public Response<Long> xgroupDestroy(byte[] key, byte[] groupName) {
2401      return appendCommand(commandObjects.xgroupDestroy(key, groupName));
2402    }
2403    @Override
2404    public Response<Boolean> xgroupCreateConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2405      return appendCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2406    }
2407    @Override
2408    public Response<Long> xgroupDelConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2409      return appendCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2410    }
2411    @Override
2412    public Response<Long> xdel(byte[] key, byte[]... ids) {
2413      return appendCommand(commandObjects.xdel(key, ids));
2414    }
2415    @Override
2416    public Response<Long> xtrim(byte[] key, long maxLen, boolean approximateLength) {
2417      return appendCommand(commandObjects.xtrim(key, maxLen, approximateLength));
2418    }
2419    @Override
2420    public Response<Long> xtrim(byte[] key, XTrimParams params) {
2421      return appendCommand(commandObjects.xtrim(key, params));
2422    }
2423    @Override
2424    public Response<Object> xpending(byte[] key, byte[] groupName) {
2425      return appendCommand(commandObjects.xpending(key, groupName));
2426    }
2427    @Override
2428    public Response<List<Object>> xpending(byte[] key, byte[] groupName, XPendingParams params) {
2429      return appendCommand(commandObjects.xpending(key, groupName, params));
2430    }
2431    @Override
2432    public Response<List<byte[]>> xclaim(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2433      return appendCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2434    }
2435    @Override
2436    public Response<List<byte[]>> xclaimJustId(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2437      return appendCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2438    }
2439    @Override
2440    public Response<List<Object>> xautoclaim(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2441      return appendCommand(commandObjects.xautoclaim(key, groupName, consumerName, minIdleTime, start, params));
2442    }
2443    @Override
2444    public Response<List<Object>> xautoclaimJustId(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2445      return appendCommand(commandObjects.xautoclaimJustId(key, groupName, consumerName, minIdleTime, start, params));
2446    }
2447    @Override
2448    public Response<Object> xinfoStream(byte[] key) {
2449      return appendCommand(commandObjects.xinfoStream(key));
2450    }
2451    @Override
2452    public Response<Object> xinfoStreamFull(byte[] key) {
2453      return appendCommand(commandObjects.xinfoStreamFull(key));
2454    }
2455    @Override
2456    public Response<Object> xinfoStreamFull(byte[] key, int count) {
2457      return appendCommand(commandObjects.xinfoStreamFull(key, count));
2458    }
2459    @Override
2460    public Response<List<Object>> xinfoGroups(byte[] key) {
2461      return appendCommand(commandObjects.xinfoGroups(key));
2462    }
2463    @Override
2464    public Response<List<Object>> xinfoConsumers(byte[] key, byte[] group) {
2465      return appendCommand(commandObjects.xinfoConsumers(key, group));
2466    }
2467    @Override
2468    public Response<List<byte[]>> xread(XReadParams xReadParams, Map.Entry<byte[], byte[]>... streams) {
2469      return appendCommand(commandObjects.xread(xReadParams, streams));
2470    }
2471    @Override
2472    public Response<List<byte[]>> xreadGroup(byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {
2473      return appendCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2474    }
2475    @Override
2476    public Response<String> set(byte[] key, byte[] value) {
2477      return appendCommand(commandObjects.set(key, value));
2478    }
2479    @Override
2480    public Response<String> set(byte[] key, byte[] value, SetParams params) {
2481      return appendCommand(commandObjects.set(key, value, params));
2482    }
2483    @Override
2484    public Response<byte[]> get(byte[] key) {
2485      return appendCommand(commandObjects.get(key));
2486    }
2487    @Override
2488    public Response<byte[]> setGet(byte[] key, byte[] value, SetParams params) {
2489      return appendCommand(commandObjects.setGet(key, value, params));
2490    }
2491    @Override
2492    public Response<byte[]> getDel(byte[] key) {
2493      return appendCommand(commandObjects.getDel(key));
2494    }
2495    @Override
2496    public Response<byte[]> getEx(byte[] key, GetExParams params) {
2497      return appendCommand(commandObjects.getEx(key, params));
2498    }
2499    @Override
2500    public Response<Boolean> setbit(byte[] key, long offset, boolean value) {
2501      return appendCommand(commandObjects.setbit(key, offset, value));
2502    }
2503    @Override
2504    public Response<Boolean> getbit(byte[] key, long offset) {
2505      return appendCommand(commandObjects.getbit(key, offset));
2506    }
2507    @Override
2508    public Response<Long> setrange(byte[] key, long offset, byte[] value) {
2509      return appendCommand(commandObjects.setrange(key, offset, value));
2510    }
2511    @Override
2512    public Response<byte[]> getrange(byte[] key, long startOffset, long endOffset) {
2513      return appendCommand(commandObjects.getrange(key, startOffset, endOffset));
2514    }
2515    @Override
2516    public Response<byte[]> getSet(byte[] key, byte[] value) {
2517      return appendCommand(commandObjects.getSet(key, value));
2518    }
2519    @Override
2520    public Response<Long> setnx(byte[] key, byte[] value) {
2521      return appendCommand(commandObjects.setnx(key, value));
2522    }
2523    @Override
2524    public Response<String> setex(byte[] key, long seconds, byte[] value) {
2525      return appendCommand(commandObjects.setex(key, seconds, value));
2526    }
2527    @Override
2528    public Response<String> psetex(byte[] key, long milliseconds, byte[] value) {
2529      return appendCommand(commandObjects.psetex(key, milliseconds, value));
2530    }
2531    @Override
2532    public Response<List<byte[]>> mget(byte[]... keys) {
2533      return appendCommand(commandObjects.mget(keys));
2534    }
2535    @Override
2536    public Response<String> mset(byte[]... keysvalues) {
2537      return appendCommand(commandObjects.mset(keysvalues));
2538    }
2539    @Override
2540    public Response<Long> msetnx(byte[]... keysvalues) {
2541      return appendCommand(commandObjects.msetnx(keysvalues));
2542    }
2543    @Override
2544    public Response<Long> incr(byte[] key) {
2545      return appendCommand(commandObjects.incr(key));
2546    }
2547    @Override
2548    public Response<Long> incrBy(byte[] key, long increment) {
2549      return appendCommand(commandObjects.incrBy(key, increment));
2550    }
2551    @Override
2552    public Response<Double> incrByFloat(byte[] key, double increment) {
2553      return appendCommand(commandObjects.incrByFloat(key, increment));
2554    }
2555    @Override
2556    public Response<Long> decr(byte[] key) {
2557      return appendCommand(commandObjects.decr(key));
2558    }
2559    @Override
2560    public Response<Long> decrBy(byte[] key, long decrement) {
2561      return appendCommand(commandObjects.decrBy(key, decrement));
2562    }
2563    @Override
2564    public Response<Long> append(byte[] key, byte[] value) {
2565      return appendCommand(commandObjects.append(key, value));
2566    }
2567    @Override
2568    public Response<byte[]> substr(byte[] key, int start, int end) {
2569      return appendCommand(commandObjects.substr(key, start, end));
2570    }
2571    @Override
2572    public Response<Long> strlen(byte[] key) {
2573      return appendCommand(commandObjects.strlen(key));
2574    }
2575    @Override
2576    public Response<Long> bitcount(byte[] key) {
2577      return appendCommand(commandObjects.bitcount(key));
2578    }
2579    @Override
2580    public Response<Long> bitcount(byte[] key, long start, long end) {
2581      return appendCommand(commandObjects.bitcount(key, start, end));
2582    }
2583    @Override
2584    public Response<Long> bitcount(byte[] key, long start, long end, BitCountOption option) {
2585      return appendCommand(commandObjects.bitcount(key, start, end, option));
2586    }
2587    @Override
2588    public Response<Long> bitpos(byte[] key, boolean value) {
2589      return appendCommand(commandObjects.bitpos(key, value));
2590    }
2591    @Override
2592    public Response<Long> bitpos(byte[] key, boolean value, BitPosParams params) {
2593      return appendCommand(commandObjects.bitpos(key, value, params));
2594    }
2595    @Override
2596    public Response<List<Long>> bitfield(byte[] key, byte[]... arguments) {
2597      return appendCommand(commandObjects.bitfield(key, arguments));
2598    }
2599    @Override
2600    public Response<List<Long>> bitfieldReadonly(byte[] key, byte[]... arguments) {
2601      return appendCommand(commandObjects.bitfieldReadonly(key, arguments));
2602    }
2603    @Override
2604    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
2605      return appendCommand(commandObjects.bitop(op, destKey, srcKeys));
2606    }
2607    @Override
2608    public Response<String> ftCreate(String indexName, IndexOptions indexOptions, Schema schema) {
2609      return appendCommand(commandObjects.ftCreate(indexName, indexOptions, schema));
2610    }
2611    @Override
2612    public Response<String> ftCreate(String indexName, FTCreateParams createParams, Iterable<SchemaField> schemaFields) {
2613      return appendCommand(commandObjects.ftCreate(indexName, createParams, schemaFields));
2614    }
2615    @Override
2616    public Response<String> ftAlter(String indexName, Schema schema) {
2617      return appendCommand(commandObjects.ftAlter(indexName, schema));
2618    }
2619    @Override
2620    public Response<String> ftAlter(String indexName, Iterable<SchemaField> schemaFields) {
2621      return appendCommand(commandObjects.ftAlter(indexName, schemaFields));
2622    }
2623    @Override
2624    public Response<SearchResult> ftSearch(String indexName, String query) {
2625      return appendCommand(commandObjects.ftSearch(indexName, query));
2626    }
2627    @Override
2628    public Response<SearchResult> ftSearch(String indexName, String query, FTSearchParams searchParams) {
2629      return appendCommand(commandObjects.ftSearch(indexName, query, searchParams));
2630    }
2631    @Override
2632    public Response<SearchResult> ftSearch(String indexName, Query query) {
2633      return appendCommand(commandObjects.ftSearch(indexName, query));
2634    }
2635    @Override
2636    public Response<SearchResult> ftSearch(byte[] indexName, Query query) {
2637      return appendCommand(commandObjects.ftSearch(indexName, query));
2638    }
2639    @Override
2640    public Response<String> ftExplain(String indexName, Query query) {
2641      return appendCommand(commandObjects.ftExplain(indexName, query));
2642    }
2643    @Override
2644    public Response<List<String>> ftExplainCLI(String indexName, Query query) {
2645      return appendCommand(commandObjects.ftExplainCLI(indexName, query));
2646    }
2647    @Override
2648    public Response<AggregationResult> ftAggregate(String indexName, AggregationBuilder aggr) {
2649      return appendCommand(commandObjects.ftAggregate(indexName, aggr));
2650    }
2651    @Override
2652    public Response<String> ftSynUpdate(String indexName, String synonymGroupId, String... terms) {
2653      return appendCommand(commandObjects.ftSynUpdate(indexName, synonymGroupId, terms));
2654    }
2655    @Override
2656    public Response<Map<String, List<String>>> ftSynDump(String indexName) {
2657      return appendCommand(commandObjects.ftSynDump(indexName));
2658    }
2659    @Override
2660    public Response<Long> ftDictAdd(String dictionary, String... terms) {
2661      return appendCommand(commandObjects.ftDictAdd(dictionary, terms));
2662    }
2663    @Override
2664    public Response<Long> ftDictDel(String dictionary, String... terms) {
2665      return appendCommand(commandObjects.ftDictDel(dictionary, terms));
2666    }
2667    @Override
2668    public Response<Set<String>> ftDictDump(String dictionary) {
2669      return appendCommand(commandObjects.ftDictDump(dictionary));
2670    }
2671    @Override
2672    public Response<Long> ftDictAddBySampleKey(String indexName, String dictionary, String... terms) {
2673      return appendCommand(commandObjects.ftDictAddBySampleKey(indexName, dictionary, terms));
2674    }
2675    @Override
2676    public Response<Long> ftDictDelBySampleKey(String indexName, String dictionary, String... terms) {
2677      return appendCommand(commandObjects.ftDictDelBySampleKey(indexName, dictionary, terms));
2678    }
2679    @Override
2680    public Response<Set<String>> ftDictDumpBySampleKey(String indexName, String dictionary) {
2681      return appendCommand(commandObjects.ftDictDumpBySampleKey(indexName, dictionary));
2682    }
2683    @Override
2684    public Response<Map<String, Map<String, Double>>> ftSpellCheck(String index, String query) {
2685      return appendCommand(commandObjects.ftSpellCheck(index, query));
2686    }
2687    @Override
2688    public Response<Map<String, Map<String, Double>>> ftSpellCheck(String index, String query, FTSpellCheckParams spellCheckParams) {
2689      return appendCommand(commandObjects.ftSpellCheck(index, query, spellCheckParams));
2690    }
2691    @Override
2692    public Response<Map<String, Object>> ftInfo(String indexName) {
2693      return appendCommand(commandObjects.ftInfo(indexName));
2694    }
2695    @Override
2696    public Response<Set<String>> ftTagVals(String indexName, String fieldName) {
2697      return appendCommand(commandObjects.ftTagVals(indexName, fieldName));
2698    }
2699    @Override
2700    public Response<Map<String, String>> ftConfigGet(String option) {
2701      return appendCommand(commandObjects.ftConfigGet(option));
2702    }
2703    @Override
2704    public Response<Map<String, String>> ftConfigGet(String indexName, String option) {
2705      return appendCommand(commandObjects.ftConfigGet(indexName, option));
2706    }
2707    @Override
2708    public Response<String> ftConfigSet(String option, String value) {
2709      return appendCommand(commandObjects.ftConfigSet(option, value));
2710    }
2711    @Override
2712    public Response<String> ftConfigSet(String indexName, String option, String value) {
2713      return appendCommand(commandObjects.ftConfigSet(indexName, option, value));
2714    }
2715    @Override
2716    public Response<Long> ftSugAdd(String key, String string, double score) {
2717      return appendCommand(commandObjects.ftSugAdd(key, string, score));
2718    }
2719    @Override
2720    public Response<Long> ftSugAddIncr(String key, String string, double score) {
2721      return appendCommand(commandObjects.ftSugAddIncr(key, string, score));
2722    }
2723    @Override
2724    public Response<List<String>> ftSugGet(String key, String prefix) {
2725      return appendCommand(commandObjects.ftSugGet(key, prefix));
2726    }
2727    @Override
2728    public Response<List<String>> ftSugGet(String key, String prefix, boolean fuzzy, int max) {
2729      return appendCommand(commandObjects.ftSugGet(key, prefix, fuzzy, max));
2730    }
2731    @Override
2732    public Response<List<Tuple>> ftSugGetWithScores(String key, String prefix) {
2733      return appendCommand(commandObjects.ftSugGetWithScores(key, prefix));
2734    }
2735    @Override
2736    public Response<List<Tuple>> ftSugGetWithScores(String key, String prefix, boolean fuzzy, int max) {
2737      return appendCommand(commandObjects.ftSugGetWithScores(key, prefix, fuzzy, max));
2738    }
2739    @Override
2740    public Response<Boolean> ftSugDel(String key, String string) {
2741      return appendCommand(commandObjects.ftSugDel(key, string));
2742    }
2743    @Override
2744    public Response<Long> ftSugLen(String key) {
2745      return appendCommand(commandObjects.ftSugLen(key));
2746    }
2747    @Override
2748    public Response<LCSMatchResult> lcs(byte[] keyA, byte[] keyB, LCSParams params) {
2749      return appendCommand(commandObjects.lcs(keyA, keyB, params));
2750    }
2751    @Override
2752    public Response<String> jsonSet(String key, Path2 path, Object object) {
2753      return appendCommand(commandObjects.jsonSet(key, path, object));
2754    }
2755    @Override
2756    public Response<String> jsonSetWithEscape(String key, Path2 path, Object object) {
2757      return appendCommand(commandObjects.jsonSetWithEscape(key, path, object));
2758    }
2759    @Override
2760    public Response<String> jsonSet(String key, Path path, Object object) {
2761      return appendCommand(commandObjects.jsonSet(key, path, object));
2762    }
2763    @Override
2764    public Response<String> jsonSet(String key, Path2 path, Object object, JsonSetParams params) {
2765      return appendCommand(commandObjects.jsonSet(key, path, object, params));
2766    }
2767    @Override
2768    public Response<String> jsonSetWithEscape(String key, Path2 path, Object object, JsonSetParams params) {
2769      return appendCommand(commandObjects.jsonSetWithEscape(key, path, object, params));
2770    }
2771    @Override
2772    public Response<String> jsonSet(String key, Path path, Object object, JsonSetParams params) {
2773      return appendCommand(commandObjects.jsonSet(key, path, object, params));
2774    }
2775    @Override
2776    public Response<String> jsonMerge(String key, Path2 path, Object object) {
2777      return appendCommand(commandObjects.jsonMerge(key, path, object));
2778    }
2779    @Override
2780    public Response<String> jsonMerge(String key, Path path, Object object) {
2781      return appendCommand(commandObjects.jsonMerge(key, path, object));
2782    }
2783    @Override
2784    public Response<Object> jsonGet(String key) {
2785      return appendCommand(commandObjects.jsonGet(key));
2786    }
2787    @Override
2788    public <T> Response<T> jsonGet(String key, Class<T> clazz) {
2789      return appendCommand(commandObjects.jsonGet(key, clazz));
2790    }
2791    @Override
2792    public Response<Object> jsonGet(String key, Path2... paths) {
2793      return appendCommand(commandObjects.jsonGet(key, paths));
2794    }
2795    @Override
2796    public Response<Object> jsonGet(String key, Path... paths) {
2797      return appendCommand(commandObjects.jsonGet(key, paths));
2798    }
2799    @Override
2800    public <T> Response<T> jsonGet(String key, Class<T> clazz, Path... paths) {
2801      return appendCommand(commandObjects.jsonGet(key, clazz, paths));
2802    }
2803    @Override
2804    public Response<List<JSONArray>> jsonMGet(Path2 path, String... keys) {
2805      return appendCommand(commandObjects.jsonMGet(path, keys));
2806    }
2807    @Override
2808    public <T> Response<List<T>> jsonMGet(Path path, Class<T> clazz, String... keys) {
2809      return appendCommand(commandObjects.jsonMGet(path, clazz, keys));
2810    }
2811    @Override
2812    public Response<Long> jsonDel(String key) {
2813      return appendCommand(commandObjects.jsonDel(key));
2814    }
2815    @Override
2816    public Response<Long> jsonDel(String key, Path2 path) {
2817      return appendCommand(commandObjects.jsonDel(key, path));
2818    }
2819    @Override
2820    public Response<Long> jsonDel(String key, Path path) {
2821      return appendCommand(commandObjects.jsonDel(key, path));
2822    }
2823    @Override
2824    public Response<Long> jsonClear(String key) {
2825      return appendCommand(commandObjects.jsonClear(key));
2826    }
2827    @Override
2828    public Response<Long> jsonClear(String key, Path2 path) {
2829      return appendCommand(commandObjects.jsonClear(key, path));
2830    }
2831    @Override
2832    public Response<Long> jsonClear(String key, Path path) {
2833      return appendCommand(commandObjects.jsonClear(key, path));
2834    }
2835    @Override
2836    public Response<List<Boolean>> jsonToggle(String key, Path2 path) {
2837      return appendCommand(commandObjects.jsonToggle(key, path));
2838    }
2839    @Override
2840    public Response<String> jsonToggle(String key, Path path) {
2841      return appendCommand(commandObjects.jsonToggle(key, path));
2842    }
2843    @Override
2844    public Response<Class<?>> jsonType(String key) {
2845      return appendCommand(commandObjects.jsonType(key));
2846    }
2847    @Override
2848    public Response<List<Class<?>>> jsonType(String key, Path2 path) {
2849      return appendCommand(commandObjects.jsonType(key, path));
2850    }
2851    @Override
2852    public Response<Class<?>> jsonType(String key, Path path) {
2853      return appendCommand(commandObjects.jsonType(key, path));
2854    }
2855    @Override
2856    public Response<Long> jsonStrAppend(String key, Object string) {
2857      return appendCommand(commandObjects.jsonStrAppend(key, string));
2858    }
2859    @Override
2860    public Response<List<Long>> jsonStrAppend(String key, Path2 path, Object string) {
2861      return appendCommand(commandObjects.jsonStrAppend(key, path, string));
2862    }
2863    @Override
2864    public Response<Long> jsonStrAppend(String key, Path path, Object string) {
2865      return appendCommand(commandObjects.jsonStrAppend(key, path, string));
2866    }
2867    @Override
2868    public Response<Long> jsonStrLen(String key) {
2869      return appendCommand(commandObjects.jsonStrLen(key));
2870    }
2871    @Override
2872    public Response<List<Long>> jsonStrLen(String key, Path2 path) {
2873      return appendCommand(commandObjects.jsonStrLen(key, path));
2874    }
2875    @Override
2876    public Response<Long> jsonStrLen(String key, Path path) {
2877      return appendCommand(commandObjects.jsonStrLen(key, path));
2878    }
2879    @Override
2880    public Response<JSONArray> jsonNumIncrBy(String key, Path2 path, double value) {
2881      return appendCommand(commandObjects.jsonNumIncrBy(key, path, value));
2882    }
2883    @Override
2884    public Response<Double> jsonNumIncrBy(String key, Path path, double value) {
2885      return appendCommand(commandObjects.jsonNumIncrBy(key, path, value));
2886    }
2887    @Override
2888    public Response<List<Long>> jsonArrAppend(String key, Path2 path, Object... objects) {
2889      return appendCommand(commandObjects.jsonArrAppend(key, path, objects));
2890    }
2891    @Override
2892    public Response<List<Long>> jsonArrAppendWithEscape(String key, Path2 path, Object... objects) {
2893      return appendCommand(commandObjects.jsonArrAppendWithEscape(key, path, objects));
2894    }
2895    @Override
2896    public Response<Long> jsonArrAppend(String key, Path path, Object... objects) {
2897      return appendCommand(commandObjects.jsonArrAppend(key, path, objects));
2898    }
2899    @Override
2900    public Response<List<Long>> jsonArrIndex(String key, Path2 path, Object scalar) {
2901      return appendCommand(commandObjects.jsonArrIndex(key, path, scalar));
2902    }
2903    @Override
2904    public Response<List<Long>> jsonArrIndexWithEscape(String key, Path2 path, Object scalar) {
2905      return appendCommand(commandObjects.jsonArrIndexWithEscape(key, path, scalar));
2906    }
2907    @Override
2908    public Response<Long> jsonArrIndex(String key, Path path, Object scalar) {
2909      return appendCommand(commandObjects.jsonArrIndex(key, path, scalar));
2910    }
2911    @Override
2912    public Response<List<Long>> jsonArrInsert(String key, Path2 path, int index, Object... objects) {
2913      return appendCommand(commandObjects.jsonArrInsert(key, path, index, objects));
2914    }
2915    @Override
2916    public Response<List<Long>> jsonArrInsertWithEscape(String key, Path2 path, int index, Object... objects) {
2917      return appendCommand(commandObjects.jsonArrInsertWithEscape(key, path, index, objects));
2918    }
2919    @Override
2920    public Response<Long> jsonArrInsert(String key, Path path, int index, Object... pojos) {
2921      return appendCommand(commandObjects.jsonArrInsert(key, path, index, pojos));
2922    }
2923    @Override
2924    public Response<Object> jsonArrPop(String key) {
2925      return appendCommand(commandObjects.jsonArrPop(key));
2926    }
2927    @Override
2928    public Response<Long> jsonArrLen(String key, Path path) {
2929      return appendCommand(commandObjects.jsonArrLen(key, path));
2930    }
2931    @Override
2932    public Response<List<Long>> jsonArrTrim(String key, Path2 path, int start, int stop) {
2933      return appendCommand(commandObjects.jsonArrTrim(key, path, start, stop));
2934    }
2935    @Override
2936    public Response<Long> jsonArrTrim(String key, Path path, int start, int stop) {
2937      return appendCommand(commandObjects.jsonArrTrim(key, path, start, stop));
2938    }
2939    @Override
2940    public <T> Response<T> jsonArrPop(String key, Class<T> clazz, Path path) {
2941      return appendCommand(commandObjects.jsonArrPop(key, clazz, path));
2942    }
2943    @Override
2944    public Response<List<Object>> jsonArrPop(String key, Path2 path, int index) {
2945      return appendCommand(commandObjects.jsonArrPop(key, path, index));
2946    }
2947    @Override
2948    public Response<Object> jsonArrPop(String key, Path path, int index) {
2949      return appendCommand(commandObjects.jsonArrPop(key, path, index));
2950    }
2951    @Override
2952    public <T> Response<T> jsonArrPop(String key, Class<T> clazz, Path path, int index) {
2953      return appendCommand(commandObjects.jsonArrPop(key, clazz, path, index));
2954    }
2955    @Override
2956    public Response<Long> jsonArrLen(String key) {
2957      return appendCommand(commandObjects.jsonArrLen(key));
2958    }
2959    @Override
2960    public Response<List<Long>> jsonArrLen(String key, Path2 path) {
2961      return appendCommand(commandObjects.jsonArrLen(key, path));
2962    }
2963    @Override
2964    public <T> Response<T> jsonArrPop(String key, Class<T> clazz) {
2965      return appendCommand(commandObjects.jsonArrPop(key, clazz));
2966    }
2967    @Override
2968    public Response<List<Object>> jsonArrPop(String key, Path2 path) {
2969      return appendCommand(commandObjects.jsonArrPop(key, path));
2970    }
2971    @Override
2972    public Response<Object> jsonArrPop(String key, Path path) {
2973      return appendCommand(commandObjects.jsonArrPop(key, path));
2974    }
2975    @Override
2976    public Response<String> tsCreate(String key) {
2977      return appendCommand(commandObjects.tsCreate(key));
2978    }
2979    @Override
2980    public Response<String> tsCreate(String key, TSCreateParams createParams) {
2981      return appendCommand(commandObjects.tsCreate(key, createParams));
2982    }
2983    @Override
2984    public Response<Long> tsDel(String key, long fromTimestamp, long toTimestamp) {
2985      return appendCommand(commandObjects.tsDel(key, fromTimestamp, toTimestamp));
2986    }
2987    @Override
2988    public Response<String> tsAlter(String key, TSAlterParams alterParams) {
2989      return appendCommand(commandObjects.tsAlter(key, alterParams));
2990    }
2991    @Override
2992    public Response<Long> tsAdd(String key, double value) {
2993      return appendCommand(commandObjects.tsAdd(key, value));
2994    }
2995    @Override
2996    public Response<Long> tsAdd(String key, long timestamp, double value) {
2997      return appendCommand(commandObjects.tsAdd(key, timestamp, value));
2998    }
2999    @Override
3000    public Response<Long> tsAdd(String key, long timestamp, double value, TSCreateParams createParams) {
3001      return appendCommand(commandObjects.tsAdd(key, timestamp, value, createParams));
3002    }
3003    @Override
3004    public Response<List<Long>> tsMAdd(Map.Entry<String, TSElement>... entries) {
3005      return appendCommand(commandObjects.tsMAdd(entries));
3006    }
3007    @Override
3008    public Response<Long> tsIncrBy(String key, double value) {
3009      return appendCommand(commandObjects.tsIncrBy(key, value));
3010    }
3011    @Override
3012    public Response<Long> tsIncrBy(String key, double value, long timestamp) {
3013      return appendCommand(commandObjects.tsIncrBy(key, value, timestamp));
3014    }
3015    @Override
3016    public Response<Long> tsDecrBy(String key, double value) {
3017      return appendCommand(commandObjects.tsDecrBy(key, value));
3018    }
3019    @Override
3020    public Response<Long> tsDecrBy(String key, double value, long timestamp) {
3021      return appendCommand(commandObjects.tsDecrBy(key, value, timestamp));
3022    }
3023    @Override
3024    public Response<List<TSElement>> tsRange(String key, long fromTimestamp, long toTimestamp) {
3025      return appendCommand(commandObjects.tsRange(key, fromTimestamp, toTimestamp));
3026    }
3027    @Override
3028    public Response<List<TSElement>> tsRange(String key, TSRangeParams rangeParams) {
3029      return appendCommand(commandObjects.tsRange(key, rangeParams));
3030    }
3031    @Override
3032    public Response<List<TSElement>> tsRevRange(String key, long fromTimestamp, long toTimestamp) {
3033      return appendCommand(commandObjects.tsRevRange(key, fromTimestamp, toTimestamp));
3034    }
3035    @Override
3036    public Response<List<TSElement>> tsRevRange(String key, TSRangeParams rangeParams) {
3037      return appendCommand(commandObjects.tsRevRange(key, rangeParams));
3038    }
3039    @Override
3040    public Response<Map<String, TSMRangeElements>> tsMRange(long fromTimestamp, long toTimestamp, String... filters) {
3041      return appendCommand(commandObjects.tsMRange(fromTimestamp, toTimestamp, filters));
3042    }
3043    @Override
3044    public Response<Map<String, TSMRangeElements>> tsMRange(TSMRangeParams multiRangeParams) {
3045      return appendCommand(commandObjects.tsMRange(multiRangeParams));
3046    }
3047    @Override
3048    public Response<Map<String, TSMRangeElements>> tsMRevRange(long fromTimestamp, long toTimestamp, String... filters) {
3049      return appendCommand(commandObjects.tsMRevRange(fromTimestamp, toTimestamp, filters));
3050    }
3051    @Override
3052    public Response<Map<String, TSMRangeElements>> tsMRevRange(TSMRangeParams multiRangeParams) {
3053      return appendCommand(commandObjects.tsMRevRange(multiRangeParams));
3054    }
3055    @Override
3056    public Response<TSElement> tsGet(String key) {
3057      return appendCommand(commandObjects.tsGet(key));
3058    }
3059    @Override
3060    public Response<TSElement> tsGet(String key, TSGetParams getParams) {
3061      return appendCommand(commandObjects.tsGet(key, getParams));
3062    }
3063    @Override
3064    public Response<Map<String, TSMGetElement>> tsMGet(TSMGetParams multiGetParams, String... filters) {
3065      return appendCommand(commandObjects.tsMGet(multiGetParams, filters));
3066    }
3067    @Override
3068    public Response<String> tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long timeBucket) {
3069      return appendCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, timeBucket));
3070    }
3071    @Override
3072    public Response<String> tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long bucketDuration, long alignTimestamp) {
3073      return appendCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, bucketDuration, alignTimestamp));
3074    }
3075    @Override
3076    public Response<String> tsDeleteRule(String sourceKey, String destKey) {
3077      return appendCommand(commandObjects.tsDeleteRule(sourceKey, destKey));
3078    }
3079    @Override
3080    public Response<List<String>> tsQueryIndex(String... filters) {
3081      return appendCommand(commandObjects.tsQueryIndex(filters));
3082    }
3083    @Override
3084    public Response<String> bfReserve(String key, double errorRate, long capacity) {
3085      return appendCommand(commandObjects.bfReserve(key, errorRate, capacity));
3086    }
3087    @Override
3088    public Response<String> bfReserve(String key, double errorRate, long capacity, BFReserveParams reserveParams) {
3089      return appendCommand(commandObjects.bfReserve(key, errorRate, capacity, reserveParams));
3090    }
3091    @Override
3092    public Response<Boolean> bfAdd(String key, String item) {
3093      return appendCommand(commandObjects.bfAdd(key, item));
3094    }
3095    @Override
3096    public Response<List<Boolean>> bfMAdd(String key, String... items) {
3097      return appendCommand(commandObjects.bfMAdd(key, items));
3098    }
3099    @Override
3100    public Response<List<Boolean>> bfInsert(String key, String... items) {
3101      return appendCommand(commandObjects.bfInsert(key, items));
3102    }
3103    @Override
3104    public Response<List<Boolean>> bfInsert(String key, BFInsertParams insertParams, String... items) {
3105      return appendCommand(commandObjects.bfInsert(key, insertParams, items));
3106    }
3107    @Override
3108    public Response<Boolean> bfExists(String key, String item) {
3109      return appendCommand(commandObjects.bfExists(key, item));
3110    }
3111    @Override
3112    public Response<List<Boolean>> bfMExists(String key, String... items) {
3113      return appendCommand(commandObjects.bfMExists(key, items));
3114    }
3115    @Override
3116    public Response<Map.Entry<Long, byte[]>> bfScanDump(String key, long iterator) {
3117      return appendCommand(commandObjects.bfScanDump(key, iterator));
3118    }
3119    @Override
3120    public Response<String> bfLoadChunk(String key, long iterator, byte[] data) {
3121      return appendCommand(commandObjects.bfLoadChunk(key, iterator, data));
3122    }
3123    @Override
3124    public Response<Long> bfCard(String key) {
3125      return appendCommand(commandObjects.bfCard(key));
3126    }
3127    @Override
3128    public Response<Map<String, Object>> bfInfo(String key) {
3129      return appendCommand(commandObjects.bfInfo(key));
3130    }
3131    @Override
3132    public Response<String> cfReserve(String key, long capacity) {
3133      return appendCommand(commandObjects.cfReserve(key, capacity));
3134    }
3135    @Override
3136    public Response<String> cfReserve(String key, long capacity, CFReserveParams reserveParams) {
3137      return appendCommand(commandObjects.cfReserve(key, capacity, reserveParams));
3138    }
3139    @Override
3140    public Response<Boolean> cfAdd(String key, String item) {
3141      return appendCommand(commandObjects.cfAdd(key, item));
3142    }
3143    @Override
3144    public Response<Boolean> cfAddNx(String key, String item) {
3145      return appendCommand(commandObjects.cfAddNx(key, item));
3146    }
3147    @Override
3148    public Response<List<Boolean>> cfInsert(String key, String... items) {
3149      return appendCommand(commandObjects.cfInsert(key, items));
3150    }
3151    @Override
3152    public Response<List<Boolean>> cfInsert(String key, CFInsertParams insertParams, String... items) {
3153      return appendCommand(commandObjects.cfInsert(key, insertParams, items));
3154    }
3155    @Override
3156    public Response<List<Boolean>> cfInsertNx(String key, String... items) {
3157      return appendCommand(commandObjects.cfInsertNx(key, items));
3158    }
3159    @Override
3160    public Response<List<Boolean>> cfInsertNx(String key, CFInsertParams insertParams, String... items) {
3161      return appendCommand(commandObjects.cfInsertNx(key, insertParams, items));
3162    }
3163    @Override
3164    public Response<Boolean> cfExists(String key, String item) {
3165      return appendCommand(commandObjects.cfExists(key, item));
3166    }
3167    @Override
3168    public Response<Boolean> cfDel(String key, String item) {
3169      return appendCommand(commandObjects.cfDel(key, item));
3170    }
3171    @Override
3172    public Response<Long> cfCount(String key, String item) {
3173      return appendCommand(commandObjects.cfCount(key, item));
3174    }
3175    @Override
3176    public Response<Map.Entry<Long, byte[]>> cfScanDump(String key, long iterator) {
3177      return appendCommand(commandObjects.cfScanDump(key, iterator));
3178    }
3179    @Override
3180    public Response<String> cfLoadChunk(String key, long iterator, byte[] data) {
3181      return appendCommand(commandObjects.cfLoadChunk(key, iterator, data));
3182    }
3183    @Override
3184    public Response<Map<String, Object>> cfInfo(String key) {
3185      return appendCommand(commandObjects.cfInfo(key));
3186    }
3187    @Override
3188    public Response<String> cmsInitByDim(String key, long width, long depth) {
3189      return appendCommand(commandObjects.cmsInitByDim(key, width, depth));
3190    }
3191    @Override
3192    public Response<String> cmsInitByProb(String key, double error, double probability) {
3193      return appendCommand(commandObjects.cmsInitByProb(key, error, probability));
3194    }
3195    @Override
3196    public Response<List<Long>> cmsIncrBy(String key, Map<String, Long> itemIncrements) {
3197      return appendCommand(commandObjects.cmsIncrBy(key, itemIncrements));
3198    }
3199    @Override
3200    public Response<List<Long>> cmsQuery(String key, String... items) {
3201      return appendCommand(commandObjects.cmsQuery(key, items));
3202    }
3203    @Override
3204    public Response<String> cmsMerge(String destKey, String... keys) {
3205      return appendCommand(commandObjects.cmsMerge(destKey, keys));
3206    }
3207    @Override
3208    public Response<String> cmsMerge(String destKey, Map<String, Long> keysAndWeights) {
3209      return appendCommand(commandObjects.cmsMerge(destKey, keysAndWeights));
3210    }
3211    @Override
3212    public Response<Map<String, Object>> cmsInfo(String key) {
3213      return appendCommand(commandObjects.cmsInfo(key));
3214    }
3215    @Override
3216    public Response<String> topkReserve(String key, long topk) {
3217      return appendCommand(commandObjects.topkReserve(key, topk));
3218    }
3219    @Override
3220    public Response<String> topkReserve(String key, long topk, long width, long depth, double decay) {
3221      return appendCommand(commandObjects.topkReserve(key, topk, width, depth, decay));
3222    }
3223    @Override
3224    public Response<List<String>> topkAdd(String key, String... items) {
3225      return appendCommand(commandObjects.topkAdd(key, items));
3226    }
3227    @Override
3228    public Response<List<String>> topkIncrBy(String key, Map<String, Long> itemIncrements) {
3229      return appendCommand(commandObjects.topkIncrBy(key, itemIncrements));
3230    }
3231    @Override
3232    public Response<List<Boolean>> topkQuery(String key, String... items) {
3233      return appendCommand(commandObjects.topkQuery(key, items));
3234    }
3235    @Override
3236    public Response<List<String>> topkList(String key) {
3237      return appendCommand(commandObjects.topkList(key));
3238    }
3239    @Override
3240    public Response<Map<String, Object>> topkInfo(String key) {
3241      return appendCommand(commandObjects.topkInfo(key));
3242    }
3243    @Override
3244    public Response<String> tdigestCreate(String key) {
3245      return appendCommand(commandObjects.tdigestCreate(key));
3246    }
3247    @Override
3248    public Response<String> tdigestCreate(String key, int compression) {
3249      return appendCommand(commandObjects.tdigestCreate(key, compression));
3250    }
3251    @Override
3252    public Response<String> tdigestReset(String key) {
3253      return appendCommand(commandObjects.tdigestReset(key));
3254    }
3255    @Override
3256    public Response<String> tdigestMerge(String destinationKey, String... sourceKeys) {
3257      return appendCommand(commandObjects.tdigestMerge(destinationKey, sourceKeys));
3258    }
3259    @Override
3260    public Response<String> tdigestMerge(TDigestMergeParams mergeParams, String destinationKey, String... sourceKeys) {
3261      return appendCommand(commandObjects.tdigestMerge(mergeParams, destinationKey, sourceKeys));
3262    }
3263    @Override
3264    public Response<Map<String, Object>> tdigestInfo(String key) {
3265      return appendCommand(commandObjects.tdigestInfo(key));
3266    }
3267    @Override
3268    public Response<String> tdigestAdd(String key, double... values) {
3269      return appendCommand(commandObjects.tdigestAdd(key, values));
3270    }
3271    @Override
3272    public Response<List<Double>> tdigestCDF(String key, double... values) {
3273      return appendCommand(commandObjects.tdigestCDF(key, values));
3274    }
3275    @Override
3276    public Response<List<Double>> tdigestQuantile(String key, double... quantiles) {
3277      return appendCommand(commandObjects.tdigestQuantile(key, quantiles));
3278    }
3279    @Override
3280    public Response<Double> tdigestMin(String key) {
3281      return appendCommand(commandObjects.tdigestMin(key));
3282    }
3283    @Override
3284    public Response<Double> tdigestMax(String key) {
3285      return appendCommand(commandObjects.tdigestMax(key));
3286    }
3287    @Override
3288    public Response<Double> tdigestTrimmedMean(String key, double lowCutQuantile, double highCutQuantile) {
3289      return appendCommand(commandObjects.tdigestTrimmedMean(key, lowCutQuantile, highCutQuantile));
3290    }
3291    @Override
3292    public Response<List<Long>> tdigestRank(String key, double... values) {
3293      return appendCommand(commandObjects.tdigestRank(key, values));
3294    }
3295    @Override
3296    public Response<List<Long>> tdigestRevRank(String key, double... values) {
3297      return appendCommand(commandObjects.tdigestRevRank(key, values));
3298    }
3299    @Override
3300    public Response<List<Double>> tdigestByRank(String key, long... ranks) {
3301      return appendCommand(commandObjects.tdigestByRank(key, ranks));
3302    }
3303    @Override
3304    public Response<List<Double>> tdigestByRevRank(String key, long... ranks) {
3305      return appendCommand(commandObjects.tdigestByRevRank(key, ranks));
3306    }
3307    @Override
3308    public Response<ResultSet> graphQuery(String name, String query) {
3309      return appendCommand(graphCommandObjects.graphQuery(name, query));
3310    }
3311    @Override
3312    public Response<ResultSet> graphReadonlyQuery(String name, String query) {
3313      return appendCommand(graphCommandObjects.graphReadonlyQuery(name, query));
3314    }
3315    @Override
3316    public Response<ResultSet> graphQuery(String name, String query, long timeout) {
3317      return appendCommand(graphCommandObjects.graphQuery(name, query, timeout));
3318    }
3319    @Override
3320    public Response<ResultSet> graphReadonlyQuery(String name, String query, long timeout) {
3321      return appendCommand(graphCommandObjects.graphReadonlyQuery(name, query, timeout));
3322    }
3323    @Override
3324    public Response<ResultSet> graphQuery(String name, String query, Map<String, Object> params) {
3325      return appendCommand(graphCommandObjects.graphQuery(name, query, params));
3326    }
3327    @Override
3328    public Response<ResultSet> graphReadonlyQuery(String name, String query, Map<String, Object> params) {
3329      return appendCommand(graphCommandObjects.graphReadonlyQuery(name, query, params));
3330    }
3331    @Override
3332    public Response<ResultSet> graphQuery(String name, String query, Map<String, Object> params, long timeout) {
3333      return appendCommand(graphCommandObjects.graphQuery(name, query, params, timeout));
3334    }
3335    @Override
3336    public Response<ResultSet> graphReadonlyQuery(String name, String query, Map<String, Object> params, long timeout) {
3337      return appendCommand(graphCommandObjects.graphReadonlyQuery(name, query, params, timeout));
3338    }
3339    @Override
3340    public Response<String> graphDelete(String name) {
3341      return appendCommand(graphCommandObjects.graphDelete(name));
3342    }
3343    @Override
3344    public Response<List<String>> graphProfile(String graphName, String query) {
3345      return appendCommand(commandObjects.graphProfile(graphName, query));
3346    }
3347    public Response<Long> publish(String channel, String message) {
3348      return appendCommand(commandObjects.publish(channel, message));
3349    }
3350    public Response<Long> publish(byte[] channel, byte[] message) {
3351      return appendCommand(commandObjects.publish(channel, message));
3352    }
3353    public Response<Object> sendCommand(ProtocolCommand cmd, String... args) {
3354      return sendCommand(new CommandArguments(cmd).addObjects((Object[]) args));
3355    }
3356    public Response<Object> sendCommand(ProtocolCommand cmd, byte[]... args) {
3357      return sendCommand(new CommandArguments(cmd).addObjects((Object[]) args));
3358    }
3359    public Response<Object> sendCommand(CommandArguments args) {
3360      return executeCommand(new CommandObject<>(args, BuilderFactory.RAW_OBJECT));
3361    }
3362    public <T> Response<T> executeCommand(CommandObject<T> command) {
3363      return appendCommand(command);
3364    }
3365    public void setJsonObjectMapper(JsonObjectMapper jsonObjectMapper) {
3366      this.commandObjects.setJsonObjectMapper(jsonObjectMapper);
3367    }
3368  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-TransactionBase.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import static redis.clients.jedis.Protocol.Command.DISCARD;
3  import static redis.clients.jedis.Protocol.Command.EXEC;
4  import static redis.clients.jedis.Protocol.Command.MULTI;
5  import static redis.clients.jedis.Protocol.Command.UNWATCH;
6  import static redis.clients.jedis.Protocol.Command.WATCH;
7  import java.io.Closeable;
8  import java.util.ArrayList;
9  import java.util.LinkedList;
10  import java.util.List;
11  import java.util.Map;
12  import java.util.Queue;
13  import java.util.Set;
14  import org.json.JSONArray;
15  import redis.clients.jedis.args.*;
16  import redis.clients.jedis.bloom.*;
17  import redis.clients.jedis.commands.PipelineBinaryCommands;
18  import redis.clients.jedis.commands.PipelineCommands;
19  import redis.clients.jedis.commands.ProtocolCommand;
20  import redis.clients.jedis.commands.RedisModulePipelineCommands;
21  import redis.clients.jedis.exceptions.JedisConnectionException;
22  import redis.clients.jedis.exceptions.JedisDataException;
23  import redis.clients.jedis.graph.GraphCommandObjects;
24  import redis.clients.jedis.graph.ResultSet;
25  import redis.clients.jedis.json.JsonSetParams;
26  import redis.clients.jedis.json.Path;
27  import redis.clients.jedis.json.Path2;
28  import redis.clients.jedis.json.JsonObjectMapper;
29  import redis.clients.jedis.params.*;
30  import redis.clients.jedis.resps.*;
31  import redis.clients.jedis.search.*;
32  import redis.clients.jedis.search.aggr.AggregationBuilder;
33  import redis.clients.jedis.search.aggr.AggregationResult;
34  import redis.clients.jedis.search.schemafields.SchemaField;
35  import redis.clients.jedis.timeseries.*;
36  import redis.clients.jedis.util.KeyValue;
37  public abstract class TransactionBase implements PipelineCommands, PipelineBinaryCommands,
38      RedisModulePipelineCommands, Closeable {
39    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();
40    protected final Connection connection;
41    private final boolean closeConnection;
42    private final CommandObjects commandObjects;
43    private final GraphCommandObjects graphCommandObjects;
44    private boolean broken = false;
45    private boolean inWatch = false;
46    private boolean inMulti = false;
47    public TransactionBase(Connection connection) {
48      this(connection, true);
49    }
50    public TransactionBase(Connection connection, boolean doMulti) {
51      this(connection, doMulti, false);
52    }
53    public TransactionBase(Connection connection, boolean doMulti, boolean closeConnection) {
54      this.connection = connection;
55      this.closeConnection = closeConnection;
56      this.commandObjects = new CommandObjects();
57      this.graphCommandObjects = new GraphCommandObjects(this.connection);
58      if (doMulti) multi();
59    }
60    public final void multi() {
61      connection.sendCommand(MULTI);
62      processMultiResponse();
63      inMulti = true;
64    }
65    public String watch(final String... keys) {
66      connection.sendCommand(WATCH, keys);
67      String status = connection.getStatusCodeReply();
68      inWatch = true;
69      return status;
70    }
71    public String watch(final byte[]... keys) {
72      connection.sendCommand(WATCH, keys);
73      String status = connection.getStatusCodeReply();
74      inWatch = true;
75      return status;
76    }
77    public String unwatch() {
78      connection.sendCommand(UNWATCH);
79      String status = connection.getStatusCodeReply();
80      inWatch = false;
81      return status;
82    }
83    protected abstract void processMultiResponse();
84    protected abstract void processAppendStatus();
85    protected final <T> Response<T> appendCommand(CommandObject<T> commandObject) {
86      connection.sendCommand(commandObject.getArguments());
87      processAppendStatus();
88      Response<T> response = new Response<>(commandObject.getBuilder());
89      pipelinedResponses.add(response);
90      return response;
91    }
92    @Override
93    public final void close() {
94      try {
95        clear();
96      } finally {
97        if (closeConnection) {
98          connection.close();
99        }
100      }
101    }
102    public final void clear() {
103      if (broken) {
104        return;
105      }
106      if (inMulti) {
107        discard();
108      } else if (inWatch) {
109        unwatch();
110      }
111    }
112    protected abstract void processPipelinedResponses(int pipelineLength);
113    public List<Object> exec() {
114      if (!inMulti) {
115        throw new IllegalStateException("EXEC without MULTI");
116      }
117      try {
118        processPipelinedResponses(pipelinedResponses.size());
119        connection.sendCommand(EXEC);
120        List<Object> unformatted = connection.getObjectMultiBulkReply();
121        if (unformatted == null) {
122          pipelinedResponses.clear();
123          return null;
124        }
125        List<Object> formatted = new ArrayList<>(unformatted.size());
126        for (Object o : unformatted) {
127          try {
128            Response<?> response = pipelinedResponses.poll();
129            response.set(o);
130            formatted.add(response.get());
131          } catch (JedisDataException e) {
132            formatted.add(e);
133          }
134        }
135        return formatted;
136      } catch (JedisConnectionException jce) {
137        broken = true;
138        throw jce;
139      } finally {
140        inMulti = false;
141        inWatch = false;
142        pipelinedResponses.clear();
143      }
144    }
145    public String discard() {
146      if (!inMulti) {
147        throw new IllegalStateException("DISCARD without MULTI");
148      }
149      try {
150        processPipelinedResponses(pipelinedResponses.size());
151        connection.sendCommand(DISCARD);
152        return connection.getStatusCodeReply();
153      } catch (JedisConnectionException jce) {
154        broken = true;
155        throw jce;
156      } finally {
157        inMulti = false;
158        inWatch = false;
159        pipelinedResponses.clear();
160      }
161    }
162    @Override
163    public Response<Boolean> exists(String key) {
164      return appendCommand(commandObjects.exists(key));
165    }
166    @Override
167    public Response<Long> exists(String... keys) {
168      return appendCommand(commandObjects.exists(keys));
169    }
170    @Override
171    public Response<Long> persist(String key) {
172      return appendCommand(commandObjects.persist(key));
173    }
174    @Override
175    public Response<String> type(String key) {
176      return appendCommand(commandObjects.type(key));
177    }
178    @Override
179    public Response<byte[]> dump(String key) {
180      return appendCommand(commandObjects.dump(key));
181    }
182    @Override
183    public Response<String> restore(String key, long ttl, byte[] serializedValue) {
184      return appendCommand(commandObjects.restore(key, ttl, serializedValue));
185    }
186    @Override
187    public Response<String> restore(String key, long ttl, byte[] serializedValue, RestoreParams params) {
188      return appendCommand(commandObjects.restore(key, ttl, serializedValue, params));
189    }
190    @Override
191    public Response<Long> expire(String key, long seconds) {
192      return appendCommand(commandObjects.expire(key, seconds));
193    }
194    @Override
195    public Response<Long> expire(String key, long seconds, ExpiryOption expiryOption) {
196      return appendCommand(commandObjects.expire(key, seconds, expiryOption));
197    }
198    @Override
199    public Response<Long> pexpire(String key, long milliseconds) {
200      return appendCommand(commandObjects.pexpire(key, milliseconds));
201    }
202    @Override
203    public Response<Long> pexpire(String key, long milliseconds, ExpiryOption expiryOption) {
204      return appendCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
205    }
206    @Override
207    public Response<Long> expireTime(String key) {
208      return appendCommand(commandObjects.expireTime(key));
209    }
210    @Override
211    public Response<Long> pexpireTime(String key) {
212      return appendCommand(commandObjects.pexpireTime(key));
213    }
214    @Override
215    public Response<Long> expireAt(String key, long unixTime) {
216      return appendCommand(commandObjects.expireAt(key, unixTime));
217    }
218    @Override
219    public Response<Long> expireAt(String key, long unixTime, ExpiryOption expiryOption) {
220      return appendCommand(commandObjects.expireAt(key, unixTime, expiryOption));
221    }
222    @Override
223    public Response<Long> pexpireAt(String key, long millisecondsTimestamp) {
224      return appendCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
225    }
226    @Override
227    public Response<Long> pexpireAt(String key, long millisecondsTimestamp, ExpiryOption expiryOption) {
228      return appendCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
229    }
230    @Override
231    public Response<Long> ttl(String key) {
232      return appendCommand(commandObjects.ttl(key));
233    }
234    @Override
235    public Response<Long> pttl(String key) {
236      return appendCommand(commandObjects.pttl(key));
237    }
238    @Override
239    public Response<Long> touch(String key) {
240      return appendCommand(commandObjects.touch(key));
241    }
242    @Override
243    public Response<Long> touch(String... keys) {
244      return appendCommand(commandObjects.touch(keys));
245    }
246    @Override
247    public Response<List<String>> sort(String key) {
248      return appendCommand(commandObjects.sort(key));
249    }
250    @Override
251    public Response<Long> sort(String key, String dstKey) {
252      return appendCommand(commandObjects.sort(key, dstKey));
253    }
254    @Override
255    public Response<List<String>> sort(String key, SortingParams sortingParams) {
256      return appendCommand(commandObjects.sort(key, sortingParams));
257    }
258    @Override
259    public Response<Long> sort(String key, SortingParams sortingParams, String dstKey) {
260      return appendCommand(commandObjects.sort(key, sortingParams, dstKey));
261    }
262    @Override
263    public Response<List<String>> sortReadonly(String key, SortingParams sortingParams) {
264      return appendCommand(commandObjects.sortReadonly(key, sortingParams));
265    }
266    @Override
267    public Response<Long> del(String key) {
268      return appendCommand(commandObjects.del(key));
269    }
270    @Override
271    public Response<Long> del(String... keys) {
272      return appendCommand(commandObjects.del(keys));
273    }
274    @Override
275    public Response<Long> unlink(String key) {
276      return appendCommand(commandObjects.unlink(key));
277    }
278    @Override
279    public Response<Long> unlink(String... keys) {
280      return appendCommand(commandObjects.unlink(keys));
281    }
282    @Override
283    public Response<Boolean> copy(String srcKey, String dstKey, boolean replace) {
284      return appendCommand(commandObjects.copy(srcKey, dstKey, replace));
285    }
286    @Override
287    public Response<String> rename(String oldkey, String newkey) {
288      return appendCommand(commandObjects.rename(oldkey, newkey));
289    }
290    @Override
291    public Response<Long> renamenx(String oldkey, String newkey) {
292      return appendCommand(commandObjects.renamenx(oldkey, newkey));
293    }
294    @Override
295    public Response<Long> memoryUsage(String key) {
296      return appendCommand(commandObjects.memoryUsage(key));
297    }
298    @Override
299    public Response<Long> memoryUsage(String key, int samples) {
300      return appendCommand(commandObjects.memoryUsage(key, samples));
301    }
302    @Override
303    public Response<Long> objectRefcount(String key) {
304      return appendCommand(commandObjects.objectRefcount(key));
305    }
306    @Override
307    public Response<String> objectEncoding(String key) {
308      return appendCommand(commandObjects.objectEncoding(key));
309    }
310    @Override
311    public Response<Long> objectIdletime(String key) {
312      return appendCommand(commandObjects.objectIdletime(key));
313    }
314    @Override
315    public Response<Long> objectFreq(String key) {
316      return appendCommand(commandObjects.objectFreq(key));
317    }
318    @Override
319    public Response<String> migrate(String host, int port, String key, int timeout) {
320      return appendCommand(commandObjects.migrate(host, port, key, timeout));
321    }
322    @Override
323    public Response<String> migrate(String host, int port, int timeout, MigrateParams params, String... keys) {
324      return appendCommand(commandObjects.migrate(host, port, timeout, params, keys));
325    }
326    @Override
327    public Response<Set<String>> keys(String pattern) {
328      return appendCommand(commandObjects.keys(pattern));
329    }
330    @Override
331    public Response<ScanResult<String>> scan(String cursor) {
332      return appendCommand(commandObjects.scan(cursor));
333    }
334    @Override
335    public Response<ScanResult<String>> scan(String cursor, ScanParams params) {
336      return appendCommand(commandObjects.scan(cursor, params));
337    }
338    @Override
339    public Response<ScanResult<String>> scan(String cursor, ScanParams params, String type) {
340      return appendCommand(commandObjects.scan(cursor, params, type));
341    }
342    @Override
343    public Response<String> randomKey() {
344      return appendCommand(commandObjects.randomKey());
345    }
346    @Override
347    public Response<String> get(String key) {
348      return appendCommand(commandObjects.get(key));
349    }
350    @Override
351    public Response<String> setGet(String key, String value, SetParams params) {
352      return appendCommand(commandObjects.setGet(key, value, params));
353    }
354    @Override
355    public Response<String> getDel(String key) {
356      return appendCommand(commandObjects.getDel(key));
357    }
358    @Override
359    public Response<String> getEx(String key, GetExParams params) {
360      return appendCommand(commandObjects.getEx(key, params));
361    }
362    @Override
363    public Response<Boolean> setbit(String key, long offset, boolean value) {
364      return appendCommand(commandObjects.setbit(key, offset, value));
365    }
366    @Override
367    public Response<Boolean> getbit(String key, long offset) {
368      return appendCommand(commandObjects.getbit(key, offset));
369    }
370    @Override
371    public Response<Long> setrange(String key, long offset, String value) {
372      return appendCommand(commandObjects.setrange(key, offset, value));
373    }
374    @Override
375    public Response<String> getrange(String key, long startOffset, long endOffset) {
376      return appendCommand(commandObjects.getrange(key, startOffset, endOffset));
377    }
378    @Override
379    public Response<String> getSet(String key, String value) {
380      return appendCommand(commandObjects.getSet(key, value));
381    }
382    @Override
383    public Response<Long> setnx(String key, String value) {
384      return appendCommand(commandObjects.setnx(key, value));
385    }
386    @Override
387    public Response<String> setex(String key, long seconds, String value) {
388      return appendCommand(commandObjects.setex(key, seconds, value));
389    }
390    @Override
391    public Response<String> psetex(String key, long milliseconds, String value) {
392      return appendCommand(commandObjects.psetex(key, milliseconds, value));
393    }
394    @Override
395    public Response<List<String>> mget(String... keys) {
396      return appendCommand(commandObjects.mget(keys));
397    }
398    @Override
399    public Response<String> mset(String... keysvalues) {
400      return appendCommand(commandObjects.mset(keysvalues));
401    }
402    @Override
403    public Response<Long> msetnx(String... keysvalues) {
404      return appendCommand(commandObjects.msetnx(keysvalues));
405    }
406    @Override
407    public Response<Long> incr(String key) {
408      return appendCommand(commandObjects.incr(key));
409    }
410    @Override
411    public Response<Long> incrBy(String key, long increment) {
412      return appendCommand(commandObjects.incrBy(key, increment));
413    }
414    @Override
415    public Response<Double> incrByFloat(String key, double increment) {
416      return appendCommand(commandObjects.incrByFloat(key, increment));
417    }
418    @Override
419    public Response<Long> decr(String key) {
420      return appendCommand(commandObjects.decr(key));
421    }
422    @Override
423    public Response<Long> decrBy(String key, long decrement) {
424      return appendCommand(commandObjects.decrBy(key, decrement));
425    }
426    @Override
427    public Response<Long> append(String key, String value) {
428      return appendCommand(commandObjects.append(key, value));
429    }
430    @Override
431    public Response<String> substr(String key, int start, int end) {
432      return appendCommand(commandObjects.substr(key, start, end));
433    }
434    @Override
435    public Response<Long> strlen(String key) {
436      return appendCommand(commandObjects.strlen(key));
437    }
438    @Override
439    public Response<Long> bitcount(String key) {
440      return appendCommand(commandObjects.bitcount(key));
441    }
442    @Override
443    public Response<Long> bitcount(String key, long start, long end) {
444      return appendCommand(commandObjects.bitcount(key, start, end));
445    }
446    @Override
447    public Response<Long> bitcount(String key, long start, long end, BitCountOption option) {
448      return appendCommand(commandObjects.bitcount(key, start, end, option));
449    }
450    @Override
451    public Response<Long> bitpos(String key, boolean value) {
452      return appendCommand(commandObjects.bitpos(key, value));
453    }
454    @Override
455    public Response<Long> bitpos(String key, boolean value, BitPosParams params) {
456      return appendCommand(commandObjects.bitpos(key, value, params));
457    }
458    @Override
459    public Response<List<Long>> bitfield(String key, String... arguments) {
460      return appendCommand(commandObjects.bitfield(key, arguments));
461    }
462    @Override
463    public Response<List<Long>> bitfieldReadonly(String key, String... arguments) {
464      return appendCommand(commandObjects.bitfieldReadonly(key, arguments));
465    }
466    @Override
467    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
468      return appendCommand(commandObjects.bitop(op, destKey, srcKeys));
469    }
470    @Override
471    public Response<LCSMatchResult> lcs(String keyA, String keyB, LCSParams params) {
472      return appendCommand(commandObjects.lcs(keyA, keyB, params));
473    }
474    @Override
475    public Response<String> set(String key, String value) {
476      return appendCommand(commandObjects.set(key, value));
477    }
478    @Override
479    public Response<String> set(String key, String value, SetParams params) {
480      return appendCommand(commandObjects.set(key, value, params));
481    }
482    @Override
483    public Response<Long> rpush(String key, String... string) {
484      return appendCommand(commandObjects.rpush(key, string));
485    }
486    @Override
487    public Response<Long> lpush(String key, String... string) {
488      return appendCommand(commandObjects.lpush(key, string));
489    }
490    @Override
491    public Response<Long> llen(String key) {
492      return appendCommand(commandObjects.llen(key));
493    }
494    @Override
495    public Response<List<String>> lrange(String key, long start, long stop) {
496      return appendCommand(commandObjects.lrange(key, start, stop));
497    }
498    @Override
499    public Response<String> ltrim(String key, long start, long stop) {
500      return appendCommand(commandObjects.ltrim(key, start, stop));
501    }
502    @Override
503    public Response<String> lindex(String key, long index) {
504      return appendCommand(commandObjects.lindex(key, index));
505    }
506    @Override
507    public Response<String> lset(String key, long index, String value) {
508      return appendCommand(commandObjects.lset(key, index, value));
509    }
510    @Override
511    public Response<Long> lrem(String key, long count, String value) {
512      return appendCommand(commandObjects.lrem(key, count, value));
513    }
514    @Override
515    public Response<String> lpop(String key) {
516      return appendCommand(commandObjects.lpop(key));
517    }
518    @Override
519    public Response<List<String>> lpop(String key, int count) {
520      return appendCommand(commandObjects.lpop(key, count));
521    }
522    @Override
523    public Response<Long> lpos(String key, String element) {
524      return appendCommand(commandObjects.lpos(key, element));
525    }
526    @Override
527    public Response<Long> lpos(String key, String element, LPosParams params) {
528      return appendCommand(commandObjects.lpos(key, element, params));
529    }
530    @Override
531    public Response<List<Long>> lpos(String key, String element, LPosParams params, long count) {
532      return appendCommand(commandObjects.lpos(key, element, params, count));
533    }
534    @Override
535    public Response<String> rpop(String key) {
536      return appendCommand(commandObjects.rpop(key));
537    }
538    @Override
539    public Response<List<String>> rpop(String key, int count) {
540      return appendCommand(commandObjects.rpop(key, count));
541    }
542    @Override
543    public Response<Long> linsert(String key, ListPosition where, String pivot, String value) {
544      return appendCommand(commandObjects.linsert(key, where, pivot, value));
545    }
546    @Override
547    public Response<Long> lpushx(String key, String... strings) {
548      return appendCommand(commandObjects.lpushx(key, strings));
549    }
550    @Override
551    public Response<Long> rpushx(String key, String... strings) {
552      return appendCommand(commandObjects.rpushx(key, strings));
553    }
554    @Override
555    public Response<List<String>> blpop(int timeout, String key) {
556      return appendCommand(commandObjects.blpop(timeout, key));
557    }
558    @Override
559    public Response<KeyValue<String, String>> blpop(double timeout, String key) {
560      return appendCommand(commandObjects.blpop(timeout, key));
561    }
562    @Override
563    public Response<List<String>> brpop(int timeout, String key) {
564      return appendCommand(commandObjects.brpop(timeout, key));
565    }
566    @Override
<span onclick='openModal()' class='match'>567    public Response<KeyValue<String, String>> brpop(double timeout, String key) {
568      return appendCommand(commandObjects.brpop(timeout, key));
569    }
570    @Override
571    public Response<List<String>> blpop(int timeout, String... keys) {
</span>572      return appendCommand(commandObjects.blpop(timeout, keys));
573    }
574    @Override
575    public Response<KeyValue<String, String>> blpop(double timeout, String... keys) {
576      return appendCommand(commandObjects.blpop(timeout, keys));
577    }
578    @Override
579    public Response<List<String>> brpop(int timeout, String... keys) {
580      return appendCommand(commandObjects.brpop(timeout, keys));
581    }
582    @Override
583    public Response<KeyValue<String, String>> brpop(double timeout, String... keys) {
584      return appendCommand(commandObjects.brpop(timeout, keys));
585    }
586    @Override
587    public Response<String> rpoplpush(String srcKey, String dstKey) {
588      return appendCommand(commandObjects.rpoplpush(srcKey, dstKey));
589    }
590    @Override
591    public Response<String> brpoplpush(String source, String destination, int timeout) {
592      return appendCommand(commandObjects.brpoplpush(source, destination, timeout));
593    }
594    @Override
595    public Response<String> lmove(String srcKey, String dstKey, ListDirection from, ListDirection to) {
596      return appendCommand(commandObjects.lmove(srcKey, dstKey, from, to));
597    }
598    @Override
599    public Response<String> blmove(String srcKey, String dstKey, ListDirection from, ListDirection to, double timeout) {
600      return appendCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
601    }
602    @Override
603    public Response<KeyValue<String, List<String>>> lmpop(ListDirection direction, String... keys) {
604      return appendCommand(commandObjects.lmpop(direction, keys));
605    }
606    @Override
607    public Response<KeyValue<String, List<String>>> lmpop(ListDirection direction, int count, String... keys) {
608      return appendCommand(commandObjects.lmpop(direction, count, keys));
609    }
610    @Override
611    public Response<KeyValue<String, List<String>>> blmpop(double timeout, ListDirection direction, String... keys) {
612      return appendCommand(commandObjects.blmpop(timeout, direction, keys));
613    }
614    @Override
615    public Response<KeyValue<String, List<String>>> blmpop(double timeout, ListDirection direction, int count, String... keys) {
616      return appendCommand(commandObjects.blmpop(timeout, direction, count, keys));
617    }
618    @Override
619    public Response<Long> hset(String key, String field, String value) {
620      return appendCommand(commandObjects.hset(key, field, value));
621    }
622    @Override
623    public Response<Long> hset(String key, Map<String, String> hash) {
624      return appendCommand(commandObjects.hset(key, hash));
625    }
626    @Override
627    public Response<String> hget(String key, String field) {
628      return appendCommand(commandObjects.hget(key, field));
629    }
630    @Override
631    public Response<Long> hsetnx(String key, String field, String value) {
632      return appendCommand(commandObjects.hsetnx(key, field, value));
633    }
634    @Override
635    public Response<String> hmset(String key, Map<String, String> hash) {
636      return appendCommand(commandObjects.hmset(key, hash));
637    }
638    @Override
639    public Response<List<String>> hmget(String key, String... fields) {
640      return appendCommand(commandObjects.hmget(key, fields));
641    }
642    @Override
643    public Response<Long> hincrBy(String key, String field, long value) {
644      return appendCommand(commandObjects.hincrBy(key, field, value));
645    }
646    @Override
647    public Response<Double> hincrByFloat(String key, String field, double value) {
648      return appendCommand(commandObjects.hincrByFloat(key, field, value));
649    }
650    @Override
651    public Response<Boolean> hexists(String key, String field) {
652      return appendCommand(commandObjects.hexists(key, field));
653    }
654    @Override
655    public Response<Long> hdel(String key, String... field) {
656      return appendCommand(commandObjects.hdel(key, field));
657    }
658    @Override
659    public Response<Long> hlen(String key) {
660      return appendCommand(commandObjects.hlen(key));
661    }
662    @Override
663    public Response<Set<String>> hkeys(String key) {
664      return appendCommand(commandObjects.hkeys(key));
665    }
666    @Override
667    public Response<List<String>> hvals(String key) {
668      return appendCommand(commandObjects.hvals(key));
669    }
670    @Override
671    public Response<Map<String, String>> hgetAll(String key) {
672      return appendCommand(commandObjects.hgetAll(key));
673    }
674    @Override
675    public Response<String> hrandfield(String key) {
676      return appendCommand(commandObjects.hrandfield(key));
677    }
678    @Override
679    public Response<List<String>> hrandfield(String key, long count) {
680      return appendCommand(commandObjects.hrandfield(key, count));
681    }
682    @Override
683    public Response<List<Map.Entry<String, String>>> hrandfieldWithValues(String key, long count) {
684      return appendCommand(commandObjects.hrandfieldWithValues(key, count));
685    }
686    @Override
687    public Response<ScanResult<Map.Entry<String, String>>> hscan(String key, String cursor, ScanParams params) {
688      return appendCommand(commandObjects.hscan(key, cursor, params));
689    }
690    @Override
691    public Response<Long> hstrlen(String key, String field) {
692      return appendCommand(commandObjects.hstrlen(key, field));
693    }
694    @Override
695    public Response<Long> sadd(String key, String... members) {
696      return appendCommand(commandObjects.sadd(key, members));
697    }
698    @Override
699    public Response<Set<String>> smembers(String key) {
700      return appendCommand(commandObjects.smembers(key));
701    }
702    @Override
703    public Response<Long> srem(String key, String... members) {
704      return appendCommand(commandObjects.srem(key, members));
705    }
706    @Override
707    public Response<String> spop(String key) {
708      return appendCommand(commandObjects.spop(key));
709    }
710    @Override
711    public Response<Set<String>> spop(String key, long count) {
712      return appendCommand(commandObjects.spop(key, count));
713    }
714    @Override
715    public Response<Long> scard(String key) {
716      return appendCommand(commandObjects.scard(key));
717    }
718    @Override
719    public Response<Boolean> sismember(String key, String member) {
720      return appendCommand(commandObjects.sismember(key, member));
721    }
722    @Override
723    public Response<List<Boolean>> smismember(String key, String... members) {
724      return appendCommand(commandObjects.smismember(key, members));
725    }
726    @Override
727    public Response<String> srandmember(String key) {
728      return appendCommand(commandObjects.srandmember(key));
729    }
730    @Override
731    public Response<List<String>> srandmember(String key, int count) {
732      return appendCommand(commandObjects.srandmember(key, count));
733    }
734    @Override
735    public Response<ScanResult<String>> sscan(String key, String cursor, ScanParams params) {
736      return appendCommand(commandObjects.sscan(key, cursor, params));
737    }
738    @Override
739    public Response<Set<String>> sdiff(String... keys) {
740      return appendCommand(commandObjects.sdiff(keys));
741    }
742    @Override
743    public Response<Long> sdiffStore(String dstKey, String... keys) {
744      return appendCommand(commandObjects.sdiffstore(dstKey, keys));
745    }
746    @Override
747    public Response<Set<String>> sinter(String... keys) {
748      return appendCommand(commandObjects.sinter(keys));
749    }
750    @Override
751    public Response<Long> sinterstore(String dstKey, String... keys) {
752      return appendCommand(commandObjects.sinterstore(dstKey, keys));
753    }
754    @Override
755    public Response<Long> sintercard(String... keys) {
756      return appendCommand(commandObjects.sintercard(keys));
757    }
758    @Override
759    public Response<Long> sintercard(int limit, String... keys) {
760      return appendCommand(commandObjects.sintercard(limit, keys));
761    }
762    @Override
763    public Response<Set<String>> sunion(String... keys) {
764      return appendCommand(commandObjects.sunion(keys));
765    }
766    @Override
767    public Response<Long> sunionstore(String dstKey, String... keys) {
768      return appendCommand(commandObjects.sunionstore(dstKey, keys));
769    }
770    @Override
771    public Response<Long> smove(String srcKey, String dstKey, String member) {
772      return appendCommand(commandObjects.smove(srcKey, dstKey, member));
773    }
774    @Override
775    public Response<Long> zadd(String key, double score, String member) {
776      return appendCommand(commandObjects.zadd(key, score, member));
777    }
778    @Override
779    public Response<Long> zadd(String key, double score, String member, ZAddParams params) {
780      return appendCommand(commandObjects.zadd(key, score, member, params));
781    }
782    @Override
783    public Response<Long> zadd(String key, Map<String, Double> scoreMembers) {
784      return appendCommand(commandObjects.zadd(key, scoreMembers));
785    }
786    @Override
787    public Response<Long> zadd(String key, Map<String, Double> scoreMembers, ZAddParams params) {
788      return appendCommand(commandObjects.zadd(key, scoreMembers, params));
789    }
790    @Override
791    public Response<Double> zaddIncr(String key, double score, String member, ZAddParams params) {
792      return appendCommand(commandObjects.zaddIncr(key, score, member, params));
793    }
794    @Override
795    public Response<Long> zrem(String key, String... members) {
796      return appendCommand(commandObjects.zrem(key, members));
797    }
798    @Override
799    public Response<Double> zincrby(String key, double increment, String member) {
800      return appendCommand(commandObjects.zincrby(key, increment, member));
801    }
802    @Override
803    public Response<Double> zincrby(String key, double increment, String member, ZIncrByParams params) {
804      return appendCommand(commandObjects.zincrby(key, increment, member, params));
805    }
806    @Override
807    public Response<Long> zrank(String key, String member) {
808      return appendCommand(commandObjects.zrank(key, member));
809    }
810    @Override
811    public Response<Long> zrevrank(String key, String member) {
812      return appendCommand(commandObjects.zrevrank(key, member));
813    }
814    @Override
815    public Response<KeyValue<Long, Double>> zrankWithScore(String key, String member) {
816      return appendCommand(commandObjects.zrankWithScore(key, member));
817    }
818    @Override
819    public Response<KeyValue<Long, Double>> zrevrankWithScore(String key, String member) {
820      return appendCommand(commandObjects.zrevrankWithScore(key, member));
821    }
822    @Override
823    public Response<List<String>> zrange(String key, long start, long stop) {
824      return appendCommand(commandObjects.zrange(key, start, stop));
825    }
826    @Override
827    public Response<List<String>> zrevrange(String key, long start, long stop) {
828      return appendCommand(commandObjects.zrevrange(key, start, stop));
829    }
830    @Override
831    public Response<List<Tuple>> zrangeWithScores(String key, long start, long stop) {
832      return appendCommand(commandObjects.zrangeWithScores(key, start, stop));
833    }
834    @Override
835    public Response<List<Tuple>> zrevrangeWithScores(String key, long start, long stop) {
836      return appendCommand(commandObjects.zrevrangeWithScores(key, start, stop));
837    }
838    @Override
839    public Response<List<String>> zrange(String key, ZRangeParams zRangeParams) {
840      return appendCommand(commandObjects.zrange(key, zRangeParams));
841    }
842    @Override
843    public Response<List<Tuple>> zrangeWithScores(String key, ZRangeParams zRangeParams) {
844      return appendCommand(commandObjects.zrangeWithScores(key, zRangeParams));
845    }
846    @Override
847    public Response<Long> zrangestore(String dest, String src, ZRangeParams zRangeParams) {
848      return appendCommand(commandObjects.zrangestore(dest, src, zRangeParams));
849    }
850    @Override
851    public Response<String> zrandmember(String key) {
852      return appendCommand(commandObjects.zrandmember(key));
853    }
854    @Override
855    public Response<List<String>> zrandmember(String key, long count) {
856      return appendCommand(commandObjects.zrandmember(key, count));
857    }
858    @Override
859    public Response<List<Tuple>> zrandmemberWithScores(String key, long count) {
860      return appendCommand(commandObjects.zrandmemberWithScores(key, count));
861    }
862    @Override
863    public Response<Long> zcard(String key) {
864      return appendCommand(commandObjects.zcard(key));
865    }
866    @Override
867    public Response<Double> zscore(String key, String member) {
868      return appendCommand(commandObjects.zscore(key, member));
869    }
870    @Override
871    public Response<List<Double>> zmscore(String key, String... members) {
872      return appendCommand(commandObjects.zmscore(key, members));
873    }
874    @Override
875    public Response<Tuple> zpopmax(String key) {
876      return appendCommand(commandObjects.zpopmax(key));
877    }
878    @Override
879    public Response<List<Tuple>> zpopmax(String key, int count) {
880      return appendCommand(commandObjects.zpopmax(key, count));
881    }
882    @Override
883    public Response<Tuple> zpopmin(String key) {
884      return appendCommand(commandObjects.zpopmin(key));
885    }
886    @Override
887    public Response<List<Tuple>> zpopmin(String key, int count) {
888      return appendCommand(commandObjects.zpopmin(key, count));
889    }
890    @Override
891    public Response<Long> zcount(String key, double min, double max) {
892      return appendCommand(commandObjects.zcount(key, min, max));
893    }
894    @Override
895    public Response<Long> zcount(String key, String min, String max) {
896      return appendCommand(commandObjects.zcount(key, min, max));
897    }
898    @Override
899    public Response<List<String>> zrangeByScore(String key, double min, double max) {
900      return appendCommand(commandObjects.zrangeByScore(key, min, max));
901    }
902    @Override
903    public Response<List<String>> zrangeByScore(String key, String min, String max) {
904      return appendCommand(commandObjects.zrangeByScore(key, min, max));
905    }
906    @Override
907    public Response<List<String>> zrevrangeByScore(String key, double max, double min) {
908      return appendCommand(commandObjects.zrevrangeByScore(key, max, min));
909    }
910    @Override
911    public Response<List<String>> zrangeByScore(String key, double min, double max, int offset, int count) {
912      return appendCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
913    }
914    @Override
915    public Response<List<String>> zrevrangeByScore(String key, String max, String min) {
916      return appendCommand(commandObjects.zrevrangeByScore(key, max, min));
917    }
918    @Override
919    public Response<List<String>> zrangeByScore(String key, String min, String max, int offset, int count) {
920      return appendCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
921    }
922    @Override
923    public Response<List<String>> zrevrangeByScore(String key, double max, double min, int offset, int count) {
924      return appendCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
925    }
926    @Override
927    public Response<List<Tuple>> zrangeByScoreWithScores(String key, double min, double max) {
928      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
929    }
930    @Override
931    public Response<List<Tuple>> zrevrangeByScoreWithScores(String key, double max, double min) {
932      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
933    }
934    @Override
935    public Response<List<Tuple>> zrangeByScoreWithScores(String key, double min, double max, int offset, int count) {
936      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
937    }
938    @Override
939    public Response<List<String>> zrevrangeByScore(String key, String max, String min, int offset, int count) {
940      return appendCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
941    }
942    @Override
943    public Response<List<Tuple>> zrangeByScoreWithScores(String key, String min, String max) {
944      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
945    }
946    @Override
947    public Response<List<Tuple>> zrevrangeByScoreWithScores(String key, String max, String min) {
948      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
949    }
950    @Override
951    public Response<List<Tuple>> zrangeByScoreWithScores(String key, String min, String max, int offset, int count) {
952      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
953    }
954    @Override
955    public Response<List<Tuple>> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count) {
956      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
957    }
958    @Override
959    public Response<List<Tuple>> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count) {
960      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
961    }
962    @Override
963    public Response<Long> zremrangeByRank(String key, long start, long stop) {
964      return appendCommand(commandObjects.zremrangeByRank(key, start, stop));
965    }
966    @Override
967    public Response<Long> zremrangeByScore(String key, double min, double max) {
968      return appendCommand(commandObjects.zremrangeByScore(key, min, max));
969    }
970    @Override
971    public Response<Long> zremrangeByScore(String key, String min, String max) {
972      return appendCommand(commandObjects.zremrangeByScore(key, min, max));
973    }
974    @Override
975    public Response<Long> zlexcount(String key, String min, String max) {
976      return appendCommand(commandObjects.zlexcount(key, min, max));
977    }
978    @Override
979    public Response<List<String>> zrangeByLex(String key, String min, String max) {
980      return appendCommand(commandObjects.zrangeByLex(key, min, max));
981    }
982    @Override
983    public Response<List<String>> zrangeByLex(String key, String min, String max, int offset, int count) {
984      return appendCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
985    }
986    @Override
987    public Response<List<String>> zrevrangeByLex(String key, String max, String min) {
988      return appendCommand(commandObjects.zrevrangeByLex(key, max, min));
989    }
990    @Override
991    public Response<List<String>> zrevrangeByLex(String key, String max, String min, int offset, int count) {
992      return appendCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
993    }
994    @Override
995    public Response<Long> zremrangeByLex(String key, String min, String max) {
996      return appendCommand(commandObjects.zremrangeByLex(key, min, max));
997    }
998    @Override
999    public Response<ScanResult<Tuple>> zscan(String key, String cursor, ScanParams params) {
1000      return appendCommand(commandObjects.zscan(key, cursor, params));
1001    }
1002    @Override
1003    public Response<KeyValue<String, Tuple>> bzpopmax(double timeout, String... keys) {
1004      return appendCommand(commandObjects.bzpopmax(timeout, keys));
1005    }
1006    @Override
1007    public Response<KeyValue<String, Tuple>> bzpopmin(double timeout, String... keys) {
1008      return appendCommand(commandObjects.bzpopmin(timeout, keys));
1009    }
1010    @Override
1011    public Response<KeyValue<String, List<Tuple>>> zmpop(SortedSetOption option, String... keys) {
1012      return appendCommand(commandObjects.zmpop(option, keys));
1013    }
1014    @Override
1015    public Response<KeyValue<String, List<Tuple>>> zmpop(SortedSetOption option, int count, String... keys) {
1016      return appendCommand(commandObjects.zmpop(option, count, keys));
1017    }
1018    @Override
1019    public Response<KeyValue<String, List<Tuple>>> bzmpop(double timeout, SortedSetOption option, String... keys) {
1020      return appendCommand(commandObjects.bzmpop(timeout, option, keys));
1021    }
1022    @Override
1023    public Response<KeyValue<String, List<Tuple>>> bzmpop(double timeout, SortedSetOption option, int count, String... keys) {
1024      return appendCommand(commandObjects.bzmpop(timeout, option, count, keys));
1025    }
1026    @Override
1027    public Response<List<String>> zdiff(String... keys) {
1028      return appendCommand(commandObjects.zdiff(keys));
1029    }
1030    @Override
1031    public Response<List<Tuple>> zdiffWithScores(String... keys) {
1032      return appendCommand(commandObjects.zdiffWithScores(keys));
1033    }
1034    @Override
1035    @Deprecated
1036    public Response<Long> zdiffStore(String dstKey, String... keys) {
1037      return appendCommand(commandObjects.zdiffStore(dstKey, keys));
1038    }
1039    @Override
1040    public Response<Long> zdiffstore(String dstKey, String... keys) {
1041      return appendCommand(commandObjects.zdiffstore(dstKey, keys));
1042    }
1043    @Override
1044    public Response<Long> zinterstore(String dstKey, String... sets) {
1045      return appendCommand(commandObjects.zinterstore(dstKey, sets));
1046    }
1047    @Override
1048    public Response<Long> zinterstore(String dstKey, ZParams params, String... sets) {
1049      return appendCommand(commandObjects.zinterstore(dstKey, params, sets));
1050    }
1051    @Override
1052    public Response<List<String>> zinter(ZParams params, String... keys) {
1053      return appendCommand(commandObjects.zinter(params, keys));
1054    }
1055    @Override
1056    public Response<List<Tuple>> zinterWithScores(ZParams params, String... keys) {
1057      return appendCommand(commandObjects.zinterWithScores(params, keys));
1058    }
1059    @Override
1060    public Response<Long> zintercard(String... keys) {
1061      return appendCommand(commandObjects.zintercard(keys));
1062    }
1063    @Override
1064    public Response<Long> zintercard(long limit, String... keys) {
1065      return appendCommand(commandObjects.zintercard(limit, keys));
1066    }
1067    @Override
1068    public Response<List<String>> zunion(ZParams params, String... keys) {
1069      return appendCommand(commandObjects.zunion(params, keys));
1070    }
1071    @Override
1072    public Response<List<Tuple>> zunionWithScores(ZParams params, String... keys) {
1073      return appendCommand(commandObjects.zunionWithScores(params, keys));
1074    }
1075    @Override
1076    public Response<Long> zunionstore(String dstKey, String... sets) {
1077      return appendCommand(commandObjects.zunionstore(dstKey, sets));
1078    }
1079    @Override
1080    public Response<Long> zunionstore(String dstKey, ZParams params, String... sets) {
1081      return appendCommand(commandObjects.zunionstore(dstKey, params, sets));
1082    }
1083    @Override
1084    public Response<Long> geoadd(String key, double longitude, double latitude, String member) {
1085      return appendCommand(commandObjects.geoadd(key, longitude, latitude, member));
1086    }
1087    @Override
1088    public Response<Long> geoadd(String key, Map<String, GeoCoordinate> memberCoordinateMap) {
1089      return appendCommand(commandObjects.geoadd(key, memberCoordinateMap));
1090    }
1091    @Override
1092    public Response<Long> geoadd(String key, GeoAddParams params, Map<String, GeoCoordinate> memberCoordinateMap) {
1093      return appendCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
1094    }
1095    @Override
1096    public Response<Double> geodist(String key, String member1, String member2) {
1097      return appendCommand(commandObjects.geodist(key, member1, member2));
1098    }
1099    @Override
1100    public Response<Double> geodist(String key, String member1, String member2, GeoUnit unit) {
1101      return appendCommand(commandObjects.geodist(key, member1, member2, unit));
1102    }
1103    @Override
1104    public Response<List<String>> geohash(String key, String... members) {
1105      return appendCommand(commandObjects.geohash(key, members));
1106    }
1107    @Override
1108    public Response<List<GeoCoordinate>> geopos(String key, String... members) {
1109      return appendCommand(commandObjects.geopos(key, members));
1110    }
1111    @Override
1112    public Response<List<GeoRadiusResponse>> georadius(String key, double longitude, double latitude, double radius, GeoUnit unit) {
1113      return appendCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
1114    }
1115    @Override
1116    public Response<List<GeoRadiusResponse>> georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit) {
1117      return appendCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
1118    }
1119    @Override
1120    public Response<List<GeoRadiusResponse>> georadius(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
1121      return appendCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
1122    }
1123    @Override
1124    public Response<List<GeoRadiusResponse>> georadiusReadonly(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
1125      return appendCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
1126    }
1127    @Override
1128    public Response<List<GeoRadiusResponse>> georadiusByMember(String key, String member, double radius, GeoUnit unit) {
1129      return appendCommand(commandObjects.georadiusByMember(key, member, radius, unit));
1130    }
1131    @Override
1132    public Response<List<GeoRadiusResponse>> georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit) {
1133      return appendCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
1134    }
1135    @Override
1136    public Response<List<GeoRadiusResponse>> georadiusByMember(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
1137      return appendCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
1138    }
1139    @Override
1140    public Response<List<GeoRadiusResponse>> georadiusByMemberReadonly(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param) {
1141      return appendCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
1142    }
1143    @Override
1144    public Response<Long> georadiusStore(String key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
1145      return appendCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
1146    }
1147    @Override
1148    public Response<Long> georadiusByMemberStore(String key, String member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
1149      return appendCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
1150    }
1151    @Override
1152    public Response<List<GeoRadiusResponse>> geosearch(String key, String member, double radius, GeoUnit unit) {
1153      return appendCommand(commandObjects.geosearch(key, member, radius, unit));
1154    }
1155    @Override
1156    public Response<List<GeoRadiusResponse>> geosearch(String key, GeoCoordinate coord, double radius, GeoUnit unit) {
1157      return appendCommand(commandObjects.geosearch(key, coord, radius, unit));
1158    }
1159    @Override
1160    public Response<List<GeoRadiusResponse>> geosearch(String key, String member, double width, double height, GeoUnit unit) {
1161      return appendCommand(commandObjects.geosearch(key, member, width, height, unit));
1162    }
1163    @Override
1164    public Response<List<GeoRadiusResponse>> geosearch(String key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
1165      return appendCommand(commandObjects.geosearch(key, coord, width, height, unit));
1166    }
1167    @Override
1168    public Response<List<GeoRadiusResponse>> geosearch(String key, GeoSearchParam params) {
1169      return appendCommand(commandObjects.geosearch(key, params));
1170    }
1171    @Override
1172    public Response<Long> geosearchStore(String dest, String src, String member, double radius, GeoUnit unit) {
1173      return appendCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
1174    }
1175    @Override
1176    public Response<Long> geosearchStore(String dest, String src, GeoCoordinate coord, double radius, GeoUnit unit) {
1177      return appendCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
1178    }
1179    @Override
1180    public Response<Long> geosearchStore(String dest, String src, String member, double width, double height, GeoUnit unit) {
1181      return appendCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
1182    }
1183    @Override
1184    public Response<Long> geosearchStore(String dest, String src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
1185      return appendCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
1186    }
1187    @Override
1188    public Response<Long> geosearchStore(String dest, String src, GeoSearchParam params) {
1189      return appendCommand(commandObjects.geosearchStore(dest, src, params));
1190    }
1191    @Override
1192    public Response<Long> geosearchStoreStoreDist(String dest, String src, GeoSearchParam params) {
1193      return appendCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
1194    }
1195    @Override
1196    public Response<Long> pfadd(String key, String... elements) {
1197      return appendCommand(commandObjects.pfadd(key, elements));
1198    }
1199    @Override
1200    public Response<String> pfmerge(String destkey, String... sourcekeys) {
1201      return appendCommand(commandObjects.pfmerge(destkey, sourcekeys));
1202    }
1203    @Override
1204    public Response<Long> pfcount(String key) {
1205      return appendCommand(commandObjects.pfcount(key));
1206    }
1207    @Override
1208    public Response<Long> pfcount(String... keys) {
1209      return appendCommand(commandObjects.pfcount(keys));
1210    }
1211    @Override
1212    public Response<StreamEntryID> xadd(String key, StreamEntryID id, Map<String, String> hash) {
1213      return appendCommand(commandObjects.xadd(key, id, hash));
1214    }
1215    @Override
1216    public Response<StreamEntryID> xadd(String key, XAddParams params, Map<String, String> hash) {
1217      return appendCommand(commandObjects.xadd(key, params, hash));
1218    }
1219    @Override
1220    public Response<Long> xlen(String key) {
1221      return appendCommand(commandObjects.xlen(key));
1222    }
1223    @Override
1224    public Response<List<StreamEntry>> xrange(String key, StreamEntryID start, StreamEntryID end) {
1225      return appendCommand(commandObjects.xrange(key, start, end));
1226    }
1227    @Override
1228    public Response<List<StreamEntry>> xrange(String key, StreamEntryID start, StreamEntryID end, int count) {
1229      return appendCommand(commandObjects.xrange(key, start, end, count));
1230    }
1231    @Override
1232    public Response<List<StreamEntry>> xrevrange(String key, StreamEntryID end, StreamEntryID start) {
1233      return appendCommand(commandObjects.xrevrange(key, start, end));
1234    }
1235    @Override
1236    public Response<List<StreamEntry>> xrevrange(String key, StreamEntryID end, StreamEntryID start, int count) {
1237      return appendCommand(commandObjects.xrevrange(key, start, end, count));
1238    }
1239    @Override
1240    public Response<List<StreamEntry>> xrange(String key, String start, String end) {
1241      return appendCommand(commandObjects.xrange(key, start, end));
1242    }
1243    @Override
1244    public Response<List<StreamEntry>> xrange(String key, String start, String end, int count) {
1245      return appendCommand(commandObjects.xrange(key, start, end, count));
1246    }
1247    @Override
1248    public Response<List<StreamEntry>> xrevrange(String key, String end, String start) {
1249      return appendCommand(commandObjects.xrevrange(key, start, end));
1250    }
1251    @Override
1252    public Response<List<StreamEntry>> xrevrange(String key, String end, String start, int count) {
1253      return appendCommand(commandObjects.xrevrange(key, start, end, count));
1254    }
1255    @Override
1256    public Response<Long> xack(String key, String group, StreamEntryID... ids) {
1257      return appendCommand(commandObjects.xack(key, group, ids));
1258    }
1259    @Override
1260    public Response<String> xgroupCreate(String key, String groupName, StreamEntryID id, boolean makeStream) {
1261      return appendCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
1262    }
1263    @Override
1264    public Response<String> xgroupSetID(String key, String groupName, StreamEntryID id) {
1265      return appendCommand(commandObjects.xgroupSetID(key, groupName, id));
1266    }
1267    @Override
1268    public Response<Long> xgroupDestroy(String key, String groupName) {
1269      return appendCommand(commandObjects.xgroupDestroy(key, groupName));
1270    }
1271    @Override
1272    public Response<Boolean> xgroupCreateConsumer(String key, String groupName, String consumerName) {
1273      return appendCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
1274    }
1275    @Override
1276    public Response<Long> xgroupDelConsumer(String key, String groupName, String consumerName) {
1277      return appendCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
1278    }
1279    @Override
1280    public Response<StreamPendingSummary> xpending(String key, String groupName) {
1281      return appendCommand(commandObjects.xpending(key, groupName));
1282    }
1283    @Override
1284    public Response<List<StreamPendingEntry>> xpending(String key, String groupName, XPendingParams params) {
1285      return appendCommand(commandObjects.xpending(key, groupName, params));
1286    }
1287    @Override
1288    public Response<Long> xdel(String key, StreamEntryID... ids) {
1289      return appendCommand(commandObjects.xdel(key, ids));
1290    }
1291    @Override
1292    public Response<Long> xtrim(String key, long maxLen, boolean approximate) {
1293      return appendCommand(commandObjects.xtrim(key, maxLen, approximate));
1294    }
1295    @Override
1296    public Response<Long> xtrim(String key, XTrimParams params) {
1297      return appendCommand(commandObjects.xtrim(key, params));
1298    }
1299    @Override
1300    public Response<List<StreamEntry>> xclaim(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
1301      return appendCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
1302    }
1303    @Override
1304    public Response<List<StreamEntryID>> xclaimJustId(String key, String group, String consumerName, long minIdleTime, XClaimParams params, StreamEntryID... ids) {
1305      return appendCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
1306    }
1307    @Override
1308    public Response<Map.Entry<StreamEntryID, List<StreamEntry>>> xautoclaim(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
1309      return appendCommand(commandObjects.xautoclaim(key, group, consumerName, minIdleTime, start, params));
1310    }
1311    @Override
1312    public Response<Map.Entry<StreamEntryID, List<StreamEntryID>>> xautoclaimJustId(String key, String group, String consumerName, long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
1313      return appendCommand(commandObjects.xautoclaimJustId(key, group, consumerName, minIdleTime, start, params));
1314    }
1315    @Override
1316    public Response<StreamInfo> xinfoStream(String key) {
1317      return appendCommand(commandObjects.xinfoStream(key));
1318    }
1319    @Override
1320    public Response<StreamFullInfo> xinfoStreamFull(String key) {
1321      return appendCommand(commandObjects.xinfoStreamFull(key));
1322    }
1323    @Override
1324    public Response<StreamFullInfo> xinfoStreamFull(String key, int count) {
1325      return appendCommand(commandObjects.xinfoStreamFull(key, count));
1326    }
1327    @Override
1328    public Response<List<StreamGroupInfo>> xinfoGroups(String key) {
1329      return appendCommand(commandObjects.xinfoGroups(key));
1330    }
1331    @Override
1332    public Response<List<StreamConsumersInfo>> xinfoConsumers(String key, String group) {
1333      return appendCommand(commandObjects.xinfoConsumers(key, group));
1334    }
1335    @Override
1336    public Response<List<StreamConsumerInfo>> xinfoConsumers2(String key, String group) {
1337      return appendCommand(commandObjects.xinfoConsumers2(key, group));
1338    }
1339    @Override
1340    public Response<List<Map.Entry<String, List<StreamEntry>>>> xread(XReadParams xReadParams, Map<String, StreamEntryID> streams) {
1341      return appendCommand(commandObjects.xread(xReadParams, streams));
1342    }
1343    @Override
1344    public Response<List<Map.Entry<String, List<StreamEntry>>>> xreadGroup(String groupName, String consumer, XReadGroupParams xReadGroupParams, Map<String, StreamEntryID> streams) {
1345      return appendCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
1346    }
1347    @Override
1348    public Response<Object> eval(String script) {
1349      return appendCommand(commandObjects.eval(script));
1350    }
1351    @Override
1352    public Response<Object> eval(String script, int keyCount, String... params) {
1353      return appendCommand(commandObjects.eval(script, keyCount, params));
1354    }
1355    @Override
1356    public Response<Object> eval(String script, List<String> keys, List<String> args) {
1357      return appendCommand(commandObjects.eval(script, keys, args));
1358    }
1359    @Override
1360    public Response<Object> evalReadonly(String script, List<String> keys, List<String> args) {
1361      return appendCommand(commandObjects.evalReadonly(script, keys, args));
1362    }
1363    @Override
1364    public Response<Object> evalsha(String sha1) {
1365      return appendCommand(commandObjects.evalsha(sha1));
1366    }
1367    @Override
1368    public Response<Object> evalsha(String sha1, int keyCount, String... params) {
1369      return appendCommand(commandObjects.evalsha(sha1, keyCount, params));
1370    }
1371    @Override
1372    public Response<Object> evalsha(String sha1, List<String> keys, List<String> args) {
1373      return appendCommand(commandObjects.evalsha(sha1, keys, args));
1374    }
1375    @Override
1376    public Response<Object> evalshaReadonly(String sha1, List<String> keys, List<String> args) {
1377      return appendCommand(commandObjects.evalshaReadonly(sha1, keys, args));
1378    }
1379    @Override
1380    public Response<Long> waitReplicas(String sampleKey, int replicas, long timeout) {
1381      return appendCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
1382    }
1383    @Override
1384    public Response<KeyValue<Long, Long>> waitAOF(String sampleKey, long numLocal, long numReplicas, long timeout) {
1385      return appendCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
1386    }
1387    @Override
1388    public Response<Object> eval(String script, String sampleKey) {
1389      return appendCommand(commandObjects.eval(script, sampleKey));
1390    }
1391    @Override
1392    public Response<Object> evalsha(String sha1, String sampleKey) {
1393      return appendCommand(commandObjects.evalsha(sha1, sampleKey));
1394    }
1395    @Override
1396    public Response<List<Boolean>> scriptExists(String sampleKey, String... sha1) {
1397      return appendCommand(commandObjects.scriptExists(sampleKey, sha1));
1398    }
1399    @Override
1400    public Response<String> scriptLoad(String script, String sampleKey) {
1401      return appendCommand(commandObjects.scriptLoad(script, sampleKey));
1402    }
1403    @Override
1404    public Response<String> scriptFlush(String sampleKey) {
1405      return appendCommand(commandObjects.scriptFlush(sampleKey));
1406    }
1407    @Override
1408    public Response<String> scriptFlush(String sampleKey, FlushMode flushMode) {
1409      return appendCommand(commandObjects.scriptFlush(sampleKey, flushMode));
1410    }
1411    @Override
1412    public Response<String> scriptKill(String sampleKey) {
1413      return appendCommand(commandObjects.scriptKill(sampleKey));
1414    }
1415    @Override
1416    public Response<Object> fcall(byte[] name, List<byte[]> keys, List<byte[]> args) {
1417      return appendCommand(commandObjects.fcall(name, keys, args));
1418    }
1419    @Override
1420    public Response<Object> fcall(String name, List<String> keys, List<String> args) {
1421      return appendCommand(commandObjects.fcall(name, keys, args));
1422    }
1423    @Override
1424    public Response<Object> fcallReadonly(byte[] name, List<byte[]> keys, List<byte[]> args) {
1425      return appendCommand(commandObjects.fcallReadonly(name, keys, args));
1426    }
1427    @Override
1428    public Response<Object> fcallReadonly(String name, List<String> keys, List<String> args) {
1429      return appendCommand(commandObjects.fcallReadonly(name, keys, args));
1430    }
1431    @Override
1432    public Response<String> functionDelete(byte[] libraryName) {
1433      return appendCommand(commandObjects.functionDelete(libraryName));
1434    }
1435    @Override
1436    public Response<String> functionDelete(String libraryName) {
1437      return appendCommand(commandObjects.functionDelete(libraryName));
1438    }
1439    @Override
1440    public Response<byte[]> functionDump() {
1441      return appendCommand(commandObjects.functionDump());
1442    }
1443    @Override
1444    public Response<List<LibraryInfo>> functionList(String libraryNamePattern) {
1445      return appendCommand(commandObjects.functionList(libraryNamePattern));
1446    }
1447    @Override
1448    public Response<List<LibraryInfo>> functionList() {
1449      return appendCommand(commandObjects.functionList());
1450    }
1451    @Override
1452    public Response<List<LibraryInfo>> functionListWithCode(String libraryNamePattern) {
1453      return appendCommand(commandObjects.functionListWithCode(libraryNamePattern));
1454    }
1455    @Override
1456    public Response<List<LibraryInfo>> functionListWithCode() {
1457      return appendCommand(commandObjects.functionListWithCode());
1458    }
1459    @Override
1460    public Response<List<Object>> functionListBinary() {
1461      return appendCommand(commandObjects.functionListBinary());
1462    }
1463    @Override
1464    public Response<List<Object>> functionList(final byte[] libraryNamePattern) {
1465      return appendCommand(commandObjects.functionList(libraryNamePattern));
1466    }
1467    @Override
1468    public Response<List<Object>> functionListWithCodeBinary() {
1469      return appendCommand(commandObjects.functionListWithCodeBinary());
1470    }
1471    @Override
1472    public Response<List<Object>> functionListWithCode(final byte[] libraryNamePattern) {
1473      return appendCommand(commandObjects.functionListWithCode(libraryNamePattern));
1474    }
1475    @Override
1476    public Response<String> functionLoad(byte[] functionCode) {
1477      return appendCommand(commandObjects.functionLoad(functionCode));
1478    }
1479    @Override
1480    public Response<String> functionLoad(String functionCode) {
1481      return appendCommand(commandObjects.functionLoad(functionCode));
1482    }
1483    @Override
1484    public Response<String> functionLoadReplace(byte[] functionCode) {
1485      return appendCommand(commandObjects.functionLoadReplace(functionCode));
1486    }
1487    @Override
1488    public Response<String> functionLoadReplace(String functionCode) {
1489      return appendCommand(commandObjects.functionLoadReplace(functionCode));
1490    }
1491    @Override
1492    public Response<String> functionRestore(byte[] serializedValue) {
1493      return appendCommand(commandObjects.functionRestore(serializedValue));
1494    }
1495    @Override
1496    public Response<String> functionRestore(byte[] serializedValue, FunctionRestorePolicy policy) {
1497      return appendCommand(commandObjects.functionRestore(serializedValue, policy));
1498    }
1499    @Override
1500    public Response<String> functionFlush() {
1501      return appendCommand(commandObjects.functionFlush());
1502    }
1503    @Override
1504    public Response<String> functionFlush(FlushMode mode) {
1505      return appendCommand(commandObjects.functionFlush(mode));
1506    }
1507    @Override
1508    public Response<String> functionKill() {
1509      return appendCommand(commandObjects.functionKill());
1510    }
1511    @Override
1512    public Response<FunctionStats> functionStats() {
1513      return appendCommand(commandObjects.functionStats());
1514    }
1515    @Override
1516    public Response<Object> functionStatsBinary() {
1517      return appendCommand(commandObjects.functionStatsBinary());
1518    }
1519    public Response<Long> publish(String channel, String message) {
1520      return appendCommand(commandObjects.publish(channel, message));
1521    }
1522    @Override
1523    public Response<Long> geoadd(byte[] key, double longitude, double latitude, byte[] member) {
1524      return appendCommand(commandObjects.geoadd(key, longitude, latitude, member));
1525    }
1526    @Override
1527    public Response<Long> geoadd(byte[] key, Map<byte[], GeoCoordinate> memberCoordinateMap) {
1528      return appendCommand(commandObjects.geoadd(key, memberCoordinateMap));
1529    }
1530    @Override
1531    public Response<Long> geoadd(byte[] key, GeoAddParams params, Map<byte[], GeoCoordinate> memberCoordinateMap) {
1532      return appendCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
1533    }
1534    @Override
1535    public Response<Double> geodist(byte[] key, byte[] member1, byte[] member2) {
1536      return appendCommand(commandObjects.geodist(key, member1, member2));
1537    }
1538    @Override
1539    public Response<Double> geodist(byte[] key, byte[] member1, byte[] member2, GeoUnit unit) {
1540      return appendCommand(commandObjects.geodist(key, member1, member2, unit));
1541    }
1542    @Override
1543    public Response<List<byte[]>> geohash(byte[] key, byte[]... members) {
1544      return appendCommand(commandObjects.geohash(key, members));
1545    }
1546    @Override
1547    public Response<List<GeoCoordinate>> geopos(byte[] key, byte[]... members) {
1548      return appendCommand(commandObjects.geopos(key, members));
1549    }
1550    @Override
1551    public Response<List<GeoRadiusResponse>> georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
1552      return appendCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
1553    }
1554    @Override
1555    public Response<List<GeoRadiusResponse>> georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit) {
1556      return appendCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
1557    }
1558    @Override
1559    public Response<List<GeoRadiusResponse>> georadius(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
1560      return appendCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
1561    }
1562    @Override
1563    public Response<List<GeoRadiusResponse>> georadiusReadonly(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param) {
1564      return appendCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
1565    }
1566    @Override
1567    public Response<List<GeoRadiusResponse>> georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit) {
1568      return appendCommand(commandObjects.georadiusByMember(key, member, radius, unit));
1569    }
1570    @Override
1571    public Response<List<GeoRadiusResponse>> georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit) {
1572      return appendCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
1573    }
1574    @Override
1575    public Response<List<GeoRadiusResponse>> georadiusByMember(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
1576      return appendCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
1577    }
1578    @Override
1579    public Response<List<GeoRadiusResponse>> georadiusByMemberReadonly(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param) {
1580      return appendCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
1581    }
1582    @Override
1583    public Response<Long> georadiusStore(byte[] key, double longitude, double latitude, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
1584      return appendCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
1585    }
1586    @Override
1587    public Response<Long> georadiusByMemberStore(byte[] key, byte[] member, double radius, GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
1588      return appendCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
1589    }
1590    @Override
1591    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, byte[] member, double radius, GeoUnit unit) {
1592      return appendCommand(commandObjects.geosearch(key, member, radius, unit));
1593    }
1594    @Override
1595    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, GeoCoordinate coord, double radius, GeoUnit unit) {
1596      return appendCommand(commandObjects.geosearch(key, coord, radius, unit));
1597    }
1598    @Override
1599    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, byte[] member, double width, double height, GeoUnit unit) {
1600      return appendCommand(commandObjects.geosearch(key, member, width, height, unit));
1601    }
1602    @Override
1603    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
1604      return appendCommand(commandObjects.geosearch(key, coord, width, height, unit));
1605    }
1606    @Override
1607    public Response<List<GeoRadiusResponse>> geosearch(byte[] key, GeoSearchParam params) {
1608      return appendCommand(commandObjects.geosearch(key, params));
1609    }
1610    @Override
1611    public Response<Long> geosearchStore(byte[] dest, byte[] src, byte[] member, double radius, GeoUnit unit) {
1612      return appendCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
1613    }
1614    @Override
1615    public Response<Long> geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double radius, GeoUnit unit) {
1616      return appendCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
1617    }
1618    @Override
1619    public Response<Long> geosearchStore(byte[] dest, byte[] src, byte[] member, double width, double height, GeoUnit unit) {
1620      return appendCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
1621    }
1622    @Override
1623    public Response<Long> geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
1624      return appendCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
1625    }
1626    @Override
1627    public Response<Long> geosearchStore(byte[] dest, byte[] src, GeoSearchParam params) {
1628      return appendCommand(commandObjects.geosearchStore(dest, src, params));
1629    }
1630    @Override
1631    public Response<Long> geosearchStoreStoreDist(byte[] dest, byte[] src, GeoSearchParam params) {
1632      return appendCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
1633    }
1634    @Override
1635    public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
1636      return appendCommand(commandObjects.hset(key, field, value));
1637    }
1638    @Override
1639    public Response<Long> hset(byte[] key, Map<byte[], byte[]> hash) {
1640      return appendCommand(commandObjects.hset(key, hash));
1641    }
1642    @Override
1643    public Response<byte[]> hget(byte[] key, byte[] field) {
1644      return appendCommand(commandObjects.hget(key, field));
1645    }
1646    @Override
1647    public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
1648      return appendCommand(commandObjects.hsetnx(key, field, value));
1649    }
1650    @Override
1651    public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
1652      return appendCommand(commandObjects.hmset(key, hash));
1653    }
1654    @Override
1655    public Response<List<byte[]>> hmget(byte[] key, byte[]... fields) {
1656      return appendCommand(commandObjects.hmget(key, fields));
1657    }
1658    @Override
1659    public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
1660      return appendCommand(commandObjects.hincrBy(key, field, value));
1661    }
1662    @Override
1663    public Response<Double> hincrByFloat(byte[] key, byte[] field, double value) {
1664      return appendCommand(commandObjects.hincrByFloat(key, field, value));
1665    }
1666    @Override
1667    public Response<Boolean> hexists(byte[] key, byte[] field) {
1668      return appendCommand(commandObjects.hexists(key, field));
1669    }
1670    @Override
1671    public Response<Long> hdel(byte[] key, byte[]... field) {
1672      return appendCommand(commandObjects.hdel(key, field));
1673    }
1674    @Override
1675    public Response<Long> hlen(byte[] key) {
1676      return appendCommand(commandObjects.hlen(key));
1677    }
1678    @Override
1679    public Response<Set<byte[]>> hkeys(byte[] key) {
1680      return appendCommand(commandObjects.hkeys(key));
1681    }
1682    @Override
1683    public Response<List<byte[]>> hvals(byte[] key) {
1684      return appendCommand(commandObjects.hvals(key));
1685    }
1686    @Override
1687    public Response<Map<byte[], byte[]>> hgetAll(byte[] key) {
1688      return appendCommand(commandObjects.hgetAll(key));
1689    }
1690    @Override
1691    public Response<byte[]> hrandfield(byte[] key) {
1692      return appendCommand(commandObjects.hrandfield(key));
1693    }
1694    @Override
1695    public Response<List<byte[]>> hrandfield(byte[] key, long count) {
1696      return appendCommand(commandObjects.hrandfield(key, count));
1697    }
1698    @Override
1699    public Response<List<Map.Entry<byte[], byte[]>>> hrandfieldWithValues(byte[] key, long count) {
1700      return appendCommand(commandObjects.hrandfieldWithValues(key, count));
1701    }
1702    @Override
1703    public Response<ScanResult<Map.Entry<byte[], byte[]>>> hscan(byte[] key, byte[] cursor, ScanParams params) {
1704      return appendCommand(commandObjects.hscan(key, cursor, params));
1705    }
1706    @Override
1707    public Response<Long> hstrlen(byte[] key, byte[] field) {
1708      return appendCommand(commandObjects.hstrlen(key, field));
1709    }
1710    @Override
1711    public Response<Long> pfadd(byte[] key, byte[]... elements) {
1712      return appendCommand(commandObjects.pfadd(key, elements));
1713    }
1714    @Override
1715    public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
1716      return appendCommand(commandObjects.pfmerge(destkey, sourcekeys));
1717    }
1718    @Override
1719    public Response<Long> pfcount(byte[] key) {
1720      return appendCommand(commandObjects.pfcount(key));
1721    }
1722    @Override
1723    public Response<Long> pfcount(byte[]... keys) {
1724      return appendCommand(commandObjects.pfcount(keys));
1725    }
1726    @Override
1727    public Response<Boolean> exists(byte[] key) {
1728      return appendCommand(commandObjects.exists(key));
1729    }
1730    @Override
1731    public Response<Long> exists(byte[]... keys) {
1732      return appendCommand(commandObjects.exists(keys));
1733    }
1734    @Override
1735    public Response<Long> persist(byte[] key) {
1736      return appendCommand(commandObjects.persist(key));
1737    }
1738    @Override
1739    public Response<String> type(byte[] key) {
1740      return appendCommand(commandObjects.type(key));
1741    }
1742    @Override
1743    public Response<byte[]> dump(byte[] key) {
1744      return appendCommand(commandObjects.dump(key));
1745    }
1746    @Override
1747    public Response<String> restore(byte[] key, long ttl, byte[] serializedValue) {
1748      return appendCommand(commandObjects.restore(key, ttl, serializedValue));
1749    }
1750    @Override
1751    public Response<String> restore(byte[] key, long ttl, byte[] serializedValue, RestoreParams params) {
1752      return appendCommand(commandObjects.restore(key, ttl, serializedValue, params));
1753    }
1754    @Override
1755    public Response<Long> expire(byte[] key, long seconds) {
1756      return appendCommand(commandObjects.expire(key, seconds));
1757    }
1758    @Override
1759    public Response<Long> expire(byte[] key, long seconds, ExpiryOption expiryOption) {
1760      return appendCommand(commandObjects.expire(key, seconds, expiryOption));
1761    }
1762    @Override
1763    public Response<Long> pexpire(byte[] key, long milliseconds) {
1764      return appendCommand(commandObjects.pexpire(key, milliseconds));
1765    }
1766    @Override
1767    public Response<Long> pexpire(byte[] key, long milliseconds, ExpiryOption expiryOption) {
1768      return appendCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
1769    }
1770    @Override
1771    public Response<Long> expireTime(byte[] key) {
1772      return appendCommand(commandObjects.expireTime(key));
1773    }
1774    @Override
1775    public Response<Long> pexpireTime(byte[] key) {
1776      return appendCommand(commandObjects.pexpireTime(key));
1777    }
1778    @Override
1779    public Response<Long> expireAt(byte[] key, long unixTime) {
1780      return appendCommand(commandObjects.expireAt(key, unixTime));
1781    }
1782    @Override
1783    public Response<Long> expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {
1784      return appendCommand(commandObjects.expireAt(key, unixTime, expiryOption));
1785    }
1786    @Override
1787    public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp) {
1788      return appendCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
1789    }
1790    @Override
1791    public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp, ExpiryOption expiryOption) {
1792      return appendCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
1793    }
1794    @Override
1795    public Response<Long> ttl(byte[] key) {
1796      return appendCommand(commandObjects.ttl(key));
1797    }
1798    @Override
1799    public Response<Long> pttl(byte[] key) {
1800      return appendCommand(commandObjects.pttl(key));
1801    }
1802    @Override
1803    public Response<Long> touch(byte[] key) {
1804      return appendCommand(commandObjects.touch(key));
1805    }
1806    @Override
1807    public Response<Long> touch(byte[]... keys) {
1808      return appendCommand(commandObjects.touch(keys));
1809    }
1810    @Override
1811    public Response<List<byte[]>> sort(byte[] key) {
1812      return appendCommand(commandObjects.sort(key));
1813    }
1814    @Override
1815    public Response<List<byte[]>> sort(byte[] key, SortingParams sortingParams) {
1816      return appendCommand(commandObjects.sort(key, sortingParams));
1817    }
1818    @Override
1819    public Response<List<byte[]>> sortReadonly(byte[] key, SortingParams sortingParams) {
1820      return appendCommand(commandObjects.sortReadonly(key, sortingParams));
1821    }
1822    @Override
1823    public Response<Long> del(byte[] key) {
1824      return appendCommand(commandObjects.del(key));
1825    }
1826    @Override
1827    public Response<Long> del(byte[]... keys) {
1828      return appendCommand(commandObjects.del(keys));
1829    }
1830    @Override
1831    public Response<Long> unlink(byte[] key) {
1832      return appendCommand(commandObjects.unlink(key));
1833    }
1834    @Override
1835    public Response<Long> unlink(byte[]... keys) {
1836      return appendCommand(commandObjects.unlink(keys));
1837    }
1838    @Override
1839    public Response<Boolean> copy(byte[] srcKey, byte[] dstKey, boolean replace) {
1840      return appendCommand(commandObjects.copy(srcKey, dstKey, replace));
1841    }
1842    @Override
1843    public Response<String> rename(byte[] oldkey, byte[] newkey) {
1844      return appendCommand(commandObjects.rename(oldkey, newkey));
1845    }
1846    @Override
1847    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
1848      return appendCommand(commandObjects.renamenx(oldkey, newkey));
1849    }
1850    @Override
1851    public Response<Long> sort(byte[] key, SortingParams sortingParams, byte[] dstkey) {
1852      return appendCommand(commandObjects.sort(key, sortingParams, dstkey));
1853    }
1854    @Override
1855    public Response<Long> sort(byte[] key, byte[] dstkey) {
1856      return appendCommand(commandObjects.sort(key, dstkey));
1857    }
1858    @Override
1859    public Response<Long> memoryUsage(byte[] key) {
1860      return appendCommand(commandObjects.memoryUsage(key));
1861    }
1862    @Override
1863    public Response<Long> memoryUsage(byte[] key, int samples) {
1864      return appendCommand(commandObjects.memoryUsage(key, samples));
1865    }
1866    @Override
1867    public Response<Long> objectRefcount(byte[] key) {
1868      return appendCommand(commandObjects.objectRefcount(key));
1869    }
1870    @Override
1871    public Response<byte[]> objectEncoding(byte[] key) {
1872      return appendCommand(commandObjects.objectEncoding(key));
1873    }
1874    @Override
1875    public Response<Long> objectIdletime(byte[] key) {
1876      return appendCommand(commandObjects.objectIdletime(key));
1877    }
1878    @Override
1879    public Response<Long> objectFreq(byte[] key) {
1880      return appendCommand(commandObjects.objectFreq(key));
1881    }
1882    @Override
1883    public Response<String> migrate(String host, int port, byte[] key, int timeout) {
1884      return appendCommand(commandObjects.migrate(host, port, key, timeout));
1885    }
1886    @Override
1887    public Response<String> migrate(String host, int port, int timeout, MigrateParams params, byte[]... keys) {
1888      return appendCommand(commandObjects.migrate(host, port, timeout, params, keys));
1889    }
1890    @Override
1891    public Response<Set<byte[]>> keys(byte[] pattern) {
1892      return appendCommand(commandObjects.keys(pattern));
1893    }
1894    @Override
1895    public Response<ScanResult<byte[]>> scan(byte[] cursor) {
1896      return appendCommand(commandObjects.scan(cursor));
1897    }
1898    @Override
1899    public Response<ScanResult<byte[]>> scan(byte[] cursor, ScanParams params) {
1900      return appendCommand(commandObjects.scan(cursor, params));
1901    }
1902    @Override
1903    public Response<ScanResult<byte[]>> scan(byte[] cursor, ScanParams params, byte[] type) {
1904      return appendCommand(commandObjects.scan(cursor, params, type));
1905    }
1906    @Override
1907    public Response<byte[]> randomBinaryKey() {
1908      return appendCommand(commandObjects.randomBinaryKey());
1909    }
1910    @Override
1911    public Response<Long> rpush(byte[] key, byte[]... args) {
1912      return appendCommand(commandObjects.rpush(key, args));
1913    }
1914    @Override
1915    public Response<Long> lpush(byte[] key, byte[]... args) {
1916      return appendCommand(commandObjects.lpush(key, args));
1917    }
1918    @Override
1919    public Response<Long> llen(byte[] key) {
1920      return appendCommand(commandObjects.llen(key));
1921    }
1922    @Override
1923    public Response<List<byte[]>> lrange(byte[] key, long start, long stop) {
1924      return appendCommand(commandObjects.lrange(key, start, stop));
1925    }
1926    @Override
1927    public Response<String> ltrim(byte[] key, long start, long stop) {
1928      return appendCommand(commandObjects.ltrim(key, start, stop));
1929    }
1930    @Override
1931    public Response<byte[]> lindex(byte[] key, long index) {
1932      return appendCommand(commandObjects.lindex(key, index));
1933    }
1934    @Override
1935    public Response<String> lset(byte[] key, long index, byte[] value) {
1936      return appendCommand(commandObjects.lset(key, index, value));
1937    }
1938    @Override
1939    public Response<Long> lrem(byte[] key, long count, byte[] value) {
1940      return appendCommand(commandObjects.lrem(key, count, value));
1941    }
1942    @Override
1943    public Response<byte[]> lpop(byte[] key) {
1944      return appendCommand(commandObjects.lpop(key));
1945    }
1946    @Override
1947    public Response<List<byte[]>> lpop(byte[] key, int count) {
1948      return appendCommand(commandObjects.lpop(key, count));
1949    }
1950    @Override
1951    public Response<Long> lpos(byte[] key, byte[] element) {
1952      return appendCommand(commandObjects.lpos(key, element));
1953    }
1954    @Override
1955    public Response<Long> lpos(byte[] key, byte[] element, LPosParams params) {
1956      return appendCommand(commandObjects.lpos(key, element, params));
1957    }
1958    @Override
1959    public Response<List<Long>> lpos(byte[] key, byte[] element, LPosParams params, long count) {
1960      return appendCommand(commandObjects.lpos(key, element, params, count));
1961    }
1962    @Override
1963    public Response<byte[]> rpop(byte[] key) {
1964      return appendCommand(commandObjects.rpop(key));
1965    }
1966    @Override
1967    public Response<List<byte[]>> rpop(byte[] key, int count) {
1968      return appendCommand(commandObjects.rpop(key, count));
1969    }
1970    @Override
1971    public Response<Long> linsert(byte[] key, ListPosition where, byte[] pivot, byte[] value) {
1972      return appendCommand(commandObjects.linsert(key, where, pivot, value));
1973    }
1974    @Override
1975    public Response<Long> lpushx(byte[] key, byte[]... args) {
1976      return appendCommand(commandObjects.lpushx(key, args));
1977    }
1978    @Override
1979    public Response<Long> rpushx(byte[] key, byte[]... args) {
1980      return appendCommand(commandObjects.rpushx(key, args));
1981    }
1982    @Override
1983    public Response<List<byte[]>> blpop(int timeout, byte[]... keys) {
1984      return appendCommand(commandObjects.blpop(timeout, keys));
1985    }
1986    @Override
1987    public Response<KeyValue<byte[], byte[]>> blpop(double timeout, byte[]... keys) {
1988      return appendCommand(commandObjects.blpop(timeout, keys));
1989    }
1990    @Override
1991    public Response<List<byte[]>> brpop(int timeout, byte[]... keys) {
1992      return appendCommand(commandObjects.brpop(timeout, keys));
1993    }
1994    @Override
1995    public Response<KeyValue<byte[], byte[]>> brpop(double timeout, byte[]... keys) {
1996      return appendCommand(commandObjects.brpop(timeout, keys));
1997    }
1998    @Override
1999    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
2000      return appendCommand(commandObjects.rpoplpush(srckey, dstkey));
2001    }
2002    @Override
2003    public Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout) {
2004      return appendCommand(commandObjects.brpoplpush(source, destination, timeout));
2005    }
2006    @Override
2007    public Response<byte[]> lmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to) {
2008      return appendCommand(commandObjects.lmove(srcKey, dstKey, from, to));
2009    }
2010    @Override
2011    public Response<byte[]> blmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to, double timeout) {
2012      return appendCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
2013    }
2014    @Override
2015    public Response<KeyValue<byte[], List<byte[]>>> lmpop(ListDirection direction, byte[]... keys) {
2016      return appendCommand(commandObjects.lmpop(direction, keys));
2017    }
2018    @Override
2019    public Response<KeyValue<byte[], List<byte[]>>> lmpop(ListDirection direction, int count, byte[]... keys) {
2020      return appendCommand(commandObjects.lmpop(direction, count, keys));
2021    }
2022    @Override
2023    public Response<KeyValue<byte[], List<byte[]>>> blmpop(double timeout, ListDirection direction, byte[]... keys) {
2024      return appendCommand(commandObjects.blmpop(timeout, direction, keys));
2025    }
2026    @Override
2027    public Response<KeyValue<byte[], List<byte[]>>> blmpop(double timeout, ListDirection direction, int count, byte[]... keys) {
2028      return appendCommand(commandObjects.blmpop(timeout, direction, count, keys));
2029    }
2030    public Response<Long> publish(byte[] channel, byte[] message) {
2031      return appendCommand(commandObjects.publish(channel, message));
2032    }
2033    @Override
2034    public Response<Long> waitReplicas(byte[] sampleKey, int replicas, long timeout) {
2035      return appendCommand(commandObjects.waitReplicas(sampleKey, replicas, timeout));
2036    }
2037    @Override
2038    public Response<KeyValue<Long, Long>> waitAOF(byte[] sampleKey, long numLocal, long numReplicas, long timeout) {
2039      return appendCommand(commandObjects.waitAOF(sampleKey, numLocal, numReplicas, timeout));
2040    }
2041    @Override
2042    public Response<Object> eval(byte[] script, byte[] sampleKey) {
2043      return appendCommand(commandObjects.eval(script, sampleKey));
2044    }
2045    @Override
2046    public Response<Object> evalsha(byte[] sha1, byte[] sampleKey) {
2047      return appendCommand(commandObjects.evalsha(sha1, sampleKey));
2048    }
2049    @Override
2050    public Response<List<Boolean>> scriptExists(byte[] sampleKey, byte[]... sha1s) {
2051      return appendCommand(commandObjects.scriptExists(sampleKey, sha1s));
2052    }
2053    @Override
2054    public Response<byte[]> scriptLoad(byte[] script, byte[] sampleKey) {
2055      return appendCommand(commandObjects.scriptLoad(script, sampleKey));
2056    }
2057    @Override
2058    public Response<String> scriptFlush(byte[] sampleKey) {
2059      return appendCommand(commandObjects.scriptFlush(sampleKey));
2060    }
2061    @Override
2062    public Response<String> scriptFlush(byte[] sampleKey, FlushMode flushMode) {
2063      return appendCommand(commandObjects.scriptFlush(sampleKey, flushMode));
2064    }
2065    @Override
2066    public Response<String> scriptKill(byte[] sampleKey) {
2067      return appendCommand(commandObjects.scriptKill(sampleKey));
2068    }
2069    @Override
2070    public Response<Object> eval(byte[] script) {
2071      return appendCommand(commandObjects.eval(script));
2072    }
2073    @Override
2074    public Response<Object> eval(byte[] script, int keyCount, byte[]... params) {
2075      return appendCommand(commandObjects.eval(script, keyCount, params));
2076    }
2077    @Override
2078    public Response<Object> eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
2079      return appendCommand(commandObjects.eval(script, keys, args));
2080    }
2081    @Override
2082    public Response<Object> evalReadonly(byte[] script, List<byte[]> keys, List<byte[]> args) {
2083      return appendCommand(commandObjects.evalReadonly(script, keys, args));
2084    }
2085    @Override
2086    public Response<Object> evalsha(byte[] sha1) {
2087      return appendCommand(commandObjects.evalsha(sha1));
2088    }
2089    @Override
2090    public Response<Object> evalsha(byte[] sha1, int keyCount, byte[]... params) {
2091      return appendCommand(commandObjects.evalsha(sha1, keyCount, params));
2092    }
2093    @Override
2094    public Response<Object> evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
2095      return appendCommand(commandObjects.evalsha(sha1, keys, args));
2096    }
2097    @Override
2098    public Response<Object> evalshaReadonly(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
2099      return appendCommand(commandObjects.evalshaReadonly(sha1, keys, args));
2100    }
2101    @Override
2102    public Response<Long> sadd(byte[] key, byte[]... members) {
2103      return appendCommand(commandObjects.sadd(key, members));
2104    }
2105    @Override
2106    public Response<Set<byte[]>> smembers(byte[] key) {
2107      return appendCommand(commandObjects.smembers(key));
2108    }
2109    @Override
2110    public Response<Long> srem(byte[] key, byte[]... members) {
2111      return appendCommand(commandObjects.srem(key, members));
2112    }
2113    @Override
2114    public Response<byte[]> spop(byte[] key) {
2115      return appendCommand(commandObjects.spop(key));
2116    }
2117    @Override
2118    public Response<Set<byte[]>> spop(byte[] key, long count) {
2119      return appendCommand(commandObjects.spop(key, count));
2120    }
2121    @Override
2122    public Response<Long> scard(byte[] key) {
2123      return appendCommand(commandObjects.scard(key));
2124    }
2125    @Override
2126    public Response<Boolean> sismember(byte[] key, byte[] member) {
2127      return appendCommand(commandObjects.sismember(key, member));
2128    }
2129    @Override
2130    public Response<List<Boolean>> smismember(byte[] key, byte[]... members) {
2131      return appendCommand(commandObjects.smismember(key, members));
2132    }
2133    @Override
2134    public Response<byte[]> srandmember(byte[] key) {
2135      return appendCommand(commandObjects.srandmember(key));
2136    }
2137    @Override
2138    public Response<List<byte[]>> srandmember(byte[] key, int count) {
2139      return appendCommand(commandObjects.srandmember(key, count));
2140    }
2141    @Override
2142    public Response<ScanResult<byte[]>> sscan(byte[] key, byte[] cursor, ScanParams params) {
2143      return appendCommand(commandObjects.sscan(key, cursor, params));
2144    }
2145    @Override
2146    public Response<Set<byte[]>> sdiff(byte[]... keys) {
2147      return appendCommand(commandObjects.sdiff(keys));
2148    }
2149    @Override
2150    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
2151      return appendCommand(commandObjects.sdiffstore(dstkey, keys));
2152    }
2153    @Override
2154    public Response<Set<byte[]>> sinter(byte[]... keys) {
2155      return appendCommand(commandObjects.sinter(keys));
2156    }
2157    @Override
2158    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
2159      return appendCommand(commandObjects.sinterstore(dstkey, keys));
2160    }
2161    @Override
2162    public Response<Long> sintercard(byte[]... keys) {
2163      return appendCommand(commandObjects.sintercard(keys));
2164    }
2165    @Override
2166    public Response<Long> sintercard(int limit, byte[]... keys) {
2167      return appendCommand(commandObjects.sintercard(limit, keys));
2168    }
2169    @Override
2170    public Response<Set<byte[]>> sunion(byte[]... keys) {
2171      return appendCommand(commandObjects.sunion(keys));
2172    }
2173    @Override
2174    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
2175      return appendCommand(commandObjects.sunionstore(dstkey, keys));
2176    }
2177    @Override
2178    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
2179      return appendCommand(commandObjects.smove(srckey, dstkey, member));
2180    }
2181    @Override
2182    public Response<Long> zadd(byte[] key, double score, byte[] member) {
2183      return appendCommand(commandObjects.zadd(key, score, member));
2184    }
2185    @Override
2186    public Response<Long> zadd(byte[] key, double score, byte[] member, ZAddParams params) {
2187      return appendCommand(commandObjects.zadd(key, score, member, params));
2188    }
2189    @Override
2190    public Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers) {
2191      return appendCommand(commandObjects.zadd(key, scoreMembers));
2192    }
2193    @Override
2194    public Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params) {
2195      return appendCommand(commandObjects.zadd(key, scoreMembers, params));
2196    }
2197    @Override
2198    public Response<Double> zaddIncr(byte[] key, double score, byte[] member, ZAddParams params) {
2199      return appendCommand(commandObjects.zaddIncr(key, score, member, params));
2200    }
2201    @Override
2202    public Response<Long> zrem(byte[] key, byte[]... members) {
2203      return appendCommand(commandObjects.zrem(key, members));
2204    }
2205    @Override
2206    public Response<Double> zincrby(byte[] key, double increment, byte[] member) {
2207      return appendCommand(commandObjects.zincrby(key, increment, member));
2208    }
2209    @Override
2210    public Response<Double> zincrby(byte[] key, double increment, byte[] member, ZIncrByParams params) {
2211      return appendCommand(commandObjects.zincrby(key, increment, member, params));
2212    }
2213    @Override
2214    public Response<Long> zrank(byte[] key, byte[] member) {
2215      return appendCommand(commandObjects.zrank(key, member));
2216    }
2217    @Override
2218    public Response<Long> zrevrank(byte[] key, byte[] member) {
2219      return appendCommand(commandObjects.zrevrank(key, member));
2220    }
2221    @Override
2222    public Response<KeyValue<Long, Double>> zrankWithScore(byte[] key, byte[] member) {
2223      return appendCommand(commandObjects.zrankWithScore(key, member));
2224    }
2225    @Override
2226    public Response<KeyValue<Long, Double>> zrevrankWithScore(byte[] key, byte[] member) {
2227      return appendCommand(commandObjects.zrevrankWithScore(key, member));
2228    }
2229    @Override
2230    public Response<List<byte[]>> zrange(byte[] key, long start, long stop) {
2231      return appendCommand(commandObjects.zrange(key, start, stop));
2232    }
2233    @Override
2234    public Response<List<byte[]>> zrevrange(byte[] key, long start, long stop) {
2235      return appendCommand(commandObjects.zrevrange(key, start, stop));
2236    }
2237    @Override
2238    public Response<List<Tuple>> zrangeWithScores(byte[] key, long start, long stop) {
2239      return appendCommand(commandObjects.zrangeWithScores(key, start, stop));
2240    }
2241    @Override
2242    public Response<List<Tuple>> zrevrangeWithScores(byte[] key, long start, long stop) {
2243      return appendCommand(commandObjects.zrevrangeWithScores(key, start, stop));
2244    }
2245    @Override
2246    public Response<List<byte[]>> zrange(byte[] key, ZRangeParams zRangeParams) {
2247      return appendCommand(commandObjects.zrange(key, zRangeParams));
2248    }
2249    @Override
2250    public Response<List<Tuple>> zrangeWithScores(byte[] key, ZRangeParams zRangeParams) {
2251      return appendCommand(commandObjects.zrangeWithScores(key, zRangeParams));
2252    }
2253    @Override
2254    public Response<Long> zrangestore(byte[] dest, byte[] src, ZRangeParams zRangeParams) {
2255      return appendCommand(commandObjects.zrangestore(dest, src, zRangeParams));
2256    }
2257    @Override
2258    public Response<byte[]> zrandmember(byte[] key) {
2259      return appendCommand(commandObjects.zrandmember(key));
2260    }
2261    @Override
2262    public Response<List<byte[]>> zrandmember(byte[] key, long count) {
2263      return appendCommand(commandObjects.zrandmember(key, count));
2264    }
2265    @Override
2266    public Response<List<Tuple>> zrandmemberWithScores(byte[] key, long count) {
2267      return appendCommand(commandObjects.zrandmemberWithScores(key, count));
2268    }
2269    @Override
2270    public Response<Long> zcard(byte[] key) {
2271      return appendCommand(commandObjects.zcard(key));
2272    }
2273    @Override
2274    public Response<Double> zscore(byte[] key, byte[] member) {
2275      return appendCommand(commandObjects.zscore(key, member));
2276    }
2277    @Override
2278    public Response<List<Double>> zmscore(byte[] key, byte[]... members) {
2279      return appendCommand(commandObjects.zmscore(key, members));
2280    }
2281    @Override
2282    public Response<Tuple> zpopmax(byte[] key) {
2283      return appendCommand(commandObjects.zpopmax(key));
2284    }
2285    @Override
2286    public Response<List<Tuple>> zpopmax(byte[] key, int count) {
2287      return appendCommand(commandObjects.zpopmax(key, count));
2288    }
2289    @Override
2290    public Response<Tuple> zpopmin(byte[] key) {
2291      return appendCommand(commandObjects.zpopmin(key));
2292    }
2293    @Override
2294    public Response<List<Tuple>> zpopmin(byte[] key, int count) {
2295      return appendCommand(commandObjects.zpopmin(key, count));
2296    }
2297    @Override
2298    public Response<Long> zcount(byte[] key, double min, double max) {
2299      return appendCommand(commandObjects.zcount(key, min, max));
2300    }
2301    @Override
2302    public Response<Long> zcount(byte[] key, byte[] min, byte[] max) {
2303      return appendCommand(commandObjects.zcount(key, min, max));
2304    }
2305    @Override
2306    public Response<List<byte[]>> zrangeByScore(byte[] key, double min, double max) {
2307      return appendCommand(commandObjects.zrangeByScore(key, min, max));
2308    }
2309    @Override
2310    public Response<List<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max) {
2311      return appendCommand(commandObjects.zrangeByScore(key, min, max));
2312    }
2313    @Override
2314    public Response<List<byte[]>> zrevrangeByScore(byte[] key, double max, double min) {
2315      return appendCommand(commandObjects.zrevrangeByScore(key, max, min));
2316    }
2317    @Override
2318    public Response<List<byte[]>> zrangeByScore(byte[] key, double min, double max, int offset, int count) {
2319      return appendCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
2320    }
2321    @Override
2322    public Response<List<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
2323      return appendCommand(commandObjects.zrevrangeByScore(key, max, min));
2324    }
2325    @Override
2326    public Response<List<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count) {
2327      return appendCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
2328    }
2329    @Override
2330    public Response<List<byte[]>> zrevrangeByScore(byte[] key, double max, double min, int offset, int count) {
2331      return appendCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
2332    }
2333    @Override
2334    public Response<List<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max) {
2335      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
2336    }
2337    @Override
2338    public Response<List<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min) {
2339      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
2340    }
2341    @Override
2342    public Response<List<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count) {
2343      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
2344    }
2345    @Override
2346    public Response<List<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count) {
2347      return appendCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
2348    }
2349    @Override
2350    public Response<List<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max) {
2351      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
2352    }
2353    @Override
2354    public Response<List<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min) {
2355      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
2356    }
2357    @Override
2358    public Response<List<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count) {
2359      return appendCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
2360    }
2361    @Override
2362    public Response<List<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count) {
2363      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
2364    }
2365    @Override
2366    public Response<List<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count) {
2367      return appendCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
2368    }
2369    @Override
2370    public Response<Long> zremrangeByRank(byte[] key, long start, long stop) {
2371      return appendCommand(commandObjects.zremrangeByRank(key, start, stop));
2372    }
2373    @Override
2374    public Response<Long> zremrangeByScore(byte[] key, double min, double max) {
2375      return appendCommand(commandObjects.zremrangeByScore(key, min, max));
2376    }
2377    @Override
2378    public Response<Long> zremrangeByScore(byte[] key, byte[] min, byte[] max) {
2379      return appendCommand(commandObjects.zremrangeByScore(key, min, max));
2380    }
2381    @Override
2382    public Response<Long> zlexcount(byte[] key, byte[] min, byte[] max) {
2383      return appendCommand(commandObjects.zlexcount(key, min, max));
2384    }
2385    @Override
2386    public Response<List<byte[]>> zrangeByLex(byte[] key, byte[] min, byte[] max) {
2387      return appendCommand(commandObjects.zrangeByLex(key, min, max));
2388    }
2389    @Override
2390    public Response<List<byte[]>> zrangeByLex(byte[] key, byte[] min, byte[] max, int offset, int count) {
2391      return appendCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
2392    }
2393    @Override
2394    public Response<List<byte[]>> zrevrangeByLex(byte[] key, byte[] max, byte[] min) {
2395      return appendCommand(commandObjects.zrevrangeByLex(key, min, max));
2396    }
2397    @Override
2398    public Response<List<byte[]>> zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count) {
2399      return appendCommand(commandObjects.zrevrangeByLex(key, min, max, offset, count));
2400    }
2401    @Override
2402    public Response<Long> zremrangeByLex(byte[] key, byte[] min, byte[] max) {
2403      return appendCommand(commandObjects.zremrangeByLex(key, min, max));
2404    }
2405    @Override
2406    public Response<ScanResult<Tuple>> zscan(byte[] key, byte[] cursor, ScanParams params) {
2407      return appendCommand(commandObjects.zscan(key, cursor, params));
2408    }
2409    @Override
2410    public Response<KeyValue<byte[], Tuple>> bzpopmax(double timeout, byte[]... keys) {
2411      return appendCommand(commandObjects.bzpopmax(timeout, keys));
2412    }
2413    @Override
2414    public Response<KeyValue<byte[], Tuple>> bzpopmin(double timeout, byte[]... keys) {
2415      return appendCommand(commandObjects.bzpopmin(timeout, keys));
2416    }
2417    @Override
2418    public Response<KeyValue<byte[], List<Tuple>>> zmpop(SortedSetOption option, byte[]... keys) {
2419      return appendCommand(commandObjects.zmpop(option, keys));
2420    }
2421    @Override
2422    public Response<KeyValue<byte[], List<Tuple>>> zmpop(SortedSetOption option, int count, byte[]... keys) {
2423      return appendCommand(commandObjects.zmpop(option, count, keys));
2424    }
2425    @Override
2426    public Response<KeyValue<byte[], List<Tuple>>> bzmpop(double timeout, SortedSetOption option, byte[]... keys) {
2427      return appendCommand(commandObjects.bzmpop(timeout, option, keys));
2428    }
2429    @Override
2430    public Response<KeyValue<byte[], List<Tuple>>> bzmpop(double timeout, SortedSetOption option, int count, byte[]... keys) {
2431      return appendCommand(commandObjects.bzmpop(timeout, option, count, keys));
2432    }
2433    @Override
2434    public Response<List<byte[]>> zdiff(byte[]... keys) {
2435      return appendCommand(commandObjects.zdiff(keys));
2436    }
2437    @Override
2438    public Response<List<Tuple>> zdiffWithScores(byte[]... keys) {
2439      return appendCommand(commandObjects.zdiffWithScores(keys));
2440    }
2441    @Override
2442    @Deprecated
2443    public Response<Long> zdiffStore(byte[] dstkey, byte[]... keys) {
2444      return appendCommand(commandObjects.zdiffStore(dstkey, keys));
2445    }
2446    @Override
2447    public Response<Long> zdiffstore(byte[] dstkey, byte[]... keys) {
2448      return appendCommand(commandObjects.zdiffstore(dstkey, keys));
2449    }
2450    @Override
2451    public Response<List<byte[]>> zinter(ZParams params, byte[]... keys) {
2452      return appendCommand(commandObjects.zinter(params, keys));
2453    }
2454    @Override
2455    public Response<List<Tuple>> zinterWithScores(ZParams params, byte[]... keys) {
2456      return appendCommand(commandObjects.zinterWithScores(params, keys));
2457    }
2458    @Override
2459    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
2460      return appendCommand(commandObjects.zinterstore(dstkey, sets));
2461    }
2462    @Override
2463    public Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
2464      return appendCommand(commandObjects.zinterstore(dstkey, params, sets));
2465    }
2466    @Override
2467    public Response<Long> zintercard(byte[]... keys) {
2468      return appendCommand(commandObjects.zintercard(keys));
2469    }
2470    @Override
2471    public Response<Long> zintercard(long limit, byte[]... keys) {
2472      return appendCommand(commandObjects.zintercard(limit, keys));
2473    }
2474    @Override
2475    public Response<List<byte[]>> zunion(ZParams params, byte[]... keys) {
2476      return appendCommand(commandObjects.zunion(params, keys));
2477    }
2478    @Override
2479    public Response<List<Tuple>> zunionWithScores(ZParams params, byte[]... keys) {
2480      return appendCommand(commandObjects.zunionWithScores(params, keys));
2481    }
2482    @Override
2483    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
2484      return appendCommand(commandObjects.zunionstore(dstkey, sets));
2485    }
2486    @Override
2487    public Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
2488      return appendCommand(commandObjects.zunionstore(dstkey, params, sets));
2489    }
2490    @Override
2491    public Response<byte[]> xadd(byte[] key, XAddParams params, Map<byte[], byte[]> hash) {
2492      return appendCommand(commandObjects.xadd(key, params, hash));
2493    }
2494    @Override
2495    public Response<Long> xlen(byte[] key) {
2496      return appendCommand(commandObjects.xlen(key));
2497    }
2498    @Override
2499    public Response<List<byte[]>> xrange(byte[] key, byte[] start, byte[] end) {
2500      return appendCommand(commandObjects.xrange(key, start, end));
2501    }
2502    @Override
2503    public Response<List<byte[]>> xrange(byte[] key, byte[] start, byte[] end, int count) {
2504      return appendCommand(commandObjects.xrange(key, start, end, count));
2505    }
2506    @Override
2507    public Response<List<byte[]>> xrevrange(byte[] key, byte[] end, byte[] start) {
2508      return appendCommand(commandObjects.xrevrange(key, end, start));
2509    }
2510    @Override
2511    public Response<List<byte[]>> xrevrange(byte[] key, byte[] end, byte[] start, int count) {
2512      return appendCommand(commandObjects.xrevrange(key, end, start, count));
2513    }
2514    @Override
2515    public Response<Long> xack(byte[] key, byte[] group, byte[]... ids) {
2516      return appendCommand(commandObjects.xack(key, group, ids));
2517    }
2518    @Override
2519    public Response<String> xgroupCreate(byte[] key, byte[] groupName, byte[] id, boolean makeStream) {
2520      return appendCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
2521    }
2522    @Override
2523    public Response<String> xgroupSetID(byte[] key, byte[] groupName, byte[] id) {
2524      return appendCommand(commandObjects.xgroupSetID(key, groupName, id));
2525    }
2526    @Override
2527    public Response<Long> xgroupDestroy(byte[] key, byte[] groupName) {
2528      return appendCommand(commandObjects.xgroupDestroy(key, groupName));
2529    }
2530    @Override
2531    public Response<Boolean> xgroupCreateConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2532      return appendCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2533    }
2534    @Override
2535    public Response<Long> xgroupDelConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2536      return appendCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2537    }
2538    @Override
2539    public Response<Long> xdel(byte[] key, byte[]... ids) {
2540      return appendCommand(commandObjects.xdel(key, ids));
2541    }
2542    @Override
2543    public Response<Long> xtrim(byte[] key, long maxLen, boolean approximateLength) {
2544      return appendCommand(commandObjects.xtrim(key, maxLen, approximateLength));
2545    }
2546    @Override
2547    public Response<Long> xtrim(byte[] key, XTrimParams params) {
2548      return appendCommand(commandObjects.xtrim(key, params));
2549    }
2550    @Override
2551    public Response<Object> xpending(byte[] key, byte[] groupName) {
2552      return appendCommand(commandObjects.xpending(key, groupName));
2553    }
2554    @Override
2555    public Response<List<Object>> xpending(byte[] key, byte[] groupName, XPendingParams params) {
2556      return appendCommand(commandObjects.xpending(key, groupName, params));
2557    }
2558    @Override
2559    public Response<List<byte[]>> xclaim(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2560      return appendCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2561    }
2562    @Override
2563    public Response<List<byte[]>> xclaimJustId(byte[] key, byte[] group, byte[] consumerName, long minIdleTime, XClaimParams params, byte[]... ids) {
2564      return appendCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2565    }
2566    @Override
2567    public Response<List<Object>> xautoclaim(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2568      return appendCommand(commandObjects.xautoclaim(key, groupName, consumerName, minIdleTime, start, params));
2569    }
2570    @Override
2571    public Response<List<Object>> xautoclaimJustId(byte[] key, byte[] groupName, byte[] consumerName, long minIdleTime, byte[] start, XAutoClaimParams params) {
2572      return appendCommand(commandObjects.xautoclaimJustId(key, groupName, consumerName, minIdleTime, start, params));
2573    }
2574    @Override
2575    public Response<Object> xinfoStream(byte[] key) {
2576      return appendCommand(commandObjects.xinfoStream(key));
2577    }
2578    @Override
2579    public Response<Object> xinfoStreamFull(byte[] key) {
2580      return appendCommand(commandObjects.xinfoStreamFull(key));
2581    }
2582    @Override
2583    public Response<Object> xinfoStreamFull(byte[] key, int count) {
2584      return appendCommand(commandObjects.xinfoStreamFull(key, count));
2585    }
2586    @Override
2587    public Response<List<Object>> xinfoGroups(byte[] key) {
2588      return appendCommand(commandObjects.xinfoGroups(key));
2589    }
2590    @Override
2591    public Response<List<Object>> xinfoConsumers(byte[] key, byte[] group) {
2592      return appendCommand(commandObjects.xinfoConsumers(key, group));
2593    }
2594    @Override
2595    public Response<List<byte[]>> xread(XReadParams xReadParams, Map.Entry<byte[], byte[]>... streams) {
2596      return appendCommand(commandObjects.xread(xReadParams, streams));
2597    }
2598    @Override
2599    public Response<List<byte[]>> xreadGroup(byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {
2600      return appendCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2601    }
2602    @Override
2603    public Response<String> set(byte[] key, byte[] value) {
2604      return appendCommand(commandObjects.set(key, value));
2605    }
2606    @Override
2607    public Response<String> set(byte[] key, byte[] value, SetParams params) {
2608      return appendCommand(commandObjects.set(key, value, params));
2609    }
2610    @Override
2611    public Response<byte[]> get(byte[] key) {
2612      return appendCommand(commandObjects.get(key));
2613    }
2614    @Override
2615    public Response<byte[]> setGet(byte[] key, byte[] value, SetParams params) {
2616      return appendCommand(commandObjects.setGet(key, value, params));
2617    }
2618    @Override
2619    public Response<byte[]> getDel(byte[] key) {
2620      return appendCommand(commandObjects.getDel(key));
2621    }
2622    @Override
2623    public Response<byte[]> getEx(byte[] key, GetExParams params) {
2624      return appendCommand(commandObjects.getEx(key, params));
2625    }
2626    @Override
2627    public Response<Boolean> setbit(byte[] key, long offset, boolean value) {
2628      return appendCommand(commandObjects.setbit(key, offset, value));
2629    }
2630    @Override
2631    public Response<Boolean> getbit(byte[] key, long offset) {
2632      return appendCommand(commandObjects.getbit(key, offset));
2633    }
2634    @Override
2635    public Response<Long> setrange(byte[] key, long offset, byte[] value) {
2636      return appendCommand(commandObjects.setrange(key, offset, value));
2637    }
2638    @Override
2639    public Response<byte[]> getrange(byte[] key, long startOffset, long endOffset) {
2640      return appendCommand(commandObjects.getrange(key, startOffset, endOffset));
2641    }
2642    @Override
2643    public Response<byte[]> getSet(byte[] key, byte[] value) {
2644      return appendCommand(commandObjects.getSet(key, value));
2645    }
2646    @Override
2647    public Response<Long> setnx(byte[] key, byte[] value) {
2648      return appendCommand(commandObjects.setnx(key, value));
2649    }
2650    @Override
2651    public Response<String> setex(byte[] key, long seconds, byte[] value) {
2652      return appendCommand(commandObjects.setex(key, seconds, value));
2653    }
2654    @Override
2655    public Response<String> psetex(byte[] key, long milliseconds, byte[] value) {
2656      return appendCommand(commandObjects.psetex(key, milliseconds, value));
2657    }
2658    @Override
2659    public Response<List<byte[]>> mget(byte[]... keys) {
2660      return appendCommand(commandObjects.mget(keys));
2661    }
2662    @Override
2663    public Response<String> mset(byte[]... keysvalues) {
2664      return appendCommand(commandObjects.mset(keysvalues));
2665    }
2666    @Override
2667    public Response<Long> msetnx(byte[]... keysvalues) {
2668      return appendCommand(commandObjects.msetnx(keysvalues));
2669    }
2670    @Override
2671    public Response<Long> incr(byte[] key) {
2672      return appendCommand(commandObjects.incr(key));
2673    }
2674    @Override
2675    public Response<Long> incrBy(byte[] key, long increment) {
2676      return appendCommand(commandObjects.incrBy(key, increment));
2677    }
2678    @Override
2679    public Response<Double> incrByFloat(byte[] key, double increment) {
2680      return appendCommand(commandObjects.incrByFloat(key, increment));
2681    }
2682    @Override
2683    public Response<Long> decr(byte[] key) {
2684      return appendCommand(commandObjects.decr(key));
2685    }
2686    @Override
2687    public Response<Long> decrBy(byte[] key, long decrement) {
2688      return appendCommand(commandObjects.decrBy(key, decrement));
2689    }
2690    @Override
2691    public Response<Long> append(byte[] key, byte[] value) {
2692      return appendCommand(commandObjects.append(key, value));
2693    }
2694    @Override
2695    public Response<byte[]> substr(byte[] key, int start, int end) {
2696      return appendCommand(commandObjects.substr(key, start, end));
2697    }
2698    @Override
2699    public Response<Long> strlen(byte[] key) {
2700      return appendCommand(commandObjects.strlen(key));
2701    }
2702    @Override
2703    public Response<Long> bitcount(byte[] key) {
2704      return appendCommand(commandObjects.bitcount(key));
2705    }
2706    @Override
2707    public Response<Long> bitcount(byte[] key, long start, long end) {
2708      return appendCommand(commandObjects.bitcount(key, start, end));
2709    }
2710    @Override
2711    public Response<Long> bitcount(byte[] key, long start, long end, BitCountOption option) {
2712      return appendCommand(commandObjects.bitcount(key, start, end, option));
2713    }
2714    @Override
2715    public Response<Long> bitpos(byte[] key, boolean value) {
2716      return appendCommand(commandObjects.bitpos(key, value));
2717    }
2718    @Override
2719    public Response<Long> bitpos(byte[] key, boolean value, BitPosParams params) {
2720      return appendCommand(commandObjects.bitpos(key, value, params));
2721    }
2722    @Override
2723    public Response<List<Long>> bitfield(byte[] key, byte[]... arguments) {
2724      return appendCommand(commandObjects.bitfield(key, arguments));
2725    }
2726    @Override
2727    public Response<List<Long>> bitfieldReadonly(byte[] key, byte[]... arguments) {
2728      return appendCommand(commandObjects.bitfieldReadonly(key, arguments));
2729    }
2730    @Override
2731    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
2732      return appendCommand(commandObjects.bitop(op, destKey, srcKeys));
2733    }
2734    @Override
2735    public Response<String> ftCreate(String indexName, IndexOptions indexOptions, Schema schema) {
2736      return appendCommand(commandObjects.ftCreate(indexName, indexOptions, schema));
2737    }
2738    @Override
2739    public Response<String> ftCreate(String indexName, FTCreateParams createParams, Iterable<SchemaField> schemaFields) {
2740      return appendCommand(commandObjects.ftCreate(indexName, createParams, schemaFields));
2741    }
2742    @Override
2743    public Response<String> ftAlter(String indexName, Schema schema) {
2744      return appendCommand(commandObjects.ftAlter(indexName, schema));
2745    }
2746    @Override
2747    public Response<String> ftAlter(String indexName, Iterable<SchemaField> schemaFields) {
2748      return appendCommand(commandObjects.ftAlter(indexName, schemaFields));
2749    }
2750    @Override
2751    public Response<SearchResult> ftSearch(String indexName, String query) {
2752      return appendCommand(commandObjects.ftSearch(indexName, query));
2753    }
2754    @Override
2755    public Response<SearchResult> ftSearch(String indexName, String query, FTSearchParams searchParams) {
2756      return appendCommand(commandObjects.ftSearch(indexName, query, searchParams));
2757    }
2758    @Override
2759    public Response<SearchResult> ftSearch(String indexName, Query query) {
2760      return appendCommand(commandObjects.ftSearch(indexName, query));
2761    }
2762    @Override
2763    public Response<SearchResult> ftSearch(byte[] indexName, Query query) {
2764      return appendCommand(commandObjects.ftSearch(indexName, query));
2765    }
2766    @Override
2767    public Response<String> ftExplain(String indexName, Query query) {
2768      return appendCommand(commandObjects.ftExplain(indexName, query));
2769    }
2770    @Override
2771    public Response<List<String>> ftExplainCLI(String indexName, Query query) {
2772      return appendCommand(commandObjects.ftExplainCLI(indexName, query));
2773    }
2774    @Override
2775    public Response<AggregationResult> ftAggregate(String indexName, AggregationBuilder aggr) {
2776      return appendCommand(commandObjects.ftAggregate(indexName, aggr));
2777    }
2778    @Override
2779    public Response<String> ftSynUpdate(String indexName, String synonymGroupId, String... terms) {
2780      return appendCommand(commandObjects.ftSynUpdate(indexName, synonymGroupId, terms));
2781    }
2782    @Override
2783    public Response<Map<String, List<String>>> ftSynDump(String indexName) {
2784      return appendCommand(commandObjects.ftSynDump(indexName));
2785    }
2786    @Override
2787    public Response<Long> ftDictAdd(String dictionary, String... terms) {
2788      return appendCommand(commandObjects.ftDictAdd(dictionary, terms));
2789    }
2790    @Override
2791    public Response<Long> ftDictDel(String dictionary, String... terms) {
2792      return appendCommand(commandObjects.ftDictDel(dictionary, terms));
2793    }
2794    @Override
2795    public Response<Set<String>> ftDictDump(String dictionary) {
2796      return appendCommand(commandObjects.ftDictDump(dictionary));
2797    }
2798    @Override
2799    public Response<Long> ftDictAddBySampleKey(String indexName, String dictionary, String... terms) {
2800      return appendCommand(commandObjects.ftDictAddBySampleKey(indexName, dictionary, terms));
2801    }
2802    @Override
2803    public Response<Long> ftDictDelBySampleKey(String indexName, String dictionary, String... terms) {
2804      return appendCommand(commandObjects.ftDictDelBySampleKey(indexName, dictionary, terms));
2805    }
2806    @Override
2807    public Response<Set<String>> ftDictDumpBySampleKey(String indexName, String dictionary) {
2808      return appendCommand(commandObjects.ftDictDumpBySampleKey(indexName, dictionary));
2809    }
2810    @Override
2811    public Response<Map<String, Map<String, Double>>> ftSpellCheck(String index, String query) {
2812      return appendCommand(commandObjects.ftSpellCheck(index, query));
2813    }
2814    @Override
2815    public Response<Map<String, Map<String, Double>>> ftSpellCheck(String index, String query, FTSpellCheckParams spellCheckParams) {
2816      return appendCommand(commandObjects.ftSpellCheck(index, query, spellCheckParams));
2817    }
2818    @Override
2819    public Response<Map<String, Object>> ftInfo(String indexName) {
2820      return appendCommand(commandObjects.ftInfo(indexName));
2821    }
2822    @Override
2823    public Response<Set<String>> ftTagVals(String indexName, String fieldName) {
2824      return appendCommand(commandObjects.ftTagVals(indexName, fieldName));
2825    }
2826    @Override
2827    public Response<Map<String, String>> ftConfigGet(String option) {
2828      return appendCommand(commandObjects.ftConfigGet(option));
2829    }
2830    @Override
2831    public Response<Map<String, String>> ftConfigGet(String indexName, String option) {
2832      return appendCommand(commandObjects.ftConfigGet(indexName, option));
2833    }
2834    @Override
2835    public Response<String> ftConfigSet(String option, String value) {
2836      return appendCommand(commandObjects.ftConfigSet(option, value));
2837    }
2838    @Override
2839    public Response<String> ftConfigSet(String indexName, String option, String value) {
2840      return appendCommand(commandObjects.ftConfigSet(indexName, option, value));
2841    }
2842    @Override
2843    public Response<Long> ftSugAdd(String key, String string, double score) {
2844      return appendCommand(commandObjects.ftSugAdd(key, string, score));
2845    }
2846    @Override
2847    public Response<Long> ftSugAddIncr(String key, String string, double score) {
2848      return appendCommand(commandObjects.ftSugAddIncr(key, string, score));
2849    }
2850    @Override
2851    public Response<List<String>> ftSugGet(String key, String prefix) {
2852      return appendCommand(commandObjects.ftSugGet(key, prefix));
2853    }
2854    @Override
2855    public Response<List<String>> ftSugGet(String key, String prefix, boolean fuzzy, int max) {
2856      return appendCommand(commandObjects.ftSugGet(key, prefix, fuzzy, max));
2857    }
2858    @Override
2859    public Response<List<Tuple>> ftSugGetWithScores(String key, String prefix) {
2860      return appendCommand(commandObjects.ftSugGetWithScores(key, prefix));
2861    }
2862    @Override
2863    public Response<List<Tuple>> ftSugGetWithScores(String key, String prefix, boolean fuzzy, int max) {
2864      return appendCommand(commandObjects.ftSugGetWithScores(key, prefix, fuzzy, max));
2865    }
2866    @Override
2867    public Response<Boolean> ftSugDel(String key, String string) {
2868      return appendCommand(commandObjects.ftSugDel(key, string));
2869    }
2870    @Override
2871    public Response<Long> ftSugLen(String key) {
2872      return appendCommand(commandObjects.ftSugLen(key));
2873    }
2874    @Override
2875    public Response<LCSMatchResult> lcs(byte[] keyA, byte[] keyB, LCSParams params) {
2876      return appendCommand(commandObjects.lcs(keyA, keyB, params));
2877    }
2878    @Override
2879    public Response<String> jsonSet(String key, Path2 path, Object object) {
2880      return appendCommand(commandObjects.jsonSet(key, path, object));
2881    }
2882    @Override
2883    public Response<String> jsonSetWithEscape(String key, Path2 path, Object object) {
2884      return appendCommand(commandObjects.jsonSetWithEscape(key, path, object));
2885    }
2886    @Override
2887    public Response<String> jsonSet(String key, Path path, Object object) {
2888      return appendCommand(commandObjects.jsonSet(key, path, object));
2889    }
2890    @Override
2891    public Response<String> jsonSet(String key, Path2 path, Object object, JsonSetParams params) {
2892      return appendCommand(commandObjects.jsonSet(key, path, object, params));
2893    }
2894    @Override
2895    public Response<String> jsonSetWithEscape(String key, Path2 path, Object object, JsonSetParams params) {
2896      return appendCommand(commandObjects.jsonSetWithEscape(key, path, object, params));
2897    }
2898    @Override
2899    public Response<String> jsonSet(String key, Path path, Object object, JsonSetParams params) {
2900      return appendCommand(commandObjects.jsonSet(key, path, object, params));
2901    }
2902    @Override
2903    public Response<String> jsonMerge(String key, Path2 path, Object object) {
2904      return appendCommand(commandObjects.jsonMerge(key, path, object));
2905    }
2906    @Override
2907    public Response<String> jsonMerge(String key, Path path, Object object) {
2908      return appendCommand(commandObjects.jsonMerge(key, path, object));
2909    }
2910    @Override
2911    public Response<Object> jsonGet(String key) {
2912      return appendCommand(commandObjects.jsonGet(key));
2913    }
2914    @Override
2915    public <T> Response<T> jsonGet(String key, Class<T> clazz) {
2916      return appendCommand(commandObjects.jsonGet(key, clazz));
2917    }
2918    @Override
2919    public Response<Object> jsonGet(String key, Path2... paths) {
2920      return appendCommand(commandObjects.jsonGet(key, paths));
2921    }
2922    @Override
2923    public Response<Object> jsonGet(String key, Path... paths) {
2924      return appendCommand(commandObjects.jsonGet(key, paths));
2925    }
2926    @Override
2927    public <T> Response<T> jsonGet(String key, Class<T> clazz, Path... paths) {
2928      return appendCommand(commandObjects.jsonGet(key, clazz, paths));
2929    }
2930    @Override
2931    public Response<List<JSONArray>> jsonMGet(Path2 path, String... keys) {
2932      return appendCommand(commandObjects.jsonMGet(path, keys));
2933    }
2934    @Override
2935    public <T> Response<List<T>> jsonMGet(Path path, Class<T> clazz, String... keys) {
2936      return appendCommand(commandObjects.jsonMGet(path, clazz, keys));
2937    }
2938    @Override
2939    public Response<Long> jsonDel(String key) {
2940      return appendCommand(commandObjects.jsonDel(key));
2941    }
2942    @Override
2943    public Response<Long> jsonDel(String key, Path2 path) {
2944      return appendCommand(commandObjects.jsonDel(key, path));
2945    }
2946    @Override
2947    public Response<Long> jsonDel(String key, Path path) {
2948      return appendCommand(commandObjects.jsonDel(key, path));
2949    }
2950    @Override
2951    public Response<Long> jsonClear(String key) {
2952      return appendCommand(commandObjects.jsonClear(key));
2953    }
2954    @Override
2955    public Response<Long> jsonClear(String key, Path2 path) {
2956      return appendCommand(commandObjects.jsonClear(key, path));
2957    }
2958    @Override
2959    public Response<Long> jsonClear(String key, Path path) {
2960      return appendCommand(commandObjects.jsonClear(key, path));
2961    }
2962    @Override
2963    public Response<List<Boolean>> jsonToggle(String key, Path2 path) {
2964      return appendCommand(commandObjects.jsonToggle(key, path));
2965    }
2966    @Override
2967    public Response<String> jsonToggle(String key, Path path) {
2968      return appendCommand(commandObjects.jsonToggle(key, path));
2969    }
2970    @Override
2971    public Response<Class<?>> jsonType(String key) {
2972      return appendCommand(commandObjects.jsonType(key));
2973    }
2974    @Override
2975    public Response<List<Class<?>>> jsonType(String key, Path2 path) {
2976      return appendCommand(commandObjects.jsonType(key, path));
2977    }
2978    @Override
2979    public Response<Class<?>> jsonType(String key, Path path) {
2980      return appendCommand(commandObjects.jsonType(key, path));
2981    }
2982    @Override
2983    public Response<Long> jsonStrAppend(String key, Object string) {
2984      return appendCommand(commandObjects.jsonStrAppend(key, string));
2985    }
2986    @Override
2987    public Response<List<Long>> jsonStrAppend(String key, Path2 path, Object string) {
2988      return appendCommand(commandObjects.jsonStrAppend(key, path, string));
2989    }
2990    @Override
2991    public Response<Long> jsonStrAppend(String key, Path path, Object string) {
2992      return appendCommand(commandObjects.jsonStrAppend(key, path, string));
2993    }
2994    @Override
2995    public Response<Long> jsonStrLen(String key) {
2996      return appendCommand(commandObjects.jsonStrLen(key));
2997    }
2998    @Override
2999    public Response<List<Long>> jsonStrLen(String key, Path2 path) {
3000      return appendCommand(commandObjects.jsonStrLen(key, path));
3001    }
3002    @Override
3003    public Response<Long> jsonStrLen(String key, Path path) {
3004      return appendCommand(commandObjects.jsonStrLen(key, path));
3005    }
3006    @Override
3007    public Response<JSONArray> jsonNumIncrBy(String key, Path2 path, double value) {
3008      return appendCommand(commandObjects.jsonNumIncrBy(key, path, value));
3009    }
3010    @Override
3011    public Response<Double> jsonNumIncrBy(String key, Path path, double value) {
3012      return appendCommand(commandObjects.jsonNumIncrBy(key, path, value));
3013    }
3014    @Override
3015    public Response<List<Long>> jsonArrAppend(String key, Path2 path, Object... objects) {
3016      return appendCommand(commandObjects.jsonArrAppend(key, path, objects));
3017    }
3018    @Override
3019    public Response<List<Long>> jsonArrAppendWithEscape(String key, Path2 path, Object... objects) {
3020      return appendCommand(commandObjects.jsonArrAppendWithEscape(key, path, objects));
3021    }
3022    @Override
3023    public Response<Long> jsonArrAppend(String key, Path path, Object... objects) {
3024      return appendCommand(commandObjects.jsonArrAppend(key, path, objects));
3025    }
3026    @Override
3027    public Response<List<Long>> jsonArrIndex(String key, Path2 path, Object scalar) {
3028      return appendCommand(commandObjects.jsonArrIndex(key, path, scalar));
3029    }
3030    @Override
3031    public Response<List<Long>> jsonArrIndexWithEscape(String key, Path2 path, Object scalar) {
3032      return appendCommand(commandObjects.jsonArrIndexWithEscape(key, path, scalar));
3033    }
3034    @Override
3035    public Response<Long> jsonArrIndex(String key, Path path, Object scalar) {
3036      return appendCommand(commandObjects.jsonArrIndex(key, path, scalar));
3037    }
3038    @Override
3039    public Response<List<Long>> jsonArrInsert(String key, Path2 path, int index, Object... objects) {
3040      return appendCommand(commandObjects.jsonArrInsert(key, path, index, objects));
3041    }
3042    @Override
3043    public Response<List<Long>> jsonArrInsertWithEscape(String key, Path2 path, int index, Object... objects) {
3044      return appendCommand(commandObjects.jsonArrInsertWithEscape(key, path, index, objects));
3045    }
3046    @Override
3047    public Response<Long> jsonArrInsert(String key, Path path, int index, Object... pojos) {
3048      return appendCommand(commandObjects.jsonArrInsert(key, path, index, pojos));
3049    }
3050    @Override
3051    public Response<Object> jsonArrPop(String key) {
3052      return appendCommand(commandObjects.jsonArrPop(key));
3053    }
3054    @Override
3055    public Response<Long> jsonArrLen(String key, Path path) {
3056      return appendCommand(commandObjects.jsonArrLen(key, path));
3057    }
3058    @Override
3059    public Response<List<Long>> jsonArrTrim(String key, Path2 path, int start, int stop) {
3060      return appendCommand(commandObjects.jsonArrTrim(key, path, start, stop));
3061    }
3062    @Override
3063    public Response<Long> jsonArrTrim(String key, Path path, int start, int stop) {
3064      return appendCommand(commandObjects.jsonArrTrim(key, path, start, stop));
3065    }
3066    @Override
3067    public <T> Response<T> jsonArrPop(String key, Class<T> clazz, Path path) {
3068      return appendCommand(commandObjects.jsonArrPop(key, clazz, path));
3069    }
3070    @Override
3071    public Response<List<Object>> jsonArrPop(String key, Path2 path, int index) {
3072      return appendCommand(commandObjects.jsonArrPop(key, path, index));
3073    }
3074    @Override
3075    public Response<Object> jsonArrPop(String key, Path path, int index) {
3076      return appendCommand(commandObjects.jsonArrPop(key, path, index));
3077    }
3078    @Override
3079    public <T> Response<T> jsonArrPop(String key, Class<T> clazz, Path path, int index) {
3080      return appendCommand(commandObjects.jsonArrPop(key, clazz, path, index));
3081    }
3082    @Override
3083    public Response<Long> jsonArrLen(String key) {
3084      return appendCommand(commandObjects.jsonArrLen(key));
3085    }
3086    @Override
3087    public Response<List<Long>> jsonArrLen(String key, Path2 path) {
3088      return appendCommand(commandObjects.jsonArrLen(key, path));
3089    }
3090    @Override
3091    public <T> Response<T> jsonArrPop(String key, Class<T> clazz) {
3092      return appendCommand(commandObjects.jsonArrPop(key, clazz));
3093    }
3094    @Override
3095    public Response<List<Object>> jsonArrPop(String key, Path2 path) {
3096      return appendCommand(commandObjects.jsonArrPop(key, path));
3097    }
3098    @Override
3099    public Response<Object> jsonArrPop(String key, Path path) {
3100      return appendCommand(commandObjects.jsonArrPop(key, path));
3101    }
3102    @Override
3103    public Response<String> tsCreate(String key) {
3104      return appendCommand(commandObjects.tsCreate(key));
3105    }
3106    @Override
3107    public Response<String> tsCreate(String key, TSCreateParams createParams) {
3108      return appendCommand(commandObjects.tsCreate(key, createParams));
3109    }
3110    @Override
3111    public Response<Long> tsDel(String key, long fromTimestamp, long toTimestamp) {
3112      return appendCommand(commandObjects.tsDel(key, fromTimestamp, toTimestamp));
3113    }
3114    @Override
3115    public Response<String> tsAlter(String key, TSAlterParams alterParams) {
3116      return appendCommand(commandObjects.tsAlter(key, alterParams));
3117    }
3118    @Override
3119    public Response<Long> tsAdd(String key, double value) {
3120      return appendCommand(commandObjects.tsAdd(key, value));
3121    }
3122    @Override
3123    public Response<Long> tsAdd(String key, long timestamp, double value) {
3124      return appendCommand(commandObjects.tsAdd(key, timestamp, value));
3125    }
3126    @Override
3127    public Response<Long> tsAdd(String key, long timestamp, double value, TSCreateParams createParams) {
3128      return appendCommand(commandObjects.tsAdd(key, timestamp, value, createParams));
3129    }
3130    @Override
3131    public Response<List<Long>> tsMAdd(Map.Entry<String, TSElement>... entries) {
3132      return appendCommand(commandObjects.tsMAdd(entries));
3133    }
3134    @Override
3135    public Response<Long> tsIncrBy(String key, double value) {
3136      return appendCommand(commandObjects.tsIncrBy(key, value));
3137    }
3138    @Override
3139    public Response<Long> tsIncrBy(String key, double value, long timestamp) {
3140      return appendCommand(commandObjects.tsIncrBy(key, value, timestamp));
3141    }
3142    @Override
3143    public Response<Long> tsDecrBy(String key, double value) {
3144      return appendCommand(commandObjects.tsDecrBy(key, value));
3145    }
3146    @Override
3147    public Response<Long> tsDecrBy(String key, double value, long timestamp) {
3148      return appendCommand(commandObjects.tsDecrBy(key, value, timestamp));
3149    }
3150    @Override
3151    public Response<List<TSElement>> tsRange(String key, long fromTimestamp, long toTimestamp) {
3152      return appendCommand(commandObjects.tsRange(key, fromTimestamp, toTimestamp));
3153    }
3154    @Override
3155    public Response<List<TSElement>> tsRange(String key, TSRangeParams rangeParams) {
3156      return appendCommand(commandObjects.tsRange(key, rangeParams));
3157    }
3158    @Override
3159    public Response<List<TSElement>> tsRevRange(String key, long fromTimestamp, long toTimestamp) {
3160      return appendCommand(commandObjects.tsRevRange(key, fromTimestamp, toTimestamp));
3161    }
3162    @Override
3163    public Response<List<TSElement>> tsRevRange(String key, TSRangeParams rangeParams) {
3164      return appendCommand(commandObjects.tsRevRange(key, rangeParams));
3165    }
3166    @Override
3167    public Response<Map<String, TSMRangeElements>> tsMRange(long fromTimestamp, long toTimestamp, String... filters) {
3168      return appendCommand(commandObjects.tsMRange(fromTimestamp, toTimestamp, filters));
3169    }
3170    @Override
3171    public Response<Map<String, TSMRangeElements>> tsMRange(TSMRangeParams multiRangeParams) {
3172      return appendCommand(commandObjects.tsMRange(multiRangeParams));
3173    }
3174    @Override
3175    public Response<Map<String, TSMRangeElements>> tsMRevRange(long fromTimestamp, long toTimestamp, String... filters) {
3176      return appendCommand(commandObjects.tsMRevRange(fromTimestamp, toTimestamp, filters));
3177    }
3178    @Override
3179    public Response<Map<String, TSMRangeElements>> tsMRevRange(TSMRangeParams multiRangeParams) {
3180      return appendCommand(commandObjects.tsMRevRange(multiRangeParams));
3181    }
3182    @Override
3183    public Response<TSElement> tsGet(String key) {
3184      return appendCommand(commandObjects.tsGet(key));
3185    }
3186    @Override
3187    public Response<TSElement> tsGet(String key, TSGetParams getParams) {
3188      return appendCommand(commandObjects.tsGet(key, getParams));
3189    }
3190    @Override
3191    public Response<Map<String, TSMGetElement>> tsMGet(TSMGetParams multiGetParams, String... filters) {
3192      return appendCommand(commandObjects.tsMGet(multiGetParams, filters));
3193    }
3194    @Override
3195    public Response<String> tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long timeBucket) {
3196      return appendCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, timeBucket));
3197    }
3198    @Override
3199    public Response<String> tsCreateRule(String sourceKey, String destKey, AggregationType aggregationType, long bucketDuration, long alignTimestamp) {
3200      return appendCommand(commandObjects.tsCreateRule(sourceKey, destKey, aggregationType, bucketDuration, alignTimestamp));
3201    }
3202    @Override
3203    public Response<String> tsDeleteRule(String sourceKey, String destKey) {
3204      return appendCommand(commandObjects.tsDeleteRule(sourceKey, destKey));
3205    }
3206    @Override
3207    public Response<List<String>> tsQueryIndex(String... filters) {
3208      return appendCommand(commandObjects.tsQueryIndex(filters));
3209    }
3210    @Override
3211    public Response<String> bfReserve(String key, double errorRate, long capacity) {
3212      return appendCommand(commandObjects.bfReserve(key, errorRate, capacity));
3213    }
3214    @Override
3215    public Response<String> bfReserve(String key, double errorRate, long capacity, BFReserveParams reserveParams) {
3216      return appendCommand(commandObjects.bfReserve(key, errorRate, capacity, reserveParams));
3217    }
3218    @Override
3219    public Response<Boolean> bfAdd(String key, String item) {
3220      return appendCommand(commandObjects.bfAdd(key, item));
3221    }
3222    @Override
3223    public Response<List<Boolean>> bfMAdd(String key, String... items) {
3224      return appendCommand(commandObjects.bfMAdd(key, items));
3225    }
3226    @Override
3227    public Response<List<Boolean>> bfInsert(String key, String... items) {
3228      return appendCommand(commandObjects.bfInsert(key, items));
3229    }
3230    @Override
3231    public Response<List<Boolean>> bfInsert(String key, BFInsertParams insertParams, String... items) {
3232      return appendCommand(commandObjects.bfInsert(key, insertParams, items));
3233    }
3234    @Override
3235    public Response<Boolean> bfExists(String key, String item) {
3236      return appendCommand(commandObjects.bfExists(key, item));
3237    }
3238    @Override
3239    public Response<List<Boolean>> bfMExists(String key, String... items) {
3240      return appendCommand(commandObjects.bfMExists(key, items));
3241    }
3242    @Override
3243    public Response<Map.Entry<Long, byte[]>> bfScanDump(String key, long iterator) {
3244      return appendCommand(commandObjects.bfScanDump(key, iterator));
3245    }
3246    @Override
3247    public Response<String> bfLoadChunk(String key, long iterator, byte[] data) {
3248      return appendCommand(commandObjects.bfLoadChunk(key, iterator, data));
3249    }
3250    @Override
3251    public Response<Long> bfCard(String key) {
3252      return appendCommand(commandObjects.bfCard(key));
3253    }
3254    @Override
3255    public Response<Map<String, Object>> bfInfo(String key) {
3256      return appendCommand(commandObjects.bfInfo(key));
3257    }
3258    @Override
3259    public Response<String> cfReserve(String key, long capacity) {
3260      return appendCommand(commandObjects.cfReserve(key, capacity));
3261    }
3262    @Override
3263    public Response<String> cfReserve(String key, long capacity, CFReserveParams reserveParams) {
3264      return appendCommand(commandObjects.cfReserve(key, capacity, reserveParams));
3265    }
3266    @Override
3267    public Response<Boolean> cfAdd(String key, String item) {
3268      return appendCommand(commandObjects.cfAdd(key, item));
3269    }
3270    @Override
3271    public Response<Boolean> cfAddNx(String key, String item) {
3272      return appendCommand(commandObjects.cfAddNx(key, item));
3273    }
3274    @Override
3275    public Response<List<Boolean>> cfInsert(String key, String... items) {
3276      return appendCommand(commandObjects.cfInsert(key, items));
3277    }
3278    @Override
3279    public Response<List<Boolean>> cfInsert(String key, CFInsertParams insertParams, String... items) {
3280      return appendCommand(commandObjects.cfInsert(key, insertParams, items));
3281    }
3282    @Override
3283    public Response<List<Boolean>> cfInsertNx(String key, String... items) {
3284      return appendCommand(commandObjects.cfInsertNx(key, items));
3285    }
3286    @Override
3287    public Response<List<Boolean>> cfInsertNx(String key, CFInsertParams insertParams, String... items) {
3288      return appendCommand(commandObjects.cfInsertNx(key, insertParams, items));
3289    }
3290    @Override
3291    public Response<Boolean> cfExists(String key, String item) {
3292      return appendCommand(commandObjects.cfExists(key, item));
3293    }
3294    @Override
3295    public Response<Boolean> cfDel(String key, String item) {
3296      return appendCommand(commandObjects.cfDel(key, item));
3297    }
3298    @Override
3299    public Response<Long> cfCount(String key, String item) {
3300      return appendCommand(commandObjects.cfCount(key, item));
3301    }
3302    @Override
3303    public Response<Map.Entry<Long, byte[]>> cfScanDump(String key, long iterator) {
3304      return appendCommand(commandObjects.cfScanDump(key, iterator));
3305    }
3306    @Override
3307    public Response<String> cfLoadChunk(String key, long iterator, byte[] data) {
3308      return appendCommand(commandObjects.cfLoadChunk(key, iterator, data));
3309    }
3310    @Override
3311    public Response<Map<String, Object>> cfInfo(String key) {
3312      return appendCommand(commandObjects.cfInfo(key));
3313    }
3314    @Override
3315    public Response<String> cmsInitByDim(String key, long width, long depth) {
3316      return appendCommand(commandObjects.cmsInitByDim(key, width, depth));
3317    }
3318    @Override
3319    public Response<String> cmsInitByProb(String key, double error, double probability) {
3320      return appendCommand(commandObjects.cmsInitByProb(key, error, probability));
3321    }
3322    @Override
3323    public Response<List<Long>> cmsIncrBy(String key, Map<String, Long> itemIncrements) {
3324      return appendCommand(commandObjects.cmsIncrBy(key, itemIncrements));
3325    }
3326    @Override
3327    public Response<List<Long>> cmsQuery(String key, String... items) {
3328      return appendCommand(commandObjects.cmsQuery(key, items));
3329    }
3330    @Override
3331    public Response<String> cmsMerge(String destKey, String... keys) {
3332      return appendCommand(commandObjects.cmsMerge(destKey, keys));
3333    }
3334    @Override
3335    public Response<String> cmsMerge(String destKey, Map<String, Long> keysAndWeights) {
3336      return appendCommand(commandObjects.cmsMerge(destKey, keysAndWeights));
3337    }
3338    @Override
3339    public Response<Map<String, Object>> cmsInfo(String key) {
3340      return appendCommand(commandObjects.cmsInfo(key));
3341    }
3342    @Override
3343    public Response<String> topkReserve(String key, long topk) {
3344      return appendCommand(commandObjects.topkReserve(key, topk));
3345    }
3346    @Override
3347    public Response<String> topkReserve(String key, long topk, long width, long depth, double decay) {
3348      return appendCommand(commandObjects.topkReserve(key, topk, width, depth, decay));
3349    }
3350    @Override
3351    public Response<List<String>> topkAdd(String key, String... items) {
3352      return appendCommand(commandObjects.topkAdd(key, items));
3353    }
3354    @Override
3355    public Response<List<String>> topkIncrBy(String key, Map<String, Long> itemIncrements) {
3356      return appendCommand(commandObjects.topkIncrBy(key, itemIncrements));
3357    }
3358    @Override
3359    public Response<List<Boolean>> topkQuery(String key, String... items) {
3360      return appendCommand(commandObjects.topkQuery(key, items));
3361    }
3362    @Override
3363    public Response<List<String>> topkList(String key) {
3364      return appendCommand(commandObjects.topkList(key));
3365    }
3366    @Override
3367    public Response<Map<String, Object>> topkInfo(String key) {
3368      return appendCommand(commandObjects.topkInfo(key));
3369    }
3370    @Override
3371    public Response<String> tdigestCreate(String key) {
3372      return appendCommand(commandObjects.tdigestCreate(key));
3373    }
3374    @Override
3375    public Response<String> tdigestCreate(String key, int compression) {
3376      return appendCommand(commandObjects.tdigestCreate(key, compression));
3377    }
3378    @Override
3379    public Response<String> tdigestReset(String key) {
3380      return appendCommand(commandObjects.tdigestReset(key));
3381    }
3382    @Override
3383    public Response<String> tdigestMerge(String destinationKey, String... sourceKeys) {
3384      return appendCommand(commandObjects.tdigestMerge(destinationKey, sourceKeys));
3385    }
3386    @Override
3387    public Response<String> tdigestMerge(TDigestMergeParams mergeParams, String destinationKey, String... sourceKeys) {
3388      return appendCommand(commandObjects.tdigestMerge(mergeParams, destinationKey, sourceKeys));
3389    }
3390    @Override
3391    public Response<Map<String, Object>> tdigestInfo(String key) {
3392      return appendCommand(commandObjects.tdigestInfo(key));
3393    }
3394    @Override
3395    public Response<String> tdigestAdd(String key, double... values) {
3396      return appendCommand(commandObjects.tdigestAdd(key, values));
3397    }
3398    @Override
3399    public Response<List<Double>> tdigestCDF(String key, double... values) {
3400      return appendCommand(commandObjects.tdigestCDF(key, values));
3401    }
3402    @Override
3403    public Response<List<Double>> tdigestQuantile(String key, double... quantiles) {
3404      return appendCommand(commandObjects.tdigestQuantile(key, quantiles));
3405    }
3406    @Override
3407    public Response<Double> tdigestMin(String key) {
3408      return appendCommand(commandObjects.tdigestMin(key));
3409    }
3410    @Override
3411    public Response<Double> tdigestMax(String key) {
3412      return appendCommand(commandObjects.tdigestMax(key));
3413    }
3414    @Override
3415    public Response<Double> tdigestTrimmedMean(String key, double lowCutQuantile, double highCutQuantile) {
3416      return appendCommand(commandObjects.tdigestTrimmedMean(key, lowCutQuantile, highCutQuantile));
3417    }
3418    @Override
3419    public Response<List<Long>> tdigestRank(String key, double... values) {
3420      return appendCommand(commandObjects.tdigestRank(key, values));
3421    }
3422    @Override
3423    public Response<List<Long>> tdigestRevRank(String key, double... values) {
3424      return appendCommand(commandObjects.tdigestRevRank(key, values));
3425    }
3426    @Override
3427    public Response<List<Double>> tdigestByRank(String key, long... ranks) {
3428      return appendCommand(commandObjects.tdigestByRank(key, ranks));
3429    }
3430    @Override
3431    public Response<List<Double>> tdigestByRevRank(String key, long... ranks) {
3432      return appendCommand(commandObjects.tdigestByRevRank(key, ranks));
3433    }
3434    @Override
3435    public Response<ResultSet> graphQuery(String name, String query) {
3436      return appendCommand(graphCommandObjects.graphQuery(name, query));
3437    }
3438    @Override
3439    public Response<ResultSet> graphReadonlyQuery(String name, String query) {
3440      return appendCommand(graphCommandObjects.graphReadonlyQuery(name, query));
3441    }
3442    @Override
3443    public Response<ResultSet> graphQuery(String name, String query, long timeout) {
3444      return appendCommand(graphCommandObjects.graphQuery(name, query, timeout));
3445    }
3446    @Override
3447    public Response<ResultSet> graphReadonlyQuery(String name, String query, long timeout) {
3448      return appendCommand(graphCommandObjects.graphReadonlyQuery(name, query, timeout));
3449    }
3450    @Override
3451    public Response<ResultSet> graphQuery(String name, String query, Map<String, Object> params) {
3452      return appendCommand(graphCommandObjects.graphQuery(name, query, params));
3453    }
3454    @Override
3455    public Response<ResultSet> graphReadonlyQuery(String name, String query, Map<String, Object> params) {
3456      return appendCommand(graphCommandObjects.graphReadonlyQuery(name, query, params));
3457    }
3458    @Override
3459    public Response<ResultSet> graphQuery(String name, String query, Map<String, Object> params, long timeout) {
3460      return appendCommand(graphCommandObjects.graphQuery(name, query, params, timeout));
3461    }
3462    @Override
3463    public Response<ResultSet> graphReadonlyQuery(String name, String query, Map<String, Object> params, long timeout) {
3464      return appendCommand(graphCommandObjects.graphReadonlyQuery(name, query, params, timeout));
3465    }
3466    @Override
3467    public Response<String> graphDelete(String name) {
3468      return appendCommand(graphCommandObjects.graphDelete(name));
3469    }
3470    @Override
3471    public Response<List<String>> graphProfile(String graphName, String query) {
3472      return appendCommand(commandObjects.graphProfile(graphName, query));
3473    }
3474    public Response<Long> waitReplicas(int replicas, long timeout) {
3475      return appendCommand(commandObjects.waitReplicas(replicas, timeout));
3476    }
3477    public Response<Object> sendCommand(ProtocolCommand cmd, String... args) {
3478      return sendCommand(new CommandArguments(cmd).addObjects((Object[]) args));
3479    }
3480    public Response<Object> sendCommand(ProtocolCommand cmd, byte[]... args) {
3481      return sendCommand(new CommandArguments(cmd).addObjects((Object[]) args));
3482    }
3483    public Response<Object> sendCommand(CommandArguments args) {
3484      return executeCommand(new CommandObject<>(args, BuilderFactory.RAW_OBJECT));
3485    }
3486    public <T> Response<T> executeCommand(CommandObject<T> command) {
3487      return appendCommand(command);
3488    }
3489    public void setJsonObjectMapper(JsonObjectMapper jsonObjectMapper) {
3490      this.commandObjects.setJsonObjectMapper(jsonObjectMapper);
3491    }
3492  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-PipelineBase.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-TransactionBase.java</div>
                </div>
                <div class="column column_space"><pre><code>438    public Response<KeyValue<String, String>> blpop(double timeout, String key) {
439      return appendCommand(commandObjects.blpop(timeout, key));
440    }
441    @Override
442    public Response<List<String>> brpop(int timeout, String key) {
</pre></code></div>
                <div class="column column_space"><pre><code>567    public Response<KeyValue<String, String>> brpop(double timeout, String key) {
568      return appendCommand(commandObjects.brpop(timeout, key));
569    }
570    @Override
571    public Response<List<String>> blpop(int timeout, String... keys) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    