
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.6036036036036037%, Tokens: 10</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-SpringBeanUtil.java</h3>
            <pre><code>1  package com.weibo.api.motan.config.springsupport.util;
<span onclick='openModal()' class='match'>2  import com.weibo.api.motan.common.URLParamType;
3  import com.weibo.api.motan.config.RegistryConfig;
4  import com.weibo.api.motan.util.LoggerUtil;
5  import org.apache.commons.lang3.StringUtils;
6  import org.springframework.beans.factory.BeanFactory;
7  import java.util.ArrayList;
8  import java.util.List;
9  import java.util.Map;
10  public class SpringBeanUtil {
11      public static final String COMMA_SPLIT_PATTERN = "\\s*[,]+\\s*";
</span>12      public static <T> List<T> getMultiBeans(BeanFactory beanFactory, String names, String pattern, Class<T> clazz) {
13          String[] nameArr = names.split(pattern);
14          List<T> beans = new ArrayList<T>();
15          for (String name : nameArr) {
16              if (name != null && name.length() > 0) {
17                  beans.add(beanFactory.getBean(name, clazz));
18              }
19          }
20          return beans;
21      }
22      public static void addRegistryParamBean(RegistryConfig registryConfig, BeanFactory beanFactory) {
23          if (registryConfig.getProxyRegistry() == null) {
24              Map<String, String> addressParams = registryConfig.getAddressParams();
25              String proxyRegistryId = addressParams.get(URLParamType.proxyRegistryId);
26              if (StringUtils.isNotBlank(proxyRegistryId)) {
27                  String identity = registryConfig.getId() + "-" + registryConfig.getName();
28                  RegistryConfig proxyRegistry = beanFactory.getBean(proxyRegistryId, RegistryConfig.class);
29                  if (proxyRegistry != null) {
30                      registryConfig.setProxyRegistry(proxyRegistry);
31                      LoggerUtil.info("add proxy registry bean by address params. proxyRegistryId:" + proxyRegistryId + ", RegistryConfig:" + identity);
32                  } else {
33                      LoggerUtil.warn("proxy registry bean not found. proxyRegistryId:" + proxyRegistryId + ", RegistryConfig:" + identity);
34                  }
35              }
36          }
37      }
38  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ServerStats.java</h3>
            <pre><code>1  package com.netflix.loadbalancer;
2  import com.google.common.annotations.VisibleForTesting;
3  import com.netflix.client.config.CommonClientConfigKey;
4  import com.netflix.client.config.IClientConfigKey;
5  import com.netflix.client.config.Property;
6  import com.netflix.client.config.UnboxedIntProperty;
7  import com.netflix.servo.annotations.DataSourceType;
8  import com.netflix.servo.annotations.Monitor;
<span onclick='openModal()' class='match'>9  import com.netflix.stats.distribution.DataDistribution;
10  import com.netflix.stats.distribution.DataPublisher;
11  import com.netflix.stats.distribution.Distribution;
12  import com.netflix.util.MeasuredRate;
13  import java.util.Date;
14  import java.util.Random;
15  import java.util.concurrent.atomic.AtomicInteger;
16  import java.util.concurrent.atomic.AtomicLong;
17  public class ServerStats {
18      private static final int DEFAULT_PUBLISH_INTERVAL =  60 * 1000; 
</span>19      private static final int DEFAULT_BUFFER_SIZE = 60 * 1000; 
20      private final UnboxedIntProperty connectionFailureThreshold;
21      private final UnboxedIntProperty circuitTrippedTimeoutFactor;
22      private final UnboxedIntProperty maxCircuitTrippedTimeout;
23      private final UnboxedIntProperty activeRequestsCountTimeout;
24      private static final double[] PERCENTS = makePercentValues();
25      private DataDistribution dataDist = new DataDistribution(1, PERCENTS); 
26      private DataPublisher publisher = null;
27      private final Distribution responseTimeDist = new Distribution();
28      int bufferSize = DEFAULT_BUFFER_SIZE;
29      int publishInterval = DEFAULT_PUBLISH_INTERVAL;
30      long failureCountSlidingWindowInterval = 1000; 
31      private MeasuredRate serverFailureCounts = new MeasuredRate(failureCountSlidingWindowInterval);
32      private MeasuredRate requestCountInWindow = new MeasuredRate(300000L);
33      Server server;
34      AtomicLong totalRequests = new AtomicLong();
35      @VisibleForTesting
36      AtomicInteger successiveConnectionFailureCount = new AtomicInteger(0);
37      @VisibleForTesting
38      AtomicInteger activeRequestsCount = new AtomicInteger(0);
39      @VisibleForTesting
40      AtomicInteger openConnectionsCount = new AtomicInteger(0);
41      private volatile long lastConnectionFailedTimestamp;
42      private volatile long lastActiveRequestsCountChangeTimestamp;
43      private AtomicLong totalCircuitBreakerBlackOutPeriod = new AtomicLong(0);
44      private volatile long lastAccessedTimestamp;
45      private volatile long firstConnectionTimestamp = 0;
46      public ServerStats() {
47          connectionFailureThreshold = new UnboxedIntProperty(Property.of(LoadBalancerStats.CONNECTION_FAILURE_COUNT_THRESHOLD.defaultValue()));
48          circuitTrippedTimeoutFactor = new UnboxedIntProperty(LoadBalancerStats.CIRCUIT_TRIP_TIMEOUT_FACTOR_SECONDS.defaultValue());
49          maxCircuitTrippedTimeout = new UnboxedIntProperty(LoadBalancerStats.CIRCUIT_TRIP_MAX_TIMEOUT_SECONDS.defaultValue());
50          activeRequestsCountTimeout = new UnboxedIntProperty(LoadBalancerStats.ACTIVE_REQUESTS_COUNT_TIMEOUT.defaultValue());
51      }
52      public ServerStats(LoadBalancerStats lbStats) {
53          maxCircuitTrippedTimeout = lbStats.getCircuitTripMaxTimeoutSeconds();
54          circuitTrippedTimeoutFactor = lbStats.getCircuitTrippedTimeoutFactor();
55          connectionFailureThreshold = lbStats.getConnectionFailureCountThreshold();
56          activeRequestsCountTimeout = lbStats.getActiveRequestsCountTimeout();
57      }
58      public void initialize(Server server) {
59          serverFailureCounts = new MeasuredRate(failureCountSlidingWindowInterval);
60          requestCountInWindow = new MeasuredRate(300000L);
61          if (publisher == null) {
62              dataDist = new DataDistribution(getBufferSize(), PERCENTS);
63              publisher = new DataPublisher(dataDist, getPublishIntervalMillis());
64              publisher.start();
65          }
66          this.server = server;
67      }
68      public void close() {
69          if (publisher != null)
70              publisher.stop();
71      }
72      public Server getServer() {
73          return server;
74      }
75      private int getBufferSize() {
76          return bufferSize;
77      }
78      private long getPublishIntervalMillis() {
79          return publishInterval;
80      }
81      public void setBufferSize(int bufferSize) {
82          this.bufferSize = bufferSize;
83      }
84      public void setPublishInterval(int publishInterval) {
85          this.publishInterval = publishInterval;
86      }
87      private static enum Percent {
88          TEN(10), TWENTY_FIVE(25), FIFTY(50), SEVENTY_FIVE(75), NINETY(90),
89          NINETY_FIVE(95), NINETY_EIGHT(98), NINETY_NINE(99), NINETY_NINE_POINT_FIVE(99.5);
90          private double val;
91          Percent(double val) {
92              this.val = val;
93          }
94          public double getValue() {
95              return val;
96          }
97      }
98      private static double[] makePercentValues() {
99          Percent[] percents = Percent.values();
100          double[] p = new double[percents.length];
101          for (int i = 0; i < percents.length; i++) {
102              p[i] = percents[i].getValue();
103          }
104          return p;
105      }
106      public long getFailureCountSlidingWindowInterval() {
107          return failureCountSlidingWindowInterval;
108      }
109      public void setFailureCountSlidingWindowInterval(
110              long failureCountSlidingWindowInterval) {
111          this.failureCountSlidingWindowInterval = failureCountSlidingWindowInterval;
112      }
113      public void addToFailureCount(){
114          serverFailureCounts.increment();
115      }
116      public long getFailureCount(){
117          return serverFailureCounts.getCurrentCount();
118      }
119      public void noteResponseTime(double msecs){
120          dataDist.noteValue(msecs);
121          responseTimeDist.noteValue(msecs);
122      }
123      public void incrementNumRequests(){
124          totalRequests.incrementAndGet();
125      }
126      public void incrementActiveRequestsCount() {        
127          activeRequestsCount.incrementAndGet();
128          requestCountInWindow.increment();
129          long currentTime = System.currentTimeMillis();
130          lastActiveRequestsCountChangeTimestamp = currentTime;
131          lastAccessedTimestamp = currentTime;
132          if (firstConnectionTimestamp == 0) {
133              firstConnectionTimestamp = currentTime;
134          }
135      }
136      public void incrementOpenConnectionsCount() {
137          openConnectionsCount.incrementAndGet();
138      }
139      public void decrementActiveRequestsCount() {
140          activeRequestsCount.getAndUpdate(current -> Math.max(0, current - 1));
141          lastActiveRequestsCountChangeTimestamp = System.currentTimeMillis();
142      }
143      public void decrementOpenConnectionsCount() {
144          openConnectionsCount.getAndUpdate(current -> Math.max(0, current - 1));
145      }
146      public int  getActiveRequestsCount() {
147          return getActiveRequestsCount(System.currentTimeMillis());
148      }
149      public int getActiveRequestsCount(long currentTime) {
150          int count = activeRequestsCount.get();
151          if (count == 0) {
152              return 0;
153          } else if (currentTime - lastActiveRequestsCountChangeTimestamp > activeRequestsCountTimeout.get() * 1000 || count < 0) {
154              activeRequestsCount.set(0);
155              return 0;            
156          } else {
157              return count;
158          }
159      }
160      public int getOpenConnectionsCount() {
161          return openConnectionsCount.get();
162      }
163      public long getMeasuredRequestsCount() {
164          return requestCountInWindow.getCount();
165      }
166      @Monitor(name="ActiveRequestsCount", type = DataSourceType.GAUGE)    
167      public int getMonitoredActiveRequestsCount() {
168          return activeRequestsCount.get();
169      }
170      @Monitor(name="CircuitBreakerTripped", type = DataSourceType.INFORMATIONAL)    
171      public boolean isCircuitBreakerTripped() {
172          return isCircuitBreakerTripped(System.currentTimeMillis());
173      }
174      public boolean isCircuitBreakerTripped(long currentTime) {
175          long circuitBreakerTimeout = getCircuitBreakerTimeout();
176          if (circuitBreakerTimeout <= 0) {
177              return false;
178          }
179          return circuitBreakerTimeout > currentTime;
180      }
181      private long getCircuitBreakerTimeout() {
182          long blackOutPeriod = getCircuitBreakerBlackoutPeriod();
183          if (blackOutPeriod <= 0) {
184              return 0;
185          }
186          return lastConnectionFailedTimestamp + blackOutPeriod;
187      }
188      private long getCircuitBreakerBlackoutPeriod() {
189          int failureCount = successiveConnectionFailureCount.get();
190          int threshold = connectionFailureThreshold.get();
191          if (failureCount < threshold) {
192              return 0;
193          }
194          int diff = Math.min(failureCount - threshold, 16);
195          int blackOutSeconds = (1 << diff) * circuitTrippedTimeoutFactor.get();
196          if (blackOutSeconds > maxCircuitTrippedTimeout.get()) {
197              blackOutSeconds = maxCircuitTrippedTimeout.get();
198          }
199          return blackOutSeconds * 1000L;
200      }
201      public void incrementSuccessiveConnectionFailureCount() {
202          lastConnectionFailedTimestamp = System.currentTimeMillis();
203          successiveConnectionFailureCount.incrementAndGet();
204          totalCircuitBreakerBlackOutPeriod.addAndGet(getCircuitBreakerBlackoutPeriod());
205      }
206      public void clearSuccessiveConnectionFailureCount() {
207          successiveConnectionFailureCount.set(0);
208      }
209      @Monitor(name="SuccessiveConnectionFailureCount", type = DataSourceType.GAUGE)
210      public int getSuccessiveConnectionFailureCount() {
211          return successiveConnectionFailureCount.get();
212      }
213      @Monitor(name = "OverallResponseTimeMillisAvg", type = DataSourceType.INFORMATIONAL,
214               description = "Average total time for a request, in milliseconds")
215      public double getResponseTimeAvg() {
216          return responseTimeDist.getMean();
217      }
218      @Monitor(name = "OverallResponseTimeMillisMax", type = DataSourceType.INFORMATIONAL,
219               description = "Max total time for a request, in milliseconds")
220      public double getResponseTimeMax() {
221          return responseTimeDist.getMaximum();
222      }
223      @Monitor(name = "OverallResponseTimeMillisMin", type = DataSourceType.INFORMATIONAL,
224               description = "Min total time for a request, in milliseconds")
225      public double getResponseTimeMin() {
226          return responseTimeDist.getMinimum();
227      }
228      @Monitor(name = "OverallResponseTimeMillisStdDev", type = DataSourceType.INFORMATIONAL,
229               description = "Standard Deviation in total time to handle a request, in milliseconds")
230      public double getResponseTimeStdDev() {
231          return responseTimeDist.getStdDev();
232      }
233      @Monitor(name = "ResponseTimePercentileNumValues", type = DataSourceType.GAUGE,
234               description = "The number of data points used to compute the currently reported percentile values")
235      public int getResponseTimePercentileNumValues() {
236          return dataDist.getSampleSize();
237      }
238      @Monitor(name = "ResponseTimePercentileWhen", type = DataSourceType.INFORMATIONAL,
239               description = "The time the percentile values were computed")
240      public String getResponseTimePercentileTime() {
241          return dataDist.getTimestamp();
242      }
243      @Monitor(name = "ResponseTimePercentileWhenMillis", type = DataSourceType.COUNTER,
244               description = "The time the percentile values were computed in milliseconds since the epoch")
245      public long getResponseTimePercentileTimeMillis() {
246          return dataDist.getTimestampMillis();
247      }
248      @Monitor(name = "ResponseTimeMillisAvg", type = DataSourceType.GAUGE,
249               description = "Average total time for a request in the recent time slice, in milliseconds")
250      public double getResponseTimeAvgRecent() {
251          return dataDist.getMean();
252      }
253      @Monitor(name = "ResponseTimeMillis10Percentile", type = DataSourceType.INFORMATIONAL,
254               description = "10th percentile in total time to handle a request, in milliseconds")
255      public double getResponseTime10thPercentile() {
256          return getResponseTimePercentile(Percent.TEN);
257      }
258      @Monitor(name = "ResponseTimeMillis25Percentile", type = DataSourceType.INFORMATIONAL,
259               description = "25th percentile in total time to handle a request, in milliseconds")
260      public double getResponseTime25thPercentile() {
261          return getResponseTimePercentile(Percent.TWENTY_FIVE);
262      }
263      @Monitor(name = "ResponseTimeMillis50Percentile", type = DataSourceType.INFORMATIONAL,
264               description = "50th percentile in total time to handle a request, in milliseconds")
265      public double getResponseTime50thPercentile() {
266          return getResponseTimePercentile(Percent.FIFTY);
267      }
268      @Monitor(name = "ResponseTimeMillis75Percentile", type = DataSourceType.INFORMATIONAL,
269               description = "75th percentile in total time to handle a request, in milliseconds")
270      public double getResponseTime75thPercentile() {
271          return getResponseTimePercentile(Percent.SEVENTY_FIVE);
272      }
273      @Monitor(name = "ResponseTimeMillis90Percentile", type = DataSourceType.INFORMATIONAL,
274               description = "90th percentile in total time to handle a request, in milliseconds")
275      public double getResponseTime90thPercentile() {
276          return getResponseTimePercentile(Percent.NINETY);
277      }
278      @Monitor(name = "ResponseTimeMillis95Percentile", type = DataSourceType.GAUGE,
279               description = "95th percentile in total time to handle a request, in milliseconds")
280      public double getResponseTime95thPercentile() {
281          return getResponseTimePercentile(Percent.NINETY_FIVE);
282      }
283      @Monitor(name = "ResponseTimeMillis98Percentile", type = DataSourceType.INFORMATIONAL,
284               description = "98th percentile in total time to handle a request, in milliseconds")
285      public double getResponseTime98thPercentile() {
286          return getResponseTimePercentile(Percent.NINETY_EIGHT);
287      }
288      @Monitor(name = "ResponseTimeMillis99Percentile", type = DataSourceType.GAUGE,
289               description = "99th percentile in total time to handle a request, in milliseconds")
290      public double getResponseTime99thPercentile() {
291          return getResponseTimePercentile(Percent.NINETY_NINE);
292      }
293      @Monitor(name = "ResponseTimeMillis99_5Percentile", type = DataSourceType.GAUGE,
294               description = "99.5th percentile in total time to handle a request, in milliseconds")
295      public double getResponseTime99point5thPercentile() {
296          return getResponseTimePercentile(Percent.NINETY_NINE_POINT_FIVE);
297      }
298      public long getTotalRequestsCount() {
299          return totalRequests.get();
300      }
301      private double getResponseTimePercentile(Percent p) {
302          return dataDist.getPercentiles()[p.ordinal()];
303      }
304      public String toString(){
305          StringBuilder sb = new StringBuilder();
306          sb.append("[Server:" + server + ";");
307          sb.append("\tZone:" + server.getZone() + ";");
308          sb.append("\tTotal Requests:" + totalRequests + ";");
309          sb.append("\tSuccessive connection failure:" + getSuccessiveConnectionFailureCount() + ";");
310          if (isCircuitBreakerTripped()) {
311              sb.append("\tBlackout until: " + new Date(getCircuitBreakerTimeout()) + ";");
312          }
313          sb.append("\tTotal blackout seconds:" + totalCircuitBreakerBlackOutPeriod.get() / 1000 + ";");
314          sb.append("\tLast connection made:" + new Date(lastAccessedTimestamp) + ";");
315          if (lastConnectionFailedTimestamp > 0) {
316              sb.append("\tLast connection failure: " + new Date(lastConnectionFailedTimestamp)  + ";");
317          }
318          sb.append("\tFirst connection made: " + new Date(firstConnectionTimestamp)  + ";");
319          sb.append("\tActive Connections:" + getMonitoredActiveRequestsCount()  + ";");
320          sb.append("\ttotal failure count in last (" + failureCountSlidingWindowInterval + ") msecs:" + getFailureCount()  + ";");
321          sb.append("\taverage resp time:" + getResponseTimeAvg()  + ";");
322          sb.append("\t90 percentile resp time:" + getResponseTime90thPercentile()  + ";");
323          sb.append("\t95 percentile resp time:" + getResponseTime95thPercentile()  + ";");
324          sb.append("\tmin resp time:" + getResponseTimeMin()  + ";");
325          sb.append("\tmax resp time:" + getResponseTimeMax()  + ";");
326          sb.append("\tstddev resp time:" + getResponseTimeStdDev());
327          sb.append("]\n");
328          return sb.toString();
329      }
330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-SpringBeanUtil.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ServerStats.java</div>
                </div>
                <div class="column column_space"><pre><code>2  import com.weibo.api.motan.common.URLParamType;
3  import com.weibo.api.motan.config.RegistryConfig;
4  import com.weibo.api.motan.util.LoggerUtil;
5  import org.apache.commons.lang3.StringUtils;
6  import org.springframework.beans.factory.BeanFactory;
7  import java.util.ArrayList;
8  import java.util.List;
9  import java.util.Map;
10  public class SpringBeanUtil {
11      public static final String COMMA_SPLIT_PATTERN = "\\s*[,]+\\s*";
</pre></code></div>
                <div class="column column_space"><pre><code>9  import com.netflix.stats.distribution.DataDistribution;
10  import com.netflix.stats.distribution.DataPublisher;
11  import com.netflix.stats.distribution.Distribution;
12  import com.netflix.util.MeasuredRate;
13  import java.util.Date;
14  import java.util.Random;
15  import java.util.concurrent.atomic.AtomicInteger;
16  import java.util.concurrent.atomic.AtomicLong;
17  public class ServerStats {
18      private static final int DEFAULT_PUBLISH_INTERVAL =  60 * 1000; 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    