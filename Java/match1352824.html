<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for FuturesGetCheckedBenchmark_1.java & ImmutableSortedMultiset_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for FuturesGetCheckedBenchmark_1.java & ImmutableSortedMultiset_1.java
      </h3>
      <h1 align="center">
        5.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>FuturesGetCheckedBenchmark_1.java (10.160428%)<TH>ImmutableSortedMultiset_1.java (3.4926472%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1352824-0.html#0',2,'match1352824-1.html#0',3)" NAME="0">(17-37)<TD><A HREF="javascript:ZweiFrames('match1352824-0.html#0',2,'match1352824-1.html#0',3)" NAME="0">(15-35)</A><TD ALIGN=center><FONT COLOR="#ff0000">19</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FuturesGetCheckedBenchmark_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2015 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="0"></A> * limitations under the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1352824-1.html#0',3,'match1352824-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.util.concurrent;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
import static com.google.common.util.concurrent.Futures.immediateFuture;
import static com.google.common.util.concurrent.FuturesGetChecked.checkExceptionClassValidity;
import static com.google.common.util.concurrent.FuturesGetChecked.getChecked;
import static com.google.common.util.concurrent.FuturesGetChecked.isCheckedException;
import static com.google.common.util.concurrent.FuturesGetChecked.weakSetValidator;

import com.google.caliper.BeforeExperiment;
import com.google.caliper.Benchmark;
import com.google.caliper.Param;
import com.google.common.collect.ImmutableSet;
import com.google.common.util.concurrent.FuturesGetChecked.GetCheckedTypeValidator;
import java.io.IOException;
import java.net.URISyntaxException;
import java.security.GeneralSecurityException;
import java.security.acl.NotOwnerException;
import</B></FONT> java.util.List;
import java.util.TooManyListenersException;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeoutException;
import java.util.prefs.BackingStoreException;
import java.util.prefs.InvalidPreferencesFormatException;
import java.util.zip.DataFormatException;
import javax.security.auth.RefreshFailedException;

/** Microbenchmark for {@link Futures#getChecked}. */
public class FuturesGetCheckedBenchmark {
  private enum Validator {
    NON_CACHING_WITH_CONSTRUCTOR_CHECK(nonCachingWithConstructorCheckValidator()),
    NON_CACHING_WITHOUT_CONSTRUCTOR_CHECK(nonCachingWithoutConstructorCheckValidator()),
    WEAK_SET(weakSetValidator()),
    ;

    final GetCheckedTypeValidator validator;

    Validator(GetCheckedTypeValidator validator) {
      this.validator = validator;
    }
  }

  private enum Result {
    SUCCESS(immediateFuture(new Object())),
    FAILURE(immediateFailedFuture(new Exception()));

    final Future&lt;Object&gt; future;

    Result(Future&lt;Object&gt; result) {
      this.future = result;
    }
  }

  private enum ExceptionType {
    CHECKED(IOException.class),
    UNCHECKED(RuntimeException.class);

    final Class&lt;? extends Exception&gt; exceptionType;

    ExceptionType(Class&lt;? extends Exception&gt; exceptionType) {
      this.exceptionType = exceptionType;
    }
  }

  private static final ImmutableSet&lt;Class&lt;? extends Exception&gt;&gt; OTHER_EXCEPTION_TYPES =
      ImmutableSet.of(
          BackingStoreException.class,
          BrokenBarrierException.class,
          CloneNotSupportedException.class,
          DataFormatException.class,
          ExecutionException.class,
          GeneralSecurityException.class,
          InvalidPreferencesFormatException.class,
          NotOwnerException.class,
          RefreshFailedException.class,
          TimeoutException.class,
          TooManyListenersException.class,
          URISyntaxException.class);

  @Param Validator validator;
  @Param Result result;
  @Param ExceptionType exceptionType;
  /**
   * The number of other exception types in the cache of known-good exceptions and the number of
   * other {@code ClassValue} entries for the exception type to be tested. This lets us evaluate
   * whether our solution scales to use with multiple exception types and to whether it is affected
   * by other {@code ClassValue} users. Some of the benchmarked implementations don't use one or
   * both of these mechanisms, so they will be unaffected.
   */
  @Param({&quot;0&quot;, &quot;1&quot;, &quot;12&quot;})
  int otherEntriesInDataStructure;

  final List&lt;ClassValue&lt;?&gt;&gt; retainedReferencesToOtherClassValues = newArrayList();

  @BeforeExperiment
  void addOtherEntries() throws Exception {
    GetCheckedTypeValidator validator = this.validator.validator;
    Class&lt;? extends Exception&gt; exceptionType = this.exceptionType.exceptionType;

    for (Class&lt;? extends Exception&gt; exceptionClass :
        OTHER_EXCEPTION_TYPES.asList().subList(0, otherEntriesInDataStructure)) {
      getChecked(validator, immediateFuture(&quot;&quot;), exceptionClass);
    }

    for (int i = 0; i &lt; otherEntriesInDataStructure; i++) {
      ClassValue&lt;Boolean&gt; classValue =
          new ClassValue&lt;Boolean&gt;() {
            @Override
            protected Boolean computeValue(Class&lt;?&gt; type) {
              return true;
            }
          };
      classValue.get(exceptionType);
      retainedReferencesToOtherClassValues.add(classValue);
    }
  }

  @Benchmark
  int benchmarkGetChecked(int reps) {
    int tmp = 0;
    GetCheckedTypeValidator validator = this.validator.validator;
    Future&lt;Object&gt; future = this.result.future;
    Class&lt;? extends Exception&gt; exceptionType = this.exceptionType.exceptionType;
    for (int i = 0; i &lt; reps; ++i) {
      try {
        tmp += getChecked(validator, future, exceptionType).hashCode();
      } catch (Exception e) {
        tmp += e.hashCode();
      }
    }
    return tmp;
  }

  private static GetCheckedTypeValidator nonCachingWithoutConstructorCheckValidator() {
    return NonCachingWithoutConstructorCheckValidator.INSTANCE;
  }

  private enum NonCachingWithoutConstructorCheckValidator implements GetCheckedTypeValidator {
    INSTANCE;

    @Override
    public void validateClass(Class&lt;? extends Exception&gt; exceptionClass) {
      checkArgument(
          isCheckedException(exceptionClass),
          &quot;Futures.getChecked exception type (%s) must not be a RuntimeException&quot;,
          exceptionClass);
    }
  }

  private static GetCheckedTypeValidator nonCachingWithConstructorCheckValidator() {
    return NonCachingWithConstructorCheckValidator.INSTANCE;
  }

  private enum NonCachingWithConstructorCheckValidator implements GetCheckedTypeValidator {
    INSTANCE;

    @Override
    public void validateClass(Class&lt;? extends Exception&gt; exceptionClass) {
      checkExceptionClassValidity(exceptionClass);
    }
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableSortedMultiset_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
<A NAME="0"></A> * limitations under the License.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1352824-0.html#0',2,'match1352824-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.GwtIncompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import java.util.function.ToIntFunction;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;
import</B></FONT> org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A {@link SortedMultiset} whose contents will never change, with many other important properties
 * detailed at {@link ImmutableCollection}.
 *
 * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; as with any sorted collection, you are strongly advised not to use a {@link
 * Comparator} or {@link Comparable} type whose comparison behavior is &lt;i&gt;inconsistent with
 * equals&lt;/i&gt;. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero
 * &lt;i&gt;if and only if&lt;/i&gt; {@code a.equals(b)}. If this advice is not followed, the resulting
 * collection will not correctly obey its specification.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * &quot;https://github.com/google/guava/wiki/ImmutableCollectionsExplained&quot;&gt;immutable collections&lt;/a&gt;.
 *
 * @author Louis Wasserman
 * @since 12.0
 */
@GwtIncompatible // hasn't been tested yet
@ElementTypesAreNonnullByDefault
public abstract class ImmutableSortedMultiset&lt;E&gt; extends ImmutableSortedMultisetFauxverideShim&lt;E&gt;
    implements SortedMultiset&lt;E&gt; {
  // TODO(lowasser): GWT compatibility

  /**
   * Returns a {@code Collector} that accumulates the input elements into a new {@code
   * ImmutableMultiset}. Elements are sorted by the specified comparator.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; {@code comparator} should be &lt;i&gt;consistent with {@code equals}&lt;/i&gt; as
   * explained in the {@link Comparator} documentation.
   *
   * @since 21.0
   */
  public static &lt;E&gt; Collector&lt;E, ?, ImmutableSortedMultiset&lt;E&gt;&gt; toImmutableSortedMultiset(
      Comparator&lt;? super E&gt; comparator) {
    return toImmutableSortedMultiset(comparator, Function.identity(), e -&gt; 1);
  }

  /**
   * Returns a {@code Collector} that accumulates elements into an {@code ImmutableSortedMultiset}
   * whose elements are the result of applying {@code elementFunction} to the inputs, with counts
   * equal to the result of applying {@code countFunction} to the inputs.
   *
   * &lt;p&gt;If the mapped elements contain duplicates (according to {@code comparator}), the first
   * occurrence in encounter order appears in the resulting multiset, with count equal to the sum of
   * the outputs of {@code countFunction.applyAsInt(t)} for each {@code t} mapped to that element.
   *
   * @since 22.0
   */
  public static &lt;T extends @Nullable Object, E&gt;
      Collector&lt;T, ?, ImmutableSortedMultiset&lt;E&gt;&gt; toImmutableSortedMultiset(
          Comparator&lt;? super E&gt; comparator,
          Function&lt;? super T, ? extends E&gt; elementFunction,
          ToIntFunction&lt;? super T&gt; countFunction) {
    checkNotNull(comparator);
    checkNotNull(elementFunction);
    checkNotNull(countFunction);
    return Collector.of(
        () -&gt; TreeMultiset.create(comparator),
        (multiset, t) -&gt;
            multiset.add(checkNotNull(elementFunction.apply(t)), countFunction.applyAsInt(t)),
        (multiset1, multiset2) -&gt; {
          multiset1.addAll(multiset2);
          return multiset1;
        },
        (Multiset&lt;E&gt; multiset) -&gt; copyOfSortedEntries(comparator, multiset.entrySet()));
  }

  /**
   * Returns the empty immutable sorted multiset.
   *
   * &lt;p&gt;&lt;b&gt;Performance note:&lt;/b&gt; the instance returned is a singleton.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E&gt; ImmutableSortedMultiset&lt;E&gt; of() {
    return (ImmutableSortedMultiset) RegularImmutableSortedMultiset.NATURAL_EMPTY_MULTISET;
  }

  /** Returns an immutable sorted multiset containing a single element. */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; of(E element) {
    RegularImmutableSortedSet&lt;E&gt; elementSet =
        (RegularImmutableSortedSet&lt;E&gt;) ImmutableSortedSet.of(element);
    long[] cumulativeCounts = {0, 1};
    return new RegularImmutableSortedMultiset&lt;E&gt;(elementSet, cumulativeCounts, 0, 1);
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * @throws NullPointerException if any element is null
   */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; of(E e1, E e2) {
    return copyOf(Ordering.natural(), Arrays.asList(e1, e2));
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * @throws NullPointerException if any element is null
   */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; of(E e1, E e2, E e3) {
    return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3));
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * @throws NullPointerException if any element is null
   */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; of(
      E e1, E e2, E e3, E e4) {
    return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3, e4));
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * @throws NullPointerException if any element is null
   */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5) {
    return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3, e4, e5));
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * @throws NullPointerException if any element is null
   */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
    int size = remaining.length + 6;
    List&lt;E&gt; all = Lists.newArrayListWithCapacity(size);
    Collections.addAll(all, e1, e2, e3, e4, e5, e6);
    Collections.addAll(all, remaining);
    return copyOf(Ordering.natural(), all);
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * @throws NullPointerException if any of {@code elements} is null
   */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedMultiset&lt;E&gt; copyOf(E[] elements) {
    return copyOf(Ordering.natural(), Arrays.asList(elements));
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering. To create a copy of a {@code SortedMultiset} that preserves the comparator, call
   * {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.
   *
   * &lt;p&gt;Note that if {@code s} is a {@code Multiset&lt;String&gt;}, then {@code
   * ImmutableSortedMultiset.copyOf(s)} returns an {@code ImmutableSortedMultiset&lt;String&gt;}
   * containing each of the strings in {@code s}, while {@code ImmutableSortedMultiset.of(s)}
   * returns an {@code ImmutableSortedMultiset&lt;Multiset&lt;String&gt;&gt;} containing one element (the given
   * multiset itself).
   *
   * &lt;p&gt;Despite the method name, this method attempts to avoid actually copying the data when it is
   * safe to do so. The exact circumstances under which a copy will or will not be performed are
   * undocumented and subject to change.
   *
   * &lt;p&gt;This method is not type-safe, as it may be called on elements that are not mutually
   * comparable.
   *
   * @throws ClassCastException if the elements are not mutually comparable
   * @throws NullPointerException if any of {@code elements} is null
   */
  public static &lt;E&gt; ImmutableSortedMultiset&lt;E&gt; copyOf(Iterable&lt;? extends E&gt; elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedMultisetFauxverideShim.
    @SuppressWarnings(&quot;unchecked&quot;)
    Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by their natural
   * ordering.
   *
   * &lt;p&gt;This method is not type-safe, as it may be called on elements that are not mutually
   * comparable.
   *
   * @throws ClassCastException if the elements are not mutually comparable
   * @throws NullPointerException if any of {@code elements} is null
   */
  public static &lt;E&gt; ImmutableSortedMultiset&lt;E&gt; copyOf(Iterator&lt;? extends E&gt; elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedMultisetFauxverideShim.
    @SuppressWarnings(&quot;unchecked&quot;)
    Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by the given {@code
   * Comparator}.
   *
   * @throws NullPointerException if {@code comparator} or any of {@code elements} is null
   */
  public static &lt;E&gt; ImmutableSortedMultiset&lt;E&gt; copyOf(
      Comparator&lt;? super E&gt; comparator, Iterator&lt;? extends E&gt; elements) {
    checkNotNull(comparator);
    return new Builder&lt;E&gt;(comparator).addAll(elements).build();
  }

  /**
   * Returns an immutable sorted multiset containing the given elements sorted by the given {@code
   * Comparator}. This method iterates over {@code elements} at most once.
   *
   * &lt;p&gt;Despite the method name, this method attempts to avoid actually copying the data when it is
   * safe to do so. The exact circumstances under which a copy will or will not be performed are
   * undocumented and subject to change.
   *
   * @throws NullPointerException if {@code comparator} or any of {@code elements} is null
   */
  public static &lt;E&gt; ImmutableSortedMultiset&lt;E&gt; copyOf(
      Comparator&lt;? super E&gt; comparator, Iterable&lt;? extends E&gt; elements) {
    if (elements instanceof ImmutableSortedMultiset) {
      @SuppressWarnings(&quot;unchecked&quot;) // immutable collections are always safe for covariant casts
      ImmutableSortedMultiset&lt;E&gt; multiset = (ImmutableSortedMultiset&lt;E&gt;) elements;
      if (comparator.equals(multiset.comparator())) {
        if (multiset.isPartialView()) {
          return copyOfSortedEntries(comparator, multiset.entrySet().asList());
        } else {
          return multiset;
        }
      }
    }
    elements = Lists.newArrayList(elements); // defensive copy
    TreeMultiset&lt;E&gt; sortedCopy = TreeMultiset.create(checkNotNull(comparator));
    Iterables.addAll(sortedCopy, elements);
    return copyOfSortedEntries(comparator, sortedCopy.entrySet());
  }

  /**
   * Returns an immutable sorted multiset containing the elements of a sorted multiset, sorted by
   * the same {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always
   * uses the natural ordering of the elements.
   *
   * &lt;p&gt;Despite the method name, this method attempts to avoid actually copying the data when it is
   * safe to do so. The exact circumstances under which a copy will or will not be performed are
   * undocumented and subject to change.
   *
   * &lt;p&gt;This method is safe to use even when {@code sortedMultiset} is a synchronized or concurrent
   * collection that is currently being modified by another thread.
   *
   * @throws NullPointerException if {@code sortedMultiset} or any of its elements is null
   */
  public static &lt;E&gt; ImmutableSortedMultiset&lt;E&gt; copyOfSorted(SortedMultiset&lt;E&gt; sortedMultiset) {
    return copyOfSortedEntries(
        sortedMultiset.comparator(), Lists.newArrayList(sortedMultiset.entrySet()));
  }

  private static &lt;E&gt; ImmutableSortedMultiset&lt;E&gt; copyOfSortedEntries(
      Comparator&lt;? super E&gt; comparator, Collection&lt;Entry&lt;E&gt;&gt; entries) {
    if (entries.isEmpty()) {
      return emptyMultiset(comparator);
    }
    ImmutableList.Builder&lt;E&gt; elementsBuilder = new ImmutableList.Builder&lt;E&gt;(entries.size());
    long[] cumulativeCounts = new long[entries.size() + 1];
    int i = 0;
    for (Entry&lt;E&gt; entry : entries) {
      elementsBuilder.add(entry.getElement());
      cumulativeCounts[i + 1] = cumulativeCounts[i] + entry.getCount();
      i++;
    }
    return new RegularImmutableSortedMultiset&lt;E&gt;(
        new RegularImmutableSortedSet&lt;E&gt;(elementsBuilder.build(), comparator),
        cumulativeCounts,
        0,
        entries.size());
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  static &lt;E&gt; ImmutableSortedMultiset&lt;E&gt; emptyMultiset(Comparator&lt;? super E&gt; comparator) {
    if (Ordering.natural().equals(comparator)) {
      return (ImmutableSortedMultiset&lt;E&gt;) RegularImmutableSortedMultiset.NATURAL_EMPTY_MULTISET;
    } else {
      return new RegularImmutableSortedMultiset&lt;E&gt;(comparator);
    }
  }

  ImmutableSortedMultiset() {}

  @Override
  public final Comparator&lt;? super E&gt; comparator() {
    return elementSet().comparator();
  }

  @Override
  public abstract ImmutableSortedSet&lt;E&gt; elementSet();

  @LazyInit @CheckForNull transient ImmutableSortedMultiset&lt;E&gt; descendingMultiset;

  @Override
  public ImmutableSortedMultiset&lt;E&gt; descendingMultiset() {
    ImmutableSortedMultiset&lt;E&gt; result = descendingMultiset;
    if (result == null) {
      return descendingMultiset =
          this.isEmpty()
              ? emptyMultiset(Ordering.from(comparator()).reverse())
              : new DescendingImmutableSortedMultiset&lt;E&gt;(this);
    }
    return result;
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;This implementation is guaranteed to throw an {@link UnsupportedOperationException}.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @CanIgnoreReturnValue
  @Deprecated
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  @CheckForNull
  public final Entry&lt;E&gt; pollFirstEntry() {
    throw new UnsupportedOperationException();
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;This implementation is guaranteed to throw an {@link UnsupportedOperationException}.
   *
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @CanIgnoreReturnValue
  @Deprecated
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  @CheckForNull
  public final Entry&lt;E&gt; pollLastEntry() {
    throw new UnsupportedOperationException();
  }

  @Override
  public abstract ImmutableSortedMultiset&lt;E&gt; headMultiset(E upperBound, BoundType boundType);

  @Override
  public ImmutableSortedMultiset&lt;E&gt; subMultiset(
      E lowerBound, BoundType lowerBoundType, E upperBound, BoundType upperBoundType) {
    checkArgument(
        comparator().compare(lowerBound, upperBound) &lt;= 0,
        &quot;Expected lowerBound &lt;= upperBound but %s &gt; %s&quot;,
        lowerBound,
        upperBound);
    return tailMultiset(lowerBound, lowerBoundType).headMultiset(upperBound, upperBoundType);
  }

  @Override
  public abstract ImmutableSortedMultiset&lt;E&gt; tailMultiset(E lowerBound, BoundType boundType);

  /**
   * Returns a builder that creates immutable sorted multisets with an explicit comparator. If the
   * comparator has a more general type than the set being generated, such as creating a {@code
   * SortedMultiset&lt;Integer&gt;} with a {@code Comparator&lt;Number&gt;}, use the {@link Builder} constructor
   * instead.
   *
   * @throws NullPointerException if {@code comparator} is null
   */
  public static &lt;E&gt; Builder&lt;E&gt; orderedBy(Comparator&lt;E&gt; comparator) {
    return new Builder&lt;E&gt;(comparator);
  }

  /**
   * Returns a builder that creates immutable sorted multisets whose elements are ordered by the
   * reverse of their natural ordering.
   *
   * &lt;p&gt;Note: the type parameter {@code E} extends {@code Comparable&lt;?&gt;} rather than {@code
   * Comparable&lt;? super E&gt;} as a workaround for javac &lt;a
   * href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354&quot;&gt;bug 6468354&lt;/a&gt;.
   */
  public static &lt;E extends Comparable&lt;?&gt;&gt; Builder&lt;E&gt; reverseOrder() {
    return new Builder&lt;E&gt;(Ordering.natural().reverse());
  }

  /**
   * Returns a builder that creates immutable sorted multisets whose elements are ordered by their
   * natural ordering. The sorted multisets use {@link Ordering#natural()} as the comparator. This
   * method provides more type-safety than {@link #builder}, as it can be called only for classes
   * that implement {@link Comparable}.
   *
   * &lt;p&gt;Note: the type parameter {@code E} extends {@code Comparable&lt;?&gt;} rather than {@code
   * Comparable&lt;? super E&gt;} as a workaround for javac &lt;a
   * href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354&quot;&gt;bug 6468354&lt;/a&gt;.
   */
  public static &lt;E extends Comparable&lt;?&gt;&gt; Builder&lt;E&gt; naturalOrder() {
    return new Builder&lt;E&gt;(Ordering.natural());
  }

  /**
   * A builder for creating immutable multiset instances, especially {@code public static final}
   * multisets (&quot;constant multisets&quot;). Example:
   *
   * &lt;pre&gt;{@code
   * public static final ImmutableSortedMultiset&lt;Bean&gt; BEANS =
   *     new ImmutableSortedMultiset.Builder&lt;Bean&gt;(colorComparator())
   *         .addCopies(Bean.COCOA, 4)
   *         .addCopies(Bean.GARDEN, 6)
   *         .addCopies(Bean.RED, 8)
   *         .addCopies(Bean.BLACK_EYED, 10)
   *         .build();
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;Builder instances can be reused; it is safe to call {@link #build} multiple times to build
   * multiple multisets in series.
   *
   * @since 12.0
   */
  public static class Builder&lt;E&gt; extends ImmutableMultiset.Builder&lt;E&gt; {
    /**
     * Creates a new builder. The returned builder is equivalent to the builder generated by {@link
     * ImmutableSortedMultiset#orderedBy(Comparator)}.
     */
    public Builder(Comparator&lt;? super E&gt; comparator) {
      super(TreeMultiset.&lt;E&gt;create(checkNotNull(comparator)));
    }

    /**
     * Adds {@code element} to the {@code ImmutableSortedMultiset}.
     *
     * @param element the element to add
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code element} is null
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E element) {
      super.add(element);
      return this;
    }

    /**
     * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.
     *
     * @param elements the elements to add
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code elements} is null or contains a null element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E... elements) {
      super.add(elements);
      return this;
    }

    /**
     * Adds a number of occurrences of an element to this {@code ImmutableSortedMultiset}.
     *
     * @param element the element to add
     * @param occurrences the number of occurrences of the element to add. May be zero, in which
     *     case no change will be made.
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code element} is null
     * @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation
     *     would result in more than {@link Integer#MAX_VALUE} occurrences of the element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addCopies(E element, int occurrences) {
      super.addCopies(element, occurrences);
      return this;
    }

    /**
     * Adds or removes the necessary occurrences of an element such that the element attains the
     * desired count.
     *
     * @param element the element to add or remove occurrences of
     * @param count the desired count of the element in this multiset
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code element} is null
     * @throws IllegalArgumentException if {@code count} is negative
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; setCount(E element, int count) {
      super.setCount(element, count);
      return this;
    }

    /**
     * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.
     *
     * @param elements the {@code Iterable} to add to the {@code ImmutableSortedMultiset}
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code elements} is null or contains a null element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterable&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }

    /**
     * Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.
     *
     * @param elements the elements to add to the {@code ImmutableSortedMultiset}
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code elements} is null or contains a null element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }

    /**
     * Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code
     * Builder}.
     */
    @Override
    public ImmutableSortedMultiset&lt;E&gt; build() {
      return copyOfSorted((SortedMultiset&lt;E&gt;) contents);
    }
  }

  private static final class SerializedForm&lt;E&gt; implements Serializable {
    final Comparator&lt;? super E&gt; comparator;
    final E[] elements;
    final int[] counts;

    @SuppressWarnings(&quot;unchecked&quot;)
    SerializedForm(SortedMultiset&lt;E&gt; multiset) {
      this.comparator = multiset.comparator();
      int n = multiset.entrySet().size();
      elements = (E[]) new Object[n];
      counts = new int[n];
      int i = 0;
      for (Entry&lt;E&gt; entry : multiset.entrySet()) {
        elements[i] = entry.getElement();
        counts[i] = entry.getCount();
        i++;
      }
    }

    Object readResolve() {
      int n = elements.length;
      Builder&lt;E&gt; builder = new Builder&lt;&gt;(comparator);
      for (int i = 0; i &lt; n; i++) {
        builder.addCopies(elements[i], counts[i]);
      }
      return builder.build();
    }
  }

  @Override
  Object writeReplace() {
    return new SerializedForm&lt;E&gt;(this);
  }
}
</PRE>
</div>
  </div>
</body>
</html>
