<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for NodeService.java &amp; JobLauncher.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for NodeService.java &amp; JobLauncher.java
      </h3>
<h1 align="center">
        5.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>NodeService.java (22.64151%)<th>JobLauncher.java (3.0769231%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-36)<td><a href="#" name="0">(54-103)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>NodeService.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package org.elasticsearch.node;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;
4 import io.crate.common.io.IOUtils;
5 import org.elasticsearch.indices.IndicesService;
6 import org.elasticsearch.monitor.MonitorService;
7 import org.elasticsearch.transport.TransportService;
8 import java.io.Closeable;
9 import java.io.IOException;
10 import java.util.concurrent.TimeUnit;
11 public class NodeService implements Closeable {
12     private final MonitorService monitorService;
13     private final IndicesService indicesService;
14     private final TransportService transportService</b></font>;
15     NodeService(MonitorService monitorService, IndicesService indicesService, TransportService transportService) {
16         this.monitorService = monitorService;
17         this.indicesService = indicesService;
18         this.transportService = transportService;
19     }
20     public MonitorService getMonitorService() {
21         return monitorService;
22     }
23     @Override
24     public void close() throws IOException {
25         IOUtils.close(indicesService);
26     }
27     public NodeStats stats() {
28         return new NodeStats(transportService.getLocalNode(), System.currentTimeMillis(), monitorService.fsService().stats());
29     }
30     public boolean awaitClose(long timeout, TimeUnit timeUnit) throws InterruptedException {
31         return indicesService.awaitClose(timeout, timeUnit);
32     }
33 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>JobLauncher.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.crate.execution.engine;
2 import io.crate.concurrent.CompletableFutures;
3 import io.crate.data.CollectingRowConsumer;
4 import io.crate.data.RowConsumer;
5 import io.crate.execution.dsl.phases.ExecutionPhase;
6 import io.crate.execution.dsl.phases.ExecutionPhases;
7 import io.crate.execution.dsl.phases.NodeOperation;
8 import io.crate.execution.dsl.phases.NodeOperationGrouper;
9 import io.crate.execution.dsl.phases.NodeOperationTree;
10 import io.crate.execution.engine.distribution.StreamBucket;
11 import io.crate.execution.jobs.DownstreamRXTask;
12 import io.crate.execution.jobs.InstrumentedIndexSearcher;
13 import io.crate.execution.jobs.JobSetup;
14 import io.crate.execution.jobs.PageBucketReceiver;
15 import io.crate.execution.jobs.RootTask;
16 import io.crate.execution.jobs.SharedShardContexts;
17 import io.crate.execution.jobs.Task;
18 import io.crate.execution.jobs.TasksService;
19 import io.crate.execution.jobs.kill.TransportKillJobsNodeAction;
20 import io.crate.execution.jobs.transport.JobRequest;
21 import io.crate.execution.jobs.transport.TransportJobAction;
22 import io.crate.metadata.TransactionContext;
23 import io.crate.profile.ProfilingContext;
24 import org.elasticsearch.cluster.service.ClusterService;
25 import io.crate.common.collections.Tuple;
26 import org.elasticsearch.indices.IndicesService;
27 import org.elasticsearch.search.profile.query.QueryProfiler;
28 <a name="0"></a>import java.util.ArrayList;
29 import java.util.Collection;
30 import java.util.Collections;
31 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.List;
32 import java.util.ListIterator;
33 import java.util.Map;
34 import java.util.UUID;
35 import java.util.concurrent.CompletableFuture;
36 import java.util.concurrent.Executor;
37 import java.util.function.UnaryOperator;
38 import java.util.stream.Collectors;
39 public final class JobLauncher {
40     private final TransportJobAction transportJobAction;
41     private final TransportKillJobsNodeAction transportKillJobsNodeAction;
42     private final List&lt;NodeOperationTree&gt; nodeOperationTrees</b></font>;
43     private final UUID jobId;
44     private final ClusterService clusterService;
45     private final JobSetup jobSetup;
46     private final TasksService tasksService;
47     private final IndicesService indicesService;
48     private final boolean enableProfiling;
49     private final Executor executor;
50     private boolean hasDirectResponse;
51     JobLauncher(UUID jobId,
52                 ClusterService clusterService,
53                 JobSetup jobSetup,
54                 TasksService tasksService,
55                 IndicesService indicesService,
56                 TransportJobAction transportJobAction,
57                 TransportKillJobsNodeAction transportKillJobsNodeAction,
58                 List&lt;NodeOperationTree&gt; nodeOperationTrees,
59                 boolean enableProfiling,
60                 Executor executor) {
61         this.jobId = jobId;
62         this.clusterService = clusterService;
63         this.jobSetup = jobSetup;
64         this.tasksService = tasksService;
65         this.indicesService = indicesService;
66         this.transportJobAction = transportJobAction;
67         this.transportKillJobsNodeAction = transportKillJobsNodeAction;
68         this.nodeOperationTrees = nodeOperationTrees;
69         this.enableProfiling = enableProfiling;
70         this.executor = executor;
71         for (NodeOperationTree nodeOperationTree : nodeOperationTrees) {
72             for (NodeOperation nodeOperation : nodeOperationTree.nodeOperations()) {
73                 if (ExecutionPhases.hasDirectResponseDownstream(nodeOperation.downstreamNodes())) {
74                     hasDirectResponse = true;
75                     break;
76                 }
77             }
78         }
79     }
80     public void execute(RowConsumer consumer, TransactionContext txnCtx) {
81         assert nodeOperationTrees.size() == 1 : "must only have 1 NodeOperationTree for non-bulk operations";
82         NodeOperationTree nodeOperationTree = nodeOperationTrees.get(0);
83         Map&lt;String, Collection&lt;NodeOperation&gt;&gt; operationByServer = NodeOperationGrouper.groupByServer(nodeOperationTree.nodeOperations());
84         List&lt;ExecutionPhase&gt; handlerPhases = Collections.singletonList(nodeOperationTree.leaf());
85         List&lt;RowConsumer&gt; handlerConsumers = Collections.singletonList(consumer);
86         try {
87             setupTasks(txnCtx, operationByServer, handlerPhases, handlerConsumers);
88         } catch (Throwable throwable) {
89             consumer.accept(null, throwable);
90         }
91     }
92     public List&lt;CompletableFuture&lt;Long&gt;&gt; executeBulk(TransactionContext txnCtx) {
93         Iterable&lt;NodeOperation&gt; nodeOperations = nodeOperationTrees.stream()
94             .flatMap(opTree -&gt; opTree.nodeOperations().stream())
95             ::iterator;
96         Map&lt;String, Collection&lt;NodeOperation&gt;&gt; operationByServer = NodeOperationGrouper.groupByServer(nodeOperations);
97         List&lt;ExecutionPhase&gt; handlerPhases = new ArrayList&lt;&gt;(nodeOperationTrees.size());
98         List&lt;RowConsumer&gt; handlerConsumers = new ArrayList&lt;&gt;(nodeOperationTrees.size());
99         List&lt;CompletableFuture&lt;Long&gt;&gt; results = new ArrayList&lt;&gt;(nodeOperationTrees.size());
100         for (NodeOperationTree nodeOperationTree : nodeOperationTrees) {
101             CollectingRowConsumer&lt;?, Long&gt; consumer = new CollectingRowConsumer&lt;&gt;(
102                 Collectors.collectingAndThen(Collectors.summingLong(r -&gt; ((long) r.get(0))), sum -&gt; sum));
103             handlerConsumers.add(consumer);
104             results.add(consumer.completionFuture());
105             handlerPhases.add(nodeOperationTree.leaf());
106         }
107         try {
108             setupTasks(txnCtx, operationByServer, handlerPhases, handlerConsumers);
109         } catch (Throwable throwable) {
110             return Collections.singletonList(CompletableFuture.failedFuture(throwable));
111         }
112         return results;
113     }
114     private void setupTasks(TransactionContext txnCtx,
115                             Map&lt;String, Collection&lt;NodeOperation&gt;&gt; operationByServer,
116                             List&lt;ExecutionPhase&gt; handlerPhases,
117                             List&lt;RowConsumer&gt; handlerConsumers) throws Throwable {
118         assert handlerPhases.size() == handlerConsumers.size() : "handlerPhases size must match handlerConsumers size";
119         String localNodeId = clusterService.localNode().getId();
120         Collection&lt;NodeOperation&gt; localNodeOperations = operationByServer.remove(localNodeId);
121         if (localNodeOperations == null) {
122             localNodeOperations = Collections.emptyList();
123         }
124         InitializationTracker initializationTracker = new InitializationTracker(operationByServer.size() + 1);
125         List&lt;Tuple&lt;ExecutionPhase, RowConsumer&gt;&gt; handlerPhaseAndReceiver = createHandlerPhaseAndReceivers(
126             handlerPhases, handlerConsumers, initializationTracker);
127         RootTask.Builder builder = tasksService.newBuilder(
128             jobId,
129             txnCtx.sessionSettings().userName(),
130             localNodeId,
131             operationByServer.keySet()
132         );
133         SharedShardContexts sharedShardContexts = maybeInstrumentProfiler(builder);
134         List&lt;CompletableFuture&lt;StreamBucket&gt;&gt; directResponseFutures = jobSetup.prepareOnHandler(
135             txnCtx.sessionSettings(),
136             localNodeOperations,
137             builder,
138             handlerPhaseAndReceiver,
139             sharedShardContexts);
140         RootTask localTask = tasksService.createTask(builder);
141         List&lt;PageBucketReceiver&gt; pageBucketReceivers = getHandlerBucketReceivers(localTask, handlerPhaseAndReceiver);
142         int bucketIdx = 0;
143         /*
144          * If you touch anything here make sure the following tests pass with &gt; 1k iterations:
145          *
146          * Seed: 112E1807417E925A - testInvalidPatternSyntax
147          * Seed: Any              - testRegularSelectWithFewAvailableThreadsShouldNeverGetStuck
148          * Seed: CC456FF5004F35D3 - testFailureOfJoinDownstream
149          */
150         if (!localNodeOperations.isEmpty() &amp;&amp; !directResponseFutures.isEmpty()) {
151             assert directResponseFutures.size() == pageBucketReceivers.size() : "directResponses size must match pageBucketReceivers";
152             CompletableFutures.allAsList(directResponseFutures)
153                 .whenComplete(BucketForwarder.asConsumer(pageBucketReceivers, bucketIdx, initializationTracker));
154             bucketIdx++;
155             try {
156                 localTask.start();
157             } catch (Throwable t) {
158                 accountFailureForRemoteOperations(operationByServer, initializationTracker, handlerPhaseAndReceiver, t);
159                 return;
160             }
161         } else {
162             try {
163                 localTask.start();
164                 initializationTracker.jobInitialized();
165             } catch (Throwable t) {
166                 initializationTracker.jobInitializationFailed(t);
167                 accountFailureForRemoteOperations(operationByServer, initializationTracker, handlerPhaseAndReceiver, t);
168                 return;
169             }
170         }
171         sendJobRequests(
172             txnCtx,
173             localNodeId,
174             operationByServer,
175             pageBucketReceivers,
176             handlerPhaseAndReceiver,
177             bucketIdx,
178             initializationTracker
179         );
180     }
181     private SharedShardContexts maybeInstrumentProfiler(RootTask.Builder builder) {
182         if (enableProfiling) {
183             var profilers = new ArrayList&lt;QueryProfiler&gt;();
184             ProfilingContext profilingContext = new ProfilingContext(profilers);
185             builder.profilingContext(profilingContext);
186             return new SharedShardContexts(
187                 indicesService,
188                 indexSearcher -&gt; {
189                     var queryProfiler = new QueryProfiler();
190                     profilers.add(queryProfiler);
191                     return new InstrumentedIndexSearcher(indexSearcher, queryProfiler);
192                 }
193             );
194         } else {
195             return new SharedShardContexts(indicesService, UnaryOperator.identity());
196         }
197     }
198     private void accountFailureForRemoteOperations(Map&lt;String, Collection&lt;NodeOperation&gt;&gt; operationByServer,
199                                                    InitializationTracker initializationTracker,
200                                                    List&lt;Tuple&lt;ExecutionPhase, RowConsumer&gt;&gt; handlerPhaseAndReceiver,
201                                                    Throwable t) {
202         for (Tuple&lt;ExecutionPhase, RowConsumer&gt; executionPhaseRowReceiverTuple : handlerPhaseAndReceiver) {
203             executionPhaseRowReceiverTuple.v2().accept(null, t);
204         }
205         for (int i = 0; i &lt; operationByServer.size() + 1; i++) {
206             initializationTracker.jobInitializationFailed(t);
207         }
208     }
209     private List&lt;Tuple&lt;ExecutionPhase, RowConsumer&gt;&gt; createHandlerPhaseAndReceivers(List&lt;ExecutionPhase&gt; handlerPhases,
210                                                                                          List&lt;RowConsumer&gt; handlerReceivers,
211                                                                                          InitializationTracker initializationTracker) {
212         List&lt;Tuple&lt;ExecutionPhase, RowConsumer&gt;&gt; handlerPhaseAndReceiver = new ArrayList&lt;&gt;();
213         ListIterator&lt;RowConsumer&gt; consumerIt = handlerReceivers.listIterator();
214         for (ExecutionPhase handlerPhase : handlerPhases) {
215             InterceptingRowConsumer interceptingBatchConsumer = new InterceptingRowConsumer(
216                 jobId,
217                 consumerIt.next(),
218                 initializationTracker,
219                 executor,
220                 transportKillJobsNodeAction
221             );
222             handlerPhaseAndReceiver.add(new Tuple&lt;&gt;(handlerPhase, interceptingBatchConsumer));
223         }
224         return handlerPhaseAndReceiver;
225     }
226     private void sendJobRequests(TransactionContext txnCtx,
227                                  String localNodeId,
228                                  Map&lt;String, Collection&lt;NodeOperation&gt;&gt; operationByServer,
229                                  List&lt;PageBucketReceiver&gt; pageBucketReceivers,
230                                  List&lt;Tuple&lt;ExecutionPhase, RowConsumer&gt;&gt; handlerPhases,
231                                  int bucketIdx,
232                                  InitializationTracker initializationTracker) {
233         for (Map.Entry&lt;String, Collection&lt;NodeOperation&gt;&gt; entry : operationByServer.entrySet()) {
234             String serverNodeId = entry.getKey();
235             JobRequest request = new JobRequest(
236                 jobId,
237                 txnCtx.sessionSettings(),
238                 localNodeId,
239                 entry.getValue(),
240                 enableProfiling);
241             if (hasDirectResponse) {
242                 transportJobAction.execute(serverNodeId, request,
243                     BucketForwarder.asActionListener(pageBucketReceivers, bucketIdx, initializationTracker));
244             } else {
245                 transportJobAction.execute(serverNodeId, request, new FailureOnlyResponseListener(handlerPhases, initializationTracker));
246             }
247             bucketIdx++;
248         }
249     }
250     private List&lt;PageBucketReceiver&gt; getHandlerBucketReceivers(RootTask rootTask,
251                                                                List&lt;Tuple&lt;ExecutionPhase, RowConsumer&gt;&gt; handlerPhases) {
252         final List&lt;PageBucketReceiver&gt; pageBucketReceivers = new ArrayList&lt;&gt;(handlerPhases.size());
253         for (Tuple&lt;ExecutionPhase, ?&gt; handlerPhase : handlerPhases) {
254             Task ctx = rootTask.getTaskOrNull(handlerPhase.v1().phaseId());
255             if (ctx instanceof DownstreamRXTask) {
256                 PageBucketReceiver pageBucketReceiver = ((DownstreamRXTask) ctx).getBucketReceiver((byte) 0);
257                 pageBucketReceivers.add(pageBucketReceiver);
258             }
259         }
260         return pageBucketReceivers;
261     }
262 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
