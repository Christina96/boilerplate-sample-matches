
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RestClient.java</h3>
            <pre><code>1  package com.netflix.niws.client.http;
2  import java.io.File;
3  import java.net.SocketException;
4  import java.net.SocketTimeoutException;
5  import java.net.URI;
6  import java.net.URISyntaxException;
7  import java.net.URL;
8  import java.net.URLDecoder;
9  import java.security.KeyStore;
10  import java.util.Collection;
11  import java.util.Map;
12  import java.util.Optional;
13  import com.netflix.client.config.Property;
14  import org.apache.http.HttpHost;
15  import org.apache.http.client.HttpClient;
16  import org.apache.http.client.UserTokenHandler;
17  import org.apache.http.conn.ClientConnectionManager;
18  import org.apache.http.conn.params.ConnRouteParams;
19  import org.apache.http.conn.scheme.Scheme;
20  import org.apache.http.conn.scheme.SchemeRegistry;
21  import org.apache.http.conn.scheme.SchemeSocketFactory;
22  import org.apache.http.conn.ssl.SSLSocketFactory;
23  import org.apache.http.impl.client.AbstractHttpClient;
24  import org.apache.http.impl.client.BasicCookieStore;
25  import org.apache.http.impl.client.DefaultHttpClient;
26  import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
27  import org.apache.http.params.HttpConnectionParams;
28  import org.apache.http.params.HttpParams;
29  import org.apache.http.protocol.HttpContext;
30  import org.slf4j.Logger;
31  import org.slf4j.LoggerFactory;
32  import com.netflix.client.AbstractLoadBalancerAwareClient;
33  import com.netflix.client.ClientException;
34  import com.netflix.client.ClientFactory;
35  import com.netflix.client.RequestSpecificRetryHandler;
36  import com.netflix.client.config.CommonClientConfigKey;
37  import com.netflix.client.config.IClientConfig;
38  import com.netflix.client.config.IClientConfigKey;
39  import com.netflix.client.http.HttpRequest;
40  import com.netflix.client.http.HttpResponse;
41  import com.netflix.client.ssl.AbstractSslContextFactory;
42  import com.netflix.client.ssl.ClientSslSocketFactoryException;
43  import com.netflix.client.ssl.URLSslContextFactory;
44  import com.netflix.http4.NFHttpClient;
45  import com.netflix.http4.NFHttpClientFactory;
46  import com.netflix.http4.NFHttpMethodRetryHandler;
47  import com.netflix.http4.ssl.KeyStoreAwareSocketFactory;
48  import com.netflix.loadbalancer.BaseLoadBalancer;
49  import com.netflix.loadbalancer.ILoadBalancer;
50  import com.netflix.util.Pair;
51  import com.sun.jersey.api.client.Client;
52  import com.sun.jersey.api.client.ClientResponse;
53  import com.sun.jersey.api.client.WebResource;
54  import com.sun.jersey.api.client.WebResource.Builder;
55  import com.sun.jersey.client.apache4.ApacheHttpClient4;
56  import com.sun.jersey.client.apache4.ApacheHttpClient4Handler;
57  import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
58  import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
59  @Deprecated
60  public class RestClient extends AbstractLoadBalancerAwareClient&lt;HttpRequest, HttpResponse&gt; {
61      private static IClientConfigKey&lt;Integer&gt; CONN_IDLE_EVICT_TIME_MILLIS = new CommonClientConfigKey&lt;Integer&gt;(
62              &quot;%s.nfhttpclient.connIdleEvictTimeMilliSeconds&quot;) {};
63      private Client restClient;
64      private HttpClient httpClient4;
65      private IClientConfig ncc;
66      private String restClientName;
67      private boolean enableConnectionPoolCleanerTask = false;
68      private Property&lt;Integer&gt; connIdleEvictTimeMilliSeconds;
<span onclick='openModal()' class='match'>69      private int connectionCleanerRepeatInterval;
70      private int maxConnectionsperHost;
71      private int maxTotalConnections;
72      private int connectionTimeout;
73      private int readTimeout;
</span>74      private String proxyHost;
75      private int proxyPort;
76      private boolean isSecure;
77      private boolean isHostnameValidationRequired;
78      private boolean isClientAuthRequired;
79      private boolean ignoreUserToken;
80      private ApacheHttpClient4Config config;
81      boolean bFollowRedirects = CommonClientConfigKey.FollowRedirects.defaultValue();
82      private static final Logger logger = LoggerFactory.getLogger(RestClient.class);
83      public RestClient() {
84          super(null);
85      }
86      public RestClient(ILoadBalancer lb) {
87          super(lb);
88          restClientName = &quot;default&quot;;
89      }
90      public RestClient(ILoadBalancer lb, IClientConfig ncc) {
91          super(lb, ncc);
92          initWithNiwsConfig(ncc);
93      }
94      public RestClient(IClientConfig ncc) {
95          super(null, ncc);
96          initWithNiwsConfig(ncc);
97      }
98      public RestClient(ILoadBalancer lb, Client jerseyClient) {
99          super(lb);
100          this.restClient = jerseyClient;
101          this.setRetryHandler(new HttpClientLoadBalancerErrorHandler());
102      }
103      @Override
104      public void initWithNiwsConfig(IClientConfig clientConfig) {
105          super.initWithNiwsConfig(clientConfig);
106          this.ncc = clientConfig;
107          this.restClientName = ncc.getClientName();
108          this.isSecure = ncc.get(CommonClientConfigKey.IsSecure, this.isSecure);
109          this.isHostnameValidationRequired = ncc.get(CommonClientConfigKey.IsHostnameValidationRequired, this.isHostnameValidationRequired);
110          this.isClientAuthRequired = ncc.get(CommonClientConfigKey.IsClientAuthRequired, this.isClientAuthRequired);
111          this.bFollowRedirects = ncc.get(CommonClientConfigKey.FollowRedirects, true);
112          this.ignoreUserToken = ncc.get(CommonClientConfigKey.IgnoreUserTokenInConnectionPoolForSecureClient, this.ignoreUserToken);
113          this.config = new DefaultApacheHttpClient4Config();
114          this.config.getProperties().put(
115                  ApacheHttpClient4Config.PROPERTY_CONNECT_TIMEOUT,
116                  ncc.get(CommonClientConfigKey.ConnectTimeout));
117          this.config.getProperties().put(
118                  ApacheHttpClient4Config.PROPERTY_READ_TIMEOUT,
119                  ncc.get(CommonClientConfigKey.ReadTimeout));
120          this.restClient = apacheHttpClientSpecificInitialization();
121          this.setRetryHandler(new HttpClientLoadBalancerErrorHandler(ncc));
122      }
123      private void throwInvalidValue(IClientConfigKey&lt;?&gt; key, Exception e) {
124          throw new IllegalArgumentException(&quot;Invalid value for property:&quot; + key, e);
125      }
126      protected Client apacheHttpClientSpecificInitialization() {
127          httpClient4 = NFHttpClientFactory.getNamedNFHttpClient(restClientName, this.ncc, true);
128          if (httpClient4 instanceof AbstractHttpClient) {
129              ((AbstractHttpClient) httpClient4).setHttpRequestRetryHandler(new NFHttpMethodRetryHandler(restClientName, 0, false, 0));
130          } else {
131              logger.warn(&quot;Unexpected error: Unable to disable NFHttpClient &quot;
132                      + &quot;retry handler, this most likely will not cause an &quot;
133                      + &quot;issue but probably should be looked at&quot;);
134          }
135          HttpParams httpClientParams = httpClient4.getParams();
136          NFHttpClient nfHttpClient = (NFHttpClient) httpClient4;
137          try {
138              enableConnectionPoolCleanerTask = ncc.getOrDefault(CommonClientConfigKey.ConnectionPoolCleanerTaskEnabled);
139              nfHttpClient.getConnPoolCleaner().setEnableConnectionPoolCleanerTask(enableConnectionPoolCleanerTask);
140          } catch (Exception e1) {
141              throwInvalidValue(CommonClientConfigKey.ConnectionPoolCleanerTaskEnabled, e1);
142          }
143          if (enableConnectionPoolCleanerTask) {
144              try {
145                  connectionCleanerRepeatInterval = ncc.getOrDefault(CommonClientConfigKey.ConnectionCleanerRepeatInterval);
146                  nfHttpClient.getConnPoolCleaner().setConnectionCleanerRepeatInterval(connectionCleanerRepeatInterval);
147              } catch (Exception e1) {
148                  throwInvalidValue(CommonClientConfigKey.ConnectionCleanerRepeatInterval, e1);
149              }
150              try {
151                  connIdleEvictTimeMilliSeconds = ncc.getDynamicProperty(CommonClientConfigKey.ConnIdleEvictTimeMilliSeconds);
152                  nfHttpClient.setConnIdleEvictTimeMilliSeconds(connIdleEvictTimeMilliSeconds);
153              } catch (Exception e1) {
154                  throwInvalidValue(CommonClientConfigKey.ConnIdleEvictTimeMilliSeconds, e1);
155              }
156              nfHttpClient.initConnectionCleanerTask();
157          }
158          try {
159              maxConnectionsperHost = ncc.getOrDefault(CommonClientConfigKey.MaxHttpConnectionsPerHost);
160              ClientConnectionManager connMgr = httpClient4.getConnectionManager();
161              if (connMgr instanceof ThreadSafeClientConnManager) {
162                  ((ThreadSafeClientConnManager) connMgr)
163                  .setDefaultMaxPerRoute(maxConnectionsperHost);
164              }
165          } catch (Exception e1) {
166              throwInvalidValue(CommonClientConfigKey.MaxHttpConnectionsPerHost, e1);
167          }
168          try {
169              maxTotalConnections = ncc.getOrDefault(CommonClientConfigKey.MaxTotalHttpConnections);
170              ClientConnectionManager connMgr = httpClient4.getConnectionManager();
171              if (connMgr instanceof ThreadSafeClientConnManager) {
172                  ((ThreadSafeClientConnManager) connMgr)
173                  .setMaxTotal(maxTotalConnections);
174              }
175          } catch (Exception e1) {
176              throwInvalidValue(CommonClientConfigKey.MaxTotalHttpConnections, e1);
177          }
178          try {
179              connectionTimeout = ncc.getOrDefault(CommonClientConfigKey.ConnectTimeout);
180              HttpConnectionParams.setConnectionTimeout(httpClientParams,
181                      connectionTimeout);
182          } catch (Exception e1) {
183              throwInvalidValue(CommonClientConfigKey.ConnectTimeout, e1);
184          }
185          try {
186              readTimeout = ncc.getOrDefault(CommonClientConfigKey.ReadTimeout);
187              HttpConnectionParams.setSoTimeout(httpClientParams, readTimeout);
188          } catch (Exception e1) {
189              throwInvalidValue(CommonClientConfigKey.ReadTimeout, e1);
190          }
191          int bufferSize = Integer.MIN_VALUE;
192          if (ncc.get(CommonClientConfigKey.ReceiveBufferSize) != null) {
193              try {
194                  bufferSize = ncc.getOrDefault(CommonClientConfigKey.ReceiveBufferSize);
195              } catch (Exception e) {
196                  throwInvalidValue(CommonClientConfigKey.ReceiveBufferSize, e);
197              }
198              if (ncc.get(CommonClientConfigKey.SendBufferSize) != null) {
199                  try {
200                      int sendBufferSize = ncc.getOrDefault(CommonClientConfigKey.SendBufferSize);
201                      if (sendBufferSize &gt; bufferSize) {
202                          bufferSize = sendBufferSize;
203                      }
204                  } catch (Exception e) {
205                      throwInvalidValue(CommonClientConfigKey.SendBufferSize,e);
206                  }
207              }
208          }
209          if (bufferSize != Integer.MIN_VALUE) {
210              HttpConnectionParams.setSocketBufferSize(httpClientParams,
211                      bufferSize);
212          }
213          if (ncc.get(CommonClientConfigKey.StaleCheckingEnabled) != null) {
214              try {
215                  HttpConnectionParams.setStaleCheckingEnabled(
216                          httpClientParams, ncc.getOrDefault(CommonClientConfigKey.StaleCheckingEnabled));
217              } catch (Exception e) {
218                  throwInvalidValue(CommonClientConfigKey.StaleCheckingEnabled, e);
219              }
220          }
221          if (ncc.get(CommonClientConfigKey.Linger) != null) {
222              try {
223                  HttpConnectionParams.setLinger(httpClientParams, ncc.getOrDefault(CommonClientConfigKey.Linger));
224              } catch (Exception e) {
225                  throwInvalidValue(CommonClientConfigKey.Linger, e);
226              }
227          }
228          if (ncc.get(CommonClientConfigKey.ProxyHost) != null) {
229              try {
230                  proxyHost = (String) ncc.getOrDefault(CommonClientConfigKey.ProxyHost);
231                  proxyPort = ncc.getOrDefault(CommonClientConfigKey.ProxyPort);
232                  HttpHost proxy = new HttpHost(proxyHost, proxyPort);
233                  httpClient4.getParams()
234                      .setParameter(ConnRouteParams.DEFAULT_PROXY, proxy);
235              } catch (Exception e) {
236                  throwInvalidValue(CommonClientConfigKey.ProxyHost, e);
237              }
238          }
239          if (isSecure) {
240              final URL trustStoreUrl = getResourceForOptionalProperty(CommonClientConfigKey.TrustStore);
241              final URL keyStoreUrl = getResourceForOptionalProperty(CommonClientConfigKey.KeyStore);
242          	final ClientConnectionManager currentManager = httpClient4.getConnectionManager();
243              AbstractSslContextFactory abstractFactory = null;
244              if (    
245              		(isClientAuthRequired &amp;&amp; (trustStoreUrl != null &amp;&amp; keyStoreUrl != null))
246              		    || (!isClientAuthRequired &amp;&amp; (trustStoreUrl != null || keyStoreUrl != null))
247              		) {
248                  try {
249                  	abstractFactory = new URLSslContextFactory(trustStoreUrl,
250                              ncc.get(CommonClientConfigKey.TrustStorePassword),
251                              keyStoreUrl,
252                              ncc.get(CommonClientConfigKey.KeyStorePassword));
253                  } catch (ClientSslSocketFactoryException e) {
254                      throw new IllegalArgumentException(&quot;Unable to configure custom secure socket factory&quot;, e);
255                  }
256              }
257          	KeyStoreAwareSocketFactory awareSocketFactory;
258          	try {
259          		awareSocketFactory = isHostnameValidationRequired ? new KeyStoreAwareSocketFactory(abstractFactory) :
260          		    new KeyStoreAwareSocketFactory(abstractFactory, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
261          		currentManager.getSchemeRegistry().register(new Scheme(
262                          &quot;https&quot;,443, awareSocketFactory));
263          	} catch (Exception e) {
264          		throw new IllegalArgumentException(&quot;Unable to configure custom secure socket factory&quot;, e);
265          	}
266          }
267          if (ignoreUserToken) {
268              ((DefaultHttpClient) httpClient4).setUserTokenHandler(new UserTokenHandler() {
269                  @Override
270                  public Object getUserToken(HttpContext context) {
271                      return null;
272                  }
273              });
274          }
275          String customSSLFactoryClassName = ncc.get(CommonClientConfigKey.CustomSSLSocketFactoryClassName);
276          if (customSSLFactoryClassName != null){
277              try{
278                  SSLSocketFactory customSocketFactory = (SSLSocketFactory) ClientFactory.instantiateInstanceWithClientConfig(customSSLFactoryClassName, ncc);
279                  httpClient4.getConnectionManager().getSchemeRegistry().register(new Scheme(
280                          &quot;https&quot;,443, customSocketFactory));
281              } catch(Exception e){
282                  throwInvalidValue(CommonClientConfigKey.CustomSSLSocketFactoryClassName, e);
283              }
284          }
285          ApacheHttpClient4Handler handler = new ApacheHttpClient4Handler(httpClient4, new BasicCookieStore(), false);
286          return new ApacheHttpClient4(handler, config);
287      }
288      public void resetSSLSocketFactory(AbstractSslContextFactory abstractContextFactory){
289      	try {
290      		KeyStoreAwareSocketFactory awareSocketFactory = isHostnameValidationRequired ? new KeyStoreAwareSocketFactory(abstractContextFactory) :
291                  new KeyStoreAwareSocketFactory(abstractContextFactory, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
292      		httpClient4.getConnectionManager().getSchemeRegistry().register(new Scheme(
293                      &quot;https&quot;,443, awareSocketFactory));
294      	} catch (Exception e) {
295      		throw new IllegalArgumentException(&quot;Unable to configure custom secure socket factory&quot;, e);
296      	}
297      }
298      public KeyStore getKeyStore(){
299      	SchemeRegistry registry = httpClient4.getConnectionManager().getSchemeRegistry();
300      	if(! registry.getSchemeNames().contains(&quot;https&quot;)){
301      		throw new IllegalStateException(&quot;Registry does not include an &#x27;https&#x27; entry.&quot;);
302      	}
303      	SchemeSocketFactory awareSocketFactory = httpClient4.getConnectionManager().getSchemeRegistry().getScheme(&quot;https&quot;).getSchemeSocketFactory();
304      	if(awareSocketFactory instanceof KeyStoreAwareSocketFactory){
305      		return ((KeyStoreAwareSocketFactory) awareSocketFactory).getKeyStore();
306      	}else{
307      		throw new IllegalStateException(&quot;Cannot extract keystore from scheme socket factory of type: &quot; + awareSocketFactory.getClass().getName());
308      	}
309      }
310      public static URL getResource(String resourceName)
311      {
312          URL url = null;
313          ClassLoader loader = Thread.currentThread().getContextClassLoader();
314          if (loader != null) {
315              url = loader.getResource(resourceName);
316          }
317          if (url == null) {
318              url = ClassLoader.getSystemResource(resourceName);
319          }
320          if (url == null) {
321              url = RestClient.class.getResource(resourceName);
322          }
323          if (url == null) {
324              url = RestClient.class.getClassLoader().getResource(resourceName);
325          }
326          if (url == null) {
327              try {
328                  resourceName = URLDecoder.decode(resourceName, &quot;UTF-8&quot;);
329                  url = (new File(resourceName)).toURI().toURL();
330              } catch (Exception e) {
331              	logger.error(&quot;Problem loading resource&quot;, e);
332              }
333          }
334          return url;
335      }
336      public Client getJerseyClient() {
337          return restClient;
338      }
339      public void setJerseyClient(Client c) {
340          restClient = c;
341      }
342      private URL getResourceForOptionalProperty(final IClientConfigKey configKey) {
343          final String propValue = (String) ncc.get(configKey);
344          URL result = null;
345          if (propValue != null) {
346              result = getResource(propValue);
347              if (result == null) {
348                  throw new IllegalArgumentException(&quot;No resource found for &quot; + configKey + &quot;: &quot;
349                          + propValue);
350              }
351          }
352          return result;
353      }
354      public HttpResponse execute(HttpRequest task) throws Exception  {
355          return execute(task, null);
356      }
357      @Override
358      public HttpResponse execute(HttpRequest task, IClientConfig requestConfig) throws Exception {
359          IClientConfig config = (requestConfig == null) ? task.getOverrideConfig() : requestConfig;
360          return execute(task.getVerb(), task.getUri(),
361                  task.getHeaders(), task.getQueryParams(), config, task.getEntity());
362      }
363      @Override
364      protected int getDefaultPortFromScheme(String scheme) {
365          int port = super.getDefaultPortFromScheme(scheme);
366          if (port &lt; 0) {
367              return 80;
368          } else {
369              return port;
370          }
371      }
372      @Override
373      protected Pair&lt;String, Integer&gt; deriveSchemeAndPortFromPartialUri(URI uri) {
374          boolean isSecure = ncc.get(CommonClientConfigKey.IsSecure, this.isSecure);
375          String scheme = uri.getScheme();
376          if (scheme != null) {
377              isSecure = 	scheme.equalsIgnoreCase(&quot;https&quot;);
378          }
379          int port = uri.getPort();
380          if (port &lt; 0 &amp;&amp; !isSecure){
381              port = 80;
382          } else if (port &lt; 0 &amp;&amp; isSecure){
383              port = 443;
384          }
385          if (scheme == null){
386              if (isSecure) {
387                  scheme = &quot;https&quot;;
388              } else {
389                  scheme = &quot;http&quot;;
390              }
391          }
392          return new Pair&lt;&gt;(scheme, port);
393      }
394      private HttpResponse execute(HttpRequest.Verb verb, URI uri,
395              Map&lt;String, Collection&lt;String&gt;&gt; headers, Map&lt;String, Collection&lt;String&gt;&gt; params,
396              IClientConfig overriddenClientConfig, Object requestEntity) throws Exception {
397          HttpClientResponse thisResponse = null;
398          final boolean bbFollowRedirects = Optional.ofNullable(overriddenClientConfig)
399                  .flatMap(config -&gt; config.getIfSet(CommonClientConfigKey.FollowRedirects))
400                  .orElse(bFollowRedirects);
401          restClient.setFollowRedirects(bbFollowRedirects);
402          if (logger.isDebugEnabled()) {
403              logger.debug(&quot;RestClient sending new Request(&quot; + verb
404                      + &quot;: ) &quot; + uri);
405          }
406          WebResource xResource = restClient.resource(uri.toString());
407          if (params != null) {
408              for (Map.Entry&lt;String, Collection&lt;String&gt;&gt; entry: params.entrySet()) {
409                  String name = entry.getKey();
410                  for (String value: entry.getValue()) {
411                      xResource = xResource.queryParam(name, value);
412                  }
413              }
414          }
415          ClientResponse jerseyResponse;
416          Builder b = xResource.getRequestBuilder();
417          if (headers != null) {
418              for (Map.Entry&lt;String, Collection&lt;String&gt;&gt; entry: headers.entrySet()) {
419                  String name = entry.getKey();
420                  for (String value: entry.getValue()) {
421                      b = b.header(name, value);
422                  }
423              }
424          }
425          Object entity = requestEntity;
426          switch (verb) {
427          case GET:
428              jerseyResponse = b.get(ClientResponse.class);
429              break;
430          case POST:
431              jerseyResponse = b.post(ClientResponse.class, entity);
432              break;
433          case PUT:
434              jerseyResponse = b.put(ClientResponse.class, entity);
435              break;
436          case DELETE:
437              jerseyResponse = b.delete(ClientResponse.class);
438              break;
439          case HEAD:
440              jerseyResponse = b.head();
441              break;
442          case OPTIONS:
443              jerseyResponse = b.options(ClientResponse.class);
444              break;
445          default:
446              throw new ClientException(
447                      ClientException.ErrorType.GENERAL,
448                      &quot;You have to one of the REST verbs such as GET, POST etc.&quot;);
449          }
450          thisResponse = new HttpClientResponse(jerseyResponse, uri, overriddenClientConfig);
451          if (thisResponse.getStatus() == 503){
452              thisResponse.close();
453              throw new ClientException(ClientException.ErrorType.SERVER_THROTTLED);
454          }
455          return thisResponse;
456      }
457      @Override
458      protected boolean isRetriableException(Throwable e) {
459          if (e instanceof ClientException
460                  &amp;&amp; ((ClientException)e).getErrorType() == ClientException.ErrorType.SERVER_THROTTLED){
461              return false;
462          }
463          boolean shouldRetry = isConnectException(e) || isSocketException(e);
464          return shouldRetry;
465      }
466      @Override
467      protected boolean isCircuitBreakerException(Throwable e) {
468          if (e instanceof ClientException) {
469              ClientException clientException = (ClientException) e;
470              if (clientException.getErrorType() == ClientException.ErrorType.SERVER_THROTTLED) {
471                  return true;
472              }
473          }
474          return isConnectException(e) || isSocketException(e);
475      }
476      private static boolean isSocketException(Throwable e) {
477          int levelCount = 0;
478          while (e != null &amp;&amp; levelCount &lt; 10) {
479              if ((e instanceof SocketException) || (e instanceof SocketTimeoutException)) {
480                  return true;
481              }
482              e = e.getCause();
483              levelCount++;
484          }
485          return false;
486      }
487      private static boolean isConnectException(Throwable e) {
488          int levelCount = 0;
489          while (e != null &amp;&amp; levelCount &lt; 10) {
490              if ((e instanceof SocketException)
491                      || ((e instanceof org.apache.http.conn.ConnectTimeoutException)
492                              &amp;&amp; !(e instanceof org.apache.http.conn.ConnectionPoolTimeoutException))) {
493                  return true;
494              }
495              e = e.getCause();
496              levelCount++;
497          }
498          return false;
499      }
500  	@Override
501  	protected Pair&lt;String, Integer&gt; deriveHostAndPortFromVipAddress(String vipAddress)
502  			throws URISyntaxException, ClientException {
503  		if (!vipAddress.contains(&quot;http&quot;)) {
504  			vipAddress = &quot;http:&amp;bsol;&amp;bsol;&quot; + vipAddress;
505  		}
506  		return super.deriveHostAndPortFromVipAddress(vipAddress);
507  	}
508      @Override
509      public RequestSpecificRetryHandler getRequestSpecificRetryHandler(
510              HttpRequest request, IClientConfig requestConfig) {
511          if (!request.isRetriable()) {
512              return new RequestSpecificRetryHandler(false, false, this.getRetryHandler(), requestConfig);
513          }
514          if (this.ncc.get(CommonClientConfigKey.OkToRetryOnAllOperations, false)) {
515              return new RequestSpecificRetryHandler(true, true, this.getRetryHandler(), requestConfig);
516          }
517          if (request.getVerb() != HttpRequest.Verb.GET) {
518              return new RequestSpecificRetryHandler(true, false, this.getRetryHandler(), requestConfig);
519          } else {
520              return new RequestSpecificRetryHandler(true, true, this.getRetryHandler(), requestConfig);
521          } 
522      }
523  	public void shutdown() {
524  	    ILoadBalancer lb = this.getLoadBalancer();
525  	    if (lb instanceof BaseLoadBalancer) {
526  	        ((BaseLoadBalancer) lb).shutdown();
527  	    }
528  	    NFHttpClientFactory.shutdownNFHttpClient(restClientName);
529  	}
530  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RestClient.java</h3>
            <pre><code>1  package com.netflix.niws.client.http;
2  import java.io.File;
3  import java.net.SocketException;
4  import java.net.SocketTimeoutException;
5  import java.net.URI;
6  import java.net.URISyntaxException;
7  import java.net.URL;
8  import java.net.URLDecoder;
9  import java.security.KeyStore;
10  import java.util.Collection;
11  import java.util.Map;
12  import java.util.Optional;
13  import com.netflix.client.config.Property;
14  import org.apache.http.HttpHost;
15  import org.apache.http.client.HttpClient;
16  import org.apache.http.client.UserTokenHandler;
17  import org.apache.http.conn.ClientConnectionManager;
18  import org.apache.http.conn.params.ConnRouteParams;
19  import org.apache.http.conn.scheme.Scheme;
20  import org.apache.http.conn.scheme.SchemeRegistry;
21  import org.apache.http.conn.scheme.SchemeSocketFactory;
22  import org.apache.http.conn.ssl.SSLSocketFactory;
23  import org.apache.http.impl.client.AbstractHttpClient;
24  import org.apache.http.impl.client.BasicCookieStore;
25  import org.apache.http.impl.client.DefaultHttpClient;
26  import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
27  import org.apache.http.params.HttpConnectionParams;
28  import org.apache.http.params.HttpParams;
29  import org.apache.http.protocol.HttpContext;
30  import org.slf4j.Logger;
31  import org.slf4j.LoggerFactory;
32  import com.netflix.client.AbstractLoadBalancerAwareClient;
33  import com.netflix.client.ClientException;
34  import com.netflix.client.ClientFactory;
35  import com.netflix.client.RequestSpecificRetryHandler;
36  import com.netflix.client.config.CommonClientConfigKey;
37  import com.netflix.client.config.IClientConfig;
38  import com.netflix.client.config.IClientConfigKey;
39  import com.netflix.client.http.HttpRequest;
40  import com.netflix.client.http.HttpResponse;
41  import com.netflix.client.ssl.AbstractSslContextFactory;
42  import com.netflix.client.ssl.ClientSslSocketFactoryException;
43  import com.netflix.client.ssl.URLSslContextFactory;
44  import com.netflix.http4.NFHttpClient;
45  import com.netflix.http4.NFHttpClientFactory;
46  import com.netflix.http4.NFHttpMethodRetryHandler;
47  import com.netflix.http4.ssl.KeyStoreAwareSocketFactory;
48  import com.netflix.loadbalancer.BaseLoadBalancer;
49  import com.netflix.loadbalancer.ILoadBalancer;
50  import com.netflix.util.Pair;
51  import com.sun.jersey.api.client.Client;
52  import com.sun.jersey.api.client.ClientResponse;
53  import com.sun.jersey.api.client.WebResource;
54  import com.sun.jersey.api.client.WebResource.Builder;
55  import com.sun.jersey.client.apache4.ApacheHttpClient4;
56  import com.sun.jersey.client.apache4.ApacheHttpClient4Handler;
57  import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
58  import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
59  @Deprecated
60  public class RestClient extends AbstractLoadBalancerAwareClient&lt;HttpRequest, HttpResponse&gt; {
61      private static IClientConfigKey&lt;Integer&gt; CONN_IDLE_EVICT_TIME_MILLIS = new CommonClientConfigKey&lt;Integer&gt;(
62              &quot;%s.nfhttpclient.connIdleEvictTimeMilliSeconds&quot;) {};
63      private Client restClient;
64      private HttpClient httpClient4;
65      private IClientConfig ncc;
66      private String restClientName;
67      private boolean enableConnectionPoolCleanerTask = false;
68      private Property&lt;Integer&gt; connIdleEvictTimeMilliSeconds;
69      private int connectionCleanerRepeatInterval;
<span onclick='openModal()' class='match'>70      private int maxConnectionsperHost;
71      private int maxTotalConnections;
72      private int connectionTimeout;
73      private int readTimeout;
74      private String proxyHost;
</span>75      private int proxyPort;
76      private boolean isSecure;
77      private boolean isHostnameValidationRequired;
78      private boolean isClientAuthRequired;
79      private boolean ignoreUserToken;
80      private ApacheHttpClient4Config config;
81      boolean bFollowRedirects = CommonClientConfigKey.FollowRedirects.defaultValue();
82      private static final Logger logger = LoggerFactory.getLogger(RestClient.class);
83      public RestClient() {
84          super(null);
85      }
86      public RestClient(ILoadBalancer lb) {
87          super(lb);
88          restClientName = &quot;default&quot;;
89      }
90      public RestClient(ILoadBalancer lb, IClientConfig ncc) {
91          super(lb, ncc);
92          initWithNiwsConfig(ncc);
93      }
94      public RestClient(IClientConfig ncc) {
95          super(null, ncc);
96          initWithNiwsConfig(ncc);
97      }
98      public RestClient(ILoadBalancer lb, Client jerseyClient) {
99          super(lb);
100          this.restClient = jerseyClient;
101          this.setRetryHandler(new HttpClientLoadBalancerErrorHandler());
102      }
103      @Override
104      public void initWithNiwsConfig(IClientConfig clientConfig) {
105          super.initWithNiwsConfig(clientConfig);
106          this.ncc = clientConfig;
107          this.restClientName = ncc.getClientName();
108          this.isSecure = ncc.get(CommonClientConfigKey.IsSecure, this.isSecure);
109          this.isHostnameValidationRequired = ncc.get(CommonClientConfigKey.IsHostnameValidationRequired, this.isHostnameValidationRequired);
110          this.isClientAuthRequired = ncc.get(CommonClientConfigKey.IsClientAuthRequired, this.isClientAuthRequired);
111          this.bFollowRedirects = ncc.get(CommonClientConfigKey.FollowRedirects, true);
112          this.ignoreUserToken = ncc.get(CommonClientConfigKey.IgnoreUserTokenInConnectionPoolForSecureClient, this.ignoreUserToken);
113          this.config = new DefaultApacheHttpClient4Config();
114          this.config.getProperties().put(
115                  ApacheHttpClient4Config.PROPERTY_CONNECT_TIMEOUT,
116                  ncc.get(CommonClientConfigKey.ConnectTimeout));
117          this.config.getProperties().put(
118                  ApacheHttpClient4Config.PROPERTY_READ_TIMEOUT,
119                  ncc.get(CommonClientConfigKey.ReadTimeout));
120          this.restClient = apacheHttpClientSpecificInitialization();
121          this.setRetryHandler(new HttpClientLoadBalancerErrorHandler(ncc));
122      }
123      private void throwInvalidValue(IClientConfigKey&lt;?&gt; key, Exception e) {
124          throw new IllegalArgumentException(&quot;Invalid value for property:&quot; + key, e);
125      }
126      protected Client apacheHttpClientSpecificInitialization() {
127          httpClient4 = NFHttpClientFactory.getNamedNFHttpClient(restClientName, this.ncc, true);
128          if (httpClient4 instanceof AbstractHttpClient) {
129              ((AbstractHttpClient) httpClient4).setHttpRequestRetryHandler(new NFHttpMethodRetryHandler(restClientName, 0, false, 0));
130          } else {
131              logger.warn(&quot;Unexpected error: Unable to disable NFHttpClient &quot;
132                      + &quot;retry handler, this most likely will not cause an &quot;
133                      + &quot;issue but probably should be looked at&quot;);
134          }
135          HttpParams httpClientParams = httpClient4.getParams();
136          NFHttpClient nfHttpClient = (NFHttpClient) httpClient4;
137          try {
138              enableConnectionPoolCleanerTask = ncc.getOrDefault(CommonClientConfigKey.ConnectionPoolCleanerTaskEnabled);
139              nfHttpClient.getConnPoolCleaner().setEnableConnectionPoolCleanerTask(enableConnectionPoolCleanerTask);
140          } catch (Exception e1) {
141              throwInvalidValue(CommonClientConfigKey.ConnectionPoolCleanerTaskEnabled, e1);
142          }
143          if (enableConnectionPoolCleanerTask) {
144              try {
145                  connectionCleanerRepeatInterval = ncc.getOrDefault(CommonClientConfigKey.ConnectionCleanerRepeatInterval);
146                  nfHttpClient.getConnPoolCleaner().setConnectionCleanerRepeatInterval(connectionCleanerRepeatInterval);
147              } catch (Exception e1) {
148                  throwInvalidValue(CommonClientConfigKey.ConnectionCleanerRepeatInterval, e1);
149              }
150              try {
151                  connIdleEvictTimeMilliSeconds = ncc.getDynamicProperty(CommonClientConfigKey.ConnIdleEvictTimeMilliSeconds);
152                  nfHttpClient.setConnIdleEvictTimeMilliSeconds(connIdleEvictTimeMilliSeconds);
153              } catch (Exception e1) {
154                  throwInvalidValue(CommonClientConfigKey.ConnIdleEvictTimeMilliSeconds, e1);
155              }
156              nfHttpClient.initConnectionCleanerTask();
157          }
158          try {
159              maxConnectionsperHost = ncc.getOrDefault(CommonClientConfigKey.MaxHttpConnectionsPerHost);
160              ClientConnectionManager connMgr = httpClient4.getConnectionManager();
161              if (connMgr instanceof ThreadSafeClientConnManager) {
162                  ((ThreadSafeClientConnManager) connMgr)
163                  .setDefaultMaxPerRoute(maxConnectionsperHost);
164              }
165          } catch (Exception e1) {
166              throwInvalidValue(CommonClientConfigKey.MaxHttpConnectionsPerHost, e1);
167          }
168          try {
169              maxTotalConnections = ncc.getOrDefault(CommonClientConfigKey.MaxTotalHttpConnections);
170              ClientConnectionManager connMgr = httpClient4.getConnectionManager();
171              if (connMgr instanceof ThreadSafeClientConnManager) {
172                  ((ThreadSafeClientConnManager) connMgr)
173                  .setMaxTotal(maxTotalConnections);
174              }
175          } catch (Exception e1) {
176              throwInvalidValue(CommonClientConfigKey.MaxTotalHttpConnections, e1);
177          }
178          try {
179              connectionTimeout = ncc.getOrDefault(CommonClientConfigKey.ConnectTimeout);
180              HttpConnectionParams.setConnectionTimeout(httpClientParams,
181                      connectionTimeout);
182          } catch (Exception e1) {
183              throwInvalidValue(CommonClientConfigKey.ConnectTimeout, e1);
184          }
185          try {
186              readTimeout = ncc.getOrDefault(CommonClientConfigKey.ReadTimeout);
187              HttpConnectionParams.setSoTimeout(httpClientParams, readTimeout);
188          } catch (Exception e1) {
189              throwInvalidValue(CommonClientConfigKey.ReadTimeout, e1);
190          }
191          int bufferSize = Integer.MIN_VALUE;
192          if (ncc.get(CommonClientConfigKey.ReceiveBufferSize) != null) {
193              try {
194                  bufferSize = ncc.getOrDefault(CommonClientConfigKey.ReceiveBufferSize);
195              } catch (Exception e) {
196                  throwInvalidValue(CommonClientConfigKey.ReceiveBufferSize, e);
197              }
198              if (ncc.get(CommonClientConfigKey.SendBufferSize) != null) {
199                  try {
200                      int sendBufferSize = ncc.getOrDefault(CommonClientConfigKey.SendBufferSize);
201                      if (sendBufferSize &gt; bufferSize) {
202                          bufferSize = sendBufferSize;
203                      }
204                  } catch (Exception e) {
205                      throwInvalidValue(CommonClientConfigKey.SendBufferSize,e);
206                  }
207              }
208          }
209          if (bufferSize != Integer.MIN_VALUE) {
210              HttpConnectionParams.setSocketBufferSize(httpClientParams,
211                      bufferSize);
212          }
213          if (ncc.get(CommonClientConfigKey.StaleCheckingEnabled) != null) {
214              try {
215                  HttpConnectionParams.setStaleCheckingEnabled(
216                          httpClientParams, ncc.getOrDefault(CommonClientConfigKey.StaleCheckingEnabled));
217              } catch (Exception e) {
218                  throwInvalidValue(CommonClientConfigKey.StaleCheckingEnabled, e);
219              }
220          }
221          if (ncc.get(CommonClientConfigKey.Linger) != null) {
222              try {
223                  HttpConnectionParams.setLinger(httpClientParams, ncc.getOrDefault(CommonClientConfigKey.Linger));
224              } catch (Exception e) {
225                  throwInvalidValue(CommonClientConfigKey.Linger, e);
226              }
227          }
228          if (ncc.get(CommonClientConfigKey.ProxyHost) != null) {
229              try {
230                  proxyHost = (String) ncc.getOrDefault(CommonClientConfigKey.ProxyHost);
231                  proxyPort = ncc.getOrDefault(CommonClientConfigKey.ProxyPort);
232                  HttpHost proxy = new HttpHost(proxyHost, proxyPort);
233                  httpClient4.getParams()
234                      .setParameter(ConnRouteParams.DEFAULT_PROXY, proxy);
235              } catch (Exception e) {
236                  throwInvalidValue(CommonClientConfigKey.ProxyHost, e);
237              }
238          }
239          if (isSecure) {
240              final URL trustStoreUrl = getResourceForOptionalProperty(CommonClientConfigKey.TrustStore);
241              final URL keyStoreUrl = getResourceForOptionalProperty(CommonClientConfigKey.KeyStore);
242          	final ClientConnectionManager currentManager = httpClient4.getConnectionManager();
243              AbstractSslContextFactory abstractFactory = null;
244              if (    
245              		(isClientAuthRequired &amp;&amp; (trustStoreUrl != null &amp;&amp; keyStoreUrl != null))
246              		    || (!isClientAuthRequired &amp;&amp; (trustStoreUrl != null || keyStoreUrl != null))
247              		) {
248                  try {
249                  	abstractFactory = new URLSslContextFactory(trustStoreUrl,
250                              ncc.get(CommonClientConfigKey.TrustStorePassword),
251                              keyStoreUrl,
252                              ncc.get(CommonClientConfigKey.KeyStorePassword));
253                  } catch (ClientSslSocketFactoryException e) {
254                      throw new IllegalArgumentException(&quot;Unable to configure custom secure socket factory&quot;, e);
255                  }
256              }
257          	KeyStoreAwareSocketFactory awareSocketFactory;
258          	try {
259          		awareSocketFactory = isHostnameValidationRequired ? new KeyStoreAwareSocketFactory(abstractFactory) :
260          		    new KeyStoreAwareSocketFactory(abstractFactory, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
261          		currentManager.getSchemeRegistry().register(new Scheme(
262                          &quot;https&quot;,443, awareSocketFactory));
263          	} catch (Exception e) {
264          		throw new IllegalArgumentException(&quot;Unable to configure custom secure socket factory&quot;, e);
265          	}
266          }
267          if (ignoreUserToken) {
268              ((DefaultHttpClient) httpClient4).setUserTokenHandler(new UserTokenHandler() {
269                  @Override
270                  public Object getUserToken(HttpContext context) {
271                      return null;
272                  }
273              });
274          }
275          String customSSLFactoryClassName = ncc.get(CommonClientConfigKey.CustomSSLSocketFactoryClassName);
276          if (customSSLFactoryClassName != null){
277              try{
278                  SSLSocketFactory customSocketFactory = (SSLSocketFactory) ClientFactory.instantiateInstanceWithClientConfig(customSSLFactoryClassName, ncc);
279                  httpClient4.getConnectionManager().getSchemeRegistry().register(new Scheme(
280                          &quot;https&quot;,443, customSocketFactory));
281              } catch(Exception e){
282                  throwInvalidValue(CommonClientConfigKey.CustomSSLSocketFactoryClassName, e);
283              }
284          }
285          ApacheHttpClient4Handler handler = new ApacheHttpClient4Handler(httpClient4, new BasicCookieStore(), false);
286          return new ApacheHttpClient4(handler, config);
287      }
288      public void resetSSLSocketFactory(AbstractSslContextFactory abstractContextFactory){
289      	try {
290      		KeyStoreAwareSocketFactory awareSocketFactory = isHostnameValidationRequired ? new KeyStoreAwareSocketFactory(abstractContextFactory) :
291                  new KeyStoreAwareSocketFactory(abstractContextFactory, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
292      		httpClient4.getConnectionManager().getSchemeRegistry().register(new Scheme(
293                      &quot;https&quot;,443, awareSocketFactory));
294      	} catch (Exception e) {
295      		throw new IllegalArgumentException(&quot;Unable to configure custom secure socket factory&quot;, e);
296      	}
297      }
298      public KeyStore getKeyStore(){
299      	SchemeRegistry registry = httpClient4.getConnectionManager().getSchemeRegistry();
300      	if(! registry.getSchemeNames().contains(&quot;https&quot;)){
301      		throw new IllegalStateException(&quot;Registry does not include an &#x27;https&#x27; entry.&quot;);
302      	}
303      	SchemeSocketFactory awareSocketFactory = httpClient4.getConnectionManager().getSchemeRegistry().getScheme(&quot;https&quot;).getSchemeSocketFactory();
304      	if(awareSocketFactory instanceof KeyStoreAwareSocketFactory){
305      		return ((KeyStoreAwareSocketFactory) awareSocketFactory).getKeyStore();
306      	}else{
307      		throw new IllegalStateException(&quot;Cannot extract keystore from scheme socket factory of type: &quot; + awareSocketFactory.getClass().getName());
308      	}
309      }
310      public static URL getResource(String resourceName)
311      {
312          URL url = null;
313          ClassLoader loader = Thread.currentThread().getContextClassLoader();
314          if (loader != null) {
315              url = loader.getResource(resourceName);
316          }
317          if (url == null) {
318              url = ClassLoader.getSystemResource(resourceName);
319          }
320          if (url == null) {
321              url = RestClient.class.getResource(resourceName);
322          }
323          if (url == null) {
324              url = RestClient.class.getClassLoader().getResource(resourceName);
325          }
326          if (url == null) {
327              try {
328                  resourceName = URLDecoder.decode(resourceName, &quot;UTF-8&quot;);
329                  url = (new File(resourceName)).toURI().toURL();
330              } catch (Exception e) {
331              	logger.error(&quot;Problem loading resource&quot;, e);
332              }
333          }
334          return url;
335      }
336      public Client getJerseyClient() {
337          return restClient;
338      }
339      public void setJerseyClient(Client c) {
340          restClient = c;
341      }
342      private URL getResourceForOptionalProperty(final IClientConfigKey configKey) {
343          final String propValue = (String) ncc.get(configKey);
344          URL result = null;
345          if (propValue != null) {
346              result = getResource(propValue);
347              if (result == null) {
348                  throw new IllegalArgumentException(&quot;No resource found for &quot; + configKey + &quot;: &quot;
349                          + propValue);
350              }
351          }
352          return result;
353      }
354      public HttpResponse execute(HttpRequest task) throws Exception  {
355          return execute(task, null);
356      }
357      @Override
358      public HttpResponse execute(HttpRequest task, IClientConfig requestConfig) throws Exception {
359          IClientConfig config = (requestConfig == null) ? task.getOverrideConfig() : requestConfig;
360          return execute(task.getVerb(), task.getUri(),
361                  task.getHeaders(), task.getQueryParams(), config, task.getEntity());
362      }
363      @Override
364      protected int getDefaultPortFromScheme(String scheme) {
365          int port = super.getDefaultPortFromScheme(scheme);
366          if (port &lt; 0) {
367              return 80;
368          } else {
369              return port;
370          }
371      }
372      @Override
373      protected Pair&lt;String, Integer&gt; deriveSchemeAndPortFromPartialUri(URI uri) {
374          boolean isSecure = ncc.get(CommonClientConfigKey.IsSecure, this.isSecure);
375          String scheme = uri.getScheme();
376          if (scheme != null) {
377              isSecure = 	scheme.equalsIgnoreCase(&quot;https&quot;);
378          }
379          int port = uri.getPort();
380          if (port &lt; 0 &amp;&amp; !isSecure){
381              port = 80;
382          } else if (port &lt; 0 &amp;&amp; isSecure){
383              port = 443;
384          }
385          if (scheme == null){
386              if (isSecure) {
387                  scheme = &quot;https&quot;;
388              } else {
389                  scheme = &quot;http&quot;;
390              }
391          }
392          return new Pair&lt;&gt;(scheme, port);
393      }
394      private HttpResponse execute(HttpRequest.Verb verb, URI uri,
395              Map&lt;String, Collection&lt;String&gt;&gt; headers, Map&lt;String, Collection&lt;String&gt;&gt; params,
396              IClientConfig overriddenClientConfig, Object requestEntity) throws Exception {
397          HttpClientResponse thisResponse = null;
398          final boolean bbFollowRedirects = Optional.ofNullable(overriddenClientConfig)
399                  .flatMap(config -&gt; config.getIfSet(CommonClientConfigKey.FollowRedirects))
400                  .orElse(bFollowRedirects);
401          restClient.setFollowRedirects(bbFollowRedirects);
402          if (logger.isDebugEnabled()) {
403              logger.debug(&quot;RestClient sending new Request(&quot; + verb
404                      + &quot;: ) &quot; + uri);
405          }
406          WebResource xResource = restClient.resource(uri.toString());
407          if (params != null) {
408              for (Map.Entry&lt;String, Collection&lt;String&gt;&gt; entry: params.entrySet()) {
409                  String name = entry.getKey();
410                  for (String value: entry.getValue()) {
411                      xResource = xResource.queryParam(name, value);
412                  }
413              }
414          }
415          ClientResponse jerseyResponse;
416          Builder b = xResource.getRequestBuilder();
417          if (headers != null) {
418              for (Map.Entry&lt;String, Collection&lt;String&gt;&gt; entry: headers.entrySet()) {
419                  String name = entry.getKey();
420                  for (String value: entry.getValue()) {
421                      b = b.header(name, value);
422                  }
423              }
424          }
425          Object entity = requestEntity;
426          switch (verb) {
427          case GET:
428              jerseyResponse = b.get(ClientResponse.class);
429              break;
430          case POST:
431              jerseyResponse = b.post(ClientResponse.class, entity);
432              break;
433          case PUT:
434              jerseyResponse = b.put(ClientResponse.class, entity);
435              break;
436          case DELETE:
437              jerseyResponse = b.delete(ClientResponse.class);
438              break;
439          case HEAD:
440              jerseyResponse = b.head();
441              break;
442          case OPTIONS:
443              jerseyResponse = b.options(ClientResponse.class);
444              break;
445          default:
446              throw new ClientException(
447                      ClientException.ErrorType.GENERAL,
448                      &quot;You have to one of the REST verbs such as GET, POST etc.&quot;);
449          }
450          thisResponse = new HttpClientResponse(jerseyResponse, uri, overriddenClientConfig);
451          if (thisResponse.getStatus() == 503){
452              thisResponse.close();
453              throw new ClientException(ClientException.ErrorType.SERVER_THROTTLED);
454          }
455          return thisResponse;
456      }
457      @Override
458      protected boolean isRetriableException(Throwable e) {
459          if (e instanceof ClientException
460                  &amp;&amp; ((ClientException)e).getErrorType() == ClientException.ErrorType.SERVER_THROTTLED){
461              return false;
462          }
463          boolean shouldRetry = isConnectException(e) || isSocketException(e);
464          return shouldRetry;
465      }
466      @Override
467      protected boolean isCircuitBreakerException(Throwable e) {
468          if (e instanceof ClientException) {
469              ClientException clientException = (ClientException) e;
470              if (clientException.getErrorType() == ClientException.ErrorType.SERVER_THROTTLED) {
471                  return true;
472              }
473          }
474          return isConnectException(e) || isSocketException(e);
475      }
476      private static boolean isSocketException(Throwable e) {
477          int levelCount = 0;
478          while (e != null &amp;&amp; levelCount &lt; 10) {
479              if ((e instanceof SocketException) || (e instanceof SocketTimeoutException)) {
480                  return true;
481              }
482              e = e.getCause();
483              levelCount++;
484          }
485          return false;
486      }
487      private static boolean isConnectException(Throwable e) {
488          int levelCount = 0;
489          while (e != null &amp;&amp; levelCount &lt; 10) {
490              if ((e instanceof SocketException)
491                      || ((e instanceof org.apache.http.conn.ConnectTimeoutException)
492                              &amp;&amp; !(e instanceof org.apache.http.conn.ConnectionPoolTimeoutException))) {
493                  return true;
494              }
495              e = e.getCause();
496              levelCount++;
497          }
498          return false;
499      }
500  	@Override
501  	protected Pair&lt;String, Integer&gt; deriveHostAndPortFromVipAddress(String vipAddress)
502  			throws URISyntaxException, ClientException {
503  		if (!vipAddress.contains(&quot;http&quot;)) {
504  			vipAddress = &quot;http:&amp;bsol;&amp;bsol;&quot; + vipAddress;
505  		}
506  		return super.deriveHostAndPortFromVipAddress(vipAddress);
507  	}
508      @Override
509      public RequestSpecificRetryHandler getRequestSpecificRetryHandler(
510              HttpRequest request, IClientConfig requestConfig) {
511          if (!request.isRetriable()) {
512              return new RequestSpecificRetryHandler(false, false, this.getRetryHandler(), requestConfig);
513          }
514          if (this.ncc.get(CommonClientConfigKey.OkToRetryOnAllOperations, false)) {
515              return new RequestSpecificRetryHandler(true, true, this.getRetryHandler(), requestConfig);
516          }
517          if (request.getVerb() != HttpRequest.Verb.GET) {
518              return new RequestSpecificRetryHandler(true, false, this.getRetryHandler(), requestConfig);
519          } else {
520              return new RequestSpecificRetryHandler(true, true, this.getRetryHandler(), requestConfig);
521          } 
522      }
523  	public void shutdown() {
524  	    ILoadBalancer lb = this.getLoadBalancer();
525  	    if (lb instanceof BaseLoadBalancer) {
526  	        ((BaseLoadBalancer) lb).shutdown();
527  	    }
528  	    NFHttpClientFactory.shutdownNFHttpClient(restClientName);
529  	}
530  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RestClient.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RestClient.java</div>
                </div>
                <div class="column column_space"><pre><code>69      private int connectionCleanerRepeatInterval;
70      private int maxConnectionsperHost;
71      private int maxTotalConnections;
72      private int connectionTimeout;
73      private int readTimeout;
</pre></code></div>
                <div class="column column_space"><pre><code>70      private int maxConnectionsperHost;
71      private int maxTotalConnections;
72      private int connectionTimeout;
73      private int readTimeout;
74      private String proxyHost;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    