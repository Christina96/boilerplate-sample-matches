<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for MultisetIteratorTester_1.java &amp; HashCodeTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for MultisetIteratorTester_1.java &amp; HashCodeTest.java
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>MultisetIteratorTester_1.java (11.320755%)<th>HashCodeTest.java (3.0560272%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(67-68)<td><a href="#" name="0">(171-173)</a><td align="center"><font color="#ff0000">9</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(52-53)<td><a href="#" name="1">(146-149)</a><td align="center"><font color="#ff0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MultisetIteratorTester_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect.testing.google;
2 import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
3 import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;
4 import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;
5 import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ITERATOR_REMOVE;
6 import com.google.common.annotations.GwtCompatible;
7 import com.google.common.annotations.GwtIncompatible;
8 import com.google.common.collect.testing.Helpers;
9 import com.google.common.collect.testing.IteratorTester;
10 import com.google.common.collect.testing.features.CollectionFeature;
11 import java.lang.reflect.Method;
12 import java.util.Arrays;
13 import java.util.Iterator;
14 import java.util.List;
15 import org.junit.Ignore;
16 @GwtCompatible(emulated = true)
17 @Ignore public class MultisetIteratorTester&lt;E&gt; extends AbstractMultisetTester&lt;E&gt; {
18   @SuppressWarnings("unchecked")
19   @CollectionFeature.Require({SUPPORTS_ITERATOR_REMOVE, KNOWN_ORDER})
20   public void testRemovingIteratorKnownOrder() {
21     new IteratorTester&lt;E&gt;(
22         4,
23         MODIFIABLE,
24         getSubjectGenerator().order(Arrays.asList(e0(), e1(), e1(), e2())),
25 <a name="1"></a>        IteratorTester.KnownOrder.KNOWN_ORDER) {
26       @Override
27       protected Iterator&lt;E&gt; newTargetIterator() {
28         return <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>getSubjectGenerator().create(e0(), e1(), e1(), e2()).iterator();
29       }</b></font>
30     }.test();
31   }
32   @SuppressWarnings("unchecked")
33   @CollectionFeature.Require(value = SUPPORTS_ITERATOR_REMOVE, absent = KNOWN_ORDER)
34   public void testRemovingIteratorUnknownOrder() {
35     new IteratorTester&lt;E&gt;(
36         4,
37         MODIFIABLE,
38         Arrays.asList(e0(), e1(), e1(), e2()),
39 <a name="0"></a>        IteratorTester.KnownOrder.UNKNOWN_ORDER) {
40       @Override
41       protected Iterator&lt;E&gt; newTargetIterator() {
42         return <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>getSubjectGenerator().create(e0(), e1(), e1(), e2()).iterator();
43       }</b></font>
44     }.test();
45   }
46   @SuppressWarnings("unchecked")
47   @CollectionFeature.Require(value = KNOWN_ORDER, absent = SUPPORTS_ITERATOR_REMOVE)
48   public void testIteratorKnownOrder() {
49     new IteratorTester&lt;E&gt;(
50         4,
51         UNMODIFIABLE,
52         getSubjectGenerator().order(Arrays.asList(e0(), e1(), e1(), e2())),
53         IteratorTester.KnownOrder.KNOWN_ORDER) {
54       @Override
55       protected Iterator&lt;E&gt; newTargetIterator() {
56         return getSubjectGenerator().create(e0(), e1(), e1(), e2()).iterator();
57       }
58     }.test();
59   }
60   @SuppressWarnings("unchecked")
61   @CollectionFeature.Require(absent = {SUPPORTS_ITERATOR_REMOVE, KNOWN_ORDER})
62   public void testIteratorUnknownOrder() {
63     new IteratorTester&lt;E&gt;(
64         4,
65         UNMODIFIABLE,
66         Arrays.asList(e0(), e1(), e1(), e2()),
67         IteratorTester.KnownOrder.UNKNOWN_ORDER) {
68       @Override
69       protected Iterator&lt;E&gt; newTargetIterator() {
70         return getSubjectGenerator().create(e0(), e1(), e1(), e2()).iterator();
71       }
72     }.test();
73   }
74   @GwtIncompatible   public static List&lt;Method&gt; getIteratorDuplicateInitializingMethods() {
75     return Arrays.asList(
76         Helpers.getMethod(MultisetIteratorTester.class, "testIteratorKnownOrder"),
77         Helpers.getMethod(MultisetIteratorTester.class, "testIteratorUnknownOrder"),
78         Helpers.getMethod(MultisetIteratorTester.class, "testRemovingIteratorKnownOrder"),
79         Helpers.getMethod(MultisetIteratorTester.class, "testRemovingIteratorUnknownOrder"));
80   }
81 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HashCodeTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.hash;
2 import static com.google.common.io.BaseEncoding.base16;
3 import com.google.common.base.Charsets;
4 import com.google.common.collect.ImmutableList;
5 import com.google.common.io.BaseEncoding;
6 import com.google.common.testing.ClassSanityTester;
7 import java.util.Arrays;
8 import junit.framework.TestCase;
9 public class HashCodeTest extends TestCase {
10   private static final ImmutableList&lt;ExpectedHashCode&gt; expectedHashCodes =
11       ImmutableList.of(
12           new ExpectedHashCode(
13               new byte[] {
14                 (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,
15                 (byte) 0x67, (byte) 0x45, (byte) 0x23, (byte) 0x01
16               },
17               0x89abcdef,
18               0x0123456789abcdefL,
19               "efcdab8967452301"),
20           new ExpectedHashCode(
21               new byte[] {
22                 (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,
23                 (byte) 0x67, (byte) 0x45, (byte) 0x23,
24                     (byte) 0x01,                 (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
25                 (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08
26               },
27               0x89abcdef,
28               0x0123456789abcdefL,               "efcdab89674523010102030405060708"),
29           new ExpectedHashCode(
30               new byte[] {(byte) 0xdf, (byte) 0x9b, (byte) 0x57, (byte) 0x13},
31               0x13579bdf,
32               null,
33               "df9b5713"),
34           new ExpectedHashCode(
35               new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00},
36               0x0000abcd,
37               null,
38               "cdab0000"),
39           new ExpectedHashCode(
40               new byte[] {
41                 (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x00,
42                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00
43               },
44               0x00abcdef,
45               0x0000000000abcdefL,
46               "efcdab0000000000"));
47   public void testFromInt() {
48     for (ExpectedHashCode expected : expectedHashCodes) {
49       if (expected.bytes.length == 4) {
50         HashCode fromInt = HashCode.fromInt(expected.asInt);
51         assertExpectedHashCode(expected, fromInt);
52       }
53     }
54   }
55   public void testFromLong() {
56     for (ExpectedHashCode expected : expectedHashCodes) {
57       if (expected.bytes.length == 8) {
58         HashCode fromLong = HashCode.fromLong(expected.asLong);
59         assertExpectedHashCode(expected, fromLong);
60       }
61     }
62   }
63   public void testFromBytes() {
64     for (ExpectedHashCode expected : expectedHashCodes) {
65       HashCode fromBytes = HashCode.fromBytes(expected.bytes);
66       assertExpectedHashCode(expected, fromBytes);
67     }
68   }
69   public void testFromBytes_copyOccurs() {
70     byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};
71     HashCode hashCode = HashCode.fromBytes(bytes);
72     int expectedInt = 0x0000abcd;
73     String expectedToString = "cdab0000";
74     assertEquals(expectedInt, hashCode.asInt());
75     assertEquals(expectedToString, hashCode.toString());
76     bytes[0] = (byte) 0x00;
77     assertEquals(expectedInt, hashCode.asInt());
78     assertEquals(expectedToString, hashCode.toString());
79   }
80   public void testFromBytesNoCopy_noCopyOccurs() {
81     byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};
82     HashCode hashCode = HashCode.fromBytesNoCopy(bytes);
83     assertEquals(0x0000abcd, hashCode.asInt());
84     assertEquals("cdab0000", hashCode.toString());
85     bytes[0] = (byte) 0x00;
86     assertEquals(0x0000ab00, hashCode.asInt());
87     assertEquals("00ab0000", hashCode.toString());
88   }
89   public void testGetBytesInternal_noCloneOccurs() {
90     byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};
91     HashCode hashCode = HashCode.fromBytes(bytes);
92     assertEquals(0x0000abcd, hashCode.asInt());
93     assertEquals("cdab0000", hashCode.toString());
94     hashCode.getBytesInternal()[0] = (byte) 0x00;
95     assertEquals(0x0000ab00, hashCode.asInt());
96     assertEquals("00ab0000", hashCode.toString());
97   }
98 <a name="1"></a>
99   public void testPadToLong() {
100     assertEquals(0x1111111111111111L, HashCode.fromLong(0x1111111111111111L).padToLong());
101     assertEquals(0x9999999999999999L, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>HashCode.fromLong(0x9999999999999999L).padToLong());
102     assertEquals(0x0000000011111111L, HashCode.fromInt(0x11111111).padToLong());
103     assertEquals(0x0000000099999999L, HashCode.fromInt(0x99999999).padToLong());
104   }</b></font>
105   public void testPadToLongWith4Bytes() {
106     assertEquals(0x0000000099999999L, HashCode.fromBytesNoCopy(byteArrayWith9s(4)).padToLong());
107   }
108   public void testPadToLongWith6Bytes() {
109     assertEquals(0x0000999999999999L, HashCode.fromBytesNoCopy(byteArrayWith9s(6)).padToLong());
110   }
111   public void testPadToLongWith8Bytes() {
112     assertEquals(0x9999999999999999L, HashCode.fromBytesNoCopy(byteArrayWith9s(8)).padToLong());
113   }
114   private static byte[] byteArrayWith9s(int size) {
115     byte[] bytez = new byte[size];
116     Arrays.fill(bytez, (byte) 0x99);
117     return bytez;
118   }
119 <a name="0"></a>
120   public void testToString() {
121     byte[] data = new byte[] {127, -128, 5, -1, 14};
122     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals("7f8005ff0e", HashCode.fromBytes(data).toString());
123     assertEquals("7f8005ff0e", base16().lowerCase().encode(data));
124   }</b></font>
125   public void testHashCode_nulls() throws Exception {
126     sanityTester().testNulls();
127   }
128   public void testHashCode_equalsAndSerializable() throws Exception {
129     sanityTester().testEqualsAndSerializable();
130   }
131   public void testRoundTripHashCodeUsingBaseEncoding() {
132     HashCode hash1 = Hashing.sha1().hashString("foo", Charsets.US_ASCII);
133     HashCode hash2 = HashCode.fromBytes(BaseEncoding.base16().lowerCase().decode(hash1.toString()));
134     assertEquals(hash1, hash2);
135   }
136   public void testObjectHashCode() {
137     HashCode hashCode42 = HashCode.fromInt(42);
138     assertEquals(42, hashCode42.hashCode());
139   }
140   public void testObjectHashCodeWithSameLowOrderBytes() {
141     byte[] bytesA = new byte[5];
142     byte[] bytesB = new byte[5];
143     bytesA[4] = (byte) 0xbe;
144     bytesB[4] = (byte) 0xef;
145     HashCode hashCodeA = HashCode.fromBytes(bytesA);
146     HashCode hashCodeB = HashCode.fromBytes(bytesB);
147     assertFalse(hashCodeA.equals(hashCodeB));
148     assertEquals(hashCodeA.hashCode(), hashCodeB.hashCode());
149   }
150   public void testRoundTripHashCodeUsingFromString() {
151     HashCode hash1 = Hashing.sha1().hashString("foo", Charsets.US_ASCII);
152     HashCode hash2 = HashCode.fromString(hash1.toString());
153     assertEquals(hash1, hash2);
154   }
155   public void testRoundTrip() {
156     for (ExpectedHashCode expected : expectedHashCodes) {
157       String string = HashCode.fromBytes(expected.bytes).toString();
158       assertEquals(expected.toString, string);
159       assertEquals(
160           expected.toString,
161           HashCode.fromBytes(BaseEncoding.base16().lowerCase().decode(string)).toString());
162     }
163   }
164   public void testFromStringFailsWithInvalidHexChar() {
165     try {
166       HashCode.fromString("7f8005ff0z");
167       fail();
168     } catch (IllegalArgumentException expected) {
169     }
170   }
171   public void testFromStringFailsWithUpperCaseString() {
172     String string = Hashing.sha1().hashString("foo", Charsets.US_ASCII).toString().toUpperCase();
173     try {
174       HashCode.fromString(string);
175       fail();
176     } catch (IllegalArgumentException expected) {
177     }
178   }
179   public void testFromStringFailsWithShortInputs() {
180     try {
181       HashCode.fromString("");
182       fail();
183     } catch (IllegalArgumentException expected) {
184     }
185     try {
186       HashCode.fromString("7");
187       fail();
188     } catch (IllegalArgumentException expected) {
189     }
190     HashCode unused = HashCode.fromString("7f");
191   }
192   public void testFromStringFailsWithOddLengthInput() {
193     try {
194       HashCode.fromString("7f8");
195       fail();
196     } catch (IllegalArgumentException expected) {
197     }
198   }
199   public void testIntWriteBytesTo() {
200     byte[] dest = new byte[4];
201     HashCode.fromInt(42).writeBytesTo(dest, 0, 4);
202     assertTrue(Arrays.equals(HashCode.fromInt(42).asBytes(), dest));
203   }
204   public void testLongWriteBytesTo() {
205     byte[] dest = new byte[8];
206     HashCode.fromLong(42).writeBytesTo(dest, 0, 8);
207     assertTrue(Arrays.equals(HashCode.fromLong(42).asBytes(), dest));
208   }
209   private static final HashCode HASH_ABCD =
210       HashCode.fromBytes(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd});
211   public void testWriteBytesTo() {
212     byte[] dest = new byte[4];
213     HASH_ABCD.writeBytesTo(dest, 0, 4);
214     assertTrue(
215         Arrays.equals(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd}, dest));
216   }
217   public void testWriteBytesToOversizedArray() {
218     byte[] dest = new byte[5];
219     HASH_ABCD.writeBytesTo(dest, 0, 4);
220     assertTrue(
221         Arrays.equals(
222             new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0x00}, dest));
223   }
224   public void testWriteBytesToOversizedArrayLongMaxLength() {
225     byte[] dest = new byte[5];
226     HASH_ABCD.writeBytesTo(dest, 0, 5);
227     assertTrue(
228         Arrays.equals(
229             new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0x00}, dest));
230   }
231   public void testWriteBytesToOversizedArrayShortMaxLength() {
232     byte[] dest = new byte[5];
233     HASH_ABCD.writeBytesTo(dest, 0, 3);
234     assertTrue(
235         Arrays.equals(
236             new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0x00, (byte) 0x00}, dest));
237   }
238   public void testWriteBytesToUndersizedArray() {
239     byte[] dest = new byte[3];
240     try {
241       HASH_ABCD.writeBytesTo(dest, 0, 4);
242       fail();
243     } catch (IndexOutOfBoundsException expected) {
244     }
245   }
246   public void testWriteBytesToUndersizedArrayLongMaxLength() {
247     byte[] dest = new byte[3];
248     try {
249       HASH_ABCD.writeBytesTo(dest, 0, 5);
250       fail();
251     } catch (IndexOutOfBoundsException expected) {
252     }
253   }
254   public void testWriteBytesToUndersizedArrayShortMaxLength() {
255     byte[] dest = new byte[3];
256     HASH_ABCD.writeBytesTo(dest, 0, 2);
257     assertTrue(Arrays.equals(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0x00}, dest));
258   }
259   private static ClassSanityTester.FactoryMethodReturnValueTester sanityTester() {
260     return new ClassSanityTester()
261         .setDefault(byte[].class, new byte[] {1, 2, 3, 4})
262         .setDistinctValues(byte[].class, new byte[] {1, 2, 3, 4}, new byte[] {5, 6, 7, 8})
263         .setDistinctValues(String.class, "7f8005ff0e", "7f8005ff0f")
264         .forAllPublicStaticMethods(HashCode.class);
265   }
266   private static void assertExpectedHashCode(ExpectedHashCode expectedHashCode, HashCode hash) {
267     assertTrue(Arrays.equals(expectedHashCode.bytes, hash.asBytes()));
268     byte[] bb = new byte[hash.bits() / 8];
269     hash.writeBytesTo(bb, 0, bb.length);
270     assertTrue(Arrays.equals(expectedHashCode.bytes, bb));
271     assertEquals(expectedHashCode.asInt, hash.asInt());
272     if (expectedHashCode.asLong == null) {
273       try {
274         hash.asLong();
275         fail();
276       } catch (IllegalStateException expected) {
277       }
278     } else {
279       assertEquals(expectedHashCode.asLong.longValue(), hash.asLong());
280     }
281     assertEquals(expectedHashCode.toString, hash.toString());
282     assertSideEffectFree(hash);
283     assertReadableBytes(hash);
284   }
285   private static void assertSideEffectFree(HashCode hash) {
286     byte[] original = hash.asBytes();
287     byte[] mutated = hash.asBytes();
288     mutated[0]++;
289     assertTrue(Arrays.equals(original, hash.asBytes()));
290   }
291   private static void assertReadableBytes(HashCode hashCode) {
292     assertTrue(hashCode.bits() &gt;= 32);     byte[] hashBytes = hashCode.asBytes();
293     int totalBytes = hashCode.bits() / 8;
294     for (int bytes = 0; bytes &lt; totalBytes; bytes++) {
295       byte[] bb = new byte[bytes];
296       hashCode.writeBytesTo(bb, 0, bb.length);
297       assertTrue(Arrays.equals(Arrays.copyOf(hashBytes, bytes), bb));
298     }
299   }
300   private static class ExpectedHashCode {
301     final byte[] bytes;
302     final int asInt;
303     final Long asLong;     final String toString;
304     ExpectedHashCode(byte[] bytes, int asInt, Long asLong, String toString) {
305       this.bytes = bytes;
306       this.asInt = asInt;
307       this.asLong = asLong;
308       this.toString = toString;
309     }
310   }
311 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
