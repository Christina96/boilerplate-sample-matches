<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for MultisetIteratorTester_1.java &amp; HashCodeTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for MultisetIteratorTester_1.java &amp; HashCodeTest.java
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>MultisetIteratorTester_1.java (11.320755%)<th>HashCodeTest.java (3.0560272%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(67-68)<td><a href="#" name="0">(171-173)</a><td align="center"><font color="#ff0000">9</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(52-53)<td><a href="#" name="1">(146-149)</a><td align="center"><font color="#ff0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MultisetIteratorTester_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.collect.testing.google;
import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;
import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;
import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ITERATOR_REMOVE;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.testing.Helpers;
import com.google.common.collect.testing.IteratorTester;
import com.google.common.collect.testing.features.CollectionFeature;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import org.junit.Ignore;
@GwtCompatible(emulated = true)
@Ignore public class MultisetIteratorTester&lt;E&gt; extends AbstractMultisetTester&lt;E&gt; {
  @SuppressWarnings("unchecked")
  @CollectionFeature.Require({SUPPORTS_ITERATOR_REMOVE, KNOWN_ORDER})
  public void testRemovingIteratorKnownOrder() {
    new IteratorTester&lt;E&gt;(
        4,
        MODIFIABLE,
        getSubjectGenerator().order(Arrays.asList(e0(), e1(), e1(), e2())),
<a name="1"></a>        IteratorTester.KnownOrder.KNOWN_ORDER) {
      @Override
      protected Iterator&lt;E&gt; newTargetIterator() {
        return <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>getSubjectGenerator().create(e0(), e1(), e1(), e2()).iterator();
      }</b></font>
    }.test();
  }
  @SuppressWarnings("unchecked")
  @CollectionFeature.Require(value = SUPPORTS_ITERATOR_REMOVE, absent = KNOWN_ORDER)
  public void testRemovingIteratorUnknownOrder() {
    new IteratorTester&lt;E&gt;(
        4,
        MODIFIABLE,
        Arrays.asList(e0(), e1(), e1(), e2()),
<a name="0"></a>        IteratorTester.KnownOrder.UNKNOWN_ORDER) {
      @Override
      protected Iterator&lt;E&gt; newTargetIterator() {
        return <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>getSubjectGenerator().create(e0(), e1(), e1(), e2()).iterator();
      }</b></font>
    }.test();
  }
  @SuppressWarnings("unchecked")
  @CollectionFeature.Require(value = KNOWN_ORDER, absent = SUPPORTS_ITERATOR_REMOVE)
  public void testIteratorKnownOrder() {
    new IteratorTester&lt;E&gt;(
        4,
        UNMODIFIABLE,
        getSubjectGenerator().order(Arrays.asList(e0(), e1(), e1(), e2())),
        IteratorTester.KnownOrder.KNOWN_ORDER) {
      @Override
      protected Iterator&lt;E&gt; newTargetIterator() {
        return getSubjectGenerator().create(e0(), e1(), e1(), e2()).iterator();
      }
    }.test();
  }
  @SuppressWarnings("unchecked")
  @CollectionFeature.Require(absent = {SUPPORTS_ITERATOR_REMOVE, KNOWN_ORDER})
  public void testIteratorUnknownOrder() {
    new IteratorTester&lt;E&gt;(
        4,
        UNMODIFIABLE,
        Arrays.asList(e0(), e1(), e1(), e2()),
        IteratorTester.KnownOrder.UNKNOWN_ORDER) {
      @Override
      protected Iterator&lt;E&gt; newTargetIterator() {
        return getSubjectGenerator().create(e0(), e1(), e1(), e2()).iterator();
      }
    }.test();
  }
  @GwtIncompatible   public static List&lt;Method&gt; getIteratorDuplicateInitializingMethods() {
    return Arrays.asList(
        Helpers.getMethod(MultisetIteratorTester.class, "testIteratorKnownOrder"),
        Helpers.getMethod(MultisetIteratorTester.class, "testIteratorUnknownOrder"),
        Helpers.getMethod(MultisetIteratorTester.class, "testRemovingIteratorKnownOrder"),
        Helpers.getMethod(MultisetIteratorTester.class, "testRemovingIteratorUnknownOrder"));
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HashCodeTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.hash;
import static com.google.common.io.BaseEncoding.base16;
import com.google.common.base.Charsets;
import com.google.common.collect.ImmutableList;
import com.google.common.io.BaseEncoding;
import com.google.common.testing.ClassSanityTester;
import java.util.Arrays;
import junit.framework.TestCase;
public class HashCodeTest extends TestCase {
  private static final ImmutableList&lt;ExpectedHashCode&gt; expectedHashCodes =
      ImmutableList.of(
          new ExpectedHashCode(
              new byte[] {
                (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,
                (byte) 0x67, (byte) 0x45, (byte) 0x23, (byte) 0x01
              },
              0x89abcdef,
              0x0123456789abcdefL,
              "efcdab8967452301"),
          new ExpectedHashCode(
              new byte[] {
                (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x89,
                (byte) 0x67, (byte) 0x45, (byte) 0x23,
                    (byte) 0x01,                 (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
                (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08
              },
              0x89abcdef,
              0x0123456789abcdefL,               "efcdab89674523010102030405060708"),
          new ExpectedHashCode(
              new byte[] {(byte) 0xdf, (byte) 0x9b, (byte) 0x57, (byte) 0x13},
              0x13579bdf,
              null,
              "df9b5713"),
          new ExpectedHashCode(
              new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00},
              0x0000abcd,
              null,
              "cdab0000"),
          new ExpectedHashCode(
              new byte[] {
                (byte) 0xef, (byte) 0xcd, (byte) 0xab, (byte) 0x00,
                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00
              },
              0x00abcdef,
              0x0000000000abcdefL,
              "efcdab0000000000"));
  public void testFromInt() {
    for (ExpectedHashCode expected : expectedHashCodes) {
      if (expected.bytes.length == 4) {
        HashCode fromInt = HashCode.fromInt(expected.asInt);
        assertExpectedHashCode(expected, fromInt);
      }
    }
  }
  public void testFromLong() {
    for (ExpectedHashCode expected : expectedHashCodes) {
      if (expected.bytes.length == 8) {
        HashCode fromLong = HashCode.fromLong(expected.asLong);
        assertExpectedHashCode(expected, fromLong);
      }
    }
  }
  public void testFromBytes() {
    for (ExpectedHashCode expected : expectedHashCodes) {
      HashCode fromBytes = HashCode.fromBytes(expected.bytes);
      assertExpectedHashCode(expected, fromBytes);
    }
  }
  public void testFromBytes_copyOccurs() {
    byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};
    HashCode hashCode = HashCode.fromBytes(bytes);
    int expectedInt = 0x0000abcd;
    String expectedToString = "cdab0000";
    assertEquals(expectedInt, hashCode.asInt());
    assertEquals(expectedToString, hashCode.toString());
    bytes[0] = (byte) 0x00;
    assertEquals(expectedInt, hashCode.asInt());
    assertEquals(expectedToString, hashCode.toString());
  }
  public void testFromBytesNoCopy_noCopyOccurs() {
    byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};
    HashCode hashCode = HashCode.fromBytesNoCopy(bytes);
    assertEquals(0x0000abcd, hashCode.asInt());
    assertEquals("cdab0000", hashCode.toString());
    bytes[0] = (byte) 0x00;
    assertEquals(0x0000ab00, hashCode.asInt());
    assertEquals("00ab0000", hashCode.toString());
  }
  public void testGetBytesInternal_noCloneOccurs() {
    byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};
    HashCode hashCode = HashCode.fromBytes(bytes);
    assertEquals(0x0000abcd, hashCode.asInt());
    assertEquals("cdab0000", hashCode.toString());
    hashCode.getBytesInternal()[0] = (byte) 0x00;
    assertEquals(0x0000ab00, hashCode.asInt());
    assertEquals("00ab0000", hashCode.toString());
  }
<a name="1"></a>
  public void testPadToLong() {
    assertEquals(0x1111111111111111L, HashCode.fromLong(0x1111111111111111L).padToLong());
    assertEquals(0x9999999999999999L, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>HashCode.fromLong(0x9999999999999999L).padToLong());
    assertEquals(0x0000000011111111L, HashCode.fromInt(0x11111111).padToLong());
    assertEquals(0x0000000099999999L, HashCode.fromInt(0x99999999).padToLong());
  }</b></font>
  public void testPadToLongWith4Bytes() {
    assertEquals(0x0000000099999999L, HashCode.fromBytesNoCopy(byteArrayWith9s(4)).padToLong());
  }
  public void testPadToLongWith6Bytes() {
    assertEquals(0x0000999999999999L, HashCode.fromBytesNoCopy(byteArrayWith9s(6)).padToLong());
  }
  public void testPadToLongWith8Bytes() {
    assertEquals(0x9999999999999999L, HashCode.fromBytesNoCopy(byteArrayWith9s(8)).padToLong());
  }
  private static byte[] byteArrayWith9s(int size) {
    byte[] bytez = new byte[size];
    Arrays.fill(bytez, (byte) 0x99);
    return bytez;
  }
<a name="0"></a>
  public void testToString() {
    byte[] data = new byte[] {127, -128, 5, -1, 14};
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals("7f8005ff0e", HashCode.fromBytes(data).toString());
    assertEquals("7f8005ff0e", base16().lowerCase().encode(data));
  }</b></font>
  public void testHashCode_nulls() throws Exception {
    sanityTester().testNulls();
  }
  public void testHashCode_equalsAndSerializable() throws Exception {
    sanityTester().testEqualsAndSerializable();
  }
  public void testRoundTripHashCodeUsingBaseEncoding() {
    HashCode hash1 = Hashing.sha1().hashString("foo", Charsets.US_ASCII);
    HashCode hash2 = HashCode.fromBytes(BaseEncoding.base16().lowerCase().decode(hash1.toString()));
    assertEquals(hash1, hash2);
  }
  public void testObjectHashCode() {
    HashCode hashCode42 = HashCode.fromInt(42);
    assertEquals(42, hashCode42.hashCode());
  }
  public void testObjectHashCodeWithSameLowOrderBytes() {
    byte[] bytesA = new byte[5];
    byte[] bytesB = new byte[5];
    bytesA[4] = (byte) 0xbe;
    bytesB[4] = (byte) 0xef;
    HashCode hashCodeA = HashCode.fromBytes(bytesA);
    HashCode hashCodeB = HashCode.fromBytes(bytesB);
    assertFalse(hashCodeA.equals(hashCodeB));
    assertEquals(hashCodeA.hashCode(), hashCodeB.hashCode());
  }
  public void testRoundTripHashCodeUsingFromString() {
    HashCode hash1 = Hashing.sha1().hashString("foo", Charsets.US_ASCII);
    HashCode hash2 = HashCode.fromString(hash1.toString());
    assertEquals(hash1, hash2);
  }
  public void testRoundTrip() {
    for (ExpectedHashCode expected : expectedHashCodes) {
      String string = HashCode.fromBytes(expected.bytes).toString();
      assertEquals(expected.toString, string);
      assertEquals(
          expected.toString,
          HashCode.fromBytes(BaseEncoding.base16().lowerCase().decode(string)).toString());
    }
  }
  public void testFromStringFailsWithInvalidHexChar() {
    try {
      HashCode.fromString("7f8005ff0z");
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
  public void testFromStringFailsWithUpperCaseString() {
    String string = Hashing.sha1().hashString("foo", Charsets.US_ASCII).toString().toUpperCase();
    try {
      HashCode.fromString(string);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
  public void testFromStringFailsWithShortInputs() {
    try {
      HashCode.fromString("");
      fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
      HashCode.fromString("7");
      fail();
    } catch (IllegalArgumentException expected) {
    }
    HashCode unused = HashCode.fromString("7f");
  }
  public void testFromStringFailsWithOddLengthInput() {
    try {
      HashCode.fromString("7f8");
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
  public void testIntWriteBytesTo() {
    byte[] dest = new byte[4];
    HashCode.fromInt(42).writeBytesTo(dest, 0, 4);
    assertTrue(Arrays.equals(HashCode.fromInt(42).asBytes(), dest));
  }
  public void testLongWriteBytesTo() {
    byte[] dest = new byte[8];
    HashCode.fromLong(42).writeBytesTo(dest, 0, 8);
    assertTrue(Arrays.equals(HashCode.fromLong(42).asBytes(), dest));
  }
  private static final HashCode HASH_ABCD =
      HashCode.fromBytes(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd});
  public void testWriteBytesTo() {
    byte[] dest = new byte[4];
    HASH_ABCD.writeBytesTo(dest, 0, 4);
    assertTrue(
        Arrays.equals(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd}, dest));
  }
  public void testWriteBytesToOversizedArray() {
    byte[] dest = new byte[5];
    HASH_ABCD.writeBytesTo(dest, 0, 4);
    assertTrue(
        Arrays.equals(
            new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0x00}, dest));
  }
  public void testWriteBytesToOversizedArrayLongMaxLength() {
    byte[] dest = new byte[5];
    HASH_ABCD.writeBytesTo(dest, 0, 5);
    assertTrue(
        Arrays.equals(
            new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0x00}, dest));
  }
  public void testWriteBytesToOversizedArrayShortMaxLength() {
    byte[] dest = new byte[5];
    HASH_ABCD.writeBytesTo(dest, 0, 3);
    assertTrue(
        Arrays.equals(
            new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0x00, (byte) 0x00}, dest));
  }
  public void testWriteBytesToUndersizedArray() {
    byte[] dest = new byte[3];
    try {
      HASH_ABCD.writeBytesTo(dest, 0, 4);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }
  public void testWriteBytesToUndersizedArrayLongMaxLength() {
    byte[] dest = new byte[3];
    try {
      HASH_ABCD.writeBytesTo(dest, 0, 5);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }
  public void testWriteBytesToUndersizedArrayShortMaxLength() {
    byte[] dest = new byte[3];
    HASH_ABCD.writeBytesTo(dest, 0, 2);
    assertTrue(Arrays.equals(new byte[] {(byte) 0xaa, (byte) 0xbb, (byte) 0x00}, dest));
  }
  private static ClassSanityTester.FactoryMethodReturnValueTester sanityTester() {
    return new ClassSanityTester()
        .setDefault(byte[].class, new byte[] {1, 2, 3, 4})
        .setDistinctValues(byte[].class, new byte[] {1, 2, 3, 4}, new byte[] {5, 6, 7, 8})
        .setDistinctValues(String.class, "7f8005ff0e", "7f8005ff0f")
        .forAllPublicStaticMethods(HashCode.class);
  }
  private static void assertExpectedHashCode(ExpectedHashCode expectedHashCode, HashCode hash) {
    assertTrue(Arrays.equals(expectedHashCode.bytes, hash.asBytes()));
    byte[] bb = new byte[hash.bits() / 8];
    hash.writeBytesTo(bb, 0, bb.length);
    assertTrue(Arrays.equals(expectedHashCode.bytes, bb));
    assertEquals(expectedHashCode.asInt, hash.asInt());
    if (expectedHashCode.asLong == null) {
      try {
        hash.asLong();
        fail();
      } catch (IllegalStateException expected) {
      }
    } else {
      assertEquals(expectedHashCode.asLong.longValue(), hash.asLong());
    }
    assertEquals(expectedHashCode.toString, hash.toString());
    assertSideEffectFree(hash);
    assertReadableBytes(hash);
  }
  private static void assertSideEffectFree(HashCode hash) {
    byte[] original = hash.asBytes();
    byte[] mutated = hash.asBytes();
    mutated[0]++;
    assertTrue(Arrays.equals(original, hash.asBytes()));
  }
  private static void assertReadableBytes(HashCode hashCode) {
    assertTrue(hashCode.bits() &gt;= 32);     byte[] hashBytes = hashCode.asBytes();
    int totalBytes = hashCode.bits() / 8;
    for (int bytes = 0; bytes &lt; totalBytes; bytes++) {
      byte[] bb = new byte[bytes];
      hashCode.writeBytesTo(bb, 0, bb.length);
      assertTrue(Arrays.equals(Arrays.copyOf(hashBytes, bytes), bb));
    }
  }
  private static class ExpectedHashCode {
    final byte[] bytes;
    final int asInt;
    final Long asLong;     final String toString;
    ExpectedHashCode(byte[] bytes, int asInt, Long asLong, String toString) {
      this.bytes = bytes;
      this.asInt = asInt;
      this.asLong = asLong;
      this.toString = toString;
    }
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
