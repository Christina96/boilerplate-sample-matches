<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for FingerprintTrustManagerFactory.java &amp; HttpObjectDecoder.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for FingerprintTrustManagerFactory.java &amp; HttpObjectDecoder.java
      </h3>
<h1 align="center">
        4.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>FingerprintTrustManagerFactory.java (12.355212%)<th>HttpObjectDecoder.java (2.7164686%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(28-84)<td><a href="#" name="0">(18-132)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(118-123)<td><a href="#" name="1">(845-851)</a><td align="center"><font color="#a30000">9</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(102-107)<td><a href="#" name="2">(990-995)</a><td align="center"><font color="#a30000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FingerprintTrustManagerFactory.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.handler.ssl.util;
2 import io.netty.buffer.ByteBufUtil;
3 import io.netty.buffer.Unpooled;
4 import io.netty.util.concurrent.FastThreadLocal;
5 import io.netty.util.internal.EmptyArrays;
6 import io.netty.util.internal.ObjectUtil;
7 import io.netty.util.internal.StringUtil;
8 <a name="0"></a>
9 import javax.net.ssl.ManagerFactoryParameters;
10 import javax.net.ssl.TrustManager;
11 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import javax.net.ssl.TrustManagerFactory;
12 import javax.net.ssl.X509TrustManager;
13 import java.security.KeyStore;
14 import java.security.MessageDigest;
15 import java.security.NoSuchAlgorithmException;
16 import java.security.cert.CertificateEncodingException;
17 import java.security.cert.CertificateException;
18 import java.security.cert.X509Certificate;
19 import java.util.ArrayList;
20 import java.util.Arrays;
21 import java.util.List;
22 import java.util.regex.Pattern;
23 public final class FingerprintTrustManagerFactory extends SimpleTrustManagerFactory {
24     private static final Pattern FINGERPRINT_PATTERN = Pattern.compile("^[0-9a-fA-F:]+$")</b></font>;
25     private static final Pattern FINGERPRINT_STRIP_PATTERN = Pattern.compile(":");
26     public static FingerprintTrustManagerFactoryBuilder builder(String algorithm) {
27         return new FingerprintTrustManagerFactoryBuilder(algorithm);
28     }
29     private final FastThreadLocal&lt;MessageDigest&gt; tlmd;
30 <a name="2"></a>    private final TrustManager tm = new X509TrustManager() {
31         @Override
32         public void checkClientTrusted(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>X509Certificate[] chain, String s) throws CertificateException {
33             checkTrusted("client", chain);
34         }
35         @Override
36         public void checkServerTrusted(X509Certificate[] chain</b></font>, String s) throws CertificateException {
37             checkTrusted("server", chain);
38         }
39         private void checkTrusted(String type, X509Certificate[] chain) throws CertificateException {
40             X509Certificate cert = chain[0];
41             byte[] fingerprint = fingerprint(cert);
42             boolean found = false;
43 <a name="1"></a>            for (byte[] allowedFingerprint: fingerprints) {
44                 if (Arrays.equals(fingerprint, allowedFingerprint)) {
45                     found = true;
46                     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>break;
47                 }
48             }
49             if (!found) {
50                 throw new</b></font> CertificateException(
51                         type + " certificate with unknown fingerprint: " + cert.getSubjectDN());
52             }
53         }
54         private byte[] fingerprint(X509Certificate cert) throws CertificateEncodingException {
55             MessageDigest md = tlmd.get();
56             md.reset();
57             return md.digest(cert.getEncoded());
58         }
59         @Override
60         public X509Certificate[] getAcceptedIssuers() {
61             return EmptyArrays.EMPTY_X509_CERTIFICATES;
62         }
63     };
64     private final byte[][] fingerprints;
65     @Deprecated
66     public FingerprintTrustManagerFactory(Iterable&lt;String&gt; fingerprints) {
67         this("SHA1", toFingerprintArray(fingerprints));
68     }
69     @Deprecated
70     public FingerprintTrustManagerFactory(String... fingerprints) {
71         this("SHA1", toFingerprintArray(Arrays.asList(fingerprints)));
72     }
73     @Deprecated
74     public FingerprintTrustManagerFactory(byte[]... fingerprints) {
75         this("SHA1", fingerprints);
76     }
77     FingerprintTrustManagerFactory(final String algorithm, byte[][] fingerprints) {
78         ObjectUtil.checkNotNull(algorithm, "algorithm");
79         ObjectUtil.checkNotNull(fingerprints, "fingerprints");
80         if (fingerprints.length == 0) {
81             throw new IllegalArgumentException("No fingerprints provided");
82         }
83         final MessageDigest md;
84         try {
85             md = MessageDigest.getInstance(algorithm);
86         } catch (NoSuchAlgorithmException e) {
87             throw new IllegalArgumentException(
88                     String.format("Unsupported hash algorithm: %s", algorithm), e);
89         }
90         int hashLength = md.getDigestLength();
91         List&lt;byte[]&gt; list = new ArrayList&lt;byte[]&gt;(fingerprints.length);
92         for (byte[] f: fingerprints) {
93             if (f == null) {
94                 break;
95             }
96             if (f.length != hashLength) {
97                 throw new IllegalArgumentException(
98                         String.format("malformed fingerprint (length is %d but expected %d): %s",
99                                       f.length, hashLength, ByteBufUtil.hexDump(Unpooled.wrappedBuffer(f))));
100             }
101             list.add(f.clone());
102         }
103         this.tlmd = new FastThreadLocal&lt;MessageDigest&gt;() {
104             @Override
105             protected MessageDigest initialValue() {
106                 try {
107                     return MessageDigest.getInstance(algorithm);
108                 } catch (NoSuchAlgorithmException e) {
109                     throw new IllegalArgumentException(
110                             String.format("Unsupported hash algorithm: %s", algorithm), e);
111                 }
112             }
113         };
114         this.fingerprints = list.toArray(new byte[0][]);
115     }
116     static byte[][] toFingerprintArray(Iterable&lt;String&gt; fingerprints) {
117         ObjectUtil.checkNotNull(fingerprints, "fingerprints");
118         List&lt;byte[]&gt; list = new ArrayList&lt;byte[]&gt;();
119         for (String f: fingerprints) {
120             if (f == null) {
121                 break;
122             }
123             if (!FINGERPRINT_PATTERN.matcher(f).matches()) {
124                 throw new IllegalArgumentException("malformed fingerprint: " + f);
125             }
126             f = FINGERPRINT_STRIP_PATTERN.matcher(f).replaceAll("");
127             list.add(StringUtil.decodeHexDump(f));
128         }
129         return list.toArray(new byte[0][]);
130     }
131     @Override
132     protected void engineInit(KeyStore keyStore) throws Exception { }
133     @Override
134     protected void engineInit(ManagerFactoryParameters managerFactoryParameters) throws Exception { }
135     @Override
136     protected TrustManager[] engineGetTrustManagers() {
137         return new TrustManager[] { tm };
138     }
139 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HttpObjectDecoder.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.handler.codec.http;
2 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import static io.netty.util.internal.ObjectUtil.checkPositive;
3 import io.netty.buffer.ByteBuf;
4 import io.netty.buffer.Unpooled;
5 import io.netty.channel.ChannelHandlerContext;
6 import io.netty.channel.ChannelPipeline;
7 import io.netty.handler.codec.ByteToMessageDecoder;
8 import io.netty.handler.codec.DecoderResult;
9 import io.netty.handler.codec.PrematureChannelClosureException;
10 import io.netty.handler.codec.TooLongFrameException;
11 import io.netty.util.ByteProcessor;
12 import io.netty.util.internal.AppendableCharSequence;
13 import java.util.List;
14 public abstract class HttpObjectDecoder extends ByteToMessageDecoder {
15     public static final int DEFAULT_MAX_INITIAL_LINE_LENGTH = 4096</b></font>;
16     public static final int DEFAULT_MAX_HEADER_SIZE = 8192;
17     public static final boolean DEFAULT_CHUNKED_SUPPORTED = true;
18     public static final boolean DEFAULT_ALLOW_PARTIAL_CHUNKS = true;
19     public static final int DEFAULT_MAX_CHUNK_SIZE = 8192;
20     public static final boolean DEFAULT_VALIDATE_HEADERS = true;
21     public static final int DEFAULT_INITIAL_BUFFER_SIZE = 128;
22     public static final boolean DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS = false;
23     private static final String EMPTY_VALUE = "";
24     private final int maxChunkSize;
25     private final boolean chunkedSupported;
26     private final boolean allowPartialChunks;
27     protected final boolean validateHeaders;
28     private final boolean allowDuplicateContentLengths;
29     private final HeaderParser headerParser;
30     private final LineParser lineParser;
31     private HttpMessage message;
32     private long chunkSize;
33     private long contentLength = Long.MIN_VALUE;
34     private volatile boolean resetRequested;
35     private CharSequence name;
36     private CharSequence value;
37     private LastHttpContent trailer;
38     private enum State {
39         SKIP_CONTROL_CHARS,
40         READ_INITIAL,
41         READ_HEADER,
42         READ_VARIABLE_LENGTH_CONTENT,
43         READ_FIXED_LENGTH_CONTENT,
44         READ_CHUNK_SIZE,
45         READ_CHUNKED_CONTENT,
46         READ_CHUNK_DELIMITER,
47         READ_CHUNK_FOOTER,
48         BAD_MESSAGE,
49         UPGRADED
50     }
51     private State currentState = State.SKIP_CONTROL_CHARS;
52     protected HttpObjectDecoder() {
53         this(DEFAULT_MAX_INITIAL_LINE_LENGTH, DEFAULT_MAX_HEADER_SIZE, DEFAULT_MAX_CHUNK_SIZE,
54              DEFAULT_CHUNKED_SUPPORTED);
55     }
56     protected HttpObjectDecoder(
57             int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean chunkedSupported) {
58         this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, DEFAULT_VALIDATE_HEADERS);
59     }
60     protected HttpObjectDecoder(
61             int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,
62             boolean chunkedSupported, boolean validateHeaders) {
63         this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders,
64              DEFAULT_INITIAL_BUFFER_SIZE);
65     }
66     protected HttpObjectDecoder(
67             int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,
68             boolean chunkedSupported, boolean validateHeaders, int initialBufferSize) {
69         this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,
70              DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS);
71     }
72     protected HttpObjectDecoder(
73             int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,
74             boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,
75             boolean allowDuplicateContentLengths) {
76         this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,
77             allowDuplicateContentLengths, DEFAULT_ALLOW_PARTIAL_CHUNKS);
78     }
79     protected HttpObjectDecoder(
80             int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,
81             boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,
82             boolean allowDuplicateContentLengths, boolean allowPartialChunks) {
83         checkPositive(maxInitialLineLength, "maxInitialLineLength");
84         checkPositive(maxHeaderSize, "maxHeaderSize");
85         checkPositive(maxChunkSize, "maxChunkSize");
86         AppendableCharSequence seq = new AppendableCharSequence(initialBufferSize);
87         lineParser = new LineParser(seq, maxInitialLineLength);
88         headerParser = new HeaderParser(seq, maxHeaderSize);
89         this.maxChunkSize = maxChunkSize;
90         this.chunkedSupported = chunkedSupported;
91         this.validateHeaders = validateHeaders;
92         this.allowDuplicateContentLengths = allowDuplicateContentLengths;
93         this.allowPartialChunks = allowPartialChunks;
94     }
95     @Override
96     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List&lt;Object&gt; out) throws Exception {
97         if (resetRequested) {
98             resetNow();
99         }
100         switch (currentState) {
101         case SKIP_CONTROL_CHARS:
102         case READ_INITIAL: try {
103             AppendableCharSequence line = lineParser.parse(buffer);
104             if (line == null) {
105                 return;
106             }
107             String[] initialLine = splitInitialLine(line);
108             if (initialLine.length &lt; 3) {
109                 currentState = State.SKIP_CONTROL_CHARS;
110                 return;
111             }
112             message = createMessage(initialLine);
113             currentState = State.READ_HEADER;
114         } catch (Exception e) {
115             out.add(invalidMessage(buffer, e));
116             return;
117         }
118         case READ_HEADER: try {
119             State nextState = readHeaders(buffer);
120             if (nextState == null) {
121                 return;
122             }
123             currentState = nextState;
124             switch (nextState) {
125             case SKIP_CONTROL_CHARS:
126                 out.add(message);
127                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
128                 resetNow();
129                 return;
130             case READ_CHUNK_SIZE:
131                 if (!chunkedSupported) {
132                     throw new IllegalArgumentException("Chunked messages not supported");
133                 }
134                 out.add(message);
135                 return;
136             default:
137                 long contentLength = contentLength();
138                 if (contentLength == 0 || contentLength == -1 &amp;&amp; isDecodingRequest()) {
139                     out.add(message);
140                     out.add(LastHttpContent.EMPTY_LAST_CONTENT);
141                     resetNow();
142                     return;
143                 }
144                 assert nextState == State.READ_FIXED_LENGTH_CONTENT ||
145                         nextState == State.READ_VARIABLE_LENGTH_CONTENT;
146                 out.add(message);
147                 if (nextState == State.READ_FIXED_LENGTH_CONTENT) {
148                     chunkSize = contentLength;
149                 }
150                 return;
151             }
152         } catch (Exception e) {
153             out.add(invalidMessage(buffer, e));
154             return;
155         }
156         case READ_VARIABLE_LENGTH_CONTENT: {
157             int toRead = Math.min(buffer.readableBytes(), maxChunkSize);
158             if (toRead &gt; 0) {
159                 ByteBuf content = buffer.readRetainedSlice(toRead);
160                 out.add(new DefaultHttpContent(content));
161             }
162             return;
163         }
164         case READ_FIXED_LENGTH_CONTENT: {
165             int readLimit = buffer.readableBytes();
166             //
167             if (readLimit == 0) {
168                 return;
169             }
170             int toRead = Math.min(readLimit, maxChunkSize);
171             if (toRead &gt; chunkSize) {
172                 toRead = (int) chunkSize;
173             }
174             ByteBuf content = buffer.readRetainedSlice(toRead);
175             chunkSize -= toRead;
176             if (chunkSize == 0) {
177                 out.add(new DefaultLastHttpContent(content, validateHeaders));
178                 resetNow();
179             } else {
180                 out.add(new DefaultHttpContent(content));
181             }
182             return;
183         }
184         case READ_CHUNK_SIZE: try {
185             AppendableCharSequence line = lineParser.parse(buffer);
186             if (line == null) {
187                 return;
188             }
189             int chunkSize = getChunkSize(line.toString());
190             this.chunkSize = chunkSize;
191             if (chunkSize == 0) {
192                 currentState = State.READ_CHUNK_FOOTER;
193                 return;
194             }
195             currentState = State.READ_CHUNKED_CONTENT;
196         } catch (Exception e) {
197             out.add(invalidChunk(buffer, e));
198             return;
199         }
200         case READ_CHUNKED_CONTENT: {
201             assert chunkSize &lt;= Integer.MAX_VALUE;
202             int toRead = Math.min((int) chunkSize, maxChunkSize);
203             if (!allowPartialChunks &amp;&amp; buffer.readableBytes() &lt; toRead) {
204                 return;
205             }
206             toRead = Math.min(toRead, buffer.readableBytes());
207             if (toRead == 0) {
208                 return;
209             }
210             HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));
211             chunkSize -= toRead;
212             out.add(chunk);
213             if (chunkSize != 0) {
214                 return;
215             }
216             currentState = State.READ_CHUNK_DELIMITER;
217         }
218         case READ_CHUNK_DELIMITER: {
219             final int wIdx = buffer.writerIndex();
220             int rIdx = buffer.readerIndex();
221             while (wIdx &gt; rIdx) {
222                 byte next = buffer.getByte(rIdx++);
223                 if (next == HttpConstants.LF) {
224                     currentState = State.READ_CHUNK_SIZE;
225                     break;
226                 }
227             }
228             buffer.readerIndex(rIdx);
229             return;
230         }
231         case READ_CHUNK_FOOTER: try {
232             LastHttpContent trailer = readTrailingHeaders(buffer);
233             if (trailer == null) {
234                 return;
235             }
236             out.add(trailer);
237             resetNow();
238             return;
239         } catch (Exception e) {
240             out.add(invalidChunk(buffer, e));
241             return;
242         }
243         case BAD_MESSAGE: {
244             buffer.skipBytes(buffer.readableBytes());
245             break;
246         }
247         case UPGRADED: {
248             int readableBytes = buffer.readableBytes();
249             if (readableBytes &gt; 0) {
250                 out.add(buffer.readBytes(readableBytes));
251             }
252             break;
253         }
254         default:
255             break;
256         }
257     }
258     @Override
259     protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
260         super.decodeLast(ctx, in, out);
261         if (resetRequested) {
262             resetNow();
263         }
264         if (message != null) {
265             boolean chunked = HttpUtil.isTransferEncodingChunked(message);
266             if (currentState == State.READ_VARIABLE_LENGTH_CONTENT &amp;&amp; !in.isReadable() &amp;&amp; !chunked) {
267                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
268                 resetNow();
269                 return;
270             }
271             if (currentState == State.READ_HEADER) {
272                 out.add(invalidMessage(Unpooled.EMPTY_BUFFER,
273                         new PrematureChannelClosureException("Connection closed before received headers")));
274                 resetNow();
275                 return;
276             }
277             boolean prematureClosure;
278             if (isDecodingRequest() || chunked) {
279                 prematureClosure = true;
280             } else {
281                 prematureClosure = contentLength() &gt; 0;
282             }
283             if (!prematureClosure) {
284                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
285             }
286             resetNow();
287         }
288     }
289     @Override
290     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
291         if (evt instanceof HttpExpectationFailedEvent) {
292             switch (currentState) {
293             case READ_FIXED_LENGTH_CONTENT:
294             case READ_VARIABLE_LENGTH_CONTENT:
295             case READ_CHUNK_SIZE:
296                 reset();
297                 break;
298             default:
299                 break;
300             }
301         }
302         super.userEventTriggered(ctx, evt);
303     }
304     protected boolean isContentAlwaysEmpty(HttpMessage msg) {
305         if (msg instanceof HttpResponse) {
306             HttpResponse res = (HttpResponse) msg;
307             int code = res.status().code();
308             //
309             if (code &gt;= 100 &amp;&amp; code &lt; 200) {
310                 return !(code == 101 &amp;&amp; !res.headers().contains(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT)
311                          &amp;&amp; res.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true));
312             }
313             switch (code) {
314             case 204: case 304:
315                 return true;
316             default:
317                 return false;
318             }
319         }
320         return false;
321     }
322     protected boolean isSwitchingToNonHttp1Protocol(HttpResponse msg) {
323         if (msg.status().code() != HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {
324             return false;
325         }
326         String newProtocol = msg.headers().get(HttpHeaderNames.UPGRADE);
327         return newProtocol == null ||
328                 !newProtocol.contains(HttpVersion.HTTP_1_0.text()) &amp;&amp;
329                 !newProtocol.contains(HttpVersion.HTTP_1_1.text());
330     }
331     public void reset() {
332         resetRequested = true;
333     }
334     private void resetNow() {
335         HttpMessage message = this.message;
336         this.message = null;
337         name = null;
338         value = null;
339         contentLength = Long.MIN_VALUE;
340         lineParser.reset();
341         headerParser.reset();
342         trailer = null;
343         if (!isDecodingRequest()) {
344             HttpResponse res = (HttpResponse) message;
345             if (res != null &amp;&amp; isSwitchingToNonHttp1Protocol(res)) {
346                 currentState = State.UPGRADED;
347                 return;
348             }
349         }
350         resetRequested = false;
351         currentState = State.SKIP_CONTROL_CHARS;
352     }
353     private HttpMessage invalidMessage(ByteBuf in, Exception cause) {
354         currentState = State.BAD_MESSAGE;
355         in.skipBytes(in.readableBytes());
356         if (message == null) {
357             message = createInvalidMessage();
358         }
359         message.setDecoderResult(DecoderResult.failure(cause));
360         HttpMessage ret = message;
361         message = null;
362         return ret;
363     }
364     private HttpContent invalidChunk(ByteBuf in, Exception cause) {
365         currentState = State.BAD_MESSAGE;
366         in.skipBytes(in.readableBytes());
367         HttpContent chunk = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER);
368         chunk.setDecoderResult(DecoderResult.failure(cause));
369         message = null;
370         trailer = null;
371         return chunk;
372     }
373     private State readHeaders(ByteBuf buffer) {
374         final HttpMessage message = this.message;
375         final HttpHeaders headers = message.headers();
376         AppendableCharSequence line = headerParser.parse(buffer);
377         if (line == null) {
378             return null;
379         }
380         if (line.length() &gt; 0) {
381             do {
382                 char firstChar = line.charAtUnsafe(0);
383                 if (name != null &amp;&amp; (firstChar == ' ' || firstChar == '\t')) {
384                     //please do not make one line from below code
385                     //as it breaks +XX:OptimizeStringConcat optimization
386                     String trimmedLine = line.toString().trim();
387                     String valueStr = String.valueOf(value);
388                     value = valueStr + ' ' + trimmedLine;
389                 } else {
390                     if (name != null) {
391                         headers.add(name, value);
392                     }
393                     splitHeader(line);
394                 }
395                 line = headerParser.parse(buffer);
396                 if (line == null) {
397                     return null;
398                 }
399             } while (line.length() &gt; 0);
400         }
401         if (name != null) {
402             headers.add(name, value);
403         }
404         name = null;
405         value = null;
406         HttpMessageDecoderResult decoderResult = new HttpMessageDecoderResult(lineParser.size, headerParser.size);
407         message.setDecoderResult(decoderResult);
408         List&lt;String&gt; contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);
409         if (!contentLengthFields.isEmpty()) {
410             HttpVersion version = message.protocolVersion();
411             boolean isHttp10OrEarlier = version.majorVersion() &lt; 1 || (version.majorVersion() == 1
412                     &amp;&amp; version.minorVersion() == 0);
413             contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,
414                     isHttp10OrEarlier, allowDuplicateContentLengths);
415             if (contentLength != -1) {
416                 headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);
417             }
418         }
419         if (isContentAlwaysEmpty(message)) {
420             HttpUtil.setTransferEncodingChunked(message, false);
421             return State.SKIP_CONTROL_CHARS;
422         } else if (HttpUtil.isTransferEncodingChunked(message)) {
423             if (!contentLengthFields.isEmpty() &amp;&amp; message.protocolVersion() == HttpVersion.HTTP_1_1) {
424                 handleTransferEncodingChunkedWithContentLength(message);
425             }
426             return State.READ_CHUNK_SIZE;
427         } else if (contentLength() &gt;= 0) {
428             return State.READ_FIXED_LENGTH_CONTENT;
429         } else {
430             return State.READ_VARIABLE_LENGTH_CONTENT;
431         }
432     }
433     protected void handleTransferEncodingChunkedWithContentLength(HttpMessage message) {
434         message.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
435         contentLength = Long.MIN_VALUE;
436     }
437     private long contentLength() {
438         if (contentLength == Long.MIN_VALUE) {
439             contentLength = HttpUtil.getContentLength(message, -1L);
440         }
441         return contentLength;
442     }
443     private LastHttpContent readTrailingHeaders(ByteBuf buffer) {
444         AppendableCharSequence line = headerParser.parse(buffer);
445         if (line == null) {
446             return null;
447         }
448         LastHttpContent trailer = this.trailer;
449         if (line.length() == 0 &amp;&amp; trailer == null) {
450             return LastHttpContent.EMPTY_LAST_CONTENT;
451         }
452         CharSequence lastHeader = null;
453         if (trailer == null) {
454             trailer = this.trailer = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);
455         }
456         while (line.length() &gt; 0) {
457             char firstChar = line.charAtUnsafe(0);
458             if (lastHeader != null &amp;&amp; (firstChar == ' ' || firstChar == '\t')) {
459                 List&lt;String&gt; current = trailer.trailingHeaders().getAll(lastHeader);
460                 if (!current.isEmpty()) {
461                     int lastPos = current.size() - 1;
462                     //please do not make one line from below code
463                     //as it breaks +XX:OptimizeStringConcat optimization
464                     String lineTrimmed = line.toString().trim();
465                     String currentLastPos = current.get(lastPos);
466                     current.set(lastPos, currentLastPos + lineTrimmed);
467                 }
468             } else {
469                 splitHeader(line);
470                 CharSequence headerName = name;
471                 if (!HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase(headerName) &amp;&amp;
472                         !HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase(headerName) &amp;&amp;
473                         !HttpHeaderNames.TRAILER.contentEqualsIgnoreCase(headerName)) {
474                     trailer.trailingHeaders().add(headerName, value);
475                 }
476                 lastHeader = name;
477                 name = null;
478                 value = null;
479             }
480             line = headerParser.parse(buffer);
481             if (line == null) {
482                 return null;
483             }
484         }
485         this.trailer = null;
486         return trailer;
487     }
488     protected abstract boolean isDecodingRequest();
489     protected abstract HttpMessage createMessage(String[] initialLine) throws Exception;
490     protected abstract HttpMessage createInvalidMessage();
491     private static int getChunkSize(String hex) {
492         hex = hex.trim();
493         for (int i = 0; i &lt; hex.length(); i ++) {
494             char c = hex.charAt(i);
495             if (c == ';' || Character.isWhitespace(c) || Character.isISOControl(c)) {
496                 hex = hex.substring(0, i);
497                 break;
498             }
499         }
500         return Integer.parseInt(hex, 16);
501     }
502     private static String[] splitInitialLine(AppendableCharSequence sb) {
503         int aStart;
504         int aEnd;
505         int bStart;
506         int bEnd;
507         int cStart;
508         int cEnd;
509         aStart = findNonSPLenient(sb, 0);
510         aEnd = findSPLenient(sb, aStart);
511         bStart = findNonSPLenient(sb, aEnd);
512         bEnd = findSPLenient(sb, bStart);
513         cStart = findNonSPLenient(sb, bEnd);
514         cEnd = findEndOfString(sb);
515         return new String[] {
516                 sb.subStringUnsafe(aStart, aEnd),
517                 sb.subStringUnsafe(bStart, bEnd),
518                 cStart &lt; cEnd? sb.subStringUnsafe(cStart, cEnd) : "" };
519     }
520     private void splitHeader(AppendableCharSequence sb) {
521         final int length = sb.length();
522         int nameStart;
523         int nameEnd;
524         int colonEnd;
525         int valueStart;
526         int valueEnd;
527         nameStart = findNonWhitespace(sb, 0);
528         for (nameEnd = nameStart; nameEnd &lt; length; nameEnd ++) {
529             char ch = sb.charAtUnsafe(nameEnd);
530             //
531             if (ch == ':' ||
532 <a name="1"></a>                    //
533                     (!isDecodingRequest() &amp;&amp; isOWS(ch))) {
534                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>break;
535             }
536         }
537         if (nameEnd == length) {
538             throw new</b></font> IllegalArgumentException("No colon found");
539         }
540         for (colonEnd = nameEnd; colonEnd &lt; length; colonEnd ++) {
541             if (sb.charAtUnsafe(colonEnd) == ':') {
542                 colonEnd ++;
543                 break;
544             }
545         }
546         name = sb.subStringUnsafe(nameStart, nameEnd);
547         valueStart = findNonWhitespace(sb, colonEnd);
548         if (valueStart == length) {
549             value = EMPTY_VALUE;
550         } else {
551             valueEnd = findEndOfString(sb);
552             value = sb.subStringUnsafe(valueStart, valueEnd);
553         }
554     }
555     private static int findNonSPLenient(AppendableCharSequence sb, int offset) {
556         for (int result = offset; result &lt; sb.length(); ++result) {
557             char c = sb.charAtUnsafe(result);
558             if (isSPLenient(c)) {
559                 continue;
560             }
561             if (Character.isWhitespace(c)) {
562                 throw new IllegalArgumentException("Invalid separator");
563             }
564             return result;
565         }
566         return sb.length();
567     }
568     private static int findSPLenient(AppendableCharSequence sb, int offset) {
569         for (int result = offset; result &lt; sb.length(); ++result) {
570             if (isSPLenient(sb.charAtUnsafe(result))) {
571                 return result;
572             }
573         }
574         return sb.length();
575     }
576     private static boolean isSPLenient(char c) {
577         return c == ' ' || c == (char) 0x09 || c == (char) 0x0B || c == (char) 0x0C || c == (char) 0x0D;
578     }
579     private static int findNonWhitespace(AppendableCharSequence sb, int offset) {
580         for (int result = offset; result &lt; sb.length(); ++result) {
581             char c = sb.charAtUnsafe(result);
582             if (!Character.isWhitespace(c)) {
583                 return result;
584             } else if (!isOWS(c)) {
585                 throw new IllegalArgumentException("Invalid separator, only a single space or horizontal tab allowed," +
586                         " but received a '" + c + "' (0x" + Integer.toHexString(c) + ")");
587             }
588         }
589         return sb.length();
590     }
591     private static int findEndOfString(AppendableCharSequence sb) {
592         for (int result = sb.length() - 1; result &gt; 0; --result) {
593             if (!Character.isWhitespace(sb.charAtUnsafe(result))) {
594                 return result + 1;
595             }
596         }
597         return 0;
598     }
599     private static boolean isOWS(char ch) {
600         return ch == ' ' || ch == (char) 0x09;
601     }
602     private static class HeaderParser implements ByteProcessor {
603         private final AppendableCharSequence seq;
604         private final int maxLength;
605         int size;
606         HeaderParser(AppendableCharSequence seq, int maxLength) {
607             this.seq = seq;
608             this.maxLength = maxLength;
609         }
610         public AppendableCharSequence parse(ByteBuf buffer) {
611             final int oldSize = size;
612             seq.reset();
613             int i = buffer.forEachByte(this);
614             if (i == -1) {
615                 size = oldSize;
616                 return null;
617             }
618             buffer.readerIndex(i + 1);
619             return seq;
620         }
621         public void reset() {
622             size = 0;
623         }
624         @Override
625         public boolean process(byte value) throws Exception {
626             char nextByte = (char) (value &amp; 0xFF);
627             if (nextByte == HttpConstants.LF) {
628                 int len = seq.length();
629                 if (len &gt;= 1 &amp;&amp; seq.charAtUnsafe(len - 1) == HttpConstants.CR) {
630                     -- size;
631                     seq.setLength(len - 1);
632                 }
633                 return false;
634             }
635             increaseCount();
636             seq.append(nextByte);
637             return true;
638         }
639         protected final void increaseCount() {
640             if (++ size &gt; maxLength) {
641                 throw newException(maxLength);
642             }
643         }
644         protected TooLongFrameException newException(int maxLength) {
645             return new TooLongHttpHeaderException("HTTP header is larger than " + maxLength + " bytes.");
646         }
647     }
648 <a name="2"></a>
649     private final class LineParser extends HeaderParser {
650         LineParser(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>AppendableCharSequence seq, int maxLength) {
651             super(seq, maxLength);
652         }
653         @Override
654         public AppendableCharSequence parse(ByteBuf buffer</b></font>) {
655             reset();                return super.parse(buffer);
656         }
657         @Override
658         public boolean process(byte value) throws Exception {
659             if (currentState == State.SKIP_CONTROL_CHARS) {
660                 char c = (char) (value &amp; 0xFF);
661                 if (Character.isISOControl(c) || Character.isWhitespace(c)) {
662                     increaseCount();
663                     return true;
664                 }
665                 currentState = State.READ_INITIAL;
666             }
667             return super.process(value);
668         }
669         @Override
670         protected TooLongFrameException newException(int maxLength) {
671             return new TooLongHttpLineException("An HTTP line is larger than " + maxLength + " bytes.");
672         }
673     }
674 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
