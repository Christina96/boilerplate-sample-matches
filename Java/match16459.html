<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for DefaultHttp2ConnectionEncoderTest.java & OpenSslEngineTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for DefaultHttp2ConnectionEncoderTest.java & OpenSslEngineTest.java
      </h3>
      <h1 align="center">
        39.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>DefaultHttp2ConnectionEncoderTest.java (49.252804%)<TH>OpenSslEngineTest.java (33.573853%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#0',2,'match16459-1.html#0',3)" NAME="0">(23-83)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#0',2,'match16459-1.html#0',3)" NAME="0">(18-75)</A><TD ALIGN=center><FONT COLOR="#ff0000">55</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#1',2,'match16459-1.html#1',3)" NAME="1">(549-559)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#1',2,'match16459-1.html#1',3)" NAME="1">(607-632)</A><TD ALIGN=center><FONT COLOR="#7d0000">27</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#2',2,'match16459-1.html#2',3)" NAME="2">(465-475)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#2',2,'match16459-1.html#2',3)" NAME="2">(540-564)</A><TD ALIGN=center><FONT COLOR="#7d0000">27</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#3',2,'match16459-1.html#3',3)" NAME="3">(314-331)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#3',2,'match16459-1.html#3',3)" NAME="3">(649-671)</A><TD ALIGN=center><FONT COLOR="#6f0000">24</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#4',2,'match16459-1.html#4',3)" NAME="4">(287-302)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#4',2,'match16459-1.html#4',3)" NAME="4">(572-593)</A><TD ALIGN=center><FONT COLOR="#6f0000">24</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#5',2,'match16459-1.html#5',3)" NAME="5">(804-812)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#5',2,'match16459-1.html#5',3)" NAME="5">(705-722)</A><TD ALIGN=center><FONT COLOR="#5c0000">20</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#6',2,'match16459-1.html#6',3)" NAME="6">(373-382)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#6',2,'match16459-1.html#6',3)" NAME="6">(301-310)</A><TD ALIGN=center><FONT COLOR="#530000">18</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#7',2,'match16459-1.html#7',3)" NAME="7">(265-273)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#7',2,'match16459-1.html#7',3)" NAME="7">(315-321)</A><TD ALIGN=center><FONT COLOR="#4e0000">17</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#8',2,'match16459-1.html#8',3)" NAME="8">(587-596)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#8',2,'match16459-1.html#8',3)" NAME="8">(346-353)</A><TD ALIGN=center><FONT COLOR="#4a0000">16</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#9',2,'match16459-1.html#9',3)" NAME="9">(780-787)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#9',2,'match16459-1.html#9',3)" NAME="9">(953-962)</A><TD ALIGN=center><FONT COLOR="#450000">15</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#10',2,'match16459-1.html#10',3)" NAME="10">(728-735)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#10',2,'match16459-1.html#10',3)" NAME="10">(794-802)</A><TD ALIGN=center><FONT COLOR="#450000">15</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#11',2,'match16459-1.html#11',3)" NAME="11">(661-668)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#11',2,'match16459-1.html#11',3)" NAME="11">(1055-1064)</A><TD ALIGN=center><FONT COLOR="#450000">15</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#12',2,'match16459-1.html#12',3)" NAME="12">(400-407)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#12',2,'match16459-1.html#12',3)" NAME="12">(777-785)</A><TD ALIGN=center><FONT COLOR="#400000">14</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#13',2,'match16459-1.html#13',3)" NAME="13">(334-339)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#13',2,'match16459-1.html#13',3)" NAME="13">(677-684)</A><TD ALIGN=center><FONT COLOR="#400000">14</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#14',2,'match16459-1.html#14',3)" NAME="14">(204-208)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#14',2,'match16459-1.html#14',3)" NAME="14">(724-740)</A><TD ALIGN=center><FONT COLOR="#400000">14</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#15',2,'match16459-1.html#15',3)" NAME="15">(429-437)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#15',2,'match16459-1.html#15',3)" NAME="15">(291-300)</A><TD ALIGN=center><FONT COLOR="#3c0000">13</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#16',2,'match16459-1.html#16',3)" NAME="16">(253-259)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#16',2,'match16459-1.html#16',3)" NAME="16">(356-362)</A><TD ALIGN=center><FONT COLOR="#3c0000">13</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#17',2,'match16459-1.html#17',3)" NAME="17">(124-128)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#17',2,'match16459-1.html#17',3)" NAME="17">(820-832)</A><TD ALIGN=center><FONT COLOR="#3c0000">13</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#18',2,'match16459-1.html#18',3)" NAME="18">(681-688)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#18',2,'match16459-1.html#18',3)" NAME="18">(878-881)</A><TD ALIGN=center><FONT COLOR="#370000">12</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#19',2,'match16459-1.html#19',3)" NAME="19">(603-608)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#19',2,'match16459-1.html#19',3)" NAME="19">(1556-1562)</A><TD ALIGN=center><FONT COLOR="#370000">12</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#20',2,'match16459-1.html#20',3)" NAME="20">(539-546)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#20',2,'match16459-1.html#20',3)" NAME="20">(499-506)</A><TD ALIGN=center><FONT COLOR="#370000">12</FONT>
<TR><TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#21',2,'match16459-1.html#21',3)" NAME="21">(243-250)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#21',2,'match16459-1.html#21',3)" NAME="21">(868-874)</A><TD ALIGN=center><FONT COLOR="#370000">12</FONT>
<TR><TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#22',2,'match16459-1.html#22',3)" NAME="22">(176-177)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#22',2,'match16459-1.html#22',3)" NAME="22">(986-994)</A><TD ALIGN=center><FONT COLOR="#370000">12</FONT>
<TR><TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#23',2,'match16459-1.html#23',3)" NAME="23">(135-140)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#23',2,'match16459-1.html#23',3)" NAME="23">(640-648)</A><TD ALIGN=center><FONT COLOR="#370000">12</FONT>
<TR><TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#24',2,'match16459-1.html#24',3)" NAME="24">(901-905)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#24',2,'match16459-1.html#24',3)" NAME="24">(940-944)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#5eac10"><FONT COLOR="#5eac10">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#25',2,'match16459-1.html#25',3)" NAME="25">(840-845)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#25',2,'match16459-1.html#25',3)" NAME="25">(931-936)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#68818b"><FONT COLOR="#68818b">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#26',2,'match16459-1.html#26',3)" NAME="26">(828-833)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#26',2,'match16459-1.html#26',3)" NAME="26">(859-863)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#e77471"><FONT COLOR="#e77471">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#27',2,'match16459-1.html#27',3)" NAME="27">(817-820)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#27',2,'match16459-1.html#27',3)" NAME="27">(850-855)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#717d7d"><FONT COLOR="#717d7d">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#28',2,'match16459-1.html#28',3)" NAME="28">(761-767)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#28',2,'match16459-1.html#28',3)" NAME="28">(78-84)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#af7a82"><FONT COLOR="#af7a82">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#29',2,'match16459-1.html#29',3)" NAME="29">(621-625)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#29',2,'match16459-1.html#29',3)" NAME="29">(768-772)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#ae694a"><FONT COLOR="#ae694a">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#30',2,'match16459-1.html#30',3)" NAME="30">(598-600)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#30',2,'match16459-1.html#30',3)" NAME="30">(759-764)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#3ea99f"><FONT COLOR="#3ea99f">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#31',2,'match16459-1.html#31',3)" NAME="31">(523-531)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#31',2,'match16459-1.html#31',3)" NAME="31">(89-97)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#5b8daf"><FONT COLOR="#5b8daf">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#32',2,'match16459-1.html#32',3)" NAME="32">(511-513)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#32',2,'match16459-1.html#32',3)" NAME="32">(686-690)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#736aff"><FONT COLOR="#736aff">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#33',2,'match16459-1.html#33',3)" NAME="33">(506-510)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#33',2,'match16459-1.html#33',3)" NAME="33">(472-475)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#827d6b"><FONT COLOR="#827d6b">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#34',2,'match16459-1.html#34',3)" NAME="34">(438-442)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#34',2,'match16459-1.html#34',3)" NAME="34">(378-381)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#41a317"><FONT COLOR="#41a317">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#35',2,'match16459-1.html#35',3)" NAME="35">(419-423)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#35',2,'match16459-1.html#35',3)" NAME="35">(337-340)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#ff00ff"><FONT COLOR="#ff00ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#36',2,'match16459-1.html#36',3)" NAME="36">(391-395)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#36',2,'match16459-1.html#36',3)" NAME="36">(281-284)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#810541"><FONT COLOR="#810541">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#37',2,'match16459-1.html#37',3)" NAME="37">(362-367)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#37',2,'match16459-1.html#37',3)" NAME="37">(242-245)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#348781"><FONT COLOR="#348781">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#38',2,'match16459-1.html#38',3)" NAME="38">(129-132)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#38',2,'match16459-1.html#38',3)" NAME="38">(1348-1351)</A><TD ALIGN=center><FONT COLOR="#330000">11</FONT>
<TR><TD BGCOLOR="#152dc6"><FONT COLOR="#152dc6">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#39',2,'match16459-1.html#39',3)" NAME="39">(891-894)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#39',2,'match16459-1.html#39',3)" NAME="39">(442-446)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#347235"><FONT COLOR="#347235">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#40',2,'match16459-1.html#40',3)" NAME="40">(881-884)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#40',2,'match16459-1.html#40',3)" NAME="40">(423-427)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#f87a17"><FONT COLOR="#f87a17">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#41',2,'match16459-1.html#41',3)" NAME="41">(862-865)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#41',2,'match16459-1.html#41',3)" NAME="41">(371-375)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#c57717"><FONT COLOR="#c57717">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#42',2,'match16459-1.html#42',3)" NAME="42">(717-723)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#42',2,'match16459-1.html#42',3)" NAME="42">(791-794)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#c22817"><FONT COLOR="#c22817">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#43',2,'match16459-1.html#43',3)" NAME="43">(673-675)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#43',2,'match16459-1.html#43',3)" NAME="43">(330-334)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#a057a5"><FONT COLOR="#a057a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#44',2,'match16459-1.html#44',3)" NAME="44">(651-656)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#44',2,'match16459-1.html#44',3)" NAME="44">(214-222)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#549748"><FONT COLOR="#549748">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#45',2,'match16459-1.html#45',3)" NAME="45">(644-647)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#45',2,'match16459-1.html#45',3)" NAME="45">(274-278)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#668b8b"><FONT COLOR="#668b8b">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#46',2,'match16459-1.html#46',3)" NAME="46">(632-634)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#46',2,'match16459-1.html#46',3)" NAME="46">(235-239)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#d16587"><FONT COLOR="#d16587">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#47',2,'match16459-1.html#47',3)" NAME="47">(612-618)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#47',2,'match16459-1.html#47',3)" NAME="47">(1564-1568)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#c57726"><FONT COLOR="#c57726">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#48',2,'match16459-1.html#48',3)" NAME="48">(600-603)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#48',2,'match16459-1.html#48',3)" NAME="48">(1453-1457)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#8e35ef"><FONT COLOR="#8e35ef">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#49',2,'match16459-1.html#49',3)" NAME="49">(514-516)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#49',2,'match16459-1.html#49',3)" NAME="49">(1237-1251)</A><TD ALIGN=center><FONT COLOR="#2e0000">10</FONT>
<TR><TD BGCOLOR="#ff0000"><FONT COLOR="#ff0000">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#50',2,'match16459-1.html#50',3)" NAME="50">(795-795)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#50',2,'match16459-1.html#50',3)" NAME="50">(1072-1073)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#b38481"><FONT COLOR="#b38481">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#51',2,'match16459-1.html#51',3)" NAME="51">(769-769)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#51',2,'match16459-1.html#51',3)" NAME="51">(976-984)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#2b60de"><FONT COLOR="#2b60de">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#52',2,'match16459-1.html#52',3)" NAME="52">(754-759)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#52',2,'match16459-1.html#52',3)" NAME="52">(1291-1305)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#ad5a3d"><FONT COLOR="#ad5a3d">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#53',2,'match16459-1.html#53',3)" NAME="53">(745-749)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#53',2,'match16459-1.html#53',3)" NAME="53">(967-975)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#4e8975"><FONT COLOR="#4e8975">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#54',2,'match16459-1.html#54',3)" NAME="54">(693-696)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#54',2,'match16459-1.html#54',3)" NAME="54">(811-815)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#4863a0"><FONT COLOR="#4863a0">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#55',2,'match16459-1.html#55',3)" NAME="55">(656-659)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#55',2,'match16459-1.html#55',3)" NAME="55">(1527-1533)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#52d017"><FONT COLOR="#52d017">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#56',2,'match16459-1.html#56',3)" NAME="56">(350-352)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#56',2,'match16459-1.html#56',3)" NAME="56">(1102-1106)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#57',2,'match16459-1.html#57',3)" NAME="57">(280-287)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#57',2,'match16459-1.html#57',3)" NAME="57">(1203-1212)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#58',2,'match16459-1.html#58',3)" NAME="58">(190-191)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#58',2,'match16459-1.html#58',3)" NAME="58">(601-606)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match16459-0.html#59',2,'match16459-1.html#59',3)" NAME="59">(155-156)<TD><A HREF="javascript:ZweiFrames('match16459-0.html#59',2,'match16459-1.html#59',3)" NAME="59">(478-481)</A><TD ALIGN=center><FONT COLOR="#290000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultHttp2ConnectionEncoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2014 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at:
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package io.netty.handler.codec.http2;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.buffer.Unpooled;
<A NAME="0"></A>import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match16459-1.html#0',3,'match16459-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelMetadata;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultChannelConfig;
import io.netty.channel.DefaultChannelPromise;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http2.Http2RemoteFlowController.FlowControlled;
import io.netty.util.concurrent.ImmediateEventExecutor;
import junit.framework.AssertionFailedError;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InOrder;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import java.util.ArrayList;
import java.util.List;

import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
import static io.netty.buffer.Unpooled.wrappedBuffer;
import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;
import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_REMOTE;
import static io.netty.handler.codec.http2.Http2Stream.State.RESERVED_LOCAL;
import static io.netty.handler.codec.http2.Http2TestUtil.newVoidPromise;
import static io.netty.util.CharsetUtil.UTF_8;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.anyBoolean;
import static org.mockito.Mockito.anyInt;
import static org.mockito.Mockito.anyLong;
import static org.mockito.Mockito.anyShort;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link DefaultHttp2ConnectionEncoder}
 */
public class DefaultHttp2ConnectionEncoderTest {
    private static final int STREAM_ID = 2;
    private static final int PUSH_STREAM_ID = 4</B></FONT>;

    @Mock
    private Http2RemoteFlowController remoteFlow;

    @Mock
    private ChannelHandlerContext ctx;

    @Mock
    private Channel channel;

    @Mock
    private Channel.Unsafe unsafe;

    @Mock
    private ChannelPipeline pipeline;

    @Mock
    private Http2FrameWriter writer;

    @Mock
    private Http2FrameWriter.Configuration writerConfig;

    @Mock
    private Http2FrameSizePolicy frameSizePolicy;

    @Mock
    private Http2LifecycleManager lifecycleManager;

    private DefaultHttp2ConnectionEncoder encoder;
    private Http2Connection connection;
    private ArgumentCaptor&lt;Http2RemoteFlowController.FlowControlled&gt; payloadCaptor;
    private List&lt;String&gt; writtenData;
    private List&lt;Integer&gt; writtenPadding;
    private boolean streamClosed;

    @BeforeEach
    public void setup() throws Exception {
<A NAME="17"></A>        MockitoAnnotations.initMocks(this);

        ChannelMetadata metadata = new ChannelMetadata(false, 16);
        <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match16459-1.html#17',3,'match16459-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(channel.isActive()).thenReturn(true);
        when(channel.pipeline()).thenReturn(pipeline);
<A NAME="38"></A>        when(channel.metadata()).thenReturn(metadata);
        when(channel.unsafe()).thenReturn(unsafe);
        ChannelConfig config = new DefaultChannelConfig(channel)</B></FONT>;
        <FONT color="#348781"><A HREF="javascript:ZweiFrames('match16459-1.html#38',3,'match16459-top.html#38',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(channel.config()).thenReturn(config);
        doAnswer(new Answer&lt;ChannelFuture&gt;() {
            @Override
<A NAME="23"></A>            public ChannelFuture answer(InvocationOnMock in</B></FONT>) {
                return newPromise().setFailure((Throwable) in.getArgument(0));
            }
        }).when(channel).newFailedFuture(<FONT color="#f660ab"><A HREF="javascript:ZweiFrames('match16459-1.html#23',3,'match16459-top.html#23',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>any(Throwable.class));

        when(writer.configuration()).thenReturn(writerConfig);
        when(writerConfig.frameSizePolicy()).thenReturn(frameSizePolicy);
        when(frameSizePolicy.maxFrameSize()).thenReturn(64);
        doAnswer(new Answer&lt;ChannelFuture&gt;() {</B></FONT>
            @Override
            public ChannelFuture answer(InvocationOnMock in) throws Throwable {
                return ((ChannelPromise) in.getArguments()[2]).setSuccess();
            }
        }).when(writer).writeSettings(eq(ctx), any(Http2Settings.class), any(ChannelPromise.class));
        doAnswer(new Answer&lt;ChannelFuture&gt;() {
            @Override
            public ChannelFuture answer(InvocationOnMock in) throws Throwable {
                ((ByteBuf) in.getArguments()[3]).release();
                return ((ChannelPromise) in.getArguments()[4]).setSuccess();
            }
<A NAME="59"></A>        }).when(writer).writeGoAway(eq(ctx), anyInt(), anyInt(), any(ByteBuf.class), any(ChannelPromise.class));
        writtenData = new ArrayList&lt;String&gt;();
        writtenPadding = new ArrayList&lt;Integer&gt;();
        <FONT color="#980517"><A HREF="javascript:ZweiFrames('match16459-1.html#59',3,'match16459-top.html#59',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(writer.writeData(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean(),
                any</B></FONT>(ChannelPromise.class))).then(new Answer&lt;ChannelFuture&gt;() {
                    @Override
                    public ChannelFuture answer(InvocationOnMock in) throws Throwable {
                        // Make sure we only receive stream closure on the last frame and that void promises
                        // are used for all writes except the last one.
                        ChannelPromise promise = (ChannelPromise) in.getArguments()[5];
                        if (streamClosed) {
                            fail(&quot;Stream already closed&quot;);
                        } else {
                            streamClosed = (Boolean) in.getArguments()[4];
                        }
                        writtenPadding.add((Integer) in.getArguments()[3]);
                        ByteBuf data = (ByteBuf) in.getArguments()[2];
                        writtenData.add(data.toString(UTF_8));
                        // Release the buffer just as DefaultHttp2FrameWriter does
                        data.release();
                        // Let the promise succeed to trigger listeners.
<A NAME="22"></A>                        return promise.setSuccess();
                    }
                });
        <FONT color="#4cc417"><A HREF="javascript:ZweiFrames('match16459-1.html#22',3,'match16459-top.html#22',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(writer.writeHeaders(eq(ctx), anyInt(), any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(),
                anyInt(), anyBoolean(), any</B></FONT>(ChannelPromise.class)))
                .then(new Answer&lt;ChannelFuture&gt;() {
                    @Override
                    public ChannelFuture answer(InvocationOnMock invocationOnMock) {
                        ChannelPromise promise = invocationOnMock.getArgument(8);
                        if (streamClosed) {
                            fail(&quot;Stream already closed&quot;);
                        } else {
                            streamClosed = invocationOnMock.getArgument(5);
                        }
<A NAME="58"></A>                        return promise.setSuccess();
                    }
                });
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match16459-1.html#58',3,'match16459-top.html#58',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(writer.writeHeaders(eq(ctx), anyInt(), any(Http2Headers.class),
                anyInt(), anyBoolean(), any</B></FONT>(ChannelPromise.class)))
                .then(new Answer&lt;ChannelFuture&gt;() {
                    @Override
                    public ChannelFuture answer(InvocationOnMock invocationOnMock) {
                        ChannelPromise promise = invocationOnMock.getArgument(5);
                        if (streamClosed) {
                            fail(&quot;Stream already closed&quot;);
                        } else {
                            streamClosed = invocationOnMock.getArgument(4);
                        }
<A NAME="14"></A>                        return promise.setSuccess();
                    }
                });
        <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match16459-1.html#14',3,'match16459-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>payloadCaptor = ArgumentCaptor.forClass(Http2RemoteFlowController.FlowControlled.class);
        doNothing().when(remoteFlow).addFlowControlled(any(Http2Stream.class), payloadCaptor.capture());
        when(ctx.alloc()).thenReturn(UnpooledByteBufAllocator.DEFAULT);
        when(ctx.channel()).thenReturn(channel);
        doAnswer(new Answer&lt;ChannelPromise&gt;() {</B></FONT>
            @Override
            public ChannelPromise answer(InvocationOnMock in) throws Throwable {
                return newPromise();
            }
        }).when(ctx).newPromise();
        doAnswer(new Answer&lt;ChannelFuture&gt;() {
            @Override
            public ChannelFuture answer(InvocationOnMock in) throws Throwable {
                return newSucceededFuture();
            }
        }).when(ctx).newSucceededFuture();
        when(ctx.flush()).thenThrow(new AssertionFailedError(&quot;forbidden&quot;));
        when(channel.alloc()).thenReturn(PooledByteBufAllocator.DEFAULT);

        // Use a server-side connection so we can test server push.
        connection = new DefaultHttp2Connection(true);
        connection.remote().flowController(remoteFlow);

        encoder = new DefaultHttp2ConnectionEncoder(connection, writer);
        encoder.lifecycleManager(lifecycleManager);
    }

    @Test
    public void dataWithEndOfStreamWriteShouldSignalThatFrameWasConsumedOnError() throws Exception {
        dataWriteShouldSignalThatFrameWasConsumedOnError0(true);
    }

    @Test
    public void dataWriteShouldSignalThatFrameWasConsumedOnError() throws Exception {
        dataWriteShouldSignalThatFrameWasConsumedOnError0(false);
    }
<A NAME="21"></A>
    private void dataWriteShouldSignalThatFrameWasConsumedOnError0(boolean endOfStream) throws Exception {
        createStream(STREAM_ID, false);
        final ByteBuf data = <FONT color="#947010"><A HREF="javascript:ZweiFrames('match16459-1.html#21',3,'match16459-top.html#21',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>dummyData();
        ChannelPromise p = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, endOfStream, p);

        FlowControlled controlled = payloadCaptor.getValue();
        assertEquals(8, controlled.size());
        payloadCaptor.getValue().write(ctx, 4);
<A NAME="16"></A>        assertEquals(4, controlled.size</B></FONT>());

        Throwable error = new IllegalStateException();
        <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match16459-1.html#16',3,'match16459-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>payloadCaptor.getValue().error(ctx, error);
        payloadCaptor.getValue().write(ctx, 8);
        assertEquals(0, controlled.size());
        assertEquals(&quot;abcd&quot;, writtenData.get(0));
        assertEquals(0, data.refCnt());
        assertSame(error, p.cause());
    }</B></FONT>

    @Test
<A NAME="7"></A>    public void dataWriteShouldSucceed() throws Exception {
        createStream(STREAM_ID, false);
        final ByteBuf data = dummyData();
        ChannelPromise p = <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match16459-1.html#7',3,'match16459-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, true, p);
        assertEquals(8, payloadCaptor.getValue().size());
        payloadCaptor.getValue().write(ctx, 8);
        assertEquals(0, payloadCaptor.getValue().size());
        assertEquals(&quot;abcdefgh&quot;, writtenData.get(0));
        assertEquals(0, data.refCnt());
        assertTrue(p.isSuccess());
    }</B></FONT>

    @Test
    public void dataFramesShouldMerge() throws Exception {
<A NAME="57"></A>        createStream(STREAM_ID, false);
        final ByteBuf data = dummyData().retain();

        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match16459-1.html#57',3,'match16459-top.html#57',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ChannelPromise promise1 = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, true, promise1);
        ChannelPromise promise2 = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, true, promise2);
<A NAME="4"></A>
        // Now merge the two payloads.
        List&lt;FlowControlled&gt; capturedWrites = payloadCaptor.getAllValues();
        FlowControlled mergedPayload = <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match16459-1.html#4',3,'match16459-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>capturedWrites.get(0)</B></FONT>;
        mergedPayload.merge(ctx, capturedWrites.get(1));
        assertEquals(16, mergedPayload.size());
        assertFalse(promise1.isDone());
        assertFalse(promise2.isDone());

        // Write the merged payloads and verify it was written correctly.
        mergedPayload.write(ctx, 16);
        assertEquals(0, mergedPayload.size());
        assertEquals(&quot;abcdefghabcdefgh&quot;, writtenData.get(0));
        assertEquals(0, data.refCnt());
        assertTrue(promise1.isSuccess());
        assertTrue(promise2.isSuccess());
    }

    @</B></FONT>Test
    public void dataFramesShouldMergeUseVoidPromise() throws Exception {
        createStream(STREAM_ID, false);
        final ByteBuf data = dummyData().retain();

        ChannelPromise promise1 = newVoidPromise(channel);
        encoder.writeData(ctx, STREAM_ID, data, 0, true, promise1);
        ChannelPromise promise2 = newVoidPromise(channel);
        encoder.writeData(ctx, STREAM_ID, data, 0, true, promise2);
<A NAME="3"></A>
        // Now merge the two payloads.
        List&lt;FlowControlled&gt; capturedWrites = payloadCaptor.getAllValues();
        FlowControlled mergedPayload = <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match16459-1.html#3',3,'match16459-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>capturedWrites.get(0);
        mergedPayload.merge(ctx, capturedWrites.get(1));
        assertEquals(16, mergedPayload.size());
        assertFalse(promise1.isSuccess());
        assertFalse(promise2.isSuccess());

        // Write the merged payloads and verify it was written correctly.
        mergedPayload.write(ctx, 16);
        assertEquals(0, mergedPayload.size());
        assertEquals(&quot;abcdefghabcdefgh&quot;, writtenData.get(0));
        assertEquals(0, data.refCnt());

        // The promises won't be set since there are no listeners.
        assertFalse(promise1.isSuccess());
        assertFalse(promise2.isSuccess());
    }

<A NAME="13"></A>    @</B></FONT>Test
    public void dataFramesDontMergeWithHeaders() throws Exception {
        createStream(STREAM_ID, false);
        final ByteBuf data = <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match16459-1.html#13',3,'match16459-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>dummyData().retain();
        encoder.writeData(ctx, STREAM_ID, data, 0, false, newPromise());
        when(remoteFlow.hasFlowControlled(any(Http2Stream.class))).thenReturn(true);
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, newPromise());
        List&lt;FlowControlled&gt; capturedWrites = payloadCaptor.getAllValues();
        assertFalse(capturedWrites.get(0).merge</B></FONT>(ctx, capturedWrites.get(1)));
    }

    @Test
    public void emptyFrameShouldSplitPadding() throws Exception {
        ByteBuf data = Unpooled.buffer(0);
        assertSplitPaddingOnEmptyBuffer(data);
        assertEquals(0, data.refCnt());
<A NAME="56"></A>    }

    @Test
    public void writeHeadersUsingVoidPromise() throws Exception <FONT color="#52d017"><A HREF="javascript:ZweiFrames('match16459-1.html#56',3,'match16459-top.html#56',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        final Throwable cause = new RuntimeException(&quot;fake exception&quot;);
        when(writer.writeHeaders(eq(ctx), eq(STREAM_ID), any</B></FONT>(Http2Headers.class),
                                 anyInt(), anyBoolean(), any(ChannelPromise.class)))
                .then(new Answer&lt;ChannelFuture&gt;() {
                    @Override
                    public ChannelFuture answer(InvocationOnMock invocationOnMock) throws Throwable {
                        ChannelPromise promise = invocationOnMock.getArgument(5);
                        assertFalse(promise.isVoid());
<A NAME="37"></A>                        return promise.setFailure(cause);
                    }
                });
        <FONT color="#810541"><A HREF="javascript:ZweiFrames('match16459-1.html#37',3,'match16459-top.html#37',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>createStream(STREAM_ID, false);
        // END_STREAM flag, so that a listener is added to the future.
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, newVoidPromise(channel));

        verify(writer).writeHeaders(eq(ctx), eq(STREAM_ID), any(Http2Headers.class),
                                    anyInt(), anyBoolean(), any</B></FONT>(ChannelPromise.class));
        // When using a void promise, the error should be propagated via the channel pipeline.
        verify(pipeline).fireExceptionCaught(cause);
<A NAME="6"></A>    }

    private void assertSplitPaddingOnEmptyBuffer(ByteBuf data) throws Exception {
        <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match16459-1.html#6',3,'match16459-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>createStream(STREAM_ID, false);
        when(frameSizePolicy.maxFrameSize()).thenReturn(5);
        ChannelPromise p = newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 10, true, p);
        assertEquals(10, payloadCaptor.getValue().size());
        payloadCaptor.getValue().write(ctx, 10);
        // writer was called 2 times
        assertEquals(1, writtenData.size());
        assertEquals(&quot;&quot;, writtenData.get(0));
        assertEquals(10, (int) writtenPadding.get</B></FONT>(0));
        assertEquals(0, data.refCnt());
        assertTrue(p.isSuccess());
    }

    @Test
<A NAME="36"></A>    public void headersWriteForUnknownStreamShouldCreateStream() throws Exception {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = <FONT color="#ff00ff"><A HREF="javascript:ZweiFrames('match16459-1.html#36',3,'match16459-top.html#36',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE), eq(0),
                eq(false), eq(promise));
        assertTrue</B></FONT>(promise.isSuccess());
    }
<A NAME="12"></A>
    @Test
    public void headersWriteShouldOpenStreamForPush() throws Exception {
        <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match16459-1.html#12',3,'match16459-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>writeAllFlowControlledFrames();
        Http2Stream parent = createStream(STREAM_ID, false);
        reservePushStream(PUSH_STREAM_ID, parent);

        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        assertEquals(HALF_CLOSED_REMOTE, stream(PUSH_STREAM_ID).state());
        verify(writer).writeHeaders(eq(ctx), eq</B></FONT>(PUSH_STREAM_ID), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }

    @Test
    public void trailersDoNotEndStreamThrows() {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
<A NAME="35"></A>        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);

        ChannelPromise promise2 = newPromise();
        ChannelFuture future = <FONT color="#41a317"><A HREF="javascript:ZweiFrames('match16459-1.html#35',3,'match16459-top.html#35',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise2);
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());

        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq</B></FONT>(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }
<A NAME="15"></A>
    @Test
    public void trailersDoNotEndStreamWithDataThrows() {
        <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match16459-1.html#15',3,'match16459-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);

        Http2Stream stream = connection.stream(streamId);
<A NAME="34"></A>        when(remoteFlow.hasFlowControlled(eq(stream))).thenReturn(true);

        ChannelPromise promise2 = newPromise</B></FONT>();
        ChannelFuture future = <FONT color="#827d6b"><A HREF="javascript:ZweiFrames('match16459-1.html#34',3,'match16459-top.html#34',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise2);
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());

        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq</B></FONT>(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
    }

    @Test
    public void tooManyHeadersNoEOSThrows() {
        tooManyHeadersThrows(false);
    }

    @Test
    public void tooManyHeadersEOSThrows() {
        tooManyHeadersThrows(true);
    }

    private void tooManyHeadersThrows(boolean eos) {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        ChannelPromise promise2 = newPromise();
<A NAME="2"></A>        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, true, promise2);

        ChannelPromise promise3 = newPromise();
        ChannelFuture future = <FONT color="#980517"><A HREF="javascript:ZweiFrames('match16459-1.html#2',3,'match16459-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, eos, promise3);
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());

        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(true), eq(promise2));
    }

    @</B></FONT>Test
    public void infoHeadersAndTrailersAllowed() throws Exception {
        infoHeadersAndTrailers(true, 1);
    }

    @Test
    public void multipleInfoHeadersAndTrailersAllowed() throws Exception {
        infoHeadersAndTrailers(true, 10);
    }

    @Test
    public void infoHeadersAndTrailersNoEOSThrows() throws Exception {
        infoHeadersAndTrailers(false, 1);
    }

    @Test
    public void multipleInfoHeadersAndTrailersNoEOSThrows() throws Exception {
        infoHeadersAndTrailers(false, 10);
    }

    private void infoHeadersAndTrailers(boolean eos, int infoHeaderCount) {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        Http2Headers infoHeaders = informationalHeaders();
        for (int i = 0; i &lt; infoHeaderCount; ++i) {
            encoder.writeHeaders(ctx, streamId, infoHeaders, 0, false, newPromise());
        }
        ChannelPromise promise2 = newPromise();
<A NAME="33"></A>        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise2);

        ChannelPromise promise3 = newPromise();
        ChannelFuture future = <FONT color="#736aff"><A HREF="javascript:ZweiFrames('match16459-1.html#33',3,'match16459-top.html#33',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, eos, promise3);
        assertTrue(future.isDone());
<A NAME="32"></A>        assertEquals(eos, future.isSuccess());

        verify(writer, times(infoHeaderCount)).writeHeaders(eq(ctx), eq(streamId), eq</B></FONT>(infoHeaders),
<A NAME="49"></A>                <FONT color="#5b8daf"><A HREF="javascript:ZweiFrames('match16459-1.html#32',3,'match16459-top.html#32',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eq(0), eq(false), any(ChannelPromise.class));
        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq</B></FONT>(false), eq(promise2));
        if (eos) <FONT color="#8e35ef"><A HREF="javascript:ZweiFrames('match16459-1.html#49',3,'match16459-top.html#49',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
            verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                    eq(0), eq(true), eq</B></FONT>(promise3));
        }
    }

<A NAME="31"></A>    private static Http2Headers informationalHeaders() {
        Http2Headers headers = new DefaultHttp2Headers();
        headers.status(HttpResponseStatus.CONTINUE.codeAsText());
        <FONT color="#3ea99f"><A HREF="javascript:ZweiFrames('match16459-1.html#31',3,'match16459-top.html#31',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return headers;
    }

    @Test
    public void tooManyHeadersWithDataNoEOSThrows() {
        tooManyHeadersWithDataThrows(false);
    }

    @</B></FONT>Test
    public void tooManyHeadersWithDataEOSThrows() {
        tooManyHeadersWithDataThrows(true);
    }

<A NAME="20"></A>    private void tooManyHeadersWithDataThrows(boolean eos) {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match16459-1.html#20',3,'match16459-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ChannelPromise promise = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);

        Http2Stream stream = connection.stream(streamId);
        when(remoteFlow.hasFlowControlled(eq(stream))).thenReturn(true);

        ChannelPromise promise2 = newPromise();
<A NAME="1"></A>        encoder.writeHeaders</B></FONT>(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, true, promise2);

        ChannelPromise promise3 = newPromise();
        ChannelFuture future = <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match16459-1.html#1',3,'match16459-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, eos, promise3);
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());

        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise));
        verify(writer, times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(true), eq(promise2));
    }

    @</B></FONT>Test
    public void infoHeadersAndTrailersWithDataAllowed() {
        infoHeadersAndTrailersWithData(true, 1);
    }

    @Test
    public void multipleInfoHeadersAndTrailersWithDataAllowed() {
        infoHeadersAndTrailersWithData(true, 10);
    }

    @Test
    public void infoHeadersAndTrailersWithDataNoEOSThrows() {
        infoHeadersAndTrailersWithData(false, 1);
    }

    @Test
    public void multipleInfoHeadersAndTrailersWithDataNoEOSThrows() {
        infoHeadersAndTrailersWithData(false, 10);
    }

    private void infoHeadersAndTrailersWithData(boolean eos, int infoHeaderCount) {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        Http2Headers infoHeaders = informationalHeaders();
        for (int i = 0; i &lt; infoHeaderCount; ++i) {
<A NAME="8"></A>            encoder.writeHeaders(ctx, streamId, infoHeaders, 0, false, newPromise());
        }

        Http2Stream stream = <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match16459-1.html#8',3,'match16459-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>connection.stream(streamId);
        when(remoteFlow.hasFlowControlled(eq(stream))).thenReturn(true);

        ChannelPromise promise2 = newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise2);

        ChannelPromise promise3 = newPromise();
        ChannelFuture future = encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, eos, promise3);
<A NAME="30"></A>        assertTrue(future.isDone());
        assertEquals(eos, future.isSuccess</B></FONT>());
<A NAME="48"></A>
        <FONT color="#ae694a"><A HREF="javascript:ZweiFrames('match16459-1.html#30',3,'match16459-top.html#30',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>verify(writer, times(infoHeaderCount)).writeHeaders(eq(ctx), eq(streamId), eq(infoHeaders),
                eq(0), eq(false), any(ChannelPromise.class));
<A NAME="19"></A>        verify</B></FONT>(writer, <FONT color="#c57726"><A HREF="javascript:ZweiFrames('match16459-1.html#48',3,'match16459-top.html#48',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>times(1)).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq(promise2));
        if (eos) {
            verify(writer, times(1)).writeHeaders</B></FONT>(<FONT color="#f62817"><A HREF="javascript:ZweiFrames('match16459-1.html#19',3,'match16459-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                    eq(0), eq(true), eq(promise3));
        }
    }

    @</B></FONT>Test
<A NAME="47"></A>    public void pushPromiseWriteAfterGoAwayReceivedShouldFail() throws Exception {
        createStream(STREAM_ID, false);
        goAwayReceived(0);
        ChannelFuture future = <FONT color="#d16587"><A HREF="javascript:ZweiFrames('match16459-1.html#47',3,'match16459-top.html#47',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>encoder.writePushPromise(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0,
                newPromise());
        assertTrue(future.isDone());
        assertFalse(future.isSuccess());
    }

<A NAME="29"></A>    @</B></FONT>Test
    public void pushPromiseWriteShouldReserveStream() throws Exception {
        createStream(STREAM_ID, false);
        ChannelPromise promise = <FONT color="#af7a82"><A HREF="javascript:ZweiFrames('match16459-1.html#29',3,'match16459-top.html#29',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writePushPromise(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, promise);
        assertEquals(RESERVED_LOCAL, stream(PUSH_STREAM_ID).state());
        verify(writer).writePushPromise(eq(ctx), eq(STREAM_ID), eq(PUSH_STREAM_ID),
                eq</B></FONT>(EmptyHttp2Headers.INSTANCE), eq(0), eq(promise));
    }

    @Test
<A NAME="46"></A>    public void priorityWriteAfterGoAwayShouldSucceed() throws Exception {
        createStream(STREAM_ID, false);
        goAwayReceived(Integer.MAX_VALUE);
        ChannelPromise promise = <FONT color="#668b8b"><A HREF="javascript:ZweiFrames('match16459-1.html#46',3,'match16459-top.html#46',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writePriority(ctx, STREAM_ID, 0, (short) 255, true, promise);
        verify(writer).writePriority(eq(ctx), eq(STREAM_ID), eq(0), eq((short) 255), eq(true), eq</B></FONT>(promise));
    }

    @Test
    public void priorityWriteShouldSetPriorityForStream() throws Exception {
        ChannelPromise promise = newPromise();
        short weight = 255;
<A NAME="45"></A>        encoder.writePriority(ctx, STREAM_ID, 0, weight, true, promise);

        // Verify that this did NOT create a stream object.
        Http2Stream stream = <FONT color="#549748"><A HREF="javascript:ZweiFrames('match16459-1.html#45',3,'match16459-top.html#45',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>stream(STREAM_ID);
        assertNull(stream);

        verify(writer).writePriority(eq(ctx), eq(STREAM_ID), eq(0), eq((short) 255), eq(true), eq</B></FONT>(promise));
<A NAME="44"></A>    }

    @Test
    public void priorityWriteOnPreviouslyExistingStreamShouldSucceed() throws Exception <FONT color="#a057a5"><A HREF="javascript:ZweiFrames('match16459-1.html#44',3,'match16459-top.html#44',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        createStream(STREAM_ID, false).close();
<A NAME="55"></A>        ChannelPromise promise = newPromise();
        short weight = 255;
        encoder.writePriority(ctx, STREAM_ID, 0, weight, true, promise);
        verify(writer).writePriority(eq</B></FONT>(ctx), <FONT color="#4863a0"><A HREF="javascript:ZweiFrames('match16459-1.html#55',3,'match16459-top.html#55',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eq(STREAM_ID), eq(0), eq(weight), eq(true), eq(promise));
    }
<A NAME="11"></A>
    @</B></FONT>Test
    public void priorityWriteOnPreviouslyExistingParentStreamShouldSucceed() throws Exception {
        <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match16459-1.html#11',3,'match16459-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>final int parentStreamId = STREAM_ID + 2;
        createStream(STREAM_ID, false);
        createStream(parentStreamId, false).close();

        ChannelPromise promise = newPromise();
        short weight = 255;
        encoder.writePriority(ctx, STREAM_ID, parentStreamId, weight, true, promise);
        verify(writer).writePriority(eq(ctx), eq(STREAM_ID), eq(parentStreamId), eq(weight), eq</B></FONT>(true), eq(promise));
    }
<A NAME="43"></A>
    @Test
    public void rstStreamWriteForUnknownStreamShouldIgnore() throws Exception {
        ChannelPromise promise = <FONT color="#c22817"><A HREF="javascript:ZweiFrames('match16459-1.html#43',3,'match16459-top.html#43',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeRstStream(ctx, 5, PROTOCOL_ERROR.code(), promise);
        verify(writer, never()).writeRstStream(eq(ctx), anyInt(), anyLong(), eq</B></FONT>(promise));
    }

<A NAME="18"></A>    @Test
    public void rstStreamShouldCloseStream() throws Exception {
        // Create the stream and send headers.
        <FONT color="#800517"><A HREF="javascript:ZweiFrames('match16459-1.html#18',3,'match16459-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>writeAllFlowControlledFrames();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, newPromise());

        // Now verify that a stream reset is performed.
        stream(STREAM_ID);
        ChannelPromise promise = newPromise();
        encoder.writeRstStream(ctx, STREAM_ID, PROTOCOL_ERROR.code(), promise);
        verify(lifecycleManager).resetStream(eq(ctx), eq</B></FONT>(STREAM_ID), anyLong(), eq(promise));
    }
<A NAME="54"></A>
    @Test
    public void pingWriteAfterGoAwayShouldSucceed() throws Exception {
        ChannelPromise promise = <FONT color="#4e8975"><A HREF="javascript:ZweiFrames('match16459-1.html#54',3,'match16459-top.html#54',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        goAwayReceived(0);
        encoder.writePing(ctx, false, 0L, promise);
        verify(writer).writePing(eq(ctx), eq(false), eq(0L), eq</B></FONT>(promise));
    }

    @Test
    public void pingWriteShouldSucceed() throws Exception {
        ChannelPromise promise = newPromise();
        encoder.writePing(ctx, false, 0L, promise);
        verify(writer).writePing(eq(ctx), eq(false), eq(0L), eq(promise));
    }

    @Test
    public void settingsWriteAfterGoAwayShouldSucceed() throws Exception {
        goAwayReceived(0);
        ChannelPromise promise = newPromise();
        encoder.writeSettings(ctx, new Http2Settings(), promise);
        verify(writer).writeSettings(eq(ctx), any(Http2Settings.class), eq(promise));
    }

<A NAME="42"></A>    @Test
    public void settingsWriteShouldNotUpdateSettings() throws Exception {
        Http2Settings settings = new Http2Settings();
        <FONT color="#c57717"><A HREF="javascript:ZweiFrames('match16459-1.html#42',3,'match16459-top.html#42',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>settings.initialWindowSize(100);
        settings.maxConcurrentStreams(1000);
        settings.headerTableSize(2000);

        ChannelPromise promise = newPromise();
        encoder.writeSettings(ctx, settings, promise);
        verify(writer).writeSettings(eq(ctx), eq</B></FONT>(settings), eq(promise));
    }
<A NAME="10"></A>
    @Test
    public void dataWriteShouldCreateHalfClosedStream() throws Exception {
        <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match16459-1.html#10',3,'match16459-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>writeAllFlowControlledFrames();

        Http2Stream stream = createStream(STREAM_ID, false);
        ByteBuf data = dummyData();
        ChannelPromise promise = newPromise();
        encoder.writeData(ctx, STREAM_ID, data.retain(), 0, true, promise);
        assertTrue(promise.isSuccess());
        verify(remoteFlow).addFlowControlled(eq(stream), any</B></FONT>(FlowControlled.class));
        verify(lifecycleManager).closeStreamLocal(stream, promise);
        assertEquals(data.toString(UTF_8), writtenData.get(0));
        data.release();
    }

    @Test
<A NAME="53"></A>    public void headersWriteShouldHalfCloseStream() throws Exception {
        writeAllFlowControlledFrames();
        createStream(STREAM_ID, false);
        ChannelPromise promise = <FONT color="#ad5a3d"><A HREF="javascript:ZweiFrames('match16459-1.html#53',3,'match16459-top.html#53',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);

        assertTrue(promise.isSuccess());
        verify(lifecycleManager).closeStreamLocal(eq(stream(STREAM_ID)), eq</B></FONT>(promise));
    }
<A NAME="52"></A>
    @Test
    public void headersWriteShouldHalfClosePushStream() throws Exception {
        <FONT color="#2b60de"><A HREF="javascript:ZweiFrames('match16459-1.html#52',3,'match16459-top.html#52',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>writeAllFlowControlledFrames();
        Http2Stream parent = createStream(STREAM_ID, false);
        Http2Stream stream = reservePushStream(PUSH_STREAM_ID, parent);
        ChannelPromise promise = newPromise();
<A NAME="28"></A>        encoder.writeHeaders(ctx, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);
        assertEquals</B></FONT>(HALF_CLOSED_REMOTE, stream.state());
        assertTrue(promise.isSuccess());
        verify(lifecycleManager).closeStreamLocal(<FONT color="#717d7d"><A HREF="javascript:ZweiFrames('match16459-1.html#28',3,'match16459-top.html#28',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eq(stream), eq(promise));
    }

    @Test
    public void headersWriteShouldHalfCloseAfterOnErrorForPreCreatedStream() throws Exception {
<A NAME="51"></A>        final ChannelPromise promise = newPromise();
        final Throwable ex = new</B></FONT> RuntimeException();
        // Fake an encoding error, like HPACK's HeaderListSizeException
        <FONT color="#b38481"><A HREF="javascript:ZweiFrames('match16459-1.html#51',3,'match16459-top.html#51',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(writer.writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0), eq(true), eq</B></FONT>(promise)))
            .thenAnswer(new Answer&lt;ChannelFuture&gt;() {
                @Override
                public ChannelFuture answer(InvocationOnMock invocation) {
                    promise.setFailure(ex);
                    return promise;
                }
            });
<A NAME="9"></A>
        writeAllFlowControlledFrames();
        Http2Stream stream = createStream(STREAM_ID, false);
        <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match16459-1.html#9',3,'match16459-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);

        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertFalse(stream.isHeadersSent());
        InOrder inOrder = inOrder(lifecycleManager);
        inOrder.verify(lifecycleManager).onError(eq(ctx), eq(true), eq(ex));
        inOrder.verify(lifecycleManager).closeStreamLocal</B></FONT>(eq(stream(STREAM_ID)), eq(promise));
    }

    @Test
    public void headersWriteShouldHalfCloseAfterOnErrorForImplicitlyCreatedStream() throws Exception {
<A NAME="50"></A>        final ChannelPromise promise = newPromise();
        final Throwable ex = new RuntimeException();
        // Fake an encoding error, like HPACK's HeaderListSizeException
        <FONT color="#ff0000"><A HREF="javascript:ZweiFrames('match16459-1.html#50',3,'match16459-top.html#50',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>when(writer.writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0), eq(true), eq</B></FONT>(promise)))
            .thenAnswer(new Answer&lt;ChannelFuture&gt;() {
                @Override
                public ChannelFuture answer(InvocationOnMock invocation) {
                    promise.setFailure(ex);
                    return promise;
<A NAME="5"></A>                }
            });

        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match16459-1.html#5',3,'match16459-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>writeAllFlowControlledFrames();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);

        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertFalse(stream(STREAM_ID).isHeadersSent());
        InOrder inOrder = inOrder(lifecycleManager);
        inOrder.verify(lifecycleManager).onError(eq(ctx), eq(true), eq(ex));
        inOrder.verify(lifecycleManager).closeStreamLocal(eq(stream</B></FONT>(STREAM_ID)), eq(promise));
    }
<A NAME="27"></A>
    @Test
    public void encoderDelegatesGoAwayToLifeCycleManager() {
        ChannelPromise promise = <FONT color="#e77471"><A HREF="javascript:ZweiFrames('match16459-1.html#27',3,'match16459-top.html#27',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeGoAway(ctx, STREAM_ID, Http2Error.INTERNAL_ERROR.code(), null, promise);
        verify(lifecycleManager).goAway(eq(ctx), eq(STREAM_ID), eq(Http2Error.INTERNAL_ERROR.code()),
                eq((ByteBuf) null), eq</B></FONT>(promise));
        verifyNoMoreInteractions(writer);
    }

    @Test
<A NAME="26"></A>    public void dataWriteToClosedStreamShouldFail() throws Exception {
        createStream(STREAM_ID, false).close();
        ByteBuf data = mock(ByteBuf.class);
        ChannelPromise promise = <FONT color="#68818b"><A HREF="javascript:ZweiFrames('match16459-1.html#26',3,'match16459-top.html#26',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, false, promise);
        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertThat(promise.cause(), instanceOf(IllegalArgumentException.class));
        verify</B></FONT>(data).release();
    }

    @Test
<A NAME="25"></A>    public void dataWriteToHalfClosedLocalStreamShouldFail() throws Exception {
        createStream(STREAM_ID, true);
        ByteBuf data = mock(ByteBuf.class);
        ChannelPromise promise = <FONT color="#5eac10"><A HREF="javascript:ZweiFrames('match16459-1.html#25',3,'match16459-top.html#25',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeData(ctx, STREAM_ID, data, 0, false, promise);
        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertThat(promise.cause(), instanceOf(IllegalStateException.class));
        verify</B></FONT>(data).release();
    }

    @Test
    public void canWriteDataFrameAfterGoAwaySent() throws Exception {
        Http2Stream stream = createStream(STREAM_ID, false);
        connection.goAwaySent(0, 0, EMPTY_BUFFER);
        ByteBuf data = mock(ByteBuf.class);
        encoder.writeData(ctx, STREAM_ID, data, 0, false, newPromise());
        verify(remoteFlow).addFlowControlled(eq(stream), any(FlowControlled.class));
    }

    @Test
    public void canWriteHeaderFrameAfterGoAwaySent() throws Exception {
<A NAME="41"></A>        writeAllFlowControlledFrames();
        createStream(STREAM_ID, false);
        goAwaySent(0);
        ChannelPromise promise = <FONT color="#f87a17"><A HREF="javascript:ZweiFrames('match16459-1.html#41',3,'match16459-top.html#41',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq</B></FONT>(promise));
    }

    @Test
    public void canWriteDataFrameAfterGoAwayReceived() throws Exception {
        Http2Stream stream = createStream(STREAM_ID, false);
        goAwayReceived(STREAM_ID);
        ByteBuf data = mock(ByteBuf.class);
        encoder.writeData(ctx, STREAM_ID, data, 0, false, newPromise());
        verify(remoteFlow).addFlowControlled(eq(stream), any(FlowControlled.class));
    }

    @Test
<A NAME="40"></A>    public void canWriteHeaderFrameAfterGoAwayReceived() throws Http2Exception {
        writeAllFlowControlledFrames();
        goAwayReceived(STREAM_ID);
        ChannelPromise promise = <FONT color="#347235"><A HREF="javascript:ZweiFrames('match16459-1.html#40',3,'match16459-top.html#40',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq</B></FONT>(promise));
    }

    @Test
<A NAME="39"></A>    public void headersWithNoPriority() {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = <FONT color="#152dc6"><A HREF="javascript:ZweiFrames('match16459-1.html#39',3,'match16459-top.html#39',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE),
                eq(0), eq(false), eq</B></FONT>(promise));
    }

    @Test
<A NAME="24"></A>    public void headersWithPriority() {
        writeAllFlowControlledFrames();
        final int streamId = 6;
        ChannelPromise promise = <FONT color="#79764d"><A HREF="javascript:ZweiFrames('match16459-1.html#24',3,'match16459-top.html#24',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>newPromise();
        encoder.writeHeaders(ctx, streamId, EmptyHttp2Headers.INSTANCE, 10, DEFAULT_PRIORITY_WEIGHT,
                true, 1, false, promise);
        verify(writer).writeHeaders(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE), eq(10),
                eq(DEFAULT_PRIORITY_WEIGHT), eq(true), eq</B></FONT>(1), eq(false), eq(promise));
    }

    private void writeAllFlowControlledFrames() {
        doAnswer(new Answer&lt;Void&gt;() {
            @Override
            public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
                FlowControlled flowControlled = (FlowControlled) invocationOnMock.getArguments()[1];
                flowControlled.write(ctx, Integer.MAX_VALUE);
                flowControlled.writeComplete();
                return null;
            }
        }).when(remoteFlow).addFlowControlled(any(Http2Stream.class), payloadCaptor.capture());
    }

    private Http2Stream createStream(int streamId, boolean halfClosed) throws Http2Exception {
        return connection.local().createStream(streamId, halfClosed);
    }

    private Http2Stream reservePushStream(int pushStreamId, Http2Stream parent) throws Http2Exception {
        return connection.local().reservePushStream(pushStreamId, parent);
    }

    private Http2Stream stream(int streamId) {
        return connection.stream(streamId);
    }

    private void goAwayReceived(int lastStreamId) throws Http2Exception {
        connection.goAwayReceived(lastStreamId, 0, EMPTY_BUFFER);
    }

    private void goAwaySent(int lastStreamId) throws Http2Exception {
        connection.goAwaySent(lastStreamId, 0, EMPTY_BUFFER);
    }

    private ChannelPromise newPromise() {
        return new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);
    }

    private ChannelFuture newSucceededFuture() {
        return newPromise().setSuccess();
    }

    private static ByteBuf dummyData() {
        // The buffer is purposely 8 bytes so it will even work for a ping frame.
        return wrappedBuffer(&quot;abcdefgh&quot;.getBytes(UTF_8));
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>OpenSslEngineTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2015 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
<A NAME="0"></A> */
package io.netty.handler.ssl;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#0',2,'match16459-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;
import io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior;
import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.ssl.util.SelfSignedCertificate;
import io.netty.internal.tcnative.SSL;
import io.netty.util.CharsetUtil;
import io.netty.util.internal.EmptyArrays;
import io.netty.util.internal.PlatformDependent;
import org.junit.AssumptionViolatedException;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.function.Executable;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLEngineResult.HandshakeStatus;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.X509ExtendedKeyManager;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.security.AlgorithmConstraints;
import java.security.AlgorithmParameters;
import java.security.CryptoPrimitive;
import java.security.Key;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

import static io.netty.handler.ssl.OpenSslTestUtils.checkShouldUseKeyManagerFactory;
import static io.netty.handler.ssl.ReferenceCountedOpenSslEngine.MAX_PLAINTEXT_LENGTH;
import static io.netty.internal.tcnative.SSL.SSL_CVERIFY_IGNORED;
import static java.lang.Integer.MAX_VALUE;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

public class OpenSslEngineTest extends SSLEngineTest {
    private static final String PREFERRED_APPLICATION_LEVEL_PROTOCOL = &quot;my-protocol-http2&quot;;
<A NAME="28"></A>    private static final String FALLBACK_APPLICATION_LEVEL_PROTOCOL = &quot;my-protocol-http1_1&quot;</B></FONT>;

    public OpenSslEngineTest() {
        <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#28',2,'match16459-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super(SslProvider.isTlsv13Supported(SslProvider.OPENSSL));
    }

    @Override
    protected List&lt;SSLEngineTestParam&gt; newTestParams() {
        List&lt;SSLEngineTestParam&gt; params = super.newTestParams();
        List&lt;SSLEngineTestParam&gt; testParams = new</B></FONT> ArrayList&lt;SSLEngineTestParam&gt;();
        for (SSLEngineTestParam param: params) {
<A NAME="31"></A>            testParams.add(new OpenSslEngineTestParam(true, param));
            testParams.add(new OpenSslEngineTestParam(false, param));
        }
        <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#31',2,'match16459-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return testParams;
    }

    @BeforeAll
    public static void checkOpenSsl() {
        OpenSsl.ensureAvailability();
    }

    @</B></FONT>AfterEach
    @Override
    public void tearDown() throws InterruptedException {
        super.tearDown();
        assertEquals(0, SSL.getLastErrorNumber(), &quot;SSL error stack not correctly consumed&quot;);
    }

    @Override
    public void testSessionAfterHandshakeKeyManagerFactory(SSLEngineTestParam param) throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testSessionAfterHandshakeKeyManagerFactory(param);
    }

    @Override
    public void testSessionAfterHandshakeKeyManagerFactoryMutualAuth(SSLEngineTestParam param) throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testSessionAfterHandshakeKeyManagerFactoryMutualAuth(param);
    }

    @Override
    public void testMutualAuthInvalidIntermediateCASucceedWithOptionalClientAuth(SSLEngineTestParam param)
            throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testMutualAuthInvalidIntermediateCASucceedWithOptionalClientAuth(param);
    }

    @Override
    public void testMutualAuthInvalidIntermediateCAFailWithOptionalClientAuth(SSLEngineTestParam param)
            throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testMutualAuthInvalidIntermediateCAFailWithOptionalClientAuth(param);
    }

    @Override
    public void testMutualAuthInvalidIntermediateCAFailWithRequiredClientAuth(SSLEngineTestParam param)
            throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testMutualAuthInvalidIntermediateCAFailWithRequiredClientAuth(param);
    }

    @Override
    public void testMutualAuthValidClientCertChainTooLongFailOptionalClientAuth(SSLEngineTestParam param)
            throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testMutualAuthValidClientCertChainTooLongFailOptionalClientAuth(param);
    }

    @Override
    public void testMutualAuthValidClientCertChainTooLongFailRequireClientAuth(SSLEngineTestParam param)
            throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testMutualAuthValidClientCertChainTooLongFailRequireClientAuth(param);
    }

    @Override
    public void testHandshakeSession(SSLEngineTestParam param) throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testHandshakeSession(param);
    }

    @Override
    public void testSupportedSignatureAlgorithms(SSLEngineTestParam param) throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testSupportedSignatureAlgorithms(param);
    }

    private static boolean isNpnSupported(String versionString) {
        String[] versionStringParts = versionString.split(&quot; &quot;, -1);
        if (versionStringParts.length == 2 &amp;&amp; &quot;LibreSSL&quot;.equals(versionStringParts[0])) {
            String[] versionParts = versionStringParts[1].split(&quot;\\.&quot;, -1);
            if (versionParts.length == 3) {
                int major = Integer.parseInt(versionParts[0]);
                if (major &lt; 2) {
                    return true;
                }
                if (major &gt; 2) {
                    return false;
                }
                int minor = Integer.parseInt(versionParts[1]);
                if (minor &lt; 6) {
                    return true;
                }
                if (minor &gt; 6) {
                    return false;
                }
                int bugfix = Integer.parseInt(versionParts[2]);
                if (bugfix &gt; 0) {
                    return false;
                }
            }
        }
        return true;
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testNpn(SSLEngineTestParam param) throws Exception {
        String versionString = OpenSsl.versionString();
        assumeTrue(isNpnSupported(versionString), &quot;LibreSSL 2.6.1 removed NPN support, detected &quot; + versionString);
        ApplicationProtocolConfig apn = acceptingNegotiator(Protocol.NPN,
                PREFERRED_APPLICATION_LEVEL_PROTOCOL);
        setupHandlers(param, apn);
        runTest(PREFERRED_APPLICATION_LEVEL_PROTOCOL);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testAlpn(SSLEngineTestParam param) throws Exception {
        assumeTrue(OpenSsl.isAlpnSupported());
        ApplicationProtocolConfig apn = acceptingNegotiator(Protocol.ALPN,
                PREFERRED_APPLICATION_LEVEL_PROTOCOL);
        setupHandlers(param, apn);
        runTest(PREFERRED_APPLICATION_LEVEL_PROTOCOL);
    }
<A NAME="44"></A>
    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testAlpnCompatibleProtocolsDifferentClientOrder(SSLEngineTestParam param) throws Exception <FONT color="#a057a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#44',2,'match16459-top.html#44',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        assumeTrue(OpenSsl.isAlpnSupported());
        ApplicationProtocolConfig clientApn = acceptingNegotiator(Protocol.ALPN,
                FALLBACK_APPLICATION_LEVEL_PROTOCOL, PREFERRED_APPLICATION_LEVEL_PROTOCOL);
        ApplicationProtocolConfig serverApn = acceptingNegotiator(Protocol.ALPN,
                PREFERRED_APPLICATION_LEVEL_PROTOCOL, FALLBACK_APPLICATION_LEVEL_PROTOCOL);
        setupHandlers(param, serverApn, clientApn);
        assertNull(serverException);
        runTest</B></FONT>(PREFERRED_APPLICATION_LEVEL_PROTOCOL);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testEnablingAnAlreadyDisabledSslProtocol(SSLEngineTestParam param) throws Exception {
        testEnablingAnAlreadyDisabledSslProtocol(param, new String[]{SslProtocols.SSL_v2_HELLO},
            new String[]{SslProtocols.SSL_v2_HELLO, SslProtocols.TLS_v1_2});
    }

<A NAME="46"></A>    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testWrapBuffersNoWritePendingError(SSLEngineTestParam param) throws Exception {
        clientSslCtx = <FONT color="#668b8b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#46',2,'match16459-top.html#46',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
                                        .sslProvider(sslClientProvider())
                                        .protocols(param.protocols())
<A NAME="37"></A>                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#37',2,'match16459-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SSLEngine clientEngine = null;
        SSLEngine serverEngine = null;
        try {
            clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            handshake(param.type(), param.delegate(), clientEngine, serverEngine);

            ByteBuffer src = allocateBuffer(param.type(), 1024 * 10);
            byte[] data = new byte[src.capacity()];
            PlatformDependent.threadLocalRandom().nextBytes(data);
            src.put(data).flip();
            ByteBuffer dst = allocateBuffer(param.type(), 1);
            // Try to wrap multiple times so we are more likely to hit the issue.
            for (int i = 0; i &lt; 100; i++) {
                src.position(0);
                dst.position(0);
                assertSame(SSLEngineResult.Status.BUFFER_OVERFLOW, clientEngine.wrap(src, dst).getStatus());
            }
        } finally {
            cleanupClientSslEngine(clientEngine);
            cleanupServerSslEngine(serverEngine);
        }
    }

<A NAME="45"></A>    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testOnlySmallBufferNeededForWrap(SSLEngineTestParam param) throws Exception {
        clientSslCtx = <FONT color="#549748"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#45',2,'match16459-top.html#45',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
                                        .sslProvider(sslClientProvider())
                                        .protocols(param.protocols())
<A NAME="36"></A>                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = <FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#36',2,'match16459-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SSLEngine clientEngine = null;
        SSLEngine serverEngine = null;
<A NAME="15"></A>        try {
            clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            handshake(param.type(), <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#15',2,'match16459-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>param.delegate(), clientEngine, serverEngine);

            // Allocate a buffer which is small enough and set the limit to the capacity to mark its whole content
            // as readable.
            int srcLen = 1024;
            ByteBuffer src = allocateBuffer(param.type(), srcLen);

<A NAME="6"></A>            ByteBuffer dstTooSmall = allocateBuffer(
                    param.type(), src.capacity() + unwrapEngine(clientEngine).maxWrapOverhead() - 1);
            ByteBuffer dst = allocateBuffer</B></FONT>(
                    <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#6',2,'match16459-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>param.type(), src.capacity() + unwrapEngine(clientEngine).maxWrapOverhead());

            // Check that we fail to wrap if the dst buffers capacity is not at least
            // src.capacity() + ReferenceCountedOpenSslEngine.MAX_TLS_RECORD_OVERHEAD_LENGTH
            SSLEngineResult result = clientEngine.wrap(src, dstTooSmall);
            assertEquals(SSLEngineResult.Status.BUFFER_OVERFLOW, result.getStatus());
            assertEquals(0, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());
            assertEquals(src.remaining(), src.capacity());
            assertEquals(dst.remaining(), dst.capacity</B></FONT>());

<A NAME="7"></A>            // Check that we can wrap with a dst buffer that has the capacity of
            // src.capacity() + ReferenceCountedOpenSslEngine.MAX_TLS_RECORD_OVERHEAD_LENGTH
            result = clientEngine.wrap(src, dst);
            <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#7',2,'match16459-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(srcLen, result.bytesConsumed());
            assertEquals(0, src.remaining());
            assertTrue(result.bytesProduced() &gt; srcLen);
            assertEquals(src.capacity() - result.bytesConsumed(), src.remaining());
            assertEquals(dst.capacity() - result.bytesProduced(), dst.remaining());
        }</B></FONT> finally {
            cleanupClientSslEngine(clientEngine);
            cleanupServerSslEngine(serverEngine);
        }
    }

<A NAME="43"></A>    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testNeededDstCapacityIsCorrectlyCalculated(SSLEngineTestParam param) throws Exception {
        clientSslCtx = <FONT color="#c22817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#43',2,'match16459-top.html#43',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
                                        .sslProvider(sslClientProvider())
                                        .protocols(param.protocols())
<A NAME="35"></A>                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = <FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#35',2,'match16459-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SSLEngine clientEngine = null;
<A NAME="8"></A>        SSLEngine serverEngine = null;
        try {
            clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            serverEngine = <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#8',2,'match16459-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            handshake(param.type(), param.delegate(), clientEngine, serverEngine);

            ByteBuffer src = allocateBuffer(param.type(), 1024);
            ByteBuffer src2 = src.duplicate();

            ByteBuffer dst = allocateBuffer(param.type(), src.capacity()
<A NAME="16"></A>                    + unwrapEngine</B></FONT>(clientEngine).maxWrapOverhead());

            SSLEngineResult result = clientEngine.wrap(new ByteBuffer[] { src, src2 }, dst);
            <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#16',2,'match16459-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(SSLEngineResult.Status.BUFFER_OVERFLOW, result.getStatus());
            assertEquals(0, src.position());
            assertEquals(0, src2.position());
            assertEquals(0, dst.position());
            assertEquals(0, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());
        }</B></FONT> finally {
            cleanupClientSslEngine(clientEngine);
            cleanupServerSslEngine(serverEngine);
        }
    }

<A NAME="41"></A>    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testSrcsLenOverFlowCorrectlyHandled(SSLEngineTestParam param) throws Exception {
        clientSslCtx = <FONT color="#f87a17"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#41',2,'match16459-top.html#41',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
                                        .sslProvider(sslClientProvider())
                                        .protocols(param.protocols())
<A NAME="34"></A>                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#34',2,'match16459-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SSLEngine clientEngine = null;
        SSLEngine serverEngine = null;
        try {
            clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            handshake(param.type(), param.delegate(), clientEngine, serverEngine);

            ByteBuffer src = allocateBuffer(param.type(), 1024);
            List&lt;ByteBuffer&gt; srcList = new ArrayList&lt;ByteBuffer&gt;();
            long srcsLen = 0;
            long maxLen = ((long) MAX_VALUE) * 2;

            while (srcsLen &lt; maxLen) {
                ByteBuffer dup = src.duplicate();
                srcList.add(dup);
                srcsLen += dup.capacity();
            }

            ByteBuffer[] srcs = srcList.toArray(new ByteBuffer[0]);
            ByteBuffer dst = allocateBuffer(
                    param.type(), unwrapEngine(clientEngine).maxEncryptedPacketLength() - 1);

            SSLEngineResult result = clientEngine.wrap(srcs, dst);
            assertEquals(SSLEngineResult.Status.BUFFER_OVERFLOW, result.getStatus());

            for (ByteBuffer buffer : srcs) {
                assertEquals(0, buffer.position());
            }
            assertEquals(0, dst.position());
            assertEquals(0, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());
        } finally {
            cleanupClientSslEngine(clientEngine);
            cleanupServerSslEngine(serverEngine);
        }
    }

<A NAME="40"></A>    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testCalculateOutNetBufSizeOverflow(SSLEngineTestParam param) throws SSLException {
        clientSslCtx = <FONT color="#347235"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#40',2,'match16459-top.html#40',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
                                        .sslProvider(sslClientProvider())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SSLEngine clientEngine = null;
        try {
            clientEngine = clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);
            int value = ((ReferenceCountedOpenSslEngine) clientEngine).calculateMaxLengthForWrap(MAX_VALUE, 1);
            assertTrue(value &gt; 0);
        } finally {
            cleanupClientSslEngine(clientEngine);
        }
    }

<A NAME="39"></A>    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testCalculateOutNetBufSize0(SSLEngineTestParam param) throws SSLException {
        clientSslCtx = <FONT color="#152dc6"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#39',2,'match16459-top.html#39',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
                                        .sslProvider(sslClientProvider())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());
        SSLEngine clientEngine = null;
        try {
            clientEngine = clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);
            assertTrue(((ReferenceCountedOpenSslEngine) clientEngine).calculateMaxLengthForWrap(0, 1) &gt; 0);
        } finally {
            cleanupClientSslEngine(clientEngine);
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testCorrectlyCalculateSpaceForAlert(SSLEngineTestParam param) throws Exception {
        testCorrectlyCalculateSpaceForAlert(param, true);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testCorrectlyCalculateSpaceForAlertJDKCompatabilityModeOff(SSLEngineTestParam param) throws Exception {
        testCorrectlyCalculateSpaceForAlert(param, false);
    }

<A NAME="33"></A>    private void testCorrectlyCalculateSpaceForAlert(SSLEngineTestParam param, boolean jdkCompatabilityMode)
            throws Exception {
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#33',2,'match16459-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .protocols(param.protocols())
<A NAME="59"></A>                                        .ciphers(param.ciphers</B></FONT>())
                                        .build());

        clientSslCtx = <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#59',2,'match16459-top.html#59',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
                                        .sslProvider(sslClientProvider())
                                        .protocols(param.protocols</B></FONT>())
                                        .ciphers(param.ciphers())
                                        .build());
        SSLEngine clientEngine = null;
        SSLEngine serverEngine = null;
        try {
            if (jdkCompatabilityMode) {
                clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
                serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            } else {
                clientEngine = wrapEngine(clientSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());
                serverEngine = wrapEngine(serverSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());
            }
            handshake(param.type(), param.delegate(), clientEngine, serverEngine);

<A NAME="20"></A>            // This should produce an alert
            clientEngine.closeOutbound();

            <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#20',2,'match16459-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ByteBuffer empty = allocateBuffer(param.type(), 0);
            ByteBuffer dst = allocateBuffer(param.type(), clientEngine.getSession().getPacketBufferSize());
            // Limit to something that is guaranteed to be too small to hold an SSL Record.
            dst.limit(1);

            // As we called closeOutbound() before this should produce a BUFFER_OVERFLOW.
            SSLEngineResult result = clientEngine.wrap(empty, dst);
            assertEquals</B></FONT>(SSLEngineResult.Status.BUFFER_OVERFLOW, result.getStatus());

            // This must calculate a length that can hold an alert at least (or more).
            dst.limit(dst.capacity());

            result = clientEngine.wrap(empty, dst);
            assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());

            // flip the buffer so we can verify we produced a full length buffer.
            dst.flip();

            int length = SslUtils.getEncryptedPacketLength(new ByteBuffer[] { dst }, 0);
            assertEquals(length, dst.remaining());
        } finally {
            cleanupClientSslEngine(clientEngine);
            cleanupServerSslEngine(serverEngine);
            ssc.delete();
        }
    }

    @Override
    protected void mySetupMutualAuthServerInitSslHandler(SslHandler handler) {
        ReferenceCountedOpenSslEngine engine = (ReferenceCountedOpenSslEngine) handler.engine();
        engine.setVerify(SSL_CVERIFY_IGNORED, 1);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testWrapWithDifferentSizesTLSv1(SSLEngineTestParam param) throws Exception {
        clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
<A NAME="2"></A>                                        .sslProvider(sslClientProvider())
                                        .build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = wrapContext(param, <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#2',2,'match16459-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .build());

        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;AES128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;ECDHE-RSA-AES128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;AECDH-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;CAMELLIA128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;SEED-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;RC4-MD5&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;ADH-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;EDH-RSA-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;ADH-RC4-MD5&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;IDEA-CBC-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;RC4-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;CAMELLIA256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;AECDH-RC4-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;ECDHE-RSA-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;ECDHE-RSA-AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1, &quot;ECDHE-RSA-RC4-SHA&quot;);
    }

    @</B></FONT>MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testWrapWithDifferentSizesTLSv1_1(SSLEngineTestParam param) throws Exception {
        clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)
<A NAME="4"></A>                                        .sslProvider(sslClientProvider())
                                        .build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = wrapContext(param, <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#4',2,'match16459-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .build());

        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;ECDHE-RSA-AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;CAMELLIA256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;ECDHE-RSA-AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;SEED-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;CAMELLIA128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;IDEA-CBC-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;AECDH-RC4-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;ADH-RC4-MD5&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;RC4-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;ECDHE-RSA-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;EDH-RSA-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;AECDH-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;ADH-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_1, &quot;DES-CBC3-SHA&quot;);
    }

    @</B></FONT>MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testWrapWithDifferentSizesTLSv1_2(SSLEngineTestParam param) throws Exception {
        clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
                .trustManager(InsecureTrustManagerFactory.INSTANCE)
<A NAME="58"></A>                .sslProvider(sslClientProvider())
                .build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#58',2,'match16459-top.html#58',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                .sslProvider(sslServerProvider())
                .build());
<A NAME="1"></A>
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;AES128-SHA&quot;);
        testWrapWithDifferentSizes</B></FONT>(param, SslProtocols.TLS_v1_2, &quot;ECDHE-RSA-AES128-SHA&quot;);
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#1',2,'match16459-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;AES128-GCM-SHA256&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ECDHE-RSA-AES256-SHA384&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;AECDH-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;AES256-GCM-SHA384&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;AES256-SHA256&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ECDHE-RSA-AES128-GCM-SHA256&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ECDHE-RSA-AES128-SHA256&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;CAMELLIA128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;SEED-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;RC4-MD5&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ADH-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;EDH-RSA-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ADH-RC4-MD5&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;RC4-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;CAMELLIA256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;AES128-SHA256&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;AECDH-RC4-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ECDHE-RSA-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ECDHE-RSA-AES256-GCM-SHA384&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ECDHE-RSA-AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.TLS_v1_2, &quot;ECDHE-RSA-RC4-SHA&quot;);
    }

    @</B></FONT>MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testWrapWithDifferentSizesSSLv3(SSLEngineTestParam param) throws Exception {
        clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
                .trustManager(InsecureTrustManagerFactory.INSTANCE)
<A NAME="23"></A>                .sslProvider(sslClientProvider())
                .build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#23',2,'match16459-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                .sslProvider(sslServerProvider())
                .build());

        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ADH-AES128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ADH-CAMELLIA128-SHA&quot;);
<A NAME="3"></A>        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;AECDH-AES128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;AECDH-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes</B></FONT>(param, SslProtocols.SSL_v3, &quot;CAMELLIA128-SHA&quot;);
        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#3',2,'match16459-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;DHE-RSA-AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;SEED-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;RC4-MD5&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ADH-AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ADH-SEED-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ADH-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;EDH-RSA-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ADH-RC4-MD5&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;IDEA-CBC-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;DHE-RSA-AES128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;RC4-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;CAMELLIA256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;AECDH-RC4-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;DHE-RSA-SEED-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;AECDH-AES256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ECDHE-RSA-DES-CBC3-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ADH-CAMELLIA256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;DHE-RSA-CAMELLIA256-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;DHE-RSA-CAMELLIA128-SHA&quot;);
        testWrapWithDifferentSizes(param, SslProtocols.SSL_v3, &quot;ECDHE-RSA-RC4-SHA&quot;);
    }

    @</B></FONT>MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testMultipleRecordsInOneBufferWithNonZeroPositionJDKCompatabilityModeOff(SSLEngineTestParam param)
<A NAME="13"></A>            throws Exception {
        SelfSignedCertificate cert = new SelfSignedCertificate();

        clientSslCtx = wrapContext(param, <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#13',2,'match16459-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>SslContextBuilder
                .forClient()
                .trustManager(cert.cert())
                .sslProvider(sslClientProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers())
<A NAME="32"></A>                .build());
        SSLEngine client = wrapEngine(clientSslCtx.newHandler</B></FONT>(UnpooledByteBufAllocator.DEFAULT).engine());

        serverSslCtx = <FONT color="#5b8daf"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#32',2,'match16459-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder
                .forServer(cert.certificate(), cert.privateKey())
                .sslProvider(sslServerProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers</B></FONT>())
                .build());
        SSLEngine server = wrapEngine(serverSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());

        try {
            // Choose buffer size small enough that we can put multiple buffers into one buffer and pass it into the
            // unwrap call without exceed MAX_ENCRYPTED_PACKET_LENGTH.
            final int plainClientOutLen = 1024;
            ByteBuffer plainClientOut = allocateBuffer(param.type(), plainClientOutLen);
            ByteBuffer plainServerOut = allocateBuffer(param.type(), server.getSession().getApplicationBufferSize());

            ByteBuffer encClientToServer = allocateBuffer(param.type(), client.getSession().getPacketBufferSize());
<A NAME="5"></A>
            int positionOffset = 1;
            // We need to be able to hold 2 records + positionOffset
            ByteBuffer combinedEncClientToServer = <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#5',2,'match16459-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocateBuffer(
                    param.type(), encClientToServer.capacity() * 2 + positionOffset);
            combinedEncClientToServer.position(positionOffset);

            handshake(param.type(), param.delegate(), client, server);

            plainClientOut.limit(plainClientOut.capacity());
            SSLEngineResult result = client.wrap(plainClientOut, encClientToServer);
            assertEquals(plainClientOut.capacity(), result.bytesConsumed());
            assertTrue(result.bytesProduced() &gt; 0);

            encClientToServer.flip();

            // Copy the first record into the combined buffer
            combinedEncClientToServer.put(encClientToServer);

<A NAME="14"></A>            plainClientOut.clear();
            encClientToServer.clear</B></FONT>();

            <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#14',2,'match16459-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>result = client.wrap(plainClientOut, encClientToServer);
            assertEquals(plainClientOut.capacity(), result.bytesConsumed());
            assertTrue(result.bytesProduced() &gt; 0);

            encClientToServer.flip();

            // Copy the first record into the combined buffer
            combinedEncClientToServer.put(encClientToServer);

            encClientToServer.clear();

            combinedEncClientToServer.flip();
            combinedEncClientToServer.position(positionOffset);

            // Make sure the limit takes positionOffset into account to the content we are looking at is correct.
            combinedEncClientToServer.limit(
                    combinedEncClientToServer.limit</B></FONT>() - positionOffset);
            final int combinedEncClientToServerLen = combinedEncClientToServer.remaining();

            result = server.unwrap(combinedEncClientToServer, plainServerOut);
            assertEquals(0, combinedEncClientToServer.remaining());
            assertEquals(combinedEncClientToServerLen, result.bytesConsumed());
            assertEquals(plainClientOutLen, result.bytesProduced());
        } finally {
            cert.delete();
            cleanupClientSslEngine(client);
            cleanupServerSslEngine(server);
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
<A NAME="30"></A>    public void testInputTooBigAndFillsUpBuffersJDKCompatabilityModeOff(SSLEngineTestParam param) throws Exception {
        SelfSignedCertificate cert = new SelfSignedCertificate();

        clientSslCtx = <FONT color="#ae694a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#30',2,'match16459-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder
                .forClient()
                .trustManager(cert.cert())
                .sslProvider(sslClientProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers</B></FONT>())
<A NAME="29"></A>                .build());
        SSLEngine client = wrapEngine(clientSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());

        serverSslCtx = <FONT color="#af7a82"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#29',2,'match16459-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder
                .forServer(cert.certificate(), cert.privateKey())
                .sslProvider(sslServerProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers</B></FONT>())
                .build());
<A NAME="12"></A>        SSLEngine server = wrapEngine(serverSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());

        try {
            ByteBuffer plainClient = allocateBuffer(<FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#12',2,'match16459-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>param.type(), MAX_PLAINTEXT_LENGTH + 100);
            ByteBuffer plainClient2 = allocateBuffer(param.type(), 512);
            ByteBuffer plainClientTotal =
                    allocateBuffer(param.type(), plainClient.capacity() + plainClient2.capacity());
            plainClientTotal.put(plainClient);
            plainClientTotal.put(plainClient2);
            plainClient.clear();
            plainClient2.clear();
            plainClientTotal.flip</B></FONT>();

            // The capacity is designed to trigger an overflow condition.
<A NAME="42"></A>            ByteBuffer encClientToServerTooSmall = allocateBuffer(param.type(), MAX_PLAINTEXT_LENGTH + 28);
            ByteBuffer encClientToServer = allocateBuffer(param.type(), client.getSession().getApplicationBufferSize());
            ByteBuffer encClientToServerTotal =
<A NAME="10"></A>                    allocateBuffer(<FONT color="#c57717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#42',2,'match16459-top.html#42',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>param.type(), client.getSession().getApplicationBufferSize() &lt;&lt; 1);
            ByteBuffer plainServer = allocateBuffer(param.type(), server.getSession().getApplicationBufferSize() &lt;&lt; 1);

            handshake(param.type</B></FONT>(), <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#10',2,'match16459-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>param.delegate(), client, server);

            int plainClientRemaining = plainClient.remaining();
            int encClientToServerTooSmallRemaining = encClientToServerTooSmall.remaining();
            SSLEngineResult result = client.wrap(plainClient, encClientToServerTooSmall);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(plainClientRemaining - plainClient.remaining(), result.bytesConsumed());
            assertEquals(encClientToServerTooSmallRemaining - encClientToServerTooSmall.remaining(),
                    result.bytesProduced</B></FONT>());

            result = client.wrap(plainClient, encClientToServerTooSmall);
            assertEquals(SSLEngineResult.Status.BUFFER_OVERFLOW, result.getStatus());
            assertEquals(0, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());
<A NAME="54"></A>
            plainClientRemaining = plainClient.remaining();
            int encClientToServerRemaining = encClientToServer.remaining();
            result = <FONT color="#4e8975"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#54',2,'match16459-top.html#54',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>client.wrap(plainClient, encClientToServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(plainClientRemaining, result.bytesConsumed());
            assertEquals(encClientToServerRemaining - encClientToServer.remaining(), result.bytesProduced());
            assertEquals</B></FONT>(0, plainClient.remaining());

<A NAME="17"></A>            final int plainClient2Remaining = plainClient2.remaining();
            encClientToServerRemaining = encClientToServer.remaining();
            result = client.wrap(plainClient2, encClientToServer);
            <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#17',2,'match16459-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(plainClient2Remaining, result.bytesConsumed());
            assertEquals(encClientToServerRemaining - encClientToServer.remaining(), result.bytesProduced());

            // Concatenate the too small buffer
            encClientToServerTooSmall.flip();
            encClientToServer.flip();
            encClientToServerTotal.put(encClientToServerTooSmall);
            encClientToServerTotal.put(encClientToServer);
            encClientToServerTotal.flip();

            // Unwrap in a single call.
            final int encClientToServerTotalRemaining = encClientToServerTotal.remaining()</B></FONT>;
            result = server.unwrap(encClientToServerTotal, plainServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(encClientToServerTotalRemaining, result.bytesConsumed());
            plainServer.flip();
            assertEquals(plainClientTotal, plainServer);
        } finally {
            cert.delete();
            cleanupClientSslEngine(client);
            cleanupServerSslEngine(server);
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
<A NAME="27"></A>    public void testPartialPacketUnwrapJDKCompatabilityModeOff(SSLEngineTestParam param) throws Exception {
        SelfSignedCertificate cert = new SelfSignedCertificate();

        clientSslCtx = <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#27',2,'match16459-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder
                .forClient()
                .trustManager(cert.cert())
                .sslProvider(sslClientProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers</B></FONT>())
<A NAME="26"></A>                .build());
        SSLEngine client = wrapEngine(clientSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());

        serverSslCtx = <FONT color="#68818b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#26',2,'match16459-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder
                .forServer(cert.certificate(), cert.privateKey())
                .sslProvider(sslServerProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers</B></FONT>())
                .build());
<A NAME="21"></A>        SSLEngine server = wrapEngine(serverSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());

        try {
            ByteBuffer plainClient = allocateBuffer(<FONT color="#947010"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#21',2,'match16459-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>param.type(), 1024);
            ByteBuffer plainClient2 = allocateBuffer(param.type(), 512);
            ByteBuffer plainClientTotal =
                    allocateBuffer(param.type(), plainClient.capacity() + plainClient2.capacity());
            plainClientTotal.put(plainClient);
            plainClientTotal.put(plainClient2);
            plainClient.clear</B></FONT>();
<A NAME="18"></A>            plainClient2.clear();
            plainClientTotal.flip();

            ByteBuffer encClientToServer = <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#18',2,'match16459-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocateBuffer(param.type(), client.getSession().getPacketBufferSize());
            ByteBuffer plainServer = allocateBuffer(param.type(), server.getSession().getApplicationBufferSize());

            handshake(param.type(), param.delegate</B></FONT>(), client, server);

            SSLEngineResult result = client.wrap(plainClient, encClientToServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(result.bytesConsumed(), plainClient.capacity());
            final int encClientLen = result.bytesProduced();

            result = client.wrap(plainClient2, encClientToServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(result.bytesConsumed(), plainClient2.capacity());
            final int encClientLen2 = result.bytesProduced();

            // Flip so we can read it.
            encClientToServer.flip();

            // Consume a partial TLS packet.
            ByteBuffer encClientFirstHalf = encClientToServer.duplicate();
            encClientFirstHalf.limit(encClientLen / 2);
            result = server.unwrap(encClientFirstHalf, plainServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(result.bytesConsumed(), encClientLen / 2);
            encClientToServer.position(result.bytesConsumed());

            // We now have half of the first packet and the whole second packet, so lets decode all but the last byte.
            ByteBuffer encClientAllButLastByte = encClientToServer.duplicate();
            final int encClientAllButLastByteLen = encClientAllButLastByte.remaining() - 1;
            encClientAllButLastByte.limit(encClientAllButLastByte.limit() - 1);
            result = server.unwrap(encClientAllButLastByte, plainServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(result.bytesConsumed(), encClientAllButLastByteLen);
            encClientToServer.position(encClientToServer.position() + result.bytesConsumed());

            // Read the last byte and verify the original content has been decrypted.
            result = server.unwrap(encClientToServer, plainServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(result.bytesConsumed(), 1);
            plainServer.flip();
            assertEquals(plainClientTotal, plainServer);
        } finally {
            cert.delete();
            cleanupClientSslEngine(client);
            cleanupServerSslEngine(server);
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
<A NAME="25"></A>    public void testBufferUnderFlowAvoidedIfJDKCompatabilityModeOff(SSLEngineTestParam param) throws Exception {
        SelfSignedCertificate cert = new SelfSignedCertificate();

        clientSslCtx = <FONT color="#5eac10"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#25',2,'match16459-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder
                .forClient()
                .trustManager(cert.cert())
                .sslProvider(sslClientProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers</B></FONT>())
<A NAME="24"></A>                .build());
        SSLEngine client = wrapEngine(clientSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());

        serverSslCtx = <FONT color="#79764d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#24',2,'match16459-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder
                .forServer(cert.certificate(), cert.privateKey())
                .sslProvider(sslServerProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers</B></FONT>())
                .build());
        SSLEngine server = wrapEngine(serverSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());

        try {
            ByteBuffer plainClient = allocateBuffer(param.type(), 1024);
<A NAME="9"></A>            plainClient.limit(plainClient.capacity());

            ByteBuffer encClientToServer = allocateBuffer(param.type(), client.getSession().getPacketBufferSize());
            ByteBuffer plainServer = <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#9',2,'match16459-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocateBuffer(param.type(), server.getSession().getApplicationBufferSize());

            handshake(param.type(), param.delegate(), client, server);

            SSLEngineResult result = client.wrap(plainClient, encClientToServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(result.bytesConsumed(), plainClient.capacity());

            // Flip so we can read it.
            encClientToServer.flip</B></FONT>();
            int remaining = encClientToServer.remaining();
<A NAME="53"></A>
            // We limit the buffer so we have less then the header to read, this should result in an BUFFER_UNDERFLOW.
            encClientToServer.limit(SslUtils.SSL_RECORD_HEADER_LENGTH - 1);
            result = <FONT color="#ad5a3d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#53',2,'match16459-top.html#53',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>server.unwrap(encClientToServer, plainServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(SslUtils.SSL_RECORD_HEADER_LENGTH - 1, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());
            remaining -= result.bytesConsumed();

<A NAME="51"></A>            // We limit the buffer so we can read the header but not the rest, this should result in an
            // BUFFER_UNDERFLOW.
            encClientToServer.limit</B></FONT>(SslUtils.SSL_RECORD_HEADER_LENGTH);
            result = <FONT color="#b38481"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#51',2,'match16459-top.html#51',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>server.unwrap(encClientToServer, plainServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(1, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());
            remaining -= result.bytesConsumed();

            // We limit the buffer so we can read the header and partly the rest, this should result in an
<A NAME="22"></A>            // BUFFER_UNDERFLOW.
            encClientToServer.limit</B></FONT>(
                    SslUtils.SSL_RECORD_HEADER_LENGTH  + remaining - 1 - SslUtils.SSL_RECORD_HEADER_LENGTH);
            result = <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#22',2,'match16459-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>server.unwrap(encClientToServer, plainServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(encClientToServer.limit() - SslUtils.SSL_RECORD_HEADER_LENGTH, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());
            remaining -= result.bytesConsumed();

            // Reset limit so we can read the full record.
            encClientToServer.limit(remaining);
            assertEquals(0, encClientToServer.remaining</B></FONT>());
            result = server.unwrap(encClientToServer, plainServer);
            assertEquals(SSLEngineResult.Status.BUFFER_UNDERFLOW, result.getStatus());
            assertEquals(0, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());

            encClientToServer.position(0);
            result = server.unwrap(encClientToServer, plainServer);
            assertEquals(SSLEngineResult.Status.OK, result.getStatus());
            assertEquals(remaining, result.bytesConsumed());
            assertEquals(0, result.bytesProduced());
        } finally {
            cert.delete();
            cleanupClientSslEngine(client);
            cleanupServerSslEngine(server);
        }
    }

    private void testWrapWithDifferentSizes(SSLEngineTestParam param, String protocol, String cipher) throws Exception {
        assumeTrue(OpenSsl.SUPPORTED_PROTOCOLS_SET.contains(protocol));
        if (!OpenSsl.isCipherSuiteAvailable(cipher)) {
            return;
        }

        SSLEngine clientEngine = null;
        SSLEngine serverEngine = null;
        try {
            clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
            clientEngine.setEnabledCipherSuites(new String[] { cipher });
            clientEngine.setEnabledProtocols(new String[] { protocol });
            serverEngine.setEnabledCipherSuites(new String[] { cipher });
            serverEngine.setEnabledProtocols(new String[] { protocol });

            try {
                handshake(param.type(), param.delegate(), clientEngine, serverEngine);
            } catch (SSLException e) {
                if (e.getMessage().contains(&quot;unsupported protocol&quot;) ||
                        e.getMessage().contains(&quot;no protocols available&quot;)) {
                    throw new AssumptionViolatedException(protocol + &quot; not supported with cipher &quot; + cipher, e);
                }
                throw e;
            }

            int srcLen = 64;
            do {
                testWrapDstBigEnough(param.type(), clientEngine, srcLen);
                srcLen += 64;
            } while (srcLen &lt; MAX_PLAINTEXT_LENGTH);

            testWrapDstBigEnough(param.type(), clientEngine, MAX_PLAINTEXT_LENGTH);
        } finally {
            cleanupClientSslEngine(clientEngine);
            cleanupServerSslEngine(serverEngine);
        }
    }

    private void testWrapDstBigEnough(BufferType type, SSLEngine engine, int srcLen) throws SSLException {
<A NAME="11"></A>        ByteBuffer src = allocateBuffer(type, srcLen);
        ByteBuffer dst = allocateBuffer(type, srcLen + unwrapEngine(engine).maxWrapOverhead());

        <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#11',2,'match16459-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>SSLEngineResult result = engine.wrap(src, dst);
        assertEquals(SSLEngineResult.Status.OK, result.getStatus());
        int consumed = result.bytesConsumed();
        int produced = result.bytesProduced();
        assertEquals(srcLen, consumed);
        assertTrue(produced &gt; consumed);

        dst.flip();
        assertEquals(produced, dst.remaining());
        assertFalse(src.hasRemaining</B></FONT>());
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
<A NAME="50"></A>    public void testSNIMatchersDoesNotThrow(SSLEngineTestParam param) throws Exception {
        assumeTrue(PlatformDependent.javaVersion() &gt;= 8);
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = <FONT color="#ff0000"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#50',2,'match16459-top.html#50',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider</B></FONT>())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers())
                                        .build());

        SSLEngine engine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
        try {
            SSLParameters parameters = new SSLParameters();
            Java8SslTestUtils.setSNIMatcher(parameters, EmptyArrays.EMPTY_BYTES);
            engine.setSSLParameters(parameters);
        } finally {
            cleanupServerSslEngine(engine);
            ssc.delete();
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testSNIMatchersWithSNINameWithUnderscore(SSLEngineTestParam param) throws Exception {
        assumeTrue(PlatformDependent.javaVersion() &gt;= 8);
        byte[] name = &quot;rb8hx3pww30y3tvw0mwy.v1_1&quot;.getBytes(CharsetUtil.UTF_8);
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers())
<A NAME="56"></A>                                        .build());

        SSLEngine engine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
        try <FONT color="#52d017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#56',2,'match16459-top.html#56',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            SSLParameters parameters = new SSLParameters();
            Java8SslTestUtils.setSNIMatcher(parameters, name);
            engine.setSSLParameters(parameters);
            assertFalse(unwrapEngine(engine).checkSniHostnameMatch(&quot;other&quot;.getBytes</B></FONT>(CharsetUtil.UTF_8)));
        } finally {
            cleanupServerSslEngine(engine);
            ssc.delete();
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testAlgorithmConstraintsThrows(SSLEngineTestParam param) throws Exception {
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                                        .sslProvider(sslServerProvider())
                                        .protocols(param.protocols())
                                        .ciphers(param.ciphers())
                                        .build());

        final SSLEngine engine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
        final SSLParameters parameters = new SSLParameters();
        parameters.setAlgorithmConstraints(new AlgorithmConstraints() {
            @Override
            public boolean permits(
                    Set&lt;CryptoPrimitive&gt; primitives, String algorithm, AlgorithmParameters parameters) {
                return false;
            }

            @Override
            public boolean permits(Set&lt;CryptoPrimitive&gt; primitives, Key key) {
                return false;
            }

            @Override
            public boolean permits(
                    Set&lt;CryptoPrimitive&gt; primitives, String algorithm, Key key, AlgorithmParameters parameters) {
                return false;
            }
        });
        try {
            assertThrows(IllegalArgumentException.class, new Executable() {
                @Override
                public void execute() throws Throwable {
                    engine.setSSLParameters(parameters);
                }
            });
        } finally {
            cleanupServerSslEngine(engine);
            ssc.delete();
        }
    }

    private static void runTasksIfNeeded(SSLEngine engine) {
        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
            for (;;) {
                Runnable task = engine.getDelegatedTask();
                if (task == null) {
                    assertNotEquals(HandshakeStatus.NEED_TASK, engine.getHandshakeStatus());
                    break;
                }
                task.run();
            }
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testExtractMasterkeyWorksCorrectly(SSLEngineTestParam param) throws Exception {
        if (param.combo() != ProtocolCipherCombo.tlsv12()) {
            return;
        }
        SelfSignedCertificate cert = new SelfSignedCertificate();
        serverSslCtx = wrapContext(param, SslContextBuilder.forServer(cert.key(), cert.cert())
                .protocols(param.protocols())
                .ciphers(param.ciphers())
                .sslProvider(SslProvider.OPENSSL).build());
        final SSLEngine serverEngine =
                wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
        clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
                .trustManager(cert.certificate())
                .protocols(param.protocols())
                .ciphers(param.ciphers())
                .sslProvider(SslProvider.OPENSSL).build());
        final SSLEngine clientEngine =
                wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));

        final String enabledCipher = &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&quot;;
        try {
            //lets set the cipher suite to a specific one with DHE
            assumeTrue(Arrays.asList(clientEngine.getSupportedCipherSuites()).contains(enabledCipher),
                    &quot;The diffie hellman cipher is not supported on your runtime.&quot;);

            //https://www.ietf.org/rfc/rfc5289.txt
            //For cipher suites ending with _SHA256, the PRF is the TLS PRF
            //[RFC5246] with SHA-256 as the hash function.  The MAC is HMAC
            //[RFC2104] with SHA-256 as the hash function.
<A NAME="57"></A>            clientEngine.setEnabledCipherSuites(new String[] { enabledCipher });
            serverEngine.setEnabledCipherSuites(new String[] { enabledCipher });

            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#57',2,'match16459-top.html#57',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int appBufferMax = clientEngine.getSession().getApplicationBufferSize();
            int netBufferMax = clientEngine.getSession().getPacketBufferSize();

            /*
             * We'll make the input buffers a bit bigger than the max needed
             * size, so that unwrap()s following a successful data transfer
             * won't generate BUFFER_OVERFLOWS.
             */
            ByteBuffer clientIn = ByteBuffer.allocate(appBufferMax + 50);
            ByteBuffer serverIn = ByteBuffer.allocate(appBufferMax + 50)</B></FONT>;

            ByteBuffer cTOs = ByteBuffer.allocate(netBufferMax);
            ByteBuffer sTOc = ByteBuffer.allocate(netBufferMax);

            ByteBuffer clientOut = ByteBuffer.wrap(&quot;Hi Server, I'm Client&quot;.getBytes(CharsetUtil.US_ASCII));
            ByteBuffer serverOut = ByteBuffer.wrap(&quot;Hello Client, I'm Server&quot;.getBytes(CharsetUtil.US_ASCII));

            // This implementation is largely imitated from
            // https://docs.oracle.com/javase/8/docs/technotes/
            // guides/security/jsse/samples/sslengine/SSLEngineSimpleDemo.java
            // It has been simplified however without the need for running delegation tasks

            // Do handshake for SSL
            // A typical handshake will usually contain the following steps:
            // 1. wrap:     ClientHello
            // 2. unwrap:   ServerHello/Cert/ServerHelloDone
            // 3. wrap:     ClientKeyExchange
            // 4. wrap:     ChangeCipherSpec
            // 5. wrap:     Finished
            // 6. unwrap:   ChangeCipherSpec
            // 7. unwrap:   Finished
<A NAME="49"></A>
            //set a for loop; instead of a while loop to guarantee we quit out eventually
            boolean asserted = false;
            for (int i = 0; i &lt; 1000; i++) <FONT color="#8e35ef"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#49',2,'match16459-top.html#49',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{

                clientEngine.wrap(clientOut, cTOs);
                serverEngine.wrap(serverOut, sTOc);

                cTOs.flip();
                sTOc.flip();

                runTasksIfNeeded(clientEngine);
                runTasksIfNeeded(serverEngine);

                clientEngine.unwrap(sTOc, clientIn);
                serverEngine.unwrap(cTOs, serverIn);

                runTasksIfNeeded</B></FONT>(clientEngine);
                runTasksIfNeeded(serverEngine);

                // check when the application data has fully been consumed and sent
                // for both the client and server
                if ((clientOut.limit() == serverIn.position()) &amp;&amp;
                        (serverOut.limit() == clientIn.position())) {
                    byte[] serverRandom = SSL.getServerRandom(unwrapEngine(serverEngine).sslPointer());
                    byte[] clientRandom = SSL.getClientRandom(unwrapEngine(clientEngine).sslPointer());
                    byte[] serverMasterKey = SSL.getMasterKey(unwrapEngine(serverEngine).sslPointer());
                    byte[] clientMasterKey = SSL.getMasterKey(unwrapEngine(clientEngine).sslPointer());

                    asserted = true;
                    assertArrayEquals(serverMasterKey, clientMasterKey);

                    // let us re-read the encrypted data and decrypt it ourselves!
                    cTOs.flip();
                    sTOc.flip();

                    // See https://tools.ietf.org/html/rfc5246#section-6.3:
                    // key_block = PRF(SecurityParameters.master_secret, &quot;key expansion&quot;,
                    //                 SecurityParameters.server_random + SecurityParameters.client_random);
                    //
                    // partitioned:
                    //       client_write_MAC_secret[SecurityParameters.hash_size]
                    //       server_write_MAC_secret[SecurityParameters.hash_size]
                    //       client_write_key[SecurityParameters.key_material_length]
                    //       server_write_key[SecurityParameters.key_material_length]

                    int keySize = 16; // AES is 16 bytes or 128 bits
                    int macSize = 32; // SHA256 is 32 bytes or 256 bits
                    int keyBlockSize = (2 * keySize) + (2 * macSize);

                    byte[] seed = new byte[serverRandom.length + clientRandom.length];
                    System.arraycopy(serverRandom, 0, seed, 0, serverRandom.length);
                    System.arraycopy(clientRandom, 0, seed, serverRandom.length, clientRandom.length);
                    byte[] keyBlock = PseudoRandomFunction.hash(serverMasterKey,
<A NAME="52"></A>                            &quot;key expansion&quot;.getBytes(CharsetUtil.US_ASCII), seed, keyBlockSize, &quot;HmacSha256&quot;);

                    int offset = 0;
                    byte[] clientWriteMac = <FONT color="#2b60de"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#52',2,'match16459-top.html#52',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Arrays.copyOfRange(keyBlock, offset, offset + macSize);
                    offset += macSize;

                    byte[] serverWriteMac = Arrays.copyOfRange(keyBlock, offset, offset + macSize);
                    offset += macSize;

                    byte[] clientWriteKey = Arrays.copyOfRange(keyBlock, offset, offset + keySize);
                    offset += keySize;

                    byte[] serverWriteKey = Arrays.copyOfRange(keyBlock, offset, offset + keySize);
                    offset += keySize;

                    //advance the cipher text by 5
                    //to take into account the TLS Record Header
                    cTOs.position(cTOs.position</B></FONT>() + 5);

                    byte[] ciphertext = new byte[cTOs.remaining()];
                    cTOs.get(ciphertext);

                    //the initialization vector is the first 16 bytes (128 bits) of the payload
                    byte[] clientWriteIV = Arrays.copyOfRange(ciphertext, 0, 16);
                    ciphertext = Arrays.copyOfRange(ciphertext, 16, ciphertext.length);

                    SecretKeySpec secretKey = new SecretKeySpec(clientWriteKey, &quot;AES&quot;);
                    final IvParameterSpec ivForCBC = new IvParameterSpec(clientWriteIV);
                    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);
                    cipher.init(Cipher.DECRYPT_MODE, secretKey, ivForCBC);
                    byte[] plaintext = cipher.doFinal(ciphertext);
                    assertTrue(new String(plaintext).startsWith(&quot;Hi Server, I'm Client&quot;));
                    break;
                } else {
                    cTOs.compact();
                    sTOc.compact();
                }
            }

            assertTrue(asserted, &quot;The assertions were never executed.&quot;);
        } finally {
            cleanupClientSslEngine(clientEngine);
            cleanupServerSslEngine(serverEngine);
            cert.delete();
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testNoKeyFound(final SSLEngineTestParam param) throws Exception {
        checkShouldUseKeyManagerFactory();
        clientSslCtx = wrapContext(param, SslContextBuilder
                .forClient()
                .trustManager(InsecureTrustManagerFactory.INSTANCE)
                .sslProvider(sslClientProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers())
<A NAME="38"></A>                .build());
        final SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));

        serverSslCtx = <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#38',2,'match16459-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>wrapContext(param, SslContextBuilder
                .forServer(new X509ExtendedKeyManager() {
                    @Override
                    public String[] getClientAliases(String keyType</B></FONT>, Principal[] issuers) {
                        return new String[0];
                    }

                    @Override
                    public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {
                        return null;
                    }

                    @Override
                    public String[] getServerAliases(String keyType, Principal[] issuers) {
                        return new String[0];
                    }

                    @Override
                    public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {
                        return null;
                    }

                    @Override
                    public X509Certificate[] getCertificateChain(String alias) {
                        return new X509Certificate[0];
                    }

                    @Override
                    public PrivateKey getPrivateKey(String alias) {
                        return null;
                    }
                })
                .sslProvider(sslServerProvider())
                .protocols(param.protocols())
                .ciphers(param.ciphers())
                .build());
        final SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));

        try {
            assertThrows(SSLException.class, new Executable() {
                @Override
                public void execute() throws Throwable {
                    handshake(param.type(), param.delegate(), client, server);
                }
            });
        } finally {
            cleanupClientSslEngine(client);
            cleanupServerSslEngine(server);
        }
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    @Override
    public void testSessionLocalWhenNonMutualWithKeyManager(SSLEngineTestParam param) throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testSessionLocalWhenNonMutualWithKeyManager(param);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    @Override
    public void testSessionLocalWhenNonMutualWithoutKeyManager(SSLEngineTestParam param) throws Exception {
        // This only really works when the KeyManagerFactory is supported as otherwise we not really know when
        // we need to provide a cert.
        assumeTrue(OpenSsl.supportsKeyManagerFactory());
        super.testSessionLocalWhenNonMutualWithoutKeyManager(param);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testDefaultTLS1NotAcceptedByDefaultServer(SSLEngineTestParam param) throws Exception {
        testDefaultTLS1NotAcceptedByDefault(param, null, SslProtocols.TLS_v1);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testDefaultTLS11NotAcceptedByDefaultServer(SSLEngineTestParam param) throws Exception {
        testDefaultTLS1NotAcceptedByDefault(param, null, SslProtocols.TLS_v1_1);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testDefaultTLS1NotAcceptedByDefaultClient(SSLEngineTestParam param) throws Exception {
        testDefaultTLS1NotAcceptedByDefault(param, SslProtocols.TLS_v1, null);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    public void testDefaultTLS11NotAcceptedByDefaultClient(SSLEngineTestParam param) throws Exception {
        testDefaultTLS1NotAcceptedByDefault(param, SslProtocols.TLS_v1_1, null);
    }

    private void testDefaultTLS1NotAcceptedByDefault(final SSLEngineTestParam param,
                                                     String clientProtocol, String serverProtocol) throws Exception {
        SslContextBuilder clientCtxBuilder = SslContextBuilder.forClient()
                .trustManager(InsecureTrustManagerFactory.INSTANCE)
                .sslProvider(sslClientProvider())
                .sslContextProvider(clientSslContextProvider());
        if (clientProtocol != null) {
            clientCtxBuilder.protocols(clientProtocol);
        }
<A NAME="48"></A>        clientSslCtx = wrapContext(param, clientCtxBuilder.build());
        SelfSignedCertificate ssc = new SelfSignedCertificate();

        SslContextBuilder serverCtxBuilder = <FONT color="#c57726"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#48',2,'match16459-top.html#48',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
                .sslProvider(sslServerProvider())
                .sslContextProvider(serverSslContextProvider());
        if (serverProtocol != null) {
            serverCtxBuilder.protocols</B></FONT>(serverProtocol);
        }
        serverSslCtx = wrapContext(param, serverCtxBuilder.build());
        final SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
        final SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));

        try {
            assertThrows(SSLHandshakeException.class, new Executable() {
                @Override
                public void execute() throws Throwable {
                    handshake(param.type(), param.delegate(), client, server);
                }
            });
        } finally {
            cleanupClientSslEngine(client);
            cleanupServerSslEngine(server);
            ssc.delete();
        }
    }

    @Override
    protected SslProvider sslClientProvider() {
        return SslProvider.OPENSSL;
    }

    @Override
    protected SslProvider sslServerProvider() {
        return SslProvider.OPENSSL;
    }

    private static ApplicationProtocolConfig acceptingNegotiator(Protocol protocol,
            String... supportedProtocols) {
        return new ApplicationProtocolConfig(protocol,
                SelectorFailureBehavior.NO_ADVERTISE,
                SelectedListenerFailureBehavior.ACCEPT,
                supportedProtocols);
    }

    @Override
    protected SSLEngine wrapEngine(SSLEngine engine) {
        if (PlatformDependent.javaVersion() &gt;= 8) {
            return Java8SslTestUtils.wrapSSLEngineForTesting(engine);
        }
        return engine;
    }

    ReferenceCountedOpenSslEngine unwrapEngine(SSLEngine engine) {
        if (engine instanceof JdkSslEngine) {
            return (ReferenceCountedOpenSslEngine) ((JdkSslEngine) engine).getWrappedEngine();
        }
        return (ReferenceCountedOpenSslEngine) engine;
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    @Override
    protected SslContext wrapContext(SSLEngineTestParam param, SslContext context) {
        if (context instanceof OpenSslContext) {
            if (param instanceof OpenSslEngineTestParam) {
                ((OpenSslContext) context).setUseTasks(((OpenSslEngineTestParam) param).useTasks);
            }
            // Explicit enable the session cache as its disabled by default on the client side.
            ((OpenSslContext) context).sessionContext().setSessionCacheEnabled(true);
        }
        return context;
    }

    @MethodSource(&quot;newTestParams&quot;)
<A NAME="55"></A>    @ParameterizedTest
    @Override
    public void testSessionCache(SSLEngineTestParam param) throws Exception {
        <FONT color="#4863a0"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#55',2,'match16459-top.html#55',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assumeTrue(OpenSsl.isSessionCacheSupported());
        super.testSessionCache(param);
        assertSessionContext(clientSslCtx);
        assertSessionContext(serverSslCtx);
    }

    @</B></FONT>MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    @Override
    public void testSessionCacheTimeout(SSLEngineTestParam param) throws Exception {
        assumeTrue(OpenSsl.isSessionCacheSupported());
        super.testSessionCacheTimeout(param);
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    @Override
    public void testSessionCacheSize(SSLEngineTestParam param) throws Exception {
        assumeTrue(OpenSsl.isSessionCacheSupported());
        super.testSessionCacheSize(param);
    }

    private static void assertSessionContext(SslContext context) {
        if (context == null) {
            return;
        }
<A NAME="19"></A>        OpenSslSessionContext serverSessionCtx = (OpenSslSessionContext) context.sessionContext();
        assertTrue(serverSessionCtx.isSessionCacheEnabled());
        if (serverSessionCtx.getIds().hasMoreElements()) {
            <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#19',2,'match16459-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>serverSessionCtx.setSessionCacheEnabled(false);
            assertFalse(serverSessionCtx.getIds().hasMoreElements());
            assertFalse(serverSessionCtx.isSessionCacheEnabled());
        }
    }
<A NAME="47"></A>
    @</B></FONT>Override
    protected void assertSessionReusedForEngine(SSLEngine clientEngine, SSLEngine serverEngine, boolean reuse) {
        <FONT color="#d16587"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16459-0.html#47',2,'match16459-top.html#47',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertEquals(reuse, unwrapEngine(clientEngine).isSessionReused());
        assertEquals(reuse, unwrapEngine(serverEngine).isSessionReused());
    }

    @</B></FONT>Override
    protected boolean isSessionMaybeReused(SSLEngine engine) {
        return unwrapEngine(engine).isSessionReused();
    }

    @MethodSource(&quot;newTestParams&quot;)
    @ParameterizedTest
    @Override
    public void testRSASSAPSS(SSLEngineTestParam param) throws Exception {
        checkShouldUseKeyManagerFactory();
        super.testRSASSAPSS(param);
    }
}
</PRE>
</div>
  </div>
</body>
</html>
