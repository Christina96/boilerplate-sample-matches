<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for NioUdtAcceptorChannel.java &amp; MessageAggregator.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for NioUdtAcceptorChannel.java &amp; MessageAggregator.java
      </h3>
<h1 align="center">
        6.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>NioUdtAcceptorChannel.java (10.784314%)<th>MessageAggregator.java (4.710921%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(16-29)<td><a href="#" name="0">(16-31)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(73-80)<td><a href="#" name="1">(190-200)</a><td align="center"><font color="#b00000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>NioUdtAcceptorChannel.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.channel.udt.nio;
2 import com.barchart.udt.TypeUDT;
3 import com.barchart.udt.nio.ServerSocketChannelUDT;
4 import com.barchart.udt.nio.SocketChannelUDT;
5 import io.netty.channel.ChannelException;
6 import io.netty.channel.ChannelMetadata;
7 import io.netty.channel.ChannelOutboundBuffer;
8 import io.netty.util.internal.SocketUtils;
9 import io.netty.channel.nio.AbstractNioMessageChannel;
10 import io.netty.channel.udt.DefaultUdtServerChannelConfig;
11 import io.netty.channel.udt.UdtChannel;
12 import io.netty.channel.udt.UdtServerChannel;
13 import</b></font> io.netty.channel.udt.UdtServerChannelConfig;
14 import io.netty.util.internal.logging.InternalLogger;
15 import io.netty.util.internal.logging.InternalLoggerFactory;
16 import java.net.InetSocketAddress;
17 import java.net.SocketAddress;
18 import java.util.List;
19 import static java.nio.channels.SelectionKey.*;
20 @Deprecated
21 public abstract class NioUdtAcceptorChannel extends AbstractNioMessageChannel implements UdtServerChannel {
22     protected static final InternalLogger logger =
23             InternalLoggerFactory.getInstance(NioUdtAcceptorChannel.class);
24     private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
25     private final UdtServerChannelConfig config;
26     protected NioUdtAcceptorChannel(final ServerSocketChannelUDT channelUDT) {
27         super(null, channelUDT, OP_ACCEPT);
28         try {
29             channelUDT.configureBlocking(false);
30             config = new DefaultUdtServerChannelConfig(this, channelUDT, true);
31         } catch (final Exception e) {
32             try {
33                 channelUDT.close();
34             } catch (final Exception e2) {
35                 if (logger.isWarnEnabled()) {
36                     logger.warn("Failed to close channel.", e2);
37                 }
38             }
39             throw new ChannelException("Failed to configure channel.", e);
40         }
41     }
42 <a name="1"></a>
43     protected NioUdtAcceptorChannel(final TypeUDT type) {
44         this(NioUdtProvider.newAcceptorChannelUDT(type));
45     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
46     @Override
47     public UdtServerChannelConfig config() {
48         return config;
49     }
50     @Overr</b></font>ide
51     protected void doBind(final SocketAddress localAddress) throws Exception {
52         javaChannel().socket().bind(localAddress, config.getBacklog());
53     }
54     @Override
55     protected void doClose() throws Exception {
56         javaChannel().close();
57     }
58     @Override
59     protected boolean doConnect(final SocketAddress remoteAddress,
60             final SocketAddress localAddress) throws Exception {
61         throw new UnsupportedOperationException();
62     }
63     @Override
64     protected void doDisconnect() throws Exception {
65         throw new UnsupportedOperationException();
66     }
67     @Override
68     protected void doFinishConnect() throws Exception {
69         throw new UnsupportedOperationException();
70     }
71     @Override
72     protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Exception {
73         throw new UnsupportedOperationException();
74     }
75     @Override
76     protected final Object filterOutboundMessage(Object msg) throws Exception {
77         throw new UnsupportedOperationException();
78     }
79     @Override
80     public boolean isActive() {
81         return javaChannel().socket().isBound();
82     }
83     @Override
84     protected ServerSocketChannelUDT javaChannel() {
85         return (ServerSocketChannelUDT) super.javaChannel();
86     }
87     @Override
88     protected SocketAddress localAddress0() {
89         return SocketUtils.localSocketAddress(javaChannel().socket());
90     }
91     @Override
92     public InetSocketAddress localAddress() {
93         return (InetSocketAddress) super.localAddress();
94     }
95     @Override
96     public InetSocketAddress remoteAddress() {
97         return null;
98     }
99     @Override
100     protected SocketAddress remoteAddress0() {
101         return null;
102     }
103     @Override
104     public ChannelMetadata metadata() {
105         return METADATA;
106     }
107     @Override
108     protected int doReadMessages(List&lt;Object&gt; buf) throws Exception {
109         final SocketChannelUDT channelUDT = (SocketChannelUDT) SocketUtils.accept(javaChannel());
110         if (channelUDT == null) {
111             return 0;
112         } else {
113             buf.add(newConnectorChannel(channelUDT));
114             return 1;
115         }
116     }
117     protected abstract UdtChannel newConnectorChannel(SocketChannelUDT channelUDT);
118 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MessageAggregator.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.codec;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.buffer.ByteBufHolder;
4 import io.netty.buffer.CompositeByteBuf;
5 import io.netty.channel.ChannelFuture;
6 import io.netty.channel.ChannelFutureListener;
7 import io.netty.channel.ChannelHandler;
8 import io.netty.channel.ChannelHandlerContext;
9 import io.netty.channel.ChannelPipeline;
10 import io.netty.util.ReferenceCountUtil;
11 import java.util.List;
12 import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
13 import</b></font> static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
14 public abstract class MessageAggregator&lt;I, S, C extends ByteBufHolder, O extends ByteBufHolder&gt;
15         extends MessageToMessageDecoder&lt;I&gt; {
16     private static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024;
17     private final int maxContentLength;
18     private O currentMessage;
19     private boolean handlingOversizedMessage;
20     private int maxCumulationBufferComponents = DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS;
21     private ChannelHandlerContext ctx;
22     private ChannelFutureListener continueResponseWriteListener;
23     private boolean aggregating;
24     protected MessageAggregator(int maxContentLength) {
25         validateMaxContentLength(maxContentLength);
26         this.maxContentLength = maxContentLength;
27     }
28     protected MessageAggregator(int maxContentLength, Class&lt;? extends I&gt; inboundMessageType) {
29         super(inboundMessageType);
30         validateMaxContentLength(maxContentLength);
31         this.maxContentLength = maxContentLength;
32     }
33     private static void validateMaxContentLength(int maxContentLength) {
34         checkPositiveOrZero(maxContentLength, "maxContentLength");
35     }
36     @Override
37     public boolean acceptInboundMessage(Object msg) throws Exception {
38         if (!super.acceptInboundMessage(msg)) {
39             return false;
40         }
41         @SuppressWarnings("unchecked")
42         I in = (I) msg;
43         if (isAggregated(in)) {
44             return false;
45         }
46         if (isStartMessage(in)) {
47             aggregating = true;
48             return true;
49         } else if (aggregating &amp;&amp; isContentMessage(in)) {
50             return true;
51         }
52         return false;
53     }
54     protected abstract boolean isStartMessage(I msg) throws Exception;
55     protected abstract boolean isContentMessage(I msg) throws Exception;
56     protected abstract boolean isLastContentMessage(C msg) throws Exception;
57     protected abstract boolean isAggregated(I msg) throws Exception;
58     public final int maxContentLength() {
59         return maxContentLength;
60     }
61     public final int maxCumulationBufferComponents() {
62         return maxCumulationBufferComponents;
63     }
64     public final void setMaxCumulationBufferComponents(int maxCumulationBufferComponents) {
65         if (maxCumulationBufferComponents &lt; 2) {
66             throw new IllegalArgumentException(
67                     "maxCumulationBufferComponents: " + maxCumulationBufferComponents +
68                     " (expected: &gt;= 2)");
69         }
70         if (ctx == null) {
71             this.maxCumulationBufferComponents = maxCumulationBufferComponents;
72         } else {
73 <a name="1"></a>            throw new IllegalStateException(
74                     "decoder properties cannot be changed once the decoder is added to a pipeline.");
75         }
76     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
77     @Deprecated
78     public final boolean isHandlingOversizedMessage() {
79         return handlingOversizedMessage;
80     }
81     pro</b></font>tected final ChannelHandlerContext ctx() {
82         if (ctx == null) {
83             throw new IllegalStateException("not added to a pipeline yet");
84         }
85         return ctx;
86     }
87     @Override
88     protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception {
89         assert aggregating;
90         if (isStartMessage(msg)) {
91             handlingOversizedMessage = false;
92             if (currentMessage != null) {
93                 currentMessage.release();
94                 currentMessage = null;
95                 throw new MessageAggregationException();
96             }
97             @SuppressWarnings("unchecked")
98             S m = (S) msg;
99             Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());
100             if (continueResponse != null) {
101                 ChannelFutureListener listener = continueResponseWriteListener;
102                 if (listener == null) {
103                     continueResponseWriteListener = listener = new ChannelFutureListener() {
104                         @Override
105                         public void operationComplete(ChannelFuture future) throws Exception {
106                             if (!future.isSuccess()) {
107                                 ctx.fireExceptionCaught(future.cause());
108                             }
109                         }
110                     };
111                 }
112                 boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);
113                 handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);
114                 final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);
115                 if (closeAfterWrite) {
116                     future.addListener(ChannelFutureListener.CLOSE);
117                     return;
118                 }
119                 if (handlingOversizedMessage) {
120                     return;
121                 }
122             } else if (isContentLengthInvalid(m, maxContentLength)) {
123                 invokeHandleOversizedMessage(ctx, m);
124                 return;
125             }
126             if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) {
127                 O aggregated;
128                 if (m instanceof ByteBufHolder) {
129                     aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());
130                 } else {
131                     aggregated = beginAggregation(m, EMPTY_BUFFER);
132                 }
133                 finishAggregation0(aggregated);
134                 out.add(aggregated);
135                 return;
136             }
137             CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);
138             if (m instanceof ByteBufHolder) {
139                 appendPartialContent(content, ((ByteBufHolder) m).content());
140             }
141             currentMessage = beginAggregation(m, content);
142         } else if (isContentMessage(msg)) {
143             if (currentMessage == null) {
144                 return;
145             }
146             CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();
147             @SuppressWarnings("unchecked")
148             final C m = (C) msg;
149             if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) {
150                 @SuppressWarnings("unchecked")
151                 S s = (S) currentMessage;
152                 invokeHandleOversizedMessage(ctx, s);
153                 return;
154             }
155             appendPartialContent(content, m.content());
156             aggregate(currentMessage, m);
157             final boolean last;
158             if (m instanceof DecoderResultProvider) {
159                 DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();
160                 if (!decoderResult.isSuccess()) {
161                     if (currentMessage instanceof DecoderResultProvider) {
162                         ((DecoderResultProvider) currentMessage).setDecoderResult(
163                                 DecoderResult.failure(decoderResult.cause()));
164                     }
165                     last = true;
166                 } else {
167                     last = isLastContentMessage(m);
168                 }
169             } else {
170                 last = isLastContentMessage(m);
171             }
172             if (last) {
173                 finishAggregation0(currentMessage);
174                 out.add(currentMessage);
175                 currentMessage = null;
176             }
177         } else {
178             throw new MessageAggregationException();
179         }
180     }
181     private static void appendPartialContent(CompositeByteBuf content, ByteBuf partialContent) {
182         if (partialContent.isReadable()) {
183             content.addComponent(true, partialContent.retain());
184         }
185     }
186     protected abstract boolean isContentLengthInvalid(S start, int maxContentLength) throws Exception;
187     protected abstract Object newContinueResponse(S start, int maxContentLength, ChannelPipeline pipeline)
188             throws Exception;
189     protected abstract boolean closeAfterContinueResponse(Object msg) throws Exception;
190     protected abstract boolean ignoreContentAfterContinueResponse(Object msg) throws Exception;
191     protected abstract O beginAggregation(S start, ByteBuf content) throws Exception;
192     protected void aggregate(O aggregated, C content) throws Exception { }
193     private void finishAggregation0(O aggregated) throws Exception {
194         aggregating = false;
195         finishAggregation(aggregated);
196     }
197     protected void finishAggregation(O aggregated) throws Exception { }
198     private void invokeHandleOversizedMessage(ChannelHandlerContext ctx, S oversized) throws Exception {
199         handlingOversizedMessage = true;
200         currentMessage = null;
201         try {
202             handleOversizedMessage(ctx, oversized);
203         } finally {
204             ReferenceCountUtil.release(oversized);
205         }
206     }
207     protected void handleOversizedMessage(ChannelHandlerContext ctx, S oversized) throws Exception {
208         ctx.fireExceptionCaught(
209                 new TooLongFrameException("content length exceeded " + maxContentLength() + " bytes."));
210     }
211     @Override
212     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
213         //
214         if (currentMessage != null &amp;&amp; !ctx.channel().config().isAutoRead()) {
215             ctx.read();
216         }
217         ctx.fireChannelReadComplete();
218     }
219     @Override
220     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
221         try {
222             super.channelInactive(ctx);
223         } finally {
224             releaseCurrentMessage();
225         }
226     }
227     @Override
228     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
229         this.ctx = ctx;
230     }
231     @Override
232     public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
233         try {
234             super.handlerRemoved(ctx);
235         } finally {
236             releaseCurrentMessage();
237         }
238     }
239     private void releaseCurrentMessage() {
240         if (currentMessage != null) {
241             currentMessage.release();
242             currentMessage = null;
243             handlingOversizedMessage = false;
244             aggregating = false;
245         }
246     }
247 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
