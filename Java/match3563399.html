<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AbstractAzureComputeServiceTestCase.java &amp; QueryTester.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractAzureComputeServiceTestCase.java &amp; QueryTester.java
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractAzureComputeServiceTestCase.java (21.276596%)<th>QueryTester.java (3.3112583%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(36-36)<td><a href="#" name="0">(196-203)</a><td align="center"><font color="#ff0000">10</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractAzureComputeServiceTestCase.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19  * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 package io.crate.azure;
22 import io.crate.azure.management.AzureComputeService.Discovery;
23 import io.crate.azure.management.AzureComputeService.Management;
24 import org.elasticsearch.common.settings.Settings;
25 import org.elasticsearch.discovery.DiscoveryModule;
26 import org.elasticsearch.test.ESIntegTestCase;
27 import org.hamcrest.Matchers;
28 public abstract class AbstractAzureComputeServiceTestCase extends ESIntegTestCase {
29 <a name="0"></a>
30     @Override
31     protected Settings nodeSettings(int nodeOrdinal) {
32         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Settings.Builder builder = Settings.builder</b></font>()
33             .put(super.nodeSettings(nodeOrdinal))
34             .put(DiscoveryModule.DISCOVERY_SEED_PROVIDERS_SETTING.getKey(), "azure")
35             .put(Management.SUBSCRIPTION_ID.getKey(), "fake")
36             .put(Discovery.REFRESH.getKey(), "5s")
37             .put(Management.APP_ID.getKey(), "dummy")
38             .put(Management.TENANT_ID.getKey(), "dummy")
39             .put(Management.APP_SECRET.getKey(), "dummy")
40             .put(Management.RESOURCE_GROUP_NAME.getKey(), "dummy");
41         return builder.build();
42     }
43     void checkNumberOfNodes(int expected) {
44         assertThat(internalCluster().clusterService().state().nodes().getSize(), Matchers.is(expected));
45     }
46 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>QueryTester.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19  * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 package io.crate.testing;
22 import io.crate.analyze.relations.DocTableRelation;
23 import io.crate.data.BatchIterators;
24 import io.crate.data.Input;
25 import io.crate.execution.dml.upsert.InsertSourceGen;
26 import io.crate.execution.engine.collect.collectors.LuceneBatchIterator;
27 import io.crate.expression.InputFactory;
28 import io.crate.expression.reference.doc.lucene.CollectorContext;
29 import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;
30 import io.crate.expression.symbol.FunctionCopyVisitor;
31 import io.crate.expression.symbol.Literal;
32 import io.crate.expression.symbol.ParameterSymbol;
33 import io.crate.expression.symbol.Symbol;
34 import io.crate.lucene.LuceneQueryBuilder;
35 import io.crate.metadata.ColumnIdent;
36 import io.crate.metadata.CoordinatorTxnCtx;
37 import io.crate.metadata.Schemas;
38 import io.crate.metadata.doc.DocSchemaInfo;
39 import io.crate.metadata.doc.DocTableInfo;
40 import io.crate.metadata.table.SchemaInfo;
41 import io.crate.planner.PlannerContext;
42 import io.crate.planner.optimizer.symbol.Optimizer;
43 import org.apache.lucene.index.DirectoryReader;
44 import org.apache.lucene.search.IndexSearcher;
45 import org.apache.lucene.search.Query;
46 import org.elasticsearch.Version;
47 import org.elasticsearch.cluster.service.ClusterService;
48 import org.elasticsearch.common.UUIDs;
49 import org.elasticsearch.common.bytes.BytesReference;
50 import org.elasticsearch.common.inject.AbstractModule;
51 import org.elasticsearch.common.xcontent.XContentType;
52 import org.elasticsearch.index.mapper.DocumentMapper;
53 import org.elasticsearch.index.mapper.ParsedDocument;
54 import org.elasticsearch.index.mapper.SourceToParse;
55 import org.elasticsearch.threadpool.ThreadPool;
56 import java.io.IOException;
57 import java.nio.file.Path;
58 import java.util.Collections;
59 import java.util.List;
60 import java.util.concurrent.TimeUnit;
61 import java.util.function.BiFunction;
62 import java.util.function.Function;
63 import java.util.stream.Collectors;
64 import static java.util.Objects.requireNonNull;
65 public final class QueryTester implements AutoCloseable {
66     private final BiFunction&lt;ColumnIdent, Query, LuceneBatchIterator&gt; getIterator;
67     private final BiFunction&lt;String, Object[], Symbol&gt; expressionToSymbol;
68     private final Function&lt;Symbol, Query&gt; symbolToQuery;
69     private final IndexEnv indexEnv;
70     public static class Builder {
71         private final DocTableInfo table;
72         private final SQLExecutor sqlExecutor;
73         private final SqlExpressions expressions;
74         private final PlannerContext plannerContext;
75         private final DocTableRelation docTableRelation;
76         private final IndexEnv indexEnv;
77         private final LuceneQueryBuilder queryBuilder;
78         public Builder(Path tempDir,
79                        ThreadPool threadPool,
80                        ClusterService clusterService,
81                        Version indexVersion,
82                        String createTableStmt,
83                        AbstractModule... additionalModules) throws IOException {
84             sqlExecutor = SQLExecutor
85                 .builder(clusterService, additionalModules)
86                 .addTable(createTableStmt)
87                 .build();
88             plannerContext = sqlExecutor.getPlannerContext(clusterService.state());
89             DocSchemaInfo docSchema = findDocSchema(sqlExecutor.schemas());
90             table = (DocTableInfo) docSchema.getTables().iterator().next();
91             indexEnv = new IndexEnv(
92                 threadPool,
93                 table,
94                 clusterService.state(),
95                 indexVersion,
96                 tempDir
97             );
98             queryBuilder = new LuceneQueryBuilder(plannerContext.nodeContext());
99             docTableRelation = new DocTableRelation(table);
100             expressions = new SqlExpressions(
101                 Collections.singletonMap(table.ident(), docTableRelation),
102                 docTableRelation
103             );
104         }
105         private DocSchemaInfo findDocSchema(Schemas schemas) {
106             for (SchemaInfo schema : schemas) {
107                 if (schema instanceof DocSchemaInfo) {
108                     return (DocSchemaInfo) schema;
109                 }
110             }
111             throw new IllegalArgumentException("Create table statement must result in the creation of a user table");
112         }
113         public Builder indexValues(String column, Object ... values) throws IOException {
114             for (Object value : values) {
115                 indexValue(column, value);
116             }
117             return this;
118         }
119         void indexValue(String column, Object value) throws IOException {
120             DocumentMapper mapper = indexEnv.mapperService().documentMapper();
121             InsertSourceGen sourceGen = InsertSourceGen.of(
122                 CoordinatorTxnCtx.systemTransactionContext(),
123                 plannerContext.nodeContext(),
124                 table,
125                 table.concreteIndices()[0],
126                 false,
127                 Collections.singletonList(table.getReference(ColumnIdent.fromPath(column)))
128             );
129             BytesReference source = sourceGen.generateSourceAndCheckConstraintsAsBytesReference(new Object[]{value});
130             SourceToParse sourceToParse = new SourceToParse(
131                 table.concreteIndices()[0],
132                 UUIDs.randomBase64UUID(),
133                 source,
134                 XContentType.JSON
135             );
136             ParsedDocument parsedDocument = mapper.parse(sourceToParse);
137             indexEnv.writer().addDocuments(parsedDocument.docs());
138         }
139         private LuceneBatchIterator getIterator(ColumnIdent column, Query query) {
140             InputFactory inputFactory = new InputFactory(plannerContext.nodeContext());
141             InputFactory.Context&lt;LuceneCollectorExpression&lt;?&gt;&gt; ctx = inputFactory.ctxForRefs(
142                 CoordinatorTxnCtx.systemTransactionContext(), indexEnv.luceneReferenceResolver());
143             Input&lt;?&gt; input = ctx.add(requireNonNull(table.getReference(column),
144                 "column must exist in created table: " + column));
145             IndexSearcher indexSearcher;
146             try {
147                 indexSearcher = new IndexSearcher(DirectoryReader.open(indexEnv.writer()));
148             } catch (IOException e) {
149                 throw new RuntimeException(e);
150             }
151             return new LuceneBatchIterator(
152                 indexSearcher,
153                 query,
154                 null,
155                 false,
156                 new CollectorContext(),
157                 Collections.singletonList(input),
158                 ctx.expressions()
159             );
160         }
161         public QueryTester build() throws IOException {
162             indexEnv.writer().commit();
163             CoordinatorTxnCtx systemTxnCtx = CoordinatorTxnCtx.systemTransactionContext();
164             return new QueryTester(
165                 this::getIterator,
166                 (expr, params) -&gt; {
167                     Symbol symbol = expressions.asSymbol(expr);
168                     Symbol boundSymbol = symbol.accept(new FunctionCopyVisitor&lt;&gt;() {
169                         @Override
170                         public Symbol visitParameterSymbol(ParameterSymbol parameterSymbol, Object context) {
171                             Object param = params[parameterSymbol.index()];
172                             return Literal.ofUnchecked(
173                                 parameterSymbol.valueType(),
174                                 parameterSymbol.valueType().sanitizeValue(param)
175                             );
176                         }
177 <a name="0"></a>                    }, null);
178                     return Optimizer.optimizeCasts(expressions.normalize(boundSymbol), plannerContext);
179                 },
180                 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>symbol -&gt; queryBuilder.convert(
181                     Optimizer.optimizeCasts(symbol,plannerContext),
182                     systemTxnCtx,
183                     indexEnv.mapperService(),
184                     indexEnv.indexService().index().getName(),
185                     indexEnv.queryShardContext(),
186                     table,
187                     indexEnv.indexCache</b></font>()
188                 ).query(),
189                 indexEnv
190             );
191         }
192     }
193     private QueryTester(BiFunction&lt;ColumnIdent, Query, LuceneBatchIterator&gt; getIterator,
194                         BiFunction&lt;String, Object[], Symbol&gt; expressionToSymbol,
195                         Function&lt;Symbol, Query&gt; symbolToQuery,
196                         IndexEnv indexEnv) {
197         this.getIterator = getIterator;
198         this.expressionToSymbol = expressionToSymbol;
199         this.symbolToQuery = symbolToQuery;
200         this.indexEnv = indexEnv;
201     }
202     public IndexSearcher searcher() throws IOException {
203         return new IndexSearcher(DirectoryReader.open(indexEnv.writer()));
204     }
205     public Query toQuery(String expression, Object ... params) {
206         return symbolToQuery.apply(expressionToSymbol.apply(expression, params));
207     }
208     public Query toQuery(Symbol expression) {
209         return symbolToQuery.apply(expression);
210     }
211     public List&lt;Object&gt; runQuery(String resultColumn, String expression, Object ... params) throws Exception {
212         Query query = toQuery(expression, params);
213         LuceneBatchIterator batchIterator = getIterator.apply(ColumnIdent.fromPath(resultColumn), query);
214         return BatchIterators.collect(
215             batchIterator,
216             Collectors.mapping(row -&gt; row.get(0), Collectors.toList())
217         ).get(5, TimeUnit.SECONDS);
218     }
219     @Override
220     public void close() throws Exception {
221         indexEnv.close();
222     }
223 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
