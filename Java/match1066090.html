<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for AbstractDirectedNetworkConnections_1.java &amp; Iterators.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractDirectedNetworkConnections_1.java &amp; Iterators.java
      </h3>
<h1 align="center">
        6.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractDirectedNetworkConnections_1.java (33.908047%)<th>Iterators.java (3.82372%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-43)<td><a href="#" name="0">(37-70)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(132-141)<td><a href="#" name="1">(925-940)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(60-65)<td><a href="#" name="2">(405-419)</a><td align="center"><font color="#a50000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(72-77)<td><a href="#" name="3">(536-553)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(99-107)<td><a href="#" name="4">(451-465)</a><td align="center"><font color="#870000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractDirectedNetworkConnections_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2016 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<a name="0"></a>
package com.google.common.graph;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.graph.Graphs.checkNonNegative;
import static com.google.common.graph.Graphs.checkPositive;
import static java.util.Objects.requireNonNull;

import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.Sets;
import com.google.common.collect.UnmodifiableIterator;
import com.google.common.math.IntMath;
import java.util.AbstractSet;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import javax.annotation.CheckForNull;

/**
 * A base implementation of {@link NetworkConnections} for directed networks.
 *
 * @author James Sexton
 * @param &lt;N&gt; Node parameter type
 * @param &lt;E&gt; Edge parameter type
 */
@</b></font>ElementTypesAreNonnullByDefault
abstract class AbstractDirectedNetworkConnections&lt;N, E&gt; implements NetworkConnections&lt;N, E&gt; {
  /** Keys are edges incoming to the origin node, values are the source node. */
  final Map&lt;E, N&gt; inEdgeMap;

  /** Keys are edges outgoing from the origin node, values are the target node. */
  final Map&lt;E, N&gt; outEdgeMap;

  private int selfLoopCount;

  AbstractDirectedNetworkConnections(Map&lt;E, N&gt; inEdgeMap, Map&lt;E, N&gt; outEdgeMap, int selfLoopCount) {
    this.inEdgeMap = checkNotNull(inEdgeMap);
    this.outEdgeMap = checkNotNull(outEdgeMap);
    this.selfLoopCount = checkNonNegative(selfLoopCount);
<a name="2"></a>    checkState(selfLoopCount &lt;= inEdgeMap.size() &amp;&amp; selfLoopCount &lt;= outEdgeMap.size());
  }

  <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
  public Set&lt;N&gt; adjacentNodes() {
    return Sets.union(predecessors(), successors());
  }

  @</b></font>Override
  public Set&lt;E&gt; incidentEdges() {
    return new AbstractSet&lt;E&gt;() {
      @Override
<a name="3"></a>      public UnmodifiableIterator&lt;E&gt; iterator() {
        Iterable&lt;E&gt; incidentEdges =
            (selfLoopCount == 0)
                ? Iterables.concat(inEdgeMap.keySet(), <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>outEdgeMap.keySet())
                : Sets.union(inEdgeMap.keySet(), outEdgeMap.keySet());
        return Iterators.unmodifiableIterator(incidentEdges.iterator());
      }

      @Ove</b></font>rride
      public int size() {
        return IntMath.saturatedAdd(inEdgeMap.size(), outEdgeMap.size() - selfLoopCount);
      }

      @Override
      public boolean contains(@CheckForNull Object obj) {
        return inEdgeMap.containsKey(obj) || outEdgeMap.containsKey(obj);
      }
    };
  }

  @Override
  public Set&lt;E&gt; inEdges() {
    return Collections.unmodifiableSet(inEdgeMap.keySet());
  }

  @Override
  public Set&lt;E&gt; outEdges() {
<a name="4"></a>    return Collections.unmodifiableSet(outEdgeMap.keySet());
  }

  <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
  public N adjacentNode(E edge) {
    // Since the reference node is defined to be 'source' for directed graphs,
    // we can assume this edge lives in the set of outgoing edges.
    // (We're relying on callers to call this method only with an edge that's in the graph.)
    return requireNonNull(outEdgeMap.get(edge));
  }

  @Override</b></font>
  public N removeInEdge(E edge, boolean isSelfLoop) {
    if (isSelfLoop) {
      checkNonNegative(--selfLoopCount);
    }
    N previousNode = inEdgeMap.remove(edge);
    // We're relying on callers to call this method only with an edge that's in the graph.
    return requireNonNull(previousNode);
  }

  @Override
  public N removeOutEdge(E edge) {
    N previousNode = outEdgeMap.remove(edge);
    // We're relying on callers to call this method only with an edge that's in the graph.
    return requireNonNull(previousNode);
  }

  @Override
  public void addInEdge(E edge, N node, boolean isSelfLoop) {
    checkNotNull(edge);
    checkNotNull(node);

<a name="1"></a>    if (isSelfLoop) {
      checkPositive(++selfLoopCount);
    }
    N previousNode = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inEdgeMap.put(edge, node);
    checkState(previousNode == null);
  }

  @Override
  public void addOutEdge(E edge, N node) {
    checkNotNull(edge);
    checkNotNull(node);

    N previousNode = outEdgeMap.put(edge, node)</b></font>;
    checkState(previousNode == null);
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Iterators.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.base.Predicates.instanceOf;
import static com.google.common.collect.CollectPreconditions.checkRemove;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
<a name="0"></a>import com.google.common.base.Predicate;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * This class contains static utility methods that operate on or return objects of type {@link
 * Iterator}. Except as noted, each method has a corresponding {@link Iterable}-based method in the
 * {@link Iterables} class.
 *
 * &lt;p&gt;&lt;i&gt;Performance notes:&lt;/i&gt; Unless otherwise noted, all of the iterators produced in this class
 * are &lt;i&gt;lazy&lt;/i&gt;, which means that they only advance the backing iteration when absolutely
 * necessary.
 *
 * &lt;p&gt;See the Guava User Guide section on &lt;a href=
 * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables"&gt;{@code
 * Iterators}&lt;/a&gt;.
 *
 * @author Kevin Bourrillion
 * @author Jared Levy
 * @since 2.0
 */
@</b></font>GwtCompatible(emulated = true)
@ElementTypesAreNonnullByDefault
public final class Iterators {
  private Iterators() {}

  /**
   * Returns the empty iterator.
   *
   * &lt;p&gt;The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.
   */
  static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; emptyIterator() {
    return emptyListIterator();
  }

  /**
   * Returns the empty iterator.
   *
   * &lt;p&gt;The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.
   */
  // Casting to any type is safe since there are no actual elements.
  @SuppressWarnings("unchecked")
  static &lt;T extends @Nullable Object&gt; UnmodifiableListIterator&lt;T&gt; emptyListIterator() {
    return (UnmodifiableListIterator&lt;T&gt;) ArrayItr.EMPTY;
  }

  /**
   * This is an enum singleton rather than an anonymous class so ProGuard can figure out it's only
   * referenced by emptyModifiableIterator().
   */
  private enum EmptyModifiableIterator implements Iterator&lt;Object&gt; {
    INSTANCE;

    @Override
    public boolean hasNext() {
      return false;
    }

    @Override
    public Object next() {
      throw new NoSuchElementException();
    }

    @Override
    public void remove() {
      checkRemove(false);
    }
  }

  /**
   * Returns the empty {@code Iterator} that throws {@link IllegalStateException} instead of {@link
   * UnsupportedOperationException} on a call to {@link Iterator#remove()}.
   */
  // Casting to any type is safe since there are no actual elements.
  @SuppressWarnings("unchecked")
  static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; emptyModifiableIterator() {
    return (Iterator&lt;T&gt;) EmptyModifiableIterator.INSTANCE;
  }

  /** Returns an unmodifiable view of {@code iterator}. */
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; unmodifiableIterator(
      Iterator&lt;? extends T&gt; iterator) {
    checkNotNull(iterator);
    if (iterator instanceof UnmodifiableIterator) {
      @SuppressWarnings("unchecked") // Since it's unmodifiable, the covariant cast is safe
      UnmodifiableIterator&lt;T&gt; result = (UnmodifiableIterator&lt;T&gt;) iterator;
      return result;
    }
    return new UnmodifiableIterator&lt;T&gt;() {
      @Override
      public boolean hasNext() {
        return iterator.hasNext();
      }

      @Override
      @ParametricNullness
      public T next() {
        return iterator.next();
      }
    };
  }

  /**
   * Simply returns its argument.
   *
   * @deprecated no need to use this
   * @since 10.0
   */
  @Deprecated
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; unmodifiableIterator(
      UnmodifiableIterator&lt;T&gt; iterator) {
    return checkNotNull(iterator);
  }

  /**
   * Returns the number of elements remaining in {@code iterator}. The iterator will be left
   * exhausted: its {@code hasNext()} method will return {@code false}.
   */
  public static int size(Iterator&lt;?&gt; iterator) {
    long count = 0L;
    while (iterator.hasNext()) {
      iterator.next();
      count++;
    }
    return Ints.saturatedCast(count);
  }

  /** Returns {@code true} if {@code iterator} contains {@code element}. */
  public static boolean contains(Iterator&lt;?&gt; iterator, @CheckForNull Object element) {
    if (element == null) {
      while (iterator.hasNext()) {
        if (iterator.next() == null) {
          return true;
        }
      }
    } else {
      while (iterator.hasNext()) {
        if (element.equals(iterator.next())) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Traverses an iterator and removes every element that belongs to the provided collection. The
   * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.
   *
   * @param removeFrom the iterator to (potentially) remove elements from
   * @param elementsToRemove the elements to remove
   * @return {@code true} if any element was removed from {@code iterator}
   */
  @CanIgnoreReturnValue
  public static boolean removeAll(Iterator&lt;?&gt; removeFrom, Collection&lt;?&gt; elementsToRemove) {
    checkNotNull(elementsToRemove);
    boolean result = false;
    while (removeFrom.hasNext()) {
      if (elementsToRemove.contains(removeFrom.next())) {
        removeFrom.remove();
        result = true;
      }
    }
    return result;
  }

  /**
   * Removes every element that satisfies the provided predicate from the iterator. The iterator
   * will be left exhausted: its {@code hasNext()} method will return {@code false}.
   *
   * @param removeFrom the iterator to (potentially) remove elements from
   * @param predicate a predicate that determines whether an element should be removed
   * @return {@code true} if any elements were removed from the iterator
   * @since 2.0
   */
  @CanIgnoreReturnValue
  public static &lt;T extends @Nullable Object&gt; boolean removeIf(
      Iterator&lt;T&gt; removeFrom, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(predicate);
    boolean modified = false;
    while (removeFrom.hasNext()) {
      if (predicate.apply(removeFrom.next())) {
        removeFrom.remove();
        modified = true;
      }
    }
    return modified;
  }

  /**
   * Traverses an iterator and removes every element that does not belong to the provided
   * collection. The iterator will be left exhausted: its {@code hasNext()} method will return
   * {@code false}.
   *
   * @param removeFrom the iterator to (potentially) remove elements from
   * @param elementsToRetain the elements to retain
   * @return {@code true} if any element was removed from {@code iterator}
   */
  @CanIgnoreReturnValue
  public static boolean retainAll(Iterator&lt;?&gt; removeFrom, Collection&lt;?&gt; elementsToRetain) {
    checkNotNull(elementsToRetain);
    boolean result = false;
    while (removeFrom.hasNext()) {
      if (!elementsToRetain.contains(removeFrom.next())) {
        removeFrom.remove();
        result = true;
      }
    }
    return result;
  }

  /**
   * Determines whether two iterators contain equal elements in the same order. More specifically,
   * this method returns {@code true} if {@code iterator1} and {@code iterator2} contain the same
   * number of elements and every element of {@code iterator1} is equal to the corresponding element
   * of {@code iterator2}.
   *
   * &lt;p&gt;Note that this will modify the supplied iterators, since they will have been advanced some
   * number of elements forward.
   */
  public static boolean elementsEqual(Iterator&lt;?&gt; iterator1, Iterator&lt;?&gt; iterator2) {
    while (iterator1.hasNext()) {
      if (!iterator2.hasNext()) {
        return false;
      }
      Object o1 = iterator1.next();
      Object o2 = iterator2.next();
      if (!Objects.equal(o1, o2)) {
        return false;
      }
    }
    return !iterator2.hasNext();
  }

  /**
   * Returns a string representation of {@code iterator}, with the format {@code [e1, e2, ..., en]}.
   * The iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.
   */
  public static String toString(Iterator&lt;?&gt; iterator) {
    StringBuilder sb = new StringBuilder().append('[');
    boolean first = true;
    while (iterator.hasNext()) {
      if (!first) {
        sb.append(", ");
      }
      first = false;
      sb.append(iterator.next());
    }
    return sb.append(']').toString();
  }

  /**
   * Returns the single element contained in {@code iterator}.
   *
   * @throws NoSuchElementException if the iterator is empty
   * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the
   *     iterator is unspecified.
   */
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getOnlyElement(Iterator&lt;T&gt; iterator) {
    T first = iterator.next();
    if (!iterator.hasNext()) {
      return first;
    }

    StringBuilder sb = new StringBuilder().append("expected one element but was: &lt;").append(first);
    for (int i = 0; i &lt; 4 &amp;&amp; iterator.hasNext(); i++) {
      sb.append(", ").append(iterator.next());
    }
    if (iterator.hasNext()) {
      sb.append(", ...");
    }
    sb.append('&gt;');

    throw new IllegalArgumentException(sb.toString());
  }

  /**
   * Returns the single element contained in {@code iterator}, or {@code defaultValue} if the
   * iterator is empty.
   *
   * @throws IllegalArgumentException if the iterator contains multiple elements. The state of the
   *     iterator is unspecified.
   */
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getOnlyElement(
      Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
    return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;
  }

  /**
   * Copies an iterator's elements into an array. The iterator will be left exhausted: its {@code
   * hasNext()} method will return {@code false}.
   *
   * @param iterator the iterator to copy
   * @param type the type of the elements
   * @return a newly-allocated array into which all the elements of the iterator have been copied
   */
  @GwtIncompatible // Array.newInstance(Class, int)
  // For discussion of this signature, see the corresponding overload of *Iterables*.toArray.
  public static &lt;T&gt; @Nullable T[] toArray(Iterator&lt;? extends @Nullable T&gt; iterator, Class&lt;T&gt; type) {
    List&lt;@Nullable T&gt; list = Lists.newArrayList(iterator);
    return Iterables.toArray(list, type);
  }

  /**
   * Adds all elements in {@code iterator} to {@code collection}. The iterator will be left
   * exhausted: its {@code hasNext()} method will return {@code false}.
   *
   * @return {@code true} if {@code collection} was modified as a result of this operation
   */
  @CanIgnoreReturnValue
  public static &lt;T extends @Nullable Object&gt; boolean addAll(
      Collection&lt;T&gt; addTo, Iterator&lt;? extends T&gt; iterator) {
    checkNotNull(addTo);
    checkNotNull(iterator);
    boolean wasModified = false;
    while (iterator.hasNext()) {
      wasModified |= addTo.add(iterator.next());
    }
    return wasModified;
  }

  /**
   * Returns the number of elements in the specified iterator that equal the specified object. The
   * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.
   *
   * @see Collections#frequency
   */
  public static int frequency(Iterator&lt;?&gt; iterator, @CheckForNull Object element) {
    int count = 0;
    while (contains(iterator, element)) {
      // Since it lives in the same class, we know contains gets to the element and then stops,
      // though that isn't currently publicly documented.
      count++;
    }
    return count;
  }

  /**
   * Returns an iterator that cycles indefinitely over the elements of {@code iterable}.
   *
   * &lt;p&gt;The returned iterator supports {@code remove()} if the provided iterator does. After {@code
   * remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code
   * iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}
   * is empty.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Typical uses of the resulting iterator may produce an infinite loop. You
   * should use an explicit {@code break} or be certain that you will eventually remove all the
   * elements.
   */
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; cycle(Iterable&lt;T&gt; iterable) {
    checkNotNull(iterable);
<a name="2"></a>    return new Iterator&lt;T&gt;() {
      Iterator&lt;T&gt; iterator = emptyModifiableIterator();

      <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
      public boolean hasNext() {
        /*
         * Don't store a new Iterator until we know the user can't remove() the last returned
         * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating
         * the new one. The result is a ConcurrentModificationException or other bad behavior.
         *
         * (If we decide that we really, really hate allocating two Iterators per cycle instead of
         * one, we can optimistically store the new Iterator and then be willing to throw it out if
         * the user calls remove().)
         */
        return iterator.hasNext() || iterable.iterator().hasNext();
      }

      @</b></font>Override
      @ParametricNullness
      public T next() {
        if (!iterator.hasNext()) {
          iterator = iterable.iterator();
          if (!iterator.hasNext()) {
            throw new NoSuchElementException();
          }
        }
        return iterator.next();
      }

      @Override
      public void remove() {
        iterator.remove();
      }
    };
  }

  /**
   * Returns an iterator that cycles indefinitely over the provided elements.
   *
   * &lt;p&gt;The returned iterator supports {@code remove()}. After {@code remove()} is called,
   * subsequent cycles omit the removed element, but {@code elements} does not change. The
   * iterator's {@code hasNext()} method returns {@code true} until all of the original elements
   * have been removed.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Typical uses of the resulting iterator may produce an infinite loop. You
   * should use an explicit {@code break} or be certain that you will eventually remove all the
<a name="4"></a>   * elements.
   */
  @SafeVarargs
  public static &lt;T extends <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Nullable Object&gt; Iterator&lt;T&gt; cycle(T... elements) {
    return cycle(Lists.newArrayList(elements));
  }

  /**
   * Returns an Iterator that walks the specified array, nulling out elements behind it. This can
   * avoid memory leaks when an element is no longer necessary.
   *
   * &lt;p&gt;This method accepts an array with element type {@code @Nullable T}, but callers must pass an
   * array whose contents are initially non-null. The {@code @Nullable} annotation indicates that
   * this method will write nulls into the array during iteration.
   *
   * &lt;p&gt;This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.
   */
  private static &lt;I</b></font> extends Iterator&lt;?&gt;&gt; Iterator&lt;I&gt; consumingForArray(@Nullable I... elements) {
    return new UnmodifiableIterator&lt;I&gt;() {
      int index = 0;

      @Override
      public boolean hasNext() {
        return index &lt; elements.length;
      }

      @Override
      public I next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        /*
         * requireNonNull is safe because our callers always pass non-null arguments. Each element
         * of the array becomes null only when we iterate past it and then clear it.
         */
        I result = requireNonNull(elements[index]);
        elements[index] = null;
        index++;
        return result;
      }
    };
  }

  /**
   * Combines two iterators into a single iterator. The returned iterator iterates across the
   * elements in {@code a}, followed by the elements in {@code b}. The source iterators are not
   * polled until necessary.
   *
   * &lt;p&gt;The returned iterator supports {@code remove()} when the corresponding input iterator
   * supports it.
   */
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
      Iterator&lt;? extends T&gt; a, Iterator&lt;? extends T&gt; b) {
    checkNotNull(a);
    checkNotNull(b);
    return concat(consumingForArray(a, b));
  }

  /**
   * Combines three iterators into a single iterator. The returned iterator iterates across the
   * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in
   * {@code c}. The source iterators are not polled until necessary.
   *
   * &lt;p&gt;The returned iterator supports {@code remove()} when the corresponding input iterator
   * supports it.
   */
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
      Iterator&lt;? extends T&gt; a, Iterator&lt;? extends T&gt; b, Iterator&lt;? extends T&gt; c) {
    checkNotNull(a);
    checkNotNull(b);
    checkNotNull(c);
    return concat(consumingForArray(a, b, c));
  }

  /**
   * Combines four iterators into a single iterator. The returned iterator iterates across the
   * elements in {@code a}, followed by the elements in {@code b}, followed by the elements in
   * {@code c}, followed by the elements in {@code d}. The source iterators are not polled until
   * necessary.
   *
   * &lt;p&gt;The returned iterator supports {@code remove()} when the corresponding input iterator
   * supports it.
   */
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
      Iterator&lt;? extends T&gt; a,
<a name="3"></a>      Iterator&lt;? extends T&gt; b,
      Iterator&lt;? extends T&gt; c,
      Iterator&lt;? extends T&gt; d) {
    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>checkNotNull(a);
    checkNotNull(b);
    checkNotNull(c);
    checkNotNull(d);
    return concat(consumingForArray(a, b, c, d));
  }

  /**
   * Combines multiple iterators into a single iterator. The returned iterator iterates across the
   * elements of each iterator in {@code inputs}. The input iterators are not polled until
   * necessary.
   *
   * &lt;p&gt;The returned iterator supports {@code remove()} when the corresponding input iterator
   * supports it.
   *
   * @throws NullPointerException if any of the provided iterators is null
   */
  public</b></font> static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(Iterator&lt;? extends T&gt;... inputs) {
    return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));
  }

  /**
   * Combines multiple iterators into a single iterator. The returned iterator iterates across the
   * elements of each iterator in {@code inputs}. The input iterators are not polled until
   * necessary.
   *
   * &lt;p&gt;The returned iterator supports {@code remove()} when the corresponding input iterator
   * supports it. The methods of the returned iterator may throw {@code NullPointerException} if any
   * of the input iterators is null.
   */
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concat(
      Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; inputs) {
    return new ConcatenatedIterator&lt;&gt;(inputs);
  }

  /** Concats a varargs array of iterators without making a defensive copy of the array. */
  static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; concatNoDefensiveCopy(
      Iterator&lt;? extends T&gt;... inputs) {
    for (Iterator&lt;? extends T&gt; input : checkNotNull(inputs)) {
      checkNotNull(input);
    }
    return concat(consumingForArray(inputs));
  }

  /**
   * Divides an iterator into unmodifiable sublists of the given size (the final list may be
   * smaller). For example, partitioning an iterator containing {@code [a, b, c, d, e]} with a
   * partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterator containing two
   * inner lists of three and two elements, all in the original order.
   *
   * &lt;p&gt;The returned lists implement {@link java.util.RandomAccess}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The current implementation eagerly allocates storage for {@code size} elements.
   * As a consequence, passing values like {@code Integer.MAX_VALUE} can lead to {@link
   * OutOfMemoryError}.
   *
   * @param iterator the iterator to return a partitioned view of
   * @param size the desired size of each partition (the last may be smaller)
   * @return an iterator of immutable lists containing the elements of {@code iterator} divided into
   *     partitions
   * @throws IllegalArgumentException if {@code size} is nonpositive
   */
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;List&lt;T&gt;&gt; partition(
      Iterator&lt;T&gt; iterator, int size) {
    return partitionImpl(iterator, size, false);
  }

  /**
   * Divides an iterator into unmodifiable sublists of the given size, padding the final iterator
   * with null values if necessary. For example, partitioning an iterator containing {@code [a, b,
   * c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer
   * iterator containing two inner lists of three elements each, all in the original order.
   *
   * &lt;p&gt;The returned lists implement {@link java.util.RandomAccess}.
   *
   * @param iterator the iterator to return a partitioned view of
   * @param size the desired size of each partition
   * @return an iterator of immutable lists containing the elements of {@code iterator} divided into
   *     partitions (the final iterable may have trailing null elements)
   * @throws IllegalArgumentException if {@code size} is nonpositive
   */
  public static &lt;T extends @Nullable Object&gt;
      UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt; paddedPartition(Iterator&lt;T&gt; iterator, int size) {
    return partitionImpl(iterator, size, true);
  }

  private static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt; partitionImpl(
      Iterator&lt;T&gt; iterator, int size, boolean pad) {
    checkNotNull(iterator);
    checkArgument(size &gt; 0);
    return new UnmodifiableIterator&lt;List&lt;@Nullable T&gt;&gt;() {
      @Override
      public boolean hasNext() {
        return iterator.hasNext();
      }

      @Override
      public List&lt;@Nullable T&gt; next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        @SuppressWarnings("unchecked") // we only put Ts in it
        @Nullable
        T[] array = (@Nullable T[]) new Object[size];
        int count = 0;
        for (; count &lt; size &amp;&amp; iterator.hasNext(); count++) {
          array[count] = iterator.next();
        }
        for (int i = count; i &lt; size; i++) {
          array[i] = null; // for GWT
        }

        List&lt;@Nullable T&gt; list = Collections.unmodifiableList(Arrays.asList(array));
        // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.
        if (pad || count == size) {
          return list;
        } else {
          return list.subList(0, count);
        }
      }
    };
  }

  /**
   * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate
   * {@code retainIfTrue}.
   */
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; filter(
      Iterator&lt;T&gt; unfiltered, Predicate&lt;? super T&gt; retainIfTrue) {
    checkNotNull(unfiltered);
    checkNotNull(retainIfTrue);
    return new AbstractIterator&lt;T&gt;() {
      @Override
      @CheckForNull
      protected T computeNext() {
        while (unfiltered.hasNext()) {
          T element = unfiltered.next();
          if (retainIfTrue.apply(element)) {
            return element;
          }
        }
        return endOfData();
      }
    };
  }

  /**
   * Returns a view of {@code unfiltered} containing all elements that are of the type {@code
   * desiredType}.
   */
  @SuppressWarnings("unchecked") // can cast to &lt;T&gt; because non-Ts are removed
  @GwtIncompatible // Class.isInstance
  public static &lt;T&gt; UnmodifiableIterator&lt;T&gt; filter(Iterator&lt;?&gt; unfiltered, Class&lt;T&gt; desiredType) {
    return (UnmodifiableIterator&lt;T&gt;) filter(unfiltered, instanceOf(desiredType));
  }

  /**
   * Returns {@code true} if one or more elements returned by {@code iterator} satisfy the given
   * predicate.
   */
  public static &lt;T extends @Nullable Object&gt; boolean any(
      Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    return indexOf(iterator, predicate) != -1;
  }

  /**
   * Returns {@code true} if every element returned by {@code iterator} satisfies the given
   * predicate. If {@code iterator} is empty, {@code true} is returned.
   */
  public static &lt;T extends @Nullable Object&gt; boolean all(
      Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(predicate);
    while (iterator.hasNext()) {
      T element = iterator.next();
      if (!predicate.apply(element)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Returns the first element in {@code iterator} that satisfies the given predicate; use this
   * method only when such an element is known to exist. If no such element is found, the iterator
   * will be left exhausted: its {@code hasNext()} method will return {@code false}. If it is
   * possible that &lt;i&gt;no&lt;/i&gt; element will match, use {@link #tryFind} or {@link #find(Iterator,
   * Predicate, Object)} instead.
   *
   * @throws NoSuchElementException if no element in {@code iterator} matches the given predicate
   */
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T find(
      Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(iterator);
    checkNotNull(predicate);
    while (iterator.hasNext()) {
      T t = iterator.next();
      if (predicate.apply(t)) {
        return t;
      }
    }
    throw new NoSuchElementException();
  }

  /**
   * Returns the first element in {@code iterator} that satisfies the given predicate. If no such
   * element is found, {@code defaultValue} will be returned from this method and the iterator will
   * be left exhausted: its {@code hasNext()} method will return {@code false}. Note that this can
   * usually be handled more naturally using {@code tryFind(iterator, predicate).or(defaultValue)}.
   *
   * @since 7.0
   */
  // For discussion of this signature, see the corresponding overload of *Iterables*.find.
  @CheckForNull
  public static &lt;T extends @Nullable Object&gt; T find(
      Iterator&lt;? extends T&gt; iterator,
      Predicate&lt;? super T&gt; predicate,
      @CheckForNull T defaultValue) {
    checkNotNull(iterator);
    checkNotNull(predicate);
    while (iterator.hasNext()) {
      T t = iterator.next();
      if (predicate.apply(t)) {
        return t;
      }
    }
    return defaultValue;
  }

  /**
   * Returns an {@link Optional} containing the first element in {@code iterator} that satisfies the
   * given predicate, if such an element exists. If no such element is found, an empty {@link
   * Optional} will be returned from this method and the iterator will be left exhausted: its {@code
   * hasNext()} method will return {@code false}.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; avoid using a {@code predicate} that matches {@code null}. If {@code null}
   * is matched in {@code iterator}, a NullPointerException will be thrown.
   *
   * @since 11.0
   */
  public static &lt;T&gt; Optional&lt;T&gt; tryFind(Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(iterator);
    checkNotNull(predicate);
    while (iterator.hasNext()) {
      T t = iterator.next();
      if (predicate.apply(t)) {
        return Optional.of(t);
      }
    }
    return Optional.absent();
  }

  /**
   * Returns the index in {@code iterator} of the first element that satisfies the provided {@code
   * predicate}, or {@code -1} if the Iterator has no such elements.
   *
   * &lt;p&gt;More formally, returns the lowest index {@code i} such that {@code
   * predicate.apply(Iterators.get(iterator, i))} returns {@code true}, or {@code -1} if there is no
   * such index.
   *
   * &lt;p&gt;If -1 is returned, the iterator will be left exhausted: its {@code hasNext()} method will
   * return {@code false}. Otherwise, the iterator will be set to the element which satisfies the
   * {@code predicate}.
   *
   * @since 2.0
   */
  public static &lt;T extends @Nullable Object&gt; int indexOf(
      Iterator&lt;T&gt; iterator, Predicate&lt;? super T&gt; predicate) {
    checkNotNull(predicate, "predicate");
    for (int i = 0; iterator.hasNext(); i++) {
      T current = iterator.next();
      if (predicate.apply(current)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns a view containing the result of applying {@code function} to each element of {@code
   * fromIterator}.
   *
   * &lt;p&gt;The returned iterator supports {@code remove()} if {@code fromIterator} does. After a
   * successful {@code remove()} call, {@code fromIterator} no longer contains the corresponding
   * element.
   */
  public static &lt;F extends @Nullable Object, T extends @Nullable Object&gt; Iterator&lt;T&gt; transform(
      Iterator&lt;F&gt; fromIterator, Function&lt;? super F, ? extends T&gt; function) {
    checkNotNull(function);
    return new TransformedIterator&lt;F, T&gt;(fromIterator) {
      @ParametricNullness
      @Override
      T transform(@ParametricNullness F from) {
        return function.apply(from);
      }
    };
  }

  /**
   * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code
   * position}th position.
   *
   * @param position position of the element to return
   * @return the element at the specified position in {@code iterator}
   * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to
   *     the number of elements remaining in {@code iterator}
   */
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T get(Iterator&lt;T&gt; iterator, int position) {
    checkNonnegative(position);
    int skipped = advance(iterator, position);
    if (!iterator.hasNext()) {
      throw new IndexOutOfBoundsException(
          "position ("
              + position
              + ") must be less than the number of elements that remained ("
              + skipped
              + ")");
    }
    return iterator.next();
  }

  /**
   * Advances {@code iterator} {@code position + 1} times, returning the element at the {@code
   * position}th position or {@code defaultValue} otherwise.
   *
   * @param position position of the element to return
   * @param defaultValue the default value to return if the iterator is empty or if {@code position}
   *     is greater than the number of elements remaining in {@code iterator}
   * @return the element at the specified position in {@code iterator} or {@code defaultValue} if
   *     {@code iterator} produces fewer than {@code position + 1} elements.
   * @throws IndexOutOfBoundsException if {@code position} is negative
   * @since 4.0
   */
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T get(
      Iterator&lt;? extends T&gt; iterator, int position, @ParametricNullness T defaultValue) {
    checkNonnegative(position);
    advance(iterator, position);
    return getNext(iterator, defaultValue);
  }

  static void checkNonnegative(int position) {
    if (position &lt; 0) {
      throw new IndexOutOfBoundsException("position (" + position + ") must not be negative");
    }
  }

  /**
   * Returns the next element in {@code iterator} or {@code defaultValue} if the iterator is empty.
   * The {@link Iterables} analog to this method is {@link Iterables#getFirst}.
   *
   * @param defaultValue the default value to return if the iterator is empty
   * @return the next element of {@code iterator} or the default value
   * @since 7.0
   */
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getNext(
      Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
    return iterator.hasNext() ? iterator.next() : defaultValue;
  }

  /**
   * Advances {@code iterator} to the end, returning the last element.
   *
   * @return the last element of {@code iterator}
   * @throws NoSuchElementException if the iterator is empty
   */
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getLast(Iterator&lt;T&gt; iterator) {
    while (true) {
      T current = iterator.next();
      if (!iterator.hasNext()) {
        return current;
      }
    }
  }

  /**
   * Advances {@code iterator} to the end, returning the last element or {@code defaultValue} if the
   * iterator is empty.
   *
   * @param defaultValue the default value to return if the iterator is empty
   * @return the last element of {@code iterator}
   * @since 3.0
   */
<a name="1"></a>  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T getLast(
      Iterator&lt;? extends T&gt; iterator, @ParametricNullness T defaultValue) {
    return <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>iterator.hasNext() ? getLast(iterator) : defaultValue;
  }

  /**
   * Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times or until {@code
   * hasNext()} returns {@code false}, whichever comes first.
   *
   * @return the number of elements the iterator was advanced
   * @since 13.0 (since 3.0 as {@code Iterators.skip})
   */
  @CanIgnoreReturnValue
  public static int advance(Iterator&lt;?&gt; iterator, int numberToAdvance) {
    checkNotNull(iterator);
    checkArgument(numberToAdvance &gt;= 0, "numberToAdvance must be nonnegative");

    int i</b></font>;
    for (i = 0; i &lt; numberToAdvance &amp;&amp; iterator.hasNext(); i++) {
      iterator.next();
    }
    return i;
  }

  /**
   * Returns a view containing the first {@code limitSize} elements of {@code iterator}. If {@code
   * iterator} contains fewer than {@code limitSize} elements, the returned view contains all of its
   * elements. The returned iterator supports {@code remove()} if {@code iterator} does.
   *
   * @param iterator the iterator to limit
   * @param limitSize the maximum number of elements in the returned iterator
   * @throws IllegalArgumentException if {@code limitSize} is negative
   * @since 3.0
   */
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; limit(
      Iterator&lt;T&gt; iterator, int limitSize) {
    checkNotNull(iterator);
    checkArgument(limitSize &gt;= 0, "limit is negative");
    return new Iterator&lt;T&gt;() {
      private int count;

      @Override
      public boolean hasNext() {
        return count &lt; limitSize &amp;&amp; iterator.hasNext();
      }

      @Override
      @ParametricNullness
      public T next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        count++;
        return iterator.next();
      }

      @Override
      public void remove() {
        iterator.remove();
      }
    };
  }

  /**
   * Returns a view of the supplied {@code iterator} that removes each element from the supplied
   * {@code iterator} as it is returned.
   *
   * &lt;p&gt;The provided iterator must support {@link Iterator#remove()} or else the returned iterator
   * will fail on the first call to {@code next}.
   *
   * @param iterator the iterator to remove and return elements from
   * @return an iterator that removes and returns elements from the supplied iterator
   * @since 2.0
   */
  public static &lt;T extends @Nullable Object&gt; Iterator&lt;T&gt; consumingIterator(Iterator&lt;T&gt; iterator) {
    checkNotNull(iterator);
    return new UnmodifiableIterator&lt;T&gt;() {
      @Override
      public boolean hasNext() {
        return iterator.hasNext();
      }

      @Override
      @ParametricNullness
      public T next() {
        T next = iterator.next();
        iterator.remove();
        return next;
      }

      @Override
      public String toString() {
        return "Iterators.consumingIterator(...)";
      }
    };
  }

  /**
   * Deletes and returns the next value from the iterator, or returns {@code null} if there is no
   * such value.
   */
  @CheckForNull
  static &lt;T extends @Nullable Object&gt; T pollNext(Iterator&lt;T&gt; iterator) {
    if (iterator.hasNext()) {
      T result = iterator.next();
      iterator.remove();
      return result;
    } else {
      return null;
    }
  }

  // Methods only in Iterators, not in Iterables

  /** Clears the iterator using its remove method. */
  static void clear(Iterator&lt;?&gt; iterator) {
    checkNotNull(iterator);
    while (iterator.hasNext()) {
      iterator.next();
      iterator.remove();
    }
  }

  /**
   * Returns an iterator containing the elements of {@code array} in order. The returned iterator is
   * a view of the array; subsequent changes to the array will be reflected in the iterator.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; It is often preferable to represent your data using a collection type, for
   * example using {@link Arrays#asList(Object[])}, making this method unnecessary.
   *
   * &lt;p&gt;The {@code Iterable} equivalent of this method is either {@link Arrays#asList(Object[])},
   * {@link ImmutableList#copyOf(Object[])}}, or {@link ImmutableList#of}.
   */
  @SafeVarargs
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; forArray(T... array) {
    return forArray(array, 0, array.length, 0);
  }

  /**
   * Returns a list iterator containing the elements in the specified range of {@code array} in
   * order, starting at the specified index.
   *
   * &lt;p&gt;The {@code Iterable} equivalent of this method is {@code
   * Arrays.asList(array).subList(offset, offset + length).listIterator(index)}.
   */
  static &lt;T extends @Nullable Object&gt; UnmodifiableListIterator&lt;T&gt; forArray(
      T[] array, int offset, int length, int index) {
    checkArgument(length &gt;= 0);
    int end = offset + length;

    // Technically we should give a slightly more descriptive error on overflow
    Preconditions.checkPositionIndexes(offset, end, array.length);
    Preconditions.checkPositionIndex(index, length);
    if (length == 0) {
      return emptyListIterator();
    }
    return new ArrayItr&lt;&gt;(array, offset, length, index);
  }

  private static final class ArrayItr&lt;T extends @Nullable Object&gt;
      extends AbstractIndexedListIterator&lt;T&gt; {
    static final UnmodifiableListIterator&lt;Object&gt; EMPTY = new ArrayItr&lt;&gt;(new Object[0], 0, 0, 0);

    private final T[] array;
    private final int offset;

    ArrayItr(T[] array, int offset, int length, int index) {
      super(length, index);
      this.array = array;
      this.offset = offset;
    }

    @Override
    @ParametricNullness
    protected T get(int index) {
      return array[offset + index];
    }
  }

  /**
   * Returns an iterator containing only {@code value}.
   *
   * &lt;p&gt;The {@link Iterable} equivalent of this method is {@link Collections#singleton}.
   */
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; singletonIterator(
      @ParametricNullness T value) {
    return new UnmodifiableIterator&lt;T&gt;() {
      boolean done;

      @Override
      public boolean hasNext() {
        return !done;
      }

      @Override
      @ParametricNullness
      public T next() {
        if (done) {
          throw new NoSuchElementException();
        }
        done = true;
        return value;
      }
    };
  }

  /**
   * Adapts an {@code Enumeration} to the {@code Iterator} interface.
   *
   * &lt;p&gt;This method has no equivalent in {@link Iterables} because viewing an {@code Enumeration} as
   * an {@code Iterable} is impossible. However, the contents can be &lt;i&gt;copied&lt;/i&gt; into a collection
   * using {@link Collections#list}.
   *
   * &lt;p&gt;&lt;b&gt;Java 9 users:&lt;/b&gt; use {@code enumeration.asIterator()} instead, unless it is important to
   * return an {@code UnmodifiableIterator} instead of a plain {@code Iterator}.
   */
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; forEnumeration(
      Enumeration&lt;T&gt; enumeration) {
    checkNotNull(enumeration);
    return new UnmodifiableIterator&lt;T&gt;() {
      @Override
      public boolean hasNext() {
        return enumeration.hasMoreElements();
      }

      @Override
      @ParametricNullness
      public T next() {
        return enumeration.nextElement();
      }
    };
  }

  /**
   * Adapts an {@code Iterator} to the {@code Enumeration} interface.
   *
   * &lt;p&gt;The {@code Iterable} equivalent of this method is either {@link Collections#enumeration} (if
   * you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.
   */
  public static &lt;T extends @Nullable Object&gt; Enumeration&lt;T&gt; asEnumeration(Iterator&lt;T&gt; iterator) {
    checkNotNull(iterator);
    return new Enumeration&lt;T&gt;() {
      @Override
      public boolean hasMoreElements() {
        return iterator.hasNext();
      }

      @Override
      @ParametricNullness
      public T nextElement() {
        return iterator.next();
      }
    };
  }

  /** Implementation of PeekingIterator that avoids peeking unless necessary. */
  private static class PeekingImpl&lt;E extends @Nullable Object&gt; implements PeekingIterator&lt;E&gt; {

    private final Iterator&lt;? extends E&gt; iterator;
    private boolean hasPeeked;
    @CheckForNull private E peekedElement;

    public PeekingImpl(Iterator&lt;? extends E&gt; iterator) {
      this.iterator = checkNotNull(iterator);
    }

    @Override
    public boolean hasNext() {
      return hasPeeked || iterator.hasNext();
    }

    @Override
    @ParametricNullness
    public E next() {
      if (!hasPeeked) {
        return iterator.next();
      }
      // The cast is safe because of the hasPeeked check.
      E result = uncheckedCastNullableTToT(peekedElement);
      hasPeeked = false;
      peekedElement = null;
      return result;
    }

    @Override
    public void remove() {
      checkState(!hasPeeked, "Can't remove after you've peeked at next");
      iterator.remove();
    }

    @Override
    @ParametricNullness
    public E peek() {
      if (!hasPeeked) {
        peekedElement = iterator.next();
        hasPeeked = true;
      }
      // The cast is safe because of the hasPeeked check.
      return uncheckedCastNullableTToT(peekedElement);
    }
  }

  /**
   * Returns a {@code PeekingIterator} backed by the given iterator.
   *
   * &lt;p&gt;Calls to the {@code peek} method with no intervening calls to {@code next} do not affect the
   * iteration, and hence return the same object each time. A subsequent call to {@code next} is
   * guaranteed to return the same object again. For example:
   *
   * &lt;pre&gt;{@code
   * PeekingIterator&lt;String&gt; peekingIterator =
   *     Iterators.peekingIterator(Iterators.forArray("a", "b"));
   * String a1 = peekingIterator.peek(); // returns "a"
   * String a2 = peekingIterator.peek(); // also returns "a"
   * String a3 = peekingIterator.next(); // also returns "a"
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;Any structural changes to the underlying iteration (aside from those performed by the
   * iterator's own {@link PeekingIterator#remove()} method) will leave the iterator in an undefined
   * state.
   *
   * &lt;p&gt;The returned iterator does not support removal after peeking, as explained by {@link
   * PeekingIterator#remove()}.
   *
   * &lt;p&gt;Note: If the given iterator is already a {@code PeekingIterator}, it &lt;i&gt;might&lt;/i&gt; be
   * returned to the caller, although this is neither guaranteed to occur nor required to be
   * consistent. For example, this method &lt;i&gt;might&lt;/i&gt; choose to pass through recognized
   * implementations of {@code PeekingIterator} when the behavior of the implementation is known to
   * meet the contract guaranteed by this method.
   *
   * &lt;p&gt;There is no {@link Iterable} equivalent to this method, so use this method to wrap each
   * individual iterator as it is generated.
   *
   * @param iterator the backing iterator. The {@link PeekingIterator} assumes ownership of this
   *     iterator, so users should cease making direct calls to it after calling this method.
   * @return a peeking iterator backed by that iterator. Apart from the additional {@link
   *     PeekingIterator#peek()} method, this iterator behaves exactly the same as {@code iterator}.
   */
  public static &lt;T extends @Nullable Object&gt; PeekingIterator&lt;T&gt; peekingIterator(
      Iterator&lt;? extends T&gt; iterator) {
    if (iterator instanceof PeekingImpl) {
      // Safe to cast &lt;? extends T&gt; to &lt;T&gt; because PeekingImpl only uses T
      // covariantly (and cannot be subclassed to add non-covariant uses).
      @SuppressWarnings("unchecked")
      PeekingImpl&lt;T&gt; peeking = (PeekingImpl&lt;T&gt;) iterator;
      return peeking;
    }
    return new PeekingImpl&lt;&gt;(iterator);
  }

  /**
   * Simply returns its argument.
   *
   * @deprecated no need to use this
   * @since 10.0
   */
  @Deprecated
  public static &lt;T extends @Nullable Object&gt; PeekingIterator&lt;T&gt; peekingIterator(
      PeekingIterator&lt;T&gt; iterator) {
    return checkNotNull(iterator);
  }

  /**
   * Returns an iterator over the merged contents of all given {@code iterators}, traversing every
   * element of the input iterators. Equivalent entries will not be de-duplicated.
   *
   * &lt;p&gt;Callers must ensure that the source {@code iterators} are in non-descending order as this
   * method does not sort its input.
   *
   * &lt;p&gt;For any equivalent elements across all {@code iterators}, it is undefined which element is
   * returned first.
   *
   * @since 11.0
   */
  @Beta
  public static &lt;T extends @Nullable Object&gt; UnmodifiableIterator&lt;T&gt; mergeSorted(
      Iterable&lt;? extends Iterator&lt;? extends T&gt;&gt; iterators, Comparator&lt;? super T&gt; comparator) {
    checkNotNull(iterators, "iterators");
    checkNotNull(comparator, "comparator");

    return new MergingIterator&lt;&gt;(iterators, comparator);
  }

  /**
   * An iterator that performs a lazy N-way merge, calculating the next value each time the iterator
   * is polled. This amortizes the sorting cost over the iteration and requires less memory than
   * sorting all elements at once.
   *
   * &lt;p&gt;Retrieving a single element takes approximately O(log(M)) time, where M is the number of
   * iterators. (Retrieving all elements takes approximately O(N*log(M)) time, where N is the total
   * number of elements.)
   */
  private static class MergingIterator&lt;T extends @Nullable Object&gt; extends UnmodifiableIterator&lt;T&gt; {
    final Queue&lt;PeekingIterator&lt;T&gt;&gt; queue;

    public MergingIterator(
        Iterable&lt;? extends Iterator&lt;? extends T&gt;&gt; iterators, Comparator&lt;? super T&gt; itemComparator) {
      // A comparator that's used by the heap, allowing the heap
      // to be sorted based on the top of each iterator.
      Comparator&lt;PeekingIterator&lt;T&gt;&gt; heapComparator =
          (PeekingIterator&lt;T&gt; o1, PeekingIterator&lt;T&gt; o2) -&gt;
              itemComparator.compare(o1.peek(), o2.peek());

      queue = new PriorityQueue&lt;&gt;(2, heapComparator);

      for (Iterator&lt;? extends T&gt; iterator : iterators) {
        if (iterator.hasNext()) {
          queue.add(Iterators.peekingIterator(iterator));
        }
      }
    }

    @Override
    public boolean hasNext() {
      return !queue.isEmpty();
    }

    @Override
    @ParametricNullness
    public T next() {
      PeekingIterator&lt;T&gt; nextIter = queue.remove();
      T next = nextIter.next();
      if (nextIter.hasNext()) {
        queue.add(nextIter);
      }
      return next;
    }
  }

  private static class ConcatenatedIterator&lt;T extends @Nullable Object&gt; implements Iterator&lt;T&gt; {
    /* The last iterator to return an element.  Calls to remove() go to this iterator. */
    @CheckForNull private Iterator&lt;? extends T&gt; toRemove;

    /* The iterator currently returning elements. */
    private Iterator&lt;? extends T&gt; iterator;

    /*
     * We track the "meta iterators," the iterators-of-iterators, below.  Usually, topMetaIterator
     * is the only one in use, but if we encounter nested concatenations, we start a deque of
     * meta-iterators rather than letting the nesting get arbitrarily deep.  This keeps each
     * operation O(1).
     */

    @CheckForNull private Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; topMetaIterator;

    // Only becomes nonnull if we encounter nested concatenations.
    @CheckForNull private Deque&lt;Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt;&gt; metaIterators;

    ConcatenatedIterator(Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; metaIterator) {
      iterator = emptyIterator();
      topMetaIterator = checkNotNull(metaIterator);
    }

    // Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.
    @CheckForNull
    private Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; getTopMetaIterator() {
      while (topMetaIterator == null || !topMetaIterator.hasNext()) {
        if (metaIterators != null &amp;&amp; !metaIterators.isEmpty()) {
          topMetaIterator = metaIterators.removeFirst();
        } else {
          return null;
        }
      }
      return topMetaIterator;
    }

    @Override
    public boolean hasNext() {
      while (!checkNotNull(iterator).hasNext()) {
        // this weird checkNotNull positioning appears required by our tests, which expect
        // both hasNext and next to throw NPE if an input iterator is null.

        topMetaIterator = getTopMetaIterator();
        if (topMetaIterator == null) {
          return false;
        }

        iterator = topMetaIterator.next();

        if (iterator instanceof ConcatenatedIterator) {
          // Instead of taking linear time in the number of nested concatenations, unpack
          // them into the queue
          @SuppressWarnings("unchecked")
          ConcatenatedIterator&lt;T&gt; topConcat = (ConcatenatedIterator&lt;T&gt;) iterator;
          iterator = topConcat.iterator;

          // topConcat.topMetaIterator, then topConcat.metaIterators, then this.topMetaIterator,
          // then this.metaIterators

          if (this.metaIterators == null) {
            this.metaIterators = new ArrayDeque&lt;&gt;();
          }
          this.metaIterators.addFirst(this.topMetaIterator);
          if (topConcat.metaIterators != null) {
            while (!topConcat.metaIterators.isEmpty()) {
              this.metaIterators.addFirst(topConcat.metaIterators.removeLast());
            }
          }
          this.topMetaIterator = topConcat.topMetaIterator;
        }
      }
      return true;
    }

    @Override
    @ParametricNullness
    public T next() {
      if (hasNext()) {
        toRemove = iterator;
        return iterator.next();
      } else {
        throw new NoSuchElementException();
      }
    }

    @Override
    public void remove() {
      if (toRemove == null) {
        throw new IllegalStateException("no calls to next() since the last call to remove()");
      }
      toRemove.remove();
      toRemove = null;
    }
  }

  /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
  static &lt;T extends @Nullable Object&gt; ListIterator&lt;T&gt; cast(Iterator&lt;T&gt; iterator) {
    return (ListIterator&lt;T&gt;) iterator;
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
