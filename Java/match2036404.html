<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for SysSnapshotsTest.java & LeaderChecker.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for SysSnapshotsTest.java & LeaderChecker.java
      </h3>
      <h1 align="center">
        10.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>SysSnapshotsTest.java (21.830986%)<TH>LeaderChecker.java (7.1264367%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2036404-0.html#0',2,'match2036404-1.html#0',3)" NAME="0">(22-47)<TD><A HREF="javascript:ZweiFrames('match2036404-0.html#0',2,'match2036404-1.html#0',3)" NAME="0">(20-42)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2036404-0.html#1',2,'match2036404-1.html#1',3)" NAME="1">(87-95)<TD><A HREF="javascript:ZweiFrames('match2036404-0.html#1',2,'match2036404-1.html#1',3)" NAME="1">(207-210)</A><TD ALIGN=center><FONT COLOR="#680000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SysSnapshotsTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2036404-1.html#0',3,'match2036404-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.crate.integrationtests;

import static org.hamcrest.Matchers.arrayContaining;
import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.lessThanOrEqualTo;

import java.util.List;

import org.elasticsearch.Version;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.snapshots.SnapshotState;
import org.elasticsearch.test.ESIntegTestCase;
import org.elasticsearch.threadpool.ThreadPool;
import org.hamcrest.Matchers;
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import io.crate.testing.TestingHelpers;
import io.crate.testing.UseJdbc;
import io.crate.types.ArrayType;
import io.crate.types.DataTypes;
import io.crate.types.ObjectType;
import io.crate.types.StringType;
import</B></FONT> io.crate.types.TimestampType;

@ESIntegTestCase.ClusterScope()
@UseJdbc(0) // missing column types
public class SysSnapshotsTest extends SQLIntegrationTestCase {

    @ClassRule
    public static TemporaryFolder TEMP_FOLDER = new TemporaryFolder();

    @Override
    protected Settings nodeSettings(int nodeOrdinal) {
        return Settings.builder()
            .put(super.nodeSettings(nodeOrdinal))
            .put(&quot;path.repo&quot;, TEMP_FOLDER.getRoot().getAbsolutePath())
            .put(ThreadPool.ESTIMATED_TIME_INTERVAL_SETTING.getKey(), 0) // We have tests that verify an exact wait time
            .build();
    }

    @Test
    public void testQueryAllColumns() throws Exception {
        execute(&quot;create table tbl (id int primary key) &quot;);
        Object[][] bulkArgs = new Object[10][];
        for (int i = 0; i &lt; 10; i++) {
            bulkArgs[i] = new Object[] { i };
        }
        execute(&quot;insert into tbl (id) values (?)&quot;, bulkArgs);
        execute(&quot;refresh table tbl&quot;);

        ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class);
        execute(
            &quot;CREATE REPOSITORY r1 TYPE fs WITH (location = ?, compress = true)&quot;,
            new Object[] { TEMP_FOLDER.newFolder(&quot;backup_s1&quot;).getAbsolutePath() });
        long createdTime = threadPool.absoluteTimeInMillis();
        execute(&quot;CREATE SNAPSHOT r1.s1 TABLE tbl WITH (wait_for_completion = true)&quot;);
        long finishedTime = threadPool.absoluteTimeInMillis();

        execute(&quot;select * from sys.snapshots&quot;);
<A NAME="1"></A>        assertThat(response.rowCount(), is(1L));
        assertThat(response.cols(), arrayContaining(&quot;concrete_indices&quot;, &quot;failures&quot;, &quot;finished&quot;, &quot;name&quot;, &quot;repository&quot;, &quot;started&quot;, &quot;state&quot;, &quot;table_partitions&quot;, &quot;tables&quot;, &quot;version&quot;));
        ArrayType&lt;String&gt; stringArray = new ArrayType&lt;&gt;(DataTypes.STRING);
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2036404-1.html#1',3,'match2036404-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(response.columnTypes(), arrayContaining(
            stringArray,
            stringArray,
            TimestampType.INSTANCE_WITH_TZ,
            StringType.INSTANCE,
            StringType.INSTANCE,
            TimestampType.INSTANCE_WITH_TZ,
            StringType.INSTANCE,
            new ArrayType&lt;&gt;(ObjectType.builder</B></FONT>()
                .setInnerType(&quot;values&quot;, stringArray)
                .setInnerType(&quot;table_schema&quot;, StringType.INSTANCE)
                .setInnerType(&quot;table_name&quot;, StringType.INSTANCE)
                .build()
            ),
            stringArray,
            StringType.INSTANCE
        ));
        Object[] firstRow = response.rows()[0];
        assertThat((List&lt;Object&gt;) firstRow[0], Matchers.contains(getFqn(&quot;tbl&quot;)));
        assertThat((List&lt;Object&gt;) firstRow[1], Matchers.empty());
        assertThat((Long) firstRow[2], lessThanOrEqualTo(finishedTime));
        assertThat(firstRow[3], is(&quot;s1&quot;));
        assertThat(firstRow[4], is(&quot;r1&quot;));
        assertThat((Long) firstRow[5], greaterThanOrEqualTo(createdTime));
        assertThat(firstRow[6], is(SnapshotState.SUCCESS.name()));
        assertThat((List&lt;Object&gt;) firstRow[7], Matchers.empty());
        assertThat((List&lt;Object&gt;) firstRow[8], Matchers.contains(getFqn(&quot;tbl&quot;)));
        assertThat(firstRow[9], is(Version.CURRENT.toString()));
    }

    @Test
    public void test_sys_snapshots_returns_table_partition_information() throws Exception {
        execute(&quot;create table tbl (x int, p int) clustered into 1 shards partitioned by (p)&quot;);
        execute(&quot;insert into tbl (x, p) values (1, 1), (2, 2)&quot;);
        execute(&quot;refresh table tbl&quot;);
        execute(
            &quot;CREATE REPOSITORY r1 TYPE fs WITH (location = ?, compress = true)&quot;,
            new Object[] { TEMP_FOLDER.newFolder(&quot;backup_s2&quot;).getAbsolutePath() });
        execute(&quot;CREATE SNAPSHOT r1.s2 TABLE tbl WITH (wait_for_completion = true)&quot;);

        execute(&quot;select x['table_name'], unnest(x['values']::string[]) &quot;
            + &quot;from (select unnest(table_partitions) from sys.snapshots) t (x) order by 2&quot;);
        assertThat(TestingHelpers.printedTable(response.rows()), is(
            &quot;tbl| 1\n&quot; +
            &quot;tbl| 2\n&quot;
        ));
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>LeaderChecker.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="0"></A> * under the License.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2036404-0.html#0',2,'match2036404-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package org.elasticsearch.cluster.coordination;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.message.ParameterizedMessage;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.cluster.node.DiscoveryNodes;
import javax.annotation.Nullable;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;
import org.elasticsearch.common.lease.Releasable;
import org.elasticsearch.common.settings.Setting;
import org.elasticsearch.common.settings.Settings;
import io.crate.common.unit.TimeValue;
import org.elasticsearch.threadpool.ThreadPool.Names;
import org.elasticsearch.transport.ConnectTransportException;
import org.elasticsearch.transport.Transport;
import org.elasticsearch.transport.NodeDisconnectedException;
import org.elasticsearch.transport.TransportConnectionListener;
import org.elasticsearch.transport.TransportException;
import org.elasticsearch.transport.TransportRequest;
import</B></FONT> org.elasticsearch.transport.TransportRequestOptions;
import org.elasticsearch.transport.TransportRequestOptions.Type;
import org.elasticsearch.transport.TransportResponse;
import org.elasticsearch.transport.TransportResponse.Empty;
import org.elasticsearch.transport.TransportResponseHandler;
import org.elasticsearch.transport.TransportService;

import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

/**
 * The LeaderChecker is responsible for allowing followers to check that the currently elected leader is still connected and healthy. We are
 * fairly lenient, possibly allowing multiple checks to fail before considering the leader to be faulty, to allow for the leader to
 * temporarily stand down on occasion, e.g. if it needs to move to a higher term. On deciding that the leader has failed a follower will
 * become a candidate and attempt to become a leader itself.
 */
public class LeaderChecker {

    private static final Logger LOGGER = LogManager.getLogger(LeaderChecker.class);

    public static final String LEADER_CHECK_ACTION_NAME = &quot;internal:coordination/fault_detection/leader_check&quot;;

    // the time between checks sent to the leader
    public static final Setting&lt;TimeValue&gt; LEADER_CHECK_INTERVAL_SETTING =
        Setting.timeSetting(&quot;cluster.fault_detection.leader_check.interval&quot;,
            TimeValue.timeValueMillis(1000), TimeValue.timeValueMillis(100), Setting.Property.NodeScope);

    // the timeout for each check sent to the leader
    public static final Setting&lt;TimeValue&gt; LEADER_CHECK_TIMEOUT_SETTING =
        Setting.timeSetting(&quot;cluster.fault_detection.leader_check.timeout&quot;,
            TimeValue.timeValueMillis(10000), TimeValue.timeValueMillis(1), Setting.Property.NodeScope);

    // the number of failed checks that must happen before the leader is considered to have failed.
    public static final Setting&lt;Integer&gt; LEADER_CHECK_RETRY_COUNT_SETTING =
        Setting.intSetting(&quot;cluster.fault_detection.leader_check.retry_count&quot;, 3, 1, Setting.Property.NodeScope);

    private final TimeValue leaderCheckInterval;
    private final TimeValue leaderCheckTimeout;
    private final int leaderCheckRetryCount;
    private final TransportService transportService;
    private final Consumer&lt;Exception&gt; onLeaderFailure;

    private AtomicReference&lt;CheckScheduler&gt; currentChecker = new AtomicReference&lt;&gt;();

    private volatile DiscoveryNodes discoveryNodes;

    public LeaderChecker(final Settings settings, final TransportService transportService, final Consumer&lt;Exception&gt; onLeaderFailure) {
        leaderCheckInterval = LEADER_CHECK_INTERVAL_SETTING.get(settings);
        leaderCheckTimeout = LEADER_CHECK_TIMEOUT_SETTING.get(settings);
        leaderCheckRetryCount = LEADER_CHECK_RETRY_COUNT_SETTING.get(settings);
        this.transportService = transportService;
        this.onLeaderFailure = onLeaderFailure;

        transportService.registerRequestHandler(LEADER_CHECK_ACTION_NAME, Names.SAME, false, false, LeaderCheckRequest::new,
            (request, channel) -&gt; {
                handleLeaderCheck(request);
                channel.sendResponse(Empty.INSTANCE);
            });

        transportService.addConnectionListener(new TransportConnectionListener() {
            @Override
            public void onNodeDisconnected(DiscoveryNode node, Transport.Connection connection) {
                handleDisconnectedNode(node);
            }
        });
    }

    public DiscoveryNode leader() {
        CheckScheduler checkScheduler = currentChecker.get();
        return checkScheduler == null ? null : checkScheduler.leader;
    }

    /**
     * Starts and / or stops a leader checker for the given leader. Should only be called after successfully joining this leader.
     *
     * @param leader the node to be checked as leader, or null if checks should be disabled
     */
    public void updateLeader(@Nullable final DiscoveryNode leader) {
        assert transportService.getLocalNode().equals(leader) == false;
        final CheckScheduler checkScheduler;
        if (leader != null) {
            checkScheduler = new CheckScheduler(leader);
        } else {
            checkScheduler = null;
        }
        CheckScheduler previousChecker = currentChecker.getAndSet(checkScheduler);
        if (previousChecker != null) {
            previousChecker.close();
        }
        if (checkScheduler != null) {
            checkScheduler.handleWakeUp();
        }
    }

    /**
     * Update the &quot;known&quot; discovery nodes. Should be called on the leader before a new cluster state is published to reflect the new
     * publication targets, and also called if a leader becomes a non-leader.
     * TODO if heartbeats can make nodes become followers then this needs to be called before a heartbeat is sent to a new node too.
     * &lt;p&gt;
     * isLocalNodeElectedMaster() should reflect whether this node is a leader, and nodeExists()
     * should indicate whether nodes are known publication targets or not.
     */
    public void setCurrentNodes(DiscoveryNodes discoveryNodes) {
        LOGGER.trace(&quot;setCurrentNodes: {}&quot;, discoveryNodes);
        this.discoveryNodes = discoveryNodes;
    }

    // For assertions
    boolean currentNodeIsMaster() {
        return discoveryNodes.isLocalNodeElectedMaster();
    }

    private void handleLeaderCheck(LeaderCheckRequest request) {
        final DiscoveryNodes discoveryNodes = this.discoveryNodes;
        assert discoveryNodes != null;

        if (discoveryNodes.isLocalNodeElectedMaster() == false) {
            LOGGER.debug(&quot;non-master handling {}&quot;, request);
            throw new CoordinationStateRejectedException(&quot;non-leader rejecting leader check&quot;);
        } else if (discoveryNodes.nodeExists(request.getSender()) == false) {
            LOGGER.debug(&quot;leader check from unknown node: {}&quot;, request);
            throw new CoordinationStateRejectedException(&quot;leader check from unknown node&quot;);
        } else {
            LOGGER.trace(&quot;handling {}&quot;, request);
        }
    }

    private void handleDisconnectedNode(DiscoveryNode discoveryNode) {
        CheckScheduler checkScheduler = currentChecker.get();
        if (checkScheduler != null) {
            checkScheduler.handleDisconnectedNode(discoveryNode);
        } else {
            LOGGER.trace(&quot;disconnect event ignored for {}, no check scheduler&quot;, discoveryNode);
        }
    }

    private class CheckScheduler implements Releasable {

        private final AtomicBoolean isClosed = new AtomicBoolean();
        private final AtomicLong failureCountSinceLastSuccess = new AtomicLong();
        private final DiscoveryNode leader;

        CheckScheduler(final DiscoveryNode leader) {
            this.leader = leader;
        }

        @Override
        public void close() {
            if (isClosed.compareAndSet(false, true) == false) {
                LOGGER.trace(&quot;already closed, doing nothing&quot;);
            } else {
                LOGGER.debug(&quot;closed&quot;);
            }
        }

        void handleWakeUp() {
            if (isClosed.get()) {
                LOGGER.trace(&quot;closed check scheduler woken up, doing nothing&quot;);
<A NAME="1"></A>                return;
            }

            <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2036404-0.html#1',2,'match2036404-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>LOGGER.trace(&quot;checking {} with [{}] = {}&quot;, leader, LEADER_CHECK_TIMEOUT_SETTING.getKey(), leaderCheckTimeout);

            transportService.sendRequest(leader, LEADER_CHECK_ACTION_NAME, new LeaderCheckRequest(transportService.getLocalNode()),
                TransportRequestOptions.builder</B></FONT>().withTimeout(leaderCheckTimeout).withType(Type.PING).build(),

                new TransportResponseHandler&lt;TransportResponse.Empty&gt;() {

                    @Override
                    public Empty read(StreamInput in) {
                        return Empty.INSTANCE;
                    }

                    @Override
                    public void handleResponse(Empty response) {
                        if (isClosed.get()) {
                            LOGGER.debug(&quot;closed check scheduler received a response, doing nothing&quot;);
                            return;
                        }

                        failureCountSinceLastSuccess.set(0);
                        scheduleNextWakeUp(); // logs trace message indicating success
                    }

                    @Override
                    public void handleException(TransportException exp) {
                        if (isClosed.get()) {
                            LOGGER.debug(&quot;closed check scheduler received a response, doing nothing&quot;);
                            return;
                        }

                        if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {
                            LOGGER.debug(new ParameterizedMessage(
                                &quot;leader [{}] disconnected during check&quot;, leader), exp);
                            leaderFailed(new ConnectTransportException(leader, &quot;disconnected during check&quot;, exp));
                            return;
                        }

                        long failureCount = failureCountSinceLastSuccess.incrementAndGet();
                        if (failureCount &gt;= leaderCheckRetryCount) {
                            LOGGER.debug(new ParameterizedMessage(
                                &quot;leader [{}] has failed {} consecutive checks (limit [{}] is {}); last failure was:&quot;,
                                leader, failureCount, LEADER_CHECK_RETRY_COUNT_SETTING.getKey(), leaderCheckRetryCount), exp);
                            leaderFailed(new ElasticsearchException(
                                &quot;node [&quot; + leader + &quot;] failed [&quot; + failureCount + &quot;] consecutive checks&quot;, exp));
                            return;
                        }

                        LOGGER.debug(new ParameterizedMessage(&quot;{} consecutive failures (limit [{}] is {}) with leader [{}]&quot;,
                            failureCount, LEADER_CHECK_RETRY_COUNT_SETTING.getKey(), leaderCheckRetryCount, leader), exp);
                        scheduleNextWakeUp();
                    }

                    @Override
                    public String executor() {
                        return Names.SAME;
                    }
                });
        }

        void leaderFailed(Exception e) {
            if (isClosed.compareAndSet(false, true)) {
                transportService.getThreadPool().generic().execute(new Runnable() {
                    @Override
                    public void run() {
                        onLeaderFailure.accept(e);
                    }

                    @Override
                    public String toString() {
                        return &quot;notification of leader failure: &quot; + e.getMessage();
                    }
                });
            } else {
                LOGGER.trace(&quot;already closed, not failing leader&quot;);
            }
        }

        void handleDisconnectedNode(DiscoveryNode discoveryNode) {
            if (discoveryNode.equals(leader)) {
                LOGGER.debug(&quot;leader [{}] disconnected&quot;, leader);
                leaderFailed(new NodeDisconnectedException(discoveryNode, &quot;disconnected&quot;));
            }
        }

        private void scheduleNextWakeUp() {
            LOGGER.trace(&quot;scheduling next check of {} for [{}] = {}&quot;, leader, LEADER_CHECK_INTERVAL_SETTING.getKey(), leaderCheckInterval);
            transportService.getThreadPool().schedule(new Runnable() {
                @Override
                public void run() {
                    handleWakeUp();
                }

                @Override
                public String toString() {
                    return &quot;scheduled check of leader &quot; + leader;
                }
            }, leaderCheckInterval, Names.SAME);
        }
    }

    public static class LeaderCheckRequest extends TransportRequest {

        private final DiscoveryNode sender;

        public LeaderCheckRequest(final DiscoveryNode sender) {
            this.sender = sender;
        }

        public LeaderCheckRequest(final StreamInput in) throws IOException {
            super(in);
            sender = new DiscoveryNode(in);
        }

        @Override
        public void writeTo(final StreamOutput out) throws IOException {
            super.writeTo(out);
            sender.writeTo(out);
        }

        public DiscoveryNode getSender() {
            return sender;
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            final LeaderCheckRequest that = (LeaderCheckRequest) o;
            return Objects.equals(sender, that.sender);
        }

        @Override
        public int hashCode() {
            return Objects.hash(sender);
        }

        @Override
        public String toString() {
            return &quot;LeaderCheckRequest{&quot; +
                &quot;sender=&quot; + sender +
                '}';
        }
    }
}

</PRE>
</div>
  </div>
</body>
</html>
