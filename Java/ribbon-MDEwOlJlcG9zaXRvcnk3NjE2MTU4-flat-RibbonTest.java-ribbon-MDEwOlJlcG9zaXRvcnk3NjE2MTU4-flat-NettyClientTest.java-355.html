
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RibbonTest.java</h3>
            <pre><code>1  package com.netflix.ribbon;
2  import com.google.mockwebserver.MockResponse;
3  import com.google.mockwebserver.MockWebServer;
4  import com.netflix.hystrix.HystrixInvokableInfo;
5  import com.netflix.hystrix.exception.HystrixBadRequestException;
6  import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
7  import com.netflix.ribbon.http.HttpRequestTemplate;
8  import com.netflix.ribbon.http.HttpResourceGroup;
9  import com.netflix.ribbon.hystrix.FallbackHandler;
10  import io.netty.buffer.ByteBuf;
11  import io.netty.buffer.Unpooled;
12  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
13  import org.apache.log4j.Level;
14  import org.apache.log4j.LogManager;
15  import org.junit.BeforeClass;
16  import org.junit.Ignore;
17  import org.junit.Test;
18  import rx.Observable;
19  import rx.functions.Action0;
20  import rx.functions.Action1;
21  import rx.functions.Func1;
22  import java.io.IOException;
23  import java.io.UnsupportedEncodingException;
24  import java.nio.charset.Charset;
25  import java.util.Map;
26  import java.util.concurrent.CountDownLatch;
27  import java.util.concurrent.ExecutionException;
28  import java.util.concurrent.Future;
29  import java.util.concurrent.atomic.AtomicBoolean;
30  import java.util.concurrent.atomic.AtomicReference;
31  import static org.junit.Assert.*;
32  public class RibbonTest {
33      private static String toStringBlocking(RibbonRequest&lt;ByteBuf&gt; request) {
34          return request.toObservable().map(new Func1&lt;ByteBuf, String&gt;() {
35              @Override
36              public String call(ByteBuf t1) {
37                  return t1.toString(Charset.defaultCharset());
38              }
39          }).toBlocking().single();
40      }
41      @BeforeClass
42      public static void init() {
43          LogManager.getRootLogger().setLevel(Level.DEBUG);
44      }
45      @Test
46      public void testCommand() throws IOException, InterruptedException, ExecutionException {
47          MockWebServer server = new MockWebServer();
48          String content = &quot;Hello world&quot;;
49          MockResponse response = new MockResponse()
50              .setResponseCode(200)
51              .setHeader(&quot;Content-type&quot;, &quot;text/plain&quot;)
52              .setBody(content);
53          server.enqueue(response);        
54          server.enqueue(response);       
55          server.enqueue(response);       
56          server.play();
57          HttpResourceGroup group = Ribbon.createHttpResourceGroup(&quot;myclient&quot;,
58                  ClientOptions.create()
59                  .withMaxAutoRetriesNextServer(3)
60                  .withReadTimeout(300000)
61                  .withConfigurationBasedServerList(&quot;localhost:12345, localhost:10092, localhost:&quot; + server.getPort()));
62          HttpRequestTemplate&lt;ByteBuf&gt; template = group.newTemplateBuilder(&quot;test&quot;, ByteBuf.class)
63                  .withUriTemplate(&quot;/&quot;)
64                  .withMethod(&quot;GET&quot;)
65                  .build();
66          RibbonRequest&lt;ByteBuf&gt; request = template.requestBuilder().build();
67          String result = request.execute().toString(Charset.defaultCharset());
68          assertEquals(content, result);
69          ByteBuf raw = request.execute();
70          result = raw.toString(Charset.defaultCharset());
71          raw.release();
72          assertEquals(content, result);
73          result = request.queue().get().toString(Charset.defaultCharset());
74          assertEquals(content, result);
75      }
76      @Test
77      public void testHystrixCache() throws IOException {
78          MockWebServer server = new MockWebServer();
79          String content = &quot;Hello world&quot;;
80          MockResponse response = new MockResponse()
81              .setResponseCode(200)
82              .setHeader(&quot;Content-type&quot;, &quot;text/plain&quot;)
83              .setBody(content);
84          server.enqueue(response);
85          server.enqueue(response);       
86          server.play();
87          HttpResourceGroup group = Ribbon.createHttpResourceGroupBuilder(&quot;myclient&quot;).build();
88          HttpRequestTemplate&lt;ByteBuf&gt; template = group.newTemplateBuilder(&quot;test&quot;, ByteBuf.class)
89                  .withUriTemplate(&quot;http:&amp;bsol;&amp;bsol;localhost:&quot; + server.getPort())
90                  .withMethod(&quot;GET&quot;)
91                  .withRequestCacheKey(&quot;xyz&quot;)
92                  .build();
93          RibbonRequest&lt;ByteBuf&gt; request = template
94                  .requestBuilder().build();
95          HystrixRequestContext context = HystrixRequestContext.initializeContext();
96          try {
97              RibbonResponse&lt;ByteBuf&gt; ribbonResponse = request.withMetadata().execute();
98              assertFalse(ribbonResponse.getHystrixInfo().isResponseFromCache());
99              ribbonResponse = request.withMetadata().execute();
100              assertTrue(ribbonResponse.getHystrixInfo().isResponseFromCache());
101          } finally {
102              context.shutdown();
103          }
104      }
105      @Test
106      @Ignore
107      public void testCommandWithMetaData() throws IOException, InterruptedException, ExecutionException {
108          MockWebServer server = new MockWebServer();
109          String content = &quot;Hello world&quot;;
110          for (int i = 0; i &lt; 6; i++) {
111              server.enqueue(new MockResponse()
112                  .setResponseCode(200)
113                  .setHeader(&quot;Content-type&quot;, &quot;text/plain&quot;)
114                  .setBody(content));
115          }
116          server.play();
117          HttpResourceGroup group = Ribbon.createHttpResourceGroup(&quot;myclient&quot;, ClientOptions.create()
118                  .withConfigurationBasedServerList(&quot;localhost:&quot; + server.getPort())
119                  .withMaxAutoRetriesNextServer(3));
120          HttpRequestTemplate&lt;ByteBuf&gt; template = group.newTemplateBuilder(&quot;test&quot;)
121                  .withUriTemplate(&quot;/&quot;)
122                  .withMethod(&quot;GET&quot;)
123                  .withCacheProvider(&quot;somekey&quot;, new CacheProvider&lt;ByteBuf&gt;(){
124                      @Override
125                      public Observable&lt;ByteBuf&gt; get(String key, Map&lt;String, Object&gt; vars) {
126                          return Observable.error(new Exception(&quot;Cache miss&quot;));
127                      }
128                  }).build();
129          RibbonRequest&lt;ByteBuf&gt; request = template
130                  .requestBuilder().build();
131          final AtomicBoolean success = new AtomicBoolean(false);
132          RequestWithMetaData&lt;ByteBuf&gt; metaRequest = request.withMetadata();
133          Observable&lt;String&gt; result = metaRequest.toObservable().flatMap(new Func1&lt;RibbonResponse&lt;Observable&lt;ByteBuf&gt;&gt;, Observable&lt;String&gt;&gt;(){
134              @Override
135              public Observable&lt;String&gt; call(
136                      final RibbonResponse&lt;Observable&lt;ByteBuf&gt;&gt; response) {
137                  success.set(response.getHystrixInfo().isSuccessfulExecution());
138                  return response.content().map(new Func1&lt;ByteBuf, String&gt;(){
139                      @Override
140                      public String call(ByteBuf t1) {
141                          return t1.toString(Charset.defaultCharset());
142                      }
143                  });
144              }
145          });
146          String s = result.toBlocking().single();
147          assertEquals(content, s);
148          assertTrue(success.get());
149          Future&lt;RibbonResponse&lt;ByteBuf&gt;&gt; future = metaRequest.queue();
150          RibbonResponse&lt;ByteBuf&gt; response = future.get();
151          assertTrue(future.isDone());
152          assertEquals(content, response.content().toString(Charset.defaultCharset()));
153          assertTrue(response.getHystrixInfo().isSuccessfulExecution()); 
154          RibbonResponse&lt;ByteBuf&gt; result1 = metaRequest.execute();
155          assertEquals(content, result1.content().toString(Charset.defaultCharset()));
156          assertTrue(result1.getHystrixInfo().isSuccessfulExecution());
157      }
158      @Test
159      public void testValidator() throws IOException, InterruptedException {
160          MockWebServer server = new MockWebServer();
161          String content = &quot;Hello world&quot;;
162          server.enqueue(new MockResponse()
163                  .setResponseCode(200)
164                  .setHeader(&quot;Content-type&quot;, &quot;text/plain&quot;)
165                  .setBody(content));       
166          server.play();
167          HttpResourceGroup group = Ribbon.createHttpResourceGroup(&quot;myclient&quot;, ClientOptions.create()
168                  .withConfigurationBasedServerList(&quot;localhost:&quot; + server.getPort()));
169          HttpRequestTemplate&lt;ByteBuf&gt; template = group.newTemplateBuilder(&quot;test&quot;, ByteBuf.class)
170                  .withUriTemplate(&quot;/&quot;)
171                  .withMethod(&quot;GET&quot;)
172                  .withResponseValidator(new ResponseValidator&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;() {
173                      @Override
174                      public void validate(HttpClientResponse&lt;ByteBuf&gt; t1) throws UnsuccessfulResponseException {
175                          throw new UnsuccessfulResponseException(&quot;error&quot;, new IllegalArgumentException());
176                      }
177                  }).build();
178          RibbonRequest&lt;ByteBuf&gt; request = template.requestBuilder().build();
179          final CountDownLatch latch = new CountDownLatch(1);
180          final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
181          request.toObservable().subscribe(new Action1&lt;ByteBuf&gt;() {
182              @Override
183              public void call(ByteBuf t1) {
184              }
185          }, 
186          new Action1&lt;Throwable&gt;(){
187              @Override
188              public void call(Throwable t1) {
189                  error.set(t1);
<span onclick='openModal()' class='match'>190                  latch.countDown();
191              }
192          }, 
193          new Action0() {
194              @Override
195              public void call() {
196              }
</span>197          });
198          latch.await();
199          assertTrue(error.get() instanceof HystrixBadRequestException);
200          assertTrue(error.get().getCause() instanceof UnsuccessfulResponseException);
201      }
202      @Test
203      public void testFallback() throws IOException {
204          HttpResourceGroup group = Ribbon.createHttpResourceGroup(&quot;myclient&quot;, ClientOptions.create()
205                  .withConfigurationBasedServerList(&quot;localhost:12345&quot;)
206                  .withMaxAutoRetriesNextServer(1));
207          final String fallback = &quot;fallback&quot;;
208          HttpRequestTemplate&lt;ByteBuf&gt; template = group.newTemplateBuilder(&quot;test&quot;, ByteBuf.class)
209                  .withUriTemplate(&quot;/&quot;)
210                  .withMethod(&quot;GET&quot;)
211                  .withFallbackProvider(new FallbackHandler&lt;ByteBuf&gt;() {
212                      @Override
213                      public Observable&lt;ByteBuf&gt; getFallback(
214                              HystrixInvokableInfo&lt;?&gt; hystrixInfo,
215                              Map&lt;String, Object&gt; requestProperties) {
216                          try {
217                              return Observable.just(Unpooled.buffer().writeBytes(fallback.getBytes(&quot;UTF-8&quot;)));
218                          } catch (UnsupportedEncodingException e) {
219                              return Observable.error(e);
220                          }
221                      }
222                  }).build();
223          RibbonRequest&lt;ByteBuf&gt; request = template
224                  .requestBuilder().build();
225          final AtomicReference&lt;HystrixInvokableInfo&lt;?&gt;&gt; hystrixInfo = new AtomicReference&lt;HystrixInvokableInfo&lt;?&gt;&gt;();
226          final AtomicBoolean failed = new AtomicBoolean(false);
227          Observable&lt;String&gt; result = request.withMetadata().toObservable().flatMap(new Func1&lt;RibbonResponse&lt;Observable&lt;ByteBuf&gt;&gt;, Observable&lt;String&gt;&gt;(){
228              @Override
229              public Observable&lt;String&gt; call(
230                      final RibbonResponse&lt;Observable&lt;ByteBuf&gt;&gt; response) {
231                  hystrixInfo.set(response.getHystrixInfo());
232                  failed.set(response.getHystrixInfo().isFailedExecution());
233                  return response.content().map(new Func1&lt;ByteBuf, String&gt;(){
234                      @Override
235                      public String call(ByteBuf t1) {
236                          return t1.toString(Charset.defaultCharset());
237                      }
238                  });
239              }
240          });
241          String s = result.toBlocking().single();
242          assertTrue(hystrixInfo.get().isResponseFromFallback());
243          assertTrue(failed.get());
244          assertEquals(fallback, s);
245      }
246      @Test
247      public void testCacheHit() {
248          HttpResourceGroup group = Ribbon.createHttpResourceGroup(&quot;myclient&quot;, ClientOptions.create()
249                  .withConfigurationBasedServerList(&quot;localhost:12345&quot;)
250                  .withMaxAutoRetriesNextServer(1));
251          final String content = &quot;from cache&quot;;
252          final String cacheKey = &quot;somekey&quot;;
253          HttpRequestTemplate&lt;ByteBuf&gt; template = group.newTemplateBuilder(&quot;test&quot;)
254          .withCacheProvider(cacheKey, new CacheProvider&lt;ByteBuf&gt;(){
255              @Override
256              public Observable&lt;ByteBuf&gt; get(String key, Map&lt;String, Object&gt; vars) {
257                  if (key.equals(cacheKey)) {
258                      try {
259                          return Observable.just(Unpooled.buffer().writeBytes(content.getBytes(&quot;UTF-8&quot;)));
260                      } catch (UnsupportedEncodingException e) {
261                          return Observable.error(e);
262                      }
263                  } else {
264                      return Observable.error(new Exception(&quot;Cache miss&quot;));
265                  }
266              }
267          }).withUriTemplate(&quot;/&quot;)
268                  .withMethod(&quot;GET&quot;).build();
269          RibbonRequest&lt;ByteBuf&gt; request = template
270                  .requestBuilder().build();
271          String result = request.execute().toString(Charset.defaultCharset());
272          assertEquals(content, result);
273      }
274      @Test
275      public void testObserve() throws IOException, InterruptedException {
276          MockWebServer server = new MockWebServer();
277          String content = &quot;Hello world&quot;;
278          server.enqueue(new MockResponse()
279                  .setResponseCode(200)
280                  .setHeader(&quot;Content-type&quot;, &quot;text/plain&quot;)
281                  .setBody(content));       
282          server.enqueue(new MockResponse()
283                  .setResponseCode(200)
284                  .setHeader(&quot;Content-type&quot;, &quot;text/plain&quot;)
285                  .setBody(content));       
286          server.play();
287          HttpResourceGroup group = Ribbon.createHttpResourceGroup(&quot;myclient&quot;,
288                  ClientOptions.create()
289                  .withMaxAutoRetriesNextServer(3)
290                  .withReadTimeout(300000)
291                  .withConfigurationBasedServerList(&quot;localhost:12345, localhost:10092, localhost:&quot; + server.getPort()));
292          HttpRequestTemplate&lt;ByteBuf&gt; template = group.newTemplateBuilder(&quot;test&quot;, ByteBuf.class)
293                  .withUriTemplate(&quot;/&quot;)
294                  .withMethod(&quot;GET&quot;).build();
295          RibbonRequest&lt;ByteBuf&gt; request = template
296                  .requestBuilder().build();
297          Observable&lt;ByteBuf&gt; result = request.observe();
298          final CountDownLatch latch = new CountDownLatch(1);
299          final AtomicReference&lt;String&gt; fromCommand = new AtomicReference&lt;String&gt;();
300          result.toBlocking().last();
301          result.subscribe(new Action1&lt;ByteBuf&gt;() {
302              @Override
303              public void call(ByteBuf t1) {
304                  try {
305                      fromCommand.set(t1.toString(Charset.defaultCharset()));
306                  } catch (Exception e) {
307                      e.printStackTrace();
308                  }
309                  latch.countDown();
310              }
311          });
312          latch.await();
313          assertEquals(content, fromCommand.get());
314          Observable&lt;RibbonResponse&lt;Observable&lt;ByteBuf&gt;&gt;&gt; metaResult = request.withMetadata().observe();
315          String result2 = &quot;&quot;;
316          metaResult.toBlocking().last();
317          result2 = metaResult.flatMap(new Func1&lt;RibbonResponse&lt;Observable&lt;ByteBuf&gt;&gt;, Observable&lt;ByteBuf&gt;&gt;(){
318              @Override
319              public Observable&lt;ByteBuf&gt; call(
320                      RibbonResponse&lt;Observable&lt;ByteBuf&gt;&gt; t1) {
321                  return t1.content();
322              }
323          }).map(new Func1&lt;ByteBuf, String&gt;(){
324              @Override
325              public String call(ByteBuf t1) {
326                  return t1.toString(Charset.defaultCharset());
327              }
328          }).toBlocking().single();
329          assertEquals(content, result2);
330      }
331      @Test
332      public void testCacheMiss() throws IOException, InterruptedException {
333          MockWebServer server = new MockWebServer();
334          String content = &quot;Hello world&quot;;
335          server.enqueue(new MockResponse()
336                  .setResponseCode(200)
337                  .setHeader(&quot;Content-type&quot;, &quot;text/plain&quot;)
338                  .setBody(content));       
339          server.play();
340          HttpResourceGroup group = Ribbon.createHttpResourceGroup(&quot;myclient&quot;, ClientOptions.create()
341                  .withConfigurationBasedServerList(&quot;localhost:&quot; + server.getPort())
342                  .withMaxAutoRetriesNextServer(1));
343          final String cacheKey = &quot;somekey&quot;;
344          HttpRequestTemplate&lt;ByteBuf&gt; template = group.newTemplateBuilder(&quot;test&quot;)
345                  .withCacheProvider(cacheKey, new CacheProvider&lt;ByteBuf&gt;(){
346                      @Override
347                      public Observable&lt;ByteBuf&gt; get(String key, Map&lt;String, Object&gt; vars) {
348                          return Observable.error(new Exception(&quot;Cache miss again&quot;));
349                      }
350                  })
351                  .withMethod(&quot;GET&quot;)
352                  .withUriTemplate(&quot;/&quot;).build();
353          RibbonRequest&lt;ByteBuf&gt; request = template
354                  .requestBuilder().build();
355          String result = toStringBlocking(request);
356          assertEquals(content, result);
357      } 
358  }
</code></pre>
        </div>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-NettyClientTest.java</h3>
            <pre><code>1  package com.netflix.ribbon.transport.netty.http;
2  import static com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout;
3  import static org.junit.Assert.assertEquals;
4  import static org.junit.Assert.assertNotNull;
5  import static org.junit.Assert.assertNull;
6  import static org.junit.Assert.assertTrue;
7  import static org.junit.Assert.fail;
8  import io.netty.buffer.ByteBuf;
9  import io.netty.buffer.ByteBufInputStream;
10  import io.netty.buffer.Unpooled;
11  import io.reactivex.netty.contexts.ContextsContainer;
12  import io.reactivex.netty.contexts.ContextsContainerImpl;
13  import io.reactivex.netty.contexts.MapBackedKeySupplier;
14  import io.reactivex.netty.contexts.RxContexts;
15  import io.reactivex.netty.protocol.http.client.HttpClient.HttpClientConfig;
16  import io.reactivex.netty.protocol.http.client.HttpClientRequest;
17  import io.reactivex.netty.protocol.http.client.HttpClientResponse;
18  import io.reactivex.netty.protocol.text.sse.ServerSentEvent;
19  import io.reactivex.netty.servo.http.HttpClientListener;
20  import java.io.IOException;
21  import java.nio.charset.Charset;
22  import java.util.Iterator;
23  import java.util.List;
24  import java.util.Random;
25  import java.util.concurrent.CountDownLatch;
26  import java.util.concurrent.ExecutorService;
27  import java.util.concurrent.Executors;
28  import java.util.concurrent.atomic.AtomicReference;
29  import org.codehaus.jackson.map.ObjectMapper;
30  import org.junit.BeforeClass;
31  import org.junit.Ignore;
32  import org.junit.Test;
33  import rx.Observable;
34  import rx.functions.Action0;
35  import rx.functions.Action1;
36  import rx.functions.Func0;
37  import rx.functions.Func1;
38  import com.google.common.collect.Lists;
39  import com.google.mockwebserver.MockResponse;
40  import com.google.mockwebserver.MockWebServer;
41  import com.netflix.client.ClientException;
42  import com.netflix.client.RequestSpecificRetryHandler;
43  import com.netflix.client.RetryHandler;
44  import com.netflix.client.config.CommonClientConfigKey;
45  import com.netflix.client.config.DefaultClientConfigImpl;
46  import com.netflix.client.config.IClientConfig;
47  import com.netflix.client.config.IClientConfigKey;
48  import com.netflix.loadbalancer.AvailabilityFilteringRule;
49  import com.netflix.loadbalancer.BaseLoadBalancer;
50  import com.netflix.loadbalancer.DummyPing;
51  import com.netflix.loadbalancer.LoadBalancerBuilder;
52  import com.netflix.loadbalancer.Server;
53  import com.netflix.loadbalancer.ServerStats;
54  import com.netflix.ribbon.test.resources.EmbeddedResources;
55  import com.netflix.ribbon.test.resources.EmbeddedResources.Person;
56  import com.netflix.ribbon.transport.netty.RibbonTransport;
57  import com.netflix.serialization.JacksonCodec;
58  import com.netflix.serialization.SerializationUtils;
59  import com.netflix.serialization.TypeDef;
60  import com.sun.jersey.api.container.httpserver.HttpServerFactory;
61  import com.sun.jersey.api.core.PackagesResourceConfig;
62  import com.sun.net.httpserver.HttpServer;
63  public class NettyClientTest {
64      private static HttpServer server = null;
65      private static String SERVICE_URI;
66      private static int port;
67      private static final String host = &quot;localhost&quot;;
68      static Observable&lt;ServerSentEvent&gt; transformSSE(Observable&lt;HttpClientResponse&lt;ServerSentEvent&gt;&gt; response) {
69          return response.flatMap(new Func1&lt;HttpClientResponse&lt;ServerSentEvent&gt;, Observable&lt;ServerSentEvent&gt;&gt;() {
70              @Override
71              public Observable&lt;ServerSentEvent&gt; call(HttpClientResponse&lt;ServerSentEvent&gt; t1) {
72                  return t1.getContent();
73              }
74          });
75      }
76      @BeforeClass 
77      public static void init() throws Exception {
78          PackagesResourceConfig resourceConfig = new PackagesResourceConfig(&quot;com.netflix.ribbon.test.resources&quot;);
79          port = (new Random()).nextInt(1000) + 4000;
80          SERVICE_URI = &quot;http:&amp;bsol;&amp;bsol;localhost:&quot; + port + &quot;/&quot;;
81          ExecutorService service = Executors.newFixedThreadPool(20);
82          try{
83              server = HttpServerFactory.create(SERVICE_URI, resourceConfig);           
84              server.setExecutor(service);
85              server.start();
86          } catch(Exception e) {
87              e.printStackTrace();
88              fail(&quot;Unable to start server&quot;);
89          }
90      }
91      private static Observable&lt;Person&gt; getPersonObservable(Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; response) {
92          return response.flatMap(new Func1&lt;HttpClientResponse&lt;ByteBuf&gt;, Observable&lt;ByteBuf&gt;&gt;() {
93              @Override
94              public Observable&lt;ByteBuf&gt; call(HttpClientResponse&lt;ByteBuf&gt; t1) {
95                  return t1.getContent();
96              }
97          }).map(new Func1&lt;ByteBuf, Person&gt;() {
98              @Override
99              public Person call(ByteBuf t1) {
100                  try {
101                      return JacksonCodec.&lt;Person&gt;getInstance().deserialize(new ByteBufInputStream(t1), TypeDef.fromClass(Person.class));
102                  } catch (IOException e) {
103                      e.printStackTrace();
104                      return null;
105                  }
106              }
107          });
108      }
109      @Test
110      public void testObservable() throws Exception {
111          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/person&quot;);
112          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient();
113          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; response = observableClient.submit(request);
114          Person person = getPersonObservable(response).toBlocking().single();
115          assertEquals(EmbeddedResources.defaultPerson, person);
116          final HttpClientListener listener = observableClient.getListener();
117          assertEquals(1, listener.getPoolAcquires());
118          assertEquals(1, listener.getConnectionCount());
119          waitUntilTrueOrTimeout(1000, new Func0&lt;Boolean&gt;() {
120              @Override
121              public Boolean call() {
122                  return listener.getPoolReleases() == 1;
123              }
124          });
125      }
126      @Test
127      public void testSubmitToAbsoluteURI() throws Exception {
128          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/person&quot;);
129          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient();
130          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; response = observableClient.submit(request);
131          Person person = getPersonObservable(response).toBlocking().single();
132          assertEquals(EmbeddedResources.defaultPerson, person);
133          final HttpClientListener listener = observableClient.getListener();
134          assertEquals(1, listener.getConnectionCount());
135          assertEquals(1, listener.getPoolAcquires());
136          waitUntilTrueOrTimeout(1000, new Func0&lt;Boolean&gt;() {
137              @Override
138              public Boolean call() {
139                  return listener.getPoolReleases() == 1;
140              }
141          });
142      }
143      @Test
144      public void testPoolReuse() throws Exception {
145          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/person&quot;);
146          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient(
147                  IClientConfig.Builder.newBuilder().withDefaultValues()
148                  .withMaxAutoRetries(1)
149                  .withMaxAutoRetriesNextServer(1).build());
150          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; response = observableClient.submit(request);
151          Person person = getPersonObservable(response).toBlocking().single();
152          assertEquals(EmbeddedResources.defaultPerson, person);
153          response = observableClient.submit(request);
154          person = getPersonObservable(response).toBlocking().single();
155          assertEquals(EmbeddedResources.defaultPerson, person);
156          final HttpClientListener listener = observableClient.getListener();
157          assertEquals(2, listener.getPoolAcquires());
158          waitUntilTrueOrTimeout(1000, new Func0&lt;Boolean&gt;() {
159              @Override
160              public Boolean call() {
161                  return listener.getPoolReleases() == 2;
162              }
163          });
164          assertEquals(1, listener.getConnectionCount());
165          assertEquals(1, listener.getPoolReuse());
166      }
167      @Test
168      public void testPostWithObservable() throws Exception {
169          Person myPerson = new Person(&quot;netty&quot;, 5);
170          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createPost(SERVICE_URI + &quot;testAsync/person&quot;)
171                  .withHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
172                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), myPerson, null));
173          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient(
174                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().set(CommonClientConfigKey.ReadTimeout, 10000));
175          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; response = observableClient.submit(new Server(host, port), request);
176          Person person = getPersonObservable(response).toBlocking().single();
177          assertEquals(myPerson, person);
178      }
179      @Test
180      public void testPostWithByteBuf() throws Exception {
181          Person myPerson = new Person(&quot;netty&quot;, 5);
182          ObjectMapper mapper = new ObjectMapper();
183          byte[] raw = mapper.writeValueAsBytes(myPerson);
184          ByteBuf buffer = Unpooled.copiedBuffer(raw);
185          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createPost(SERVICE_URI + &quot;testAsync/person&quot;)
186                  .withHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
187                  .withHeader(&quot;Content-length&quot;, String.valueOf(raw.length))
188                  .withContent(buffer);
189          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient(
190                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().set(CommonClientConfigKey.ReadTimeout, 10000));
191          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; response = observableClient.submit(request);
192          Person person = getPersonObservable(response).toBlocking().single();
193          assertEquals(myPerson, person);
194      }
195      @Test
196      public void testConnectTimeout() throws Exception {
197          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient(
198                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;1&quot;));
199          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;http:&amp;bsol;&amp;bsol;www.google.com:81/&quot;);
200          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; observable = observableClient.submit(new Server(&quot;www.google.com&quot;, 81), request);
201          ObserverWithLatch&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; observer = new ObserverWithLatch&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;();
202          observable.subscribe(observer);
203          observer.await();
204          assertNotNull(observer.error);
205          assertTrue(observer.error instanceof io.netty.channel.ConnectTimeoutException);
206      }
207      @Test
208      public void testReadTimeout() throws Exception {
209          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient(
210                  DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ReadTimeout, &quot;100&quot;));
211          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/readTimeout&quot;);
212          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; observable = observableClient.submit(request);
213          ObserverWithLatch&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; observer = new ObserverWithLatch&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;();
214          observable.subscribe(observer);
215          observer.await();
216          assertTrue(observer.error instanceof io.netty.handler.timeout.ReadTimeoutException);      
217      }
218      @Test
219      public void testObservableWithMultipleServers() throws Exception {
220          IClientConfig config = DefaultClientConfigImpl
221                  .getClientConfigWithDefaultValues()
222                  .withProperty(CommonClientConfigKey.ConnectTimeout, &quot;1000&quot;);
223          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
224          Server badServer = new Server(&quot;localhost:12345&quot;);
225          Server goodServer = new Server(&quot;localhost:&quot; + port);
226          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
227          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
228                  .withRule(new AvailabilityFilteringRule())
229                  .withPing(new DummyPing())
230                  .buildFixedServerListLoadBalancer(servers);
231          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config,
232                  new NettyHttpLoadBalancerErrorHandler(1, 3, true));
233          Person person = getPersonObservable(lbObservables.submit(request)).toBlocking().single();
234          assertEquals(EmbeddedResources.defaultPerson, person);
235          ServerStats stats = lbObservables.getServerStats(badServer);
236          assertEquals(4, stats.getTotalRequestsCount());
237          assertEquals(0, stats.getActiveRequestsCount());
238          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
239          stats = lbObservables.getServerStats(goodServer);
240          assertEquals(1, stats.getTotalRequestsCount());
241          assertEquals(0, stats.getActiveRequestsCount());
242          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
243          person = getPersonObservable(lbObservables.submit(request)).toBlocking().single();
244          assertEquals(EmbeddedResources.defaultPerson, person);
245          HttpClientListener listener = lbObservables.getListener();
246          assertEquals(1, listener.getPoolReuse());
247      }
248      @Test
249      public void testObservableWithMultipleServersWithOverrideRxConfig() throws Exception {
250          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;1000&quot;);
251          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
252          Server badServer = new Server(&quot;localhost:12345&quot;);
253          Server goodServer = new Server(&quot;localhost:&quot; + port);
254          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
255          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
256                  .withRule(new AvailabilityFilteringRule())
257                  .withPing(new DummyPing())
258                  .buildFixedServerListLoadBalancer(servers);
259          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config,
260                  new NettyHttpLoadBalancerErrorHandler(1, 3, true));
261          HttpClientConfig rxconfig = HttpClientConfig.Builder.newDefaultConfig();
262          Person person = getPersonObservable(lbObservables.submit(request, rxconfig)).toBlocking().single();
263          assertEquals(EmbeddedResources.defaultPerson, person);
264          ServerStats stats = lbObservables.getServerStats(badServer);
265          assertEquals(4, stats.getTotalRequestsCount());
266          assertEquals(0, stats.getActiveRequestsCount());
267          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
268          stats = lbObservables.getServerStats(goodServer);
269          assertEquals(1, stats.getTotalRequestsCount());
270          assertEquals(0, stats.getActiveRequestsCount());
271          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
272          final HttpClientListener listener = lbObservables.getListener();
273          assertEquals(1, listener.getConnectionCount());
274          waitUntilTrueOrTimeout(1000, new Func0&lt;Boolean&gt;() {
275              @Override
276              public Boolean call() {
277                  return listener.getPoolReleases() == 1;
278              }
279          });
280      }
281      @Test
282      public void testObservableWithRetrySameServer() throws Exception {
283          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues().withProperty(CommonClientConfigKey.ConnectTimeout, &quot;1000&quot;);
284          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
285          Server badServer = new Server(&quot;localhost:12345&quot;);
286          Server goodServer = new Server(&quot;localhost:&quot; + port);
287          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer, goodServer);
288          BaseLoadBalancer lb = LoadBalancerBuilder.&lt;Server&gt;newBuilder()
289                  .withRule(new AvailabilityFilteringRule())
290                  .withPing(new DummyPing())
291                  .buildFixedServerListLoadBalancer(servers);
292          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config,
293                  new NettyHttpLoadBalancerErrorHandler(1, 0, true));
294          Observable&lt;Person&gt; observableWithRetries = getPersonObservable(lbObservables.submit(request));
295          ObserverWithLatch&lt;Person&gt; observer = new ObserverWithLatch&lt;Person&gt;();
296          observableWithRetries.subscribe(observer);
297          observer.await();
298          assertNull(observer.obj);
299          assertTrue(observer.error instanceof ClientException);
300          ServerStats stats = lbObservables.getServerStats(badServer);
301          assertEquals(2, stats.getTotalRequestsCount());
302          assertEquals(0, stats.getActiveRequestsCount());
303          stats = lbObservables.getServerStats(goodServer);
304          assertEquals(0, stats.getTotalRequestsCount());
305      }
306      @Test
307      public void testLoadBalancingObservablesWithReadTimeout() throws Exception {
308          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
309          MockWebServer server = new MockWebServer();
310          String content = &quot;{\&quot;name\&quot;: \&quot;ribbon\&quot;, \&quot;age\&quot;: 2}&quot;;
311          server.enqueue(new MockResponse().setResponseCode(200).setHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
312                  .setBody(content));       
313          server.play();
314          IClientConfig config = DefaultClientConfigImpl
315                  .getClientConfigWithDefaultValues()
316                  .set(CommonClientConfigKey.ReadTimeout, 100);
317          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/readTimeout&quot;);
318          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
319          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
320          Server goodServer = new Server(&quot;localhost:&quot; + server.getPort());
321          Server badServer  = new Server(&quot;localhost:&quot; + port);
322          lb.setServersList(Lists.newArrayList(goodServer, badServer, badServer, goodServer));
323          Observable&lt;Person&gt; observableWithRetries = getPersonObservable(lbObservables.submit(request));
324          ObserverWithLatch&lt;Person&gt; observer = new ObserverWithLatch&lt;Person&gt;();
325          observableWithRetries.subscribe(observer);
326          observer.await();
327          if (observer.error != null) {
328              observer.error.printStackTrace();
329          }
330          assertEquals(&quot;ribbon&quot;, observer.obj.name);
331          assertEquals(2, observer.obj.age);
332          ServerStats stats = lbObservables.getServerStats(badServer);
333          server.shutdown();
334          final HttpClientListener listener = lbObservables.getListener();
335          waitUntilTrueOrTimeout(1000, new Func0&lt;Boolean&gt;() {
336              @Override
337              public Boolean call() {
338                  return listener.getPoolReleases() == 5;
339              }
340          });
341          assertEquals(0, listener.getPoolReuse());
342          assertEquals(4, stats.getTotalRequestsCount());
343          assertEquals(0, stats.getActiveRequestsCount());
344          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
345          stats = lbObservables.getServerStats(goodServer);
346          assertEquals(1, stats.getTotalRequestsCount());
347          assertEquals(0, stats.getActiveRequestsCount());
348          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
349      }
350      @Test
351      public void testLoadBalancingWithTwoServers() throws Exception {
352          MockWebServer server = new MockWebServer();
353          String content = &quot;{\&quot;name\&quot;: \&quot;ribbon\&quot;, \&quot;age\&quot;: 2}&quot;;
354          server.enqueue(new MockResponse().setResponseCode(200).setHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
355                  .setBody(content));       
356          server.play();
357          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues();
358          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createPost(&quot;/testAsync/person&quot;)
359                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
360                  .withHeader(&quot;Content-type&quot;, &quot;application/json&quot;);
361          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
362          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
363          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
364          HttpClientListener externalListener = HttpClientListener.newHttpListener(&quot;external&quot;);
365          lbObservables.subscribe(externalListener);
366          Server server1 = new Server(&quot;localhost:&quot; + server.getPort());
367          Server server2 = new Server(&quot;localhost:&quot; + port);
368          lb.setServersList(Lists.newArrayList(server1, server2));
369          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
370              @Override
371              public boolean isRetriableException(Throwable e, boolean sameServer) {
372                  return true;
373              }
374          };
375          Observable&lt;Person&gt; observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
376          ObserverWithLatch&lt;Person&gt; observer = new ObserverWithLatch&lt;Person&gt;();
377          observableWithRetries.subscribe(observer);
378          observer.await();
379          if (observer.error != null) {
380              observer.error.printStackTrace();
381          }
382          assertEquals(&quot;ribbon&quot;, observer.obj.name);
383          assertEquals(EmbeddedResources.defaultPerson.age, observer.obj.age);
384          observer = new ObserverWithLatch&lt;Person&gt;();
385          observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
386          observableWithRetries.subscribe(observer);
387          observer.await();
388          if (observer.error != null) {
389              observer.error.printStackTrace();
390          }
391          assertEquals(&quot;ribbon&quot;, observer.obj.name);
392          assertEquals(2, observer.obj.age);
393          ServerStats stats = lbObservables.getServerStats(server1);
394          server.shutdown();
395          assertEquals(0, stats.getActiveRequestsCount());
396          stats = lbObservables.getServerStats(server2);
397          assertEquals(1, stats.getTotalRequestsCount());
398          assertEquals(0, stats.getActiveRequestsCount());
399          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
400          final HttpClientListener listener = lbObservables.getListener();
401          assertEquals(2, listener.getPoolAcquires());
402          waitUntilTrueOrTimeout(1000, new Func0&lt;Boolean&gt;() {
403              @Override
404              public Boolean call() {
405                  return listener.getPoolReleases() == 2;
406              }
407          });
408          assertEquals(2, listener.getConnectionCount());
409          assertEquals(0, listener.getPoolReuse());
410          assertEquals(2, externalListener.getPoolAcquires());
411      }
412      @Test
413      public void testLoadBalancingPostWithReadTimeout() throws Exception {
414          MockWebServer server = new MockWebServer();
415          String content = &quot;{\&quot;name\&quot;: \&quot;ribbon\&quot;, \&quot;age\&quot;: 2}&quot;;
416          server.enqueue(new MockResponse()
417                  .setResponseCode(200)
418                  .setHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
419                  .setBody(content));       
420          server.play();
421          IClientConfig config = DefaultClientConfigImpl
422                  .getClientConfigWithDefaultValues()
423                  .set(CommonClientConfigKey.ReadTimeout, 100);
424          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createPost(&quot;/testAsync/postTimeout&quot;)
425                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
426                  .withHeader(&quot;Content-type&quot;, &quot;application/json&quot;);
427          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(1, 3, true);
428          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
429          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
430          Server goodServer = new Server(&quot;localhost:&quot; + server.getPort());
431          Server badServer = new Server(&quot;localhost:&quot; + port);
432          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
433          lb.setServersList(servers);
434          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
435              @Override
436              public boolean isRetriableException(Throwable e, boolean sameServer) {
437                  return true;
438              }
439          };
440          Observable&lt;Person&gt; observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
441          ObserverWithLatch&lt;Person&gt; observer = new ObserverWithLatch&lt;Person&gt;();
442          observableWithRetries.subscribe(observer);
443          observer.await();
444          if (observer.error != null) {
445              observer.error.printStackTrace();
446          }
447          assertEquals(&quot;ribbon&quot;, observer.obj.name);
448          assertEquals(2, observer.obj.age);
449          ServerStats stats = lbObservables.getServerStats(badServer);
450          server.shutdown();
451          assertEquals(4, stats.getTotalRequestsCount());
452          assertEquals(0, stats.getActiveRequestsCount());
453          assertEquals(4, stats.getSuccessiveConnectionFailureCount());
454          stats = lbObservables.getServerStats(goodServer);
455          assertEquals(1, stats.getTotalRequestsCount());
456          assertEquals(0, stats.getActiveRequestsCount());
457          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
458      }
459      @Test
460      public void testLoadBalancingPostWithNoRetrySameServer() throws Exception {
461          MockWebServer server = new MockWebServer();
462          String content = &quot;{\&quot;name\&quot;: \&quot;ribbon\&quot;, \&quot;age\&quot;: 2}&quot;;
463          server.enqueue(new MockResponse().setResponseCode(200).setHeader(&quot;Content-type&quot;, &quot;application/json&quot;)
464                  .setBody(content));       
465          server.play();
466          IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues()
467                  .set(CommonClientConfigKey.ReadTimeout, 100);
468          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createPost(&quot;/testAsync/postTimeout&quot;)
469                  .withContent(SerializationUtils.serializeToBytes(JacksonCodec.getInstance(), EmbeddedResources.defaultPerson, null))
470                  .withHeader(&quot;Content-type&quot;, &quot;application/json&quot;);
471          NettyHttpLoadBalancerErrorHandler errorHandler = new NettyHttpLoadBalancerErrorHandler(0, 3, true);
472          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
473          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config, errorHandler);
474          Server goodServer = new Server(&quot;localhost:&quot; + server.getPort());
475          Server badServer = new Server(&quot;localhost:&quot; + port);
476          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
477          lb.setServersList(servers);
478          RetryHandler handler = new RequestSpecificRetryHandler(true, true, errorHandler, null) {
479              @Override
480              public boolean isRetriableException(Throwable e, boolean sameServer) {
481                  return true;
482              }
483          };
484          Observable&lt;Person&gt; observableWithRetries = getPersonObservable(lbObservables.submit(request, handler, null));
485          ObserverWithLatch&lt;Person&gt; observer = new ObserverWithLatch&lt;Person&gt;();
486          observableWithRetries.subscribe(observer);
487          observer.await();
488          if (observer.error != null) {
489              observer.error.printStackTrace();
490          }
491          server.shutdown();
492          assertEquals(&quot;ribbon&quot;, observer.obj.name);
493          assertEquals(2, observer.obj.age);
494          ServerStats stats = lbObservables.getServerStats(badServer);
495          assertEquals(2, stats.getTotalRequestsCount());
496          assertEquals(0, stats.getActiveRequestsCount());
497          assertEquals(2, stats.getSuccessiveConnectionFailureCount());
498          stats = lbObservables.getServerStats(goodServer);
499          assertEquals(1, stats.getTotalRequestsCount());
500          assertEquals(0, stats.getActiveRequestsCount());
501          assertEquals(0, stats.getSuccessiveConnectionFailureCount());
502      }
503      @Test
504      public void testObservableWithMultipleServersFailed() throws Exception {        
505          IClientConfig config = IClientConfig.Builder.newBuilder()
506                  .withDefaultValues()
507                  .withRetryOnAllOperations(true)
508                  .withMaxAutoRetries(1)
509                  .withMaxAutoRetriesNextServer(3)
510                  .withConnectTimeout(100)
511                  .build();
512          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/person&quot;);
513          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());        
514          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config);
515          Server badServer = new Server(&quot;localhost:12345&quot;);
516          Server badServer1 = new Server(&quot;localhost:12346&quot;);
517          Server badServer2 = new Server(&quot;localhost:12347&quot;);
518          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer1, badServer2);
519          lb.setServersList(servers);
520          Observable&lt;Person&gt; observableWithRetries = getPersonObservable(lbObservables.submit(request));
521          ObserverWithLatch&lt;Person&gt; observer = new ObserverWithLatch&lt;Person&gt;();
522          observableWithRetries.subscribe(observer);
523          observer.await();
524          assertNull(observer.obj);
525          observer.error.printStackTrace();
526          assertTrue(observer.error instanceof ClientException);
527          ServerStats stats = lbObservables.getServerStats(badServer);
528          assertEquals(2, stats.getTotalRequestsCount());
529          assertEquals(0, stats.getActiveRequestsCount());
530          assertEquals(2, stats.getSuccessiveConnectionFailureCount());
531      }
532      private static List&lt;Person&gt; getPersonListFromResponse(Observable&lt;HttpClientResponse&lt;ServerSentEvent&gt;&gt; response) {
533          return getPersonList(transformSSE(response));
534      }
535      private static List&lt;Person&gt; getPersonList(Observable&lt;ServerSentEvent&gt; events) {
536          List&lt;Person&gt; result = Lists.newArrayList();
537          Iterator&lt;Person&gt; iterator = events.map(new Func1&lt;ServerSentEvent, Person&gt;() {
538              @Override
539              public Person call(ServerSentEvent t1) {
540                  String content = t1.getEventData();
541                  try {
542                      return SerializationUtils.deserializeFromString(JacksonCodec.&lt;Person&gt;getInstance(), content, TypeDef.fromClass(Person.class));
543                  } catch (IOException e) {
544                      e.printStackTrace();
545                      return null;
546                  }
547              }
548          }).toBlocking().getIterator();
549          while (iterator.hasNext()) {
550              result.add(iterator.next());
551          }
552          return result;
553      }
554      @Test
555      public void testStream() throws Exception {
556          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/personStream&quot;);
557          LoadBalancingHttpClient&lt;ByteBuf, ServerSentEvent&gt; observableClient = (LoadBalancingHttpClient&lt;ByteBuf, ServerSentEvent&gt;) RibbonTransport.newSSEClient();
558          List&lt;Person&gt; result = getPersonListFromResponse(observableClient.submit(new Server(host, port), request));
559          assertEquals(EmbeddedResources.entityStream, result);
560      }
561      @Test
562      public void testStreamWithLoadBalancer() throws Exception {
563          IClientConfig config = IClientConfig.Builder.newBuilder().withRetryOnAllOperations(true)
564                  .withMaxAutoRetries(1)
565                  .withMaxAutoRetriesNextServer(3)
566                  .build();
567          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());
568          LoadBalancingHttpClient&lt;ByteBuf, ServerSentEvent&gt; lbObservables = (LoadBalancingHttpClient&lt;ByteBuf, ServerSentEvent&gt;) RibbonTransport.newSSEClient(lb, config);
569          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/personStream&quot;);
570          List&lt;Person&gt; result = Lists.newArrayList();
571          Server goodServer = new Server(&quot;localhost:&quot; + port);
572          Server badServer = new Server(&quot;localhost:12245&quot;);
573          List&lt;Server&gt; servers = Lists.newArrayList(badServer, badServer, badServer, goodServer);
574          lb.setServersList(servers);
575          result = getPersonListFromResponse(lbObservables.submit(request, null, null));
576          assertEquals(EmbeddedResources.entityStream, result);
577      }
578      @Test
579      public void testQuery() throws Exception {
580          Person myPerson = new Person(&quot;hello_world&quot;, 4);
581          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/personQuery?name=&quot; + myPerson.name + &quot;&amp;age=&quot; + myPerson.age);
582          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient();
583          Person person = getPersonObservable(observableClient.submit(new Server(host, port), request)).toBlocking().single();
584          assertEquals(myPerson, person);
585      }
586      @Test
587      public void testUnexpectedResponse() throws Exception {
588          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/throttle&quot;);
589          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; client = RibbonTransport.newHttpClient();
590          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; responseObservable = client.submit(new Server(host, port), request);
591          final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
592          final CountDownLatch latch = new CountDownLatch(1);
593          responseObservable.subscribe(new Action1&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;() {
594              @Override
595              public void call(HttpClientResponse&lt;ByteBuf&gt; t1) {
596                  latch.countDown();
597              }
598          }, new Action1&lt;Throwable&gt;(){
599              @Override
600              public void call(Throwable t1) {
601                  error.set(t1);
602                  latch.countDown();
603              }
604          });
605          latch.await();
606          assertTrue(error.get() instanceof ClientException);
607          ClientException ce = (ClientException) error.get();
608          assertTrue(ce.getErrorType() == ClientException.ErrorType.SERVER_THROTTLED);
609      }
610      @Test
611      public void testLoadBalancerThrottle() throws Exception {
612          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(&quot;/testAsync/throttle&quot;);
613          IClientConfig config = DefaultClientConfigImpl
614                  .getClientConfigWithDefaultValues()
615                  .set(IClientConfigKey.Keys.MaxAutoRetriesNextServer, 1)
616                  .set(IClientConfigKey.Keys.OkToRetryOnAllOperations, true);
617          BaseLoadBalancer lb = new BaseLoadBalancer(new DummyPing(), new AvailabilityFilteringRule());        
618          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; lbObservables = RibbonTransport.newHttpClient(lb, config);
619          Server server = new Server(host, port);
620          lb.setServersList(Lists.newArrayList(server, server, server));
621          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; response = lbObservables.submit(request);
622          final CountDownLatch latch = new CountDownLatch(1);
623          final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();
624          response.subscribe(new Action1&lt;HttpClientResponse&lt;ByteBuf&gt;&gt;() {
625              @Override
626              public void call(HttpClientResponse&lt;ByteBuf&gt; t1) {
627                  System.err.println(&quot;Get response: &quot; + t1.getStatus().code());
628                  latch.countDown();
629              }
630          }, new Action1&lt;Throwable&gt;(){
631              @Override
632              public void call(Throwable t1) {
633                  error.set(t1);
<span onclick='openModal()' class='match'>634                  latch.countDown();
635              }
636          }, new Action0() {
637              @Override
638              public void call() {
639                  Thread.dumpStack();
</span>640                  latch.countDown();
641              }
642          });
643          latch.await();
644          assertTrue(error.get() instanceof ClientException);
645          ClientException ce = (ClientException) error.get();
646          assertTrue(ce.toString(), ce.getErrorType() == ClientException.ErrorType.NUMBEROF_RETRIES_NEXTSERVER_EXCEEDED);
647          assertEquals(2, lbObservables.getServerStats(server).getSuccessiveConnectionFailureCount());
648      }
649      @Test
650      public void testContext() throws Exception {
651          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/context&quot;);
652          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient = RibbonTransport.newHttpClient();
653          String requestId = &quot;xyz&quot;;
654          ContextsContainerImpl contextsContainer = new ContextsContainerImpl(new MapBackedKeySupplier());
655          contextsContainer.addContext(&quot;Context1&quot;, &quot;value1&quot;);
656          RxContexts.DEFAULT_CORRELATOR.onNewServerRequest(requestId, contextsContainer);
657          Observable&lt;HttpClientResponse&lt;ByteBuf&gt;&gt; response = observableClient.submit(new Server(host, port), request);
658          final AtomicReference&lt;ContextsContainer&gt; responseContext = new AtomicReference&lt;ContextsContainer&gt;(); 
659          String requestIdSent = response.flatMap(new Func1&lt;HttpClientResponse&lt;ByteBuf&gt;, Observable&lt;ByteBuf&gt;&gt;() {
660              @Override
661              public Observable&lt;ByteBuf&gt; call(HttpClientResponse&lt;ByteBuf&gt; t1) {
662                  return t1.getContent();
663              }
664          }).map(new Func1&lt;ByteBuf, String&gt;() {
665              @Override
666              public String call(ByteBuf t1) {
667                  String requestId = RxContexts.DEFAULT_CORRELATOR.getRequestIdForClientRequest();
668                  responseContext.set(RxContexts.DEFAULT_CORRELATOR.getContextForClientRequest(requestId));
669                  return t1.toString(Charset.defaultCharset());
670              }
671          }).toBlocking().single();
672          assertEquals(requestId, requestIdSent);
673          assertEquals(&quot;value1&quot;, responseContext.get().getContext(&quot;Context1&quot;));
674      }
675      @Test
676      @Ignore
677      public void testRedirect() throws Exception {
678          HttpClientRequest&lt;ByteBuf&gt; request = HttpClientRequest.createGet(SERVICE_URI + &quot;testAsync/redirect?port=&quot; + port);
679          LoadBalancingHttpClient&lt;ByteBuf, ByteBuf&gt; observableClient =
680                  RibbonTransport.newHttpClient(
681                          IClientConfig.Builder.newBuilder().withDefaultValues()
682                          .withFollowRedirects(true)
683                          .build());
684          Person person = getPersonObservable(observableClient.submit(new Server(host, port), request)).toBlocking().single();
685          assertEquals(EmbeddedResources.defaultPerson, person);
686      }     
687  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-RibbonTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-NettyClientTest.java</div>
                </div>
                <div class="column column_space"><pre><code>190                  latch.countDown();
191              }
192          }, 
193          new Action0() {
194              @Override
195              public void call() {
196              }
</pre></code></div>
                <div class="column column_space"><pre><code>634                  latch.countDown();
635              }
636          }, new Action0() {
637              @Override
638              public void call() {
639                  Thread.dumpStack();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    