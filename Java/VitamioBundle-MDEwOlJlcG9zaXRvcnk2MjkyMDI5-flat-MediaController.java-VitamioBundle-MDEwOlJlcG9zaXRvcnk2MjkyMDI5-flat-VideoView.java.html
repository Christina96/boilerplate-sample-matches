
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaController.java</h3>
            <pre><code>1  package io.vov.vitamio.widget;
2  import android.annotation.SuppressLint;
3  import android.annotation.TargetApi;
4  import android.content.Context;
5  import android.graphics.Rect;
6  import android.media.AudioManager;
7  import android.os.Build;
8  import android.os.Handler;
9  import android.os.Message;
10  import android.util.AttributeSet;
11  import android.view.Gravity;
12  import android.view.KeyEvent;
13  import android.view.LayoutInflater;
14  import android.view.MotionEvent;
15  import android.view.View;
16  import android.view.WindowManager;
17  import android.widget.FrameLayout;
18  import android.widget.ImageButton;
19  import android.widget.PopupWindow;
20  import android.widget.SeekBar;
21  import android.widget.SeekBar.OnSeekBarChangeListener;
22  import android.widget.TextView;
23  import java.lang.reflect.Method;
24  import io.vov.vitamio.utils.Log;
25  import io.vov.vitamio.utils.StringUtils;
26  public class MediaController extends FrameLayout {
27    private static final int sDefaultTimeout = 3000;
28    private static final int FADE_OUT = 1;
29    private static final int SHOW_PROGRESS = 2;
30    private MediaPlayerControl mPlayer;
31    private Context mContext;
32    private PopupWindow mWindow;
33    private int mAnimStyle;
34    private View mAnchor;
35    private View mRoot;
36    private SeekBar mProgress;
37    private TextView mEndTime, mCurrentTime;
38    private TextView mFileName;
39    private OutlineTextView mInfoView;
40    private String mTitle;
41    private long mDuration;
42    private boolean mShowing;
43    private boolean mDragging;
44    private boolean mInstantSeeking = false;
45    private boolean mFromXml = false;
46    private ImageButton mPauseButton;
47    private AudioManager mAM;
48    private OnShownListener mShownListener;
49    private OnHiddenListener mHiddenListener;
50    @SuppressLint("HandlerLeak")
<span onclick='openModal()' class='match'>51    private Handler mHandler = new Handler() {
52      @Override
53      public void handleMessage(Message msg) {
54        long pos;
</span>55        switch (msg.what) {
56          case FADE_OUT:
57            hide();
58            break;
59          case SHOW_PROGRESS:
60            pos = setProgress();
61            if (!mDragging && mShowing) {
62              msg = obtainMessage(SHOW_PROGRESS);
63              sendMessageDelayed(msg, 1000 - (pos % 1000));
64              updatePausePlay();
65            }
66            break;
67        }
68      }
69    };
70    private View.OnClickListener mPauseListener = new View.OnClickListener() {
71      public void onClick(View v) {
72        doPauseResume();
73        show(sDefaultTimeout);
74      }
75    };
76    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {
77      public void onStartTrackingTouch(SeekBar bar) {
78        mDragging = true;
79        show(3600000);
80        mHandler.removeMessages(SHOW_PROGRESS);
81        if (mInstantSeeking)
82          mAM.setStreamMute(AudioManager.STREAM_MUSIC, true);
83        if (mInfoView != null) {
84          mInfoView.setText("");
85          mInfoView.setVisibility(View.VISIBLE);
86        }
87      }
88      public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {
89        if (!fromuser)
90          return;
91        long newposition = (mDuration * progress) / 1000;
92        String time = StringUtils.generateTime(newposition);
93        if (mInstantSeeking)
94          mPlayer.seekTo(newposition);
95        if (mInfoView != null)
96          mInfoView.setText(time);
97        if (mCurrentTime != null)
98          mCurrentTime.setText(time);
99      }
100      public void onStopTrackingTouch(SeekBar bar) {
101        if (!mInstantSeeking)
102          mPlayer.seekTo((mDuration * bar.getProgress()) / 1000);
103        if (mInfoView != null) {
104          mInfoView.setText("");
105          mInfoView.setVisibility(View.GONE);
106        }
107        show(sDefaultTimeout);
108        mHandler.removeMessages(SHOW_PROGRESS);
109        mAM.setStreamMute(AudioManager.STREAM_MUSIC, false);
110        mDragging = false;
111        mHandler.sendEmptyMessageDelayed(SHOW_PROGRESS, 1000);
112      }
113    };
114    public MediaController(Context context, AttributeSet attrs) {
115      super(context, attrs);
116      mRoot = this;
117      mFromXml = true;
118      initController(context);
119    }
120    public MediaController(Context context) {
121      super(context);
122      if (!mFromXml && initController(context))
123        initFloatingWindow();
124    }
125    private boolean initController(Context context) {
126      mContext = context;
127      mAM = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
128      return true;
129    }
130    @Override
131    public void onFinishInflate() {
132      if (mRoot != null)
133        initControllerView(mRoot);
134    }
135    private void initFloatingWindow() {
136      mWindow = new PopupWindow(mContext);
137      mWindow.setFocusable(false);
138      mWindow.setBackgroundDrawable(null);
139      mWindow.setOutsideTouchable(true);
140      mAnimStyle = android.R.style.Animation;
141    }
142    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
143  	public void setWindowLayoutType() {
144  		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
145  			try {
146  				mAnchor.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
147  				Method setWindowLayoutType = PopupWindow.class.getMethod("setWindowLayoutType", new Class[] { int.class });
148  				setWindowLayoutType.invoke(mWindow, WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG);
149  			} catch (Exception e) {
150  				Log.e("setWindowLayoutType", e);
151  			}
152  		}
153  	}
154    public void setAnchorView(View view) {
155      mAnchor = view;
156      if (!mFromXml) {
157        removeAllViews();
158        mRoot = makeControllerView();
159        mWindow.setContentView(mRoot);
160        mWindow.setWidth(LayoutParams.MATCH_PARENT);
161        mWindow.setHeight(LayoutParams.WRAP_CONTENT);
162      }
163      initControllerView(mRoot);
164    }
165    protected View makeControllerView() {
166      return ((LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE)).inflate(getResources().getIdentifier("mediacontroller", "layout", mContext.getPackageName()), this);
167    }
168    private void initControllerView(View v) {
169      mPauseButton = (ImageButton) v.findViewById(getResources().getIdentifier("mediacontroller_play_pause", "id", mContext.getPackageName()));
170      if (mPauseButton != null) {
171        mPauseButton.requestFocus();
172        mPauseButton.setOnClickListener(mPauseListener);
173      }
174      mProgress = (SeekBar) v.findViewById(getResources().getIdentifier("mediacontroller_seekbar", "id", mContext.getPackageName()));
175      if (mProgress != null) {
176        if (mProgress instanceof SeekBar) {
177          SeekBar seeker = (SeekBar) mProgress;
178          seeker.setOnSeekBarChangeListener(mSeekListener);
179        }
180        mProgress.setMax(1000);
181      }
182      mEndTime = (TextView) v.findViewById(getResources().getIdentifier("mediacontroller_time_total", "id", mContext.getPackageName()));
183      mCurrentTime = (TextView) v.findViewById(getResources().getIdentifier("mediacontroller_time_current", "id", mContext.getPackageName()));
184      mFileName = (TextView) v.findViewById(getResources().getIdentifier("mediacontroller_file_name", "id", mContext.getPackageName()));
185      if (mFileName != null)
186        mFileName.setText(mTitle);
187    }
188    public void setMediaPlayer(MediaPlayerControl player) {
189      mPlayer = player;
190      updatePausePlay();
191    }
192    public void setInstantSeeking(boolean seekWhenDragging) {
193      mInstantSeeking = seekWhenDragging;
194    }
195    public void show() {
196      show(sDefaultTimeout);
197    }
198    public void setFileName(String name) {
199      mTitle = name;
200      if (mFileName != null)
201        mFileName.setText(mTitle);
202    }
203    public void setInfoView(OutlineTextView v) {
204      mInfoView = v;
205    }
206    public void setAnimationStyle(int animationStyle) {
207      mAnimStyle = animationStyle;
208    }
209    public void show(int timeout) {
210      if (!mShowing && mAnchor != null && mAnchor.getWindowToken() != null) {
211        if (mPauseButton != null)
212          mPauseButton.requestFocus();
213        if (mFromXml) {
214          setVisibility(View.VISIBLE);
215        } else {
216          int[] location = new int[2];
217          mAnchor.getLocationOnScreen(location);
218          Rect anchorRect = new Rect(location[0], location[1], location[0] + mAnchor.getWidth(), location[1] + mAnchor.getHeight());
219          mWindow.setAnimationStyle(mAnimStyle);
220          setWindowLayoutType();
221          mWindow.showAtLocation(mAnchor, Gravity.NO_GRAVITY, anchorRect.left, anchorRect.bottom);
222        }
223        mShowing = true;
224        if (mShownListener != null)
225          mShownListener.onShown();
226      }
227      updatePausePlay();
228      mHandler.sendEmptyMessage(SHOW_PROGRESS);
229      if (timeout != 0) {
230        mHandler.removeMessages(FADE_OUT);
231        mHandler.sendMessageDelayed(mHandler.obtainMessage(FADE_OUT), timeout);
232      }
233    }
234    public boolean isShowing() {
235      return mShowing;
236    }
237    public void hide() {
238      if (mAnchor == null)
239        return;
240      if (mShowing) {
241        try {
242          mHandler.removeMessages(SHOW_PROGRESS);
243          if (mFromXml)
244            setVisibility(View.GONE);
245          else
246            mWindow.dismiss();
247        } catch (IllegalArgumentException ex) {
248          Log.d("MediaController already removed");
249        }
250        mShowing = false;
251        if (mHiddenListener != null)
252          mHiddenListener.onHidden();
253      }
254    }
255    public void setOnShownListener(OnShownListener l) {
256      mShownListener = l;
257    }
258    public void setOnHiddenListener(OnHiddenListener l) {
259      mHiddenListener = l;
260    }
261    private long setProgress() {
262      if (mPlayer == null || mDragging)
263        return 0;
264      long position = mPlayer.getCurrentPosition();
265      long duration = mPlayer.getDuration();
266      if (mProgress != null) {
267        if (duration > 0) {
268          long pos = 1000L * position / duration;
269          mProgress.setProgress((int) pos);
270        }
271        int percent = mPlayer.getBufferPercentage();
272        mProgress.setSecondaryProgress(percent * 10);
273      }
274      mDuration = duration;
275      if (mEndTime != null)
276        mEndTime.setText(StringUtils.generateTime(mDuration));
277      if (mCurrentTime != null)
278        mCurrentTime.setText(StringUtils.generateTime(position));
279      return position;
280    }
281    @Override
282    public boolean onTouchEvent(MotionEvent event) {
283      show(sDefaultTimeout);
284      return true;
285    }
286    @Override
287    public boolean onTrackballEvent(MotionEvent ev) {
288      show(sDefaultTimeout);
289      return false;
290    }
291    @Override
292    public boolean dispatchKeyEvent(KeyEvent event) {
293      int keyCode = event.getKeyCode();
294      if (event.getRepeatCount() == 0 && (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE || keyCode == KeyEvent.KEYCODE_SPACE)) {
295        doPauseResume();
296        show(sDefaultTimeout);
297        if (mPauseButton != null)
298          mPauseButton.requestFocus();
299        return true;
300      } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP) {
301        if (mPlayer.isPlaying()) {
302          mPlayer.pause();
303          updatePausePlay();
304        }
305        return true;
306      } else if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU) {
307        hide();
308        return true;
309      } else {
310        show(sDefaultTimeout);
311      }
312      return super.dispatchKeyEvent(event);
313    }
314    private void updatePausePlay() {
315      if (mRoot == null || mPauseButton == null)
316        return;
317      if (mPlayer.isPlaying())
318        mPauseButton.setImageResource(getResources().getIdentifier("mediacontroller_pause", "drawable", mContext.getPackageName()));
319      else
320        mPauseButton.setImageResource(getResources().getIdentifier("mediacontroller_play", "drawable", mContext.getPackageName()));
321    }
322    private void doPauseResume() {
323      if (mPlayer.isPlaying())
324        mPlayer.pause();
325      else
326        mPlayer.start();
327      updatePausePlay();
328    }
329    @Override
330    public void setEnabled(boolean enabled) {
331      if (mPauseButton != null)
332        mPauseButton.setEnabled(enabled);
333      if (mProgress != null)
334        mProgress.setEnabled(enabled);
335      super.setEnabled(enabled);
336    }
337    public interface OnShownListener {
338      public void onShown();
339    }
340    public interface OnHiddenListener {
341      public void onHidden();
342    }
343    public interface MediaPlayerControl {
344      void start();
345      void pause();
346      long getDuration();
347      long getCurrentPosition();
348      void seekTo(long pos);
349      boolean isPlaying();
350      int getBufferPercentage();
351    }
352  }
</code></pre>
        </div>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-VideoView.java</h3>
            <pre><code>1  package io.vov.vitamio.widget;
2  import android.app.Activity;
3  import android.app.AlertDialog;
4  import android.content.Context;
5  import android.content.DialogInterface;
6  import android.content.Intent;
7  import android.graphics.PixelFormat;
8  import android.media.AudioManager;
9  import android.net.Uri;
10  import android.os.Build;
11  import android.util.AttributeSet;
12  import android.util.Pair;
13  import android.util.SparseArray;
14  import android.view.KeyEvent;
15  import android.view.MotionEvent;
16  import android.view.SurfaceHolder;
17  import android.view.SurfaceView;
18  import android.view.View;
19  import android.view.ViewGroup;
20  import android.view.ViewGroup.LayoutParams;
21  import io.vov.vitamio.MediaFormat;
22  import io.vov.vitamio.MediaPlayer;
23  import io.vov.vitamio.MediaPlayer.OnBufferingUpdateListener;
24  import io.vov.vitamio.MediaPlayer.OnCompletionListener;
25  import io.vov.vitamio.MediaPlayer.OnErrorListener;
26  import io.vov.vitamio.MediaPlayer.OnInfoListener;
27  import io.vov.vitamio.MediaPlayer.OnPreparedListener;
28  import io.vov.vitamio.MediaPlayer.OnSeekCompleteListener;
29  import io.vov.vitamio.MediaPlayer.OnTimedTextListener;
30  import io.vov.vitamio.MediaPlayer.OnVideoSizeChangedListener;
31  import io.vov.vitamio.MediaPlayer.TrackInfo;
32  import io.vov.vitamio.Vitamio;
33  import io.vov.vitamio.utils.Log;
34  import io.vov.vitamio.utils.ScreenResolution;
35  import java.io.IOException;
36  import java.util.List;
37  import java.util.Map;
38  public class VideoView extends SurfaceView implements MediaController.MediaPlayerControl {
39    public static final int VIDEO_LAYOUT_ORIGIN = 0;
40    public static final int VIDEO_LAYOUT_SCALE = 1;
41    public static final int VIDEO_LAYOUT_STRETCH = 2;
42    public static final int VIDEO_LAYOUT_ZOOM = 3;
43    public static final int VIDEO_LAYOUT_FIT_PARENT = 4;
44    private static final int STATE_ERROR = -1;
45    private static final int STATE_IDLE = 0;
46    private static final int STATE_PREPARING = 1;
47    private static final int STATE_PREPARED = 2;
48    private static final int STATE_PLAYING = 3;
49    private static final int STATE_PAUSED = 4;
50    private static final int STATE_PLAYBACK_COMPLETED = 5;
51    private static final int STATE_SUSPEND = 6;
52    private static final int STATE_RESUME = 7;
53    private static final int STATE_SUSPEND_UNSUPPORTED = 8;
54    OnVideoSizeChangedListener mSizeChangedListener = new OnVideoSizeChangedListener() {
55      public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
56        Log.d("onVideoSizeChanged: (%dx%d)", width, height);
57        mVideoWidth = mp.getVideoWidth();
58        mVideoHeight = mp.getVideoHeight();
59        mVideoAspectRatio = mp.getVideoAspectRatio();
60        if (mVideoWidth != 0 && mVideoHeight != 0)
61          setVideoLayout(mVideoLayout, mAspectRatio);
62      }
63    };
64    OnPreparedListener mPreparedListener = new OnPreparedListener() {
65      public void onPrepared(MediaPlayer mp) {
66        Log.d("onPrepared");
67        mCurrentState = STATE_PREPARED;
68        if (mOnPreparedListener != null)
69          mOnPreparedListener.onPrepared(mMediaPlayer);
70        if (mMediaController != null)
71          mMediaController.setEnabled(true);
72        mVideoWidth = mp.getVideoWidth();
73        mVideoHeight = mp.getVideoHeight();
74        mVideoAspectRatio = mp.getVideoAspectRatio();
75        long seekToPosition = mSeekWhenPrepared;
76        if (seekToPosition != 0)
77          seekTo(seekToPosition);
78        if (mVideoWidth != 0 && mVideoHeight != 0) {
79          setVideoLayout(mVideoLayout, mAspectRatio);
80          if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
81            if (mTargetState == STATE_PLAYING) {
82              start();
83              if (mMediaController != null)
84                mMediaController.show();
85            } else if (!isPlaying() && (seekToPosition != 0 || getCurrentPosition() > 0)) {
86              if (mMediaController != null)
87                mMediaController.show(0);
88            }
89          }
90        } else if (mTargetState == STATE_PLAYING) {
91          start();
92        }
93      }
94    };
95    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback() {
96      public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
97        mSurfaceWidth = w;
98        mSurfaceHeight = h;
99        boolean isValidState = (mTargetState == STATE_PLAYING);
100        boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
101        if (mMediaPlayer != null && isValidState && hasValidSize) {
102          if (mSeekWhenPrepared != 0)
103            seekTo(mSeekWhenPrepared);
104          start();
105          if (mMediaController != null) {
106            if (mMediaController.isShowing())
107              mMediaController.hide();
108            mMediaController.show();
109          }
110        }
111      }
112      public void surfaceCreated(SurfaceHolder holder) {
113        mSurfaceHolder = holder;
114        if (mMediaPlayer != null && mCurrentState == STATE_SUSPEND && mTargetState == STATE_RESUME) {
115          mMediaPlayer.setDisplay(mSurfaceHolder);
116          resume();
117        } else {
118          openVideo();
119        }
120      }
121      public void surfaceDestroyed(SurfaceHolder holder) {
122        mSurfaceHolder = null;
123        if (mMediaController != null) mMediaController.hide();
124        release(true);
125      }
126    };
127    private Uri mUri;
128    private long mDuration;
129    private int mCurrentState = STATE_IDLE;
130    private int mTargetState = STATE_IDLE;
131    private float mAspectRatio = 0;
132    private int mVideoLayout = VIDEO_LAYOUT_SCALE;
133    private SurfaceHolder mSurfaceHolder = null;
134    private MediaPlayer mMediaPlayer = null;
135    private int mVideoWidth;
136    private int mVideoHeight;
137    private float mVideoAspectRatio;
138    private int mVideoChroma = MediaPlayer.VIDEOCHROMA_RGBA;
139    private boolean mHardwareDecoder = false;
140    private int mSurfaceWidth;
141    private int mSurfaceHeight;
142    private MediaController mMediaController;
143    private View mMediaBufferingIndicator;
144    private OnCompletionListener mOnCompletionListener;
145    private OnPreparedListener mOnPreparedListener;
146    private OnErrorListener mOnErrorListener;
147    private OnSeekCompleteListener mOnSeekCompleteListener;
148    private OnTimedTextListener mOnTimedTextListener;
149    private OnInfoListener mOnInfoListener;
150    private OnBufferingUpdateListener mOnBufferingUpdateListener;
151    private int mCurrentBufferPercentage;
152    private long mSeekWhenPrepared; 
153    private Context mContext;
154    private Map<String, String> mHeaders;
155    private int mBufSize;
156    private OnCompletionListener mCompletionListener = new OnCompletionListener() {
157      public void onCompletion(MediaPlayer mp) {
158        Log.d("onCompletion");
159        mCurrentState = STATE_PLAYBACK_COMPLETED;
160        mTargetState = STATE_PLAYBACK_COMPLETED;
161        if (mMediaController != null)
162          mMediaController.hide();
163        if (mOnCompletionListener != null)
164          mOnCompletionListener.onCompletion(mMediaPlayer);
165      }
166    };
167    private OnErrorListener mErrorListener = new OnErrorListener() {
168      public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
169        Log.d("Error: %d, %d", framework_err, impl_err);
170        mCurrentState = STATE_ERROR;
171        mTargetState = STATE_ERROR;
172        if (mMediaController != null)
173          mMediaController.hide();
174        if (mOnErrorListener != null) {
175          if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err))
176            return true;
177        }
178        if (getWindowToken() != null) {
179          int message = framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK ? getResources().getIdentifier("VideoView_error_text_invalid_progressive_playback", "string", mContext.getPackageName()): getResources().getIdentifier("VideoView_error_text_unknown", "string", mContext.getPackageName());
180          new AlertDialog.Builder(mContext).setTitle(getResources().getIdentifier("VideoView_error_title", "string", mContext.getPackageName())).setMessage(message).setPositiveButton(getResources().getIdentifier("VideoView_error_button", "string", mContext.getPackageName()), new DialogInterface.OnClickListener() {
181            public void onClick(DialogInterface dialog, int whichButton) {
182              if (mOnCompletionListener != null)
183                mOnCompletionListener.onCompletion(mMediaPlayer);
184            }
185          }).setCancelable(false).show();
186        }
187        return true;
188      }
189    };
190    private OnBufferingUpdateListener mBufferingUpdateListener = new OnBufferingUpdateListener() {
191      public void onBufferingUpdate(MediaPlayer mp, int percent) {
192        mCurrentBufferPercentage = percent;
193        if (mOnBufferingUpdateListener != null)
194          mOnBufferingUpdateListener.onBufferingUpdate(mp, percent);
195      }
196    };
197    private OnInfoListener mInfoListener = new OnInfoListener() {
198      @Override
199      public boolean onInfo(MediaPlayer mp, int what, int extra) {
200        Log.d("onInfo: (%d, %d)", what, extra);
201        if (mOnInfoListener != null) {
202          mOnInfoListener.onInfo(mp, what, extra);
203        } else if (mMediaPlayer != null) {
204          if (what == MediaPlayer.MEDIA_INFO_BUFFERING_START) {
205            mMediaPlayer.pause();
206            if (mMediaBufferingIndicator != null)
207              mMediaBufferingIndicator.setVisibility(View.VISIBLE);
208          } else if (what == MediaPlayer.MEDIA_INFO_BUFFERING_END) {
209            mMediaPlayer.start();
210            if (mMediaBufferingIndicator != null)
211              mMediaBufferingIndicator.setVisibility(View.GONE);
212          }
213        }
214        return true;
215      }
216    };
<span onclick='openModal()' class='match'>217    private OnSeekCompleteListener mSeekCompleteListener = new OnSeekCompleteListener() {
218      @Override
219      public void onSeekComplete(MediaPlayer mp) {
220        Log.d("onSeekComplete");
</span>221        if (mOnSeekCompleteListener != null)
222          mOnSeekCompleteListener.onSeekComplete(mp);
223      }
224    };
225    private OnTimedTextListener mTimedTextListener = new OnTimedTextListener() {
226      @Override
227      public void onTimedTextUpdate(byte[] pixels, int width, int height) {
228        Log.i("onSubtitleUpdate: bitmap subtitle, %dx%d", width, height);
229        if (mOnTimedTextListener != null)
230          mOnTimedTextListener.onTimedTextUpdate(pixels, width, height);
231      }
232      @Override
233      public void onTimedText(String text) {
234        Log.i("onSubtitleUpdate: %s", text);
235        if (mOnTimedTextListener != null)
236          mOnTimedTextListener.onTimedText(text);
237      }
238    };
239    public VideoView(Context context) {
240      super(context);
241      initVideoView(context);
242    }
243    public VideoView(Context context, AttributeSet attrs) {
244      this(context, attrs, 0);
245      initVideoView(context);
246    }
247    public VideoView(Context context, AttributeSet attrs, int defStyle) {
248      super(context, attrs, defStyle);
249      initVideoView(context);
250    }
251    @Override
252    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
253      int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
254      int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
255      setMeasuredDimension(width, height);
256    }
257    public void setVideoLayout(int layout, float aspectRatio) {
258      LayoutParams lp = getLayoutParams();
259      Pair<Integer, Integer> res = ScreenResolution.getResolution(mContext);
260      int windowWidth = res.first.intValue(), windowHeight = res.second.intValue();
261      float windowRatio = windowWidth / (float) windowHeight;
262      float videoRatio = aspectRatio <= 0.01f ? mVideoAspectRatio : aspectRatio;
263      mSurfaceHeight = mVideoHeight;
264      mSurfaceWidth = mVideoWidth;
265      if (VIDEO_LAYOUT_ORIGIN == layout && mSurfaceWidth < windowWidth && mSurfaceHeight < windowHeight) {
266        lp.width = (int) (mSurfaceHeight * videoRatio);
267        lp.height = mSurfaceHeight;
268      } else if (layout == VIDEO_LAYOUT_ZOOM) {
269        lp.width = windowRatio > videoRatio ? windowWidth : (int) (videoRatio * windowHeight);
270        lp.height = windowRatio < videoRatio ? windowHeight : (int) (windowWidth / videoRatio);
271      } else if (layout == VIDEO_LAYOUT_FIT_PARENT) {
272        ViewGroup parent = (ViewGroup) getParent();
273        float parentRatio = ((float) parent.getWidth()) / ((float) parent.getHeight());
274        lp.width = (parentRatio < videoRatio) ? parent.getWidth() : Math.round(((float) parent.getHeight()) * videoRatio);
275        lp.height = (parentRatio > videoRatio) ? parent.getHeight() : Math.round(((float) parent.getWidth()) / videoRatio);
276      } else {
277        boolean full = layout == VIDEO_LAYOUT_STRETCH;
278        lp.width = (full || windowRatio < videoRatio) ? windowWidth : (int) (videoRatio * windowHeight);
279        lp.height = (full || windowRatio > videoRatio) ? windowHeight : (int) (windowWidth / videoRatio);
280      }
281      setLayoutParams(lp);
282      getHolder().setFixedSize(mSurfaceWidth, mSurfaceHeight);
283      Log.d("VIDEO: %dx%dx%f, Surface: %dx%d, LP: %dx%d, Window: %dx%dx%f", mVideoWidth, mVideoHeight, mVideoAspectRatio, mSurfaceWidth, mSurfaceHeight, lp.width, lp.height, windowWidth, windowHeight, windowRatio);
284      mVideoLayout = layout;
285      mAspectRatio = aspectRatio;
286    }
287    @SuppressWarnings("deprecation")
288    private void initVideoView(Context ctx) {
289      mContext = ctx;
290      mVideoWidth = 0;
291      mVideoHeight = 0;
292      getHolder().setFormat(PixelFormat.RGBA_8888); 
293      getHolder().addCallback(mSHCallback);
294      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB && mHardwareDecoder) {
295        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
296      }
297      setFocusable(true);
298      setFocusableInTouchMode(true);
299      requestFocus();
300      mCurrentState = STATE_IDLE;
301      mTargetState = STATE_IDLE;
302      if (ctx instanceof Activity)
303        ((Activity) ctx).setVolumeControlStream(AudioManager.STREAM_MUSIC);
304    }
305    public boolean isValid() {
306      return (mSurfaceHolder != null && mSurfaceHolder.getSurface().isValid());
307    }
308    public void setVideoPath(String path) {
309      setVideoURI(Uri.parse(path));
310    }
311    public void setVideoURI(Uri uri) {
312      setVideoURI(uri, null);
313    }
314    public void setVideoURI(Uri uri, Map<String, String> headers) {
315      mUri = uri;
316      mHeaders = headers;
317      mSeekWhenPrepared = 0;
318      openVideo();
319      requestLayout();
320      invalidate();
321    }
322    public void stopPlayback() {
323      if (mMediaPlayer != null) {
324        mMediaPlayer.stop();
325        mMediaPlayer.release();
326        mMediaPlayer = null;
327        mCurrentState = STATE_IDLE;
328        mTargetState = STATE_IDLE;
329      }
330    }
331    private void openVideo() {
332      if (mUri == null || mSurfaceHolder == null || !Vitamio.isInitialized(mContext))
333        return;
334      Intent i = new Intent("com.android.music.musicservicecommand");
335      i.putExtra("command", "pause");
336      mContext.sendBroadcast(i);
337      release(false);
338      try {
339        mDuration = -1;
340        mCurrentBufferPercentage = 0;
341        mMediaPlayer = new MediaPlayer(mContext, mHardwareDecoder);
342        mMediaPlayer.setOnPreparedListener(mPreparedListener);
343        mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
344        mMediaPlayer.setOnCompletionListener(mCompletionListener);
345        mMediaPlayer.setOnErrorListener(mErrorListener);
346        mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
347        mMediaPlayer.setOnInfoListener(mInfoListener);
348        mMediaPlayer.setOnSeekCompleteListener(mSeekCompleteListener);
349        mMediaPlayer.setOnTimedTextListener(mTimedTextListener);
350        mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
351        mMediaPlayer.setDisplay(mSurfaceHolder);
352        mMediaPlayer.setBufferSize(mBufSize);
353        mMediaPlayer.setVideoChroma(mVideoChroma == MediaPlayer.VIDEOCHROMA_RGB565 ? MediaPlayer.VIDEOCHROMA_RGB565 : MediaPlayer.VIDEOCHROMA_RGBA);
354        mMediaPlayer.setScreenOnWhilePlaying(true);
355        mMediaPlayer.prepareAsync();
356        mCurrentState = STATE_PREPARING;
357        attachMediaController();
358      } catch (IOException ex) {
359        Log.e("Unable to open content: " + mUri, ex);
360        mCurrentState = STATE_ERROR;
361        mTargetState = STATE_ERROR;
362        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
363        return;
364      } catch (IllegalArgumentException ex) {
365        Log.e("Unable to open content: " + mUri, ex);
366        mCurrentState = STATE_ERROR;
367        mTargetState = STATE_ERROR;
368        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
369        return;
370      }
371    }
372    public void setMediaController(MediaController controller) {
373      if (mMediaController != null)
374        mMediaController.hide();
375      mMediaController = controller;
376      attachMediaController();
377    }
378    public void setMediaBufferingIndicator(View mediaBufferingIndicator) {
379      if (mMediaBufferingIndicator != null)
380        mMediaBufferingIndicator.setVisibility(View.GONE);
381      mMediaBufferingIndicator = mediaBufferingIndicator;
382    }
383    private void attachMediaController() {
384      if (mMediaPlayer != null && mMediaController != null) {
385        mMediaController.setMediaPlayer(this);
386        View anchorView = this.getParent() instanceof View ? (View) this.getParent() : this;
387        mMediaController.setAnchorView(anchorView);
388        mMediaController.setEnabled(isInPlaybackState());
389        if (mUri != null) {
390          List<String> paths = mUri.getPathSegments();
391          String name = paths == null || paths.isEmpty() ? "null" : paths.get(paths.size() - 1);
392          mMediaController.setFileName(name);
393        }
394      }
395    }
396    public void setOnPreparedListener(OnPreparedListener l) {
397      mOnPreparedListener = l;
398    }
399    public void setOnCompletionListener(OnCompletionListener l) {
400      mOnCompletionListener = l;
401    }
402    public void setOnErrorListener(OnErrorListener l) {
403      mOnErrorListener = l;
404    }
405    public void setOnBufferingUpdateListener(OnBufferingUpdateListener l) {
406      mOnBufferingUpdateListener = l;
407    }
408    public void setOnSeekCompleteListener(OnSeekCompleteListener l) {
409      mOnSeekCompleteListener = l;
410    }
411    public void setOnTimedTextListener(OnTimedTextListener l) {
412      mOnTimedTextListener = l;
413    }
414    public void setOnInfoListener(OnInfoListener l) {
415      mOnInfoListener = l;
416    }
417    private void release(boolean cleartargetstate) {
418      if (mMediaPlayer != null) {
419        mMediaPlayer.reset();
420        mMediaPlayer.release();
421        mMediaPlayer = null;
422        mCurrentState = STATE_IDLE;
423        if (cleartargetstate)
424          mTargetState = STATE_IDLE;
425      }
426    }
427    @Override
428    public boolean onTouchEvent(MotionEvent ev) {
429      if (isInPlaybackState() && mMediaController != null)
430        toggleMediaControlsVisiblity();
431      return false;
432    }
433    @Override
434    public boolean onTrackballEvent(MotionEvent ev) {
435      if (isInPlaybackState() && mMediaController != null)
436        toggleMediaControlsVisiblity();
437      return false;
438    }
439    @Override
440    public boolean onKeyDown(int keyCode, KeyEvent event) {
441      boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_MENU && keyCode != KeyEvent.KEYCODE_CALL && keyCode != KeyEvent.KEYCODE_ENDCALL;
442      if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
443        if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE || keyCode == KeyEvent.KEYCODE_SPACE) {
444          if (mMediaPlayer.isPlaying()) {
445            pause();
446            mMediaController.show();
447          } else {
448            start();
449            mMediaController.hide();
450          }
451          return true;
452        } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
453          if (!mMediaPlayer.isPlaying()) {
454              start();
455              mMediaController.hide();
456          }
457          return true;
458        } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
459          if (mMediaPlayer.isPlaying()) {
460            pause();
461            mMediaController.show();
462          }
463          return true;
464        } else {
465          toggleMediaControlsVisiblity();
466        }
467      }
468      return super.onKeyDown(keyCode, event);
469    }
470    private void toggleMediaControlsVisiblity() {
471      if (mMediaController.isShowing()) {
472        mMediaController.hide();
473      } else {
474        mMediaController.show();
475      }
476    }
477    public void start() {
478      if (isInPlaybackState()) {
479        mMediaPlayer.start();
480        mCurrentState = STATE_PLAYING;
481      }
482      mTargetState = STATE_PLAYING;
483    }
484    public void pause() {
485      if (isInPlaybackState()) {
486        if (mMediaPlayer.isPlaying()) {
487          mMediaPlayer.pause();
488          mCurrentState = STATE_PAUSED;
489        }
490      }
491      mTargetState = STATE_PAUSED;
492    }
493    public void suspend() {
494      if (isInPlaybackState()) {
495        release(false);
496        mCurrentState = STATE_SUSPEND_UNSUPPORTED;
497        Log.d("Unable to suspend video. Release MediaPlayer.");
498      }
499    }
500    public void resume() {
501      if (mSurfaceHolder == null && mCurrentState == STATE_SUSPEND) {
502        mTargetState = STATE_RESUME;
503      } else if (mCurrentState == STATE_SUSPEND_UNSUPPORTED) {
504        openVideo();
505      }
506    }
507    public long getDuration() {
508      if (isInPlaybackState()) {
509        if (mDuration > 0)
510          return mDuration;
511        mDuration = mMediaPlayer.getDuration();
512        return mDuration;
513      }
514      mDuration = -1;
515      return mDuration;
516    }
517    public long getCurrentPosition() {
518      if (isInPlaybackState())
519        return mMediaPlayer.getCurrentPosition();
520      return 0;
521    }
522    public void seekTo(long msec) {
523      if (isInPlaybackState()) {
524        mMediaPlayer.seekTo(msec);
525        mSeekWhenPrepared = 0;
526      } else {
527        mSeekWhenPrepared = msec;
528      }
529    }
530    public boolean isPlaying() {
531      return isInPlaybackState() && mMediaPlayer.isPlaying();
532    }
533    public int getBufferPercentage() {
534      if (mMediaPlayer != null)
535        return mCurrentBufferPercentage;
536      return 0;
537    }
538    public void setVolume(float leftVolume, float rightVolume) {
539      if (mMediaPlayer != null)
540        mMediaPlayer.setVolume(leftVolume, rightVolume);
541    }
542    public int getVideoWidth() {
543      return mVideoWidth;
544    }
545    public int getVideoHeight() {
546      return mVideoHeight;
547    }
548    public float getVideoAspectRatio() {
549      return mVideoAspectRatio;
550    }
551    public void setVideoChroma(int chroma) {
552      getHolder().setFormat(chroma == MediaPlayer.VIDEOCHROMA_RGB565 ? PixelFormat.RGB_565 : PixelFormat.RGBA_8888); 
553      mVideoChroma = chroma;
554    }
555    public void setHardwareDecoder(boolean hardware) {
556      mHardwareDecoder= hardware;
557    }
558    public void setVideoQuality(int quality) {
559      if (mMediaPlayer != null)
560        mMediaPlayer.setVideoQuality(quality);
561    }
562    public void setBufferSize(int bufSize) {
563      mBufSize = bufSize;
564    }
565    public boolean isBuffering() {
566      if (mMediaPlayer != null)
567        return mMediaPlayer.isBuffering();
568      return false;
569    }
570    public String getMetaEncoding() {
571      if (mMediaPlayer != null)
572        return mMediaPlayer.getMetaEncoding();
573      return null;
574    }
575    public void setMetaEncoding(String encoding) {
576      if (mMediaPlayer != null)
577        mMediaPlayer.setMetaEncoding(encoding);
578    }
579    public SparseArray<MediaFormat> getAudioTrackMap(String encoding) {
580      if (mMediaPlayer != null)
581        return mMediaPlayer.findTrackFromTrackInfo(TrackInfo.MEDIA_TRACK_TYPE_AUDIO, mMediaPlayer.getTrackInfo(encoding));
582      return null;
583    }
584    public int getAudioTrack() {
585      if (mMediaPlayer != null)
586        return mMediaPlayer.getAudioTrack();
587      return -1;
588    }
589    public void setAudioTrack(int audioIndex) {
590      if (mMediaPlayer != null)
591        mMediaPlayer.selectTrack(audioIndex);
592    }
593    public void setTimedTextShown(boolean shown) {
594      if (mMediaPlayer != null)
595        mMediaPlayer.setTimedTextShown(shown);
596    }
597    public void setTimedTextEncoding(String encoding) {
598      if (mMediaPlayer != null)
599        mMediaPlayer.setTimedTextEncoding(encoding);
600    }
601    public int getTimedTextLocation() {
602      if (mMediaPlayer != null)
603        return mMediaPlayer.getTimedTextLocation();
604      return -1;
605    }
606    public void addTimedTextSource(String subPath) {
607      if (mMediaPlayer != null)
608        mMediaPlayer.addTimedTextSource(subPath);
609    }
610    public String getTimedTextPath() {
611      if (mMediaPlayer != null)
612        return mMediaPlayer.getTimedTextPath();
613      return null;
614    }
615    public void setSubTrack(int trackId) {
616      if (mMediaPlayer != null)
617        mMediaPlayer.selectTrack(trackId);
618    }
619    public int getTimedTextTrack() {
620      if (mMediaPlayer != null)
621        return mMediaPlayer.getTimedTextTrack();
622      return -1;
623    }
624    public SparseArray<MediaFormat> getSubTrackMap(String encoding) {
625      if (mMediaPlayer != null)
626        return mMediaPlayer.findTrackFromTrackInfo(TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT, mMediaPlayer.getTrackInfo(encoding));
627      return null;
628    }
629    protected boolean isInPlaybackState() {
630      return (mMediaPlayer != null && mCurrentState != STATE_ERROR && mCurrentState != STATE_IDLE && mCurrentState != STATE_PREPARING);
631    }
632  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaController.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-VideoView.java</div>
                </div>
                <div class="column column_space"><pre><code>51    private Handler mHandler = new Handler() {
52      @Override
53      public void handleMessage(Message msg) {
54        long pos;
</pre></code></div>
                <div class="column column_space"><pre><code>217    private OnSeekCompleteListener mSeekCompleteListener = new OnSeekCompleteListener() {
218      @Override
219      public void onSeekComplete(MediaPlayer mp) {
220        Log.d("onSeekComplete");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    