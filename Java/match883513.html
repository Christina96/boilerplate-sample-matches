<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TcpTransportTests.java & CreateAlterTableStatementAnalyzerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TcpTransportTests.java & CreateAlterTableStatementAnalyzerTest.java
      </h3>
      <h1 align="center">
        17.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TcpTransportTests.java (37.979095%)<TH>CreateAlterTableStatementAnalyzerTest.java (11.173757%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#0',2,'match883513-1.html#0',3)" NAME="0">(20-56)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#0',2,'match883513-1.html#0',3)" NAME="0">(22-56)</A><TD ALIGN=center><FONT COLOR="#ff0000">34</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#1',2,'match883513-1.html#1',3)" NAME="1">(266-273)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#1',2,'match883513-1.html#1',3)" NAME="1">(1255-1261)</A><TD ALIGN=center><FONT COLOR="#610000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#2',2,'match883513-1.html#2',3)" NAME="2">(162-170)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#2',2,'match883513-1.html#2',3)" NAME="2">(514-520)</A><TD ALIGN=center><FONT COLOR="#610000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#3',2,'match883513-1.html#3',3)" NAME="3">(312-319)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#3',2,'match883513-1.html#3',3)" NAME="3">(1011-1019)</A><TD ALIGN=center><FONT COLOR="#5a0000">12</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#4',2,'match883513-1.html#4',3)" NAME="4">(82-87)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#4',2,'match883513-1.html#4',3)" NAME="4">(180-185)</A><TD ALIGN=center><FONT COLOR="#5a0000">12</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#5',2,'match883513-1.html#5',3)" NAME="5">(236-246)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#5',2,'match883513-1.html#5',3)" NAME="5">(737-747)</A><TD ALIGN=center><FONT COLOR="#520000">11</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#6',2,'match883513-1.html#6',3)" NAME="6">(225-234)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#6',2,'match883513-1.html#6',3)" NAME="6">(695-700)</A><TD ALIGN=center><FONT COLOR="#520000">11</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#7',2,'match883513-1.html#7',3)" NAME="7">(153-160)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#7',2,'match883513-1.html#7',3)" NAME="7">(592-596)</A><TD ALIGN=center><FONT COLOR="#520000">11</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#8',2,'match883513-1.html#8',3)" NAME="8">(143-151)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#8',2,'match883513-1.html#8',3)" NAME="8">(582-586)</A><TD ALIGN=center><FONT COLOR="#520000">11</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#9',2,'match883513-1.html#9',3)" NAME="9">(71-80)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#9',2,'match883513-1.html#9',3)" NAME="9">(1336-1343)</A><TD ALIGN=center><FONT COLOR="#520000">11</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#10',2,'match883513-1.html#10',3)" NAME="10">(62-71)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#10',2,'match883513-1.html#10',3)" NAME="10">(1326-1335)</A><TD ALIGN=center><FONT COLOR="#520000">11</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#11',2,'match883513-1.html#11',3)" NAME="11">(206-214)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#11',2,'match883513-1.html#11',3)" NAME="11">(247-254)</A><TD ALIGN=center><FONT COLOR="#4b0000">10</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#12',2,'match883513-1.html#12',3)" NAME="12">(136-141)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#12',2,'match883513-1.html#12',3)" NAME="12">(239-245)</A><TD ALIGN=center><FONT COLOR="#4b0000">10</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#13',2,'match883513-1.html#13',3)" NAME="13">(126-134)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#13',2,'match883513-1.html#13',3)" NAME="13">(233-237)</A><TD ALIGN=center><FONT COLOR="#4b0000">10</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#14',2,'match883513-1.html#14',3)" NAME="14">(100-107)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#14',2,'match883513-1.html#14',3)" NAME="14">(307-313)</A><TD ALIGN=center><FONT COLOR="#4b0000">10</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#15',2,'match883513-1.html#15',3)" NAME="15">(91-99)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#15',2,'match883513-1.html#15',3)" NAME="15">(293-299)</A><TD ALIGN=center><FONT COLOR="#4b0000">10</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#16',2,'match883513-1.html#16',3)" NAME="16">(254-257)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#16',2,'match883513-1.html#16',3)" NAME="16">(1234-1237)</A><TD ALIGN=center><FONT COLOR="#430000">9</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match883513-0.html#17',2,'match883513-1.html#17',3)" NAME="17">(216-223)<TD><A HREF="javascript:ZweiFrames('match883513-0.html#17',2,'match883513-1.html#17',3)" NAME="17">(195-200)</A><TD ALIGN=center><FONT COLOR="#430000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TcpTransportTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="0"></A> * under the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match883513-1.html#0',3,'match883513-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package org.elasticsearch.transport;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.Version;
import org.elasticsearch.action.support.PlainActionFuture;
import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.common.component.Lifecycle;
import org.elasticsearch.common.io.stream.BytesStreamOutput;
import org.elasticsearch.common.logging.Loggers;
import org.elasticsearch.common.network.NetworkService;
import org.elasticsearch.common.network.NetworkUtils;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.transport.TransportAddress;
import org.elasticsearch.common.util.BigArrays;
import org.elasticsearch.common.util.MockPageCacheRecycler;
import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
import org.elasticsearch.test.ESTestCase;
import org.elasticsearch.test.MockLogAppender;
import org.elasticsearch.test.junit.annotations.TestLogging;
import org.elasticsearch.threadpool.TestThreadPool;
import org.elasticsearch.threadpool.ThreadPool;
import org.hamcrest.Matcher;

import java.io.IOException;
import java.io.StreamCorruptedException;
import java.net.BindException;
import java.net.InetSocketAddress;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.ClosedChannelException;
import java.util.Collections;
import java.util.concurrent.TimeUnit;

import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.hamcrest.Matchers.nullValue;
import</B></FONT> static org.hamcrest.core.IsInstanceOf.instanceOf;

/** Unit tests for {@link TcpTransport} */
<A NAME="10"></A>public class TcpTransportTests extends ESTestCase {

    /** Test ipv4 host with a default port works */
    public void testParseV4DefaultPort() throws Exception <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match883513-1.html#10',3,'match883513-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        TransportAddress[] addresses = TcpTransport.parse(&quot;127.0.0.1&quot;, 1234);
        assertEquals(1, addresses.length);

        assertEquals(&quot;127.0.0.1&quot;, addresses[0].getAddress());
        assertEquals(1234, addresses[0].getPort());
<A NAME="9"></A>    }

    /** Test ipv4 host with port works */
    public void testPar</B></FONT>seV4WithPort() throws Exception <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match883513-1.html#9',3,'match883513-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        TransportAddress[] addresses = TcpTransport.parse(&quot;127.0.0.1:2345&quot;, 1234);
        assertEquals(1, addresses.length);

        assertEquals(&quot;127.0.0.1&quot;, addresses[0].getAddress());
        assertEquals(2345, addresses[0].getPort());
    }

<A NAME="4"></A>    /** Test unbracketed ipv6 hosts in configuration fail. Leave no ambiguity */
    public void testParseV</B></FONT>6UnBracketed() throws Exception {
        try {
            <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match883513-1.html#4',3,'match883513-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>TcpTransport.parse(&quot;::1&quot;, 1234);
            fail(&quot;should have gotten exception&quot;);
        } catch (IllegalArgumentException expected) {
            assertTrue(expected.getMessage().contains(&quot;must be bracketed&quot;));
        }
    }</B></FONT>
<A NAME="15"></A>
    /** Test ipv6 host with a default port works */
    public void testParseV6DefaultPort() throws Exception {
        <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match883513-1.html#15',3,'match883513-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>TransportAddress[] addresses = TcpTransport.parse(&quot;[::1]&quot;, 1234);
        assertEquals(1, addresses.length);

        assertEquals(&quot;::1&quot;, addresses[0].getAddress());
        assertEquals(1234, addresses[0].getPort());
    }
<A NAME="14"></A>
    /** Test ipv6 host with port works */
    public void testPar</B></FONT>seV6WithPort() throws Exception {
        <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match883513-1.html#14',3,'match883513-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>TransportAddress[] addresses = TcpTransport.parse(&quot;[::1]:2345&quot;, 1234);
        assertEquals(1, addresses.length);

        assertEquals(&quot;::1&quot;, addresses[0].getAddress());
        assertEquals(2345, addresses[0].getPort());
    }

    public void testRejec</B></FONT>tsPortRanges() {
        expectThrows(
            NumberFormatException.class,
            () -&gt; TcpTransport.parse(&quot;[::1]:100-200&quot;, 1000)
        );
    }

    public void testDefaultSeedAddressesWithDefaultPort() {
        final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
            containsInAnyOrder(
                &quot;[::1]:4300&quot;, &quot;[::1]:4301&quot;, &quot;[::1]:4302&quot;, &quot;[::1]:4303&quot;, &quot;[::1]:4304&quot;, &quot;[::1]:4305&quot;,
                &quot;127.0.0.1:4300&quot;, &quot;127.0.0.1:4301&quot;, &quot;127.0.0.1:4302&quot;, &quot;127.0.0.1:4303&quot;, &quot;127.0.0.1:4304&quot;, &quot;127.0.0.1:4305&quot;) :
            containsInAnyOrder(
                &quot;127.0.0.1:4300&quot;, &quot;127.0.0.1:4301&quot;, &quot;127.0.0.1:4302&quot;, &quot;127.0.0.1:4303&quot;, &quot;127.0.0.1:4304&quot;, &quot;127.0.0.1:4305&quot;);
        testDefaultSeedAddresses(Settings.EMPTY, seedAddressMatcher);
    }
<A NAME="13"></A>
    public void testDefaultSeedAddressesWithNonstandardGlobalPortRange() {
        final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
            <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match883513-1.html#13',3,'match883513-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>containsInAnyOrder(
                &quot;[::1]:4500&quot;, &quot;[::1]:4501&quot;, &quot;[::1]:4502&quot;, &quot;[::1]:4503&quot;, &quot;[::1]:4504&quot;, &quot;[::1]:4505&quot;,
                &quot;127.0.0.1:4500&quot;, &quot;127.0.0.1:4501&quot;, &quot;127.0.0.1:4502&quot;, &quot;127.0.0.1:4503&quot;, &quot;127.0.0.1:4504&quot;, &quot;127.0.0.1:4505&quot;) :
            containsInAnyOrder(
                &quot;127.0.0.1:4500&quot;, &quot;127.0.0.1:4501&quot;, &quot;127.0.0.1:4502&quot;, &quot;127.0.0.1:4503&quot;, &quot;127.0.0.1:4504&quot;, &quot;127.0.0.1:4505&quot;);
        testDefaultSeedAddresses(Settings.builder().put(TransportSettings.PORT.getKey(), &quot;4500-9600&quot;).build(), seedAddressMatcher);
    }
<A NAME="12"></A>
    public void testDefaultSeedAddressesWithSmallGlo</B></FONT>balPortRange() {
        final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
            <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match883513-1.html#12',3,'match883513-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>containsInAnyOrder(&quot;[::1]:4300&quot;, &quot;[::1]:4301&quot;, &quot;[::1]:4302&quot;, &quot;127.0.0.1:4300&quot;, &quot;127.0.0.1:4301&quot;, &quot;127.0.0.1:4302&quot;) :
            containsInAnyOrder(&quot;127.0.0.1:4300&quot;, &quot;127.0.0.1:4301&quot;, &quot;127.0.0.1:4302&quot;);
        testDefaultSeedAddresses(Settings.builder().put(TransportSettings.PORT.getKey(), &quot;4300-4302&quot;).build(), seedAddressMatcher);
    }
<A NAME="8"></A>
    public void testDefaultSeedAddressesWithNonstandardProf</B></FONT>ilePortRange() {
        final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
            <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match883513-1.html#8',3,'match883513-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>containsInAnyOrder(&quot;[::1]:4500&quot;, &quot;[::1]:4501&quot;, &quot;[::1]:4502&quot;, &quot;[::1]:4503&quot;, &quot;[::1]:4504&quot;, &quot;[::1]:4505&quot;,
                &quot;127.0.0.1:4500&quot;, &quot;127.0.0.1:4501&quot;, &quot;127.0.0.1:4502&quot;, &quot;127.0.0.1:4503&quot;, &quot;127.0.0.1:4504&quot;, &quot;127.0.0.1:4505&quot;) :
            containsInAnyOrder(&quot;127.0.0.1:4500&quot;, &quot;127.0.0.1:4501&quot;, &quot;127.0.0.1:4502&quot;, &quot;127.0.0.1:4503&quot;, &quot;127.0.0.1:4504&quot;, &quot;127.0.0.1:4505&quot;);
        testDefaultSeedAddresses(Settings.builder()
                .put(TransportSettings.PORT_PROFILE.getConcreteSettingForNamespace(TransportSettings.DEFAULT_PROFILE).getKey(), &quot;4500-9600&quot;)
                .build(), seedAddressMatcher);
    }
<A NAME="7"></A>
    public void testDefaultSeedAddressesWithSmallProf</B></FONT>ilePortRange() {
        final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
            <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match883513-1.html#7',3,'match883513-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>containsInAnyOrder(&quot;[::1]:4300&quot;, &quot;[::1]:4301&quot;, &quot;[::1]:4302&quot;, &quot;127.0.0.1:4300&quot;, &quot;127.0.0.1:4301&quot;, &quot;127.0.0.1:4302&quot;) :
            containsInAnyOrder(&quot;127.0.0.1:4300&quot;, &quot;127.0.0.1:4301&quot;, &quot;127.0.0.1:4302&quot;);
        testDefaultSeedAddresses(Settings.builder()
                .put(TransportSettings.PORT_PROFILE.getConcreteSettingForNamespace(TransportSettings.DEFAULT_PROFILE).getKey(), &quot;4300-4302&quot;)
                .build(), seedAddressMatcher);
    }
<A NAME="2"></A>
    public void testDefaultSeedAddressesPrefersProfileSettingToG</B></FONT>lobalSetting() {
        final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
            <FONT color="#980517"><A HREF="javascript:ZweiFrames('match883513-1.html#2',3,'match883513-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>containsInAnyOrder(&quot;[::1]:4300&quot;, &quot;[::1]:4301&quot;, &quot;[::1]:4302&quot;, &quot;127.0.0.1:4300&quot;, &quot;127.0.0.1:4301&quot;, &quot;127.0.0.1:4302&quot;) :
            containsInAnyOrder(&quot;127.0.0.1:4300&quot;, &quot;127.0.0.1:4301&quot;, &quot;127.0.0.1:4302&quot;);
        testDefaultSeedAddresses(Settings.builder()
                .put(TransportSettings.PORT_PROFILE.getConcreteSettingForNamespace(TransportSettings.DEFAULT_PROFILE).getKey(), &quot;4300-4302&quot;)
                .put(TransportSettings.PORT.getKey(), &quot;4500-9600&quot;)
                .build(), seedAddressMatcher);
    }

    public void testDefaultSeedAddressesWithNonstanda</B></FONT>rdSinglePort() {
        testDefaultSeedAddresses(Settings.builder().put(TransportSettings.PORT.getKey(), &quot;4500&quot;).build(),
            NetworkUtils.SUPPORTS_V6 ? containsInAnyOrder(&quot;[::1]:4500&quot;, &quot;127.0.0.1:4500&quot;) : containsInAnyOrder(&quot;127.0.0.1:4500&quot;));
    }

    private void testDefaultSeedAddresses(final Settings settings, Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressesMatcher) {
        final TestThreadPool testThreadPool = new TestThreadPool(&quot;test&quot;);
        try {
            final TcpTransport tcpTransport = new TcpTransport(settings, Version.CURRENT, testThreadPool,
                new MockPageCacheRecycler(settings),
                new NoneCircuitBreakerService(), writableRegistry(), new NetworkService(Collections.emptyList())) {

                @Override
                protected TcpServerChannel bind(String name, InetSocketAddress address) {
                    throw new UnsupportedOperationException();
                }

                @Override
                protected TcpChannel initiateChannel(DiscoveryNode node) {
                    throw new UnsupportedOperationException();
                }

                @Override
                protected void stopInternal() {
                    throw new UnsupportedOperationException();
                }
            };

            assertThat(tcpTransport.getDefaultSeedAddresses(), seedAddressesMatcher);
        } finally {
            testThreadPool.shutdown();
        }
    }
<A NAME="11"></A>
    public void testReadMessageLengthWithIncompleteHeader() throws IOException {
        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
        <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match883513-1.html#11',3,'match883513-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>streamOutput.write('E');
        streamOutput.write('S');
        streamOutput.write(1);
        streamOutput.write(1);

        assertEquals(-1, TcpTransport.readMessageLength(streamOutput.bytes()));
    }
<A NAME="17"></A>
    public void testReadPingM</B></FONT>essageLength() throws IOException {
        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
        <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match883513-1.html#17',3,'match883513-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>streamOutput.write('E');
        streamOutput.write('S');
        streamOutput.writeInt(-1);

        assertEquals(0, TcpTransport.readMessageLength(streamOutput.bytes()));
    }
<A NAME="6"></A>
    public void testReadPingMessageLengthWithStartOfS</B></FONT>econdMessage() throws IOException {
        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
        <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match883513-1.html#6',3,'match883513-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>streamOutput.write('E');
        streamOutput.write('S');
        streamOutput.writeInt(-1);
        streamOutput.write('E');
        streamOutput.write('S');

        assertEquals(0, TcpTransport.readMessageLength(streamOutput.bytes()));
    }
<A NAME="5"></A>
    public void testReadM</B></FONT>essageLength() throws IOException {
        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
        <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match883513-1.html#5',3,'match883513-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>streamOutput.write('E');
        streamOutput.write('S');
        streamOutput.writeInt(2);
        streamOutput.write('M');
        streamOutput.write('A');

        assertEquals(2, TcpTransport.readMessageLength(streamOutput.bytes()));

    }

    public void testI</B></FONT>nvalidLength() throws IOException {
        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
        streamOutput.write('E');
        streamOutput.write('S');
        streamOutput.writeInt(-2);
<A NAME="16"></A>        streamOutput.write('M');
        streamOutput.write('A');

        <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match883513-1.html#16',3,'match883513-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try {
            TcpTransport.readMessageLength(streamOutput.bytes());
            fail(&quot;Expected exception&quot;);
        } catch (Exception ex) {</B></FONT>
            assertThat(ex, instanceOf(StreamCorruptedException.class));
            assertEquals(&quot;invalid data length: -2&quot;, ex.getMessage());
        }
    }

<A NAME="1"></A>    public void testInvalidHeader() throws IOException {
        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
        streamOutput.write('E');
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match883513-1.html#1',3,'match883513-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>streamOutput.write('C');
        byte byte1 = randomByte();
        byte byte2 = randomByte();
        streamOutput.write(byte1);
        streamOutput.write(byte2);
        streamOutput.write(randomByte());
        streamOutput.write(randomByte());
        streamOutput.write(randomByte</B></FONT>());

        try {
            TcpTransport.readMessageLength(streamOutput.bytes());
            fail(&quot;Expected exception&quot;);
        } catch (Exception ex) {
            assertThat(ex, instanceOf(StreamCorruptedException.class));
            String expected = &quot;invalid internal transport message format, got (45,43,&quot;
                + Integer.toHexString(byte1 &amp; 0xFF) + &quot;,&quot;
                + Integer.toHexString(byte2 &amp; 0xFF) + &quot;)&quot;;
            assertEquals(expected, ex.getMessage());
        }
    }

    public void testHTTPRequest() throws IOException {
        String[] httpHeaders = {&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;HEAD&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;, &quot;PATCH&quot;, &quot;TRACE&quot;};

        for (String httpHeader : httpHeaders) {
            BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);

            for (char c : httpHeader.toCharArray()) {
                streamOutput.write((byte) c);
            }
            streamOutput.write(new byte[6]);

            try {
                TcpTransport.readMessageLength(streamOutput.bytes());
                fail(&quot;Expected exception&quot;);
            } catch (Exception ex) {
                assertThat(ex, instanceOf(TcpTransport.HttpRequestOnTransportException.class));
                assertEquals(&quot;This is not a HTTP port&quot;, ex.getMessage());
            }
        }
    }

    public void testTLSHeader() throws IOException {
<A NAME="3"></A>        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);

        streamOutput.write(0x16);
        <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match883513-1.html#3',3,'match883513-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>streamOutput.write(0x03);
        byte byte1 = randomByte();
        streamOutput.write(byte1);
        byte byte2 = randomByte();
        streamOutput.write(byte2);
        streamOutput.write(randomByte());
        streamOutput.write(randomByte());
        streamOutput.write</B></FONT>(randomByte());

        try {
            TcpTransport.readMessageLength(streamOutput.bytes());
            fail(&quot;Expected exception&quot;);
        } catch (Exception ex) {
            assertThat(ex, instanceOf(StreamCorruptedException.class));
            String expected = &quot;SSL/TLS request received but SSL/TLS is not enabled on this node, got (16,3,&quot;
                    + Integer.toHexString(byte1 &amp; 0xFF) + &quot;,&quot;
                    + Integer.toHexString(byte2 &amp; 0xFF) + &quot;)&quot;;
            assertEquals(expected, ex.getMessage());
        }
    }

    public void testHTTPResponse() throws IOException {
        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
        streamOutput.write('H');
        streamOutput.write('T');
        streamOutput.write('T');
        streamOutput.write('P');
        streamOutput.write(randomByte());
        streamOutput.write(randomByte());

        try {
            TcpTransport.readMessageLength(streamOutput.bytes());
            fail(&quot;Expected exception&quot;);
        } catch (Exception ex) {
            assertThat(ex, instanceOf(StreamCorruptedException.class));
            assertEquals(&quot;received HTTP response on transport port, ensure that transport port &quot; +
                    &quot;(not HTTP port) of a remote node is specified in the configuration&quot;, ex.getMessage());
        }
    }

    @TestLogging(value = &quot;org.elasticsearch.transport.TcpTransport:DEBUG&quot;)
    public void testExceptionHandling() throws IllegalAccessException {
        testExceptionHandling(false, new ElasticsearchException(&quot;simulated&quot;), true,
            new MockLogAppender.UnseenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;, Level.ERROR, &quot;*&quot;),
            new MockLogAppender.UnseenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;, Level.WARN, &quot;*&quot;),
            new MockLogAppender.UnseenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;, Level.INFO, &quot;*&quot;),
            new MockLogAppender.UnseenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;, Level.DEBUG, &quot;*&quot;));
        testExceptionHandling(new ElasticsearchException(&quot;simulated&quot;),
            new MockLogAppender.SeenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;,
                Level.WARN, &quot;exception caught on transport layer [*], closing connection&quot;));
        testExceptionHandling(new ClosedChannelException(),
            new MockLogAppender.SeenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;,
                Level.DEBUG, &quot;close connection exception caught on transport layer [*], disconnecting from relevant node&quot;));
        testExceptionHandling(new ElasticsearchException(&quot;Connection reset&quot;),
            new MockLogAppender.SeenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;,
                Level.DEBUG, &quot;close connection exception caught on transport layer [*], disconnecting from relevant node&quot;));
        testExceptionHandling(new BindException(),
            new MockLogAppender.SeenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;,
                Level.DEBUG, &quot;bind exception caught on transport layer [*]&quot;));
        testExceptionHandling(new CancelledKeyException(),
            new MockLogAppender.SeenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;,
                Level.DEBUG, &quot;cancelled key exception caught on transport layer [*], disconnecting from relevant node&quot;));
        testExceptionHandling(true, new TcpTransport.HttpRequestOnTransportException(&quot;test&quot;), false,
            new MockLogAppender.UnseenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;, Level.ERROR, &quot;*&quot;),
            new MockLogAppender.UnseenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;, Level.WARN, &quot;*&quot;),
            new MockLogAppender.UnseenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;, Level.INFO, &quot;*&quot;),
            new MockLogAppender.UnseenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;, Level.DEBUG, &quot;*&quot;));
        testExceptionHandling(new StreamCorruptedException(&quot;simulated&quot;),
            new MockLogAppender.SeenEventExpectation(&quot;message&quot;, &quot;org.elasticsearch.transport.TcpTransport&quot;,
                Level.WARN, &quot;simulated, [*], closing connection&quot;));
    }

    private void testExceptionHandling(Exception exception,
                                       MockLogAppender.LoggingExpectation... expectations) throws IllegalAccessException {
        testExceptionHandling(true, exception, true, expectations);
    }

    private void testExceptionHandling(boolean startTransport, Exception exception, boolean expectClosed,
                                       MockLogAppender.LoggingExpectation... expectations) throws IllegalAccessException {
        final TestThreadPool testThreadPool = new TestThreadPool(&quot;test&quot;);
        MockLogAppender appender = new MockLogAppender();

        try {
            appender.start();

            Loggers.addAppender(LogManager.getLogger(TcpTransport.class), appender);
            for (MockLogAppender.LoggingExpectation expectation : expectations) {
                appender.addExpectation(expectation);
            }

            final Lifecycle lifecycle = new Lifecycle();

            if (startTransport) {
                lifecycle.moveToStarted();
            }

            final FakeTcpChannel channel = new FakeTcpChannel();
            final PlainActionFuture&lt;Void&gt; listener = new PlainActionFuture&lt;&gt;();
            channel.addCloseListener(listener);

            var logger = Loggers.getLogger(TcpTransport.class);
            TcpTransport.handleException(logger, channel, exception, lifecycle,
                new OutboundHandler(randomAlphaOfLength(10), Version.CURRENT, new StatsTracker(), testThreadPool,
                    BigArrays.NON_RECYCLING_INSTANCE));

            if (expectClosed) {
                assertTrue(listener.isDone());
                assertThat(listener.actionGet(), nullValue());
            } else {
                assertFalse(listener.isDone());
            }

            appender.assertAllExpectationsMatched();

        } finally {
            Loggers.removeAppender(LogManager.getLogger(TcpTransport.class), appender);
            appender.stop();
            ThreadPool.terminate(testThreadPool, 30, TimeUnit.SECONDS);
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CreateAlterTableStatementAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#0',2,'match883513-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.crate.analyze;

import io.crate.common.collections.Maps;
import io.crate.data.RowN;
import io.crate.exceptions.ColumnUnknownException;
import io.crate.exceptions.InvalidColumnNameException;
import io.crate.exceptions.InvalidRelationName;
import io.crate.exceptions.InvalidSchemaNameException;
import io.crate.exceptions.OperationOnInaccessibleRelationException;
import io.crate.exceptions.RelationAlreadyExists;
import io.crate.exceptions.UnsupportedFeatureException;
import io.crate.metadata.ColumnIdent;
import io.crate.metadata.FulltextAnalyzerResolver;
import io.crate.metadata.RelationName;
import io.crate.metadata.Schemas;
import io.crate.planner.PlannerContext;
import io.crate.planner.node.ddl.AlterTableAddColumnPlan;
import io.crate.planner.node.ddl.AlterTableDropCheckConstraintPlan;
import io.crate.planner.node.ddl.AlterTablePlan;
import io.crate.planner.node.ddl.CreateBlobTablePlan;
import io.crate.planner.node.ddl.CreateTablePlan;
import io.crate.planner.operators.SubQueryResults;
import io.crate.sql.parser.ParsingException;
import io.crate.sql.tree.ColumnPolicy;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.types.DataTypes;
import org.elasticsearch.cluster.ClusterName;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.metadata.AutoExpandReplicas;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.Metadata;
import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;
import org.elasticsearch.cluster.routing.allocation.decider.MaxRetryAllocationDecider;
import</B></FONT> org.elasticsearch.common.Randomness;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.index.IndexSettings;
import org.elasticsearch.index.mapper.MapperService;
import org.elasticsearch.test.ClusterServiceUtils;
import org.hamcrest.Matchers;
import org.junit.Before;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static com.carrotsearch.randomizedtesting.RandomizedTest.$;
import static io.crate.metadata.FulltextAnalyzerResolver.CustomType.ANALYZER;
import static io.crate.testing.Asserts.assertThrowsMatches;
import static io.crate.testing.TestingHelpers.mapToSortedString;
import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_ROUTING_EXCLUDE_GROUP_SETTING;
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.isEmptyOrNullString;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.Matchers.startsWith;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class CreateAlterTableStatementAnalyzerTest extends CrateDummyClusterServiceUnitTest {

    private SQLExecutor e;
    private PlannerContext plannerContext;

    @Before
    public void prepare() throws IOException {
        String analyzerSettings = FulltextAnalyzerResolver.encodeSettings(
            Settings.builder().put(&quot;search&quot;, &quot;foobar&quot;).build()).utf8ToString();
        Metadata metadata = Metadata.builder()
            .persistentSettings(
                Settings.builder().put(ANALYZER.buildSettingName(&quot;ft_search&quot;), analyzerSettings).build())
            .build();
        ClusterState state = ClusterState.builder(ClusterName.DEFAULT)
            .metadata(metadata)
            .build();
        ClusterServiceUtils.setState(clusterService, state);
        e = SQLExecutor.builder(clusterService, 3, Randomness.get(), List.of())
            .enableDefaultTables()
            .build();
        plannerContext = e.getPlannerContext(clusterService.state());
    }

    private &lt;S&gt; S analyze(String stmt, Object... arguments) {
        return analyze(e, stmt, arguments);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;S&gt; S analyze(SQLExecutor e, String stmt, Object... arguments) {
        AnalyzedStatement analyzedStatement = e.analyze(stmt);
        if (analyzedStatement instanceof AnalyzedCreateTable) {
            return (S) CreateTablePlan.bind(
                (AnalyzedCreateTable) analyzedStatement,
                plannerContext.transactionContext(),
                plannerContext.nodeContext(),
                new RowN(arguments),
                SubQueryResults.EMPTY,
                new NumberOfShards(clusterService),
                e.schemas(),
                e.fulltextAnalyzerResolver()
            );
        } else if (analyzedStatement instanceof AnalyzedAlterTable) {
            return (S) AlterTablePlan.bind(
                (AnalyzedAlterTable) analyzedStatement,
                plannerContext.transactionContext(),
                plannerContext.nodeContext(),
                new RowN(arguments),
                SubQueryResults.EMPTY
            );
        } else if (analyzedStatement instanceof AnalyzedAlterTableAddColumn) {
            return (S) AlterTableAddColumnPlan.bind(
                (AnalyzedAlterTableAddColumn) analyzedStatement,
                plannerContext.transactionContext(),
                plannerContext.nodeContext(),
                new RowN(arguments),
                SubQueryResults.EMPTY,
                null
            );
        } else if (analyzedStatement instanceof AnalyzedAlterTableDropCheckConstraint) {
            return (S) AlterTableDropCheckConstraintPlan.bind(
                (AnalyzedAlterTableDropCheckConstraint) analyzedStatement
            );
        } else {
            return (S) analyzedStatement;
        }
    }

    @Test
    public void testTimestampDataTypeDeprecationWarning() {
        analyze(&quot;create table t (ts timestamp)&quot;);
        assertWarnings(
            &quot;Column [ts]: Usage of the `TIMESTAMP` data type as a timestamp with zone is deprecated,&quot; +
            &quot; use the `TIMESTAMPTZ` or `TIMESTAMP WITH TIME ZONE` data type instead.&quot;
        );
    }

    @Test
    public void test_cannot_create_table_that_contains_a_column_definition_of_type_time () {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot use the type `time with time zone` for column: ts&quot;);
        analyze(&quot;create table t (ts time with time zone)&quot;);
    }

    @Test
    public void test_cannot_alter_table_to_add_a_column_definition_of_type_time () {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot use the type `time with time zone` for column: ts&quot;);
        analyze(&quot;alter table user_refresh_interval add column ts time with time zone&quot;);
    }

    @Test
<A NAME="4"></A>    public void testCreateTableInSystemSchemasIsProhibited() {
        for (String schema : Schemas.READ_ONLY_SYSTEM_SCHEMAS) {
            try {
                analyze(<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#4',2,'match883513-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>String.format(&quot;CREATE TABLE %s.%s (ordinal INTEGER, name STRING)&quot;, schema, &quot;my_table&quot;));
                fail(&quot;create table in read-only schema must fail&quot;);
            } catch (IllegalArgumentException e) {
                assertThat(e.getLocalizedMessage(), startsWith(&quot;Cannot create relation in read-only schema: &quot; + schema));
            }
        }</B></FONT>
    }

    @Test
    public void testCreateTableWithAlternativePrimaryKeySyntax() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer, name string, primary key (id, name))&quot;
<A NAME="17"></A>        );

        String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
        <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#17',2,'match883513-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(primaryKeys.length, is(2));
        assertThat(primaryKeys[0], is(&quot;id&quot;));
        assertThat(primaryKeys[1], is(&quot;name&quot;));
    }

    @Test</B></FONT>
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testSimpleCreateTable() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, name string not null) &quot; +
            &quot;clustered into 3 shards with (number_of_replicas=0)&quot;);

        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;3&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is(&quot;0&quot;));

        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));

        assertNull(metaMapping.get(&quot;columns&quot;));

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();

        Map&lt;String, Object&gt; idMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;id&quot;);
        assertThat(idMapping.get(&quot;type&quot;), is(&quot;integer&quot;));

        Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;name&quot;);
        assertThat(nameMapping.get(&quot;type&quot;), is(&quot;keyword&quot;));

        String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
        assertThat(primaryKeys.length, is(1));
        assertThat(primaryKeys[0], is(&quot;id&quot;));

        String[] notNullColumns = analysis.notNullColumns().toArray(new String[0]);
        assertThat(notNullColumns.length, is(1));
        assertThat(notNullColumns[0], is(&quot;name&quot;));
    }
<A NAME="13"></A>
    @Test
    public void testCreateTableWithDefaultNumberOfShards() {
        BoundCreateTable analysis = <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#13',2,'match883513-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>analyze(&quot;create table foo (id integer primary key, name string)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;6&quot;));
    }
<A NAME="12"></A>
    @Test</B></FONT>
    public void testCreateTableWithDefaultNumberOfShardsWithClusterByClause() {
        BoundCreateTable analysis = <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#12',2,'match883513-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>analyze(
            &quot;create table foo (id integer primary key) clustered by (id)&quot;
        );
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;6&quot;));
    }
<A NAME="11"></A>
    @Test</B></FONT>
    public void testCreateTableNumberOfShardsProvidedInClusteredClause() {
        BoundCreateTable analysis = <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#11',2,'match883513-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>analyze(
            &quot;create table foo (id integer primary key) &quot; +
            &quot;clustered by (id) into 8 shards&quot;
        );
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;8&quot;));
    }

    @Test</B></FONT>
    public void testCreateTableWithTotalFieldsLimit() {
        BoundCreateTable analysis = analyze(
            &quot;CREATE TABLE foo (id int primary key) &quot; +
            &quot;with (\&quot;mapping.total_fields.limit\&quot;=5000)&quot;);
        assertThat(analysis.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()), is(&quot;5000&quot;));
    }

    @Test
    public void testCreateTableWithRefreshInterval() {
        BoundCreateTable analysis = analyze(
            &quot;CREATE TABLE foo (id int primary key, content string) &quot; +
            &quot;with (refresh_interval='5000ms')&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()), is(&quot;5s&quot;));
    }

    @Test
    public void testCreateTableWithNumberOfShardsOnWithClauseIsInvalid() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Invalid property \&quot;number_of_shards\&quot; passed to [ALTER | CREATE] TABLE statement&quot;);
        analyze(&quot;CREATE TABLE foo (id int primary key, content string) &quot; +
                &quot;with (number_of_shards=8)&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testCreateTableWithRefreshIntervalWrongNumberFormat() {
        analyze(&quot;CREATE TABLE foo (id int primary key, content string) &quot; +
                &quot;with (refresh_interval='1asdf')&quot;);
    }

    @Test
    public void testAlterTableWithRefreshInterval() {
        // alter t set
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE user_refresh_interval &quot; +
            &quot;SET (refresh_interval = '5000ms')&quot;);
<A NAME="15"></A>        assertEquals(&quot;5s&quot;, analysisSet.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()));

        // alter t reset
        <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#15',2,'match883513-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BoundAlterTable analysisReset = analyze(
            &quot;ALTER TABLE user_refresh_interval &quot; +
            &quot;RESET (refresh_interval)&quot;);
        assertEquals(&quot;1s&quot;, analysisReset.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()));
    }

    @Test</B></FONT>
    public void testTotalFieldsLimitCanBeUsedWithAlterTable() {
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE users &quot; +
            &quot;SET (\&quot;mapping.total_fields.limit\&quot; = '5000')&quot;);
<A NAME="14"></A>        assertEquals(&quot;5000&quot;, analysisSet.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()));

        // Check if resetting total_fields results in default value
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#14',2,'match883513-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>BoundAlterTable analysisReset = analyze(
            &quot;ALTER TABLE users &quot; +
            &quot;RESET (\&quot;mapping.total_fields.limit\&quot;)&quot;);
        assertEquals(&quot;1000&quot;, analysisReset.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()));
    }

    @Test</B></FONT>
    public void testAlterTableWithColumnPolicy() {
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE user_refresh_interval &quot; +
            &quot;SET (column_policy = 'strict')&quot;);
        assertEquals(
            ColumnPolicy.STRICT.lowerCaseName(),
            analysisSet.tableParameter().mappings().get(TableParameters.COLUMN_POLICY.getKey()));
    }

    @Test
    public void testAlterTableWithInvalidColumnPolicy() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Invalid value for argument 'column_policy'&quot;);
        analyze(&quot;ALTER TABLE user_refresh_interval &quot; +
                  &quot;SET (column_policy = 'ignored')&quot;);
    }

    @Test
    public void testAlterTableWithMaxNGramDiffSetting() {
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE users &quot; +
            &quot;SET (max_ngram_diff = 42)&quot;);
        assertThat(analysisSet.tableParameter().settings().get(IndexSettings.MAX_NGRAM_DIFF_SETTING.getKey()), is(&quot;42&quot;));
    }

    @Test
    public void testAlterTableWithMaxShingleDiffSetting() {
        BoundAlterTable analysisSet = analyze(
            &quot;ALTER TABLE users &quot; +
            &quot;SET (max_shingle_diff = 43)&quot;);
        assertThat(analysisSet.tableParameter().settings().get(IndexSettings.MAX_SHINGLE_DIFF_SETTING.getKey()), is(&quot;43&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithClusteredBy() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer, name string) clustered by(id)&quot;);

        Map&lt;String, Object&gt; meta = (Map) analysis.mapping().get(&quot;_meta&quot;);
        assertNotNull(meta);
        assertThat(meta.get(&quot;routing&quot;), is(&quot;id&quot;));
    }

    @Test(expected = IllegalArgumentException.class)
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithClusteredByNotInPrimaryKeys() {
        analyze(&quot;create table foo (id integer primary key, name string) clustered by(name)&quot;);
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithObjects() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details object as (name string, age integer))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;details&quot;);

        assertThat(details.get(&quot;type&quot;), is(&quot;object&quot;));
        assertThat(details.get(&quot;dynamic&quot;), is(&quot;true&quot;));

        Map&lt;String, Object&gt; detailsProperties = (Map&lt;String, Object&gt;) details.get(&quot;properties&quot;);
        Map&lt;String, Object&gt; nameProperties = (Map&lt;String, Object&gt;) detailsProperties.get(&quot;name&quot;);
        assertThat(nameProperties.get(&quot;type&quot;), is(&quot;keyword&quot;));

        Map&lt;String, Object&gt; ageProperties = (Map&lt;String, Object&gt;) detailsProperties.get(&quot;age&quot;);
        assertThat(ageProperties.get(&quot;type&quot;), is(&quot;integer&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithStrictObject() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details object(strict) as (name string, age integer))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;details&quot;);

        assertThat(details.get(&quot;type&quot;), is(&quot;object&quot;));
        assertThat(details.get(&quot;dynamic&quot;), is(&quot;strict&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithIgnoredObject()  {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details object(ignored))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;details&quot;);

        assertThat(details.get(&quot;type&quot;), is(&quot;object&quot;));
        assertThat(details.get(&quot;dynamic&quot;), is(&quot;false&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithSubscriptInFulltextIndexDefinition() {
        BoundCreateTable analysis = analyze(
            &quot;create table my_table1g (&quot; +
            &quot;   title string, &quot; +
            &quot;   author object(dynamic) as ( &quot; +
            &quot;   name string, &quot; +
            &quot;   birthday timestamp with time zone&quot; +
            &quot;), &quot; +
            &quot;INDEX author_title_ft using fulltext(title, author['name']))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;author&quot;);
        Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) ((Map&lt;String, Object&gt;) details.get(&quot;properties&quot;)).get(&quot;name&quot;);

        assertThat(((List&lt;String&gt;) nameMapping.get(&quot;copy_to&quot;)).get(0), is(&quot;author_title_ft&quot;));
    }

    @Test(expected = ColumnUnknownException.class)
    public void testCreateTableWithInvalidFulltextIndexDefinition() {
        analyze(
            &quot;create table my_table1g (&quot; +
            &quot;   title string, &quot; +
            &quot;   author object(dynamic) as ( &quot; +
            &quot;   name string, &quot; +
            &quot;   birthday timestamp with time zone&quot; +
            &quot;), &quot; +
            &quot;INDEX author_title_ft using fulltext(title, author['name']['foo']['bla']))&quot;);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableWithArray() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details array(string), more_details text[])&quot;);
        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;details&quot;);
        assertThat(details.get(&quot;type&quot;), is(&quot;array&quot;));
        Map&lt;String, Object&gt; inner = (Map&lt;String, Object&gt;) details.get(&quot;inner&quot;);
        assertThat(inner.get(&quot;type&quot;), is(&quot;keyword&quot;));


        Map&lt;String, Object&gt; moreDetails = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;more_details&quot;);
        assertThat(moreDetails.get(&quot;type&quot;), is(&quot;array&quot;));
        Map&lt;String, Object&gt; moreDetailsInner = (Map&lt;String, Object&gt;) details.get(&quot;inner&quot;);
        assertThat(moreDetailsInner.get(&quot;type&quot;), is(&quot;keyword&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithObjectsArray() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, details array(object as (name string, age integer, tags array(string))))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;details={inner={dynamic=true, position=2, properties={age={position=4, type=integer}, &quot; +
                      &quot;name={position=3, type=keyword}, &quot; +
                      &quot;tags={inner={position=5, type=keyword}, type=array}}, type=object}, type=array}, &quot; +
                      &quot;id={position=1, type=integer}&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithAnalyzer() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, content string INDEX using fulltext with (analyzer='german'))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content&quot;);

        assertThat(contentMapping.get(&quot;index&quot;), nullValue());
        assertThat(contentMapping.get(&quot;analyzer&quot;), is(&quot;german&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithAnalyzerParameter() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, content string INDEX using fulltext with (analyzer=?))&quot;,
            &quot;german&quot;
        );

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content&quot;);

        assertThat(contentMapping.get(&quot;index&quot;), nullValue());
        assertThat(contentMapping.get(&quot;analyzer&quot;), is(&quot;german&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void textCreateTableWithCustomAnalyzerInNestedColumn() {
        BoundCreateTable analysis = analyze(
            &quot;create table ft_search (&quot; +
            &quot;\&quot;user\&quot; object (strict) as (&quot; +
            &quot;name string index using fulltext with (analyzer='ft_search') &quot; +
            &quot;)&quot; +
            &quot;)&quot;);
        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
<A NAME="2"></A>        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;user&quot;);
        Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) ((Map&lt;String, Object&gt;) details.get(&quot;properties&quot;)).get(&quot;name&quot;);

        assertThat(<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#2',2,'match883513-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>nameMapping.get(&quot;index&quot;), nullValue());
        assertThat(nameMapping.get(&quot;analyzer&quot;), is(&quot;ft_search&quot;));

        assertThat(analysis.tableParameter().settings().get(&quot;search&quot;), is(&quot;foobar&quot;));
    }

    @Test</B></FONT>
    public void testCreateTableWithSchemaName() {
        BoundCreateTable analysis =
            analyze(&quot;create table something.foo (id integer primary key)&quot;);
        RelationName relationName = analysis.tableIdent();
        assertThat(relationName.schema(), is(&quot;something&quot;));
        assertThat(relationName.name(), is(&quot;foo&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithIndexColumn() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, content string, INDEX content_ft using fulltext (content))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content&quot;);

        assertThat((String) contentMapping.get(&quot;index&quot;), isEmptyOrNullString());
        assertThat(((List&lt;String&gt;) contentMapping.get(&quot;copy_to&quot;)).get(0), is(&quot;content_ft&quot;));

        Map&lt;String, Object&gt; ft_mapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content_ft&quot;);
        assertThat(ft_mapping.get(&quot;index&quot;), nullValue());
        assertThat(ft_mapping.get(&quot;analyzer&quot;), is(&quot;standard&quot;));
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCreateTableWithPlainIndexColumn() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, content string, INDEX content_ft using plain (content))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content&quot;);

        assertThat((String) contentMapping.get(&quot;index&quot;), isEmptyOrNullString());
        assertThat(((List&lt;String&gt;) contentMapping.get(&quot;copy_to&quot;)).get(0), is(&quot;content_ft&quot;));

        Map&lt;String, Object&gt; ft_mapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;content_ft&quot;);
        assertThat(ft_mapping.get(&quot;index&quot;), nullValue());
        assertThat(ft_mapping.get(&quot;analyzer&quot;), is(&quot;keyword&quot;));
    }

    @Test
    public void testCreateTableWithIndexColumnOverNonString() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;INDEX definition only support 'string' typed source columns&quot;);
        analyze(&quot;create table foo (id integer, id2 integer, INDEX id_ft using fulltext (id, id2))&quot;);
    }

    @Test
    public void testCreateTableWithIndexColumnOverNonString2() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;INDEX definition only support 'string' typed source columns&quot;);
        analyze(&quot;create table foo (id integer, name string, INDEX id_ft using fulltext (id, name))&quot;);
    }

    @Test
    public void testChangeNumberOfReplicas() {
<A NAME="8"></A>        BoundAlterTable analysis =
            analyze(&quot;alter table users set (number_of_replicas=2)&quot;);

        assertThat(<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#8',2,'match883513-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is(&quot;2&quot;));
    }

    @Test</B></FONT>
    public void testResetNumberOfReplicas() {
        BoundAlterTable analysis =
<A NAME="7"></A>            analyze(&quot;alter table users reset (number_of_replicas)&quot;);

        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#7',2,'match883513-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is(&quot;0&quot;));
        assertThat(analysis.tableParameter().settings().get(AutoExpandReplicas.SETTING.getKey()), is(&quot;0-1&quot;));
    }

    @Test(expected = IllegalArgumentE</B></FONT>xception.class)
    public void testAlterTableWithInvalidProperty() {
        analyze(&quot;alter table users set (foobar='2')&quot;);
    }

    @Test
    public void testAlterSystemTable() {
        expectedException.expect(OperationOnInaccessibleRelationException.class);
        expectedException.expectMessage(&quot;The relation \&quot;sys.shards\&quot; doesn't support or allow ALTER &quot; +
                                        &quot;operations, as it is read-only.&quot;);
        analyze(&quot;alter table sys.shards reset (number_of_replicas)&quot;);
    }

    @Test
    public void testCreateTableWithMultiplePrimaryKeys() {
        BoundCreateTable analysis = analyze(
            &quot;create table test (id integer primary key, name string primary key)&quot;);

        String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
        assertThat(primaryKeys.length, is(2));
        assertThat(primaryKeys[0], is(&quot;id&quot;));
        assertThat(primaryKeys[1], is(&quot;name&quot;));
    }

    @Test
    public void testCreateTableWithMultiplePrimaryKeysAndClusteredBy() {
        BoundCreateTable analysis = analyze(
            &quot;create table test (id integer primary key, name string primary key) &quot; +
            &quot;clustered by(name)&quot;);

        String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
        assertThat(primaryKeys.length, is(2));
        assertThat(primaryKeys[0], is(&quot;id&quot;));
        assertThat(primaryKeys[1], is(&quot;name&quot;));

        //noinspection unchecked
        Map&lt;String, Object&gt; meta = (Map) analysis.mapping().get(&quot;_meta&quot;);
        assertNotNull(meta);
        assertThat(meta.get(&quot;routing&quot;), is(&quot;name&quot;));

    }

    @Test
    public void testCreateTableWithObjectAndUnderscoreColumnPrefix() {
        BoundCreateTable analysis = analyze(&quot;create table test (o object as (_id integer), name string)&quot;);

        assertThat(analysis.analyzedTableElements().columns().size(), is(2)); // id pk column is also added
        AnalyzedColumnDefinition&lt;Object&gt; column = analysis.analyzedTableElements().columns().get(0);
        assertEquals(column.ident(), new ColumnIdent(&quot;o&quot;));
        assertThat(column.children().size(), is(1));
        AnalyzedColumnDefinition&lt;Object&gt; xColumn = column.children().get(0);
        assertEquals(xColumn.ident(), new ColumnIdent(&quot;o&quot;, Collections.singletonList(&quot;_id&quot;)));
    }

    @Test(expected = InvalidColumnNameException.class)
    public void testCreateTableWithUnderscoreColumnPrefix() {
        analyze(&quot;create table test (_id integer, name string)&quot;);
    }

    @Test(expected = ParsingException.class)
    public void testCreateTableWithColumnDot() {
        analyze(&quot;create table test (dot.column integer)&quot;);
    }

    @Test(expected = InvalidRelationName.class)
    public void testCreateTableIllegalTableName() {
        analyze(&quot;create table \&quot;abc.def\&quot; (id integer primary key, name string)&quot;);
    }

    @Test
    public void testTableStartWithUnderscore() {
        expectedException.expect(InvalidRelationName.class);
        expectedException.expectMessage(&quot;Relation name \&quot;doc._invalid\&quot; is invalid.&quot;);
        analyze(&quot;create table _invalid (id integer primary key)&quot;);
    }

    @Test
    public void testHasColumnDefinition() {
        BoundCreateTable analysis = analyze(
            &quot;create table my_table (&quot; +
            &quot;  id integer primary key, &quot; +
            &quot;  name string, &quot; +
            &quot;  indexed string index using fulltext with (analyzer='german'),&quot; +
            &quot;  arr array(object as(&quot; +
            &quot;    nested float,&quot; +
            &quot;    nested_object object as (id byte)&quot; +
            &quot;  )),&quot; +
            &quot;  obj object as ( content string ),&quot; +
            &quot;  index ft using fulltext(name, obj['content']) with (analyzer='standard')&quot; +
            &quot;)&quot;);
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;id&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;name&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;indexed&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;arr&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;arr.nested&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;arr.nested_object.id&quot;)));
<A NAME="6"></A>        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;obj&quot;)));
        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;obj.content&quot;)));

        assertFalse(<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#6',2,'match883513-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;arr.nested.wrong&quot;)));
        assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;ft&quot;)));
        assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath(&quot;obj.content.ft&quot;)));
    }

    @Test</B></FONT>
    public void testCreateTableWithGeoPoint() {
        BoundCreateTable analyze = analyze(
            &quot;create table geo_point_table (\n&quot; +
            &quot;    id integer primary key,\n&quot; +
            &quot;    my_point geo_point\n&quot; +
            &quot;)\n&quot;);
        Map my_point = (Map) analyze.mappingProperties().get(&quot;my_point&quot;);
        assertEquals(&quot;geo_point&quot;, my_point.get(&quot;type&quot;));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testClusteredIntoZeroShards() {
        analyze(&quot;create table my_table (&quot; +
                &quot;  id integer,&quot; +
                &quot;  name string&quot; +
                &quot;) clustered into 0 shards&quot;);
    }

    @Test
    public void testBlobTableClusteredIntoZeroShards() {
        AnalyzedCreateBlobTable blobTable = analyze(&quot;create blob table my_table clustered into 0 shards&quot;);

        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;num_shards in CLUSTERED clause must be greater than 0&quot;);
        CreateBlobTablePlan.buildSettings(
            blobTable.createBlobTable(),
            plannerContext.transactionContext(),
            plannerContext.nodeContext(),
            new RowN(new Object[0]),
            SubQueryResults.EMPTY,
            new NumberOfShards(clusterService));

    }
<A NAME="5"></A>
    @Test
    public void testEarlyPrimaryKeyConstraint() {
        BoundCreateTable analysis = <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#5',2,'match883513-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>analyze(
            &quot;create table my_table (&quot; +
            &quot;primary key (id1, id2),&quot; +
            &quot;id1 integer,&quot; +
            &quot;id2 long&quot; +
            &quot;)&quot;);
        assertThat(analysis.primaryKeys().size(), is(2));
        assertThat(analysis.primaryKeys(), hasItems(&quot;id1&quot;, &quot;id2&quot;));
    }

    @Test(expected = ColumnUnknownException.cl</B></FONT>ass)
    public void testPrimaryKeyConstraintNonExistingColumns() {
        analyze(&quot;create table my_table (&quot; +
                &quot;primary key (id1, id2),&quot; +
                &quot;title string,&quot; +
                &quot;name string&quot; +
                &quot;)&quot;);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEarlyIndexDefinition() {
        BoundCreateTable analysis = analyze(
            &quot;create table my_table (&quot; +
            &quot;index ft using fulltext(title, name) with (analyzer='snowball'),&quot; +
            &quot;title string,&quot; +
            &quot;name string&quot; +
            &quot;)&quot;);
        Map&lt;String, Object&gt; metaMap = (Map) analysis.mapping().get(&quot;_meta&quot;);
        assertThat(
            metaMap.get(&quot;indices&quot;).toString(),
            is(&quot;{ft={}}&quot;));
        assertThat(
            (List&lt;String&gt;) ((Map&lt;String, Object&gt;) analysis.mappingProperties()
                .get(&quot;title&quot;)).get(&quot;copy_to&quot;),
            hasItem(&quot;ft&quot;)
        );
        assertThat(
            (List&lt;String&gt;) ((Map&lt;String, Object&gt;) analysis.mappingProperties()
                .get(&quot;name&quot;)).get(&quot;copy_to&quot;),
            hasItem(&quot;ft&quot;));

    }

    @Test(expected = ColumnUnknownException.class)
    public void testIndexDefinitionNonExistingColumns() {
        analyze(&quot;create table my_table (&quot; +
                &quot;index ft using fulltext(id1, id2) with (analyzer='snowball'),&quot; +
                &quot;title string,&quot; +
                &quot;name string&quot; +
                &quot;)&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testAnalyzerOnInvalidType() {
        analyze(&quot;create table my_table (x integer INDEX using fulltext with (analyzer='snowball'))&quot;);
    }

    @Test
    public void createTableNegativeReplicas() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Failed to parse value [-1] for setting [number_of_replicas] must be &gt;= 0&quot;);
        analyze(&quot;create table t (id int, name string) with (number_of_replicas=-1)&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testCreateTableSameColumn() {
        analyze(&quot;create table my_table (title string, title integer)&quot;);
    }


    @Test(expected = UnsupportedOperationException.class)
    public void testCreateTableWithArrayPrimaryKeyUnsupported() {
        analyze(&quot;create table t (id array(int) primary key)&quot;);
    }

    @Test
    public void testCreateTableWithClusteredIntoShardsParameter() {
        BoundCreateTable analysis = analyze(
            &quot;create table t (id int primary key) clustered into ? shards&quot;, 2);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;2&quot;));
    }

    @Test
    public void testCreateTableWithClusteredIntoShardsParameterNonNumeric() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;invalid number 'foo'&quot;);
        analyze(&quot;create table t (id int primary key) clustered into ? shards&quot;, &quot;foo&quot;);
    }

    @Test
    public void testCreateTableWithParitionedColumnInClusteredBy() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot use CLUSTERED BY column in PARTITIONED BY clause&quot;);
        analyze(&quot;create table t(id int primary key) partitioned by (id) clustered by (id)&quot;);
    }

    @Test
    public void testCreateTableUsesDefaultSchema() {
        SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService, 1, Randomness.get(), List.of())
            .setSearchPath(&quot;firstSchema&quot;, &quot;secondSchema&quot;)
            .build();

        BoundCreateTable analysis = analyze(sqlExecutor, &quot;create table t (id int)&quot;);
        assertThat(analysis.tableIdent().schema(), is(sqlExecutor.getSessionContext().searchPath().currentSchema()));
    }

    @Test
    public void testCreateTableWithEmptySchema() {
        expectedException.expect(InvalidSchemaNameException.class);
        expectedException.expectMessage(&quot;schema name \&quot;\&quot; is invalid.&quot;);
        analyze(&quot;create table \&quot;\&quot;.my_table (&quot; +
                &quot;id long primary key&quot; +
                &quot;)&quot;);
    }

    @Test
    public void testCreateTableWithIllegalSchema() {
        expectedException.expect(InvalidSchemaNameException.class);
        expectedException.expectMessage(&quot;schema name \&quot;with.\&quot; is invalid.&quot;);
        analyze(&quot;create table \&quot;with.\&quot;.my_table (&quot; +
                &quot;id long primary key&quot; +
                &quot;)&quot;);
    }

    @Test
    public void testCreateTableWithInvalidColumnName() {
        expectedException.expect(InvalidColumnNameException.class);
        expectedException.expectMessage(
            &quot;\&quot;_test\&quot; conflicts with system column pattern&quot;);
        analyze(&quot;create table my_table (\&quot;_test\&quot; string)&quot;);
    }

    @Test
    public void testCreateTableShouldRaiseErrorIfItExists() {
        expectedException.expect(RelationAlreadyExists.class);
        analyze(&quot;create table users (\&quot;'test\&quot; string)&quot;);
    }

    @Test
    public void testExplicitSchemaHasPrecedenceOverDefaultSchema() {
        SQLExecutor e = SQLExecutor.builder(clusterService).setSearchPath(&quot;hoschi&quot;).build();
        BoundCreateTable statement = analyze(e, &quot;create table foo.bar (x string)&quot;);

        // schema from statement must take precedence
        assertThat(statement.tableIdent().schema(), is(&quot;foo&quot;));
    }

    @Test
    public void testDefaultSchemaIsAddedToTableIdentIfNoExplicitSchemaExistsInTheStatement() {
        SQLExecutor e = SQLExecutor.builder(clusterService).setSearchPath(&quot;hoschi&quot;).build();
        BoundCreateTable statement = analyze(e, &quot;create table bar (x string)&quot;);

        assertThat(statement.tableIdent().schema(), is(&quot;hoschi&quot;));
    }

    @Test
    public void testChangeReadBlock() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.read\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeWriteBlock() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.write\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_WRITE_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeMetadataBlock() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.metadata\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_METADATA_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeReadOnlyBlock() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.read_only\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_READ_ONLY_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeBlockReadOnlyAllowDelete() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;blocks.read_only_allow_delete\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeBlockReadOnlyAllowedDeletePartitionedTable() {
        BoundAlterTable analysis =
            analyze(&quot;alter table parted set (\&quot;blocks.read_only_allow_delete\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.getKey()), is(&quot;true&quot;));
    }

    @Test
    public void testChangeFlushThresholdSize() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;translog.flush_threshold_size\&quot;='300b')&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey()), is(&quot;300b&quot;));
    }

    @Test
    public void testChangeTranslogInterval() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;translog.sync_interval\&quot;='100ms')&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()), is(&quot;100ms&quot;));
    }

    @Test
    public void testChangeTranslogDurability() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;translog.durability\&quot;='ASYNC')&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey()), is(&quot;ASYNC&quot;));
    }

    @Test
    public void testRoutingAllocationEnable() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;routing.allocation.enable\&quot;=\&quot;none\&quot;)&quot;);
        assertThat(analysis.tableParameter().settings().get(EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey()), is(&quot;none&quot;));
    }

    @Test
    public void testRoutingAllocationValidation() {
        expectedException.expect(IllegalArgumentException.class);
        analyze(&quot;alter table users set (\&quot;routing.allocation.enable\&quot;=\&quot;foo\&quot;)&quot;);
    }

    @Test
    public void testAlterTableSetShards() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;number_of_shards\&quot;=1)&quot;);
        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;1&quot;));
    }

    @Test
    public void testAlterTableResetShards() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users reset (\&quot;number_of_shards\&quot;)&quot;);
        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is(&quot;5&quot;));
    }

    @Test
    public void testTranslogSyncInterval() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;translog.sync_interval\&quot;='1s')&quot;);
        assertThat(analysis.table().ident().name(), is(&quot;users&quot;));
        assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()), is(&quot;1s&quot;));
    }

    @Test
    public void testAllocationMaxRetriesValidation() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;allocation.max_retries\&quot;=1)&quot;);
        assertThat(analysis.tableParameter().settings().get(MaxRetryAllocationDecider.SETTING_ALLOCATION_MAX_RETRY.getKey()), is(&quot;1&quot;));
    }

    @Test
    public void testCreateReadOnlyTable() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id integer primary key, name string) &quot;
            + &quot;clustered into 3 shards with (\&quot;blocks.read_only\&quot;=true)&quot;);
        assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_READ_ONLY_SETTING.getKey()), is(&quot;true&quot;));
    }

<A NAME="3"></A>    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableWithGeneratedColumn() {
        BoundCreateTable analysis = <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#3',2,'match883513-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day as date_trunc('day', ts))&quot;);

        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(generatedColumnsMapping.size(), is(1));
        assertThat(generatedColumnsMapping.get(&quot;day&quot;), is</B></FONT>(&quot;date_trunc('day', ts)&quot;));

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; dayMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;day&quot;);
        assertThat(dayMapping.get(&quot;type&quot;), is(&quot;date&quot;));
        Map&lt;String, Object&gt; tsMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;ts&quot;);
        assertThat(tsMapping.get(&quot;type&quot;), is(&quot;date&quot;));
    }

    @Test
    public void testCreateTableWithColumnOfArrayTypeAndGeneratedExpression() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (arr array(integer) as ([1.0, 2.0]))&quot;);

        assertThat(
            mapToSortedString(analysis.mappingProperties()),
            is(&quot;arr={inner={position=1, type=integer}, type=array}&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableGeneratedColumnWithCast() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day timestamp with time zone GENERATED ALWAYS as ts + 1)&quot;);
        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(
            generatedColumnsMapping.get(&quot;day&quot;),
            is(&quot;(ts + 1::bigint)&quot;));

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        Map&lt;String, Object&gt; dayMapping = (Map&lt;String, Object&gt;) mappingProperties.get(&quot;day&quot;);
        assertThat(dayMapping.get(&quot;type&quot;), is(&quot;date&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableWithCurrentTimestampAsGeneratedColumnIsntNormalized() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (ts timestamp with time zone GENERATED ALWAYS as current_timestamp(3))&quot;);

        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(generatedColumnsMapping.size(), is(1));
        // current_timestamp used to get evaluated and then this contained the actual timestamp instead of the function name
        assertThat(generatedColumnsMapping.get(&quot;ts&quot;), is(&quot;current_timestamp(3)&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableGeneratedColumnWithSubscript() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (\&quot;user\&quot; object as (name string), name as concat(\&quot;user\&quot;['name'], 'foo'))&quot;);

        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(generatedColumnsMapping.get(&quot;name&quot;), is(&quot;concat(\&quot;user\&quot;['name'], 'foo')&quot;));
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testCreateTableGeneratedColumnParameter() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (\&quot;user\&quot; object as (name string), name as concat(\&quot;user\&quot;['name'], ?))&quot;, $(&quot;foo&quot;));
        Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get(&quot;_meta&quot;));
        Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get(&quot;generated_columns&quot;);
        assertThat(generatedColumnsMapping.get(&quot;name&quot;), is(&quot;concat(\&quot;user\&quot;['name'], 'foo')&quot;));
    }

    @Test
    public void testCreateTableGeneratedColumnWithInvalidType() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;expression value type&quot; +
                                        &quot; 'timestamp with time zone' not supported for conversion to 'ip'&quot;);
        analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day ip GENERATED ALWAYS as date_trunc('day', ts))&quot;);
    }

    @Test
    public void testCreateTableGeneratedColumnWithMatch() {
        expectedException.expect(UnsupportedFeatureException.class);
        expectedException.expectMessage(&quot;Cannot use MATCH in CREATE TABLE statements&quot;);
        analyze(&quot;create table foo (name string, bar as match(name, 'crate'))&quot;);
    }

    @Test
    public void testCreateTableGeneratedColumnBasedOnGeneratedColumn() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;A generated column cannot be based on a generated column&quot;);
        analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day as date_trunc('day', ts),&quot; +
            &quot;   date_string as cast(day as string))&quot;);
    }

    @Test
    public void testCreateTableGeneratedColumnBasedOnUnknownColumn() {
        expectedException.expect(ColumnUnknownException.class);
        expectedException.expectMessage(&quot;Column unknown_col unknown&quot;);
        analyze(
            &quot;create table foo (&quot; +
            &quot;   ts timestamp with time zone,&quot; +
            &quot;   day as date_trunc('day', ts),&quot; +
            &quot;   date_string as cast(unknown_col as string))&quot;);
    }

    @Test
    public void testCreateTableWithDefaultExpressionLiteral() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (name text default 'bar')&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;name={default_expr='bar', position=1, type=keyword}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionFunction() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (name text default upper('bar'))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;name={default_expr='BAR', position=1, type=keyword}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionWithCast() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (id int default 3.5)&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;id={default_expr=_cast(3.5, 'integer'), position=1, type=integer}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionIsNotNormalized() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (ts timestamp with time zone default current_timestamp(3))&quot;);

        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties),
                   is(&quot;ts={default_expr=current_timestamp(3), &quot; +
                      &quot;format=epoch_millis||strict_date_optional_time, &quot; +
                      &quot;position=1, type=date}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionAsCompoundTypes() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (&quot; +
            &quot;   obj object as (key text) default {key=''},&quot; +
            &quot;   arr array(long) default [1, 2])&quot;);

        assertThat(mapToSortedString(analysis.mappingProperties()), is(
            &quot;arr={inner={position=3, type=long}, type=array}, &quot; +
            &quot;obj={default_expr={\&quot;key\&quot;=''}, dynamic=true, position=1, properties={key={position=2, type=keyword}}, type=object}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionAsGeoTypes() {
        BoundCreateTable analysis = analyze(
            &quot;create table foo (&quot; +
            &quot;   p geo_point default [0,0],&quot; +
            &quot;   s geo_shape default 'LINESTRING (0 0, 1 1)')&quot;);

        assertThat(mapToSortedString(analysis.mappingProperties()), is(
            &quot;p={default_expr=_cast([0, 0], 'geo_point'), position=1, type=geo_point}, &quot; +
            &quot;s={default_expr=_cast('LINESTRING (0 0, 1 1)', 'geo_shape'), position=2, type=geo_shape}&quot;));
    }

    @Test
    public void testCreateTableWithDefaultExpressionRefToColumnsNotAllowed() {
        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;Columns cannot be used in this context. &quot; +
                                        &quot;Maybe you wanted to use a string literal which requires single quotes: 'name'&quot;);
        analyze(&quot;create table foo (name text, name_def text default upper(name))&quot;);
    }

    @Test
    public void testCreateTableWithObjectAsPrimaryKey() {
        expectedException.expectMessage(&quot;Cannot use columns of type \&quot;object\&quot; as primary key&quot;);
        expectedException.expect(UnsupportedOperationException.class);
        analyze(&quot;create table t (obj object as (x int) primary key)&quot;);
    }

    @Test
    public void testCreateTableWithGeoPointAsPrimaryKey() {
        expectedException.expectMessage(&quot;Cannot use columns of type \&quot;geo_point\&quot; as primary key&quot;);
        expectedException.expect(UnsupportedOperationException.class);
        analyze(&quot;create table t (c geo_point primary key)&quot;);
    }

    @Test
    public void testCreateTableWithGeoShapeAsPrimaryKey() {
        expectedException.expectMessage(&quot;Cannot use columns of type \&quot;geo_shape\&quot; as primary key&quot;);
        expectedException.expect(UnsupportedOperationException.class);
        analyze(&quot;create table t (c geo_shape primary key)&quot;);
    }

    @Test
    public void testCreateTableWithDuplicatePrimaryKey() {
        assertDuplicatePrimaryKey(&quot;create table t (id int, primary key (id, id))&quot;);
        assertDuplicatePrimaryKey(&quot;create table t (obj object as (id int), primary key (obj['id'], obj['id']))&quot;);
        assertDuplicatePrimaryKey(&quot;create table t (id int primary key, primary key (id))&quot;);
        assertDuplicatePrimaryKey(&quot;create table t (obj object as (id int primary key), primary key (obj['id']))&quot;);
<A NAME="16"></A>    }

    private void assertDuplicatePrimaryKey(String stmt) {
        <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#16',2,'match883513-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try {
            analyze(stmt);
            fail(String.format(Locale.ENGLISH, &quot;Statement '%s' did not result in duplicate primary key exception&quot;, stmt));
        } catch (IllegalArgumentException e) {</B></FONT>
            String msg = &quot;appears twice in primary key constraint&quot;;
            if (!e.getMessage().contains(msg)) {
                fail(&quot;Exception message is expected to contain: &quot; + msg);
            }
        }
    }

    @Test
    public void testAlterTableAddColumnWithCheckConstraint() throws Exception {
        SQLExecutor.builder(clusterService)
            .addTable(&quot;create table t (&quot; +
                      &quot;    id int primary key, &quot; +
                      &quot;    qty int constraint check_qty_gt_zero check(qty &gt; 0), &quot; +
                      &quot;    constraint check_id_ge_zero check (id &gt;= 0)&quot; +
<A NAME="1"></A>                      &quot;)&quot;)
            .build();
        String alterStmt = &quot;alter table t add column bazinga int constraint bazinga_check check(bazinga != 42)&quot;;
        BoundAddColumn analysis = <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#1',2,'match883513-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>analyze(alterStmt);
        Map&lt;String, Object&gt; mapping = analysis.mapping();
        Map&lt;String, String&gt; checkConstraints = analysis.analyzedTableElements().getCheckConstraints();
        assertEquals(checkConstraints.get(&quot;check_id_ge_zero&quot;),
                     Maps.getByPath(mapping, Arrays.asList(&quot;_meta&quot;, &quot;check_constraints&quot;, &quot;check_id_ge_zero&quot;)));
        assertEquals(checkConstraints.get(&quot;check_qty_gt_zero&quot;),
                     Maps.getByPath</B></FONT>(mapping, Arrays.asList(&quot;_meta&quot;, &quot;check_constraints&quot;, &quot;check_qty_gt_zero&quot;)));
        assertEquals(checkConstraints.get(&quot;bazinga_check&quot;),
                     Maps.getByPath(mapping, Arrays.asList(&quot;_meta&quot;, &quot;check_constraints&quot;, &quot;bazinga_check&quot;)));
    }

    @Test
    public void testCreateTableWithPrimaryKeyConstraintInArrayItem() {
        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;Cannot use column \&quot;id\&quot; as primary key within an array object&quot;);
        analyze(&quot;create table test (arr array(object as (id long primary key)))&quot;);
    }

    @Test
    public void testCreateTableWithDeepNestedPrimaryKeyConstraintInArrayItem() {
        expectedException.expect(UnsupportedOperationException.class);
        expectedException.expectMessage(&quot;Cannot use column \&quot;name\&quot; as primary key within an array object&quot;);
        analyze(&quot;create table test (arr array(object as (\&quot;user\&quot; object as (name string primary key), id long)))&quot;);
    }

    @Test
    public void testCreateTableWithInvalidIndexConstraint() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;INDEX constraint cannot be used on columns of type \&quot;object\&quot;&quot;);
        analyze(&quot;create table test (obj object index off)&quot;);
    }

    @Test
    public void testCreateTableWithColumnStoreDisabled() {
        BoundCreateTable analysis = analyze(
            &quot;create table columnstore_disabled (s string STORAGE WITH (columnstore = false))&quot;);
        Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
        assertThat(mapToSortedString(mappingProperties), is(&quot;s={doc_values=false, position=1, type=keyword}&quot;));
    }

    @Test
    public void testCreateTableWithColumnStoreDisabledOnInvalidDataType() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Invalid storage option \&quot;columnstore\&quot; for data type \&quot;integer\&quot;&quot;);
        analyze(&quot;create table columnstore_disabled (s int STORAGE WITH (columnstore = false))&quot;);
    }

    @Test
    public void testCreateTableFailsIfNameConflictsWithView() {
        SQLExecutor executor = SQLExecutor.builder(clusterService)
            .addView(RelationName.fromIndexName(&quot;v1&quot;), &quot;Select * from t1&quot;)
            .build();
        expectedException.expect(RelationAlreadyExists.class);
        expectedException.expectMessage(&quot;Relation 'doc.v1' already exists&quot;);
        analyze(executor, &quot;create table v1 (x int) clustered into 1 shards with (number_of_replicas = 0)&quot;);
    }

    @Test
    public void testGeneratedColumnInsideObjectIsProcessed() {
        BoundCreateTable stmt = analyze(&quot;create table t (obj object as (c as 1 + 1))&quot;);
        AnalyzedColumnDefinition&lt;Object&gt; obj = stmt.analyzedTableElements().columns().get(0);
        AnalyzedColumnDefinition&lt;?&gt; c = obj.children().get(0);

        assertThat(c.dataType(), is(DataTypes.INTEGER));
        assertThat(c.formattedGeneratedExpression(), is(&quot;2&quot;));
        assertThat(AnalyzedTableElements.toMapping(stmt.analyzedTableElements()).toString(),
                   is(&quot;{_meta={generated_columns={obj.c=2}}, &quot; +
                      &quot;properties={obj={dynamic=true, position=1, type=object, properties={c={position=2, type=integer}}}}}&quot;));
<A NAME="10"></A>    }

    @Test
    public void testNumberOfRoutingShardsCanBeSetAtCreateTable() <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#10',2,'match883513-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        BoundCreateTable stmt = analyze(&quot;&quot;&quot;
            create table t (x int)
            clustered into 2 shards
            with (number_of_routing_shards = 10)
        &quot;&quot;&quot;);
        assertThat(stmt.tableParameter().settings().get(&quot;index.number_of_routing_shards&quot;), is(&quot;10&quot;));
<A NAME="9"></A>    }

    @Test</B></FONT>
    public void testNumberOfRoutingShardsCanBeSetAtCreateTableForPartitionedTables() <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match883513-0.html#9',2,'match883513-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        BoundCreateTable stmt = analyze(
            &quot;create table t (p int, x int) clustered into 2 shards partitioned by (p) &quot; +
            &quot;with (number_of_routing_shards = 10)&quot;);
        assertThat(stmt.tableParameter().settings().get(&quot;index.number_of_routing_shards&quot;), is(&quot;10&quot;));
    }

    @Test</B></FONT>
    public void testAlterTableSetDynamicSetting() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users set (\&quot;routing.allocation.exclude.foo\&quot;='bar')&quot;);
        assertThat(analysis.tableParameter().settings().get(INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + &quot;foo&quot;), is(&quot;bar&quot;));
    }

    @Test
    public void testAlterTableResetDynamicSetting() {
        BoundAlterTable analysis =
            analyze(&quot;alter table users reset (\&quot;routing.allocation.exclude.foo\&quot;)&quot;);
        assertThat(analysis.tableParameter().settings().get(INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + &quot;foo&quot;), nullValue());
    }

    @Test
    public void testCreateTableWithIntervalFails() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(&quot;Cannot use the type `interval` for column: i&quot;);
        analyze(&quot;create table test (i interval)&quot;);
    }

    @Test
    public void test_character_varying_type_can_be_used_in_create_table() throws Exception {
        BoundCreateTable stmt = analyze(&quot;create table tbl (name character varying)&quot;);
        assertThat(
            mapToSortedString(stmt.mappingProperties()),
            is(&quot;name={position=1, type=keyword}&quot;));
    }

    @Test
    public void test_create_table_with_varchar_column_of_limited_length() {
        BoundCreateTable stmt = analyze(&quot;CREATE TABLE tbl (name character varying(2))&quot;);
        assertThat(
            mapToSortedString(stmt.mappingProperties()),
            is(&quot;name={length_limit=2, position=1, type=keyword}&quot;));
    }

    @Test
    public void test_create_table_with_varchar_column_of_limited_length_with_analyzer_throws_exception() {
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(
            &quot;Can't use an Analyzer on column name because analyzers are only allowed on columns &quot; +
            &quot;of type \&quot;&quot; + DataTypes.STRING.getName() + &quot;\&quot; of the unbound length limit.&quot;);
        analyze(&quot;CREATE TABLE tbl (name varchar(2) INDEX using fulltext WITH (analyzer='german'))&quot;);
    }

    @Test
    public void test_oidvector_cannot_be_used_in_create_table() throws Exception {
        expectedException.expectMessage(&quot;Cannot use the type `oidvector` for column: x&quot;);
        analyze(&quot;CREATE TABLE tbl (x oidvector)&quot;);
    }

    @Test
    public void test_generated_column_arguments_are_detected_as_array_and_validation_fails_with_missing_overload() throws Exception {
        Exception exception = Assertions.assertThrows(
            Exception.class,
            () -&gt; analyze(&quot;CREATE TABLE tbl (xs int[], x as max(xs))&quot;)
        );
        assertThat(
            exception.getMessage(),
            Matchers.startsWith(&quot;Unknown function: max(doc.tbl.xs), no overload found for matching argument types: (integer_array)&quot;)
        );
    }

    @Test
    public void test_prohibit_using_aggregations_in_generated_columns() throws Exception {
        Exception exception = Assertions.assertThrows(
            Exception.class,
            () -&gt; analyze(&quot;CREATE TABLE tbl (x int, y as max(x))&quot;)
        );
        assertThat(
            exception.getMessage(),
            Matchers.startsWith(&quot;Aggregation functions are not allowed in generated columns: max(x)&quot;)
        );
    }

    @Test
    public void test_can_use_bit_type_in_create_table_statement() throws Exception {
        BoundCreateTable stmt = analyze(&quot;CREATE TABLE tbl (xs bit(20))&quot;);
        assertThat(mapToSortedString(stmt.mappingProperties()), is(
            &quot;xs={length=20, position=1, type=bit}&quot;
        ));
    }

    @Test
    public void test_bit_type_defaults_to_length_1() throws Exception {
        BoundCreateTable stmt = analyze(&quot;CREATE TABLE tbl (xs bit)&quot;);
        assertThat(mapToSortedString(stmt.mappingProperties()), is(
            &quot;xs={length=1, position=1, type=bit}&quot;
        ));
    }

    @Test
    public void test_now_function_is_not_normalized_to_literal_in_create_table() throws Exception {
        BoundCreateTable stmt = analyze(&quot;create table tbl (ts timestamp with time zone default now())&quot;);
        assertThat(mapToSortedString(stmt.mappingProperties()), Matchers.startsWith(
            &quot;ts={default_expr=now()&quot;
        ));
    }

    @Test
    public void test_current_user_function_is_not_normalized_to_literal_in_create_table() throws Exception {
        BoundCreateTable stmt = analyze(&quot;create table tbl (user_name text default current_user)&quot;);
        assertThat(mapToSortedString(stmt.mappingProperties()), Matchers.startsWith(
            &quot;user_name={default_expr=CURRENT_USER, position=1, type=keyword}&quot;
        ));
    }

    @Test
    public void test_create_table_with_invalid_storage_option_errors_with_invalid_property_name() throws Exception {
        assertThrowsMatches(
            () -&gt; analyze(&quot;create table tbl (name text storage with (foobar = true))&quot;),
            IllegalArgumentException.class,
            &quot;Invalid STORAGE WITH option `foobar`&quot;
        );
    }
}
</PRE>
</div>
  </div>
</body>
</html>
