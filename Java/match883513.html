<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TcpTransportTests.java &amp; CreateAlterTableStatementAnalyzerTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TcpTransportTests.java &amp; CreateAlterTableStatementAnalyzerTest.java
      </h3>
<h1 align="center">
        17.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TcpTransportTests.java (37.979095%)<th>CreateAlterTableStatementAnalyzerTest.java (11.173757%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-56)<td><a href="#" name="0">(22-56)</a><td align="center"><font color="#ff0000">34</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(266-273)<td><a href="#" name="1">(1255-1261)</a><td align="center"><font color="#610000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(162-170)<td><a href="#" name="2">(514-520)</a><td align="center"><font color="#610000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(312-319)<td><a href="#" name="3">(1011-1019)</a><td align="center"><font color="#5a0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(82-87)<td><a href="#" name="4">(180-185)</a><td align="center"><font color="#5a0000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(236-246)<td><a href="#" name="5">(737-747)</a><td align="center"><font color="#520000">11</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(225-234)<td><a href="#" name="6">(695-700)</a><td align="center"><font color="#520000">11</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(153-160)<td><a href="#" name="7">(592-596)</a><td align="center"><font color="#520000">11</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(143-151)<td><a href="#" name="8">(582-586)</a><td align="center"><font color="#520000">11</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(71-80)<td><a href="#" name="9">(1336-1343)</a><td align="center"><font color="#520000">11</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(62-71)<td><a href="#" name="10">(1326-1335)</a><td align="center"><font color="#520000">11</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(206-214)<td><a href="#" name="11">(247-254)</a><td align="center"><font color="#4b0000">10</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(136-141)<td><a href="#" name="12">(239-245)</a><td align="center"><font color="#4b0000">10</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(126-134)<td><a href="#" name="13">(233-237)</a><td align="center"><font color="#4b0000">10</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(100-107)<td><a href="#" name="14">(307-313)</a><td align="center"><font color="#4b0000">10</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(91-99)<td><a href="#" name="15">(293-299)</a><td align="center"><font color="#4b0000">10</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(254-257)<td><a href="#" name="16">(1234-1237)</a><td align="center"><font color="#430000">9</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(216-223)<td><a href="#" name="17">(195-200)</a><td align="center"><font color="#430000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TcpTransportTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Elasticsearch under one or more contributor
3  * license agreements. See the NOTICE file distributed with
4  * this work for additional information regarding copyright
5  * ownership. Elasticsearch licenses this file to you under
6  * the Apache License, Version 2.0 (the "License"); you may
7  * not use this file except in compliance with the License.
8  * You may obtain a copy of the License at
9  *
10  *    http://www.apache.org/licenses/LICENSE-2.0
11  *
12  * Unless required by applicable law or agreed to in writing,
13  * software distributed under the License is distributed on an
14  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
15  * KIND, either express or implied.  See the License for the
16  * specific language governing permissions and limitations
17 <a name="0"></a> * under the License.
18  */
19 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.transport;
20 import org.apache.logging.log4j.Level;
21 import org.apache.logging.log4j.LogManager;
22 import org.elasticsearch.ElasticsearchException;
23 import org.elasticsearch.Version;
24 import org.elasticsearch.action.support.PlainActionFuture;
25 import org.elasticsearch.cluster.node.DiscoveryNode;
26 import org.elasticsearch.common.component.Lifecycle;
27 import org.elasticsearch.common.io.stream.BytesStreamOutput;
28 import org.elasticsearch.common.logging.Loggers;
29 import org.elasticsearch.common.network.NetworkService;
30 import org.elasticsearch.common.network.NetworkUtils;
31 import org.elasticsearch.common.settings.Settings;
32 import org.elasticsearch.common.transport.TransportAddress;
33 import org.elasticsearch.common.util.BigArrays;
34 import org.elasticsearch.common.util.MockPageCacheRecycler;
35 import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
36 import org.elasticsearch.test.ESTestCase;
37 import org.elasticsearch.test.MockLogAppender;
38 import org.elasticsearch.test.junit.annotations.TestLogging;
39 import org.elasticsearch.threadpool.TestThreadPool;
40 import org.elasticsearch.threadpool.ThreadPool;
41 import org.hamcrest.Matcher;
42 import java.io.IOException;
43 import java.io.StreamCorruptedException;
44 import java.net.BindException;
45 import java.net.InetSocketAddress;
46 import java.nio.channels.CancelledKeyException;
47 import java.nio.channels.ClosedChannelException;
48 import java.util.Collections;
49 import java.util.concurrent.TimeUnit;
50 import static org.hamcrest.Matchers.containsInAnyOrder;
51 import static org.hamcrest.Matchers.nullValue;
52 import</b></font> static org.hamcrest.core.IsInstanceOf.instanceOf;
53 <a name="10"></a>public class TcpTransportTests extends ESTestCase {
54     public void testParseV4DefaultPort() throws Exception <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
55         TransportAddress[] addresses = TcpTransport.parse("127.0.0.1", 1234);
56         assertEquals(1, addresses.length);
57         assertEquals("127.0.0.1", addresses[0].getAddress());
58         assertEquals(1234, addresses[0].getPort());
59 <a name="9"></a>    }
60     public void testPar</b></font>seV4WithPort() throws Exception <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
61         TransportAddress[] addresses = TcpTransport.parse("127.0.0.1:2345", 1234);
62         assertEquals(1, addresses.length);
63         assertEquals("127.0.0.1", addresses[0].getAddress());
64         assertEquals(2345, addresses[0].getPort());
65     }
66 <a name="4"></a>        public void testParseV</b></font>6UnBracketed() throws Exception {
67         try {
68             <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>TcpTransport.parse("::1", 1234);
69             fail("should have gotten exception");
70         } catch (IllegalArgumentException expected) {
71             assertTrue(expected.getMessage().contains("must be bracketed"));
72         }
73     }</b></font>
74 <a name="15"></a>
75     public void testParseV6DefaultPort() throws Exception {
76         <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>TransportAddress[] addresses = TcpTransport.parse("[::1]", 1234);
77         assertEquals(1, addresses.length);
78         assertEquals("::1", addresses[0].getAddress());
79         assertEquals(1234, addresses[0].getPort());
80     }
81 <a name="14"></a>
82     public void testPar</b></font>seV6WithPort() throws Exception {
83         <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>TransportAddress[] addresses = TcpTransport.parse("[::1]:2345", 1234);
84         assertEquals(1, addresses.length);
85         assertEquals("::1", addresses[0].getAddress());
86         assertEquals(2345, addresses[0].getPort());
87     }
88     public void testRejec</b></font>tsPortRanges() {
89         expectThrows(
90             NumberFormatException.class,
91             () -&gt; TcpTransport.parse("[::1]:100-200", 1000)
92         );
93     }
94     public void testDefaultSeedAddressesWithDefaultPort() {
95         final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
96             containsInAnyOrder(
97                 "[::1]:4300", "[::1]:4301", "[::1]:4302", "[::1]:4303", "[::1]:4304", "[::1]:4305",
98                 "127.0.0.1:4300", "127.0.0.1:4301", "127.0.0.1:4302", "127.0.0.1:4303", "127.0.0.1:4304", "127.0.0.1:4305") :
99             containsInAnyOrder(
100                 "127.0.0.1:4300", "127.0.0.1:4301", "127.0.0.1:4302", "127.0.0.1:4303", "127.0.0.1:4304", "127.0.0.1:4305");
101         testDefaultSeedAddresses(Settings.EMPTY, seedAddressMatcher);
102     }
103 <a name="13"></a>
104     public void testDefaultSeedAddressesWithNonstandardGlobalPortRange() {
105         final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
106             <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>containsInAnyOrder(
107                 "[::1]:4500", "[::1]:4501", "[::1]:4502", "[::1]:4503", "[::1]:4504", "[::1]:4505",
108                 "127.0.0.1:4500", "127.0.0.1:4501", "127.0.0.1:4502", "127.0.0.1:4503", "127.0.0.1:4504", "127.0.0.1:4505") :
109             containsInAnyOrder(
110                 "127.0.0.1:4500", "127.0.0.1:4501", "127.0.0.1:4502", "127.0.0.1:4503", "127.0.0.1:4504", "127.0.0.1:4505");
111         testDefaultSeedAddresses(Settings.builder().put(TransportSettings.PORT.getKey(), "4500-9600").build(), seedAddressMatcher);
112     }
113 <a name="12"></a>
114     public void testDefaultSeedAddressesWithSmallGlo</b></font>balPortRange() {
115         final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
116             <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>containsInAnyOrder("[::1]:4300", "[::1]:4301", "[::1]:4302", "127.0.0.1:4300", "127.0.0.1:4301", "127.0.0.1:4302") :
117             containsInAnyOrder("127.0.0.1:4300", "127.0.0.1:4301", "127.0.0.1:4302");
118         testDefaultSeedAddresses(Settings.builder().put(TransportSettings.PORT.getKey(), "4300-4302").build(), seedAddressMatcher);
119     }
120 <a name="8"></a>
121     public void testDefaultSeedAddressesWithNonstandardProf</b></font>ilePortRange() {
122         final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
123             <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>containsInAnyOrder("[::1]:4500", "[::1]:4501", "[::1]:4502", "[::1]:4503", "[::1]:4504", "[::1]:4505",
124                 "127.0.0.1:4500", "127.0.0.1:4501", "127.0.0.1:4502", "127.0.0.1:4503", "127.0.0.1:4504", "127.0.0.1:4505") :
125             containsInAnyOrder("127.0.0.1:4500", "127.0.0.1:4501", "127.0.0.1:4502", "127.0.0.1:4503", "127.0.0.1:4504", "127.0.0.1:4505");
126         testDefaultSeedAddresses(Settings.builder()
127                 .put(TransportSettings.PORT_PROFILE.getConcreteSettingForNamespace(TransportSettings.DEFAULT_PROFILE).getKey(), "4500-9600")
128                 .build(), seedAddressMatcher);
129     }
130 <a name="7"></a>
131     public void testDefaultSeedAddressesWithSmallProf</b></font>ilePortRange() {
132         final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
133             <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>containsInAnyOrder("[::1]:4300", "[::1]:4301", "[::1]:4302", "127.0.0.1:4300", "127.0.0.1:4301", "127.0.0.1:4302") :
134             containsInAnyOrder("127.0.0.1:4300", "127.0.0.1:4301", "127.0.0.1:4302");
135         testDefaultSeedAddresses(Settings.builder()
136                 .put(TransportSettings.PORT_PROFILE.getConcreteSettingForNamespace(TransportSettings.DEFAULT_PROFILE).getKey(), "4300-4302")
137                 .build(), seedAddressMatcher);
138     }
139 <a name="2"></a>
140     public void testDefaultSeedAddressesPrefersProfileSettingToG</b></font>lobalSetting() {
141         final Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressMatcher = NetworkUtils.SUPPORTS_V6 ?
142             <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>containsInAnyOrder("[::1]:4300", "[::1]:4301", "[::1]:4302", "127.0.0.1:4300", "127.0.0.1:4301", "127.0.0.1:4302") :
143             containsInAnyOrder("127.0.0.1:4300", "127.0.0.1:4301", "127.0.0.1:4302");
144         testDefaultSeedAddresses(Settings.builder()
145                 .put(TransportSettings.PORT_PROFILE.getConcreteSettingForNamespace(TransportSettings.DEFAULT_PROFILE).getKey(), "4300-4302")
146                 .put(TransportSettings.PORT.getKey(), "4500-9600")
147                 .build(), seedAddressMatcher);
148     }
149     public void testDefaultSeedAddressesWithNonstanda</b></font>rdSinglePort() {
150         testDefaultSeedAddresses(Settings.builder().put(TransportSettings.PORT.getKey(), "4500").build(),
151             NetworkUtils.SUPPORTS_V6 ? containsInAnyOrder("[::1]:4500", "127.0.0.1:4500") : containsInAnyOrder("127.0.0.1:4500"));
152     }
153     private void testDefaultSeedAddresses(final Settings settings, Matcher&lt;Iterable&lt;? extends String&gt;&gt; seedAddressesMatcher) {
154         final TestThreadPool testThreadPool = new TestThreadPool("test");
155         try {
156             final TcpTransport tcpTransport = new TcpTransport(settings, Version.CURRENT, testThreadPool,
157                 new MockPageCacheRecycler(settings),
158                 new NoneCircuitBreakerService(), writableRegistry(), new NetworkService(Collections.emptyList())) {
159                 @Override
160                 protected TcpServerChannel bind(String name, InetSocketAddress address) {
161                     throw new UnsupportedOperationException();
162                 }
163                 @Override
164                 protected TcpChannel initiateChannel(DiscoveryNode node) {
165                     throw new UnsupportedOperationException();
166                 }
167                 @Override
168                 protected void stopInternal() {
169                     throw new UnsupportedOperationException();
170                 }
171             };
172             assertThat(tcpTransport.getDefaultSeedAddresses(), seedAddressesMatcher);
173         } finally {
174             testThreadPool.shutdown();
175         }
176     }
177 <a name="11"></a>
178     public void testReadMessageLengthWithIncompleteHeader() throws IOException {
179         BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
180         <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>streamOutput.write('E');
181         streamOutput.write('S');
182         streamOutput.write(1);
183         streamOutput.write(1);
184         assertEquals(-1, TcpTransport.readMessageLength(streamOutput.bytes()));
185     }
186 <a name="17"></a>
187     public void testReadPingM</b></font>essageLength() throws IOException {
188         BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
189         <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>streamOutput.write('E');
190         streamOutput.write('S');
191         streamOutput.writeInt(-1);
192         assertEquals(0, TcpTransport.readMessageLength(streamOutput.bytes()));
193     }
194 <a name="6"></a>
195     public void testReadPingMessageLengthWithStartOfS</b></font>econdMessage() throws IOException {
196         BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
197         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>streamOutput.write('E');
198         streamOutput.write('S');
199         streamOutput.writeInt(-1);
200         streamOutput.write('E');
201         streamOutput.write('S');
202         assertEquals(0, TcpTransport.readMessageLength(streamOutput.bytes()));
203     }
204 <a name="5"></a>
205     public void testReadM</b></font>essageLength() throws IOException {
206         BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
207         <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>streamOutput.write('E');
208         streamOutput.write('S');
209         streamOutput.writeInt(2);
210         streamOutput.write('M');
211         streamOutput.write('A');
212         assertEquals(2, TcpTransport.readMessageLength(streamOutput.bytes()));
213     }
214     public void testI</b></font>nvalidLength() throws IOException {
215         BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
216         streamOutput.write('E');
217         streamOutput.write('S');
218         streamOutput.writeInt(-2);
219 <a name="16"></a>        streamOutput.write('M');
220         streamOutput.write('A');
221         <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
222             TcpTransport.readMessageLength(streamOutput.bytes());
223             fail("Expected exception");
224         } catch (Exception ex) {</b></font>
225             assertThat(ex, instanceOf(StreamCorruptedException.class));
226             assertEquals("invalid data length: -2", ex.getMessage());
227         }
228     }
229 <a name="1"></a>    public void testInvalidHeader() throws IOException {
230         BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
231         streamOutput.write('E');
232         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>streamOutput.write('C');
233         byte byte1 = randomByte();
234         byte byte2 = randomByte();
235         streamOutput.write(byte1);
236         streamOutput.write(byte2);
237         streamOutput.write(randomByte());
238         streamOutput.write(randomByte());
239         streamOutput.write(randomByte</b></font>());
240         try {
241             TcpTransport.readMessageLength(streamOutput.bytes());
242             fail("Expected exception");
243         } catch (Exception ex) {
244             assertThat(ex, instanceOf(StreamCorruptedException.class));
245             String expected = "invalid internal transport message format, got (45,43,"
246                 + Integer.toHexString(byte1 &amp; 0xFF) + ","
247                 + Integer.toHexString(byte2 &amp; 0xFF) + ")";
248             assertEquals(expected, ex.getMessage());
249         }
250     }
251     public void testHTTPRequest() throws IOException {
252         String[] httpHeaders = {"GET", "POST", "PUT", "HEAD", "DELETE", "OPTIONS", "PATCH", "TRACE"};
253         for (String httpHeader : httpHeaders) {
254             BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
255             for (char c : httpHeader.toCharArray()) {
256                 streamOutput.write((byte) c);
257             }
258             streamOutput.write(new byte[6]);
259             try {
260                 TcpTransport.readMessageLength(streamOutput.bytes());
261                 fail("Expected exception");
262             } catch (Exception ex) {
263                 assertThat(ex, instanceOf(TcpTransport.HttpRequestOnTransportException.class));
264                 assertEquals("This is not a HTTP port", ex.getMessage());
265             }
266         }
267     }
268     public void testTLSHeader() throws IOException {
269 <a name="3"></a>        BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
270         streamOutput.write(0x16);
271         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>streamOutput.write(0x03);
272         byte byte1 = randomByte();
273         streamOutput.write(byte1);
274         byte byte2 = randomByte();
275         streamOutput.write(byte2);
276         streamOutput.write(randomByte());
277         streamOutput.write(randomByte());
278         streamOutput.write</b></font>(randomByte());
279         try {
280             TcpTransport.readMessageLength(streamOutput.bytes());
281             fail("Expected exception");
282         } catch (Exception ex) {
283             assertThat(ex, instanceOf(StreamCorruptedException.class));
284             String expected = "SSL/TLS request received but SSL/TLS is not enabled on this node, got (16,3,"
285                     + Integer.toHexString(byte1 &amp; 0xFF) + ","
286                     + Integer.toHexString(byte2 &amp; 0xFF) + ")";
287             assertEquals(expected, ex.getMessage());
288         }
289     }
290     public void testHTTPResponse() throws IOException {
291         BytesStreamOutput streamOutput = new BytesStreamOutput(1 &lt;&lt; 14);
292         streamOutput.write('H');
293         streamOutput.write('T');
294         streamOutput.write('T');
295         streamOutput.write('P');
296         streamOutput.write(randomByte());
297         streamOutput.write(randomByte());
298         try {
299             TcpTransport.readMessageLength(streamOutput.bytes());
300             fail("Expected exception");
301         } catch (Exception ex) {
302             assertThat(ex, instanceOf(StreamCorruptedException.class));
303             assertEquals("received HTTP response on transport port, ensure that transport port " +
304                     "(not HTTP port) of a remote node is specified in the configuration", ex.getMessage());
305         }
306     }
307     @TestLogging(value = "org.elasticsearch.transport.TcpTransport:DEBUG")
308     public void testExceptionHandling() throws IllegalAccessException {
309         testExceptionHandling(false, new ElasticsearchException("simulated"), true,
310             new MockLogAppender.UnseenEventExpectation("message", "org.elasticsearch.transport.TcpTransport", Level.ERROR, "*"),
311             new MockLogAppender.UnseenEventExpectation("message", "org.elasticsearch.transport.TcpTransport", Level.WARN, "*"),
312             new MockLogAppender.UnseenEventExpectation("message", "org.elasticsearch.transport.TcpTransport", Level.INFO, "*"),
313             new MockLogAppender.UnseenEventExpectation("message", "org.elasticsearch.transport.TcpTransport", Level.DEBUG, "*"));
314         testExceptionHandling(new ElasticsearchException("simulated"),
315             new MockLogAppender.SeenEventExpectation("message", "org.elasticsearch.transport.TcpTransport",
316                 Level.WARN, "exception caught on transport layer [*], closing connection"));
317         testExceptionHandling(new ClosedChannelException(),
318             new MockLogAppender.SeenEventExpectation("message", "org.elasticsearch.transport.TcpTransport",
319                 Level.DEBUG, "close connection exception caught on transport layer [*], disconnecting from relevant node"));
320         testExceptionHandling(new ElasticsearchException("Connection reset"),
321             new MockLogAppender.SeenEventExpectation("message", "org.elasticsearch.transport.TcpTransport",
322                 Level.DEBUG, "close connection exception caught on transport layer [*], disconnecting from relevant node"));
323         testExceptionHandling(new BindException(),
324             new MockLogAppender.SeenEventExpectation("message", "org.elasticsearch.transport.TcpTransport",
325                 Level.DEBUG, "bind exception caught on transport layer [*]"));
326         testExceptionHandling(new CancelledKeyException(),
327             new MockLogAppender.SeenEventExpectation("message", "org.elasticsearch.transport.TcpTransport",
328                 Level.DEBUG, "cancelled key exception caught on transport layer [*], disconnecting from relevant node"));
329         testExceptionHandling(true, new TcpTransport.HttpRequestOnTransportException("test"), false,
330             new MockLogAppender.UnseenEventExpectation("message", "org.elasticsearch.transport.TcpTransport", Level.ERROR, "*"),
331             new MockLogAppender.UnseenEventExpectation("message", "org.elasticsearch.transport.TcpTransport", Level.WARN, "*"),
332             new MockLogAppender.UnseenEventExpectation("message", "org.elasticsearch.transport.TcpTransport", Level.INFO, "*"),
333             new MockLogAppender.UnseenEventExpectation("message", "org.elasticsearch.transport.TcpTransport", Level.DEBUG, "*"));
334         testExceptionHandling(new StreamCorruptedException("simulated"),
335             new MockLogAppender.SeenEventExpectation("message", "org.elasticsearch.transport.TcpTransport",
336                 Level.WARN, "simulated, [*], closing connection"));
337     }
338     private void testExceptionHandling(Exception exception,
339                                        MockLogAppender.LoggingExpectation... expectations) throws IllegalAccessException {
340         testExceptionHandling(true, exception, true, expectations);
341     }
342     private void testExceptionHandling(boolean startTransport, Exception exception, boolean expectClosed,
343                                        MockLogAppender.LoggingExpectation... expectations) throws IllegalAccessException {
344         final TestThreadPool testThreadPool = new TestThreadPool("test");
345         MockLogAppender appender = new MockLogAppender();
346         try {
347             appender.start();
348             Loggers.addAppender(LogManager.getLogger(TcpTransport.class), appender);
349             for (MockLogAppender.LoggingExpectation expectation : expectations) {
350                 appender.addExpectation(expectation);
351             }
352             final Lifecycle lifecycle = new Lifecycle();
353             if (startTransport) {
354                 lifecycle.moveToStarted();
355             }
356             final FakeTcpChannel channel = new FakeTcpChannel();
357             final PlainActionFuture&lt;Void&gt; listener = new PlainActionFuture&lt;&gt;();
358             channel.addCloseListener(listener);
359             var logger = Loggers.getLogger(TcpTransport.class);
360             TcpTransport.handleException(logger, channel, exception, lifecycle,
361                 new OutboundHandler(randomAlphaOfLength(10), Version.CURRENT, new StatsTracker(), testThreadPool,
362                     BigArrays.NON_RECYCLING_INSTANCE));
363             if (expectClosed) {
364                 assertTrue(listener.isDone());
365                 assertThat(listener.actionGet(), nullValue());
366             } else {
367                 assertFalse(listener.isDone());
368             }
369             appender.assertAllExpectationsMatched();
370         } finally {
371             Loggers.removeAppender(LogManager.getLogger(TcpTransport.class), appender);
372             appender.stop();
373             ThreadPool.terminate(testThreadPool, 30, TimeUnit.SECONDS);
374         }
375     }
376 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CreateAlterTableStatementAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19 <a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.analyze;
22 import io.crate.common.collections.Maps;
23 import io.crate.data.RowN;
24 import io.crate.exceptions.ColumnUnknownException;
25 import io.crate.exceptions.InvalidColumnNameException;
26 import io.crate.exceptions.InvalidRelationName;
27 import io.crate.exceptions.InvalidSchemaNameException;
28 import io.crate.exceptions.OperationOnInaccessibleRelationException;
29 import io.crate.exceptions.RelationAlreadyExists;
30 import io.crate.exceptions.UnsupportedFeatureException;
31 import io.crate.metadata.ColumnIdent;
32 import io.crate.metadata.FulltextAnalyzerResolver;
33 import io.crate.metadata.RelationName;
34 import io.crate.metadata.Schemas;
35 import io.crate.planner.PlannerContext;
36 import io.crate.planner.node.ddl.AlterTableAddColumnPlan;
37 import io.crate.planner.node.ddl.AlterTableDropCheckConstraintPlan;
38 import io.crate.planner.node.ddl.AlterTablePlan;
39 import io.crate.planner.node.ddl.CreateBlobTablePlan;
40 import io.crate.planner.node.ddl.CreateTablePlan;
41 import io.crate.planner.operators.SubQueryResults;
42 import io.crate.sql.parser.ParsingException;
43 import io.crate.sql.tree.ColumnPolicy;
44 import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
45 import io.crate.testing.SQLExecutor;
46 import io.crate.types.DataTypes;
47 import org.elasticsearch.cluster.ClusterName;
48 import org.elasticsearch.cluster.ClusterState;
49 import org.elasticsearch.cluster.metadata.AutoExpandReplicas;
50 import org.elasticsearch.cluster.metadata.IndexMetadata;
51 import org.elasticsearch.cluster.metadata.Metadata;
52 import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;
53 import org.elasticsearch.cluster.routing.allocation.decider.MaxRetryAllocationDecider;
54 import</b></font> org.elasticsearch.common.Randomness;
55 import org.elasticsearch.common.settings.Settings;
56 import org.elasticsearch.index.IndexSettings;
57 import org.elasticsearch.index.mapper.MapperService;
58 import org.elasticsearch.test.ClusterServiceUtils;
59 import org.hamcrest.Matchers;
60 import org.junit.Before;
61 import org.junit.Test;
62 import org.junit.jupiter.api.Assertions;
63 import java.io.IOException;
64 import java.util.Arrays;
65 import java.util.Collections;
66 import java.util.List;
67 import java.util.Locale;
68 import java.util.Map;
69 import static com.carrotsearch.randomizedtesting.RandomizedTest.$;
70 import static io.crate.metadata.FulltextAnalyzerResolver.CustomType.ANALYZER;
71 import static io.crate.testing.Asserts.assertThrowsMatches;
72 import static io.crate.testing.TestingHelpers.mapToSortedString;
73 import static org.elasticsearch.cluster.metadata.IndexMetadata.INDEX_ROUTING_EXCLUDE_GROUP_SETTING;
74 import static org.hamcrest.Matchers.hasItem;
75 import static org.hamcrest.Matchers.hasItems;
76 import static org.hamcrest.Matchers.is;
77 import static org.hamcrest.Matchers.isEmptyOrNullString;
78 import static org.hamcrest.Matchers.nullValue;
79 import static org.hamcrest.Matchers.startsWith;
80 import static org.junit.jupiter.api.Assertions.assertThrows;
81 public class CreateAlterTableStatementAnalyzerTest extends CrateDummyClusterServiceUnitTest {
82     private SQLExecutor e;
83     private PlannerContext plannerContext;
84     @Before
85     public void prepare() throws IOException {
86         String analyzerSettings = FulltextAnalyzerResolver.encodeSettings(
87             Settings.builder().put("search", "foobar").build()).utf8ToString();
88         Metadata metadata = Metadata.builder()
89             .persistentSettings(
90                 Settings.builder().put(ANALYZER.buildSettingName("ft_search"), analyzerSettings).build())
91             .build();
92         ClusterState state = ClusterState.builder(ClusterName.DEFAULT)
93             .metadata(metadata)
94             .build();
95         ClusterServiceUtils.setState(clusterService, state);
96         e = SQLExecutor.builder(clusterService, 3, Randomness.get(), List.of())
97             .enableDefaultTables()
98             .build();
99         plannerContext = e.getPlannerContext(clusterService.state());
100     }
101     private &lt;S&gt; S analyze(String stmt, Object... arguments) {
102         return analyze(e, stmt, arguments);
103     }
104     @SuppressWarnings("unchecked")
105     private &lt;S&gt; S analyze(SQLExecutor e, String stmt, Object... arguments) {
106         AnalyzedStatement analyzedStatement = e.analyze(stmt);
107         if (analyzedStatement instanceof AnalyzedCreateTable) {
108             return (S) CreateTablePlan.bind(
109                 (AnalyzedCreateTable) analyzedStatement,
110                 plannerContext.transactionContext(),
111                 plannerContext.nodeContext(),
112                 new RowN(arguments),
113                 SubQueryResults.EMPTY,
114                 new NumberOfShards(clusterService),
115                 e.schemas(),
116                 e.fulltextAnalyzerResolver()
117             );
118         } else if (analyzedStatement instanceof AnalyzedAlterTable) {
119             return (S) AlterTablePlan.bind(
120                 (AnalyzedAlterTable) analyzedStatement,
121                 plannerContext.transactionContext(),
122                 plannerContext.nodeContext(),
123                 new RowN(arguments),
124                 SubQueryResults.EMPTY
125             );
126         } else if (analyzedStatement instanceof AnalyzedAlterTableAddColumn) {
127             return (S) AlterTableAddColumnPlan.bind(
128                 (AnalyzedAlterTableAddColumn) analyzedStatement,
129                 plannerContext.transactionContext(),
130                 plannerContext.nodeContext(),
131                 new RowN(arguments),
132                 SubQueryResults.EMPTY,
133                 null
134             );
135         } else if (analyzedStatement instanceof AnalyzedAlterTableDropCheckConstraint) {
136             return (S) AlterTableDropCheckConstraintPlan.bind(
137                 (AnalyzedAlterTableDropCheckConstraint) analyzedStatement
138             );
139         } else {
140             return (S) analyzedStatement;
141         }
142     }
143     @Test
144     public void testTimestampDataTypeDeprecationWarning() {
145         analyze("create table t (ts timestamp)");
146         assertWarnings(
147             "Column [ts]: Usage of the `TIMESTAMP` data type as a timestamp with zone is deprecated," +
148             " use the `TIMESTAMPTZ` or `TIMESTAMP WITH TIME ZONE` data type instead."
149         );
150     }
151     @Test
152     public void test_cannot_create_table_that_contains_a_column_definition_of_type_time () {
153         expectedException.expect(IllegalArgumentException.class);
154         expectedException.expectMessage("Cannot use the type `time with time zone` for column: ts");
155         analyze("create table t (ts time with time zone)");
156     }
157     @Test
158     public void test_cannot_alter_table_to_add_a_column_definition_of_type_time () {
159         expectedException.expect(IllegalArgumentException.class);
160         expectedException.expectMessage("Cannot use the type `time with time zone` for column: ts");
161         analyze("alter table user_refresh_interval add column ts time with time zone");
162     }
163     @Test
164 <a name="4"></a>    public void testCreateTableInSystemSchemasIsProhibited() {
165         for (String schema : Schemas.READ_ONLY_SYSTEM_SCHEMAS) {
166             try {
167                 analyze(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>String.format("CREATE TABLE %s.%s (ordinal INTEGER, name STRING)", schema, "my_table"));
168                 fail("create table in read-only schema must fail");
169             } catch (IllegalArgumentException e) {
170                 assertThat(e.getLocalizedMessage(), startsWith("Cannot create relation in read-only schema: " + schema));
171             }
172         }</b></font>
173     }
174     @Test
175     public void testCreateTableWithAlternativePrimaryKeySyntax() {
176         BoundCreateTable analysis = analyze(
177             "create table foo (id integer, name string, primary key (id, name))"
178 <a name="17"></a>        );
179         String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
180         <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(primaryKeys.length, is(2));
181         assertThat(primaryKeys[0], is("id"));
182         assertThat(primaryKeys[1], is("name"));
183     }
184     @Test</b></font>
185     @SuppressWarnings("unchecked")
186     public void testSimpleCreateTable() {
187         BoundCreateTable analysis = analyze(
188             "create table foo (id integer primary key, name string not null) " +
189             "clustered into 3 shards with (number_of_replicas=0)");
190         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("3"));
191         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is("0"));
192         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
193         assertNull(metaMapping.get("columns"));
194         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
195         Map&lt;String, Object&gt; idMapping = (Map&lt;String, Object&gt;) mappingProperties.get("id");
196         assertThat(idMapping.get("type"), is("integer"));
197         Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) mappingProperties.get("name");
198         assertThat(nameMapping.get("type"), is("keyword"));
199         String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
200         assertThat(primaryKeys.length, is(1));
201         assertThat(primaryKeys[0], is("id"));
202         String[] notNullColumns = analysis.notNullColumns().toArray(new String[0]);
203         assertThat(notNullColumns.length, is(1));
204         assertThat(notNullColumns[0], is("name"));
205     }
206 <a name="13"></a>
207     @Test
208     public void testCreateTableWithDefaultNumberOfShards() {
209         BoundCreateTable analysis = <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>analyze("create table foo (id integer primary key, name string)");
210         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("6"));
211     }
212 <a name="12"></a>
213     @Test</b></font>
214     public void testCreateTableWithDefaultNumberOfShardsWithClusterByClause() {
215         BoundCreateTable analysis = <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>analyze(
216             "create table foo (id integer primary key) clustered by (id)"
217         );
218         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("6"));
219     }
220 <a name="11"></a>
221     @Test</b></font>
222     public void testCreateTableNumberOfShardsProvidedInClusteredClause() {
223         BoundCreateTable analysis = <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>analyze(
224             "create table foo (id integer primary key) " +
225             "clustered by (id) into 8 shards"
226         );
227         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("8"));
228     }
229     @Test</b></font>
230     public void testCreateTableWithTotalFieldsLimit() {
231         BoundCreateTable analysis = analyze(
232             "CREATE TABLE foo (id int primary key) " +
233             "with (\"mapping.total_fields.limit\"=5000)");
234         assertThat(analysis.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()), is("5000"));
235     }
236     @Test
237     public void testCreateTableWithRefreshInterval() {
238         BoundCreateTable analysis = analyze(
239             "CREATE TABLE foo (id int primary key, content string) " +
240             "with (refresh_interval='5000ms')");
241         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()), is("5s"));
242     }
243     @Test
244     public void testCreateTableWithNumberOfShardsOnWithClauseIsInvalid() {
245         expectedException.expect(IllegalArgumentException.class);
246         expectedException.expectMessage("Invalid property \"number_of_shards\" passed to [ALTER | CREATE] TABLE statement");
247         analyze("CREATE TABLE foo (id int primary key, content string) " +
248                 "with (number_of_shards=8)");
249     }
250     @Test(expected = IllegalArgumentException.class)
251     public void testCreateTableWithRefreshIntervalWrongNumberFormat() {
252         analyze("CREATE TABLE foo (id int primary key, content string) " +
253                 "with (refresh_interval='1asdf')");
254     }
255     @Test
256     public void testAlterTableWithRefreshInterval() {
257         BoundAlterTable analysisSet = analyze(
258             "ALTER TABLE user_refresh_interval " +
259             "SET (refresh_interval = '5000ms')");
260 <a name="15"></a>        assertEquals("5s", analysisSet.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()));
261         <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BoundAlterTable analysisReset = analyze(
262             "ALTER TABLE user_refresh_interval " +
263             "RESET (refresh_interval)");
264         assertEquals("1s", analysisReset.tableParameter().settings().get(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey()));
265     }
266     @Test</b></font>
267     public void testTotalFieldsLimitCanBeUsedWithAlterTable() {
268         BoundAlterTable analysisSet = analyze(
269             "ALTER TABLE users " +
270             "SET (\"mapping.total_fields.limit\" = '5000')");
271 <a name="14"></a>        assertEquals("5000", analysisSet.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()));
272         <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BoundAlterTable analysisReset = analyze(
273             "ALTER TABLE users " +
274             "RESET (\"mapping.total_fields.limit\")");
275         assertEquals("1000", analysisReset.tableParameter().settings().get(MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey()));
276     }
277     @Test</b></font>
278     public void testAlterTableWithColumnPolicy() {
279         BoundAlterTable analysisSet = analyze(
280             "ALTER TABLE user_refresh_interval " +
281             "SET (column_policy = 'strict')");
282         assertEquals(
283             ColumnPolicy.STRICT.lowerCaseName(),
284             analysisSet.tableParameter().mappings().get(TableParameters.COLUMN_POLICY.getKey()));
285     }
286     @Test
287     public void testAlterTableWithInvalidColumnPolicy() {
288         expectedException.expect(IllegalArgumentException.class);
289         expectedException.expectMessage("Invalid value for argument 'column_policy'");
290         analyze("ALTER TABLE user_refresh_interval " +
291                   "SET (column_policy = 'ignored')");
292     }
293     @Test
294     public void testAlterTableWithMaxNGramDiffSetting() {
295         BoundAlterTable analysisSet = analyze(
296             "ALTER TABLE users " +
297             "SET (max_ngram_diff = 42)");
298         assertThat(analysisSet.tableParameter().settings().get(IndexSettings.MAX_NGRAM_DIFF_SETTING.getKey()), is("42"));
299     }
300     @Test
301     public void testAlterTableWithMaxShingleDiffSetting() {
302         BoundAlterTable analysisSet = analyze(
303             "ALTER TABLE users " +
304             "SET (max_shingle_diff = 43)");
305         assertThat(analysisSet.tableParameter().settings().get(IndexSettings.MAX_SHINGLE_DIFF_SETTING.getKey()), is("43"));
306     }
307     @Test
308     @SuppressWarnings("unchecked")
309     public void testCreateTableWithClusteredBy() {
310         BoundCreateTable analysis = analyze(
311             "create table foo (id integer, name string) clustered by(id)");
312         Map&lt;String, Object&gt; meta = (Map) analysis.mapping().get("_meta");
313         assertNotNull(meta);
314         assertThat(meta.get("routing"), is("id"));
315     }
316     @Test(expected = IllegalArgumentException.class)
317     @SuppressWarnings("unchecked")
318     public void testCreateTableWithClusteredByNotInPrimaryKeys() {
319         analyze("create table foo (id integer primary key, name string) clustered by(name)");
320     }
321     @Test
322     @SuppressWarnings("unchecked")
323     public void testCreateTableWithObjects() {
324         BoundCreateTable analysis = analyze(
325             "create table foo (id integer primary key, details object as (name string, age integer))");
326         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
327         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("details");
328         assertThat(details.get("type"), is("object"));
329         assertThat(details.get("dynamic"), is("true"));
330         Map&lt;String, Object&gt; detailsProperties = (Map&lt;String, Object&gt;) details.get("properties");
331         Map&lt;String, Object&gt; nameProperties = (Map&lt;String, Object&gt;) detailsProperties.get("name");
332         assertThat(nameProperties.get("type"), is("keyword"));
333         Map&lt;String, Object&gt; ageProperties = (Map&lt;String, Object&gt;) detailsProperties.get("age");
334         assertThat(ageProperties.get("type"), is("integer"));
335     }
336     @Test
337     @SuppressWarnings("unchecked")
338     public void testCreateTableWithStrictObject() {
339         BoundCreateTable analysis = analyze(
340             "create table foo (id integer primary key, details object(strict) as (name string, age integer))");
341         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
342         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("details");
343         assertThat(details.get("type"), is("object"));
344         assertThat(details.get("dynamic"), is("strict"));
345     }
346     @Test
347     @SuppressWarnings("unchecked")
348     public void testCreateTableWithIgnoredObject()  {
349         BoundCreateTable analysis = analyze(
350             "create table foo (id integer primary key, details object(ignored))");
351         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
352         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("details");
353         assertThat(details.get("type"), is("object"));
354         assertThat(details.get("dynamic"), is("false"));
355     }
356     @Test
357     @SuppressWarnings("unchecked")
358     public void testCreateTableWithSubscriptInFulltextIndexDefinition() {
359         BoundCreateTable analysis = analyze(
360             "create table my_table1g (" +
361             "   title string, " +
362             "   author object(dynamic) as ( " +
363             "   name string, " +
364             "   birthday timestamp with time zone" +
365             "), " +
366             "INDEX author_title_ft using fulltext(title, author['name']))");
367         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
368         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("author");
369         Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) ((Map&lt;String, Object&gt;) details.get("properties")).get("name");
370         assertThat(((List&lt;String&gt;) nameMapping.get("copy_to")).get(0), is("author_title_ft"));
371     }
372     @Test(expected = ColumnUnknownException.class)
373     public void testCreateTableWithInvalidFulltextIndexDefinition() {
374         analyze(
375             "create table my_table1g (" +
376             "   title string, " +
377             "   author object(dynamic) as ( " +
378             "   name string, " +
379             "   birthday timestamp with time zone" +
380             "), " +
381             "INDEX author_title_ft using fulltext(title, author['name']['foo']['bla']))");
382     }
383     @SuppressWarnings("unchecked")
384     @Test
385     public void testCreateTableWithArray() {
386         BoundCreateTable analysis = analyze(
387             "create table foo (id integer primary key, details array(string), more_details text[])");
388         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
389         Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("details");
390         assertThat(details.get("type"), is("array"));
391         Map&lt;String, Object&gt; inner = (Map&lt;String, Object&gt;) details.get("inner");
392         assertThat(inner.get("type"), is("keyword"));
393         Map&lt;String, Object&gt; moreDetails = (Map&lt;String, Object&gt;) mappingProperties.get("more_details");
394         assertThat(moreDetails.get("type"), is("array"));
395         Map&lt;String, Object&gt; moreDetailsInner = (Map&lt;String, Object&gt;) details.get("inner");
396         assertThat(moreDetailsInner.get("type"), is("keyword"));
397     }
398     @Test
399     @SuppressWarnings("unchecked")
400     public void testCreateTableWithObjectsArray() {
401         BoundCreateTable analysis = analyze(
402             "create table foo (id integer primary key, details array(object as (name string, age integer, tags array(string))))");
403         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
404         assertThat(mapToSortedString(mappingProperties),
405                    is("details={inner={dynamic=true, position=2, properties={age={position=4, type=integer}, " +
406                       "name={position=3, type=keyword}, " +
407                       "tags={inner={position=5, type=keyword}, type=array}}, type=object}, type=array}, " +
408                       "id={position=1, type=integer}"));
409     }
410     @Test
411     @SuppressWarnings("unchecked")
412     public void testCreateTableWithAnalyzer() {
413         BoundCreateTable analysis = analyze(
414             "create table foo (id integer primary key, content string INDEX using fulltext with (analyzer='german'))");
415         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
416         Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get("content");
417         assertThat(contentMapping.get("index"), nullValue());
418         assertThat(contentMapping.get("analyzer"), is("german"));
419     }
420     @Test
421     @SuppressWarnings("unchecked")
422     public void testCreateTableWithAnalyzerParameter() {
423         BoundCreateTable analysis = analyze(
424             "create table foo (id integer primary key, content string INDEX using fulltext with (analyzer=?))",
425             "german"
426         );
427         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
428         Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get("content");
429         assertThat(contentMapping.get("index"), nullValue());
430         assertThat(contentMapping.get("analyzer"), is("german"));
431     }
432     @SuppressWarnings("unchecked")
433     @Test
434     public void textCreateTableWithCustomAnalyzerInNestedColumn() {
435         BoundCreateTable analysis = analyze(
436             "create table ft_search (" +
437             "\"user\" object (strict) as (" +
438             "name string index using fulltext with (analyzer='ft_search') " +
439             ")" +
440             ")");
441         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
442 <a name="2"></a>        Map&lt;String, Object&gt; details = (Map&lt;String, Object&gt;) mappingProperties.get("user");
443         Map&lt;String, Object&gt; nameMapping = (Map&lt;String, Object&gt;) ((Map&lt;String, Object&gt;) details.get("properties")).get("name");
444         assertThat(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>nameMapping.get("index"), nullValue());
445         assertThat(nameMapping.get("analyzer"), is("ft_search"));
446         assertThat(analysis.tableParameter().settings().get("search"), is("foobar"));
447     }
448     @Test</b></font>
449     public void testCreateTableWithSchemaName() {
450         BoundCreateTable analysis =
451             analyze("create table something.foo (id integer primary key)");
452         RelationName relationName = analysis.tableIdent();
453         assertThat(relationName.schema(), is("something"));
454         assertThat(relationName.name(), is("foo"));
455     }
456     @Test
457     @SuppressWarnings("unchecked")
458     public void testCreateTableWithIndexColumn() {
459         BoundCreateTable analysis = analyze(
460             "create table foo (id integer primary key, content string, INDEX content_ft using fulltext (content))");
461         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
462         Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get("content");
463         assertThat((String) contentMapping.get("index"), isEmptyOrNullString());
464         assertThat(((List&lt;String&gt;) contentMapping.get("copy_to")).get(0), is("content_ft"));
465         Map&lt;String, Object&gt; ft_mapping = (Map&lt;String, Object&gt;) mappingProperties.get("content_ft");
466         assertThat(ft_mapping.get("index"), nullValue());
467         assertThat(ft_mapping.get("analyzer"), is("standard"));
468     }
469     @Test
470     @SuppressWarnings("unchecked")
471     public void testCreateTableWithPlainIndexColumn() {
472         BoundCreateTable analysis = analyze(
473             "create table foo (id integer primary key, content string, INDEX content_ft using plain (content))");
474         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
475         Map&lt;String, Object&gt; contentMapping = (Map&lt;String, Object&gt;) mappingProperties.get("content");
476         assertThat((String) contentMapping.get("index"), isEmptyOrNullString());
477         assertThat(((List&lt;String&gt;) contentMapping.get("copy_to")).get(0), is("content_ft"));
478         Map&lt;String, Object&gt; ft_mapping = (Map&lt;String, Object&gt;) mappingProperties.get("content_ft");
479         assertThat(ft_mapping.get("index"), nullValue());
480         assertThat(ft_mapping.get("analyzer"), is("keyword"));
481     }
482     @Test
483     public void testCreateTableWithIndexColumnOverNonString() {
484         expectedException.expect(IllegalArgumentException.class);
485         expectedException.expectMessage("INDEX definition only support 'string' typed source columns");
486         analyze("create table foo (id integer, id2 integer, INDEX id_ft using fulltext (id, id2))");
487     }
488     @Test
489     public void testCreateTableWithIndexColumnOverNonString2() {
490         expectedException.expect(IllegalArgumentException.class);
491         expectedException.expectMessage("INDEX definition only support 'string' typed source columns");
492         analyze("create table foo (id integer, name string, INDEX id_ft using fulltext (id, name))");
493     }
494     @Test
495     public void testChangeNumberOfReplicas() {
496 <a name="8"></a>        BoundAlterTable analysis =
497             analyze("alter table users set (number_of_replicas=2)");
498         assertThat(<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>analysis.table().ident().name(), is("users"));
499         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is("2"));
500     }
501     @Test</b></font>
502     public void testResetNumberOfReplicas() {
503         BoundAlterTable analysis =
504 <a name="7"></a>            analyze("alter table users reset (number_of_replicas)");
505         assertThat(analysis.table().ident().name(), is("users"));
506         assertThat(analysis.tableParameter().settings().get(<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey()), is("0"));
507         assertThat(analysis.tableParameter().settings().get(AutoExpandReplicas.SETTING.getKey()), is("0-1"));
508     }
509     @Test(expected = IllegalArgumentE</b></font>xception.class)
510     public void testAlterTableWithInvalidProperty() {
511         analyze("alter table users set (foobar='2')");
512     }
513     @Test
514     public void testAlterSystemTable() {
515         expectedException.expect(OperationOnInaccessibleRelationException.class);
516         expectedException.expectMessage("The relation \"sys.shards\" doesn't support or allow ALTER " +
517                                         "operations, as it is read-only.");
518         analyze("alter table sys.shards reset (number_of_replicas)");
519     }
520     @Test
521     public void testCreateTableWithMultiplePrimaryKeys() {
522         BoundCreateTable analysis = analyze(
523             "create table test (id integer primary key, name string primary key)");
524         String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
525         assertThat(primaryKeys.length, is(2));
526         assertThat(primaryKeys[0], is("id"));
527         assertThat(primaryKeys[1], is("name"));
528     }
529     @Test
530     public void testCreateTableWithMultiplePrimaryKeysAndClusteredBy() {
531         BoundCreateTable analysis = analyze(
532             "create table test (id integer primary key, name string primary key) " +
533             "clustered by(name)");
534         String[] primaryKeys = analysis.primaryKeys().toArray(new String[0]);
535         assertThat(primaryKeys.length, is(2));
536         assertThat(primaryKeys[0], is("id"));
537         assertThat(primaryKeys[1], is("name"));
538         //noinspection unchecked
539         Map&lt;String, Object&gt; meta = (Map) analysis.mapping().get("_meta");
540         assertNotNull(meta);
541         assertThat(meta.get("routing"), is("name"));
542     }
543     @Test
544     public void testCreateTableWithObjectAndUnderscoreColumnPrefix() {
545         BoundCreateTable analysis = analyze("create table test (o object as (_id integer), name string)");
546         assertThat(analysis.analyzedTableElements().columns().size(), is(2));         AnalyzedColumnDefinition&lt;Object&gt; column = analysis.analyzedTableElements().columns().get(0);
547         assertEquals(column.ident(), new ColumnIdent("o"));
548         assertThat(column.children().size(), is(1));
549         AnalyzedColumnDefinition&lt;Object&gt; xColumn = column.children().get(0);
550         assertEquals(xColumn.ident(), new ColumnIdent("o", Collections.singletonList("_id")));
551     }
552     @Test(expected = InvalidColumnNameException.class)
553     public void testCreateTableWithUnderscoreColumnPrefix() {
554         analyze("create table test (_id integer, name string)");
555     }
556     @Test(expected = ParsingException.class)
557     public void testCreateTableWithColumnDot() {
558         analyze("create table test (dot.column integer)");
559     }
560     @Test(expected = InvalidRelationName.class)
561     public void testCreateTableIllegalTableName() {
562         analyze("create table \"abc.def\" (id integer primary key, name string)");
563     }
564     @Test
565     public void testTableStartWithUnderscore() {
566         expectedException.expect(InvalidRelationName.class);
567         expectedException.expectMessage("Relation name \"doc._invalid\" is invalid.");
568         analyze("create table _invalid (id integer primary key)");
569     }
570     @Test
571     public void testHasColumnDefinition() {
572         BoundCreateTable analysis = analyze(
573             "create table my_table (" +
574             "  id integer primary key, " +
575             "  name string, " +
576             "  indexed string index using fulltext with (analyzer='german')," +
577             "  arr array(object as(" +
578             "    nested float," +
579             "    nested_object object as (id byte)" +
580             "  ))," +
581             "  obj object as ( content string )," +
582             "  index ft using fulltext(name, obj['content']) with (analyzer='standard')" +
583             ")");
584         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("id")));
585         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("name")));
586         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("indexed")));
587         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("arr")));
588         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("arr.nested")));
589         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("arr.nested_object.id")));
590 <a name="6"></a>        assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("obj")));
591         assertTrue(analysis.hasColumnDefinition(ColumnIdent.fromPath("obj.content")));
592         assertFalse(<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>analysis.hasColumnDefinition(ColumnIdent.fromPath("arr.nested.wrong")));
593         assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath("ft")));
594         assertFalse(analysis.hasColumnDefinition(ColumnIdent.fromPath("obj.content.ft")));
595     }
596     @Test</b></font>
597     public void testCreateTableWithGeoPoint() {
598         BoundCreateTable analyze = analyze(
599             "create table geo_point_table (\n" +
600             "    id integer primary key,\n" +
601             "    my_point geo_point\n" +
602             ")\n");
603         Map my_point = (Map) analyze.mappingProperties().get("my_point");
604         assertEquals("geo_point", my_point.get("type"));
605     }
606     @Test(expected = IllegalArgumentException.class)
607     public void testClusteredIntoZeroShards() {
608         analyze("create table my_table (" +
609                 "  id integer," +
610                 "  name string" +
611                 ") clustered into 0 shards");
612     }
613     @Test
614     public void testBlobTableClusteredIntoZeroShards() {
615         AnalyzedCreateBlobTable blobTable = analyze("create blob table my_table clustered into 0 shards");
616         expectedException.expect(IllegalArgumentException.class);
617         expectedException.expectMessage("num_shards in CLUSTERED clause must be greater than 0");
618         CreateBlobTablePlan.buildSettings(
619             blobTable.createBlobTable(),
620             plannerContext.transactionContext(),
621             plannerContext.nodeContext(),
622             new RowN(new Object[0]),
623             SubQueryResults.EMPTY,
624             new NumberOfShards(clusterService));
625     }
626 <a name="5"></a>
627     @Test
628     public void testEarlyPrimaryKeyConstraint() {
629         BoundCreateTable analysis = <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>analyze(
630             "create table my_table (" +
631             "primary key (id1, id2)," +
632             "id1 integer," +
633             "id2 long" +
634             ")");
635         assertThat(analysis.primaryKeys().size(), is(2));
636         assertThat(analysis.primaryKeys(), hasItems("id1", "id2"));
637     }
638     @Test(expected = ColumnUnknownException.cl</b></font>ass)
639     public void testPrimaryKeyConstraintNonExistingColumns() {
640         analyze("create table my_table (" +
641                 "primary key (id1, id2)," +
642                 "title string," +
643                 "name string" +
644                 ")");
645     }
646     @SuppressWarnings("unchecked")
647     @Test
648     public void testEarlyIndexDefinition() {
649         BoundCreateTable analysis = analyze(
650             "create table my_table (" +
651             "index ft using fulltext(title, name) with (analyzer='snowball')," +
652             "title string," +
653             "name string" +
654             ")");
655         Map&lt;String, Object&gt; metaMap = (Map) analysis.mapping().get("_meta");
656         assertThat(
657             metaMap.get("indices").toString(),
658             is("{ft={}}"));
659         assertThat(
660             (List&lt;String&gt;) ((Map&lt;String, Object&gt;) analysis.mappingProperties()
661                 .get("title")).get("copy_to"),
662             hasItem("ft")
663         );
664         assertThat(
665             (List&lt;String&gt;) ((Map&lt;String, Object&gt;) analysis.mappingProperties()
666                 .get("name")).get("copy_to"),
667             hasItem("ft"));
668     }
669     @Test(expected = ColumnUnknownException.class)
670     public void testIndexDefinitionNonExistingColumns() {
671         analyze("create table my_table (" +
672                 "index ft using fulltext(id1, id2) with (analyzer='snowball')," +
673                 "title string," +
674                 "name string" +
675                 ")");
676     }
677     @Test(expected = IllegalArgumentException.class)
678     public void testAnalyzerOnInvalidType() {
679         analyze("create table my_table (x integer INDEX using fulltext with (analyzer='snowball'))");
680     }
681     @Test
682     public void createTableNegativeReplicas() {
683         expectedException.expect(IllegalArgumentException.class);
684         expectedException.expectMessage("Failed to parse value [-1] for setting [number_of_replicas] must be &gt;= 0");
685         analyze("create table t (id int, name string) with (number_of_replicas=-1)");
686     }
687     @Test(expected = IllegalArgumentException.class)
688     public void testCreateTableSameColumn() {
689         analyze("create table my_table (title string, title integer)");
690     }
691     @Test(expected = UnsupportedOperationException.class)
692     public void testCreateTableWithArrayPrimaryKeyUnsupported() {
693         analyze("create table t (id array(int) primary key)");
694     }
695     @Test
696     public void testCreateTableWithClusteredIntoShardsParameter() {
697         BoundCreateTable analysis = analyze(
698             "create table t (id int primary key) clustered into ? shards", 2);
699         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("2"));
700     }
701     @Test
702     public void testCreateTableWithClusteredIntoShardsParameterNonNumeric() {
703         expectedException.expect(IllegalArgumentException.class);
704         expectedException.expectMessage("invalid number 'foo'");
705         analyze("create table t (id int primary key) clustered into ? shards", "foo");
706     }
707     @Test
708     public void testCreateTableWithParitionedColumnInClusteredBy() {
709         expectedException.expect(IllegalArgumentException.class);
710         expectedException.expectMessage("Cannot use CLUSTERED BY column in PARTITIONED BY clause");
711         analyze("create table t(id int primary key) partitioned by (id) clustered by (id)");
712     }
713     @Test
714     public void testCreateTableUsesDefaultSchema() {
715         SQLExecutor sqlExecutor = SQLExecutor.builder(clusterService, 1, Randomness.get(), List.of())
716             .setSearchPath("firstSchema", "secondSchema")
717             .build();
718         BoundCreateTable analysis = analyze(sqlExecutor, "create table t (id int)");
719         assertThat(analysis.tableIdent().schema(), is(sqlExecutor.getSessionContext().searchPath().currentSchema()));
720     }
721     @Test
722     public void testCreateTableWithEmptySchema() {
723         expectedException.expect(InvalidSchemaNameException.class);
724         expectedException.expectMessage("schema name \"\" is invalid.");
725         analyze("create table \"\".my_table (" +
726                 "id long primary key" +
727                 ")");
728     }
729     @Test
730     public void testCreateTableWithIllegalSchema() {
731         expectedException.expect(InvalidSchemaNameException.class);
732         expectedException.expectMessage("schema name \"with.\" is invalid.");
733         analyze("create table \"with.\".my_table (" +
734                 "id long primary key" +
735                 ")");
736     }
737     @Test
738     public void testCreateTableWithInvalidColumnName() {
739         expectedException.expect(InvalidColumnNameException.class);
740         expectedException.expectMessage(
741             "\"_test\" conflicts with system column pattern");
742         analyze("create table my_table (\"_test\" string)");
743     }
744     @Test
745     public void testCreateTableShouldRaiseErrorIfItExists() {
746         expectedException.expect(RelationAlreadyExists.class);
747         analyze("create table users (\"'test\" string)");
748     }
749     @Test
750     public void testExplicitSchemaHasPrecedenceOverDefaultSchema() {
751         SQLExecutor e = SQLExecutor.builder(clusterService).setSearchPath("hoschi").build();
752         BoundCreateTable statement = analyze(e, "create table foo.bar (x string)");
753         assertThat(statement.tableIdent().schema(), is("foo"));
754     }
755     @Test
756     public void testDefaultSchemaIsAddedToTableIdentIfNoExplicitSchemaExistsInTheStatement() {
757         SQLExecutor e = SQLExecutor.builder(clusterService).setSearchPath("hoschi").build();
758         BoundCreateTable statement = analyze(e, "create table bar (x string)");
759         assertThat(statement.tableIdent().schema(), is("hoschi"));
760     }
761     @Test
762     public void testChangeReadBlock() {
763         BoundAlterTable analysis =
764             analyze("alter table users set (\"blocks.read\"=true)");
765         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_SETTING.getKey()), is("true"));
766     }
767     @Test
768     public void testChangeWriteBlock() {
769         BoundAlterTable analysis =
770             analyze("alter table users set (\"blocks.write\"=true)");
771         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_WRITE_SETTING.getKey()), is("true"));
772     }
773     @Test
774     public void testChangeMetadataBlock() {
775         BoundAlterTable analysis =
776             analyze("alter table users set (\"blocks.metadata\"=true)");
777         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_METADATA_SETTING.getKey()), is("true"));
778     }
779     @Test
780     public void testChangeReadOnlyBlock() {
781         BoundAlterTable analysis =
782             analyze("alter table users set (\"blocks.read_only\"=true)");
783         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_READ_ONLY_SETTING.getKey()), is("true"));
784     }
785     @Test
786     public void testChangeBlockReadOnlyAllowDelete() {
787         BoundAlterTable analysis =
788             analyze("alter table users set (\"blocks.read_only_allow_delete\"=true)");
789         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.getKey()), is("true"));
790     }
791     @Test
792     public void testChangeBlockReadOnlyAllowedDeletePartitionedTable() {
793         BoundAlterTable analysis =
794             analyze("alter table parted set (\"blocks.read_only_allow_delete\"=true)");
795         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.getKey()), is("true"));
796     }
797     @Test
798     public void testChangeFlushThresholdSize() {
799         BoundAlterTable analysis =
800             analyze("alter table users set (\"translog.flush_threshold_size\"='300b')");
801         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey()), is("300b"));
802     }
803     @Test
804     public void testChangeTranslogInterval() {
805         BoundAlterTable analysis =
806             analyze("alter table users set (\"translog.sync_interval\"='100ms')");
807         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()), is("100ms"));
808     }
809     @Test
810     public void testChangeTranslogDurability() {
811         BoundAlterTable analysis =
812             analyze("alter table users set (\"translog.durability\"='ASYNC')");
813         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey()), is("ASYNC"));
814     }
815     @Test
816     public void testRoutingAllocationEnable() {
817         BoundAlterTable analysis =
818             analyze("alter table users set (\"routing.allocation.enable\"=\"none\")");
819         assertThat(analysis.tableParameter().settings().get(EnableAllocationDecider.INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey()), is("none"));
820     }
821     @Test
822     public void testRoutingAllocationValidation() {
823         expectedException.expect(IllegalArgumentException.class);
824         analyze("alter table users set (\"routing.allocation.enable\"=\"foo\")");
825     }
826     @Test
827     public void testAlterTableSetShards() {
828         BoundAlterTable analysis =
829             analyze("alter table users set (\"number_of_shards\"=1)");
830         assertThat(analysis.table().ident().name(), is("users"));
831         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("1"));
832     }
833     @Test
834     public void testAlterTableResetShards() {
835         BoundAlterTable analysis =
836             analyze("alter table users reset (\"number_of_shards\")");
837         assertThat(analysis.table().ident().name(), is("users"));
838         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey()), is("5"));
839     }
840     @Test
841     public void testTranslogSyncInterval() {
842         BoundAlterTable analysis =
843             analyze("alter table users set (\"translog.sync_interval\"='1s')");
844         assertThat(analysis.table().ident().name(), is("users"));
845         assertThat(analysis.tableParameter().settings().get(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey()), is("1s"));
846     }
847     @Test
848     public void testAllocationMaxRetriesValidation() {
849         BoundAlterTable analysis =
850             analyze("alter table users set (\"allocation.max_retries\"=1)");
851         assertThat(analysis.tableParameter().settings().get(MaxRetryAllocationDecider.SETTING_ALLOCATION_MAX_RETRY.getKey()), is("1"));
852     }
853     @Test
854     public void testCreateReadOnlyTable() {
855         BoundCreateTable analysis = analyze(
856             "create table foo (id integer primary key, name string) "
857             + "clustered into 3 shards with (\"blocks.read_only\"=true)");
858         assertThat(analysis.tableParameter().settings().get(IndexMetadata.INDEX_READ_ONLY_SETTING.getKey()), is("true"));
859     }
860 <a name="3"></a>    @SuppressWarnings("unchecked")
861     @Test
862     public void testCreateTableWithGeneratedColumn() {
863         BoundCreateTable analysis = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>analyze(
864             "create table foo (" +
865             "   ts timestamp with time zone," +
866             "   day as date_trunc('day', ts))");
867         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
868         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
869         assertThat(generatedColumnsMapping.size(), is(1));
870         assertThat(generatedColumnsMapping.get("day"), is</b></font>("date_trunc('day', ts)"));
871         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
872         Map&lt;String, Object&gt; dayMapping = (Map&lt;String, Object&gt;) mappingProperties.get("day");
873         assertThat(dayMapping.get("type"), is("date"));
874         Map&lt;String, Object&gt; tsMapping = (Map&lt;String, Object&gt;) mappingProperties.get("ts");
875         assertThat(tsMapping.get("type"), is("date"));
876     }
877     @Test
878     public void testCreateTableWithColumnOfArrayTypeAndGeneratedExpression() {
879         BoundCreateTable analysis = analyze(
880             "create table foo (arr array(integer) as ([1.0, 2.0]))");
881         assertThat(
882             mapToSortedString(analysis.mappingProperties()),
883             is("arr={inner={position=1, type=integer}, type=array}"));
884     }
885     @SuppressWarnings("unchecked")
886     @Test
887     public void testCreateTableGeneratedColumnWithCast() {
888         BoundCreateTable analysis = analyze(
889             "create table foo (" +
890             "   ts timestamp with time zone," +
891             "   day timestamp with time zone GENERATED ALWAYS as ts + 1)");
892         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
893         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
894         assertThat(
895             generatedColumnsMapping.get("day"),
896             is("(ts + 1::bigint)"));
897         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
898         Map&lt;String, Object&gt; dayMapping = (Map&lt;String, Object&gt;) mappingProperties.get("day");
899         assertThat(dayMapping.get("type"), is("date"));
900     }
901     @SuppressWarnings("unchecked")
902     @Test
903     public void testCreateTableWithCurrentTimestampAsGeneratedColumnIsntNormalized() {
904         BoundCreateTable analysis = analyze(
905             "create table foo (ts timestamp with time zone GENERATED ALWAYS as current_timestamp(3))");
906         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
907         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
908         assertThat(generatedColumnsMapping.size(), is(1));
909         assertThat(generatedColumnsMapping.get("ts"), is("current_timestamp(3)"));
910     }
911     @SuppressWarnings("unchecked")
912     @Test
913     public void testCreateTableGeneratedColumnWithSubscript() {
914         BoundCreateTable analysis = analyze(
915             "create table foo (\"user\" object as (name string), name as concat(\"user\"['name'], 'foo'))");
916         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
917         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
918         assertThat(generatedColumnsMapping.get("name"), is("concat(\"user\"['name'], 'foo')"));
919     }
920     @SuppressWarnings("unchecked")
921     @Test
922     public void testCreateTableGeneratedColumnParameter() {
923         BoundCreateTable analysis = analyze(
924             "create table foo (\"user\" object as (name string), name as concat(\"user\"['name'], ?))", $("foo"));
925         Map&lt;String, Object&gt; metaMapping = ((Map) analysis.mapping().get("_meta"));
926         Map&lt;String, String&gt; generatedColumnsMapping = (Map&lt;String, String&gt;) metaMapping.get("generated_columns");
927         assertThat(generatedColumnsMapping.get("name"), is("concat(\"user\"['name'], 'foo')"));
928     }
929     @Test
930     public void testCreateTableGeneratedColumnWithInvalidType() {
931         expectedException.expect(IllegalArgumentException.class);
932         expectedException.expectMessage("expression value type" +
933                                         " 'timestamp with time zone' not supported for conversion to 'ip'");
934         analyze(
935             "create table foo (" +
936             "   ts timestamp with time zone," +
937             "   day ip GENERATED ALWAYS as date_trunc('day', ts))");
938     }
939     @Test
940     public void testCreateTableGeneratedColumnWithMatch() {
941         expectedException.expect(UnsupportedFeatureException.class);
942         expectedException.expectMessage("Cannot use MATCH in CREATE TABLE statements");
943         analyze("create table foo (name string, bar as match(name, 'crate'))");
944     }
945     @Test
946     public void testCreateTableGeneratedColumnBasedOnGeneratedColumn() {
947         expectedException.expect(IllegalArgumentException.class);
948         expectedException.expectMessage("A generated column cannot be based on a generated column");
949         analyze(
950             "create table foo (" +
951             "   ts timestamp with time zone," +
952             "   day as date_trunc('day', ts)," +
953             "   date_string as cast(day as string))");
954     }
955     @Test
956     public void testCreateTableGeneratedColumnBasedOnUnknownColumn() {
957         expectedException.expect(ColumnUnknownException.class);
958         expectedException.expectMessage("Column unknown_col unknown");
959         analyze(
960             "create table foo (" +
961             "   ts timestamp with time zone," +
962             "   day as date_trunc('day', ts)," +
963             "   date_string as cast(unknown_col as string))");
964     }
965     @Test
966     public void testCreateTableWithDefaultExpressionLiteral() {
967         BoundCreateTable analysis = analyze(
968             "create table foo (name text default 'bar')");
969         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
970         assertThat(mapToSortedString(mappingProperties),
971                    is("name={default_expr='bar', position=1, type=keyword}"));
972     }
973     @Test
974     public void testCreateTableWithDefaultExpressionFunction() {
975         BoundCreateTable analysis = analyze(
976             "create table foo (name text default upper('bar'))");
977         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
978         assertThat(mapToSortedString(mappingProperties),
979                    is("name={default_expr='BAR', position=1, type=keyword}"));
980     }
981     @Test
982     public void testCreateTableWithDefaultExpressionWithCast() {
983         BoundCreateTable analysis = analyze(
984             "create table foo (id int default 3.5)");
985         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
986         assertThat(mapToSortedString(mappingProperties),
987                    is("id={default_expr=_cast(3.5, 'integer'), position=1, type=integer}"));
988     }
989     @Test
990     public void testCreateTableWithDefaultExpressionIsNotNormalized() {
991         BoundCreateTable analysis = analyze(
992             "create table foo (ts timestamp with time zone default current_timestamp(3))");
993         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
994         assertThat(mapToSortedString(mappingProperties),
995                    is("ts={default_expr=current_timestamp(3), " +
996                       "format=epoch_millis||strict_date_optional_time, " +
997                       "position=1, type=date}"));
998     }
999     @Test
1000     public void testCreateTableWithDefaultExpressionAsCompoundTypes() {
1001         BoundCreateTable analysis = analyze(
1002             "create table foo (" +
1003             "   obj object as (key text) default {key=''}," +
1004             "   arr array(long) default [1, 2])");
1005         assertThat(mapToSortedString(analysis.mappingProperties()), is(
1006             "arr={inner={position=3, type=long}, type=array}, " +
1007             "obj={default_expr={\"key\"=''}, dynamic=true, position=1, properties={key={position=2, type=keyword}}, type=object}"));
1008     }
1009     @Test
1010     public void testCreateTableWithDefaultExpressionAsGeoTypes() {
1011         BoundCreateTable analysis = analyze(
1012             "create table foo (" +
1013             "   p geo_point default [0,0]," +
1014             "   s geo_shape default 'LINESTRING (0 0, 1 1)')");
1015         assertThat(mapToSortedString(analysis.mappingProperties()), is(
1016             "p={default_expr=_cast([0, 0], 'geo_point'), position=1, type=geo_point}, " +
1017             "s={default_expr=_cast('LINESTRING (0 0, 1 1)', 'geo_shape'), position=2, type=geo_shape}"));
1018     }
1019     @Test
1020     public void testCreateTableWithDefaultExpressionRefToColumnsNotAllowed() {
1021         expectedException.expect(UnsupportedOperationException.class);
1022         expectedException.expectMessage("Columns cannot be used in this context. " +
1023                                         "Maybe you wanted to use a string literal which requires single quotes: 'name'");
1024         analyze("create table foo (name text, name_def text default upper(name))");
1025     }
1026     @Test
1027     public void testCreateTableWithObjectAsPrimaryKey() {
1028         expectedException.expectMessage("Cannot use columns of type \"object\" as primary key");
1029         expectedException.expect(UnsupportedOperationException.class);
1030         analyze("create table t (obj object as (x int) primary key)");
1031     }
1032     @Test
1033     public void testCreateTableWithGeoPointAsPrimaryKey() {
1034         expectedException.expectMessage("Cannot use columns of type \"geo_point\" as primary key");
1035         expectedException.expect(UnsupportedOperationException.class);
1036         analyze("create table t (c geo_point primary key)");
1037     }
1038     @Test
1039     public void testCreateTableWithGeoShapeAsPrimaryKey() {
1040         expectedException.expectMessage("Cannot use columns of type \"geo_shape\" as primary key");
1041         expectedException.expect(UnsupportedOperationException.class);
1042         analyze("create table t (c geo_shape primary key)");
1043     }
1044     @Test
1045     public void testCreateTableWithDuplicatePrimaryKey() {
1046         assertDuplicatePrimaryKey("create table t (id int, primary key (id, id))");
1047         assertDuplicatePrimaryKey("create table t (obj object as (id int), primary key (obj['id'], obj['id']))");
1048         assertDuplicatePrimaryKey("create table t (id int primary key, primary key (id))");
1049         assertDuplicatePrimaryKey("create table t (obj object as (id int primary key), primary key (obj['id']))");
1050 <a name="16"></a>    }
1051     private void assertDuplicatePrimaryKey(String stmt) {
1052         <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
1053             analyze(stmt);
1054             fail(String.format(Locale.ENGLISH, "Statement '%s' did not result in duplicate primary key exception", stmt));
1055         } catch (IllegalArgumentException e) {</b></font>
1056             String msg = "appears twice in primary key constraint";
1057             if (!e.getMessage().contains(msg)) {
1058                 fail("Exception message is expected to contain: " + msg);
1059             }
1060         }
1061     }
1062     @Test
1063     public void testAlterTableAddColumnWithCheckConstraint() throws Exception {
1064         SQLExecutor.builder(clusterService)
1065             .addTable("create table t (" +
1066                       "    id int primary key, " +
1067                       "    qty int constraint check_qty_gt_zero check(qty &gt; 0), " +
1068                       "    constraint check_id_ge_zero check (id &gt;= 0)" +
1069 <a name="1"></a>                      ")")
1070             .build();
1071         String alterStmt = "alter table t add column bazinga int constraint bazinga_check check(bazinga != 42)";
1072         BoundAddColumn analysis = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>analyze(alterStmt);
1073         Map&lt;String, Object&gt; mapping = analysis.mapping();
1074         Map&lt;String, String&gt; checkConstraints = analysis.analyzedTableElements().getCheckConstraints();
1075         assertEquals(checkConstraints.get("check_id_ge_zero"),
1076                      Maps.getByPath(mapping, Arrays.asList("_meta", "check_constraints", "check_id_ge_zero")));
1077         assertEquals(checkConstraints.get("check_qty_gt_zero"),
1078                      Maps.getByPath</b></font>(mapping, Arrays.asList("_meta", "check_constraints", "check_qty_gt_zero")));
1079         assertEquals(checkConstraints.get("bazinga_check"),
1080                      Maps.getByPath(mapping, Arrays.asList("_meta", "check_constraints", "bazinga_check")));
1081     }
1082     @Test
1083     public void testCreateTableWithPrimaryKeyConstraintInArrayItem() {
1084         expectedException.expect(UnsupportedOperationException.class);
1085         expectedException.expectMessage("Cannot use column \"id\" as primary key within an array object");
1086         analyze("create table test (arr array(object as (id long primary key)))");
1087     }
1088     @Test
1089     public void testCreateTableWithDeepNestedPrimaryKeyConstraintInArrayItem() {
1090         expectedException.expect(UnsupportedOperationException.class);
1091         expectedException.expectMessage("Cannot use column \"name\" as primary key within an array object");
1092         analyze("create table test (arr array(object as (\"user\" object as (name string primary key), id long)))");
1093     }
1094     @Test
1095     public void testCreateTableWithInvalidIndexConstraint() {
1096         expectedException.expect(IllegalArgumentException.class);
1097         expectedException.expectMessage("INDEX constraint cannot be used on columns of type \"object\"");
1098         analyze("create table test (obj object index off)");
1099     }
1100     @Test
1101     public void testCreateTableWithColumnStoreDisabled() {
1102         BoundCreateTable analysis = analyze(
1103             "create table columnstore_disabled (s string STORAGE WITH (columnstore = false))");
1104         Map&lt;String, Object&gt; mappingProperties = analysis.mappingProperties();
1105         assertThat(mapToSortedString(mappingProperties), is("s={doc_values=false, position=1, type=keyword}"));
1106     }
1107     @Test
1108     public void testCreateTableWithColumnStoreDisabledOnInvalidDataType() {
1109         expectedException.expect(IllegalArgumentException.class);
1110         expectedException.expectMessage("Invalid storage option \"columnstore\" for data type \"integer\"");
1111         analyze("create table columnstore_disabled (s int STORAGE WITH (columnstore = false))");
1112     }
1113     @Test
1114     public void testCreateTableFailsIfNameConflictsWithView() {
1115         SQLExecutor executor = SQLExecutor.builder(clusterService)
1116             .addView(RelationName.fromIndexName("v1"), "Select * from t1")
1117             .build();
1118         expectedException.expect(RelationAlreadyExists.class);
1119         expectedException.expectMessage("Relation 'doc.v1' already exists");
1120         analyze(executor, "create table v1 (x int) clustered into 1 shards with (number_of_replicas = 0)");
1121     }
1122     @Test
1123     public void testGeneratedColumnInsideObjectIsProcessed() {
1124         BoundCreateTable stmt = analyze("create table t (obj object as (c as 1 + 1))");
1125         AnalyzedColumnDefinition&lt;Object&gt; obj = stmt.analyzedTableElements().columns().get(0);
1126         AnalyzedColumnDefinition&lt;?&gt; c = obj.children().get(0);
1127         assertThat(c.dataType(), is(DataTypes.INTEGER));
1128         assertThat(c.formattedGeneratedExpression(), is("2"));
1129         assertThat(AnalyzedTableElements.toMapping(stmt.analyzedTableElements()).toString(),
1130                    is("{_meta={generated_columns={obj.c=2}}, " +
1131                       "properties={obj={dynamic=true, position=1, type=object, properties={c={position=2, type=integer}}}}}"));
1132 <a name="10"></a>    }
1133     @Test
1134     public void testNumberOfRoutingShardsCanBeSetAtCreateTable() <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
1135         BoundCreateTable stmt = analyze("""
1136             create table t (x int)
1137             clustered into 2 shards
1138             with (number_of_routing_shards = 10)
1139         """);
1140         assertThat(stmt.tableParameter().settings().get("index.number_of_routing_shards"), is("10"));
1141 <a name="9"></a>    }
1142     @Test</b></font>
1143     public void testNumberOfRoutingShardsCanBeSetAtCreateTableForPartitionedTables() <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
1144         BoundCreateTable stmt = analyze(
1145             "create table t (p int, x int) clustered into 2 shards partitioned by (p) " +
1146             "with (number_of_routing_shards = 10)");
1147         assertThat(stmt.tableParameter().settings().get("index.number_of_routing_shards"), is("10"));
1148     }
1149     @Test</b></font>
1150     public void testAlterTableSetDynamicSetting() {
1151         BoundAlterTable analysis =
1152             analyze("alter table users set (\"routing.allocation.exclude.foo\"='bar')");
1153         assertThat(analysis.tableParameter().settings().get(INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + "foo"), is("bar"));
1154     }
1155     @Test
1156     public void testAlterTableResetDynamicSetting() {
1157         BoundAlterTable analysis =
1158             analyze("alter table users reset (\"routing.allocation.exclude.foo\")");
1159         assertThat(analysis.tableParameter().settings().get(INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + "foo"), nullValue());
1160     }
1161     @Test
1162     public void testCreateTableWithIntervalFails() {
1163         expectedException.expect(IllegalArgumentException.class);
1164         expectedException.expectMessage("Cannot use the type `interval` for column: i");
1165         analyze("create table test (i interval)");
1166     }
1167     @Test
1168     public void test_character_varying_type_can_be_used_in_create_table() throws Exception {
1169         BoundCreateTable stmt = analyze("create table tbl (name character varying)");
1170         assertThat(
1171             mapToSortedString(stmt.mappingProperties()),
1172             is("name={position=1, type=keyword}"));
1173     }
1174     @Test
1175     public void test_create_table_with_varchar_column_of_limited_length() {
1176         BoundCreateTable stmt = analyze("CREATE TABLE tbl (name character varying(2))");
1177         assertThat(
1178             mapToSortedString(stmt.mappingProperties()),
1179             is("name={length_limit=2, position=1, type=keyword}"));
1180     }
1181     @Test
1182     public void test_create_table_with_varchar_column_of_limited_length_with_analyzer_throws_exception() {
1183         expectedException.expect(IllegalArgumentException.class);
1184         expectedException.expectMessage(
1185             "Can't use an Analyzer on column name because analyzers are only allowed on columns " +
1186             "of type \"" + DataTypes.STRING.getName() + "\" of the unbound length limit.");
1187         analyze("CREATE TABLE tbl (name varchar(2) INDEX using fulltext WITH (analyzer='german'))");
1188     }
1189     @Test
1190     public void test_oidvector_cannot_be_used_in_create_table() throws Exception {
1191         expectedException.expectMessage("Cannot use the type `oidvector` for column: x");
1192         analyze("CREATE TABLE tbl (x oidvector)");
1193     }
1194     @Test
1195     public void test_generated_column_arguments_are_detected_as_array_and_validation_fails_with_missing_overload() throws Exception {
1196         Exception exception = Assertions.assertThrows(
1197             Exception.class,
1198             () -&gt; analyze("CREATE TABLE tbl (xs int[], x as max(xs))")
1199         );
1200         assertThat(
1201             exception.getMessage(),
1202             Matchers.startsWith("Unknown function: max(doc.tbl.xs), no overload found for matching argument types: (integer_array)")
1203         );
1204     }
1205     @Test
1206     public void test_prohibit_using_aggregations_in_generated_columns() throws Exception {
1207         Exception exception = Assertions.assertThrows(
1208             Exception.class,
1209             () -&gt; analyze("CREATE TABLE tbl (x int, y as max(x))")
1210         );
1211         assertThat(
1212             exception.getMessage(),
1213             Matchers.startsWith("Aggregation functions are not allowed in generated columns: max(x)")
1214         );
1215     }
1216     @Test
1217     public void test_can_use_bit_type_in_create_table_statement() throws Exception {
1218         BoundCreateTable stmt = analyze("CREATE TABLE tbl (xs bit(20))");
1219         assertThat(mapToSortedString(stmt.mappingProperties()), is(
1220             "xs={length=20, position=1, type=bit}"
1221         ));
1222     }
1223     @Test
1224     public void test_bit_type_defaults_to_length_1() throws Exception {
1225         BoundCreateTable stmt = analyze("CREATE TABLE tbl (xs bit)");
1226         assertThat(mapToSortedString(stmt.mappingProperties()), is(
1227             "xs={length=1, position=1, type=bit}"
1228         ));
1229     }
1230     @Test
1231     public void test_now_function_is_not_normalized_to_literal_in_create_table() throws Exception {
1232         BoundCreateTable stmt = analyze("create table tbl (ts timestamp with time zone default now())");
1233         assertThat(mapToSortedString(stmt.mappingProperties()), Matchers.startsWith(
1234             "ts={default_expr=now()"
1235         ));
1236     }
1237     @Test
1238     public void test_current_user_function_is_not_normalized_to_literal_in_create_table() throws Exception {
1239         BoundCreateTable stmt = analyze("create table tbl (user_name text default current_user)");
1240         assertThat(mapToSortedString(stmt.mappingProperties()), Matchers.startsWith(
1241             "user_name={default_expr=CURRENT_USER, position=1, type=keyword}"
1242         ));
1243     }
1244     @Test
1245     public void test_create_table_with_invalid_storage_option_errors_with_invalid_property_name() throws Exception {
1246         assertThrowsMatches(
1247             () -&gt; analyze("create table tbl (name text storage with (foobar = true))"),
1248             IllegalArgumentException.class,
1249             "Invalid STORAGE WITH option `foobar`"
1250         );
1251     }
1252 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
