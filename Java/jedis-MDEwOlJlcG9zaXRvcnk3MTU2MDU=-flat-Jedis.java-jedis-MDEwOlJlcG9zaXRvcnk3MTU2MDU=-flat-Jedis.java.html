
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Jedis.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import static redis.clients.jedis.Protocol.Command.*;
3  import static redis.clients.jedis.Protocol.Keyword.*;
4  import static redis.clients.jedis.Protocol.SentinelKeyword.*;
5  import static redis.clients.jedis.Protocol.toByteArray;
6  import static redis.clients.jedis.util.SafeEncoder.encode;
7  import java.io.Closeable;
8  import java.net.URI;
9  import java.util.Iterator;
10  import java.util.List;
11  import java.util.Map;
12  import java.util.Map.Entry;
13  import java.util.Set;
14  import java.util.stream.Collectors;
15  import javax.net.ssl.HostnameVerifier;
16  import javax.net.ssl.SSLParameters;
17  import javax.net.ssl.SSLSocketFactory;
18  import redis.clients.jedis.Protocol.*;
19  import redis.clients.jedis.args.*;
20  import redis.clients.jedis.commands.*;
21  import redis.clients.jedis.exceptions.InvalidURIException;
22  import redis.clients.jedis.exceptions.JedisConnectionException;
23  import redis.clients.jedis.exceptions.JedisException;
24  import redis.clients.jedis.params.*;
25  import redis.clients.jedis.resps.*;
26  import redis.clients.jedis.util.JedisURIHelper;
27  import redis.clients.jedis.util.KeyValue;
28  import redis.clients.jedis.util.Pool;
29  public class Jedis implements ServerCommands, DatabaseCommands, JedisCommands, JedisBinaryCommands,
30      ControlCommands, ControlBinaryCommands, ClusterCommands, ModuleCommands, GenericControlCommands,
31      SentinelCommands, Closeable {
32    protected final Connection connection;
33    private final CommandObjects commandObjects = new CommandObjects();
34    private int db = 0;
35    private Transaction transaction = null;
36    private boolean isInMulti = false;
37    private boolean isInWatch = false;
38    private Pipeline pipeline = null;
39    protected static final byte[][] DUMMY_ARRAY = new byte[0][];
40    private Pool&lt;Jedis&gt; dataSource = null;
41    public Jedis() {
42      connection = new Connection();
43    }
44    public Jedis(final String url) {
45      this(URI.create(url));
46    }
47    public Jedis(final HostAndPort hp) {
48      connection = new Connection(hp);
49    }
50    public Jedis(final String host, final int port) {
51      connection = new Connection(host, port);
52    }
53    public Jedis(final String host, final int port, final JedisClientConfig config) {
54      this(new HostAndPort(host, port), config);
55    }
56    public Jedis(final HostAndPort hostPort, final JedisClientConfig config) {
57      connection = new Connection(hostPort, config);
58      RedisProtocol proto = config.getRedisProtocol();
59      if (proto != null) commandObjects.setProtocol(proto);
60    }
61    public Jedis(final String host, final int port, final boolean ssl) {
62      this(host, port, DefaultJedisClientConfig.builder().ssl(ssl).build());
63    }
64    public Jedis(final String host, final int port, final boolean ssl,
65        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
66        final HostnameVerifier hostnameVerifier) {
67      this(host, port, DefaultJedisClientConfig.builder().ssl(ssl)
68          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
69          .hostnameVerifier(hostnameVerifier).build());
70    }
71    public Jedis(final String host, final int port, final int timeout) {
72      this(host, port, timeout, timeout);
73    }
74    public Jedis(final String host, final int port, final int timeout, final boolean ssl) {
75      this(host, port, timeout, timeout, ssl);
76    }
77    public Jedis(final String host, final int port, final int timeout, final boolean ssl,
78        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
79        final HostnameVerifier hostnameVerifier) {
80      this(host, port, timeout, timeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);
81    }
82    public Jedis(final String host, final int port, final int connectionTimeout,
83        final int soTimeout) {
84      this(host, port, DefaultJedisClientConfig.builder()
85          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).build());
86    }
87    public Jedis(final String host, final int port, final int connectionTimeout,
88        final int soTimeout, final int infiniteSoTimeout) {
89      this(host, port, DefaultJedisClientConfig.builder()
90          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout)
91          .blockingSocketTimeoutMillis(infiniteSoTimeout).build());
92    }
93    public Jedis(final String host, final int port, final int connectionTimeout,
94        final int soTimeout, final boolean ssl) {
95      this(host, port, DefaultJedisClientConfig.builder()
96          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).ssl(ssl)
97          .build());
98    }
99    public Jedis(final String host, final int port, final int connectionTimeout,
100        final int soTimeout, final boolean ssl, final SSLSocketFactory sslSocketFactory,
101        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
102      this(host, port, DefaultJedisClientConfig.builder()
103          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).ssl(ssl)
104          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
105          .hostnameVerifier(hostnameVerifier).build());
106    }
107    public Jedis(final String host, final int port, final int connectionTimeout,
108        final int soTimeout, final int infiniteSoTimeout, final boolean ssl,
109        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
110        final HostnameVerifier hostnameVerifier) {
111      this(host, port, DefaultJedisClientConfig.builder()
112          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout)
113          .blockingSocketTimeoutMillis(infiniteSoTimeout).ssl(ssl)
114          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
115          .hostnameVerifier(hostnameVerifier).build());
116    }
117    public Jedis(URI uri) {
118      if (!JedisURIHelper.isValid(uri)) {
119        throw new InvalidURIException(String.format(
120          &quot;Cannot open Redis connection due invalid URI \&quot;%s\&quot;.&quot;, uri.toString()));
121      }
122      connection = new Connection(new HostAndPort(uri.getHost(), uri.getPort()),
123          DefaultJedisClientConfig.builder().user(JedisURIHelper.getUser(uri))
124              .password(JedisURIHelper.getPassword(uri)).database(JedisURIHelper.getDBIndex(uri))
125              .protocol(JedisURIHelper.getRedisProtocol(uri))
126              .ssl(JedisURIHelper.isRedisSSLScheme(uri)).build());
127    }
128    public Jedis(URI uri, final SSLSocketFactory sslSocketFactory,
129        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
130      this(uri, DefaultJedisClientConfig.builder().sslSocketFactory(sslSocketFactory)
131          .sslParameters(sslParameters).hostnameVerifier(hostnameVerifier).build());
132    }
133    public Jedis(final URI uri, final int timeout) {
134      this(uri, timeout, timeout);
135    }
136    public Jedis(final URI uri, final int timeout, final SSLSocketFactory sslSocketFactory,
137        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
138      this(uri, timeout, timeout, sslSocketFactory, sslParameters, hostnameVerifier);
139    }
140    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout) {
141      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
142          .socketTimeoutMillis(soTimeout).build());
143    }
144    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout,
145        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
146        final HostnameVerifier hostnameVerifier) {
147      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
148          .socketTimeoutMillis(soTimeout).sslSocketFactory(sslSocketFactory)
149          .sslParameters(sslParameters).hostnameVerifier(hostnameVerifier).build());
150    }
151    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout,
152        final int infiniteSoTimeout, final SSLSocketFactory sslSocketFactory,
153        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
154      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
155          .socketTimeoutMillis(soTimeout).blockingSocketTimeoutMillis(infiniteSoTimeout)
156          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
157          .hostnameVerifier(hostnameVerifier).build());
158    }
159    public Jedis(final URI uri, JedisClientConfig config) {
160      if (!JedisURIHelper.isValid(uri)) {
161        throw new InvalidURIException(String.format(
162          &quot;Cannot open Redis connection due invalid URI \&quot;%s\&quot;.&quot;, uri.toString()));
163      }
164      connection = new Connection(new HostAndPort(uri.getHost(), uri.getPort()),
165          DefaultJedisClientConfig.builder()
166              .connectionTimeoutMillis(config.getConnectionTimeoutMillis())
167              .socketTimeoutMillis(config.getSocketTimeoutMillis())
168              .blockingSocketTimeoutMillis(config.getBlockingSocketTimeoutMillis())
169              .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
170              .database(JedisURIHelper.getDBIndex(uri)).clientName(config.getClientName())
171              .protocol(JedisURIHelper.getRedisProtocol(uri))
172              .ssl(JedisURIHelper.isRedisSSLScheme(uri)).sslSocketFactory(config.getSslSocketFactory())
173              .sslParameters(config.getSslParameters()).hostnameVerifier(config.getHostnameVerifier())
174              .build());
175      RedisProtocol proto = config.getRedisProtocol();
176      if (proto != null) commandObjects.setProtocol(proto);
177    }
178    public Jedis(final JedisSocketFactory jedisSocketFactory) {
179      connection = new Connection(jedisSocketFactory);
180    }
181    public Jedis(final JedisSocketFactory jedisSocketFactory, final JedisClientConfig clientConfig) {
182      connection = new Connection(jedisSocketFactory, clientConfig);
183      RedisProtocol proto = clientConfig.getRedisProtocol();
184      if (proto != null) commandObjects.setProtocol(proto);
185    }
186    public Jedis(final Connection connection) {
187      this.connection = connection;
188    }
189    @Override
190    public String toString() {
191      return &quot;Jedis{&quot; + connection + &#x27;}&#x27;;
192    }
193    public Connection getClient() {
194      return getConnection();
195    }
196    public Connection getConnection() {
197      return connection;
198    }
199    public void connect() {
200      connection.connect();
201    }
202    public void disconnect() {
203      connection.disconnect();
204    }
205    public boolean isConnected() {
206      return connection.isConnected();
207    }
208    public boolean isBroken() {
209      return connection.isBroken();
210    }
211    public void resetState() {
212      if (isConnected()) {
213        if (transaction != null) {
214          transaction.close();
215        }
216        if (pipeline != null) {
217          pipeline.close();
218        }
219        if (isInWatch) {
220          connection.sendCommand(UNWATCH);
221          connection.getStatusCodeReply();
222          isInWatch = false;
223        }
224      }
225      transaction = null;
226      pipeline = null;
227    }
228    protected void setDataSource(Pool&lt;Jedis&gt; jedisPool) {
229      this.dataSource = jedisPool;
230    }
231    @Override
232    public void close() {
233      if (dataSource != null) {
234        Pool&lt;Jedis&gt; pool = this.dataSource;
235        this.dataSource = null;
236        if (isBroken()) {
237          pool.returnBrokenResource(this);
238        } else {
239          pool.returnResource(this);
240        }
241      } else {
242        connection.close();
243      }
244    }
245    public Transaction multi() {
246      transaction = new Transaction(this);
247      return transaction;
248    }
249    public Pipeline pipelined() {
250      pipeline = new Pipeline(this);
251      return pipeline;
252    }
253    protected void checkIsInMultiOrPipeline() {
254      if (transaction != null) {
255        throw new IllegalStateException(
256            &quot;Cannot use Jedis when in Multi. Please use Transaction or reset jedis state.&quot;);
257      } else if (pipeline != null &amp;&amp; pipeline.hasPipelinedResponse()) {
258        throw new IllegalStateException(
259            &quot;Cannot use Jedis when in Pipeline. Please use Pipeline or reset jedis state.&quot;);
260      }
261    }
262    public int getDB() {
263      return this.db;
264    }
265    @Override
266    public String ping() {
267      checkIsInMultiOrPipeline();
268      connection.sendCommand(Command.PING);
269      return connection.getStatusCodeReply();
270    }
271    public byte[] ping(final byte[] message) {
272      checkIsInMultiOrPipeline();
273      connection.sendCommand(Command.PING, message);
274      return connection.getBinaryBulkReply();
275    }
276    @Override
277    public String select(final int index) {
278      checkIsInMultiOrPipeline();
279      connection.sendCommand(SELECT, toByteArray(index));
280      String statusCodeReply = connection.getStatusCodeReply();
281      this.db = index;
282      return statusCodeReply;
283    }
284    @Override
285    public String swapDB(final int index1, final int index2) {
286      checkIsInMultiOrPipeline();
287      connection.sendCommand(SWAPDB, toByteArray(index1), toByteArray(index2));
288      return connection.getStatusCodeReply();
289    }
290    @Override
291    public String flushDB() {
292      checkIsInMultiOrPipeline();
293      return connection.executeCommand(commandObjects.flushDB());
294    }
295    @Override
296    public String flushDB(FlushMode flushMode) {
297      checkIsInMultiOrPipeline();
298      connection.sendCommand(FLUSHDB, flushMode.getRaw());
299      return connection.getStatusCodeReply();
300    }
301    @Override
302    public String flushAll() {
303      checkIsInMultiOrPipeline();
304      return connection.executeCommand(commandObjects.flushAll());
305    }
306    @Override
307    public String flushAll(FlushMode flushMode) {
308      checkIsInMultiOrPipeline();
309      connection.sendCommand(FLUSHALL, flushMode.getRaw());
310      return connection.getStatusCodeReply();
311    }
312    @Override
313    public boolean copy(byte[] srcKey, byte[] dstKey, int db, boolean replace) {
314      checkIsInMultiOrPipeline();
315      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, db, replace));
316    }
317    @Override
318    public boolean copy(byte[] srcKey, byte[] dstKey, boolean replace) {
319      checkIsInMultiOrPipeline();
320      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, replace));
321    }
322    @Override
323    public String set(final byte[] key, final byte[] value) {
324      checkIsInMultiOrPipeline();
325      return connection.executeCommand(commandObjects.set(key, value));
326    }
327    @Override
328    public String set(final byte[] key, final byte[] value, final SetParams params) {
329      checkIsInMultiOrPipeline();
330      return connection.executeCommand(commandObjects.set(key, value, params));
331    }
332    @Override
333    public byte[] get(final byte[] key) {
334      checkIsInMultiOrPipeline();
335      return connection.executeCommand(commandObjects.get(key));
336    }
337    @Override
338    public byte[] setGet(final byte[] key, final byte[] value) {
339      checkIsInMultiOrPipeline();
340      return connection.executeCommand(commandObjects.setGet(key, value));
341    }
342    @Override
343    public byte[] setGet(final byte[] key, final byte[] value, final SetParams params) {
344      checkIsInMultiOrPipeline();
345      return connection.executeCommand(commandObjects.setGet(key, value, params));
346    }
347    @Override
348    public byte[] getDel(final byte[] key) {
349      checkIsInMultiOrPipeline();
350      return connection.executeCommand(commandObjects.getDel(key));
351    }
352    @Override
353    public byte[] getEx(final byte[] key, final GetExParams params) {
354      checkIsInMultiOrPipeline();
355      return connection.executeCommand(commandObjects.getEx(key, params));
356    }
357    @Override
358    public long exists(final byte[]... keys) {
359      checkIsInMultiOrPipeline();
360      return connection.executeCommand(commandObjects.exists(keys));
361    }
362    @Override
363    public boolean exists(final byte[] key) {
364      checkIsInMultiOrPipeline();
365      return connection.executeCommand(commandObjects.exists(key));
366    }
367    @Override
368    public long del(final byte[]... keys) {
369      checkIsInMultiOrPipeline();
370      return connection.executeCommand(commandObjects.del(keys));
371    }
372    @Override
373    public long del(final byte[] key) {
374      checkIsInMultiOrPipeline();
375      return connection.executeCommand(commandObjects.del(key));
376    }
377    @Override
378    public long unlink(final byte[]... keys) {
379      checkIsInMultiOrPipeline();
380      return connection.executeCommand(commandObjects.unlink(keys));
381    }
382    @Override
383    public long unlink(final byte[] key) {
384      checkIsInMultiOrPipeline();
385      return connection.executeCommand(commandObjects.unlink(key));
386    }
387    @Override
388    public String type(final byte[] key) {
389      checkIsInMultiOrPipeline();
390      return connection.executeCommand(commandObjects.type(key));
391    }
392    @Override
393    public Set&lt;byte[]&gt; keys(final byte[] pattern) {
394      checkIsInMultiOrPipeline();
395      return connection.executeCommand(commandObjects.keys(pattern));
396    }
397    @Override
398    public byte[] randomBinaryKey() {
399      checkIsInMultiOrPipeline();
400      return connection.executeCommand(commandObjects.randomBinaryKey());
401    }
402    @Override
403    public String rename(final byte[] oldkey, final byte[] newkey) {
404      checkIsInMultiOrPipeline();
405      return connection.executeCommand(commandObjects.rename(oldkey, newkey));
406    }
407    @Override
408    public long renamenx(final byte[] oldkey, final byte[] newkey) {
409      checkIsInMultiOrPipeline();
410      return connection.executeCommand(commandObjects.renamenx(oldkey, newkey));
411    }
412    @Override
413    public long dbSize() {
414      checkIsInMultiOrPipeline();
415      connection.sendCommand(DBSIZE);
416      return connection.getIntegerReply();
417    }
418    @Override
419    public long expire(final byte[] key, final long seconds) {
420      checkIsInMultiOrPipeline();
421      return connection.executeCommand(commandObjects.expire(key, seconds));
422    }
423    @Override
424    public long expire(final byte[] key, final long seconds, final ExpiryOption expiryOption) {
425      checkIsInMultiOrPipeline();
426      return connection.executeCommand((commandObjects.expire(key, seconds, expiryOption)));
427    }
428    @Override
429    public long pexpire(final byte[] key, final long milliseconds) {
430      checkIsInMultiOrPipeline();
431      return connection.executeCommand(commandObjects.pexpire(key, milliseconds));
432    }
433    @Override
434    public long pexpire(final byte[] key, final long milliseconds, final ExpiryOption expiryOption) {
435      checkIsInMultiOrPipeline();
436      return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
437    }
438    @Override
439    public long expireTime(final byte[] key) {
440      checkIsInMultiOrPipeline();
441      return connection.executeCommand((commandObjects.expireTime(key)));
442    }
443    @Override
444    public long pexpireTime(final byte[] key) {
445      checkIsInMultiOrPipeline();
446      return connection.executeCommand(commandObjects.pexpireTime(key));
447    }
448    @Override
449    public long expireAt(final byte[] key, final long unixTime) {
450      checkIsInMultiOrPipeline();
451      return connection.executeCommand(commandObjects.expireAt(key, unixTime));
452    }
453    @Override
454    public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {
455      checkIsInMultiOrPipeline();
456      return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
457    }
458    @Override
459    public long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
460      checkIsInMultiOrPipeline();
461      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
462    }
463    @Override
464    public long pexpireAt(byte[] key, long millisecondsTimestamp, ExpiryOption expiryOption) {
465      checkIsInMultiOrPipeline();
466      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
467    }
468    @Override
469    public long ttl(final byte[] key) {
470      checkIsInMultiOrPipeline();
471      return connection.executeCommand(commandObjects.ttl(key));
472    }
473    @Override
474    public long touch(final byte[]... keys) {
475      checkIsInMultiOrPipeline();
476      return connection.executeCommand(commandObjects.touch(keys));
477    }
478    @Override
479    public long touch(final byte[] key) {
480      checkIsInMultiOrPipeline();
481      return connection.executeCommand(commandObjects.touch(key));
482    }
483    @Override
484    public long move(final byte[] key, final int dbIndex) {
485      checkIsInMultiOrPipeline();
486      connection.sendCommand(MOVE, key, toByteArray(dbIndex));
487      return connection.getIntegerReply();
488    }
489    @Override
490    public byte[] getSet(final byte[] key, final byte[] value) {
491      checkIsInMultiOrPipeline();
492      return connection.executeCommand(commandObjects.getSet(key, value));
493    }
494    @Override
495    public List&lt;byte[]&gt; mget(final byte[]... keys) {
496      checkIsInMultiOrPipeline();
497      return connection.executeCommand(commandObjects.mget(keys));
498    }
499    @Override
500    public long setnx(final byte[] key, final byte[] value) {
501      checkIsInMultiOrPipeline();
502      return connection.executeCommand(commandObjects.setnx(key, value));
503    }
504    @Override
505    public String setex(final byte[] key, final long seconds, final byte[] value) {
506      checkIsInMultiOrPipeline();
507      return connection.executeCommand(commandObjects.setex(key, seconds, value));
508    }
509    @Override
510    public String mset(final byte[]... keysvalues) {
511      checkIsInMultiOrPipeline();
512      return connection.executeCommand(commandObjects.mset(keysvalues));
513    }
514    @Override
515    public long msetnx(final byte[]... keysvalues) {
516      checkIsInMultiOrPipeline();
517      return connection.executeCommand(commandObjects.msetnx(keysvalues));
518    }
519    @Override
520    public long decrBy(final byte[] key, final long decrement) {
521      checkIsInMultiOrPipeline();
522      return connection.executeCommand(commandObjects.decrBy(key, decrement));
523    }
524    @Override
525    public long decr(final byte[] key) {
526      checkIsInMultiOrPipeline();
527      return connection.executeCommand(commandObjects.decr(key));
528    }
529    @Override
530    public long incrBy(final byte[] key, final long increment) {
531      checkIsInMultiOrPipeline();
532      return connection.executeCommand(commandObjects.incrBy(key, increment));
533    }
534    @Override
535    public double incrByFloat(final byte[] key, final double increment) {
536      checkIsInMultiOrPipeline();
537      return connection.executeCommand(commandObjects.incrByFloat(key, increment));
538    }
539    @Override
540    public long incr(final byte[] key) {
541      checkIsInMultiOrPipeline();
542      return connection.executeCommand(commandObjects.incr(key));
543    }
544    @Override
545    public long append(final byte[] key, final byte[] value) {
546      checkIsInMultiOrPipeline();
547      return connection.executeCommand(commandObjects.append(key, value));
548    }
549    @Override
550    public byte[] substr(final byte[] key, final int start, final int end) {
551      checkIsInMultiOrPipeline();
552      return connection.executeCommand(commandObjects.substr(key, start, end));
553    }
554    @Override
555    public long hset(final byte[] key, final byte[] field, final byte[] value) {
556      checkIsInMultiOrPipeline();
557      return connection.executeCommand(commandObjects.hset(key, field, value));
558    }
559    @Override
560    public long hset(final byte[] key, final Map&lt;byte[], byte[]&gt; hash) {
561      checkIsInMultiOrPipeline();
562      return connection.executeCommand(commandObjects.hset(key, hash));
563    }
564    @Override
565    public byte[] hget(final byte[] key, final byte[] field) {
566      checkIsInMultiOrPipeline();
567      return connection.executeCommand(commandObjects.hget(key, field));
568    }
569    @Override
570    public long hsetnx(final byte[] key, final byte[] field, final byte[] value) {
571      checkIsInMultiOrPipeline();
572      return connection.executeCommand(commandObjects.hsetnx(key, field, value));
573    }
574    @Override
575    public String hmset(final byte[] key, final Map&lt;byte[], byte[]&gt; hash) {
576      checkIsInMultiOrPipeline();
577      return connection.executeCommand(commandObjects.hmset(key, hash));
578    }
579    @Override
580    public List&lt;byte[]&gt; hmget(final byte[] key, final byte[]... fields) {
581      checkIsInMultiOrPipeline();
582      return connection.executeCommand(commandObjects.hmget(key, fields));
583    }
584    @Override
585    public long hincrBy(final byte[] key, final byte[] field, final long value) {
586      checkIsInMultiOrPipeline();
587      return connection.executeCommand(commandObjects.hincrBy(key, field, value));
588    }
589    @Override
590    public double hincrByFloat(final byte[] key, final byte[] field, final double value) {
591      checkIsInMultiOrPipeline();
592      return connection.executeCommand(commandObjects.hincrByFloat(key, field, value));
593    }
594    @Override
595    public boolean hexists(final byte[] key, final byte[] field) {
596      checkIsInMultiOrPipeline();
597      return connection.executeCommand(commandObjects.hexists(key, field));
598    }
599    @Override
600    public long hdel(final byte[] key, final byte[]... fields) {
601      checkIsInMultiOrPipeline();
602      return connection.executeCommand(commandObjects.hdel(key, fields));
603    }
604    @Override
605    public long hlen(final byte[] key) {
606      checkIsInMultiOrPipeline();
607      return connection.executeCommand(commandObjects.hlen(key));
608    }
609    @Override
610    public Set&lt;byte[]&gt; hkeys(final byte[] key) {
611      checkIsInMultiOrPipeline();
612      return connection.executeCommand(commandObjects.hkeys(key));
613    }
614    @Override
615    public List&lt;byte[]&gt; hvals(final byte[] key) {
616      checkIsInMultiOrPipeline();
617      return connection.executeCommand(commandObjects.hvals(key));
618    }
619    @Override
620    public Map&lt;byte[], byte[]&gt; hgetAll(final byte[] key) {
621      checkIsInMultiOrPipeline();
622      return connection.executeCommand(commandObjects.hgetAll(key));
623    }
624    @Override
625    public byte[] hrandfield(final byte[] key) {
626      checkIsInMultiOrPipeline();
627      return connection.executeCommand(commandObjects.hrandfield(key));
628    }
629    @Override
630    public List&lt;byte[]&gt; hrandfield(final byte[] key, final long count) {
631      checkIsInMultiOrPipeline();
632      return connection.executeCommand(commandObjects.hrandfield(key, count));
633    }
634    @Override
635    public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hrandfieldWithValues(final byte[] key, final long count) {
636      checkIsInMultiOrPipeline();
637      return connection.executeCommand(commandObjects.hrandfieldWithValues(key, count));
638    }
639    @Override
640    public long rpush(final byte[] key, final byte[]... strings) {
641      checkIsInMultiOrPipeline();
642      return connection.executeCommand(commandObjects.rpush(key, strings));
643    }
644    @Override
645    public long lpush(final byte[] key, final byte[]... strings) {
646      checkIsInMultiOrPipeline();
647      return connection.executeCommand(commandObjects.lpush(key, strings));
648    }
649    @Override
650    public long llen(final byte[] key) {
651      checkIsInMultiOrPipeline();
652      return connection.executeCommand(commandObjects.llen(key));
653    }
654    @Override
655    public List&lt;byte[]&gt; lrange(final byte[] key, final long start, final long stop) {
656      checkIsInMultiOrPipeline();
657      return connection.executeCommand(commandObjects.lrange(key, start, stop));
658    }
659    @Override
660    public String ltrim(final byte[] key, final long start, final long stop) {
661      checkIsInMultiOrPipeline();
662      return connection.executeCommand(commandObjects.ltrim(key, start, stop));
663    }
664    @Override
665    public byte[] lindex(final byte[] key, final long index) {
666      checkIsInMultiOrPipeline();
667      return connection.executeCommand(commandObjects.lindex(key, index));
668    }
669    @Override
670    public String lset(final byte[] key, final long index, final byte[] value) {
671      checkIsInMultiOrPipeline();
672      return connection.executeCommand(commandObjects.lset(key, index, value));
673    }
674    @Override
675    public long lrem(final byte[] key, final long count, final byte[] value) {
676      checkIsInMultiOrPipeline();
677      return connection.executeCommand(commandObjects.lrem(key, count, value));
678    }
679    @Override
680    public byte[] lpop(final byte[] key) {
681      checkIsInMultiOrPipeline();
682      return connection.executeCommand(commandObjects.lpop(key));
683    }
684    @Override
685    public List&lt;byte[]&gt; lpop(final byte[] key, final int count) {
686      checkIsInMultiOrPipeline();
687      return connection.executeCommand(commandObjects.lpop(key, count));
688    }
689    @Override
690    public Long lpos(final byte[] key, final byte[] element) {
691      checkIsInMultiOrPipeline();
692      return connection.executeCommand(commandObjects.lpos(key, element));
693    }
694    @Override
695    public Long lpos(final byte[] key, final byte[] element, final LPosParams params) {
696      checkIsInMultiOrPipeline();
697      return connection.executeCommand(commandObjects.lpos(key, element, params));
698    }
699    @Override
700    public List&lt;Long&gt; lpos(final byte[] key, final byte[] element, final LPosParams params,
701        final long count) {
702      checkIsInMultiOrPipeline();
703      return connection.executeCommand(commandObjects.lpos(key, element, params, count));
704    }
705    @Override
<span onclick='openModal()' class='match'>706    public byte[] rpop(final byte[] key) {
707      checkIsInMultiOrPipeline();
708      return connection.executeCommand(commandObjects.rpop(key));
</span>709    }
710    @Override
711    public List&lt;byte[]&gt; rpop(final byte[] key, final int count) {
712      checkIsInMultiOrPipeline();
713      return connection.executeCommand(commandObjects.rpop(key, count));
714    }
715    @Override
716    public byte[] rpoplpush(final byte[] srckey, final byte[] dstkey) {
717      checkIsInMultiOrPipeline();
718      return connection.executeCommand(commandObjects.rpoplpush(srckey, dstkey));
719    }
720    @Override
721    public long sadd(final byte[] key, final byte[]... members) {
722      checkIsInMultiOrPipeline();
723      return connection.executeCommand(commandObjects.sadd(key, members));
724    }
725    @Override
726    public Set&lt;byte[]&gt; smembers(final byte[] key) {
727      checkIsInMultiOrPipeline();
728      return connection.executeCommand(commandObjects.smembers(key));
729    }
730    @Override
731    public long srem(final byte[] key, final byte[]... members) {
732      checkIsInMultiOrPipeline();
733      return connection.executeCommand(commandObjects.srem(key, members));
734    }
735    @Override
736    public byte[] spop(final byte[] key) {
737      checkIsInMultiOrPipeline();
738      return connection.executeCommand(commandObjects.spop(key));
739    }
740    @Override
741    public Set&lt;byte[]&gt; spop(final byte[] key, final long count) {
742      checkIsInMultiOrPipeline();
743      return connection.executeCommand(commandObjects.spop(key, count));
744    }
745    @Override
746    public long smove(final byte[] srckey, final byte[] dstkey, final byte[] member) {
747      checkIsInMultiOrPipeline();
748      return connection.executeCommand(commandObjects.smove(srckey, dstkey, member));
749    }
750    @Override
751    public long scard(final byte[] key) {
752      checkIsInMultiOrPipeline();
753      return connection.executeCommand(commandObjects.scard(key));
754    }
755    @Override
756    public boolean sismember(final byte[] key, final byte[] member) {
757      checkIsInMultiOrPipeline();
758      return connection.executeCommand(commandObjects.sismember(key, member));
759    }
760    @Override
761    public List&lt;Boolean&gt; smismember(final byte[] key, final byte[]... members) {
762      checkIsInMultiOrPipeline();
763      return connection.executeCommand(commandObjects.smismember(key, members));
764    }
765    @Override
766    public Set&lt;byte[]&gt; sinter(final byte[]... keys) {
767      checkIsInMultiOrPipeline();
768      return connection.executeCommand(commandObjects.sinter(keys));
769    }
770    @Override
771    public long sinterstore(final byte[] dstkey, final byte[]... keys) {
772      checkIsInMultiOrPipeline();
773      return connection.executeCommand(commandObjects.sinterstore(dstkey, keys));
774    }
775    @Override
776    public long sintercard(byte[]... keys) {
777      checkIsInMultiOrPipeline();
778      return connection.executeCommand(commandObjects.sintercard(keys));
779    }
780    @Override
781    public long sintercard(int limit, byte[]... keys) {
782      checkIsInMultiOrPipeline();
783      return connection.executeCommand(commandObjects.sintercard(limit, keys));
784    }
785    @Override
786    public Set&lt;byte[]&gt; sunion(final byte[]... keys) {
787      checkIsInMultiOrPipeline();
788      return connection.executeCommand(commandObjects.sunion(keys));
789    }
790    @Override
791    public long sunionstore(final byte[] dstkey, final byte[]... keys) {
792      checkIsInMultiOrPipeline();
793      return connection.executeCommand(commandObjects.sunionstore(dstkey, keys));
794    }
795    @Override
796    public Set&lt;byte[]&gt; sdiff(final byte[]... keys) {
797      checkIsInMultiOrPipeline();
798      return connection.executeCommand(commandObjects.sdiff(keys));
799    }
800    @Override
801    public long sdiffstore(final byte[] dstkey, final byte[]... keys) {
802      checkIsInMultiOrPipeline();
803      return connection.executeCommand(commandObjects.sdiffstore(dstkey, keys));
804    }
805    @Override
806    public byte[] srandmember(final byte[] key) {
807      checkIsInMultiOrPipeline();
808      return connection.executeCommand(commandObjects.srandmember(key));
809    }
810    @Override
811    public List&lt;byte[]&gt; srandmember(final byte[] key, final int count) {
812      checkIsInMultiOrPipeline();
813      return connection.executeCommand(commandObjects.srandmember(key, count));
814    }
815    @Override
816    public long zadd(final byte[] key, final double score, final byte[] member) {
817      checkIsInMultiOrPipeline();
818      return connection.executeCommand(commandObjects.zadd(key, score, member));
819    }
820    @Override
821    public long zadd(final byte[] key, final double score, final byte[] member,
822        final ZAddParams params) {
823      checkIsInMultiOrPipeline();
824      return connection.executeCommand(commandObjects.zadd(key, score, member, params));
825    }
826    @Override
827    public long zadd(final byte[] key, final Map&lt;byte[], Double&gt; scoreMembers) {
828      checkIsInMultiOrPipeline();
829      return connection.executeCommand(commandObjects.zadd(key, scoreMembers));
830    }
831    @Override
832    public long zadd(final byte[] key, final Map&lt;byte[], Double&gt; scoreMembers, final ZAddParams params) {
833      checkIsInMultiOrPipeline();
834      return connection.executeCommand(commandObjects.zadd(key, scoreMembers, params));
835    }
836    @Override
837    public Double zaddIncr(final byte[] key, final double score, final byte[] member, final ZAddParams params) {
838      checkIsInMultiOrPipeline();
839      return connection.executeCommand(commandObjects.zaddIncr(key, score, member, params));
840    }
841    @Override
842    public List&lt;byte[]&gt; zrange(final byte[] key, final long start, final long stop) {
843      checkIsInMultiOrPipeline();
844      return connection.executeCommand(commandObjects.zrange(key, start, stop));
845    }
846    @Override
847    public long zrem(final byte[] key, final byte[]... members) {
848      checkIsInMultiOrPipeline();
849      return connection.executeCommand(commandObjects.zrem(key, members));
850    }
851    @Override
852    public double zincrby(final byte[] key, final double increment, final byte[] member) {
853      checkIsInMultiOrPipeline();
854      return connection.executeCommand(commandObjects.zincrby(key, increment, member));
855    }
856    @Override
857    public Double zincrby(final byte[] key, final double increment, final byte[] member,
858        final ZIncrByParams params) {
859      checkIsInMultiOrPipeline();
860      return connection.executeCommand(commandObjects.zincrby(key, increment, member, params));
861    }
862    @Override
863    public Long zrank(final byte[] key, final byte[] member) {
864      checkIsInMultiOrPipeline();
865      return connection.executeCommand(commandObjects.zrank(key, member));
866    }
867    @Override
868    public Long zrevrank(final byte[] key, final byte[] member) {
869      checkIsInMultiOrPipeline();
870      return connection.executeCommand(commandObjects.zrevrank(key, member));
871    }
872    @Override
873    public KeyValue&lt;Long, Double&gt; zrankWithScore(byte[] key, byte[] member) {
874      checkIsInMultiOrPipeline();
875      return connection.executeCommand(commandObjects.zrankWithScore(key, member));
876    }
877    @Override
878    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(byte[] key, byte[] member) {
879      checkIsInMultiOrPipeline();
880      return connection.executeCommand(commandObjects.zrevrankWithScore(key, member));
881    }
882    @Override
883    public List&lt;byte[]&gt; zrevrange(final byte[] key, final long start, final long stop) {
884      checkIsInMultiOrPipeline();
885      return connection.executeCommand(commandObjects.zrevrange(key, start, stop));
886    }
887    @Override
888    public List&lt;Tuple&gt; zrangeWithScores(final byte[] key, final long start, final long stop) {
889      checkIsInMultiOrPipeline();
890      return connection.executeCommand(commandObjects.zrangeWithScores(key, start, stop));
891    }
892    @Override
893    public List&lt;Tuple&gt; zrevrangeWithScores(final byte[] key, final long start, final long stop) {
894      checkIsInMultiOrPipeline();
895      return connection.executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
896    }
897    @Override
898    public List&lt;byte[]&gt; zrange(byte[] key, ZRangeParams zRangeParams) {
899      checkIsInMultiOrPipeline();
900      return connection.executeCommand(commandObjects.zrange(key, zRangeParams));
901    }
902    @Override
903    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, ZRangeParams zRangeParams) {
904      checkIsInMultiOrPipeline();
905      return connection.executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
906    }
907    @Override
908    public long zrangestore(byte[] dest, byte[] src, ZRangeParams zRangeParams) {
909      checkIsInMultiOrPipeline();
910      return connection.executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
911    }
912    @Override
913    public byte[] zrandmember(final byte[] key) {
914      checkIsInMultiOrPipeline();
915      return connection.executeCommand(commandObjects.zrandmember(key));
916    }
917    @Override
918    public List&lt;byte[]&gt; zrandmember(final byte[] key, final long count) {
919      checkIsInMultiOrPipeline();
920      return connection.executeCommand(commandObjects.zrandmember(key, count));
921    }
922    @Override
923    public List&lt;Tuple&gt; zrandmemberWithScores(final byte[] key, final long count) {
924      checkIsInMultiOrPipeline();
925      return connection.executeCommand(commandObjects.zrandmemberWithScores(key, count));
926    }
927    @Override
928    public long zcard(final byte[] key) {
929      checkIsInMultiOrPipeline();
930      return connection.executeCommand(commandObjects.zcard(key));
931    }
932    @Override
933    public Double zscore(final byte[] key, final byte[] member) {
934      checkIsInMultiOrPipeline();
935      return connection.executeCommand(commandObjects.zscore(key, member));
936    }
937    @Override
938    public List&lt;Double&gt; zmscore(final byte[] key, final byte[]... members) {
939      checkIsInMultiOrPipeline();
940      return connection.executeCommand(commandObjects.zmscore(key, members));
941    }
942    @Override
943    public Tuple zpopmax(final byte[] key) {
944      checkIsInMultiOrPipeline();
945      return connection.executeCommand(commandObjects.zpopmax(key));
946    }
947    @Override
948    public List&lt;Tuple&gt; zpopmax(final byte[] key, final int count) {
949      checkIsInMultiOrPipeline();
950      return connection.executeCommand(commandObjects.zpopmax(key, count));
951    }
952    @Override
953    public Tuple zpopmin(final byte[] key) {
954      checkIsInMultiOrPipeline();
955      return connection.executeCommand(commandObjects.zpopmin(key));
956    }
957    @Override
958    public List&lt;Tuple&gt; zpopmin(final byte[] key, final int count) {
959      checkIsInMultiOrPipeline();
960      return connection.executeCommand(commandObjects.zpopmin(key, count));
961    }
962    public String watch(final byte[]... keys) {
963      checkIsInMultiOrPipeline();
964      connection.sendCommand(WATCH, keys);
965      String status = connection.getStatusCodeReply();
966      isInWatch = true;
967      return status;
968    }
969    public String unwatch() {
970      checkIsInMultiOrPipeline();
971      connection.sendCommand(UNWATCH);
972      return connection.getStatusCodeReply();
973    }
974    @Override
975    public List&lt;byte[]&gt; sort(final byte[] key) {
976      checkIsInMultiOrPipeline();
977      return connection.executeCommand(commandObjects.sort(key));
978    }
979    @Override
980    public List&lt;byte[]&gt; sort(final byte[] key, final SortingParams sortingParams) {
981      checkIsInMultiOrPipeline();
982      return connection.executeCommand(commandObjects.sort(key, sortingParams));
983    }
984    @Override
985    public long sort(final byte[] key, final SortingParams sortingParams, final byte[] dstkey) {
986      checkIsInMultiOrPipeline();
987      return connection.executeCommand(commandObjects.sort(key, sortingParams, dstkey));
988    }
989    @Override
990    public long sort(final byte[] key, final byte[] dstkey) {
991      checkIsInMultiOrPipeline();
992      return connection.executeCommand(commandObjects.sort(key, dstkey));
993    }
994    @Override
995    public List&lt;byte[]&gt; sortReadonly(byte[] key, SortingParams sortingParams) {
996      checkIsInMultiOrPipeline();
997      return connection.executeCommand(commandObjects.sortReadonly(key, sortingParams));
998    }
999    @Override
1000    public byte[] lmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to) {
1001      checkIsInMultiOrPipeline();
1002      return connection.executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1003    }
1004    @Override
1005    public byte[] blmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to, double timeout) {
1006      checkIsInMultiOrPipeline();
1007      return connection.executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1008    }
1009    @Override
1010    public List&lt;byte[]&gt; blpop(final int timeout, final byte[]... keys) {
1011      return connection.executeCommand(commandObjects.blpop(timeout, keys));
1012    }
1013    @Override
1014    public KeyValue&lt;byte[], byte[]&gt; blpop(final double timeout, final byte[]... keys) {
1015      return connection.executeCommand(commandObjects.blpop(timeout, keys));
1016    }
1017    @Override
1018    public List&lt;byte[]&gt; brpop(final int timeout, final byte[]... keys) {
1019      return connection.executeCommand(commandObjects.brpop(timeout, keys));
1020    }
1021    @Override
1022    public KeyValue&lt;byte[], byte[]&gt; brpop(final double timeout, final byte[]... keys) {
1023      return connection.executeCommand(commandObjects.brpop(timeout, keys));
1024    }
1025    @Override
1026    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, byte[]... keys) {
1027      checkIsInMultiOrPipeline();
1028      return connection.executeCommand(commandObjects.lmpop(direction, keys));
1029    }
1030    @Override
1031    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, int count, byte[]... keys) {
1032      checkIsInMultiOrPipeline();
1033      return connection.executeCommand(commandObjects.lmpop(direction, count, keys));
1034    }
1035    @Override
1036    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, byte[]... keys) {
1037      checkIsInMultiOrPipeline();
1038      return connection.executeCommand(commandObjects.blmpop(timeout, direction, keys));
1039    }
1040    @Override
1041    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, int count, byte[]... keys) {
1042      checkIsInMultiOrPipeline();
1043      return connection.executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1044    }
1045    @Override
1046    public KeyValue&lt;byte[], Tuple&gt; bzpopmax(final double timeout, final byte[]... keys) {
1047      return connection.executeCommand(commandObjects.bzpopmax(timeout, keys));
1048    }
1049    @Override
1050    public KeyValue&lt;byte[], Tuple&gt; bzpopmin(final double timeout, final byte[]... keys) {
1051      return connection.executeCommand(commandObjects.bzpopmin(timeout, keys));
1052    }
1053    @Override
1054    public String auth(final String password) {
1055      checkIsInMultiOrPipeline();
1056      connection.sendCommand(Command.AUTH, password);
1057      return connection.getStatusCodeReply();
1058    }
1059    @Override
1060    public String auth(final String user, final String password) {
1061      checkIsInMultiOrPipeline();
1062      connection.sendCommand(Command.AUTH, user, password);
1063      return connection.getStatusCodeReply();
1064    }
1065    @Override
1066    public long zcount(final byte[] key, final double min, final double max) {
1067      checkIsInMultiOrPipeline();
1068      return connection.executeCommand(commandObjects.zcount(key, min, max));
1069    }
1070    @Override
1071    public long zcount(final byte[] key, final byte[] min, final byte[] max) {
1072      checkIsInMultiOrPipeline();
1073      return connection.executeCommand(commandObjects.zcount(key, min, max));
1074    }
1075    @Override
1076    public List&lt;byte[]&gt; zdiff(final byte[]... keys) {
1077      checkIsInMultiOrPipeline();
1078      return connection.executeCommand(commandObjects.zdiff(keys));
1079    }
1080    @Override
1081    public List&lt;Tuple&gt; zdiffWithScores(final byte[]... keys) {
1082      checkIsInMultiOrPipeline();
1083      return connection.executeCommand(commandObjects.zdiffWithScores(keys));
1084    }
1085    @Override
1086    @Deprecated
1087    public long zdiffStore(final byte[] dstkey, final byte[]... keys) {
1088      checkIsInMultiOrPipeline();
1089      return connection.executeCommand(commandObjects.zdiffStore(dstkey, keys));
1090    }
1091    @Override
1092    public long zdiffstore(final byte[] dstkey, final byte[]... keys) {
1093      checkIsInMultiOrPipeline();
1094      return connection.executeCommand(commandObjects.zdiffstore(dstkey, keys));
1095    }
1096    @Override
1097    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final double min, final double max) {
1098      checkIsInMultiOrPipeline();
1099      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
1100    }
1101    @Override
1102    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
1103      checkIsInMultiOrPipeline();
1104      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
1105    }
1106    @Override
1107    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final double min, final double max,
1108        final int offset, final int count) {
1109      checkIsInMultiOrPipeline();
1110      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1111    }
1112    @Override
1113    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final byte[] min, final byte[] max,
1114        final int offset, final int count) {
1115      checkIsInMultiOrPipeline();
1116      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1117    }
1118    @Override
1119    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
1120      checkIsInMultiOrPipeline();
1121      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1122    }
1123    @Override
1124    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
1125      checkIsInMultiOrPipeline();
1126      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1127    }
1128    @Override
1129    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final double min, final double max,
1130        final int offset, final int count) {
1131      checkIsInMultiOrPipeline();
1132      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1133    }
1134    @Override
1135    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
1136        final int offset, final int count) {
1137      checkIsInMultiOrPipeline();
1138      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1139    }
1140    @Override
1141    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final double max, final double min) {
1142      checkIsInMultiOrPipeline();
1143      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1144    }
1145    @Override
1146    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
1147      checkIsInMultiOrPipeline();
1148      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1149    }
1150    @Override
1151    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final double max, final double min,
1152        final int offset, final int count) {
1153      checkIsInMultiOrPipeline();
1154      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1155    }
1156    @Override
1157    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
1158        final int offset, final int count) {
1159      checkIsInMultiOrPipeline();
1160      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1161    }
1162    @Override
1163    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
1164      checkIsInMultiOrPipeline();
1165      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1166    }
1167    @Override
1168    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final double max,
1169        final double min, final int offset, final int count) {
1170      checkIsInMultiOrPipeline();
1171      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1172    }
1173    @Override
1174    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
1175      checkIsInMultiOrPipeline();
1176      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1177    }
1178    @Override
1179    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
1180        final byte[] min, final int offset, final int count) {
1181      checkIsInMultiOrPipeline();
1182      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1183    }
1184    @Override
1185    public long zremrangeByRank(final byte[] key, final long start, final long stop) {
1186      checkIsInMultiOrPipeline();
1187      return connection.executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1188    }
1189    @Override
1190    public long zremrangeByScore(final byte[] key, final double min, final double max) {
1191      checkIsInMultiOrPipeline();
1192      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
1193    }
1194    @Override
1195    public long zremrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
1196      checkIsInMultiOrPipeline();
1197      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
1198    }
1199    @Override
1200    public List&lt;byte[]&gt; zunion(final ZParams params, final byte[]... keys) {
1201      checkIsInMultiOrPipeline();
1202      return connection.executeCommand(commandObjects.zunion(params, keys));
1203    }
1204    @Override
1205    public List&lt;Tuple&gt; zunionWithScores(final ZParams params, final byte[]... keys) {
1206      checkIsInMultiOrPipeline();
1207      return connection.executeCommand(commandObjects.zunionWithScores(params, keys));
1208    }
1209    @Override
1210    public long zunionstore(final byte[] dstkey, final byte[]... sets) {
1211      checkIsInMultiOrPipeline();
1212      return connection.executeCommand(commandObjects.zunionstore(dstkey, sets));
1213    }
1214    @Override
1215    public long zunionstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
1216      checkIsInMultiOrPipeline();
1217      return connection.executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1218    }
1219    @Override
1220    public List&lt;byte[]&gt; zinter(final ZParams params, final byte[]... keys) {
1221      checkIsInMultiOrPipeline();
1222      return connection.executeCommand(commandObjects.zinter(params, keys));
1223    }
1224    @Override
1225    public List&lt;Tuple&gt; zinterWithScores(final ZParams params, final byte[]... keys) {
1226      checkIsInMultiOrPipeline();
1227      return connection.executeCommand(commandObjects.zinterWithScores(params, keys));
1228    }
1229    @Override
1230    public long zinterstore(final byte[] dstkey, final byte[]... sets) {
1231      checkIsInMultiOrPipeline();
1232      return connection.executeCommand(commandObjects.zinterstore(dstkey, sets));
1233    }
1234    @Override
1235    public long zinterstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
1236      checkIsInMultiOrPipeline();
1237      return connection.executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1238    }
1239    @Override
1240    public long zintercard(byte[]... keys) {
1241      checkIsInMultiOrPipeline();
1242      return connection.executeCommand(commandObjects.zintercard(keys));
1243    }
1244    @Override
1245    public long zintercard(long limit, byte[]... keys) {
1246      checkIsInMultiOrPipeline();
1247      return connection.executeCommand(commandObjects.zintercard(limit, keys));
1248    }
1249    @Override
1250    public long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
1251      checkIsInMultiOrPipeline();
1252      return connection.executeCommand(commandObjects.zlexcount(key, min, max));
1253    }
1254    @Override
1255    public List&lt;byte[]&gt; zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
1256      checkIsInMultiOrPipeline();
1257      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max));
1258    }
1259    @Override
1260    public List&lt;byte[]&gt; zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
1261        final int offset, final int count) {
1262      checkIsInMultiOrPipeline();
1263      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1264    }
1265    @Override
1266    public List&lt;byte[]&gt; zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min) {
1267      checkIsInMultiOrPipeline();
1268      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1269    }
1270    @Override
1271    public List&lt;byte[]&gt; zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
1272        final int offset, final int count) {
1273      checkIsInMultiOrPipeline();
1274      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1275    }
1276    @Override
1277    public long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
1278      checkIsInMultiOrPipeline();
1279      return connection.executeCommand(commandObjects.zremrangeByLex(key, min, max));
1280    }
1281    @Override
1282    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, byte[]... keys) {
1283      checkIsInMultiOrPipeline();
1284      return connection.executeCommand(commandObjects.zmpop(option, keys));
1285    }
1286    @Override
1287    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, byte[]... keys) {
1288      checkIsInMultiOrPipeline();
1289      return connection.executeCommand(commandObjects.zmpop(option, count, keys));
1290    }
1291    @Override
1292    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, byte[]... keys) {
1293      checkIsInMultiOrPipeline();
1294      return connection.executeCommand(commandObjects.bzmpop(timeout, option, keys));
1295    }
1296    @Override
1297    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, byte[]... keys) {
1298      checkIsInMultiOrPipeline();
1299      return connection.executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
1300    }
1301    @Override
1302    public String save() {
1303      connection.sendCommand(Command.SAVE);
1304      return connection.getStatusCodeReply();
1305    }
1306    @Override
1307    public String bgsave() {
1308      connection.sendCommand(BGSAVE);
1309      return connection.getStatusCodeReply();
1310    }
1311    @Override
1312    public String bgsaveSchedule() {
1313      connection.sendCommand(BGSAVE, SCHEDULE);
1314      return connection.getStatusCodeReply();
1315    }
1316    @Override
1317    public String bgrewriteaof() {
1318      connection.sendCommand(BGREWRITEAOF);
1319      return connection.getStatusCodeReply();
1320    }
1321    @Override
1322    public long lastsave() {
1323      connection.sendCommand(LASTSAVE);
1324      return connection.getIntegerReply();
1325    }
1326    @Override
1327    public void shutdown() throws JedisException {
1328      connection.sendCommand(SHUTDOWN);
1329      try {
1330        throw new JedisException(connection.getStatusCodeReply());
1331      } catch (JedisConnectionException jce) {
1332        connection.setBroken();
1333      }
1334    }
1335    @Override
1336    public void shutdown(ShutdownParams shutdownParams) throws JedisException {
1337      connection.sendCommand(new CommandArguments(SHUTDOWN).addParams(shutdownParams));
1338      try {
1339        throw new JedisException(connection.getStatusCodeReply());
1340      } catch (JedisConnectionException jce) {
1341        connection.setBroken();
1342      }
1343    }
1344    @Override
1345    public String shutdownAbort() {
1346      connection.sendCommand(SHUTDOWN, ABORT);
1347      return connection.getStatusCodeReply();
1348    }
1349    @Override
1350    public String info() {
1351      connection.sendCommand(Command.INFO);
1352      return connection.getBulkReply();
1353    }
1354    @Override
1355    public String info(final String section) {
1356      connection.sendCommand(Command.INFO, section);
1357      return connection.getBulkReply();
1358    }
1359    public void monitor(final JedisMonitor jedisMonitor) {
1360      connection.sendCommand(Command.MONITOR);
1361      connection.getStatusCodeReply();
1362      jedisMonitor.proceed(connection);
1363    }
1364    @Override
1365    @Deprecated
1366    public String slaveof(final String host, final int port) {
1367      connection.sendCommand(SLAVEOF, encode(host), toByteArray(port));
1368      return connection.getStatusCodeReply();
1369    }
1370    @Override
1371    @Deprecated
1372    public String slaveofNoOne() {
1373      connection.sendCommand(SLAVEOF, NO.getRaw(), ONE.getRaw());
1374      return connection.getStatusCodeReply();
1375    }
1376    @Override
1377    public String replicaof(final String host, final int port) {
1378      connection.sendCommand(REPLICAOF, encode(host), toByteArray(port));
1379      return connection.getStatusCodeReply();
1380    }
1381    @Override
1382    public String replicaofNoOne() {
1383      connection.sendCommand(REPLICAOF, NO.getRaw(), ONE.getRaw());
1384      return connection.getStatusCodeReply();
1385    }
1386    @Override
1387    public List&lt;Object&gt; roleBinary() {
1388      checkIsInMultiOrPipeline();
1389      connection.sendCommand(ROLE);
1390      return BuilderFactory.RAW_OBJECT_LIST.build(connection.getOne());
1391    }
1392    @Override
1393    public Map&lt;byte[], byte[]&gt; configGet(final byte[] pattern) {
1394      checkIsInMultiOrPipeline();
1395      connection.sendCommand(Command.CONFIG, Keyword.GET.getRaw(), pattern);
1396      return BuilderFactory.BINARY_MAP.build(connection.getOne());
1397    }
1398    @Override
1399    public Map&lt;byte[], byte[]&gt; configGet(byte[]... patterns) {
1400      checkIsInMultiOrPipeline();
1401      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.GET.getRaw(), patterns));
1402      return BuilderFactory.BINARY_MAP.build(connection.getOne());
1403    }
1404    @Override
1405    public String configResetStat() {
1406      checkIsInMultiOrPipeline();
1407      connection.sendCommand(Command.CONFIG, Keyword.RESETSTAT);
1408      return connection.getStatusCodeReply();
1409    }
1410    @Override
1411    public String configRewrite() {
1412      checkIsInMultiOrPipeline();
1413      connection.sendCommand(Command.CONFIG, Keyword.REWRITE);
1414      return connection.getStatusCodeReply();
1415    }
1416    @Override
1417    public String configSet(final byte[] parameter, final byte[] value) {
1418      checkIsInMultiOrPipeline();
1419      connection.sendCommand(Command.CONFIG, Keyword.SET.getRaw(), parameter, value);
1420      return connection.getStatusCodeReply();
1421    }
1422    @Override
1423    public String configSet(final byte[]... parameterValues) {
1424      checkIsInMultiOrPipeline();
1425      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.SET.getRaw(), parameterValues));
1426      return connection.getStatusCodeReply();
1427    }
1428    @Override
1429    public String configSetBinary(Map&lt;byte[], byte[]&gt; parameterValues) {
1430      checkIsInMultiOrPipeline();
1431      CommandArguments args = new CommandArguments(Command.CONFIG).add(Keyword.SET);
1432      parameterValues.forEach((k, v) -&gt; args.add(k).add(v));
1433      connection.sendCommand(args);
1434      return connection.getStatusCodeReply();
1435    }
1436    @Override
1437    public long strlen(final byte[] key) {
1438      checkIsInMultiOrPipeline();
1439      return connection.executeCommand(commandObjects.strlen(key));
1440    }
1441    @Override
1442    public LCSMatchResult lcs(final byte[] keyA, final byte[] keyB, final LCSParams params) {
1443      checkIsInMultiOrPipeline();
1444      return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));
1445    }
1446    @Override
1447    public long lpushx(final byte[] key, final byte[]... strings) {
1448      checkIsInMultiOrPipeline();
1449      return connection.executeCommand(commandObjects.lpushx(key, strings));
1450    }
1451    @Override
1452    public long persist(final byte[] key) {
1453      checkIsInMultiOrPipeline();
1454      return connection.executeCommand(commandObjects.persist(key));
1455    }
1456    @Override
1457    public long rpushx(final byte[] key, final byte[]... strings) {
1458      checkIsInMultiOrPipeline();
1459      return connection.executeCommand(commandObjects.rpushx(key, strings));
1460    }
1461    @Override
1462    public byte[] echo(final byte[] string) {
1463      checkIsInMultiOrPipeline();
1464      connection.sendCommand(ECHO, string);
1465      return connection.getBinaryBulkReply();
1466    }
1467    @Override
1468    public long linsert(final byte[] key, final ListPosition where, final byte[] pivot,
1469        final byte[] value) {
1470      checkIsInMultiOrPipeline();
1471      return connection.executeCommand(commandObjects.linsert(key, where, pivot, value));
1472    }
1473    @Override
1474    public byte[] brpoplpush(final byte[] source, final byte[] destination, final int timeout) {
1475      checkIsInMultiOrPipeline();
1476      return connection.executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1477    }
1478    @Override
1479    public boolean setbit(final byte[] key, final long offset, final boolean value) {
1480      checkIsInMultiOrPipeline();
1481      return connection.executeCommand(commandObjects.setbit(key, offset, value));
1482    }
1483    @Override
1484    public boolean getbit(final byte[] key, final long offset) {
1485      checkIsInMultiOrPipeline();
1486      return connection.executeCommand(commandObjects.getbit(key, offset));
1487    }
1488    @Override
1489    public long bitpos(final byte[] key, final boolean value) {
1490      return bitpos(key, value, new BitPosParams());
1491    }
1492    @Override
1493    public long bitpos(final byte[] key, final boolean value, final BitPosParams params) {
1494      checkIsInMultiOrPipeline();
1495      return connection.executeCommand(commandObjects.bitpos(key, value, params));
1496    }
1497    @Override
1498    public long setrange(final byte[] key, final long offset, final byte[] value) {
1499      checkIsInMultiOrPipeline();
1500      return connection.executeCommand(commandObjects.setrange(key, offset, value));
1501    }
1502    @Override
1503    public byte[] getrange(final byte[] key, final long startOffset, final long endOffset) {
1504      checkIsInMultiOrPipeline();
1505      return connection.executeCommand(commandObjects.getrange(key, startOffset, endOffset));
1506    }
1507    public long publish(final byte[] channel, final byte[] message) {
1508      checkIsInMultiOrPipeline();
1509      return connection.executeCommand(commandObjects.publish(channel, message));
1510    }
1511    public void subscribe(BinaryJedisPubSub jedisPubSub, final byte[]... channels) {
1512      jedisPubSub.proceed(connection, channels);
1513    }
1514    public void psubscribe(BinaryJedisPubSub jedisPubSub, final byte[]... patterns) {
1515      jedisPubSub.proceedWithPatterns(connection, patterns);
1516    }
1517    @Override
1518    public Object eval(final byte[] script, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
1519      checkIsInMultiOrPipeline();
1520      return connection.executeCommand(commandObjects.eval(script, keys, args));
1521    }
1522    @Override
1523    public Object evalReadonly(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1524      checkIsInMultiOrPipeline();
1525      return connection.executeCommand(commandObjects.evalReadonly(script, keys, args));
1526    }
1527    protected static byte[][] getParamsWithBinary(List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1528      final int keyCount = keys.size();
1529      final int argCount = args.size();
1530      byte[][] params = new byte[keyCount + argCount][];
1531      for (int i = 0; i &lt; keyCount; i++)
1532        params[i] = keys.get(i);
1533      for (int i = 0; i &lt; argCount; i++)
1534        params[keyCount + i] = args.get(i);
1535      return params;
1536    }
1537    @Override
1538    public Object eval(final byte[] script, final int keyCount, final byte[]... params) {
1539      checkIsInMultiOrPipeline();
1540      return connection.executeCommand(commandObjects.eval(script, keyCount, params));
1541    }
1542    @Override
1543    public Object eval(final byte[] script) {
1544      checkIsInMultiOrPipeline();
1545      return connection.executeCommand(commandObjects.eval(script));
1546    }
1547    @Override
1548    public Object evalsha(final byte[] sha1) {
1549      checkIsInMultiOrPipeline();
1550      return connection.executeCommand(commandObjects.evalsha(sha1));
1551    }
1552    @Override
1553    public Object evalsha(final byte[] sha1, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
1554      checkIsInMultiOrPipeline();
1555      return connection.executeCommand(commandObjects.evalsha(sha1, keys, args));
1556    }
1557    @Override
1558    public Object evalshaReadonly(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1559      checkIsInMultiOrPipeline();
1560      return connection.executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
1561    }
1562    @Override
1563    public Object evalsha(final byte[] sha1, final int keyCount, final byte[]... params) {
1564      checkIsInMultiOrPipeline();
1565      return connection.executeCommand(commandObjects.evalsha(sha1, keyCount, params));
1566    }
1567    @Override
1568    public String scriptFlush() {
1569      connection.sendCommand(SCRIPT, FLUSH);
1570      return connection.getStatusCodeReply();
1571    }
1572    @Override
1573    public String scriptFlush(final FlushMode flushMode) {
1574      connection.sendCommand(SCRIPT, FLUSH.getRaw(), flushMode.getRaw());
1575      return connection.getStatusCodeReply();
1576    }
1577    @Override
1578    public Boolean scriptExists(final byte[] sha1) {
1579      byte[][] a = new byte[1][];
1580      a[0] = sha1;
1581      return scriptExists(a).get(0);
1582    }
1583    @Override
1584    public List&lt;Boolean&gt; scriptExists(final byte[]... sha1) {
1585      connection.sendCommand(SCRIPT, joinParameters(Keyword.EXISTS.getRaw(), sha1));
1586      return BuilderFactory.BOOLEAN_LIST.build(connection.getOne());
1587    }
1588    @Override
1589    public byte[] scriptLoad(final byte[] script) {
1590      connection.sendCommand(SCRIPT, LOAD.getRaw(), script);
1591      return connection.getBinaryBulkReply();
1592    }
1593    @Override
1594    public String scriptKill() {
1595      return connection.executeCommand(commandObjects.scriptKill());
1596    }
1597    @Override
1598    public String slowlogReset() {
1599      return connection.executeCommand(commandObjects.slowlogReset());
1600    }
1601    @Override
1602    public long slowlogLen() {
1603      connection.sendCommand(SLOWLOG, LEN);
1604      return connection.getIntegerReply();
1605    }
1606    @Override
1607    public List&lt;Object&gt; slowlogGetBinary() {
1608      connection.sendCommand(SLOWLOG, Keyword.GET);
1609      return connection.getObjectMultiBulkReply();
1610    }
1611    @Override
1612    public List&lt;Object&gt; slowlogGetBinary(final long entries) {
1613      connection.sendCommand(SLOWLOG, Keyword.GET.getRaw(), toByteArray(entries));
1614      return connection.getObjectMultiBulkReply();
1615    }
1616    @Override
1617    public Long objectRefcount(final byte[] key) {
1618      connection.sendCommand(OBJECT, REFCOUNT.getRaw(), key);
1619      return connection.getIntegerReply();
1620    }
1621    @Override
1622    public byte[] objectEncoding(final byte[] key) {
1623      connection.sendCommand(OBJECT, ENCODING.getRaw(), key);
1624      return connection.getBinaryBulkReply();
1625    }
1626    @Override
1627    public Long objectIdletime(final byte[] key) {
1628      connection.sendCommand(OBJECT, IDLETIME.getRaw(), key);
1629      return connection.getIntegerReply();
1630    }
1631    @Override
1632    public List&lt;byte[]&gt; objectHelpBinary() {
1633      connection.sendCommand(OBJECT, HELP);
1634      return connection.getBinaryMultiBulkReply();
1635    }
1636    @Override
1637    public Long objectFreq(final byte[] key) {
1638      connection.sendCommand(OBJECT, FREQ.getRaw(), key);
1639      return connection.getIntegerReply();
1640    }
1641    @Override
1642    public long bitcount(final byte[] key) {
1643      checkIsInMultiOrPipeline();
1644      return connection.executeCommand(commandObjects.bitcount(key));
1645    }
1646    @Override
1647    public long bitcount(final byte[] key, final long start, final long end) {
1648      checkIsInMultiOrPipeline();
1649      return connection.executeCommand(commandObjects.bitcount(key, start, end));
1650    }
1651    @Override
1652    public long bitcount(final byte[] key, final long start, final long end, final BitCountOption option) {
1653      checkIsInMultiOrPipeline();
1654      return connection.executeCommand(commandObjects.bitcount(key, start, end, option));
1655    }
1656    @Override
1657    public long bitop(final BitOP op, final byte[] destKey, final byte[]... srcKeys) {
1658      checkIsInMultiOrPipeline();
1659      return connection.executeCommand(commandObjects.bitop(op, destKey, srcKeys));
1660    }
1661    @Override
1662    public byte[] dump(final byte[] key) {
1663      checkIsInMultiOrPipeline();
1664      return connection.executeCommand(commandObjects.dump(key));
1665    }
1666    @Override
1667    public String restore(final byte[] key, final long ttl, final byte[] serializedValue) {
1668      checkIsInMultiOrPipeline();
1669      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue));
1670    }
1671    @Override
1672    public String restore(final byte[] key, final long ttl, final byte[] serializedValue,
1673        final RestoreParams params) {
1674      checkIsInMultiOrPipeline();
1675      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
1676    }
1677    @Override
1678    public long pttl(final byte[] key) {
1679      checkIsInMultiOrPipeline();
1680      return connection.executeCommand(commandObjects.pttl(key));
1681    }
1682    @Override
1683    public String psetex(final byte[] key, final long milliseconds, final byte[] value) {
1684      checkIsInMultiOrPipeline();
1685      return connection.executeCommand(commandObjects.psetex(key, milliseconds, value));
1686    }
1687    @Override
1688    public byte[] memoryDoctorBinary() {
1689      checkIsInMultiOrPipeline();
1690      connection.sendCommand(MEMORY, DOCTOR);
1691      return connection.getBinaryBulkReply();
1692    }
1693    @Override
1694    public Long memoryUsage(final byte[] key) {
1695      checkIsInMultiOrPipeline();
1696      connection.sendCommand(MEMORY, USAGE.getRaw(), key);
1697      return connection.getIntegerReply();
1698    }
1699    @Override
1700    public Long memoryUsage(final byte[] key, final int samples) {
1701      checkIsInMultiOrPipeline();
1702      connection.sendCommand(MEMORY, USAGE.getRaw(), key, SAMPLES.getRaw(), toByteArray(samples));
1703      return connection.getIntegerReply();
1704    }
1705    @Override
1706    public String failover() {
1707      checkIsInMultiOrPipeline();
1708      connection.sendCommand(Command.FAILOVER);
1709      connection.setTimeoutInfinite();
1710      try {
1711        return connection.getStatusCodeReply();
1712      } finally {
1713        connection.rollbackTimeout();
1714      }
1715    }
1716    @Override
1717    public String failover(FailoverParams failoverParams) {
1718      checkIsInMultiOrPipeline();
1719      CommandArguments args = new ClusterCommandArguments(Command.FAILOVER).addParams(failoverParams);
1720      connection.sendCommand(args);
1721      connection.setTimeoutInfinite();
1722      try {
1723        return connection.getStatusCodeReply();
1724      } finally {
1725        connection.rollbackTimeout();
1726      }
1727    }
1728    @Override
1729    public String failoverAbort() {
1730      checkIsInMultiOrPipeline();
1731      connection.sendCommand(Command.FAILOVER, ABORT);
1732      return connection.getStatusCodeReply();
1733    }
1734    @Override
1735    public byte[] aclWhoAmIBinary() {
1736      checkIsInMultiOrPipeline();
1737      connection.sendCommand(ACL, WHOAMI);
1738      return connection.getBinaryBulkReply();
1739    }
1740    @Override
1741    public byte[] aclGenPassBinary() {
1742      checkIsInMultiOrPipeline();
1743      connection.sendCommand(ACL, GENPASS);
1744      return connection.getBinaryBulkReply();
1745    }
1746    @Override
1747    public byte[] aclGenPassBinary(int bits) {
1748      checkIsInMultiOrPipeline();
1749      connection.sendCommand(ACL, GENPASS.getRaw(), toByteArray(bits));
1750      return connection.getBinaryBulkReply();
1751    }
1752    @Override
1753    public List&lt;byte[]&gt; aclListBinary() {
1754      checkIsInMultiOrPipeline();
1755      connection.sendCommand(ACL, LIST);
1756      return connection.getBinaryMultiBulkReply();
1757    }
1758    @Override
1759    public List&lt;byte[]&gt; aclUsersBinary() {
1760      checkIsInMultiOrPipeline();
1761      connection.sendCommand(ACL, USERS);
1762      return connection.getBinaryMultiBulkReply();
1763    }
1764    @Override
1765    public AccessControlUser aclGetUser(byte[] name) {
1766      checkIsInMultiOrPipeline();
1767      connection.sendCommand(ACL, GETUSER.getRaw(), name);
1768      return BuilderFactory.ACCESS_CONTROL_USER.build(connection.getObjectMultiBulkReply());
1769    }
1770    @Override
1771    public String aclSetUser(byte[] name) {
1772      checkIsInMultiOrPipeline();
1773      connection.sendCommand(ACL, SETUSER.getRaw(), name);
1774      return connection.getStatusCodeReply();
1775    }
1776    @Override
1777    public String aclSetUser(byte[] name, byte[]... rules) {
1778      checkIsInMultiOrPipeline();
1779      connection.sendCommand(ACL, joinParameters(SETUSER.getRaw(), name, rules));
1780      return connection.getStatusCodeReply();
1781    }
1782    @Override
1783    public long aclDelUser(byte[]... names) {
1784      checkIsInMultiOrPipeline();
1785      connection.sendCommand(ACL, joinParameters(DELUSER.getRaw(), names));
1786      return connection.getIntegerReply();
1787    }
1788    @Override
1789    public List&lt;byte[]&gt; aclCatBinary() {
1790      checkIsInMultiOrPipeline();
1791      connection.sendCommand(ACL, CAT);
1792      return connection.getBinaryMultiBulkReply();
1793    }
1794    @Override
1795    public List&lt;byte[]&gt; aclCat(byte[] category) {
1796      checkIsInMultiOrPipeline();
1797      connection.sendCommand(ACL, CAT.getRaw(), category);
1798      return connection.getBinaryMultiBulkReply();
1799    }
1800    @Override
1801    public List&lt;byte[]&gt; aclLogBinary() {
1802      checkIsInMultiOrPipeline();
1803      connection.sendCommand(ACL, LOG);
1804      return connection.getBinaryMultiBulkReply();
1805    }
1806    @Override
1807    public List&lt;byte[]&gt; aclLogBinary(int limit) {
1808      checkIsInMultiOrPipeline();
1809      connection.sendCommand(ACL, LOG.getRaw(), toByteArray(limit));
1810      return connection.getBinaryMultiBulkReply();
1811    }
1812    @Override
1813    public String aclLogReset() {
1814      checkIsInMultiOrPipeline();
1815      connection.sendCommand(ACL, LOG.getRaw(), Keyword.RESET.getRaw());
1816      return connection.getStatusCodeReply();
1817    }
1818    @Override
1819    public String clientKill(final byte[] ipPort) {
1820      checkIsInMultiOrPipeline();
1821      connection.sendCommand(CLIENT, KILL.getRaw(), ipPort);
1822      return this.connection.getStatusCodeReply();
1823    }
1824    @Override
1825    public String clientKill(final String ip, final int port) {
1826      return clientKill(ip + &#x27;:&#x27; + port);
1827    }
1828    @Override
1829    public long clientKill(ClientKillParams params) {
1830      checkIsInMultiOrPipeline();
1831      connection.sendCommand(new CommandArguments(CLIENT).add(KILL).addParams(params));
1832      return this.connection.getIntegerReply();
1833    }
1834    @Override
1835    public byte[] clientGetnameBinary() {
1836      checkIsInMultiOrPipeline();
1837      connection.sendCommand(CLIENT, GETNAME);
1838      return connection.getBinaryBulkReply();
1839    }
1840    @Override
1841    public byte[] clientListBinary() {
1842      checkIsInMultiOrPipeline();
1843      connection.sendCommand(CLIENT, LIST);
1844      return connection.getBinaryBulkReply();
1845    }
1846    @Override
1847    public byte[] clientListBinary(ClientType type) {
1848      checkIsInMultiOrPipeline();
1849      connection.sendCommand(CLIENT, LIST.getRaw(), type.getRaw());
1850      return connection.getBinaryBulkReply();
1851    }
1852    @Override
1853    public byte[] clientListBinary(final long... clientIds) {
1854      checkIsInMultiOrPipeline();
1855      connection.sendCommand(CLIENT, clientListParams(clientIds));
1856      return connection.getBinaryBulkReply();
1857    }
1858    private byte[][] clientListParams(final long... clientIds) {
1859      final byte[][] params = new byte[2 + clientIds.length][];
1860      int index = 0;
1861      params[index++] = Keyword.LIST.getRaw();
1862      params[index++] = ID.getRaw();
1863      for (final long clientId : clientIds) {
1864        params[index++] = toByteArray(clientId);
1865      }
1866      return params;
1867    }
1868    @Override
1869    public byte[] clientInfoBinary() {
1870      checkIsInMultiOrPipeline();
1871      connection.sendCommand(CLIENT, Keyword.INFO);
1872      return connection.getBinaryBulkReply();
1873    }
1874    @Override
1875    public String clientSetInfo(ClientAttributeOption attr, byte[] value) {
1876      checkIsInMultiOrPipeline();
1877      connection.sendCommand(CLIENT, SETINFO.getRaw(), attr.getRaw(), value);
1878      return connection.getStatusCodeReply();
1879    }
1880    @Override
1881    public String clientSetname(final byte[] name) {
1882      checkIsInMultiOrPipeline();
1883      connection.sendCommand(CLIENT, SETNAME.getRaw(), name);
1884      return connection.getBulkReply();
1885    }
1886    @Override
1887    public long clientId() {
1888      checkIsInMultiOrPipeline();
1889      connection.sendCommand(CLIENT, ID);
1890      return connection.getIntegerReply();
1891    }
1892    @Override
1893    public long clientUnblock(final long clientId) {
1894      checkIsInMultiOrPipeline();
1895      connection.sendCommand(CLIENT, UNBLOCK.getRaw(), toByteArray(clientId));
1896      return connection.getIntegerReply();
1897    }
1898    @Override
1899    public long clientUnblock(final long clientId, final UnblockType unblockType) {
1900      checkIsInMultiOrPipeline();
1901      connection.sendCommand(CLIENT, UNBLOCK.getRaw(), toByteArray(clientId), unblockType.getRaw());
1902      return connection.getIntegerReply();
1903    }
1904    @Override
1905    public String clientPause(final long timeout) {
1906      checkIsInMultiOrPipeline();
1907      connection.sendCommand(CLIENT, PAUSE.getRaw(), toByteArray(timeout));
1908      return connection.getBulkReply();
1909    }
1910    @Override
1911    public String clientPause(final long timeout, final ClientPauseMode mode) {
1912      checkIsInMultiOrPipeline();
1913      connection.sendCommand(CLIENT, PAUSE.getRaw(), toByteArray(timeout), mode.getRaw());
1914      return connection.getBulkReply();
1915    }
1916    @Override
1917    public String clientUnpause() {
1918      checkIsInMultiOrPipeline();
1919      connection.sendCommand(CLIENT, UNPAUSE);
1920      return connection.getBulkReply();
1921    }
1922    @Override
1923    public String clientNoEvictOn() {
1924      checkIsInMultiOrPipeline();
1925      connection.sendCommand(CLIENT, &quot;NO-EVICT&quot;, &quot;ON&quot;);
1926      return connection.getBulkReply();
1927    }
1928    @Override
1929    public String clientNoEvictOff() {
1930      checkIsInMultiOrPipeline();
1931      connection.sendCommand(CLIENT, &quot;NO-EVICT&quot;, &quot;OFF&quot;);
1932      return connection.getBulkReply();
1933    }
1934    @Override
1935    public String clientNoTouchOn() {
1936      checkIsInMultiOrPipeline();
1937      connection.sendCommand(CLIENT, &quot;NO-TOUCH&quot;, &quot;ON&quot;);
1938      return connection.getStatusCodeReply();
1939    }
1940    @Override
1941    public String clientNoTouchOff() {
1942      checkIsInMultiOrPipeline();
1943      connection.sendCommand(CLIENT, &quot;NO-TOUCH&quot;, &quot;OFF&quot;);
1944      return connection.getStatusCodeReply();
1945    }
1946    public List&lt;String&gt; time() {
1947      checkIsInMultiOrPipeline();
1948      connection.sendCommand(Command.TIME);
1949      return connection.getMultiBulkReply();
1950    }
1951    @Override
1952    public String migrate(final String host, final int port, final byte[] key,
1953        final int destinationDb, final int timeout) {
1954      checkIsInMultiOrPipeline();
1955      return connection.executeCommand(commandObjects.migrate(host, port, key, destinationDb, timeout));
1956    }
1957    @Override
1958    public String migrate(final String host, final int port, final int destinationDB,
1959        final int timeout, final MigrateParams params, final byte[]... keys) {
1960      checkIsInMultiOrPipeline();
1961      return connection.executeCommand(commandObjects.migrate(host, port, destinationDB, timeout, params, keys));
1962    }
1963    @Override
1964    public String migrate(String host, int port, byte[] key, int timeout) {
1965      checkIsInMultiOrPipeline();
1966      return connection.executeCommand(commandObjects.migrate(host, port, key, timeout));
1967    }
1968    @Override
1969    public String migrate(String host, int port, int timeout, MigrateParams params, byte[]... keys) {
1970      checkIsInMultiOrPipeline();
1971      return connection.executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
1972    }
1973    @Override
1974    public long waitReplicas(final int replicas, final long timeout) {
1975      checkIsInMultiOrPipeline();
1976      connection.sendCommand(WAIT, toByteArray(replicas), toByteArray(timeout));
1977      return connection.getIntegerReply();
1978    }
1979    @Override
1980    public KeyValue&lt;Long, Long&gt; waitAOF(long numLocal, long numReplicas, long timeout) {
1981      checkIsInMultiOrPipeline();
1982      connection.sendCommand(WAITAOF, toByteArray(numLocal), toByteArray(numReplicas), toByteArray(timeout));
1983      return BuilderFactory.LONG_LONG_PAIR.build(connection.getOne());
1984    }
1985    @Override
1986    public long pfadd(final byte[] key, final byte[]... elements) {
1987      checkIsInMultiOrPipeline();
1988      return connection.executeCommand(commandObjects.pfadd(key, elements));
1989    }
1990    @Override
1991    public long pfcount(final byte[] key) {
1992      checkIsInMultiOrPipeline();
1993      return connection.executeCommand(commandObjects.pfcount(key));
1994    }
1995    @Override
1996    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
1997      checkIsInMultiOrPipeline();
1998      return connection.executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
1999    }
2000    @Override
2001    public long pfcount(final byte[]... keys) {
2002      checkIsInMultiOrPipeline();
2003      return connection.executeCommand(commandObjects.pfcount(keys));
2004    }
2005    @Override
2006    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor) {
2007      checkIsInMultiOrPipeline();
2008      return connection.executeCommand(commandObjects.scan(cursor));
2009    }
2010    @Override
2011    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor, final ScanParams params) {
2012      checkIsInMultiOrPipeline();
2013      return connection.executeCommand(commandObjects.scan(cursor, params));
2014    }
2015    @Override
2016    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor, final ScanParams params, final byte[] type) {
2017      checkIsInMultiOrPipeline();
2018      return connection.executeCommand(commandObjects.scan(cursor, params, type));
2019    }
2020    @Override
2021    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(final byte[] key, final byte[] cursor) {
2022      return hscan(key, cursor, new ScanParams());
2023    }
2024    @Override
2025    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(final byte[] key, final byte[] cursor,
2026        final ScanParams params) {
2027      checkIsInMultiOrPipeline();
2028      return connection.executeCommand(commandObjects.hscan(key, cursor, params));
2029    }
2030    @Override
2031    public ScanResult&lt;byte[]&gt; sscan(final byte[] key, final byte[] cursor) {
2032      return sscan(key, cursor, new ScanParams());
2033    }
2034    @Override
2035    public ScanResult&lt;byte[]&gt; sscan(final byte[] key, final byte[] cursor, final ScanParams params) {
2036      checkIsInMultiOrPipeline();
2037      return connection.executeCommand(commandObjects.sscan(key, cursor, params));
2038    }
2039    @Override
2040    public ScanResult&lt;Tuple&gt; zscan(final byte[] key, final byte[] cursor) {
2041      return zscan(key, cursor, new ScanParams());
2042    }
2043    @Override
2044    public ScanResult&lt;Tuple&gt; zscan(final byte[] key, final byte[] cursor, final ScanParams params) {
2045      checkIsInMultiOrPipeline();
2046      return connection.executeCommand(commandObjects.zscan(key, cursor, params));
2047    }
2048    @Override
2049    public long geoadd(final byte[] key, final double longitude, final double latitude,
2050        final byte[] member) {
2051      checkIsInMultiOrPipeline();
2052      return connection.executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2053    }
2054    @Override
2055    public long geoadd(final byte[] key, final Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2056      checkIsInMultiOrPipeline();
2057      return connection.executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2058    }
2059    @Override
2060    public long geoadd(final byte[] key, final GeoAddParams params, final Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2061      checkIsInMultiOrPipeline();
2062      return connection.executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2063    }
2064    @Override
2065    public Double geodist(final byte[] key, final byte[] member1, final byte[] member2) {
2066      checkIsInMultiOrPipeline();
2067      return connection.executeCommand(commandObjects.geodist(key, member1, member2));
2068    }
2069    @Override
2070    public Double geodist(final byte[] key, final byte[] member1, final byte[] member2,
2071        final GeoUnit unit) {
2072      checkIsInMultiOrPipeline();
2073      return connection.executeCommand(commandObjects.geodist(key, member1, member2, unit));
2074    }
2075    @Override
2076    public List&lt;byte[]&gt; geohash(final byte[] key, final byte[]... members) {
2077      checkIsInMultiOrPipeline();
2078      return connection.executeCommand(commandObjects.geohash(key, members));
2079    }
2080    @Override
2081    public List&lt;GeoCoordinate&gt; geopos(final byte[] key, final byte[]... members) {
2082      checkIsInMultiOrPipeline();
2083      return connection.executeCommand(commandObjects.geopos(key, members));
2084    }
2085    @Override
2086    public List&lt;GeoRadiusResponse&gt; georadius(final byte[] key, final double longitude,
2087        final double latitude, final double radius, final GeoUnit unit) {
2088      checkIsInMultiOrPipeline();
2089      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2090    }
2091    @Override
2092    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final byte[] key, final double longitude,
2093        final double latitude, final double radius, final GeoUnit unit) {
2094      checkIsInMultiOrPipeline();
2095      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2096    }
2097    @Override
2098    public List&lt;GeoRadiusResponse&gt; georadius(final byte[] key, final double longitude,
2099        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2100      checkIsInMultiOrPipeline();
2101      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2102    }
2103    @Override
2104    public long georadiusStore(final byte[] key, final double longitude, final double latitude,
2105        final double radius, final GeoUnit unit, final GeoRadiusParam param,
2106        final GeoRadiusStoreParam storeParam) {
2107      checkIsInMultiOrPipeline();
2108      return connection.executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2109    }
2110    @Override
2111    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final byte[] key, final double longitude,
2112        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2113      checkIsInMultiOrPipeline();
2114      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2115    }
2116    @Override
2117    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final byte[] key, final byte[] member,
2118        final double radius, final GeoUnit unit) {
2119      checkIsInMultiOrPipeline();
2120      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2121    }
2122    @Override
2123    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final byte[] key, final byte[] member,
2124        final double radius, final GeoUnit unit) {
2125      checkIsInMultiOrPipeline();
2126      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2127    }
2128    @Override
2129    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final byte[] key, final byte[] member,
2130        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2131      checkIsInMultiOrPipeline();
2132      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2133    }
2134    @Override
2135    public long georadiusByMemberStore(final byte[] key, final byte[] member, final double radius,
2136        final GeoUnit unit, final GeoRadiusParam param, final GeoRadiusStoreParam storeParam) {
2137      checkIsInMultiOrPipeline();
2138      return connection.executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2139    }
2140    @Override
2141    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double radius, GeoUnit unit) {
2142      checkIsInMultiOrPipeline();
2143      return connection.executeCommand(commandObjects.geosearch(key, member, radius, unit));
2144    }
2145    @Override
2146    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double radius, GeoUnit unit) {
2147      checkIsInMultiOrPipeline();
2148      return connection.executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2149    }
2150    @Override
2151    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double width, double height, GeoUnit unit) {
2152      checkIsInMultiOrPipeline();
2153      return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2154    }
2155    @Override
2156    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2157      checkIsInMultiOrPipeline();
2158      return connection.executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2159    }
2160    @Override
2161    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoSearchParam params) {
2162      checkIsInMultiOrPipeline();
2163      return connection.executeCommand(commandObjects.geosearch(key, params));
2164    }
2165    @Override
2166    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double radius, GeoUnit unit) {
2167      checkIsInMultiOrPipeline();
2168      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2169    }
2170    @Override
2171    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double radius, GeoUnit unit) {
2172      checkIsInMultiOrPipeline();
2173      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2174    }
2175    @Override
2176    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double width, double height, GeoUnit unit) {
2177      checkIsInMultiOrPipeline();
2178      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2179    }
2180    @Override
2181    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2182      checkIsInMultiOrPipeline();
2183      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2184    }
2185    @Override
2186    public long geosearchStore(byte[] dest, byte[] src, GeoSearchParam params) {
2187      checkIsInMultiOrPipeline();
2188      return connection.executeCommand(commandObjects.geosearchStore(dest, src, params));
2189    }
2190    @Override
2191    public long geosearchStoreStoreDist(byte[] dest, byte[] src, GeoSearchParam params) {
2192      checkIsInMultiOrPipeline();
2193      return connection.executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2194    }
2195    @Override
2196    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final byte[] key, final byte[] member,
2197        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2198      checkIsInMultiOrPipeline();
2199      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2200    }
2201    @Override
2202    public List&lt;Long&gt; bitfield(final byte[] key, final byte[]... arguments) {
2203      checkIsInMultiOrPipeline();
2204      return connection.executeCommand(commandObjects.bitfield(key, arguments));
2205    }
2206    @Override
2207    public List&lt;Long&gt; bitfieldReadonly(byte[] key, final byte[]... arguments) {
2208      checkIsInMultiOrPipeline();
2209      return connection.executeCommand(commandObjects.bitfieldReadonly(key, arguments));
2210    }
2211    @Override
2212    public long hstrlen(final byte[] key, final byte[] field) {
2213      checkIsInMultiOrPipeline();
2214      return connection.executeCommand(commandObjects.hstrlen(key, field));
2215    }
2216    @Override
2217    public List&lt;byte[]&gt; xread(XReadParams xReadParams, Entry&lt;byte[], byte[]&gt;... streams) {
2218      checkIsInMultiOrPipeline();
2219      return connection.executeCommand(commandObjects.xread(xReadParams, streams));
2220    }
2221    @Override
2222    public List&lt;byte[]&gt; xreadGroup(byte[] groupName, byte[] consumer,
2223        XReadGroupParams xReadGroupParams, Entry&lt;byte[], byte[]&gt;... streams) {
2224      checkIsInMultiOrPipeline();
2225      return connection.executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2226    }
2227    @Override
2228    public byte[] xadd(final byte[] key, final XAddParams params, final Map&lt;byte[], byte[]&gt; hash) {
2229      checkIsInMultiOrPipeline();
2230      return connection.executeCommand(commandObjects.xadd(key, params, hash));
2231    }
2232    @Override
2233    public long xlen(byte[] key) {
2234      checkIsInMultiOrPipeline();
2235      return connection.executeCommand(commandObjects.xlen(key));
2236    }
2237    @Override
2238    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end) {
2239      checkIsInMultiOrPipeline();
2240      return connection.executeCommand(commandObjects.xrange(key, start, end));
2241    }
2242    @Override
2243    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end, int count) {
2244      checkIsInMultiOrPipeline();
2245      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
2246    }
2247    @Override
2248    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start) {
2249      checkIsInMultiOrPipeline();
2250      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
2251    }
2252    @Override
2253    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start, int count) {
2254      checkIsInMultiOrPipeline();
2255      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
2256    }
2257    @Override
2258    public long xack(byte[] key, byte[] group, byte[]... ids) {
2259      checkIsInMultiOrPipeline();
2260      return connection.executeCommand(commandObjects.xack(key, group, ids));
2261    }
2262    @Override
2263    public String xgroupCreate(byte[] key, byte[] consumer, byte[] id, boolean makeStream) {
2264      checkIsInMultiOrPipeline();
2265      return connection.executeCommand(commandObjects.xgroupCreate(key, consumer, id, makeStream));
2266    }
2267    @Override
2268    public String xgroupSetID(byte[] key, byte[] consumer, byte[] id) {
2269      checkIsInMultiOrPipeline();
2270      return connection.executeCommand(commandObjects.xgroupSetID(key, consumer, id));
2271    }
2272    @Override
2273    public long xgroupDestroy(byte[] key, byte[] consumer) {
2274      checkIsInMultiOrPipeline();
2275      return connection.executeCommand(commandObjects.xgroupDestroy(key, consumer));
2276    }
2277    @Override
2278    public boolean xgroupCreateConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2279      checkIsInMultiOrPipeline();
2280      return connection.executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2281    }
2282    @Override
2283    public long xgroupDelConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2284      checkIsInMultiOrPipeline();
2285      return connection.executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2286    }
2287    @Override
2288    public long xdel(byte[] key, byte[]... ids) {
2289      checkIsInMultiOrPipeline();
2290      return connection.executeCommand(commandObjects.xdel(key, ids));
2291    }
2292    @Override
2293    public long xtrim(byte[] key, long maxLen, boolean approximateLength) {
2294      checkIsInMultiOrPipeline();
2295      return connection.executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
2296    }
2297    @Override
2298    public long xtrim(byte[] key, XTrimParams params) {
2299      checkIsInMultiOrPipeline();
2300      return connection.executeCommand(commandObjects.xtrim(key, params));
2301    }
2302    @Override
2303    public Object xpending(final byte[] key, final byte[] groupName) {
2304      checkIsInMultiOrPipeline();
2305      return connection.executeCommand(commandObjects.xpending(key, groupName));
2306    }
2307    @Override
2308    public List&lt;Object&gt; xpending(final byte[] key, final byte[] groupName, final XPendingParams params) {
2309      checkIsInMultiOrPipeline();
2310      return connection.executeCommand(commandObjects.xpending(key, groupName, params));
2311    }
2312    @Override
2313    public List&lt;byte[]&gt; xclaim(byte[] key, byte[] group, byte[] consumerName, long minIdleTime,
2314        XClaimParams params, byte[]... ids) {
2315      checkIsInMultiOrPipeline();
2316      return connection.executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2317    }
2318    @Override
2319    public List&lt;byte[]&gt; xclaimJustId(byte[] key, byte[] group, byte[] consumerName, long minIdleTime,
2320        XClaimParams params, byte[]... ids) {
2321      checkIsInMultiOrPipeline();
2322      return connection.executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2323    }
2324    @Override
2325    public List&lt;Object&gt; xautoclaim(byte[] key, byte[] groupName, byte[] consumerName,
2326        long minIdleTime, byte[] start, XAutoClaimParams params) {
2327      checkIsInMultiOrPipeline();
2328      return connection.executeCommand(commandObjects.xautoclaim(key, groupName, consumerName, minIdleTime, start, params));
2329    }
2330    @Override
2331    public List&lt;Object&gt; xautoclaimJustId(byte[] key, byte[] groupName, byte[] consumerName,
2332        long minIdleTime, byte[] start, XAutoClaimParams params) {
2333      checkIsInMultiOrPipeline();
2334      return connection.executeCommand(commandObjects.xautoclaimJustId(key, groupName, consumerName, minIdleTime, start, params));
2335    }
2336    @Override
2337    public Object xinfoStream(byte[] key) {
2338      checkIsInMultiOrPipeline();
2339      return connection.executeCommand(commandObjects.xinfoStream(key));
2340    }
2341    @Override
2342    public Object xinfoStreamFull(byte[] key) {
2343      checkIsInMultiOrPipeline();
2344      return connection.executeCommand(commandObjects.xinfoStreamFull(key));
2345    }
2346    @Override
2347    public Object xinfoStreamFull(byte[] key, int count) {
2348      checkIsInMultiOrPipeline();
2349      return connection.executeCommand(commandObjects.xinfoStreamFull(key, count));
2350    }
2351    @Override
2352    public List&lt;Object&gt; xinfoGroups(byte[] key) {
2353      checkIsInMultiOrPipeline();
2354      return connection.executeCommand(commandObjects.xinfoGroups(key));
2355    }
2356    @Override
2357    public List&lt;Object&gt; xinfoConsumers(byte[] key, byte[] group) {
2358      checkIsInMultiOrPipeline();
2359      return connection.executeCommand(commandObjects.xinfoConsumers(key, group));
2360    }
2361    public Object sendCommand(ProtocolCommand cmd, byte[]... args) {
2362      checkIsInMultiOrPipeline();
2363      connection.sendCommand(cmd, args);
2364      return connection.getOne();
2365    }
2366    public Object sendBlockingCommand(ProtocolCommand cmd, byte[]... args) {
2367      checkIsInMultiOrPipeline();
2368      connection.sendCommand(cmd, args);
2369      connection.setTimeoutInfinite();
2370      try {
2371        return connection.getOne();
2372      } finally {
2373        connection.rollbackTimeout();
2374      }
2375    }
2376    public Object sendCommand(ProtocolCommand cmd) {
2377      return sendCommand(cmd, DUMMY_ARRAY);
2378    }
2379    @Override
2380    public boolean copy(String srcKey, String dstKey, int db, boolean replace) {
2381      checkIsInMultiOrPipeline();
2382      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, db, replace));
2383    }
2384    @Override
2385    public boolean copy(String srcKey, String dstKey, boolean replace) {
2386      checkIsInMultiOrPipeline();
2387      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, replace));
2388    }
2389    @Override
2390    public String ping(final String message) {
2391      checkIsInMultiOrPipeline();
2392      connection.sendCommand(Command.PING, message);
2393      return connection.getBulkReply();
2394    }
2395    @Override
2396    public String set(final String key, final String value) {
2397      checkIsInMultiOrPipeline();
2398      return connection.executeCommand(commandObjects.set(key, value));
2399    }
2400    @Override
2401    public String set(final String key, final String value, final SetParams params) {
2402      checkIsInMultiOrPipeline();
2403      return connection.executeCommand(commandObjects.set(key, value, params));
2404    }
2405    @Override
2406    public String get(final String key) {
2407      checkIsInMultiOrPipeline();
2408      return connection.executeCommand(commandObjects.get(key));
2409    }
2410    @Override
2411    public String setGet(final String key, final String value) {
2412      checkIsInMultiOrPipeline();
2413      return connection.executeCommand(commandObjects.setGet(key, value));
2414    }
2415    @Override
2416    public String setGet(final String key, final String value, final SetParams params) {
2417      checkIsInMultiOrPipeline();
2418      return connection.executeCommand(commandObjects.setGet(key, value, params));
2419    }
2420    @Override
2421    public String getDel(final String key) {
2422      checkIsInMultiOrPipeline();
2423      return connection.executeCommand(commandObjects.getDel(key));
2424    }
2425    @Override
2426    public String getEx(String key, GetExParams params) {
2427      checkIsInMultiOrPipeline();
2428      return connection.executeCommand(commandObjects.getEx(key, params));
2429    }
2430    @Override
2431    public long exists(final String... keys) {
2432      checkIsInMultiOrPipeline();
2433      return connection.executeCommand(commandObjects.exists(keys));
2434    }
2435    @Override
2436    public boolean exists(final String key) {
2437      checkIsInMultiOrPipeline();
2438      return connection.executeCommand(commandObjects.exists(key));
2439    }
2440    @Override
2441    public long del(final String... keys) {
2442      checkIsInMultiOrPipeline();
2443      return connection.executeCommand(commandObjects.del(keys));
2444    }
2445    @Override
2446    public long del(final String key) {
2447      checkIsInMultiOrPipeline();
2448      return connection.executeCommand(commandObjects.del(key));
2449    }
2450    @Override
2451    public long unlink(final String... keys) {
2452      checkIsInMultiOrPipeline();
2453      return connection.executeCommand(commandObjects.unlink(keys));
2454    }
2455    @Override
2456    public long unlink(final String key) {
2457      checkIsInMultiOrPipeline();
2458      return connection.executeCommand(commandObjects.unlink(key));
2459    }
2460    @Override
2461    public String type(final String key) {
2462      checkIsInMultiOrPipeline();
2463      return connection.executeCommand(commandObjects.type(key));
2464    }
2465    @Override
2466    public Set&lt;String&gt; keys(final String pattern) {
2467      checkIsInMultiOrPipeline();
2468      return connection.executeCommand(commandObjects.keys(pattern));
2469    }
2470    @Override
2471    public String randomKey() {
2472      checkIsInMultiOrPipeline();
2473      return connection.executeCommand(commandObjects.randomKey());
2474    }
2475    @Override
2476    public String rename(final String oldkey, final String newkey) {
2477      checkIsInMultiOrPipeline();
2478      return connection.executeCommand(commandObjects.rename(oldkey, newkey));
2479    }
2480    @Override
2481    public long renamenx(final String oldkey, final String newkey) {
2482      checkIsInMultiOrPipeline();
2483      return connection.executeCommand(commandObjects.renamenx(oldkey, newkey));
2484    }
2485    @Override
2486    public long expire(final String key, final long seconds) {
2487      checkIsInMultiOrPipeline();
2488      return connection.executeCommand(commandObjects.expire(key, seconds));
2489    }
2490    @Override
2491    public long expire(final String key, final long seconds, final ExpiryOption expiryOption) {
2492      checkIsInMultiOrPipeline();
2493      return connection.executeCommand(commandObjects.expire(key, seconds, expiryOption));
2494    }
2495    @Override
2496    public long pexpire(final String key, final long milliseconds) {
2497      checkIsInMultiOrPipeline();
2498      return connection.executeCommand(commandObjects.pexpire(key, milliseconds));
2499    }
2500    @Override
2501    public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {
2502      checkIsInMultiOrPipeline();
2503      return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
2504    }
2505    @Override
2506    public long expireTime(final String key) {
2507      checkIsInMultiOrPipeline();
2508      return connection.executeCommand(commandObjects.expireTime(key));
2509    }
2510    @Override
2511    public long pexpireTime(final String key) {
2512      checkIsInMultiOrPipeline();
2513      return connection.executeCommand(commandObjects.pexpireTime(key));
2514    }
2515    @Override
2516    public long expireAt(final String key, final long unixTime) {
2517      checkIsInMultiOrPipeline();
2518      return connection.executeCommand(commandObjects.expireAt(key, unixTime));
2519    }
2520    @Override
2521    public long expireAt(String key, long unixTime, ExpiryOption expiryOption) {
2522      checkIsInMultiOrPipeline();
2523      return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
2524    }
2525    @Override
2526    public long pexpireAt(final String key, final long millisecondsTimestamp) {
2527      checkIsInMultiOrPipeline();
2528      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
2529    }
2530    @Override
2531    public long pexpireAt(String key, long millisecondsTimestamp, ExpiryOption expiryOption) {
2532      checkIsInMultiOrPipeline();
2533      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
2534    }
2535    @Override
2536    public long ttl(final String key) {
2537      checkIsInMultiOrPipeline();
2538      return connection.executeCommand(commandObjects.ttl(key));
2539    }
2540    @Override
2541    public long touch(final String... keys) {
2542      checkIsInMultiOrPipeline();
2543      return connection.executeCommand(commandObjects.touch(keys));
2544    }
2545    @Override
2546    public long touch(final String key) {
2547      checkIsInMultiOrPipeline();
2548      return connection.executeCommand(commandObjects.touch(key));
2549    }
2550    @Override
2551    public long move(final String key, final int dbIndex) {
2552      checkIsInMultiOrPipeline();
2553      connection.sendCommand(MOVE, encode(key), toByteArray(dbIndex));
2554      return connection.getIntegerReply();
2555    }
2556    @Override
2557    public String getSet(final String key, final String value) {
2558      checkIsInMultiOrPipeline();
2559      return connection.executeCommand(commandObjects.getSet(key, value));
2560    }
2561    @Override
2562    public List&lt;String&gt; mget(final String... keys) {
2563      checkIsInMultiOrPipeline();
2564      return connection.executeCommand(commandObjects.mget(keys));
2565    }
2566    @Override
2567    public long setnx(final String key, final String value) {
2568      checkIsInMultiOrPipeline();
2569      return connection.executeCommand(commandObjects.setnx(key, value));
2570    }
2571    @Override
2572    public String setex(final String key, final long seconds, final String value) {
2573      checkIsInMultiOrPipeline();
2574      return connection.executeCommand(commandObjects.setex(key, seconds, value));
2575    }
2576    @Override
2577    public String mset(final String... keysvalues) {
2578      checkIsInMultiOrPipeline();
2579      return connection.executeCommand(commandObjects.mset(keysvalues));
2580    }
2581    @Override
2582    public long msetnx(final String... keysvalues) {
2583      checkIsInMultiOrPipeline();
2584      return connection.executeCommand(commandObjects.msetnx(keysvalues));
2585    }
2586    @Override
2587    public long decrBy(final String key, final long decrement) {
2588      checkIsInMultiOrPipeline();
2589      return connection.executeCommand(commandObjects.decrBy(key, decrement));
2590    }
2591    @Override
2592    public long decr(final String key) {
2593      checkIsInMultiOrPipeline();
2594      return connection.executeCommand(commandObjects.decr(key));
2595    }
2596    @Override
2597    public long incrBy(final String key, final long increment) {
2598      checkIsInMultiOrPipeline();
2599      return connection.executeCommand(commandObjects.incrBy(key, increment));
2600    }
2601    @Override
2602    public double incrByFloat(final String key, final double increment) {
2603      checkIsInMultiOrPipeline();
2604      return connection.executeCommand(commandObjects.incrByFloat(key, increment));
2605    }
2606    @Override
2607    public long incr(final String key) {
2608      checkIsInMultiOrPipeline();
2609      return connection.executeCommand(commandObjects.incr(key));
2610    }
2611    @Override
2612    public long append(final String key, final String value) {
2613      checkIsInMultiOrPipeline();
2614      return connection.executeCommand(commandObjects.append(key, value));
2615    }
2616    @Override
2617    public String substr(final String key, final int start, final int end) {
2618      checkIsInMultiOrPipeline();
2619      return connection.executeCommand(commandObjects.substr(key, start, end));
2620    }
2621    @Override
2622    public long hset(final String key, final String field, final String value) {
2623      checkIsInMultiOrPipeline();
2624      return connection.executeCommand(commandObjects.hset(key, field, value));
2625    }
2626    @Override
2627    public long hset(final String key, final Map&lt;String, String&gt; hash) {
2628      checkIsInMultiOrPipeline();
2629      return connection.executeCommand(commandObjects.hset(key, hash));
2630    }
2631    @Override
2632    public String hget(final String key, final String field) {
2633      checkIsInMultiOrPipeline();
2634      return connection.executeCommand(commandObjects.hget(key, field));
2635    }
2636    @Override
2637    public long hsetnx(final String key, final String field, final String value) {
2638      checkIsInMultiOrPipeline();
2639      return connection.executeCommand(commandObjects.hsetnx(key, field, value));
2640    }
2641    @Override
2642    public String hmset(final String key, final Map&lt;String, String&gt; hash) {
2643      checkIsInMultiOrPipeline();
2644      return connection.executeCommand(commandObjects.hmset(key, hash));
2645    }
2646    @Override
2647    public List&lt;String&gt; hmget(final String key, final String... fields) {
2648      checkIsInMultiOrPipeline();
2649      return connection.executeCommand(commandObjects.hmget(key, fields));
2650    }
2651    @Override
2652    public long hincrBy(final String key, final String field, final long value) {
2653      checkIsInMultiOrPipeline();
2654      return connection.executeCommand(commandObjects.hincrBy(key, field, value));
2655    }
2656    @Override
2657    public double hincrByFloat(final String key, final String field, final double value) {
2658      checkIsInMultiOrPipeline();
2659      return connection.executeCommand(commandObjects.hincrByFloat(key, field, value));
2660    }
2661    @Override
2662    public boolean hexists(final String key, final String field) {
2663      checkIsInMultiOrPipeline();
2664      return connection.executeCommand(commandObjects.hexists(key, field));
2665    }
2666    @Override
2667    public long hdel(final String key, final String... fields) {
2668      checkIsInMultiOrPipeline();
2669      return connection.executeCommand(commandObjects.hdel(key, fields));
2670    }
2671    @Override
2672    public long hlen(final String key) {
2673      checkIsInMultiOrPipeline();
2674      return connection.executeCommand(commandObjects.hlen(key));
2675    }
2676    @Override
2677    public Set&lt;String&gt; hkeys(final String key) {
2678      checkIsInMultiOrPipeline();
2679      return connection.executeCommand(commandObjects.hkeys(key));
2680    }
2681    @Override
2682    public List&lt;String&gt; hvals(final String key) {
2683      checkIsInMultiOrPipeline();
2684      return connection.executeCommand(commandObjects.hvals(key));
2685    }
2686    @Override
2687    public Map&lt;String, String&gt; hgetAll(final String key) {
2688      checkIsInMultiOrPipeline();
2689      return connection.executeCommand(commandObjects.hgetAll(key));
2690    }
2691    @Override
2692    public String hrandfield(final String key) {
2693      checkIsInMultiOrPipeline();
2694      return connection.executeCommand(commandObjects.hrandfield(key));
2695    }
2696    @Override
2697    public List&lt;String&gt; hrandfield(final String key, final long count) {
2698      checkIsInMultiOrPipeline();
2699      return connection.executeCommand(commandObjects.hrandfield(key, count));
2700    }
2701    @Override
2702    public List&lt;Map.Entry&lt;String, String&gt;&gt; hrandfieldWithValues(final String key, final long count) {
2703      checkIsInMultiOrPipeline();
2704      return connection.executeCommand(commandObjects.hrandfieldWithValues(key, count));
2705    }
2706    @Override
2707    public long rpush(final String key, final String... strings) {
2708      checkIsInMultiOrPipeline();
2709      return connection.executeCommand(commandObjects.rpush(key, strings));
2710    }
2711    @Override
2712    public long lpush(final String key, final String... strings) {
2713      checkIsInMultiOrPipeline();
2714      return connection.executeCommand(commandObjects.lpush(key, strings));
2715    }
2716    @Override
2717    public long llen(final String key) {
2718      checkIsInMultiOrPipeline();
2719      return connection.executeCommand(commandObjects.llen(key));
2720    }
2721    @Override
2722    public List&lt;String&gt; lrange(final String key, final long start, final long stop) {
2723      checkIsInMultiOrPipeline();
2724      return connection.executeCommand(commandObjects.lrange(key, start, stop));
2725    }
2726    @Override
2727    public String ltrim(final String key, final long start, final long stop) {
2728      checkIsInMultiOrPipeline();
2729      return connection.executeCommand(commandObjects.ltrim(key, start, stop));
2730    }
2731    @Override
2732    public String lindex(final String key, final long index) {
2733      checkIsInMultiOrPipeline();
2734      return connection.executeCommand(commandObjects.lindex(key, index));
2735    }
2736    @Override
2737    public String lset(final String key, final long index, final String value) {
2738      checkIsInMultiOrPipeline();
2739      return connection.executeCommand(commandObjects.lset(key, index, value));
2740    }
2741    @Override
2742    public long lrem(final String key, final long count, final String value) {
2743      checkIsInMultiOrPipeline();
2744      return connection.executeCommand(commandObjects.lrem(key, count, value));
2745    }
2746    @Override
2747    public String lpop(final String key) {
2748      checkIsInMultiOrPipeline();
2749      return connection.executeCommand(commandObjects.lpop(key));
2750    }
2751    @Override
2752    public List&lt;String&gt; lpop(final String key, final int count) {
2753      checkIsInMultiOrPipeline();
2754      return connection.executeCommand(commandObjects.lpop(key, count));
2755    }
2756    @Override
2757    public Long lpos(final String key, final String element) {
2758      checkIsInMultiOrPipeline();
2759      return connection.executeCommand(commandObjects.lpos(key, element));
2760    }
2761    @Override
2762    public Long lpos(final String key, final String element, final LPosParams params) {
2763      checkIsInMultiOrPipeline();
2764      return connection.executeCommand(commandObjects.lpos(key, element, params));
2765    }
2766    @Override
2767    public List&lt;Long&gt; lpos(final String key, final String element, final LPosParams params,
2768        final long count) {
2769      checkIsInMultiOrPipeline();
2770      return connection.executeCommand(commandObjects.lpos(key, element, params, count));
2771    }
2772    @Override
2773    public String rpop(final String key) {
2774      checkIsInMultiOrPipeline();
2775      return connection.executeCommand(commandObjects.rpop(key));
2776    }
2777    @Override
2778    public List&lt;String&gt; rpop(final String key, final int count) {
2779      checkIsInMultiOrPipeline();
2780      return connection.executeCommand(commandObjects.rpop(key, count));
2781    }
2782    @Override
2783    public String rpoplpush(final String srckey, final String dstkey) {
2784      checkIsInMultiOrPipeline();
2785      return connection.executeCommand(commandObjects.rpoplpush(srckey, dstkey));
2786    }
2787    @Override
2788    public long sadd(final String key, final String... members) {
2789      checkIsInMultiOrPipeline();
2790      return connection.executeCommand(commandObjects.sadd(key, members));
2791    }
2792    @Override
2793    public Set&lt;String&gt; smembers(final String key) {
2794      checkIsInMultiOrPipeline();
2795      return connection.executeCommand(commandObjects.smembers(key));
2796    }
2797    @Override
2798    public long srem(final String key, final String... members) {
2799      checkIsInMultiOrPipeline();
2800      return connection.executeCommand(commandObjects.srem(key, members));
2801    }
2802    @Override
2803    public String spop(final String key) {
2804      checkIsInMultiOrPipeline();
2805      return connection.executeCommand(commandObjects.spop(key));
2806    }
2807    @Override
2808    public Set&lt;String&gt; spop(final String key, final long count) {
2809      checkIsInMultiOrPipeline();
2810      return connection.executeCommand(commandObjects.spop(key, count));
2811    }
2812    @Override
2813    public long smove(final String srckey, final String dstkey, final String member) {
2814      checkIsInMultiOrPipeline();
2815      return connection.executeCommand(commandObjects.smove(srckey, dstkey, member));
2816    }
2817    @Override
2818    public long scard(final String key) {
2819      checkIsInMultiOrPipeline();
2820      return connection.executeCommand(commandObjects.scard(key));
2821    }
2822    @Override
2823    public boolean sismember(final String key, final String member) {
2824      checkIsInMultiOrPipeline();
2825      return connection.executeCommand(commandObjects.sismember(key, member));
2826    }
2827    @Override
2828    public List&lt;Boolean&gt; smismember(final String key, final String... members) {
2829      checkIsInMultiOrPipeline();
2830      return connection.executeCommand(commandObjects.smismember(key, members));
2831    }
2832    @Override
2833    public Set&lt;String&gt; sinter(final String... keys) {
2834      checkIsInMultiOrPipeline();
2835      return connection.executeCommand(commandObjects.sinter(keys));
2836    }
2837    @Override
2838    public long sinterstore(final String dstkey, final String... keys) {
2839      checkIsInMultiOrPipeline();
2840      return connection.executeCommand(commandObjects.sinterstore(dstkey, keys));
2841    }
2842    @Override
2843    public long sintercard(String... keys) {
2844      checkIsInMultiOrPipeline();
2845      return connection.executeCommand(commandObjects.sintercard(keys));
2846    }
2847    @Override
2848    public long sintercard(int limit, String... keys) {
2849      checkIsInMultiOrPipeline();
2850      return connection.executeCommand(commandObjects.sintercard(limit, keys));
2851    }
2852    @Override
2853    public Set&lt;String&gt; sunion(final String... keys) {
2854      checkIsInMultiOrPipeline();
2855      return connection.executeCommand(commandObjects.sunion(keys));
2856    }
2857    @Override
2858    public long sunionstore(final String dstkey, final String... keys) {
2859      checkIsInMultiOrPipeline();
2860      return connection.executeCommand(commandObjects.sunionstore(dstkey, keys));
2861    }
2862    @Override
2863    public Set&lt;String&gt; sdiff(final String... keys) {
2864      checkIsInMultiOrPipeline();
2865      return connection.executeCommand(commandObjects.sdiff(keys));
2866    }
2867    @Override
2868    public long sdiffstore(final String dstkey, final String... keys) {
2869      checkIsInMultiOrPipeline();
2870      return connection.executeCommand(commandObjects.sdiffstore(dstkey, keys));
2871    }
2872    @Override
2873    public String srandmember(final String key) {
2874      checkIsInMultiOrPipeline();
2875      return connection.executeCommand(commandObjects.srandmember(key));
2876    }
2877    @Override
2878    public List&lt;String&gt; srandmember(final String key, final int count) {
2879      checkIsInMultiOrPipeline();
2880      return connection.executeCommand(commandObjects.srandmember(key, count));
2881    }
2882    @Override
2883    public long zadd(final String key, final double score, final String member) {
2884      checkIsInMultiOrPipeline();
2885      return connection.executeCommand(commandObjects.zadd(key, score, member));
2886    }
2887    @Override
2888    public long zadd(final String key, final double score, final String member,
2889        final ZAddParams params) {
2890      checkIsInMultiOrPipeline();
2891      return connection.executeCommand(commandObjects.zadd(key, score, member, params));
2892    }
2893    @Override
2894    public long zadd(final String key, final Map&lt;String, Double&gt; scoreMembers) {
2895      checkIsInMultiOrPipeline();
2896      return connection.executeCommand(commandObjects.zadd(key, scoreMembers));
2897    }
2898    @Override
2899    public long zadd(final String key, final Map&lt;String, Double&gt; scoreMembers, final ZAddParams params) {
2900      checkIsInMultiOrPipeline();
2901      return connection.executeCommand(commandObjects.zadd(key, scoreMembers, params));
2902    }
2903    @Override
2904    public Double zaddIncr(final String key, final double score, final String member, final ZAddParams params) {
2905      checkIsInMultiOrPipeline();
2906      return connection.executeCommand(commandObjects.zaddIncr(key, score, member, params));
2907    }
2908    @Override
2909    public List&lt;String&gt; zdiff(String... keys) {
2910      checkIsInMultiOrPipeline();
2911      return connection.executeCommand(commandObjects.zdiff(keys));
2912    }
2913    @Override
2914    public List&lt;Tuple&gt; zdiffWithScores(String... keys) {
2915      checkIsInMultiOrPipeline();
2916      return connection.executeCommand(commandObjects.zdiffWithScores(keys));
2917    }
2918    @Override
2919    @Deprecated
2920    public long zdiffStore(final String dstkey, final String... keys) {
2921      checkIsInMultiOrPipeline();
2922      return connection.executeCommand(commandObjects.zdiffStore(dstkey, keys));
2923    }
2924    @Override
2925    public long zdiffstore(final String dstkey, final String... keys) {
2926      checkIsInMultiOrPipeline();
2927      return connection.executeCommand(commandObjects.zdiffstore(dstkey, keys));
2928    }
2929    @Override
2930    public List&lt;String&gt; zrange(final String key, final long start, final long stop) {
2931      checkIsInMultiOrPipeline();
2932      return connection.executeCommand(commandObjects.zrange(key, start, stop));
2933    }
2934    @Override
2935    public long zrem(final String key, final String... members) {
2936      checkIsInMultiOrPipeline();
2937      return connection.executeCommand(commandObjects.zrem(key, members));
2938    }
2939    @Override
2940    public double zincrby(final String key, final double increment, final String member) {
2941      checkIsInMultiOrPipeline();
2942      return connection.executeCommand(commandObjects.zincrby(key, increment, member));
2943    }
2944    @Override
2945    public Double zincrby(final String key, final double increment, final String member,
2946        final ZIncrByParams params) {
2947      checkIsInMultiOrPipeline();
2948      return connection.executeCommand(commandObjects.zincrby(key, increment, member, params));
2949    }
2950    @Override
2951    public Long zrank(final String key, final String member) {
2952      checkIsInMultiOrPipeline();
2953      return connection.executeCommand(commandObjects.zrank(key, member));
2954    }
2955    @Override
2956    public Long zrevrank(final String key, final String member) {
2957      checkIsInMultiOrPipeline();
2958      return connection.executeCommand(commandObjects.zrevrank(key, member));
2959    }
2960    @Override
2961    public KeyValue&lt;Long, Double&gt; zrankWithScore(String key, String member) {
2962      checkIsInMultiOrPipeline();
2963      return connection.executeCommand(commandObjects.zrankWithScore(key, member));
2964    }
2965    @Override
2966    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(String key, String member) {
2967      checkIsInMultiOrPipeline();
2968      return connection.executeCommand(commandObjects.zrevrankWithScore(key, member));
2969    }
2970    @Override
2971    public List&lt;String&gt; zrevrange(final String key, final long start, final long stop) {
2972      checkIsInMultiOrPipeline();
2973      return connection.executeCommand(commandObjects.zrevrange(key, start, stop));
2974    }
2975    @Override
2976    public List&lt;Tuple&gt; zrangeWithScores(final String key, final long start, final long stop) {
2977      checkIsInMultiOrPipeline();
2978      return connection.executeCommand(commandObjects.zrangeWithScores(key, start, stop));
2979    }
2980    @Override
2981    public List&lt;Tuple&gt; zrevrangeWithScores(final String key, final long start, final long stop) {
2982      checkIsInMultiOrPipeline();
2983      return connection.executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
2984    }
2985    @Override
2986    public List&lt;String&gt; zrange(String key, ZRangeParams zRangeParams) {
2987      checkIsInMultiOrPipeline();
2988      return connection.executeCommand(commandObjects.zrange(key, zRangeParams));
2989    }
2990    @Override
2991    public List&lt;Tuple&gt; zrangeWithScores(String key, ZRangeParams zRangeParams) {
2992      checkIsInMultiOrPipeline();
2993      return connection.executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
2994    }
2995    @Override
2996    public long zrangestore(String dest, String src, ZRangeParams zRangeParams) {
2997      checkIsInMultiOrPipeline();
2998      return connection.executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
2999    }
3000    @Override
3001    public String zrandmember(final String key) {
3002      checkIsInMultiOrPipeline();
3003      return connection.executeCommand(commandObjects.zrandmember(key));
3004    }
3005    @Override
3006    public List&lt;String&gt; zrandmember(final String key, final long count) {
3007      checkIsInMultiOrPipeline();
3008      return connection.executeCommand(commandObjects.zrandmember(key, count));
3009    }
3010    @Override
3011    public List&lt;Tuple&gt; zrandmemberWithScores(final String key, final long count) {
3012      checkIsInMultiOrPipeline();
3013      return connection.executeCommand(commandObjects.zrandmemberWithScores(key, count));
3014    }
3015    @Override
3016    public long zcard(final String key) {
3017      checkIsInMultiOrPipeline();
3018      return connection.executeCommand(commandObjects.zcard(key));
3019    }
3020    @Override
3021    public Double zscore(final String key, final String member) {
3022      checkIsInMultiOrPipeline();
3023      return connection.executeCommand(commandObjects.zscore(key, member));
3024    }
3025    @Override
3026    public List&lt;Double&gt; zmscore(final String key, final String... members) {
3027      checkIsInMultiOrPipeline();
3028      return connection.executeCommand(commandObjects.zmscore(key, members));
3029    }
3030    @Override
3031    public Tuple zpopmax(final String key) {
3032      checkIsInMultiOrPipeline();
3033      return connection.executeCommand(commandObjects.zpopmax(key));
3034    }
3035    @Override
3036    public List&lt;Tuple&gt; zpopmax(final String key, final int count) {
3037      checkIsInMultiOrPipeline();
3038      return connection.executeCommand(commandObjects.zpopmax(key, count));
3039    }
3040    @Override
3041    public Tuple zpopmin(final String key) {
3042      checkIsInMultiOrPipeline();
3043      return connection.executeCommand(commandObjects.zpopmin(key));
3044    }
3045    @Override
3046    public List&lt;Tuple&gt; zpopmin(final String key, final int count) {
3047      checkIsInMultiOrPipeline();
3048      return connection.executeCommand(commandObjects.zpopmin(key, count));
3049    }
3050    public String watch(final String... keys) {
3051      checkIsInMultiOrPipeline();
3052      connection.sendCommand(WATCH, keys);
3053      String status = connection.getStatusCodeReply();
3054      isInWatch = true;
3055      return status;
3056    }
3057    @Override
3058    public List&lt;String&gt; sort(final String key) {
3059      checkIsInMultiOrPipeline();
3060      return connection.executeCommand(commandObjects.sort(key));
3061    }
3062    @Override
3063    public List&lt;String&gt; sort(final String key, final SortingParams sortingParams) {
3064      checkIsInMultiOrPipeline();
3065      return connection.executeCommand(commandObjects.sort(key, sortingParams));
3066    }
3067    @Override
3068    public long sort(final String key, final SortingParams sortingParams, final String dstkey) {
3069      checkIsInMultiOrPipeline();
3070      return connection.executeCommand(commandObjects.sort(key, sortingParams, dstkey));
3071    }
3072    @Override
3073    public List&lt;String&gt; sortReadonly(String key, SortingParams sortingParams) {
3074      checkIsInMultiOrPipeline();
3075      return connection.executeCommand(commandObjects.sortReadonly(key, sortingParams));
3076    }
3077    @Override
3078    public long sort(final String key, final String dstkey) {
3079      checkIsInMultiOrPipeline();
3080      return connection.executeCommand(commandObjects.sort(key, dstkey));
3081    }
3082    @Override
3083    public String lmove(final String srcKey, final String dstKey, final ListDirection from,
3084        final ListDirection to) {
3085      checkIsInMultiOrPipeline();
3086      return connection.executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
3087    }
3088    @Override
3089    public String blmove(final String srcKey, final String dstKey, final ListDirection from,
3090        final ListDirection to, final double timeout) {
3091      checkIsInMultiOrPipeline();
3092      return connection.executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
3093    }
3094    @Override
3095    public List&lt;String&gt; blpop(final int timeout, final String... keys) {
3096      checkIsInMultiOrPipeline();
3097      return connection.executeCommand(commandObjects.blpop(timeout, keys));
3098    }
3099    @Override
3100    public KeyValue&lt;String, String&gt; blpop(final double timeout, final String... keys) {
3101      checkIsInMultiOrPipeline();
3102      return connection.executeCommand(commandObjects.blpop(timeout, keys));
3103    }
3104    @Override
3105    public List&lt;String&gt; brpop(final int timeout, final String... keys) {
3106      checkIsInMultiOrPipeline();
3107      return connection.executeCommand(commandObjects.brpop(timeout, keys));
3108    }
3109    @Override
3110    public KeyValue&lt;String, String&gt; brpop(final double timeout, final String... keys) {
3111      checkIsInMultiOrPipeline();
3112      return connection.executeCommand(commandObjects.brpop(timeout, keys));
3113    }
3114    @Override
3115    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, String... keys) {
3116      checkIsInMultiOrPipeline();
3117      return connection.executeCommand(commandObjects.lmpop(direction, keys));
3118    }
3119    @Override
3120    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, int count, String... keys) {
3121      checkIsInMultiOrPipeline();
3122      return connection.executeCommand(commandObjects.lmpop(direction, count, keys));
3123    }
3124    @Override
3125    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, String... keys) {
3126      checkIsInMultiOrPipeline();
3127      return connection.executeCommand(commandObjects.blmpop(timeout, direction, keys));
3128    }
3129    @Override
3130    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, int count, String... keys) {
3131      checkIsInMultiOrPipeline();
3132      return connection.executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
3133    }
3134    @Override
3135    public KeyValue&lt;String, Tuple&gt; bzpopmax(double timeout, String... keys) {
3136      checkIsInMultiOrPipeline();
3137      return connection.executeCommand(commandObjects.bzpopmax(timeout, keys));
3138    }
3139    @Override
3140    public KeyValue&lt;String, Tuple&gt; bzpopmin(double timeout, String... keys) {
3141      checkIsInMultiOrPipeline();
3142      return connection.executeCommand(commandObjects.bzpopmin(timeout, keys));
3143    }
3144    @Override
3145    public List&lt;String&gt; blpop(final int timeout, final String key) {
3146      checkIsInMultiOrPipeline();
3147      return connection.executeCommand(commandObjects.blpop(timeout, key));
3148    }
3149    @Override
3150    public KeyValue&lt;String, String&gt; blpop(double timeout, String key) {
3151      checkIsInMultiOrPipeline();
3152      return connection.executeCommand(commandObjects.blpop(timeout, key));
3153    }
3154    @Override
3155    public List&lt;String&gt; brpop(final int timeout, final String key) {
3156      checkIsInMultiOrPipeline();
3157      return connection.executeCommand(commandObjects.brpop(timeout, key));
3158    }
3159    @Override
3160    public KeyValue&lt;String, String&gt; brpop(double timeout, String key) {
3161      checkIsInMultiOrPipeline();
3162      return connection.executeCommand(commandObjects.brpop(timeout, key));
3163    }
3164    @Override
3165    public long zcount(final String key, final double min, final double max) {
3166      checkIsInMultiOrPipeline();
3167      return connection.executeCommand(commandObjects.zcount(key, min, max));
3168    }
3169    @Override
3170    public long zcount(final String key, final String min, final String max) {
3171      checkIsInMultiOrPipeline();
3172      return connection.executeCommand(commandObjects.zcount(key, min, max));
3173    }
3174    @Override
3175    public List&lt;String&gt; zrangeByScore(final String key, final double min, final double max) {
3176      checkIsInMultiOrPipeline();
3177      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
3178    }
3179    @Override
3180    public List&lt;String&gt; zrangeByScore(final String key, final String min, final String max) {
3181      checkIsInMultiOrPipeline();
3182      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
3183    }
3184    @Override
3185    public List&lt;String&gt; zrangeByScore(final String key, final double min, final double max,
3186        final int offset, final int count) {
3187      checkIsInMultiOrPipeline();
3188      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
3189    }
3190    @Override
3191    public List&lt;String&gt; zrangeByScore(final String key, final String min, final String max,
3192        final int offset, final int count) {
3193      checkIsInMultiOrPipeline();
3194      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
3195    }
3196    @Override
3197    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final double min, final double max) {
3198      checkIsInMultiOrPipeline();
3199      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
3200    }
3201    @Override
3202    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final String min, final String max) {
3203      checkIsInMultiOrPipeline();
3204      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
3205    }
3206    @Override
3207    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final double min, final double max,
3208        final int offset, final int count) {
3209      checkIsInMultiOrPipeline();
3210      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
3211    }
3212    @Override
3213    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final String min, final String max,
3214        final int offset, final int count) {
3215      checkIsInMultiOrPipeline();
3216      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
3217    }
3218    @Override
3219    public List&lt;String&gt; zrevrangeByScore(final String key, final double max, final double min) {
3220      checkIsInMultiOrPipeline();
3221      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
3222    }
3223    @Override
3224    public List&lt;String&gt; zrevrangeByScore(final String key, final String max, final String min) {
3225      checkIsInMultiOrPipeline();
3226      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
3227    }
3228    @Override
3229    public List&lt;String&gt; zrevrangeByScore(final String key, final double max, final double min,
3230        final int offset, final int count) {
3231      checkIsInMultiOrPipeline();
3232      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
3233    }
3234    @Override
3235    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final double max, final double min) {
3236      checkIsInMultiOrPipeline();
3237      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
3238    }
3239    @Override
3240    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final double max,
3241        final double min, final int offset, final int count) {
3242      checkIsInMultiOrPipeline();
3243      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
3244    }
3245    @Override
3246    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final String max,
3247        final String min, final int offset, final int count) {
3248      checkIsInMultiOrPipeline();
3249      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
3250    }
3251    @Override
3252    public List&lt;String&gt; zrevrangeByScore(final String key, final String max, final String min,
3253        final int offset, final int count) {
3254      checkIsInMultiOrPipeline();
3255      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
3256    }
3257    @Override
3258    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final String max, final String min) {
3259      checkIsInMultiOrPipeline();
3260      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
3261    }
3262    @Override
3263    public long zremrangeByRank(final String key, final long start, final long stop) {
3264      checkIsInMultiOrPipeline();
3265      return connection.executeCommand(commandObjects.zremrangeByRank(key, start, stop));
3266    }
3267    @Override
3268    public long zremrangeByScore(final String key, final double min, final double max) {
3269      checkIsInMultiOrPipeline();
3270      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
3271    }
3272    @Override
3273    public long zremrangeByScore(final String key, final String min, final String max) {
3274      checkIsInMultiOrPipeline();
3275      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
3276    }
3277    @Override
3278    public List&lt;String&gt; zunion(ZParams params, String... keys) {
3279      checkIsInMultiOrPipeline();
3280      return connection.executeCommand(commandObjects.zunion(params, keys));
3281    }
3282    @Override
3283    public List&lt;Tuple&gt; zunionWithScores(ZParams params, String... keys) {
3284      checkIsInMultiOrPipeline();
3285      return connection.executeCommand(commandObjects.zunionWithScores(params, keys));
3286    }
3287    @Override
3288    public long zunionstore(final String dstkey, final String... sets) {
3289      checkIsInMultiOrPipeline();
3290      return connection.executeCommand(commandObjects.zunionstore(dstkey, sets));
3291    }
3292    @Override
3293    public long zunionstore(final String dstkey, final ZParams params, final String... sets) {
3294      checkIsInMultiOrPipeline();
3295      return connection.executeCommand(commandObjects.zunionstore(dstkey, params, sets));
3296    }
3297    @Override
3298    public List&lt;String&gt; zinter(final ZParams params, final String... keys) {
3299      checkIsInMultiOrPipeline();
3300      return connection.executeCommand(commandObjects.zinter(params, keys));
3301    }
3302    @Override
3303    public List&lt;Tuple&gt; zinterWithScores(final ZParams params, final String... keys) {
3304      checkIsInMultiOrPipeline();
3305      return connection.executeCommand(commandObjects.zinterWithScores(params, keys));
3306    }
3307    @Override
3308    public long zintercard(String... keys) {
3309      checkIsInMultiOrPipeline();
3310      return connection.executeCommand(commandObjects.zintercard(keys));
3311    }
3312    @Override
3313    public long zintercard(long limit, String... keys) {
3314      checkIsInMultiOrPipeline();
3315      return connection.executeCommand(commandObjects.zintercard(limit, keys));
3316    }
3317    @Override
3318    public long zinterstore(final String dstkey, final String... sets) {
3319      checkIsInMultiOrPipeline();
3320      return connection.executeCommand(commandObjects.zinterstore(dstkey, sets));
3321    }
3322    @Override
3323    public long zinterstore(final String dstkey, final ZParams params, final String... sets) {
3324      checkIsInMultiOrPipeline();
3325      return connection.executeCommand(commandObjects.zinterstore(dstkey, params, sets));
3326    }
3327    @Override
3328    public long zlexcount(final String key, final String min, final String max) {
3329      checkIsInMultiOrPipeline();
3330      return connection.executeCommand(commandObjects.zlexcount(key, min, max));
3331    }
3332    @Override
3333    public List&lt;String&gt; zrangeByLex(final String key, final String min, final String max) {
3334      checkIsInMultiOrPipeline();
3335      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max));
3336    }
3337    @Override
3338    public List&lt;String&gt; zrangeByLex(final String key, final String min, final String max,
3339        final int offset, final int count) {
3340      checkIsInMultiOrPipeline();
3341      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
3342    }
3343    @Override
3344    public List&lt;String&gt; zrevrangeByLex(final String key, final String max, final String min) {
3345      checkIsInMultiOrPipeline();
3346      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min));
3347    }
3348    @Override
3349    public List&lt;String&gt; zrevrangeByLex(final String key, final String max, final String min,
3350        final int offset, final int count) {
3351      checkIsInMultiOrPipeline();
3352      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
3353    }
3354    @Override
3355    public long zremrangeByLex(final String key, final String min, final String max) {
3356      checkIsInMultiOrPipeline();
3357      return connection.executeCommand(commandObjects.zremrangeByLex(key, min, max));
3358    }
3359    @Override
3360    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, String... keys) {
3361      checkIsInMultiOrPipeline();
3362      return connection.executeCommand(commandObjects.zmpop(option, keys));
3363    }
3364    @Override
3365    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, String... keys) {
3366      checkIsInMultiOrPipeline();
3367      return connection.executeCommand(commandObjects.zmpop(option, count, keys));
3368    }
3369    @Override
3370    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, String... keys) {
3371      checkIsInMultiOrPipeline();
3372      return connection.executeCommand(commandObjects.bzmpop(timeout, option, keys));
3373    }
3374    @Override
3375    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, String... keys) {
3376      checkIsInMultiOrPipeline();
3377      return connection.executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
3378    }
3379    @Override
3380    public long strlen(final String key) {
3381      checkIsInMultiOrPipeline();
3382      return connection.executeCommand(commandObjects.strlen(key));
3383    }
3384    @Override
3385    public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {
3386      checkIsInMultiOrPipeline();
3387      return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));
3388    }
3389    @Override
3390    public long lpushx(final String key, final String... strings) {
3391      checkIsInMultiOrPipeline();
3392      return connection.executeCommand(commandObjects.lpushx(key, strings));
3393    }
3394    @Override
3395    public long persist(final String key) {
3396      checkIsInMultiOrPipeline();
3397      return connection.executeCommand(commandObjects.persist(key));
3398    }
3399    @Override
3400    public long rpushx(final String key, final String... strings) {
3401      checkIsInMultiOrPipeline();
3402      return connection.executeCommand(commandObjects.rpushx(key, strings));
3403    }
3404    @Override
3405    public String echo(final String string) {
3406      checkIsInMultiOrPipeline();
3407      connection.sendCommand(ECHO, string);
3408      return connection.getBulkReply();
3409    }
3410    @Override
3411    public long linsert(final String key, final ListPosition where, final String pivot,
3412        final String value) {
3413      checkIsInMultiOrPipeline();
3414      return connection.executeCommand(commandObjects.linsert(key, where, pivot, value));
3415    }
3416    @Override
3417    public String brpoplpush(final String source, final String destination, final int timeout) {
3418      checkIsInMultiOrPipeline();
3419      return connection.executeCommand(commandObjects.brpoplpush(source, destination, timeout));
3420    }
3421    @Override
3422    public boolean setbit(final String key, final long offset, final boolean value) {
3423      checkIsInMultiOrPipeline();
3424      return connection.executeCommand(commandObjects.setbit(key, offset, value));
3425    }
3426    @Override
3427    public boolean getbit(final String key, final long offset) {
3428      checkIsInMultiOrPipeline();
3429      return connection.executeCommand(commandObjects.getbit(key, offset));
3430    }
3431    @Override
3432    public long setrange(final String key, final long offset, final String value) {
3433      checkIsInMultiOrPipeline();
3434      return connection.executeCommand(commandObjects.setrange(key, offset, value));
3435    }
3436    @Override
3437    public String getrange(final String key, final long startOffset, final long endOffset) {
3438      checkIsInMultiOrPipeline();
3439      return connection.executeCommand(commandObjects.getrange(key, startOffset, endOffset));
3440    }
3441    @Override
3442    public long bitpos(final String key, final boolean value) {
3443      checkIsInMultiOrPipeline();
3444      return connection.executeCommand(commandObjects.bitpos(key, value));
3445    }
3446    @Override
3447    public long bitpos(final String key, final boolean value, final BitPosParams params) {
3448      checkIsInMultiOrPipeline();
3449      return connection.executeCommand(commandObjects.bitpos(key, value, params));
3450    }
3451    @Override
3452    public List&lt;Object&gt; role() {
3453      checkIsInMultiOrPipeline();
3454      connection.sendCommand(ROLE);
3455      return BuilderFactory.ENCODED_OBJECT_LIST.build(connection.getOne());
3456    }
3457    @Override
3458    public Map&lt;String, String&gt; configGet(final String pattern) {
3459      checkIsInMultiOrPipeline();
3460      connection.sendCommand(Command.CONFIG, Keyword.GET.name(), pattern);
3461      return BuilderFactory.STRING_MAP.build(connection.getOne());
3462    }
3463    @Override
3464    public Map&lt;String, String&gt; configGet(String... patterns) {
3465      checkIsInMultiOrPipeline();
3466      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.GET.name(), patterns));
3467      return BuilderFactory.STRING_MAP.build(connection.getOne());
3468    }
3469    @Override
3470    public String configSet(final String parameter, final String value) {
3471      checkIsInMultiOrPipeline();
3472      connection.sendCommand(Command.CONFIG, Keyword.SET.name(), parameter, value);
3473      return connection.getStatusCodeReply();
3474    }
3475    @Override
3476    public String configSet(final String... parameterValues) {
3477      checkIsInMultiOrPipeline();
3478      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.SET.name(), parameterValues));
3479      return connection.getStatusCodeReply();
3480    }
3481    @Override
3482    public String configSet(Map&lt;String, String&gt; parameterValues) {
3483      checkIsInMultiOrPipeline();
3484      CommandArguments args = new CommandArguments(Command.CONFIG).add(Keyword.SET);
3485      parameterValues.forEach((k, v) -&gt; args.add(k).add(v));
3486      connection.sendCommand(args);
3487      return connection.getStatusCodeReply();
3488    }
3489    public long publish(final String channel, final String message) {
3490      checkIsInMultiOrPipeline();
3491      connection.sendCommand(PUBLISH, channel, message);
3492      return connection.getIntegerReply();
3493    }
3494    public void subscribe(final JedisPubSub jedisPubSub, final String... channels) {
3495      jedisPubSub.proceed(connection, channels);
3496    }
3497    public void psubscribe(final JedisPubSub jedisPubSub, final String... patterns) {
3498      jedisPubSub.proceedWithPatterns(connection, patterns);
3499    }
3500    public List&lt;String&gt; pubsubChannels() {
3501      checkIsInMultiOrPipeline();
3502      connection.sendCommand(PUBSUB, CHANNELS);
3503      return connection.getMultiBulkReply();
3504    }
3505    public List&lt;String&gt; pubsubChannels(final String pattern) {
3506      checkIsInMultiOrPipeline();
3507      connection.sendCommand(PUBSUB, CHANNELS.name(), pattern);
3508      return connection.getMultiBulkReply();
3509    }
3510    public Long pubsubNumPat() {
3511      checkIsInMultiOrPipeline();
3512      connection.sendCommand(PUBSUB, NUMPAT);
3513      return connection.getIntegerReply();
3514    }
3515    public Map&lt;String, Long&gt; pubsubNumSub(String... channels) {
3516      checkIsInMultiOrPipeline();
3517      connection.sendCommand(PUBSUB, joinParameters(NUMSUB.name(), channels));
3518      return BuilderFactory.PUBSUB_NUMSUB_MAP.build(connection.getOne());
3519    }
3520    public List&lt;String&gt; pubsubShardChannels() {
3521      checkIsInMultiOrPipeline();
3522      connection.sendCommand(PUBSUB, SHARDCHANNELS);
3523      return connection.getMultiBulkReply();
3524    }
3525    public List&lt;String&gt; pubsubShardChannels(final String pattern) {
3526      checkIsInMultiOrPipeline();
3527      connection.sendCommand(PUBSUB, SHARDCHANNELS.name(), pattern);
3528      return connection.getMultiBulkReply();
3529    }
3530    public Map&lt;String, Long&gt; pubsubShardNumSub(String... channels) {
3531      checkIsInMultiOrPipeline();
3532      connection.sendCommand(PUBSUB, joinParameters(SHARDNUMSUB.name(), channels));
3533      return BuilderFactory.PUBSUB_NUMSUB_MAP.build(connection.getOne());
3534    }
3535    @Override
3536    public Object eval(final String script, final int keyCount, final String... params) {
3537      checkIsInMultiOrPipeline();
3538      return connection.executeCommand(commandObjects.eval(script, keyCount, params));
3539    }
3540    @Override
3541    public Object eval(final String script, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
3542      checkIsInMultiOrPipeline();
3543      return connection.executeCommand(commandObjects.eval(script, keys, args));
3544    }
3545    @Override
3546    public Object evalReadonly(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
3547      checkIsInMultiOrPipeline();
3548      return connection.executeCommand(commandObjects.evalReadonly(script, keys, args));
3549    }
3550    @Override
3551    public Object eval(final String script) {
3552      checkIsInMultiOrPipeline();
3553      return connection.executeCommand(commandObjects.eval(script));
3554    }
3555    @Override
3556    public Object evalsha(final String sha1) {
3557      checkIsInMultiOrPipeline();
3558      return connection.executeCommand(commandObjects.evalsha(sha1));
3559    }
3560    @Override
3561    public Object evalsha(final String sha1, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
3562      checkIsInMultiOrPipeline();
3563      return connection.executeCommand(commandObjects.evalsha(sha1, keys, args));
3564    }
3565    @Override
3566    public Object evalshaReadonly(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
3567      checkIsInMultiOrPipeline();
3568      return connection.executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
3569    }
3570    @Override
3571    public Object evalsha(final String sha1, final int keyCount, final String... params) {
3572      checkIsInMultiOrPipeline();
3573      return connection.executeCommand(commandObjects.evalsha(sha1, keyCount, params));
3574    }
3575    @Override
3576    public Boolean scriptExists(final String sha1) {
3577      String[] a = new String[1];
3578      a[0] = sha1;
3579      return scriptExists(a).get(0);
3580    }
3581    @Override
3582    public List&lt;Boolean&gt; scriptExists(final String... sha1) {
3583      connection.sendCommand(SCRIPT, joinParameters(Keyword.EXISTS.name(), sha1));
3584      return BuilderFactory.BOOLEAN_LIST.build(connection.getOne());
3585    }
3586    @Override
3587    public String scriptLoad(final String script) {
3588      connection.sendCommand(SCRIPT, LOAD.name(), script);
3589      return connection.getBulkReply();
3590    }
3591    @Override
3592    public List&lt;Slowlog&gt; slowlogGet() {
3593      connection.sendCommand(SLOWLOG, Keyword.GET);
3594      return Slowlog.from(connection.getObjectMultiBulkReply());
3595    }
3596    @Override
3597    public List&lt;Slowlog&gt; slowlogGet(final long entries) {
3598      connection.sendCommand(SLOWLOG, Keyword.GET.getRaw(), toByteArray(entries));
3599      return Slowlog.from(connection.getObjectMultiBulkReply());
3600    }
3601    @Override
3602    public Long objectRefcount(final String key) {
3603      connection.sendCommand(OBJECT, REFCOUNT.name(), key);
3604      return connection.getIntegerReply();
3605    }
3606    @Override
3607    public String objectEncoding(final String key) {
3608      connection.sendCommand(OBJECT, ENCODING.name(), key);
3609      return connection.getBulkReply();
3610    }
3611    @Override
3612    public Long objectIdletime(final String key) {
3613      connection.sendCommand(OBJECT, IDLETIME.name(), key);
3614      return connection.getIntegerReply();
3615    }
3616    @Override
3617    public List&lt;String&gt; objectHelp() {
3618      connection.sendCommand(OBJECT, HELP);
3619      return connection.getMultiBulkReply();
3620    }
3621    @Override
3622    public Long objectFreq(final String key) {
3623      connection.sendCommand(OBJECT, FREQ.name(), key);
3624      return connection.getIntegerReply();
3625    }
3626    @Override
3627    public long bitcount(final String key) {
3628      checkIsInMultiOrPipeline();
3629      return connection.executeCommand(commandObjects.bitcount(key));
3630    }
3631    @Override
3632    public long bitcount(final String key, final long start, final long end) {
3633      checkIsInMultiOrPipeline();
3634      return connection.executeCommand(commandObjects.bitcount(key, start, end));
3635    }
3636    @Override
3637    public long bitcount(final String key, final long start, final long end, final BitCountOption option) {
3638      checkIsInMultiOrPipeline();
3639      return connection.executeCommand(commandObjects.bitcount(key, start, end, option));
3640    }
3641    @Override
3642    public long bitop(final BitOP op, final String destKey, final String... srcKeys) {
3643      checkIsInMultiOrPipeline();
3644      return connection.executeCommand(commandObjects.bitop(op, destKey, srcKeys));
3645    }
3646    public long commandCount() {
3647      checkIsInMultiOrPipeline();
3648      connection.sendCommand(COMMAND, COUNT);
3649      return connection.getIntegerReply();
3650    }
3651    public Map&lt;String, CommandDocument&gt; commandDocs(String... commands) {
3652      checkIsInMultiOrPipeline();
3653      connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));
3654      return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());
3655    }
3656    public List&lt;String&gt; commandGetKeys(String... command) {
3657      checkIsInMultiOrPipeline();
3658      connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));
3659      return BuilderFactory.STRING_LIST.build(connection.getOne());
3660    }
3661    public List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt; commandGetKeysAndFlags(String... command) {
3662      checkIsInMultiOrPipeline();
3663      connection.sendCommand(COMMAND, joinParameters(GETKEYSANDFLAGS.name(), command));
3664      return BuilderFactory.KEYED_STRING_LIST_LIST.build(connection.getOne());
3665    }
3666    public Map&lt;String, CommandInfo&gt; commandInfo(String... commands) {
3667      checkIsInMultiOrPipeline();
3668      connection.sendCommand(COMMAND, joinParameters(Keyword.INFO.name(), commands));
3669      return BuilderFactory.COMMAND_INFO_RESPONSE.build(connection.getOne());
3670    }
3671    public List&lt;String&gt; commandList() {
3672      checkIsInMultiOrPipeline();
3673      connection.sendCommand(COMMAND, LIST);
3674      return BuilderFactory.STRING_LIST.build(connection.getOne());
3675    }
3676    public List&lt;String&gt; commandListFilterBy(CommandListFilterByParams filterByParams) {
3677      checkIsInMultiOrPipeline();
3678      CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);
3679      connection.sendCommand(args);
3680      return BuilderFactory.STRING_LIST.build(connection.getOne());
3681    }
3682    @Override
3683    public String sentinelMyId() {
3684      connection.sendCommand(SENTINEL, MYID);
3685      return connection.getBulkReply();
3686    }
3687    @Override
3688    public List&lt;Map&lt;String, String&gt;&gt; sentinelMasters() {
3689      connection.sendCommand(SENTINEL, MASTERS);
3690      return connection.getObjectMultiBulkReply().stream()
3691          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3692    }
3693    @Override
3694    public Map&lt;String, String&gt; sentinelMaster(String masterName) {
3695      connection.sendCommand(SENTINEL, MASTER.name(), masterName);
3696      return BuilderFactory.STRING_MAP.build(connection.getOne());
3697    }
3698    @Override
3699    public List&lt;Map&lt;String, String&gt;&gt; sentinelSentinels(String masterName) {
3700      connection.sendCommand(SENTINEL, SENTINELS.name(), masterName);
3701      return connection.getObjectMultiBulkReply().stream()
3702          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3703    }
3704    @Override
3705    public List&lt;String&gt; sentinelGetMasterAddrByName(String masterName) {
3706      connection.sendCommand(SENTINEL, GET_MASTER_ADDR_BY_NAME.getRaw(), encode(masterName));
3707      return connection.getMultiBulkReply();
3708    }
3709    @Override
3710    public Long sentinelReset(String pattern) {
3711      connection.sendCommand(SENTINEL, SentinelKeyword.RESET.name(), pattern);
3712      return connection.getIntegerReply();
3713    }
3714    @Override
3715    @Deprecated
3716    public List&lt;Map&lt;String, String&gt;&gt; sentinelSlaves(String masterName) {
3717      connection.sendCommand(SENTINEL, SLAVES.name(), masterName);
3718      return connection.getObjectMultiBulkReply().stream()
3719          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3720    }
3721    @Override
3722    public List&lt;Map&lt;String, String&gt;&gt; sentinelReplicas(String masterName) {
3723      connection.sendCommand(SENTINEL, REPLICAS.name(), masterName);
3724      return connection.getObjectMultiBulkReply().stream()
3725          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3726    }
3727    @Override
3728    public String sentinelFailover(String masterName) {
3729      connection.sendCommand(SENTINEL, SentinelKeyword.FAILOVER.name(), masterName);
3730      return connection.getStatusCodeReply();
3731    }
3732    @Override
3733    public String sentinelMonitor(String masterName, String ip, int port, int quorum) {
3734      CommandArguments args = new CommandArguments(SENTINEL).add(SentinelKeyword.MONITOR)
3735          .add(masterName).add(ip).add(port).add(quorum);
3736      connection.sendCommand(args);
3737      return connection.getStatusCodeReply();
3738    }
3739    @Override
3740    public String sentinelRemove(String masterName) {
3741      connection.sendCommand(SENTINEL, REMOVE.name(), masterName);
3742      return connection.getStatusCodeReply();
3743    }
3744    @Override
3745    public String sentinelSet(String masterName, Map&lt;String, String&gt; parameterMap) {
3746      CommandArguments args = new CommandArguments(SENTINEL).add(SentinelKeyword.SET).add(masterName);
3747      parameterMap.entrySet().forEach(entry -&gt; args.add(entry.getKey()).add(entry.getValue()));
3748      connection.sendCommand(args);
3749      return connection.getStatusCodeReply();
3750    }
3751    @Override
3752    public byte[] dump(final String key) {
3753      checkIsInMultiOrPipeline();
3754      return connection.executeCommand(commandObjects.dump(key));
3755    }
3756    @Override
3757    public String restore(final String key, final long ttl, final byte[] serializedValue) {
3758      checkIsInMultiOrPipeline();
3759      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue));
3760    }
3761    @Override
3762    public String restore(final String key, final long ttl, final byte[] serializedValue,
3763        final RestoreParams params) {
3764      checkIsInMultiOrPipeline();
3765      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
3766    }
3767    @Override
3768    public long pttl(final String key) {
3769      checkIsInMultiOrPipeline();
3770      return connection.executeCommand(commandObjects.pttl(key));
3771    }
3772    @Override
3773    public String psetex(final String key, final long milliseconds, final String value) {
3774      checkIsInMultiOrPipeline();
3775      return connection.executeCommand(commandObjects.psetex(key, milliseconds, value));
3776    }
3777    @Override
3778    public String aclSetUser(final String name) {
3779      checkIsInMultiOrPipeline();
3780      connection.sendCommand(ACL, SETUSER.name(), name);
3781      return connection.getStatusCodeReply();
3782    }
3783    @Override
3784    public String aclSetUser(String name, String... rules) {
3785      checkIsInMultiOrPipeline();
3786      connection.sendCommand(ACL, joinParameters(SETUSER.name(), name, rules));
3787      return connection.getStatusCodeReply();
3788    }
3789    @Override
3790    public long aclDelUser(final String... names) {
3791      checkIsInMultiOrPipeline();
3792      connection.sendCommand(ACL, joinParameters(DELUSER.name(), names));
3793      return connection.getIntegerReply();
3794    }
3795    @Override
3796    public AccessControlUser aclGetUser(final String name) {
3797      checkIsInMultiOrPipeline();
3798      connection.sendCommand(ACL, GETUSER.name(), name);
3799      return BuilderFactory.ACCESS_CONTROL_USER.build(connection.getOne());
3800    }
3801    @Override
3802    public List&lt;String&gt; aclUsers() {
3803      checkIsInMultiOrPipeline();
3804      connection.sendCommand(ACL, USERS);
3805      return BuilderFactory.STRING_LIST.build(connection.getObjectMultiBulkReply());
3806    }
3807    @Override
3808    public List&lt;String&gt; aclList() {
3809      checkIsInMultiOrPipeline();
3810      connection.sendCommand(ACL, LIST);
3811      return connection.getMultiBulkReply();
3812    }
3813    @Override
3814    public String aclWhoAmI() {
3815      checkIsInMultiOrPipeline();
3816      connection.sendCommand(ACL, WHOAMI);
3817      return connection.getStatusCodeReply();
3818    }
3819    @Override
3820    public List&lt;String&gt; aclCat() {
3821      checkIsInMultiOrPipeline();
3822      connection.sendCommand(ACL, CAT);
3823      return BuilderFactory.STRING_LIST.build(connection.getOne());
3824    }
3825    @Override
3826    public List&lt;String&gt; aclCat(String category) {
3827      checkIsInMultiOrPipeline();
3828      connection.sendCommand(ACL, CAT.name(), category);
3829      return BuilderFactory.STRING_LIST.build(connection.getOne());
3830    }
3831    @Override
3832    public List&lt;AccessControlLogEntry&gt; aclLog() {
3833      checkIsInMultiOrPipeline();
3834      connection.sendCommand(ACL, LOG);
3835      return BuilderFactory.ACCESS_CONTROL_LOG_ENTRY_LIST.build(connection.getOne());
3836    }
3837    @Override
3838    public List&lt;AccessControlLogEntry&gt; aclLog(int limit) {
3839      checkIsInMultiOrPipeline();
3840      connection.sendCommand(ACL, LOG.getRaw(), toByteArray(limit));
3841      return BuilderFactory.ACCESS_CONTROL_LOG_ENTRY_LIST.build(connection.getOne());
3842    }
3843    @Override
3844    public String aclLoad() {
3845      checkIsInMultiOrPipeline();
3846      connection.sendCommand(ACL, LOAD);
3847      return connection.getStatusCodeReply();
3848    }
3849    @Override
3850    public String aclSave() {
3851      checkIsInMultiOrPipeline();
3852      connection.sendCommand(ACL, Keyword.SAVE);
3853      return connection.getStatusCodeReply();
3854    }
3855    @Override
3856    public String aclGenPass() {
3857      connection.sendCommand(ACL, GENPASS);
3858      return connection.getBulkReply();
3859    }
3860    @Override
3861    public String aclGenPass(int bits) {
3862      checkIsInMultiOrPipeline();
3863      connection.sendCommand(ACL, GENPASS.getRaw(), toByteArray(bits));
3864      return connection.getBulkReply();
3865    }
3866    @Override
3867    public String aclDryRun(String username, String command, String... args) {
3868      checkIsInMultiOrPipeline();
3869      String[] allArgs = new String[3 + args.length];
3870      allArgs[0] = DRYRUN.name();
3871      allArgs[1] = username;
3872      allArgs[2] = command;
3873      System.arraycopy(args, 0, allArgs, 3, args.length);
3874      connection.sendCommand(ACL, allArgs);
3875      return connection.getBulkReply();
3876    }
3877    @Override
3878    public String aclDryRun(String username, CommandArguments commandArgs) {
3879      checkIsInMultiOrPipeline();
3880      CommandArguments allArgs = new CommandArguments(ACL).add(DRYRUN).add(username);
3881      Iterator&lt;Rawable&gt; it = commandArgs.iterator();
3882      while (it.hasNext()) allArgs.add(it.next());
3883      connection.sendCommand(allArgs);
3884      return connection.getBulkReply();
3885    }
3886    @Override
3887    public byte[] aclDryRunBinary(byte[] username, byte[] command, byte[]... args) {
3888      checkIsInMultiOrPipeline();
3889      byte[][] allArgs = new byte[3 + args.length][];
3890      allArgs[0] = DRYRUN.getRaw();
3891      allArgs[1] = username;
3892      allArgs[2] = command;
3893      System.arraycopy(args, 0, allArgs, 3, args.length);
3894      connection.sendCommand(ACL, allArgs);
3895      return connection.getBinaryBulkReply();
3896    }
3897    @Override
3898    public byte[] aclDryRunBinary(byte[] username, CommandArguments commandArgs) {
3899      checkIsInMultiOrPipeline();
3900      CommandArguments allArgs = new CommandArguments(ACL).add(DRYRUN).add(username);
3901      Iterator&lt;Rawable&gt; it = commandArgs.iterator();
3902      while (it.hasNext()) allArgs.add(it.next());
3903      connection.sendCommand(allArgs);
3904      return connection.getBinaryBulkReply();
3905    }
3906    @Override
3907    public String clientKill(final String ipPort) {
3908      checkIsInMultiOrPipeline();
3909      connection.sendCommand(CLIENT, KILL.name(), ipPort);
3910      return connection.getStatusCodeReply();
3911    }
3912    @Override
3913    public String clientGetname() {
3914      checkIsInMultiOrPipeline();
3915      connection.sendCommand(CLIENT, GETNAME);
3916      return connection.getBulkReply();
3917    }
3918    @Override
3919    public String clientList() {
3920      checkIsInMultiOrPipeline();
3921      connection.sendCommand(CLIENT, LIST);
3922      return connection.getBulkReply();
3923    }
3924    @Override
3925    public String clientList(ClientType type) {
3926      checkIsInMultiOrPipeline();
3927      connection.sendCommand(CLIENT, LIST.getRaw(), Keyword.TYPE.getRaw(), type.getRaw());
3928      return connection.getBulkReply();
3929    }
3930    @Override
3931    public String clientList(final long... clientIds) {
3932      checkIsInMultiOrPipeline();
3933      connection.sendCommand(CLIENT, clientListParams(clientIds));
3934      return connection.getBulkReply();
3935    }
3936    @Override
3937    public String clientInfo() {
3938      checkIsInMultiOrPipeline();
3939      connection.sendCommand(CLIENT, Keyword.INFO);
3940      return connection.getBulkReply();
3941    }
3942    @Override
3943    public String clientSetInfo(ClientAttributeOption attr, String value) {
3944      checkIsInMultiOrPipeline();
3945      connection.sendCommand(CLIENT, SETINFO.getRaw(), attr.getRaw(), encode(value));
3946      return connection.getStatusCodeReply();
3947    }
3948    @Override
3949    public String clientSetname(final String name) {
3950      checkIsInMultiOrPipeline();
3951      connection.sendCommand(CLIENT, SETNAME.name(), name);
3952      return connection.getStatusCodeReply();
3953    }
3954    @Override
3955    public String migrate(final String host, final int port, final String key,
3956        final int destinationDb, final int timeout) {
3957      checkIsInMultiOrPipeline();
3958      return connection.executeCommand(commandObjects.migrate(host, port, key, destinationDb, timeout));
3959    }
3960    @Override
3961    public String migrate(final String host, final int port, final int destinationDB,
3962        final int timeout, final MigrateParams params, final String... keys) {
3963      checkIsInMultiOrPipeline();
3964      return connection.executeCommand(commandObjects.migrate(host, port, destinationDB, timeout, params, keys));
3965    }
3966    @Override
3967    public String migrate(String host, int port, String key, int timeout) {
3968      checkIsInMultiOrPipeline();
3969      return connection.executeCommand(commandObjects.migrate(host, port, key, timeout));
3970    }
3971    @Override
3972    public String migrate(String host, int port, int timeout, MigrateParams params, String... keys) {
3973      checkIsInMultiOrPipeline();
3974      return connection.executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
3975    }
3976    @Override
3977    public ScanResult&lt;String&gt; scan(final String cursor) {
3978      return connection.executeCommand(commandObjects.scan(cursor));
3979    }
3980    @Override
3981    public ScanResult&lt;String&gt; scan(final String cursor, final ScanParams params) {
3982      return connection.executeCommand(commandObjects.scan(cursor, params));
3983    }
3984    @Override
3985    public ScanResult&lt;String&gt; scan(final String cursor, final ScanParams params, final String type) {
3986      checkIsInMultiOrPipeline();
3987      return connection.executeCommand(commandObjects.scan(cursor, params, type));
3988    }
3989    @Override
3990    public ScanResult&lt;Map.Entry&lt;String, String&gt;&gt; hscan(final String key, final String cursor,
3991        final ScanParams params) {
3992      checkIsInMultiOrPipeline();
3993      return connection.executeCommand(commandObjects.hscan(key, cursor, params));
3994    }
3995    @Override
3996    public ScanResult&lt;String&gt; sscan(final String key, final String cursor, final ScanParams params) {
3997      checkIsInMultiOrPipeline();
3998      return connection.executeCommand(commandObjects.sscan(key, cursor, params));
3999    }
4000    @Override
4001    public ScanResult&lt;Tuple&gt; zscan(final String key, final String cursor, final ScanParams params) {
4002      checkIsInMultiOrPipeline();
4003      return connection.executeCommand(commandObjects.zscan(key, cursor, params));
4004    }
4005    @Override
4006    public String readonly() {
4007      checkIsInMultiOrPipeline();
4008      connection.sendCommand(READONLY);
4009      return connection.getStatusCodeReply();
4010    }
4011    @Override
4012    public String readwrite() {
4013      checkIsInMultiOrPipeline();
4014      connection.sendCommand(READWRITE);
4015      return connection.getStatusCodeReply();
4016    }
4017    @Override
4018    public String clusterNodes() {
4019      checkIsInMultiOrPipeline();
4020      connection.sendCommand(CLUSTER, ClusterKeyword.NODES);
4021      return connection.getBulkReply();
4022    }
4023    @Override
4024    public String clusterMeet(final String ip, final int port) {
4025      checkIsInMultiOrPipeline();
4026      connection.sendCommand(CLUSTER, ClusterKeyword.MEET.name(), ip, Integer.toString(port));
4027      return connection.getStatusCodeReply();
4028    }
4029    @Override
4030    public String clusterReset() {
4031      checkIsInMultiOrPipeline();
4032      connection.sendCommand(CLUSTER, ClusterKeyword.RESET);
4033      return connection.getStatusCodeReply();
4034    }
4035    @Override
4036    public String clusterReset(final ClusterResetType resetType) {
4037      checkIsInMultiOrPipeline();
4038      connection.sendCommand(CLUSTER, ClusterKeyword.RESET.getRaw(), resetType.getRaw());
4039      return connection.getStatusCodeReply();
4040    }
4041    @Override
4042    public String clusterAddSlots(final int... slots) {
4043      checkIsInMultiOrPipeline();
4044      connection.sendCommand(CLUSTER, joinParameters(ClusterKeyword.ADDSLOTS.getRaw(), joinParameters(slots)));
4045      return connection.getStatusCodeReply();
4046    }
4047    @Override
4048    public String clusterDelSlots(final int... slots) {
4049      checkIsInMultiOrPipeline();
4050      connection.sendCommand(CLUSTER, joinParameters(ClusterKeyword.DELSLOTS.getRaw(), joinParameters(slots)));
4051      return connection.getStatusCodeReply();
4052    }
4053    @Override
4054    public String clusterInfo() {
4055      checkIsInMultiOrPipeline();
4056      connection.sendCommand(CLUSTER, ClusterKeyword.INFO);
4057      return connection.getStatusCodeReply();
4058    }
4059    @Override
4060    public List&lt;String&gt; clusterGetKeysInSlot(final int slot, final int count) {
4061      checkIsInMultiOrPipeline();
4062      connection.sendCommand(CLUSTER, ClusterKeyword.GETKEYSINSLOT.getRaw(), toByteArray(slot), toByteArray(count));
4063      return connection.getMultiBulkReply();
4064    }
4065    @Override
4066    public List&lt;byte[]&gt; clusterGetKeysInSlotBinary(final int slot, final int count) {
4067      checkIsInMultiOrPipeline();
4068      connection.sendCommand(CLUSTER, ClusterKeyword.GETKEYSINSLOT.getRaw(), toByteArray(slot), toByteArray(count));
4069      return connection.getBinaryMultiBulkReply();
4070    }
4071    @Override
4072    public String clusterSetSlotNode(final int slot, final String nodeId) {
4073      checkIsInMultiOrPipeline();
4074      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.NODE.getRaw(), encode(nodeId));
4075      return connection.getStatusCodeReply();
4076    }
4077    @Override
4078    public String clusterSetSlotMigrating(final int slot, final String nodeId) {
4079      checkIsInMultiOrPipeline();
4080      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.MIGRATING.getRaw(), encode(nodeId));
4081      return connection.getStatusCodeReply();
4082    }
4083    @Override
4084    public String clusterSetSlotImporting(final int slot, final String nodeId) {
4085      checkIsInMultiOrPipeline();
4086      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.IMPORTING.getRaw(), encode(nodeId));
4087      return connection.getStatusCodeReply();
4088    }
4089    @Override
4090    public String clusterSetSlotStable(final int slot) {
4091      checkIsInMultiOrPipeline();
4092      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.STABLE.getRaw());
4093      return connection.getStatusCodeReply();
4094    }
4095    @Override
4096    public String clusterForget(final String nodeId) {
4097      checkIsInMultiOrPipeline();
4098      connection.sendCommand(CLUSTER, ClusterKeyword.FORGET.name(), nodeId);
4099      return connection.getStatusCodeReply();
4100    }
4101    @Override
4102    public String clusterFlushSlots() {
4103      checkIsInMultiOrPipeline();
4104      connection.sendCommand(CLUSTER, ClusterKeyword.FLUSHSLOTS);
4105      return connection.getStatusCodeReply();
4106    }
4107    @Override
4108    public long clusterKeySlot(final String key) {
4109      checkIsInMultiOrPipeline();
4110      connection.sendCommand(CLUSTER, ClusterKeyword.KEYSLOT.name(), key);
4111      return connection.getIntegerReply();
4112    }
4113    @Override
4114    public long clusterCountFailureReports(final String nodeId) {
4115      checkIsInMultiOrPipeline();
4116      connection.sendCommand(CLUSTER, &quot;COUNT-FAILURE-REPORTS&quot;,  nodeId);
4117      return connection.getIntegerReply();  
4118    }
4119    @Override
4120    public long clusterCountKeysInSlot(final int slot) {
4121      checkIsInMultiOrPipeline();
4122      connection.sendCommand(CLUSTER, ClusterKeyword.COUNTKEYSINSLOT.getRaw(), toByteArray(slot));
4123      return connection.getIntegerReply();
4124    }
4125    @Override
4126    public String clusterSaveConfig() {
4127      checkIsInMultiOrPipeline();
4128      connection.sendCommand(CLUSTER, ClusterKeyword.SAVECONFIG);
4129      return connection.getStatusCodeReply();
4130    }
4131    @Override
4132    public String clusterSetConfigEpoch(long configEpoch) {
4133      checkIsInMultiOrPipeline();
4134      connection.sendCommand(CLUSTER, &quot;SET-CONFIG-EPOCH&quot;, Long.toString(configEpoch));
4135      return connection.getStatusCodeReply();
4136    }
4137    @Override
4138    public String clusterBumpEpoch() {
4139      checkIsInMultiOrPipeline();
4140      connection.sendCommand(CLUSTER, ClusterKeyword.BUMPEPOCH);
4141      return connection.getBulkReply();
4142    }
4143    @Override
4144    public String clusterReplicate(final String nodeId) {
4145      checkIsInMultiOrPipeline();
4146      connection.sendCommand(CLUSTER, ClusterKeyword.REPLICATE.name(), nodeId);
4147      return connection.getStatusCodeReply();
4148    }
4149    @Override
4150    @Deprecated
4151    public List&lt;String&gt; clusterSlaves(final String nodeId) {
4152      checkIsInMultiOrPipeline();
4153      connection.sendCommand(CLUSTER, ClusterKeyword.SLAVES.name(), nodeId);
4154      return connection.getMultiBulkReply();
4155    }
4156    @Override
4157    public List&lt;String&gt; clusterReplicas(final String nodeId) {
4158      checkIsInMultiOrPipeline();
4159      connection.sendCommand(CLUSTER, ClusterKeyword.REPLICAS.name(), nodeId);
4160      return connection.getMultiBulkReply();
4161    }
4162    @Override
4163    public String clusterFailover() {
4164      checkIsInMultiOrPipeline();
4165      connection.sendCommand(CLUSTER, ClusterKeyword.FAILOVER);
4166      return connection.getStatusCodeReply();
4167    }
4168    @Override
4169    public String clusterFailover(ClusterFailoverOption failoverOption) {
4170      checkIsInMultiOrPipeline();
4171      connection.sendCommand(CLUSTER, ClusterKeyword.FAILOVER.getRaw(), failoverOption.getRaw());
4172      return connection.getStatusCodeReply();
4173    }
4174    @Override
4175    public List&lt;Object&gt; clusterSlots() {
4176      checkIsInMultiOrPipeline();
4177      connection.sendCommand(CLUSTER, ClusterKeyword.SLOTS);
4178      return connection.getObjectMultiBulkReply();
4179    }
4180    @Override
4181    public String clusterMyId() {
4182      checkIsInMultiOrPipeline();
4183      connection.sendCommand(CLUSTER, ClusterKeyword.MYID);
4184      return connection.getBulkReply();
4185    }
4186    @Override
4187    public String clusterMyShardId() {
4188      checkIsInMultiOrPipeline();
4189      connection.sendCommand(CLUSTER, ClusterKeyword.MYSHARDID);
4190      return connection.getBulkReply();
4191    }
4192    @Override
4193    public List&lt;Map&lt;String, Object&gt;&gt; clusterLinks() {
4194      checkIsInMultiOrPipeline();
4195      connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);
4196      return connection.getObjectMultiBulkReply().stream()
4197              .map(BuilderFactory.ENCODED_OBJECT_MAP::build).collect(Collectors.toList());
4198    }
4199    @Override
4200    public String clusterAddSlotsRange(int... ranges) {
4201      checkIsInMultiOrPipeline();
4202      connection.sendCommand(CLUSTER,
4203          joinParameters(ClusterKeyword.ADDSLOTSRANGE.getRaw(), joinParameters(ranges)));
4204      return connection.getStatusCodeReply();
4205    }
4206    @Override
4207    public String clusterDelSlotsRange(int... ranges) {
4208      checkIsInMultiOrPipeline();
4209      connection.sendCommand(CLUSTER,
4210          joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges)));
4211      return connection.getStatusCodeReply();
4212    }
4213    @Override
4214    public String asking() {
4215      checkIsInMultiOrPipeline();
4216      connection.sendCommand(ASKING);
4217      return connection.getStatusCodeReply();
4218    }
4219    @Override
4220    public long pfadd(final String key, final String... elements) {
4221      checkIsInMultiOrPipeline();
4222      return connection.executeCommand(commandObjects.pfadd(key, elements));
4223    }
4224    @Override
4225    public long pfcount(final String key) {
4226      checkIsInMultiOrPipeline();
4227      return connection.executeCommand(commandObjects.pfcount(key));
4228    }
4229    @Override
4230    public long pfcount(final String... keys) {
4231      checkIsInMultiOrPipeline();
4232      return connection.executeCommand(commandObjects.pfcount(keys));
4233    }
4234    @Override
4235    public String pfmerge(final String destkey, final String... sourcekeys) {
4236      checkIsInMultiOrPipeline();
4237      return connection.executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
4238    }
4239    @Override
4240    public Object fcall(final String name, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
4241      return connection.executeCommand(commandObjects.fcall(name, keys, args));
4242    }
4243    @Override
4244    public Object fcallReadonly(final String name, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
4245      return connection.executeCommand(commandObjects.fcallReadonly(name, keys, args));
4246    }
4247    @Override
4248    public String functionDelete(final String libraryName) {
4249      checkIsInMultiOrPipeline();
4250      return connection.executeCommand(commandObjects.functionDelete(libraryName));
4251    }
4252    @Override
4253    public String functionLoad(final String functionCode) {
4254      checkIsInMultiOrPipeline();
4255      return connection.executeCommand(commandObjects.functionLoad(functionCode));
4256    }
4257    @Override
4258    public String functionLoadReplace(final String functionCode) {
4259      checkIsInMultiOrPipeline();
4260      return connection.executeCommand(commandObjects.functionLoadReplace(functionCode));
4261    }
4262    @Override
4263    public FunctionStats functionStats() {
4264      checkIsInMultiOrPipeline();
4265      return connection.executeCommand(commandObjects.functionStats());
4266    }
4267    @Override
4268    public String functionFlush() {
4269      checkIsInMultiOrPipeline();
4270      return connection.executeCommand(commandObjects.functionFlush());
4271    }
4272    @Override
4273    public String functionFlush(final FlushMode mode) {
4274      checkIsInMultiOrPipeline();
4275      return connection.executeCommand(commandObjects.functionFlush(mode));
4276    }
4277    @Override
4278    public String functionKill() {
4279      checkIsInMultiOrPipeline();
4280      return connection.executeCommand(commandObjects.functionKill());
4281    }
4282    @Override
4283    public List&lt;LibraryInfo&gt; functionList() {
4284      checkIsInMultiOrPipeline();
4285      return connection.executeCommand(commandObjects.functionList());
4286    }
4287    @Override
4288    public List&lt;LibraryInfo&gt; functionList(final String libraryNamePattern) {
4289      checkIsInMultiOrPipeline();
4290      return connection.executeCommand(commandObjects.functionList(libraryNamePattern));
4291    }
4292    @Override
4293    public List&lt;LibraryInfo&gt; functionListWithCode() {
4294      checkIsInMultiOrPipeline();
4295      return connection.executeCommand(commandObjects.functionListWithCode());  }
4296    @Override
4297    public List&lt;LibraryInfo&gt; functionListWithCode(String libraryNamePattern) {
4298      checkIsInMultiOrPipeline();
4299      return connection.executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
4300    }
4301    @Override
4302    public long geoadd(final String key, final double longitude, final double latitude,
4303        final String member) {
4304      checkIsInMultiOrPipeline();
4305      return connection.executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
4306    }
4307    @Override
4308    public long geoadd(final String key, final Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
4309      checkIsInMultiOrPipeline();
4310      return connection.executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
4311    }
4312    @Override
4313    public long geoadd(final String key, final GeoAddParams params, final Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
4314      checkIsInMultiOrPipeline();
4315      return connection.executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
4316    }
4317    @Override
4318    public Double geodist(final String key, final String member1, final String member2) {
4319      checkIsInMultiOrPipeline();
4320      return connection.executeCommand(commandObjects.geodist(key, member1, member2));
4321    }
4322    @Override
4323    public Double geodist(final String key, final String member1, final String member2,
4324        final GeoUnit unit) {
4325      checkIsInMultiOrPipeline();
4326      return connection.executeCommand(commandObjects.geodist(key, member1, member2, unit));
4327    }
4328    @Override
4329    public List&lt;String&gt; geohash(final String key, String... members) {
4330      checkIsInMultiOrPipeline();
4331      return connection.executeCommand(commandObjects.geohash(key, members));
4332    }
4333    @Override
4334    public List&lt;GeoCoordinate&gt; geopos(final String key, String... members) {
4335      checkIsInMultiOrPipeline();
4336      return connection.executeCommand(commandObjects.geopos(key, members));
4337    }
4338    @Override
4339    public List&lt;GeoRadiusResponse&gt; georadius(final String key, final double longitude,
4340        final double latitude, final double radius, final GeoUnit unit) {
4341      checkIsInMultiOrPipeline();
4342      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
4343    }
4344    @Override
4345    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final String key, final double longitude,
4346        final double latitude, final double radius, final GeoUnit unit) {
4347      checkIsInMultiOrPipeline();
4348      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
4349    }
4350    @Override
4351    public List&lt;GeoRadiusResponse&gt; georadius(final String key, final double longitude,
4352        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4353      checkIsInMultiOrPipeline();
4354      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
4355    }
4356    @Override
4357    public long georadiusStore(final String key, double longitude, double latitude, double radius,
4358        GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
4359      checkIsInMultiOrPipeline();
4360      return connection.executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
4361    }
4362    @Override
4363    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final String key, final double longitude,
4364        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4365      checkIsInMultiOrPipeline();
4366      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
4367    }
4368    @Override
4369    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final String key, final String member,
4370        final double radius, final GeoUnit unit) {
4371      checkIsInMultiOrPipeline();
4372      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
4373    }
4374    @Override
4375    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final String key, final String member,
4376        final double radius, final GeoUnit unit) {
4377      checkIsInMultiOrPipeline();
4378      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
4379    }
4380    @Override
4381    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final String key, final String member,
4382        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4383      checkIsInMultiOrPipeline();
4384      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
4385    }
4386    @Override
4387    public long georadiusByMemberStore(final String key, String member, double radius, GeoUnit unit,
4388        GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
4389      checkIsInMultiOrPipeline();
4390      return connection.executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
4391    }
4392    @Override
4393    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final String key, final String member,
4394        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4395      checkIsInMultiOrPipeline();
4396      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
4397    }
4398    @Override
4399    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double radius, GeoUnit unit) {
4400      checkIsInMultiOrPipeline();
4401      return connection.executeCommand(commandObjects.geosearch(key, member, radius, unit));
4402    }
4403    @Override
4404    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double radius, GeoUnit unit) {
4405      checkIsInMultiOrPipeline();
4406      return connection.executeCommand(commandObjects.geosearch(key, coord, radius, unit));
4407    }
4408    @Override
4409    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double width, double height, GeoUnit unit) {
4410      checkIsInMultiOrPipeline();
4411      return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));
4412    }
4413    @Override
4414    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
4415      checkIsInMultiOrPipeline();
4416      return connection.executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
4417    }
4418    @Override
4419    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoSearchParam params) {
4420      checkIsInMultiOrPipeline();
4421      return connection.executeCommand(commandObjects.geosearch(key, params));
4422    }
4423    @Override
4424    public long geosearchStore(String dest, String src, String member, double radius, GeoUnit unit) {
4425      checkIsInMultiOrPipeline();
4426      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
4427    }
4428    @Override
4429    public long geosearchStore(String dest, String src, GeoCoordinate coord, double radius, GeoUnit unit) {
4430      checkIsInMultiOrPipeline();
4431      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
4432    }
4433    @Override
4434    public long geosearchStore(String dest, String src, String member, double width, double height, GeoUnit unit) {
4435      checkIsInMultiOrPipeline();
4436      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
4437    }
4438    @Override
4439    public long geosearchStore(String dest, String src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
4440      checkIsInMultiOrPipeline();
4441      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
4442    }
4443    @Override
4444    public long geosearchStore(String dest, String src, GeoSearchParam params) {
4445      checkIsInMultiOrPipeline();
4446      return connection.executeCommand(commandObjects.geosearchStore(dest, src, params));
4447    }
4448    @Override
4449    public long geosearchStoreStoreDist(String dest, String src, GeoSearchParam params) {
4450      checkIsInMultiOrPipeline();
4451      return connection.executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
4452    }
4453    @Override
4454    public String moduleLoad(final String path) {
4455      checkIsInMultiOrPipeline();
4456      connection.sendCommand(Command.MODULE, LOAD.name(), path);
4457      return connection.getStatusCodeReply();
4458    }
4459    @Override
4460    public String moduleLoad(String path, String... args) {
4461      checkIsInMultiOrPipeline();
4462      connection.sendCommand(Command.MODULE, joinParameters(LOAD.name(), path, args));
4463      return connection.getStatusCodeReply();
4464    }
4465    @Override
4466    public String moduleLoadEx(String path, ModuleLoadExParams params) {
4467      checkIsInMultiOrPipeline();
4468      connection.sendCommand(new CommandArguments(Command.MODULE).add(LOADEX).add(path)
4469          .addParams(params));
4470      return connection.getStatusCodeReply();
4471    }
4472    @Override
4473    public String moduleUnload(final String name) {
4474      checkIsInMultiOrPipeline();
4475      connection.sendCommand(Command.MODULE, UNLOAD.name(), name);
4476      return connection.getStatusCodeReply();
4477    }
4478    @Override
4479    public List&lt;Module&gt; moduleList() {
4480      checkIsInMultiOrPipeline();
4481      connection.sendCommand(Command.MODULE, LIST);
4482      return BuilderFactory.MODULE_LIST.build(connection.getOne());
4483    }
4484    @Override
4485    public List&lt;Long&gt; bitfield(final String key, final String... arguments) {
4486      checkIsInMultiOrPipeline();
4487      return connection.executeCommand(commandObjects.bitfield(key, arguments));
4488    }
4489    @Override
4490    public List&lt;Long&gt; bitfieldReadonly(final String key, final String... arguments) {
4491      checkIsInMultiOrPipeline();
4492      return connection.executeCommand(commandObjects.bitfieldReadonly(key, arguments));
4493    }
4494    @Override
4495    public long hstrlen(final String key, final String field) {
4496      checkIsInMultiOrPipeline();
4497      return connection.executeCommand(commandObjects.hstrlen(key, field));
4498    }
4499    @Override
4500    public String memoryDoctor() {
4501      checkIsInMultiOrPipeline();
4502      connection.sendCommand(MEMORY, DOCTOR);
4503      return connection.getBulkReply();
4504    }
4505    @Override
4506    public Long memoryUsage(final String key) {
4507      checkIsInMultiOrPipeline();
4508      connection.sendCommand(MEMORY, USAGE.name(), key);
4509      return connection.getIntegerReply();
4510    }
4511    @Override
4512    public Long memoryUsage(final String key, final int samples) {
4513      checkIsInMultiOrPipeline();
4514      connection.sendCommand(MEMORY, USAGE.getRaw(), encode(key), SAMPLES.getRaw(), toByteArray(samples));
4515      return connection.getIntegerReply();
4516    }
4517    @Override
4518    public String memoryPurge() {
4519      checkIsInMultiOrPipeline();
4520      connection.sendCommand(MEMORY, PURGE);
4521      return connection.getBulkReply();
4522    }
4523    @Override
4524    public Map&lt;String, Object&gt; memoryStats() {
4525      checkIsInMultiOrPipeline();
4526      connection.sendCommand(MEMORY, STATS);
4527      return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());
4528    }
4529    @Override
4530    public String lolwut() {
4531      checkIsInMultiOrPipeline();
4532      connection.sendCommand(LOLWUT);
4533      return connection.getBulkReply();
4534    }
4535    @Override
4536    public String lolwut(LolwutParams lolwutParams) {
4537      checkIsInMultiOrPipeline();
4538      connection.sendCommand(new CommandArguments(LOLWUT).addParams(lolwutParams));
4539      return connection.getBulkReply();
4540    }
4541    @Override
4542    public String latencyDoctor() {
4543      checkIsInMultiOrPipeline();
4544      connection.sendCommand(LATENCY, DOCTOR);
4545      return connection.getBulkReply();
4546    }
4547    @Override
4548    public StreamEntryID xadd(final String key, final StreamEntryID id, final Map&lt;String, String&gt; hash) {
4549      checkIsInMultiOrPipeline();
4550      return connection.executeCommand(commandObjects.xadd(key, id, hash));
4551    }
4552    @Override
4553    public StreamEntryID xadd(final String key, final XAddParams params, final Map&lt;String, String&gt; hash) {
4554      checkIsInMultiOrPipeline();
4555      return connection.executeCommand(commandObjects.xadd(key, params, hash));
4556    }
4557    @Override
4558    public long xlen(final String key) {
4559      checkIsInMultiOrPipeline();
4560      return connection.executeCommand(commandObjects.xlen(key));
4561    }
4562    @Override
4563    public List&lt;StreamEntry&gt; xrange(final String key, final StreamEntryID start, final StreamEntryID end) {
4564      checkIsInMultiOrPipeline();
4565      return connection.executeCommand(commandObjects.xrange(key, start, end));
4566    }
4567    @Override
4568    public List&lt;StreamEntry&gt; xrange(final String key, final StreamEntryID start,
4569        final StreamEntryID end, final int count) {
4570      checkIsInMultiOrPipeline();
4571      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
4572    }
4573    @Override
4574    public List&lt;StreamEntry&gt; xrevrange(final String key, final StreamEntryID end,
4575        final StreamEntryID start) {
4576      checkIsInMultiOrPipeline();
4577      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
4578    }
4579    @Override
4580    public List&lt;StreamEntry&gt; xrevrange(final String key, final StreamEntryID end,
4581        final StreamEntryID start, final int count) {
4582      checkIsInMultiOrPipeline();
4583      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
4584    }
4585    @Override
4586    public List&lt;StreamEntry&gt; xrange(final String key, final String start, final String end) {
4587      checkIsInMultiOrPipeline();
4588      return connection.executeCommand(commandObjects.xrange(key, start, end));
4589    }
4590    @Override
4591    public List&lt;StreamEntry&gt; xrange(final String key, final String start, final String end, final int count) {
4592      checkIsInMultiOrPipeline();
4593      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
4594    }
4595    @Override
4596    public List&lt;StreamEntry&gt; xrevrange(final String key, final String end, final String start) {
4597      checkIsInMultiOrPipeline();
4598      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
4599    }
4600    @Override
4601    public List&lt;StreamEntry&gt; xrevrange(final String key, final String end, final String start, final int count) {
4602      checkIsInMultiOrPipeline();
4603      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
4604    }
4605    @Override
4606    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xread(final XReadParams xReadParams, final Map&lt;String, StreamEntryID&gt; streams) {
4607      checkIsInMultiOrPipeline();
4608      return connection.executeCommand(commandObjects.xread(xReadParams, streams));
4609    }
4610    @Override
4611    public long xack(final String key, final String group, final StreamEntryID... ids) {
4612      checkIsInMultiOrPipeline();
4613      return connection.executeCommand(commandObjects.xack(key, group, ids));
4614    }
4615    @Override
4616    public String xgroupCreate(final String key, final String groupName, final StreamEntryID id,
4617        final boolean makeStream) {
4618      checkIsInMultiOrPipeline();
4619      return connection.executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
4620    }
4621    @Override
4622    public String xgroupSetID(final String key, final String groupName, final StreamEntryID id) {
4623      checkIsInMultiOrPipeline();
4624      return connection.executeCommand(commandObjects.xgroupSetID(key, groupName, id));
4625    }
4626    @Override
4627    public long xgroupDestroy(final String key, final String groupName) {
4628      checkIsInMultiOrPipeline();
4629      return connection.executeCommand(commandObjects.xgroupDestroy(key, groupName));
4630    }
4631    @Override
4632    public boolean xgroupCreateConsumer(String key, String groupName, String consumerName) {
4633      checkIsInMultiOrPipeline();
4634      return connection.executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
4635    }
4636    @Override
4637    public long xgroupDelConsumer(final String key, final String groupName, final String consumerName) {
4638      checkIsInMultiOrPipeline();
4639      return connection.executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
4640    }
4641    @Override
4642    public long xdel(final String key, final StreamEntryID... ids) {
4643      checkIsInMultiOrPipeline();
4644      return connection.executeCommand(commandObjects.xdel(key, ids));
4645    }
4646    @Override
4647    public long xtrim(final String key, final long maxLen, final boolean approximateLength) {
4648      checkIsInMultiOrPipeline();
4649      return connection.executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
4650    }
4651    @Override
4652    public long xtrim(final String key, final XTrimParams params) {
4653      checkIsInMultiOrPipeline();
4654      return connection.executeCommand(commandObjects.xtrim(key, params));
4655    }
4656    @Override
4657    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xreadGroup(final String groupName,
4658        final String consumer, final XReadGroupParams xReadGroupParams,
4659        final Map&lt;String, StreamEntryID&gt; streams) {
4660      checkIsInMultiOrPipeline();
4661      return connection.executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
4662    }
4663    @Override
4664    public StreamPendingSummary xpending(final String key, final String groupName) {
4665      checkIsInMultiOrPipeline();
4666      return connection.executeCommand(commandObjects.xpending(key, groupName));
4667    }
4668    @Override
4669    public List&lt;StreamPendingEntry&gt; xpending(final String key, final String groupName, final XPendingParams params) {
4670      checkIsInMultiOrPipeline();
4671      return connection.executeCommand(commandObjects.xpending(key, groupName, params));
4672    }
4673    @Override
4674    public List&lt;StreamEntry&gt; xclaim(String key, String group, String consumerName, long minIdleTime,
4675        XClaimParams params, StreamEntryID... ids) {
4676      checkIsInMultiOrPipeline();
4677      return connection.executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
4678    }
4679    @Override
4680    public List&lt;StreamEntryID&gt; xclaimJustId(String key, String group, String consumerName,
4681        long minIdleTime, XClaimParams params, StreamEntryID... ids) {
4682      checkIsInMultiOrPipeline();
4683      return connection.executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
4684    }
4685    @Override
4686    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt; xautoclaim(String key, String group, String consumerName,
4687        long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
4688      checkIsInMultiOrPipeline();
4689      return connection.executeCommand(commandObjects.xautoclaim(key, group, consumerName, minIdleTime, start, params));
4690    }
4691    @Override
4692    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt; xautoclaimJustId(String key, String group, String consumerName,
4693        long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
4694      checkIsInMultiOrPipeline();
4695      return connection.executeCommand(commandObjects.xautoclaimJustId(key, group, consumerName, minIdleTime, start, params));
4696    }
4697    @Override
4698    public StreamInfo xinfoStream(String key) {
4699      return connection.executeCommand(commandObjects.xinfoStream(key));
4700    }
4701    @Override
4702    public StreamFullInfo xinfoStreamFull(String key) {
4703      checkIsInMultiOrPipeline();
4704      return connection.executeCommand(commandObjects.xinfoStreamFull(key));
4705    }
4706    @Override
4707    public StreamFullInfo xinfoStreamFull(String key, int count) {
4708      checkIsInMultiOrPipeline();
4709      return connection.executeCommand(commandObjects.xinfoStreamFull(key, count));
4710    }
4711    @Override
4712    public List&lt;StreamGroupInfo&gt; xinfoGroups(String key) {
4713      return connection.executeCommand(commandObjects.xinfoGroups(key));
4714    }
4715    @Override
4716    public List&lt;StreamConsumersInfo&gt; xinfoConsumers(String key, String group) {
4717      return connection.executeCommand(commandObjects.xinfoConsumers(key, group));
4718    }
4719    @Override
4720    public List&lt;StreamConsumerInfo&gt; xinfoConsumers2(String key, String group) {
4721      return connection.executeCommand(commandObjects.xinfoConsumers2(key, group));
4722    }
4723    @Override
4724    public Object fcall(final byte[] name, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
4725      checkIsInMultiOrPipeline();
4726      return connection.executeCommand(commandObjects.fcall(name, keys, args));
4727    }
4728    @Override
4729    public Object fcallReadonly(final byte[] name, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
4730      checkIsInMultiOrPipeline();
4731      return connection.executeCommand(commandObjects.fcallReadonly(name, keys, args));
4732    }
4733    @Override
4734    public String functionDelete(final byte[] libraryName) {
4735      checkIsInMultiOrPipeline();
4736      return connection.executeCommand(commandObjects.functionDelete(libraryName));
4737    }
4738    @Override
4739    public byte[] functionDump() {
4740      checkIsInMultiOrPipeline();
4741      return connection.executeCommand(commandObjects.functionDump());
4742    }
4743    @Override
4744    public List&lt;Object&gt; functionListBinary() {
4745      checkIsInMultiOrPipeline();
4746      return connection.executeCommand(commandObjects.functionListBinary());
4747    }
4748    @Override
4749    public List&lt;Object&gt; functionList(final byte[] libraryNamePattern) {
4750      checkIsInMultiOrPipeline();
4751      return connection.executeCommand(commandObjects.functionList(libraryNamePattern));
4752    }
4753    @Override
4754    public List&lt;Object&gt; functionListWithCodeBinary() {
4755      checkIsInMultiOrPipeline();
4756      return connection.executeCommand(commandObjects.functionListWithCodeBinary());
4757    }
4758    @Override
4759    public List&lt;Object&gt; functionListWithCode(final byte[] libraryNamePattern) {
4760      checkIsInMultiOrPipeline();
4761      return connection.executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
4762    }
4763    @Override
4764    public String functionLoad(final byte[] functionCode) {
4765      checkIsInMultiOrPipeline();
4766      return connection.executeCommand(commandObjects.functionLoad(functionCode));
4767    }
4768    @Override
4769    public String functionLoadReplace(final byte[] functionCode) {
4770      checkIsInMultiOrPipeline();
4771      return connection.executeCommand(commandObjects.functionLoadReplace(functionCode));
4772    }
4773    @Override
4774    public String functionRestore(final byte[] serializedValue) {
4775      checkIsInMultiOrPipeline();
4776      return connection.executeCommand(commandObjects.functionRestore(serializedValue));
4777    }
4778    @Override
4779    public String functionRestore(final byte[] serializedValue, final FunctionRestorePolicy policy) {
4780      checkIsInMultiOrPipeline();
4781      return connection.executeCommand(commandObjects.functionRestore(serializedValue, policy));
4782    }
4783    @Override
4784    public Object functionStatsBinary() {
4785      checkIsInMultiOrPipeline();
4786      return connection.executeCommand(commandObjects.functionStatsBinary());
4787    }
4788    public Object sendCommand(ProtocolCommand cmd, String... args) {
4789      checkIsInMultiOrPipeline();
4790      connection.sendCommand(cmd, args);
4791      return connection.getOne();
4792    }
4793    public Object sendBlockingCommand(ProtocolCommand cmd, String... args) {
4794      checkIsInMultiOrPipeline();
4795      connection.sendCommand(cmd, args);
4796      connection.setTimeoutInfinite();
4797      try {
4798        return connection.getOne();
4799      } finally {
4800        connection.rollbackTimeout();
4801      }
4802    }
4803    private static byte[][] joinParameters(int... params) {
4804      byte[][] result = new byte[params.length][];
4805      for (int i = 0; i &lt; params.length; i++) {
4806        result[i] = toByteArray(params[i]);
4807      }
4808      return result;
4809    }
4810    private static byte[][] joinParameters(byte[] first, byte[][] rest) {
4811      byte[][] result = new byte[rest.length + 1][];
4812      result[0] = first;
4813      System.arraycopy(rest, 0, result, 1, rest.length);
4814      return result;
4815    }
4816    private static byte[][] joinParameters(byte[] first, byte[] second, byte[][] rest) {
4817      byte[][] result = new byte[rest.length + 2][];
4818      result[0] = first;
4819      result[1] = second;
4820      System.arraycopy(rest, 0, result, 2, rest.length);
4821      return result;
4822    }
4823    private static String[] joinParameters(String first, String[] rest) {
4824      String[] result = new String[rest.length + 1];
4825      result[0] = first;
4826      System.arraycopy(rest, 0, result, 1, rest.length);
4827      return result;
4828    }
4829    private static String[] joinParameters(String first, String second, String[] rest) {
4830      String[] result = new String[rest.length + 2];
4831      result[0] = first;
4832      result[1] = second;
4833      System.arraycopy(rest, 0, result, 2, rest.length);
4834      return result;
4835    }
4836  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Jedis.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import static redis.clients.jedis.Protocol.Command.*;
3  import static redis.clients.jedis.Protocol.Keyword.*;
4  import static redis.clients.jedis.Protocol.SentinelKeyword.*;
5  import static redis.clients.jedis.Protocol.toByteArray;
6  import static redis.clients.jedis.util.SafeEncoder.encode;
7  import java.io.Closeable;
8  import java.net.URI;
9  import java.util.Iterator;
10  import java.util.List;
11  import java.util.Map;
12  import java.util.Map.Entry;
13  import java.util.Set;
14  import java.util.stream.Collectors;
15  import javax.net.ssl.HostnameVerifier;
16  import javax.net.ssl.SSLParameters;
17  import javax.net.ssl.SSLSocketFactory;
18  import redis.clients.jedis.Protocol.*;
19  import redis.clients.jedis.args.*;
20  import redis.clients.jedis.commands.*;
21  import redis.clients.jedis.exceptions.InvalidURIException;
22  import redis.clients.jedis.exceptions.JedisConnectionException;
23  import redis.clients.jedis.exceptions.JedisException;
24  import redis.clients.jedis.params.*;
25  import redis.clients.jedis.resps.*;
26  import redis.clients.jedis.util.JedisURIHelper;
27  import redis.clients.jedis.util.KeyValue;
28  import redis.clients.jedis.util.Pool;
29  public class Jedis implements ServerCommands, DatabaseCommands, JedisCommands, JedisBinaryCommands,
30      ControlCommands, ControlBinaryCommands, ClusterCommands, ModuleCommands, GenericControlCommands,
31      SentinelCommands, Closeable {
32    protected final Connection connection;
33    private final CommandObjects commandObjects = new CommandObjects();
34    private int db = 0;
35    private Transaction transaction = null;
36    private boolean isInMulti = false;
37    private boolean isInWatch = false;
38    private Pipeline pipeline = null;
39    protected static final byte[][] DUMMY_ARRAY = new byte[0][];
40    private Pool&lt;Jedis&gt; dataSource = null;
41    public Jedis() {
42      connection = new Connection();
43    }
44    public Jedis(final String url) {
45      this(URI.create(url));
46    }
47    public Jedis(final HostAndPort hp) {
48      connection = new Connection(hp);
49    }
50    public Jedis(final String host, final int port) {
51      connection = new Connection(host, port);
52    }
53    public Jedis(final String host, final int port, final JedisClientConfig config) {
54      this(new HostAndPort(host, port), config);
55    }
56    public Jedis(final HostAndPort hostPort, final JedisClientConfig config) {
57      connection = new Connection(hostPort, config);
58      RedisProtocol proto = config.getRedisProtocol();
59      if (proto != null) commandObjects.setProtocol(proto);
60    }
61    public Jedis(final String host, final int port, final boolean ssl) {
62      this(host, port, DefaultJedisClientConfig.builder().ssl(ssl).build());
63    }
64    public Jedis(final String host, final int port, final boolean ssl,
65        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
66        final HostnameVerifier hostnameVerifier) {
67      this(host, port, DefaultJedisClientConfig.builder().ssl(ssl)
68          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
69          .hostnameVerifier(hostnameVerifier).build());
70    }
71    public Jedis(final String host, final int port, final int timeout) {
72      this(host, port, timeout, timeout);
73    }
74    public Jedis(final String host, final int port, final int timeout, final boolean ssl) {
75      this(host, port, timeout, timeout, ssl);
76    }
77    public Jedis(final String host, final int port, final int timeout, final boolean ssl,
78        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
79        final HostnameVerifier hostnameVerifier) {
80      this(host, port, timeout, timeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);
81    }
82    public Jedis(final String host, final int port, final int connectionTimeout,
83        final int soTimeout) {
84      this(host, port, DefaultJedisClientConfig.builder()
85          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).build());
86    }
87    public Jedis(final String host, final int port, final int connectionTimeout,
88        final int soTimeout, final int infiniteSoTimeout) {
89      this(host, port, DefaultJedisClientConfig.builder()
90          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout)
91          .blockingSocketTimeoutMillis(infiniteSoTimeout).build());
92    }
93    public Jedis(final String host, final int port, final int connectionTimeout,
94        final int soTimeout, final boolean ssl) {
95      this(host, port, DefaultJedisClientConfig.builder()
96          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).ssl(ssl)
97          .build());
98    }
99    public Jedis(final String host, final int port, final int connectionTimeout,
100        final int soTimeout, final boolean ssl, final SSLSocketFactory sslSocketFactory,
101        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
102      this(host, port, DefaultJedisClientConfig.builder()
103          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout).ssl(ssl)
104          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
105          .hostnameVerifier(hostnameVerifier).build());
106    }
107    public Jedis(final String host, final int port, final int connectionTimeout,
108        final int soTimeout, final int infiniteSoTimeout, final boolean ssl,
109        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
110        final HostnameVerifier hostnameVerifier) {
111      this(host, port, DefaultJedisClientConfig.builder()
112          .connectionTimeoutMillis(connectionTimeout).socketTimeoutMillis(soTimeout)
113          .blockingSocketTimeoutMillis(infiniteSoTimeout).ssl(ssl)
114          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
115          .hostnameVerifier(hostnameVerifier).build());
116    }
117    public Jedis(URI uri) {
118      if (!JedisURIHelper.isValid(uri)) {
119        throw new InvalidURIException(String.format(
120          &quot;Cannot open Redis connection due invalid URI \&quot;%s\&quot;.&quot;, uri.toString()));
121      }
122      connection = new Connection(new HostAndPort(uri.getHost(), uri.getPort()),
123          DefaultJedisClientConfig.builder().user(JedisURIHelper.getUser(uri))
124              .password(JedisURIHelper.getPassword(uri)).database(JedisURIHelper.getDBIndex(uri))
125              .protocol(JedisURIHelper.getRedisProtocol(uri))
126              .ssl(JedisURIHelper.isRedisSSLScheme(uri)).build());
127    }
128    public Jedis(URI uri, final SSLSocketFactory sslSocketFactory,
129        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
130      this(uri, DefaultJedisClientConfig.builder().sslSocketFactory(sslSocketFactory)
131          .sslParameters(sslParameters).hostnameVerifier(hostnameVerifier).build());
132    }
133    public Jedis(final URI uri, final int timeout) {
134      this(uri, timeout, timeout);
135    }
136    public Jedis(final URI uri, final int timeout, final SSLSocketFactory sslSocketFactory,
137        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
138      this(uri, timeout, timeout, sslSocketFactory, sslParameters, hostnameVerifier);
139    }
140    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout) {
141      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
142          .socketTimeoutMillis(soTimeout).build());
143    }
144    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout,
145        final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters,
146        final HostnameVerifier hostnameVerifier) {
147      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
148          .socketTimeoutMillis(soTimeout).sslSocketFactory(sslSocketFactory)
149          .sslParameters(sslParameters).hostnameVerifier(hostnameVerifier).build());
150    }
151    public Jedis(final URI uri, final int connectionTimeout, final int soTimeout,
152        final int infiniteSoTimeout, final SSLSocketFactory sslSocketFactory,
153        final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) {
154      this(uri, DefaultJedisClientConfig.builder().connectionTimeoutMillis(connectionTimeout)
155          .socketTimeoutMillis(soTimeout).blockingSocketTimeoutMillis(infiniteSoTimeout)
156          .sslSocketFactory(sslSocketFactory).sslParameters(sslParameters)
157          .hostnameVerifier(hostnameVerifier).build());
158    }
159    public Jedis(final URI uri, JedisClientConfig config) {
160      if (!JedisURIHelper.isValid(uri)) {
161        throw new InvalidURIException(String.format(
162          &quot;Cannot open Redis connection due invalid URI \&quot;%s\&quot;.&quot;, uri.toString()));
163      }
164      connection = new Connection(new HostAndPort(uri.getHost(), uri.getPort()),
165          DefaultJedisClientConfig.builder()
166              .connectionTimeoutMillis(config.getConnectionTimeoutMillis())
167              .socketTimeoutMillis(config.getSocketTimeoutMillis())
168              .blockingSocketTimeoutMillis(config.getBlockingSocketTimeoutMillis())
169              .user(JedisURIHelper.getUser(uri)).password(JedisURIHelper.getPassword(uri))
170              .database(JedisURIHelper.getDBIndex(uri)).clientName(config.getClientName())
171              .protocol(JedisURIHelper.getRedisProtocol(uri))
172              .ssl(JedisURIHelper.isRedisSSLScheme(uri)).sslSocketFactory(config.getSslSocketFactory())
173              .sslParameters(config.getSslParameters()).hostnameVerifier(config.getHostnameVerifier())
174              .build());
175      RedisProtocol proto = config.getRedisProtocol();
176      if (proto != null) commandObjects.setProtocol(proto);
177    }
178    public Jedis(final JedisSocketFactory jedisSocketFactory) {
179      connection = new Connection(jedisSocketFactory);
180    }
181    public Jedis(final JedisSocketFactory jedisSocketFactory, final JedisClientConfig clientConfig) {
182      connection = new Connection(jedisSocketFactory, clientConfig);
183      RedisProtocol proto = clientConfig.getRedisProtocol();
184      if (proto != null) commandObjects.setProtocol(proto);
185    }
186    public Jedis(final Connection connection) {
187      this.connection = connection;
188    }
189    @Override
190    public String toString() {
191      return &quot;Jedis{&quot; + connection + &#x27;}&#x27;;
192    }
193    public Connection getClient() {
194      return getConnection();
195    }
196    public Connection getConnection() {
197      return connection;
198    }
199    public void connect() {
200      connection.connect();
201    }
202    public void disconnect() {
203      connection.disconnect();
204    }
205    public boolean isConnected() {
206      return connection.isConnected();
207    }
208    public boolean isBroken() {
209      return connection.isBroken();
210    }
211    public void resetState() {
212      if (isConnected()) {
213        if (transaction != null) {
214          transaction.close();
215        }
216        if (pipeline != null) {
217          pipeline.close();
218        }
219        if (isInWatch) {
220          connection.sendCommand(UNWATCH);
221          connection.getStatusCodeReply();
222          isInWatch = false;
223        }
224      }
225      transaction = null;
226      pipeline = null;
227    }
228    protected void setDataSource(Pool&lt;Jedis&gt; jedisPool) {
229      this.dataSource = jedisPool;
230    }
231    @Override
232    public void close() {
233      if (dataSource != null) {
234        Pool&lt;Jedis&gt; pool = this.dataSource;
235        this.dataSource = null;
236        if (isBroken()) {
237          pool.returnBrokenResource(this);
238        } else {
239          pool.returnResource(this);
240        }
241      } else {
242        connection.close();
243      }
244    }
245    public Transaction multi() {
246      transaction = new Transaction(this);
247      return transaction;
248    }
249    public Pipeline pipelined() {
250      pipeline = new Pipeline(this);
251      return pipeline;
252    }
253    protected void checkIsInMultiOrPipeline() {
254      if (transaction != null) {
255        throw new IllegalStateException(
256            &quot;Cannot use Jedis when in Multi. Please use Transaction or reset jedis state.&quot;);
257      } else if (pipeline != null &amp;&amp; pipeline.hasPipelinedResponse()) {
258        throw new IllegalStateException(
259            &quot;Cannot use Jedis when in Pipeline. Please use Pipeline or reset jedis state.&quot;);
260      }
261    }
262    public int getDB() {
263      return this.db;
264    }
265    @Override
266    public String ping() {
267      checkIsInMultiOrPipeline();
268      connection.sendCommand(Command.PING);
269      return connection.getStatusCodeReply();
270    }
271    public byte[] ping(final byte[] message) {
272      checkIsInMultiOrPipeline();
273      connection.sendCommand(Command.PING, message);
274      return connection.getBinaryBulkReply();
275    }
276    @Override
277    public String select(final int index) {
278      checkIsInMultiOrPipeline();
279      connection.sendCommand(SELECT, toByteArray(index));
280      String statusCodeReply = connection.getStatusCodeReply();
281      this.db = index;
282      return statusCodeReply;
283    }
284    @Override
285    public String swapDB(final int index1, final int index2) {
286      checkIsInMultiOrPipeline();
287      connection.sendCommand(SWAPDB, toByteArray(index1), toByteArray(index2));
288      return connection.getStatusCodeReply();
289    }
290    @Override
291    public String flushDB() {
292      checkIsInMultiOrPipeline();
293      return connection.executeCommand(commandObjects.flushDB());
294    }
295    @Override
296    public String flushDB(FlushMode flushMode) {
297      checkIsInMultiOrPipeline();
298      connection.sendCommand(FLUSHDB, flushMode.getRaw());
299      return connection.getStatusCodeReply();
300    }
301    @Override
302    public String flushAll() {
303      checkIsInMultiOrPipeline();
304      return connection.executeCommand(commandObjects.flushAll());
305    }
306    @Override
307    public String flushAll(FlushMode flushMode) {
308      checkIsInMultiOrPipeline();
309      connection.sendCommand(FLUSHALL, flushMode.getRaw());
310      return connection.getStatusCodeReply();
311    }
312    @Override
313    public boolean copy(byte[] srcKey, byte[] dstKey, int db, boolean replace) {
314      checkIsInMultiOrPipeline();
315      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, db, replace));
316    }
317    @Override
318    public boolean copy(byte[] srcKey, byte[] dstKey, boolean replace) {
319      checkIsInMultiOrPipeline();
320      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, replace));
321    }
322    @Override
323    public String set(final byte[] key, final byte[] value) {
324      checkIsInMultiOrPipeline();
325      return connection.executeCommand(commandObjects.set(key, value));
326    }
327    @Override
328    public String set(final byte[] key, final byte[] value, final SetParams params) {
329      checkIsInMultiOrPipeline();
330      return connection.executeCommand(commandObjects.set(key, value, params));
331    }
332    @Override
333    public byte[] get(final byte[] key) {
334      checkIsInMultiOrPipeline();
335      return connection.executeCommand(commandObjects.get(key));
336    }
337    @Override
338    public byte[] setGet(final byte[] key, final byte[] value) {
339      checkIsInMultiOrPipeline();
340      return connection.executeCommand(commandObjects.setGet(key, value));
341    }
342    @Override
343    public byte[] setGet(final byte[] key, final byte[] value, final SetParams params) {
344      checkIsInMultiOrPipeline();
345      return connection.executeCommand(commandObjects.setGet(key, value, params));
346    }
347    @Override
348    public byte[] getDel(final byte[] key) {
349      checkIsInMultiOrPipeline();
350      return connection.executeCommand(commandObjects.getDel(key));
351    }
352    @Override
353    public byte[] getEx(final byte[] key, final GetExParams params) {
354      checkIsInMultiOrPipeline();
355      return connection.executeCommand(commandObjects.getEx(key, params));
356    }
357    @Override
358    public long exists(final byte[]... keys) {
359      checkIsInMultiOrPipeline();
360      return connection.executeCommand(commandObjects.exists(keys));
361    }
362    @Override
363    public boolean exists(final byte[] key) {
364      checkIsInMultiOrPipeline();
365      return connection.executeCommand(commandObjects.exists(key));
366    }
367    @Override
368    public long del(final byte[]... keys) {
369      checkIsInMultiOrPipeline();
370      return connection.executeCommand(commandObjects.del(keys));
371    }
372    @Override
373    public long del(final byte[] key) {
374      checkIsInMultiOrPipeline();
375      return connection.executeCommand(commandObjects.del(key));
376    }
377    @Override
378    public long unlink(final byte[]... keys) {
379      checkIsInMultiOrPipeline();
380      return connection.executeCommand(commandObjects.unlink(keys));
381    }
382    @Override
383    public long unlink(final byte[] key) {
384      checkIsInMultiOrPipeline();
385      return connection.executeCommand(commandObjects.unlink(key));
386    }
387    @Override
388    public String type(final byte[] key) {
389      checkIsInMultiOrPipeline();
390      return connection.executeCommand(commandObjects.type(key));
391    }
392    @Override
393    public Set&lt;byte[]&gt; keys(final byte[] pattern) {
394      checkIsInMultiOrPipeline();
395      return connection.executeCommand(commandObjects.keys(pattern));
396    }
397    @Override
398    public byte[] randomBinaryKey() {
399      checkIsInMultiOrPipeline();
400      return connection.executeCommand(commandObjects.randomBinaryKey());
401    }
402    @Override
403    public String rename(final byte[] oldkey, final byte[] newkey) {
404      checkIsInMultiOrPipeline();
405      return connection.executeCommand(commandObjects.rename(oldkey, newkey));
406    }
407    @Override
408    public long renamenx(final byte[] oldkey, final byte[] newkey) {
409      checkIsInMultiOrPipeline();
410      return connection.executeCommand(commandObjects.renamenx(oldkey, newkey));
411    }
412    @Override
413    public long dbSize() {
414      checkIsInMultiOrPipeline();
415      connection.sendCommand(DBSIZE);
416      return connection.getIntegerReply();
417    }
418    @Override
419    public long expire(final byte[] key, final long seconds) {
420      checkIsInMultiOrPipeline();
421      return connection.executeCommand(commandObjects.expire(key, seconds));
422    }
423    @Override
424    public long expire(final byte[] key, final long seconds, final ExpiryOption expiryOption) {
425      checkIsInMultiOrPipeline();
426      return connection.executeCommand((commandObjects.expire(key, seconds, expiryOption)));
427    }
428    @Override
429    public long pexpire(final byte[] key, final long milliseconds) {
430      checkIsInMultiOrPipeline();
431      return connection.executeCommand(commandObjects.pexpire(key, milliseconds));
432    }
433    @Override
434    public long pexpire(final byte[] key, final long milliseconds, final ExpiryOption expiryOption) {
435      checkIsInMultiOrPipeline();
436      return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
437    }
438    @Override
439    public long expireTime(final byte[] key) {
440      checkIsInMultiOrPipeline();
441      return connection.executeCommand((commandObjects.expireTime(key)));
442    }
443    @Override
444    public long pexpireTime(final byte[] key) {
445      checkIsInMultiOrPipeline();
446      return connection.executeCommand(commandObjects.pexpireTime(key));
447    }
448    @Override
449    public long expireAt(final byte[] key, final long unixTime) {
450      checkIsInMultiOrPipeline();
451      return connection.executeCommand(commandObjects.expireAt(key, unixTime));
452    }
453    @Override
454    public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {
455      checkIsInMultiOrPipeline();
456      return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
457    }
458    @Override
459    public long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
460      checkIsInMultiOrPipeline();
461      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
462    }
463    @Override
464    public long pexpireAt(byte[] key, long millisecondsTimestamp, ExpiryOption expiryOption) {
465      checkIsInMultiOrPipeline();
466      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
467    }
468    @Override
469    public long ttl(final byte[] key) {
470      checkIsInMultiOrPipeline();
471      return connection.executeCommand(commandObjects.ttl(key));
472    }
473    @Override
474    public long touch(final byte[]... keys) {
475      checkIsInMultiOrPipeline();
476      return connection.executeCommand(commandObjects.touch(keys));
477    }
478    @Override
479    public long touch(final byte[] key) {
480      checkIsInMultiOrPipeline();
481      return connection.executeCommand(commandObjects.touch(key));
482    }
483    @Override
484    public long move(final byte[] key, final int dbIndex) {
485      checkIsInMultiOrPipeline();
486      connection.sendCommand(MOVE, key, toByteArray(dbIndex));
487      return connection.getIntegerReply();
488    }
489    @Override
490    public byte[] getSet(final byte[] key, final byte[] value) {
491      checkIsInMultiOrPipeline();
492      return connection.executeCommand(commandObjects.getSet(key, value));
493    }
494    @Override
495    public List&lt;byte[]&gt; mget(final byte[]... keys) {
496      checkIsInMultiOrPipeline();
497      return connection.executeCommand(commandObjects.mget(keys));
498    }
499    @Override
500    public long setnx(final byte[] key, final byte[] value) {
501      checkIsInMultiOrPipeline();
502      return connection.executeCommand(commandObjects.setnx(key, value));
503    }
504    @Override
505    public String setex(final byte[] key, final long seconds, final byte[] value) {
506      checkIsInMultiOrPipeline();
507      return connection.executeCommand(commandObjects.setex(key, seconds, value));
508    }
509    @Override
510    public String mset(final byte[]... keysvalues) {
511      checkIsInMultiOrPipeline();
512      return connection.executeCommand(commandObjects.mset(keysvalues));
513    }
514    @Override
515    public long msetnx(final byte[]... keysvalues) {
516      checkIsInMultiOrPipeline();
517      return connection.executeCommand(commandObjects.msetnx(keysvalues));
518    }
519    @Override
520    public long decrBy(final byte[] key, final long decrement) {
521      checkIsInMultiOrPipeline();
522      return connection.executeCommand(commandObjects.decrBy(key, decrement));
523    }
524    @Override
525    public long decr(final byte[] key) {
526      checkIsInMultiOrPipeline();
527      return connection.executeCommand(commandObjects.decr(key));
528    }
529    @Override
530    public long incrBy(final byte[] key, final long increment) {
531      checkIsInMultiOrPipeline();
532      return connection.executeCommand(commandObjects.incrBy(key, increment));
533    }
534    @Override
535    public double incrByFloat(final byte[] key, final double increment) {
536      checkIsInMultiOrPipeline();
537      return connection.executeCommand(commandObjects.incrByFloat(key, increment));
538    }
539    @Override
540    public long incr(final byte[] key) {
541      checkIsInMultiOrPipeline();
542      return connection.executeCommand(commandObjects.incr(key));
543    }
544    @Override
545    public long append(final byte[] key, final byte[] value) {
546      checkIsInMultiOrPipeline();
547      return connection.executeCommand(commandObjects.append(key, value));
548    }
549    @Override
550    public byte[] substr(final byte[] key, final int start, final int end) {
551      checkIsInMultiOrPipeline();
552      return connection.executeCommand(commandObjects.substr(key, start, end));
553    }
554    @Override
555    public long hset(final byte[] key, final byte[] field, final byte[] value) {
556      checkIsInMultiOrPipeline();
557      return connection.executeCommand(commandObjects.hset(key, field, value));
558    }
559    @Override
560    public long hset(final byte[] key, final Map&lt;byte[], byte[]&gt; hash) {
561      checkIsInMultiOrPipeline();
562      return connection.executeCommand(commandObjects.hset(key, hash));
563    }
564    @Override
565    public byte[] hget(final byte[] key, final byte[] field) {
566      checkIsInMultiOrPipeline();
567      return connection.executeCommand(commandObjects.hget(key, field));
568    }
569    @Override
570    public long hsetnx(final byte[] key, final byte[] field, final byte[] value) {
571      checkIsInMultiOrPipeline();
572      return connection.executeCommand(commandObjects.hsetnx(key, field, value));
573    }
574    @Override
575    public String hmset(final byte[] key, final Map&lt;byte[], byte[]&gt; hash) {
576      checkIsInMultiOrPipeline();
577      return connection.executeCommand(commandObjects.hmset(key, hash));
578    }
579    @Override
580    public List&lt;byte[]&gt; hmget(final byte[] key, final byte[]... fields) {
581      checkIsInMultiOrPipeline();
582      return connection.executeCommand(commandObjects.hmget(key, fields));
583    }
584    @Override
585    public long hincrBy(final byte[] key, final byte[] field, final long value) {
586      checkIsInMultiOrPipeline();
587      return connection.executeCommand(commandObjects.hincrBy(key, field, value));
588    }
589    @Override
590    public double hincrByFloat(final byte[] key, final byte[] field, final double value) {
591      checkIsInMultiOrPipeline();
592      return connection.executeCommand(commandObjects.hincrByFloat(key, field, value));
593    }
594    @Override
595    public boolean hexists(final byte[] key, final byte[] field) {
596      checkIsInMultiOrPipeline();
597      return connection.executeCommand(commandObjects.hexists(key, field));
598    }
599    @Override
600    public long hdel(final byte[] key, final byte[]... fields) {
601      checkIsInMultiOrPipeline();
602      return connection.executeCommand(commandObjects.hdel(key, fields));
603    }
604    @Override
605    public long hlen(final byte[] key) {
606      checkIsInMultiOrPipeline();
607      return connection.executeCommand(commandObjects.hlen(key));
608    }
609    @Override
610    public Set&lt;byte[]&gt; hkeys(final byte[] key) {
611      checkIsInMultiOrPipeline();
612      return connection.executeCommand(commandObjects.hkeys(key));
613    }
614    @Override
615    public List&lt;byte[]&gt; hvals(final byte[] key) {
616      checkIsInMultiOrPipeline();
617      return connection.executeCommand(commandObjects.hvals(key));
618    }
619    @Override
620    public Map&lt;byte[], byte[]&gt; hgetAll(final byte[] key) {
621      checkIsInMultiOrPipeline();
622      return connection.executeCommand(commandObjects.hgetAll(key));
623    }
624    @Override
625    public byte[] hrandfield(final byte[] key) {
626      checkIsInMultiOrPipeline();
627      return connection.executeCommand(commandObjects.hrandfield(key));
628    }
629    @Override
630    public List&lt;byte[]&gt; hrandfield(final byte[] key, final long count) {
631      checkIsInMultiOrPipeline();
632      return connection.executeCommand(commandObjects.hrandfield(key, count));
633    }
634    @Override
635    public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hrandfieldWithValues(final byte[] key, final long count) {
636      checkIsInMultiOrPipeline();
637      return connection.executeCommand(commandObjects.hrandfieldWithValues(key, count));
638    }
639    @Override
640    public long rpush(final byte[] key, final byte[]... strings) {
641      checkIsInMultiOrPipeline();
642      return connection.executeCommand(commandObjects.rpush(key, strings));
643    }
644    @Override
645    public long lpush(final byte[] key, final byte[]... strings) {
646      checkIsInMultiOrPipeline();
647      return connection.executeCommand(commandObjects.lpush(key, strings));
648    }
649    @Override
650    public long llen(final byte[] key) {
651      checkIsInMultiOrPipeline();
652      return connection.executeCommand(commandObjects.llen(key));
653    }
654    @Override
655    public List&lt;byte[]&gt; lrange(final byte[] key, final long start, final long stop) {
656      checkIsInMultiOrPipeline();
657      return connection.executeCommand(commandObjects.lrange(key, start, stop));
658    }
659    @Override
660    public String ltrim(final byte[] key, final long start, final long stop) {
661      checkIsInMultiOrPipeline();
662      return connection.executeCommand(commandObjects.ltrim(key, start, stop));
663    }
664    @Override
665    public byte[] lindex(final byte[] key, final long index) {
666      checkIsInMultiOrPipeline();
667      return connection.executeCommand(commandObjects.lindex(key, index));
668    }
669    @Override
670    public String lset(final byte[] key, final long index, final byte[] value) {
671      checkIsInMultiOrPipeline();
672      return connection.executeCommand(commandObjects.lset(key, index, value));
673    }
674    @Override
675    public long lrem(final byte[] key, final long count, final byte[] value) {
676      checkIsInMultiOrPipeline();
677      return connection.executeCommand(commandObjects.lrem(key, count, value));
678    }
679    @Override
680    public byte[] lpop(final byte[] key) {
681      checkIsInMultiOrPipeline();
682      return connection.executeCommand(commandObjects.lpop(key));
683    }
684    @Override
685    public List&lt;byte[]&gt; lpop(final byte[] key, final int count) {
686      checkIsInMultiOrPipeline();
687      return connection.executeCommand(commandObjects.lpop(key, count));
688    }
689    @Override
690    public Long lpos(final byte[] key, final byte[] element) {
691      checkIsInMultiOrPipeline();
692      return connection.executeCommand(commandObjects.lpos(key, element));
693    }
694    @Override
695    public Long lpos(final byte[] key, final byte[] element, final LPosParams params) {
696      checkIsInMultiOrPipeline();
697      return connection.executeCommand(commandObjects.lpos(key, element, params));
698    }
699    @Override
700    public List&lt;Long&gt; lpos(final byte[] key, final byte[] element, final LPosParams params,
701        final long count) {
702      checkIsInMultiOrPipeline();
703      return connection.executeCommand(commandObjects.lpos(key, element, params, count));
704    }
705    @Override
706    public byte[] rpop(final byte[] key) {
707      checkIsInMultiOrPipeline();
708      return connection.executeCommand(commandObjects.rpop(key));
709    }
710    @Override
711    public List&lt;byte[]&gt; rpop(final byte[] key, final int count) {
712      checkIsInMultiOrPipeline();
713      return connection.executeCommand(commandObjects.rpop(key, count));
714    }
715    @Override
716    public byte[] rpoplpush(final byte[] srckey, final byte[] dstkey) {
717      checkIsInMultiOrPipeline();
718      return connection.executeCommand(commandObjects.rpoplpush(srckey, dstkey));
719    }
720    @Override
721    public long sadd(final byte[] key, final byte[]... members) {
722      checkIsInMultiOrPipeline();
723      return connection.executeCommand(commandObjects.sadd(key, members));
724    }
725    @Override
726    public Set&lt;byte[]&gt; smembers(final byte[] key) {
727      checkIsInMultiOrPipeline();
728      return connection.executeCommand(commandObjects.smembers(key));
729    }
730    @Override
731    public long srem(final byte[] key, final byte[]... members) {
732      checkIsInMultiOrPipeline();
733      return connection.executeCommand(commandObjects.srem(key, members));
734    }
735    @Override
736    public byte[] spop(final byte[] key) {
737      checkIsInMultiOrPipeline();
738      return connection.executeCommand(commandObjects.spop(key));
739    }
740    @Override
741    public Set&lt;byte[]&gt; spop(final byte[] key, final long count) {
742      checkIsInMultiOrPipeline();
743      return connection.executeCommand(commandObjects.spop(key, count));
744    }
745    @Override
746    public long smove(final byte[] srckey, final byte[] dstkey, final byte[] member) {
747      checkIsInMultiOrPipeline();
748      return connection.executeCommand(commandObjects.smove(srckey, dstkey, member));
749    }
750    @Override
751    public long scard(final byte[] key) {
752      checkIsInMultiOrPipeline();
753      return connection.executeCommand(commandObjects.scard(key));
754    }
755    @Override
756    public boolean sismember(final byte[] key, final byte[] member) {
757      checkIsInMultiOrPipeline();
758      return connection.executeCommand(commandObjects.sismember(key, member));
759    }
760    @Override
761    public List&lt;Boolean&gt; smismember(final byte[] key, final byte[]... members) {
762      checkIsInMultiOrPipeline();
763      return connection.executeCommand(commandObjects.smismember(key, members));
764    }
765    @Override
766    public Set&lt;byte[]&gt; sinter(final byte[]... keys) {
767      checkIsInMultiOrPipeline();
768      return connection.executeCommand(commandObjects.sinter(keys));
769    }
770    @Override
771    public long sinterstore(final byte[] dstkey, final byte[]... keys) {
772      checkIsInMultiOrPipeline();
773      return connection.executeCommand(commandObjects.sinterstore(dstkey, keys));
774    }
775    @Override
776    public long sintercard(byte[]... keys) {
777      checkIsInMultiOrPipeline();
778      return connection.executeCommand(commandObjects.sintercard(keys));
779    }
780    @Override
781    public long sintercard(int limit, byte[]... keys) {
782      checkIsInMultiOrPipeline();
783      return connection.executeCommand(commandObjects.sintercard(limit, keys));
784    }
785    @Override
786    public Set&lt;byte[]&gt; sunion(final byte[]... keys) {
787      checkIsInMultiOrPipeline();
788      return connection.executeCommand(commandObjects.sunion(keys));
789    }
790    @Override
791    public long sunionstore(final byte[] dstkey, final byte[]... keys) {
792      checkIsInMultiOrPipeline();
793      return connection.executeCommand(commandObjects.sunionstore(dstkey, keys));
794    }
795    @Override
796    public Set&lt;byte[]&gt; sdiff(final byte[]... keys) {
797      checkIsInMultiOrPipeline();
798      return connection.executeCommand(commandObjects.sdiff(keys));
799    }
800    @Override
801    public long sdiffstore(final byte[] dstkey, final byte[]... keys) {
802      checkIsInMultiOrPipeline();
803      return connection.executeCommand(commandObjects.sdiffstore(dstkey, keys));
804    }
805    @Override
806    public byte[] srandmember(final byte[] key) {
807      checkIsInMultiOrPipeline();
808      return connection.executeCommand(commandObjects.srandmember(key));
809    }
810    @Override
811    public List&lt;byte[]&gt; srandmember(final byte[] key, final int count) {
812      checkIsInMultiOrPipeline();
813      return connection.executeCommand(commandObjects.srandmember(key, count));
814    }
815    @Override
816    public long zadd(final byte[] key, final double score, final byte[] member) {
817      checkIsInMultiOrPipeline();
818      return connection.executeCommand(commandObjects.zadd(key, score, member));
819    }
820    @Override
821    public long zadd(final byte[] key, final double score, final byte[] member,
822        final ZAddParams params) {
823      checkIsInMultiOrPipeline();
824      return connection.executeCommand(commandObjects.zadd(key, score, member, params));
825    }
826    @Override
827    public long zadd(final byte[] key, final Map&lt;byte[], Double&gt; scoreMembers) {
828      checkIsInMultiOrPipeline();
829      return connection.executeCommand(commandObjects.zadd(key, scoreMembers));
830    }
831    @Override
832    public long zadd(final byte[] key, final Map&lt;byte[], Double&gt; scoreMembers, final ZAddParams params) {
833      checkIsInMultiOrPipeline();
834      return connection.executeCommand(commandObjects.zadd(key, scoreMembers, params));
835    }
836    @Override
837    public Double zaddIncr(final byte[] key, final double score, final byte[] member, final ZAddParams params) {
838      checkIsInMultiOrPipeline();
839      return connection.executeCommand(commandObjects.zaddIncr(key, score, member, params));
840    }
841    @Override
842    public List&lt;byte[]&gt; zrange(final byte[] key, final long start, final long stop) {
843      checkIsInMultiOrPipeline();
844      return connection.executeCommand(commandObjects.zrange(key, start, stop));
845    }
846    @Override
847    public long zrem(final byte[] key, final byte[]... members) {
848      checkIsInMultiOrPipeline();
849      return connection.executeCommand(commandObjects.zrem(key, members));
850    }
851    @Override
852    public double zincrby(final byte[] key, final double increment, final byte[] member) {
853      checkIsInMultiOrPipeline();
854      return connection.executeCommand(commandObjects.zincrby(key, increment, member));
855    }
856    @Override
857    public Double zincrby(final byte[] key, final double increment, final byte[] member,
858        final ZIncrByParams params) {
859      checkIsInMultiOrPipeline();
860      return connection.executeCommand(commandObjects.zincrby(key, increment, member, params));
861    }
862    @Override
863    public Long zrank(final byte[] key, final byte[] member) {
864      checkIsInMultiOrPipeline();
865      return connection.executeCommand(commandObjects.zrank(key, member));
866    }
867    @Override
868    public Long zrevrank(final byte[] key, final byte[] member) {
869      checkIsInMultiOrPipeline();
870      return connection.executeCommand(commandObjects.zrevrank(key, member));
871    }
872    @Override
873    public KeyValue&lt;Long, Double&gt; zrankWithScore(byte[] key, byte[] member) {
874      checkIsInMultiOrPipeline();
875      return connection.executeCommand(commandObjects.zrankWithScore(key, member));
876    }
877    @Override
878    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(byte[] key, byte[] member) {
879      checkIsInMultiOrPipeline();
880      return connection.executeCommand(commandObjects.zrevrankWithScore(key, member));
881    }
882    @Override
883    public List&lt;byte[]&gt; zrevrange(final byte[] key, final long start, final long stop) {
884      checkIsInMultiOrPipeline();
885      return connection.executeCommand(commandObjects.zrevrange(key, start, stop));
886    }
887    @Override
888    public List&lt;Tuple&gt; zrangeWithScores(final byte[] key, final long start, final long stop) {
889      checkIsInMultiOrPipeline();
890      return connection.executeCommand(commandObjects.zrangeWithScores(key, start, stop));
891    }
892    @Override
893    public List&lt;Tuple&gt; zrevrangeWithScores(final byte[] key, final long start, final long stop) {
894      checkIsInMultiOrPipeline();
895      return connection.executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
896    }
897    @Override
898    public List&lt;byte[]&gt; zrange(byte[] key, ZRangeParams zRangeParams) {
899      checkIsInMultiOrPipeline();
900      return connection.executeCommand(commandObjects.zrange(key, zRangeParams));
901    }
902    @Override
903    public List&lt;Tuple&gt; zrangeWithScores(byte[] key, ZRangeParams zRangeParams) {
904      checkIsInMultiOrPipeline();
905      return connection.executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
906    }
907    @Override
908    public long zrangestore(byte[] dest, byte[] src, ZRangeParams zRangeParams) {
909      checkIsInMultiOrPipeline();
910      return connection.executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
911    }
912    @Override
<span onclick='openModal()' class='match'>913    public byte[] zrandmember(final byte[] key) {
914      checkIsInMultiOrPipeline();
915      return connection.executeCommand(commandObjects.zrandmember(key));
</span>916    }
917    @Override
918    public List&lt;byte[]&gt; zrandmember(final byte[] key, final long count) {
919      checkIsInMultiOrPipeline();
920      return connection.executeCommand(commandObjects.zrandmember(key, count));
921    }
922    @Override
923    public List&lt;Tuple&gt; zrandmemberWithScores(final byte[] key, final long count) {
924      checkIsInMultiOrPipeline();
925      return connection.executeCommand(commandObjects.zrandmemberWithScores(key, count));
926    }
927    @Override
928    public long zcard(final byte[] key) {
929      checkIsInMultiOrPipeline();
930      return connection.executeCommand(commandObjects.zcard(key));
931    }
932    @Override
933    public Double zscore(final byte[] key, final byte[] member) {
934      checkIsInMultiOrPipeline();
935      return connection.executeCommand(commandObjects.zscore(key, member));
936    }
937    @Override
938    public List&lt;Double&gt; zmscore(final byte[] key, final byte[]... members) {
939      checkIsInMultiOrPipeline();
940      return connection.executeCommand(commandObjects.zmscore(key, members));
941    }
942    @Override
943    public Tuple zpopmax(final byte[] key) {
944      checkIsInMultiOrPipeline();
945      return connection.executeCommand(commandObjects.zpopmax(key));
946    }
947    @Override
948    public List&lt;Tuple&gt; zpopmax(final byte[] key, final int count) {
949      checkIsInMultiOrPipeline();
950      return connection.executeCommand(commandObjects.zpopmax(key, count));
951    }
952    @Override
953    public Tuple zpopmin(final byte[] key) {
954      checkIsInMultiOrPipeline();
955      return connection.executeCommand(commandObjects.zpopmin(key));
956    }
957    @Override
958    public List&lt;Tuple&gt; zpopmin(final byte[] key, final int count) {
959      checkIsInMultiOrPipeline();
960      return connection.executeCommand(commandObjects.zpopmin(key, count));
961    }
962    public String watch(final byte[]... keys) {
963      checkIsInMultiOrPipeline();
964      connection.sendCommand(WATCH, keys);
965      String status = connection.getStatusCodeReply();
966      isInWatch = true;
967      return status;
968    }
969    public String unwatch() {
970      checkIsInMultiOrPipeline();
971      connection.sendCommand(UNWATCH);
972      return connection.getStatusCodeReply();
973    }
974    @Override
975    public List&lt;byte[]&gt; sort(final byte[] key) {
976      checkIsInMultiOrPipeline();
977      return connection.executeCommand(commandObjects.sort(key));
978    }
979    @Override
980    public List&lt;byte[]&gt; sort(final byte[] key, final SortingParams sortingParams) {
981      checkIsInMultiOrPipeline();
982      return connection.executeCommand(commandObjects.sort(key, sortingParams));
983    }
984    @Override
985    public long sort(final byte[] key, final SortingParams sortingParams, final byte[] dstkey) {
986      checkIsInMultiOrPipeline();
987      return connection.executeCommand(commandObjects.sort(key, sortingParams, dstkey));
988    }
989    @Override
990    public long sort(final byte[] key, final byte[] dstkey) {
991      checkIsInMultiOrPipeline();
992      return connection.executeCommand(commandObjects.sort(key, dstkey));
993    }
994    @Override
995    public List&lt;byte[]&gt; sortReadonly(byte[] key, SortingParams sortingParams) {
996      checkIsInMultiOrPipeline();
997      return connection.executeCommand(commandObjects.sortReadonly(key, sortingParams));
998    }
999    @Override
1000    public byte[] lmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to) {
1001      checkIsInMultiOrPipeline();
1002      return connection.executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
1003    }
1004    @Override
1005    public byte[] blmove(byte[] srcKey, byte[] dstKey, ListDirection from, ListDirection to, double timeout) {
1006      checkIsInMultiOrPipeline();
1007      return connection.executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
1008    }
1009    @Override
1010    public List&lt;byte[]&gt; blpop(final int timeout, final byte[]... keys) {
1011      return connection.executeCommand(commandObjects.blpop(timeout, keys));
1012    }
1013    @Override
1014    public KeyValue&lt;byte[], byte[]&gt; blpop(final double timeout, final byte[]... keys) {
1015      return connection.executeCommand(commandObjects.blpop(timeout, keys));
1016    }
1017    @Override
1018    public List&lt;byte[]&gt; brpop(final int timeout, final byte[]... keys) {
1019      return connection.executeCommand(commandObjects.brpop(timeout, keys));
1020    }
1021    @Override
1022    public KeyValue&lt;byte[], byte[]&gt; brpop(final double timeout, final byte[]... keys) {
1023      return connection.executeCommand(commandObjects.brpop(timeout, keys));
1024    }
1025    @Override
1026    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, byte[]... keys) {
1027      checkIsInMultiOrPipeline();
1028      return connection.executeCommand(commandObjects.lmpop(direction, keys));
1029    }
1030    @Override
1031    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; lmpop(ListDirection direction, int count, byte[]... keys) {
1032      checkIsInMultiOrPipeline();
1033      return connection.executeCommand(commandObjects.lmpop(direction, count, keys));
1034    }
1035    @Override
1036    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, byte[]... keys) {
1037      checkIsInMultiOrPipeline();
1038      return connection.executeCommand(commandObjects.blmpop(timeout, direction, keys));
1039    }
1040    @Override
1041    public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; blmpop(double timeout, ListDirection direction, int count, byte[]... keys) {
1042      checkIsInMultiOrPipeline();
1043      return connection.executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
1044    }
1045    @Override
1046    public KeyValue&lt;byte[], Tuple&gt; bzpopmax(final double timeout, final byte[]... keys) {
1047      return connection.executeCommand(commandObjects.bzpopmax(timeout, keys));
1048    }
1049    @Override
1050    public KeyValue&lt;byte[], Tuple&gt; bzpopmin(final double timeout, final byte[]... keys) {
1051      return connection.executeCommand(commandObjects.bzpopmin(timeout, keys));
1052    }
1053    @Override
1054    public String auth(final String password) {
1055      checkIsInMultiOrPipeline();
1056      connection.sendCommand(Command.AUTH, password);
1057      return connection.getStatusCodeReply();
1058    }
1059    @Override
1060    public String auth(final String user, final String password) {
1061      checkIsInMultiOrPipeline();
1062      connection.sendCommand(Command.AUTH, user, password);
1063      return connection.getStatusCodeReply();
1064    }
1065    @Override
1066    public long zcount(final byte[] key, final double min, final double max) {
1067      checkIsInMultiOrPipeline();
1068      return connection.executeCommand(commandObjects.zcount(key, min, max));
1069    }
1070    @Override
1071    public long zcount(final byte[] key, final byte[] min, final byte[] max) {
1072      checkIsInMultiOrPipeline();
1073      return connection.executeCommand(commandObjects.zcount(key, min, max));
1074    }
1075    @Override
1076    public List&lt;byte[]&gt; zdiff(final byte[]... keys) {
1077      checkIsInMultiOrPipeline();
1078      return connection.executeCommand(commandObjects.zdiff(keys));
1079    }
1080    @Override
1081    public List&lt;Tuple&gt; zdiffWithScores(final byte[]... keys) {
1082      checkIsInMultiOrPipeline();
1083      return connection.executeCommand(commandObjects.zdiffWithScores(keys));
1084    }
1085    @Override
1086    @Deprecated
1087    public long zdiffStore(final byte[] dstkey, final byte[]... keys) {
1088      checkIsInMultiOrPipeline();
1089      return connection.executeCommand(commandObjects.zdiffStore(dstkey, keys));
1090    }
1091    @Override
1092    public long zdiffstore(final byte[] dstkey, final byte[]... keys) {
1093      checkIsInMultiOrPipeline();
1094      return connection.executeCommand(commandObjects.zdiffstore(dstkey, keys));
1095    }
1096    @Override
1097    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final double min, final double max) {
1098      checkIsInMultiOrPipeline();
1099      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
1100    }
1101    @Override
1102    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
1103      checkIsInMultiOrPipeline();
1104      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
1105    }
1106    @Override
1107    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final double min, final double max,
1108        final int offset, final int count) {
1109      checkIsInMultiOrPipeline();
1110      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1111    }
1112    @Override
1113    public List&lt;byte[]&gt; zrangeByScore(final byte[] key, final byte[] min, final byte[] max,
1114        final int offset, final int count) {
1115      checkIsInMultiOrPipeline();
1116      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
1117    }
1118    @Override
1119    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
1120      checkIsInMultiOrPipeline();
1121      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1122    }
1123    @Override
1124    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
1125      checkIsInMultiOrPipeline();
1126      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
1127    }
1128    @Override
1129    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final double min, final double max,
1130        final int offset, final int count) {
1131      checkIsInMultiOrPipeline();
1132      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1133    }
1134    @Override
1135    public List&lt;Tuple&gt; zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
1136        final int offset, final int count) {
1137      checkIsInMultiOrPipeline();
1138      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
1139    }
1140    @Override
1141    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final double max, final double min) {
1142      checkIsInMultiOrPipeline();
1143      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1144    }
1145    @Override
1146    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
1147      checkIsInMultiOrPipeline();
1148      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
1149    }
1150    @Override
1151    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final double max, final double min,
1152        final int offset, final int count) {
1153      checkIsInMultiOrPipeline();
1154      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1155    }
1156    @Override
1157    public List&lt;byte[]&gt; zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
1158        final int offset, final int count) {
1159      checkIsInMultiOrPipeline();
1160      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
1161    }
1162    @Override
1163    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
1164      checkIsInMultiOrPipeline();
1165      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1166    }
1167    @Override
1168    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final double max,
1169        final double min, final int offset, final int count) {
1170      checkIsInMultiOrPipeline();
1171      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1172    }
1173    @Override
1174    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
1175      checkIsInMultiOrPipeline();
1176      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
1177    }
1178    @Override
1179    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
1180        final byte[] min, final int offset, final int count) {
1181      checkIsInMultiOrPipeline();
1182      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
1183    }
1184    @Override
1185    public long zremrangeByRank(final byte[] key, final long start, final long stop) {
1186      checkIsInMultiOrPipeline();
1187      return connection.executeCommand(commandObjects.zremrangeByRank(key, start, stop));
1188    }
1189    @Override
1190    public long zremrangeByScore(final byte[] key, final double min, final double max) {
1191      checkIsInMultiOrPipeline();
1192      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
1193    }
1194    @Override
1195    public long zremrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
1196      checkIsInMultiOrPipeline();
1197      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
1198    }
1199    @Override
1200    public List&lt;byte[]&gt; zunion(final ZParams params, final byte[]... keys) {
1201      checkIsInMultiOrPipeline();
1202      return connection.executeCommand(commandObjects.zunion(params, keys));
1203    }
1204    @Override
1205    public List&lt;Tuple&gt; zunionWithScores(final ZParams params, final byte[]... keys) {
1206      checkIsInMultiOrPipeline();
1207      return connection.executeCommand(commandObjects.zunionWithScores(params, keys));
1208    }
1209    @Override
1210    public long zunionstore(final byte[] dstkey, final byte[]... sets) {
1211      checkIsInMultiOrPipeline();
1212      return connection.executeCommand(commandObjects.zunionstore(dstkey, sets));
1213    }
1214    @Override
1215    public long zunionstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
1216      checkIsInMultiOrPipeline();
1217      return connection.executeCommand(commandObjects.zunionstore(dstkey, params, sets));
1218    }
1219    @Override
1220    public List&lt;byte[]&gt; zinter(final ZParams params, final byte[]... keys) {
1221      checkIsInMultiOrPipeline();
1222      return connection.executeCommand(commandObjects.zinter(params, keys));
1223    }
1224    @Override
1225    public List&lt;Tuple&gt; zinterWithScores(final ZParams params, final byte[]... keys) {
1226      checkIsInMultiOrPipeline();
1227      return connection.executeCommand(commandObjects.zinterWithScores(params, keys));
1228    }
1229    @Override
1230    public long zinterstore(final byte[] dstkey, final byte[]... sets) {
1231      checkIsInMultiOrPipeline();
1232      return connection.executeCommand(commandObjects.zinterstore(dstkey, sets));
1233    }
1234    @Override
1235    public long zinterstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
1236      checkIsInMultiOrPipeline();
1237      return connection.executeCommand(commandObjects.zinterstore(dstkey, params, sets));
1238    }
1239    @Override
1240    public long zintercard(byte[]... keys) {
1241      checkIsInMultiOrPipeline();
1242      return connection.executeCommand(commandObjects.zintercard(keys));
1243    }
1244    @Override
1245    public long zintercard(long limit, byte[]... keys) {
1246      checkIsInMultiOrPipeline();
1247      return connection.executeCommand(commandObjects.zintercard(limit, keys));
1248    }
1249    @Override
1250    public long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
1251      checkIsInMultiOrPipeline();
1252      return connection.executeCommand(commandObjects.zlexcount(key, min, max));
1253    }
1254    @Override
1255    public List&lt;byte[]&gt; zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
1256      checkIsInMultiOrPipeline();
1257      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max));
1258    }
1259    @Override
1260    public List&lt;byte[]&gt; zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
1261        final int offset, final int count) {
1262      checkIsInMultiOrPipeline();
1263      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
1264    }
1265    @Override
1266    public List&lt;byte[]&gt; zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min) {
1267      checkIsInMultiOrPipeline();
1268      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min));
1269    }
1270    @Override
1271    public List&lt;byte[]&gt; zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
1272        final int offset, final int count) {
1273      checkIsInMultiOrPipeline();
1274      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
1275    }
1276    @Override
1277    public long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
1278      checkIsInMultiOrPipeline();
1279      return connection.executeCommand(commandObjects.zremrangeByLex(key, min, max));
1280    }
1281    @Override
1282    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, byte[]... keys) {
1283      checkIsInMultiOrPipeline();
1284      return connection.executeCommand(commandObjects.zmpop(option, keys));
1285    }
1286    @Override
1287    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, byte[]... keys) {
1288      checkIsInMultiOrPipeline();
1289      return connection.executeCommand(commandObjects.zmpop(option, count, keys));
1290    }
1291    @Override
1292    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, byte[]... keys) {
1293      checkIsInMultiOrPipeline();
1294      return connection.executeCommand(commandObjects.bzmpop(timeout, option, keys));
1295    }
1296    @Override
1297    public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, byte[]... keys) {
1298      checkIsInMultiOrPipeline();
1299      return connection.executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
1300    }
1301    @Override
1302    public String save() {
1303      connection.sendCommand(Command.SAVE);
1304      return connection.getStatusCodeReply();
1305    }
1306    @Override
1307    public String bgsave() {
1308      connection.sendCommand(BGSAVE);
1309      return connection.getStatusCodeReply();
1310    }
1311    @Override
1312    public String bgsaveSchedule() {
1313      connection.sendCommand(BGSAVE, SCHEDULE);
1314      return connection.getStatusCodeReply();
1315    }
1316    @Override
1317    public String bgrewriteaof() {
1318      connection.sendCommand(BGREWRITEAOF);
1319      return connection.getStatusCodeReply();
1320    }
1321    @Override
1322    public long lastsave() {
1323      connection.sendCommand(LASTSAVE);
1324      return connection.getIntegerReply();
1325    }
1326    @Override
1327    public void shutdown() throws JedisException {
1328      connection.sendCommand(SHUTDOWN);
1329      try {
1330        throw new JedisException(connection.getStatusCodeReply());
1331      } catch (JedisConnectionException jce) {
1332        connection.setBroken();
1333      }
1334    }
1335    @Override
1336    public void shutdown(ShutdownParams shutdownParams) throws JedisException {
1337      connection.sendCommand(new CommandArguments(SHUTDOWN).addParams(shutdownParams));
1338      try {
1339        throw new JedisException(connection.getStatusCodeReply());
1340      } catch (JedisConnectionException jce) {
1341        connection.setBroken();
1342      }
1343    }
1344    @Override
1345    public String shutdownAbort() {
1346      connection.sendCommand(SHUTDOWN, ABORT);
1347      return connection.getStatusCodeReply();
1348    }
1349    @Override
1350    public String info() {
1351      connection.sendCommand(Command.INFO);
1352      return connection.getBulkReply();
1353    }
1354    @Override
1355    public String info(final String section) {
1356      connection.sendCommand(Command.INFO, section);
1357      return connection.getBulkReply();
1358    }
1359    public void monitor(final JedisMonitor jedisMonitor) {
1360      connection.sendCommand(Command.MONITOR);
1361      connection.getStatusCodeReply();
1362      jedisMonitor.proceed(connection);
1363    }
1364    @Override
1365    @Deprecated
1366    public String slaveof(final String host, final int port) {
1367      connection.sendCommand(SLAVEOF, encode(host), toByteArray(port));
1368      return connection.getStatusCodeReply();
1369    }
1370    @Override
1371    @Deprecated
1372    public String slaveofNoOne() {
1373      connection.sendCommand(SLAVEOF, NO.getRaw(), ONE.getRaw());
1374      return connection.getStatusCodeReply();
1375    }
1376    @Override
1377    public String replicaof(final String host, final int port) {
1378      connection.sendCommand(REPLICAOF, encode(host), toByteArray(port));
1379      return connection.getStatusCodeReply();
1380    }
1381    @Override
1382    public String replicaofNoOne() {
1383      connection.sendCommand(REPLICAOF, NO.getRaw(), ONE.getRaw());
1384      return connection.getStatusCodeReply();
1385    }
1386    @Override
1387    public List&lt;Object&gt; roleBinary() {
1388      checkIsInMultiOrPipeline();
1389      connection.sendCommand(ROLE);
1390      return BuilderFactory.RAW_OBJECT_LIST.build(connection.getOne());
1391    }
1392    @Override
1393    public Map&lt;byte[], byte[]&gt; configGet(final byte[] pattern) {
1394      checkIsInMultiOrPipeline();
1395      connection.sendCommand(Command.CONFIG, Keyword.GET.getRaw(), pattern);
1396      return BuilderFactory.BINARY_MAP.build(connection.getOne());
1397    }
1398    @Override
1399    public Map&lt;byte[], byte[]&gt; configGet(byte[]... patterns) {
1400      checkIsInMultiOrPipeline();
1401      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.GET.getRaw(), patterns));
1402      return BuilderFactory.BINARY_MAP.build(connection.getOne());
1403    }
1404    @Override
1405    public String configResetStat() {
1406      checkIsInMultiOrPipeline();
1407      connection.sendCommand(Command.CONFIG, Keyword.RESETSTAT);
1408      return connection.getStatusCodeReply();
1409    }
1410    @Override
1411    public String configRewrite() {
1412      checkIsInMultiOrPipeline();
1413      connection.sendCommand(Command.CONFIG, Keyword.REWRITE);
1414      return connection.getStatusCodeReply();
1415    }
1416    @Override
1417    public String configSet(final byte[] parameter, final byte[] value) {
1418      checkIsInMultiOrPipeline();
1419      connection.sendCommand(Command.CONFIG, Keyword.SET.getRaw(), parameter, value);
1420      return connection.getStatusCodeReply();
1421    }
1422    @Override
1423    public String configSet(final byte[]... parameterValues) {
1424      checkIsInMultiOrPipeline();
1425      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.SET.getRaw(), parameterValues));
1426      return connection.getStatusCodeReply();
1427    }
1428    @Override
1429    public String configSetBinary(Map&lt;byte[], byte[]&gt; parameterValues) {
1430      checkIsInMultiOrPipeline();
1431      CommandArguments args = new CommandArguments(Command.CONFIG).add(Keyword.SET);
1432      parameterValues.forEach((k, v) -&gt; args.add(k).add(v));
1433      connection.sendCommand(args);
1434      return connection.getStatusCodeReply();
1435    }
1436    @Override
1437    public long strlen(final byte[] key) {
1438      checkIsInMultiOrPipeline();
1439      return connection.executeCommand(commandObjects.strlen(key));
1440    }
1441    @Override
1442    public LCSMatchResult lcs(final byte[] keyA, final byte[] keyB, final LCSParams params) {
1443      checkIsInMultiOrPipeline();
1444      return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));
1445    }
1446    @Override
1447    public long lpushx(final byte[] key, final byte[]... strings) {
1448      checkIsInMultiOrPipeline();
1449      return connection.executeCommand(commandObjects.lpushx(key, strings));
1450    }
1451    @Override
1452    public long persist(final byte[] key) {
1453      checkIsInMultiOrPipeline();
1454      return connection.executeCommand(commandObjects.persist(key));
1455    }
1456    @Override
1457    public long rpushx(final byte[] key, final byte[]... strings) {
1458      checkIsInMultiOrPipeline();
1459      return connection.executeCommand(commandObjects.rpushx(key, strings));
1460    }
1461    @Override
1462    public byte[] echo(final byte[] string) {
1463      checkIsInMultiOrPipeline();
1464      connection.sendCommand(ECHO, string);
1465      return connection.getBinaryBulkReply();
1466    }
1467    @Override
1468    public long linsert(final byte[] key, final ListPosition where, final byte[] pivot,
1469        final byte[] value) {
1470      checkIsInMultiOrPipeline();
1471      return connection.executeCommand(commandObjects.linsert(key, where, pivot, value));
1472    }
1473    @Override
1474    public byte[] brpoplpush(final byte[] source, final byte[] destination, final int timeout) {
1475      checkIsInMultiOrPipeline();
1476      return connection.executeCommand(commandObjects.brpoplpush(source, destination, timeout));
1477    }
1478    @Override
1479    public boolean setbit(final byte[] key, final long offset, final boolean value) {
1480      checkIsInMultiOrPipeline();
1481      return connection.executeCommand(commandObjects.setbit(key, offset, value));
1482    }
1483    @Override
1484    public boolean getbit(final byte[] key, final long offset) {
1485      checkIsInMultiOrPipeline();
1486      return connection.executeCommand(commandObjects.getbit(key, offset));
1487    }
1488    @Override
1489    public long bitpos(final byte[] key, final boolean value) {
1490      return bitpos(key, value, new BitPosParams());
1491    }
1492    @Override
1493    public long bitpos(final byte[] key, final boolean value, final BitPosParams params) {
1494      checkIsInMultiOrPipeline();
1495      return connection.executeCommand(commandObjects.bitpos(key, value, params));
1496    }
1497    @Override
1498    public long setrange(final byte[] key, final long offset, final byte[] value) {
1499      checkIsInMultiOrPipeline();
1500      return connection.executeCommand(commandObjects.setrange(key, offset, value));
1501    }
1502    @Override
1503    public byte[] getrange(final byte[] key, final long startOffset, final long endOffset) {
1504      checkIsInMultiOrPipeline();
1505      return connection.executeCommand(commandObjects.getrange(key, startOffset, endOffset));
1506    }
1507    public long publish(final byte[] channel, final byte[] message) {
1508      checkIsInMultiOrPipeline();
1509      return connection.executeCommand(commandObjects.publish(channel, message));
1510    }
1511    public void subscribe(BinaryJedisPubSub jedisPubSub, final byte[]... channels) {
1512      jedisPubSub.proceed(connection, channels);
1513    }
1514    public void psubscribe(BinaryJedisPubSub jedisPubSub, final byte[]... patterns) {
1515      jedisPubSub.proceedWithPatterns(connection, patterns);
1516    }
1517    @Override
1518    public Object eval(final byte[] script, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
1519      checkIsInMultiOrPipeline();
1520      return connection.executeCommand(commandObjects.eval(script, keys, args));
1521    }
1522    @Override
1523    public Object evalReadonly(byte[] script, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1524      checkIsInMultiOrPipeline();
1525      return connection.executeCommand(commandObjects.evalReadonly(script, keys, args));
1526    }
1527    protected static byte[][] getParamsWithBinary(List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1528      final int keyCount = keys.size();
1529      final int argCount = args.size();
1530      byte[][] params = new byte[keyCount + argCount][];
1531      for (int i = 0; i &lt; keyCount; i++)
1532        params[i] = keys.get(i);
1533      for (int i = 0; i &lt; argCount; i++)
1534        params[keyCount + i] = args.get(i);
1535      return params;
1536    }
1537    @Override
1538    public Object eval(final byte[] script, final int keyCount, final byte[]... params) {
1539      checkIsInMultiOrPipeline();
1540      return connection.executeCommand(commandObjects.eval(script, keyCount, params));
1541    }
1542    @Override
1543    public Object eval(final byte[] script) {
1544      checkIsInMultiOrPipeline();
1545      return connection.executeCommand(commandObjects.eval(script));
1546    }
1547    @Override
1548    public Object evalsha(final byte[] sha1) {
1549      checkIsInMultiOrPipeline();
1550      return connection.executeCommand(commandObjects.evalsha(sha1));
1551    }
1552    @Override
1553    public Object evalsha(final byte[] sha1, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
1554      checkIsInMultiOrPipeline();
1555      return connection.executeCommand(commandObjects.evalsha(sha1, keys, args));
1556    }
1557    @Override
1558    public Object evalshaReadonly(byte[] sha1, List&lt;byte[]&gt; keys, List&lt;byte[]&gt; args) {
1559      checkIsInMultiOrPipeline();
1560      return connection.executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
1561    }
1562    @Override
1563    public Object evalsha(final byte[] sha1, final int keyCount, final byte[]... params) {
1564      checkIsInMultiOrPipeline();
1565      return connection.executeCommand(commandObjects.evalsha(sha1, keyCount, params));
1566    }
1567    @Override
1568    public String scriptFlush() {
1569      connection.sendCommand(SCRIPT, FLUSH);
1570      return connection.getStatusCodeReply();
1571    }
1572    @Override
1573    public String scriptFlush(final FlushMode flushMode) {
1574      connection.sendCommand(SCRIPT, FLUSH.getRaw(), flushMode.getRaw());
1575      return connection.getStatusCodeReply();
1576    }
1577    @Override
1578    public Boolean scriptExists(final byte[] sha1) {
1579      byte[][] a = new byte[1][];
1580      a[0] = sha1;
1581      return scriptExists(a).get(0);
1582    }
1583    @Override
1584    public List&lt;Boolean&gt; scriptExists(final byte[]... sha1) {
1585      connection.sendCommand(SCRIPT, joinParameters(Keyword.EXISTS.getRaw(), sha1));
1586      return BuilderFactory.BOOLEAN_LIST.build(connection.getOne());
1587    }
1588    @Override
1589    public byte[] scriptLoad(final byte[] script) {
1590      connection.sendCommand(SCRIPT, LOAD.getRaw(), script);
1591      return connection.getBinaryBulkReply();
1592    }
1593    @Override
1594    public String scriptKill() {
1595      return connection.executeCommand(commandObjects.scriptKill());
1596    }
1597    @Override
1598    public String slowlogReset() {
1599      return connection.executeCommand(commandObjects.slowlogReset());
1600    }
1601    @Override
1602    public long slowlogLen() {
1603      connection.sendCommand(SLOWLOG, LEN);
1604      return connection.getIntegerReply();
1605    }
1606    @Override
1607    public List&lt;Object&gt; slowlogGetBinary() {
1608      connection.sendCommand(SLOWLOG, Keyword.GET);
1609      return connection.getObjectMultiBulkReply();
1610    }
1611    @Override
1612    public List&lt;Object&gt; slowlogGetBinary(final long entries) {
1613      connection.sendCommand(SLOWLOG, Keyword.GET.getRaw(), toByteArray(entries));
1614      return connection.getObjectMultiBulkReply();
1615    }
1616    @Override
1617    public Long objectRefcount(final byte[] key) {
1618      connection.sendCommand(OBJECT, REFCOUNT.getRaw(), key);
1619      return connection.getIntegerReply();
1620    }
1621    @Override
1622    public byte[] objectEncoding(final byte[] key) {
1623      connection.sendCommand(OBJECT, ENCODING.getRaw(), key);
1624      return connection.getBinaryBulkReply();
1625    }
1626    @Override
1627    public Long objectIdletime(final byte[] key) {
1628      connection.sendCommand(OBJECT, IDLETIME.getRaw(), key);
1629      return connection.getIntegerReply();
1630    }
1631    @Override
1632    public List&lt;byte[]&gt; objectHelpBinary() {
1633      connection.sendCommand(OBJECT, HELP);
1634      return connection.getBinaryMultiBulkReply();
1635    }
1636    @Override
1637    public Long objectFreq(final byte[] key) {
1638      connection.sendCommand(OBJECT, FREQ.getRaw(), key);
1639      return connection.getIntegerReply();
1640    }
1641    @Override
1642    public long bitcount(final byte[] key) {
1643      checkIsInMultiOrPipeline();
1644      return connection.executeCommand(commandObjects.bitcount(key));
1645    }
1646    @Override
1647    public long bitcount(final byte[] key, final long start, final long end) {
1648      checkIsInMultiOrPipeline();
1649      return connection.executeCommand(commandObjects.bitcount(key, start, end));
1650    }
1651    @Override
1652    public long bitcount(final byte[] key, final long start, final long end, final BitCountOption option) {
1653      checkIsInMultiOrPipeline();
1654      return connection.executeCommand(commandObjects.bitcount(key, start, end, option));
1655    }
1656    @Override
1657    public long bitop(final BitOP op, final byte[] destKey, final byte[]... srcKeys) {
1658      checkIsInMultiOrPipeline();
1659      return connection.executeCommand(commandObjects.bitop(op, destKey, srcKeys));
1660    }
1661    @Override
1662    public byte[] dump(final byte[] key) {
1663      checkIsInMultiOrPipeline();
1664      return connection.executeCommand(commandObjects.dump(key));
1665    }
1666    @Override
1667    public String restore(final byte[] key, final long ttl, final byte[] serializedValue) {
1668      checkIsInMultiOrPipeline();
1669      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue));
1670    }
1671    @Override
1672    public String restore(final byte[] key, final long ttl, final byte[] serializedValue,
1673        final RestoreParams params) {
1674      checkIsInMultiOrPipeline();
1675      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
1676    }
1677    @Override
1678    public long pttl(final byte[] key) {
1679      checkIsInMultiOrPipeline();
1680      return connection.executeCommand(commandObjects.pttl(key));
1681    }
1682    @Override
1683    public String psetex(final byte[] key, final long milliseconds, final byte[] value) {
1684      checkIsInMultiOrPipeline();
1685      return connection.executeCommand(commandObjects.psetex(key, milliseconds, value));
1686    }
1687    @Override
1688    public byte[] memoryDoctorBinary() {
1689      checkIsInMultiOrPipeline();
1690      connection.sendCommand(MEMORY, DOCTOR);
1691      return connection.getBinaryBulkReply();
1692    }
1693    @Override
1694    public Long memoryUsage(final byte[] key) {
1695      checkIsInMultiOrPipeline();
1696      connection.sendCommand(MEMORY, USAGE.getRaw(), key);
1697      return connection.getIntegerReply();
1698    }
1699    @Override
1700    public Long memoryUsage(final byte[] key, final int samples) {
1701      checkIsInMultiOrPipeline();
1702      connection.sendCommand(MEMORY, USAGE.getRaw(), key, SAMPLES.getRaw(), toByteArray(samples));
1703      return connection.getIntegerReply();
1704    }
1705    @Override
1706    public String failover() {
1707      checkIsInMultiOrPipeline();
1708      connection.sendCommand(Command.FAILOVER);
1709      connection.setTimeoutInfinite();
1710      try {
1711        return connection.getStatusCodeReply();
1712      } finally {
1713        connection.rollbackTimeout();
1714      }
1715    }
1716    @Override
1717    public String failover(FailoverParams failoverParams) {
1718      checkIsInMultiOrPipeline();
1719      CommandArguments args = new ClusterCommandArguments(Command.FAILOVER).addParams(failoverParams);
1720      connection.sendCommand(args);
1721      connection.setTimeoutInfinite();
1722      try {
1723        return connection.getStatusCodeReply();
1724      } finally {
1725        connection.rollbackTimeout();
1726      }
1727    }
1728    @Override
1729    public String failoverAbort() {
1730      checkIsInMultiOrPipeline();
1731      connection.sendCommand(Command.FAILOVER, ABORT);
1732      return connection.getStatusCodeReply();
1733    }
1734    @Override
1735    public byte[] aclWhoAmIBinary() {
1736      checkIsInMultiOrPipeline();
1737      connection.sendCommand(ACL, WHOAMI);
1738      return connection.getBinaryBulkReply();
1739    }
1740    @Override
1741    public byte[] aclGenPassBinary() {
1742      checkIsInMultiOrPipeline();
1743      connection.sendCommand(ACL, GENPASS);
1744      return connection.getBinaryBulkReply();
1745    }
1746    @Override
1747    public byte[] aclGenPassBinary(int bits) {
1748      checkIsInMultiOrPipeline();
1749      connection.sendCommand(ACL, GENPASS.getRaw(), toByteArray(bits));
1750      return connection.getBinaryBulkReply();
1751    }
1752    @Override
1753    public List&lt;byte[]&gt; aclListBinary() {
1754      checkIsInMultiOrPipeline();
1755      connection.sendCommand(ACL, LIST);
1756      return connection.getBinaryMultiBulkReply();
1757    }
1758    @Override
1759    public List&lt;byte[]&gt; aclUsersBinary() {
1760      checkIsInMultiOrPipeline();
1761      connection.sendCommand(ACL, USERS);
1762      return connection.getBinaryMultiBulkReply();
1763    }
1764    @Override
1765    public AccessControlUser aclGetUser(byte[] name) {
1766      checkIsInMultiOrPipeline();
1767      connection.sendCommand(ACL, GETUSER.getRaw(), name);
1768      return BuilderFactory.ACCESS_CONTROL_USER.build(connection.getObjectMultiBulkReply());
1769    }
1770    @Override
1771    public String aclSetUser(byte[] name) {
1772      checkIsInMultiOrPipeline();
1773      connection.sendCommand(ACL, SETUSER.getRaw(), name);
1774      return connection.getStatusCodeReply();
1775    }
1776    @Override
1777    public String aclSetUser(byte[] name, byte[]... rules) {
1778      checkIsInMultiOrPipeline();
1779      connection.sendCommand(ACL, joinParameters(SETUSER.getRaw(), name, rules));
1780      return connection.getStatusCodeReply();
1781    }
1782    @Override
1783    public long aclDelUser(byte[]... names) {
1784      checkIsInMultiOrPipeline();
1785      connection.sendCommand(ACL, joinParameters(DELUSER.getRaw(), names));
1786      return connection.getIntegerReply();
1787    }
1788    @Override
1789    public List&lt;byte[]&gt; aclCatBinary() {
1790      checkIsInMultiOrPipeline();
1791      connection.sendCommand(ACL, CAT);
1792      return connection.getBinaryMultiBulkReply();
1793    }
1794    @Override
1795    public List&lt;byte[]&gt; aclCat(byte[] category) {
1796      checkIsInMultiOrPipeline();
1797      connection.sendCommand(ACL, CAT.getRaw(), category);
1798      return connection.getBinaryMultiBulkReply();
1799    }
1800    @Override
1801    public List&lt;byte[]&gt; aclLogBinary() {
1802      checkIsInMultiOrPipeline();
1803      connection.sendCommand(ACL, LOG);
1804      return connection.getBinaryMultiBulkReply();
1805    }
1806    @Override
1807    public List&lt;byte[]&gt; aclLogBinary(int limit) {
1808      checkIsInMultiOrPipeline();
1809      connection.sendCommand(ACL, LOG.getRaw(), toByteArray(limit));
1810      return connection.getBinaryMultiBulkReply();
1811    }
1812    @Override
1813    public String aclLogReset() {
1814      checkIsInMultiOrPipeline();
1815      connection.sendCommand(ACL, LOG.getRaw(), Keyword.RESET.getRaw());
1816      return connection.getStatusCodeReply();
1817    }
1818    @Override
1819    public String clientKill(final byte[] ipPort) {
1820      checkIsInMultiOrPipeline();
1821      connection.sendCommand(CLIENT, KILL.getRaw(), ipPort);
1822      return this.connection.getStatusCodeReply();
1823    }
1824    @Override
1825    public String clientKill(final String ip, final int port) {
1826      return clientKill(ip + &#x27;:&#x27; + port);
1827    }
1828    @Override
1829    public long clientKill(ClientKillParams params) {
1830      checkIsInMultiOrPipeline();
1831      connection.sendCommand(new CommandArguments(CLIENT).add(KILL).addParams(params));
1832      return this.connection.getIntegerReply();
1833    }
1834    @Override
1835    public byte[] clientGetnameBinary() {
1836      checkIsInMultiOrPipeline();
1837      connection.sendCommand(CLIENT, GETNAME);
1838      return connection.getBinaryBulkReply();
1839    }
1840    @Override
1841    public byte[] clientListBinary() {
1842      checkIsInMultiOrPipeline();
1843      connection.sendCommand(CLIENT, LIST);
1844      return connection.getBinaryBulkReply();
1845    }
1846    @Override
1847    public byte[] clientListBinary(ClientType type) {
1848      checkIsInMultiOrPipeline();
1849      connection.sendCommand(CLIENT, LIST.getRaw(), type.getRaw());
1850      return connection.getBinaryBulkReply();
1851    }
1852    @Override
1853    public byte[] clientListBinary(final long... clientIds) {
1854      checkIsInMultiOrPipeline();
1855      connection.sendCommand(CLIENT, clientListParams(clientIds));
1856      return connection.getBinaryBulkReply();
1857    }
1858    private byte[][] clientListParams(final long... clientIds) {
1859      final byte[][] params = new byte[2 + clientIds.length][];
1860      int index = 0;
1861      params[index++] = Keyword.LIST.getRaw();
1862      params[index++] = ID.getRaw();
1863      for (final long clientId : clientIds) {
1864        params[index++] = toByteArray(clientId);
1865      }
1866      return params;
1867    }
1868    @Override
1869    public byte[] clientInfoBinary() {
1870      checkIsInMultiOrPipeline();
1871      connection.sendCommand(CLIENT, Keyword.INFO);
1872      return connection.getBinaryBulkReply();
1873    }
1874    @Override
1875    public String clientSetInfo(ClientAttributeOption attr, byte[] value) {
1876      checkIsInMultiOrPipeline();
1877      connection.sendCommand(CLIENT, SETINFO.getRaw(), attr.getRaw(), value);
1878      return connection.getStatusCodeReply();
1879    }
1880    @Override
1881    public String clientSetname(final byte[] name) {
1882      checkIsInMultiOrPipeline();
1883      connection.sendCommand(CLIENT, SETNAME.getRaw(), name);
1884      return connection.getBulkReply();
1885    }
1886    @Override
1887    public long clientId() {
1888      checkIsInMultiOrPipeline();
1889      connection.sendCommand(CLIENT, ID);
1890      return connection.getIntegerReply();
1891    }
1892    @Override
1893    public long clientUnblock(final long clientId) {
1894      checkIsInMultiOrPipeline();
1895      connection.sendCommand(CLIENT, UNBLOCK.getRaw(), toByteArray(clientId));
1896      return connection.getIntegerReply();
1897    }
1898    @Override
1899    public long clientUnblock(final long clientId, final UnblockType unblockType) {
1900      checkIsInMultiOrPipeline();
1901      connection.sendCommand(CLIENT, UNBLOCK.getRaw(), toByteArray(clientId), unblockType.getRaw());
1902      return connection.getIntegerReply();
1903    }
1904    @Override
1905    public String clientPause(final long timeout) {
1906      checkIsInMultiOrPipeline();
1907      connection.sendCommand(CLIENT, PAUSE.getRaw(), toByteArray(timeout));
1908      return connection.getBulkReply();
1909    }
1910    @Override
1911    public String clientPause(final long timeout, final ClientPauseMode mode) {
1912      checkIsInMultiOrPipeline();
1913      connection.sendCommand(CLIENT, PAUSE.getRaw(), toByteArray(timeout), mode.getRaw());
1914      return connection.getBulkReply();
1915    }
1916    @Override
1917    public String clientUnpause() {
1918      checkIsInMultiOrPipeline();
1919      connection.sendCommand(CLIENT, UNPAUSE);
1920      return connection.getBulkReply();
1921    }
1922    @Override
1923    public String clientNoEvictOn() {
1924      checkIsInMultiOrPipeline();
1925      connection.sendCommand(CLIENT, &quot;NO-EVICT&quot;, &quot;ON&quot;);
1926      return connection.getBulkReply();
1927    }
1928    @Override
1929    public String clientNoEvictOff() {
1930      checkIsInMultiOrPipeline();
1931      connection.sendCommand(CLIENT, &quot;NO-EVICT&quot;, &quot;OFF&quot;);
1932      return connection.getBulkReply();
1933    }
1934    @Override
1935    public String clientNoTouchOn() {
1936      checkIsInMultiOrPipeline();
1937      connection.sendCommand(CLIENT, &quot;NO-TOUCH&quot;, &quot;ON&quot;);
1938      return connection.getStatusCodeReply();
1939    }
1940    @Override
1941    public String clientNoTouchOff() {
1942      checkIsInMultiOrPipeline();
1943      connection.sendCommand(CLIENT, &quot;NO-TOUCH&quot;, &quot;OFF&quot;);
1944      return connection.getStatusCodeReply();
1945    }
1946    public List&lt;String&gt; time() {
1947      checkIsInMultiOrPipeline();
1948      connection.sendCommand(Command.TIME);
1949      return connection.getMultiBulkReply();
1950    }
1951    @Override
1952    public String migrate(final String host, final int port, final byte[] key,
1953        final int destinationDb, final int timeout) {
1954      checkIsInMultiOrPipeline();
1955      return connection.executeCommand(commandObjects.migrate(host, port, key, destinationDb, timeout));
1956    }
1957    @Override
1958    public String migrate(final String host, final int port, final int destinationDB,
1959        final int timeout, final MigrateParams params, final byte[]... keys) {
1960      checkIsInMultiOrPipeline();
1961      return connection.executeCommand(commandObjects.migrate(host, port, destinationDB, timeout, params, keys));
1962    }
1963    @Override
1964    public String migrate(String host, int port, byte[] key, int timeout) {
1965      checkIsInMultiOrPipeline();
1966      return connection.executeCommand(commandObjects.migrate(host, port, key, timeout));
1967    }
1968    @Override
1969    public String migrate(String host, int port, int timeout, MigrateParams params, byte[]... keys) {
1970      checkIsInMultiOrPipeline();
1971      return connection.executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
1972    }
1973    @Override
1974    public long waitReplicas(final int replicas, final long timeout) {
1975      checkIsInMultiOrPipeline();
1976      connection.sendCommand(WAIT, toByteArray(replicas), toByteArray(timeout));
1977      return connection.getIntegerReply();
1978    }
1979    @Override
1980    public KeyValue&lt;Long, Long&gt; waitAOF(long numLocal, long numReplicas, long timeout) {
1981      checkIsInMultiOrPipeline();
1982      connection.sendCommand(WAITAOF, toByteArray(numLocal), toByteArray(numReplicas), toByteArray(timeout));
1983      return BuilderFactory.LONG_LONG_PAIR.build(connection.getOne());
1984    }
1985    @Override
1986    public long pfadd(final byte[] key, final byte[]... elements) {
1987      checkIsInMultiOrPipeline();
1988      return connection.executeCommand(commandObjects.pfadd(key, elements));
1989    }
1990    @Override
1991    public long pfcount(final byte[] key) {
1992      checkIsInMultiOrPipeline();
1993      return connection.executeCommand(commandObjects.pfcount(key));
1994    }
1995    @Override
1996    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
1997      checkIsInMultiOrPipeline();
1998      return connection.executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
1999    }
2000    @Override
2001    public long pfcount(final byte[]... keys) {
2002      checkIsInMultiOrPipeline();
2003      return connection.executeCommand(commandObjects.pfcount(keys));
2004    }
2005    @Override
2006    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor) {
2007      checkIsInMultiOrPipeline();
2008      return connection.executeCommand(commandObjects.scan(cursor));
2009    }
2010    @Override
2011    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor, final ScanParams params) {
2012      checkIsInMultiOrPipeline();
2013      return connection.executeCommand(commandObjects.scan(cursor, params));
2014    }
2015    @Override
2016    public ScanResult&lt;byte[]&gt; scan(final byte[] cursor, final ScanParams params, final byte[] type) {
2017      checkIsInMultiOrPipeline();
2018      return connection.executeCommand(commandObjects.scan(cursor, params, type));
2019    }
2020    @Override
2021    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(final byte[] key, final byte[] cursor) {
2022      return hscan(key, cursor, new ScanParams());
2023    }
2024    @Override
2025    public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; hscan(final byte[] key, final byte[] cursor,
2026        final ScanParams params) {
2027      checkIsInMultiOrPipeline();
2028      return connection.executeCommand(commandObjects.hscan(key, cursor, params));
2029    }
2030    @Override
2031    public ScanResult&lt;byte[]&gt; sscan(final byte[] key, final byte[] cursor) {
2032      return sscan(key, cursor, new ScanParams());
2033    }
2034    @Override
2035    public ScanResult&lt;byte[]&gt; sscan(final byte[] key, final byte[] cursor, final ScanParams params) {
2036      checkIsInMultiOrPipeline();
2037      return connection.executeCommand(commandObjects.sscan(key, cursor, params));
2038    }
2039    @Override
2040    public ScanResult&lt;Tuple&gt; zscan(final byte[] key, final byte[] cursor) {
2041      return zscan(key, cursor, new ScanParams());
2042    }
2043    @Override
2044    public ScanResult&lt;Tuple&gt; zscan(final byte[] key, final byte[] cursor, final ScanParams params) {
2045      checkIsInMultiOrPipeline();
2046      return connection.executeCommand(commandObjects.zscan(key, cursor, params));
2047    }
2048    @Override
2049    public long geoadd(final byte[] key, final double longitude, final double latitude,
2050        final byte[] member) {
2051      checkIsInMultiOrPipeline();
2052      return connection.executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
2053    }
2054    @Override
2055    public long geoadd(final byte[] key, final Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2056      checkIsInMultiOrPipeline();
2057      return connection.executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
2058    }
2059    @Override
2060    public long geoadd(final byte[] key, final GeoAddParams params, final Map&lt;byte[], GeoCoordinate&gt; memberCoordinateMap) {
2061      checkIsInMultiOrPipeline();
2062      return connection.executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
2063    }
2064    @Override
2065    public Double geodist(final byte[] key, final byte[] member1, final byte[] member2) {
2066      checkIsInMultiOrPipeline();
2067      return connection.executeCommand(commandObjects.geodist(key, member1, member2));
2068    }
2069    @Override
2070    public Double geodist(final byte[] key, final byte[] member1, final byte[] member2,
2071        final GeoUnit unit) {
2072      checkIsInMultiOrPipeline();
2073      return connection.executeCommand(commandObjects.geodist(key, member1, member2, unit));
2074    }
2075    @Override
2076    public List&lt;byte[]&gt; geohash(final byte[] key, final byte[]... members) {
2077      checkIsInMultiOrPipeline();
2078      return connection.executeCommand(commandObjects.geohash(key, members));
2079    }
2080    @Override
2081    public List&lt;GeoCoordinate&gt; geopos(final byte[] key, final byte[]... members) {
2082      checkIsInMultiOrPipeline();
2083      return connection.executeCommand(commandObjects.geopos(key, members));
2084    }
2085    @Override
2086    public List&lt;GeoRadiusResponse&gt; georadius(final byte[] key, final double longitude,
2087        final double latitude, final double radius, final GeoUnit unit) {
2088      checkIsInMultiOrPipeline();
2089      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
2090    }
2091    @Override
2092    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final byte[] key, final double longitude,
2093        final double latitude, final double radius, final GeoUnit unit) {
2094      checkIsInMultiOrPipeline();
2095      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
2096    }
2097    @Override
2098    public List&lt;GeoRadiusResponse&gt; georadius(final byte[] key, final double longitude,
2099        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2100      checkIsInMultiOrPipeline();
2101      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
2102    }
2103    @Override
2104    public long georadiusStore(final byte[] key, final double longitude, final double latitude,
2105        final double radius, final GeoUnit unit, final GeoRadiusParam param,
2106        final GeoRadiusStoreParam storeParam) {
2107      checkIsInMultiOrPipeline();
2108      return connection.executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
2109    }
2110    @Override
2111    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final byte[] key, final double longitude,
2112        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2113      checkIsInMultiOrPipeline();
2114      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
2115    }
2116    @Override
2117    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final byte[] key, final byte[] member,
2118        final double radius, final GeoUnit unit) {
2119      checkIsInMultiOrPipeline();
2120      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
2121    }
2122    @Override
2123    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final byte[] key, final byte[] member,
2124        final double radius, final GeoUnit unit) {
2125      checkIsInMultiOrPipeline();
2126      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
2127    }
2128    @Override
2129    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final byte[] key, final byte[] member,
2130        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2131      checkIsInMultiOrPipeline();
2132      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
2133    }
2134    @Override
2135    public long georadiusByMemberStore(final byte[] key, final byte[] member, final double radius,
2136        final GeoUnit unit, final GeoRadiusParam param, final GeoRadiusStoreParam storeParam) {
2137      checkIsInMultiOrPipeline();
2138      return connection.executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
2139    }
2140    @Override
2141    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double radius, GeoUnit unit) {
2142      checkIsInMultiOrPipeline();
2143      return connection.executeCommand(commandObjects.geosearch(key, member, radius, unit));
2144    }
2145    @Override
2146    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double radius, GeoUnit unit) {
2147      checkIsInMultiOrPipeline();
2148      return connection.executeCommand(commandObjects.geosearch(key, coord, radius, unit));
2149    }
2150    @Override
2151    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, byte[] member, double width, double height, GeoUnit unit) {
2152      checkIsInMultiOrPipeline();
2153      return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));
2154    }
2155    @Override
2156    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2157      checkIsInMultiOrPipeline();
2158      return connection.executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
2159    }
2160    @Override
2161    public List&lt;GeoRadiusResponse&gt; geosearch(byte[] key, GeoSearchParam params) {
2162      checkIsInMultiOrPipeline();
2163      return connection.executeCommand(commandObjects.geosearch(key, params));
2164    }
2165    @Override
2166    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double radius, GeoUnit unit) {
2167      checkIsInMultiOrPipeline();
2168      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
2169    }
2170    @Override
2171    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double radius, GeoUnit unit) {
2172      checkIsInMultiOrPipeline();
2173      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
2174    }
2175    @Override
2176    public long geosearchStore(byte[] dest, byte[] src, byte[] member, double width, double height, GeoUnit unit) {
2177      checkIsInMultiOrPipeline();
2178      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
2179    }
2180    @Override
2181    public long geosearchStore(byte[] dest, byte[] src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
2182      checkIsInMultiOrPipeline();
2183      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
2184    }
2185    @Override
2186    public long geosearchStore(byte[] dest, byte[] src, GeoSearchParam params) {
2187      checkIsInMultiOrPipeline();
2188      return connection.executeCommand(commandObjects.geosearchStore(dest, src, params));
2189    }
2190    @Override
2191    public long geosearchStoreStoreDist(byte[] dest, byte[] src, GeoSearchParam params) {
2192      checkIsInMultiOrPipeline();
2193      return connection.executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
2194    }
2195    @Override
2196    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final byte[] key, final byte[] member,
2197        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
2198      checkIsInMultiOrPipeline();
2199      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
2200    }
2201    @Override
2202    public List&lt;Long&gt; bitfield(final byte[] key, final byte[]... arguments) {
2203      checkIsInMultiOrPipeline();
2204      return connection.executeCommand(commandObjects.bitfield(key, arguments));
2205    }
2206    @Override
2207    public List&lt;Long&gt; bitfieldReadonly(byte[] key, final byte[]... arguments) {
2208      checkIsInMultiOrPipeline();
2209      return connection.executeCommand(commandObjects.bitfieldReadonly(key, arguments));
2210    }
2211    @Override
2212    public long hstrlen(final byte[] key, final byte[] field) {
2213      checkIsInMultiOrPipeline();
2214      return connection.executeCommand(commandObjects.hstrlen(key, field));
2215    }
2216    @Override
2217    public List&lt;byte[]&gt; xread(XReadParams xReadParams, Entry&lt;byte[], byte[]&gt;... streams) {
2218      checkIsInMultiOrPipeline();
2219      return connection.executeCommand(commandObjects.xread(xReadParams, streams));
2220    }
2221    @Override
2222    public List&lt;byte[]&gt; xreadGroup(byte[] groupName, byte[] consumer,
2223        XReadGroupParams xReadGroupParams, Entry&lt;byte[], byte[]&gt;... streams) {
2224      checkIsInMultiOrPipeline();
2225      return connection.executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
2226    }
2227    @Override
2228    public byte[] xadd(final byte[] key, final XAddParams params, final Map&lt;byte[], byte[]&gt; hash) {
2229      checkIsInMultiOrPipeline();
2230      return connection.executeCommand(commandObjects.xadd(key, params, hash));
2231    }
2232    @Override
2233    public long xlen(byte[] key) {
2234      checkIsInMultiOrPipeline();
2235      return connection.executeCommand(commandObjects.xlen(key));
2236    }
2237    @Override
2238    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end) {
2239      checkIsInMultiOrPipeline();
2240      return connection.executeCommand(commandObjects.xrange(key, start, end));
2241    }
2242    @Override
2243    public List&lt;byte[]&gt; xrange(byte[] key, byte[] start, byte[] end, int count) {
2244      checkIsInMultiOrPipeline();
2245      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
2246    }
2247    @Override
2248    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start) {
2249      checkIsInMultiOrPipeline();
2250      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
2251    }
2252    @Override
2253    public List&lt;byte[]&gt; xrevrange(byte[] key, byte[] end, byte[] start, int count) {
2254      checkIsInMultiOrPipeline();
2255      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
2256    }
2257    @Override
2258    public long xack(byte[] key, byte[] group, byte[]... ids) {
2259      checkIsInMultiOrPipeline();
2260      return connection.executeCommand(commandObjects.xack(key, group, ids));
2261    }
2262    @Override
2263    public String xgroupCreate(byte[] key, byte[] consumer, byte[] id, boolean makeStream) {
2264      checkIsInMultiOrPipeline();
2265      return connection.executeCommand(commandObjects.xgroupCreate(key, consumer, id, makeStream));
2266    }
2267    @Override
2268    public String xgroupSetID(byte[] key, byte[] consumer, byte[] id) {
2269      checkIsInMultiOrPipeline();
2270      return connection.executeCommand(commandObjects.xgroupSetID(key, consumer, id));
2271    }
2272    @Override
2273    public long xgroupDestroy(byte[] key, byte[] consumer) {
2274      checkIsInMultiOrPipeline();
2275      return connection.executeCommand(commandObjects.xgroupDestroy(key, consumer));
2276    }
2277    @Override
2278    public boolean xgroupCreateConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2279      checkIsInMultiOrPipeline();
2280      return connection.executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
2281    }
2282    @Override
2283    public long xgroupDelConsumer(byte[] key, byte[] groupName, byte[] consumerName) {
2284      checkIsInMultiOrPipeline();
2285      return connection.executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
2286    }
2287    @Override
2288    public long xdel(byte[] key, byte[]... ids) {
2289      checkIsInMultiOrPipeline();
2290      return connection.executeCommand(commandObjects.xdel(key, ids));
2291    }
2292    @Override
2293    public long xtrim(byte[] key, long maxLen, boolean approximateLength) {
2294      checkIsInMultiOrPipeline();
2295      return connection.executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
2296    }
2297    @Override
2298    public long xtrim(byte[] key, XTrimParams params) {
2299      checkIsInMultiOrPipeline();
2300      return connection.executeCommand(commandObjects.xtrim(key, params));
2301    }
2302    @Override
2303    public Object xpending(final byte[] key, final byte[] groupName) {
2304      checkIsInMultiOrPipeline();
2305      return connection.executeCommand(commandObjects.xpending(key, groupName));
2306    }
2307    @Override
2308    public List&lt;Object&gt; xpending(final byte[] key, final byte[] groupName, final XPendingParams params) {
2309      checkIsInMultiOrPipeline();
2310      return connection.executeCommand(commandObjects.xpending(key, groupName, params));
2311    }
2312    @Override
2313    public List&lt;byte[]&gt; xclaim(byte[] key, byte[] group, byte[] consumerName, long minIdleTime,
2314        XClaimParams params, byte[]... ids) {
2315      checkIsInMultiOrPipeline();
2316      return connection.executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
2317    }
2318    @Override
2319    public List&lt;byte[]&gt; xclaimJustId(byte[] key, byte[] group, byte[] consumerName, long minIdleTime,
2320        XClaimParams params, byte[]... ids) {
2321      checkIsInMultiOrPipeline();
2322      return connection.executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
2323    }
2324    @Override
2325    public List&lt;Object&gt; xautoclaim(byte[] key, byte[] groupName, byte[] consumerName,
2326        long minIdleTime, byte[] start, XAutoClaimParams params) {
2327      checkIsInMultiOrPipeline();
2328      return connection.executeCommand(commandObjects.xautoclaim(key, groupName, consumerName, minIdleTime, start, params));
2329    }
2330    @Override
2331    public List&lt;Object&gt; xautoclaimJustId(byte[] key, byte[] groupName, byte[] consumerName,
2332        long minIdleTime, byte[] start, XAutoClaimParams params) {
2333      checkIsInMultiOrPipeline();
2334      return connection.executeCommand(commandObjects.xautoclaimJustId(key, groupName, consumerName, minIdleTime, start, params));
2335    }
2336    @Override
2337    public Object xinfoStream(byte[] key) {
2338      checkIsInMultiOrPipeline();
2339      return connection.executeCommand(commandObjects.xinfoStream(key));
2340    }
2341    @Override
2342    public Object xinfoStreamFull(byte[] key) {
2343      checkIsInMultiOrPipeline();
2344      return connection.executeCommand(commandObjects.xinfoStreamFull(key));
2345    }
2346    @Override
2347    public Object xinfoStreamFull(byte[] key, int count) {
2348      checkIsInMultiOrPipeline();
2349      return connection.executeCommand(commandObjects.xinfoStreamFull(key, count));
2350    }
2351    @Override
2352    public List&lt;Object&gt; xinfoGroups(byte[] key) {
2353      checkIsInMultiOrPipeline();
2354      return connection.executeCommand(commandObjects.xinfoGroups(key));
2355    }
2356    @Override
2357    public List&lt;Object&gt; xinfoConsumers(byte[] key, byte[] group) {
2358      checkIsInMultiOrPipeline();
2359      return connection.executeCommand(commandObjects.xinfoConsumers(key, group));
2360    }
2361    public Object sendCommand(ProtocolCommand cmd, byte[]... args) {
2362      checkIsInMultiOrPipeline();
2363      connection.sendCommand(cmd, args);
2364      return connection.getOne();
2365    }
2366    public Object sendBlockingCommand(ProtocolCommand cmd, byte[]... args) {
2367      checkIsInMultiOrPipeline();
2368      connection.sendCommand(cmd, args);
2369      connection.setTimeoutInfinite();
2370      try {
2371        return connection.getOne();
2372      } finally {
2373        connection.rollbackTimeout();
2374      }
2375    }
2376    public Object sendCommand(ProtocolCommand cmd) {
2377      return sendCommand(cmd, DUMMY_ARRAY);
2378    }
2379    @Override
2380    public boolean copy(String srcKey, String dstKey, int db, boolean replace) {
2381      checkIsInMultiOrPipeline();
2382      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, db, replace));
2383    }
2384    @Override
2385    public boolean copy(String srcKey, String dstKey, boolean replace) {
2386      checkIsInMultiOrPipeline();
2387      return connection.executeCommand(commandObjects.copy(srcKey, dstKey, replace));
2388    }
2389    @Override
2390    public String ping(final String message) {
2391      checkIsInMultiOrPipeline();
2392      connection.sendCommand(Command.PING, message);
2393      return connection.getBulkReply();
2394    }
2395    @Override
2396    public String set(final String key, final String value) {
2397      checkIsInMultiOrPipeline();
2398      return connection.executeCommand(commandObjects.set(key, value));
2399    }
2400    @Override
2401    public String set(final String key, final String value, final SetParams params) {
2402      checkIsInMultiOrPipeline();
2403      return connection.executeCommand(commandObjects.set(key, value, params));
2404    }
2405    @Override
2406    public String get(final String key) {
2407      checkIsInMultiOrPipeline();
2408      return connection.executeCommand(commandObjects.get(key));
2409    }
2410    @Override
2411    public String setGet(final String key, final String value) {
2412      checkIsInMultiOrPipeline();
2413      return connection.executeCommand(commandObjects.setGet(key, value));
2414    }
2415    @Override
2416    public String setGet(final String key, final String value, final SetParams params) {
2417      checkIsInMultiOrPipeline();
2418      return connection.executeCommand(commandObjects.setGet(key, value, params));
2419    }
2420    @Override
2421    public String getDel(final String key) {
2422      checkIsInMultiOrPipeline();
2423      return connection.executeCommand(commandObjects.getDel(key));
2424    }
2425    @Override
2426    public String getEx(String key, GetExParams params) {
2427      checkIsInMultiOrPipeline();
2428      return connection.executeCommand(commandObjects.getEx(key, params));
2429    }
2430    @Override
2431    public long exists(final String... keys) {
2432      checkIsInMultiOrPipeline();
2433      return connection.executeCommand(commandObjects.exists(keys));
2434    }
2435    @Override
2436    public boolean exists(final String key) {
2437      checkIsInMultiOrPipeline();
2438      return connection.executeCommand(commandObjects.exists(key));
2439    }
2440    @Override
2441    public long del(final String... keys) {
2442      checkIsInMultiOrPipeline();
2443      return connection.executeCommand(commandObjects.del(keys));
2444    }
2445    @Override
2446    public long del(final String key) {
2447      checkIsInMultiOrPipeline();
2448      return connection.executeCommand(commandObjects.del(key));
2449    }
2450    @Override
2451    public long unlink(final String... keys) {
2452      checkIsInMultiOrPipeline();
2453      return connection.executeCommand(commandObjects.unlink(keys));
2454    }
2455    @Override
2456    public long unlink(final String key) {
2457      checkIsInMultiOrPipeline();
2458      return connection.executeCommand(commandObjects.unlink(key));
2459    }
2460    @Override
2461    public String type(final String key) {
2462      checkIsInMultiOrPipeline();
2463      return connection.executeCommand(commandObjects.type(key));
2464    }
2465    @Override
2466    public Set&lt;String&gt; keys(final String pattern) {
2467      checkIsInMultiOrPipeline();
2468      return connection.executeCommand(commandObjects.keys(pattern));
2469    }
2470    @Override
2471    public String randomKey() {
2472      checkIsInMultiOrPipeline();
2473      return connection.executeCommand(commandObjects.randomKey());
2474    }
2475    @Override
2476    public String rename(final String oldkey, final String newkey) {
2477      checkIsInMultiOrPipeline();
2478      return connection.executeCommand(commandObjects.rename(oldkey, newkey));
2479    }
2480    @Override
2481    public long renamenx(final String oldkey, final String newkey) {
2482      checkIsInMultiOrPipeline();
2483      return connection.executeCommand(commandObjects.renamenx(oldkey, newkey));
2484    }
2485    @Override
2486    public long expire(final String key, final long seconds) {
2487      checkIsInMultiOrPipeline();
2488      return connection.executeCommand(commandObjects.expire(key, seconds));
2489    }
2490    @Override
2491    public long expire(final String key, final long seconds, final ExpiryOption expiryOption) {
2492      checkIsInMultiOrPipeline();
2493      return connection.executeCommand(commandObjects.expire(key, seconds, expiryOption));
2494    }
2495    @Override
2496    public long pexpire(final String key, final long milliseconds) {
2497      checkIsInMultiOrPipeline();
2498      return connection.executeCommand(commandObjects.pexpire(key, milliseconds));
2499    }
2500    @Override
2501    public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {
2502      checkIsInMultiOrPipeline();
2503      return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));
2504    }
2505    @Override
2506    public long expireTime(final String key) {
2507      checkIsInMultiOrPipeline();
2508      return connection.executeCommand(commandObjects.expireTime(key));
2509    }
2510    @Override
2511    public long pexpireTime(final String key) {
2512      checkIsInMultiOrPipeline();
2513      return connection.executeCommand(commandObjects.pexpireTime(key));
2514    }
2515    @Override
2516    public long expireAt(final String key, final long unixTime) {
2517      checkIsInMultiOrPipeline();
2518      return connection.executeCommand(commandObjects.expireAt(key, unixTime));
2519    }
2520    @Override
2521    public long expireAt(String key, long unixTime, ExpiryOption expiryOption) {
2522      checkIsInMultiOrPipeline();
2523      return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));
2524    }
2525    @Override
2526    public long pexpireAt(final String key, final long millisecondsTimestamp) {
2527      checkIsInMultiOrPipeline();
2528      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp));
2529    }
2530    @Override
2531    public long pexpireAt(String key, long millisecondsTimestamp, ExpiryOption expiryOption) {
2532      checkIsInMultiOrPipeline();
2533      return connection.executeCommand(commandObjects.pexpireAt(key, millisecondsTimestamp, expiryOption));
2534    }
2535    @Override
2536    public long ttl(final String key) {
2537      checkIsInMultiOrPipeline();
2538      return connection.executeCommand(commandObjects.ttl(key));
2539    }
2540    @Override
2541    public long touch(final String... keys) {
2542      checkIsInMultiOrPipeline();
2543      return connection.executeCommand(commandObjects.touch(keys));
2544    }
2545    @Override
2546    public long touch(final String key) {
2547      checkIsInMultiOrPipeline();
2548      return connection.executeCommand(commandObjects.touch(key));
2549    }
2550    @Override
2551    public long move(final String key, final int dbIndex) {
2552      checkIsInMultiOrPipeline();
2553      connection.sendCommand(MOVE, encode(key), toByteArray(dbIndex));
2554      return connection.getIntegerReply();
2555    }
2556    @Override
2557    public String getSet(final String key, final String value) {
2558      checkIsInMultiOrPipeline();
2559      return connection.executeCommand(commandObjects.getSet(key, value));
2560    }
2561    @Override
2562    public List&lt;String&gt; mget(final String... keys) {
2563      checkIsInMultiOrPipeline();
2564      return connection.executeCommand(commandObjects.mget(keys));
2565    }
2566    @Override
2567    public long setnx(final String key, final String value) {
2568      checkIsInMultiOrPipeline();
2569      return connection.executeCommand(commandObjects.setnx(key, value));
2570    }
2571    @Override
2572    public String setex(final String key, final long seconds, final String value) {
2573      checkIsInMultiOrPipeline();
2574      return connection.executeCommand(commandObjects.setex(key, seconds, value));
2575    }
2576    @Override
2577    public String mset(final String... keysvalues) {
2578      checkIsInMultiOrPipeline();
2579      return connection.executeCommand(commandObjects.mset(keysvalues));
2580    }
2581    @Override
2582    public long msetnx(final String... keysvalues) {
2583      checkIsInMultiOrPipeline();
2584      return connection.executeCommand(commandObjects.msetnx(keysvalues));
2585    }
2586    @Override
2587    public long decrBy(final String key, final long decrement) {
2588      checkIsInMultiOrPipeline();
2589      return connection.executeCommand(commandObjects.decrBy(key, decrement));
2590    }
2591    @Override
2592    public long decr(final String key) {
2593      checkIsInMultiOrPipeline();
2594      return connection.executeCommand(commandObjects.decr(key));
2595    }
2596    @Override
2597    public long incrBy(final String key, final long increment) {
2598      checkIsInMultiOrPipeline();
2599      return connection.executeCommand(commandObjects.incrBy(key, increment));
2600    }
2601    @Override
2602    public double incrByFloat(final String key, final double increment) {
2603      checkIsInMultiOrPipeline();
2604      return connection.executeCommand(commandObjects.incrByFloat(key, increment));
2605    }
2606    @Override
2607    public long incr(final String key) {
2608      checkIsInMultiOrPipeline();
2609      return connection.executeCommand(commandObjects.incr(key));
2610    }
2611    @Override
2612    public long append(final String key, final String value) {
2613      checkIsInMultiOrPipeline();
2614      return connection.executeCommand(commandObjects.append(key, value));
2615    }
2616    @Override
2617    public String substr(final String key, final int start, final int end) {
2618      checkIsInMultiOrPipeline();
2619      return connection.executeCommand(commandObjects.substr(key, start, end));
2620    }
2621    @Override
2622    public long hset(final String key, final String field, final String value) {
2623      checkIsInMultiOrPipeline();
2624      return connection.executeCommand(commandObjects.hset(key, field, value));
2625    }
2626    @Override
2627    public long hset(final String key, final Map&lt;String, String&gt; hash) {
2628      checkIsInMultiOrPipeline();
2629      return connection.executeCommand(commandObjects.hset(key, hash));
2630    }
2631    @Override
2632    public String hget(final String key, final String field) {
2633      checkIsInMultiOrPipeline();
2634      return connection.executeCommand(commandObjects.hget(key, field));
2635    }
2636    @Override
2637    public long hsetnx(final String key, final String field, final String value) {
2638      checkIsInMultiOrPipeline();
2639      return connection.executeCommand(commandObjects.hsetnx(key, field, value));
2640    }
2641    @Override
2642    public String hmset(final String key, final Map&lt;String, String&gt; hash) {
2643      checkIsInMultiOrPipeline();
2644      return connection.executeCommand(commandObjects.hmset(key, hash));
2645    }
2646    @Override
2647    public List&lt;String&gt; hmget(final String key, final String... fields) {
2648      checkIsInMultiOrPipeline();
2649      return connection.executeCommand(commandObjects.hmget(key, fields));
2650    }
2651    @Override
2652    public long hincrBy(final String key, final String field, final long value) {
2653      checkIsInMultiOrPipeline();
2654      return connection.executeCommand(commandObjects.hincrBy(key, field, value));
2655    }
2656    @Override
2657    public double hincrByFloat(final String key, final String field, final double value) {
2658      checkIsInMultiOrPipeline();
2659      return connection.executeCommand(commandObjects.hincrByFloat(key, field, value));
2660    }
2661    @Override
2662    public boolean hexists(final String key, final String field) {
2663      checkIsInMultiOrPipeline();
2664      return connection.executeCommand(commandObjects.hexists(key, field));
2665    }
2666    @Override
2667    public long hdel(final String key, final String... fields) {
2668      checkIsInMultiOrPipeline();
2669      return connection.executeCommand(commandObjects.hdel(key, fields));
2670    }
2671    @Override
2672    public long hlen(final String key) {
2673      checkIsInMultiOrPipeline();
2674      return connection.executeCommand(commandObjects.hlen(key));
2675    }
2676    @Override
2677    public Set&lt;String&gt; hkeys(final String key) {
2678      checkIsInMultiOrPipeline();
2679      return connection.executeCommand(commandObjects.hkeys(key));
2680    }
2681    @Override
2682    public List&lt;String&gt; hvals(final String key) {
2683      checkIsInMultiOrPipeline();
2684      return connection.executeCommand(commandObjects.hvals(key));
2685    }
2686    @Override
2687    public Map&lt;String, String&gt; hgetAll(final String key) {
2688      checkIsInMultiOrPipeline();
2689      return connection.executeCommand(commandObjects.hgetAll(key));
2690    }
2691    @Override
2692    public String hrandfield(final String key) {
2693      checkIsInMultiOrPipeline();
2694      return connection.executeCommand(commandObjects.hrandfield(key));
2695    }
2696    @Override
2697    public List&lt;String&gt; hrandfield(final String key, final long count) {
2698      checkIsInMultiOrPipeline();
2699      return connection.executeCommand(commandObjects.hrandfield(key, count));
2700    }
2701    @Override
2702    public List&lt;Map.Entry&lt;String, String&gt;&gt; hrandfieldWithValues(final String key, final long count) {
2703      checkIsInMultiOrPipeline();
2704      return connection.executeCommand(commandObjects.hrandfieldWithValues(key, count));
2705    }
2706    @Override
2707    public long rpush(final String key, final String... strings) {
2708      checkIsInMultiOrPipeline();
2709      return connection.executeCommand(commandObjects.rpush(key, strings));
2710    }
2711    @Override
2712    public long lpush(final String key, final String... strings) {
2713      checkIsInMultiOrPipeline();
2714      return connection.executeCommand(commandObjects.lpush(key, strings));
2715    }
2716    @Override
2717    public long llen(final String key) {
2718      checkIsInMultiOrPipeline();
2719      return connection.executeCommand(commandObjects.llen(key));
2720    }
2721    @Override
2722    public List&lt;String&gt; lrange(final String key, final long start, final long stop) {
2723      checkIsInMultiOrPipeline();
2724      return connection.executeCommand(commandObjects.lrange(key, start, stop));
2725    }
2726    @Override
2727    public String ltrim(final String key, final long start, final long stop) {
2728      checkIsInMultiOrPipeline();
2729      return connection.executeCommand(commandObjects.ltrim(key, start, stop));
2730    }
2731    @Override
2732    public String lindex(final String key, final long index) {
2733      checkIsInMultiOrPipeline();
2734      return connection.executeCommand(commandObjects.lindex(key, index));
2735    }
2736    @Override
2737    public String lset(final String key, final long index, final String value) {
2738      checkIsInMultiOrPipeline();
2739      return connection.executeCommand(commandObjects.lset(key, index, value));
2740    }
2741    @Override
2742    public long lrem(final String key, final long count, final String value) {
2743      checkIsInMultiOrPipeline();
2744      return connection.executeCommand(commandObjects.lrem(key, count, value));
2745    }
2746    @Override
2747    public String lpop(final String key) {
2748      checkIsInMultiOrPipeline();
2749      return connection.executeCommand(commandObjects.lpop(key));
2750    }
2751    @Override
2752    public List&lt;String&gt; lpop(final String key, final int count) {
2753      checkIsInMultiOrPipeline();
2754      return connection.executeCommand(commandObjects.lpop(key, count));
2755    }
2756    @Override
2757    public Long lpos(final String key, final String element) {
2758      checkIsInMultiOrPipeline();
2759      return connection.executeCommand(commandObjects.lpos(key, element));
2760    }
2761    @Override
2762    public Long lpos(final String key, final String element, final LPosParams params) {
2763      checkIsInMultiOrPipeline();
2764      return connection.executeCommand(commandObjects.lpos(key, element, params));
2765    }
2766    @Override
2767    public List&lt;Long&gt; lpos(final String key, final String element, final LPosParams params,
2768        final long count) {
2769      checkIsInMultiOrPipeline();
2770      return connection.executeCommand(commandObjects.lpos(key, element, params, count));
2771    }
2772    @Override
2773    public String rpop(final String key) {
2774      checkIsInMultiOrPipeline();
2775      return connection.executeCommand(commandObjects.rpop(key));
2776    }
2777    @Override
2778    public List&lt;String&gt; rpop(final String key, final int count) {
2779      checkIsInMultiOrPipeline();
2780      return connection.executeCommand(commandObjects.rpop(key, count));
2781    }
2782    @Override
2783    public String rpoplpush(final String srckey, final String dstkey) {
2784      checkIsInMultiOrPipeline();
2785      return connection.executeCommand(commandObjects.rpoplpush(srckey, dstkey));
2786    }
2787    @Override
2788    public long sadd(final String key, final String... members) {
2789      checkIsInMultiOrPipeline();
2790      return connection.executeCommand(commandObjects.sadd(key, members));
2791    }
2792    @Override
2793    public Set&lt;String&gt; smembers(final String key) {
2794      checkIsInMultiOrPipeline();
2795      return connection.executeCommand(commandObjects.smembers(key));
2796    }
2797    @Override
2798    public long srem(final String key, final String... members) {
2799      checkIsInMultiOrPipeline();
2800      return connection.executeCommand(commandObjects.srem(key, members));
2801    }
2802    @Override
2803    public String spop(final String key) {
2804      checkIsInMultiOrPipeline();
2805      return connection.executeCommand(commandObjects.spop(key));
2806    }
2807    @Override
2808    public Set&lt;String&gt; spop(final String key, final long count) {
2809      checkIsInMultiOrPipeline();
2810      return connection.executeCommand(commandObjects.spop(key, count));
2811    }
2812    @Override
2813    public long smove(final String srckey, final String dstkey, final String member) {
2814      checkIsInMultiOrPipeline();
2815      return connection.executeCommand(commandObjects.smove(srckey, dstkey, member));
2816    }
2817    @Override
2818    public long scard(final String key) {
2819      checkIsInMultiOrPipeline();
2820      return connection.executeCommand(commandObjects.scard(key));
2821    }
2822    @Override
2823    public boolean sismember(final String key, final String member) {
2824      checkIsInMultiOrPipeline();
2825      return connection.executeCommand(commandObjects.sismember(key, member));
2826    }
2827    @Override
2828    public List&lt;Boolean&gt; smismember(final String key, final String... members) {
2829      checkIsInMultiOrPipeline();
2830      return connection.executeCommand(commandObjects.smismember(key, members));
2831    }
2832    @Override
2833    public Set&lt;String&gt; sinter(final String... keys) {
2834      checkIsInMultiOrPipeline();
2835      return connection.executeCommand(commandObjects.sinter(keys));
2836    }
2837    @Override
2838    public long sinterstore(final String dstkey, final String... keys) {
2839      checkIsInMultiOrPipeline();
2840      return connection.executeCommand(commandObjects.sinterstore(dstkey, keys));
2841    }
2842    @Override
2843    public long sintercard(String... keys) {
2844      checkIsInMultiOrPipeline();
2845      return connection.executeCommand(commandObjects.sintercard(keys));
2846    }
2847    @Override
2848    public long sintercard(int limit, String... keys) {
2849      checkIsInMultiOrPipeline();
2850      return connection.executeCommand(commandObjects.sintercard(limit, keys));
2851    }
2852    @Override
2853    public Set&lt;String&gt; sunion(final String... keys) {
2854      checkIsInMultiOrPipeline();
2855      return connection.executeCommand(commandObjects.sunion(keys));
2856    }
2857    @Override
2858    public long sunionstore(final String dstkey, final String... keys) {
2859      checkIsInMultiOrPipeline();
2860      return connection.executeCommand(commandObjects.sunionstore(dstkey, keys));
2861    }
2862    @Override
2863    public Set&lt;String&gt; sdiff(final String... keys) {
2864      checkIsInMultiOrPipeline();
2865      return connection.executeCommand(commandObjects.sdiff(keys));
2866    }
2867    @Override
2868    public long sdiffstore(final String dstkey, final String... keys) {
2869      checkIsInMultiOrPipeline();
2870      return connection.executeCommand(commandObjects.sdiffstore(dstkey, keys));
2871    }
2872    @Override
2873    public String srandmember(final String key) {
2874      checkIsInMultiOrPipeline();
2875      return connection.executeCommand(commandObjects.srandmember(key));
2876    }
2877    @Override
2878    public List&lt;String&gt; srandmember(final String key, final int count) {
2879      checkIsInMultiOrPipeline();
2880      return connection.executeCommand(commandObjects.srandmember(key, count));
2881    }
2882    @Override
2883    public long zadd(final String key, final double score, final String member) {
2884      checkIsInMultiOrPipeline();
2885      return connection.executeCommand(commandObjects.zadd(key, score, member));
2886    }
2887    @Override
2888    public long zadd(final String key, final double score, final String member,
2889        final ZAddParams params) {
2890      checkIsInMultiOrPipeline();
2891      return connection.executeCommand(commandObjects.zadd(key, score, member, params));
2892    }
2893    @Override
2894    public long zadd(final String key, final Map&lt;String, Double&gt; scoreMembers) {
2895      checkIsInMultiOrPipeline();
2896      return connection.executeCommand(commandObjects.zadd(key, scoreMembers));
2897    }
2898    @Override
2899    public long zadd(final String key, final Map&lt;String, Double&gt; scoreMembers, final ZAddParams params) {
2900      checkIsInMultiOrPipeline();
2901      return connection.executeCommand(commandObjects.zadd(key, scoreMembers, params));
2902    }
2903    @Override
2904    public Double zaddIncr(final String key, final double score, final String member, final ZAddParams params) {
2905      checkIsInMultiOrPipeline();
2906      return connection.executeCommand(commandObjects.zaddIncr(key, score, member, params));
2907    }
2908    @Override
2909    public List&lt;String&gt; zdiff(String... keys) {
2910      checkIsInMultiOrPipeline();
2911      return connection.executeCommand(commandObjects.zdiff(keys));
2912    }
2913    @Override
2914    public List&lt;Tuple&gt; zdiffWithScores(String... keys) {
2915      checkIsInMultiOrPipeline();
2916      return connection.executeCommand(commandObjects.zdiffWithScores(keys));
2917    }
2918    @Override
2919    @Deprecated
2920    public long zdiffStore(final String dstkey, final String... keys) {
2921      checkIsInMultiOrPipeline();
2922      return connection.executeCommand(commandObjects.zdiffStore(dstkey, keys));
2923    }
2924    @Override
2925    public long zdiffstore(final String dstkey, final String... keys) {
2926      checkIsInMultiOrPipeline();
2927      return connection.executeCommand(commandObjects.zdiffstore(dstkey, keys));
2928    }
2929    @Override
2930    public List&lt;String&gt; zrange(final String key, final long start, final long stop) {
2931      checkIsInMultiOrPipeline();
2932      return connection.executeCommand(commandObjects.zrange(key, start, stop));
2933    }
2934    @Override
2935    public long zrem(final String key, final String... members) {
2936      checkIsInMultiOrPipeline();
2937      return connection.executeCommand(commandObjects.zrem(key, members));
2938    }
2939    @Override
2940    public double zincrby(final String key, final double increment, final String member) {
2941      checkIsInMultiOrPipeline();
2942      return connection.executeCommand(commandObjects.zincrby(key, increment, member));
2943    }
2944    @Override
2945    public Double zincrby(final String key, final double increment, final String member,
2946        final ZIncrByParams params) {
2947      checkIsInMultiOrPipeline();
2948      return connection.executeCommand(commandObjects.zincrby(key, increment, member, params));
2949    }
2950    @Override
2951    public Long zrank(final String key, final String member) {
2952      checkIsInMultiOrPipeline();
2953      return connection.executeCommand(commandObjects.zrank(key, member));
2954    }
2955    @Override
2956    public Long zrevrank(final String key, final String member) {
2957      checkIsInMultiOrPipeline();
2958      return connection.executeCommand(commandObjects.zrevrank(key, member));
2959    }
2960    @Override
2961    public KeyValue&lt;Long, Double&gt; zrankWithScore(String key, String member) {
2962      checkIsInMultiOrPipeline();
2963      return connection.executeCommand(commandObjects.zrankWithScore(key, member));
2964    }
2965    @Override
2966    public KeyValue&lt;Long, Double&gt; zrevrankWithScore(String key, String member) {
2967      checkIsInMultiOrPipeline();
2968      return connection.executeCommand(commandObjects.zrevrankWithScore(key, member));
2969    }
2970    @Override
2971    public List&lt;String&gt; zrevrange(final String key, final long start, final long stop) {
2972      checkIsInMultiOrPipeline();
2973      return connection.executeCommand(commandObjects.zrevrange(key, start, stop));
2974    }
2975    @Override
2976    public List&lt;Tuple&gt; zrangeWithScores(final String key, final long start, final long stop) {
2977      checkIsInMultiOrPipeline();
2978      return connection.executeCommand(commandObjects.zrangeWithScores(key, start, stop));
2979    }
2980    @Override
2981    public List&lt;Tuple&gt; zrevrangeWithScores(final String key, final long start, final long stop) {
2982      checkIsInMultiOrPipeline();
2983      return connection.executeCommand(commandObjects.zrevrangeWithScores(key, start, stop));
2984    }
2985    @Override
2986    public List&lt;String&gt; zrange(String key, ZRangeParams zRangeParams) {
2987      checkIsInMultiOrPipeline();
2988      return connection.executeCommand(commandObjects.zrange(key, zRangeParams));
2989    }
2990    @Override
2991    public List&lt;Tuple&gt; zrangeWithScores(String key, ZRangeParams zRangeParams) {
2992      checkIsInMultiOrPipeline();
2993      return connection.executeCommand(commandObjects.zrangeWithScores(key, zRangeParams));
2994    }
2995    @Override
2996    public long zrangestore(String dest, String src, ZRangeParams zRangeParams) {
2997      checkIsInMultiOrPipeline();
2998      return connection.executeCommand(commandObjects.zrangestore(dest, src, zRangeParams));
2999    }
3000    @Override
3001    public String zrandmember(final String key) {
3002      checkIsInMultiOrPipeline();
3003      return connection.executeCommand(commandObjects.zrandmember(key));
3004    }
3005    @Override
3006    public List&lt;String&gt; zrandmember(final String key, final long count) {
3007      checkIsInMultiOrPipeline();
3008      return connection.executeCommand(commandObjects.zrandmember(key, count));
3009    }
3010    @Override
3011    public List&lt;Tuple&gt; zrandmemberWithScores(final String key, final long count) {
3012      checkIsInMultiOrPipeline();
3013      return connection.executeCommand(commandObjects.zrandmemberWithScores(key, count));
3014    }
3015    @Override
3016    public long zcard(final String key) {
3017      checkIsInMultiOrPipeline();
3018      return connection.executeCommand(commandObjects.zcard(key));
3019    }
3020    @Override
3021    public Double zscore(final String key, final String member) {
3022      checkIsInMultiOrPipeline();
3023      return connection.executeCommand(commandObjects.zscore(key, member));
3024    }
3025    @Override
3026    public List&lt;Double&gt; zmscore(final String key, final String... members) {
3027      checkIsInMultiOrPipeline();
3028      return connection.executeCommand(commandObjects.zmscore(key, members));
3029    }
3030    @Override
3031    public Tuple zpopmax(final String key) {
3032      checkIsInMultiOrPipeline();
3033      return connection.executeCommand(commandObjects.zpopmax(key));
3034    }
3035    @Override
3036    public List&lt;Tuple&gt; zpopmax(final String key, final int count) {
3037      checkIsInMultiOrPipeline();
3038      return connection.executeCommand(commandObjects.zpopmax(key, count));
3039    }
3040    @Override
3041    public Tuple zpopmin(final String key) {
3042      checkIsInMultiOrPipeline();
3043      return connection.executeCommand(commandObjects.zpopmin(key));
3044    }
3045    @Override
3046    public List&lt;Tuple&gt; zpopmin(final String key, final int count) {
3047      checkIsInMultiOrPipeline();
3048      return connection.executeCommand(commandObjects.zpopmin(key, count));
3049    }
3050    public String watch(final String... keys) {
3051      checkIsInMultiOrPipeline();
3052      connection.sendCommand(WATCH, keys);
3053      String status = connection.getStatusCodeReply();
3054      isInWatch = true;
3055      return status;
3056    }
3057    @Override
3058    public List&lt;String&gt; sort(final String key) {
3059      checkIsInMultiOrPipeline();
3060      return connection.executeCommand(commandObjects.sort(key));
3061    }
3062    @Override
3063    public List&lt;String&gt; sort(final String key, final SortingParams sortingParams) {
3064      checkIsInMultiOrPipeline();
3065      return connection.executeCommand(commandObjects.sort(key, sortingParams));
3066    }
3067    @Override
3068    public long sort(final String key, final SortingParams sortingParams, final String dstkey) {
3069      checkIsInMultiOrPipeline();
3070      return connection.executeCommand(commandObjects.sort(key, sortingParams, dstkey));
3071    }
3072    @Override
3073    public List&lt;String&gt; sortReadonly(String key, SortingParams sortingParams) {
3074      checkIsInMultiOrPipeline();
3075      return connection.executeCommand(commandObjects.sortReadonly(key, sortingParams));
3076    }
3077    @Override
3078    public long sort(final String key, final String dstkey) {
3079      checkIsInMultiOrPipeline();
3080      return connection.executeCommand(commandObjects.sort(key, dstkey));
3081    }
3082    @Override
3083    public String lmove(final String srcKey, final String dstKey, final ListDirection from,
3084        final ListDirection to) {
3085      checkIsInMultiOrPipeline();
3086      return connection.executeCommand(commandObjects.lmove(srcKey, dstKey, from, to));
3087    }
3088    @Override
3089    public String blmove(final String srcKey, final String dstKey, final ListDirection from,
3090        final ListDirection to, final double timeout) {
3091      checkIsInMultiOrPipeline();
3092      return connection.executeCommand(commandObjects.blmove(srcKey, dstKey, from, to, timeout));
3093    }
3094    @Override
3095    public List&lt;String&gt; blpop(final int timeout, final String... keys) {
3096      checkIsInMultiOrPipeline();
3097      return connection.executeCommand(commandObjects.blpop(timeout, keys));
3098    }
3099    @Override
3100    public KeyValue&lt;String, String&gt; blpop(final double timeout, final String... keys) {
3101      checkIsInMultiOrPipeline();
3102      return connection.executeCommand(commandObjects.blpop(timeout, keys));
3103    }
3104    @Override
3105    public List&lt;String&gt; brpop(final int timeout, final String... keys) {
3106      checkIsInMultiOrPipeline();
3107      return connection.executeCommand(commandObjects.brpop(timeout, keys));
3108    }
3109    @Override
3110    public KeyValue&lt;String, String&gt; brpop(final double timeout, final String... keys) {
3111      checkIsInMultiOrPipeline();
3112      return connection.executeCommand(commandObjects.brpop(timeout, keys));
3113    }
3114    @Override
3115    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, String... keys) {
3116      checkIsInMultiOrPipeline();
3117      return connection.executeCommand(commandObjects.lmpop(direction, keys));
3118    }
3119    @Override
3120    public KeyValue&lt;String, List&lt;String&gt;&gt; lmpop(ListDirection direction, int count, String... keys) {
3121      checkIsInMultiOrPipeline();
3122      return connection.executeCommand(commandObjects.lmpop(direction, count, keys));
3123    }
3124    @Override
3125    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, String... keys) {
3126      checkIsInMultiOrPipeline();
3127      return connection.executeCommand(commandObjects.blmpop(timeout, direction, keys));
3128    }
3129    @Override
3130    public KeyValue&lt;String, List&lt;String&gt;&gt; blmpop(double timeout, ListDirection direction, int count, String... keys) {
3131      checkIsInMultiOrPipeline();
3132      return connection.executeCommand(commandObjects.blmpop(timeout, direction, count, keys));
3133    }
3134    @Override
3135    public KeyValue&lt;String, Tuple&gt; bzpopmax(double timeout, String... keys) {
3136      checkIsInMultiOrPipeline();
3137      return connection.executeCommand(commandObjects.bzpopmax(timeout, keys));
3138    }
3139    @Override
3140    public KeyValue&lt;String, Tuple&gt; bzpopmin(double timeout, String... keys) {
3141      checkIsInMultiOrPipeline();
3142      return connection.executeCommand(commandObjects.bzpopmin(timeout, keys));
3143    }
3144    @Override
3145    public List&lt;String&gt; blpop(final int timeout, final String key) {
3146      checkIsInMultiOrPipeline();
3147      return connection.executeCommand(commandObjects.blpop(timeout, key));
3148    }
3149    @Override
3150    public KeyValue&lt;String, String&gt; blpop(double timeout, String key) {
3151      checkIsInMultiOrPipeline();
3152      return connection.executeCommand(commandObjects.blpop(timeout, key));
3153    }
3154    @Override
3155    public List&lt;String&gt; brpop(final int timeout, final String key) {
3156      checkIsInMultiOrPipeline();
3157      return connection.executeCommand(commandObjects.brpop(timeout, key));
3158    }
3159    @Override
3160    public KeyValue&lt;String, String&gt; brpop(double timeout, String key) {
3161      checkIsInMultiOrPipeline();
3162      return connection.executeCommand(commandObjects.brpop(timeout, key));
3163    }
3164    @Override
3165    public long zcount(final String key, final double min, final double max) {
3166      checkIsInMultiOrPipeline();
3167      return connection.executeCommand(commandObjects.zcount(key, min, max));
3168    }
3169    @Override
3170    public long zcount(final String key, final String min, final String max) {
3171      checkIsInMultiOrPipeline();
3172      return connection.executeCommand(commandObjects.zcount(key, min, max));
3173    }
3174    @Override
3175    public List&lt;String&gt; zrangeByScore(final String key, final double min, final double max) {
3176      checkIsInMultiOrPipeline();
3177      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
3178    }
3179    @Override
3180    public List&lt;String&gt; zrangeByScore(final String key, final String min, final String max) {
3181      checkIsInMultiOrPipeline();
3182      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max));
3183    }
3184    @Override
3185    public List&lt;String&gt; zrangeByScore(final String key, final double min, final double max,
3186        final int offset, final int count) {
3187      checkIsInMultiOrPipeline();
3188      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
3189    }
3190    @Override
3191    public List&lt;String&gt; zrangeByScore(final String key, final String min, final String max,
3192        final int offset, final int count) {
3193      checkIsInMultiOrPipeline();
3194      return connection.executeCommand(commandObjects.zrangeByScore(key, min, max, offset, count));
3195    }
3196    @Override
3197    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final double min, final double max) {
3198      checkIsInMultiOrPipeline();
3199      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
3200    }
3201    @Override
3202    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final String min, final String max) {
3203      checkIsInMultiOrPipeline();
3204      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max));
3205    }
3206    @Override
3207    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final double min, final double max,
3208        final int offset, final int count) {
3209      checkIsInMultiOrPipeline();
3210      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
3211    }
3212    @Override
3213    public List&lt;Tuple&gt; zrangeByScoreWithScores(final String key, final String min, final String max,
3214        final int offset, final int count) {
3215      checkIsInMultiOrPipeline();
3216      return connection.executeCommand(commandObjects.zrangeByScoreWithScores(key, min, max, offset, count));
3217    }
3218    @Override
3219    public List&lt;String&gt; zrevrangeByScore(final String key, final double max, final double min) {
3220      checkIsInMultiOrPipeline();
3221      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
3222    }
3223    @Override
3224    public List&lt;String&gt; zrevrangeByScore(final String key, final String max, final String min) {
3225      checkIsInMultiOrPipeline();
3226      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min));
3227    }
3228    @Override
3229    public List&lt;String&gt; zrevrangeByScore(final String key, final double max, final double min,
3230        final int offset, final int count) {
3231      checkIsInMultiOrPipeline();
3232      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
3233    }
3234    @Override
3235    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final double max, final double min) {
3236      checkIsInMultiOrPipeline();
3237      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
3238    }
3239    @Override
3240    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final double max,
3241        final double min, final int offset, final int count) {
3242      checkIsInMultiOrPipeline();
3243      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
3244    }
3245    @Override
3246    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final String max,
3247        final String min, final int offset, final int count) {
3248      checkIsInMultiOrPipeline();
3249      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min, offset, count));
3250    }
3251    @Override
3252    public List&lt;String&gt; zrevrangeByScore(final String key, final String max, final String min,
3253        final int offset, final int count) {
3254      checkIsInMultiOrPipeline();
3255      return connection.executeCommand(commandObjects.zrevrangeByScore(key, max, min, offset, count));
3256    }
3257    @Override
3258    public List&lt;Tuple&gt; zrevrangeByScoreWithScores(final String key, final String max, final String min) {
3259      checkIsInMultiOrPipeline();
3260      return connection.executeCommand(commandObjects.zrevrangeByScoreWithScores(key, max, min));
3261    }
3262    @Override
3263    public long zremrangeByRank(final String key, final long start, final long stop) {
3264      checkIsInMultiOrPipeline();
3265      return connection.executeCommand(commandObjects.zremrangeByRank(key, start, stop));
3266    }
3267    @Override
3268    public long zremrangeByScore(final String key, final double min, final double max) {
3269      checkIsInMultiOrPipeline();
3270      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
3271    }
3272    @Override
3273    public long zremrangeByScore(final String key, final String min, final String max) {
3274      checkIsInMultiOrPipeline();
3275      return connection.executeCommand(commandObjects.zremrangeByScore(key, min, max));
3276    }
3277    @Override
3278    public List&lt;String&gt; zunion(ZParams params, String... keys) {
3279      checkIsInMultiOrPipeline();
3280      return connection.executeCommand(commandObjects.zunion(params, keys));
3281    }
3282    @Override
3283    public List&lt;Tuple&gt; zunionWithScores(ZParams params, String... keys) {
3284      checkIsInMultiOrPipeline();
3285      return connection.executeCommand(commandObjects.zunionWithScores(params, keys));
3286    }
3287    @Override
3288    public long zunionstore(final String dstkey, final String... sets) {
3289      checkIsInMultiOrPipeline();
3290      return connection.executeCommand(commandObjects.zunionstore(dstkey, sets));
3291    }
3292    @Override
3293    public long zunionstore(final String dstkey, final ZParams params, final String... sets) {
3294      checkIsInMultiOrPipeline();
3295      return connection.executeCommand(commandObjects.zunionstore(dstkey, params, sets));
3296    }
3297    @Override
3298    public List&lt;String&gt; zinter(final ZParams params, final String... keys) {
3299      checkIsInMultiOrPipeline();
3300      return connection.executeCommand(commandObjects.zinter(params, keys));
3301    }
3302    @Override
3303    public List&lt;Tuple&gt; zinterWithScores(final ZParams params, final String... keys) {
3304      checkIsInMultiOrPipeline();
3305      return connection.executeCommand(commandObjects.zinterWithScores(params, keys));
3306    }
3307    @Override
3308    public long zintercard(String... keys) {
3309      checkIsInMultiOrPipeline();
3310      return connection.executeCommand(commandObjects.zintercard(keys));
3311    }
3312    @Override
3313    public long zintercard(long limit, String... keys) {
3314      checkIsInMultiOrPipeline();
3315      return connection.executeCommand(commandObjects.zintercard(limit, keys));
3316    }
3317    @Override
3318    public long zinterstore(final String dstkey, final String... sets) {
3319      checkIsInMultiOrPipeline();
3320      return connection.executeCommand(commandObjects.zinterstore(dstkey, sets));
3321    }
3322    @Override
3323    public long zinterstore(final String dstkey, final ZParams params, final String... sets) {
3324      checkIsInMultiOrPipeline();
3325      return connection.executeCommand(commandObjects.zinterstore(dstkey, params, sets));
3326    }
3327    @Override
3328    public long zlexcount(final String key, final String min, final String max) {
3329      checkIsInMultiOrPipeline();
3330      return connection.executeCommand(commandObjects.zlexcount(key, min, max));
3331    }
3332    @Override
3333    public List&lt;String&gt; zrangeByLex(final String key, final String min, final String max) {
3334      checkIsInMultiOrPipeline();
3335      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max));
3336    }
3337    @Override
3338    public List&lt;String&gt; zrangeByLex(final String key, final String min, final String max,
3339        final int offset, final int count) {
3340      checkIsInMultiOrPipeline();
3341      return connection.executeCommand(commandObjects.zrangeByLex(key, min, max, offset, count));
3342    }
3343    @Override
3344    public List&lt;String&gt; zrevrangeByLex(final String key, final String max, final String min) {
3345      checkIsInMultiOrPipeline();
3346      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min));
3347    }
3348    @Override
3349    public List&lt;String&gt; zrevrangeByLex(final String key, final String max, final String min,
3350        final int offset, final int count) {
3351      checkIsInMultiOrPipeline();
3352      return connection.executeCommand(commandObjects.zrevrangeByLex(key, max, min, offset, count));
3353    }
3354    @Override
3355    public long zremrangeByLex(final String key, final String min, final String max) {
3356      checkIsInMultiOrPipeline();
3357      return connection.executeCommand(commandObjects.zremrangeByLex(key, min, max));
3358    }
3359    @Override
3360    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, String... keys) {
3361      checkIsInMultiOrPipeline();
3362      return connection.executeCommand(commandObjects.zmpop(option, keys));
3363    }
3364    @Override
3365    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; zmpop(SortedSetOption option, int count, String... keys) {
3366      checkIsInMultiOrPipeline();
3367      return connection.executeCommand(commandObjects.zmpop(option, count, keys));
3368    }
3369    @Override
3370    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, String... keys) {
3371      checkIsInMultiOrPipeline();
3372      return connection.executeCommand(commandObjects.bzmpop(timeout, option, keys));
3373    }
3374    @Override
3375    public KeyValue&lt;String, List&lt;Tuple&gt;&gt; bzmpop(double timeout, SortedSetOption option, int count, String... keys) {
3376      checkIsInMultiOrPipeline();
3377      return connection.executeCommand(commandObjects.bzmpop(timeout, option, count, keys));
3378    }
3379    @Override
3380    public long strlen(final String key) {
3381      checkIsInMultiOrPipeline();
3382      return connection.executeCommand(commandObjects.strlen(key));
3383    }
3384    @Override
3385    public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {
3386      checkIsInMultiOrPipeline();
3387      return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));
3388    }
3389    @Override
3390    public long lpushx(final String key, final String... strings) {
3391      checkIsInMultiOrPipeline();
3392      return connection.executeCommand(commandObjects.lpushx(key, strings));
3393    }
3394    @Override
3395    public long persist(final String key) {
3396      checkIsInMultiOrPipeline();
3397      return connection.executeCommand(commandObjects.persist(key));
3398    }
3399    @Override
3400    public long rpushx(final String key, final String... strings) {
3401      checkIsInMultiOrPipeline();
3402      return connection.executeCommand(commandObjects.rpushx(key, strings));
3403    }
3404    @Override
3405    public String echo(final String string) {
3406      checkIsInMultiOrPipeline();
3407      connection.sendCommand(ECHO, string);
3408      return connection.getBulkReply();
3409    }
3410    @Override
3411    public long linsert(final String key, final ListPosition where, final String pivot,
3412        final String value) {
3413      checkIsInMultiOrPipeline();
3414      return connection.executeCommand(commandObjects.linsert(key, where, pivot, value));
3415    }
3416    @Override
3417    public String brpoplpush(final String source, final String destination, final int timeout) {
3418      checkIsInMultiOrPipeline();
3419      return connection.executeCommand(commandObjects.brpoplpush(source, destination, timeout));
3420    }
3421    @Override
3422    public boolean setbit(final String key, final long offset, final boolean value) {
3423      checkIsInMultiOrPipeline();
3424      return connection.executeCommand(commandObjects.setbit(key, offset, value));
3425    }
3426    @Override
3427    public boolean getbit(final String key, final long offset) {
3428      checkIsInMultiOrPipeline();
3429      return connection.executeCommand(commandObjects.getbit(key, offset));
3430    }
3431    @Override
3432    public long setrange(final String key, final long offset, final String value) {
3433      checkIsInMultiOrPipeline();
3434      return connection.executeCommand(commandObjects.setrange(key, offset, value));
3435    }
3436    @Override
3437    public String getrange(final String key, final long startOffset, final long endOffset) {
3438      checkIsInMultiOrPipeline();
3439      return connection.executeCommand(commandObjects.getrange(key, startOffset, endOffset));
3440    }
3441    @Override
3442    public long bitpos(final String key, final boolean value) {
3443      checkIsInMultiOrPipeline();
3444      return connection.executeCommand(commandObjects.bitpos(key, value));
3445    }
3446    @Override
3447    public long bitpos(final String key, final boolean value, final BitPosParams params) {
3448      checkIsInMultiOrPipeline();
3449      return connection.executeCommand(commandObjects.bitpos(key, value, params));
3450    }
3451    @Override
3452    public List&lt;Object&gt; role() {
3453      checkIsInMultiOrPipeline();
3454      connection.sendCommand(ROLE);
3455      return BuilderFactory.ENCODED_OBJECT_LIST.build(connection.getOne());
3456    }
3457    @Override
3458    public Map&lt;String, String&gt; configGet(final String pattern) {
3459      checkIsInMultiOrPipeline();
3460      connection.sendCommand(Command.CONFIG, Keyword.GET.name(), pattern);
3461      return BuilderFactory.STRING_MAP.build(connection.getOne());
3462    }
3463    @Override
3464    public Map&lt;String, String&gt; configGet(String... patterns) {
3465      checkIsInMultiOrPipeline();
3466      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.GET.name(), patterns));
3467      return BuilderFactory.STRING_MAP.build(connection.getOne());
3468    }
3469    @Override
3470    public String configSet(final String parameter, final String value) {
3471      checkIsInMultiOrPipeline();
3472      connection.sendCommand(Command.CONFIG, Keyword.SET.name(), parameter, value);
3473      return connection.getStatusCodeReply();
3474    }
3475    @Override
3476    public String configSet(final String... parameterValues) {
3477      checkIsInMultiOrPipeline();
3478      connection.sendCommand(Command.CONFIG, joinParameters(Keyword.SET.name(), parameterValues));
3479      return connection.getStatusCodeReply();
3480    }
3481    @Override
3482    public String configSet(Map&lt;String, String&gt; parameterValues) {
3483      checkIsInMultiOrPipeline();
3484      CommandArguments args = new CommandArguments(Command.CONFIG).add(Keyword.SET);
3485      parameterValues.forEach((k, v) -&gt; args.add(k).add(v));
3486      connection.sendCommand(args);
3487      return connection.getStatusCodeReply();
3488    }
3489    public long publish(final String channel, final String message) {
3490      checkIsInMultiOrPipeline();
3491      connection.sendCommand(PUBLISH, channel, message);
3492      return connection.getIntegerReply();
3493    }
3494    public void subscribe(final JedisPubSub jedisPubSub, final String... channels) {
3495      jedisPubSub.proceed(connection, channels);
3496    }
3497    public void psubscribe(final JedisPubSub jedisPubSub, final String... patterns) {
3498      jedisPubSub.proceedWithPatterns(connection, patterns);
3499    }
3500    public List&lt;String&gt; pubsubChannels() {
3501      checkIsInMultiOrPipeline();
3502      connection.sendCommand(PUBSUB, CHANNELS);
3503      return connection.getMultiBulkReply();
3504    }
3505    public List&lt;String&gt; pubsubChannels(final String pattern) {
3506      checkIsInMultiOrPipeline();
3507      connection.sendCommand(PUBSUB, CHANNELS.name(), pattern);
3508      return connection.getMultiBulkReply();
3509    }
3510    public Long pubsubNumPat() {
3511      checkIsInMultiOrPipeline();
3512      connection.sendCommand(PUBSUB, NUMPAT);
3513      return connection.getIntegerReply();
3514    }
3515    public Map&lt;String, Long&gt; pubsubNumSub(String... channels) {
3516      checkIsInMultiOrPipeline();
3517      connection.sendCommand(PUBSUB, joinParameters(NUMSUB.name(), channels));
3518      return BuilderFactory.PUBSUB_NUMSUB_MAP.build(connection.getOne());
3519    }
3520    public List&lt;String&gt; pubsubShardChannels() {
3521      checkIsInMultiOrPipeline();
3522      connection.sendCommand(PUBSUB, SHARDCHANNELS);
3523      return connection.getMultiBulkReply();
3524    }
3525    public List&lt;String&gt; pubsubShardChannels(final String pattern) {
3526      checkIsInMultiOrPipeline();
3527      connection.sendCommand(PUBSUB, SHARDCHANNELS.name(), pattern);
3528      return connection.getMultiBulkReply();
3529    }
3530    public Map&lt;String, Long&gt; pubsubShardNumSub(String... channels) {
3531      checkIsInMultiOrPipeline();
3532      connection.sendCommand(PUBSUB, joinParameters(SHARDNUMSUB.name(), channels));
3533      return BuilderFactory.PUBSUB_NUMSUB_MAP.build(connection.getOne());
3534    }
3535    @Override
3536    public Object eval(final String script, final int keyCount, final String... params) {
3537      checkIsInMultiOrPipeline();
3538      return connection.executeCommand(commandObjects.eval(script, keyCount, params));
3539    }
3540    @Override
3541    public Object eval(final String script, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
3542      checkIsInMultiOrPipeline();
3543      return connection.executeCommand(commandObjects.eval(script, keys, args));
3544    }
3545    @Override
3546    public Object evalReadonly(String script, List&lt;String&gt; keys, List&lt;String&gt; args) {
3547      checkIsInMultiOrPipeline();
3548      return connection.executeCommand(commandObjects.evalReadonly(script, keys, args));
3549    }
3550    @Override
3551    public Object eval(final String script) {
3552      checkIsInMultiOrPipeline();
3553      return connection.executeCommand(commandObjects.eval(script));
3554    }
3555    @Override
3556    public Object evalsha(final String sha1) {
3557      checkIsInMultiOrPipeline();
3558      return connection.executeCommand(commandObjects.evalsha(sha1));
3559    }
3560    @Override
3561    public Object evalsha(final String sha1, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
3562      checkIsInMultiOrPipeline();
3563      return connection.executeCommand(commandObjects.evalsha(sha1, keys, args));
3564    }
3565    @Override
3566    public Object evalshaReadonly(String sha1, List&lt;String&gt; keys, List&lt;String&gt; args) {
3567      checkIsInMultiOrPipeline();
3568      return connection.executeCommand(commandObjects.evalshaReadonly(sha1, keys, args));
3569    }
3570    @Override
3571    public Object evalsha(final String sha1, final int keyCount, final String... params) {
3572      checkIsInMultiOrPipeline();
3573      return connection.executeCommand(commandObjects.evalsha(sha1, keyCount, params));
3574    }
3575    @Override
3576    public Boolean scriptExists(final String sha1) {
3577      String[] a = new String[1];
3578      a[0] = sha1;
3579      return scriptExists(a).get(0);
3580    }
3581    @Override
3582    public List&lt;Boolean&gt; scriptExists(final String... sha1) {
3583      connection.sendCommand(SCRIPT, joinParameters(Keyword.EXISTS.name(), sha1));
3584      return BuilderFactory.BOOLEAN_LIST.build(connection.getOne());
3585    }
3586    @Override
3587    public String scriptLoad(final String script) {
3588      connection.sendCommand(SCRIPT, LOAD.name(), script);
3589      return connection.getBulkReply();
3590    }
3591    @Override
3592    public List&lt;Slowlog&gt; slowlogGet() {
3593      connection.sendCommand(SLOWLOG, Keyword.GET);
3594      return Slowlog.from(connection.getObjectMultiBulkReply());
3595    }
3596    @Override
3597    public List&lt;Slowlog&gt; slowlogGet(final long entries) {
3598      connection.sendCommand(SLOWLOG, Keyword.GET.getRaw(), toByteArray(entries));
3599      return Slowlog.from(connection.getObjectMultiBulkReply());
3600    }
3601    @Override
3602    public Long objectRefcount(final String key) {
3603      connection.sendCommand(OBJECT, REFCOUNT.name(), key);
3604      return connection.getIntegerReply();
3605    }
3606    @Override
3607    public String objectEncoding(final String key) {
3608      connection.sendCommand(OBJECT, ENCODING.name(), key);
3609      return connection.getBulkReply();
3610    }
3611    @Override
3612    public Long objectIdletime(final String key) {
3613      connection.sendCommand(OBJECT, IDLETIME.name(), key);
3614      return connection.getIntegerReply();
3615    }
3616    @Override
3617    public List&lt;String&gt; objectHelp() {
3618      connection.sendCommand(OBJECT, HELP);
3619      return connection.getMultiBulkReply();
3620    }
3621    @Override
3622    public Long objectFreq(final String key) {
3623      connection.sendCommand(OBJECT, FREQ.name(), key);
3624      return connection.getIntegerReply();
3625    }
3626    @Override
3627    public long bitcount(final String key) {
3628      checkIsInMultiOrPipeline();
3629      return connection.executeCommand(commandObjects.bitcount(key));
3630    }
3631    @Override
3632    public long bitcount(final String key, final long start, final long end) {
3633      checkIsInMultiOrPipeline();
3634      return connection.executeCommand(commandObjects.bitcount(key, start, end));
3635    }
3636    @Override
3637    public long bitcount(final String key, final long start, final long end, final BitCountOption option) {
3638      checkIsInMultiOrPipeline();
3639      return connection.executeCommand(commandObjects.bitcount(key, start, end, option));
3640    }
3641    @Override
3642    public long bitop(final BitOP op, final String destKey, final String... srcKeys) {
3643      checkIsInMultiOrPipeline();
3644      return connection.executeCommand(commandObjects.bitop(op, destKey, srcKeys));
3645    }
3646    public long commandCount() {
3647      checkIsInMultiOrPipeline();
3648      connection.sendCommand(COMMAND, COUNT);
3649      return connection.getIntegerReply();
3650    }
3651    public Map&lt;String, CommandDocument&gt; commandDocs(String... commands) {
3652      checkIsInMultiOrPipeline();
3653      connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));
3654      return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());
3655    }
3656    public List&lt;String&gt; commandGetKeys(String... command) {
3657      checkIsInMultiOrPipeline();
3658      connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));
3659      return BuilderFactory.STRING_LIST.build(connection.getOne());
3660    }
3661    public List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt; commandGetKeysAndFlags(String... command) {
3662      checkIsInMultiOrPipeline();
3663      connection.sendCommand(COMMAND, joinParameters(GETKEYSANDFLAGS.name(), command));
3664      return BuilderFactory.KEYED_STRING_LIST_LIST.build(connection.getOne());
3665    }
3666    public Map&lt;String, CommandInfo&gt; commandInfo(String... commands) {
3667      checkIsInMultiOrPipeline();
3668      connection.sendCommand(COMMAND, joinParameters(Keyword.INFO.name(), commands));
3669      return BuilderFactory.COMMAND_INFO_RESPONSE.build(connection.getOne());
3670    }
3671    public List&lt;String&gt; commandList() {
3672      checkIsInMultiOrPipeline();
3673      connection.sendCommand(COMMAND, LIST);
3674      return BuilderFactory.STRING_LIST.build(connection.getOne());
3675    }
3676    public List&lt;String&gt; commandListFilterBy(CommandListFilterByParams filterByParams) {
3677      checkIsInMultiOrPipeline();
3678      CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);
3679      connection.sendCommand(args);
3680      return BuilderFactory.STRING_LIST.build(connection.getOne());
3681    }
3682    @Override
3683    public String sentinelMyId() {
3684      connection.sendCommand(SENTINEL, MYID);
3685      return connection.getBulkReply();
3686    }
3687    @Override
3688    public List&lt;Map&lt;String, String&gt;&gt; sentinelMasters() {
3689      connection.sendCommand(SENTINEL, MASTERS);
3690      return connection.getObjectMultiBulkReply().stream()
3691          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3692    }
3693    @Override
3694    public Map&lt;String, String&gt; sentinelMaster(String masterName) {
3695      connection.sendCommand(SENTINEL, MASTER.name(), masterName);
3696      return BuilderFactory.STRING_MAP.build(connection.getOne());
3697    }
3698    @Override
3699    public List&lt;Map&lt;String, String&gt;&gt; sentinelSentinels(String masterName) {
3700      connection.sendCommand(SENTINEL, SENTINELS.name(), masterName);
3701      return connection.getObjectMultiBulkReply().stream()
3702          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3703    }
3704    @Override
3705    public List&lt;String&gt; sentinelGetMasterAddrByName(String masterName) {
3706      connection.sendCommand(SENTINEL, GET_MASTER_ADDR_BY_NAME.getRaw(), encode(masterName));
3707      return connection.getMultiBulkReply();
3708    }
3709    @Override
3710    public Long sentinelReset(String pattern) {
3711      connection.sendCommand(SENTINEL, SentinelKeyword.RESET.name(), pattern);
3712      return connection.getIntegerReply();
3713    }
3714    @Override
3715    @Deprecated
3716    public List&lt;Map&lt;String, String&gt;&gt; sentinelSlaves(String masterName) {
3717      connection.sendCommand(SENTINEL, SLAVES.name(), masterName);
3718      return connection.getObjectMultiBulkReply().stream()
3719          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3720    }
3721    @Override
3722    public List&lt;Map&lt;String, String&gt;&gt; sentinelReplicas(String masterName) {
3723      connection.sendCommand(SENTINEL, REPLICAS.name(), masterName);
3724      return connection.getObjectMultiBulkReply().stream()
3725          .map(BuilderFactory.STRING_MAP::build).collect(Collectors.toList());
3726    }
3727    @Override
3728    public String sentinelFailover(String masterName) {
3729      connection.sendCommand(SENTINEL, SentinelKeyword.FAILOVER.name(), masterName);
3730      return connection.getStatusCodeReply();
3731    }
3732    @Override
3733    public String sentinelMonitor(String masterName, String ip, int port, int quorum) {
3734      CommandArguments args = new CommandArguments(SENTINEL).add(SentinelKeyword.MONITOR)
3735          .add(masterName).add(ip).add(port).add(quorum);
3736      connection.sendCommand(args);
3737      return connection.getStatusCodeReply();
3738    }
3739    @Override
3740    public String sentinelRemove(String masterName) {
3741      connection.sendCommand(SENTINEL, REMOVE.name(), masterName);
3742      return connection.getStatusCodeReply();
3743    }
3744    @Override
3745    public String sentinelSet(String masterName, Map&lt;String, String&gt; parameterMap) {
3746      CommandArguments args = new CommandArguments(SENTINEL).add(SentinelKeyword.SET).add(masterName);
3747      parameterMap.entrySet().forEach(entry -&gt; args.add(entry.getKey()).add(entry.getValue()));
3748      connection.sendCommand(args);
3749      return connection.getStatusCodeReply();
3750    }
3751    @Override
3752    public byte[] dump(final String key) {
3753      checkIsInMultiOrPipeline();
3754      return connection.executeCommand(commandObjects.dump(key));
3755    }
3756    @Override
3757    public String restore(final String key, final long ttl, final byte[] serializedValue) {
3758      checkIsInMultiOrPipeline();
3759      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue));
3760    }
3761    @Override
3762    public String restore(final String key, final long ttl, final byte[] serializedValue,
3763        final RestoreParams params) {
3764      checkIsInMultiOrPipeline();
3765      return connection.executeCommand(commandObjects.restore(key, ttl, serializedValue, params));
3766    }
3767    @Override
3768    public long pttl(final String key) {
3769      checkIsInMultiOrPipeline();
3770      return connection.executeCommand(commandObjects.pttl(key));
3771    }
3772    @Override
3773    public String psetex(final String key, final long milliseconds, final String value) {
3774      checkIsInMultiOrPipeline();
3775      return connection.executeCommand(commandObjects.psetex(key, milliseconds, value));
3776    }
3777    @Override
3778    public String aclSetUser(final String name) {
3779      checkIsInMultiOrPipeline();
3780      connection.sendCommand(ACL, SETUSER.name(), name);
3781      return connection.getStatusCodeReply();
3782    }
3783    @Override
3784    public String aclSetUser(String name, String... rules) {
3785      checkIsInMultiOrPipeline();
3786      connection.sendCommand(ACL, joinParameters(SETUSER.name(), name, rules));
3787      return connection.getStatusCodeReply();
3788    }
3789    @Override
3790    public long aclDelUser(final String... names) {
3791      checkIsInMultiOrPipeline();
3792      connection.sendCommand(ACL, joinParameters(DELUSER.name(), names));
3793      return connection.getIntegerReply();
3794    }
3795    @Override
3796    public AccessControlUser aclGetUser(final String name) {
3797      checkIsInMultiOrPipeline();
3798      connection.sendCommand(ACL, GETUSER.name(), name);
3799      return BuilderFactory.ACCESS_CONTROL_USER.build(connection.getOne());
3800    }
3801    @Override
3802    public List&lt;String&gt; aclUsers() {
3803      checkIsInMultiOrPipeline();
3804      connection.sendCommand(ACL, USERS);
3805      return BuilderFactory.STRING_LIST.build(connection.getObjectMultiBulkReply());
3806    }
3807    @Override
3808    public List&lt;String&gt; aclList() {
3809      checkIsInMultiOrPipeline();
3810      connection.sendCommand(ACL, LIST);
3811      return connection.getMultiBulkReply();
3812    }
3813    @Override
3814    public String aclWhoAmI() {
3815      checkIsInMultiOrPipeline();
3816      connection.sendCommand(ACL, WHOAMI);
3817      return connection.getStatusCodeReply();
3818    }
3819    @Override
3820    public List&lt;String&gt; aclCat() {
3821      checkIsInMultiOrPipeline();
3822      connection.sendCommand(ACL, CAT);
3823      return BuilderFactory.STRING_LIST.build(connection.getOne());
3824    }
3825    @Override
3826    public List&lt;String&gt; aclCat(String category) {
3827      checkIsInMultiOrPipeline();
3828      connection.sendCommand(ACL, CAT.name(), category);
3829      return BuilderFactory.STRING_LIST.build(connection.getOne());
3830    }
3831    @Override
3832    public List&lt;AccessControlLogEntry&gt; aclLog() {
3833      checkIsInMultiOrPipeline();
3834      connection.sendCommand(ACL, LOG);
3835      return BuilderFactory.ACCESS_CONTROL_LOG_ENTRY_LIST.build(connection.getOne());
3836    }
3837    @Override
3838    public List&lt;AccessControlLogEntry&gt; aclLog(int limit) {
3839      checkIsInMultiOrPipeline();
3840      connection.sendCommand(ACL, LOG.getRaw(), toByteArray(limit));
3841      return BuilderFactory.ACCESS_CONTROL_LOG_ENTRY_LIST.build(connection.getOne());
3842    }
3843    @Override
3844    public String aclLoad() {
3845      checkIsInMultiOrPipeline();
3846      connection.sendCommand(ACL, LOAD);
3847      return connection.getStatusCodeReply();
3848    }
3849    @Override
3850    public String aclSave() {
3851      checkIsInMultiOrPipeline();
3852      connection.sendCommand(ACL, Keyword.SAVE);
3853      return connection.getStatusCodeReply();
3854    }
3855    @Override
3856    public String aclGenPass() {
3857      connection.sendCommand(ACL, GENPASS);
3858      return connection.getBulkReply();
3859    }
3860    @Override
3861    public String aclGenPass(int bits) {
3862      checkIsInMultiOrPipeline();
3863      connection.sendCommand(ACL, GENPASS.getRaw(), toByteArray(bits));
3864      return connection.getBulkReply();
3865    }
3866    @Override
3867    public String aclDryRun(String username, String command, String... args) {
3868      checkIsInMultiOrPipeline();
3869      String[] allArgs = new String[3 + args.length];
3870      allArgs[0] = DRYRUN.name();
3871      allArgs[1] = username;
3872      allArgs[2] = command;
3873      System.arraycopy(args, 0, allArgs, 3, args.length);
3874      connection.sendCommand(ACL, allArgs);
3875      return connection.getBulkReply();
3876    }
3877    @Override
3878    public String aclDryRun(String username, CommandArguments commandArgs) {
3879      checkIsInMultiOrPipeline();
3880      CommandArguments allArgs = new CommandArguments(ACL).add(DRYRUN).add(username);
3881      Iterator&lt;Rawable&gt; it = commandArgs.iterator();
3882      while (it.hasNext()) allArgs.add(it.next());
3883      connection.sendCommand(allArgs);
3884      return connection.getBulkReply();
3885    }
3886    @Override
3887    public byte[] aclDryRunBinary(byte[] username, byte[] command, byte[]... args) {
3888      checkIsInMultiOrPipeline();
3889      byte[][] allArgs = new byte[3 + args.length][];
3890      allArgs[0] = DRYRUN.getRaw();
3891      allArgs[1] = username;
3892      allArgs[2] = command;
3893      System.arraycopy(args, 0, allArgs, 3, args.length);
3894      connection.sendCommand(ACL, allArgs);
3895      return connection.getBinaryBulkReply();
3896    }
3897    @Override
3898    public byte[] aclDryRunBinary(byte[] username, CommandArguments commandArgs) {
3899      checkIsInMultiOrPipeline();
3900      CommandArguments allArgs = new CommandArguments(ACL).add(DRYRUN).add(username);
3901      Iterator&lt;Rawable&gt; it = commandArgs.iterator();
3902      while (it.hasNext()) allArgs.add(it.next());
3903      connection.sendCommand(allArgs);
3904      return connection.getBinaryBulkReply();
3905    }
3906    @Override
3907    public String clientKill(final String ipPort) {
3908      checkIsInMultiOrPipeline();
3909      connection.sendCommand(CLIENT, KILL.name(), ipPort);
3910      return connection.getStatusCodeReply();
3911    }
3912    @Override
3913    public String clientGetname() {
3914      checkIsInMultiOrPipeline();
3915      connection.sendCommand(CLIENT, GETNAME);
3916      return connection.getBulkReply();
3917    }
3918    @Override
3919    public String clientList() {
3920      checkIsInMultiOrPipeline();
3921      connection.sendCommand(CLIENT, LIST);
3922      return connection.getBulkReply();
3923    }
3924    @Override
3925    public String clientList(ClientType type) {
3926      checkIsInMultiOrPipeline();
3927      connection.sendCommand(CLIENT, LIST.getRaw(), Keyword.TYPE.getRaw(), type.getRaw());
3928      return connection.getBulkReply();
3929    }
3930    @Override
3931    public String clientList(final long... clientIds) {
3932      checkIsInMultiOrPipeline();
3933      connection.sendCommand(CLIENT, clientListParams(clientIds));
3934      return connection.getBulkReply();
3935    }
3936    @Override
3937    public String clientInfo() {
3938      checkIsInMultiOrPipeline();
3939      connection.sendCommand(CLIENT, Keyword.INFO);
3940      return connection.getBulkReply();
3941    }
3942    @Override
3943    public String clientSetInfo(ClientAttributeOption attr, String value) {
3944      checkIsInMultiOrPipeline();
3945      connection.sendCommand(CLIENT, SETINFO.getRaw(), attr.getRaw(), encode(value));
3946      return connection.getStatusCodeReply();
3947    }
3948    @Override
3949    public String clientSetname(final String name) {
3950      checkIsInMultiOrPipeline();
3951      connection.sendCommand(CLIENT, SETNAME.name(), name);
3952      return connection.getStatusCodeReply();
3953    }
3954    @Override
3955    public String migrate(final String host, final int port, final String key,
3956        final int destinationDb, final int timeout) {
3957      checkIsInMultiOrPipeline();
3958      return connection.executeCommand(commandObjects.migrate(host, port, key, destinationDb, timeout));
3959    }
3960    @Override
3961    public String migrate(final String host, final int port, final int destinationDB,
3962        final int timeout, final MigrateParams params, final String... keys) {
3963      checkIsInMultiOrPipeline();
3964      return connection.executeCommand(commandObjects.migrate(host, port, destinationDB, timeout, params, keys));
3965    }
3966    @Override
3967    public String migrate(String host, int port, String key, int timeout) {
3968      checkIsInMultiOrPipeline();
3969      return connection.executeCommand(commandObjects.migrate(host, port, key, timeout));
3970    }
3971    @Override
3972    public String migrate(String host, int port, int timeout, MigrateParams params, String... keys) {
3973      checkIsInMultiOrPipeline();
3974      return connection.executeCommand(commandObjects.migrate(host, port, timeout, params, keys));
3975    }
3976    @Override
3977    public ScanResult&lt;String&gt; scan(final String cursor) {
3978      return connection.executeCommand(commandObjects.scan(cursor));
3979    }
3980    @Override
3981    public ScanResult&lt;String&gt; scan(final String cursor, final ScanParams params) {
3982      return connection.executeCommand(commandObjects.scan(cursor, params));
3983    }
3984    @Override
3985    public ScanResult&lt;String&gt; scan(final String cursor, final ScanParams params, final String type) {
3986      checkIsInMultiOrPipeline();
3987      return connection.executeCommand(commandObjects.scan(cursor, params, type));
3988    }
3989    @Override
3990    public ScanResult&lt;Map.Entry&lt;String, String&gt;&gt; hscan(final String key, final String cursor,
3991        final ScanParams params) {
3992      checkIsInMultiOrPipeline();
3993      return connection.executeCommand(commandObjects.hscan(key, cursor, params));
3994    }
3995    @Override
3996    public ScanResult&lt;String&gt; sscan(final String key, final String cursor, final ScanParams params) {
3997      checkIsInMultiOrPipeline();
3998      return connection.executeCommand(commandObjects.sscan(key, cursor, params));
3999    }
4000    @Override
4001    public ScanResult&lt;Tuple&gt; zscan(final String key, final String cursor, final ScanParams params) {
4002      checkIsInMultiOrPipeline();
4003      return connection.executeCommand(commandObjects.zscan(key, cursor, params));
4004    }
4005    @Override
4006    public String readonly() {
4007      checkIsInMultiOrPipeline();
4008      connection.sendCommand(READONLY);
4009      return connection.getStatusCodeReply();
4010    }
4011    @Override
4012    public String readwrite() {
4013      checkIsInMultiOrPipeline();
4014      connection.sendCommand(READWRITE);
4015      return connection.getStatusCodeReply();
4016    }
4017    @Override
4018    public String clusterNodes() {
4019      checkIsInMultiOrPipeline();
4020      connection.sendCommand(CLUSTER, ClusterKeyword.NODES);
4021      return connection.getBulkReply();
4022    }
4023    @Override
4024    public String clusterMeet(final String ip, final int port) {
4025      checkIsInMultiOrPipeline();
4026      connection.sendCommand(CLUSTER, ClusterKeyword.MEET.name(), ip, Integer.toString(port));
4027      return connection.getStatusCodeReply();
4028    }
4029    @Override
4030    public String clusterReset() {
4031      checkIsInMultiOrPipeline();
4032      connection.sendCommand(CLUSTER, ClusterKeyword.RESET);
4033      return connection.getStatusCodeReply();
4034    }
4035    @Override
4036    public String clusterReset(final ClusterResetType resetType) {
4037      checkIsInMultiOrPipeline();
4038      connection.sendCommand(CLUSTER, ClusterKeyword.RESET.getRaw(), resetType.getRaw());
4039      return connection.getStatusCodeReply();
4040    }
4041    @Override
4042    public String clusterAddSlots(final int... slots) {
4043      checkIsInMultiOrPipeline();
4044      connection.sendCommand(CLUSTER, joinParameters(ClusterKeyword.ADDSLOTS.getRaw(), joinParameters(slots)));
4045      return connection.getStatusCodeReply();
4046    }
4047    @Override
4048    public String clusterDelSlots(final int... slots) {
4049      checkIsInMultiOrPipeline();
4050      connection.sendCommand(CLUSTER, joinParameters(ClusterKeyword.DELSLOTS.getRaw(), joinParameters(slots)));
4051      return connection.getStatusCodeReply();
4052    }
4053    @Override
4054    public String clusterInfo() {
4055      checkIsInMultiOrPipeline();
4056      connection.sendCommand(CLUSTER, ClusterKeyword.INFO);
4057      return connection.getStatusCodeReply();
4058    }
4059    @Override
4060    public List&lt;String&gt; clusterGetKeysInSlot(final int slot, final int count) {
4061      checkIsInMultiOrPipeline();
4062      connection.sendCommand(CLUSTER, ClusterKeyword.GETKEYSINSLOT.getRaw(), toByteArray(slot), toByteArray(count));
4063      return connection.getMultiBulkReply();
4064    }
4065    @Override
4066    public List&lt;byte[]&gt; clusterGetKeysInSlotBinary(final int slot, final int count) {
4067      checkIsInMultiOrPipeline();
4068      connection.sendCommand(CLUSTER, ClusterKeyword.GETKEYSINSLOT.getRaw(), toByteArray(slot), toByteArray(count));
4069      return connection.getBinaryMultiBulkReply();
4070    }
4071    @Override
4072    public String clusterSetSlotNode(final int slot, final String nodeId) {
4073      checkIsInMultiOrPipeline();
4074      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.NODE.getRaw(), encode(nodeId));
4075      return connection.getStatusCodeReply();
4076    }
4077    @Override
4078    public String clusterSetSlotMigrating(final int slot, final String nodeId) {
4079      checkIsInMultiOrPipeline();
4080      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.MIGRATING.getRaw(), encode(nodeId));
4081      return connection.getStatusCodeReply();
4082    }
4083    @Override
4084    public String clusterSetSlotImporting(final int slot, final String nodeId) {
4085      checkIsInMultiOrPipeline();
4086      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.IMPORTING.getRaw(), encode(nodeId));
4087      return connection.getStatusCodeReply();
4088    }
4089    @Override
4090    public String clusterSetSlotStable(final int slot) {
4091      checkIsInMultiOrPipeline();
4092      connection.sendCommand(CLUSTER, ClusterKeyword.SETSLOT.getRaw(), toByteArray(slot), ClusterKeyword.STABLE.getRaw());
4093      return connection.getStatusCodeReply();
4094    }
4095    @Override
4096    public String clusterForget(final String nodeId) {
4097      checkIsInMultiOrPipeline();
4098      connection.sendCommand(CLUSTER, ClusterKeyword.FORGET.name(), nodeId);
4099      return connection.getStatusCodeReply();
4100    }
4101    @Override
4102    public String clusterFlushSlots() {
4103      checkIsInMultiOrPipeline();
4104      connection.sendCommand(CLUSTER, ClusterKeyword.FLUSHSLOTS);
4105      return connection.getStatusCodeReply();
4106    }
4107    @Override
4108    public long clusterKeySlot(final String key) {
4109      checkIsInMultiOrPipeline();
4110      connection.sendCommand(CLUSTER, ClusterKeyword.KEYSLOT.name(), key);
4111      return connection.getIntegerReply();
4112    }
4113    @Override
4114    public long clusterCountFailureReports(final String nodeId) {
4115      checkIsInMultiOrPipeline();
4116      connection.sendCommand(CLUSTER, &quot;COUNT-FAILURE-REPORTS&quot;,  nodeId);
4117      return connection.getIntegerReply();  
4118    }
4119    @Override
4120    public long clusterCountKeysInSlot(final int slot) {
4121      checkIsInMultiOrPipeline();
4122      connection.sendCommand(CLUSTER, ClusterKeyword.COUNTKEYSINSLOT.getRaw(), toByteArray(slot));
4123      return connection.getIntegerReply();
4124    }
4125    @Override
4126    public String clusterSaveConfig() {
4127      checkIsInMultiOrPipeline();
4128      connection.sendCommand(CLUSTER, ClusterKeyword.SAVECONFIG);
4129      return connection.getStatusCodeReply();
4130    }
4131    @Override
4132    public String clusterSetConfigEpoch(long configEpoch) {
4133      checkIsInMultiOrPipeline();
4134      connection.sendCommand(CLUSTER, &quot;SET-CONFIG-EPOCH&quot;, Long.toString(configEpoch));
4135      return connection.getStatusCodeReply();
4136    }
4137    @Override
4138    public String clusterBumpEpoch() {
4139      checkIsInMultiOrPipeline();
4140      connection.sendCommand(CLUSTER, ClusterKeyword.BUMPEPOCH);
4141      return connection.getBulkReply();
4142    }
4143    @Override
4144    public String clusterReplicate(final String nodeId) {
4145      checkIsInMultiOrPipeline();
4146      connection.sendCommand(CLUSTER, ClusterKeyword.REPLICATE.name(), nodeId);
4147      return connection.getStatusCodeReply();
4148    }
4149    @Override
4150    @Deprecated
4151    public List&lt;String&gt; clusterSlaves(final String nodeId) {
4152      checkIsInMultiOrPipeline();
4153      connection.sendCommand(CLUSTER, ClusterKeyword.SLAVES.name(), nodeId);
4154      return connection.getMultiBulkReply();
4155    }
4156    @Override
4157    public List&lt;String&gt; clusterReplicas(final String nodeId) {
4158      checkIsInMultiOrPipeline();
4159      connection.sendCommand(CLUSTER, ClusterKeyword.REPLICAS.name(), nodeId);
4160      return connection.getMultiBulkReply();
4161    }
4162    @Override
4163    public String clusterFailover() {
4164      checkIsInMultiOrPipeline();
4165      connection.sendCommand(CLUSTER, ClusterKeyword.FAILOVER);
4166      return connection.getStatusCodeReply();
4167    }
4168    @Override
4169    public String clusterFailover(ClusterFailoverOption failoverOption) {
4170      checkIsInMultiOrPipeline();
4171      connection.sendCommand(CLUSTER, ClusterKeyword.FAILOVER.getRaw(), failoverOption.getRaw());
4172      return connection.getStatusCodeReply();
4173    }
4174    @Override
4175    public List&lt;Object&gt; clusterSlots() {
4176      checkIsInMultiOrPipeline();
4177      connection.sendCommand(CLUSTER, ClusterKeyword.SLOTS);
4178      return connection.getObjectMultiBulkReply();
4179    }
4180    @Override
4181    public String clusterMyId() {
4182      checkIsInMultiOrPipeline();
4183      connection.sendCommand(CLUSTER, ClusterKeyword.MYID);
4184      return connection.getBulkReply();
4185    }
4186    @Override
4187    public String clusterMyShardId() {
4188      checkIsInMultiOrPipeline();
4189      connection.sendCommand(CLUSTER, ClusterKeyword.MYSHARDID);
4190      return connection.getBulkReply();
4191    }
4192    @Override
4193    public List&lt;Map&lt;String, Object&gt;&gt; clusterLinks() {
4194      checkIsInMultiOrPipeline();
4195      connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);
4196      return connection.getObjectMultiBulkReply().stream()
4197              .map(BuilderFactory.ENCODED_OBJECT_MAP::build).collect(Collectors.toList());
4198    }
4199    @Override
4200    public String clusterAddSlotsRange(int... ranges) {
4201      checkIsInMultiOrPipeline();
4202      connection.sendCommand(CLUSTER,
4203          joinParameters(ClusterKeyword.ADDSLOTSRANGE.getRaw(), joinParameters(ranges)));
4204      return connection.getStatusCodeReply();
4205    }
4206    @Override
4207    public String clusterDelSlotsRange(int... ranges) {
4208      checkIsInMultiOrPipeline();
4209      connection.sendCommand(CLUSTER,
4210          joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges)));
4211      return connection.getStatusCodeReply();
4212    }
4213    @Override
4214    public String asking() {
4215      checkIsInMultiOrPipeline();
4216      connection.sendCommand(ASKING);
4217      return connection.getStatusCodeReply();
4218    }
4219    @Override
4220    public long pfadd(final String key, final String... elements) {
4221      checkIsInMultiOrPipeline();
4222      return connection.executeCommand(commandObjects.pfadd(key, elements));
4223    }
4224    @Override
4225    public long pfcount(final String key) {
4226      checkIsInMultiOrPipeline();
4227      return connection.executeCommand(commandObjects.pfcount(key));
4228    }
4229    @Override
4230    public long pfcount(final String... keys) {
4231      checkIsInMultiOrPipeline();
4232      return connection.executeCommand(commandObjects.pfcount(keys));
4233    }
4234    @Override
4235    public String pfmerge(final String destkey, final String... sourcekeys) {
4236      checkIsInMultiOrPipeline();
4237      return connection.executeCommand(commandObjects.pfmerge(destkey, sourcekeys));
4238    }
4239    @Override
4240    public Object fcall(final String name, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
4241      return connection.executeCommand(commandObjects.fcall(name, keys, args));
4242    }
4243    @Override
4244    public Object fcallReadonly(final String name, final List&lt;String&gt; keys, final List&lt;String&gt; args) {
4245      return connection.executeCommand(commandObjects.fcallReadonly(name, keys, args));
4246    }
4247    @Override
4248    public String functionDelete(final String libraryName) {
4249      checkIsInMultiOrPipeline();
4250      return connection.executeCommand(commandObjects.functionDelete(libraryName));
4251    }
4252    @Override
4253    public String functionLoad(final String functionCode) {
4254      checkIsInMultiOrPipeline();
4255      return connection.executeCommand(commandObjects.functionLoad(functionCode));
4256    }
4257    @Override
4258    public String functionLoadReplace(final String functionCode) {
4259      checkIsInMultiOrPipeline();
4260      return connection.executeCommand(commandObjects.functionLoadReplace(functionCode));
4261    }
4262    @Override
4263    public FunctionStats functionStats() {
4264      checkIsInMultiOrPipeline();
4265      return connection.executeCommand(commandObjects.functionStats());
4266    }
4267    @Override
4268    public String functionFlush() {
4269      checkIsInMultiOrPipeline();
4270      return connection.executeCommand(commandObjects.functionFlush());
4271    }
4272    @Override
4273    public String functionFlush(final FlushMode mode) {
4274      checkIsInMultiOrPipeline();
4275      return connection.executeCommand(commandObjects.functionFlush(mode));
4276    }
4277    @Override
4278    public String functionKill() {
4279      checkIsInMultiOrPipeline();
4280      return connection.executeCommand(commandObjects.functionKill());
4281    }
4282    @Override
4283    public List&lt;LibraryInfo&gt; functionList() {
4284      checkIsInMultiOrPipeline();
4285      return connection.executeCommand(commandObjects.functionList());
4286    }
4287    @Override
4288    public List&lt;LibraryInfo&gt; functionList(final String libraryNamePattern) {
4289      checkIsInMultiOrPipeline();
4290      return connection.executeCommand(commandObjects.functionList(libraryNamePattern));
4291    }
4292    @Override
4293    public List&lt;LibraryInfo&gt; functionListWithCode() {
4294      checkIsInMultiOrPipeline();
4295      return connection.executeCommand(commandObjects.functionListWithCode());  }
4296    @Override
4297    public List&lt;LibraryInfo&gt; functionListWithCode(String libraryNamePattern) {
4298      checkIsInMultiOrPipeline();
4299      return connection.executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
4300    }
4301    @Override
4302    public long geoadd(final String key, final double longitude, final double latitude,
4303        final String member) {
4304      checkIsInMultiOrPipeline();
4305      return connection.executeCommand(commandObjects.geoadd(key, longitude, latitude, member));
4306    }
4307    @Override
4308    public long geoadd(final String key, final Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
4309      checkIsInMultiOrPipeline();
4310      return connection.executeCommand(commandObjects.geoadd(key, memberCoordinateMap));
4311    }
4312    @Override
4313    public long geoadd(final String key, final GeoAddParams params, final Map&lt;String, GeoCoordinate&gt; memberCoordinateMap) {
4314      checkIsInMultiOrPipeline();
4315      return connection.executeCommand(commandObjects.geoadd(key, params, memberCoordinateMap));
4316    }
4317    @Override
4318    public Double geodist(final String key, final String member1, final String member2) {
4319      checkIsInMultiOrPipeline();
4320      return connection.executeCommand(commandObjects.geodist(key, member1, member2));
4321    }
4322    @Override
4323    public Double geodist(final String key, final String member1, final String member2,
4324        final GeoUnit unit) {
4325      checkIsInMultiOrPipeline();
4326      return connection.executeCommand(commandObjects.geodist(key, member1, member2, unit));
4327    }
4328    @Override
4329    public List&lt;String&gt; geohash(final String key, String... members) {
4330      checkIsInMultiOrPipeline();
4331      return connection.executeCommand(commandObjects.geohash(key, members));
4332    }
4333    @Override
4334    public List&lt;GeoCoordinate&gt; geopos(final String key, String... members) {
4335      checkIsInMultiOrPipeline();
4336      return connection.executeCommand(commandObjects.geopos(key, members));
4337    }
4338    @Override
4339    public List&lt;GeoRadiusResponse&gt; georadius(final String key, final double longitude,
4340        final double latitude, final double radius, final GeoUnit unit) {
4341      checkIsInMultiOrPipeline();
4342      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit));
4343    }
4344    @Override
4345    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final String key, final double longitude,
4346        final double latitude, final double radius, final GeoUnit unit) {
4347      checkIsInMultiOrPipeline();
4348      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit));
4349    }
4350    @Override
4351    public List&lt;GeoRadiusResponse&gt; georadius(final String key, final double longitude,
4352        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4353      checkIsInMultiOrPipeline();
4354      return connection.executeCommand(commandObjects.georadius(key, longitude, latitude, radius, unit, param));
4355    }
4356    @Override
4357    public long georadiusStore(final String key, double longitude, double latitude, double radius,
4358        GeoUnit unit, GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
4359      checkIsInMultiOrPipeline();
4360      return connection.executeCommand(commandObjects.georadiusStore(key, longitude, latitude, radius, unit, param, storeParam));
4361    }
4362    @Override
4363    public List&lt;GeoRadiusResponse&gt; georadiusReadonly(final String key, final double longitude,
4364        final double latitude, final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4365      checkIsInMultiOrPipeline();
4366      return connection.executeCommand(commandObjects.georadiusReadonly(key, longitude, latitude, radius, unit, param));
4367    }
4368    @Override
4369    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final String key, final String member,
4370        final double radius, final GeoUnit unit) {
4371      checkIsInMultiOrPipeline();
4372      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit));
4373    }
4374    @Override
4375    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final String key, final String member,
4376        final double radius, final GeoUnit unit) {
4377      checkIsInMultiOrPipeline();
4378      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit));
4379    }
4380    @Override
4381    public List&lt;GeoRadiusResponse&gt; georadiusByMember(final String key, final String member,
4382        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4383      checkIsInMultiOrPipeline();
4384      return connection.executeCommand(commandObjects.georadiusByMember(key, member, radius, unit, param));
4385    }
4386    @Override
4387    public long georadiusByMemberStore(final String key, String member, double radius, GeoUnit unit,
4388        GeoRadiusParam param, GeoRadiusStoreParam storeParam) {
4389      checkIsInMultiOrPipeline();
4390      return connection.executeCommand(commandObjects.georadiusByMemberStore(key, member, radius, unit, param, storeParam));
4391    }
4392    @Override
4393    public List&lt;GeoRadiusResponse&gt; georadiusByMemberReadonly(final String key, final String member,
4394        final double radius, final GeoUnit unit, final GeoRadiusParam param) {
4395      checkIsInMultiOrPipeline();
4396      return connection.executeCommand(commandObjects.georadiusByMemberReadonly(key, member, radius, unit, param));
4397    }
4398    @Override
4399    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double radius, GeoUnit unit) {
4400      checkIsInMultiOrPipeline();
4401      return connection.executeCommand(commandObjects.geosearch(key, member, radius, unit));
4402    }
4403    @Override
4404    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double radius, GeoUnit unit) {
4405      checkIsInMultiOrPipeline();
4406      return connection.executeCommand(commandObjects.geosearch(key, coord, radius, unit));
4407    }
4408    @Override
4409    public List&lt;GeoRadiusResponse&gt; geosearch(String key, String member, double width, double height, GeoUnit unit) {
4410      checkIsInMultiOrPipeline();
4411      return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));
4412    }
4413    @Override
4414    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoCoordinate coord, double width, double height, GeoUnit unit) {
4415      checkIsInMultiOrPipeline();
4416      return connection.executeCommand(commandObjects.geosearch(key, coord, width, height, unit));
4417    }
4418    @Override
4419    public List&lt;GeoRadiusResponse&gt; geosearch(String key, GeoSearchParam params) {
4420      checkIsInMultiOrPipeline();
4421      return connection.executeCommand(commandObjects.geosearch(key, params));
4422    }
4423    @Override
4424    public long geosearchStore(String dest, String src, String member, double radius, GeoUnit unit) {
4425      checkIsInMultiOrPipeline();
4426      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, radius, unit));
4427    }
4428    @Override
4429    public long geosearchStore(String dest, String src, GeoCoordinate coord, double radius, GeoUnit unit) {
4430      checkIsInMultiOrPipeline();
4431      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, radius, unit));
4432    }
4433    @Override
4434    public long geosearchStore(String dest, String src, String member, double width, double height, GeoUnit unit) {
4435      checkIsInMultiOrPipeline();
4436      return connection.executeCommand(commandObjects.geosearchStore(dest, src, member, width, height, unit));
4437    }
4438    @Override
4439    public long geosearchStore(String dest, String src, GeoCoordinate coord, double width, double height, GeoUnit unit) {
4440      checkIsInMultiOrPipeline();
4441      return connection.executeCommand(commandObjects.geosearchStore(dest, src, coord, width, height, unit));
4442    }
4443    @Override
4444    public long geosearchStore(String dest, String src, GeoSearchParam params) {
4445      checkIsInMultiOrPipeline();
4446      return connection.executeCommand(commandObjects.geosearchStore(dest, src, params));
4447    }
4448    @Override
4449    public long geosearchStoreStoreDist(String dest, String src, GeoSearchParam params) {
4450      checkIsInMultiOrPipeline();
4451      return connection.executeCommand(commandObjects.geosearchStoreStoreDist(dest, src, params));
4452    }
4453    @Override
4454    public String moduleLoad(final String path) {
4455      checkIsInMultiOrPipeline();
4456      connection.sendCommand(Command.MODULE, LOAD.name(), path);
4457      return connection.getStatusCodeReply();
4458    }
4459    @Override
4460    public String moduleLoad(String path, String... args) {
4461      checkIsInMultiOrPipeline();
4462      connection.sendCommand(Command.MODULE, joinParameters(LOAD.name(), path, args));
4463      return connection.getStatusCodeReply();
4464    }
4465    @Override
4466    public String moduleLoadEx(String path, ModuleLoadExParams params) {
4467      checkIsInMultiOrPipeline();
4468      connection.sendCommand(new CommandArguments(Command.MODULE).add(LOADEX).add(path)
4469          .addParams(params));
4470      return connection.getStatusCodeReply();
4471    }
4472    @Override
4473    public String moduleUnload(final String name) {
4474      checkIsInMultiOrPipeline();
4475      connection.sendCommand(Command.MODULE, UNLOAD.name(), name);
4476      return connection.getStatusCodeReply();
4477    }
4478    @Override
4479    public List&lt;Module&gt; moduleList() {
4480      checkIsInMultiOrPipeline();
4481      connection.sendCommand(Command.MODULE, LIST);
4482      return BuilderFactory.MODULE_LIST.build(connection.getOne());
4483    }
4484    @Override
4485    public List&lt;Long&gt; bitfield(final String key, final String... arguments) {
4486      checkIsInMultiOrPipeline();
4487      return connection.executeCommand(commandObjects.bitfield(key, arguments));
4488    }
4489    @Override
4490    public List&lt;Long&gt; bitfieldReadonly(final String key, final String... arguments) {
4491      checkIsInMultiOrPipeline();
4492      return connection.executeCommand(commandObjects.bitfieldReadonly(key, arguments));
4493    }
4494    @Override
4495    public long hstrlen(final String key, final String field) {
4496      checkIsInMultiOrPipeline();
4497      return connection.executeCommand(commandObjects.hstrlen(key, field));
4498    }
4499    @Override
4500    public String memoryDoctor() {
4501      checkIsInMultiOrPipeline();
4502      connection.sendCommand(MEMORY, DOCTOR);
4503      return connection.getBulkReply();
4504    }
4505    @Override
4506    public Long memoryUsage(final String key) {
4507      checkIsInMultiOrPipeline();
4508      connection.sendCommand(MEMORY, USAGE.name(), key);
4509      return connection.getIntegerReply();
4510    }
4511    @Override
4512    public Long memoryUsage(final String key, final int samples) {
4513      checkIsInMultiOrPipeline();
4514      connection.sendCommand(MEMORY, USAGE.getRaw(), encode(key), SAMPLES.getRaw(), toByteArray(samples));
4515      return connection.getIntegerReply();
4516    }
4517    @Override
4518    public String memoryPurge() {
4519      checkIsInMultiOrPipeline();
4520      connection.sendCommand(MEMORY, PURGE);
4521      return connection.getBulkReply();
4522    }
4523    @Override
4524    public Map&lt;String, Object&gt; memoryStats() {
4525      checkIsInMultiOrPipeline();
4526      connection.sendCommand(MEMORY, STATS);
4527      return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());
4528    }
4529    @Override
4530    public String lolwut() {
4531      checkIsInMultiOrPipeline();
4532      connection.sendCommand(LOLWUT);
4533      return connection.getBulkReply();
4534    }
4535    @Override
4536    public String lolwut(LolwutParams lolwutParams) {
4537      checkIsInMultiOrPipeline();
4538      connection.sendCommand(new CommandArguments(LOLWUT).addParams(lolwutParams));
4539      return connection.getBulkReply();
4540    }
4541    @Override
4542    public String latencyDoctor() {
4543      checkIsInMultiOrPipeline();
4544      connection.sendCommand(LATENCY, DOCTOR);
4545      return connection.getBulkReply();
4546    }
4547    @Override
4548    public StreamEntryID xadd(final String key, final StreamEntryID id, final Map&lt;String, String&gt; hash) {
4549      checkIsInMultiOrPipeline();
4550      return connection.executeCommand(commandObjects.xadd(key, id, hash));
4551    }
4552    @Override
4553    public StreamEntryID xadd(final String key, final XAddParams params, final Map&lt;String, String&gt; hash) {
4554      checkIsInMultiOrPipeline();
4555      return connection.executeCommand(commandObjects.xadd(key, params, hash));
4556    }
4557    @Override
4558    public long xlen(final String key) {
4559      checkIsInMultiOrPipeline();
4560      return connection.executeCommand(commandObjects.xlen(key));
4561    }
4562    @Override
4563    public List&lt;StreamEntry&gt; xrange(final String key, final StreamEntryID start, final StreamEntryID end) {
4564      checkIsInMultiOrPipeline();
4565      return connection.executeCommand(commandObjects.xrange(key, start, end));
4566    }
4567    @Override
4568    public List&lt;StreamEntry&gt; xrange(final String key, final StreamEntryID start,
4569        final StreamEntryID end, final int count) {
4570      checkIsInMultiOrPipeline();
4571      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
4572    }
4573    @Override
4574    public List&lt;StreamEntry&gt; xrevrange(final String key, final StreamEntryID end,
4575        final StreamEntryID start) {
4576      checkIsInMultiOrPipeline();
4577      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
4578    }
4579    @Override
4580    public List&lt;StreamEntry&gt; xrevrange(final String key, final StreamEntryID end,
4581        final StreamEntryID start, final int count) {
4582      checkIsInMultiOrPipeline();
4583      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
4584    }
4585    @Override
4586    public List&lt;StreamEntry&gt; xrange(final String key, final String start, final String end) {
4587      checkIsInMultiOrPipeline();
4588      return connection.executeCommand(commandObjects.xrange(key, start, end));
4589    }
4590    @Override
4591    public List&lt;StreamEntry&gt; xrange(final String key, final String start, final String end, final int count) {
4592      checkIsInMultiOrPipeline();
4593      return connection.executeCommand(commandObjects.xrange(key, start, end, count));
4594    }
4595    @Override
4596    public List&lt;StreamEntry&gt; xrevrange(final String key, final String end, final String start) {
4597      checkIsInMultiOrPipeline();
4598      return connection.executeCommand(commandObjects.xrevrange(key, end, start));
4599    }
4600    @Override
4601    public List&lt;StreamEntry&gt; xrevrange(final String key, final String end, final String start, final int count) {
4602      checkIsInMultiOrPipeline();
4603      return connection.executeCommand(commandObjects.xrevrange(key, end, start, count));
4604    }
4605    @Override
4606    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xread(final XReadParams xReadParams, final Map&lt;String, StreamEntryID&gt; streams) {
4607      checkIsInMultiOrPipeline();
4608      return connection.executeCommand(commandObjects.xread(xReadParams, streams));
4609    }
4610    @Override
4611    public long xack(final String key, final String group, final StreamEntryID... ids) {
4612      checkIsInMultiOrPipeline();
4613      return connection.executeCommand(commandObjects.xack(key, group, ids));
4614    }
4615    @Override
4616    public String xgroupCreate(final String key, final String groupName, final StreamEntryID id,
4617        final boolean makeStream) {
4618      checkIsInMultiOrPipeline();
4619      return connection.executeCommand(commandObjects.xgroupCreate(key, groupName, id, makeStream));
4620    }
4621    @Override
4622    public String xgroupSetID(final String key, final String groupName, final StreamEntryID id) {
4623      checkIsInMultiOrPipeline();
4624      return connection.executeCommand(commandObjects.xgroupSetID(key, groupName, id));
4625    }
4626    @Override
4627    public long xgroupDestroy(final String key, final String groupName) {
4628      checkIsInMultiOrPipeline();
4629      return connection.executeCommand(commandObjects.xgroupDestroy(key, groupName));
4630    }
4631    @Override
4632    public boolean xgroupCreateConsumer(String key, String groupName, String consumerName) {
4633      checkIsInMultiOrPipeline();
4634      return connection.executeCommand(commandObjects.xgroupCreateConsumer(key, groupName, consumerName));
4635    }
4636    @Override
4637    public long xgroupDelConsumer(final String key, final String groupName, final String consumerName) {
4638      checkIsInMultiOrPipeline();
4639      return connection.executeCommand(commandObjects.xgroupDelConsumer(key, groupName, consumerName));
4640    }
4641    @Override
4642    public long xdel(final String key, final StreamEntryID... ids) {
4643      checkIsInMultiOrPipeline();
4644      return connection.executeCommand(commandObjects.xdel(key, ids));
4645    }
4646    @Override
4647    public long xtrim(final String key, final long maxLen, final boolean approximateLength) {
4648      checkIsInMultiOrPipeline();
4649      return connection.executeCommand(commandObjects.xtrim(key, maxLen, approximateLength));
4650    }
4651    @Override
4652    public long xtrim(final String key, final XTrimParams params) {
4653      checkIsInMultiOrPipeline();
4654      return connection.executeCommand(commandObjects.xtrim(key, params));
4655    }
4656    @Override
4657    public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; xreadGroup(final String groupName,
4658        final String consumer, final XReadGroupParams xReadGroupParams,
4659        final Map&lt;String, StreamEntryID&gt; streams) {
4660      checkIsInMultiOrPipeline();
4661      return connection.executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));
4662    }
4663    @Override
4664    public StreamPendingSummary xpending(final String key, final String groupName) {
4665      checkIsInMultiOrPipeline();
4666      return connection.executeCommand(commandObjects.xpending(key, groupName));
4667    }
4668    @Override
4669    public List&lt;StreamPendingEntry&gt; xpending(final String key, final String groupName, final XPendingParams params) {
4670      checkIsInMultiOrPipeline();
4671      return connection.executeCommand(commandObjects.xpending(key, groupName, params));
4672    }
4673    @Override
4674    public List&lt;StreamEntry&gt; xclaim(String key, String group, String consumerName, long minIdleTime,
4675        XClaimParams params, StreamEntryID... ids) {
4676      checkIsInMultiOrPipeline();
4677      return connection.executeCommand(commandObjects.xclaim(key, group, consumerName, minIdleTime, params, ids));
4678    }
4679    @Override
4680    public List&lt;StreamEntryID&gt; xclaimJustId(String key, String group, String consumerName,
4681        long minIdleTime, XClaimParams params, StreamEntryID... ids) {
4682      checkIsInMultiOrPipeline();
4683      return connection.executeCommand(commandObjects.xclaimJustId(key, group, consumerName, minIdleTime, params, ids));
4684    }
4685    @Override
4686    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt; xautoclaim(String key, String group, String consumerName,
4687        long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
4688      checkIsInMultiOrPipeline();
4689      return connection.executeCommand(commandObjects.xautoclaim(key, group, consumerName, minIdleTime, start, params));
4690    }
4691    @Override
4692    public Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt; xautoclaimJustId(String key, String group, String consumerName,
4693        long minIdleTime, StreamEntryID start, XAutoClaimParams params) {
4694      checkIsInMultiOrPipeline();
4695      return connection.executeCommand(commandObjects.xautoclaimJustId(key, group, consumerName, minIdleTime, start, params));
4696    }
4697    @Override
4698    public StreamInfo xinfoStream(String key) {
4699      return connection.executeCommand(commandObjects.xinfoStream(key));
4700    }
4701    @Override
4702    public StreamFullInfo xinfoStreamFull(String key) {
4703      checkIsInMultiOrPipeline();
4704      return connection.executeCommand(commandObjects.xinfoStreamFull(key));
4705    }
4706    @Override
4707    public StreamFullInfo xinfoStreamFull(String key, int count) {
4708      checkIsInMultiOrPipeline();
4709      return connection.executeCommand(commandObjects.xinfoStreamFull(key, count));
4710    }
4711    @Override
4712    public List&lt;StreamGroupInfo&gt; xinfoGroups(String key) {
4713      return connection.executeCommand(commandObjects.xinfoGroups(key));
4714    }
4715    @Override
4716    public List&lt;StreamConsumersInfo&gt; xinfoConsumers(String key, String group) {
4717      return connection.executeCommand(commandObjects.xinfoConsumers(key, group));
4718    }
4719    @Override
4720    public List&lt;StreamConsumerInfo&gt; xinfoConsumers2(String key, String group) {
4721      return connection.executeCommand(commandObjects.xinfoConsumers2(key, group));
4722    }
4723    @Override
4724    public Object fcall(final byte[] name, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
4725      checkIsInMultiOrPipeline();
4726      return connection.executeCommand(commandObjects.fcall(name, keys, args));
4727    }
4728    @Override
4729    public Object fcallReadonly(final byte[] name, final List&lt;byte[]&gt; keys, final List&lt;byte[]&gt; args) {
4730      checkIsInMultiOrPipeline();
4731      return connection.executeCommand(commandObjects.fcallReadonly(name, keys, args));
4732    }
4733    @Override
4734    public String functionDelete(final byte[] libraryName) {
4735      checkIsInMultiOrPipeline();
4736      return connection.executeCommand(commandObjects.functionDelete(libraryName));
4737    }
4738    @Override
4739    public byte[] functionDump() {
4740      checkIsInMultiOrPipeline();
4741      return connection.executeCommand(commandObjects.functionDump());
4742    }
4743    @Override
4744    public List&lt;Object&gt; functionListBinary() {
4745      checkIsInMultiOrPipeline();
4746      return connection.executeCommand(commandObjects.functionListBinary());
4747    }
4748    @Override
4749    public List&lt;Object&gt; functionList(final byte[] libraryNamePattern) {
4750      checkIsInMultiOrPipeline();
4751      return connection.executeCommand(commandObjects.functionList(libraryNamePattern));
4752    }
4753    @Override
4754    public List&lt;Object&gt; functionListWithCodeBinary() {
4755      checkIsInMultiOrPipeline();
4756      return connection.executeCommand(commandObjects.functionListWithCodeBinary());
4757    }
4758    @Override
4759    public List&lt;Object&gt; functionListWithCode(final byte[] libraryNamePattern) {
4760      checkIsInMultiOrPipeline();
4761      return connection.executeCommand(commandObjects.functionListWithCode(libraryNamePattern));
4762    }
4763    @Override
4764    public String functionLoad(final byte[] functionCode) {
4765      checkIsInMultiOrPipeline();
4766      return connection.executeCommand(commandObjects.functionLoad(functionCode));
4767    }
4768    @Override
4769    public String functionLoadReplace(final byte[] functionCode) {
4770      checkIsInMultiOrPipeline();
4771      return connection.executeCommand(commandObjects.functionLoadReplace(functionCode));
4772    }
4773    @Override
4774    public String functionRestore(final byte[] serializedValue) {
4775      checkIsInMultiOrPipeline();
4776      return connection.executeCommand(commandObjects.functionRestore(serializedValue));
4777    }
4778    @Override
4779    public String functionRestore(final byte[] serializedValue, final FunctionRestorePolicy policy) {
4780      checkIsInMultiOrPipeline();
4781      return connection.executeCommand(commandObjects.functionRestore(serializedValue, policy));
4782    }
4783    @Override
4784    public Object functionStatsBinary() {
4785      checkIsInMultiOrPipeline();
4786      return connection.executeCommand(commandObjects.functionStatsBinary());
4787    }
4788    public Object sendCommand(ProtocolCommand cmd, String... args) {
4789      checkIsInMultiOrPipeline();
4790      connection.sendCommand(cmd, args);
4791      return connection.getOne();
4792    }
4793    public Object sendBlockingCommand(ProtocolCommand cmd, String... args) {
4794      checkIsInMultiOrPipeline();
4795      connection.sendCommand(cmd, args);
4796      connection.setTimeoutInfinite();
4797      try {
4798        return connection.getOne();
4799      } finally {
4800        connection.rollbackTimeout();
4801      }
4802    }
4803    private static byte[][] joinParameters(int... params) {
4804      byte[][] result = new byte[params.length][];
4805      for (int i = 0; i &lt; params.length; i++) {
4806        result[i] = toByteArray(params[i]);
4807      }
4808      return result;
4809    }
4810    private static byte[][] joinParameters(byte[] first, byte[][] rest) {
4811      byte[][] result = new byte[rest.length + 1][];
4812      result[0] = first;
4813      System.arraycopy(rest, 0, result, 1, rest.length);
4814      return result;
4815    }
4816    private static byte[][] joinParameters(byte[] first, byte[] second, byte[][] rest) {
4817      byte[][] result = new byte[rest.length + 2][];
4818      result[0] = first;
4819      result[1] = second;
4820      System.arraycopy(rest, 0, result, 2, rest.length);
4821      return result;
4822    }
4823    private static String[] joinParameters(String first, String[] rest) {
4824      String[] result = new String[rest.length + 1];
4825      result[0] = first;
4826      System.arraycopy(rest, 0, result, 1, rest.length);
4827      return result;
4828    }
4829    private static String[] joinParameters(String first, String second, String[] rest) {
4830      String[] result = new String[rest.length + 2];
4831      result[0] = first;
4832      result[1] = second;
4833      System.arraycopy(rest, 0, result, 2, rest.length);
4834      return result;
4835    }
4836  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Jedis.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Jedis.java</div>
                </div>
                <div class="column column_space"><pre><code>706    public byte[] rpop(final byte[] key) {
707      checkIsInMultiOrPipeline();
708      return connection.executeCommand(commandObjects.rpop(key));
</pre></code></div>
                <div class="column column_space"><pre><code>913    public byte[] zrandmember(final byte[] key) {
914      checkIsInMultiOrPipeline();
915      return connection.executeCommand(commandObjects.zrandmember(key));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    