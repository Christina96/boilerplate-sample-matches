<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for FunctionTest.java &amp; PeerFinderTests.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for FunctionTest.java &amp; PeerFinderTests.java
      </h3>
<h1 align="center">
        9.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>FunctionTest.java (47.5%)<th>PeerFinderTests.java (5.3023257%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-47)<td><a href="#" name="0">(59-81)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(104-113)<td><a href="#" name="1">(332-347)</a><td align="center"><font color="#d80000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(86-92)<td><a href="#" name="2">(242-252)</a><td align="center"><font color="#8c0000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(67-73)<td><a href="#" name="3">(531-536)</a><td align="center"><font color="#720000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>FunctionTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19  * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <a name="0"></a>
22 package io.crate.expression.symbol;
23 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.metadata.Scalar;
24 import io.crate.metadata.functions.Signature;
25 import org.elasticsearch.test.ESTestCase;
26 import io.crate.testing.TestingHelpers;
27 import io.crate.types.DataType;
28 import io.crate.types.DataTypes;
29 import org.elasticsearch.Version;
30 import org.elasticsearch.common.io.stream.BytesStreamOutput;
31 import org.elasticsearch.common.io.stream.StreamInput;
32 import org.junit.Test;
33 import java.util.EnumSet;
34 import java.util.List;
35 import java.util.Set;
36 import static com.carrotsearch.randomizedtesting.RandomizedTest.randomAsciiLettersOfLength;
37 import static io.crate.testing.TestingHelpers.createReference;
38 import static org.hamcrest.Matchers.is;
39 import static org.hamcrest.Matchers.not;
40 import static org.hamcrest.Matchers.nullValue;
41 public class FunctionTest extends ESTestCase {
42     private DataType&lt;?&gt; returnType = TestingHelpers.randomPrimitiveType()</b></font>;
43     private Signature signature = Signature.scalar(
44         randomAsciiLettersOfLength(10),
45         DataTypes.BOOLEAN.getTypeSignature(),
46         returnType.getTypeSignature()
47     ).withFeatures(randomFeatures());
48     @Test
49     public void test_serialization_without_filter() throws Exception {
50         Function fn = new Function(
51             signature,
52             List.of(createReference(randomAsciiLettersOfLength(2), DataTypes.BOOLEAN)),
53             returnType
54         );
55 <a name="3"></a>        BytesStreamOutput output = new BytesStreamOutput();
56         Symbols.toStream(fn, output);
57         StreamInput input = <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>output.bytes().streamInput();
58         Function fn2 = (Function) Symbols.fromStream(input);
59         assertThat(fn, is(fn2));
60     }
61     @Test</b></font>
62     public void test_serialization_with_filter() throws Exception {
63         Function fn = new Function(
64             signature,
65             List.of(createReference(randomAsciiLettersOfLength(2), DataTypes.BOOLEAN)),
66             returnType,
67             Literal.of(true)
68         );
69         BytesStreamOutput output = new BytesStreamOutput();
70 <a name="2"></a>        Symbols.toStream(fn, output);
71         StreamInput input = output.bytes().streamInput();
72         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Function fn2 = (Function) Symbols.fromStream(input);
73         assertThat(fn2.filter(), not(nullValue()));
74         assertThat(fn, is(fn2));
75     }
76     @Test</b></font>
77     public void test_serialization_before_version_4_1_0() throws Exception {
78         Function fn = new Function(
79             signature,
80             List.of(createReference(randomAsciiLettersOfLength(2), DataTypes.BOOLEAN)),
81             returnType
82         );
83         var output = new BytesStreamOutput();
84 <a name="1"></a>        output.setVersion(Version.V_4_0_0);
85         Symbols.toStream(fn, output);
86         var input = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>output.bytes().streamInput();
87         input.setVersion(Version.V_4_0_0);
88         Function fn2 = (Function) Symbols.fromStream(input);
89         assertThat(fn2.filter(), is(nullValue()));
90         assertThat(fn, is(fn2));
91     }
92     private static Set&lt;Scalar.Feature&gt; randomFeatures() {
93         Set&lt;Scalar.Feature&gt; features = EnumSet.noneOf</b></font>(Scalar.Feature.class);
94         for (Scalar.Feature feature : Scalar.Feature.values()) {
95             if (randomBoolean()) {
96                 features.add(feature);
97             }
98         }
99         return features;
100     }
101 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>PeerFinderTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Elasticsearch under one or more contributor
3  * license agreements. See the NOTICE file distributed with
4  * this work for additional information regarding copyright
5  * ownership. Elasticsearch licenses this file to you under
6  * the Apache License, Version 2.0 (the "License"); you may
7  * not use this file except in compliance with the License.
8  * You may obtain a copy of the License at
9  *
10  *    http://www.apache.org/licenses/LICENSE-2.0
11  *
12  * Unless required by applicable law or agreed to in writing,
13  * software distributed under the License is distributed on an
14  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
15  * KIND, either express or implied.  See the License for the
16  * specific language governing permissions and limitations
17  * under the License.
18  */
19 package org.elasticsearch.discovery;
20 import org.elasticsearch.ElasticsearchException;
21 import org.elasticsearch.Version;
22 import org.elasticsearch.action.ActionListener;
23 import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;
24 import org.elasticsearch.cluster.coordination.PeersResponse;
25 import org.elasticsearch.cluster.node.DiscoveryNode;
26 import org.elasticsearch.cluster.node.DiscoveryNodes;
27 import org.elasticsearch.cluster.node.DiscoveryNodes.Builder;
28 import org.elasticsearch.common.io.stream.StreamInput;
29 import org.elasticsearch.common.settings.Settings;
30 import org.elasticsearch.common.transport.TransportAddress;
31 import io.crate.common.collections.Sets;
32 import org.elasticsearch.discovery.PeerFinder.TransportAddressConnector;
33 import org.elasticsearch.test.ESTestCase;
34 import org.elasticsearch.test.transport.CapturingTransport;
35 import org.elasticsearch.test.transport.CapturingTransport.CapturedRequest;
36 import org.elasticsearch.test.transport.StubbableConnectionManager;
37 import org.elasticsearch.threadpool.ThreadPool.Names;
38 import org.elasticsearch.transport.ConnectionManager;
39 import org.elasticsearch.transport.TransportException;
40 import org.elasticsearch.transport.TransportResponseHandler;
41 import org.elasticsearch.transport.TransportService;
42 import org.junit.After;
43 import org.junit.Before;
44 import java.io.IOException;
45 import java.util.ArrayList;
46 import java.util.Arrays;
47 import java.util.Collections;
48 import java.util.HashMap;
49 import java.util.HashSet;
50 import java.util.List;
51 import java.util.Map;
52 import java.util.Optional;
53 <a name="0"></a>import java.util.OptionalLong;
54 import java.util.Set;
55 import java.util.concurrent.atomic.AtomicBoolean;
56 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.function.Consumer;
57 import java.util.function.Function;
58 import java.util.stream.Collectors;
59 import java.util.stream.Stream;
60 import java.util.stream.StreamSupport;
61 import static java.util.Collections.emptyList;
62 import static java.util.Collections.emptyMap;
63 import static java.util.Collections.emptySet;
64 import static java.util.Collections.singletonList;
65 import static org.elasticsearch.discovery.PeerFinder.REQUEST_PEERS_ACTION_NAME;
66 import static org.elasticsearch.node.Node.NODE_NAME_SETTING;
67 import static org.hamcrest.Matchers.contains;
68 import static org.hamcrest.Matchers.empty;
69 import static org.hamcrest.Matchers.emptyArray;
70 import static org.hamcrest.Matchers.equalTo;
71 import static org.hamcrest.Matchers.instanceOf;
72 import static org.hamcrest.Matchers.is;
73 import static org.hamcrest.Matchers.nullValue;
74 public class PeerFinderTests extends ESTestCase {
75     private CapturingTransport capturingTransport</b></font>;
76     private DeterministicTaskQueue deterministicTaskQueue;
77     private DiscoveryNode localNode;
78     private MockTransportAddressConnector transportAddressConnector;
79     private TestPeerFinder peerFinder;
80     private List&lt;TransportAddress&gt; providedAddresses;
81     private long addressResolveDelay; 
82     private Set&lt;DiscoveryNode&gt; disconnectedNodes = new HashSet&lt;&gt;();
83     private Set&lt;DiscoveryNode&gt; connectedNodes = new HashSet&lt;&gt;();
84     private DiscoveryNodes lastAcceptedNodes;
85     private TransportService transportService;
86     private Iterable&lt;DiscoveryNode&gt; foundPeersFromNotification;
87     private static long CONNECTION_TIMEOUT_MILLIS = 30000;
88     class MockTransportAddressConnector implements TransportAddressConnector {
89         final Map&lt;TransportAddress, DiscoveryNode&gt; reachableNodes = new HashMap&lt;&gt;();
90         final Set&lt;TransportAddress&gt; unreachableAddresses = new HashSet&lt;&gt;();
91         final Set&lt;TransportAddress&gt; slowAddresses = new HashSet&lt;&gt;();
92         final Set&lt;TransportAddress&gt; inFlightConnectionAttempts = new HashSet&lt;&gt;();
93         void addReachableNode(DiscoveryNode node) {
94             reachableNodes.put(node.getAddress(), node);
95         }
96         @Override
97         public void connectToRemoteMasterNode(TransportAddress transportAddress, ActionListener&lt;DiscoveryNode&gt; listener) {
98             assert localNode.getAddress().equals(transportAddress) == false : "should not probe local node";
99             final boolean isNotInFlight = inFlightConnectionAttempts.add(transportAddress);
100             assertTrue(isNotInFlight);
101             final long connectResultTime = deterministicTaskQueue.getCurrentTimeMillis()
102                 + (slowAddresses.contains(transportAddress) ? CONNECTION_TIMEOUT_MILLIS : 0);
103             deterministicTaskQueue.scheduleAt(connectResultTime, new Runnable() {
104                 @Override
105                 public void run() {
106                     if (unreachableAddresses.contains(transportAddress)) {
107                         assertTrue(inFlightConnectionAttempts.remove(transportAddress));
108                         listener.onFailure(new IOException("cannot connect to " + transportAddress));
109                         return;
110                     }
111                     for (final Map.Entry&lt;TransportAddress, DiscoveryNode&gt; addressAndNode : reachableNodes.entrySet()) {
112                         if (addressAndNode.getKey().equals(transportAddress)) {
113                             final DiscoveryNode discoveryNode = addressAndNode.getValue();
114                             if (discoveryNode.isMasterEligibleNode()) {
115                                 disconnectedNodes.remove(discoveryNode);
116                                 connectedNodes.add(discoveryNode);
117                                 assertTrue(inFlightConnectionAttempts.remove(transportAddress));
118                                 listener.onResponse(discoveryNode);
119                                 return;
120                             } else {
121                                 listener.onFailure(new ElasticsearchException("non-master node " + discoveryNode));
122                                 return;
123                             }
124                         }
125                     }
126                     throw new AssertionError(transportAddress + " unknown");
127                 }
128                 @Override
129                 public String toString() {
130                     return "connection attempt to " + transportAddress;
131                 }
132             });
133         }
134     }
135     class TestPeerFinder extends PeerFinder {
136         DiscoveryNode discoveredMasterNode;
137         OptionalLong discoveredMasterTerm = OptionalLong.empty();
138         TestPeerFinder(Settings settings, TransportService transportService, TransportAddressConnector transportAddressConnector) {
139             super(settings, transportService, transportAddressConnector, PeerFinderTests.this::resolveConfiguredHosts);
140         }
141         @Override
142         protected void onActiveMasterFound(DiscoveryNode masterNode, long term) {
143             assert holdsLock() == false : "PeerFinder lock held in error";
144             assertThat(discoveredMasterNode, nullValue());
145             assertFalse(discoveredMasterTerm.isPresent());
146             discoveredMasterNode = masterNode;
147             discoveredMasterTerm = OptionalLong.of(term);
148         }
149         @Override
150         protected void onFoundPeersUpdated() {
151             assert holdsLock() == false : "PeerFinder lock held in error";
152             foundPeersFromNotification = getFoundPeers();
153             logger.trace("onFoundPeersUpdated({})", foundPeersFromNotification);
154         }
155     }
156     private void resolveConfiguredHosts(Consumer&lt;List&lt;TransportAddress&gt;&gt; onResult) {
157         if (addressResolveDelay &gt;= 0) {
158             deterministicTaskQueue.scheduleAt(deterministicTaskQueue.getCurrentTimeMillis() + addressResolveDelay, new Runnable() {
159                 @Override
160                 public void run() {
161                     onResult.accept(providedAddresses);
162                 }
163                 @Override
164                 public String toString() {
165                     return "PeerFinderTests#resolveConfiguredHosts";
166                 }
167             });
168         } else {
169             assertThat(addressResolveDelay, is(-1L));
170         }
171     }
172     private void updateLastAcceptedNodes(Consumer&lt;DiscoveryNodes.Builder&gt; onBuilder) {
173         final Builder builder = DiscoveryNodes.builder(lastAcceptedNodes);
174         onBuilder.accept(builder);
175         lastAcceptedNodes = builder.build();
176     }
177     @Before
178     public void setup() {
179         capturingTransport = new CapturingTransport();
180         transportAddressConnector = new MockTransportAddressConnector();
181         providedAddresses = new ArrayList&lt;&gt;();
182         addressResolveDelay = 0L;
183         final Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), "node").build();
184         deterministicTaskQueue = new DeterministicTaskQueue(settings, random());
185         localNode = newDiscoveryNode("local-node");
186         ConnectionManager innerConnectionManager
187             = new ConnectionManager(settings, capturingTransport);
188         StubbableConnectionManager connectionManager
189             = new StubbableConnectionManager(innerConnectionManager, settings, capturingTransport, deterministicTaskQueue.getThreadPool());
190         connectionManager.setDefaultNodeConnectedBehavior(cm -&gt; {
191             assertTrue(Sets.haveEmptyIntersection(connectedNodes, disconnectedNodes));
192             return connectedNodes;
193         });
194         connectionManager.setDefaultGetConnectionBehavior((cm, discoveryNode) -&gt; capturingTransport.createConnection(discoveryNode));
195         transportService = new TransportService(settings, capturingTransport, deterministicTaskQueue.getThreadPool(),
196                                                 boundTransportAddress -&gt; localNode, null, connectionManager);
197         transportService.start();
198         transportService.acceptIncomingRequests();
199         lastAcceptedNodes = DiscoveryNodes.builder().localNodeId(localNode.getId()).add(localNode).build();
200         peerFinder = new TestPeerFinder(settings, transportService, transportAddressConnector);
201         foundPeersFromNotification = emptyList();
202     }
203     @After
204     public void deactivateAndRunRemainingTasks() {
205         peerFinder.deactivate(localNode);
206         deterministicTaskQueue.runAllRunnableTasks();
207 <a name="2"></a>    }
208     public void testAddsReachableNodesFromUnicastHostsList() {
209         <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
210         providedAddresses.add(otherNode.getAddress());
211         transportAddressConnector.addReachableNode(otherNode);
212         peerFinder.activate(lastAcceptedNodes);
213         runAllRunnableTasks();
214         assertFoundPeers(otherNode);
215     }
216     public void testDoesNotReturnDuplicateNodesWithDisti</b></font>nctAddresses() {
217         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
218         final TransportAddress alternativeAddress = buildNewFakeTransportAddress();
219         providedAddresses.add(otherNode.getAddress());
220         providedAddresses.add(alternativeAddress);
221         transportAddressConnector.addReachableNode(otherNode);
222         transportAddressConnector.reachableNodes.put(alternativeAddress, otherNode);
223         peerFinder.activate(lastAcceptedNodes);
224         runAllRunnableTasks();
225         assertFoundPeers(otherNode);
226     }
227     public void testAddsReachableNodesFromUnicastHostsListProvidedLater() {
228         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
229         providedAddresses.add(otherNode.getAddress());
230         transportAddressConnector.addReachableNode(otherNode);
231         addressResolveDelay = 10000;
232         peerFinder.activate(lastAcceptedNodes);
233         runAllRunnableTasks();
234         assertFoundPeers();
235         final long successTime = addressResolveDelay + PeerFinder.DISCOVERY_FIND_PEERS_INTERVAL_SETTING.get(Settings.EMPTY).millis();
236         while (deterministicTaskQueue.getCurrentTimeMillis() &lt; successTime) {
237             deterministicTaskQueue.advanceTime();
238             runAllRunnableTasks();
239         }
240         assertFoundPeers(otherNode);
241     }
242     public void testDoesNotRequireAddressResolutionToSucceed() {
243         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
244         providedAddresses.add(otherNode.getAddress());
245         transportAddressConnector.addReachableNode(otherNode);
246         addressResolveDelay = -1;
247         peerFinder.activate(lastAcceptedNodes);
248         runAllRunnableTasks();
249         assertFoundPeers();
250         final long successTime = 10000 + PeerFinder.DISCOVERY_FIND_PEERS_INTERVAL_SETTING.get(Settings.EMPTY).millis();
251         while (deterministicTaskQueue.getCurrentTimeMillis() &lt; successTime) {
252             deterministicTaskQueue.advanceTime();
253             runAllRunnableTasks();
254         }
255         assertFoundPeers();
256     }
257     public void testDoesNotAddUnreachableNodesFromUnicastHostsList() {
258         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
259         providedAddresses.add(otherNode.getAddress());
260         transportAddressConnector.unreachableAddresses.add(otherNode.getAddress());
261         peerFinder.activate(lastAcceptedNodes);
262         runAllRunnableTasks();
263         assertFoundPeers();
264     }
265     public void testDoesNotAddNonMasterEligibleNodesFromUnicastHostsList() {
266         final DiscoveryNode nonMasterNode = new DiscoveryNode("node-from-hosts-list", buildNewFakeTransportAddress(),
267             emptyMap(), emptySet(), Version.CURRENT);
268         providedAddresses.add(nonMasterNode.getAddress());
269         transportAddressConnector.addReachableNode(nonMasterNode);
270         peerFinder.activate(lastAcceptedNodes);
271         runAllRunnableTasks();
272         assertFoundPeers();
273         assertThat(capturingTransport.capturedRequests(), emptyArray());
274 <a name="1"></a>    }
275     public void testChecksUnicastHostsForChanges() {
276         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>peerFinder.activate(lastAcceptedNodes);
277         runAllRunnableTasks();
278         assertFoundPeers();
279         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
280         providedAddresses.add(otherNode.getAddress());
281         transportAddressConnector.addReachableNode(otherNode);
282         deterministicTaskQueue.advanceTime();
283         runAllRunnableTasks();
284         assertFoundPeers(otherNode);
285     }
286     public void testDeactivationClearsPastKnowledge() {
287         final DiscoveryNode otherNode = newDiscoveryNode</b></font>("node-from-hosts-list");
288         providedAddresses.add(otherNode.getAddress());
289         transportAddressConnector.addReachableNode(otherNode);
290         peerFinder.activate(lastAcceptedNodes);
291         runAllRunnableTasks();
292         assertFoundPeers(otherNode);
293         peerFinder.deactivate(localNode);
294         providedAddresses.clear();
295         peerFinder.activate(lastAcceptedNodes);
296         runAllRunnableTasks();
297         assertFoundPeers();
298     }
299     public void testAddsReachableNodesFromClusterState() {
300         final DiscoveryNode otherNode = newDiscoveryNode("node-in-cluster-state");
301         updateLastAcceptedNodes(b -&gt; b.add(otherNode));
302         transportAddressConnector.addReachableNode(otherNode);
303         peerFinder.activate(lastAcceptedNodes);
304         runAllRunnableTasks();
305         assertFoundPeers(otherNode);
306     }
307     public void testDoesNotAddUnreachableNodesFromClusterState() {
308         final DiscoveryNode otherNode = newDiscoveryNode("node-in-cluster-state");
309         updateLastAcceptedNodes(b -&gt; b.add(otherNode));
310         transportAddressConnector.unreachableAddresses.add(otherNode.getAddress());
311         peerFinder.activate(lastAcceptedNodes);
312         runAllRunnableTasks();
313         assertFoundPeers();
314     }
315     public void testAddsReachableNodesFromIncomingRequests() {
316         final DiscoveryNode sourceNode = newDiscoveryNode("request-source");
317         final DiscoveryNode otherKnownNode = newDiscoveryNode("other-known-node");
318         transportAddressConnector.addReachableNode(sourceNode);
319         transportAddressConnector.addReachableNode(otherKnownNode);
320         peerFinder.activate(lastAcceptedNodes);
321         peerFinder.handlePeersRequest(new PeersRequest(sourceNode, Collections.singletonList(otherKnownNode)));
322         runAllRunnableTasks();
323         assertFoundPeers(sourceNode, otherKnownNode);
324     }
325     public void testDoesNotAddReachableNonMasterEligibleNodesFromIncomingRequests() {
326         final DiscoveryNode sourceNode = new DiscoveryNode("request-source", buildNewFakeTransportAddress(),
327             emptyMap(), emptySet(), Version.CURRENT);
328         final DiscoveryNode otherKnownNode = newDiscoveryNode("other-known-node");
329         transportAddressConnector.addReachableNode(otherKnownNode);
330         peerFinder.activate(lastAcceptedNodes);
331         peerFinder.handlePeersRequest(new PeersRequest(sourceNode, Collections.singletonList(otherKnownNode)));
332         runAllRunnableTasks();
333         assertFoundPeers(otherKnownNode);
334     }
335     public void testDoesNotAddUnreachableNodesFromIncomingRequests() {
336         final DiscoveryNode sourceNode = newDiscoveryNode("request-source");
337         final DiscoveryNode otherKnownNode = newDiscoveryNode("other-known-node");
338         transportAddressConnector.addReachableNode(sourceNode);
339         transportAddressConnector.unreachableAddresses.add(otherKnownNode.getAddress());
340         peerFinder.activate(lastAcceptedNodes);
341         peerFinder.handlePeersRequest(new PeersRequest(sourceNode, Collections.singletonList(otherKnownNode)));
342         runAllRunnableTasks();
343         assertFoundPeers(sourceNode);
344     }
345     public void testDoesNotAddUnreachableSourceNodeFromIncomingRequests() {
346         final DiscoveryNode sourceNode = newDiscoveryNode("request-source");
347         final DiscoveryNode otherKnownNode = newDiscoveryNode("other-known-node");
348         transportAddressConnector.unreachableAddresses.add(sourceNode.getAddress());
349         transportAddressConnector.addReachableNode(otherKnownNode);
350         peerFinder.activate(lastAcceptedNodes);
351         peerFinder.handlePeersRequest(new PeersRequest(sourceNode, Collections.singletonList(otherKnownNode)));
352         runAllRunnableTasks();
353         assertFoundPeers(otherKnownNode);
354     }
355     public void testRespondsToRequestWhenActive() {
356         final DiscoveryNode sourceNode = newDiscoveryNode("request-source");
357         transportAddressConnector.addReachableNode(sourceNode);
358         peerFinder.activate(lastAcceptedNodes);
359         final PeersResponse peersResponse1 = peerFinder.handlePeersRequest(new PeersRequest(sourceNode, Collections.emptyList()));
360         assertFalse(peersResponse1.getMasterNode().isPresent());
361         assertThat(peersResponse1.getKnownPeers(), empty());         assertThat(peersResponse1.getTerm(), is(0L));
362         runAllRunnableTasks();
363         assertFoundPeers(sourceNode);
364         final long updatedTerm = randomNonNegativeLong();
365         peerFinder.setCurrentTerm(updatedTerm);
366         final PeersResponse peersResponse2 = peerFinder.handlePeersRequest(new PeersRequest(sourceNode, Collections.emptyList()));
367         assertFalse(peersResponse2.getMasterNode().isPresent());
368         assertThat(peersResponse2.getKnownPeers(), contains(sourceNode));
369         assertThat(peersResponse2.getTerm(), is(updatedTerm));
370     }
371     public void testDelegatesRequestHandlingWhenInactive() {
372         final DiscoveryNode masterNode = newDiscoveryNode("master-node");
373         final DiscoveryNode sourceNode = newDiscoveryNode("request-source");
374         transportAddressConnector.addReachableNode(sourceNode);
375         peerFinder.activate(DiscoveryNodes.EMPTY_NODES);
376         final long term = randomNonNegativeLong();
377         peerFinder.setCurrentTerm(term);
378         peerFinder.deactivate(masterNode);
379         final PeersResponse expectedResponse = new PeersResponse(Optional.of(masterNode), Collections.emptyList(), term);
380         final PeersResponse peersResponse = peerFinder.handlePeersRequest(new PeersRequest(sourceNode, Collections.emptyList()));
381         assertThat(peersResponse, equalTo(expectedResponse));
382     }
383     public void testReceivesRequestsFromTransportService() {
384         final DiscoveryNode sourceNode = newDiscoveryNode("request-source");
385         transportAddressConnector.addReachableNode(sourceNode);
386         peerFinder.activate(lastAcceptedNodes);
387         final AtomicBoolean responseReceived = new AtomicBoolean();
388         transportService.sendRequest(localNode, REQUEST_PEERS_ACTION_NAME, new PeersRequest(sourceNode, Collections.emptyList()),
389             new TransportResponseHandler&lt;PeersResponse&gt;() {
390                 @Override
391                 public PeersResponse read(StreamInput in) throws IOException {
392                     return new PeersResponse(in);
393                 }
394                 @Override
395                 public void handleResponse(PeersResponse response) {
396                     assertTrue(responseReceived.compareAndSet(false, true));
397                     assertFalse(response.getMasterNode().isPresent());
398                     assertThat(response.getKnownPeers(), empty());                     assertThat(response.getTerm(), is(0L));
399                 }
400                 @Override
401                 public void handleException(TransportException exp) {
402                     throw new AssertionError("unexpected", exp);
403                 }
404                 @Override
405                 public String executor() {
406                     return Names.SAME;
407                 }
408             });
409         runAllRunnableTasks();
410         assertTrue(responseReceived.get());
411         assertFoundPeers(sourceNode);
412     }
413     public void testRequestsPeersIncludingKnownPeersInRequest() {
414         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
415         providedAddresses.add(otherNode.getAddress());
416         transportAddressConnector.addReachableNode(otherNode);
417         peerFinder.activate(lastAcceptedNodes);
418         runAllRunnableTasks();
419 <a name="3"></a>        assertFoundPeers(otherNode);
420         final CapturedRequest[] capturedRequests = capturingTransport.getCapturedRequestsAndClear();
421         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(capturedRequests.length, is(1));
422         final PeersRequest peersRequest = (PeersRequest) capturedRequests[0].request;
423         assertThat(peersRequest.getKnownPeers(), contains(otherNode));
424     }
425     public void testAddsReachablePeers</b></font>FromResponse() {
426         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
427         providedAddresses.add(otherNode.getAddress());
428         transportAddressConnector.addReachableNode(otherNode);
429         peerFinder.activate(lastAcceptedNodes);
430         runAllRunnableTasks();
431         assertFoundPeers(otherNode);
432         final DiscoveryNode discoveredNode = newDiscoveryNode("discovered-node");
433         transportAddressConnector.addReachableNode(discoveredNode);
434         respondToRequests(node -&gt; {
435             assertThat(node, is(otherNode));
436             return new PeersResponse(Optional.empty(), singletonList(discoveredNode), randomNonNegativeLong());
437         });
438         runAllRunnableTasks();
439         assertFoundPeers(otherNode, discoveredNode);
440     }
441     public void testAddsReachableMasterFromResponse() {
442         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
443         providedAddresses.add(otherNode.getAddress());
444         transportAddressConnector.addReachableNode(otherNode);
445         peerFinder.activate(lastAcceptedNodes);
446         runAllRunnableTasks();
447         assertFoundPeers(otherNode);
448         final DiscoveryNode discoveredMaster = newDiscoveryNode("discovered-master");
449         respondToRequests(node -&gt; {
450             assertThat(node, is(otherNode));
451             return new PeersResponse(Optional.of(discoveredMaster), emptyList(), randomNonNegativeLong());
452         });
453         transportAddressConnector.addReachableNode(discoveredMaster);
454         runAllRunnableTasks();
455         assertFoundPeers(otherNode, discoveredMaster);
456         assertThat(peerFinder.discoveredMasterNode, nullValue());
457         assertFalse(peerFinder.discoveredMasterTerm.isPresent());
458     }
459     public void testHandlesDiscoveryOfMasterFromResponseFromMaster() {
460         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
461         providedAddresses.add(otherNode.getAddress());
462         transportAddressConnector.addReachableNode(otherNode);
463         peerFinder.activate(lastAcceptedNodes);
464         runAllRunnableTasks();
465         assertFoundPeers(otherNode);
466         final long term = randomNonNegativeLong();
467         respondToRequests(node -&gt; {
468             assertThat(node, is(otherNode));
469             return new PeersResponse(Optional.of(otherNode), emptyList(), term);
470         });
471         runAllRunnableTasks();
472         assertFoundPeers(otherNode);
473         assertThat(peerFinder.discoveredMasterNode, is(otherNode));
474         assertThat(peerFinder.discoveredMasterTerm, is(OptionalLong.of(term)));
475     }
476     public void testOnlyRequestsPeersOncePerRoundButDoesRetryNextRound() {
477         final DiscoveryNode sourceNode = newDiscoveryNode("request-source");
478         transportAddressConnector.addReachableNode(sourceNode);
479         peerFinder.activate(lastAcceptedNodes);
480         peerFinder.handlePeersRequest(new PeersRequest(sourceNode, emptyList()));
481         runAllRunnableTasks();
482         assertFoundPeers(sourceNode);
483         respondToRequests(node -&gt; {
484             assertThat(node, is(sourceNode));
485             return new PeersResponse(Optional.empty(), singletonList(sourceNode), randomNonNegativeLong());
486         });
487         peerFinder.handlePeersRequest(new PeersRequest(sourceNode, emptyList()));
488         runAllRunnableTasks();
489         respondToRequests(node -&gt; {
490             throw new AssertionError("there should have been no further requests");
491         });
492         final DiscoveryNode otherNode = newDiscoveryNode("otherNode");
493         transportAddressConnector.addReachableNode(otherNode);
494         deterministicTaskQueue.advanceTime();
495         runAllRunnableTasks();
496         respondToRequests(node -&gt; {
497             assertThat(node, is(sourceNode));
498             return new PeersResponse(Optional.empty(), singletonList(otherNode), randomNonNegativeLong());
499         });
500         runAllRunnableTasks();
501         assertFoundPeers(sourceNode, otherNode);
502     }
503     public void testDoesNotReconnectToNodesOnceConnected() {
504         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
505         providedAddresses.add(otherNode.getAddress());
506         transportAddressConnector.addReachableNode(otherNode);
507         peerFinder.activate(lastAcceptedNodes);
508         runAllRunnableTasks();
509         assertFoundPeers(otherNode);
510         transportAddressConnector.reachableNodes.clear();
511         deterministicTaskQueue.advanceTime();
512         runAllRunnableTasks();
513         assertFoundPeers(otherNode);
514     }
515     public void testDiscardsDisconnectedNodes() {
516         final DiscoveryNode otherNode = newDiscoveryNode("original-node");
517         providedAddresses.add(otherNode.getAddress());
518         transportAddressConnector.addReachableNode(otherNode);
519         peerFinder.activate(lastAcceptedNodes);
520         runAllRunnableTasks();
521         assertFoundPeers(otherNode);
522         transportAddressConnector.reachableNodes.clear();
523         transportAddressConnector.unreachableAddresses.add(otherNode.getAddress());
524         connectedNodes.remove(otherNode);
525         disconnectedNodes.add(otherNode);
526         deterministicTaskQueue.advanceTime();
527         runAllRunnableTasks();
528         assertFoundPeers();
529     }
530     public void testDoesNotMakeMultipleConcurrentConnectionAttemptsToOneAddress() {
531         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
532         providedAddresses.add(otherNode.getAddress());
533         transportAddressConnector.unreachableAddresses.add(otherNode.getAddress());
534         transportAddressConnector.slowAddresses.add(otherNode.getAddress());
535         peerFinder.activate(lastAcceptedNodes);
536         runAllRunnableTasks();
537         assertFoundPeers();
538         deterministicTaskQueue.advanceTime();
539         runAllRunnableTasks();         assertFoundPeers();
540         transportAddressConnector.slowAddresses.clear();
541         transportAddressConnector.unreachableAddresses.clear();
542         transportAddressConnector.addReachableNode(otherNode);
543         while (deterministicTaskQueue.getCurrentTimeMillis() &lt; CONNECTION_TIMEOUT_MILLIS) {
544             assertFoundPeers();
545             deterministicTaskQueue.advanceTime();
546             runAllRunnableTasks();
547         }
548         final long expectedTime = CONNECTION_TIMEOUT_MILLIS + PeerFinder.DISCOVERY_FIND_PEERS_INTERVAL_SETTING.get(Settings.EMPTY).millis();
549         while (deterministicTaskQueue.getCurrentTimeMillis() &lt; expectedTime) {
550             deterministicTaskQueue.advanceTime();
551             runAllRunnableTasks();
552         }
553         assertFoundPeers(otherNode);
554     }
555     public void testTimesOutAndRetriesConnectionsToBlackholedNodes() {
556         final DiscoveryNode otherNode = newDiscoveryNode("node-from-hosts-list");
557         final DiscoveryNode nodeToFind = newDiscoveryNode("node-to-find");
558         providedAddresses.add(otherNode.getAddress());
559         transportAddressConnector.addReachableNode(otherNode);
560         transportAddressConnector.addReachableNode(nodeToFind);
561         peerFinder.activate(lastAcceptedNodes);
562         while (true) {
563             deterministicTaskQueue.advanceTime();
564             runAllRunnableTasks();             if (capturingTransport.getCapturedRequestsAndClear().length &gt; 0) {
565                 break;
566             }
567         }
568         final long timeoutAtMillis = deterministicTaskQueue.getCurrentTimeMillis()
569             + PeerFinder.DISCOVERY_REQUEST_PEERS_TIMEOUT_SETTING.get(Settings.EMPTY).millis();
570         while (deterministicTaskQueue.getCurrentTimeMillis() &lt; timeoutAtMillis) {
571             assertFoundPeers(otherNode);
572             deterministicTaskQueue.advanceTime();
573             runAllRunnableTasks();
574         }
575         final long expectedTime = timeoutAtMillis + PeerFinder.DISCOVERY_FIND_PEERS_INTERVAL_SETTING.get(Settings.EMPTY).millis();
576         while (deterministicTaskQueue.getCurrentTimeMillis() &lt; expectedTime) {
577             deterministicTaskQueue.advanceTime();
578             runAllRunnableTasks();
579         }
580         respondToRequests(node -&gt; {
581             assertThat(node, is(otherNode));
582             return new PeersResponse(Optional.empty(), singletonList(nodeToFind), randomNonNegativeLong());
583         });
584         deterministicTaskQueue.advanceTime();
585         runAllRunnableTasks();
586         assertFoundPeers(nodeToFind, otherNode);
587     }
588     public void testReconnectsToDisconnectedNodes() {
589         final DiscoveryNode otherNode = newDiscoveryNode("original-node");
590         providedAddresses.add(otherNode.getAddress());
591         transportAddressConnector.addReachableNode(otherNode);
592         peerFinder.activate(lastAcceptedNodes);
593         runAllRunnableTasks();
594         assertFoundPeers(otherNode);
595         transportAddressConnector.reachableNodes.clear();
596         final DiscoveryNode rebootedOtherNode = new DiscoveryNode("rebooted-node", otherNode.getAddress(), Version.CURRENT);
597         transportAddressConnector.addReachableNode(rebootedOtherNode);
598         connectedNodes.remove(otherNode);
599         disconnectedNodes.add(otherNode);
600         deterministicTaskQueue.advanceTime();
601         runAllRunnableTasks();
602         assertFoundPeers(rebootedOtherNode);
603     }
604     private void respondToRequests(Function&lt;DiscoveryNode, PeersResponse&gt; responseFactory) {
605         final CapturedRequest[] capturedRequests = capturingTransport.getCapturedRequestsAndClear();
606         for (final CapturedRequest capturedRequest : capturedRequests) {
607             assertThat(capturedRequest.action, is(REQUEST_PEERS_ACTION_NAME));
608             assertThat(capturedRequest.request, instanceOf(PeersRequest.class));
609             final PeersRequest peersRequest = (PeersRequest) capturedRequest.request;
610             assertThat(peersRequest.getSourceNode(), is(localNode));
611             capturingTransport.handleResponse(capturedRequests[0].requestId, responseFactory.apply(capturedRequest.node));
612         }
613     }
614     private void assertFoundPeers(DiscoveryNode... expectedNodesArray) {
615         final Set&lt;DiscoveryNode&gt; expectedNodes = Arrays.stream(expectedNodesArray).collect(Collectors.toSet());
616         final List&lt;DiscoveryNode&gt; actualNodesList
617             = StreamSupport.stream(peerFinder.getFoundPeers().spliterator(), false).collect(Collectors.toList());
618         final HashSet&lt;DiscoveryNode&gt; actualNodesSet = new HashSet&lt;&gt;(actualNodesList);
619         assertThat(actualNodesSet, equalTo(expectedNodes));
620         assertTrue("no duplicates in " + actualNodesList, actualNodesSet.size() == actualNodesList.size());
621         assertNotifiedOfAllUpdates();
622     }
623     private void assertNotifiedOfAllUpdates() {
624         final Stream&lt;DiscoveryNode&gt; actualNodes = StreamSupport.stream(peerFinder.getFoundPeers().spliterator(), false);
625         final Stream&lt;DiscoveryNode&gt; notifiedNodes = StreamSupport.stream(foundPeersFromNotification.spliterator(), false);
626         assertThat(notifiedNodes.collect(Collectors.toSet()), equalTo(actualNodes.collect(Collectors.toSet())));
627     }
628     private DiscoveryNode newDiscoveryNode(String nodeId) {
629         return new DiscoveryNode(nodeId, buildNewFakeTransportAddress(), Version.CURRENT);
630     }
631     private void runAllRunnableTasks() {
632         deterministicTaskQueue.scheduleNow(new Runnable() {
633             @Override
634             public void run() {
635                 PeerFinderTests.this.assertNotifiedOfAllUpdates();
636             }
637             @Override
638             public String toString() {
639                 return "assertNotifiedOfAllUpdates";
640             }
641         });
642         deterministicTaskQueue.runAllRunnableTasks();
643         assertNotifiedOfAllUpdates();
644     }
645 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
