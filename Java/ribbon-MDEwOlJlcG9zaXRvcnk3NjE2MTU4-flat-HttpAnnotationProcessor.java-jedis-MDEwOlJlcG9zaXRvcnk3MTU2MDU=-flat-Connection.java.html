
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.398826979472141%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-HttpAnnotationProcessor.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.netflix.ribbon.proxy.processor;
2  import com.netflix.ribbon.RibbonResourceFactory;
3  import com.netflix.ribbon.http.HttpRequestTemplate.Builder;
4  import com.netflix.ribbon.http.HttpResourceGroup;
5  import com.netflix.ribbon.proxy.ProxyAnnotationException;
6  import com.netflix.ribbon.proxy.annotation.Http;
7  import com.netflix.ribbon.proxy.annotation.Http.Header;
8  import com.netflix.ribbon.proxy.annotation.Http.HttpMethod;
9  import java.lang.reflect.Method;
10  import java.util.ArrayList;
11  import java.util.HashMap;
12  import java.util.List;
13  import java.util.Map;
14  import java.util.Map.Entry;
15  import static java.lang.String.format;
</span>16  public class HttpAnnotationProcessor implements AnnotationProcessor<HttpResourceGroup.Builder, Builder> {
17      @Override
18      public void process(String templateName, Builder templateBuilder, Method method) {
19          Http annotation = method.getAnnotation(Http.class);
20          if (null == annotation) {
21              throw new ProxyAnnotationException(format("Method %s misses @Http annotation", method.getName()));
22          }
23          final HttpMethod httpMethod = annotation.method();
24          final String uriTemplate = annotation.uri();
25          final Map<String, List<String>> headers = annotation.headers().length == 0 ? null : new HashMap<String, List<String>>();
26          for (Header h : annotation.headers()) {
27              if (!headers.containsKey(h.name())) {
28                  ArrayList<String> values = new ArrayList<String>();
29                  values.add(h.value());
30                  headers.put(h.name(), values);
31              } else {
32                  headers.get(h.name()).add(h.value());
33              }
34          }
35          templateBuilder.withMethod(httpMethod.name());
36          if (uriTemplate != null) {
37              templateBuilder.withUriTemplate(uriTemplate);
38          }
39          if (headers != null) {
40              for (Entry<String, List<String>> header : headers.entrySet()) {
41                  String key = header.getKey();
42                  for (String value : header.getValue()) {
43                      templateBuilder.withHeader(key, value);
44                  }
45              }
46          }
47      }
48      @Override
49      public void process(String groupName, HttpResourceGroup.Builder groupBuilder, RibbonResourceFactory resourceFactory, Class<?> interfaceClass) {
50      }
51  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Connection.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package redis.clients.jedis;
2  import java.io.Closeable;
3  import java.io.IOException;
4  import java.net.Socket;
5  import java.net.SocketException;
6  import java.nio.ByteBuffer;
7  import java.nio.CharBuffer;
8  import java.util.ArrayList;
9  import java.util.Arrays;
10  import java.util.List;
11  import java.util.Map;
12  import java.util.function.Supplier;
13  import redis.clients.jedis.Protocol.Command;
14  import redis.clients.jedis.Protocol.Keyword;
15  import redis.clients.jedis.args.ClientAttributeOption;
</span>16  import redis.clients.jedis.args.Rawable;
17  import redis.clients.jedis.commands.ProtocolCommand;
18  import redis.clients.jedis.exceptions.JedisConnectionException;
19  import redis.clients.jedis.exceptions.JedisDataException;
20  import redis.clients.jedis.exceptions.JedisException;
21  import redis.clients.jedis.exceptions.JedisValidationException;
22  import redis.clients.jedis.util.IOUtils;
23  import redis.clients.jedis.util.JedisMetaInfo;
24  import redis.clients.jedis.util.RedisInputStream;
25  import redis.clients.jedis.util.RedisOutputStream;
26  import redis.clients.jedis.util.SafeEncoder;
27  public class Connection implements Closeable {
28    private ConnectionPool memberOf;
29    private RedisProtocol protocol;
30    private final JedisSocketFactory socketFactory;
31    private Socket socket;
32    private RedisOutputStream outputStream;
33    private RedisInputStream inputStream;
34    private int soTimeout = 0;
35    private int infiniteSoTimeout = 0;
36    private boolean broken = false;
37    public Connection() {
38      this(Protocol.DEFAULT_HOST, Protocol.DEFAULT_PORT);
39    }
40    public Connection(final String host, final int port) {
41      this(new HostAndPort(host, port));
42    }
43    public Connection(final HostAndPort hostAndPort) {
44      this(new DefaultJedisSocketFactory(hostAndPort));
45    }
46    public Connection(final HostAndPort hostAndPort, final JedisClientConfig clientConfig) {
47      this(new DefaultJedisSocketFactory(hostAndPort, clientConfig));
48      this.infiniteSoTimeout = clientConfig.getBlockingSocketTimeoutMillis();
49      initializeFromClientConfig(clientConfig);
50    }
51    public Connection(final JedisSocketFactory socketFactory) {
52      this.socketFactory = socketFactory;
53    }
54    public Connection(final JedisSocketFactory socketFactory, JedisClientConfig clientConfig) {
55      this.socketFactory = socketFactory;
56      this.soTimeout = clientConfig.getSocketTimeoutMillis();
57      this.infiniteSoTimeout = clientConfig.getBlockingSocketTimeoutMillis();
58      initializeFromClientConfig(clientConfig);
59    }
60    @Override
61    public String toString() {
62      return "Connection{" + socketFactory + "}";
63    }
64    final RedisProtocol getRedisProtocol() {
65      return protocol;
66    }
67    public final void setHandlingPool(final ConnectionPool pool) {
68      this.memberOf = pool;
69    }
70    final HostAndPort getHostAndPort() {
71      return ((DefaultJedisSocketFactory) socketFactory).getHostAndPort();
72    }
73    public int getSoTimeout() {
74      return soTimeout;
75    }
76    public void setSoTimeout(int soTimeout) {
77      this.soTimeout = soTimeout;
78      if (this.socket != null) {
79        try {
80          this.socket.setSoTimeout(soTimeout);
81        } catch (SocketException ex) {
82          broken = true;
83          throw new JedisConnectionException(ex);
84        }
85      }
86    }
87    public void setTimeoutInfinite() {
88      try {
89        if (!isConnected()) {
90          connect();
91        }
92        socket.setSoTimeout(infiniteSoTimeout);
93      } catch (SocketException ex) {
94        broken = true;
95        throw new JedisConnectionException(ex);
96      }
97    }
98    public void rollbackTimeout() {
99      try {
100        socket.setSoTimeout(this.soTimeout);
101      } catch (SocketException ex) {
102        broken = true;
103        throw new JedisConnectionException(ex);
104      }
105    }
106    public Object executeCommand(final ProtocolCommand cmd) {
107      return executeCommand(new CommandArguments(cmd));
108    }
109    public Object executeCommand(final CommandArguments args) {
110      sendCommand(args);
111      return getOne();
112    }
113    public <T> T executeCommand(final CommandObject<T> commandObject) {
114      final CommandArguments args = commandObject.getArguments();
115      sendCommand(args);
116      if (!args.isBlocking()) {
117        return commandObject.getBuilder().build(getOne());
118      } else {
119        try {
120          setTimeoutInfinite();
121          return commandObject.getBuilder().build(getOne());
122        } finally {
123          rollbackTimeout();
124        }
125      }
126    }
127    public void sendCommand(final ProtocolCommand cmd) {
128      sendCommand(new CommandArguments(cmd));
129    }
130    public void sendCommand(final ProtocolCommand cmd, Rawable keyword) {
131      sendCommand(new CommandArguments(cmd).add(keyword));
132    }
133    public void sendCommand(final ProtocolCommand cmd, final String... args) {
134      sendCommand(new CommandArguments(cmd).addObjects((Object[]) args));
135    }
136    public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {
137      sendCommand(new CommandArguments(cmd).addObjects((Object[]) args));
138    }
139    public void sendCommand(final CommandArguments args) {
140      try {
141        connect();
142        Protocol.sendCommand(outputStream, args);
143      } catch (JedisConnectionException ex) {
144        try {
145          String errorMessage = Protocol.readErrorLineIfPossible(inputStream);
146          if (errorMessage != null && errorMessage.length() > 0) {
147            ex = new JedisConnectionException(errorMessage, ex.getCause());
148          }
149        } catch (Exception e) {
150        }
151        broken = true;
152        throw ex;
153      }
154    }
155    public void connect() throws JedisConnectionException {
156      if (!isConnected()) {
157        try {
158          socket = socketFactory.createSocket();
159          soTimeout = socket.getSoTimeout(); 
160          outputStream = new RedisOutputStream(socket.getOutputStream());
161          inputStream = new RedisInputStream(socket.getInputStream());
162          broken = false; 
163        } catch (JedisConnectionException jce) {
164          setBroken();
165          throw jce;
166        } catch (IOException ioe) {
167          setBroken();
168          throw new JedisConnectionException("Failed to create input/output stream", ioe);
169        } finally {
170          if (broken) {
171            IOUtils.closeQuietly(socket);
172          }
173        }
174      }
175    }
176    @Override
177    public void close() {
178      if (this.memberOf != null) {
179        ConnectionPool pool = this.memberOf;
180        this.memberOf = null;
181        if (isBroken()) {
182          pool.returnBrokenResource(this);
183        } else {
184          pool.returnResource(this);
185        }
186      } else {
187        disconnect();
188      }
189    }
190    public void disconnect() {
191      if (isConnected()) {
192        try {
193          outputStream.flush();
194          socket.close();
195        } catch (IOException ex) {
196          throw new JedisConnectionException(ex);
197        } finally {
198          IOUtils.closeQuietly(socket);
199          setBroken();
200        }
201      }
202    }
203    public boolean isConnected() {
204      return socket != null && socket.isBound() && !socket.isClosed() && socket.isConnected()
205          && !socket.isInputShutdown() && !socket.isOutputShutdown();
206    }
207    public boolean isBroken() {
208      return broken;
209    }
210    public void setBroken() {
211      broken = true;
212    }
213    public String getStatusCodeReply() {
214      flush();
215      final byte[] resp = (byte[]) readProtocolWithCheckingBroken();
216      if (null == resp) {
217        return null;
218      } else {
219        return SafeEncoder.encode(resp);
220      }
221    }
222    public String getBulkReply() {
223      final byte[] result = getBinaryBulkReply();
224      if (null != result) {
225        return SafeEncoder.encode(result);
226      } else {
227        return null;
228      }
229    }
230    public byte[] getBinaryBulkReply() {
231      flush();
232      return (byte[]) readProtocolWithCheckingBroken();
233    }
234    public Long getIntegerReply() {
235      flush();
236      return (Long) readProtocolWithCheckingBroken();
237    }
238    public List<String> getMultiBulkReply() {
239      return BuilderFactory.STRING_LIST.build(getBinaryMultiBulkReply());
240    }
241    @SuppressWarnings("unchecked")
242    public List<byte[]> getBinaryMultiBulkReply() {
243      flush();
244      return (List<byte[]>) readProtocolWithCheckingBroken();
245    }
246    @Deprecated
247    @SuppressWarnings("unchecked")
248    public List<Object> getUnflushedObjectMultiBulkReply() {
249      return (List<Object>) readProtocolWithCheckingBroken();
250    }
251    @SuppressWarnings("unchecked")
252    public Object getUnflushedObject() {
253      return readProtocolWithCheckingBroken();
254    }
255    public List<Object> getObjectMultiBulkReply() {
256      flush();
257      return (List<Object>) readProtocolWithCheckingBroken();
258    }
259    @SuppressWarnings("unchecked")
260    public List<Long> getIntegerMultiBulkReply() {
261      flush();
262      return (List<Long>) readProtocolWithCheckingBroken();
263    }
264    public Object getOne() {
265      flush();
266      return readProtocolWithCheckingBroken();
267    }
268    protected void flush() {
269      try {
270        outputStream.flush();
271      } catch (IOException ex) {
272        broken = true;
273        throw new JedisConnectionException(ex);
274      }
275    }
276    protected Object readProtocolWithCheckingBroken() {
277      if (broken) {
278        throw new JedisConnectionException("Attempting to read from a broken connection");
279      }
280      try {
281        return Protocol.read(inputStream);
282      } catch (JedisConnectionException exc) {
283        broken = true;
284        throw exc;
285      }
286    }
287    public List<Object> getMany(final int count) {
288      flush();
289      final List<Object> responses = new ArrayList<>(count);
290      for (int i = 0; i < count; i++) {
291        try {
292          responses.add(readProtocolWithCheckingBroken());
293        } catch (JedisDataException e) {
294          responses.add(e);
295        }
296      }
297      return responses;
298    }
299    private static boolean validateClientInfo(String info) {
300      for (int i = 0; i < info.length(); i++) {
301        char c = info.charAt(i);
302        if (c < '!' || c > '~') {
303          throw new JedisValidationException("client info cannot contain spaces, "
304              + "newlines or special characters.");
305        }
306      }
307      return true;
308    }
309    private void initializeFromClientConfig(JedisClientConfig config) {
310      try {
311        connect();
312        protocol = config.getRedisProtocol();
313        boolean doClientName = true;
314        if (protocol == RedisProtocol.RESP3 && config.getUser() != null) {
315          hello(protocol, config.getUser(), config.getPassword(), config.getClientName());
316          doClientName = false;
317        } else {
318          Supplier<RedisCredentials> credentialsProvider = config.getCredentialsProvider();
319          if (credentialsProvider instanceof RedisCredentialsProvider) {
320            try {
321              ((RedisCredentialsProvider) credentialsProvider).prepare();
322              auth(credentialsProvider);
323            } finally {
324              ((RedisCredentialsProvider) credentialsProvider).cleanUp();
325            }
326          } else {
327            auth(credentialsProvider);
328          }
329          if (protocol != null) {
330            hello(protocol);
331          }
332        }
333        int dbIndex = config.getDatabase();
334        if (dbIndex > 0) {
335          select(dbIndex);
336        }
337        List<CommandArguments> fireAndForgetMsg = new ArrayList<>();
338        String clientName = config.getClientName();
339        if (doClientName && clientName != null && validateClientInfo(clientName)) {
340          fireAndForgetMsg.add(new CommandArguments(Command.CLIENT).add(Keyword.SETNAME).add(clientName));
341        }
342        String libName = JedisMetaInfo.getArtifactId();
343        if (libName != null && validateClientInfo(libName)) {
344          fireAndForgetMsg.add(new CommandArguments(Command.CLIENT).add(Keyword.SETINFO)
345              .add(ClientAttributeOption.LIB_NAME.getRaw()).add(libName));
346        }
347        String libVersion = JedisMetaInfo.getVersion();
348        if (libVersion != null && validateClientInfo(libVersion)) {
349          fireAndForgetMsg.add(new CommandArguments(Command.CLIENT).add(Keyword.SETINFO)
350              .add(ClientAttributeOption.LIB_VER.getRaw()).add(libVersion));
351        }
352        for (CommandArguments arg : fireAndForgetMsg) {
353          sendCommand(arg);
354        }
355        getMany(fireAndForgetMsg.size());
356      } catch (JedisException je) {
357        try {
358          disconnect();
359        } catch (Exception e) {
360        }
361        throw je;
362      }
363    }
364    private Map hello(final RedisProtocol protocol) {
365      sendCommand(Protocol.Command.HELLO, String.valueOf(protocol.version()));
366      Map reply = BuilderFactory.ENCODED_OBJECT_MAP.build(getOne());
367      return reply;
368    }
369    private Map hello(final RedisProtocol protocol, final String user, final String password,
370        final String clientName) {
371      if (clientName == null) {
372        sendCommand(Protocol.Command.HELLO, String.valueOf(protocol.version()),
373            Protocol.Keyword.AUTH.name(), user, password);
374      } else {
375        sendCommand(Protocol.Command.HELLO, String.valueOf(protocol.version()),
376            Protocol.Keyword.AUTH.name(), user, password,
377            Protocol.Keyword.SETNAME.name(), clientName);
378      }
379      Map reply = BuilderFactory.ENCODED_OBJECT_MAP.build(getOne());
380      return reply;
381    }
382    private void auth(final Supplier<RedisCredentials> credentialsProvider) {
383      RedisCredentials credentials = credentialsProvider.get();
384      if (credentials == null || credentials.getPassword() == null) return;
385      ByteBuffer passBuf = Protocol.CHARSET.encode(CharBuffer.wrap(credentials.getPassword()));
386      byte[] rawPass = Arrays.copyOfRange(passBuf.array(), passBuf.position(), passBuf.limit());
387      Arrays.fill(passBuf.array(), (byte) 0); 
388      if (credentials.getUser() != null) {
389        sendCommand(Protocol.Command.AUTH, SafeEncoder.encode(credentials.getUser()), rawPass);
390      } else {
391        sendCommand(Protocol.Command.AUTH, rawPass);
392      }
393      Arrays.fill(rawPass, (byte) 0); 
394      getStatusCodeReply(); 
395    }
396    public String select(final int index) {
397      sendCommand(Protocol.Command.SELECT, Protocol.toByteArray(index));
398      return getStatusCodeReply();
399    }
400    public boolean ping() {
401      sendCommand(Protocol.Command.PING);
402      String status = getStatusCodeReply();
403      if (!"PONG".equals(status)) {
404        throw new JedisException(status);
405      }
406      return true;
407    }
408  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-HttpAnnotationProcessor.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Connection.java</div>
                </div>
                <div class="column column_space"><pre><code>1  package com.netflix.ribbon.proxy.processor;
2  import com.netflix.ribbon.RibbonResourceFactory;
3  import com.netflix.ribbon.http.HttpRequestTemplate.Builder;
4  import com.netflix.ribbon.http.HttpResourceGroup;
5  import com.netflix.ribbon.proxy.ProxyAnnotationException;
6  import com.netflix.ribbon.proxy.annotation.Http;
7  import com.netflix.ribbon.proxy.annotation.Http.Header;
8  import com.netflix.ribbon.proxy.annotation.Http.HttpMethod;
9  import java.lang.reflect.Method;
10  import java.util.ArrayList;
11  import java.util.HashMap;
12  import java.util.List;
13  import java.util.Map;
14  import java.util.Map.Entry;
15  import static java.lang.String.format;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package redis.clients.jedis;
2  import java.io.Closeable;
3  import java.io.IOException;
4  import java.net.Socket;
5  import java.net.SocketException;
6  import java.nio.ByteBuffer;
7  import java.nio.CharBuffer;
8  import java.util.ArrayList;
9  import java.util.Arrays;
10  import java.util.List;
11  import java.util.Map;
12  import java.util.function.Supplier;
13  import redis.clients.jedis.Protocol.Command;
14  import redis.clients.jedis.Protocol.Keyword;
15  import redis.clients.jedis.args.ClientAttributeOption;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    