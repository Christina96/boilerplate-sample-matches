
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.67579908675799%, Tokens: 19</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-Netty4HttpServer.java</h3>
            <pre><code>1  package com.weibo.api.motan.transport.netty4.http;
2  import io.netty.bootstrap.ServerBootstrap;
3  import io.netty.channel.Channel;
4  import io.netty.channel.ChannelFuture;
5  import io.netty.channel.ChannelInitializer;
6  import io.netty.channel.ChannelOption;
7  import io.netty.channel.EventLoopGroup;
8  import io.netty.channel.nio.NioEventLoopGroup;
9  import io.netty.channel.socket.SocketChannel;
10  import io.netty.channel.socket.nio.NioServerSocketChannel;
11  import io.netty.handler.codec.http.HttpObjectAggregator;
12  import io.netty.handler.codec.http.HttpRequestDecoder;
13  import io.netty.handler.codec.http.HttpResponseEncoder;
14  import io.netty.handler.stream.ChunkedWriteHandler;
15  import java.util.concurrent.ArrayBlockingQueue;
16  import java.util.concurrent.ThreadPoolExecutor;
17  import java.util.concurrent.TimeUnit;
<span onclick='openModal()' class='match'>18  import com.weibo.api.motan.common.ChannelState;
19  import com.weibo.api.motan.common.MotanConstants;
20  import com.weibo.api.motan.common.URLParamType;
21  import com.weibo.api.motan.exception.MotanFrameworkException;
22  import com.weibo.api.motan.rpc.Request;
23  import com.weibo.api.motan.rpc.Response;
24  import com.weibo.api.motan.rpc.URL;
25  import com.weibo.api.motan.transport.AbstractServer;
26  import com.weibo.api.motan.transport.MessageHandler;
27  import com.weibo.api.motan.transport.TransportException;
28  import com.weibo.api.motan.util.LoggerUtil;
29  import com.weibo.api.motan.util.StatisticCallback;
30  import com.weibo.api.motan.util.StatsUtil;
31  public class Netty4HttpServer extends AbstractServer implements StatisticCallback {
32      private MessageHandler messageHandler;
33      private URL url;
34      private Channel channel;
35      private EventLoopGroup bossGroup;
36      private EventLoopGroup workerGroup;
</span>37      public Netty4HttpServer(URL url, MessageHandler messageHandler) {
38          this.url = url;
39          this.messageHandler = messageHandler;
40      }
41      @Override
42      public boolean open() {
43          if (isAvailable()) {
44              return true;
45          }
46          if (channel != null) {
47              channel.close();
48          }
49          if (bossGroup == null) {
50              bossGroup = new NioEventLoopGroup();
51              workerGroup = new NioEventLoopGroup();
52          }
53          boolean shareChannel = url.getBooleanParameter(URLParamType.shareChannel.getName(), URLParamType.shareChannel.getBooleanValue());
54          int maxServerConnection =
55                  url.getIntParameter(URLParamType.maxServerConnection.getName(), URLParamType.maxServerConnection.getIntValue());
56          int workerQueueSize = url.getIntParameter(URLParamType.workerQueueSize.getName(), 500);
57          int minWorkerThread = 0, maxWorkerThread = 0;
58          if (shareChannel) {
59              minWorkerThread = url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MIN_WORKDER);
60              maxWorkerThread = url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MAX_WORKDER);
61          } else {
62              minWorkerThread =
63                      url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MIN_WORKDER);
64              maxWorkerThread =
65                      url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MAX_WORKDER);
66          }
67          final int maxContentLength = url.getIntParameter(URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.getIntValue());
68          final NettyHttpRequestHandler handler =
69                  new NettyHttpRequestHandler(this, messageHandler, new ThreadPoolExecutor(minWorkerThread, maxWorkerThread, 15,
70                          TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(workerQueueSize)));
71          ServerBootstrap b = new ServerBootstrap();
72          b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {
73              @Override
74              public void initChannel(SocketChannel ch) throws Exception {
75                  ch.pipeline().addLast("http-decoder", new HttpRequestDecoder());
76                  ch.pipeline().addLast("http-aggregator", new HttpObjectAggregator(maxContentLength));
77                  ch.pipeline().addLast("http-encoder", new HttpResponseEncoder());
78                  ch.pipeline().addLast("http-chunked", new ChunkedWriteHandler());
79                  ch.pipeline().addLast("serverHandler", handler);
80              }
81          }).option(ChannelOption.SO_BACKLOG, 1024).childOption(ChannelOption.SO_KEEPALIVE, false);
82          ChannelFuture f;
83          try {
84              f = b.bind(url.getPort()).sync();
85              channel = f.channel();
86          } catch (InterruptedException e) {
87              LoggerUtil.error("init http server fail.", e);
88              return false;
89          }
90          state = ChannelState.ALIVE;
91          StatsUtil.registryStatisticCallback(this);
92          LoggerUtil.info("Netty4HttpServer ServerChannel finish Open: url=" + url);
93          return true;
94      }
95      @Override
96      public void close() {
97          close(0);
98      }
99      @Override
100      public boolean isAvailable() {
101          return state.isAliveState();
102      }
103      @Override
104      public boolean isBound() {
105          return channel != null && channel.isActive();
106      }
107      @Override
108      public Response request(Request request) throws TransportException {
109          throw new MotanFrameworkException("Netty4HttpServer request(Request request) method unsupport: url: " + url);
110      }
111      @Override
112      public void close(int timeout) {
113          if (state.isCloseState()) {
114              LoggerUtil.info("NettyServer close fail: already close, url={}", url.getUri());
115              return;
116          }
117          if (state.isUnInitState()) {
118              LoggerUtil.info("NettyServer close Fail: don't need to close because node is unInit state: url={}",
119                      url.getUri());
120              return;
121          }
122          if (channel != null) {
123              channel.close();
124              workerGroup.shutdownGracefully();
125              bossGroup.shutdownGracefully();
126              workerGroup = null;
127              bossGroup = null;
128          }
129          state = ChannelState.CLOSE;
130          StatsUtil.unRegistryStatisticCallback(this);
131      }
132      @Override
133      public boolean isClosed() {
134          return state.isCloseState();
135      }
136      @Override
137      public String statisticCallback() {
138          return null;
139      }
140      @Override
141      public URL getUrl() {
142          return url;
143      }
144  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-RegistryConfig.java</h3>
            <pre><code>1  package com.weibo.api.motan.config;
<span onclick='openModal()' class='match'>2  import com.weibo.api.motan.common.MotanConstants;
3  import com.weibo.api.motan.common.URLParamType;
4  import com.weibo.api.motan.config.annotation.ConfigDesc;
5  import com.weibo.api.motan.registry.RegistryService;
6  import com.weibo.api.motan.rpc.URL;
7  import com.weibo.api.motan.util.LoggerUtil;
8  import com.weibo.api.motan.util.NetUtils;
9  import com.weibo.api.motan.util.UrlUtils;
10  import org.apache.commons.lang3.StringUtils;
11  import java.util.Collections;
12  import java.util.HashMap;
13  import java.util.List;
14  import java.util.Map;
15  public class RegistryConfig extends AbstractConfig {
16      private static final long serialVersionUID = 3236055928361714933L;
17      private String name;
18      private String regProtocol;
19      private String address;
20      private Integer port;
</span>21      private Integer requestTimeout;
22      private Integer connectTimeout;
23      private Integer registrySessionTimeout;
24      private Integer registryRetryPeriod;
25      private String check;
26      private Boolean register;
27      private Boolean subscribe;
28      private Boolean isDefault;
29      private String excise;
30      private RegistryConfig proxyRegistry;
31      private String meshRegistryName;
32      private Boolean dynamic; 
33      @ConfigDesc(key = "protocol")
34      public String getRegProtocol() {
35          return regProtocol;
36      }
37      public void setRegProtocol(String regProtocol) {
38          this.regProtocol = regProtocol;
39      }
40      public String getAddress() {
41          return address;
42      }
43      public void setAddress(String address) {
44          this.address = address;
45      }
46      public Integer getPort() {
47          return port;
48      }
49      public void setPort(Integer port) {
50          this.port = port;
51      }
52      public String getCheck() {
53          return check;
54      }
55      public void setCheck(String check) {
56          this.check = check;
57      }
58      @Deprecated
59      public void setCheck(Boolean check) {
60          this.check = String.valueOf(check);
61      }
62      public Boolean getRegister() {
63          return register;
64      }
65      public void setRegister(Boolean register) {
66          this.register = register;
67      }
68      public Boolean getSubscribe() {
69          return subscribe;
70      }
71      public void setSubscribe(Boolean subscribe) {
72          this.subscribe = subscribe;
73      }
74      public String getName() {
75          return name;
76      }
77      public void setName(String name) {
78          this.name = name;
79      }
80      public Integer getRequestTimeout() {
81          return requestTimeout;
82      }
83      public void setRequestTimeout(Integer requestTimeout) {
84          this.requestTimeout = requestTimeout;
85      }
86      public Integer getRegistrySessionTimeout() {
87          return registrySessionTimeout;
88      }
89      public void setRegistrySessionTimeout(Integer registrySessionTimeout) {
90          this.registrySessionTimeout = registrySessionTimeout;
91      }
92      public Integer getRegistryRetryPeriod() {
93          return registryRetryPeriod;
94      }
95      public void setRegistryRetryPeriod(Integer registryRetryPeriod) {
96          this.registryRetryPeriod = registryRetryPeriod;
97      }
98      public String getExcise() {
99          return excise;
100      }
101      public void setExcise(String excise) {
102          this.excise = excise;
103      }
104      public void setDefault(boolean isDefault) {
105          this.isDefault = isDefault;
106      }
107      public Boolean isDefault() {
108          return isDefault;
109      }
110      public Integer getConnectTimeout() {
111          return connectTimeout;
112      }
113      public void setConnectTimeout(Integer connectTimeout) {
114          this.connectTimeout = connectTimeout;
115      }
116      public RegistryConfig getProxyRegistry() {
117          return proxyRegistry;
118      }
119      public void setProxyRegistry(RegistryConfig proxyRegistry) {
120          this.proxyRegistry = proxyRegistry;
121      }
122      public String getMeshRegistryName() {
123          return meshRegistryName;
124      }
125      public void setMeshRegistryName(String meshRegistryName) {
126          this.meshRegistryName = meshRegistryName;
127      }
128      public Boolean getDynamic() {
129          return dynamic;
130      }
131      public void setDynamic(Boolean dynamic) {
132          this.dynamic = dynamic;
133      }
134      public enum Excise {
135          excise_static("static"), excise_dynamic("dynamic"), excise_ratio("ratio");
136          private String name;
137          Excise(String n) {
138              this.name = n;
139          }
140          public String getName() {
141              return name;
142          }
143      }
144      public List<URL> toURLs() {
145          String address = getAddress();
146          if (StringUtils.isBlank(address)) {
147              address = NetUtils.LOCALHOST + ":" + MotanConstants.DEFAULT_INT_VALUE;
148          }
149          Map<String, String> map = new HashMap<>();
150          map.putAll(getAddressParams());
151          appendConfigParams(map);
152          map.put(URLParamType.path.getName(), RegistryService.class.getName());
153          map.put(URLParamType.refreshTimestamp.getName(), String.valueOf(System.currentTimeMillis()));
154          if (!map.containsKey(URLParamType.protocol.getName())) {
155              if (address.contains(":&bsol;&bsol;")) {
156                  map.put(URLParamType.protocol.getName(), address.substring(0, address.indexOf(":&bsol;&bsol;")));
157              } else {
158                  map.put(URLParamType.protocol.getName(), MotanConstants.REGISTRY_PROTOCOL_LOCAL);
159              }
160          }
161          if (proxyRegistry != null) {
162              String proxyRegistryString = UrlUtils.urlsToString(proxyRegistry.toURLs());
163              if (StringUtils.isNotBlank(proxyRegistryString)) {
164                  map.put(URLParamType.proxyRegistryUrlString.getName(), proxyRegistryString);
165              } else {
166                  LoggerUtil.warn("parse proxyRegistryString is empty, proxy registry:" + proxyRegistry.getName());
167              }
168          }
169          return UrlUtils.parseURLs(address, map);
170      }
171      public Map<String, String> getAddressParams() {
172          if (StringUtils.isNotBlank(address)) {
173              int index = address.indexOf("?");
174              if (index > -1) {
175                  int end = address.length();
176                  if (address.contains(MotanConstants.COMMA_SEPARATOR)) {
177                      end = address.indexOf(MotanConstants.COMMA_SEPARATOR);
178                  }
179                  return UrlUtils.parseQueryParams(address.substring(index + 1, end));
180              }
181          }
182          return Collections.emptyMap();
183      }
184  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-Netty4HttpServer.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-RegistryConfig.java</div>
                </div>
                <div class="column column_space"><pre><code>18  import com.weibo.api.motan.common.ChannelState;
19  import com.weibo.api.motan.common.MotanConstants;
20  import com.weibo.api.motan.common.URLParamType;
21  import com.weibo.api.motan.exception.MotanFrameworkException;
22  import com.weibo.api.motan.rpc.Request;
23  import com.weibo.api.motan.rpc.Response;
24  import com.weibo.api.motan.rpc.URL;
25  import com.weibo.api.motan.transport.AbstractServer;
26  import com.weibo.api.motan.transport.MessageHandler;
27  import com.weibo.api.motan.transport.TransportException;
28  import com.weibo.api.motan.util.LoggerUtil;
29  import com.weibo.api.motan.util.StatisticCallback;
30  import com.weibo.api.motan.util.StatsUtil;
31  public class Netty4HttpServer extends AbstractServer implements StatisticCallback {
32      private MessageHandler messageHandler;
33      private URL url;
34      private Channel channel;
35      private EventLoopGroup bossGroup;
36      private EventLoopGroup workerGroup;
</pre></code></div>
                <div class="column column_space"><pre><code>2  import com.weibo.api.motan.common.MotanConstants;
3  import com.weibo.api.motan.common.URLParamType;
4  import com.weibo.api.motan.config.annotation.ConfigDesc;
5  import com.weibo.api.motan.registry.RegistryService;
6  import com.weibo.api.motan.rpc.URL;
7  import com.weibo.api.motan.util.LoggerUtil;
8  import com.weibo.api.motan.util.NetUtils;
9  import com.weibo.api.motan.util.UrlUtils;
10  import org.apache.commons.lang3.StringUtils;
11  import java.util.Collections;
12  import java.util.HashMap;
13  import java.util.List;
14  import java.util.Map;
15  public class RegistryConfig extends AbstractConfig {
16      private static final long serialVersionUID = 3236055928361714933L;
17      private String name;
18      private String regProtocol;
19      private String address;
20      private Integer port;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    