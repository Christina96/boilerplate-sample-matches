<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for SingleRowSubselectAnalyzerTest.java &amp; SelectPlannerTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for SingleRowSubselectAnalyzerTest.java &amp; SelectPlannerTest.java
      </h3>
<h1 align="center">
        9.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>SingleRowSubselectAnalyzerTest.java (76.42857%)<th>SelectPlannerTest.java (5.092813%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(96-109)<td><a href="#" name="0">(530-541)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(76-91)<td><a href="#" name="1">(1350-1376)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(22-42)<td><a href="#" name="2">(22-41)</a><td align="center"><font color="#aa0000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(55-65)<td><a href="#" name="3">(221-229)</a><td align="center"><font color="#8d0000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(110-116)<td><a href="#" name="4">(119-123)</a><td align="center"><font color="#5e0000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(66-71)<td><a href="#" name="5">(108-112)</a><td align="center"><font color="#5e0000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SingleRowSubselectAnalyzerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19 <a name="2"></a> * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.analyze;
22 import io.crate.analyze.relations.AnalyzedRelation;
23 import io.crate.expression.operator.EqOperator;
24 import io.crate.expression.symbol.MatchPredicate;
25 import io.crate.expression.symbol.SelectSymbol;
26 import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
27 import io.crate.testing.SQLExecutor;
28 import org.hamcrest.Matchers;
29 import org.junit.Before;
30 import org.junit.Test;
31 import java.io.IOException;
32 import static io.crate.testing.SymbolMatchers.isFunction;
33 import static io.crate.testing.SymbolMatchers.isLiteral;
34 import static io.crate.testing.SymbolMatchers.isReference;
35 import static io.crate.testing.TestingHelpers.isSQL;
36 import static org.hamcrest.Matchers.hasEntry;
37 import static org.hamcrest.Matchers.instanceOf;
38 import</b></font> static org.hamcrest.Matchers.is;
39 public class SingleRowSubselectAnalyzerTest extends CrateDummyClusterServiceUnitTest {
40     private SQLExecutor e;
41     @Before
42     public void prepare() throws IOException {
43         e = SQLExecutor.builder(clusterService).enableDefaultTables().build();
44     }
45 <a name="3"></a>
46     @Test
47     public void testSingleRowSubselectInWhereClause() throws Exception {
48         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>QueriedSelectRelation relation = e.analyze("select * from t1 where x = (select y from t2)");
49         assertThat(relation.where(),
50             isSQL("(doc.t1.x = (SELECT y FROM (doc.t2)))"));
51     }
52     @Test
53     public void testSingleRowSubselectInWhereClauseNested() throws Exception {
54         QueriedSelectRelation relation = e.analyze(
55 <a name="5"></a>            "select a from t1 where x = (select y from t2 where y = (select z from t3))");
56         assertThat(relation.where(),
57             isSQL</b></font>("(doc.t1.x = (SELECT y FROM (doc.t2)))"));
58     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
59     @Test
60     public void testSingleRowSubselectInSelectList() {
61         AnalyzedRelation relation = e.analyze("select (select b from t2 limit 1) from t1");
62         assertThat(relation.outputs(), isSQL</b></font>("(SELECT b FROM (doc.t2))"));
63     }
64 <a name="1"></a>
65     @Test
66     public void testSubselectWithMultipleColumns() throws Exception {
67         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>expectedException.expectMessage("Subqueries with more than 1 column are not supported.");
68         e.analyze("select (select b, b from t2 limit 1) from t1");
69     }
70     @Test
71     public void testSingleRowSubselectInAssignmentOfUpdate() throws Exception {
72         AnalyzedUpdateStatement stmt = e.analyze("update t1 set x = (select y from t2)");
73         assertThat(
74             stmt.assignmentByTargetCol().values().iterator().next(),
75             Matchers.instanceOf(SelectSymbol.class));
76     }
77     @Test
78     public void testSingleRowSubselectInWhereClauseOfDelete() throws Exception {
79         AnalyzedDeleteStatement delete = e.analyze("delete from t1 where x = (select y from t2)");
80         assertThat(delete.query(), isFunction(EqOperator.NAME, isReference("x"), instanceOf</b></font>(SelectSymbol.class)));
81     }
82 <a name="0"></a>
83     @Test
84     public void testMatchPredicateWithSingleRowSubselect() throws Exception {
85         QueriedSelectRelation relation = <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e.analyze(
86             "select * from users where match(shape 1.2, (select shape from users limit 1))");
87         assertThat(relation.where(), instanceOf(MatchPredicate.class));
88         MatchPredicate match = (MatchPredicate) relation.where();
89         assertThat(match.identBoostMap(), hasEntry(isReference("shape"), isLiteral(1.2)));
90         assertThat(match.queryTerm(), instanceOf(SelectSymbol.class));
91         assertThat(match.matchType(), is("intersects"));
92     }
93     @Test
94     public void testLikeSupportsSubQueries() {
95 <a name="4"></a>        QueriedSelectRelation relation = e.analyze("select * from users where name like (select 'foo')");
96         assertThat(relation.where(),
97             isSQL</b></font>("(doc.users.name LIKE (SELECT 'foo' FROM (empty_row)))"));
98     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
99     @Test
100     public void testAnySupportsSubQueries() {
101         QueriedSelectRelation relation = e.analyze("select * from users where (select 'bar') = ANY (tags)");
102         assertThat(relation.where(),
103             isSQL</b></font>("((SELECT 'bar' FROM (empty_row)) = ANY(doc.users.tags))"));
104         relation = e.analyze("select * from users where 'bar' = ANY (select 'bar')");
105         assertThat(relation.where(),
106             isSQL("('bar' = ANY((SELECT 'bar' FROM (empty_row))))"));
107     }
108 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SelectPlannerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Licensed to Crate.io GmbH ("Crate") under one or more contributor
3  * license agreements.  See the NOTICE file distributed with this work for
4  * additional information regarding copyright ownership.  Crate licenses
5  * this file to you under the Apache License, Version 2.0 (the "License");
6  * you may not use this file except in compliance with the License.  You may
7  * obtain a copy of the License at
8  *
9  *   http://www.apache.org/licenses/LICENSE-2.0
10  *
11  * Unless required by applicable law or agreed to in writing, software
12  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
13  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
14  * License for the specific language governing permissions and limitations
15  * under the License.
16  *
17  * However, if you have executed another commercial license agreement
18  * with Crate these terms will supersede the license and you may use the
19 <a name="2"></a> * software solely pursuant to the terms of the relevant commercial agreement.
20  */
21 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.planner;
22 import static io.crate.planner.operators.LogicalPlannerTest.isPlan;
23 import static io.crate.testing.Asserts.assertThrowsMatches;
24 import static io.crate.testing.SymbolMatchers.isFunction;
25 import static io.crate.testing.SymbolMatchers.isLiteral;
26 import static io.crate.testing.SymbolMatchers.isReference;
27 import static io.crate.testing.TestingHelpers.isSQL;
28 import static java.util.Collections.singletonList;
29 import static org.hamcrest.Matchers.contains;
30 import static org.hamcrest.Matchers.equalTo;
31 import static org.hamcrest.Matchers.instanceOf;
32 import static org.hamcrest.Matchers.is;
33 import static org.hamcrest.Matchers.not;
34 import static org.hamcrest.Matchers.notNullValue;
35 import static org.hamcrest.Matchers.nullValue;
36 import java.util.Arrays;
37 import java.util.HashSet;
38 import</b></font> java.util.List;
39 import java.util.Map;
40 import java.util.Set;
41 import java.util.UUID;
42 import java.util.stream.Collectors;
43 import com.carrotsearch.hppc.IntIndexedContainer;
44 import com.carrotsearch.randomizedtesting.RandomizedTest;
45 import org.hamcrest.Matchers;
46 import org.junit.Test;
47 import io.crate.analyze.TableDefinitions;
48 import io.crate.data.RowN;
49 import io.crate.exceptions.UnsupportedFeatureException;
50 import io.crate.exceptions.VersioningValidationException;
51 import io.crate.execution.dsl.phases.ExecutionPhase;
52 import io.crate.execution.dsl.phases.MergePhase;
53 import io.crate.execution.dsl.phases.NodeOperation;
54 import io.crate.execution.dsl.phases.NodeOperationTree;
55 import io.crate.execution.dsl.phases.PKLookupPhase;
56 import io.crate.execution.dsl.phases.RoutedCollectPhase;
57 import io.crate.execution.dsl.projection.AggregationProjection;
58 import io.crate.execution.dsl.projection.EvalProjection;
59 import io.crate.execution.dsl.projection.FilterProjection;
60 import io.crate.execution.dsl.projection.GroupProjection;
61 import io.crate.execution.dsl.projection.MergeCountProjection;
62 import io.crate.execution.dsl.projection.OrderedTopNProjection;
63 import io.crate.execution.dsl.projection.Projection;
64 import io.crate.execution.dsl.projection.TopNDistinctProjection;
65 import io.crate.execution.dsl.projection.TopNProjection;
66 import io.crate.execution.dsl.projection.WindowAggProjection;
67 import io.crate.execution.engine.NodeOperationTreeGenerator;
68 import io.crate.execution.engine.aggregation.impl.CountAggregation;
69 import io.crate.expression.symbol.AggregateMode;
70 import io.crate.expression.symbol.Aggregation;
71 import io.crate.expression.symbol.Function;
72 import io.crate.expression.symbol.InputColumn;
73 import io.crate.expression.symbol.Literal;
74 import io.crate.expression.symbol.Symbol;
75 import io.crate.expression.symbol.SymbolType;
76 import io.crate.metadata.PartitionName;
77 import io.crate.metadata.Reference;
78 import io.crate.metadata.RelationName;
79 import io.crate.metadata.Routing;
80 import io.crate.metadata.RowGranularity;
81 import io.crate.planner.node.dql.Collect;
82 import io.crate.planner.node.dql.CountPlan;
83 import io.crate.planner.node.dql.QueryThenFetch;
84 import io.crate.planner.node.dql.join.Join;
85 import io.crate.planner.node.dql.join.JoinType;
86 import io.crate.planner.operators.LogicalPlan;
87 import io.crate.statistics.Stats;
88 import io.crate.statistics.TableStats;
89 import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
90 import io.crate.testing.SQLExecutor;
91 import io.crate.testing.T3;
92 import io.crate.testing.TestingHelpers;
93 import io.crate.types.DataTypes;
94 public class SelectPlannerTest extends CrateDummyClusterServiceUnitTest {
95     @Test
96     public void testHandlerSideRouting() throws Exception {
97 <a name="5"></a>        SQLExecutor e = SQLExecutor.builder(clusterService).build();
98         e.plan("select * from sys.cluster");
99     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
100     @Test
101     public void testWherePKAndMatchDoesNotResultInESGet() throws Exception {
102         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom</b></font>(), List.of())
103             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
104             .build();
105 <a name="4"></a>        ExecutionPlan plan = e.plan("select * from users where id in (1, 2, 3) and match(text, 'Hello')");
106         assertThat(plan, instanceOf(Merge.class));
107         assertThat(((Merge) plan).subPlan(), instanceOf(Collect.class));
108     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
109     @Test
110     public void testGetPlan() throws Exception {
111         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom</b></font>(), List.of())
112             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
113             .build();
114         LogicalPlan plan = e.logicalPlan("select name from users where id = 1");
115         assertThat(plan, isPlan(
116             "Get[doc.users | name | DocKeys{1::bigint} | (id = 1::bigint)]"));
117     }
118     @Test
119     public void testGetWithVersion() throws Exception {
120         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
121             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
122             .build();
123         LogicalPlan plan = e.logicalPlan("select name from users where id = 1 and _version = 1");
124         assertThat(plan, isPlan(
125             "Get[doc.users | name | DocKeys{1::bigint, 1::bigint} | ((id = 1::bigint) AND (_version = 1::bigint))]"));
126     }
127     @Test
128     public void testGetPlanStringLiteral() throws Exception {
129         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
130             .addTable(TableDefinitions.TEST_CLUSTER_BY_STRING_TABLE_DEFINITION)
131             .build();
132         LogicalPlan plan = e.logicalPlan("select name from bystring where name = 'one'");
133         assertThat(plan, isPlan(
134             "Get[doc.bystring | name | DocKeys{'one'} | (name = 'one')]"
135         ));
136     }
137     @Test
138     public void testGetPlanPartitioned() throws Exception {
139         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
140             .addPartitionedTable(
141                 TableDefinitions.PARTED_PKS_TABLE_DEFINITION,
142                 new PartitionName(new RelationName("doc", "parted_pks"), singletonList("1395874800000")).asIndexName(),
143                 new PartitionName(new RelationName("doc", "parted_pks"), singletonList("1395961200000")).asIndexName()
144             )
145             .build();
146         LogicalPlan plan = e.logicalPlan("select name, date from parted_pks where id = 1 and date = 0");
147         assertThat(plan, isPlan(
148             "Get[doc.parted_pks | name, date | DocKeys{1, 0::bigint} | ((id = 1) AND (date = 0::bigint))]"
149         ));
150     }
151     @Test
152     public void testMultiGetPlan() throws Exception {
153         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
154             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
155             .build();
156         LogicalPlan plan = e.logicalPlan("select name from users where id in (1, 2)");
157         assertThat(plan, isPlan(
158             "Get[doc.users | name | DocKeys{1::bigint; 2::bigint} | (id = ANY([1::bigint, 2::bigint]))]"
159         ));
160     }
161     @Test
162     public void testGlobalAggregationPlan() throws Exception {
163         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
164             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
165             .build();
166         Merge globalAggregate = e.plan("select count(name) from users");
167         Collect collect = (Collect) globalAggregate.subPlan();
168         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) collect.collectPhase());
169         assertEquals(CountAggregation.LongStateType.INSTANCE, collectPhase.outputTypes().get(0));
170         assertThat(collectPhase.maxRowGranularity(), is(RowGranularity.DOC));
171         assertThat(collectPhase.projections().size(), is(1));
172         assertThat(collectPhase.projections().get(0), instanceOf(AggregationProjection.class));
173         assertThat(collectPhase.projections().get(0).requiredGranularity(), is(RowGranularity.SHARD));
174         MergePhase mergePhase = globalAggregate.mergePhase();
175         assertEquals(CountAggregation.LongStateType.INSTANCE, mergePhase.inputTypes().iterator().next());
176         assertEquals(DataTypes.LONG, mergePhase.outputTypes().get(0));
177     }
178     @Test
179     public void testShardSelectWithOrderBy() throws Exception {
180         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
181             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
182             .build();
183         Merge merge = e.plan("select id from sys.shards order by id limit 10");
184         Collect collect = (Collect) merge.subPlan();
185         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) collect.collectPhase());
186         assertEquals(DataTypes.INTEGER, collectPhase.outputTypes().get(0));
187         assertThat(collectPhase.maxRowGranularity(), is(RowGranularity.SHARD));
188 <a name="3"></a>
189         assertThat(collectPhase.orderBy(), notNullValue());
190         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>List&lt;Projection&gt; projections = collectPhase.projections();
191         assertThat(projections, contains(
192             instanceOf(TopNProjection.class)
193         ));
194     }
195     @Test
196     public void testCollectAndMergePlan() throws Exception {
197         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom</b></font>(), List.of())
198             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
199             .build();
200         QueryThenFetch qtf = e.plan("select name from users where name = 'x' order by id limit 10");
201         Merge merge = (Merge) qtf.subPlan();
202         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) ((Collect) merge.subPlan()).collectPhase());
203         assertThat(collectPhase.where().toString(), is("(name = 'x')"));
204         TopNProjection topNProjection = (TopNProjection) collectPhase.projections().get(0);
205         assertThat(topNProjection.limit(), is(10));
206         MergePhase mergePhase = merge.mergePhase();
207         assertThat(mergePhase.outputTypes().size(), is(1));
208         assertEquals(DataTypes.STRING, mergePhase.outputTypes().get(0));
209     }
210     @Test
211     public void testCollectAndMergePlanNoFetch() throws Exception {
212         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
213             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
214             .build();
215         Merge merge = e.plan("select name from users where name = 'x' order by name limit 10");
216         Collect collect = (Collect) merge.subPlan();
217         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) collect.collectPhase());
218         assertThat(collectPhase.where().toString(), is("(name = 'x')"));
219         MergePhase mergePhase = merge.mergePhase();
220         assertThat(mergePhase.outputTypes().size(), is(1));
221         assertEquals(DataTypes.STRING, mergePhase.outputTypes().get(0));
222         assertTrue(mergePhase.finalProjection().isPresent());
223         Projection lastProjection = mergePhase.finalProjection().get();
224         assertThat(lastProjection, instanceOf(TopNProjection.class));
225         TopNProjection topNProjection = (TopNProjection) lastProjection;
226         assertThat(topNProjection.outputs().size(), is(1));
227     }
228     @Test
229     public void testCollectAndMergePlanHighLimit() throws Exception {
230         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
231             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
232             .build();
233         QueryThenFetch qtf = e.plan("select name from users limit 100000");
234         Merge merge = (Merge) qtf.subPlan();
235         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) ((Collect) merge.subPlan()).collectPhase());
236         assertThat(collectPhase.nodePageSizeHint(), is(100_000));
237         MergePhase mergePhase = merge.mergePhase();
238         assertThat(mergePhase.projections().size(), is(2));
239         TopNProjection topN = (TopNProjection) mergePhase.projections().get(0);
240         assertThat(topN.limit(), is(100_000));
241         assertThat(topN.offset(), is(0));
242         qtf = e.plan("select name from users limit 100000 offset 20");
243         merge = ((Merge) qtf.subPlan());
244         collectPhase = ((RoutedCollectPhase) ((Collect) merge.subPlan()).collectPhase());
245         assertThat(collectPhase.nodePageSizeHint(), is(100_000 + 20));
246         mergePhase = merge.mergePhase();
247         assertThat(mergePhase.projections().size(), is(2));
248         topN = (TopNProjection) mergePhase.projections().get(0);
249         assertThat(topN.limit(), is(100_000));
250         assertThat(topN.offset(), is(20));
251     }
252     @Test
253     public void testCollectAndMergePlanPartitioned() throws Exception {
254         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
255             .addPartitionedTable(
256                 TableDefinitions.PARTED_PKS_TABLE_DEFINITION,
257                 new PartitionName(new RelationName("doc", "parted_pks"), singletonList("1395874800000")).asIndexName(),
258                 new PartitionName(new RelationName("doc", "parted_pks"), singletonList("1395961200000")).asIndexName()
259             )
260             .build();
261         QueryThenFetch qtf = e.plan("select id, name, date from parted_pks where date &gt; 0 and name = 'x' order by id limit 10");
262         Merge merge = (Merge) qtf.subPlan();
263         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) ((Collect) merge.subPlan()).collectPhase());
264         Set&lt;String&gt; indices = new HashSet&lt;&gt;();
265         Map&lt;String, Map&lt;String, IntIndexedContainer&gt;&gt; locations = collectPhase.routing().locations();
266         for (Map.Entry&lt;String, Map&lt;String, IntIndexedContainer&gt;&gt; entry : locations.entrySet()) {
267             indices.addAll(entry.getValue().keySet());
268         }
269         assertThat(indices, Matchers.containsInAnyOrder(
270             new PartitionName(new RelationName("doc", "parted_pks"), Arrays.asList("1395874800000")).asIndexName(),
271             new PartitionName(new RelationName("doc", "parted_pks"), Arrays.asList("1395961200000")).asIndexName()));
272         assertThat(collectPhase.where().toString(), is("(name = 'x')"));
273         MergePhase mergePhase = merge.mergePhase();
274         assertThat(mergePhase.outputTypes().size(), is(3));
275     }
276     @Test
277     public void testCollectAndMergePlanFunction() throws Exception {
278         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
279             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
280             .build();
281         QueryThenFetch qtf = e.plan("select format('Hi, my name is %s', name), name from users where name = 'x' order by id limit 10");
282         Merge merge = (Merge) qtf.subPlan();
283         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) ((Collect) merge.subPlan()).collectPhase());
284         assertThat(collectPhase.where().toString(), is("(name = 'x')"));
285         MergePhase mergePhase = merge.mergePhase();
286         assertThat(mergePhase.outputTypes().size(), is(2));
287         assertEquals(DataTypes.STRING, mergePhase.outputTypes().get(0));
288         assertEquals(DataTypes.STRING, mergePhase.outputTypes().get(1));
289     }
290     @Test
291     public void testCountDistinctPlan() throws Exception {
292         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
293             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
294             .build();
295         Merge globalAggregate = e.plan("select count(distinct name) from users");
296         Collect collect = (Collect) globalAggregate.subPlan();
297         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) collect.collectPhase());
298         Projection projection = collectPhase.projections().get(0);
299         assertThat(projection, instanceOf(AggregationProjection.class));
300         AggregationProjection aggregationProjection = (AggregationProjection) projection;
301         assertThat(aggregationProjection.aggregations().size(), is(1));
302         assertThat(aggregationProjection.mode(), is(AggregateMode.ITER_PARTIAL));
303         Aggregation aggregation = aggregationProjection.aggregations().get(0);
304         Symbol aggregationInput = aggregation.inputs().get(0);
305         assertThat(aggregationInput.symbolType(), is(SymbolType.INPUT_COLUMN));
306         assertThat(collectPhase.toCollect().get(0), instanceOf(Reference.class));
307         assertThat(((Reference) collectPhase.toCollect().get(0)).column().name(), is("name"));
308         MergePhase mergePhase = globalAggregate.mergePhase();
309         assertThat(mergePhase.projections().size(), is(2));
310         Projection projection1 = mergePhase.projections().get(1);
311         assertThat(projection1, instanceOf(EvalProjection.class));
312         Symbol collection_count = projection1.outputs().get(0);
313         assertThat(collection_count, instanceOf(Function.class));
314     }
315     @Test
316     public void testGlobalAggregationHaving() throws Exception {
317         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
318             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
319             .build();
320         Merge globalAggregate = e.plan(
321             "select avg(date) from users having min(date) &gt; '1970-01-01'");
322         Collect collect = (Collect) globalAggregate.subPlan();
323         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) collect.collectPhase());
324         assertThat(collectPhase.projections().size(), is(1));
325         assertThat(collectPhase.projections().get(0), instanceOf(AggregationProjection.class));
326         MergePhase localMergeNode = globalAggregate.mergePhase();
327         assertThat(localMergeNode.projections(), contains(
328             instanceOf(AggregationProjection.class),
329             instanceOf(FilterProjection.class),
330             instanceOf(EvalProjection.class)));
331         AggregationProjection aggregationProjection = (AggregationProjection) localMergeNode.projections().get(0);
332         assertThat(aggregationProjection.aggregations().size(), is(2));
333         FilterProjection filterProjection = (FilterProjection) localMergeNode.projections().get(1);
334         assertThat(filterProjection.outputs().size(), is(2));
335         assertThat(filterProjection.outputs().get(0), instanceOf(InputColumn.class));
336         InputColumn inputColumn = (InputColumn) filterProjection.outputs().get(0);
337         assertThat(inputColumn.index(), is(0));
338         EvalProjection evalProjection = (EvalProjection) localMergeNode.projections().get(2);
339         assertThat(evalProjection.outputs().size(), is(1));
340     }
341     @Test
342     public void testCountOnPartitionedTable() throws Exception {
343         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
344             .addPartitionedTable(
345                 "create table parted (" +
346                 "   id int," +
347                 "   name string," +
348                 "   date timestamp without time zone," +
349                 "   obj object" +
350                 ") partitioned by (date) clustered into 1 shards ",
351                 new PartitionName(new RelationName("doc", "parted"), singletonList("1395874800000")).asIndexName(),
352                 new PartitionName(new RelationName("doc", "parted"), singletonList("1395961200000")).asIndexName(),
353                 new PartitionName(new RelationName("doc", "parted"), singletonList(null)).asIndexName()
354             )
355             .build();
356         CountPlan plan = e.plan("select count(*) from parted where date = 1395874800000");
357         assertThat(
358             plan.countPhase().routing().locations().entrySet().stream()
359                 .flatMap(x -&gt; x.getValue().keySet().stream())
360                 .collect(Collectors.toSet()),
361             Matchers.contains(
362                 is(".partitioned.parted.04732cpp6ks3ed1o60o30c1g")
363             )
364         );
365     }
366     @Test(expected = UnsupportedOperationException.class)
367     public void testSelectPartitionedTableOrderByPartitionedColumnInFunction() throws Exception {
368         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
369             .addPartitionedTable(
370                 "create table parted (" +
371                 "   id int," +
372                 "   name string," +
373                 "   date timestamp without time zone," +
374                 "   obj object" +
375                 ") partitioned by (date) clustered into 1 shards ",
376                 new PartitionName(new RelationName("doc", "parted"), singletonList("1395874800000")).asIndexName(),
377                 new PartitionName(new RelationName("doc", "parted"), singletonList("1395961200000")).asIndexName(),
378                 new PartitionName(new RelationName("doc", "parted"), singletonList(null)).asIndexName()
379             )
380             .build();
381         e.plan("select name from parted order by year(date)");
382     }
383     @Test(expected = UnsupportedFeatureException.class)
384     public void testQueryRequiresScalar() throws Exception {
385         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
386             .build();
387         e.plan("select * from sys.shards where match(table_name, 'characters')");
388     }
389     @Test
390     public void testSortOnUnknownColumn() throws Exception {
391         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
392             .addTable(TableDefinitions.IGNORED_NESTED_TABLE_DEFINITION)
393             .build();
394         expectedException.expect(UnsupportedOperationException.class);
395         expectedException.expectMessage("Cannot ORDER BY 'details['unknown_column']': invalid data type 'undefined'.");
396         e.plan("select details from ignored_nested order by details['unknown_column']");
397     }
398     @Test
399     public void testSelectAnalyzedReferenceInFunctionAggregation() throws Exception {
400         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
401             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
402             .build();
403         expectedException.expect(IllegalArgumentException.class);
404         expectedException.expectMessage("Cannot select analyzed column 'text' within grouping or aggregations");
405         e.plan("select min(substr(text, 0, 2)) from users");
406     }
407     @Test
408     public void testGlobalAggregateWithWhereOnPartitionColumn() throws Exception {
409         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
410             .addPartitionedTable(
411                 "create table parted (" +
412                 "   id int," +
413                 "   name string," +
414                 "   date timestamp without time zone," +
415                 "   obj object" +
416                 ") partitioned by (date) clustered into 1 shards ",
417                 new PartitionName(new RelationName("doc", "parted"), singletonList("1395874800000")).asIndexName(),
418                 new PartitionName(new RelationName("doc", "parted"), singletonList("1395961200000")).asIndexName(),
419                 new PartitionName(new RelationName("doc", "parted"), singletonList(null)).asIndexName()
420             )
421             .build();
422         ExecutionPlan plan = e.plan(
423             "select min(name) from parted where date &gt;= 1395961200000");
424         Collect collect;
425         if (plan instanceof Merge) {
426             collect = ((Collect) ((Merge) plan).subPlan());
427         } else {
428             collect = (Collect) plan;
429         }
430         Routing routing = ((RoutedCollectPhase) collect.collectPhase()).routing();
431         assertThat(
432             routing.locations().values()
433                 .stream()
434                 .flatMap(shardsByIndex -&gt; shardsByIndex.keySet().stream())
435                 .collect(Collectors.toSet()),
436             contains(
437                 is(".partitioned.parted.04732cpp6ksjcc9i60o30c1g")
438             ));
439     }
440 <a name="0"></a>
441     @Test
442     public void testHasNoResultFromHaving() throws Exception {
443         SQLExecutor e = <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
444             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
445             .build();
446         Merge merge = e.plan("select min(name) from users having 1 = 2");
447         assertThat(merge.mergePhase().projections().get(1), instanceOf(FilterProjection.class));
448         assertThat(((FilterProjection) merge.mergePhase().projections().get(1)).query(), isSQL("false"));
449     }
450     @Test
451     public void testShardQueueSizeCalculation() throws Exception {
452         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom</b></font>(), List.of())
453             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
454             .build();
455         Merge merge = e.plan("select name from users order by name limit 500");
456         Collect collect = (Collect) merge.subPlan();
457         int shardQueueSize = ((RoutedCollectPhase) collect.collectPhase()).shardQueueSize(
458             collect.collectPhase().nodeIds().iterator().next());
459         assertThat(shardQueueSize, is(375));
460     }
461     @Test
462     public void testQAFPagingIsEnabledOnHighLimit() throws Exception {
463         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
464             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
465             .build();
466         Merge plan = e.plan("select name from users order by name limit 1000000");
467         assertThat(plan.mergePhase().nodeIds().size(), is(1)); 
468         Collect collect = (Collect) plan.subPlan();
469         assertThat(((RoutedCollectPhase) collect.collectPhase()).nodePageSizeHint(), is(750000));
470     }
471     @Test
472     public void testQAFPagingIsEnabledOnHighOffset() throws Exception {
473         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
474             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
475             .build();
476         Merge merge = e.plan("select name from users order by name limit 10 offset 1000000");
477         Collect collect = (Collect) merge.subPlan();
478         assertThat(merge.mergePhase().nodeIds().size(), is(1));         assertThat(((RoutedCollectPhase) collect.collectPhase()).nodePageSizeHint(), is(750007));
479     }
480     @Test
481     public void testQTFPagingIsEnabledOnHighLimit() throws Exception {
482         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
483             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
484             .build();
485         QueryThenFetch qtf = e.plan("select name, date from users order by name limit 1000000");
486         Merge merge = (Merge) qtf.subPlan();
487         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) ((Collect) merge.subPlan()).collectPhase());
488         assertThat(merge.mergePhase().nodeIds().size(), is(1));         assertThat(collectPhase.nodePageSizeHint(), is(750000));
489     }
490     @Test
491     public void testSelectFromUnnestResultsInTableFunctionPlan() throws Exception {
492         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
493             .build();
494         Collect collect = e.plan("select * from unnest([1, 2], ['Arthur', 'Trillian'])");
495         assertNotNull(collect);
496         assertThat(collect.collectPhase().toCollect(), contains(isReference("col1"), isReference("col2")));
497     }
498     @Test
499     public void testReferenceToNestedAggregatedField() throws Exception {
500         SQLExecutor e = SQLExecutor.builder(clusterService)
501             .addTable(T3.T1_DEFINITION)
502             .build();
503         Collect collect = e.plan("select ii, xx from ( " +
504                                  "  select i + i as ii, xx from (" +
505                                  "    select i, sum(x) as xx from t1 group by i) as t) as tt " +
506                                  "where (ii * 2) &gt; 4 and (xx * 2) &gt; 120");
507         assertThat("would require merge with more than 1 nodeIds", collect.nodeIds().size(), is(1));
508         List&lt;Projection&gt; projections = collect.collectPhase().projections();
509         assertThat(projections, contains(
510             instanceOf(GroupProjection.class),             instanceOf(GroupProjection.class),             instanceOf(EvalProjection.class),
511             instanceOf(FilterProjection.class),
512             instanceOf(EvalProjection.class)
513         ));
514     }
515     @Test
516     public void test3TableJoinQuerySplitting() throws Exception {
517         TableStats tableStats = new TableStats();
518         tableStats.updateTableStats(
519             Map.of(new RelationName("doc", "users"), new Stats(20, 20, Map.of())));
520         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
521             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
522             .setTableStats(tableStats)
523             .build();
524         Join outerNl = e.plan("select" +
525                                     "  u1.id as u1, " +
526                                     "  u2.id as u2, " +
527                                     "  u3.id as u3 " +
528                                     "from " +
529                                     "  users u1," +
530                                     "  users u2," +
531                                     "  users u3 " +
532                                     "where " +
533                                     "  u1.name = 'Arthur'" +
534                                     "  and u2.id = u1.id" +
535                                     "  and u2.name = u1.name");
536         Join innerNl = (Join) outerNl.left();
537         assertThat(innerNl.joinPhase().joinCondition(), isSQL("((INPUT(0) = INPUT(2)) AND (INPUT(1) = INPUT(3)))"));
538         assertThat(innerNl.joinPhase().projections().size(), is(1));
539         assertThat(innerNl.joinPhase().projections().get(0), instanceOf(EvalProjection.class));
540         assertThat(outerNl.joinPhase().joinCondition(), nullValue());
541         assertThat(outerNl.joinPhase().projections().size(), is(2));
542         assertThat(outerNl.joinPhase().projections(), contains(
543             instanceOf(EvalProjection.class),
544             instanceOf(EvalProjection.class)
545         ));
546     }
547     @Test
548     public void testOuterJoinToInnerJoinRewrite() throws Exception {
549         TableStats tableStats = new TableStats();
550         tableStats.updateTableStats(
551             Map.of(new RelationName("doc", "users"), new Stats(20, 20, Map.of())));
552         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
553             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
554             .setTableStats(tableStats)
555             .build();
556         e.getSessionContext().setHashJoinEnabled(false);
557         Merge merge = e.plan("select u1.text, concat(u2.text, '_foo') " +
558                                     "from users u1 left join users u2 on u1.id = u2.id " +
559                                     "where u2.name = 'Arthur'" +
560                                     "and u2.id &gt; 1 ");
561         Join nl = (Join) merge.subPlan();
562         assertThat(nl.joinPhase().joinType(), is(JoinType.INNER));
563         Collect rightCM = (Collect) nl.right();
564         assertThat(((RoutedCollectPhase) rightCM.collectPhase()).where(),
565             isSQL("((doc.users.name = 'Arthur') AND (doc.users.id &gt; 1::bigint))"));
566     }
567     @Test
568     public void testShardSelect() throws Exception {
569         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
570             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
571             .build();
572         Merge merge = e.plan("select id from sys.shards");
573         Collect collect = (Collect) merge.subPlan();
574         RoutedCollectPhase collectPhase = ((RoutedCollectPhase) collect.collectPhase());
575         assertThat(collectPhase.maxRowGranularity(), is(RowGranularity.SHARD));
576     }
577     @Test
578     public void testGlobalCountPlan() throws Exception {
579         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
580             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
581             .build();
582         CountPlan plan = e.plan("select count(*) from users");
583         assertThat(plan.countPhase().where(), equalTo(Literal.BOOLEAN_TRUE));
584         assertThat(plan.mergePhase().projections().size(), is(1));
585         assertThat(plan.mergePhase().projections().get(0), instanceOf(MergeCountProjection.class));
586     }
587     @Test
588     public void testLimitThatIsBiggerThanPageSizeCausesQTFPUshPlan() throws Exception {
589         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
590             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
591             .build();
592         QueryThenFetch qtf = e.plan("select * from users limit 2147483647 ");
593         Merge merge = (Merge) qtf.subPlan();
594         assertThat(merge.mergePhase().nodeIds().size(), is(1));
595         String localNodeId = merge.mergePhase().nodeIds().iterator().next();
596         NodeOperationTree operationTree = NodeOperationTreeGenerator.fromPlan(merge, localNodeId);
597         NodeOperation nodeOperation = operationTree.nodeOperations().iterator().next();
598         assertThat(nodeOperation.downstreamNodes(), not(contains(ExecutionPhase.DIRECT_RESPONSE)));
599         qtf = e.plan("select * from users limit 2");
600         merge = (Merge) qtf.subPlan();
601         localNodeId = merge.subPlan().resultDescription().nodeIds().iterator().next();
602         operationTree = NodeOperationTreeGenerator.fromPlan(merge, localNodeId);
603         nodeOperation = operationTree.nodeOperations().iterator().next();
604         assertThat(nodeOperation.downstreamNodes(), contains(ExecutionPhase.DIRECT_RESPONSE));
605     }
606     @Test
607     public void testAggregationOnGeneratedColumns() throws Exception {
608         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
609             .addTable(
610                 "create table doc.gc_table (" +
611                 "   revenue integer," +
612                 "   cost integer," +
613                 "   profit as revenue - cost" +
614                 ")"
615             ).build();
616         Merge merge = e.plan("select sum(profit) from gc_table");
617         Collect collect = (Collect) merge.subPlan();
618         List&lt;Projection&gt; projections = collect.collectPhase().projections();
619         assertThat(projections, contains(
620             instanceOf(AggregationProjection.class)         ));
621         assertThat(
622             merge.mergePhase().projections(),
623             contains(instanceOf(AggregationProjection.class))
624         );
625         assertThat(
626             ((AggregationProjection)projections.get(0)).aggregations().get(0).inputs().get(0),
627             isSQL("INPUT(0)"));
628     }
629     @Test
630     public void testGlobalAggregationOn3TableJoinWithImplicitJoinConditions() throws Exception {
631         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
632             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
633             .build();
634         Merge plan = e.plan("select count(*) from users t1, users t2, users t3 " +
635                             "where t1.id = t2.id and t2.id = t3.id");
636         assertThat(plan.subPlan(), instanceOf(Join.class));
637         Join outerNL = (Join)plan.subPlan();
638         assertThat(outerNL.joinPhase().joinCondition(), isSQL("(INPUT(1) = INPUT(2))"));
639         assertThat(outerNL.joinPhase().projections().size(), is(2));
640         assertThat(outerNL.joinPhase().projections().get(0), instanceOf(EvalProjection.class));
641         assertThat(outerNL.joinPhase().projections().get(1), instanceOf(AggregationProjection.class));
642         assertThat(outerNL.joinPhase().outputTypes().size(), is(1));
643         assertThat(outerNL.joinPhase().outputTypes().get(0), is(CountAggregation.LongStateType.INSTANCE));
644         Join innerNL = (Join) outerNL.left();
645         assertThat(innerNL.joinPhase().joinCondition(), isSQL("(INPUT(0) = INPUT(1))"));
646         assertThat(innerNL.joinPhase().projections().size(), is(1));
647         assertThat(innerNL.joinPhase().projections().get(0), instanceOf(EvalProjection.class));
648         assertThat(innerNL.joinPhase().outputTypes().size(), is(2));
649         assertThat(innerNL.joinPhase().outputTypes().get(0), is(DataTypes.LONG));
650         plan = e.plan("select count(t1.other_id) from users t1, users t2, users t3 " +
651                       "where t1.id = t2.id and t2.id = t3.id");
652         assertThat(plan.subPlan(), instanceOf(Join.class));
653         outerNL = (Join)plan.subPlan();
654         assertThat(outerNL.joinPhase().joinCondition(), isSQL("(INPUT(2) = INPUT(3))"));
655         assertThat(outerNL.joinPhase().projections().size(), is(2));
656         assertThat(outerNL.joinPhase().projections().get(0), instanceOf(EvalProjection.class));
657         assertThat(outerNL.joinPhase().projections().get(1), instanceOf(AggregationProjection.class));
658         assertThat(outerNL.joinPhase().outputTypes().size(), is(1));
659         assertThat(outerNL.joinPhase().outputTypes().get(0), is(CountAggregation.LongStateType.INSTANCE));
660         innerNL = (Join) outerNL.left();
661         assertThat(innerNL.joinPhase().joinCondition(), isSQL("(INPUT(1) = INPUT(2))"));
662         assertThat(innerNL.joinPhase().projections().size(), is(1));
663         assertThat(innerNL.joinPhase().projections().get(0), instanceOf(EvalProjection.class));
664         assertThat(innerNL.joinPhase().outputTypes().size(), is(3));
665         assertThat(innerNL.joinPhase().outputTypes().get(0), is(DataTypes.LONG));
666         assertThat(innerNL.joinPhase().outputTypes().get(1), is(DataTypes.LONG));
667     }
668     @Test
669     public void test2TableJoinWithNoMatch() throws Exception {
670         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
671             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
672             .build();
673         Join nl = e.plan("select * from users t1, users t2 WHERE 1=2");
674         assertThat(nl.left(), instanceOf(Collect.class));
675         assertThat(nl.right(), instanceOf(Collect.class));
676         assertThat(((RoutedCollectPhase)((Collect)nl.left()).collectPhase()).where(), isSQL("false"));
677         assertThat(((RoutedCollectPhase)((Collect)nl.right()).collectPhase()).where(), isSQL("false"));
678     }
679     @Test
680     public void test3TableJoinWithNoMatch() throws Exception {
681         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
682             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
683             .build();
684         Join outer = e.plan("select * from users t1, users t2, users t3 WHERE 1=2");
685         assertThat(((RoutedCollectPhase)((Collect)outer.right()).collectPhase()).where(), isSQL("false"));
686         Join inner = (Join) outer.left();
687         assertThat(((RoutedCollectPhase)((Collect)inner.left()).collectPhase()).where(), isLiteral(false));
688         assertThat(((RoutedCollectPhase)((Collect)inner.right()).collectPhase()).where(), isLiteral(false));
689     }
690     @Test
691     public void testGlobalAggregateOn2TableJoinWithNoMatch() throws Exception {
692         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
693             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
694             .build();
695         Join nl = e.plan("select count(*) from users t1, users t2 WHERE 1=2");
696         assertThat(nl.left(), instanceOf(Collect.class));
697         assertThat(nl.right(), instanceOf(Collect.class));
698         assertThat(((RoutedCollectPhase)((Collect)nl.left()).collectPhase()).where(), isLiteral(false));
699         assertThat(((RoutedCollectPhase)((Collect)nl.right()).collectPhase()).where(), isLiteral(false));
700     }
701     @Test
702     public void testGlobalAggregateOn3TableJoinWithNoMatch() throws Exception {
703         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
704             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
705             .build();
706         Join outer = e.plan("select count(*) from users t1, users t2, users t3 WHERE 1=2");
707         Join inner = (Join) outer.left();
708         assertThat(((RoutedCollectPhase)((Collect)outer.right()).collectPhase()).where(), isLiteral(false));
709         assertThat(((RoutedCollectPhase)((Collect)inner.left()).collectPhase()).where(), isLiteral(false));
710         assertThat(((RoutedCollectPhase)((Collect)inner.right()).collectPhase()).where(), isLiteral(false));
711     }
712     @Test
713     public void testFilterOnPKSubsetResultsInPKLookupPlanIfTheOtherPKPartIsGenerated() throws Exception {
714         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
715             .addTable(
716                 "create table t_pk_part_generated (" +
717                 "   ts timestamp with time zone," +
718                 "   p as date_trunc('day', ts)," +
719                 "   primary key (ts, p))")
720             .build();
721         LogicalPlan plan = e.logicalPlan("select 1 from t_pk_part_generated where ts = 0");
722         assertThat(plan, isPlan(
723             "Get[doc.t_pk_part_generated | 1 | DocKeys{0::bigint, 0::bigint} | ((ts = 0::bigint) AND (p AS date_trunc('day', ts) = 0::bigint))]"
724         ));
725     }
726     @Test
727     public void testInnerJoinResultsInHashJoinIfHashJoinIsEnabled() throws Exception {
728         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
729             .addTable(T3.T1_DEFINITION)
730             .addTable(T3.T2_DEFINITION)
731             .build();
732         e.getSessionContext().setHashJoinEnabled(true);
733         Merge merge = e.plan("select t2.b, t1.a from t1 inner join t2 on t1.i = t2.i order by 1, 2");
734         Join join = (Join) merge.subPlan();
735         assertThat(join.joinPhase().type(), is(ExecutionPhase.Type.HASH_JOIN));
736     }
737     @Test
738     public void testUnnestInSelectListResultsInPlanWithProjectSetOperator() throws Exception {
739         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
740             .build();
741         LogicalPlan plan = e.logicalPlan("select unnest([1, 2])");
742         assertThat(plan, isPlan(
743             "ProjectSet[unnest([1, 2])]\n" +
744             "   TableFunction[empty_row | [] | true]"));
745         Symbol output = plan.outputs().get(0);
746         assertThat(output.valueType(), is(DataTypes.INTEGER));
747     }
748     @Test
749     public void testScalarCanBeUsedAroundTableGeneratingFunctionInSelectList() {
750         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
751             .build();
752         LogicalPlan plan = e.logicalPlan("select unnest([1, 2]) + 1");
753         assertThat(plan, isPlan(
754             "Eval[(unnest([1, 2]) + 1)]\n" +
755             "   ProjectSet[unnest([1, 2])]\n" +
756             "     TableFunction[empty_row | [] | true]"));
757     }
758     @Test
759     public void testAggregationOnTopOfTableFunctionIsNotPossibleWithoutSeparateSubQuery() {
760         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
761             .build();
762         expectedException.expectMessage("Cannot use table functions inside aggregates");
763         e.logicalPlan("select sum(unnest([1, 2]))");
764     }
765     @Test
766     public void testTableFunctionIsExecutedAfterAggregation() throws Exception {
767         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
768             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
769             .build();
770         LogicalPlan plan = e.logicalPlan("select count(*), generate_series(1, 2) from users");
771         assertThat(plan, isPlan(
772             "Eval[count(*), pg_catalog.generate_series(1, 2)]\n" +
773             "   ProjectSet[pg_catalog.generate_series(1, 2), count(*)]\n" +
774             "     Count[doc.users | true]"));
775     }
776     @Test
777     public void testAggregationCanBeUsedAsArgumentToTableFunction() throws Exception {
778         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
779             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
780             .build();
781         LogicalPlan plan = e.logicalPlan("select count(name), generate_series(1, count(name)) from users");
782         assertThat(plan, isPlan(
783             "Eval[count(name), pg_catalog.generate_series(1::bigint, count(name))]\n" +
784             "   ProjectSet[pg_catalog.generate_series(1::bigint, count(name)), count(name)]\n" +
785             "     HashAggregate[count(name)]\n" +
786             "       Collect[doc.users | [name] | true]"));
787     }
788     @Test
789     public void testOrderByOnTableFunctionMustOrderAfterProjectSet() throws Exception {
790         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
791             .build();
792         LogicalPlan plan = e.logicalPlan("select unnest([1, 2]) from sys.nodes order by 1");
793         assertThat(plan, isPlan(
794             "OrderBy[unnest([1, 2]) ASC]\n" +
795             "   ProjectSet[unnest([1, 2])]\n" +
796             "     Collect[sys.nodes | [] | true]"));
797     }
798     @Test
799     public void testWindowFunctionsWithPartitionByAreExecutedDistributed() throws Exception {
800         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
801             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
802             .build();
803         Merge localMerge = e.plan("select sum(ints) OVER (partition by awesome) from users");
804         Merge distMerge = (Merge) localMerge.subPlan();
805         assertThat(distMerge.nodeIds().size(), is(2));
806         assertThat(distMerge.mergePhase().projections(), contains(
807             instanceOf(WindowAggProjection.class),
808             instanceOf(EvalProjection.class)
809         ));
810         Collect collect = (Collect) distMerge.subPlan();
811         assertThat(collect.nodeIds().size(), is(2));
812     }
813     @Test
814     public void testSeqNoAndPrimaryTermFilteringRequirePrimaryKey() throws Exception {
815         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
816             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
817             .build();
818         expectedException.expect(VersioningValidationException.class);
819         expectedException.expectMessage(VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG);
820         e.plan("select * from users where _seq_no = 2 and _primary_term = 1");
821     }
822     @Test
823     public void testTablePartitionsAreNarrowedToMatchWhereClauseOfParentQuery() throws Exception {
824         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
825             .addPartitionedTable(
826                 "create table parted (" +
827                 "   id int," +
828                 "   name string," +
829                 "   date timestamp without time zone," +
830                 "   obj object" +
831                 ") partitioned by (date) clustered into 1 shards ",
832                 new PartitionName(new RelationName("doc", "parted"), singletonList("1395874800000")).asIndexName(),
833                 new PartitionName(new RelationName("doc", "parted"), singletonList("1395961200000")).asIndexName(),
834                 new PartitionName(new RelationName("doc", "parted"), singletonList(null)).asIndexName()
835             )
836             .build();
837         String statement = "select * from (select * from parted) t where date is null";
838         LogicalPlan logicalPlan = e.logicalPlan(statement);
839         assertThat(logicalPlan, isPlan(
840             "Rename[id, name, date, obj] AS t\n" +
841             "   Collect[doc.parted | [id, name, date, obj] | (date IS NULL)]"));
842         ExecutionPlan plan = e.plan(statement);
843         Collect collect = plan instanceof Collect ? (Collect) plan : ((Collect) ((Merge) plan).subPlan());
844         RoutedCollectPhase routedCollectPhase = (RoutedCollectPhase) collect.collectPhase();
845         int numShards = 0;
846         for (String node : routedCollectPhase.routing().nodes()) {
847             numShards += routedCollectPhase.routing().numShards(node);
848         }
849         assertThat(numShards, is(1));
850     }
851     @Test
852     public void test_match_used_on_table_with_alias_is_resolved_to_a_function() throws Exception {
853         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
854             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
855             .build();
856         Merge merge = e.plan("select name from users as u where match(u.text, 'yalla') order by 1");
857         Collect collect = (Collect) merge.subPlan();
858         assertThat(((RoutedCollectPhase) collect.collectPhase()).where(), isFunction("match"));
859     }
860     @Test
861     public void test_distinct_with_limit_is_optimized_to_topn_distinct() throws Exception {
862         TableStats tableStats = new TableStats();
863         tableStats.updateTableStats(
864             Map.of(new RelationName("doc", "users"), new Stats(20, 20, Map.of())));
865         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
866             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
867             .setTableStats(tableStats)
868             .build();
869         String stmt = "select distinct name from users limit 1";
870         LogicalPlan plan = e.logicalPlan(stmt);
871         assertThat(plan, isPlan(
872             "TopNDistinct[1::bigint;0 | [name]]\n" +
873             "   Collect[doc.users | [name] | true]"));
874     }
875     @Test
876     public void test_group_by_without_aggregates_and_with_limit_is_optimized_to_topn_distinct() throws Exception {
877         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
878             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
879             .build();
880         String stmt = "select id, name from users group by id, name limit 1";
881         LogicalPlan plan = e.logicalPlan(stmt);
882         assertThat(plan, isPlan(
883             "TopNDistinct[1::bigint;0 | [id, name]]\n" +
884             "   Collect[doc.users | [id, name] | true]"));
885     }
886     @Test
887     public void test_distinct_with_limit_and_offset_keeps_offset() throws Exception {
888         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
889             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
890             .build();
891         String stmt = "select id, name from users group by id, name limit 1 offset 3";
892         LogicalPlan plan = e.logicalPlan(stmt);
893         assertThat(plan, isPlan(
894             "TopNDistinct[1::bigint;3::bigint | [id, name]]\n" +
895             "   Collect[doc.users | [id, name] | true]"));
896         Merge merge = e.plan(stmt);
897         List&lt;Projection&gt; collectProjections = ((Collect) merge.subPlan()).collectPhase().projections();;
898         assertThat(
899             collectProjections,
900             contains(
901                 instanceOf(TopNDistinctProjection.class)
902             )
903         );
904         List&lt;Projection&gt; mergeProjections = merge.mergePhase().projections();
905         assertThat(
906             mergeProjections,
907             contains(
908                 instanceOf(TopNDistinctProjection.class),
909                 instanceOf(TopNProjection.class)
910             )
911         );
912     }
913     @Test
914     public void test_group_by_on_subscript_on_obj_output_of_sub_relation() throws Exception {
915         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
916             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
917             .build();
918         String stmt = "SELECT address['postcode'] FROM (SELECT address FROM users) AS u GROUP BY 1";
919         LogicalPlan plan = e.logicalPlan(stmt);
920         assertThat(plan, isPlan(
921             "GroupHashAggregate[address['postcode']]\n" +
922             "   Rename[address] AS u\n" +
923             "     Collect[doc.users | [address] | true]"));
924     }
925     @Test
926     public void test_order_by_on_subscript_on_obj_output_of_sub_relation() throws Exception {
927         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
928             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
929             .build();
930         String stmt = "SELECT address['postcode'] FROM (SELECT address FROM users) AS u ORDER BY 1";
931         LogicalPlan plan = e.logicalPlan(stmt);
932         assertThat(plan, isPlan(
933             "Eval[address['postcode']]\n" +
934             "   OrderBy[address['postcode'] ASC]\n" +
935             "     Rename[address] AS u\n" +
936             "       Collect[doc.users | [address] | true]"));
937         Merge merge = e.plan(stmt);
938         Collect collect = (Collect) merge.subPlan();
939         RoutedCollectPhase collectPhase = (RoutedCollectPhase) collect.collectPhase();
940         assertThat(collectPhase.projections(), contains(
941             instanceOf(OrderedTopNProjection.class),
942             instanceOf(EvalProjection.class)
943         ));
944     }
945     @Test
946     public void test_join_with_no_match_where_clause_pushes_down_no_match() throws Exception {
947         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
948             .build();
949         String stmt = "SELECT n.* " +
950                       "FROM " +
951                       "   pg_catalog.pg_namespace n," +
952                       "   pg_catalog.pg_class c " +
953                       "WHERE " +
954                       "   n.nspname LIKE E'sys' " +
955                       "   AND c.relnamespace = n.oid " +
956                       "   AND (false)";
957         LogicalPlan plan = e.logicalPlan(stmt);
958         String expectedPlan =
959             "NestedLoopJoin[CROSS]\n" +
960             "   Rename[nspacl, nspname, nspowner, oid] AS n\n" +
961             "     Collect[pg_catalog.pg_namespace | [nspacl, nspname, nspowner, oid] | false]\n" +
962             "   Rename[] AS c\n" +
963             "     Collect[pg_catalog.pg_class | [] | false]";
964         assertThat(plan, isPlan(expectedPlan));
965     }
966     @Test
967     public void test_window_function_with_function_used_in_order_by_injects_eval_below_window_agg_ordering() throws Exception {
968         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
969             .build();
970         String stmt =
971             "SELECT\n" +
972             "   col1,\n" +
973             "   sum(col1) OVER(ORDER BY power(col1, 2) RANGE BETWEEN 3 PRECEDING and CURRENT ROW)\n" +
974             "FROM\n" +
975             "   unnest(ARRAY[2.5, 4, 5, 6, 7.5, 8.5, 10, 12]) as t(col1)";
976         LogicalPlan plan = e.logicalPlan(stmt);
977         String expectedPlan =
978             "Eval[col1, sum(col1) OVER (ORDER BY power(col1, 2.0) ASC RANGE BETWEEN 3 PRECEDING AND CURRENT ROW)]\n" +
979             "   WindowAgg[col1, power(col1, 2.0), sum(col1) OVER (ORDER BY power(col1, 2.0) ASC RANGE BETWEEN 3 PRECEDING AND CURRENT ROW)]\n" +
980             "     Eval[col1, power(col1, 2.0)]\n" +
981             "       Rename[col1] AS t\n" +
982             "         TableFunction[unnest | [col1] | true]";
983         assertThat(plan, isPlan(expectedPlan));
984     }
985     @Test
986     public void test_select_from_table_function_with_filter_on_not_selected_column() {
987         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
988             .build();
989         String stmt =
990             "SELECT word " +
991             "FROM pg_catalog.pg_get_keywords() " +
992             "WHERE catcode = 'R' " +
993             "ORDER BY 1";
994         LogicalPlan plan = e.logicalPlan(stmt);
995         String expectedPlan =
996             "Eval[word]\n" +
997             "   OrderBy[word ASC]\n" +
998             "     Filter[(catcode = 'R')]\n" +
999             "       TableFunction[pg_get_keywords | [word, catcode] | true]";
1000         assertThat(plan, isPlan(expectedPlan));
1001     }
1002     @Test
1003     public void test_group_by_on_pk_lookup_uses_shard_projections() throws Exception {
1004         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1005             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
1006             .build();
1007         String stmt = "SELECT name, count(*) FROM users WHERE id in (1, 2, 3, 4, 5) GROUP BY name";
1008         LogicalPlan logicalPlan = e.logicalPlan(stmt);
1009         String expectedPlan =
1010             "GroupHashAggregate[name | count(*)]\n" +
1011             "   Get[doc.users | name | DocKeys{1::bigint; 2::bigint; 3::bigint; 4::bigint; 5::bigint} | (id = ANY([1::bigint, 2::bigint, 3::bigint, 4::bigint, 5::bigint]))]";
1012         assertThat(logicalPlan, isPlan(expectedPlan));
1013         Merge coordinatorMerge = e.plan(stmt);
1014         Merge distributedMerge = (Merge) coordinatorMerge.subPlan();
1015         Collect collect = (Collect) distributedMerge.subPlan();
1016         assertThat(
1017             collect.collectPhase().projections(),
1018             contains(instanceOf(GroupProjection.class))
1019         );
1020         assertThat(collect.collectPhase().projections().get(0).requiredGranularity(), is(RowGranularity.SHARD));
1021     }
1022     @Test
1023     public void test_order_by_on_aggregation_with_alias_in_select_list() throws Exception {
1024         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1025             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
1026             .build();
1027         String stmt = "SELECT count(id) as cnt FROM users GROUP BY name ORDER BY count(id) DESC";
1028         LogicalPlan plan = e.logicalPlan(stmt);
1029         String expectedPlan =
1030             "Eval[count(id) AS cnt]\n" +
1031             "   OrderBy[count(id) DESC]\n" +
1032             "     GroupHashAggregate[name | count(id)]\n" +
1033             "       Collect[doc.users | [id, name] | true]";
1034         assertThat(plan, isPlan(expectedPlan));
1035     }
1036     @Test
1037     public void test_equi_join_with_scalar_using_parameter_placeholders() throws Exception {
1038         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1039             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
1040             .build();
1041         String stmt = "SELECT u1.name FROM users u1 JOIN users u2 ON (u1.name || ?) = u2.name";
1042         LogicalPlan plan = e.logicalPlan(stmt);
1043         String expectedPlan =
1044             "Eval[name]\n" +
1045             "   HashJoin[(name = concat(name, $1))]\n" +
1046             "     Rename[name] AS u1\n" +
1047             "       Collect[doc.users | [name] | true]\n" +
1048             "     Rename[name] AS u2\n" +
1049             "       Collect[doc.users | [name] | true]";
1050         assertThat(plan, isPlan(expectedPlan));
1051         e.plan(stmt, UUID.randomUUID(), 0, new RowN("foo"));
1052     }
1053     @Test
1054     public void test_non_euqi_join_with_scalar_using_parameter_placeholders() throws Exception {
1055         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1056             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
1057             .build();
1058         String stmt = "SELECT u1.name FROM users u1 JOIN users u2 ON (u1.name || ?) != u2.name";
1059         LogicalPlan plan = e.logicalPlan(stmt);
1060         String expectedPlan =
1061             "Eval[name]\n" +
1062             "   NestedLoopJoin[INNER | (NOT (name = concat(name, $1)))]\n" +
1063             "     Rename[name] AS u1\n" +
1064             "       Collect[doc.users | [name] | true]\n" +
1065             "     Rename[name] AS u2\n" +
1066             "       Collect[doc.users | [name] | true]";
1067         assertThat(plan, isPlan(expectedPlan));
1068         e.plan(stmt, UUID.randomUUID(), 0, new RowN("foo"));
1069     }
1070     @Test
1071     public void test_columns_used_in_hash_join_condition_are_not_duplicated_in_outputs() throws Exception {
1072         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1073             .addTable(T3.T1_DEFINITION)
1074             .addTable(T3.T2_DEFINITION)
1075             .build();
1076         String stmt =
1077             "SELECT * FROM " +
1078             "   (SELECT a FROM (SELECT * FROM t1) a1) v1 " +
1079             "   JOIN " +
1080             "   (SELECT b FROM (SELECT * FROM t2) a2) v2 " +
1081             "   ON (v1.a = v2.b) ";
1082         LogicalPlan plan = e.logicalPlan(stmt);
1083         String expectedPlan =
1084             "HashJoin[(a = b)]\n" +
1085             "   Rename[a] AS v1\n" +
1086             "     Eval[a]\n" +
1087             "       Rename[a] AS a1\n" +
1088             "         Collect[doc.t1 | [a] | true]\n" +
1089             "   Rename[b] AS v2\n" +
1090             "     Eval[b]\n" +
1091             "       Rename[b] AS a2\n" +
1092             "         Collect[doc.t2 | [b] | true]";
1093         assertThat(plan, isPlan(expectedPlan));
1094     }
1095     @Test
1096     public void test_columns_used_in_nl_join_condition_are_not_duplicated_in_outputs() throws Exception {
1097         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1098             .addTable(T3.T1_DEFINITION)
1099             .addTable(T3.T2_DEFINITION)
1100             .build();
1101         String stmt =
1102             "SELECT * FROM " +
1103             "   (SELECT a FROM (SELECT * FROM t1) a1) v1 " +
1104             "   JOIN " +
1105             "   (SELECT b FROM (SELECT * FROM t2) a2) v2 " +
1106             "   ON (v1.a &gt; v2.b) ";
1107         LogicalPlan plan = e.logicalPlan(stmt);
1108         String expectedPlan =
1109             "NestedLoopJoin[INNER | (a &gt; b)]\n" +
1110             "   Rename[a] AS v1\n" +
1111             "     Eval[a]\n" +
1112             "       Rename[a] AS a1\n" +
1113             "         Collect[doc.t1 | [a] | true]\n" +
1114             "   Rename[b] AS v2\n" +
1115             "     Eval[b]\n" +
1116             "       Rename[b] AS a2\n" +
1117             "         Collect[doc.t2 | [b] | true]";
1118         assertThat(plan, isPlan(expectedPlan));
1119     }
1120     @Test
1121     public void test_collect_execution_plan_is_narrowed_to_matching_generated_partition_columns() throws Exception {
1122         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1123             .addPartitionedTable(
1124                 "create table doc.parted_by_generated (" +
1125                 "   ts timestamp without time zone, " +
1126                 "   p as date_trunc('month', ts) " +
1127                 ") partitioned by (p)",
1128                 new PartitionName(new RelationName("doc", "parted_by_generated"), singletonList("1577836800000")).asIndexName(),
1129                 new PartitionName(new RelationName("doc", "parted_by_generated"), singletonList("1580515200000")).asIndexName())
1130             .build();
1131         String stmt = "SELECT * FROM parted_by_generated WHERE ts &gt;= '2020-02-01'";
1132         LogicalPlan plan = e.logicalPlan(stmt);
1133         String expectedPlan =
1134             "Collect[doc.parted_by_generated | [ts, p AS date_trunc('month', ts)] | (ts &gt;= 1580515200000::bigint)]";
1135         assertThat(plan, isPlan(expectedPlan));
1136         Collect collect = (Collect) ((Merge) e.plan(stmt)).subPlan();;
1137         RoutedCollectPhase routedCollectPhase = (RoutedCollectPhase) collect.collectPhase();
1138         Symbol where = routedCollectPhase.where();
1139 <a name="1"></a>        assertThat(where, TestingHelpers.isSQL("(doc.parted_by_generated.ts &gt;= 1580515200000::bigint)"));
1140         assertThat(routedCollectPhase.routing().locations().values().stream()
1141             .flatMap(x -&gt; x.keySet().stream())
1142             .collect(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Collectors.toSet()),
1143             contains(
1144                 ".partitioned.parted_by_generated.04732d9o60qj2d9i60o30c1g"
1145             )
1146         );
1147     }
1148     @Test
1149     public void test_select_where_id_and_seq_missing_primary_term() throws Exception {
1150         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1151             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
1152             .build();
1153         assertThrowsMatches(
1154             () -&gt; e.plan("select id from users where id = 1 and _seq_no = 11"),
1155             VersioningValidationException.class,
1156             VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG
1157         );
1158     }
1159     @Test
1160     public void test_select_where_seq_and_primary_term_missing_id() throws Exception {
1161         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1162             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
1163             .build();
1164         assertThrowsMatches</b></font>(
1165             () -&gt; e.plan("select id from users where _seq_no = 11 and _primary_term = 1"),
1166             VersioningValidationException.class,
1167             VersioningValidationException.SEQ_NO_AND_PRIMARY_TERM_USAGE_MSG
1168         );
1169     }
1170     @Test
1171     public void test_filter_and_eval_on_get_operator_use_shard_projections() throws Exception {
1172         SQLExecutor e = SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom(), List.of())
1173             .addTable(TableDefinitions.USER_TABLE_DEFINITION)
1174             .build();
1175         Merge merge = e.plan("""
1176             SELECT count(*) FROM (
1177                 SELECT
1178                     name
1179                 FROM
1180                     users
1181                 WHERE
1182                     id = 10 AND (name = 'bar' or name IS NULL)
1183                 ) u
1184         """);
1185         Collect collect = (Collect) merge.subPlan();
1186         var pkLookup = (PKLookupPhase) collect.collectPhase();
1187         assertThat(pkLookup.projections(), Matchers.contains(
1188             Matchers.instanceOf(FilterProjection.class),
1189             Matchers.instanceOf(EvalProjection.class),
1190             Matchers.instanceOf(AggregationProjection.class)
1191         ));
1192         for (var projection : pkLookup.projections()) {
1193             assertThat(projection.requiredGranularity(), is(RowGranularity.SHARD));
1194         }
1195     }
1196     @Test
1197     public void test_queries_in_count_operator_are_optimized() throws Exception {
1198         SQLExecutor e = SQLExecutor.builder(clusterService)
1199             .addTable("create table tbl (xs array(varchar(1)))")
1200             .build();
1201         CountPlan plan = e.plan("select count(*) from tbl where 'a' = ANY(xs)");
1202         assertThat(plan.countPhase().where(), isSQL("(_cast('a', 'text(1)') = ANY(doc.tbl.xs))"));
1203     }
1204     @Test
1205     public void test_collect_phase_narrows_shard_selection_based_on_clustered_by_columns() throws Exception {
1206         SQLExecutor e = SQLExecutor.builder(clusterService)
1207             .addTable("create table tbl (x int, y int) clustered by (x) into 2 shards")
1208             .build();
1209         Collect collect = e.plan("select * from tbl where x = 1");
1210         RoutedCollectPhase routedCollectPhase = (RoutedCollectPhase )collect.collectPhase();
1211         int numShards = routedCollectPhase.routing().locations().values().stream()
1212             .flatMap(x -&gt; x.values().stream())
1213             .mapToInt(x -&gt; x.size())
1214             .sum();
1215         assertThat(numShards, is(1));
1216     }
1217 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
