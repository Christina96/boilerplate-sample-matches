
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-BuilderFactory.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import java.io.Serializable;
3  import java.util.*;
4  import java.util.stream.Collectors;
5  import redis.clients.jedis.exceptions.JedisDataException;
6  import redis.clients.jedis.resps.*;
7  import redis.clients.jedis.resps.LCSMatchResult.MatchedPosition;
8  import redis.clients.jedis.resps.LCSMatchResult.Position;
9  import redis.clients.jedis.util.DoublePrecision;
10  import redis.clients.jedis.util.JedisByteHashMap;
11  import redis.clients.jedis.util.KeyValue;
12  import redis.clients.jedis.util.SafeEncoder;
13  public final class BuilderFactory {
14    public static final Builder&lt;Object&gt; RAW_OBJECT = new Builder&lt;Object&gt;() {
15      @Override
16      public Object build(Object data) {
17        return data;
18      }
19      @Override
20      public String toString() {
21        return &quot;Object&quot;;
22      }
23    };
24    public static final Builder&lt;List&lt;Object&gt;&gt; RAW_OBJECT_LIST = new Builder&lt;List&lt;Object&gt;&gt;() {
25      @Override
26      public List&lt;Object&gt; build(Object data) {
27        return (List&lt;Object&gt;) data;
28      }
29      @Override
30      public String toString() {
31        return &quot;List&lt;Object&gt;&quot;;
32      }
33    };
34    public static final Builder&lt;Object&gt; ENCODED_OBJECT = new Builder&lt;Object&gt;() {
35      @Override
36      public Object build(Object data) {
37        return SafeEncoder.encodeObject(data);
38      }
39      @Override
40      public String toString() {
41        return &quot;Object&quot;;
42      }
43    };
44    public static final Builder&lt;List&lt;Object&gt;&gt; ENCODED_OBJECT_LIST = new Builder&lt;List&lt;Object&gt;&gt;() {
45      @Override
46      public List&lt;Object&gt; build(Object data) {
47        return (List&lt;Object&gt;) SafeEncoder.encodeObject(data);
48      }
49      @Override
50      public String toString() {
51        return &quot;List&lt;Object&gt;&quot;;
52      }
53    };
54    public static final Builder&lt;Long&gt; LONG = new Builder&lt;Long&gt;() {
55      @Override
56      public Long build(Object data) {
57        return (Long) data;
58      }
59      @Override
60      public String toString() {
61        return &quot;Long&quot;;
62      }
63    };
64    public static final Builder&lt;List&lt;Long&gt;&gt; LONG_LIST = new Builder&lt;List&lt;Long&gt;&gt;() {
65      @Override
66      @SuppressWarnings(&quot;unchecked&quot;)
67      public List&lt;Long&gt; build(Object data) {
68        if (null == data) {
69          return null;
70        }
71        return (List&lt;Long&gt;) data;
72      }
73      @Override
74      public String toString() {
75        return &quot;List&lt;Long&gt;&quot;;
76      }
77    };
78    public static final Builder&lt;Double&gt; DOUBLE = new Builder&lt;Double&gt;() {
79      @Override
80      public Double build(Object data) {
81        if (data == null) return null;
82        else if (data instanceof Double) return (Double) data;
83        else return DoublePrecision.parseFloatingPointNumber(STRING.build(data));
84      }
85      @Override
86      public String toString() {
87        return &quot;Double&quot;;
88      }
89    };
90    public static final Builder&lt;List&lt;Double&gt;&gt; DOUBLE_LIST = new Builder&lt;List&lt;Double&gt;&gt;() {
91      @Override
92      @SuppressWarnings(&quot;unchecked&quot;)
93      public List&lt;Double&gt; build(Object data) {
94        if (null == data) return null;
95        return ((List&lt;Object&gt;) data).stream().map(DOUBLE::build).collect(Collectors.toList());
96      }
97      @Override
98      public String toString() {
99        return &quot;List&lt;Double&gt;&quot;;
100      }
101    };
102    public static final Builder&lt;Boolean&gt; BOOLEAN = new Builder&lt;Boolean&gt;() {
103      @Override
104      public Boolean build(Object data) {
105        if (data == null) return null;
106        else if (data instanceof Boolean) return (Boolean) data;
107        return ((Long) data) == 1L;
108      }
109      @Override
110      public String toString() {
111        return &quot;Boolean&quot;;
112      }
113    };
114    public static final Builder&lt;List&lt;Boolean&gt;&gt; BOOLEAN_LIST = new Builder&lt;List&lt;Boolean&gt;&gt;() {
115      @Override
116      @SuppressWarnings(&quot;unchecked&quot;)
117      public List&lt;Boolean&gt; build(Object data) {
118        if (null == data) return null;
119        return ((List&lt;Object&gt;) data).stream().map(BOOLEAN::build).collect(Collectors.toList());
120      }
121      @Override
122      public String toString() {
123        return &quot;List&lt;Boolean&gt;&quot;;
124      }
125    };
126    public static final Builder&lt;List&lt;Boolean&gt;&gt; BOOLEAN_WITH_ERROR_LIST = new Builder&lt;List&lt;Boolean&gt;&gt;() {
127      @Override
128      @SuppressWarnings(&quot;unchecked&quot;)
129      public List&lt;Boolean&gt; build(Object data) {
130        if (null == data) return null;
131        return ((List&lt;Object&gt;) data).stream()
132            .map((val) -&gt; (val instanceof JedisDataException) ? null : BOOLEAN.build(val))
133            .collect(Collectors.toList());
134      }
135      @Override
136      public String toString() {
137        return &quot;List&lt;Boolean&gt;&quot;;
138      }
139    };
140    public static final Builder&lt;byte[]&gt; BINARY = new Builder&lt;byte[]&gt;() {
141      @Override
142      public byte[] build(Object data) {
143        return (byte[]) data;
144      }
145      @Override
146      public String toString() {
147        return &quot;byte[]&quot;;
148      }
149    };
150    public static final Builder&lt;List&lt;byte[]&gt;&gt; BINARY_LIST = new Builder&lt;List&lt;byte[]&gt;&gt;() {
151      @Override
152      @SuppressWarnings(&quot;unchecked&quot;)
153      public List&lt;byte[]&gt; build(Object data) {
154        return (List&lt;byte[]&gt;) data;
155      }
156      @Override
157      public String toString() {
158        return &quot;List&lt;byte[]&gt;&quot;;
159      }
160    };
161    public static final Builder&lt;Set&lt;byte[]&gt;&gt; BINARY_SET = new Builder&lt;Set&lt;byte[]&gt;&gt;() {
162      @Override
163      @SuppressWarnings(&quot;unchecked&quot;)
164      public Set&lt;byte[]&gt; build(Object data) {
165        if (null == data) {
166          return null;
167        }
168        List&lt;byte[]&gt; l = BINARY_LIST.build(data);
169        return SetFromList.of(l);
170      }
171      @Override
172      public String toString() {
173        return &quot;Set&lt;byte[]&gt;&quot;;
174      }
175    };
176    public static final Builder&lt;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt; BINARY_PAIR_LIST
177        = new Builder&lt;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt;() {
178      @Override
179      @SuppressWarnings(&quot;unchecked&quot;)
180      public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; build(Object data) {
181        final List&lt;byte[]&gt; flatHash = (List&lt;byte[]&gt;) data;
182        final List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; pairList = new ArrayList&lt;&gt;();
183        final Iterator&lt;byte[]&gt; iterator = flatHash.iterator();
184        while (iterator.hasNext()) {
<span onclick='openModal()' class='match'>185          pairList.add(new AbstractMap.SimpleEntry&lt;&gt;(iterator.next(), iterator.next()));
186        }
187        return pairList;
</span>188      }
189      @Override
190      public String toString() {
191        return &quot;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&quot;;
192      }
193    };
194    public static final Builder&lt;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt; BINARY_PAIR_LIST_FROM_PAIRS
195        = new Builder&lt;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt;() {
196      @Override
197      @SuppressWarnings(&quot;unchecked&quot;)
198      public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; build(Object data) {
199        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
200        final List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; pairList = new ArrayList&lt;&gt;();
201        for (Object object : list) {
202          final List&lt;byte[]&gt; flat = (List&lt;byte[]&gt;) object;
203          pairList.add(new AbstractMap.SimpleEntry&lt;&gt;(flat.get(0), flat.get(1)));
204        }
205        return pairList;
206      }
207      @Override
208      public String toString() {
209        return &quot;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&quot;;
210      }
211    };
212    public static final Builder&lt;String&gt; STRING = new Builder&lt;String&gt;() {
213      @Override
214      public String build(Object data) {
215        return data == null ? null : SafeEncoder.encode((byte[]) data);
216      }
217      @Override
218      public String toString() {
219        return &quot;String&quot;;
220      }
221    };
222    public static final Builder&lt;List&lt;String&gt;&gt; STRING_LIST = new Builder&lt;List&lt;String&gt;&gt;() {
223      @Override
224      @SuppressWarnings(&quot;unchecked&quot;)
225      public List&lt;String&gt; build(Object data) {
226        if (null == data) return null;
227        return ((List&lt;Object&gt;) data).stream().map(STRING::build).collect(Collectors.toList());
228      }
229      @Override
230      public String toString() {
231        return &quot;List&lt;String&gt;&quot;;
232      }
233    };
234    public static final Builder&lt;Set&lt;String&gt;&gt; STRING_SET = new Builder&lt;Set&lt;String&gt;&gt;() {
235      @Override
236      @SuppressWarnings(&quot;unchecked&quot;)
237      public Set&lt;String&gt; build(Object data) {
238        if (null == data) return null;
239        return ((List&lt;Object&gt;) data).stream().map(STRING::build).collect(Collectors.toSet());
240      }
241      @Override
242      public String toString() {
243        return &quot;Set&lt;String&gt;&quot;;
244      }
245    };
246    public static final Builder&lt;Map&lt;String, Object&gt;&gt; ENCODED_OBJECT_MAP = new Builder&lt;Map&lt;String, Object&gt;&gt;() {
247      @Override
248      public Map&lt;String, Object&gt; build(Object data) {
249        if (data == null) return null;
250        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
251        if (list.isEmpty()) return Collections.emptyMap();
252        if (list.get(0) instanceof KeyValue) {
253          final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(list.size(), 1f);
254          final Iterator iterator = list.iterator();
255          while (iterator.hasNext()) {
256            KeyValue kv = (KeyValue) iterator.next();
257            map.put(STRING.build(kv.getKey()), ENCODED_OBJECT.build(kv.getValue()));
258          }
259          return map;
260        } else {
261          final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(list.size() / 2, 1f);
262          final Iterator iterator = list.iterator();
263          while (iterator.hasNext()) {
264            map.put(STRING.build(iterator.next()), ENCODED_OBJECT.build(iterator.next()));
265          }
266          return map;
267        }
268      }
269    };
270    public static final Builder&lt;Map&lt;byte[], byte[]&gt;&gt; BINARY_MAP = new Builder&lt;Map&lt;byte[], byte[]&gt;&gt;() {
271      @Override
272      @SuppressWarnings(&quot;unchecked&quot;)
273      public Map&lt;byte[], byte[]&gt; build(Object data) {
274        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
275        if (list.isEmpty()) return Collections.emptyMap();
276        if (list.get(0) instanceof KeyValue) {
277          final Map&lt;byte[], byte[]&gt; map = new JedisByteHashMap();
278          final Iterator iterator = list.iterator();
279          while (iterator.hasNext()) {
280            KeyValue kv = (KeyValue) iterator.next();
281            map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));
282          }
283          return map;
284        } else {
285          final Map&lt;byte[], byte[]&gt; map = new JedisByteHashMap();
286          final Iterator iterator = list.iterator();
287          while (iterator.hasNext()) {
288            map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));
289          }
290          return map;
291        }
292      }
293      @Override
294      public String toString() {
295        return &quot;Map&lt;byte[], byte[]&gt;&quot;;
296      }
297    };
298    public static final Builder&lt;Map&lt;String, String&gt;&gt; STRING_MAP = new Builder&lt;Map&lt;String, String&gt;&gt;() {
299      @Override
300      @SuppressWarnings(&quot;unchecked&quot;)
301      public Map&lt;String, String&gt; build(Object data) {
302        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
303        if (list.isEmpty()) return Collections.emptyMap();
304        if (list.get(0) instanceof KeyValue) {
305          final Map&lt;String, String&gt; map = new HashMap&lt;&gt;(list.size(), 1f);
306          final Iterator iterator = list.iterator();
307          while (iterator.hasNext()) {
308            KeyValue kv = (KeyValue) iterator.next();
309            map.put(STRING.build(kv.getKey()), STRING.build(kv.getValue()));
310          }
311          return map;
312        } else {
313          final Map&lt;String, String&gt; map = new HashMap&lt;&gt;(list.size() / 2, 1f);
314          final Iterator iterator = list.iterator();
315          while (iterator.hasNext()) {
316            map.put(STRING.build(iterator.next()), STRING.build(iterator.next()));
317          }
318          return map;
319        }
320      }
321      @Override
322      public String toString() {
323        return &quot;Map&lt;String, String&gt;&quot;;
324      }
325    };
326    public static final Builder&lt;List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; STRING_PAIR_LIST
327        = new Builder&lt;List&lt;Map.Entry&lt;String, String&gt;&gt;&gt;() {
328      @Override
329      @SuppressWarnings(&quot;unchecked&quot;)
330      public List&lt;Map.Entry&lt;String, String&gt;&gt; build(Object data) {
331        final List&lt;byte[]&gt; flatHash = (List&lt;byte[]&gt;) data;
332        final List&lt;Map.Entry&lt;String, String&gt;&gt; pairList = new ArrayList&lt;&gt;(flatHash.size() / 2);
333        final Iterator&lt;byte[]&gt; iterator = flatHash.iterator();
334        while (iterator.hasNext()) {
335          pairList.add(KeyValue.of(STRING.build(iterator.next()), STRING.build(iterator.next())));
336        }
337        return pairList;
338      }
339      @Override
340      public String toString() {
341        return &quot;List&lt;Map.Entry&lt;String, String&gt;&gt;&quot;;
342      }
343    };
344    public static final Builder&lt;List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; STRING_PAIR_LIST_FROM_PAIRS
345        = new Builder&lt;List&lt;Map.Entry&lt;String, String&gt;&gt;&gt;() {
346      @Override
347      @SuppressWarnings(&quot;unchecked&quot;)
348      public List&lt;Map.Entry&lt;String, String&gt;&gt; build(Object data) {
349        return ((List&lt;Object&gt;) data).stream().map(o -&gt; (List&lt;Object&gt;) o)
350            .map(l -&gt; KeyValue.of(STRING.build(l.get(0)), STRING.build(l.get(1))))
351            .collect(Collectors.toList());
352      }
353      @Override
354      public String toString() {
355        return &quot;List&lt;Map.Entry&lt;String, String&gt;&gt;&quot;;
356      }
357    };
358    public static final Builder&lt;KeyValue&lt;String, String&gt;&gt; KEYED_ELEMENT = new Builder&lt;KeyValue&lt;String, String&gt;&gt;() {
359      @Override
360      @SuppressWarnings(&quot;unchecked&quot;)
361      public KeyValue&lt;String, String&gt; build(Object data) {
362        if (data == null) return null;
363        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
364        return KeyValue.of(STRING.build(l.get(0)), STRING.build(l.get(1)));
365      }
366      @Override
367      public String toString() {
368        return &quot;KeyValue&lt;String, String&gt;&quot;;
369      }
370    };
371    public static final Builder&lt;KeyValue&lt;byte[], byte[]&gt;&gt; BINARY_KEYED_ELEMENT = new Builder&lt;KeyValue&lt;byte[], byte[]&gt;&gt;() {
372      @Override
373      @SuppressWarnings(&quot;unchecked&quot;)
374      public KeyValue&lt;byte[], byte[]&gt; build(Object data) {
375        if (data == null) return null;
376        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
377        return KeyValue.of(BINARY.build(l.get(0)), BINARY.build(l.get(1)));
378      }
379      @Override
380      public String toString() {
381        return &quot;KeyValue&lt;byte[], byte[]&gt;&quot;;
382      }
383    };
384    public static final Builder&lt;KeyValue&lt;Long, Double&gt;&gt; ZRANK_WITHSCORE_PAIR = new Builder&lt;KeyValue&lt;Long, Double&gt;&gt;() {
385      @Override
386      public KeyValue&lt;Long, Double&gt; build(Object data) {
387        if (data == null) {
388          return null;
389        }
390        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
391        return new KeyValue&lt;&gt;(LONG.build(l.get(0)), DOUBLE.build(l.get(1)));
392      }
393      @Override
394      public String toString() {
395        return &quot;KeyValue&lt;Long, Double&gt;&quot;;
396      }
397    };
398    public static final Builder&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt; KEYED_STRING_LIST
399        = new Builder&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt;() {
400      @Override
401      @SuppressWarnings(&quot;unchecked&quot;)
402      public KeyValue&lt;String, List&lt;String&gt;&gt; build(Object data) {
403        if (data == null) return null;
404        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data;
405        return new KeyValue&lt;&gt;(STRING.build(l.get(0)), STRING_LIST.build(l.get(1)));
406      }
407      @Override
408      public String toString() {
409        return &quot;KeyValue&lt;String, List&lt;String&gt;&gt;&quot;;
410      }
411    };
412    public static final Builder&lt;KeyValue&lt;Long, Long&gt;&gt; LONG_LONG_PAIR = new Builder&lt;KeyValue&lt;Long, Long&gt;&gt;() {
413      @Override
414      @SuppressWarnings(&quot;unchecked&quot;)
415      public KeyValue&lt;Long, Long&gt; build(Object data) {
416        if (data == null) return null;
417        List&lt;Object&gt; dataList = (List&lt;Object&gt;) data;
418        return new KeyValue&lt;&gt;(LONG.build(dataList.get(0)), LONG.build(dataList.get(1)));
419      }
420    };
421    public static final Builder&lt;List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt;&gt; KEYED_STRING_LIST_LIST
422        = new Builder&lt;List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt;&gt;() {
423      @Override
424      public List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt; build(Object data) {
425        List&lt;Object&gt; list = (List&lt;Object&gt;) data;
426        return list.stream().map(KEYED_STRING_LIST::build).collect(Collectors.toList());
427      }
428    };
429    public static final Builder&lt;KeyValue&lt;byte[], List&lt;byte[]&gt;&gt;&gt; KEYED_BINARY_LIST
430        = new Builder&lt;KeyValue&lt;byte[], List&lt;byte[]&gt;&gt;&gt;() {
431      @Override
432      @SuppressWarnings(&quot;unchecked&quot;)
433      public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; build(Object data) {
434        if (data == null) return null;
435        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data;
436        return new KeyValue&lt;&gt;(BINARY.build(l.get(0)), BINARY_LIST.build(l.get(1)));
437      }
438      @Override
439      public String toString() {
440        return &quot;KeyValue&lt;byte[], List&lt;byte[]&gt;&gt;&quot;;
441      }
442    };
443    public static final Builder&lt;Tuple&gt; TUPLE = new Builder&lt;Tuple&gt;() {
444      @Override
445      @SuppressWarnings(&quot;unchecked&quot;)
446      public Tuple build(Object data) {
447        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data; 
448        if (l.isEmpty()) {
449          return null;
450        }
451        return new Tuple(l.get(0), DOUBLE.build(l.get(1)));
452      }
453      @Override
454      public String toString() {
455        return &quot;Tuple&quot;;
456      }
457    };
458    public static final Builder&lt;KeyValue&lt;String, Tuple&gt;&gt; KEYED_TUPLE = new Builder&lt;KeyValue&lt;String, Tuple&gt;&gt;() {
459      @Override
460      @SuppressWarnings(&quot;unchecked&quot;)
461      public KeyValue&lt;String, Tuple&gt; build(Object data) {
462        List&lt;Object&gt; l = (List&lt;Object&gt;) data; 
463        if (l.isEmpty()) {
464          return null;
465        }
466        return KeyValue.of(STRING.build(l.get(0)), new Tuple(BINARY.build(l.get(1)), DOUBLE.build(l.get(2))));
467      }
468      @Override
469      public String toString() {
470        return &quot;KeyValue&lt;String, Tuple&gt;&quot;;
471      }
472    };
473    public static final Builder&lt;KeyValue&lt;byte[], Tuple&gt;&gt; BINARY_KEYED_TUPLE = new Builder&lt;KeyValue&lt;byte[], Tuple&gt;&gt;() {
474      @Override
475      @SuppressWarnings(&quot;unchecked&quot;)
476      public KeyValue&lt;byte[], Tuple&gt; build(Object data) {
477        List&lt;Object&gt; l = (List&lt;Object&gt;) data; 
478        if (l.isEmpty()) {
479          return null;
480        }
481        return KeyValue.of(BINARY.build(l.get(0)), new Tuple(BINARY.build(l.get(1)), DOUBLE.build(l.get(2))));
482      }
483      @Override
484      public String toString() {
485        return &quot;KeyValue&lt;byte[], Tuple&gt;&quot;;
486      }
487    };
488    public static final Builder&lt;List&lt;Tuple&gt;&gt; TUPLE_LIST = new Builder&lt;List&lt;Tuple&gt;&gt;() {
489      @Override
490      @SuppressWarnings(&quot;unchecked&quot;)
491      public List&lt;Tuple&gt; build(Object data) {
492        if (null == data) {
493          return null;
494        }
495        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data;
496        final List&lt;Tuple&gt; result = new ArrayList&lt;&gt;(l.size() / 2);
497        Iterator&lt;byte[]&gt; iterator = l.iterator();
498        while (iterator.hasNext()) {
499          result.add(new Tuple(iterator.next(), DOUBLE.build(iterator.next())));
500        }
501        return result;
502      }
503      @Override
504      public String toString() {
505        return &quot;List&lt;Tuple&gt;&quot;;
506      }
507    };
508    public static final Builder&lt;List&lt;Tuple&gt;&gt; TUPLE_LIST_RESP3 = new Builder&lt;List&lt;Tuple&gt;&gt;() {
509      @Override
510      @SuppressWarnings(&quot;unchecked&quot;)
511      public List&lt;Tuple&gt; build(Object data) {
512        if (null == data) return null;
513        return ((List&lt;Object&gt;) data).stream().map(TUPLE::build).collect(Collectors.toList());
514      }
515      @Override
516      public String toString() {
517        return &quot;List&lt;Tuple&gt;&quot;;
518      }
519    };
520    public static final Builder&lt;Set&lt;Tuple&gt;&gt; TUPLE_ZSET = new Builder&lt;Set&lt;Tuple&gt;&gt;() {
521      @Override
522      @SuppressWarnings(&quot;unchecked&quot;)
523      public Set&lt;Tuple&gt; build(Object data) {
524        if (null == data) {
525          return null;
526        }
527        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data;
528        final Set&lt;Tuple&gt; result = new LinkedHashSet&lt;&gt;(l.size() / 2, 1);
529        Iterator&lt;byte[]&gt; iterator = l.iterator();
530        while (iterator.hasNext()) {
531          result.add(new Tuple(iterator.next(), DOUBLE.build(iterator.next())));
532        }
533        return result;
534      }
535      @Override
536      public String toString() {
537        return &quot;ZSet&lt;Tuple&gt;&quot;;
538      }
539    };
540    public static final Builder&lt;Set&lt;Tuple&gt;&gt; TUPLE_ZSET_RESP3 = new Builder&lt;Set&lt;Tuple&gt;&gt;() {
541      @Override
542      @SuppressWarnings(&quot;unchecked&quot;)
543      public Set&lt;Tuple&gt; build(Object data) {
544        if (null == data) return null;
545        return ((List&lt;Object&gt;) data).stream().map(TUPLE::build).collect(Collectors.toCollection(LinkedHashSet::new));
546      }
547      @Override
548      public String toString() {
549        return &quot;ZSet&lt;Tuple&gt;&quot;;
550      }
551    };
552    private static final Builder&lt;List&lt;Tuple&gt;&gt; TUPLE_LIST_FROM_PAIRS = new Builder&lt;List&lt;Tuple&gt;&gt;() {
553      @Override
554      @SuppressWarnings(&quot;unchecked&quot;)
555      public List&lt;Tuple&gt; build(Object data) {
556        if (data == null) return null;
557        return ((List&lt;List&lt;Object&gt;&gt;) data).stream().map(TUPLE::build).collect(Collectors.toList());
558      }
559      @Override
560      public String toString() {
561        return &quot;List&lt;Tuple&gt;&quot;;
562      }
563    };
564    public static final Builder&lt;KeyValue&lt;String, List&lt;Tuple&gt;&gt;&gt; KEYED_TUPLE_LIST
565        = new Builder&lt;KeyValue&lt;String, List&lt;Tuple&gt;&gt;&gt;() {
566      @Override
567      @SuppressWarnings(&quot;unchecked&quot;)
568      public KeyValue&lt;String, List&lt;Tuple&gt;&gt; build(Object data) {
569        if (data == null) return null;
570        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
571        return new KeyValue&lt;&gt;(STRING.build(l.get(0)), TUPLE_LIST_FROM_PAIRS.build(l.get(1)));
572      }
573      @Override
574      public String toString() {
575        return &quot;KeyValue&lt;String, List&lt;Tuple&gt;&gt;&quot;;
576      }
577    };
578    public static final Builder&lt;KeyValue&lt;byte[], List&lt;Tuple&gt;&gt;&gt; BINARY_KEYED_TUPLE_LIST
579        = new Builder&lt;KeyValue&lt;byte[], List&lt;Tuple&gt;&gt;&gt;() {
580      @Override
581      @SuppressWarnings(&quot;unchecked&quot;)
582      public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; build(Object data) {
583        if (data == null) return null;
584        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
585        return new KeyValue&lt;&gt;(BINARY.build(l.get(0)), TUPLE_LIST_FROM_PAIRS.build(l.get(1)));
586      }
587      @Override
588      public String toString() {
589        return &quot;KeyValue&lt;byte[], List&lt;Tuple&gt;&gt;&quot;;
590      }
591    };
592    public static final Builder&lt;ScanResult&lt;String&gt;&gt; SCAN_RESPONSE = new Builder&lt;ScanResult&lt;String&gt;&gt;() {
593      @Override
594      public ScanResult&lt;String&gt; build(Object data) {
595        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
596        String newcursor = new String((byte[]) result.get(0));
597        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
598        List&lt;String&gt; results = new ArrayList&lt;&gt;(rawResults.size());
599        for (byte[] bs : rawResults) {
600          results.add(SafeEncoder.encode(bs));
601        }
602        return new ScanResult&lt;&gt;(newcursor, results);
603      }
604    };
605    public static final Builder&lt;ScanResult&lt;Map.Entry&lt;String, String&gt;&gt;&gt; HSCAN_RESPONSE
606        = new Builder&lt;ScanResult&lt;Map.Entry&lt;String, String&gt;&gt;&gt;() {
607      @Override
608      public ScanResult&lt;Map.Entry&lt;String, String&gt;&gt; build(Object data) {
609        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
610        String newcursor = new String((byte[]) result.get(0));
611        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
612        List&lt;Map.Entry&lt;String, String&gt;&gt; results = new ArrayList&lt;&gt;(rawResults.size() / 2);
613        Iterator&lt;byte[]&gt; iterator = rawResults.iterator();
614        while (iterator.hasNext()) {
615          results.add(new AbstractMap.SimpleEntry&lt;&gt;(SafeEncoder.encode(iterator.next()),
616              SafeEncoder.encode(iterator.next())));
617        }
618        return new ScanResult&lt;&gt;(newcursor, results);
619      }
620    };
621    public static final Builder&lt;ScanResult&lt;String&gt;&gt; SSCAN_RESPONSE = new Builder&lt;ScanResult&lt;String&gt;&gt;() {
622      @Override
623      public ScanResult&lt;String&gt; build(Object data) {
624        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
625        String newcursor = new String((byte[]) result.get(0));
626        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
627        List&lt;String&gt; results = new ArrayList&lt;&gt;(rawResults.size());
628        for (byte[] bs : rawResults) {
629          results.add(SafeEncoder.encode(bs));
630        }
631        return new ScanResult&lt;&gt;(newcursor, results);
632      }
633    };
634    public static final Builder&lt;ScanResult&lt;Tuple&gt;&gt; ZSCAN_RESPONSE = new Builder&lt;ScanResult&lt;Tuple&gt;&gt;() {
635      @Override
636      public ScanResult&lt;Tuple&gt; build(Object data) {
637        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
638        String newcursor = new String((byte[]) result.get(0));
639        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
640        List&lt;Tuple&gt; results = new ArrayList&lt;&gt;(rawResults.size() / 2);
641        Iterator&lt;byte[]&gt; iterator = rawResults.iterator();
642        while (iterator.hasNext()) {
643          results.add(new Tuple(iterator.next(), BuilderFactory.DOUBLE.build(iterator.next())));
644        }
645        return new ScanResult&lt;&gt;(newcursor, results);
646      }
647    };
648    public static final Builder&lt;ScanResult&lt;byte[]&gt;&gt; SCAN_BINARY_RESPONSE = new Builder&lt;ScanResult&lt;byte[]&gt;&gt;() {
649      @Override
650      public ScanResult&lt;byte[]&gt; build(Object data) {
651        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
652        byte[] newcursor = (byte[]) result.get(0);
653        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
654        return new ScanResult&lt;&gt;(newcursor, rawResults);
655      }
656    };
657    public static final Builder&lt;ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt; HSCAN_BINARY_RESPONSE
658        = new Builder&lt;ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt;() {
659      @Override
660      public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; build(Object data) {
661        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
662        byte[] newcursor = (byte[]) result.get(0);
663        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
664        List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; results = new ArrayList&lt;&gt;(rawResults.size() / 2);
665        Iterator&lt;byte[]&gt; iterator = rawResults.iterator();
666        while (iterator.hasNext()) {
667          results.add(new AbstractMap.SimpleEntry&lt;&gt;(iterator.next(), iterator.next()));
668        }
669        return new ScanResult&lt;&gt;(newcursor, results);
670      }
671    };
672    public static final Builder&lt;ScanResult&lt;byte[]&gt;&gt; SSCAN_BINARY_RESPONSE = new Builder&lt;ScanResult&lt;byte[]&gt;&gt;() {
673      @Override
674      public ScanResult&lt;byte[]&gt; build(Object data) {
675        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
676        byte[] newcursor = (byte[]) result.get(0);
677        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
678        return new ScanResult&lt;&gt;(newcursor, rawResults);
679      }
680    };
681    public static final Builder&lt;Map&lt;String, Long&gt;&gt; PUBSUB_NUMSUB_MAP = new Builder&lt;Map&lt;String, Long&gt;&gt;() {
682      @Override
683      @SuppressWarnings(&quot;unchecked&quot;)
684      public Map&lt;String, Long&gt; build(Object data) {
685        final List&lt;Object&gt; flatHash = (List&lt;Object&gt;) data;
686        final Map&lt;String, Long&gt; hash = new HashMap&lt;&gt;(flatHash.size() / 2, 1f);
687        final Iterator&lt;Object&gt; iterator = flatHash.iterator();
688        while (iterator.hasNext()) {
689          hash.put(SafeEncoder.encode((byte[]) iterator.next()), (Long) iterator.next());
690        }
691        return hash;
692      }
693      @Override
694      public String toString() {
695        return &quot;PUBSUB_NUMSUB_MAP&lt;String, String&gt;&quot;;
696      }
697    };
698    public static final Builder&lt;List&lt;GeoCoordinate&gt;&gt; GEO_COORDINATE_LIST = new Builder&lt;List&lt;GeoCoordinate&gt;&gt;() {
699      @Override
700      public List&lt;GeoCoordinate&gt; build(Object data) {
701        if (null == data) {
702          return null;
703        }
704        return interpretGeoposResult((List&lt;Object&gt;) data);
705      }
706      @Override
707      public String toString() {
708        return &quot;List&lt;GeoCoordinate&gt;&quot;;
709      }
710      private List&lt;GeoCoordinate&gt; interpretGeoposResult(List&lt;Object&gt; responses) {
711        List&lt;GeoCoordinate&gt; responseCoordinate = new ArrayList&lt;&gt;(responses.size());
712        for (Object response : responses) {
713          if (response == null) {
714            responseCoordinate.add(null);
715          } else {
716            List&lt;Object&gt; respList = (List&lt;Object&gt;) response;
717            GeoCoordinate coord = new GeoCoordinate(DOUBLE.build(respList.get(0)),
718                DOUBLE.build(respList.get(1)));
719            responseCoordinate.add(coord);
720          }
721        }
722        return responseCoordinate;
723      }
724    };
725    public static final Builder&lt;List&lt;GeoRadiusResponse&gt;&gt; GEORADIUS_WITH_PARAMS_RESULT = new Builder&lt;List&lt;GeoRadiusResponse&gt;&gt;() {
726      @Override
727      public List&lt;GeoRadiusResponse&gt; build(Object data) {
728        if (data == null) {
729          return null;
730        }
731        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
732        List&lt;GeoRadiusResponse&gt; responses = new ArrayList&lt;&gt;(objectList.size());
733        if (objectList.isEmpty()) {
734          return responses;
735        }
736        if (objectList.get(0) instanceof List&lt;?&gt;) {
737          GeoRadiusResponse resp;
738          for (Object obj : objectList) {
739            List&lt;Object&gt; informations = (List&lt;Object&gt;) obj;
740            resp = new GeoRadiusResponse((byte[]) informations.get(0));
741            int size = informations.size();
742            for (int idx = 1; idx &lt; size; idx++) {
743              Object info = informations.get(idx);
744              if (info instanceof List&lt;?&gt;) {
745                List&lt;Object&gt; coord = (List&lt;Object&gt;) info;
746                resp.setCoordinate(new GeoCoordinate(DOUBLE.build(coord.get(0)),
747                    DOUBLE.build(coord.get(1))));
748              } else if (info instanceof Long) {
749                resp.setRawScore(LONG.build(info));
750              } else {
751                resp.setDistance(DOUBLE.build(info));
752              }
753            }
754            responses.add(resp);
755          }
756        } else {
757          for (Object obj : objectList) {
758            responses.add(new GeoRadiusResponse((byte[]) obj));
759          }
760        }
761        return responses;
762      }
763      @Override
764      public String toString() {
765        return &quot;GeoRadiusWithParamsResult&quot;;
766      }
767    };
768    public static final Builder&lt;Map&lt;String, CommandDocument&gt;&gt; COMMAND_DOCS_RESPONSE = new Builder&lt;Map&lt;String, CommandDocument&gt;&gt;() {
769      @Override
770      public Map&lt;String, CommandDocument&gt; build(Object data) {
771        if (data == null) return null;
772        List&lt;Object&gt; list = (List&lt;Object&gt;) data;
773        if (list.isEmpty()) return Collections.emptyMap();
774        if (list.get(0) instanceof KeyValue) {
775          final Map&lt;String, CommandDocument&gt; map = new HashMap&lt;&gt;(list.size(), 1f);
776          final Iterator iterator = list.iterator();
777          while (iterator.hasNext()) {
778            KeyValue kv = (KeyValue) iterator.next();
779            map.put(STRING.build(kv.getKey()), new CommandDocument(ENCODED_OBJECT_MAP.build(kv.getValue())));
780          }
781          return map;
782        } else {
783          final Map&lt;String, CommandDocument&gt; map = new HashMap&lt;&gt;(list.size() / 2, 1f);
784          final Iterator iterator = list.iterator();
785          while (iterator.hasNext()) {
786            map.put(STRING.build(iterator.next()), new CommandDocument(ENCODED_OBJECT_MAP.build(iterator.next())));
787          }
788          return map;
789        }
790      }
791    };
792    public static final Builder&lt;Map&lt;String, CommandInfo&gt;&gt; COMMAND_INFO_RESPONSE = new Builder&lt;Map&lt;String, CommandInfo&gt;&gt;() {
793      @Override
794      public Map&lt;String, CommandInfo&gt; build(Object data) {
795        if (data == null) {
796          return null;
797        }
798        List&lt;Object&gt; rawList = (List&lt;Object&gt;) data;
799        Map&lt;String, CommandInfo&gt; map = new HashMap&lt;&gt;(rawList.size());
800        for (Object rawCommandInfo : rawList) {
801          if (rawCommandInfo == null) {
802            continue;
803          }
804          List&lt;Object&gt; commandInfo = (List&lt;Object&gt;) rawCommandInfo;
805          String name = STRING.build(commandInfo.get(0));
806          CommandInfo info = CommandInfo.COMMAND_INFO_BUILDER.build(commandInfo);
807          map.put(name, info);
808        }
809        return map;
810      }
811    };
812    public static final Builder&lt;List&lt;Module&gt;&gt; MODULE_LIST = new Builder&lt;List&lt;Module&gt;&gt;() {
813      @Override
814      public List&lt;Module&gt; build(Object data) {
815        if (data == null) {
816          return null;
817        }
818        List&lt;List&lt;Object&gt;&gt; objectList = (List&lt;List&lt;Object&gt;&gt;) data;
819        List&lt;Module&gt; responses = new ArrayList&lt;&gt;(objectList.size());
820        if (objectList.isEmpty()) {
821          return responses;
822        }
823        for (List&lt;Object&gt; moduleResp : objectList) {
824          if (moduleResp.get(0) instanceof KeyValue) {
825            responses.add(new Module(STRING.build(((KeyValue) moduleResp.get(0)).getValue()),
826                LONG.build(((KeyValue) moduleResp.get(1)).getValue()).intValue()));
827            continue;
828          }
829          Module m = new Module(SafeEncoder.encode((byte[]) moduleResp.get(1)),
830              ((Long) moduleResp.get(3)).intValue());
831          responses.add(m);
832        }
833        return responses;
834      }
835      @Override
836      public String toString() {
837        return &quot;List&lt;Module&gt;&quot;;
838      }
839    };
840    public static final Builder&lt;AccessControlUser&gt; ACCESS_CONTROL_USER = new Builder&lt;AccessControlUser&gt;() {
841      @Override
842      public AccessControlUser build(Object data) {
843        Map&lt;String, Object&gt; map = ENCODED_OBJECT_MAP.build(data);
844        if (map == null) return null;
845        return new AccessControlUser(map);
846      }
847      @Override
848      public String toString() {
849        return &quot;AccessControlUser&quot;;
850      }
851    };
852    public static final Builder&lt;List&lt;AccessControlLogEntry&gt;&gt; ACCESS_CONTROL_LOG_ENTRY_LIST
853        = new Builder&lt;List&lt;AccessControlLogEntry&gt;&gt;() {
854      private final Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
855      private Map&lt;String, Builder&gt; createDecoderMap() {
856        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
857        tempMappingFunctions.put(AccessControlLogEntry.COUNT, LONG);
858        tempMappingFunctions.put(AccessControlLogEntry.REASON, STRING);
859        tempMappingFunctions.put(AccessControlLogEntry.CONTEXT, STRING);
860        tempMappingFunctions.put(AccessControlLogEntry.OBJECT, STRING);
861        tempMappingFunctions.put(AccessControlLogEntry.USERNAME, STRING);
862        tempMappingFunctions.put(AccessControlLogEntry.AGE_SECONDS, DOUBLE);
863        tempMappingFunctions.put(AccessControlLogEntry.CLIENT_INFO, STRING);
864        tempMappingFunctions.put(AccessControlLogEntry.ENTRY_ID, LONG);
865        tempMappingFunctions.put(AccessControlLogEntry.TIMESTAMP_CREATED, LONG);
866        tempMappingFunctions.put(AccessControlLogEntry.TIMESTAMP_LAST_UPDATED, LONG);
867        return tempMappingFunctions;
868      }
869      @Override
870      public List&lt;AccessControlLogEntry&gt; build(Object data) {
871        if (null == data) {
872          return null;
873        }
874        List&lt;AccessControlLogEntry&gt; list = new ArrayList&lt;&gt;();
875        List&lt;List&lt;Object&gt;&gt; logEntries = (List&lt;List&lt;Object&gt;&gt;) data;
876        for (List&lt;Object&gt; logEntryData : logEntries) {
877          Iterator&lt;Object&gt; logEntryDataIterator = logEntryData.iterator();
878          AccessControlLogEntry accessControlLogEntry = new AccessControlLogEntry(
879              createMapFromDecodingFunctions(logEntryDataIterator, mappingFunctions,
880                  BACKUP_BUILDERS_FOR_DECODING_FUNCTIONS));
881          list.add(accessControlLogEntry);
882        }
883        return list;
884      }
885      @Override
886      public String toString() {
887        return &quot;List&lt;AccessControlLogEntry&gt;&quot;;
888      }
889    };
890    public static final Builder&lt;StreamEntryID&gt; STREAM_ENTRY_ID = new Builder&lt;StreamEntryID&gt;() {
891      @Override
892      public StreamEntryID build(Object data) {
893        if (null == data) {
894          return null;
895        }
896        String id = SafeEncoder.encode((byte[]) data);
897        return new StreamEntryID(id);
898      }
899      @Override
900      public String toString() {
901        return &quot;StreamEntryID&quot;;
902      }
903    };
904    public static final Builder&lt;List&lt;StreamEntryID&gt;&gt; STREAM_ENTRY_ID_LIST = new Builder&lt;List&lt;StreamEntryID&gt;&gt;() {
905      @Override
906      @SuppressWarnings(&quot;unchecked&quot;)
907      public List&lt;StreamEntryID&gt; build(Object data) {
908        if (null == data) {
909          return null;
910        }
911        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
912        List&lt;StreamEntryID&gt; responses = new ArrayList&lt;&gt;(objectList.size());
913        if (!objectList.isEmpty()) {
914          for(Object object : objectList) {
915            responses.add(STREAM_ENTRY_ID.build(object));
916          }
917        }
918        return responses;
919      }
920    };
921    public static final Builder&lt;StreamEntry&gt; STREAM_ENTRY = new Builder&lt;StreamEntry&gt;() {
922      @Override
923      @SuppressWarnings(&quot;unchecked&quot;)
924      public StreamEntry build(Object data) {
925        if (null == data) {
926          return null;
927        }
928        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
929        if (objectList.isEmpty()) {
930          return null;
931        }
932        String entryIdString = SafeEncoder.encode((byte[]) objectList.get(0));
933        StreamEntryID entryID = new StreamEntryID(entryIdString);
934        List&lt;byte[]&gt; hash = (List&lt;byte[]&gt;) objectList.get(1);
935        Iterator&lt;byte[]&gt; hashIterator = hash.iterator();
936        Map&lt;String, String&gt; map = new HashMap&lt;&gt;(hash.size() / 2, 1f);
937        while (hashIterator.hasNext()) {
938          map.put(SafeEncoder.encode(hashIterator.next()), SafeEncoder.encode(hashIterator.next()));
939        }
940        return new StreamEntry(entryID, map);
941      }
942      @Override
943      public String toString() {
944        return &quot;StreamEntry&quot;;
945      }
946    };
947    public static final Builder&lt;List&lt;StreamEntry&gt;&gt; STREAM_ENTRY_LIST = new Builder&lt;List&lt;StreamEntry&gt;&gt;() {
948      @Override
949      @SuppressWarnings(&quot;unchecked&quot;)
950      public List&lt;StreamEntry&gt; build(Object data) {
951        if (null == data) {
952          return null;
953        }
954        List&lt;ArrayList&lt;Object&gt;&gt; objectList = (List&lt;ArrayList&lt;Object&gt;&gt;) data;
955        List&lt;StreamEntry&gt; responses = new ArrayList&lt;&gt;(objectList.size() / 2);
956        if (objectList.isEmpty()) {
957          return responses;
958        }
959        for (ArrayList&lt;Object&gt; res : objectList) {
960          if (res == null) {
961            responses.add(null);
962            continue;
963          }
964          String entryIdString = SafeEncoder.encode((byte[]) res.get(0));
965          StreamEntryID entryID = new StreamEntryID(entryIdString);
966          List&lt;byte[]&gt; hash = (List&lt;byte[]&gt;) res.get(1);
967          if (hash == null) {
968            responses.add(new StreamEntry(entryID, null));
969            continue;
970          }
971          Iterator&lt;byte[]&gt; hashIterator = hash.iterator();
972          Map&lt;String, String&gt; map = new HashMap&lt;&gt;(hash.size() / 2, 1f);
973          while (hashIterator.hasNext()) {
974            map.put(SafeEncoder.encode(hashIterator.next()), SafeEncoder.encode(hashIterator.next()));
975          }
976          responses.add(new StreamEntry(entryID, map));
977        }
978        return responses;
979      }
980      @Override
981      public String toString() {
982        return &quot;List&lt;StreamEntry&gt;&quot;;
983      }
984    };
985    public static final Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt;&gt; STREAM_AUTO_CLAIM_RESPONSE
986        = new Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt;&gt;() {
987      @Override
988      @SuppressWarnings(&quot;unchecked&quot;)
989      public Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt; build(Object data) {
990        if (null == data) {
991          return null;
992        }
993        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
994        return new AbstractMap.SimpleEntry&lt;&gt;(STREAM_ENTRY_ID.build(objectList.get(0)),
995            STREAM_ENTRY_LIST.build(objectList.get(1)));
996      }
997      @Override
998      public String toString() {
999        return &quot;Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt;&quot;;
1000      }
1001    };
1002    public static final Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt;&gt; STREAM_AUTO_CLAIM_JUSTID_RESPONSE
1003        = new Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt;&gt;() {
1004      @Override
1005      @SuppressWarnings(&quot;unchecked&quot;)
1006      public Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt; build(Object data) {
1007        if (null == data) {
1008          return null;
1009        }
1010        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
1011        return new AbstractMap.SimpleEntry&lt;&gt;(STREAM_ENTRY_ID.build(objectList.get(0)),
1012            STREAM_ENTRY_ID_LIST.build(objectList.get(1)));
1013      }
1014      @Override
1015      public String toString() {
1016        return &quot;Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt;&quot;;
1017      }
1018    };
1019    @Deprecated
1020    public static final Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt;&gt; STREAM_AUTO_CLAIM_ID_RESPONSE
1021        = STREAM_AUTO_CLAIM_JUSTID_RESPONSE;
1022    public static final Builder&lt;List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt;&gt; STREAM_READ_RESPONSE
1023        = new Builder&lt;List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt;&gt;() {
1024      @Override
1025      public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; build(Object data) {
1026        if (data == null) return null;
1027        List list = (List) data;
1028        if (list.isEmpty()) return Collections.emptyList();
1029        if (list.get(0) instanceof KeyValue) {
1030          return ((List&lt;KeyValue&gt;) list).stream()
1031              .map(kv -&gt; new KeyValue&lt;&gt;(STRING.build(kv.getKey()),
1032                  STREAM_ENTRY_LIST.build(kv.getValue())))
1033              .collect(Collectors.toList());
1034        } else {
1035          List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; result = new ArrayList&lt;&gt;(list.size());
1036          for (Object streamObj : list) {
1037            List&lt;Object&gt; stream = (List&lt;Object&gt;) streamObj;
1038            String streamKey = STRING.build(stream.get(0));
1039            List&lt;StreamEntry&gt; streamEntries = STREAM_ENTRY_LIST.build(stream.get(1));
1040            result.add(KeyValue.of(streamKey, streamEntries));
1041          }
1042          return result;
1043        }
1044      }
1045      @Override
1046      public String toString() {
1047        return &quot;List&lt;Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt;&quot;;
1048      }
1049    };
1050    public static final Builder&lt;List&lt;StreamPendingEntry&gt;&gt; STREAM_PENDING_ENTRY_LIST = new Builder&lt;List&lt;StreamPendingEntry&gt;&gt;() {
1051      @Override
1052      @SuppressWarnings(&quot;unchecked&quot;)
1053      public List&lt;StreamPendingEntry&gt; build(Object data) {
1054        if (null == data) {
1055          return null;
1056        }
1057        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1058        List&lt;StreamPendingEntry&gt; result = new ArrayList&lt;&gt;(streamsEntries.size());
1059        for (Object streamObj : streamsEntries) {
1060          List&lt;Object&gt; stream = (List&lt;Object&gt;) streamObj;
1061          String id = SafeEncoder.encode((byte[]) stream.get(0));
1062          String consumerName = SafeEncoder.encode((byte[]) stream.get(1));
1063          long idleTime = BuilderFactory.LONG.build(stream.get(2));
1064          long deliveredTimes = BuilderFactory.LONG.build(stream.get(3));
1065          result.add(new StreamPendingEntry(new StreamEntryID(id), consumerName, idleTime,
1066              deliveredTimes));
1067        }
1068        return result;
1069      }
1070      @Override
1071      public String toString() {
1072        return &quot;List&lt;StreamPendingEntry&gt;&quot;;
1073      }
1074    };
1075    public static final Builder&lt;StreamInfo&gt; STREAM_INFO = new Builder&lt;StreamInfo&gt;() {
1076      Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1077      private Map&lt;String, Builder&gt; createDecoderMap() {
1078        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1079        tempMappingFunctions.put(StreamInfo.LAST_GENERATED_ID, STREAM_ENTRY_ID);
1080        tempMappingFunctions.put(StreamInfo.FIRST_ENTRY, STREAM_ENTRY);
1081        tempMappingFunctions.put(StreamInfo.LENGTH, LONG);
1082        tempMappingFunctions.put(StreamInfo.RADIX_TREE_KEYS, LONG);
1083        tempMappingFunctions.put(StreamInfo.RADIX_TREE_NODES, LONG);
1084        tempMappingFunctions.put(StreamInfo.LAST_ENTRY, STREAM_ENTRY);
1085        tempMappingFunctions.put(StreamInfo.GROUPS, LONG);
1086        return tempMappingFunctions;
1087      }
1088      @Override
1089      @SuppressWarnings(&quot;unchecked&quot;)
1090      public StreamInfo build(Object data) {
1091        if (null == data) {
1092          return null;
1093        }
1094        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1095        Iterator&lt;Object&gt; iterator = streamsEntries.iterator();
1096        return new StreamInfo(createMapFromDecodingFunctions(iterator, mappingFunctions));
1097      }
1098      @Override
1099      public String toString() {
1100        return &quot;StreamInfo&quot;;
1101      }
1102    };
1103    public static final Builder&lt;List&lt;StreamGroupInfo&gt;&gt; STREAM_GROUP_INFO_LIST = new Builder&lt;List&lt;StreamGroupInfo&gt;&gt;() {
1104      Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1105      private Map&lt;String, Builder&gt; createDecoderMap() {
1106        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1107        tempMappingFunctions.put(StreamGroupInfo.NAME, STRING);
1108        tempMappingFunctions.put(StreamGroupInfo.CONSUMERS, LONG);
1109        tempMappingFunctions.put(StreamGroupInfo.PENDING, LONG);
1110        tempMappingFunctions.put(StreamGroupInfo.LAST_DELIVERED, STREAM_ENTRY_ID);
1111        return tempMappingFunctions;
1112      }
1113      @Override
1114      @SuppressWarnings(&quot;unchecked&quot;)
1115      public List&lt;StreamGroupInfo&gt; build(Object data) {
1116        if (null == data) {
1117          return null;
1118        }
1119        List&lt;StreamGroupInfo&gt; list = new ArrayList&lt;&gt;();
1120        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1121        Iterator&lt;Object&gt; groupsArray = streamsEntries.iterator();
1122        while (groupsArray.hasNext()) {
1123          List&lt;Object&gt; groupInfo = (List&lt;Object&gt;) groupsArray.next();
1124          Iterator&lt;Object&gt; groupInfoIterator = groupInfo.iterator();
1125          StreamGroupInfo streamGroupInfo = new StreamGroupInfo(createMapFromDecodingFunctions(
1126            groupInfoIterator, mappingFunctions));
1127          list.add(streamGroupInfo);
1128        }
1129        return list;
1130      }
1131      @Override
1132      public String toString() {
1133        return &quot;List&lt;StreamGroupInfo&gt;&quot;;
1134      }
1135    };
1136    @Deprecated
1137    public static final Builder&lt;List&lt;StreamConsumersInfo&gt;&gt; STREAM_CONSUMERS_INFO_LIST
1138        = new Builder&lt;List&lt;StreamConsumersInfo&gt;&gt;() {
1139      Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1140      private Map&lt;String, Builder&gt; createDecoderMap() {
1141        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1142        tempMappingFunctions.put(StreamConsumersInfo.NAME, STRING);
1143        tempMappingFunctions.put(StreamConsumersInfo.IDLE, LONG);
1144        tempMappingFunctions.put(StreamConsumersInfo.PENDING, LONG);
1145        return tempMappingFunctions;
1146      }
1147      @Override
1148      @SuppressWarnings(&quot;unchecked&quot;)
1149      public List&lt;StreamConsumersInfo&gt; build(Object data) {
1150        if (null == data) {
1151          return null;
1152        }
1153        List&lt;StreamConsumersInfo&gt; list = new ArrayList&lt;&gt;();
1154        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1155        Iterator&lt;Object&gt; groupsArray = streamsEntries.iterator();
1156        while (groupsArray.hasNext()) {
1157          List&lt;Object&gt; groupInfo = (List&lt;Object&gt;) groupsArray.next();
1158          Iterator&lt;Object&gt; consumerInfoIterator = groupInfo.iterator();
1159          StreamConsumersInfo streamGroupInfo = new StreamConsumersInfo(
1160              createMapFromDecodingFunctions(consumerInfoIterator, mappingFunctions));
1161          list.add(streamGroupInfo);
1162        }
1163        return list;
1164      }
1165      @Override
1166      public String toString() {
1167        return &quot;List&lt;StreamConsumersInfo&gt;&quot;;
1168      }
1169    };
1170    public static final Builder&lt;List&lt;StreamConsumerInfo&gt;&gt; STREAM_CONSUMER_INFO_LIST
1171        = new Builder&lt;List&lt;StreamConsumerInfo&gt;&gt;() {
1172      Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1173      private Map&lt;String, Builder&gt; createDecoderMap() {
1174        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1175        tempMappingFunctions.put(StreamConsumerInfo.NAME, STRING);
1176        tempMappingFunctions.put(StreamConsumerInfo.IDLE, LONG);
1177        tempMappingFunctions.put(StreamConsumerInfo.PENDING, LONG);
1178        return tempMappingFunctions;
1179      }
1180      @Override
1181      @SuppressWarnings(&quot;unchecked&quot;)
1182      public List&lt;StreamConsumerInfo&gt; build(Object data) {
1183        if (null == data) {
1184          return null;
1185        }
1186        List&lt;StreamConsumerInfo&gt; list = new ArrayList&lt;&gt;();
1187        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1188        Iterator&lt;Object&gt; groupsArray = streamsEntries.iterator();
1189        while (groupsArray.hasNext()) {
1190          List&lt;Object&gt; groupInfo = (List&lt;Object&gt;) groupsArray.next();
1191          Iterator&lt;Object&gt; consumerInfoIterator = groupInfo.iterator();
1192          StreamConsumerInfo streamConsumerInfo = new StreamConsumerInfo(
1193              createMapFromDecodingFunctions(consumerInfoIterator, mappingFunctions));
1194          list.add(streamConsumerInfo);
1195        }
1196        return list;
1197      }
1198      @Override
1199      public String toString() {
1200        return &quot;List&lt;StreamConsumerInfo&gt;&quot;;
1201      }
1202    };
1203    private static final Builder&lt;List&lt;StreamConsumerFullInfo&gt;&gt; STREAM_CONSUMER_FULL_INFO_LIST
1204        = new Builder&lt;List&lt;StreamConsumerFullInfo&gt;&gt;() {
1205      final Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1206      private Map&lt;String, Builder&gt; createDecoderMap() {
1207        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1208        tempMappingFunctions.put(StreamConsumerFullInfo.NAME, STRING);
1209        tempMappingFunctions.put(StreamConsumerFullInfo.SEEN_TIME, LONG);
1210        tempMappingFunctions.put(StreamConsumerFullInfo.PEL_COUNT, LONG);
1211        tempMappingFunctions.put(StreamConsumerFullInfo.PENDING, ENCODED_OBJECT_LIST);
1212        return tempMappingFunctions;
1213      }
1214      @Override
1215      @SuppressWarnings(&quot;unchecked&quot;)
1216      public List&lt;StreamConsumerFullInfo&gt; build(Object data) {
1217        if (null == data) {
1218          return null;
1219        }
1220        List&lt;StreamConsumerFullInfo&gt; list = new ArrayList&lt;&gt;();
1221        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1222        for (Object streamsEntry : streamsEntries) {
1223          List&lt;Object&gt; consumerInfoList = (List&lt;Object&gt;) streamsEntry;
1224          Iterator&lt;Object&gt; consumerInfoIterator = consumerInfoList.iterator();
1225          StreamConsumerFullInfo consumerInfo = new StreamConsumerFullInfo(
1226              createMapFromDecodingFunctions(consumerInfoIterator, mappingFunctions));
1227          list.add(consumerInfo);
1228        }
1229        return list;
1230      }
1231      @Override
1232      public String toString() {
1233        return &quot;List&lt;StreamConsumerFullInfo&gt;&quot;;
1234      }
1235    };
1236    private static final Builder&lt;List&lt;StreamGroupFullInfo&gt;&gt; STREAM_GROUP_FULL_INFO_LIST
1237        = new Builder&lt;List&lt;StreamGroupFullInfo&gt;&gt;() {
1238      final Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1239      private Map&lt;String, Builder&gt; createDecoderMap() {
1240        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1241        tempMappingFunctions.put(StreamGroupFullInfo.NAME, STRING);
1242        tempMappingFunctions.put(StreamGroupFullInfo.CONSUMERS, STREAM_CONSUMER_FULL_INFO_LIST);
1243        tempMappingFunctions.put(StreamGroupFullInfo.PENDING, ENCODED_OBJECT_LIST);
1244        tempMappingFunctions.put(StreamGroupFullInfo.LAST_DELIVERED, STREAM_ENTRY_ID);
1245        tempMappingFunctions.put(StreamGroupFullInfo.PEL_COUNT, LONG);
1246        return tempMappingFunctions;
1247      }
1248      @Override
1249      @SuppressWarnings(&quot;unchecked&quot;)
1250      public List&lt;StreamGroupFullInfo&gt; build(Object data) {
1251        if (null == data) {
1252          return null;
1253        }
1254        List&lt;StreamGroupFullInfo&gt; list = new ArrayList&lt;&gt;();
1255        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1256        for (Object streamsEntry : streamsEntries) {
1257          List&lt;Object&gt; groupInfo = (List&lt;Object&gt;) streamsEntry;
1258          Iterator&lt;Object&gt; groupInfoIterator = groupInfo.iterator();
1259          StreamGroupFullInfo groupFullInfo = new StreamGroupFullInfo(
1260              createMapFromDecodingFunctions(groupInfoIterator, mappingFunctions));
1261          list.add(groupFullInfo);
1262        }
1263        return list;
1264      }
1265      @Override
1266      public String toString() {
1267        return &quot;List&lt;StreamGroupFullInfo&gt;&quot;;
1268      }
1269    };
1270    public static final Builder&lt;StreamFullInfo&gt; STREAM_FULL_INFO = new Builder&lt;StreamFullInfo&gt;() {
1271      final Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1272      private Map&lt;String, Builder&gt; createDecoderMap() {
1273        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1274        tempMappingFunctions.put(StreamFullInfo.LAST_GENERATED_ID, STREAM_ENTRY_ID);
1275        tempMappingFunctions.put(StreamFullInfo.LENGTH, LONG);
1276        tempMappingFunctions.put(StreamFullInfo.RADIX_TREE_KEYS, LONG);
1277        tempMappingFunctions.put(StreamFullInfo.RADIX_TREE_NODES, LONG);
1278        tempMappingFunctions.put(StreamFullInfo.GROUPS, STREAM_GROUP_FULL_INFO_LIST);
1279        tempMappingFunctions.put(StreamFullInfo.ENTRIES, STREAM_ENTRY_LIST);
1280        return tempMappingFunctions;
1281      }
1282      @Override
1283      @SuppressWarnings(&quot;unchecked&quot;)
1284      public StreamFullInfo build(Object data) {
1285        if (null == data) {
1286          return null;
1287        }
1288        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1289        Iterator&lt;Object&gt; iterator = streamsEntries.iterator();
1290        return new StreamFullInfo(createMapFromDecodingFunctions(iterator, mappingFunctions));
1291      }
1292      @Override
1293      public String toString() {
1294        return &quot;StreamFullInfo&quot;;
1295      }
1296    };
1297    @Deprecated
1298    public static final Builder&lt;StreamFullInfo&gt; STREAM_INFO_FULL = STREAM_FULL_INFO;
1299    public static final Builder&lt;StreamPendingSummary&gt; STREAM_PENDING_SUMMARY = new Builder&lt;StreamPendingSummary&gt;() {
1300      @Override
1301      @SuppressWarnings(&quot;unchecked&quot;)
1302      public StreamPendingSummary build(Object data) {
1303        if (null == data) {
1304          return null;
1305        }
1306        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
1307        long total = BuilderFactory.LONG.build(objectList.get(0));
1308        String minId = SafeEncoder.encode((byte[]) objectList.get(1));
1309        String maxId = SafeEncoder.encode((byte[]) objectList.get(2));
1310        List&lt;List&lt;Object&gt;&gt; consumerObjList = (List&lt;List&lt;Object&gt;&gt;) objectList.get(3);
1311        Map&lt;String, Long&gt; map = new HashMap&lt;&gt;(consumerObjList.size());
1312        for (List&lt;Object&gt; consumerObj : consumerObjList) {
1313          map.put(SafeEncoder.encode((byte[]) consumerObj.get(0)), Long.parseLong(SafeEncoder.encode((byte[]) consumerObj.get(1))));
1314        }
1315        return new StreamPendingSummary(total, new StreamEntryID(minId), new StreamEntryID(maxId), map);
1316      }
1317      @Override
1318      public String toString() {
1319        return &quot;StreamPendingSummary&quot;;
1320      }
1321    };
1322    private static final List&lt;Builder&gt; BACKUP_BUILDERS_FOR_DECODING_FUNCTIONS
1323        = Arrays.asList(STRING, LONG, DOUBLE);
1324    private static Map&lt;String, Object&gt; createMapFromDecodingFunctions(Iterator&lt;Object&gt; iterator,
1325        Map&lt;String, Builder&gt; mappingFunctions) {
1326      return createMapFromDecodingFunctions(iterator, mappingFunctions, null);
1327    }
1328    private static Map&lt;String, Object&gt; createMapFromDecodingFunctions(Iterator&lt;Object&gt; iterator,
1329        Map&lt;String, Builder&gt; mappingFunctions, Collection&lt;Builder&gt; backupBuilders) {
1330      if (!iterator.hasNext()) {
1331        return Collections.emptyMap();
1332      }
1333      Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;();
1334      while (iterator.hasNext()) {
1335        final Object tempObject = iterator.next();
1336        final String mapKey;
1337        final Object rawValue;
1338        if (tempObject instanceof KeyValue) {
1339          KeyValue kv = (KeyValue) tempObject;
1340          mapKey = STRING.build(kv.getKey());
1341          rawValue = kv.getValue();
1342        } else {
1343          mapKey = STRING.build(tempObject);
1344          rawValue = iterator.next();
1345        }
1346        if (mappingFunctions.containsKey(mapKey)) {
1347          resultMap.put(mapKey, mappingFunctions.get(mapKey).build(rawValue));
1348        } else { 
1349          Collection&lt;Builder&gt; builders = backupBuilders != null ? backupBuilders : mappingFunctions.values();
1350          for (Builder b : builders) {
1351            try {
1352              resultMap.put(mapKey, b.build(rawValue));
1353              break;
1354            } catch (ClassCastException e) {
1355            }
1356          }
1357        }
1358      }
1359      return resultMap;
1360    }
1361    public static final Builder&lt;LCSMatchResult&gt; STR_ALGO_LCS_RESULT_BUILDER = new Builder&lt;LCSMatchResult&gt;() {
1362      @Override
1363      public LCSMatchResult build(Object data) {
1364        if (data == null) {
1365          return null;
1366        }
1367        if (data instanceof byte[]) {
1368          return new LCSMatchResult(STRING.build(data));
1369        } else if (data instanceof Long) {
1370          return new LCSMatchResult(LONG.build(data));
1371        } else {
1372          long len = 0;
1373          List&lt;MatchedPosition&gt; matchedPositions = new ArrayList&lt;&gt;();
1374          List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
1375          if (objectList.get(0) instanceof KeyValue) {
1376            Iterator iterator = objectList.iterator();
1377            while (iterator.hasNext()) {
1378              KeyValue kv = (KeyValue) iterator.next();
1379              if (&quot;matches&quot;.equalsIgnoreCase(STRING.build(kv.getKey()))) {
1380                addMatchedPosition(matchedPositions, kv.getValue());
1381              } else if (&quot;len&quot;.equalsIgnoreCase(STRING.build(kv.getKey()))) {
1382                len = LONG.build(kv.getValue());
1383              }
1384            }
1385          } else {
1386            for (int i = 0; i &lt; objectList.size(); i += 2) {
1387              if (&quot;matches&quot;.equalsIgnoreCase(STRING.build(objectList.get(i)))) {
1388                addMatchedPosition(matchedPositions, objectList.get(i + 1));
1389              } else if (&quot;len&quot;.equalsIgnoreCase(STRING.build(objectList.get(i)))) {
1390                len = LONG.build(objectList.get(i + 1));
1391              }
1392            }
1393          }
1394          return new LCSMatchResult(matchedPositions, len);
1395        }
1396      }
1397      private void addMatchedPosition(List&lt;MatchedPosition&gt; matchedPositions, Object o) {
1398        List&lt;Object&gt; matches = (List&lt;Object&gt;) o;
1399        for (Object obj : matches) {
1400          if (obj instanceof List&lt;?&gt;) {
1401            List&lt;Object&gt; positions = (List&lt;Object&gt;) obj;
1402            Position a = new Position(
1403                LONG.build(((List&lt;Object&gt;) positions.get(0)).get(0)),
1404                LONG.build(((List&lt;Object&gt;) positions.get(0)).get(1))
1405            );
1406            Position b = new Position(
1407                LONG.build(((List&lt;Object&gt;) positions.get(1)).get(0)),
1408                LONG.build(((List&lt;Object&gt;) positions.get(1)).get(1))
1409            );
1410            long matchLen = 0;
1411            if (positions.size() &gt;= 3) {
1412              matchLen = LONG.build(positions.get(2));
1413            }
1414            matchedPositions.add(new MatchedPosition(a, b, matchLen));
1415          }
1416        }
1417      }
1418    };
1419    public static final Builder&lt;Map&lt;String, String&gt;&gt; STRING_MAP_FROM_PAIRS = new Builder&lt;Map&lt;String, String&gt;&gt;() {
1420      @Override
1421      @SuppressWarnings(&quot;unchecked&quot;)
1422      public Map&lt;String, String&gt; build(Object data) {
1423        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
1424        final Map&lt;String, String&gt; map = new HashMap&lt;&gt;(list.size());
1425        for (Object object : list) {
1426          if (object == null) continue;
1427          final List&lt;Object&gt; flat = (List&lt;Object&gt;) object;
1428          if (flat.isEmpty()) continue;
1429          map.put(STRING.build(flat.get(0)), STRING.build(flat.get(1)));
1430        }
1431        return map;
1432      }
1433      @Override
1434      public String toString() {
1435        return &quot;Map&lt;String, String&gt;&quot;;
1436      }
1437    };
1438    public static final Builder&lt;List&lt;LibraryInfo&gt;&gt; LIBRARY_LIST = new Builder&lt;List&lt;LibraryInfo&gt;&gt;() {
1439      @Override
1440      public List&lt;LibraryInfo&gt; build(Object data) {
1441        List&lt;Object&gt; list = (List&lt;Object&gt;) data;
1442        return list.stream().map(o -&gt; LibraryInfo.LIBRARY_BUILDER.build(o)).collect(Collectors.toList());
1443      }
1444    };
1445    public static final Builder&lt;List&lt;List&lt;String&gt;&gt;&gt; STRING_LIST_LIST = new Builder&lt;List&lt;List&lt;String&gt;&gt;&gt;() {
1446      @Override
1447      @SuppressWarnings(&quot;unchecked&quot;)
1448      public List&lt;List&lt;String&gt;&gt; build(Object data) {
1449        if (null == data) return null;
1450        return ((List&lt;Object&gt;) data).stream().map(STRING_LIST::build).collect(Collectors.toList());
1451      }
1452      @Override
1453      public String toString() {
1454        return &quot;List&lt;List&lt;String&gt;&gt;&quot;;
1455      }
1456    };
1457    public static final Builder&lt;List&lt;List&lt;Object&gt;&gt;&gt; ENCODED_OBJECT_LIST_LIST = new Builder&lt;List&lt;List&lt;Object&gt;&gt;&gt;() {
1458      @Override
1459      @SuppressWarnings(&quot;unchecked&quot;)
1460      public List&lt;List&lt;Object&gt;&gt; build(Object data) {
1461        if (null == data) return null;
1462        return ((List&lt;Object&gt;) data).stream().map(ENCODED_OBJECT_LIST::build).collect(Collectors.toList());
1463      }
1464      @Override
1465      public String toString() {
1466        return &quot;List&lt;List&lt;Object&gt;&gt;&quot;;
1467      }
1468    };
1469    protected static class SetFromList&lt;E&gt; extends AbstractSet&lt;E&gt; implements Serializable {
1470      private static final long serialVersionUID = -2850347066962734052L;
1471      private final List&lt;E&gt; list;
1472      private SetFromList(List&lt;E&gt; list) {
1473        this.list = list;
1474      }
1475      @Override
1476      public void clear() {
1477        list.clear();
1478      }
1479      @Override
1480      public int size() {
1481        return list.size();
1482      }
1483      @Override
1484      public boolean isEmpty() {
1485        return list.isEmpty();
1486      }
1487      @Override
1488      public boolean contains(Object o) {
1489        return list.contains(o);
1490      }
1491      @Override
1492      public boolean remove(Object o) {
1493        return list.remove(o);
1494      }
1495      @Override
1496      public boolean add(E e) {
1497        return !contains(e) &amp;&amp; list.add(e);
1498      }
1499      @Override
1500      public Iterator&lt;E&gt; iterator() {
1501        return list.iterator();
1502      }
1503      @Override
1504      public Object[] toArray() {
1505        return list.toArray();
1506      }
1507      @Override
1508      public &lt;T&gt; T[] toArray(T[] a) {
1509        return list.toArray(a);
1510      }
1511      @Override
1512      public String toString() {
1513        return list.toString();
1514      }
1515      @Override
1516      public int hashCode() {
1517        return list.hashCode();
1518      }
1519      @Override
1520      public boolean equals(Object o) {
1521        if (o == null) return false;
1522        if (o == this) return true;
1523        if (!(o instanceof Set)) return false;
1524        Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
1525        if (c.size() != size()) {
1526          return false;
1527        }
1528        return containsAll(c);
1529      }
1530      @Override
1531      public boolean containsAll(Collection&lt;?&gt; c) {
1532        return list.containsAll(c);
1533      }
1534      @Override
1535      public boolean removeAll(Collection&lt;?&gt; c) {
1536        return list.removeAll(c);
1537      }
1538      @Override
1539      public boolean retainAll(Collection&lt;?&gt; c) {
1540        return list.retainAll(c);
1541      }
1542      protected static &lt;E&gt; SetFromList&lt;E&gt; of(List&lt;E&gt; list) {
1543        if (list == null) {
1544          return null;
1545        }
1546        return new SetFromList&lt;&gt;(list);
1547      }
1548    }
1549    private BuilderFactory() {
1550      throw new InstantiationError(&quot;Must not instantiate this class&quot;);
1551    }
1552  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-BuilderFactory.java</h3>
            <pre><code>1  package redis.clients.jedis;
2  import java.io.Serializable;
3  import java.util.*;
4  import java.util.stream.Collectors;
5  import redis.clients.jedis.exceptions.JedisDataException;
6  import redis.clients.jedis.resps.*;
7  import redis.clients.jedis.resps.LCSMatchResult.MatchedPosition;
8  import redis.clients.jedis.resps.LCSMatchResult.Position;
9  import redis.clients.jedis.util.DoublePrecision;
10  import redis.clients.jedis.util.JedisByteHashMap;
11  import redis.clients.jedis.util.KeyValue;
12  import redis.clients.jedis.util.SafeEncoder;
13  public final class BuilderFactory {
14    public static final Builder&lt;Object&gt; RAW_OBJECT = new Builder&lt;Object&gt;() {
15      @Override
16      public Object build(Object data) {
17        return data;
18      }
19      @Override
20      public String toString() {
21        return &quot;Object&quot;;
22      }
23    };
24    public static final Builder&lt;List&lt;Object&gt;&gt; RAW_OBJECT_LIST = new Builder&lt;List&lt;Object&gt;&gt;() {
25      @Override
26      public List&lt;Object&gt; build(Object data) {
27        return (List&lt;Object&gt;) data;
28      }
29      @Override
30      public String toString() {
31        return &quot;List&lt;Object&gt;&quot;;
32      }
33    };
34    public static final Builder&lt;Object&gt; ENCODED_OBJECT = new Builder&lt;Object&gt;() {
35      @Override
36      public Object build(Object data) {
37        return SafeEncoder.encodeObject(data);
38      }
39      @Override
40      public String toString() {
41        return &quot;Object&quot;;
42      }
43    };
44    public static final Builder&lt;List&lt;Object&gt;&gt; ENCODED_OBJECT_LIST = new Builder&lt;List&lt;Object&gt;&gt;() {
45      @Override
46      public List&lt;Object&gt; build(Object data) {
47        return (List&lt;Object&gt;) SafeEncoder.encodeObject(data);
48      }
49      @Override
50      public String toString() {
51        return &quot;List&lt;Object&gt;&quot;;
52      }
53    };
54    public static final Builder&lt;Long&gt; LONG = new Builder&lt;Long&gt;() {
55      @Override
56      public Long build(Object data) {
57        return (Long) data;
58      }
59      @Override
60      public String toString() {
61        return &quot;Long&quot;;
62      }
63    };
64    public static final Builder&lt;List&lt;Long&gt;&gt; LONG_LIST = new Builder&lt;List&lt;Long&gt;&gt;() {
65      @Override
66      @SuppressWarnings(&quot;unchecked&quot;)
67      public List&lt;Long&gt; build(Object data) {
68        if (null == data) {
69          return null;
70        }
71        return (List&lt;Long&gt;) data;
72      }
73      @Override
74      public String toString() {
75        return &quot;List&lt;Long&gt;&quot;;
76      }
77    };
78    public static final Builder&lt;Double&gt; DOUBLE = new Builder&lt;Double&gt;() {
79      @Override
80      public Double build(Object data) {
81        if (data == null) return null;
82        else if (data instanceof Double) return (Double) data;
83        else return DoublePrecision.parseFloatingPointNumber(STRING.build(data));
84      }
85      @Override
86      public String toString() {
87        return &quot;Double&quot;;
88      }
89    };
90    public static final Builder&lt;List&lt;Double&gt;&gt; DOUBLE_LIST = new Builder&lt;List&lt;Double&gt;&gt;() {
91      @Override
92      @SuppressWarnings(&quot;unchecked&quot;)
93      public List&lt;Double&gt; build(Object data) {
94        if (null == data) return null;
95        return ((List&lt;Object&gt;) data).stream().map(DOUBLE::build).collect(Collectors.toList());
96      }
97      @Override
98      public String toString() {
99        return &quot;List&lt;Double&gt;&quot;;
100      }
101    };
102    public static final Builder&lt;Boolean&gt; BOOLEAN = new Builder&lt;Boolean&gt;() {
103      @Override
104      public Boolean build(Object data) {
105        if (data == null) return null;
106        else if (data instanceof Boolean) return (Boolean) data;
107        return ((Long) data) == 1L;
108      }
109      @Override
110      public String toString() {
111        return &quot;Boolean&quot;;
112      }
113    };
114    public static final Builder&lt;List&lt;Boolean&gt;&gt; BOOLEAN_LIST = new Builder&lt;List&lt;Boolean&gt;&gt;() {
115      @Override
116      @SuppressWarnings(&quot;unchecked&quot;)
117      public List&lt;Boolean&gt; build(Object data) {
118        if (null == data) return null;
119        return ((List&lt;Object&gt;) data).stream().map(BOOLEAN::build).collect(Collectors.toList());
120      }
121      @Override
122      public String toString() {
123        return &quot;List&lt;Boolean&gt;&quot;;
124      }
125    };
126    public static final Builder&lt;List&lt;Boolean&gt;&gt; BOOLEAN_WITH_ERROR_LIST = new Builder&lt;List&lt;Boolean&gt;&gt;() {
127      @Override
128      @SuppressWarnings(&quot;unchecked&quot;)
129      public List&lt;Boolean&gt; build(Object data) {
130        if (null == data) return null;
131        return ((List&lt;Object&gt;) data).stream()
132            .map((val) -&gt; (val instanceof JedisDataException) ? null : BOOLEAN.build(val))
133            .collect(Collectors.toList());
134      }
135      @Override
136      public String toString() {
137        return &quot;List&lt;Boolean&gt;&quot;;
138      }
139    };
140    public static final Builder&lt;byte[]&gt; BINARY = new Builder&lt;byte[]&gt;() {
141      @Override
142      public byte[] build(Object data) {
143        return (byte[]) data;
144      }
145      @Override
146      public String toString() {
147        return &quot;byte[]&quot;;
148      }
149    };
150    public static final Builder&lt;List&lt;byte[]&gt;&gt; BINARY_LIST = new Builder&lt;List&lt;byte[]&gt;&gt;() {
151      @Override
152      @SuppressWarnings(&quot;unchecked&quot;)
153      public List&lt;byte[]&gt; build(Object data) {
154        return (List&lt;byte[]&gt;) data;
155      }
156      @Override
157      public String toString() {
158        return &quot;List&lt;byte[]&gt;&quot;;
159      }
160    };
161    public static final Builder&lt;Set&lt;byte[]&gt;&gt; BINARY_SET = new Builder&lt;Set&lt;byte[]&gt;&gt;() {
162      @Override
163      @SuppressWarnings(&quot;unchecked&quot;)
164      public Set&lt;byte[]&gt; build(Object data) {
165        if (null == data) {
166          return null;
167        }
168        List&lt;byte[]&gt; l = BINARY_LIST.build(data);
169        return SetFromList.of(l);
170      }
171      @Override
172      public String toString() {
173        return &quot;Set&lt;byte[]&gt;&quot;;
174      }
175    };
176    public static final Builder&lt;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt; BINARY_PAIR_LIST
177        = new Builder&lt;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt;() {
178      @Override
179      @SuppressWarnings(&quot;unchecked&quot;)
180      public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; build(Object data) {
181        final List&lt;byte[]&gt; flatHash = (List&lt;byte[]&gt;) data;
182        final List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; pairList = new ArrayList&lt;&gt;();
183        final Iterator&lt;byte[]&gt; iterator = flatHash.iterator();
184        while (iterator.hasNext()) {
185          pairList.add(new AbstractMap.SimpleEntry&lt;&gt;(iterator.next(), iterator.next()));
186        }
187        return pairList;
188      }
189      @Override
190      public String toString() {
191        return &quot;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&quot;;
192      }
193    };
194    public static final Builder&lt;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt; BINARY_PAIR_LIST_FROM_PAIRS
195        = new Builder&lt;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt;() {
196      @Override
197      @SuppressWarnings(&quot;unchecked&quot;)
198      public List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; build(Object data) {
199        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
200        final List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; pairList = new ArrayList&lt;&gt;();
201        for (Object object : list) {
202          final List&lt;byte[]&gt; flat = (List&lt;byte[]&gt;) object;
203          pairList.add(new AbstractMap.SimpleEntry&lt;&gt;(flat.get(0), flat.get(1)));
204        }
205        return pairList;
206      }
207      @Override
208      public String toString() {
209        return &quot;List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&quot;;
210      }
211    };
212    public static final Builder&lt;String&gt; STRING = new Builder&lt;String&gt;() {
213      @Override
214      public String build(Object data) {
215        return data == null ? null : SafeEncoder.encode((byte[]) data);
216      }
217      @Override
218      public String toString() {
219        return &quot;String&quot;;
220      }
221    };
222    public static final Builder&lt;List&lt;String&gt;&gt; STRING_LIST = new Builder&lt;List&lt;String&gt;&gt;() {
223      @Override
224      @SuppressWarnings(&quot;unchecked&quot;)
225      public List&lt;String&gt; build(Object data) {
226        if (null == data) return null;
227        return ((List&lt;Object&gt;) data).stream().map(STRING::build).collect(Collectors.toList());
228      }
229      @Override
230      public String toString() {
231        return &quot;List&lt;String&gt;&quot;;
232      }
233    };
234    public static final Builder&lt;Set&lt;String&gt;&gt; STRING_SET = new Builder&lt;Set&lt;String&gt;&gt;() {
235      @Override
236      @SuppressWarnings(&quot;unchecked&quot;)
237      public Set&lt;String&gt; build(Object data) {
238        if (null == data) return null;
239        return ((List&lt;Object&gt;) data).stream().map(STRING::build).collect(Collectors.toSet());
240      }
241      @Override
242      public String toString() {
243        return &quot;Set&lt;String&gt;&quot;;
244      }
245    };
246    public static final Builder&lt;Map&lt;String, Object&gt;&gt; ENCODED_OBJECT_MAP = new Builder&lt;Map&lt;String, Object&gt;&gt;() {
247      @Override
248      public Map&lt;String, Object&gt; build(Object data) {
249        if (data == null) return null;
250        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
251        if (list.isEmpty()) return Collections.emptyMap();
252        if (list.get(0) instanceof KeyValue) {
253          final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(list.size(), 1f);
254          final Iterator iterator = list.iterator();
255          while (iterator.hasNext()) {
256            KeyValue kv = (KeyValue) iterator.next();
257            map.put(STRING.build(kv.getKey()), ENCODED_OBJECT.build(kv.getValue()));
258          }
259          return map;
260        } else {
261          final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(list.size() / 2, 1f);
262          final Iterator iterator = list.iterator();
263          while (iterator.hasNext()) {
264            map.put(STRING.build(iterator.next()), ENCODED_OBJECT.build(iterator.next()));
265          }
266          return map;
267        }
268      }
269    };
270    public static final Builder&lt;Map&lt;byte[], byte[]&gt;&gt; BINARY_MAP = new Builder&lt;Map&lt;byte[], byte[]&gt;&gt;() {
271      @Override
272      @SuppressWarnings(&quot;unchecked&quot;)
273      public Map&lt;byte[], byte[]&gt; build(Object data) {
274        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
275        if (list.isEmpty()) return Collections.emptyMap();
276        if (list.get(0) instanceof KeyValue) {
277          final Map&lt;byte[], byte[]&gt; map = new JedisByteHashMap();
278          final Iterator iterator = list.iterator();
279          while (iterator.hasNext()) {
280            KeyValue kv = (KeyValue) iterator.next();
281            map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));
282          }
283          return map;
284        } else {
285          final Map&lt;byte[], byte[]&gt; map = new JedisByteHashMap();
286          final Iterator iterator = list.iterator();
287          while (iterator.hasNext()) {
288            map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));
289          }
290          return map;
291        }
292      }
293      @Override
294      public String toString() {
295        return &quot;Map&lt;byte[], byte[]&gt;&quot;;
296      }
297    };
298    public static final Builder&lt;Map&lt;String, String&gt;&gt; STRING_MAP = new Builder&lt;Map&lt;String, String&gt;&gt;() {
299      @Override
300      @SuppressWarnings(&quot;unchecked&quot;)
301      public Map&lt;String, String&gt; build(Object data) {
302        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
303        if (list.isEmpty()) return Collections.emptyMap();
304        if (list.get(0) instanceof KeyValue) {
305          final Map&lt;String, String&gt; map = new HashMap&lt;&gt;(list.size(), 1f);
306          final Iterator iterator = list.iterator();
307          while (iterator.hasNext()) {
308            KeyValue kv = (KeyValue) iterator.next();
309            map.put(STRING.build(kv.getKey()), STRING.build(kv.getValue()));
310          }
311          return map;
312        } else {
313          final Map&lt;String, String&gt; map = new HashMap&lt;&gt;(list.size() / 2, 1f);
314          final Iterator iterator = list.iterator();
315          while (iterator.hasNext()) {
316            map.put(STRING.build(iterator.next()), STRING.build(iterator.next()));
317          }
318          return map;
319        }
320      }
321      @Override
322      public String toString() {
323        return &quot;Map&lt;String, String&gt;&quot;;
324      }
325    };
326    public static final Builder&lt;List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; STRING_PAIR_LIST
327        = new Builder&lt;List&lt;Map.Entry&lt;String, String&gt;&gt;&gt;() {
328      @Override
329      @SuppressWarnings(&quot;unchecked&quot;)
330      public List&lt;Map.Entry&lt;String, String&gt;&gt; build(Object data) {
331        final List&lt;byte[]&gt; flatHash = (List&lt;byte[]&gt;) data;
332        final List&lt;Map.Entry&lt;String, String&gt;&gt; pairList = new ArrayList&lt;&gt;(flatHash.size() / 2);
333        final Iterator&lt;byte[]&gt; iterator = flatHash.iterator();
334        while (iterator.hasNext()) {
335          pairList.add(KeyValue.of(STRING.build(iterator.next()), STRING.build(iterator.next())));
336        }
337        return pairList;
338      }
339      @Override
340      public String toString() {
341        return &quot;List&lt;Map.Entry&lt;String, String&gt;&gt;&quot;;
342      }
343    };
344    public static final Builder&lt;List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; STRING_PAIR_LIST_FROM_PAIRS
345        = new Builder&lt;List&lt;Map.Entry&lt;String, String&gt;&gt;&gt;() {
346      @Override
347      @SuppressWarnings(&quot;unchecked&quot;)
348      public List&lt;Map.Entry&lt;String, String&gt;&gt; build(Object data) {
349        return ((List&lt;Object&gt;) data).stream().map(o -&gt; (List&lt;Object&gt;) o)
350            .map(l -&gt; KeyValue.of(STRING.build(l.get(0)), STRING.build(l.get(1))))
351            .collect(Collectors.toList());
352      }
353      @Override
354      public String toString() {
355        return &quot;List&lt;Map.Entry&lt;String, String&gt;&gt;&quot;;
356      }
357    };
358    public static final Builder&lt;KeyValue&lt;String, String&gt;&gt; KEYED_ELEMENT = new Builder&lt;KeyValue&lt;String, String&gt;&gt;() {
359      @Override
360      @SuppressWarnings(&quot;unchecked&quot;)
361      public KeyValue&lt;String, String&gt; build(Object data) {
362        if (data == null) return null;
363        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
364        return KeyValue.of(STRING.build(l.get(0)), STRING.build(l.get(1)));
365      }
366      @Override
367      public String toString() {
368        return &quot;KeyValue&lt;String, String&gt;&quot;;
369      }
370    };
371    public static final Builder&lt;KeyValue&lt;byte[], byte[]&gt;&gt; BINARY_KEYED_ELEMENT = new Builder&lt;KeyValue&lt;byte[], byte[]&gt;&gt;() {
372      @Override
373      @SuppressWarnings(&quot;unchecked&quot;)
374      public KeyValue&lt;byte[], byte[]&gt; build(Object data) {
375        if (data == null) return null;
376        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
377        return KeyValue.of(BINARY.build(l.get(0)), BINARY.build(l.get(1)));
378      }
379      @Override
380      public String toString() {
381        return &quot;KeyValue&lt;byte[], byte[]&gt;&quot;;
382      }
383    };
384    public static final Builder&lt;KeyValue&lt;Long, Double&gt;&gt; ZRANK_WITHSCORE_PAIR = new Builder&lt;KeyValue&lt;Long, Double&gt;&gt;() {
385      @Override
386      public KeyValue&lt;Long, Double&gt; build(Object data) {
387        if (data == null) {
388          return null;
389        }
390        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
391        return new KeyValue&lt;&gt;(LONG.build(l.get(0)), DOUBLE.build(l.get(1)));
392      }
393      @Override
394      public String toString() {
395        return &quot;KeyValue&lt;Long, Double&gt;&quot;;
396      }
397    };
398    public static final Builder&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt; KEYED_STRING_LIST
399        = new Builder&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt;() {
400      @Override
401      @SuppressWarnings(&quot;unchecked&quot;)
402      public KeyValue&lt;String, List&lt;String&gt;&gt; build(Object data) {
403        if (data == null) return null;
404        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data;
405        return new KeyValue&lt;&gt;(STRING.build(l.get(0)), STRING_LIST.build(l.get(1)));
406      }
407      @Override
408      public String toString() {
409        return &quot;KeyValue&lt;String, List&lt;String&gt;&gt;&quot;;
410      }
411    };
412    public static final Builder&lt;KeyValue&lt;Long, Long&gt;&gt; LONG_LONG_PAIR = new Builder&lt;KeyValue&lt;Long, Long&gt;&gt;() {
413      @Override
414      @SuppressWarnings(&quot;unchecked&quot;)
415      public KeyValue&lt;Long, Long&gt; build(Object data) {
416        if (data == null) return null;
417        List&lt;Object&gt; dataList = (List&lt;Object&gt;) data;
418        return new KeyValue&lt;&gt;(LONG.build(dataList.get(0)), LONG.build(dataList.get(1)));
419      }
420    };
421    public static final Builder&lt;List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt;&gt; KEYED_STRING_LIST_LIST
422        = new Builder&lt;List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt;&gt;() {
423      @Override
424      public List&lt;KeyValue&lt;String, List&lt;String&gt;&gt;&gt; build(Object data) {
425        List&lt;Object&gt; list = (List&lt;Object&gt;) data;
426        return list.stream().map(KEYED_STRING_LIST::build).collect(Collectors.toList());
427      }
428    };
429    public static final Builder&lt;KeyValue&lt;byte[], List&lt;byte[]&gt;&gt;&gt; KEYED_BINARY_LIST
430        = new Builder&lt;KeyValue&lt;byte[], List&lt;byte[]&gt;&gt;&gt;() {
431      @Override
432      @SuppressWarnings(&quot;unchecked&quot;)
433      public KeyValue&lt;byte[], List&lt;byte[]&gt;&gt; build(Object data) {
434        if (data == null) return null;
435        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data;
436        return new KeyValue&lt;&gt;(BINARY.build(l.get(0)), BINARY_LIST.build(l.get(1)));
437      }
438      @Override
439      public String toString() {
440        return &quot;KeyValue&lt;byte[], List&lt;byte[]&gt;&gt;&quot;;
441      }
442    };
443    public static final Builder&lt;Tuple&gt; TUPLE = new Builder&lt;Tuple&gt;() {
444      @Override
445      @SuppressWarnings(&quot;unchecked&quot;)
446      public Tuple build(Object data) {
447        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data; 
448        if (l.isEmpty()) {
449          return null;
450        }
451        return new Tuple(l.get(0), DOUBLE.build(l.get(1)));
452      }
453      @Override
454      public String toString() {
455        return &quot;Tuple&quot;;
456      }
457    };
458    public static final Builder&lt;KeyValue&lt;String, Tuple&gt;&gt; KEYED_TUPLE = new Builder&lt;KeyValue&lt;String, Tuple&gt;&gt;() {
459      @Override
460      @SuppressWarnings(&quot;unchecked&quot;)
461      public KeyValue&lt;String, Tuple&gt; build(Object data) {
462        List&lt;Object&gt; l = (List&lt;Object&gt;) data; 
463        if (l.isEmpty()) {
464          return null;
465        }
466        return KeyValue.of(STRING.build(l.get(0)), new Tuple(BINARY.build(l.get(1)), DOUBLE.build(l.get(2))));
467      }
468      @Override
469      public String toString() {
470        return &quot;KeyValue&lt;String, Tuple&gt;&quot;;
471      }
472    };
473    public static final Builder&lt;KeyValue&lt;byte[], Tuple&gt;&gt; BINARY_KEYED_TUPLE = new Builder&lt;KeyValue&lt;byte[], Tuple&gt;&gt;() {
474      @Override
475      @SuppressWarnings(&quot;unchecked&quot;)
476      public KeyValue&lt;byte[], Tuple&gt; build(Object data) {
477        List&lt;Object&gt; l = (List&lt;Object&gt;) data; 
478        if (l.isEmpty()) {
479          return null;
480        }
481        return KeyValue.of(BINARY.build(l.get(0)), new Tuple(BINARY.build(l.get(1)), DOUBLE.build(l.get(2))));
482      }
483      @Override
484      public String toString() {
485        return &quot;KeyValue&lt;byte[], Tuple&gt;&quot;;
486      }
487    };
488    public static final Builder&lt;List&lt;Tuple&gt;&gt; TUPLE_LIST = new Builder&lt;List&lt;Tuple&gt;&gt;() {
489      @Override
490      @SuppressWarnings(&quot;unchecked&quot;)
491      public List&lt;Tuple&gt; build(Object data) {
492        if (null == data) {
493          return null;
494        }
495        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data;
496        final List&lt;Tuple&gt; result = new ArrayList&lt;&gt;(l.size() / 2);
497        Iterator&lt;byte[]&gt; iterator = l.iterator();
498        while (iterator.hasNext()) {
499          result.add(new Tuple(iterator.next(), DOUBLE.build(iterator.next())));
500        }
501        return result;
502      }
503      @Override
504      public String toString() {
505        return &quot;List&lt;Tuple&gt;&quot;;
506      }
507    };
508    public static final Builder&lt;List&lt;Tuple&gt;&gt; TUPLE_LIST_RESP3 = new Builder&lt;List&lt;Tuple&gt;&gt;() {
509      @Override
510      @SuppressWarnings(&quot;unchecked&quot;)
511      public List&lt;Tuple&gt; build(Object data) {
512        if (null == data) return null;
513        return ((List&lt;Object&gt;) data).stream().map(TUPLE::build).collect(Collectors.toList());
514      }
515      @Override
516      public String toString() {
517        return &quot;List&lt;Tuple&gt;&quot;;
518      }
519    };
520    public static final Builder&lt;Set&lt;Tuple&gt;&gt; TUPLE_ZSET = new Builder&lt;Set&lt;Tuple&gt;&gt;() {
521      @Override
522      @SuppressWarnings(&quot;unchecked&quot;)
523      public Set&lt;Tuple&gt; build(Object data) {
524        if (null == data) {
525          return null;
526        }
527        List&lt;byte[]&gt; l = (List&lt;byte[]&gt;) data;
528        final Set&lt;Tuple&gt; result = new LinkedHashSet&lt;&gt;(l.size() / 2, 1);
529        Iterator&lt;byte[]&gt; iterator = l.iterator();
530        while (iterator.hasNext()) {
531          result.add(new Tuple(iterator.next(), DOUBLE.build(iterator.next())));
532        }
533        return result;
534      }
535      @Override
536      public String toString() {
537        return &quot;ZSet&lt;Tuple&gt;&quot;;
538      }
539    };
540    public static final Builder&lt;Set&lt;Tuple&gt;&gt; TUPLE_ZSET_RESP3 = new Builder&lt;Set&lt;Tuple&gt;&gt;() {
541      @Override
542      @SuppressWarnings(&quot;unchecked&quot;)
543      public Set&lt;Tuple&gt; build(Object data) {
544        if (null == data) return null;
545        return ((List&lt;Object&gt;) data).stream().map(TUPLE::build).collect(Collectors.toCollection(LinkedHashSet::new));
546      }
547      @Override
548      public String toString() {
549        return &quot;ZSet&lt;Tuple&gt;&quot;;
550      }
551    };
552    private static final Builder&lt;List&lt;Tuple&gt;&gt; TUPLE_LIST_FROM_PAIRS = new Builder&lt;List&lt;Tuple&gt;&gt;() {
553      @Override
554      @SuppressWarnings(&quot;unchecked&quot;)
555      public List&lt;Tuple&gt; build(Object data) {
556        if (data == null) return null;
557        return ((List&lt;List&lt;Object&gt;&gt;) data).stream().map(TUPLE::build).collect(Collectors.toList());
558      }
559      @Override
560      public String toString() {
561        return &quot;List&lt;Tuple&gt;&quot;;
562      }
563    };
564    public static final Builder&lt;KeyValue&lt;String, List&lt;Tuple&gt;&gt;&gt; KEYED_TUPLE_LIST
565        = new Builder&lt;KeyValue&lt;String, List&lt;Tuple&gt;&gt;&gt;() {
566      @Override
567      @SuppressWarnings(&quot;unchecked&quot;)
568      public KeyValue&lt;String, List&lt;Tuple&gt;&gt; build(Object data) {
569        if (data == null) return null;
570        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
571        return new KeyValue&lt;&gt;(STRING.build(l.get(0)), TUPLE_LIST_FROM_PAIRS.build(l.get(1)));
572      }
573      @Override
574      public String toString() {
575        return &quot;KeyValue&lt;String, List&lt;Tuple&gt;&gt;&quot;;
576      }
577    };
578    public static final Builder&lt;KeyValue&lt;byte[], List&lt;Tuple&gt;&gt;&gt; BINARY_KEYED_TUPLE_LIST
579        = new Builder&lt;KeyValue&lt;byte[], List&lt;Tuple&gt;&gt;&gt;() {
580      @Override
581      @SuppressWarnings(&quot;unchecked&quot;)
582      public KeyValue&lt;byte[], List&lt;Tuple&gt;&gt; build(Object data) {
583        if (data == null) return null;
584        List&lt;Object&gt; l = (List&lt;Object&gt;) data;
585        return new KeyValue&lt;&gt;(BINARY.build(l.get(0)), TUPLE_LIST_FROM_PAIRS.build(l.get(1)));
586      }
587      @Override
588      public String toString() {
589        return &quot;KeyValue&lt;byte[], List&lt;Tuple&gt;&gt;&quot;;
590      }
591    };
592    public static final Builder&lt;ScanResult&lt;String&gt;&gt; SCAN_RESPONSE = new Builder&lt;ScanResult&lt;String&gt;&gt;() {
593      @Override
594      public ScanResult&lt;String&gt; build(Object data) {
595        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
596        String newcursor = new String((byte[]) result.get(0));
597        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
598        List&lt;String&gt; results = new ArrayList&lt;&gt;(rawResults.size());
599        for (byte[] bs : rawResults) {
600          results.add(SafeEncoder.encode(bs));
601        }
602        return new ScanResult&lt;&gt;(newcursor, results);
603      }
604    };
605    public static final Builder&lt;ScanResult&lt;Map.Entry&lt;String, String&gt;&gt;&gt; HSCAN_RESPONSE
606        = new Builder&lt;ScanResult&lt;Map.Entry&lt;String, String&gt;&gt;&gt;() {
607      @Override
608      public ScanResult&lt;Map.Entry&lt;String, String&gt;&gt; build(Object data) {
609        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
610        String newcursor = new String((byte[]) result.get(0));
611        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
612        List&lt;Map.Entry&lt;String, String&gt;&gt; results = new ArrayList&lt;&gt;(rawResults.size() / 2);
613        Iterator&lt;byte[]&gt; iterator = rawResults.iterator();
614        while (iterator.hasNext()) {
615          results.add(new AbstractMap.SimpleEntry&lt;&gt;(SafeEncoder.encode(iterator.next()),
616              SafeEncoder.encode(iterator.next())));
617        }
618        return new ScanResult&lt;&gt;(newcursor, results);
619      }
620    };
621    public static final Builder&lt;ScanResult&lt;String&gt;&gt; SSCAN_RESPONSE = new Builder&lt;ScanResult&lt;String&gt;&gt;() {
622      @Override
623      public ScanResult&lt;String&gt; build(Object data) {
624        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
625        String newcursor = new String((byte[]) result.get(0));
626        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
627        List&lt;String&gt; results = new ArrayList&lt;&gt;(rawResults.size());
628        for (byte[] bs : rawResults) {
629          results.add(SafeEncoder.encode(bs));
630        }
631        return new ScanResult&lt;&gt;(newcursor, results);
632      }
633    };
634    public static final Builder&lt;ScanResult&lt;Tuple&gt;&gt; ZSCAN_RESPONSE = new Builder&lt;ScanResult&lt;Tuple&gt;&gt;() {
635      @Override
636      public ScanResult&lt;Tuple&gt; build(Object data) {
637        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
638        String newcursor = new String((byte[]) result.get(0));
639        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
640        List&lt;Tuple&gt; results = new ArrayList&lt;&gt;(rawResults.size() / 2);
641        Iterator&lt;byte[]&gt; iterator = rawResults.iterator();
642        while (iterator.hasNext()) {
643          results.add(new Tuple(iterator.next(), BuilderFactory.DOUBLE.build(iterator.next())));
644        }
645        return new ScanResult&lt;&gt;(newcursor, results);
646      }
647    };
648    public static final Builder&lt;ScanResult&lt;byte[]&gt;&gt; SCAN_BINARY_RESPONSE = new Builder&lt;ScanResult&lt;byte[]&gt;&gt;() {
649      @Override
650      public ScanResult&lt;byte[]&gt; build(Object data) {
651        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
652        byte[] newcursor = (byte[]) result.get(0);
653        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
654        return new ScanResult&lt;&gt;(newcursor, rawResults);
655      }
656    };
657    public static final Builder&lt;ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt; HSCAN_BINARY_RESPONSE
658        = new Builder&lt;ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt;&gt;() {
659      @Override
660      public ScanResult&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; build(Object data) {
661        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
662        byte[] newcursor = (byte[]) result.get(0);
663        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
664        List&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; results = new ArrayList&lt;&gt;(rawResults.size() / 2);
665        Iterator&lt;byte[]&gt; iterator = rawResults.iterator();
666        while (iterator.hasNext()) {
<span onclick='openModal()' class='match'>667          results.add(new AbstractMap.SimpleEntry&lt;&gt;(iterator.next(), iterator.next()));
668        }
669        return new ScanResult&lt;&gt;(newcursor, results);
</span>670      }
671    };
672    public static final Builder&lt;ScanResult&lt;byte[]&gt;&gt; SSCAN_BINARY_RESPONSE = new Builder&lt;ScanResult&lt;byte[]&gt;&gt;() {
673      @Override
674      public ScanResult&lt;byte[]&gt; build(Object data) {
675        List&lt;Object&gt; result = (List&lt;Object&gt;) data;
676        byte[] newcursor = (byte[]) result.get(0);
677        List&lt;byte[]&gt; rawResults = (List&lt;byte[]&gt;) result.get(1);
678        return new ScanResult&lt;&gt;(newcursor, rawResults);
679      }
680    };
681    public static final Builder&lt;Map&lt;String, Long&gt;&gt; PUBSUB_NUMSUB_MAP = new Builder&lt;Map&lt;String, Long&gt;&gt;() {
682      @Override
683      @SuppressWarnings(&quot;unchecked&quot;)
684      public Map&lt;String, Long&gt; build(Object data) {
685        final List&lt;Object&gt; flatHash = (List&lt;Object&gt;) data;
686        final Map&lt;String, Long&gt; hash = new HashMap&lt;&gt;(flatHash.size() / 2, 1f);
687        final Iterator&lt;Object&gt; iterator = flatHash.iterator();
688        while (iterator.hasNext()) {
689          hash.put(SafeEncoder.encode((byte[]) iterator.next()), (Long) iterator.next());
690        }
691        return hash;
692      }
693      @Override
694      public String toString() {
695        return &quot;PUBSUB_NUMSUB_MAP&lt;String, String&gt;&quot;;
696      }
697    };
698    public static final Builder&lt;List&lt;GeoCoordinate&gt;&gt; GEO_COORDINATE_LIST = new Builder&lt;List&lt;GeoCoordinate&gt;&gt;() {
699      @Override
700      public List&lt;GeoCoordinate&gt; build(Object data) {
701        if (null == data) {
702          return null;
703        }
704        return interpretGeoposResult((List&lt;Object&gt;) data);
705      }
706      @Override
707      public String toString() {
708        return &quot;List&lt;GeoCoordinate&gt;&quot;;
709      }
710      private List&lt;GeoCoordinate&gt; interpretGeoposResult(List&lt;Object&gt; responses) {
711        List&lt;GeoCoordinate&gt; responseCoordinate = new ArrayList&lt;&gt;(responses.size());
712        for (Object response : responses) {
713          if (response == null) {
714            responseCoordinate.add(null);
715          } else {
716            List&lt;Object&gt; respList = (List&lt;Object&gt;) response;
717            GeoCoordinate coord = new GeoCoordinate(DOUBLE.build(respList.get(0)),
718                DOUBLE.build(respList.get(1)));
719            responseCoordinate.add(coord);
720          }
721        }
722        return responseCoordinate;
723      }
724    };
725    public static final Builder&lt;List&lt;GeoRadiusResponse&gt;&gt; GEORADIUS_WITH_PARAMS_RESULT = new Builder&lt;List&lt;GeoRadiusResponse&gt;&gt;() {
726      @Override
727      public List&lt;GeoRadiusResponse&gt; build(Object data) {
728        if (data == null) {
729          return null;
730        }
731        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
732        List&lt;GeoRadiusResponse&gt; responses = new ArrayList&lt;&gt;(objectList.size());
733        if (objectList.isEmpty()) {
734          return responses;
735        }
736        if (objectList.get(0) instanceof List&lt;?&gt;) {
737          GeoRadiusResponse resp;
738          for (Object obj : objectList) {
739            List&lt;Object&gt; informations = (List&lt;Object&gt;) obj;
740            resp = new GeoRadiusResponse((byte[]) informations.get(0));
741            int size = informations.size();
742            for (int idx = 1; idx &lt; size; idx++) {
743              Object info = informations.get(idx);
744              if (info instanceof List&lt;?&gt;) {
745                List&lt;Object&gt; coord = (List&lt;Object&gt;) info;
746                resp.setCoordinate(new GeoCoordinate(DOUBLE.build(coord.get(0)),
747                    DOUBLE.build(coord.get(1))));
748              } else if (info instanceof Long) {
749                resp.setRawScore(LONG.build(info));
750              } else {
751                resp.setDistance(DOUBLE.build(info));
752              }
753            }
754            responses.add(resp);
755          }
756        } else {
757          for (Object obj : objectList) {
758            responses.add(new GeoRadiusResponse((byte[]) obj));
759          }
760        }
761        return responses;
762      }
763      @Override
764      public String toString() {
765        return &quot;GeoRadiusWithParamsResult&quot;;
766      }
767    };
768    public static final Builder&lt;Map&lt;String, CommandDocument&gt;&gt; COMMAND_DOCS_RESPONSE = new Builder&lt;Map&lt;String, CommandDocument&gt;&gt;() {
769      @Override
770      public Map&lt;String, CommandDocument&gt; build(Object data) {
771        if (data == null) return null;
772        List&lt;Object&gt; list = (List&lt;Object&gt;) data;
773        if (list.isEmpty()) return Collections.emptyMap();
774        if (list.get(0) instanceof KeyValue) {
775          final Map&lt;String, CommandDocument&gt; map = new HashMap&lt;&gt;(list.size(), 1f);
776          final Iterator iterator = list.iterator();
777          while (iterator.hasNext()) {
778            KeyValue kv = (KeyValue) iterator.next();
779            map.put(STRING.build(kv.getKey()), new CommandDocument(ENCODED_OBJECT_MAP.build(kv.getValue())));
780          }
781          return map;
782        } else {
783          final Map&lt;String, CommandDocument&gt; map = new HashMap&lt;&gt;(list.size() / 2, 1f);
784          final Iterator iterator = list.iterator();
785          while (iterator.hasNext()) {
786            map.put(STRING.build(iterator.next()), new CommandDocument(ENCODED_OBJECT_MAP.build(iterator.next())));
787          }
788          return map;
789        }
790      }
791    };
792    public static final Builder&lt;Map&lt;String, CommandInfo&gt;&gt; COMMAND_INFO_RESPONSE = new Builder&lt;Map&lt;String, CommandInfo&gt;&gt;() {
793      @Override
794      public Map&lt;String, CommandInfo&gt; build(Object data) {
795        if (data == null) {
796          return null;
797        }
798        List&lt;Object&gt; rawList = (List&lt;Object&gt;) data;
799        Map&lt;String, CommandInfo&gt; map = new HashMap&lt;&gt;(rawList.size());
800        for (Object rawCommandInfo : rawList) {
801          if (rawCommandInfo == null) {
802            continue;
803          }
804          List&lt;Object&gt; commandInfo = (List&lt;Object&gt;) rawCommandInfo;
805          String name = STRING.build(commandInfo.get(0));
806          CommandInfo info = CommandInfo.COMMAND_INFO_BUILDER.build(commandInfo);
807          map.put(name, info);
808        }
809        return map;
810      }
811    };
812    public static final Builder&lt;List&lt;Module&gt;&gt; MODULE_LIST = new Builder&lt;List&lt;Module&gt;&gt;() {
813      @Override
814      public List&lt;Module&gt; build(Object data) {
815        if (data == null) {
816          return null;
817        }
818        List&lt;List&lt;Object&gt;&gt; objectList = (List&lt;List&lt;Object&gt;&gt;) data;
819        List&lt;Module&gt; responses = new ArrayList&lt;&gt;(objectList.size());
820        if (objectList.isEmpty()) {
821          return responses;
822        }
823        for (List&lt;Object&gt; moduleResp : objectList) {
824          if (moduleResp.get(0) instanceof KeyValue) {
825            responses.add(new Module(STRING.build(((KeyValue) moduleResp.get(0)).getValue()),
826                LONG.build(((KeyValue) moduleResp.get(1)).getValue()).intValue()));
827            continue;
828          }
829          Module m = new Module(SafeEncoder.encode((byte[]) moduleResp.get(1)),
830              ((Long) moduleResp.get(3)).intValue());
831          responses.add(m);
832        }
833        return responses;
834      }
835      @Override
836      public String toString() {
837        return &quot;List&lt;Module&gt;&quot;;
838      }
839    };
840    public static final Builder&lt;AccessControlUser&gt; ACCESS_CONTROL_USER = new Builder&lt;AccessControlUser&gt;() {
841      @Override
842      public AccessControlUser build(Object data) {
843        Map&lt;String, Object&gt; map = ENCODED_OBJECT_MAP.build(data);
844        if (map == null) return null;
845        return new AccessControlUser(map);
846      }
847      @Override
848      public String toString() {
849        return &quot;AccessControlUser&quot;;
850      }
851    };
852    public static final Builder&lt;List&lt;AccessControlLogEntry&gt;&gt; ACCESS_CONTROL_LOG_ENTRY_LIST
853        = new Builder&lt;List&lt;AccessControlLogEntry&gt;&gt;() {
854      private final Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
855      private Map&lt;String, Builder&gt; createDecoderMap() {
856        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
857        tempMappingFunctions.put(AccessControlLogEntry.COUNT, LONG);
858        tempMappingFunctions.put(AccessControlLogEntry.REASON, STRING);
859        tempMappingFunctions.put(AccessControlLogEntry.CONTEXT, STRING);
860        tempMappingFunctions.put(AccessControlLogEntry.OBJECT, STRING);
861        tempMappingFunctions.put(AccessControlLogEntry.USERNAME, STRING);
862        tempMappingFunctions.put(AccessControlLogEntry.AGE_SECONDS, DOUBLE);
863        tempMappingFunctions.put(AccessControlLogEntry.CLIENT_INFO, STRING);
864        tempMappingFunctions.put(AccessControlLogEntry.ENTRY_ID, LONG);
865        tempMappingFunctions.put(AccessControlLogEntry.TIMESTAMP_CREATED, LONG);
866        tempMappingFunctions.put(AccessControlLogEntry.TIMESTAMP_LAST_UPDATED, LONG);
867        return tempMappingFunctions;
868      }
869      @Override
870      public List&lt;AccessControlLogEntry&gt; build(Object data) {
871        if (null == data) {
872          return null;
873        }
874        List&lt;AccessControlLogEntry&gt; list = new ArrayList&lt;&gt;();
875        List&lt;List&lt;Object&gt;&gt; logEntries = (List&lt;List&lt;Object&gt;&gt;) data;
876        for (List&lt;Object&gt; logEntryData : logEntries) {
877          Iterator&lt;Object&gt; logEntryDataIterator = logEntryData.iterator();
878          AccessControlLogEntry accessControlLogEntry = new AccessControlLogEntry(
879              createMapFromDecodingFunctions(logEntryDataIterator, mappingFunctions,
880                  BACKUP_BUILDERS_FOR_DECODING_FUNCTIONS));
881          list.add(accessControlLogEntry);
882        }
883        return list;
884      }
885      @Override
886      public String toString() {
887        return &quot;List&lt;AccessControlLogEntry&gt;&quot;;
888      }
889    };
890    public static final Builder&lt;StreamEntryID&gt; STREAM_ENTRY_ID = new Builder&lt;StreamEntryID&gt;() {
891      @Override
892      public StreamEntryID build(Object data) {
893        if (null == data) {
894          return null;
895        }
896        String id = SafeEncoder.encode((byte[]) data);
897        return new StreamEntryID(id);
898      }
899      @Override
900      public String toString() {
901        return &quot;StreamEntryID&quot;;
902      }
903    };
904    public static final Builder&lt;List&lt;StreamEntryID&gt;&gt; STREAM_ENTRY_ID_LIST = new Builder&lt;List&lt;StreamEntryID&gt;&gt;() {
905      @Override
906      @SuppressWarnings(&quot;unchecked&quot;)
907      public List&lt;StreamEntryID&gt; build(Object data) {
908        if (null == data) {
909          return null;
910        }
911        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
912        List&lt;StreamEntryID&gt; responses = new ArrayList&lt;&gt;(objectList.size());
913        if (!objectList.isEmpty()) {
914          for(Object object : objectList) {
915            responses.add(STREAM_ENTRY_ID.build(object));
916          }
917        }
918        return responses;
919      }
920    };
921    public static final Builder&lt;StreamEntry&gt; STREAM_ENTRY = new Builder&lt;StreamEntry&gt;() {
922      @Override
923      @SuppressWarnings(&quot;unchecked&quot;)
924      public StreamEntry build(Object data) {
925        if (null == data) {
926          return null;
927        }
928        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
929        if (objectList.isEmpty()) {
930          return null;
931        }
932        String entryIdString = SafeEncoder.encode((byte[]) objectList.get(0));
933        StreamEntryID entryID = new StreamEntryID(entryIdString);
934        List&lt;byte[]&gt; hash = (List&lt;byte[]&gt;) objectList.get(1);
935        Iterator&lt;byte[]&gt; hashIterator = hash.iterator();
936        Map&lt;String, String&gt; map = new HashMap&lt;&gt;(hash.size() / 2, 1f);
937        while (hashIterator.hasNext()) {
938          map.put(SafeEncoder.encode(hashIterator.next()), SafeEncoder.encode(hashIterator.next()));
939        }
940        return new StreamEntry(entryID, map);
941      }
942      @Override
943      public String toString() {
944        return &quot;StreamEntry&quot;;
945      }
946    };
947    public static final Builder&lt;List&lt;StreamEntry&gt;&gt; STREAM_ENTRY_LIST = new Builder&lt;List&lt;StreamEntry&gt;&gt;() {
948      @Override
949      @SuppressWarnings(&quot;unchecked&quot;)
950      public List&lt;StreamEntry&gt; build(Object data) {
951        if (null == data) {
952          return null;
953        }
954        List&lt;ArrayList&lt;Object&gt;&gt; objectList = (List&lt;ArrayList&lt;Object&gt;&gt;) data;
955        List&lt;StreamEntry&gt; responses = new ArrayList&lt;&gt;(objectList.size() / 2);
956        if (objectList.isEmpty()) {
957          return responses;
958        }
959        for (ArrayList&lt;Object&gt; res : objectList) {
960          if (res == null) {
961            responses.add(null);
962            continue;
963          }
964          String entryIdString = SafeEncoder.encode((byte[]) res.get(0));
965          StreamEntryID entryID = new StreamEntryID(entryIdString);
966          List&lt;byte[]&gt; hash = (List&lt;byte[]&gt;) res.get(1);
967          if (hash == null) {
968            responses.add(new StreamEntry(entryID, null));
969            continue;
970          }
971          Iterator&lt;byte[]&gt; hashIterator = hash.iterator();
972          Map&lt;String, String&gt; map = new HashMap&lt;&gt;(hash.size() / 2, 1f);
973          while (hashIterator.hasNext()) {
974            map.put(SafeEncoder.encode(hashIterator.next()), SafeEncoder.encode(hashIterator.next()));
975          }
976          responses.add(new StreamEntry(entryID, map));
977        }
978        return responses;
979      }
980      @Override
981      public String toString() {
982        return &quot;List&lt;StreamEntry&gt;&quot;;
983      }
984    };
985    public static final Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt;&gt; STREAM_AUTO_CLAIM_RESPONSE
986        = new Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt;&gt;() {
987      @Override
988      @SuppressWarnings(&quot;unchecked&quot;)
989      public Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt; build(Object data) {
990        if (null == data) {
991          return null;
992        }
993        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
994        return new AbstractMap.SimpleEntry&lt;&gt;(STREAM_ENTRY_ID.build(objectList.get(0)),
995            STREAM_ENTRY_LIST.build(objectList.get(1)));
996      }
997      @Override
998      public String toString() {
999        return &quot;Map.Entry&lt;StreamEntryID, List&lt;StreamEntry&gt;&gt;&quot;;
1000      }
1001    };
1002    public static final Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt;&gt; STREAM_AUTO_CLAIM_JUSTID_RESPONSE
1003        = new Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt;&gt;() {
1004      @Override
1005      @SuppressWarnings(&quot;unchecked&quot;)
1006      public Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt; build(Object data) {
1007        if (null == data) {
1008          return null;
1009        }
1010        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
1011        return new AbstractMap.SimpleEntry&lt;&gt;(STREAM_ENTRY_ID.build(objectList.get(0)),
1012            STREAM_ENTRY_ID_LIST.build(objectList.get(1)));
1013      }
1014      @Override
1015      public String toString() {
1016        return &quot;Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt;&quot;;
1017      }
1018    };
1019    @Deprecated
1020    public static final Builder&lt;Map.Entry&lt;StreamEntryID, List&lt;StreamEntryID&gt;&gt;&gt; STREAM_AUTO_CLAIM_ID_RESPONSE
1021        = STREAM_AUTO_CLAIM_JUSTID_RESPONSE;
1022    public static final Builder&lt;List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt;&gt; STREAM_READ_RESPONSE
1023        = new Builder&lt;List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt;&gt;() {
1024      @Override
1025      public List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; build(Object data) {
1026        if (data == null) return null;
1027        List list = (List) data;
1028        if (list.isEmpty()) return Collections.emptyList();
1029        if (list.get(0) instanceof KeyValue) {
1030          return ((List&lt;KeyValue&gt;) list).stream()
1031              .map(kv -&gt; new KeyValue&lt;&gt;(STRING.build(kv.getKey()),
1032                  STREAM_ENTRY_LIST.build(kv.getValue())))
1033              .collect(Collectors.toList());
1034        } else {
1035          List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; result = new ArrayList&lt;&gt;(list.size());
1036          for (Object streamObj : list) {
1037            List&lt;Object&gt; stream = (List&lt;Object&gt;) streamObj;
1038            String streamKey = STRING.build(stream.get(0));
1039            List&lt;StreamEntry&gt; streamEntries = STREAM_ENTRY_LIST.build(stream.get(1));
1040            result.add(KeyValue.of(streamKey, streamEntries));
1041          }
1042          return result;
1043        }
1044      }
1045      @Override
1046      public String toString() {
1047        return &quot;List&lt;Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt;&quot;;
1048      }
1049    };
1050    public static final Builder&lt;List&lt;StreamPendingEntry&gt;&gt; STREAM_PENDING_ENTRY_LIST = new Builder&lt;List&lt;StreamPendingEntry&gt;&gt;() {
1051      @Override
1052      @SuppressWarnings(&quot;unchecked&quot;)
1053      public List&lt;StreamPendingEntry&gt; build(Object data) {
1054        if (null == data) {
1055          return null;
1056        }
1057        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1058        List&lt;StreamPendingEntry&gt; result = new ArrayList&lt;&gt;(streamsEntries.size());
1059        for (Object streamObj : streamsEntries) {
1060          List&lt;Object&gt; stream = (List&lt;Object&gt;) streamObj;
1061          String id = SafeEncoder.encode((byte[]) stream.get(0));
1062          String consumerName = SafeEncoder.encode((byte[]) stream.get(1));
1063          long idleTime = BuilderFactory.LONG.build(stream.get(2));
1064          long deliveredTimes = BuilderFactory.LONG.build(stream.get(3));
1065          result.add(new StreamPendingEntry(new StreamEntryID(id), consumerName, idleTime,
1066              deliveredTimes));
1067        }
1068        return result;
1069      }
1070      @Override
1071      public String toString() {
1072        return &quot;List&lt;StreamPendingEntry&gt;&quot;;
1073      }
1074    };
1075    public static final Builder&lt;StreamInfo&gt; STREAM_INFO = new Builder&lt;StreamInfo&gt;() {
1076      Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1077      private Map&lt;String, Builder&gt; createDecoderMap() {
1078        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1079        tempMappingFunctions.put(StreamInfo.LAST_GENERATED_ID, STREAM_ENTRY_ID);
1080        tempMappingFunctions.put(StreamInfo.FIRST_ENTRY, STREAM_ENTRY);
1081        tempMappingFunctions.put(StreamInfo.LENGTH, LONG);
1082        tempMappingFunctions.put(StreamInfo.RADIX_TREE_KEYS, LONG);
1083        tempMappingFunctions.put(StreamInfo.RADIX_TREE_NODES, LONG);
1084        tempMappingFunctions.put(StreamInfo.LAST_ENTRY, STREAM_ENTRY);
1085        tempMappingFunctions.put(StreamInfo.GROUPS, LONG);
1086        return tempMappingFunctions;
1087      }
1088      @Override
1089      @SuppressWarnings(&quot;unchecked&quot;)
1090      public StreamInfo build(Object data) {
1091        if (null == data) {
1092          return null;
1093        }
1094        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1095        Iterator&lt;Object&gt; iterator = streamsEntries.iterator();
1096        return new StreamInfo(createMapFromDecodingFunctions(iterator, mappingFunctions));
1097      }
1098      @Override
1099      public String toString() {
1100        return &quot;StreamInfo&quot;;
1101      }
1102    };
1103    public static final Builder&lt;List&lt;StreamGroupInfo&gt;&gt; STREAM_GROUP_INFO_LIST = new Builder&lt;List&lt;StreamGroupInfo&gt;&gt;() {
1104      Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1105      private Map&lt;String, Builder&gt; createDecoderMap() {
1106        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1107        tempMappingFunctions.put(StreamGroupInfo.NAME, STRING);
1108        tempMappingFunctions.put(StreamGroupInfo.CONSUMERS, LONG);
1109        tempMappingFunctions.put(StreamGroupInfo.PENDING, LONG);
1110        tempMappingFunctions.put(StreamGroupInfo.LAST_DELIVERED, STREAM_ENTRY_ID);
1111        return tempMappingFunctions;
1112      }
1113      @Override
1114      @SuppressWarnings(&quot;unchecked&quot;)
1115      public List&lt;StreamGroupInfo&gt; build(Object data) {
1116        if (null == data) {
1117          return null;
1118        }
1119        List&lt;StreamGroupInfo&gt; list = new ArrayList&lt;&gt;();
1120        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1121        Iterator&lt;Object&gt; groupsArray = streamsEntries.iterator();
1122        while (groupsArray.hasNext()) {
1123          List&lt;Object&gt; groupInfo = (List&lt;Object&gt;) groupsArray.next();
1124          Iterator&lt;Object&gt; groupInfoIterator = groupInfo.iterator();
1125          StreamGroupInfo streamGroupInfo = new StreamGroupInfo(createMapFromDecodingFunctions(
1126            groupInfoIterator, mappingFunctions));
1127          list.add(streamGroupInfo);
1128        }
1129        return list;
1130      }
1131      @Override
1132      public String toString() {
1133        return &quot;List&lt;StreamGroupInfo&gt;&quot;;
1134      }
1135    };
1136    @Deprecated
1137    public static final Builder&lt;List&lt;StreamConsumersInfo&gt;&gt; STREAM_CONSUMERS_INFO_LIST
1138        = new Builder&lt;List&lt;StreamConsumersInfo&gt;&gt;() {
1139      Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1140      private Map&lt;String, Builder&gt; createDecoderMap() {
1141        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1142        tempMappingFunctions.put(StreamConsumersInfo.NAME, STRING);
1143        tempMappingFunctions.put(StreamConsumersInfo.IDLE, LONG);
1144        tempMappingFunctions.put(StreamConsumersInfo.PENDING, LONG);
1145        return tempMappingFunctions;
1146      }
1147      @Override
1148      @SuppressWarnings(&quot;unchecked&quot;)
1149      public List&lt;StreamConsumersInfo&gt; build(Object data) {
1150        if (null == data) {
1151          return null;
1152        }
1153        List&lt;StreamConsumersInfo&gt; list = new ArrayList&lt;&gt;();
1154        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1155        Iterator&lt;Object&gt; groupsArray = streamsEntries.iterator();
1156        while (groupsArray.hasNext()) {
1157          List&lt;Object&gt; groupInfo = (List&lt;Object&gt;) groupsArray.next();
1158          Iterator&lt;Object&gt; consumerInfoIterator = groupInfo.iterator();
1159          StreamConsumersInfo streamGroupInfo = new StreamConsumersInfo(
1160              createMapFromDecodingFunctions(consumerInfoIterator, mappingFunctions));
1161          list.add(streamGroupInfo);
1162        }
1163        return list;
1164      }
1165      @Override
1166      public String toString() {
1167        return &quot;List&lt;StreamConsumersInfo&gt;&quot;;
1168      }
1169    };
1170    public static final Builder&lt;List&lt;StreamConsumerInfo&gt;&gt; STREAM_CONSUMER_INFO_LIST
1171        = new Builder&lt;List&lt;StreamConsumerInfo&gt;&gt;() {
1172      Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1173      private Map&lt;String, Builder&gt; createDecoderMap() {
1174        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1175        tempMappingFunctions.put(StreamConsumerInfo.NAME, STRING);
1176        tempMappingFunctions.put(StreamConsumerInfo.IDLE, LONG);
1177        tempMappingFunctions.put(StreamConsumerInfo.PENDING, LONG);
1178        return tempMappingFunctions;
1179      }
1180      @Override
1181      @SuppressWarnings(&quot;unchecked&quot;)
1182      public List&lt;StreamConsumerInfo&gt; build(Object data) {
1183        if (null == data) {
1184          return null;
1185        }
1186        List&lt;StreamConsumerInfo&gt; list = new ArrayList&lt;&gt;();
1187        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1188        Iterator&lt;Object&gt; groupsArray = streamsEntries.iterator();
1189        while (groupsArray.hasNext()) {
1190          List&lt;Object&gt; groupInfo = (List&lt;Object&gt;) groupsArray.next();
1191          Iterator&lt;Object&gt; consumerInfoIterator = groupInfo.iterator();
1192          StreamConsumerInfo streamConsumerInfo = new StreamConsumerInfo(
1193              createMapFromDecodingFunctions(consumerInfoIterator, mappingFunctions));
1194          list.add(streamConsumerInfo);
1195        }
1196        return list;
1197      }
1198      @Override
1199      public String toString() {
1200        return &quot;List&lt;StreamConsumerInfo&gt;&quot;;
1201      }
1202    };
1203    private static final Builder&lt;List&lt;StreamConsumerFullInfo&gt;&gt; STREAM_CONSUMER_FULL_INFO_LIST
1204        = new Builder&lt;List&lt;StreamConsumerFullInfo&gt;&gt;() {
1205      final Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1206      private Map&lt;String, Builder&gt; createDecoderMap() {
1207        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1208        tempMappingFunctions.put(StreamConsumerFullInfo.NAME, STRING);
1209        tempMappingFunctions.put(StreamConsumerFullInfo.SEEN_TIME, LONG);
1210        tempMappingFunctions.put(StreamConsumerFullInfo.PEL_COUNT, LONG);
1211        tempMappingFunctions.put(StreamConsumerFullInfo.PENDING, ENCODED_OBJECT_LIST);
1212        return tempMappingFunctions;
1213      }
1214      @Override
1215      @SuppressWarnings(&quot;unchecked&quot;)
1216      public List&lt;StreamConsumerFullInfo&gt; build(Object data) {
1217        if (null == data) {
1218          return null;
1219        }
1220        List&lt;StreamConsumerFullInfo&gt; list = new ArrayList&lt;&gt;();
1221        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1222        for (Object streamsEntry : streamsEntries) {
1223          List&lt;Object&gt; consumerInfoList = (List&lt;Object&gt;) streamsEntry;
1224          Iterator&lt;Object&gt; consumerInfoIterator = consumerInfoList.iterator();
1225          StreamConsumerFullInfo consumerInfo = new StreamConsumerFullInfo(
1226              createMapFromDecodingFunctions(consumerInfoIterator, mappingFunctions));
1227          list.add(consumerInfo);
1228        }
1229        return list;
1230      }
1231      @Override
1232      public String toString() {
1233        return &quot;List&lt;StreamConsumerFullInfo&gt;&quot;;
1234      }
1235    };
1236    private static final Builder&lt;List&lt;StreamGroupFullInfo&gt;&gt; STREAM_GROUP_FULL_INFO_LIST
1237        = new Builder&lt;List&lt;StreamGroupFullInfo&gt;&gt;() {
1238      final Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1239      private Map&lt;String, Builder&gt; createDecoderMap() {
1240        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1241        tempMappingFunctions.put(StreamGroupFullInfo.NAME, STRING);
1242        tempMappingFunctions.put(StreamGroupFullInfo.CONSUMERS, STREAM_CONSUMER_FULL_INFO_LIST);
1243        tempMappingFunctions.put(StreamGroupFullInfo.PENDING, ENCODED_OBJECT_LIST);
1244        tempMappingFunctions.put(StreamGroupFullInfo.LAST_DELIVERED, STREAM_ENTRY_ID);
1245        tempMappingFunctions.put(StreamGroupFullInfo.PEL_COUNT, LONG);
1246        return tempMappingFunctions;
1247      }
1248      @Override
1249      @SuppressWarnings(&quot;unchecked&quot;)
1250      public List&lt;StreamGroupFullInfo&gt; build(Object data) {
1251        if (null == data) {
1252          return null;
1253        }
1254        List&lt;StreamGroupFullInfo&gt; list = new ArrayList&lt;&gt;();
1255        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1256        for (Object streamsEntry : streamsEntries) {
1257          List&lt;Object&gt; groupInfo = (List&lt;Object&gt;) streamsEntry;
1258          Iterator&lt;Object&gt; groupInfoIterator = groupInfo.iterator();
1259          StreamGroupFullInfo groupFullInfo = new StreamGroupFullInfo(
1260              createMapFromDecodingFunctions(groupInfoIterator, mappingFunctions));
1261          list.add(groupFullInfo);
1262        }
1263        return list;
1264      }
1265      @Override
1266      public String toString() {
1267        return &quot;List&lt;StreamGroupFullInfo&gt;&quot;;
1268      }
1269    };
1270    public static final Builder&lt;StreamFullInfo&gt; STREAM_FULL_INFO = new Builder&lt;StreamFullInfo&gt;() {
1271      final Map&lt;String, Builder&gt; mappingFunctions = createDecoderMap();
1272      private Map&lt;String, Builder&gt; createDecoderMap() {
1273        Map&lt;String, Builder&gt; tempMappingFunctions = new HashMap&lt;&gt;();
1274        tempMappingFunctions.put(StreamFullInfo.LAST_GENERATED_ID, STREAM_ENTRY_ID);
1275        tempMappingFunctions.put(StreamFullInfo.LENGTH, LONG);
1276        tempMappingFunctions.put(StreamFullInfo.RADIX_TREE_KEYS, LONG);
1277        tempMappingFunctions.put(StreamFullInfo.RADIX_TREE_NODES, LONG);
1278        tempMappingFunctions.put(StreamFullInfo.GROUPS, STREAM_GROUP_FULL_INFO_LIST);
1279        tempMappingFunctions.put(StreamFullInfo.ENTRIES, STREAM_ENTRY_LIST);
1280        return tempMappingFunctions;
1281      }
1282      @Override
1283      @SuppressWarnings(&quot;unchecked&quot;)
1284      public StreamFullInfo build(Object data) {
1285        if (null == data) {
1286          return null;
1287        }
1288        List&lt;Object&gt; streamsEntries = (List&lt;Object&gt;) data;
1289        Iterator&lt;Object&gt; iterator = streamsEntries.iterator();
1290        return new StreamFullInfo(createMapFromDecodingFunctions(iterator, mappingFunctions));
1291      }
1292      @Override
1293      public String toString() {
1294        return &quot;StreamFullInfo&quot;;
1295      }
1296    };
1297    @Deprecated
1298    public static final Builder&lt;StreamFullInfo&gt; STREAM_INFO_FULL = STREAM_FULL_INFO;
1299    public static final Builder&lt;StreamPendingSummary&gt; STREAM_PENDING_SUMMARY = new Builder&lt;StreamPendingSummary&gt;() {
1300      @Override
1301      @SuppressWarnings(&quot;unchecked&quot;)
1302      public StreamPendingSummary build(Object data) {
1303        if (null == data) {
1304          return null;
1305        }
1306        List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
1307        long total = BuilderFactory.LONG.build(objectList.get(0));
1308        String minId = SafeEncoder.encode((byte[]) objectList.get(1));
1309        String maxId = SafeEncoder.encode((byte[]) objectList.get(2));
1310        List&lt;List&lt;Object&gt;&gt; consumerObjList = (List&lt;List&lt;Object&gt;&gt;) objectList.get(3);
1311        Map&lt;String, Long&gt; map = new HashMap&lt;&gt;(consumerObjList.size());
1312        for (List&lt;Object&gt; consumerObj : consumerObjList) {
1313          map.put(SafeEncoder.encode((byte[]) consumerObj.get(0)), Long.parseLong(SafeEncoder.encode((byte[]) consumerObj.get(1))));
1314        }
1315        return new StreamPendingSummary(total, new StreamEntryID(minId), new StreamEntryID(maxId), map);
1316      }
1317      @Override
1318      public String toString() {
1319        return &quot;StreamPendingSummary&quot;;
1320      }
1321    };
1322    private static final List&lt;Builder&gt; BACKUP_BUILDERS_FOR_DECODING_FUNCTIONS
1323        = Arrays.asList(STRING, LONG, DOUBLE);
1324    private static Map&lt;String, Object&gt; createMapFromDecodingFunctions(Iterator&lt;Object&gt; iterator,
1325        Map&lt;String, Builder&gt; mappingFunctions) {
1326      return createMapFromDecodingFunctions(iterator, mappingFunctions, null);
1327    }
1328    private static Map&lt;String, Object&gt; createMapFromDecodingFunctions(Iterator&lt;Object&gt; iterator,
1329        Map&lt;String, Builder&gt; mappingFunctions, Collection&lt;Builder&gt; backupBuilders) {
1330      if (!iterator.hasNext()) {
1331        return Collections.emptyMap();
1332      }
1333      Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;();
1334      while (iterator.hasNext()) {
1335        final Object tempObject = iterator.next();
1336        final String mapKey;
1337        final Object rawValue;
1338        if (tempObject instanceof KeyValue) {
1339          KeyValue kv = (KeyValue) tempObject;
1340          mapKey = STRING.build(kv.getKey());
1341          rawValue = kv.getValue();
1342        } else {
1343          mapKey = STRING.build(tempObject);
1344          rawValue = iterator.next();
1345        }
1346        if (mappingFunctions.containsKey(mapKey)) {
1347          resultMap.put(mapKey, mappingFunctions.get(mapKey).build(rawValue));
1348        } else { 
1349          Collection&lt;Builder&gt; builders = backupBuilders != null ? backupBuilders : mappingFunctions.values();
1350          for (Builder b : builders) {
1351            try {
1352              resultMap.put(mapKey, b.build(rawValue));
1353              break;
1354            } catch (ClassCastException e) {
1355            }
1356          }
1357        }
1358      }
1359      return resultMap;
1360    }
1361    public static final Builder&lt;LCSMatchResult&gt; STR_ALGO_LCS_RESULT_BUILDER = new Builder&lt;LCSMatchResult&gt;() {
1362      @Override
1363      public LCSMatchResult build(Object data) {
1364        if (data == null) {
1365          return null;
1366        }
1367        if (data instanceof byte[]) {
1368          return new LCSMatchResult(STRING.build(data));
1369        } else if (data instanceof Long) {
1370          return new LCSMatchResult(LONG.build(data));
1371        } else {
1372          long len = 0;
1373          List&lt;MatchedPosition&gt; matchedPositions = new ArrayList&lt;&gt;();
1374          List&lt;Object&gt; objectList = (List&lt;Object&gt;) data;
1375          if (objectList.get(0) instanceof KeyValue) {
1376            Iterator iterator = objectList.iterator();
1377            while (iterator.hasNext()) {
1378              KeyValue kv = (KeyValue) iterator.next();
1379              if (&quot;matches&quot;.equalsIgnoreCase(STRING.build(kv.getKey()))) {
1380                addMatchedPosition(matchedPositions, kv.getValue());
1381              } else if (&quot;len&quot;.equalsIgnoreCase(STRING.build(kv.getKey()))) {
1382                len = LONG.build(kv.getValue());
1383              }
1384            }
1385          } else {
1386            for (int i = 0; i &lt; objectList.size(); i += 2) {
1387              if (&quot;matches&quot;.equalsIgnoreCase(STRING.build(objectList.get(i)))) {
1388                addMatchedPosition(matchedPositions, objectList.get(i + 1));
1389              } else if (&quot;len&quot;.equalsIgnoreCase(STRING.build(objectList.get(i)))) {
1390                len = LONG.build(objectList.get(i + 1));
1391              }
1392            }
1393          }
1394          return new LCSMatchResult(matchedPositions, len);
1395        }
1396      }
1397      private void addMatchedPosition(List&lt;MatchedPosition&gt; matchedPositions, Object o) {
1398        List&lt;Object&gt; matches = (List&lt;Object&gt;) o;
1399        for (Object obj : matches) {
1400          if (obj instanceof List&lt;?&gt;) {
1401            List&lt;Object&gt; positions = (List&lt;Object&gt;) obj;
1402            Position a = new Position(
1403                LONG.build(((List&lt;Object&gt;) positions.get(0)).get(0)),
1404                LONG.build(((List&lt;Object&gt;) positions.get(0)).get(1))
1405            );
1406            Position b = new Position(
1407                LONG.build(((List&lt;Object&gt;) positions.get(1)).get(0)),
1408                LONG.build(((List&lt;Object&gt;) positions.get(1)).get(1))
1409            );
1410            long matchLen = 0;
1411            if (positions.size() &gt;= 3) {
1412              matchLen = LONG.build(positions.get(2));
1413            }
1414            matchedPositions.add(new MatchedPosition(a, b, matchLen));
1415          }
1416        }
1417      }
1418    };
1419    public static final Builder&lt;Map&lt;String, String&gt;&gt; STRING_MAP_FROM_PAIRS = new Builder&lt;Map&lt;String, String&gt;&gt;() {
1420      @Override
1421      @SuppressWarnings(&quot;unchecked&quot;)
1422      public Map&lt;String, String&gt; build(Object data) {
1423        final List&lt;Object&gt; list = (List&lt;Object&gt;) data;
1424        final Map&lt;String, String&gt; map = new HashMap&lt;&gt;(list.size());
1425        for (Object object : list) {
1426          if (object == null) continue;
1427          final List&lt;Object&gt; flat = (List&lt;Object&gt;) object;
1428          if (flat.isEmpty()) continue;
1429          map.put(STRING.build(flat.get(0)), STRING.build(flat.get(1)));
1430        }
1431        return map;
1432      }
1433      @Override
1434      public String toString() {
1435        return &quot;Map&lt;String, String&gt;&quot;;
1436      }
1437    };
1438    public static final Builder&lt;List&lt;LibraryInfo&gt;&gt; LIBRARY_LIST = new Builder&lt;List&lt;LibraryInfo&gt;&gt;() {
1439      @Override
1440      public List&lt;LibraryInfo&gt; build(Object data) {
1441        List&lt;Object&gt; list = (List&lt;Object&gt;) data;
1442        return list.stream().map(o -&gt; LibraryInfo.LIBRARY_BUILDER.build(o)).collect(Collectors.toList());
1443      }
1444    };
1445    public static final Builder&lt;List&lt;List&lt;String&gt;&gt;&gt; STRING_LIST_LIST = new Builder&lt;List&lt;List&lt;String&gt;&gt;&gt;() {
1446      @Override
1447      @SuppressWarnings(&quot;unchecked&quot;)
1448      public List&lt;List&lt;String&gt;&gt; build(Object data) {
1449        if (null == data) return null;
1450        return ((List&lt;Object&gt;) data).stream().map(STRING_LIST::build).collect(Collectors.toList());
1451      }
1452      @Override
1453      public String toString() {
1454        return &quot;List&lt;List&lt;String&gt;&gt;&quot;;
1455      }
1456    };
1457    public static final Builder&lt;List&lt;List&lt;Object&gt;&gt;&gt; ENCODED_OBJECT_LIST_LIST = new Builder&lt;List&lt;List&lt;Object&gt;&gt;&gt;() {
1458      @Override
1459      @SuppressWarnings(&quot;unchecked&quot;)
1460      public List&lt;List&lt;Object&gt;&gt; build(Object data) {
1461        if (null == data) return null;
1462        return ((List&lt;Object&gt;) data).stream().map(ENCODED_OBJECT_LIST::build).collect(Collectors.toList());
1463      }
1464      @Override
1465      public String toString() {
1466        return &quot;List&lt;List&lt;Object&gt;&gt;&quot;;
1467      }
1468    };
1469    protected static class SetFromList&lt;E&gt; extends AbstractSet&lt;E&gt; implements Serializable {
1470      private static final long serialVersionUID = -2850347066962734052L;
1471      private final List&lt;E&gt; list;
1472      private SetFromList(List&lt;E&gt; list) {
1473        this.list = list;
1474      }
1475      @Override
1476      public void clear() {
1477        list.clear();
1478      }
1479      @Override
1480      public int size() {
1481        return list.size();
1482      }
1483      @Override
1484      public boolean isEmpty() {
1485        return list.isEmpty();
1486      }
1487      @Override
1488      public boolean contains(Object o) {
1489        return list.contains(o);
1490      }
1491      @Override
1492      public boolean remove(Object o) {
1493        return list.remove(o);
1494      }
1495      @Override
1496      public boolean add(E e) {
1497        return !contains(e) &amp;&amp; list.add(e);
1498      }
1499      @Override
1500      public Iterator&lt;E&gt; iterator() {
1501        return list.iterator();
1502      }
1503      @Override
1504      public Object[] toArray() {
1505        return list.toArray();
1506      }
1507      @Override
1508      public &lt;T&gt; T[] toArray(T[] a) {
1509        return list.toArray(a);
1510      }
1511      @Override
1512      public String toString() {
1513        return list.toString();
1514      }
1515      @Override
1516      public int hashCode() {
1517        return list.hashCode();
1518      }
1519      @Override
1520      public boolean equals(Object o) {
1521        if (o == null) return false;
1522        if (o == this) return true;
1523        if (!(o instanceof Set)) return false;
1524        Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
1525        if (c.size() != size()) {
1526          return false;
1527        }
1528        return containsAll(c);
1529      }
1530      @Override
1531      public boolean containsAll(Collection&lt;?&gt; c) {
1532        return list.containsAll(c);
1533      }
1534      @Override
1535      public boolean removeAll(Collection&lt;?&gt; c) {
1536        return list.removeAll(c);
1537      }
1538      @Override
1539      public boolean retainAll(Collection&lt;?&gt; c) {
1540        return list.retainAll(c);
1541      }
1542      protected static &lt;E&gt; SetFromList&lt;E&gt; of(List&lt;E&gt; list) {
1543        if (list == null) {
1544          return null;
1545        }
1546        return new SetFromList&lt;&gt;(list);
1547      }
1548    }
1549    private BuilderFactory() {
1550      throw new InstantiationError(&quot;Must not instantiate this class&quot;);
1551    }
1552  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-BuilderFactory.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-BuilderFactory.java</div>
                </div>
                <div class="column column_space"><pre><code>185          pairList.add(new AbstractMap.SimpleEntry&lt;&gt;(iterator.next(), iterator.next()));
186        }
187        return pairList;
</pre></code></div>
                <div class="column column_space"><pre><code>667          results.add(new AbstractMap.SimpleEntry&lt;&gt;(iterator.next(), iterator.next()));
668        }
669        return new ScanResult&lt;&gt;(newcursor, results);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    