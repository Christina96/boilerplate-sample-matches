
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-EssentialsSign.java</h3>
            <pre><code>1  package com.earth2me.essentials.signs;
2  import com.earth2me.essentials.*;
3  import static com.earth2me.essentials.I18n.tl;
4  import com.earth2me.essentials.utils.NumberUtil;
5  import java.math.BigDecimal;
6  import java.util.HashSet;
7  import java.util.Locale;
8  import java.util.Set;
9  import net.ess3.api.IEssentials;
10  import net.ess3.api.MaxMoneyException;
11  import net.ess3.api.events.SignBreakEvent;
12  import net.ess3.api.events.SignCreateEvent;
13  import net.ess3.api.events.SignInteractEvent;
14  import org.bukkit.Material;
15  import org.bukkit.block.Block;
16  import org.bukkit.block.BlockFace;
17  import org.bukkit.block.Sign;
18  import org.bukkit.entity.Player;
19  import org.bukkit.event.block.SignChangeEvent;
20  import org.bukkit.inventory.ItemStack;
21  public class EssentialsSign
22  {
23  	private static final Set&lt;Material&gt; EMPTY_SET = new HashSet&lt;Material&gt;();
24  	protected static final BigDecimal MINTRANSACTION = new BigDecimal(&quot;0.01&quot;);
25  	protected transient final String signName;
26  	public EssentialsSign(final String signName)
27  	{
28  		this.signName = signName;
29  	}
30  	protected final boolean onSignCreate(final SignChangeEvent event, final IEssentials ess)
31  	{
32  		final ISign sign = new EventSign(event);
33  		final User user = ess.getUser(event.getPlayer());
34  		if (!(user.isAuthorized(&quot;essentials.signs.&quot; + signName.toLowerCase(Locale.ENGLISH) + &quot;.create&quot;)
35  			  || user.isAuthorized(&quot;essentials.signs.create.&quot; + signName.toLowerCase(Locale.ENGLISH))))
36  		{
37  			return true;
38  		}
39  		sign.setLine(0, tl(&quot;signFormatFail&quot;, this.signName));
40  		final SignCreateEvent signEvent = new SignCreateEvent(sign, this, user);
41  		ess.getServer().getPluginManager().callEvent(signEvent);
<span onclick='openModal()' class='match'>42  		if (signEvent.isCancelled())
43  		{
44  			return false;
45  		}
46  		try
47  		{
48  			final boolean ret = onSignCreate(sign, user, getUsername(user), ess);
</span>49  			if (ret)
50  			{
51  				sign.setLine(0, getSuccessName());
52  			}
53  			return ret;
54  		}
55  		catch (ChargeException ex)
56  		{
57  			showError(ess, user.getSource(), ex, signName);
58  		}
59  		catch (SignException ex)
60  		{
61  			showError(ess, user.getSource(), ex, signName);
62  		}
63  		return true;
64  	}
65  	public String getSuccessName()
66  	{
67  		return tl(&quot;signFormatSuccess&quot;, this.signName);
68  	}
69  	public String getTemplateName()
70  	{
71  		return tl(&quot;signFormatTemplate&quot;, this.signName);
72  	}
73  	public String getName()
74  	{
75  		return this.signName;
76  	}
77  	public String getUsername(final User user)
78  	{
79  		return user.getName().substring(0, user.getName().length() &gt; 13 ? 13 : user.getName().length());
80  	}
81  	protected final boolean onSignInteract(final Block block, final Player player, final IEssentials ess)
82  	{
83  		final ISign sign = new BlockSign(block);
84  		final User user = ess.getUser(player);
85  		if (user.checkSignThrottle())
86  		{
87  			return false;
88  		}
89  		try
90  		{
91  			if (user.getBase().isDead() || !(user.isAuthorized(&quot;essentials.signs.&quot; + signName.toLowerCase(Locale.ENGLISH) + &quot;.use&quot;)
92  								   || user.isAuthorized(&quot;essentials.signs.use.&quot; + signName.toLowerCase(Locale.ENGLISH))))
93  			{
94  				return false;
95  			}
96  			final SignInteractEvent signEvent = new SignInteractEvent(sign, this, user);
97  			ess.getServer().getPluginManager().callEvent(signEvent);
98  			if (signEvent.isCancelled())
99  			{
100  				return false;
101  			}
102  			return onSignInteract(sign, user, getUsername(user), ess);
103  		}
104  		catch (ChargeException ex)
105  		{
106  			showError(ess, user.getSource(), ex, signName);
107  			return false;
108  		}
109  		catch (Exception ex)
110  		{
111  			showError(ess, user.getSource(), ex, signName);
112  			return false;
113  		}
114  	}
115  	protected final boolean onSignBreak(final Block block, final Player player, final IEssentials ess) throws MaxMoneyException
116  	{
117  		final ISign sign = new BlockSign(block);
118  		final User user = ess.getUser(player);
119  		try
120  		{
121  			if (!(user.isAuthorized(&quot;essentials.signs.&quot; + signName.toLowerCase(Locale.ENGLISH) + &quot;.break&quot;)
122  				  || user.isAuthorized(&quot;essentials.signs.break.&quot; + signName.toLowerCase(Locale.ENGLISH))))
123  			{
124  				return false;
125  			}
126  			final SignBreakEvent signEvent = new SignBreakEvent(sign, this, user);
127  			ess.getServer().getPluginManager().callEvent(signEvent);
128  			if (signEvent.isCancelled())
129  			{
130  				return false;
131  			}
132  			return onSignBreak(sign, user, getUsername(user), ess);
133  		}
134  		catch (SignException ex)
135  		{
136  			showError(ess, user.getSource(), ex, signName);
137  			return false;
138  		}
139  	}
140  	protected boolean onSignCreate(final ISign sign, final User player, final String username, final IEssentials ess) throws SignException, ChargeException
141  	{
142  		return true;
143  	}
144  	protected boolean onSignInteract(final ISign sign, final User player, final String username, final IEssentials ess) throws SignException, ChargeException, MaxMoneyException
145  	{
146  		return true;
147  	}
148  	protected boolean onSignBreak(final ISign sign, final User player, final String username, final IEssentials ess) throws SignException, MaxMoneyException
149  	{
150  		return true;
151  	}
152  	protected final boolean onBlockPlace(final Block block, final Player player, final IEssentials ess)
153  	{
154  		User user = ess.getUser(player);
155  		try
156  		{
157  			return onBlockPlace(block, user, getUsername(user), ess);
158  		}
159  		catch (ChargeException ex)
160  		{
161  			showError(ess, user.getSource(), ex, signName);
162  		}
163  		catch (SignException ex)
164  		{
165  			showError(ess, user.getSource(), ex, signName);
166  		}
167  		return false;
168  	}
169  	protected final boolean onBlockInteract(final Block block, final Player player, final IEssentials ess)
170  	{
171  		User user = ess.getUser(player);
172  		try
173  		{
174  			return onBlockInteract(block, user, getUsername(user), ess);
175  		}
176  		catch (ChargeException ex)
177  		{
178  			showError(ess, user.getSource(), ex, signName);
179  		}
180  		catch (SignException ex)
181  		{
182  			showError(ess, user.getSource(), ex, signName);
183  		}
184  		return false;
185  	}
186  	protected final boolean onBlockBreak(final Block block, final Player player, final IEssentials ess) throws MaxMoneyException
187  	{
188  		User user = ess.getUser(player);
189  		try
190  		{
191  			return onBlockBreak(block, user, getUsername(user), ess);
192  		}
193  		catch (SignException ex)
194  		{
195  			showError(ess, user.getSource(), ex, signName);
196  		}
197  		return false;
198  	}
199  	protected boolean onBlockBreak(final Block block, final IEssentials ess)
200  	{
201  		return true;
202  	}
203  	protected boolean onBlockExplode(final Block block, final IEssentials ess)
204  	{
205  		return true;
206  	}
207  	protected boolean onBlockBurn(final Block block, final IEssentials ess)
208  	{
209  		return true;
210  	}
211  	protected boolean onBlockIgnite(final Block block, final IEssentials ess)
212  	{
213  		return true;
214  	}
215  	protected boolean onBlockPush(final Block block, final IEssentials ess)
216  	{
217  		return true;
218  	}
219  	protected static boolean checkIfBlockBreaksSigns(final Block block)
220  	{
221  		final Block sign = block.getRelative(BlockFace.UP);
222  		if (sign.getType() == Material.SIGN_POST &amp;&amp; isValidSign(new BlockSign(sign)))
223  		{
224  			return true;
225  		}
226  		final BlockFace[] directions = new BlockFace[]
227  		{
228  			BlockFace.NORTH,
229  			BlockFace.EAST,
230  			BlockFace.SOUTH,
231  			BlockFace.WEST
232  		};
233  		for (BlockFace blockFace : directions)
234  		{
235  			final Block signblock = block.getRelative(blockFace);
236  			if (signblock.getType() == Material.WALL_SIGN)
237  			{
238  				try
239  				{
240  					final org.bukkit.material.Sign signMat = (org.bukkit.material.Sign)signblock.getState().getData();
241  					if (signMat != null &amp;&amp; signMat.getFacing() == blockFace &amp;&amp; isValidSign(new BlockSign(signblock)))
242  					{
243  						return true;
244  					}
245  				}
246  				catch (NullPointerException ex)
247  				{
248  				}
249  			}
250  		}
251  		return false;
252  	}
253  	public static boolean isValidSign(final ISign sign)
254  	{
255  		return sign.getLine(0).matches(&quot;§1\\[.*\\]&quot;);
256  	}
257  	protected boolean onBlockPlace(final Block block, final User player, final String username, final IEssentials ess) throws SignException, ChargeException
258  	{
259  		return true;
260  	}
261  	protected boolean onBlockInteract(final Block block, final User player, final String username, final IEssentials ess) throws SignException, ChargeException
262  	{
263  		return true;
264  	}
265  	protected boolean onBlockBreak(final Block block, final User player, final String username, final IEssentials ess) throws SignException, MaxMoneyException
266  	{
267  		return true;
268  	}
269  	public Set&lt;Material&gt; getBlocks()
270  	{
271  		return EMPTY_SET;
272  	}
273  	public boolean areHeavyEventRequired()
274  	{
275  		return false;
276  	}
277  	private String getSignText(final ISign sign, final int lineNumber)
278  	{
279  		return sign.getLine(lineNumber).trim();
280  	}
281  	protected final void validateTrade(final ISign sign, final int index, final IEssentials ess) throws SignException
282  	{
283  		final String line = getSignText(sign, index);
284  		if (line.isEmpty())
285  		{
286  			return;
287  		}
288  		final Trade trade = getTrade(sign, index, 0, ess);
289  		final BigDecimal money = trade.getMoney();
290  		if (money != null)
291  		{
292  			sign.setLine(index, NumberUtil.shortCurrency(money, ess));
293  		}
294  	}
295  	protected final void validateTrade(final ISign sign, final int amountIndex, final int itemIndex,
296  									   final User player, final IEssentials ess) throws SignException
297  	{
298  		final String itemType = getSignText(sign, itemIndex);
299  		if (itemType.equalsIgnoreCase(&quot;exp&quot;) || itemType.equalsIgnoreCase(&quot;xp&quot;))
300  		{
301  			int amount = getIntegerPositive(getSignText(sign, amountIndex));
302  			sign.setLine(amountIndex, Integer.toString(amount));
303  			sign.setLine(itemIndex, &quot;exp&quot;);
304  			return;
305  		}
306  		final Trade trade = getTrade(sign, amountIndex, itemIndex, player, ess);
307  		final ItemStack item = trade.getItemStack();
308  		sign.setLine(amountIndex, Integer.toString(item.getAmount()));
309  		sign.setLine(itemIndex, itemType);
310  	}
311  	protected final Trade getTrade(final ISign sign, final int amountIndex, final int itemIndex,
312  								   final User player, final IEssentials ess) throws SignException
313  	{
314  		final String itemType = getSignText(sign, itemIndex);
315  		if (itemType.equalsIgnoreCase(&quot;exp&quot;) || itemType.equalsIgnoreCase(&quot;xp&quot;))
316  		{
317  			final int amount = getIntegerPositive(getSignText(sign, amountIndex));
318  			return new Trade(amount, ess);
319  		}
320  		final ItemStack item = getItemStack(itemType, 1, ess);
321  		final int amount = Math.min(getIntegerPositive(getSignText(sign, amountIndex)), item.getType().getMaxStackSize() * player.getBase().getInventory().getSize());
322  		if (item.getType() == Material.AIR || amount &lt; 1)
323  		{
324  			throw new SignException(tl(&quot;moreThanZero&quot;));
325  		}
326  		item.setAmount(amount);
327  		return new Trade(item, ess);
328  	}
329  	protected final void validateInteger(final ISign sign, final int index) throws SignException
330  	{
331  		final String line = getSignText(sign, index);
332  		if (line.isEmpty())
333  		{
334  			throw new SignException(&quot;Empty line &quot; + index);
335  		}
336  		final int quantity = getIntegerPositive(line);
337  		sign.setLine(index, Integer.toString(quantity));
338  	}
339  	protected final int getIntegerPositive(final String line) throws SignException
340  	{
341  		final int quantity = getInteger(line);
342  		if (quantity &lt; 1)
343  		{
344  			throw new SignException(tl(&quot;moreThanZero&quot;));
345  		}
346  		return quantity;
347  	}
348  	protected final int getInteger(final String line) throws SignException
349  	{
350  		try
351  		{
352  			final int quantity = Integer.parseInt(line);
353  			return quantity;
354  		}
355  		catch (NumberFormatException ex)
356  		{
357  			throw new SignException(&quot;Invalid sign&quot;, ex);
358  		}
359  	}
360  	protected final ItemStack getItemStack(final String itemName, final int quantity, final IEssentials ess) throws SignException
361  	{
362  		try
363  		{
364  			final ItemStack item = ess.getItemDb().get(itemName);
365  			item.setAmount(quantity);
366  			return item;
367  		}
368  		catch (Exception ex)
369  		{
370  			throw new SignException(ex.getMessage(), ex);
371  		}
372  	}
373  	protected final ItemStack getItemMeta(final ItemStack item, final String meta, final IEssentials ess) throws SignException
374  	{
375  		ItemStack stack = item;
376  		try
377  		{
378  			if (!meta.isEmpty())
379  			{
380  				MetaItemStack metaStack = new MetaItemStack(stack);
381  				final boolean allowUnsafe = ess.getSettings().allowUnsafeEnchantments();
382  				metaStack.addStringMeta(null, allowUnsafe, meta, ess);
383  				stack = metaStack.getItemStack();
384  			}
385  		}
386  		catch (Exception ex)
387  		{
388  			throw new SignException(ex.getMessage(), ex);
389  		}
390  		return stack;
391  	}
392  	protected final BigDecimal getMoney(final String line) throws SignException
393  	{
394  		final boolean isMoney = line.matches(&quot;^[^0-9-\\.][\\.0-9]+$&quot;);
395  		return isMoney ? getBigDecimalPositive(line.substring(1)) : null;
396  	}
397  	protected final BigDecimal getBigDecimalPositive(final String line) throws SignException
398  	{
399  		final BigDecimal quantity = getBigDecimal(line);
400  		if (quantity.compareTo(MINTRANSACTION) &lt; 0)
401  		{
402  			throw new SignException(tl(&quot;moreThanZero&quot;));
403  		}
404  		return quantity;
405  	}
406  	protected final BigDecimal getBigDecimal(final String line) throws SignException
407  	{
408  		try
409  		{
410  			return new BigDecimal(line);
411  		}
412  		catch (ArithmeticException ex)
413  		{
414  			throw new SignException(ex.getMessage(), ex);
415  		}
416  		catch (NumberFormatException ex)
417  		{
418  			throw new SignException(ex.getMessage(), ex);
419  		}
420  	}
421  	protected final Trade getTrade(final ISign sign, final int index, final IEssentials ess) throws SignException
422  	{
423  		return getTrade(sign, index, 1, ess);
424  	}
425  	protected final Trade getTrade(final ISign sign, final int index, final int decrement, final IEssentials ess) throws SignException
426  	{
427  		final String line = getSignText(sign, index);
428  		if (line.isEmpty())
429  		{
430  			return new Trade(signName.toLowerCase(Locale.ENGLISH) + &quot;sign&quot;, ess);
431  		}
432  		final BigDecimal money = getMoney(line);
433  		if (money == null)
434  		{
435  			final String[] split = line.split(&quot;[ :]+&quot;, 2);
436  			if (split.length != 2)
437  			{
438  				throw new SignException(tl(&quot;invalidCharge&quot;));
439  			}
440  			final int quantity = getIntegerPositive(split[0]);
441  			final String item = split[1].toLowerCase(Locale.ENGLISH);
442  			if (item.equalsIgnoreCase(&quot;times&quot;))
443  			{
444  				sign.setLine(index, (quantity - decrement) + &quot; times&quot;);
445  				sign.updateSign();
446  				return new Trade(signName.toLowerCase(Locale.ENGLISH) + &quot;sign&quot;, ess);
447  			}
448  			else if (item.equalsIgnoreCase(&quot;exp&quot;) || item.equalsIgnoreCase(&quot;xp&quot;))
449  			{
450  				sign.setLine(index, quantity + &quot; exp&quot;);
451  				return new Trade(quantity, ess);
452  			}
453  			else
454  			{
455  				final ItemStack stack = getItemStack(item, quantity, ess);
456  				sign.setLine(index, quantity + &quot; &quot; + item);
457  				return new Trade(stack, ess);
458  			}
459  		}
460  		else
461  		{
462  			return new Trade(money, ess);
463  		}
464  	}
465  	private void showError(final IEssentials ess, final CommandSource sender, final Throwable exception, final String signName)
466  	{
467  		ess.showError(sender, exception, &quot;\\ sign: &quot; + signName);
468  	}
469  	static class EventSign implements ISign
470  	{
471  		private final transient SignChangeEvent event;
472  		private final transient Block block;
473  		private final transient Sign sign;
474  		EventSign(final SignChangeEvent event)
475  		{
476  			this.event = event;
477  			this.block = event.getBlock();
478  			this.sign = (Sign)block.getState();
479  		}
480  		@Override
481  		public final String getLine(final int index)
482  		{
483  			StringBuilder builder = new StringBuilder();
484  			for (char c : event.getLine(index).toCharArray())
485  			{
486  				if (c &lt; 0xF700 || c &gt; 0xF747)
487  				{
488  					builder.append(c);
489  				}
490  			}
491  			return builder.toString();
492  		}
493  		@Override
494  		public final void setLine(final int index, final String text)
495  		{
496  			event.setLine(index, text);
497  			sign.setLine(index, text);
498  			updateSign();
499  		}
500  		@Override
501  		public Block getBlock()
502  		{
503  			return block;
504  		}
505  		@Override
506  		public void updateSign()
507  		{
508  			sign.update();
509  		}
510  	}
511  	static class BlockSign implements ISign
512  	{
513  		private final transient Sign sign;
514  		private final transient Block block;
515  		BlockSign(final Block block)
516  		{
517  			this.block = block;
518  			this.sign = (Sign)block.getState();
519  		}
520  		@Override
521  		public final String getLine(final int index)
522  		{
523  			StringBuilder builder = new StringBuilder();
524  			for (char c : sign.getLine(index).toCharArray())
525  			{
526  				if (c &lt; 0xF700 || c &gt; 0xF747)
527  				{
528  					builder.append(c);
529  				}
530  			}
531  			return builder.toString();
532  		}
533  		@Override
534  		public final void setLine(final int index, final String text)
535  		{
536  			sign.setLine(index, text);
537  		}
538  		@Override
539  		public final Block getBlock()
540  		{
541  			return block;
542  		}
543  		@Override
544  		public final void updateSign()
545  		{
546  			sign.update();
547  		}
548  	}
549  	public interface ISign
550  	{
551  		public String getLine(final int index);
552  		public void setLine(final int index, final String text);
553  		public Block getBlock();
554  		public void updateSign();
555  	}
556  }
</code></pre>
        </div>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-EssentialsSign.java</h3>
            <pre><code>1  package com.earth2me.essentials.signs;
2  import com.earth2me.essentials.*;
3  import static com.earth2me.essentials.I18n.tl;
4  import com.earth2me.essentials.utils.NumberUtil;
5  import java.math.BigDecimal;
6  import java.util.HashSet;
7  import java.util.Locale;
8  import java.util.Set;
9  import net.ess3.api.IEssentials;
10  import net.ess3.api.MaxMoneyException;
11  import net.ess3.api.events.SignBreakEvent;
12  import net.ess3.api.events.SignCreateEvent;
13  import net.ess3.api.events.SignInteractEvent;
14  import org.bukkit.Material;
15  import org.bukkit.block.Block;
16  import org.bukkit.block.BlockFace;
17  import org.bukkit.block.Sign;
18  import org.bukkit.entity.Player;
19  import org.bukkit.event.block.SignChangeEvent;
20  import org.bukkit.inventory.ItemStack;
21  public class EssentialsSign
22  {
23  	private static final Set&lt;Material&gt; EMPTY_SET = new HashSet&lt;Material&gt;();
24  	protected static final BigDecimal MINTRANSACTION = new BigDecimal(&quot;0.01&quot;);
25  	protected transient final String signName;
26  	public EssentialsSign(final String signName)
27  	{
28  		this.signName = signName;
29  	}
30  	protected final boolean onSignCreate(final SignChangeEvent event, final IEssentials ess)
31  	{
32  		final ISign sign = new EventSign(event);
33  		final User user = ess.getUser(event.getPlayer());
34  		if (!(user.isAuthorized(&quot;essentials.signs.&quot; + signName.toLowerCase(Locale.ENGLISH) + &quot;.create&quot;)
35  			  || user.isAuthorized(&quot;essentials.signs.create.&quot; + signName.toLowerCase(Locale.ENGLISH))))
36  		{
37  			return true;
38  		}
39  		sign.setLine(0, tl(&quot;signFormatFail&quot;, this.signName));
40  		final SignCreateEvent signEvent = new SignCreateEvent(sign, this, user);
41  		ess.getServer().getPluginManager().callEvent(signEvent);
42  		if (signEvent.isCancelled())
43  		{
44  			return false;
45  		}
46  		try
47  		{
48  			final boolean ret = onSignCreate(sign, user, getUsername(user), ess);
49  			if (ret)
50  			{
51  				sign.setLine(0, getSuccessName());
52  			}
53  			return ret;
54  		}
55  		catch (ChargeException ex)
56  		{
57  			showError(ess, user.getSource(), ex, signName);
58  		}
59  		catch (SignException ex)
60  		{
61  			showError(ess, user.getSource(), ex, signName);
62  		}
63  		return true;
64  	}
65  	public String getSuccessName()
66  	{
67  		return tl(&quot;signFormatSuccess&quot;, this.signName);
68  	}
69  	public String getTemplateName()
70  	{
71  		return tl(&quot;signFormatTemplate&quot;, this.signName);
72  	}
73  	public String getName()
74  	{
75  		return this.signName;
76  	}
77  	public String getUsername(final User user)
78  	{
79  		return user.getName().substring(0, user.getName().length() &gt; 13 ? 13 : user.getName().length());
80  	}
81  	protected final boolean onSignInteract(final Block block, final Player player, final IEssentials ess)
82  	{
83  		final ISign sign = new BlockSign(block);
84  		final User user = ess.getUser(player);
<span onclick='openModal()' class='match'>85  		if (user.checkSignThrottle())
86  		{
87  			return false;
88  		}
89  		try
90  		{
91  			if (user.getBase().isDead() || !(user.isAuthorized(&quot;essentials.signs.&quot; + signName.toLowerCase(Locale.ENGLISH) + &quot;.use&quot;)
</span>92  								   || user.isAuthorized(&quot;essentials.signs.use.&quot; + signName.toLowerCase(Locale.ENGLISH))))
93  			{
94  				return false;
95  			}
96  			final SignInteractEvent signEvent = new SignInteractEvent(sign, this, user);
97  			ess.getServer().getPluginManager().callEvent(signEvent);
98  			if (signEvent.isCancelled())
99  			{
100  				return false;
101  			}
102  			return onSignInteract(sign, user, getUsername(user), ess);
103  		}
104  		catch (ChargeException ex)
105  		{
106  			showError(ess, user.getSource(), ex, signName);
107  			return false;
108  		}
109  		catch (Exception ex)
110  		{
111  			showError(ess, user.getSource(), ex, signName);
112  			return false;
113  		}
114  	}
115  	protected final boolean onSignBreak(final Block block, final Player player, final IEssentials ess) throws MaxMoneyException
116  	{
117  		final ISign sign = new BlockSign(block);
118  		final User user = ess.getUser(player);
119  		try
120  		{
121  			if (!(user.isAuthorized(&quot;essentials.signs.&quot; + signName.toLowerCase(Locale.ENGLISH) + &quot;.break&quot;)
122  				  || user.isAuthorized(&quot;essentials.signs.break.&quot; + signName.toLowerCase(Locale.ENGLISH))))
123  			{
124  				return false;
125  			}
126  			final SignBreakEvent signEvent = new SignBreakEvent(sign, this, user);
127  			ess.getServer().getPluginManager().callEvent(signEvent);
128  			if (signEvent.isCancelled())
129  			{
130  				return false;
131  			}
132  			return onSignBreak(sign, user, getUsername(user), ess);
133  		}
134  		catch (SignException ex)
135  		{
136  			showError(ess, user.getSource(), ex, signName);
137  			return false;
138  		}
139  	}
140  	protected boolean onSignCreate(final ISign sign, final User player, final String username, final IEssentials ess) throws SignException, ChargeException
141  	{
142  		return true;
143  	}
144  	protected boolean onSignInteract(final ISign sign, final User player, final String username, final IEssentials ess) throws SignException, ChargeException, MaxMoneyException
145  	{
146  		return true;
147  	}
148  	protected boolean onSignBreak(final ISign sign, final User player, final String username, final IEssentials ess) throws SignException, MaxMoneyException
149  	{
150  		return true;
151  	}
152  	protected final boolean onBlockPlace(final Block block, final Player player, final IEssentials ess)
153  	{
154  		User user = ess.getUser(player);
155  		try
156  		{
157  			return onBlockPlace(block, user, getUsername(user), ess);
158  		}
159  		catch (ChargeException ex)
160  		{
161  			showError(ess, user.getSource(), ex, signName);
162  		}
163  		catch (SignException ex)
164  		{
165  			showError(ess, user.getSource(), ex, signName);
166  		}
167  		return false;
168  	}
169  	protected final boolean onBlockInteract(final Block block, final Player player, final IEssentials ess)
170  	{
171  		User user = ess.getUser(player);
172  		try
173  		{
174  			return onBlockInteract(block, user, getUsername(user), ess);
175  		}
176  		catch (ChargeException ex)
177  		{
178  			showError(ess, user.getSource(), ex, signName);
179  		}
180  		catch (SignException ex)
181  		{
182  			showError(ess, user.getSource(), ex, signName);
183  		}
184  		return false;
185  	}
186  	protected final boolean onBlockBreak(final Block block, final Player player, final IEssentials ess) throws MaxMoneyException
187  	{
188  		User user = ess.getUser(player);
189  		try
190  		{
191  			return onBlockBreak(block, user, getUsername(user), ess);
192  		}
193  		catch (SignException ex)
194  		{
195  			showError(ess, user.getSource(), ex, signName);
196  		}
197  		return false;
198  	}
199  	protected boolean onBlockBreak(final Block block, final IEssentials ess)
200  	{
201  		return true;
202  	}
203  	protected boolean onBlockExplode(final Block block, final IEssentials ess)
204  	{
205  		return true;
206  	}
207  	protected boolean onBlockBurn(final Block block, final IEssentials ess)
208  	{
209  		return true;
210  	}
211  	protected boolean onBlockIgnite(final Block block, final IEssentials ess)
212  	{
213  		return true;
214  	}
215  	protected boolean onBlockPush(final Block block, final IEssentials ess)
216  	{
217  		return true;
218  	}
219  	protected static boolean checkIfBlockBreaksSigns(final Block block)
220  	{
221  		final Block sign = block.getRelative(BlockFace.UP);
222  		if (sign.getType() == Material.SIGN_POST &amp;&amp; isValidSign(new BlockSign(sign)))
223  		{
224  			return true;
225  		}
226  		final BlockFace[] directions = new BlockFace[]
227  		{
228  			BlockFace.NORTH,
229  			BlockFace.EAST,
230  			BlockFace.SOUTH,
231  			BlockFace.WEST
232  		};
233  		for (BlockFace blockFace : directions)
234  		{
235  			final Block signblock = block.getRelative(blockFace);
236  			if (signblock.getType() == Material.WALL_SIGN)
237  			{
238  				try
239  				{
240  					final org.bukkit.material.Sign signMat = (org.bukkit.material.Sign)signblock.getState().getData();
241  					if (signMat != null &amp;&amp; signMat.getFacing() == blockFace &amp;&amp; isValidSign(new BlockSign(signblock)))
242  					{
243  						return true;
244  					}
245  				}
246  				catch (NullPointerException ex)
247  				{
248  				}
249  			}
250  		}
251  		return false;
252  	}
253  	public static boolean isValidSign(final ISign sign)
254  	{
255  		return sign.getLine(0).matches(&quot;§1\\[.*\\]&quot;);
256  	}
257  	protected boolean onBlockPlace(final Block block, final User player, final String username, final IEssentials ess) throws SignException, ChargeException
258  	{
259  		return true;
260  	}
261  	protected boolean onBlockInteract(final Block block, final User player, final String username, final IEssentials ess) throws SignException, ChargeException
262  	{
263  		return true;
264  	}
265  	protected boolean onBlockBreak(final Block block, final User player, final String username, final IEssentials ess) throws SignException, MaxMoneyException
266  	{
267  		return true;
268  	}
269  	public Set&lt;Material&gt; getBlocks()
270  	{
271  		return EMPTY_SET;
272  	}
273  	public boolean areHeavyEventRequired()
274  	{
275  		return false;
276  	}
277  	private String getSignText(final ISign sign, final int lineNumber)
278  	{
279  		return sign.getLine(lineNumber).trim();
280  	}
281  	protected final void validateTrade(final ISign sign, final int index, final IEssentials ess) throws SignException
282  	{
283  		final String line = getSignText(sign, index);
284  		if (line.isEmpty())
285  		{
286  			return;
287  		}
288  		final Trade trade = getTrade(sign, index, 0, ess);
289  		final BigDecimal money = trade.getMoney();
290  		if (money != null)
291  		{
292  			sign.setLine(index, NumberUtil.shortCurrency(money, ess));
293  		}
294  	}
295  	protected final void validateTrade(final ISign sign, final int amountIndex, final int itemIndex,
296  									   final User player, final IEssentials ess) throws SignException
297  	{
298  		final String itemType = getSignText(sign, itemIndex);
299  		if (itemType.equalsIgnoreCase(&quot;exp&quot;) || itemType.equalsIgnoreCase(&quot;xp&quot;))
300  		{
301  			int amount = getIntegerPositive(getSignText(sign, amountIndex));
302  			sign.setLine(amountIndex, Integer.toString(amount));
303  			sign.setLine(itemIndex, &quot;exp&quot;);
304  			return;
305  		}
306  		final Trade trade = getTrade(sign, amountIndex, itemIndex, player, ess);
307  		final ItemStack item = trade.getItemStack();
308  		sign.setLine(amountIndex, Integer.toString(item.getAmount()));
309  		sign.setLine(itemIndex, itemType);
310  	}
311  	protected final Trade getTrade(final ISign sign, final int amountIndex, final int itemIndex,
312  								   final User player, final IEssentials ess) throws SignException
313  	{
314  		final String itemType = getSignText(sign, itemIndex);
315  		if (itemType.equalsIgnoreCase(&quot;exp&quot;) || itemType.equalsIgnoreCase(&quot;xp&quot;))
316  		{
317  			final int amount = getIntegerPositive(getSignText(sign, amountIndex));
318  			return new Trade(amount, ess);
319  		}
320  		final ItemStack item = getItemStack(itemType, 1, ess);
321  		final int amount = Math.min(getIntegerPositive(getSignText(sign, amountIndex)), item.getType().getMaxStackSize() * player.getBase().getInventory().getSize());
322  		if (item.getType() == Material.AIR || amount &lt; 1)
323  		{
324  			throw new SignException(tl(&quot;moreThanZero&quot;));
325  		}
326  		item.setAmount(amount);
327  		return new Trade(item, ess);
328  	}
329  	protected final void validateInteger(final ISign sign, final int index) throws SignException
330  	{
331  		final String line = getSignText(sign, index);
332  		if (line.isEmpty())
333  		{
334  			throw new SignException(&quot;Empty line &quot; + index);
335  		}
336  		final int quantity = getIntegerPositive(line);
337  		sign.setLine(index, Integer.toString(quantity));
338  	}
339  	protected final int getIntegerPositive(final String line) throws SignException
340  	{
341  		final int quantity = getInteger(line);
342  		if (quantity &lt; 1)
343  		{
344  			throw new SignException(tl(&quot;moreThanZero&quot;));
345  		}
346  		return quantity;
347  	}
348  	protected final int getInteger(final String line) throws SignException
349  	{
350  		try
351  		{
352  			final int quantity = Integer.parseInt(line);
353  			return quantity;
354  		}
355  		catch (NumberFormatException ex)
356  		{
357  			throw new SignException(&quot;Invalid sign&quot;, ex);
358  		}
359  	}
360  	protected final ItemStack getItemStack(final String itemName, final int quantity, final IEssentials ess) throws SignException
361  	{
362  		try
363  		{
364  			final ItemStack item = ess.getItemDb().get(itemName);
365  			item.setAmount(quantity);
366  			return item;
367  		}
368  		catch (Exception ex)
369  		{
370  			throw new SignException(ex.getMessage(), ex);
371  		}
372  	}
373  	protected final ItemStack getItemMeta(final ItemStack item, final String meta, final IEssentials ess) throws SignException
374  	{
375  		ItemStack stack = item;
376  		try
377  		{
378  			if (!meta.isEmpty())
379  			{
380  				MetaItemStack metaStack = new MetaItemStack(stack);
381  				final boolean allowUnsafe = ess.getSettings().allowUnsafeEnchantments();
382  				metaStack.addStringMeta(null, allowUnsafe, meta, ess);
383  				stack = metaStack.getItemStack();
384  			}
385  		}
386  		catch (Exception ex)
387  		{
388  			throw new SignException(ex.getMessage(), ex);
389  		}
390  		return stack;
391  	}
392  	protected final BigDecimal getMoney(final String line) throws SignException
393  	{
394  		final boolean isMoney = line.matches(&quot;^[^0-9-\\.][\\.0-9]+$&quot;);
395  		return isMoney ? getBigDecimalPositive(line.substring(1)) : null;
396  	}
397  	protected final BigDecimal getBigDecimalPositive(final String line) throws SignException
398  	{
399  		final BigDecimal quantity = getBigDecimal(line);
400  		if (quantity.compareTo(MINTRANSACTION) &lt; 0)
401  		{
402  			throw new SignException(tl(&quot;moreThanZero&quot;));
403  		}
404  		return quantity;
405  	}
406  	protected final BigDecimal getBigDecimal(final String line) throws SignException
407  	{
408  		try
409  		{
410  			return new BigDecimal(line);
411  		}
412  		catch (ArithmeticException ex)
413  		{
414  			throw new SignException(ex.getMessage(), ex);
415  		}
416  		catch (NumberFormatException ex)
417  		{
418  			throw new SignException(ex.getMessage(), ex);
419  		}
420  	}
421  	protected final Trade getTrade(final ISign sign, final int index, final IEssentials ess) throws SignException
422  	{
423  		return getTrade(sign, index, 1, ess);
424  	}
425  	protected final Trade getTrade(final ISign sign, final int index, final int decrement, final IEssentials ess) throws SignException
426  	{
427  		final String line = getSignText(sign, index);
428  		if (line.isEmpty())
429  		{
430  			return new Trade(signName.toLowerCase(Locale.ENGLISH) + &quot;sign&quot;, ess);
431  		}
432  		final BigDecimal money = getMoney(line);
433  		if (money == null)
434  		{
435  			final String[] split = line.split(&quot;[ :]+&quot;, 2);
436  			if (split.length != 2)
437  			{
438  				throw new SignException(tl(&quot;invalidCharge&quot;));
439  			}
440  			final int quantity = getIntegerPositive(split[0]);
441  			final String item = split[1].toLowerCase(Locale.ENGLISH);
442  			if (item.equalsIgnoreCase(&quot;times&quot;))
443  			{
444  				sign.setLine(index, (quantity - decrement) + &quot; times&quot;);
445  				sign.updateSign();
446  				return new Trade(signName.toLowerCase(Locale.ENGLISH) + &quot;sign&quot;, ess);
447  			}
448  			else if (item.equalsIgnoreCase(&quot;exp&quot;) || item.equalsIgnoreCase(&quot;xp&quot;))
449  			{
450  				sign.setLine(index, quantity + &quot; exp&quot;);
451  				return new Trade(quantity, ess);
452  			}
453  			else
454  			{
455  				final ItemStack stack = getItemStack(item, quantity, ess);
456  				sign.setLine(index, quantity + &quot; &quot; + item);
457  				return new Trade(stack, ess);
458  			}
459  		}
460  		else
461  		{
462  			return new Trade(money, ess);
463  		}
464  	}
465  	private void showError(final IEssentials ess, final CommandSource sender, final Throwable exception, final String signName)
466  	{
467  		ess.showError(sender, exception, &quot;\\ sign: &quot; + signName);
468  	}
469  	static class EventSign implements ISign
470  	{
471  		private final transient SignChangeEvent event;
472  		private final transient Block block;
473  		private final transient Sign sign;
474  		EventSign(final SignChangeEvent event)
475  		{
476  			this.event = event;
477  			this.block = event.getBlock();
478  			this.sign = (Sign)block.getState();
479  		}
480  		@Override
481  		public final String getLine(final int index)
482  		{
483  			StringBuilder builder = new StringBuilder();
484  			for (char c : event.getLine(index).toCharArray())
485  			{
486  				if (c &lt; 0xF700 || c &gt; 0xF747)
487  				{
488  					builder.append(c);
489  				}
490  			}
491  			return builder.toString();
492  		}
493  		@Override
494  		public final void setLine(final int index, final String text)
495  		{
496  			event.setLine(index, text);
497  			sign.setLine(index, text);
498  			updateSign();
499  		}
500  		@Override
501  		public Block getBlock()
502  		{
503  			return block;
504  		}
505  		@Override
506  		public void updateSign()
507  		{
508  			sign.update();
509  		}
510  	}
511  	static class BlockSign implements ISign
512  	{
513  		private final transient Sign sign;
514  		private final transient Block block;
515  		BlockSign(final Block block)
516  		{
517  			this.block = block;
518  			this.sign = (Sign)block.getState();
519  		}
520  		@Override
521  		public final String getLine(final int index)
522  		{
523  			StringBuilder builder = new StringBuilder();
524  			for (char c : sign.getLine(index).toCharArray())
525  			{
526  				if (c &lt; 0xF700 || c &gt; 0xF747)
527  				{
528  					builder.append(c);
529  				}
530  			}
531  			return builder.toString();
532  		}
533  		@Override
534  		public final void setLine(final int index, final String text)
535  		{
536  			sign.setLine(index, text);
537  		}
538  		@Override
539  		public final Block getBlock()
540  		{
541  			return block;
542  		}
543  		@Override
544  		public final void updateSign()
545  		{
546  			sign.update();
547  		}
548  	}
549  	public interface ISign
550  	{
551  		public String getLine(final int index);
552  		public void setLine(final int index, final String text);
553  		public Block getBlock();
554  		public void updateSign();
555  	}
556  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-EssentialsSign.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-EssentialsSign.java</div>
                </div>
                <div class="column column_space"><pre><code>42  		if (signEvent.isCancelled())
43  		{
44  			return false;
45  		}
46  		try
47  		{
48  			final boolean ret = onSignCreate(sign, user, getUsername(user), ess);
</pre></code></div>
                <div class="column column_space"><pre><code>85  		if (user.checkSignThrottle())
86  		{
87  			return false;
88  		}
89  		try
90  		{
91  			if (user.getBase().isDead() || !(user.isAuthorized(&quot;essentials.signs.&quot; + signName.toLowerCase(Locale.ENGLISH) + &quot;.use&quot;)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    