<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ForwardingSortedSetTest.java & ConcurrentHashMultiset_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ForwardingSortedSetTest.java & ConcurrentHashMultiset_1.java
      </h3>
      <h1 align="center">
        17.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ForwardingSortedSetTest.java (35.585587%)<TH>ConcurrentHashMultiset_1.java (11.549707%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match277892-0.html#0',2,'match277892-1.html#0',3)" NAME="0">(58-68)<TD><A HREF="javascript:ZweiFrames('match277892-0.html#0',2,'match277892-1.html#0',3)" NAME="0">(459-468)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match277892-0.html#1',2,'match277892-1.html#1',3)" NAME="1">(17-33)<TD><A HREF="javascript:ZweiFrames('match277892-0.html#1',2,'match277892-1.html#1',3)" NAME="1">(17-34)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match277892-0.html#2',2,'match277892-1.html#2',3)" NAME="2">(94-103)<TD><A HREF="javascript:ZweiFrames('match277892-0.html#2',2,'match277892-1.html#2',3)" NAME="2">(493-502)</A><TD ALIGN=center><FONT COLOR="#df0000">14</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match277892-0.html#3',2,'match277892-1.html#3',3)" NAME="3">(74-81)<TD><A HREF="javascript:ZweiFrames('match277892-0.html#3',2,'match277892-1.html#3',3)" NAME="3">(469-476)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match277892-0.html#4',2,'match277892-1.html#4',3)" NAME="4">(106-113)<TD><A HREF="javascript:ZweiFrames('match277892-0.html#4',2,'match277892-1.html#4',3)" NAME="4">(548-555)</A><TD ALIGN=center><FONT COLOR="#af0000">11</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match277892-0.html#5',2,'match277892-1.html#5',3)" NAME="5">(48-54)<TD><A HREF="javascript:ZweiFrames('match277892-0.html#5',2,'match277892-1.html#5',3)" NAME="5">(453-459)</A><TD ALIGN=center><FONT COLOR="#8f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ForwardingSortedSetTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2010 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="1"></A> * limitations under the License.
 */

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match277892-1.html#1',3,'match277892-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.collect;

import com.google.common.base.Function;
import com.google.common.collect.testing.SafeTreeSet;
import com.google.common.collect.testing.SortedSetTestSuiteBuilder;
import com.google.common.collect.testing.TestStringSortedSetGenerator;
import com.google.common.collect.testing.features.CollectionFeature;
import com.google.common.collect.testing.features.CollectionSize;
import com.google.common.testing.EqualsTester;
import com.google.common.testing.ForwardingWrapperTester;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.SortedSet;
import junit.framework.Test;
import junit.framework.TestCase;
import</B></FONT> junit.framework.TestSuite;

/**
 * Tests for {@code ForwardingSortedSet}.
 *
 * @author Louis Wasserman
 */
public class ForwardingSortedSetTest extends TestCase {
  static class StandardImplForwardingSortedSet&lt;T&gt; extends ForwardingSortedSet&lt;T&gt; {
    private final SortedSet&lt;T&gt; backingSortedSet;

    StandardImplForwardingSortedSet(SortedSet&lt;T&gt; backingSortedSet) {
<A NAME="5"></A>      this.backingSortedSet = backingSortedSet;
    }

    <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match277892-1.html#5',3,'match277892-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
    protected SortedSet&lt;T&gt; delegate() {
      return backingSortedSet;
    }

    @Override
    public boolean equals(Object object</B></FONT>) {
<A NAME="0"></A>      return standardEquals(object);
    }

    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match277892-1.html#0',3,'match277892-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
    public int hashCode() {
      return standardHashCode();
    }

    @Override
    public boolean addAll(Collection&lt;? extends T&gt; collection) {
      return standardAddAll(collection);
    }

    @</B></FONT>Override
    public void clear() {
      standardClear();
<A NAME="3"></A>    }

    @Override
    public boolean contains(Object object) <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match277892-1.html#3',3,'match277892-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
      return standardContains(object);
    }

    @Override
    public boolean containsAll(Collection&lt;?&gt; collection) {
      return standardContainsAll(collection);
    }</B></FONT>

    @Override
    public boolean remove(Object object) {
      return standardRemove(object);
    }

    @Override
    public boolean removeAll(Collection&lt;?&gt; collection) {
      return standardRemoveAll(collection);
<A NAME="2"></A>    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; collection) <FONT color="#980517"><A HREF="javascript:ZweiFrames('match277892-1.html#2',3,'match277892-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
      return standardRetainAll(collection);
    }

    @Override
    public Object[] toArray() {
      return standardToArray();
    }

<A NAME="4"></A>    @</B></FONT>Override
    public &lt;T&gt; T[] toArray(T[] array) {
      return standardToArray(array);
    <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match277892-1.html#4',3,'match277892-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Override
    public String toString() {
      return standardToString();
    }

    @</B></FONT>Override
    public SortedSet&lt;T&gt; subSet(T fromElement, T toElement) {
      return standardSubSet(fromElement, toElement);
    }
  }

  public static Test suite() {
    TestSuite suite = new TestSuite();

    suite.addTestSuite(ForwardingSortedSetTest.class);
    suite.addTest(
        SortedSetTestSuiteBuilder.using(
                new TestStringSortedSetGenerator() {
                  @Override
                  protected SortedSet&lt;String&gt; create(String[] elements) {
                    return new StandardImplForwardingSortedSet&lt;&gt;(
                        new SafeTreeSet&lt;String&gt;(Arrays.asList(elements)));
                  }

                  @Override
                  public List&lt;String&gt; order(List&lt;String&gt; insertionOrder) {
                    return Lists.newArrayList(Sets.newTreeSet(insertionOrder));
                  }
                })
            .named(&quot;ForwardingSortedSet[SafeTreeSet] with standard implementations&quot;)
            .withFeatures(
                CollectionSize.ANY,
                CollectionFeature.KNOWN_ORDER,
                CollectionFeature.GENERAL_PURPOSE)
            .createTestSuite());

    return suite;
  }

  @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
  public void testForwarding() {
    new ForwardingWrapperTester()
        .testForwarding(
            SortedSet.class,
            new Function&lt;SortedSet, SortedSet&gt;() {
              @Override
              public SortedSet apply(SortedSet delegate) {
                return wrap(delegate);
              }
            });
  }

  public void testEquals() {
    SortedSet&lt;String&gt; set1 = ImmutableSortedSet.of(&quot;one&quot;);
    SortedSet&lt;String&gt; set2 = ImmutableSortedSet.of(&quot;two&quot;);
    new EqualsTester()
        .addEqualityGroup(set1, wrap(set1), wrap(set1))
        .addEqualityGroup(set2, wrap(set2))
        .testEquals();
  }

  private static &lt;T&gt; SortedSet&lt;T&gt; wrap(final SortedSet&lt;T&gt; delegate) {
    return new ForwardingSortedSet&lt;T&gt;() {
      @Override
      protected SortedSet&lt;T&gt; delegate() {
        return delegate;
      }
    };
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConcurrentHashMultiset_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="1"></A> * limitations under the License.
 */

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match277892-0.html#1',2,'match277892-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Serialization.FieldSetter;
import com.google.common.math.IntMath;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.j2objc.annotations.WeakOuter;
import java.io.IOException;
import java.io.ObjectInputStream;
import</B></FONT> java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A multiset that supports concurrent modifications and that provides atomic versions of most
 * {@code Multiset} operations (exceptions where noted). Null elements are not supported.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * &quot;https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset&quot;&gt;{@code Multiset}&lt;/a&gt;.
 *
 * @author Cliff L. Biffle
 * @author mike nonemacher
 * @since 2.0
 */
@GwtIncompatible
@ElementTypesAreNonnullByDefault
public final class ConcurrentHashMultiset&lt;E&gt; extends AbstractMultiset&lt;E&gt; implements Serializable {

  /*
   * The ConcurrentHashMultiset's atomic operations are implemented primarily in terms of
   * AtomicInteger's atomic operations, with some help from ConcurrentMap's atomic operations on
   * creation and removal (including automatic removal of zeroes). If the modification of an
   * AtomicInteger results in zero, we compareAndSet the value to zero; if that succeeds, we remove
   * the entry from the Map. If another operation sees a zero in the map, it knows that the entry is
   * about to be removed, so this operation may remove it (often by replacing it with a new
   * AtomicInteger).
   */

  /** The number of occurrences of each element. */
  private final transient ConcurrentMap&lt;E, AtomicInteger&gt; countMap;

  // This constant allows the deserialization code to set a final field. This holder class
  // makes sure it is not initialized unless an instance is deserialized.
  private static class FieldSettersHolder {
    static final FieldSetter&lt;ConcurrentHashMultiset&gt; COUNT_MAP_FIELD_SETTER =
        Serialization.getFieldSetter(ConcurrentHashMultiset.class, &quot;countMap&quot;);
  }

  /**
   * Creates a new, empty {@code ConcurrentHashMultiset} using the default initial capacity, load
   * factor, and concurrency settings.
   */
  public static &lt;E&gt; ConcurrentHashMultiset&lt;E&gt; create() {
    // TODO(schmoe): provide a way to use this class with other (possibly arbitrary)
    // ConcurrentMap implementors. One possibility is to extract most of this class into
    // an AbstractConcurrentMapMultiset.
    return new ConcurrentHashMultiset&lt;&gt;(new ConcurrentHashMap&lt;E, AtomicInteger&gt;());
  }

  /**
   * Creates a new {@code ConcurrentHashMultiset} containing the specified elements, using the
   * default initial capacity, load factor, and concurrency settings.
   *
   * &lt;p&gt;This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.
   *
   * @param elements the elements that the multiset should contain
   */
  public static &lt;E&gt; ConcurrentHashMultiset&lt;E&gt; create(Iterable&lt;? extends E&gt; elements) {
    ConcurrentHashMultiset&lt;E&gt; multiset = ConcurrentHashMultiset.create();
    Iterables.addAll(multiset, elements);
    return multiset;
  }

  /**
   * Creates a new, empty {@code ConcurrentHashMultiset} using {@code countMap} as the internal
   * backing map.
   *
   * &lt;p&gt;This instance will assume ownership of {@code countMap}, and other code should not maintain
   * references to the map or modify it in any way.
   *
   * &lt;p&gt;The returned multiset is serializable if the input map is.
   *
   * @param countMap backing map for storing the elements in the multiset and their counts. It must
   *     be empty.
   * @throws IllegalArgumentException if {@code countMap} is not empty
   * @since 20.0
   */
  @Beta
  public static &lt;E&gt; ConcurrentHashMultiset&lt;E&gt; create(ConcurrentMap&lt;E, AtomicInteger&gt; countMap) {
    return new ConcurrentHashMultiset&lt;&gt;(countMap);
  }

  @VisibleForTesting
  ConcurrentHashMultiset(ConcurrentMap&lt;E, AtomicInteger&gt; countMap) {
    checkArgument(countMap.isEmpty(), &quot;the backing map (%s) must be empty&quot;, countMap);
    this.countMap = countMap;
  }

  // Query Operations

  /**
   * Returns the number of occurrences of {@code element} in this multiset.
   *
   * @param element the element to look for
   * @return the nonnegative number of occurrences of the element
   */
  @Override
  public int count(@CheckForNull Object element) {
    AtomicInteger existingCounter = Maps.safeGet(countMap, element);
    return (existingCounter == null) ? 0 : existingCounter.get();
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;If the data in the multiset is modified by any other threads during this method, it is
   * undefined which (if any) of these modifications will be reflected in the result.
   */
  @Override
  public int size() {
    long sum = 0L;
    for (AtomicInteger value : countMap.values()) {
      sum += value.get();
    }
    return Ints.saturatedCast(sum);
  }

  /*
   * Note: the superclass toArray() methods assume that size() gives a correct
   * answer, which ours does not.
   */

  @Override
  public Object[] toArray() {
    return snapshot().toArray();
  }

  @Override
  @SuppressWarnings(&quot;nullness&quot;) // b/192354773 in our checker affects toArray declarations
  public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
    return snapshot().toArray(array);
  }

  /*
   * We'd love to use 'new ArrayList(this)' or 'list.addAll(this)', but
   * either of these would recurse back to us again!
   */
  private List&lt;E&gt; snapshot() {
    List&lt;E&gt; list = Lists.newArrayListWithExpectedSize(size());
    for (Multiset.Entry&lt;E&gt; entry : entrySet()) {
      E element = entry.getElement();
      for (int i = entry.getCount(); i &gt; 0; i--) {
        list.add(element);
      }
    }
    return list;
  }

  // Modification Operations

  /**
   * Adds a number of occurrences of the specified element to this multiset.
   *
   * @param element the element to add
   * @param occurrences the number of occurrences to add
   * @return the previous count of the element before the operation; possibly zero
   * @throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting amount
   *     would exceed {@link Integer#MAX_VALUE}
   */
  @CanIgnoreReturnValue
  @Override
  public int add(E element, int occurrences) {
    checkNotNull(element);
    if (occurrences == 0) {
      return count(element);
    }
    CollectPreconditions.checkPositive(occurrences, &quot;occurrences&quot;);

    while (true) {
      AtomicInteger existingCounter = Maps.safeGet(countMap, element);
      if (existingCounter == null) {
        existingCounter = countMap.putIfAbsent(element, new AtomicInteger(occurrences));
        if (existingCounter == null) {
          return 0;
        }
        // existingCounter != null: fall through to operate against the existing AtomicInteger
      }

      while (true) {
        int oldValue = existingCounter.get();
        if (oldValue != 0) {
          try {
            int newValue = IntMath.checkedAdd(oldValue, occurrences);
            if (existingCounter.compareAndSet(oldValue, newValue)) {
              // newValue can't == 0, so no need to check &amp; remove
              return oldValue;
            }
          } catch (ArithmeticException overflow) {
            throw new IllegalArgumentException(
                &quot;Overflow adding &quot; + occurrences + &quot; occurrences to a count of &quot; + oldValue);
          }
        } else {
          // In the case of a concurrent remove, we might observe a zero value, which means another
          // thread is about to remove (element, existingCounter) from the map. Rather than wait,
          // we can just do that work here.
          AtomicInteger newCounter = new AtomicInteger(occurrences);
          if ((countMap.putIfAbsent(element, newCounter) == null)
              || countMap.replace(element, existingCounter, newCounter)) {
            return 0;
          }
          break;
        }
      }

      // If we're still here, there was a race, so just try again.
    }
  }

  /**
   * Removes a number of occurrences of the specified element from this multiset. If the multiset
   * contains fewer than this number of occurrences to begin with, all occurrences will be removed.
   *
   * @param element the element whose occurrences should be removed
   * @param occurrences the number of occurrences of the element to remove
   * @return the count of the element before the operation; possibly zero
   * @throws IllegalArgumentException if {@code occurrences} is negative
   */
  /*
   * TODO(cpovirk): remove and removeExactly currently accept null inputs only
   * if occurrences == 0. This satisfies both NullPointerTester and
   * CollectionRemoveTester.testRemove_nullAllowed, but it's not clear that it's
   * a good policy, especially because, in order for the test to pass, the
   * parameter must be misleadingly annotated as @Nullable. I suspect that
   * we'll want to remove @Nullable, add an eager checkNotNull, and loosen up
   * testRemove_nullAllowed.
   */
  @CanIgnoreReturnValue
  @Override
  public int remove(@CheckForNull Object element, int occurrences) {
    if (occurrences == 0) {
      return count(element);
    }
    CollectPreconditions.checkPositive(occurrences, &quot;occurrences&quot;);

    AtomicInteger existingCounter = Maps.safeGet(countMap, element);
    if (existingCounter == null) {
      return 0;
    }
    while (true) {
      int oldValue = existingCounter.get();
      if (oldValue != 0) {
        int newValue = Math.max(0, oldValue - occurrences);
        if (existingCounter.compareAndSet(oldValue, newValue)) {
          if (newValue == 0) {
            // Just CASed to 0; remove the entry to clean up the map. If the removal fails,
            // another thread has already replaced it with a new counter, which is fine.
            countMap.remove(element, existingCounter);
          }
          return oldValue;
        }
      } else {
        return 0;
      }
    }
  }

  /**
   * Removes exactly the specified number of occurrences of {@code element}, or makes no change if
   * this is not possible.
   *
   * &lt;p&gt;This method, in contrast to {@link #remove(Object, int)}, has no effect when the element
   * count is smaller than {@code occurrences}.
   *
   * @param element the element to remove
   * @param occurrences the number of occurrences of {@code element} to remove
   * @return {@code true} if the removal was possible (including if {@code occurrences} is zero)
   * @throws IllegalArgumentException if {@code occurrences} is negative
   */
  @CanIgnoreReturnValue
  public boolean removeExactly(@CheckForNull Object element, int occurrences) {
    if (occurrences == 0) {
      return true;
    }
    CollectPreconditions.checkPositive(occurrences, &quot;occurrences&quot;);

    AtomicInteger existingCounter = Maps.safeGet(countMap, element);
    if (existingCounter == null) {
      return false;
    }
    while (true) {
      int oldValue = existingCounter.get();
      if (oldValue &lt; occurrences) {
        return false;
      }
      int newValue = oldValue - occurrences;
      if (existingCounter.compareAndSet(oldValue, newValue)) {
        if (newValue == 0) {
          // Just CASed to 0; remove the entry to clean up the map. If the removal fails,
          // another thread has already replaced it with a new counter, which is fine.
          countMap.remove(element, existingCounter);
        }
        return true;
      }
    }
  }

  /**
   * Adds or removes occurrences of {@code element} such that the {@link #count} of the element
   * becomes {@code count}.
   *
   * @return the count of {@code element} in the multiset before this call
   * @throws IllegalArgumentException if {@code count} is negative
   */
  @CanIgnoreReturnValue
  @Override
  public int setCount(E element, int count) {
    checkNotNull(element);
    checkNonnegative(count, &quot;count&quot;);
    while (true) {
      AtomicInteger existingCounter = Maps.safeGet(countMap, element);
      if (existingCounter == null) {
        if (count == 0) {
          return 0;
        } else {
          existingCounter = countMap.putIfAbsent(element, new AtomicInteger(count));
          if (existingCounter == null) {
            return 0;
          }
          // existingCounter != null: fall through
        }
      }

      while (true) {
        int oldValue = existingCounter.get();
        if (oldValue == 0) {
          if (count == 0) {
            return 0;
          } else {
            AtomicInteger newCounter = new AtomicInteger(count);
            if ((countMap.putIfAbsent(element, newCounter) == null)
                || countMap.replace(element, existingCounter, newCounter)) {
              return 0;
            }
          }
          break;
        } else {
          if (existingCounter.compareAndSet(oldValue, count)) {
            if (count == 0) {
              // Just CASed to 0; remove the entry to clean up the map. If the removal fails,
              // another thread has already replaced it with a new counter, which is fine.
              countMap.remove(element, existingCounter);
            }
            return oldValue;
          }
        }
      }
    }
  }

  /**
   * Sets the number of occurrences of {@code element} to {@code newCount}, but only if the count is
   * currently {@code expectedOldCount}. If {@code element} does not appear in the multiset exactly
   * {@code expectedOldCount} times, no changes will be made.
   *
   * @return {@code true} if the change was successful. This usually indicates that the multiset has
   *     been modified, but not always: in the case that {@code expectedOldCount == newCount}, the
   *     method will return {@code true} if the condition was met.
   * @throws IllegalArgumentException if {@code expectedOldCount} or {@code newCount} is negative
   */
  @CanIgnoreReturnValue
  @Override
  public boolean setCount(E element, int expectedOldCount, int newCount) {
    checkNotNull(element);
    checkNonnegative(expectedOldCount, &quot;oldCount&quot;);
    checkNonnegative(newCount, &quot;newCount&quot;);

    AtomicInteger existingCounter = Maps.safeGet(countMap, element);
    if (existingCounter == null) {
      if (expectedOldCount != 0) {
        return false;
      } else if (newCount == 0) {
        return true;
      } else {
        // if our write lost the race, it must have lost to a nonzero value, so we can stop
        return countMap.putIfAbsent(element, new AtomicInteger(newCount)) == null;
      }
    }
    int oldValue = existingCounter.get();
    if (oldValue == expectedOldCount) {
      if (oldValue == 0) {
        if (newCount == 0) {
          // Just observed a 0; try to remove the entry to clean up the map
          countMap.remove(element, existingCounter);
          return true;
        } else {
          AtomicInteger newCounter = new AtomicInteger(newCount);
          return (countMap.putIfAbsent(element, newCounter) == null)
              || countMap.replace(element, existingCounter, newCounter);
        }
      } else {
        if (existingCounter.compareAndSet(oldValue, newCount)) {
          if (newCount == 0) {
            // Just CASed to 0; remove the entry to clean up the map. If the removal fails,
            // another thread has already replaced it with a new counter, which is fine.
            countMap.remove(element, existingCounter);
          }
          return true;
        }
      }
    }
    return false;
  }

  // Views

  @Override
<A NAME="5"></A>  Set&lt;E&gt; createElementSet() {
    Set&lt;E&gt; delegate = countMap.keySet();
    return new ForwardingSet&lt;E&gt;() {
      <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match277892-0.html#5',2,'match277892-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
      protected Set&lt;E&gt; delegate() {
        return delegate;
<A NAME="0"></A>      }

      @Override
      public boolean contains(<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match277892-0.html#0',2,'match277892-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@CheckForNull Object object</B></FONT>) {
        return object != null &amp;&amp; Collections2.safeContains(delegate, object);
      }

      @Override
      public boolean containsAll(Collection&lt;?&gt; collection) {
        return standardContainsAll(collection);
<A NAME="3"></A>      }

      @</B></FONT>Override
      public boolean remove(@CheckForNull Object object) <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match277892-0.html#3',2,'match277892-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        return object != null &amp;&amp; Collections2.safeRemove(delegate, object);
      }

      @Override
      public boolean removeAll(Collection&lt;?&gt; c) {
        return standardRemoveAll(c);
      }</B></FONT>
    };
  }

  @Override
  Iterator&lt;E&gt; elementIterator() {
    throw new AssertionError(&quot;should never be called&quot;);
  }

  /** @deprecated Internal method, use {@link #entrySet()}. */
  @Deprecated
  @Override
  public Set&lt;Multiset.Entry&lt;E&gt;&gt; createEntrySet() {
    return new EntrySet();
<A NAME="2"></A>  }

  @Override
  int distinctElements() <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match277892-0.html#2',2,'match277892-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    return countMap.size();
  }

  @Override
  public boolean isEmpty() {
    return countMap.isEmpty();
  }

  @</B></FONT>Override
  Iterator&lt;Entry&lt;E&gt;&gt; entryIterator() {
    // AbstractIterator makes this fairly clean, but it doesn't support remove(). To support
    // remove(), we create an AbstractIterator, and then use ForwardingIterator to delegate to it.
    Iterator&lt;Entry&lt;E&gt;&gt; readOnlyIterator =
        new AbstractIterator&lt;Entry&lt;E&gt;&gt;() {
          private final Iterator&lt;Map.Entry&lt;E, AtomicInteger&gt;&gt; mapEntries =
              countMap.entrySet().iterator();

          @Override
          @CheckForNull
          protected Entry&lt;E&gt; computeNext() {
            while (true) {
              if (!mapEntries.hasNext()) {
                return endOfData();
              }
              Map.Entry&lt;E, AtomicInteger&gt; mapEntry = mapEntries.next();
              int count = mapEntry.getValue().get();
              if (count != 0) {
                return Multisets.immutableEntry(mapEntry.getKey(), count);
              }
            }
          }
        };

    return new ForwardingIterator&lt;Entry&lt;E&gt;&gt;() {
      @CheckForNull private Entry&lt;E&gt; last;

      @Override
      protected Iterator&lt;Entry&lt;E&gt;&gt; delegate() {
        return readOnlyIterator;
      }

      @Override
      public Entry&lt;E&gt; next() {
        last = super.next();
        return last;
      }

      @Override
      public void remove() {
        checkState(last != null, &quot;no calls to next() since the last call to remove()&quot;);
        ConcurrentHashMultiset.this.setCount(last.getElement(), 0);
<A NAME="4"></A>        last = null;
      }
    };
  <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match277892-0.html#4',2,'match277892-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  @Override
  public Iterator&lt;E&gt; iterator() {
    return Multisets.iteratorImpl(this);
  }

  @</B></FONT>Override
  public void clear() {
    countMap.clear();
  }

  @WeakOuter
  private class EntrySet extends AbstractMultiset&lt;E&gt;.EntrySet {
    @Override
    ConcurrentHashMultiset&lt;E&gt; multiset() {
      return ConcurrentHashMultiset.this;
    }

    /*
     * Note: the superclass toArray() methods assume that size() gives a correct
     * answer, which ours does not.
     */

    @Override
    public Object[] toArray() {
      return snapshot().toArray();
    }

    @Override
    @SuppressWarnings(&quot;nullness&quot;) // b/192354773 in our checker affects toArray declarations
    public &lt;T extends @Nullable Object&gt; T[] toArray(T[] array) {
      return snapshot().toArray(array);
    }

    private List&lt;Multiset.Entry&lt;E&gt;&gt; snapshot() {
      List&lt;Multiset.Entry&lt;E&gt;&gt; list = Lists.newArrayListWithExpectedSize(size());
      // Not Iterables.addAll(list, this), because that'll forward right back here.
      Iterators.addAll(list, iterator());
      return list;
    }
  }

  /** @serialData the ConcurrentMap of elements and their counts. */
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeObject(countMap);
  }

  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    @SuppressWarnings(&quot;unchecked&quot;) // reading data stored by writeObject
    ConcurrentMap&lt;E, Integer&gt; deserializedCountMap =
        (ConcurrentMap&lt;E, Integer&gt;) stream.readObject();
    FieldSettersHolder.COUNT_MAP_FIELD_SETTER.set(this, deserializedCountMap);
  }

  private static final long serialVersionUID = 1;
}
</PRE>
</div>
  </div>
</body>
</html>
