<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for IncrementalClusterStateWriterTests.java &amp; ReplicaShardAllocatorTests.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for IncrementalClusterStateWriterTests.java &amp; ReplicaShardAllocatorTests.java
      </h3>
<h1 align="center">
        36.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>IncrementalClusterStateWriterTests.java (42.984695%)<th>ReplicaShardAllocatorTests.java (32.37272%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-72)<td><a href="#" name="0">(20-73)</a><td align="center"><font color="#ff0000">50</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(292-298)<td><a href="#" name="1">(205-211)</a><td align="center"><font color="#750000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(117-129)<td><a href="#" name="2">(473-479)</a><td align="center"><font color="#5b0000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(139-148)<td><a href="#" name="3">(94-98)</a><td align="center"><font color="#560000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(178-188)<td><a href="#" name="4">(111-120)</a><td align="center"><font color="#4c0000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(280-285)<td><a href="#" name="5">(458-467)</a><td align="center"><font color="#470000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(494-509)<td><a href="#" name="6">(355-360)</a><td align="center"><font color="#420000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(385-394)<td><a href="#" name="7">(482-490)</a><td align="center"><font color="#3d0000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(239-246)<td><a href="#" name="8">(444-450)</a><td align="center"><font color="#3d0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(316-322)<td><a href="#" name="9">(559-565)</a><td align="center"><font color="#380000">11</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(215-221)<td><a href="#" name="10">(229-233)</a><td align="center"><font color="#380000">11</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(208-214)<td><a href="#" name="11">(166-171)</a><td align="center"><font color="#380000">11</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(202-207)<td><a href="#" name="12">(152-160)</a><td align="center"><font color="#380000">11</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(195-200)<td><a href="#" name="13">(138-146)</a><td align="center"><font color="#380000">11</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(189-194)<td><a href="#" name="14">(123-132)</a><td align="center"><font color="#380000">11</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(157-164)<td><a href="#" name="15">(351-354)</a><td align="center"><font color="#380000">11</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(88-95)<td><a href="#" name="16">(433-437)</a><td align="center"><font color="#380000">11</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(480-484)<td><a href="#" name="17">(236-240)</a><td align="center"><font color="#330000">10</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(133-137)<td><a href="#" name="18">(438-442)</a><td align="center"><font color="#330000">10</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(95-98)<td><a href="#" name="19">(105-111)</a><td align="center"><font color="#330000">10</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(272-276)<td><a href="#" name="20">(341-344)</a><td align="center"><font color="#2d0000">9</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(252-261)<td><a href="#" name="21">(422-425)</a><td align="center"><font color="#2d0000">9</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(167-171)<td><a href="#" name="22">(258-268)</a><td align="center"><font color="#2d0000">9</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(110-114)<td><a href="#" name="23">(184-188)</a><td align="center"><font color="#2d0000">9</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(104-107)<td><a href="#" name="24">(199-201)</a><td align="center"><font color="#2d0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>IncrementalClusterStateWriterTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package org.elasticsearch.gateway;
2 import org.apache.logging.log4j.Level;
3 import org.apache.logging.log4j.LogManager;
4 import org.apache.logging.log4j.Logger;
5 import org.apache.lucene.store.Directory;
6 import org.apache.lucene.store.MockDirectoryWrapper;
7 import org.elasticsearch.Version;
8 import org.elasticsearch.cluster.ClusterName;
9 import org.elasticsearch.cluster.ClusterState;
10 import org.elasticsearch.cluster.ESAllocationTestCase;
11 import org.elasticsearch.cluster.metadata.IndexMetadata;
12 import org.elasticsearch.cluster.metadata.Manifest;
13 import org.elasticsearch.cluster.metadata.Metadata;
14 import org.elasticsearch.cluster.node.DiscoveryNode;
15 import org.elasticsearch.cluster.node.DiscoveryNodeRole;
16 import org.elasticsearch.cluster.node.DiscoveryNodes;
17 import org.elasticsearch.cluster.routing.RoutingTable;
18 import org.elasticsearch.cluster.routing.allocation.AllocationService;
19 import org.elasticsearch.cluster.routing.allocation.decider.ClusterRebalanceAllocationDecider;
20 import org.elasticsearch.common.UUIDs;
21 import org.elasticsearch.common.logging.Loggers;
22 import org.elasticsearch.common.settings.ClusterSettings;
23 import org.elasticsearch.common.settings.Settings;
24 import org.elasticsearch.common.xcontent.NamedXContentRegistry;
25 import org.elasticsearch.common.xcontent.XContentBuilder;
26 import org.elasticsearch.common.xcontent.XContentParser;
27 import org.elasticsearch.env.NodeEnvironment;
28 import org.elasticsearch.index.Index;
29 import org.elasticsearch.test.MockLogAppender;
30 import org.elasticsearch.test.junit.annotations.TestLogging;
31 import org.junit.Test;
32 import org.mockito.ArgumentCaptor;
33 import io.crate.common.collections.Tuple;
34 import java.io.IOException;
35 import java.nio.file.Path;
36 import java.util.Collections;
37 import java.util.HashMap;
38 import java.util.HashSet;
39 import java.util.List;
40 import java.util.Map;
41 import java.util.Set;
42 import java.util.concurrent.atomic.AtomicLong;
43 import static org.hamcrest.Matchers.containsString;
44 import static org.hamcrest.Matchers.equalTo;
45 import static org.hamcrest.Matchers.hasSize;
46 import static org.hamcrest.Matchers.lessThan;
47 import static org.mockito.Matchers.anyString;
48 import static org.mockito.Matchers.eq;
49 import static org.mockito.Mockito.mock;
50 import</b></font> static org.mockito.Mockito.times;
51 import static org.mockito.Mockito.verify;
52 import static org.mockito.Mockito.verifyNoMoreInteractions;
53 import static org.mockito.Mockito.when;
54 public class IncrementalClusterStateWriterTests extends ESAllocationTestCase {
55     private ClusterState clusterStateWithUnassignedIndex(IndexMetadata indexMetadata, boolean masterEligible) {
56         Metadata metadata = Metadata.builder()
57             .put(indexMetadata, false)
58             .build();
59         RoutingTable routingTable = RoutingTable.builder()
60 <a name="16"></a>            .addAsNew(metadata.index("test"))
61             .build();
62         return <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))
63             .metadata(metadata)
64             .routingTable(routingTable)
65             .nodes(generateDiscoveryNodes(masterEligible))
66 <a name="19"></a>            .build();
67     }
68     private ClusterState clusterStateWithAssignedIndex(IndexMetadata indexMetadata</b></font>, boolean masterEligible) <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
69         AllocationService strategy = createAllocationService(Settings.builder()
70             .put("cluster.routing.allocation.node_concurrent_recoveries", 100)
71             .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey</b></font>(), "always")
72             .put("cluster.routing.allocation.cluster_concurrent_rebalance", 100)
73             .put("cluster.routing.allocation.node_initial_primaries_recoveries", 100)
74 <a name="24"></a>            .build());
75         ClusterState oldClusterState = clusterStateWithUnassignedIndex(indexMetadata, masterEligible);
76         <font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>RoutingTable routingTable = strategy.reroute(oldClusterState, "reroute").routingTable();
77         Metadata metadataNewClusterState = Metadata.builder()
78 <a name="23"></a>            .put(oldClusterState.metadata</b></font>().index("test"), false)
79             .build();
80         return <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ClusterState.builder(oldClusterState).routingTable(routingTable)
81             .metadata(metadataNewClusterState).version(oldClusterState.getVersion() + 1).build();
82     }
83 <a name="2"></a>    private ClusterState clusterStateWithNon</b></font>ReplicatedClosedIndex(IndexMetadata indexMetadata, boolean masterEligible) {
84         ClusterState oldClusterState = clusterStateWithAssignedIndex(indexMetadata, masterEligible);
85         Metadata metadataNewClusterState = <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Metadata.builder()
86             .put(
87                 IndexMetadata.builder("test").settings(settings(Version.CURRENT)
88                     .put(IndexMetadata.SETTING_INDEX_UUID, indexMetadata.getIndexUUID())
89                 )
90                 .state(IndexMetadata.State.CLOSE)
91                 .numberOfShards(5)
92                 .numberOfReplicas(2)
93             )
94             .version(oldClusterState.metadata().version() + 1)
95             .build();
96         RoutingTable routingTable = RoutingTable.builder()
97             .addAsRecovery(metadataNewClusterState.index</b></font>("test"))
98 <a name="18"></a>            .build();
99         return ClusterState.builder(oldClusterState).routingTable(routingTable)
100             .metadata(metadataNewClusterState).version(<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>oldClusterState.getVersion() + 1).build();
101     }
102 <a name="3"></a>    private ClusterState clusterStateWithReplicatedClosedIndex(IndexMetadata indexMetadata, boolean masterEligible, boolean assigned) {
103         ClusterState oldClusterState = clusterStateWithAssignedIndex</b></font>(indexMetadata, masterEligible);
104         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Metadata metadataNewClusterState = Metadata.builder()
105             .put(
106                 IndexMetadata.builder("test").settings(settings(Version.CURRENT)
107                 .put(IndexMetadata.VERIFIED_BEFORE_CLOSE_SETTING.getKey(), true)
108                 .put(IndexMetadata.SETTING_INDEX_UUID, indexMetadata.getIndexUUID())
109                 )
110                 .state(IndexMetadata.State.CLOSE)
111                 .numberOfShards(5)
112                 .numberOfReplicas(2))
113             .version(oldClusterState.metadata</b></font>().version() + 1)
114             .build();
115         RoutingTable routingTable = RoutingTable.builder()
116             .addAsRecovery(metadataNewClusterState.index("test"))
117             .build();
118 <a name="15"></a>        oldClusterState = ClusterState.builder(oldClusterState).routingTable(routingTable)
119             .metadata(metadataNewClusterState).build();
120         if (assigned) {
121             AllocationService strategy = <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>createAllocationService(Settings.builder()
122                 .put("cluster.routing.allocation.node_concurrent_recoveries", 100)
123                 .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(), "always")
124                 .put("cluster.routing.allocation.cluster_concurrent_rebalance", 100)
125                 .put("cluster.routing.allocation.node_initial_primaries_recoveries", 100)
126                 .build());
127 <a name="22"></a>            routingTable = strategy.reroute</b></font>(oldClusterState, "reroute").routingTable();
128         }
129         return <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ClusterState.builder(oldClusterState).routingTable(routingTable)
130             .metadata(metadataNewClusterState).version(oldClusterState.getVersion() + 1).build();
131     }
132     private DiscoveryNodes</b></font>.Builder generateDiscoveryNodes(boolean masterEligible) {
133         Set&lt;DiscoveryNodeRole&gt; dataOnlyRoles = Collections.singleton(DiscoveryNodeRole.DATA_ROLE);
134         return DiscoveryNodes.builder().add(newNode("node1", masterEligible ? MASTER_DATA_ROLES : dataOnlyRoles))
135             .add(newNode("master_node", MASTER_DATA_ROLES)).localNodeId("node1").masterNodeId(masterEligible ? "node1" : "master_node");
136 <a name="4"></a>    }
137     private IndexMetadata createIndexMetadata(String name) {
138         return <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IndexMetadata.builder(name).
139             settings(settings(Version.CURRENT)
140                 .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID(random()))
141             )
142             .numberOfShards(5)
143             .numberOfReplicas(2)
144             .build();
145     }
146 <a name="14"></a>
147     public void testGetRelevantIndicesWithUnassignedShardsOnMasterEligibleNode() {
148         IndexMetadata indexMetadata = createIndexMetadata</b></font>("test");
149         Set&lt;Index&gt; indices = <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IncrementalClusterStateWriter.getRelevantIndices(clusterStateWithUnassignedIndex(indexMetadata, true));
150         assertThat(indices.size(), equalTo(0));
151     }
152 <a name="13"></a>
153     public void testGetRelevantIndicesWithUnassignedShardsOnDataOnlyNode() {
154         IndexMetadata indexMetadata = createIndexMetadata</b></font>("test");
155         Set&lt;Index&gt; indices = <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IncrementalClusterStateWriter.getRelevantIndices(clusterStateWithUnassignedIndex(indexMetadata, false));
156         assertThat(indices.size(), equalTo(0));
157     }
158 <a name="12"></a>    public void testGetRelevantIndicesWithAssignedShards() {
159         IndexMetadata indexMetadata = createIndexMetadata</b></font>("test");
160         boolean masterEligible = randomBoolean();
161         Set&lt;Index&gt; indices = <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IncrementalClusterStateWriter.getRelevantIndices(clusterStateWithAssignedIndex(indexMetadata, masterEligible));
162         assertThat(indices.size(), equalTo(1));
163     }
164 <a name="11"></a>
165     public void testGetRelevantIndicesForNonReplicatedClosedIndexOnDataOnlyNode() {
166         IndexMetadata indexMetadata = createIndexMetadata</b></font>("test");
167         Set&lt;Index&gt; indices = <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IncrementalClusterStateWriter.getRelevantIndices(
168             clusterStateWithNonReplicatedClosedIndex(indexMetadata, false));
169         assertThat(indices.size(), equalTo(0));
170     }
171 <a name="10"></a>
172     public void testGetRelevantIndicesForReplicatedClosedButUnassignedIndexOnDataOnlyNode() {
173         IndexMetadata indexMetadata = createIndexMetadata</b></font>("test");
174         Set&lt;Index&gt; indices = <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IncrementalClusterStateWriter.getRelevantIndices(
175             clusterStateWithReplicatedClosedIndex(indexMetadata, false, false));
176         assertThat(indices.size(), equalTo(0));
177     }
178     public void testGetRelevantIndicesForReplicatedClosedAndAssignedIndexOnDataOnlyNode() {
179         IndexMetadata indexMetadata = createIndexMetadata</b></font>("test");
180         Set&lt;Index&gt; indices = IncrementalClusterStateWriter.getRelevantIndices(
181             clusterStateWithReplicatedClosedIndex(indexMetadata, false, true));
182         assertThat(indices.size(), equalTo(1));
183     }
184     @Test
185     public void testResolveStatesToBeWritten() throws WriteStateException {
186         Map&lt;Index, Long&gt; indices = new HashMap&lt;&gt;();
187         Set&lt;Index&gt; relevantIndices = new HashSet&lt;&gt;();
188         IndexMetadata removedIndex = createIndexMetadata("removed_index");
189         indices.put(removedIndex.getIndex(), 1L);
190         IndexMetadata versionChangedIndex = createIndexMetadata("version_changed_index");
191 <a name="8"></a>        indices.put(versionChangedIndex.getIndex(), 2L);
192         relevantIndices.add(versionChangedIndex.getIndex());
193         IndexMetadata notChangedIndex = <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>createIndexMetadata("not_changed_index");
194         indices.put(notChangedIndex.getIndex(), 3L);
195         relevantIndices.add(notChangedIndex.getIndex());
196         IndexMetadata newIndex = createIndexMetadata("new_index");
197         relevantIndices.add(newIndex.getIndex());
198         Metadata oldMetadata = Metadata.builder()</b></font>
199             .put(removedIndex, false)
200             .put(versionChangedIndex, false)
201 <a name="21"></a>            .put(notChangedIndex, false)
202             .build();
203         Metadata newMetadata = <font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Metadata.builder()
204             .put(versionChangedIndex, true)
205             .put(notChangedIndex, false)
206             .put(newIndex, false)
207             .build();
208         IndexMetadata newVersionChangedIndex = newMetadata.index(versionChangedIndex.getIndex());
209         List&lt;IncrementalClusterStateWriter.IndexMetadataAction&gt; actions =
210             IncrementalClusterStateWriter.resolveIndexMetadataActions</b></font>(indices, relevantIndices, oldMetadata, newMetadata);
211         assertThat(actions, hasSize(3));
212         boolean keptPreviousGeneration = false;
213         boolean wroteNewIndex = false;
214         boolean wroteChangedIndex = false;
215 <a name="20"></a>        for (IncrementalClusterStateWriter.IndexMetadataAction action : actions) {
216             if (action instanceof IncrementalClusterStateWriter.KeepPreviousGeneration) {
217                 assertThat(action.getIndex(), equalTo(notChangedIndex.getIndex()));
218                 <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IncrementalClusterStateWriter.AtomicClusterStateWriter writer
219                     = mock(IncrementalClusterStateWriter.AtomicClusterStateWriter.class);
220                 assertThat(action.execute(writer), equalTo(3L));
221                 verify(writer, times(1)).incrementIndicesSkipped();
222                 verifyNoMoreInteractions</b></font>(writer);
223 <a name="5"></a>                keptPreviousGeneration = true;
224             }
225             if (action instanceof IncrementalClusterStateWriter.WriteNewIndexMetadata) {
226                 assertThat(<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>action.getIndex(), equalTo(newIndex.getIndex()));
227                 IncrementalClusterStateWriter.AtomicClusterStateWriter writer
228                     = mock(IncrementalClusterStateWriter.AtomicClusterStateWriter.class);
229                 when(writer.writeIndex("freshly created", newIndex)).thenReturn(0L);
230                 assertThat(action.execute(writer), equalTo(0L));
231                 verify(writer, times</b></font>(1)).incrementIndicesWritten();
232                 wroteNewIndex = true;
233             }
234             if (action instanceof IncrementalClusterStateWriter.WriteChangedIndexMetadata) {
235 <a name="1"></a>                assertThat(action.getIndex(), equalTo(newVersionChangedIndex.getIndex()));
236                 IncrementalClusterStateWriter.AtomicClusterStateWriter writer
237                     = mock(IncrementalClusterStateWriter.AtomicClusterStateWriter.class);
238                 when(writer.writeIndex(anyString(), <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eq(newVersionChangedIndex))).thenReturn(3L);
239                 assertThat(action.execute(writer), equalTo(3L));
240                 ArgumentCaptor&lt;String&gt; reason = ArgumentCaptor.forClass(String.class);
241                 verify(writer).writeIndex(reason.capture(), eq(newVersionChangedIndex));
242                 verify(writer, times(1)).incrementIndicesWritten();
243                 assertThat(reason.getValue(), containsString(Long.toString(versionChangedIndex.getVersion())));
244                 assertThat(reason.getValue(), containsString(Long.toString(newVersionChangedIndex.getVersion</b></font>())));
245                 wroteChangedIndex = true;
246             }
247         }
248         assertTrue(keptPreviousGeneration);
249         assertTrue(wroteNewIndex);
250         assertTrue(wroteChangedIndex);
251     }
252     private static class MetaStateServiceWithFailures extends MetaStateService {
253         private final int invertedFailRate;
254         private boolean failRandomly;
255         private &lt;T&gt; MetadataStateFormat&lt;T&gt; wrap(MetadataStateFormat&lt;T&gt; format) {
256 <a name="9"></a>            return new MetadataStateFormat&lt;T&gt;(format.getPrefix()) {
257                 @Override
258                 public void toXContent(XContentBuilder builder, T state) throws IOException {
259                     <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>format.toXContent(builder, state);
260                 }
261                 @Override
262                 public T fromXContent(XContentParser parser) throws IOException {
263                     return format.fromXContent(parser);
264                 }</b></font>
265                 @Override
266                 protected Directory newDirectory(Path dir) {
267                     MockDirectoryWrapper mock = newMockFSDirectory(dir);
268                     if (failRandomly) {
269                         MockDirectoryWrapper.Failure fail = new MockDirectoryWrapper.Failure() {
270                             @Override
271                             public void eval(MockDirectoryWrapper dir) throws IOException {
272                                 int r = randomIntBetween(0, invertedFailRate);
273                                 if (r == 0) {
274                                     throw new MockDirectoryWrapper.FakeIOException();
275                                 }
276                             }
277                         };
278                         mock.failOn(fail);
279                     }
280                     closeAfterSuite(mock);
281                     return mock;
282                 }
283             };
284         }
285         MetaStateServiceWithFailures(int invertedFailRate, NodeEnvironment nodeEnv, NamedXContentRegistry namedXContentRegistry) {
286             super(nodeEnv, namedXContentRegistry);
287             META_DATA_FORMAT = wrap(Metadata.FORMAT);
288             INDEX_META_DATA_FORMAT = wrap(IndexMetadata.FORMAT);
289             MANIFEST_FORMAT = wrap(Manifest.FORMAT);
290             failRandomly = false;
291             this.invertedFailRate = invertedFailRate;
292         }
293         void failRandomly() {
294             failRandomly = true;
295         }
296         void noFailures() {
297             failRandomly = false;
298         }
299     }
300     private boolean metadataEquals(Metadata md1, Metadata md2) {
301         boolean equals = Metadata.isGlobalStateEquals(md1, md2);
302         for (IndexMetadata imd : md1) {
303             IndexMetadata imd2 = md2.index(imd.getIndex());
304             equals = equals &amp;&amp; imd.equals(imd2);
305         }
306         for (IndexMetadata imd : md2) {
307             IndexMetadata imd2 = md1.index(imd.getIndex());
308             equals = equals &amp;&amp; imd.equals(imd2);
309         }
310         return equals;
311     }
312     private static Metadata randomMetadataForTx() {
313         int settingNo = randomIntBetween(0, 10);
314         Metadata.Builder builder = Metadata.builder()
315             .persistentSettings(Settings.builder().put("setting" + settingNo, randomAlphaOfLength(5)).build());
316 <a name="7"></a>        int numOfIndices = randomIntBetween(0, 3);
317         for (int i = 0; i &lt; numOfIndices; i++) {
318             int indexNo = <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>randomIntBetween(0, 50);
319             IndexMetadata indexMetadata = IndexMetadata.builder("index" + indexNo).settings(
320                 Settings.builder()
321                     .put(IndexMetadata.SETTING_INDEX_UUID, "index" + indexNo)
322                     .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)
323                     .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)
324                     .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)
325                     .build()
326             ).build();
327             builder.put</b></font>(indexMetadata, false);
328         }
329         return builder.build();
330     }
331     public void testAtomicityWithFailures() throws IOException {
332         try (NodeEnvironment env = newNodeEnvironment()) {
333             MetaStateServiceWithFailures metaStateService =
334                 new MetaStateServiceWithFailures(randomIntBetween(100, 1000), env, xContentRegistry());
335             Manifest manifest = Manifest.empty();
336             Metadata metadata = Metadata.EMPTY_METADATA;
337             metaStateService.writeManifestAndCleanup("startup", Manifest.empty());
338             long currentTerm = randomNonNegativeLong();
339             long clusterStateVersion = randomNonNegativeLong();
340             metaStateService.failRandomly();
341             Set&lt;Metadata&gt; possibleMetadata = new HashSet&lt;&gt;();
342             possibleMetadata.add(metadata);
343             for (int i = 0; i &lt; randomIntBetween(1, 5); i++) {
344                 IncrementalClusterStateWriter.AtomicClusterStateWriter writer =
345                     new IncrementalClusterStateWriter.AtomicClusterStateWriter(metaStateService, manifest);
346                 metadata = randomMetadataForTx();
347                 Map&lt;Index, Long&gt; indexGenerations = new HashMap&lt;&gt;();
348                 try {
349                     long globalGeneration = writer.writeGlobalState("global", metadata);
350                     for (IndexMetadata indexMetadata : metadata) {
351                         long generation = writer.writeIndex("index", indexMetadata);
352                         indexGenerations.put(indexMetadata.getIndex(), generation);
353                     }
354                     Manifest newManifest = new Manifest(currentTerm, clusterStateVersion, globalGeneration, indexGenerations);
355                     writer.writeManifestAndCleanup("manifest", newManifest);
356                     possibleMetadata.clear();
357                     possibleMetadata.add(metadata);
358                     manifest = newManifest;
359                 } catch (WriteStateException e) {
360                     if (e.isDirty()) {
361                         possibleMetadata.add(metadata);
362                         break;
363                     }
364                 }
365             }
366             metaStateService.noFailures();
367             Tuple&lt;Manifest, Metadata&gt; manifestAndMetadata = metaStateService.loadFullState();
368             Metadata loadedMetadata = manifestAndMetadata.v2();
369             assertTrue(possibleMetadata.stream().anyMatch(md -&gt; metadataEquals(md, loadedMetadata)));
370         }
371     }
372     @TestLogging(value = "org.elasticsearch.gateway:WARN")
373     public void testSlowLogging() throws WriteStateException, IllegalAccessException {
374         final long slowWriteLoggingThresholdMillis;
375         final Settings settings;
376         if (randomBoolean()) {
377             slowWriteLoggingThresholdMillis = PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.get(Settings.EMPTY).millis();
378             settings = Settings.EMPTY;
379         } else {
380             slowWriteLoggingThresholdMillis = randomLongBetween(2, 100000);
381             settings = Settings.builder()
382                 .put(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.getKey(), slowWriteLoggingThresholdMillis + "ms")
383                 .build();
384         }
385         final DiscoveryNode localNode = newNode("node");
386         final ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT)
387             .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId())).build();
388         final long startTimeMillis = randomLongBetween(0L, Long.MAX_VALUE - slowWriteLoggingThresholdMillis * 10);
389         final AtomicLong currentTime = new AtomicLong(startTimeMillis);
390         final AtomicLong writeDurationMillis = new AtomicLong(slowWriteLoggingThresholdMillis);
391 <a name="17"></a>
392         final ClusterSettings clusterSettings = new ClusterSettings(settings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
393         final IncrementalClusterStateWriter incrementalClusterStateWriter
394             = <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new IncrementalClusterStateWriter(settings, clusterSettings, mock(MetaStateService.class),
395             new Manifest(randomNonNegativeLong(), randomNonNegativeLong(), randomNonNegativeLong(), Collections.emptyMap()),
396             clusterState, () -&gt; currentTime.getAndAdd(writeDurationMillis.get()));
397         assertExpectedLogs</b></font>(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
398             "should see warning at threshold",
399             IncrementalClusterStateWriter.class.getCanonicalName(),
400             Level.WARN,
401             "writing cluster state took [*] which is above the warn threshold of [*]; " +
402                 "wrote metadata for [0] indices and skipped [0] unchanged indices"));
403 <a name="6"></a>        writeDurationMillis.set(randomLongBetween(slowWriteLoggingThresholdMillis, slowWriteLoggingThresholdMillis * 2));
404         assertExpectedLogs(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
405             "should see warning above threshold",
406             <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>IncrementalClusterStateWriter.class.getCanonicalName(),
407             Level.WARN,
408             "writing cluster state took [*] which is above the warn threshold of [*]; " +
409                 "wrote metadata for [0] indices and skipped [0] unchanged indices"));
410         writeDurationMillis.set(randomLongBetween(1, slowWriteLoggingThresholdMillis - 1));
411         assertExpectedLogs(clusterState, incrementalClusterStateWriter, new MockLogAppender.UnseenEventExpectation(
412             "should not see warning below threshold",
413             IncrementalClusterStateWriter.class.getCanonicalName(),
414             Level.WARN,
415             "*"));
416         clusterSettings.applySettings(Settings.builder()
417             .put(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.getKey(), writeDurationMillis.get() + "ms")
418             .build());
419         assertExpectedLogs</b></font>(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
420             "should see warning at reduced threshold",
421             IncrementalClusterStateWriter.class.getCanonicalName(),
422             Level.WARN,
423             "writing cluster state took [*] which is above the warn threshold of [*]; " +
424                 "wrote metadata for [0] indices and skipped [0] unchanged indices"));
425         assertThat(currentTime.get(), lessThan(startTimeMillis + 10 * slowWriteLoggingThresholdMillis));     }
426     private void assertExpectedLogs(ClusterState clusterState, IncrementalClusterStateWriter incrementalClusterStateWriter,
427                                     MockLogAppender.LoggingExpectation expectation) throws IllegalAccessException, WriteStateException {
428         MockLogAppender mockAppender = new MockLogAppender();
429         mockAppender.start();
430         mockAppender.addExpectation(expectation);
431         Logger classLogger = LogManager.getLogger(IncrementalClusterStateWriter.class);
432         Loggers.addAppender(classLogger, mockAppender);
433         try {
434             incrementalClusterStateWriter.updateClusterState(clusterState);
435         } finally {
436             Loggers.removeAppender(classLogger, mockAppender);
437             mockAppender.stop();
438         }
439         mockAppender.assertAllExpectationsMatched();
440     }
441 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ReplicaShardAllocatorTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.gateway;
2 import com.carrotsearch.randomizedtesting.generators.RandomPicks;
3 import org.elasticsearch.Version;
4 import org.elasticsearch.cluster.ClusterInfo;
5 import org.elasticsearch.cluster.ClusterState;
6 import org.elasticsearch.cluster.metadata.IndexMetadata;
7 import org.elasticsearch.cluster.metadata.Metadata;
8 import org.elasticsearch.cluster.node.DiscoveryNode;
9 import org.elasticsearch.cluster.node.DiscoveryNodes;
10 import org.elasticsearch.cluster.routing.IndexRoutingTable;
11 import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
12 import org.elasticsearch.cluster.routing.RecoverySource;
13 import org.elasticsearch.cluster.routing.RoutingNode;
14 import org.elasticsearch.cluster.routing.RoutingNodes;
15 import org.elasticsearch.cluster.routing.RoutingTable;
16 import org.elasticsearch.cluster.routing.ShardRouting;
17 import org.elasticsearch.cluster.routing.ShardRoutingState;
18 import org.elasticsearch.cluster.routing.TestShardRouting;
19 import org.elasticsearch.cluster.routing.UnassignedInfo;
20 import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;
21 import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;
22 import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;
23 import org.elasticsearch.cluster.routing.allocation.decider.Decision;
24 import org.elasticsearch.cluster.routing.allocation.decider.SameShardAllocationDecider;
25 import org.elasticsearch.common.settings.ClusterSettings;
26 import org.elasticsearch.common.settings.Settings;
27 import org.elasticsearch.index.engine.Engine;
28 import org.elasticsearch.index.seqno.ReplicationTracker;
29 import org.elasticsearch.index.seqno.RetentionLease;
30 import org.elasticsearch.index.shard.ShardId;
31 import org.elasticsearch.index.store.Store;
32 import org.elasticsearch.index.store.StoreFileMetadata;
33 import org.elasticsearch.indices.store.TransportNodesListShardStoreMetadata;
34 import org.elasticsearch.cluster.ESAllocationTestCase;
35 import org.junit.Before;
36 import io.crate.common.unit.TimeValue;
37 import java.util.ArrayList;
38 import java.util.Arrays;
39 import java.util.Collections;
40 import java.util.EnumSet;
41 import java.util.HashMap;
42 import java.util.HashSet;
43 import java.util.List;
44 import java.util.Map;
45 import java.util.Set;
46 import java.util.concurrent.atomic.AtomicBoolean;
47 import static java.util.Collections.unmodifiableMap;
48 import static org.hamcrest.Matchers.empty;
49 import static org.hamcrest.Matchers.equalTo;
50 import</b></font> static org.hamcrest.Matchers.hasSize;
51 public class ReplicaShardAllocatorTests extends ESAllocationTestCase {
52     private static final org.apache.lucene.util.Version MIN_SUPPORTED_LUCENE_VERSION = org.elasticsearch.Version.CURRENT
53         .minimumIndexCompatibilityVersion().luceneVersion;
54     private final ShardId shardId = new ShardId("test", "_na_", 0);
55     private final DiscoveryNode node1 = newNode("node1");
56     private final DiscoveryNode node2 = newNode("node2");
57     private final DiscoveryNode node3 = newNode("node3");
58     private TestAllocator testAllocator;
59     @Before
60     public void buildTestAllocator() {
61         this.testAllocator = new TestAllocator();
62     }
63     public void testNoAsyncFetchData() {
64         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
65         testAllocator.clean();
66         testAllocator.allocateUnassigned(allocation);
67         assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));
68         assertThat(allocation.routingNodes</b></font>().unassigned().ignored().get(0).shardId(), equalTo(shardId));
69     }
70     public void testNoAsyncFetchOnIndexCreation() <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
71         RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY,
72             UnassignedInfo.Reason.INDEX_CREATED);
73 <a name="4"></a>        testAllocator.clean();
74         testAllocator.allocateUnassigned(allocation);
75         assertThat(testAllocator.getFetchDataCalledAndClean(), equalTo(false));
76         assertThat</b></font>(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
77         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
78     }
79     public void testAsyncFetchOnAnythingButIndexCreation() {
80 <a name="14"></a>        UnassignedInfo.Reason reason = RandomPicks.randomFrom</b></font>(random(),
81             EnumSet.complementOf(EnumSet.of(UnassignedInfo.Reason.INDEX_CREATED)));
82         RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY, reason);
83         <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>testAllocator.clean();
84         testAllocator.allocateUnassigned(allocation);
85         assertThat("failed with reason " + reason, testAllocator.getFetchDataCalledAndClean(), equalTo(true));
86     }
87     public void testSimpleFullMatchAllocation() {
88         RoutingAllocation allocation = onePrimaryOnNode1And1Replica</b></font>(yesAllocationDeciders());
89         DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3;
90         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
91 <a name="13"></a>                .addData(nodeToMatch, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
92         testAllocator.allocateUnassigned(allocation);
93         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
94         assertThat(<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
95             equalTo(nodeToMatch.getId()));
96     }
97     public void testSyncIdMatch() {
98         RoutingAllocation allocation = onePrimaryOnNode1And1Replica</b></font>(yesAllocationDeciders());
99         DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3;
100         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
101 <a name="12"></a>                .addData(nodeToMatch, "MATCH", new StoreFileMetadata("file1", 10, "NO_MATCH_CHECKSUM" ,MIN_SUPPORTED_LUCENE_VERSION));
102         testAllocator.allocateUnassigned(allocation);
103         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
104         assertThat(<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
105             equalTo(nodeToMatch.getId()));
106     }
107     public void testFileChecksumMatch() {
108         RoutingAllocation allocation = onePrimaryOnNode1And1Replica</b></font>(yesAllocationDeciders());
109         DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3;
110         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
111 <a name="11"></a>                .addData(nodeToMatch, "NO_MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
112         testAllocator.allocateUnassigned(allocation);
113         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
114         assertThat(<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
115             equalTo(nodeToMatch.getId()));
116     }
117     public void testPreferCopyWithHighestMatchingOperations() {
118         RoutingAllocation allocation = onePrimaryOnNode1And1Replica</b></font>(yesAllocationDeciders());
119         long retainingSeqNoOnPrimary = randomLongBetween(1, Integer.MAX_VALUE);
120         long retainingSeqNoForNode2 = randomLongBetween(0, retainingSeqNoOnPrimary - 1);
121         long retainingSeqNoForNode3 = randomLongBetween(retainingSeqNoForNode2 + 1, retainingSeqNoOnPrimary + 100);
122         List&lt;RetentionLease&gt; retentionLeases = Arrays.asList(newRetentionLease(node1, retainingSeqNoOnPrimary),
123             newRetentionLease(node2, retainingSeqNoForNode2), newRetentionLease(node3, retainingSeqNoForNode3));
124         testAllocator.addData(node1, retentionLeases, "MATCH",
125             new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
126         testAllocator.addData(node2, "NOT_MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
127 <a name="23"></a>        testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
128         testAllocator.allocateUnassigned(allocation);
129         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
130         assertThat(<font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
131             equalTo(node3.getId()));
132     }
133     public void testCancelRecoveryIfFoundCopyWithNoopRe</b></font>tentionLease() {
134         final UnassignedInfo unassignedInfo;
135         final Set&lt;String&gt; failedNodeIds;
136         if (randomBoolean()) {
137             failedNodeIds = Collections.emptySet();
138             unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null);
139         } else {
140             failedNodeIds = new HashSet&lt;&gt;(randomSubsetOf(Set.of("node-4", "node-5", "node-6", "node-7")));
141 <a name="24"></a>            unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, null, null, randomIntBetween(1, 10),
142                 System.nanoTime(), System.currentTimeMillis(), false, UnassignedInfo.AllocationStatus.NO_ATTEMPT, failedNodeIds);
143         }
144         <font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders(), unassignedInfo);
145         long retainingSeqNo = randomLongBetween(1, Long.MAX_VALUE);
146         testAllocator.addData(node1, Arrays.asList(newRetentionLease(node1, retainingSeqNo), newRetentionLease</b></font>(node3, retainingSeqNo)),
147 <a name="1"></a>            "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
148         testAllocator.addData(node2, "NO_MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
149         testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
150         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>testAllocator.processExistingRecoveries(allocation);
151         assertThat(allocation.routingNodesChanged(), equalTo(true));
152         List&lt;ShardRouting&gt; unassignedShards = allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED);
153         assertThat(unassignedShards, hasSize(1));
154         assertThat(unassignedShards.get(0).shardId(), equalTo(shardId));
155         assertThat(unassignedShards.get(0).unassignedInfo().getNumFailedAllocations(), equalTo(0));
156         assertThat(unassignedShards.get(0).unassignedInfo().getFailedNodeIds(), equalTo</b></font>(failedNodeIds));
157     }
158     public void testNotCancellingRecoveryIfCurrentRecoveryHasRetentionLease() {
159         RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders());
160         List&lt;RetentionLease&gt; peerRecoveryRetentionLeasesOnPrimary = new ArrayList&lt;&gt;();
161         long retainingSeqNo = randomLongBetween(1, Long.MAX_VALUE);
162         peerRecoveryRetentionLeasesOnPrimary.add(newRetentionLease(node1, retainingSeqNo));
163         peerRecoveryRetentionLeasesOnPrimary.add(newRetentionLease(node2, randomLongBetween(1, retainingSeqNo)));
164         if (randomBoolean()) {
165             peerRecoveryRetentionLeasesOnPrimary.add(newRetentionLease(node3, randomLongBetween(0, retainingSeqNo)));
166         }
167         testAllocator.addData(node1, peerRecoveryRetentionLeasesOnPrimary,
168             "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
169         testAllocator.addData(node2, randomSyncId(), new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
170 <a name="10"></a>        testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
171         testAllocator.processExistingRecoveries(allocation);
172         assertThat(allocation.routingNodesChanged(), equalTo(false));
173         <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(0));
174     }
175     public void testNotCancelIfPrimaryDoesNotHaveValidRetentionLease() {
176 <a name="17"></a>        RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering</b></font>(yesAllocationDeciders());
177         testAllocator.addData(node1, Collections.singletonList(newRetentionLease(node3, randomNonNegativeLong())),
178             "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
179         testAllocator.addData(node2, "NOT_MATCH", <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
180         testAllocator.addData(node3, "NOT_MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
181         testAllocator.processExistingRecoveries(allocation);
182         assertThat(allocation.routingNodesChanged(), equalTo(false));
183         assertThat(allocation.routingNodes().shardsWithState</b></font>(ShardRoutingState.UNASSIGNED).size(), equalTo(0));
184     }
185     public void testIgnoreRetentionLeaseIfCopyIsEmpty() {
186         RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
187         long retainingSeqNo = randomLongBetween(1, Long.MAX_VALUE);
188         List&lt;RetentionLease&gt; retentionLeases = new ArrayList&lt;&gt;();
189         retentionLeases.add(newRetentionLease(node1, retainingSeqNo));
190         retentionLeases.add(newRetentionLease(node2, randomLongBetween(0, retainingSeqNo)));
191         if (randomBoolean()) {
192             retentionLeases.add(newRetentionLease(node3, randomLongBetween(0, retainingSeqNo)));
193         }
194         testAllocator.addData(node1, retentionLeases, randomSyncId(),
195             new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
196         testAllocator.addData(node2, null); <a name="22"></a>        testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
197         testAllocator.allocateUnassigned(allocation);
198         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
199         assertThat(<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
200             equalTo(node3.getId()));
201     }
202     public void testN</b></font>oPrimaryData() {
203         RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
204         testAllocator.addData(node2, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
205         testAllocator.allocateUnassigned(allocation);
206         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
207         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
208     }
209     public void testNoDataForReplicaOnAnyNode() {
210         RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
211         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
212         testAllocator.allocateUnassigned(allocation);
213         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
214         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
215     }
216     public void testNoMatchingFilesForReplicaOnAnyNode() {
217         RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
218         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
219                 .addData(node2, "NO_MATCH", new StoreFileMetadata("file1", 10, "NO_MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
220         testAllocator.allocateUnassigned(allocation);
221         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
222         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
223     }
224     public void testNoOrThrottleDecidersRemainsInUnassigned() {
225         RoutingAllocation allocation =
226             onePrimaryOnNode1And1Replica(randomBoolean() ? noAllocationDeciders() : throttleAllocationDeciders());
227         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
228                 .addData(node2, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
229         testAllocator.allocateUnassigned(allocation);
230         assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));
231         assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));
232     }
233     public void testThrottleWhenAllocatingToMatchingNode() {
234         RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(
235             Arrays.asList(new TestAllocateDecision(Decision.YES),
236                 new SameShardAllocationDecider(
237                     Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),
238                 new AllocationDecider() {
239                     @Override
240                     public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {
241                         if (node.node().equals(node2)) {
242                             return Decision.THROTTLE;
243                         }
244                         return Decision.YES;
245                     }
246                 })));
247         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
248                 .addData(node2, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
249         testAllocator.allocateUnassigned(allocation);
250         assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));
251         assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));
252 <a name="20"></a>    }
253     public void testDelayedAllocation() {
254         <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(),
255                 Settings.builder().put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), TimeValue.timeValueHours(1))
256                     .build(), UnassignedInfo.Reason.NODE_LEFT);
257         testAllocator.addData</b></font>(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
258         if (randomBoolean()) {
259             testAllocator.addData(node2, null);
260 <a name="15"></a>        }
261         testAllocator.allocateUnassigned(allocation);
262         assertThat(allocation.routingNodesChanged(), equalTo(false));
263         assertThat(allocation.routingNodes().unassigned().ignored().size(), <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>equalTo(1));
264 <a name="6"></a>        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));
265         allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders</b></font>(),
266                 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Settings.builder().put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(),
267                     TimeValue.timeValueHours(1)).build(), UnassignedInfo.Reason.NODE_LEFT);
268         testAllocator.addData(node2, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
269         testAllocator.allocateUnassigned(allocation);
270         assertThat(allocation.routingNodesChanged(), equalTo(true));
271         assertThat(allocation.routingNodes</b></font>().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
272         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
273             equalTo(node2.getId()));
274     }
275     public void testCancelRecoveryBetterSyncId() {
276         RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders());
277         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
278                 .addData(node2, "NO_MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
279                 .addData(node3, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
280         testAllocator.processExistingRecoveries(allocation);
281         assertThat(allocation.routingNodesChanged(), equalTo(true));
282         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
283         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
284     }
285     public void testNotCancellingRecoveryIfSyncedOnExistingRecovery() {
286         final UnassignedInfo unassignedInfo;
287         if (randomBoolean()) {
288             unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null);
289         } else {
290             unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, null, null, randomIntBetween(1, 10),
291                 System.nanoTime(), System.currentTimeMillis(), false, UnassignedInfo.AllocationStatus.NO_ATTEMPT, Set.of("node-4"));
292         }
293         RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders(), unassignedInfo);
294         List&lt;RetentionLease&gt; retentionLeases = new ArrayList&lt;&gt;();
295         if (randomBoolean()) {
296             long retainingSeqNoOnPrimary = randomLongBetween(0, Long.MAX_VALUE);
297             retentionLeases.add(newRetentionLease(node1, retainingSeqNoOnPrimary));
298             if (randomBoolean()) {
299                 retentionLeases.add(newRetentionLease(node2, randomLongBetween(0, retainingSeqNoOnPrimary)));
300             }
301             if (randomBoolean()) {
302                 retentionLeases.add(newRetentionLease(node3, randomLongBetween(0, retainingSeqNoOnPrimary)));
303             }
304         }
305         testAllocator.addData(node1, retentionLeases, "MATCH",
306             new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
307         testAllocator.addData(node2, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
308         testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM",
309             MIN_SUPPORTED_LUCENE_VERSION));
310         testAllocator.processExistingRecoveries(allocation);
311         assertThat(allocation.routingNodesChanged(), equalTo(false));
312         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(0));
313     }
314     public void testNotCancellingRecovery() {
315         RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders());
316         testAllocator.addData(node1, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
317                 .addData(node2, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
318         testAllocator.processExistingRecoveries(allocation);
319         assertThat(allocation.routingNodesChanged(), equalTo(false));
320         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(0));
321     }
322     public void testDoNotCancelForBrokenNode() {
323         Set&lt;String&gt; failedNodes = new HashSet&lt;&gt;();
324         failedNodes.add(node3.getId());
325         if (randomBoolean()) {
326 <a name="21"></a>            failedNodes.add("node4");
327         }
328         UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, null, null,
329             <font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>randomIntBetween(failedNodes.size(), 10), System.nanoTime(), System.currentTimeMillis(), false,
330             UnassignedInfo.AllocationStatus.NO_ATTEMPT, failedNodes);
331         RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders(), unassignedInfo);
332         long retainingSeqNoOnPrimary = randomLongBetween</b></font>(0, Long.MAX_VALUE);
333         List&lt;RetentionLease&gt; retentionLeases = Arrays.asList(
334             newRetentionLease(node1, retainingSeqNoOnPrimary), newRetentionLease(node3, retainingSeqNoOnPrimary));
335         testAllocator
336             .addData(node1, retentionLeases, "MATCH", new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
337 <a name="16"></a>            .addData(node2, randomSyncId(), new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))
338             .addData(node3, randomSyncId(), new StoreFileMetadata("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION));
339         testAllocator.processExistingRecoveries(allocation);
340         <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(allocation.routingNodesChanged(), equalTo(false));
341         assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED), empty());
342 <a name="18"></a>    }
343     private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders</b></font>) {
344         return <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>onePrimaryOnNode1And1Replica(deciders, Settings.EMPTY, UnassignedInfo.Reason.CLUSTER_RECOVERED);
345     }
346 <a name="8"></a>    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {
347         ShardRouting primaryShard = TestShardRouting.newShardRouting</b></font>(shardId, node1.getId(), true, ShardRoutingState.STARTED);
348         IndexMetadata.Builder indexMetadata = IndexMetadata.builder(shardId.getIndexName())
349             .settings(<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>settings(Version.CURRENT).put(settings))
350             .numberOfShards(1).numberOfReplicas(1)
351             .putInSyncAllocationIds(0, Set.of(primaryShard.allocationId().getId()));
352         Metadata metaData = Metadata.builder().put(indexMetadata).build();
353         boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &amp;&amp;
354             UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get</b></font>(settings).nanos() &gt; 0;
355         int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;
356         RoutingTable routingTable = RoutingTable.builder()
357                 .add(IndexRoutingTable.builder(shardId.getIndex())
358                                 .addIndexShard(new IndexShardRoutingTable.Builder(shardId)
359 <a name="5"></a>                                        .addShard(primaryShard)
360                                         .addShard(ShardRouting.newUnassigned(shardId, false,
361                                             RecoverySource.PeerRecoverySource.INSTANCE,
362                                             new UnassignedInfo(reason, null, null, failedAllocations, <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>System.nanoTime(),
363                                                 System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,
364                                                 Collections.emptySet())))
365                                         .build())
366                 )
367                 .build();
368         ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))
369                 .metadata(metaData)
370                 .routingTable(routingTable)
371                 .nodes(DiscoveryNodes.builder</b></font>().add(node1).add(node2).add(node3)).build();
372         return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());
373     }
374 <a name="2"></a>
375     private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {
376         ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);
377         Metadata metaData = <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Metadata.builder()
378                 .put(IndexMetadata.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))
379                     .numberOfShards(1).numberOfReplicas(1)
380                     .putInSyncAllocationIds(0, Set.of(primaryShard.allocationId().getId())))
381                 .build();
382         RoutingTable routingTable = RoutingTable.builder()
383 <a name="7"></a>                .add(IndexRoutingTable.builder(shardId.getIndex())</b></font>
384                                 .addIndexShard(new IndexShardRoutingTable.Builder(shardId)
385                                         .addShard(primaryShard)
386                                         .addShard(TestShardRouting.newShardRouting(shardId, <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>node2.getId(), null, false,
387                                             ShardRoutingState.INITIALIZING, unassignedInfo))
388                                         .build())
389                 )
390                 .build();
391         ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))
392                 .metadata(metaData)
393                 .routingTable(routingTable)
394                 .nodes(DiscoveryNodes.builder</b></font>().add(node1).add(node2).add(node3)).build();
395         return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());
396     }
397     private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {
398         return onePrimaryOnNode1And1ReplicaRecovering(deciders, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null));
399     }
400     static RetentionLease newRetentionLease(DiscoveryNode node, long retainingSeqNo) {
401         return new RetentionLease(ReplicationTracker.getPeerRecoveryRetentionLeaseId(node.getId()),
402             retainingSeqNo, randomNonNegativeLong(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE);
403     }
404     static String randomSyncId() {
405         return randomFrom("MATCH", "NOT_MATCH", null);
406     }
407     class TestAllocator extends ReplicaShardAllocator {
408         private Map&lt;DiscoveryNode, TransportNodesListShardStoreMetadata.StoreFilesMetadata&gt; data = null;
409         private AtomicBoolean fetchDataCalled = new AtomicBoolean(false);
410         public void clean() {
411             data = null;
412         }
413         public void cleanWithEmptyData() {
414             data = new HashMap&lt;&gt;();
415         }
416         public boolean getFetchDataCalledAndClean() {
417             return fetchDataCalled.getAndSet(false);
418         }
419         public TestAllocator addData(DiscoveryNode node, String syncId, StoreFileMetadata... files) {
420             return addData(node, Collections.emptyList(), syncId, files);
421         }
422         TestAllocator addData(DiscoveryNode node, List&lt;RetentionLease&gt; peerRecoveryRetentionLeases,
423                               String syncId, StoreFileMetadata... files) {
424             if (data == null) {
425                 data = new HashMap&lt;&gt;();
426             }
427             Map&lt;String, StoreFileMetadata&gt; filesAsMap = new HashMap&lt;&gt;();
428             for (StoreFileMetadata file : files) {
429                 filesAsMap.put(file.name(), file);
430             }
431             Map&lt;String, String&gt; commitData = new HashMap&lt;&gt;();
432             if (syncId != null) {
433                 commitData.put(Engine.SYNC_COMMIT_ID, syncId);
434             }
435             data.put(node, new TransportNodesListShardStoreMetadata.StoreFilesMetadata(shardId,
436                     new Store.MetadataSnapshot(unmodifiableMap(filesAsMap), unmodifiableMap(commitData), randomInt()),
437                     peerRecoveryRetentionLeases));
438             return this;
439         }
440         @Override
441         protected AsyncShardFetch.FetchResult&lt;TransportNodesListShardStoreMetadata.NodeStoreFilesMetadata&gt;
442                                                                             fetchData(ShardRouting shard, RoutingAllocation allocation) {
443             fetchDataCalled.set(true);
444             Map&lt;DiscoveryNode, TransportNodesListShardStoreMetadata.NodeStoreFilesMetadata&gt; tData = null;
445             if (data != null) {
446                 tData = new HashMap&lt;&gt;();
447                 for (Map.Entry&lt;DiscoveryNode, TransportNodesListShardStoreMetadata.StoreFilesMetadata&gt; entry : data.entrySet()) {
448                     tData.put(entry.getKey(),
449 <a name="9"></a>                        new TransportNodesListShardStoreMetadata.NodeStoreFilesMetadata(entry.getKey(), entry.getValue()));
450                 }
451             }
452             return new AsyncShardFetch.FetchResult&lt;&gt;(shardId, tData, <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Collections.emptySet());
453         }
454         @Override
455         protected boolean hasInitiatedFetching(ShardRouting shard) {
456             return fetchDataCalled.get();
457         }</b></font>
458     }
459 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
