<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for IncrementalClusterStateWriterTests.java & ReplicaShardAllocatorTests.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for IncrementalClusterStateWriterTests.java & ReplicaShardAllocatorTests.java
      </h3>
      <h1 align="center">
        36.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>IncrementalClusterStateWriterTests.java (42.984695%)<TH>ReplicaShardAllocatorTests.java (32.37272%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#0',2,'match111810-1.html#0',3)" NAME="0">(19-72)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#0',2,'match111810-1.html#0',3)" NAME="0">(20-73)</A><TD ALIGN=center><FONT COLOR="#ff0000">50</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#1',2,'match111810-1.html#1',3)" NAME="1">(292-298)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#1',2,'match111810-1.html#1',3)" NAME="1">(205-211)</A><TD ALIGN=center><FONT COLOR="#750000">23</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#2',2,'match111810-1.html#2',3)" NAME="2">(117-129)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#2',2,'match111810-1.html#2',3)" NAME="2">(473-479)</A><TD ALIGN=center><FONT COLOR="#5b0000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#3',2,'match111810-1.html#3',3)" NAME="3">(139-148)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#3',2,'match111810-1.html#3',3)" NAME="3">(94-98)</A><TD ALIGN=center><FONT COLOR="#560000">17</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#4',2,'match111810-1.html#4',3)" NAME="4">(178-188)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#4',2,'match111810-1.html#4',3)" NAME="4">(111-120)</A><TD ALIGN=center><FONT COLOR="#4c0000">15</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#5',2,'match111810-1.html#5',3)" NAME="5">(280-285)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#5',2,'match111810-1.html#5',3)" NAME="5">(458-467)</A><TD ALIGN=center><FONT COLOR="#470000">14</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#6',2,'match111810-1.html#6',3)" NAME="6">(494-509)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#6',2,'match111810-1.html#6',3)" NAME="6">(355-360)</A><TD ALIGN=center><FONT COLOR="#420000">13</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#7',2,'match111810-1.html#7',3)" NAME="7">(385-394)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#7',2,'match111810-1.html#7',3)" NAME="7">(482-490)</A><TD ALIGN=center><FONT COLOR="#3d0000">12</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#8',2,'match111810-1.html#8',3)" NAME="8">(239-246)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#8',2,'match111810-1.html#8',3)" NAME="8">(444-450)</A><TD ALIGN=center><FONT COLOR="#3d0000">12</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#9',2,'match111810-1.html#9',3)" NAME="9">(316-322)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#9',2,'match111810-1.html#9',3)" NAME="9">(559-565)</A><TD ALIGN=center><FONT COLOR="#380000">11</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#10',2,'match111810-1.html#10',3)" NAME="10">(215-221)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#10',2,'match111810-1.html#10',3)" NAME="10">(229-233)</A><TD ALIGN=center><FONT COLOR="#380000">11</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#11',2,'match111810-1.html#11',3)" NAME="11">(208-214)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#11',2,'match111810-1.html#11',3)" NAME="11">(166-171)</A><TD ALIGN=center><FONT COLOR="#380000">11</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#12',2,'match111810-1.html#12',3)" NAME="12">(202-207)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#12',2,'match111810-1.html#12',3)" NAME="12">(152-160)</A><TD ALIGN=center><FONT COLOR="#380000">11</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#13',2,'match111810-1.html#13',3)" NAME="13">(195-200)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#13',2,'match111810-1.html#13',3)" NAME="13">(138-146)</A><TD ALIGN=center><FONT COLOR="#380000">11</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#14',2,'match111810-1.html#14',3)" NAME="14">(189-194)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#14',2,'match111810-1.html#14',3)" NAME="14">(123-132)</A><TD ALIGN=center><FONT COLOR="#380000">11</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#15',2,'match111810-1.html#15',3)" NAME="15">(157-164)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#15',2,'match111810-1.html#15',3)" NAME="15">(351-354)</A><TD ALIGN=center><FONT COLOR="#380000">11</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#16',2,'match111810-1.html#16',3)" NAME="16">(88-95)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#16',2,'match111810-1.html#16',3)" NAME="16">(433-437)</A><TD ALIGN=center><FONT COLOR="#380000">11</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#17',2,'match111810-1.html#17',3)" NAME="17">(480-484)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#17',2,'match111810-1.html#17',3)" NAME="17">(236-240)</A><TD ALIGN=center><FONT COLOR="#330000">10</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#18',2,'match111810-1.html#18',3)" NAME="18">(133-137)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#18',2,'match111810-1.html#18',3)" NAME="18">(438-442)</A><TD ALIGN=center><FONT COLOR="#330000">10</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#19',2,'match111810-1.html#19',3)" NAME="19">(95-98)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#19',2,'match111810-1.html#19',3)" NAME="19">(105-111)</A><TD ALIGN=center><FONT COLOR="#330000">10</FONT>
<TR><TD BGCOLOR="#4e9258"><FONT COLOR="#4e9258">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#20',2,'match111810-1.html#20',3)" NAME="20">(272-276)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#20',2,'match111810-1.html#20',3)" NAME="20">(341-344)</A><TD ALIGN=center><FONT COLOR="#2d0000">9</FONT>
<TR><TD BGCOLOR="#947010"><FONT COLOR="#947010">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#21',2,'match111810-1.html#21',3)" NAME="21">(252-261)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#21',2,'match111810-1.html#21',3)" NAME="21">(422-425)</A><TD ALIGN=center><FONT COLOR="#2d0000">9</FONT>
<TR><TD BGCOLOR="#4cc417"><FONT COLOR="#4cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#22',2,'match111810-1.html#22',3)" NAME="22">(167-171)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#22',2,'match111810-1.html#22',3)" NAME="22">(258-268)</A><TD ALIGN=center><FONT COLOR="#2d0000">9</FONT>
<TR><TD BGCOLOR="#f660ab"><FONT COLOR="#f660ab">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#23',2,'match111810-1.html#23',3)" NAME="23">(110-114)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#23',2,'match111810-1.html#23',3)" NAME="23">(184-188)</A><TD ALIGN=center><FONT COLOR="#2d0000">9</FONT>
<TR><TD BGCOLOR="#79764d"><FONT COLOR="#79764d">-</FONT><TD><A HREF="javascript:ZweiFrames('match111810-0.html#24',2,'match111810-1.html#24',3)" NAME="24">(104-107)<TD><A HREF="javascript:ZweiFrames('match111810-0.html#24',2,'match111810-1.html#24',3)" NAME="24">(199-201)</A><TD ALIGN=center><FONT COLOR="#2d0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>IncrementalClusterStateWriterTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
<A NAME="0"></A> * specific language governing permissions and limitations
 * under the License.
 */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match111810-1.html#0',3,'match111810-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package org.elasticsearch.gateway;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.MockDirectoryWrapper;
import org.elasticsearch.Version;
import org.elasticsearch.cluster.ClusterName;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.ESAllocationTestCase;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.Manifest;
import org.elasticsearch.cluster.metadata.Metadata;
import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.cluster.node.DiscoveryNodeRole;
import org.elasticsearch.cluster.node.DiscoveryNodes;
import org.elasticsearch.cluster.routing.RoutingTable;
import org.elasticsearch.cluster.routing.allocation.AllocationService;
import org.elasticsearch.cluster.routing.allocation.decider.ClusterRebalanceAllocationDecider;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.logging.Loggers;
import org.elasticsearch.common.settings.ClusterSettings;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.xcontent.NamedXContentRegistry;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.env.NodeEnvironment;
import org.elasticsearch.index.Index;
import org.elasticsearch.test.MockLogAppender;
import org.elasticsearch.test.junit.annotations.TestLogging;
import org.junit.Test;
import org.mockito.ArgumentCaptor;

import io.crate.common.collections.Tuple;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.hasSize;
import static org.hamcrest.Matchers.lessThan;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import</B></FONT> static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;

public class IncrementalClusterStateWriterTests extends ESAllocationTestCase {

    private ClusterState clusterStateWithUnassignedIndex(IndexMetadata indexMetadata, boolean masterEligible) {
        Metadata metadata = Metadata.builder()
            .put(indexMetadata, false)
            .build();

        RoutingTable routingTable = RoutingTable.builder()
<A NAME="16"></A>            .addAsNew(metadata.index(&quot;test&quot;))
            .build();

        return <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match111810-1.html#16',3,'match111810-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))
            .metadata(metadata)
            .routingTable(routingTable)
            .nodes(generateDiscoveryNodes(masterEligible))
<A NAME="19"></A>            .build();
    }

    private ClusterState clusterStateWithAssignedIndex(IndexMetadata indexMetadata</B></FONT>, boolean masterEligible) <FONT color="#f62817"><A HREF="javascript:ZweiFrames('match111810-1.html#19',3,'match111810-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        AllocationService strategy = createAllocationService(Settings.builder()
            .put(&quot;cluster.routing.allocation.node_concurrent_recoveries&quot;, 100)
            .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey</B></FONT>(), &quot;always&quot;)
            .put(&quot;cluster.routing.allocation.cluster_concurrent_rebalance&quot;, 100)
            .put(&quot;cluster.routing.allocation.node_initial_primaries_recoveries&quot;, 100)
<A NAME="24"></A>            .build());

        ClusterState oldClusterState = clusterStateWithUnassignedIndex(indexMetadata, masterEligible);
        <FONT color="#79764d"><A HREF="javascript:ZweiFrames('match111810-1.html#24',3,'match111810-top.html#24',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>RoutingTable routingTable = strategy.reroute(oldClusterState, &quot;reroute&quot;).routingTable();

        Metadata metadataNewClusterState = Metadata.builder()
<A NAME="23"></A>            .put(oldClusterState.metadata</B></FONT>().index(&quot;test&quot;), false)
            .build();

        return <FONT color="#f660ab"><A HREF="javascript:ZweiFrames('match111810-1.html#23',3,'match111810-top.html#23',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ClusterState.builder(oldClusterState).routingTable(routingTable)
            .metadata(metadataNewClusterState).version(oldClusterState.getVersion() + 1).build();
    }

<A NAME="2"></A>    private ClusterState clusterStateWithNon</B></FONT>ReplicatedClosedIndex(IndexMetadata indexMetadata, boolean masterEligible) {
        ClusterState oldClusterState = clusterStateWithAssignedIndex(indexMetadata, masterEligible);

        Metadata metadataNewClusterState = <FONT color="#980517"><A HREF="javascript:ZweiFrames('match111810-1.html#2',3,'match111810-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Metadata.builder()
            .put(
                IndexMetadata.builder(&quot;test&quot;).settings(settings(Version.CURRENT)
                    .put(IndexMetadata.SETTING_INDEX_UUID, indexMetadata.getIndexUUID())
                )
                .state(IndexMetadata.State.CLOSE)
                .numberOfShards(5)
                .numberOfReplicas(2)
            )
            .version(oldClusterState.metadata().version() + 1)
            .build();
        RoutingTable routingTable = RoutingTable.builder()
            .addAsRecovery(metadataNewClusterState.index</B></FONT>(&quot;test&quot;))
<A NAME="18"></A>            .build();

        return ClusterState.builder(oldClusterState).routingTable(routingTable)
            .metadata(metadataNewClusterState).version(<FONT color="#800517"><A HREF="javascript:ZweiFrames('match111810-1.html#18',3,'match111810-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>oldClusterState.getVersion() + 1).build();
    }

<A NAME="3"></A>    private ClusterState clusterStateWithReplicatedClosedIndex(IndexMetadata indexMetadata, boolean masterEligible, boolean assigned) {
        ClusterState oldClusterState = clusterStateWithAssignedIndex</B></FONT>(indexMetadata, masterEligible);

        <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match111810-1.html#3',3,'match111810-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Metadata metadataNewClusterState = Metadata.builder()
            .put(
                IndexMetadata.builder(&quot;test&quot;).settings(settings(Version.CURRENT)
                .put(IndexMetadata.VERIFIED_BEFORE_CLOSE_SETTING.getKey(), true)
                .put(IndexMetadata.SETTING_INDEX_UUID, indexMetadata.getIndexUUID())
                )
                .state(IndexMetadata.State.CLOSE)
                .numberOfShards(5)
                .numberOfReplicas(2))
            .version(oldClusterState.metadata</B></FONT>().version() + 1)
            .build();
        RoutingTable routingTable = RoutingTable.builder()
            .addAsRecovery(metadataNewClusterState.index(&quot;test&quot;))
            .build();

<A NAME="15"></A>        oldClusterState = ClusterState.builder(oldClusterState).routingTable(routingTable)
            .metadata(metadataNewClusterState).build();
        if (assigned) {
            AllocationService strategy = <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match111810-1.html#15',3,'match111810-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>createAllocationService(Settings.builder()
                .put(&quot;cluster.routing.allocation.node_concurrent_recoveries&quot;, 100)
                .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(), &quot;always&quot;)
                .put(&quot;cluster.routing.allocation.cluster_concurrent_rebalance&quot;, 100)
                .put(&quot;cluster.routing.allocation.node_initial_primaries_recoveries&quot;, 100)
                .build());

<A NAME="22"></A>            routingTable = strategy.reroute</B></FONT>(oldClusterState, &quot;reroute&quot;).routingTable();
        }

        return <FONT color="#4cc417"><A HREF="javascript:ZweiFrames('match111810-1.html#22',3,'match111810-top.html#22',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ClusterState.builder(oldClusterState).routingTable(routingTable)
            .metadata(metadataNewClusterState).version(oldClusterState.getVersion() + 1).build();
    }

    private DiscoveryNodes</B></FONT>.Builder generateDiscoveryNodes(boolean masterEligible) {
        Set&lt;DiscoveryNodeRole&gt; dataOnlyRoles = Collections.singleton(DiscoveryNodeRole.DATA_ROLE);
        return DiscoveryNodes.builder().add(newNode(&quot;node1&quot;, masterEligible ? MASTER_DATA_ROLES : dataOnlyRoles))
            .add(newNode(&quot;master_node&quot;, MASTER_DATA_ROLES)).localNodeId(&quot;node1&quot;).masterNodeId(masterEligible ? &quot;node1&quot; : &quot;master_node&quot;);
<A NAME="4"></A>    }

    private IndexMetadata createIndexMetadata(String name) {
        return <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match111810-1.html#4',3,'match111810-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IndexMetadata.builder(name).
            settings(settings(Version.CURRENT)
                .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID(random()))
            )
            .numberOfShards(5)
            .numberOfReplicas(2)
            .build();
    }
<A NAME="14"></A>
    public void testGetRelevantIndicesWithUnassignedShardsOnMasterEligibleNode() {
        IndexMetadata indexMetadata = createIndexMetadata</B></FONT>(&quot;test&quot;);
        Set&lt;Index&gt; indices = <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match111810-1.html#14',3,'match111810-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IncrementalClusterStateWriter.getRelevantIndices(clusterStateWithUnassignedIndex(indexMetadata, true));
        assertThat(indices.size(), equalTo(0));
    }
<A NAME="13"></A>
    public void testGetRelevantIndicesWithUnassignedShardsOnDataOnlyNode() {
        IndexMetadata indexMetadata = createIndexMetadata</B></FONT>(&quot;test&quot;);
        Set&lt;Index&gt; indices = <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match111810-1.html#13',3,'match111810-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IncrementalClusterStateWriter.getRelevantIndices(clusterStateWithUnassignedIndex(indexMetadata, false));
        assertThat(indices.size(), equalTo(0));
    }

<A NAME="12"></A>    public void testGetRelevantIndicesWithAssignedShards() {
        IndexMetadata indexMetadata = createIndexMetadata</B></FONT>(&quot;test&quot;);
        boolean masterEligible = randomBoolean();
        Set&lt;Index&gt; indices = <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match111810-1.html#12',3,'match111810-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IncrementalClusterStateWriter.getRelevantIndices(clusterStateWithAssignedIndex(indexMetadata, masterEligible));
        assertThat(indices.size(), equalTo(1));
    }
<A NAME="11"></A>
    public void testGetRelevantIndicesForNonReplicatedClosedIndexOnDataOnlyNode() {
        IndexMetadata indexMetadata = createIndexMetadata</B></FONT>(&quot;test&quot;);
        Set&lt;Index&gt; indices = <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match111810-1.html#11',3,'match111810-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IncrementalClusterStateWriter.getRelevantIndices(
            clusterStateWithNonReplicatedClosedIndex(indexMetadata, false));
        assertThat(indices.size(), equalTo(0));
    }
<A NAME="10"></A>
    public void testGetRelevantIndicesForReplicatedClosedButUnassignedIndexOnDataOnlyNode() {
        IndexMetadata indexMetadata = createIndexMetadata</B></FONT>(&quot;test&quot;);
        Set&lt;Index&gt; indices = <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match111810-1.html#10',3,'match111810-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IncrementalClusterStateWriter.getRelevantIndices(
            clusterStateWithReplicatedClosedIndex(indexMetadata, false, false));
        assertThat(indices.size(), equalTo(0));
    }

    public void testGetRelevantIndicesForReplicatedClosedAndAssignedIndexOnDataOnlyNode() {
        IndexMetadata indexMetadata = createIndexMetadata</B></FONT>(&quot;test&quot;);
        Set&lt;Index&gt; indices = IncrementalClusterStateWriter.getRelevantIndices(
            clusterStateWithReplicatedClosedIndex(indexMetadata, false, true));
        assertThat(indices.size(), equalTo(1));
    }

    @Test
    public void testResolveStatesToBeWritten() throws WriteStateException {
        Map&lt;Index, Long&gt; indices = new HashMap&lt;&gt;();
        Set&lt;Index&gt; relevantIndices = new HashSet&lt;&gt;();

        IndexMetadata removedIndex = createIndexMetadata(&quot;removed_index&quot;);
        indices.put(removedIndex.getIndex(), 1L);

        IndexMetadata versionChangedIndex = createIndexMetadata(&quot;version_changed_index&quot;);
<A NAME="8"></A>        indices.put(versionChangedIndex.getIndex(), 2L);
        relevantIndices.add(versionChangedIndex.getIndex());

        IndexMetadata notChangedIndex = <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match111810-1.html#8',3,'match111810-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>createIndexMetadata(&quot;not_changed_index&quot;);
        indices.put(notChangedIndex.getIndex(), 3L);
        relevantIndices.add(notChangedIndex.getIndex());

        IndexMetadata newIndex = createIndexMetadata(&quot;new_index&quot;);
        relevantIndices.add(newIndex.getIndex());

        Metadata oldMetadata = Metadata.builder()</B></FONT>
            .put(removedIndex, false)
            .put(versionChangedIndex, false)
<A NAME="21"></A>            .put(notChangedIndex, false)
            .build();

        Metadata newMetadata = <FONT color="#947010"><A HREF="javascript:ZweiFrames('match111810-1.html#21',3,'match111810-top.html#21',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Metadata.builder()
            .put(versionChangedIndex, true)
            .put(notChangedIndex, false)
            .put(newIndex, false)
            .build();

        IndexMetadata newVersionChangedIndex = newMetadata.index(versionChangedIndex.getIndex());

        List&lt;IncrementalClusterStateWriter.IndexMetadataAction&gt; actions =
            IncrementalClusterStateWriter.resolveIndexMetadataActions</B></FONT>(indices, relevantIndices, oldMetadata, newMetadata);

        assertThat(actions, hasSize(3));

        boolean keptPreviousGeneration = false;
        boolean wroteNewIndex = false;
        boolean wroteChangedIndex = false;

<A NAME="20"></A>        for (IncrementalClusterStateWriter.IndexMetadataAction action : actions) {
            if (action instanceof IncrementalClusterStateWriter.KeepPreviousGeneration) {
                assertThat(action.getIndex(), equalTo(notChangedIndex.getIndex()));
                <FONT color="#4e9258"><A HREF="javascript:ZweiFrames('match111810-1.html#20',3,'match111810-top.html#20',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IncrementalClusterStateWriter.AtomicClusterStateWriter writer
                    = mock(IncrementalClusterStateWriter.AtomicClusterStateWriter.class);
                assertThat(action.execute(writer), equalTo(3L));
                verify(writer, times(1)).incrementIndicesSkipped();
                verifyNoMoreInteractions</B></FONT>(writer);
<A NAME="5"></A>                keptPreviousGeneration = true;
            }
            if (action instanceof IncrementalClusterStateWriter.WriteNewIndexMetadata) {
                assertThat(<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match111810-1.html#5',3,'match111810-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>action.getIndex(), equalTo(newIndex.getIndex()));
                IncrementalClusterStateWriter.AtomicClusterStateWriter writer
                    = mock(IncrementalClusterStateWriter.AtomicClusterStateWriter.class);
                when(writer.writeIndex(&quot;freshly created&quot;, newIndex)).thenReturn(0L);
                assertThat(action.execute(writer), equalTo(0L));
                verify(writer, times</B></FONT>(1)).incrementIndicesWritten();
                wroteNewIndex = true;
            }
            if (action instanceof IncrementalClusterStateWriter.WriteChangedIndexMetadata) {
<A NAME="1"></A>                assertThat(action.getIndex(), equalTo(newVersionChangedIndex.getIndex()));
                IncrementalClusterStateWriter.AtomicClusterStateWriter writer
                    = mock(IncrementalClusterStateWriter.AtomicClusterStateWriter.class);
                when(writer.writeIndex(anyString(), <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match111810-1.html#1',3,'match111810-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eq(newVersionChangedIndex))).thenReturn(3L);
                assertThat(action.execute(writer), equalTo(3L));
                ArgumentCaptor&lt;String&gt; reason = ArgumentCaptor.forClass(String.class);
                verify(writer).writeIndex(reason.capture(), eq(newVersionChangedIndex));
                verify(writer, times(1)).incrementIndicesWritten();
                assertThat(reason.getValue(), containsString(Long.toString(versionChangedIndex.getVersion())));
                assertThat(reason.getValue(), containsString(Long.toString(newVersionChangedIndex.getVersion</B></FONT>())));
                wroteChangedIndex = true;
            }
        }

        assertTrue(keptPreviousGeneration);
        assertTrue(wroteNewIndex);
        assertTrue(wroteChangedIndex);
    }

    private static class MetaStateServiceWithFailures extends MetaStateService {
        private final int invertedFailRate;
        private boolean failRandomly;

        private &lt;T&gt; MetadataStateFormat&lt;T&gt; wrap(MetadataStateFormat&lt;T&gt; format) {
<A NAME="9"></A>            return new MetadataStateFormat&lt;T&gt;(format.getPrefix()) {
                @Override
                public void toXContent(XContentBuilder builder, T state) throws IOException {
                    <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match111810-1.html#9',3,'match111810-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>format.toXContent(builder, state);
                }

                @Override
                public T fromXContent(XContentParser parser) throws IOException {
                    return format.fromXContent(parser);
                }</B></FONT>

                @Override
                protected Directory newDirectory(Path dir) {
                    MockDirectoryWrapper mock = newMockFSDirectory(dir);
                    if (failRandomly) {
                        MockDirectoryWrapper.Failure fail = new MockDirectoryWrapper.Failure() {
                            @Override
                            public void eval(MockDirectoryWrapper dir) throws IOException {
                                int r = randomIntBetween(0, invertedFailRate);
                                if (r == 0) {
                                    throw new MockDirectoryWrapper.FakeIOException();
                                }
                            }
                        };
                        mock.failOn(fail);
                    }
                    closeAfterSuite(mock);
                    return mock;
                }
            };
        }

        MetaStateServiceWithFailures(int invertedFailRate, NodeEnvironment nodeEnv, NamedXContentRegistry namedXContentRegistry) {
            super(nodeEnv, namedXContentRegistry);
            META_DATA_FORMAT = wrap(Metadata.FORMAT);
            INDEX_META_DATA_FORMAT = wrap(IndexMetadata.FORMAT);
            MANIFEST_FORMAT = wrap(Manifest.FORMAT);
            failRandomly = false;
            this.invertedFailRate = invertedFailRate;
        }

        void failRandomly() {
            failRandomly = true;
        }

        void noFailures() {
            failRandomly = false;
        }
    }

    private boolean metadataEquals(Metadata md1, Metadata md2) {
        boolean equals = Metadata.isGlobalStateEquals(md1, md2);

        for (IndexMetadata imd : md1) {
            IndexMetadata imd2 = md2.index(imd.getIndex());
            equals = equals &amp;&amp; imd.equals(imd2);
        }

        for (IndexMetadata imd : md2) {
            IndexMetadata imd2 = md1.index(imd.getIndex());
            equals = equals &amp;&amp; imd.equals(imd2);
        }
        return equals;
    }

    private static Metadata randomMetadataForTx() {
        int settingNo = randomIntBetween(0, 10);
        Metadata.Builder builder = Metadata.builder()
            .persistentSettings(Settings.builder().put(&quot;setting&quot; + settingNo, randomAlphaOfLength(5)).build());
<A NAME="7"></A>        int numOfIndices = randomIntBetween(0, 3);

        for (int i = 0; i &lt; numOfIndices; i++) {
            int indexNo = <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match111810-1.html#7',3,'match111810-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>randomIntBetween(0, 50);
            IndexMetadata indexMetadata = IndexMetadata.builder(&quot;index&quot; + indexNo).settings(
                Settings.builder()
                    .put(IndexMetadata.SETTING_INDEX_UUID, &quot;index&quot; + indexNo)
                    .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)
                    .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)
                    .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)
                    .build()
            ).build();
            builder.put</B></FONT>(indexMetadata, false);
        }
        return builder.build();
    }

    public void testAtomicityWithFailures() throws IOException {
        try (NodeEnvironment env = newNodeEnvironment()) {
            MetaStateServiceWithFailures metaStateService =
                new MetaStateServiceWithFailures(randomIntBetween(100, 1000), env, xContentRegistry());

            // We only guarantee atomicity of writes, if there is initial Manifest file
            Manifest manifest = Manifest.empty();
            Metadata metadata = Metadata.EMPTY_METADATA;
            metaStateService.writeManifestAndCleanup(&quot;startup&quot;, Manifest.empty());
            long currentTerm = randomNonNegativeLong();
            long clusterStateVersion = randomNonNegativeLong();

            metaStateService.failRandomly();
            Set&lt;Metadata&gt; possibleMetadata = new HashSet&lt;&gt;();
            possibleMetadata.add(metadata);

            for (int i = 0; i &lt; randomIntBetween(1, 5); i++) {
                IncrementalClusterStateWriter.AtomicClusterStateWriter writer =
                    new IncrementalClusterStateWriter.AtomicClusterStateWriter(metaStateService, manifest);
                metadata = randomMetadataForTx();
                Map&lt;Index, Long&gt; indexGenerations = new HashMap&lt;&gt;();

                try {
                    long globalGeneration = writer.writeGlobalState(&quot;global&quot;, metadata);

                    for (IndexMetadata indexMetadata : metadata) {
                        long generation = writer.writeIndex(&quot;index&quot;, indexMetadata);
                        indexGenerations.put(indexMetadata.getIndex(), generation);
                    }

                    Manifest newManifest = new Manifest(currentTerm, clusterStateVersion, globalGeneration, indexGenerations);
                    writer.writeManifestAndCleanup(&quot;manifest&quot;, newManifest);
                    possibleMetadata.clear();
                    possibleMetadata.add(metadata);
                    manifest = newManifest;
                } catch (WriteStateException e) {
                    if (e.isDirty()) {
                        possibleMetadata.add(metadata);
                        /*
                         * If dirty WriteStateException occurred, it's only safe to proceed if there is subsequent
                         * successful write of metadata and Manifest. We prefer to break here, not to over complicate test logic.
                         * See also MetadataStateFormat#testFailRandomlyAndReadAnyState, that does not break.
                         */
                        break;
                    }
                }
            }

            metaStateService.noFailures();

            Tuple&lt;Manifest, Metadata&gt; manifestAndMetadata = metaStateService.loadFullState();
            Metadata loadedMetadata = manifestAndMetadata.v2();

            assertTrue(possibleMetadata.stream().anyMatch(md -&gt; metadataEquals(md, loadedMetadata)));
        }
    }

    @TestLogging(value = &quot;org.elasticsearch.gateway:WARN&quot;)
    public void testSlowLogging() throws WriteStateException, IllegalAccessException {
        final long slowWriteLoggingThresholdMillis;
        final Settings settings;
        if (randomBoolean()) {
            slowWriteLoggingThresholdMillis = PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.get(Settings.EMPTY).millis();
            settings = Settings.EMPTY;
        } else {
            slowWriteLoggingThresholdMillis = randomLongBetween(2, 100000);
            settings = Settings.builder()
                .put(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.getKey(), slowWriteLoggingThresholdMillis + &quot;ms&quot;)
                .build();
        }

        final DiscoveryNode localNode = newNode(&quot;node&quot;);
        final ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT)
            .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId())).build();

        final long startTimeMillis = randomLongBetween(0L, Long.MAX_VALUE - slowWriteLoggingThresholdMillis * 10);
        final AtomicLong currentTime = new AtomicLong(startTimeMillis);
        final AtomicLong writeDurationMillis = new AtomicLong(slowWriteLoggingThresholdMillis);
<A NAME="17"></A>
        final ClusterSettings clusterSettings = new ClusterSettings(settings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        final IncrementalClusterStateWriter incrementalClusterStateWriter
            = <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match111810-1.html#17',3,'match111810-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>new IncrementalClusterStateWriter(settings, clusterSettings, mock(MetaStateService.class),
            new Manifest(randomNonNegativeLong(), randomNonNegativeLong(), randomNonNegativeLong(), Collections.emptyMap()),
            clusterState, () -&gt; currentTime.getAndAdd(writeDurationMillis.get()));

        assertExpectedLogs</B></FONT>(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
            &quot;should see warning at threshold&quot;,
            IncrementalClusterStateWriter.class.getCanonicalName(),
            Level.WARN,
            &quot;writing cluster state took [*] which is above the warn threshold of [*]; &quot; +
                &quot;wrote metadata for [0] indices and skipped [0] unchanged indices&quot;));

<A NAME="6"></A>        writeDurationMillis.set(randomLongBetween(slowWriteLoggingThresholdMillis, slowWriteLoggingThresholdMillis * 2));
        assertExpectedLogs(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
            &quot;should see warning above threshold&quot;,
            <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match111810-1.html#6',3,'match111810-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>IncrementalClusterStateWriter.class.getCanonicalName(),
            Level.WARN,
            &quot;writing cluster state took [*] which is above the warn threshold of [*]; &quot; +
                &quot;wrote metadata for [0] indices and skipped [0] unchanged indices&quot;));

        writeDurationMillis.set(randomLongBetween(1, slowWriteLoggingThresholdMillis - 1));
        assertExpectedLogs(clusterState, incrementalClusterStateWriter, new MockLogAppender.UnseenEventExpectation(
            &quot;should not see warning below threshold&quot;,
            IncrementalClusterStateWriter.class.getCanonicalName(),
            Level.WARN,
            &quot;*&quot;));

        clusterSettings.applySettings(Settings.builder()
            .put(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.getKey(), writeDurationMillis.get() + &quot;ms&quot;)
            .build());
        assertExpectedLogs</B></FONT>(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
            &quot;should see warning at reduced threshold&quot;,
            IncrementalClusterStateWriter.class.getCanonicalName(),
            Level.WARN,
            &quot;writing cluster state took [*] which is above the warn threshold of [*]; &quot; +
                &quot;wrote metadata for [0] indices and skipped [0] unchanged indices&quot;));

        assertThat(currentTime.get(), lessThan(startTimeMillis + 10 * slowWriteLoggingThresholdMillis)); // ensure no overflow
    }

    private void assertExpectedLogs(ClusterState clusterState, IncrementalClusterStateWriter incrementalClusterStateWriter,
                                    MockLogAppender.LoggingExpectation expectation) throws IllegalAccessException, WriteStateException {
        MockLogAppender mockAppender = new MockLogAppender();
        mockAppender.start();
        mockAppender.addExpectation(expectation);
        Logger classLogger = LogManager.getLogger(IncrementalClusterStateWriter.class);
        Loggers.addAppender(classLogger, mockAppender);

        try {
            incrementalClusterStateWriter.updateClusterState(clusterState);
        } finally {
            Loggers.removeAppender(classLogger, mockAppender);
            mockAppender.stop();
        }
        mockAppender.assertAllExpectationsMatched();
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ReplicaShardAllocatorTests.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
<A NAME="0"></A> * under the License.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#0',2,'match111810-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package org.elasticsearch.gateway;

import com.carrotsearch.randomizedtesting.generators.RandomPicks;
import org.elasticsearch.Version;
import org.elasticsearch.cluster.ClusterInfo;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.Metadata;
import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.cluster.node.DiscoveryNodes;
import org.elasticsearch.cluster.routing.IndexRoutingTable;
import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
import org.elasticsearch.cluster.routing.RecoverySource;
import org.elasticsearch.cluster.routing.RoutingNode;
import org.elasticsearch.cluster.routing.RoutingNodes;
import org.elasticsearch.cluster.routing.RoutingTable;
import org.elasticsearch.cluster.routing.ShardRouting;
import org.elasticsearch.cluster.routing.ShardRoutingState;
import org.elasticsearch.cluster.routing.TestShardRouting;
import org.elasticsearch.cluster.routing.UnassignedInfo;
import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;
import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;
import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;
import org.elasticsearch.cluster.routing.allocation.decider.Decision;
import org.elasticsearch.cluster.routing.allocation.decider.SameShardAllocationDecider;
import org.elasticsearch.common.settings.ClusterSettings;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.index.engine.Engine;
import org.elasticsearch.index.seqno.ReplicationTracker;
import org.elasticsearch.index.seqno.RetentionLease;
import org.elasticsearch.index.shard.ShardId;
import org.elasticsearch.index.store.Store;
import org.elasticsearch.index.store.StoreFileMetadata;
import org.elasticsearch.indices.store.TransportNodesListShardStoreMetadata;
import org.elasticsearch.cluster.ESAllocationTestCase;
import org.junit.Before;

import io.crate.common.unit.TimeValue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.unmodifiableMap;
import static org.hamcrest.Matchers.empty;
import static org.hamcrest.Matchers.equalTo;
import</B></FONT> static org.hamcrest.Matchers.hasSize;

public class ReplicaShardAllocatorTests extends ESAllocationTestCase {
    private static final org.apache.lucene.util.Version MIN_SUPPORTED_LUCENE_VERSION = org.elasticsearch.Version.CURRENT
        .minimumIndexCompatibilityVersion().luceneVersion;
    private final ShardId shardId = new ShardId(&quot;test&quot;, &quot;_na_&quot;, 0);
    private final DiscoveryNode node1 = newNode(&quot;node1&quot;);
    private final DiscoveryNode node2 = newNode(&quot;node2&quot;);
    private final DiscoveryNode node3 = newNode(&quot;node3&quot;);

    private TestAllocator testAllocator;

    @Before
    public void buildTestAllocator() {
        this.testAllocator = new TestAllocator();
    }

    /**
<A NAME="3"></A>     * Verifies that when we are still fetching data in an async manner, the replica shard moves to ignore unassigned.
     */
    public void testNoAsyncFetchData() {
        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#3',2,'match111810-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
        testAllocator.clean();
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));
        assertThat(allocation.routingNodes</B></FONT>().unassigned().ignored().get(0).shardId(), equalTo(shardId));
    }

    /**
<A NAME="19"></A>     * Verifies that on index creation, we don't go and fetch data, but keep the replica shard unassigned to let
     * the shard allocator to allocate it. There isn't a copy around to find anyhow.
     */
    public void testNoAsyncFetchOnIndexCreation() <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#19',2,'match111810-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY,
            UnassignedInfo.Reason.INDEX_CREATED);
<A NAME="4"></A>        testAllocator.clean();
        testAllocator.allocateUnassigned(allocation);
        assertThat(testAllocator.getFetchDataCalledAndClean(), equalTo(false));
        assertThat</B></FONT>(<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#4',2,'match111810-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
    }

    /**
     * Verifies that for anything but index creation, fetch data ends up being called, since we need to go and try
     * and find a better copy for the shard.
     */
    public void testAsyncFetchOnAnythingButIndexCreation() {
<A NAME="14"></A>        UnassignedInfo.Reason reason = RandomPicks.randomFrom</B></FONT>(random(),
            EnumSet.complementOf(EnumSet.of(UnassignedInfo.Reason.INDEX_CREATED)));
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY, reason);
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#14',2,'match111810-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>testAllocator.clean();
        testAllocator.allocateUnassigned(allocation);
        assertThat(&quot;failed with reason &quot; + reason, testAllocator.getFetchDataCalledAndClean(), equalTo(true));
    }

    /**
     * Verifies that when there is a full match (syncId and files) we allocate it to matching node.
     */
    public void testSimpleFullMatchAllocation() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica</B></FONT>(yesAllocationDeciders());
        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3;
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
<A NAME="13"></A>                .addData(nodeToMatch, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
        assertThat(<FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#13',2,'match111810-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
            equalTo(nodeToMatch.getId()));
    }

    /**
     * Verifies that when there is a sync id match but no files match, we allocate it to matching node.
     */
    public void testSyncIdMatch() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica</B></FONT>(yesAllocationDeciders());
        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3;
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
<A NAME="12"></A>                .addData(nodeToMatch, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;NO_MATCH_CHECKSUM&quot; ,MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
        assertThat(<FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#12',2,'match111810-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
            equalTo(nodeToMatch.getId()));
    }

    /**
     * Verifies that when there is no sync id match but files match, we allocate it to matching node.
     */
    public void testFileChecksumMatch() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica</B></FONT>(yesAllocationDeciders());
        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3;
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
<A NAME="11"></A>                .addData(nodeToMatch, &quot;NO_MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
        assertThat(<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#11',2,'match111810-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
            equalTo(nodeToMatch.getId()));
    }

    public void testPreferCopyWithHighestMatchingOperations() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica</B></FONT>(yesAllocationDeciders());
        long retainingSeqNoOnPrimary = randomLongBetween(1, Integer.MAX_VALUE);
        long retainingSeqNoForNode2 = randomLongBetween(0, retainingSeqNoOnPrimary - 1);
        // Rarely use a seqNo above retainingSeqNoOnPrimary, which could in theory happen when primary fails and comes back quickly.
        long retainingSeqNoForNode3 = randomLongBetween(retainingSeqNoForNode2 + 1, retainingSeqNoOnPrimary + 100);
        List&lt;RetentionLease&gt; retentionLeases = Arrays.asList(newRetentionLease(node1, retainingSeqNoOnPrimary),
            newRetentionLease(node2, retainingSeqNoForNode2), newRetentionLease(node3, retainingSeqNoForNode3));
        testAllocator.addData(node1, retentionLeases, &quot;MATCH&quot;,
            new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node2, &quot;NOT_MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
<A NAME="23"></A>        testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
        assertThat(<FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#23',2,'match111810-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
            equalTo(node3.getId()));
    }

    public void testCancelRecoveryIfFoundCopyWithNoopRe</B></FONT>tentionLease() {
        final UnassignedInfo unassignedInfo;
        final Set&lt;String&gt; failedNodeIds;
        if (randomBoolean()) {
            failedNodeIds = Collections.emptySet();
            unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null);
        } else {
            failedNodeIds = new HashSet&lt;&gt;(randomSubsetOf(Set.of(&quot;node-4&quot;, &quot;node-5&quot;, &quot;node-6&quot;, &quot;node-7&quot;)));
<A NAME="24"></A>            unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, null, null, randomIntBetween(1, 10),
                System.nanoTime(), System.currentTimeMillis(), false, UnassignedInfo.AllocationStatus.NO_ATTEMPT, failedNodeIds);
        }
        <FONT color="#79764d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#24',2,'match111810-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders(), unassignedInfo);
        long retainingSeqNo = randomLongBetween(1, Long.MAX_VALUE);
        testAllocator.addData(node1, Arrays.asList(newRetentionLease(node1, retainingSeqNo), newRetentionLease</B></FONT>(node3, retainingSeqNo)),
<A NAME="1"></A>            &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node2, &quot;NO_MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#1',2,'match111810-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>testAllocator.processExistingRecoveries(allocation);
        assertThat(allocation.routingNodesChanged(), equalTo(true));
        List&lt;ShardRouting&gt; unassignedShards = allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED);
        assertThat(unassignedShards, hasSize(1));
        assertThat(unassignedShards.get(0).shardId(), equalTo(shardId));
        assertThat(unassignedShards.get(0).unassignedInfo().getNumFailedAllocations(), equalTo(0));
        assertThat(unassignedShards.get(0).unassignedInfo().getFailedNodeIds(), equalTo</B></FONT>(failedNodeIds));
    }

    public void testNotCancellingRecoveryIfCurrentRecoveryHasRetentionLease() {
        RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders());
        List&lt;RetentionLease&gt; peerRecoveryRetentionLeasesOnPrimary = new ArrayList&lt;&gt;();
        long retainingSeqNo = randomLongBetween(1, Long.MAX_VALUE);
        peerRecoveryRetentionLeasesOnPrimary.add(newRetentionLease(node1, retainingSeqNo));
        peerRecoveryRetentionLeasesOnPrimary.add(newRetentionLease(node2, randomLongBetween(1, retainingSeqNo)));
        if (randomBoolean()) {
            peerRecoveryRetentionLeasesOnPrimary.add(newRetentionLease(node3, randomLongBetween(0, retainingSeqNo)));
        }
        testAllocator.addData(node1, peerRecoveryRetentionLeasesOnPrimary,
            &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node2, randomSyncId(), new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
<A NAME="10"></A>        testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.processExistingRecoveries(allocation);
        assertThat(allocation.routingNodesChanged(), equalTo(false));
        <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#10',2,'match111810-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(0));
    }

    public void testNotCancelIfPrimaryDoesNotHaveValidRetentionLease() {
<A NAME="17"></A>        RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering</B></FONT>(yesAllocationDeciders());
        testAllocator.addData(node1, Collections.singletonList(newRetentionLease(node3, randomNonNegativeLong())),
            &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node2, &quot;NOT_MATCH&quot;, <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#17',2,'match111810-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node3, &quot;NOT_MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.processExistingRecoveries(allocation);
        assertThat(allocation.routingNodesChanged(), equalTo(false));
        assertThat(allocation.routingNodes().shardsWithState</B></FONT>(ShardRoutingState.UNASSIGNED).size(), equalTo(0));
    }

    public void testIgnoreRetentionLeaseIfCopyIsEmpty() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
        long retainingSeqNo = randomLongBetween(1, Long.MAX_VALUE);
        List&lt;RetentionLease&gt; retentionLeases = new ArrayList&lt;&gt;();
        retentionLeases.add(newRetentionLease(node1, retainingSeqNo));
        retentionLeases.add(newRetentionLease(node2, randomLongBetween(0, retainingSeqNo)));
        if (randomBoolean()) {
            retentionLeases.add(newRetentionLease(node3, randomLongBetween(0, retainingSeqNo)));
        }
        testAllocator.addData(node1, retentionLeases, randomSyncId(),
            new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node2, null); // has retention lease but store is empty
<A NAME="22"></A>        testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
        assertThat(<FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#22',2,'match111810-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
            equalTo(node3.getId()));
    }

    /**
     * When we can't find primary data, but still find replica data, we go ahead and keep it unassigned
     * to be allocated. This is today behavior, which relies on a primary corruption identified with
     * adding a replica and having that replica actually recover and cause the corruption to be identified
     * See CorruptFileTest#
     */
    public void testN</B></FONT>oPrimaryData() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
        testAllocator.addData(node2, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
    }

    /**
     * Verifies that when there is primary data, but no data at all on other nodes, the shard keeps
     * unassigned to be allocated later on.
     */
    public void testNoDataForReplicaOnAnyNode() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
    }

    /**
     * Verifies that when there is primary data, but no matching data at all on other nodes, the shard keeps
     * unassigned to be allocated later on.
     */
    public void testNoMatchingFilesForReplicaOnAnyNode() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders());
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
                .addData(node2, &quot;NO_MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;NO_MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
    }

    /**
     * When there is no decision or throttle decision across all nodes for the shard, make sure the shard
     * moves to the ignore unassigned list.
     */
    public void testNoOrThrottleDecidersRemainsInUnassigned() {
        RoutingAllocation allocation =
            onePrimaryOnNode1And1Replica(randomBoolean() ? noAllocationDeciders() : throttleAllocationDeciders());
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
                .addData(node2, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));
        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));
    }

    /**
     * Tests when the node to allocate to due to matching is being throttled, we move the shard to ignored
     * to wait till throttling on it is done.
     */
    public void testThrottleWhenAllocatingToMatchingNode() {
        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(
            Arrays.asList(new TestAllocateDecision(Decision.YES),
                new SameShardAllocationDecider(
                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),
                new AllocationDecider() {
                    @Override
                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {
                        if (node.node().equals(node2)) {
                            return Decision.THROTTLE;
                        }
                        return Decision.YES;
                    }
                })));
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
                .addData(node2, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));
        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));
<A NAME="20"></A>    }

    public void testDelayedAllocation() {
        <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#20',2,'match111810-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(),
                Settings.builder().put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), TimeValue.timeValueHours(1))
                    .build(), UnassignedInfo.Reason.NODE_LEFT);
        testAllocator.addData</B></FONT>(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        if (randomBoolean()) {
            // we sometime return empty list of files, make sure we test this as well
            testAllocator.addData(node2, null);
<A NAME="15"></A>        }
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodesChanged(), equalTo(false));
        assertThat(allocation.routingNodes().unassigned().ignored().size(), <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#15',2,'match111810-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>equalTo(1));
<A NAME="6"></A>        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));

        allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders</B></FONT>(),
                <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#6',2,'match111810-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Settings.builder().put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(),
                    TimeValue.timeValueHours(1)).build(), UnassignedInfo.Reason.NODE_LEFT);
        testAllocator.addData(node2, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.allocateUnassigned(allocation);
        assertThat(allocation.routingNodesChanged(), equalTo(true));
        assertThat(allocation.routingNodes</B></FONT>().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),
            equalTo(node2.getId()));
    }

    public void testCancelRecoveryBetterSyncId() {
        RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders());
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
                .addData(node2, &quot;NO_MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
                .addData(node3, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.processExistingRecoveries(allocation);
        assertThat(allocation.routingNodesChanged(), equalTo(true));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));
    }

    public void testNotCancellingRecoveryIfSyncedOnExistingRecovery() {
        final UnassignedInfo unassignedInfo;
        if (randomBoolean()) {
            unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null);
        } else {
            unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, null, null, randomIntBetween(1, 10),
                System.nanoTime(), System.currentTimeMillis(), false, UnassignedInfo.AllocationStatus.NO_ATTEMPT, Set.of(&quot;node-4&quot;));
        }
        RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders(), unassignedInfo);
        List&lt;RetentionLease&gt; retentionLeases = new ArrayList&lt;&gt;();
        if (randomBoolean()) {
            long retainingSeqNoOnPrimary = randomLongBetween(0, Long.MAX_VALUE);
            retentionLeases.add(newRetentionLease(node1, retainingSeqNoOnPrimary));
            if (randomBoolean()) {
                retentionLeases.add(newRetentionLease(node2, randomLongBetween(0, retainingSeqNoOnPrimary)));
            }
            if (randomBoolean()) {
                retentionLeases.add(newRetentionLease(node3, randomLongBetween(0, retainingSeqNoOnPrimary)));
            }
        }
        testAllocator.addData(node1, retentionLeases, &quot;MATCH&quot;,
            new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node2, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.addData(node3, randomSyncId(), new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;,
            MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.processExistingRecoveries(allocation);
        assertThat(allocation.routingNodesChanged(), equalTo(false));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(0));
    }

    public void testNotCancellingRecovery() {
        RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders());
        testAllocator.addData(node1, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
                .addData(node2, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.processExistingRecoveries(allocation);
        assertThat(allocation.routingNodesChanged(), equalTo(false));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(0));
    }

    public void testDoNotCancelForBrokenNode() {
        Set&lt;String&gt; failedNodes = new HashSet&lt;&gt;();
        failedNodes.add(node3.getId());
        if (randomBoolean()) {
<A NAME="21"></A>            failedNodes.add(&quot;node4&quot;);
        }
        UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, null, null,
            <FONT color="#947010"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#21',2,'match111810-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>randomIntBetween(failedNodes.size(), 10), System.nanoTime(), System.currentTimeMillis(), false,
            UnassignedInfo.AllocationStatus.NO_ATTEMPT, failedNodes);
        RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering(yesAllocationDeciders(), unassignedInfo);
        long retainingSeqNoOnPrimary = randomLongBetween</B></FONT>(0, Long.MAX_VALUE);
        List&lt;RetentionLease&gt; retentionLeases = Arrays.asList(
            newRetentionLease(node1, retainingSeqNoOnPrimary), newRetentionLease(node3, retainingSeqNoOnPrimary));
        testAllocator
            .addData(node1, retentionLeases, &quot;MATCH&quot;, new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
<A NAME="16"></A>            .addData(node2, randomSyncId(), new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION))
            .addData(node3, randomSyncId(), new StoreFileMetadata(&quot;file1&quot;, 10, &quot;MATCH_CHECKSUM&quot;, MIN_SUPPORTED_LUCENE_VERSION));
        testAllocator.processExistingRecoveries(allocation);
        <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#16',2,'match111810-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(allocation.routingNodesChanged(), equalTo(false));
        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED), empty());
<A NAME="18"></A>    }

    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders</B></FONT>) {
        return <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#18',2,'match111810-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>onePrimaryOnNode1And1Replica(deciders, Settings.EMPTY, UnassignedInfo.Reason.CLUSTER_RECOVERED);
    }

<A NAME="8"></A>    private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {
        ShardRouting primaryShard = TestShardRouting.newShardRouting</B></FONT>(shardId, node1.getId(), true, ShardRoutingState.STARTED);
        IndexMetadata.Builder indexMetadata = IndexMetadata.builder(shardId.getIndexName())
            .settings(<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#8',2,'match111810-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>settings(Version.CURRENT).put(settings))
            .numberOfShards(1).numberOfReplicas(1)
            .putInSyncAllocationIds(0, Set.of(primaryShard.allocationId().getId()));
        Metadata metaData = Metadata.builder().put(indexMetadata).build();
        // mark shard as delayed if reason is NODE_LEFT
        boolean delayed = reason == UnassignedInfo.Reason.NODE_LEFT &amp;&amp;
            UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get</B></FONT>(settings).nanos() &gt; 0;
        int failedAllocations = reason == UnassignedInfo.Reason.ALLOCATION_FAILED ? 1 : 0;
        RoutingTable routingTable = RoutingTable.builder()
                .add(IndexRoutingTable.builder(shardId.getIndex())
                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)
<A NAME="5"></A>                                        .addShard(primaryShard)
                                        .addShard(ShardRouting.newUnassigned(shardId, false,
                                            RecoverySource.PeerRecoverySource.INSTANCE,
                                            new UnassignedInfo(reason, null, null, failedAllocations, <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#5',2,'match111810-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>System.nanoTime(),
                                                System.currentTimeMillis(), delayed, UnassignedInfo.AllocationStatus.NO_ATTEMPT,
                                                Collections.emptySet())))
                                        .build())
                )
                .build();
        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))
                .metadata(metaData)
                .routingTable(routingTable)
                .nodes(DiscoveryNodes.builder</B></FONT>().add(node1).add(node2).add(node3)).build();
        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());
    }
<A NAME="2"></A>
    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders, UnassignedInfo unassignedInfo) {
        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId, node1.getId(), true, ShardRoutingState.STARTED);
        Metadata metaData = <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#2',2,'match111810-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Metadata.builder()
                .put(IndexMetadata.builder(shardId.getIndexName()).settings(settings(Version.CURRENT))
                    .numberOfShards(1).numberOfReplicas(1)
                    .putInSyncAllocationIds(0, Set.of(primaryShard.allocationId().getId())))
                .build();
        RoutingTable routingTable = RoutingTable.builder()
<A NAME="7"></A>                .add(IndexRoutingTable.builder(shardId.getIndex())</B></FONT>
                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)
                                        .addShard(primaryShard)
                                        .addShard(TestShardRouting.newShardRouting(shardId, <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#7',2,'match111810-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>node2.getId(), null, false,
                                            ShardRoutingState.INITIALIZING, unassignedInfo))
                                        .build())
                )
                .build();
        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))
                .metadata(metaData)
                .routingTable(routingTable)
                .nodes(DiscoveryNodes.builder</B></FONT>().add(node1).add(node2).add(node3)).build();
        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state, ClusterInfo.EMPTY, System.nanoTime());
    }

    private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {
        return onePrimaryOnNode1And1ReplicaRecovering(deciders, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null));
    }

    static RetentionLease newRetentionLease(DiscoveryNode node, long retainingSeqNo) {
        return new RetentionLease(ReplicationTracker.getPeerRecoveryRetentionLeaseId(node.getId()),
            retainingSeqNo, randomNonNegativeLong(), ReplicationTracker.PEER_RECOVERY_RETENTION_LEASE_SOURCE);
    }

    static String randomSyncId() {
        return randomFrom(&quot;MATCH&quot;, &quot;NOT_MATCH&quot;, null);
    }

    class TestAllocator extends ReplicaShardAllocator {

        private Map&lt;DiscoveryNode, TransportNodesListShardStoreMetadata.StoreFilesMetadata&gt; data = null;
        private AtomicBoolean fetchDataCalled = new AtomicBoolean(false);

        public void clean() {
            data = null;
        }

        public void cleanWithEmptyData() {
            data = new HashMap&lt;&gt;();
        }

        public boolean getFetchDataCalledAndClean() {
            return fetchDataCalled.getAndSet(false);
        }

        public TestAllocator addData(DiscoveryNode node, String syncId, StoreFileMetadata... files) {
            return addData(node, Collections.emptyList(), syncId, files);
        }

        TestAllocator addData(DiscoveryNode node, List&lt;RetentionLease&gt; peerRecoveryRetentionLeases,
                              String syncId, StoreFileMetadata... files) {
            if (data == null) {
                data = new HashMap&lt;&gt;();
            }
            Map&lt;String, StoreFileMetadata&gt; filesAsMap = new HashMap&lt;&gt;();
            for (StoreFileMetadata file : files) {
                filesAsMap.put(file.name(), file);
            }
            Map&lt;String, String&gt; commitData = new HashMap&lt;&gt;();
            if (syncId != null) {
                commitData.put(Engine.SYNC_COMMIT_ID, syncId);
            }
            data.put(node, new TransportNodesListShardStoreMetadata.StoreFilesMetadata(shardId,
                    new Store.MetadataSnapshot(unmodifiableMap(filesAsMap), unmodifiableMap(commitData), randomInt()),
                    peerRecoveryRetentionLeases));
            return this;
        }

        @Override
        protected AsyncShardFetch.FetchResult&lt;TransportNodesListShardStoreMetadata.NodeStoreFilesMetadata&gt;
                                                                            fetchData(ShardRouting shard, RoutingAllocation allocation) {
            fetchDataCalled.set(true);
            Map&lt;DiscoveryNode, TransportNodesListShardStoreMetadata.NodeStoreFilesMetadata&gt; tData = null;
            if (data != null) {
                tData = new HashMap&lt;&gt;();
                for (Map.Entry&lt;DiscoveryNode, TransportNodesListShardStoreMetadata.StoreFilesMetadata&gt; entry : data.entrySet()) {
                    tData.put(entry.getKey(),
<A NAME="9"></A>                        new TransportNodesListShardStoreMetadata.NodeStoreFilesMetadata(entry.getKey(), entry.getValue()));
                }
            }
            return new AsyncShardFetch.FetchResult&lt;&gt;(shardId, tData, <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match111810-0.html#9',2,'match111810-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Collections.emptySet());
        }

        @Override
        protected boolean hasInitiatedFetching(ShardRouting shard) {
            return fetchDataCalled.get();
        }</B></FONT>
    }
}
</PRE>
</div>
  </div>
</body>
</html>
