<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for DefaultHttp2FrameWriterTest.java &amp; Http2FrameCodec.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for DefaultHttp2FrameWriterTest.java &amp; Http2FrameCodec.java
      </h3>
<h1 align="center">
        8.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>DefaultHttp2FrameWriterTest.java (14.221219%)<th>Http2FrameCodec.java (6.028708%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-41)<td><a href="#" name="0">(16-41)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(93-97)<td><a href="#" name="1">(279-284)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(332-336)<td><a href="#" name="2">(377-381)</a><td align="center"><font color="#5f0000">9</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(199-206)<td><a href="#" name="3">(430-432)</a><td align="center"><font color="#5f0000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(81-85)<td><a href="#" name="4">(714-718)</a><td align="center"><font color="#5f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DefaultHttp2FrameWriterTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.handler.codec.http2;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.buffer.Unpooled;
4 import io.netty.buffer.UnpooledByteBufAllocator;
5 import io.netty.channel.Channel;
6 import io.netty.channel.ChannelFuture;
7 import io.netty.channel.ChannelHandlerContext;
8 import io.netty.channel.ChannelPromise;
9 import io.netty.channel.DefaultChannelPromise;
10 import io.netty.util.ReferenceCountUtil;
11 import io.netty.util.concurrent.ImmediateEventExecutor;
12 import org.junit.jupiter.api.AfterEach;
13 import org.junit.jupiter.api.BeforeEach;
14 import org.junit.jupiter.api.Test;
15 import org.mockito.Mock;
16 import org.mockito.MockitoAnnotations;
17 import org.mockito.invocation.InvocationOnMock;
18 import org.mockito.stubbing.Answer;
19 import java.io.ByteArrayOutputStream;
20 import java.io.IOException;
21 import java.util.Arrays;
22 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
23 import static org.junit.jupiter.api.Assertions.assertEquals;
24 import</b></font> static org.mockito.Mockito.*;
25 public class DefaultHttp2FrameWriterTest {
26     private DefaultHttp2FrameWriter frameWriter;
27     private ByteBuf outbound;
28     private ByteBuf expectedOutbound;
29     private ChannelPromise promise;
30     private Http2HeadersEncoder http2HeadersEncoder;
31     @Mock
32     private Channel channel;
33     @Mock
34     private ChannelFuture future;
35     @Mock
36     private ChannelHandlerContext ctx;
37     @BeforeEach
38     public void setUp() throws Exception {
39         MockitoAnnotations.initMocks(this);
40         http2HeadersEncoder = new DefaultHttp2HeadersEncoder(
41                 Http2HeadersEncoder.NEVER_SENSITIVE, new HpackEncoder(false, 16, 0));
42         frameWriter = new DefaultHttp2FrameWriter(new DefaultHttp2HeadersEncoder(
43                 Http2HeadersEncoder.NEVER_SENSITIVE, new HpackEncoder(false, 16, 0)));
44         outbound = Unpooled.buffer();
45         expectedOutbound = Unpooled.EMPTY_BUFFER;
46 <a name="4"></a>
47         promise = new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);
48         Answer&lt;Object&gt; answer = new Answer&lt;Object&gt;() <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
49             @Override
50             public Object answer(InvocationOnMock var1) throws Throwable {
51                 Object msg = var1.getArgument(0);
52                 if (msg instanceof ByteBuf) {</b></font>
53                     outbound.writeBytes((ByteBuf) msg);
54                 }
55                 ReferenceCountUtil.release(msg);
56                 return future;
57 <a name="1"></a>            }
58         };
59         when(ctx.write(any())).then(answer);
60         when(ctx.write(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>any(), any(ChannelPromise.class))).then(answer);
61         when(ctx.alloc()).thenReturn(UnpooledByteBufAllocator.DEFAULT);
62         when(ctx.channel()).thenReturn(channel);
63         when(ctx.executor()).thenReturn(ImmediateEventExecutor.INSTANCE);
64     }</b></font>
65     @AfterEach
66     public void tearDown() throws Exception {
67         outbound.release();
68         expectedOutbound.release();
69         frameWriter.close();
70     }
71     @Test
72     public void writeHeaders() throws Exception {
73         int streamId = 1;
74         Http2Headers headers = new DefaultHttp2Headers()
75                 .method("GET").path("/").authority("foo.com").scheme("https");
76         frameWriter.writeHeaders(ctx, streamId, headers, 0, true, promise);
77         byte[] expectedPayload = headerPayload(streamId, headers);
78         byte[] expectedFrameBytes = {
79                 (byte) 0x00, (byte) 0x00, (byte) 0x0a,                 (byte) 0x01,                 (byte) 0x05,                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01         };
80         expectedOutbound = Unpooled.copiedBuffer(expectedFrameBytes, expectedPayload);
81         assertEquals(expectedOutbound, outbound);
82     }
83     @Test
84     public void writeHeadersWithPadding() throws Exception {
85         int streamId = 1;
86         Http2Headers headers = new DefaultHttp2Headers()
87                 .method("GET").path("/").authority("foo.com").scheme("https");
88         frameWriter.writeHeaders(ctx, streamId, headers, 5, true, promise);
89         byte[] expectedPayload = headerPayload(streamId, headers, (byte) 4);
90         byte[] expectedFrameBytes = {
91                 (byte) 0x00, (byte) 0x00, (byte) 0x0f,                 (byte) 0x01,                 (byte) 0x0d,                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01         };
92         expectedOutbound = Unpooled.copiedBuffer(expectedFrameBytes, expectedPayload);
93         assertEquals(expectedOutbound, outbound);
94     }
95     @Test
96     public void writeHeadersNotEndStream() throws Exception {
97         int streamId = 1;
98         Http2Headers headers = new DefaultHttp2Headers()
99                 .method("GET").path("/").authority("foo.com").scheme("https");
100         frameWriter.writeHeaders(ctx, streamId, headers, 0, false, promise);
101         byte[] expectedPayload = headerPayload(streamId, headers);
102         byte[] expectedFrameBytes = {
103                 (byte) 0x00, (byte) 0x00, (byte) 0x0a,                 (byte) 0x01,                 (byte) 0x04,                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01         };
104         ByteBuf expectedOutbound = Unpooled.copiedBuffer(expectedFrameBytes, expectedPayload);
105         assertEquals(expectedOutbound, outbound);
106     }
107     @Test
108     public void writeEmptyDataWithPadding() {
109         int streamId = 1;
110         ByteBuf payloadByteBuf = Unpooled.buffer();
111         frameWriter.writeData(ctx, streamId, payloadByteBuf, 2, true, promise);
112         assertEquals(0, payloadByteBuf.refCnt());
113         byte[] expectedFrameBytes = {
114             (byte) 0x00, (byte) 0x00, (byte) 0x02,             (byte) 0x00,             (byte) 0x09,             (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,             (byte) 0x01, (byte) 0x00,         };
115         expectedOutbound = Unpooled.copiedBuffer(expectedFrameBytes);
116         assertEquals(expectedOutbound, outbound);
117     }
118     @Test
119     public void writeLargeHeaders() throws Exception {
120         int streamId = 1;
121         Http2Headers headers = new DefaultHttp2Headers()
122                 .method("GET").path("/").authority("foo.com").scheme("https");
123         headers = dummyHeaders(headers, 20);
124         http2HeadersEncoder.configuration().maxHeaderListSize(Integer.MAX_VALUE);
125         frameWriter.headersConfiguration().maxHeaderListSize(Integer.MAX_VALUE);
126 <a name="3"></a>        frameWriter.maxFrameSize(Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND);
127         frameWriter.writeHeaders(ctx, streamId, headers, 0, true, promise);
128         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>byte[] expectedPayload = headerPayload(streamId, headers);
129         assertEquals(Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND,
130                      outbound.readUnsignedMedium());
131         assertEquals(0x01, outbound.readByte());
132         assertEquals(0x01, outbound.readByte());
133         assertEquals</b></font>(streamId, outbound.readInt());
134         byte[] firstPayload = new byte[Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND];
135         outbound.readBytes(firstPayload);
136         int remainPayloadLength = expectedPayload.length - Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND;
137         assertEquals(remainPayloadLength, outbound.readUnsignedMedium());
138         assertEquals(0x09, outbound.readByte());
139         assertEquals(0x04, outbound.readByte());
140         assertEquals(streamId, outbound.readInt());
141         byte[] secondPayload = new byte[remainPayloadLength];
142         outbound.readBytes(secondPayload);
143         assertArrayEquals(Arrays.copyOfRange(expectedPayload, 0, firstPayload.length),
144                           firstPayload);
145         assertArrayEquals(Arrays.copyOfRange(expectedPayload, firstPayload.length,
146                                              expectedPayload.length),
147                           secondPayload);
148     }
149     @Test
150     public void writeLargeHeaderWithPadding() throws Exception {
151         int streamId = 1;
152         Http2Headers headers = new DefaultHttp2Headers()
153                 .method("GET").path("/").authority("foo.com").scheme("https");
154         headers = dummyHeaders(headers, 20);
155         http2HeadersEncoder.configuration().maxHeaderListSize(Integer.MAX_VALUE);
156         frameWriter.headersConfiguration().maxHeaderListSize(Integer.MAX_VALUE);
157         frameWriter.maxFrameSize(Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND);
158         frameWriter.writeHeaders(ctx, streamId, headers, 5, true, promise);
159         byte[] expectedPayload = buildLargeHeaderPayload(streamId, headers, (byte) 4,
160                 Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND);
161         assertEquals(Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND,
162                 outbound.readUnsignedMedium());
163         assertEquals(0x01, outbound.readByte());
164         assertEquals(0x09, outbound.readByte());         assertEquals(streamId, outbound.readInt());
165         byte[] firstPayload = new byte[Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND];
166         outbound.readBytes(firstPayload);
167         int remainPayloadLength = expectedPayload.length - Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND;
168         assertEquals(remainPayloadLength, outbound.readUnsignedMedium());
169         assertEquals(0x09, outbound.readByte());
170         assertEquals(0x04, outbound.readByte());
171         assertEquals(streamId, outbound.readInt());
172         byte[] secondPayload = new byte[remainPayloadLength];
173         outbound.readBytes(secondPayload);
174         assertArrayEquals(Arrays.copyOfRange(expectedPayload, 0, firstPayload.length),
175                 firstPayload);
176         assertArrayEquals(Arrays.copyOfRange(expectedPayload, firstPayload.length,
177                 expectedPayload.length),
178                 secondPayload);
179     }
180     @Test
181     public void writeFrameZeroPayload() throws Exception {
182         frameWriter.writeFrame(ctx, (byte) 0xf, 0, new Http2Flags(), Unpooled.EMPTY_BUFFER, promise);
183         byte[] expectedFrameBytes = {
184                 (byte) 0x00, (byte) 0x00, (byte) 0x00,                 (byte) 0x0f,                 (byte) 0x00,                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00         };
185         expectedOutbound = Unpooled.wrappedBuffer(expectedFrameBytes);
186         assertEquals(expectedOutbound, outbound);
187     }
188     @Test
189     public void writeFrameHasPayload() throws Exception {
190         byte[] payload = {(byte) 0x01, (byte) 0x03, (byte) 0x05, (byte) 0x07, (byte) 0x09};
191         ByteBuf payloadByteBuf = Unpooled.wrappedBuffer(payload);
192         frameWriter.writeFrame(ctx, (byte) 0xf, 0, new Http2Flags(), payloadByteBuf, promise);
193         byte[] expectedFrameHeaderBytes = {
194                 (byte) 0x00, (byte) 0x00, (byte) 0x05,                 (byte) 0x0f,                 (byte) 0x00,                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00         };
195         expectedOutbound = Unpooled.copiedBuffer(expectedFrameHeaderBytes, payload);
196         assertEquals(expectedOutbound, outbound);
197     }
198     @Test
199     public void writePriority() {
200         frameWriter.writePriority(
201             ctx, 
202         expectedOutbound = Unpooled.copiedBuffer(new byte[] {
203                 (byte) 0x00, (byte) 0x00, (byte) 0x05,                 (byte) 0x02,                 (byte) 0x00,                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,                 (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x02,                 (byte) 0xFF,         });
204         assertEquals(expectedOutbound, outbound);
205     }
206     @Test
207     public void writePriorityDefaults() {
208         frameWriter.writePriority(
209             ctx, 
210         expectedOutbound = Unpooled.copiedBuffer(new byte[] {
211                 (byte) 0x00, (byte) 0x00, (byte) 0x05,                 (byte) 0x02,                 (byte) 0x00,                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, <a name="2"></a>                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,                 (byte) 0x0F,         });
212         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(expectedOutbound, outbound);
213     }
214     private byte[] headerPayload(int streamId, Http2Headers headers, byte padding) throws Http2Exception, IOException {
215         if</b></font> (padding == 0) {
216             return headerPayload(streamId, headers);
217         }
218         ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
219         try {
220             outputStream.write(padding);
221             outputStream.write(headerPayload(streamId, headers));
222             outputStream.write(new byte[padding]);
223             return outputStream.toByteArray();
224         } finally {
225             outputStream.close();
226         }
227     }
228     private byte[] headerPayload(int streamId, Http2Headers headers) throws Http2Exception {
229         ByteBuf byteBuf = Unpooled.buffer();
230         try {
231             http2HeadersEncoder.encodeHeaders(streamId, headers, byteBuf);
232             byte[] bytes = new byte[byteBuf.readableBytes()];
233             byteBuf.readBytes(bytes);
234             return bytes;
235         } finally {
236             byteBuf.release();
237         }
238     }
239     private byte[] buildLargeHeaderPayload(int streamId, Http2Headers headers, byte padding, int maxFrameSize)
240             throws Http2Exception, IOException {
241         ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
242         try {
243             outputStream.write(padding);
244             byte[] payload = headerPayload(streamId, headers);
245             int firstPayloadSize = maxFrameSize - (padding + 1); //1 for padding length
246             outputStream.write(payload, 0, firstPayloadSize);
247             outputStream.write(new byte[padding]);
248             outputStream.write(payload, firstPayloadSize, payload.length - firstPayloadSize);
249             return outputStream.toByteArray();
250         } finally {
251             outputStream.close();
252         }
253     }
254     private static Http2Headers dummyHeaders(Http2Headers headers, int times) {
255         final String largeValue = repeat("dummy-value", 100);
256         for (int i = 0; i &lt; times; i++) {
257             headers.add(String.format("dummy-%d", i), largeValue);
258         }
259         return headers;
260     }
261     private static String repeat(String str, int count) {
262         return String.format(String.format("%%%ds", count), " ").replace(" ", str);
263     }
264 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Http2FrameCodec.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.codec.http2;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.channel.Channel;
4 import io.netty.channel.ChannelFuture;
5 import io.netty.channel.ChannelFutureListener;
6 import io.netty.channel.ChannelHandlerContext;
7 import io.netty.channel.ChannelInboundHandler;
8 import io.netty.channel.ChannelPromise;
9 import io.netty.handler.codec.UnsupportedMessageTypeException;
10 import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeEvent;
11 import io.netty.handler.codec.http2.Http2Connection.PropertyKey;
12 import io.netty.handler.codec.http2.Http2Stream.State;
13 import io.netty.handler.codec.http2.StreamBufferingEncoder.Http2ChannelClosedException;
14 import io.netty.handler.codec.http2.StreamBufferingEncoder.Http2GoAwayException;
15 import io.netty.util.ReferenceCountUtil;
16 import io.netty.util.ReferenceCounted;
17 import io.netty.util.collection.IntObjectHashMap;
18 import io.netty.util.collection.IntObjectMap;
19 import io.netty.util.internal.UnstableApi;
20 import io.netty.util.internal.logging.InternalLogger;
21 import io.netty.util.internal.logging.InternalLoggerFactory;
22 import static io.netty.buffer.ByteBufUtil.writeAscii;
23 import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_STREAM_ID;
24 import</b></font> static io.netty.handler.codec.http2.Http2CodecUtil.isStreamIdValid;
25 import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;
26 import static io.netty.util.internal.logging.InternalLogLevel.DEBUG;
27 @UnstableApi
28 public class Http2FrameCodec extends Http2ConnectionHandler {
29     private static final InternalLogger LOG = InternalLoggerFactory.getInstance(Http2FrameCodec.class);
30     protected final PropertyKey streamKey;
31     private final PropertyKey upgradeKey;
32     private final Integer initialFlowControlWindowSize;
33     ChannelHandlerContext ctx;
34     private int numBufferedStreams;
35     private final IntObjectMap&lt;DefaultHttp2FrameStream&gt; frameStreamToInitializeMap =
36             new IntObjectHashMap&lt;DefaultHttp2FrameStream&gt;(8);
37     Http2FrameCodec(Http2ConnectionEncoder encoder, Http2ConnectionDecoder decoder, Http2Settings initialSettings,
38                     boolean decoupleCloseAndGoAway) {
39         super(decoder, encoder, initialSettings, decoupleCloseAndGoAway);
40         decoder.frameListener(new FrameListener());
41         connection().addListener(new ConnectionListener());
42         connection().remote().flowController().listener(new Http2RemoteFlowControllerListener());
43         streamKey = connection().newKey();
44         upgradeKey = connection().newKey();
45         initialFlowControlWindowSize = initialSettings.initialWindowSize();
46     }
47     DefaultHttp2FrameStream newStream() {
48         return new DefaultHttp2FrameStream();
49     }
50     final void forEachActiveStream(final Http2FrameStreamVisitor streamVisitor) throws Http2Exception {
51         assert ctx.executor().inEventLoop();
52         if (connection().numActiveStreams() &gt; 0) {
53             connection().forEachActiveStream(new Http2StreamVisitor() {
54                 @Override
55                 public boolean visit(Http2Stream stream) {
56                     try {
57                         return streamVisitor.visit((Http2FrameStream) stream.getProperty(streamKey));
58                     } catch (Throwable cause) {
59                         onError(ctx, false, cause);
60                         return false;
61                     }
62                 }
63             });
64         }
65     }
66     int numInitializingStreams() {
67         return frameStreamToInitializeMap.size();
68     }
69     @Override
70     public final void handlerAdded(ChannelHandlerContext ctx) throws Exception {
71         this.ctx = ctx;
72         super.handlerAdded(ctx);
73         handlerAdded0(ctx);
74         Http2Connection connection = connection();
75         if (connection.isServer()) {
76             tryExpandConnectionFlowControlWindow(connection);
77         }
78     }
79     private void tryExpandConnectionFlowControlWindow(Http2Connection connection) throws Http2Exception {
80         if (initialFlowControlWindowSize != null) {
81             Http2Stream connectionStream = connection.connectionStream();
82             Http2LocalFlowController localFlowController = connection.local().flowController();
83             final int delta = initialFlowControlWindowSize - localFlowController.initialWindowSize(connectionStream);
84             if (delta &gt; 0) {
85                 localFlowController.incrementWindowSize(connectionStream, Math.max(delta &lt;&lt; 1, delta));
86                 flush(ctx);
87             }
88         }
89     }
90     void handlerAdded0(@SuppressWarnings("unsed") ChannelHandlerContext ctx) throws Exception {
91     }
92     @Override
93     public final void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) throws Exception {
94         if (evt == Http2ConnectionPrefaceAndSettingsFrameWrittenEvent.INSTANCE) {
95             tryExpandConnectionFlowControlWindow(connection());
96             ctx.executor().execute(new Runnable() {
97                 @Override
98                 public void run() {
99                     ctx.fireUserEventTriggered(evt);
100                 }
101             });
102         } else if (evt instanceof UpgradeEvent) {
103             UpgradeEvent upgrade = (UpgradeEvent) evt;
104             try {
105                 onUpgradeEvent(ctx, upgrade.retain());
106                 Http2Stream stream = connection().stream(HTTP_UPGRADE_STREAM_ID);
107                 if (stream.getProperty(streamKey) == null) {
108 <a name="1"></a>                                        onStreamActive0(stream);
109                 }
110                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>upgrade.upgradeRequest().headers().setInt(
111                         HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text(), HTTP_UPGRADE_STREAM_ID);
112                 stream.setProperty(upgradeKey, true);
113                 InboundHttpToHttp2Adapter.handle(
114                         ctx, connection(), decoder().frameListener(), upgrade.upgradeRequest().retain());
115             }</b></font> finally {
116                 upgrade.release();
117             }
118         } else {
119             ctx.fireUserEventTriggered(evt);
120         }
121     }
122     @Override
123     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
124         if (msg instanceof Http2DataFrame) {
125             Http2DataFrame dataFrame = (Http2DataFrame) msg;
126             encoder().writeData(ctx, dataFrame.stream().id(), dataFrame.content(),
127                     dataFrame.padding(), dataFrame.isEndStream(), promise);
128         } else if (msg instanceof Http2HeadersFrame) {
129             writeHeadersFrame(ctx, (Http2HeadersFrame) msg, promise);
130         } else if (msg instanceof Http2WindowUpdateFrame) {
131             Http2WindowUpdateFrame frame = (Http2WindowUpdateFrame) msg;
132             Http2FrameStream frameStream = frame.stream();
133             try {
134                 if (frameStream == null) {
135                     increaseInitialConnectionWindow(frame.windowSizeIncrement());
136                 } else {
137                     consumeBytes(frameStream.id(), frame.windowSizeIncrement());
138                 }
139                 promise.setSuccess();
140             } catch (Throwable t) {
141                 promise.setFailure(t);
142             }
143         } else if (msg instanceof Http2ResetFrame) {
144             Http2ResetFrame rstFrame = (Http2ResetFrame) msg;
145             int id = rstFrame.stream().id();
146             if (connection().streamMayHaveExisted(id)) {
147                 encoder().writeRstStream(ctx, rstFrame.stream().id(), rstFrame.errorCode(), promise);
148             } else {
149                 ReferenceCountUtil.release(rstFrame);
150                 promise.setFailure(Http2Exception.streamError(
151                         rstFrame.stream().id(), Http2Error.PROTOCOL_ERROR, "Stream never existed"));
152             }
153         } else if (msg instanceof Http2PingFrame) {
154             Http2PingFrame frame = (Http2PingFrame) msg;
155             encoder().writePing(ctx, frame.ack(), frame.content(), promise);
156         } else if (msg instanceof Http2SettingsFrame) {
157             encoder().writeSettings(ctx, ((Http2SettingsFrame) msg).settings(), promise);
158         } else if (msg instanceof Http2SettingsAckFrame) {
159             encoder().writeSettingsAck(ctx, promise);
160         } else if (msg instanceof Http2GoAwayFrame) {
161             writeGoAwayFrame(ctx, (Http2GoAwayFrame) msg, promise);
162         } else if (msg instanceof Http2PushPromiseFrame) {
163             Http2PushPromiseFrame pushPromiseFrame = (Http2PushPromiseFrame) msg;
164             writePushPromise(ctx, pushPromiseFrame, promise);
165         } else if (msg instanceof Http2PriorityFrame) {
166             Http2PriorityFrame priorityFrame = (Http2PriorityFrame) msg;
167             encoder().writePriority(ctx, priorityFrame.stream().id(), priorityFrame.streamDependency(),
168                     priorityFrame.weight(), priorityFrame.exclusive(), promise);
169         } else if (msg instanceof Http2UnknownFrame) {
170             Http2UnknownFrame unknownFrame = (Http2UnknownFrame) msg;
171             encoder().writeFrame(ctx, unknownFrame.frameType(), unknownFrame.stream().id(),
172                     unknownFrame.flags(), unknownFrame.content(), promise);
173         } else if (!(msg instanceof Http2Frame)) {
174             ctx.write(msg, promise);
175         } else {
176             ReferenceCountUtil.release(msg);
177             throw new UnsupportedMessageTypeException(msg);
178         }
179     }
180     private void increaseInitialConnectionWindow(int deltaBytes) throws Http2Exception {
181         connection().local().flowController().incrementWindowSize(connection().connectionStream(), deltaBytes);
182     }
183     final boolean consumeBytes(int streamId, int bytes) throws Http2Exception {
184         Http2Stream stream = connection().stream(streamId);
185         if (stream != null &amp;&amp; streamId == Http2CodecUtil.HTTP_UPGRADE_STREAM_ID) {
186             Boolean upgraded = stream.getProperty(upgradeKey);
187             if (Boolean.TRUE.equals(upgraded)) {
188                 return false;
189 <a name="2"></a>            }
190         }
191         return <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>connection().local().flowController().consumeBytes(stream, bytes);
192     }
193     private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame, ChannelPromise promise) {
194         if</b></font> (frame.lastStreamId() &gt; -1) {
195             frame.release();
196             throw new IllegalArgumentException("Last stream id must not be set on GOAWAY frame");
197         }
198         int lastStreamCreated = connection().remote().lastStreamCreated();
199         long lastStreamId = lastStreamCreated + ((long) frame.extraStreamIds()) * 2;
200         if (lastStreamId &gt; Integer.MAX_VALUE) {
201             lastStreamId = Integer.MAX_VALUE;
202         }
203         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);
204     }
205     private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,
206                                    final ChannelPromise promise) {
207         if (isStreamIdValid(headersFrame.stream().id())) {
208             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),
209                     headersFrame.isEndStream(), promise);
210         } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {
211             final int streamId = headersFrame.stream().id();
212             encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),
213                     headersFrame.isEndStream(), promise);
214             if (!promise.isDone()) {
215                 numBufferedStreams++;
216                 promise.addListener(new ChannelFutureListener() {
217                     @Override
218                     public void operationComplete(ChannelFuture channelFuture) {
219                         numBufferedStreams--;
220                         handleHeaderFuture(channelFuture, streamId);
221                     }
222                 });
223             } else {
224                 handleHeaderFuture(promise, streamId);
225             }
226         }
227     }
228     private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,
229                                   final ChannelPromise promise) {
230         if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {
231 <a name="3"></a>            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),
232                     pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);
233         } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise)) {
234             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final int streamId = pushPromiseFrame.stream().id();
235             encoder().writePushPromise(ctx, streamId, pushPromiseFrame.pushStream().id(),
236                     pushPromiseFrame.http2Headers(), pushPromiseFrame.padding</b></font>(), promise);
237             if (promise.isDone()) {
238                 handleHeaderFuture(promise, streamId);
239             } else {
240                 numBufferedStreams++;
241                 promise.addListener(new ChannelFutureListener() {
242                     @Override
243                     public void operationComplete(ChannelFuture channelFuture) {
244                         numBufferedStreams--;
245                         handleHeaderFuture(channelFuture, streamId);
246                     }
247                 });
248             }
249         }
250     }
251     private boolean initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,
252                                         ChannelPromise promise) {
253         final Http2Connection connection = connection();
254         final int streamId = connection.local().incrementAndGetNextStreamId();
255         if (streamId &lt; 0) {
256             promise.setFailure(new Http2NoMoreStreamIdsException());
257             onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :
258                     Integer.MAX_VALUE - 1, NO_ERROR.code(),
259                     writeAscii(ctx.alloc(), "Stream IDs exhausted on local stream creation")));
260             return false;
261         }
262         http2FrameStream.id = streamId;
263         //
264         Object old = frameStreamToInitializeMap.put(streamId, http2FrameStream);
265         assert old == null;
266         return true;
267     }
268     private void handleHeaderFuture(ChannelFuture channelFuture, int streamId) {
269         if (!channelFuture.isSuccess()) {
270             frameStreamToInitializeMap.remove(streamId);
271         }
272     }
273     private void onStreamActive0(Http2Stream stream) {
274         if (stream.id() != Http2CodecUtil.HTTP_UPGRADE_STREAM_ID &amp;&amp;
275                 connection().local().isValidStreamId(stream.id())) {
276             return;
277         }
278         DefaultHttp2FrameStream stream2 = newStream().setStreamAndProperty(streamKey, stream);
279         onHttp2StreamStateChanged(ctx, stream2);
280     }
281     private final class ConnectionListener extends Http2ConnectionAdapter {
282         @Override
283         public void onStreamAdded(Http2Stream stream) {
284             DefaultHttp2FrameStream frameStream = frameStreamToInitializeMap.remove(stream.id());
285             if (frameStream != null) {
286                 frameStream.setStreamAndProperty(streamKey, stream);
287             }
288         }
289         @Override
290         public void onStreamActive(Http2Stream stream) {
291             onStreamActive0(stream);
292         }
293         @Override
294         public void onStreamClosed(Http2Stream stream) {
295             onHttp2StreamStateChanged0(stream);
296         }
297         @Override
298         public void onStreamHalfClosed(Http2Stream stream) {
299             onHttp2StreamStateChanged0(stream);
300         }
301         private void onHttp2StreamStateChanged0(Http2Stream stream) {
302             DefaultHttp2FrameStream stream2 = stream.getProperty(streamKey);
303             if (stream2 != null) {
304                 onHttp2StreamStateChanged(ctx, stream2);
305             }
306         }
307     }
308     @Override
309     protected void onConnectionError(
310             ChannelHandlerContext ctx, boolean outbound, Throwable cause, Http2Exception http2Ex) {
311         if (!outbound) {
312             //
313             ctx.fireExceptionCaught(cause);
314         }
315         super.onConnectionError(ctx, outbound, cause, http2Ex);
316     }
317     @Override
318     protected final void onStreamError(ChannelHandlerContext ctx, boolean outbound, Throwable cause,
319                                        Http2Exception.StreamException streamException) {
320         int streamId = streamException.streamId();
321         Http2Stream connectionStream = connection().stream(streamId);
322         if (connectionStream == null) {
323             onHttp2UnknownStreamError(ctx, cause, streamException);
324             super.onStreamError(ctx, outbound, cause, streamException);
325             return;
326         }
327         Http2FrameStream stream = connectionStream.getProperty(streamKey);
328         if (stream == null) {
329             LOG.warn("Stream exception thrown without stream object attached.", cause);
330             super.onStreamError(ctx, outbound, cause, streamException);
331             return;
332         }
333         if (!outbound) {
334             onHttp2FrameStreamException(ctx, new Http2FrameStreamException(stream, streamException.error(), cause));
335         }
336     }
337     private static void onHttp2UnknownStreamError(@SuppressWarnings("unused") ChannelHandlerContext ctx,
338             Throwable cause, Http2Exception.StreamException streamException) {
339         LOG.log(DEBUG, "Stream exception thrown for unknown stream {}.", streamException.streamId(), cause);
340     }
341     @Override
342     protected final boolean isGracefulShutdownComplete() {
343         return super.isGracefulShutdownComplete() &amp;&amp; numBufferedStreams == 0;
344     }
345     private final class FrameListener implements Http2FrameListener {
346         @Override
347         public void onUnknownFrame(
348                 ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags, ByteBuf payload) {
349             if (streamId == 0) {
350                 return;
351             }
352             onHttp2Frame(ctx, new DefaultHttp2UnknownFrame(frameType, flags, payload)
353                     .stream(requireStream(streamId)).retain());
354         }
355         @Override
356         public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) {
357             onHttp2Frame(ctx, new DefaultHttp2SettingsFrame(settings));
358         }
359         @Override
360         public void onPingRead(ChannelHandlerContext ctx, long data) {
361             onHttp2Frame(ctx, new DefaultHttp2PingFrame(data, false));
362         }
363         @Override
364         public void onPingAckRead(ChannelHandlerContext ctx, long data) {
365             onHttp2Frame(ctx, new DefaultHttp2PingFrame(data, true));
366         }
367         @Override
368         public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) {
369             onHttp2Frame(ctx, new DefaultHttp2ResetFrame(errorCode).stream(requireStream(streamId)));
370         }
371         @Override
372         public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement) {
373             if (streamId == 0) {
374                 return;
375             }
376             onHttp2Frame(ctx, new DefaultHttp2WindowUpdateFrame(windowSizeIncrement).stream(requireStream(streamId)));
377         }
378         @Override
379         public void onHeadersRead(ChannelHandlerContext ctx, int streamId,
380                                   Http2Headers headers, int streamDependency, short weight, boolean
381                                           exclusive, int padding, boolean endStream) {
382             onHeadersRead(ctx, streamId, headers, padding, endStream);
383         }
384         @Override
385         public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers,
386                                   int padding, boolean endOfStream) {
387             onHttp2Frame(ctx, new DefaultHttp2HeadersFrame(headers, endOfStream, padding)
388                     .stream(requireStream(streamId)));
389         }
390         @Override
391         public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,
392                               boolean endOfStream) {
393             onHttp2Frame(ctx, new DefaultHttp2DataFrame(data, endOfStream, padding)
394                     .stream(requireStream(streamId)).retain());
395             return 0;
396         }
397         @Override
398         public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData) {
399             onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(lastStreamId, errorCode, debugData).retain());
400         }
401         @Override
402         public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency,
403                                    short weight, boolean exclusive) {
404             Http2Stream stream = connection().stream(streamId);
405             if (stream == null) {
406                 return;
407             }
408             onHttp2Frame(ctx, new DefaultHttp2PriorityFrame(streamDependency, weight, exclusive)
409                     .stream(requireStream(streamId)));
410         }
411         @Override
412         public void onSettingsAckRead(ChannelHandlerContext ctx) {
413             onHttp2Frame(ctx, Http2SettingsAckFrame.INSTANCE);
414         }
415         @Override
416         public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,
417                                       Http2Headers headers, int padding) {
418             onHttp2Frame(ctx, new DefaultHttp2PushPromiseFrame(headers, padding, promisedStreamId)
419                     .pushStream(new DefaultHttp2FrameStream()
420                             .setStreamAndProperty(streamKey, connection().stream(promisedStreamId)))
421                     .stream(requireStream(streamId)));
422         }
423         private Http2FrameStream requireStream(int streamId) {
424             Http2FrameStream stream = connection().stream(streamId).getProperty(streamKey);
425             if (stream == null) {
426                 throw new IllegalStateException("Stream object required for identifier: " + streamId);
427             }
428             return stream;
429         }
430     }
431     private void onUpgradeEvent(ChannelHandlerContext ctx, UpgradeEvent evt) {
432         ctx.fireUserEventTriggered(evt);
433     }
434     private void onHttp2StreamWritabilityChanged(ChannelHandlerContext ctx, DefaultHttp2FrameStream stream,
435                                                  @SuppressWarnings("unused") boolean writable) {
436         ctx.fireUserEventTriggered(stream.writabilityChanged);
437     }
438     void onHttp2StreamStateChanged(ChannelHandlerContext ctx, DefaultHttp2FrameStream stream) {
439         ctx.fireUserEventTriggered(stream.stateChanged);
440     }
441     void onHttp2Frame(ChannelHandlerContext ctx, Http2Frame frame) {
442         ctx.fireChannelRead(frame);
443     }
444     void onHttp2FrameStreamException(ChannelHandlerContext ctx, Http2FrameStreamException cause) {
445 <a name="4"></a>        ctx.fireExceptionCaught(cause);
446     }
447     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private final class Http2RemoteFlowControllerListener implements Http2RemoteFlowController.Listener {
448         @Override
449         public void writabilityChanged(Http2Stream stream) {
450             DefaultHttp2FrameStream frameStream = stream.getProperty(streamKey);
451             if (frameStream == null) {</b></font>
452                 return;
453             }
454             onHttp2StreamWritabilityChanged(
455                     ctx, frameStream, connection().remote().flowController().isWritable(stream));
456         }
457     }
458     static class DefaultHttp2FrameStream implements Http2FrameStream {
459         private volatile int id = -1;
460         private volatile Http2Stream stream;
461         final Http2FrameStreamEvent stateChanged = Http2FrameStreamEvent.stateChanged(this);
462         final Http2FrameStreamEvent writabilityChanged = Http2FrameStreamEvent.writabilityChanged(this);
463         Channel attachment;
464         DefaultHttp2FrameStream setStreamAndProperty(PropertyKey streamKey, Http2Stream stream) {
465             assert id == -1 || stream.id() == id;
466             this.stream = stream;
467             stream.setProperty(streamKey, this);
468             return this;
469         }
470         @Override
471         public int id() {
472             Http2Stream stream = this.stream;
473             return stream == null ? id : stream.id();
474         }
475         @Override
476         public State state() {
477             Http2Stream stream = this.stream;
478             return stream == null ? State.IDLE : stream.state();
479         }
480         @Override
481         public String toString() {
482             return String.valueOf(id());
483         }
484     }
485 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
