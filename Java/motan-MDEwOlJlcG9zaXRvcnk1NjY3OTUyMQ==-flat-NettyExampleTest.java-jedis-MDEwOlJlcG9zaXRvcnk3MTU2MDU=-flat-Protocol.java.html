
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.8296973961998593%, Tokens: 13</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyExampleTest.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.weibo.api.motan.transport.netty;
2  import junit.framework.TestCase;
3  import org.junit.Assert;
4  import org.junit.Before;
5  import org.junit.Test;
6  import com.weibo.api.motan.codec.Codec;
7  import com.weibo.api.motan.common.URLParamType;
8  import com.weibo.api.motan.core.extension.ExtensionLoader;
9  import com.weibo.api.motan.rpc.DefaultRequest;
10  import com.weibo.api.motan.rpc.DefaultResponse;
11  import com.weibo.api.motan.rpc.Request;
12  import com.weibo.api.motan.rpc.URL;
13  import com.weibo.api.motan.transport.Channel;
</span>14  import com.weibo.api.motan.transport.MessageHandler;
15  import com.weibo.api.motan.util.RequestIdGenerator;
16  @SuppressWarnings({"rawtypes", "unchecked"})
17  public class NettyExampleTest extends TestCase {
18      private static URL url = null;
19      static {
20          ExtensionLoader loader = ExtensionLoader.getExtensionLoader(Codec.class);
21          loader.addExtensionClass(MockDefaultRpcCodec.class);
22      }
23      @Before
24      public void setUp() {
25          url = new URL("netty", "localhost", 18080, "com.weibo.api.motan.procotol.example.IHello");
26          url.addParameter(URLParamType.codec.getName(), "mockMotan");
27          url.addParameter(URLParamType.requestTimeout.getName(), "2000");
28      }
29      @Test
30      public void testNettyEncodeException() throws Exception {
31          NettyServer nettyServer;
32          nettyServer = new NettyServer(url, new MessageHandler() {
33              @Override
34              public Object handle(Channel channel, Object message) {
35                  Request request = (Request) message;
36                  DefaultResponse response = new DefaultResponse();
37                  response.setRequestId(request.getRequestId());
38                  response.setValue(new UnSerializableClass());
39                  return response;
40              }
41          });
42          nettyServer.open();
43          NettyClient nettyClient = new NettyClient(url);
44          nettyClient.open();
45          DefaultRequest request = new DefaultRequest();
46          request.setRequestId(RequestIdGenerator.getRequestId());
47          request.setInterfaceName(url.getPath());
48          request.setMethodName("helloSerializable");
49          request.setParamtersDesc("com.weibo.api.motan.procotol.example.UnSerializableClass");
50          request.setArguments(new Object[] {new UnSerializableClass()});
51          try {
52              nettyClient.request(request);
53              Assert.assertFalse(true);
54          } catch (Exception e) {
55              Assert.assertTrue(true);
56          }
57          DefaultRequest request1 = new DefaultRequest();
58          request1.setRequestId(RequestIdGenerator.getRequestId());
59          request1.setInterfaceName(url.getPath());
60          request1.setMethodName("helloSerializable");
61          request1.setParamtersDesc("void");
62          try {
63              nettyClient.request(request1);
64              Assert.fail();
65          } catch (Exception e) {
66              Assert.assertTrue(e.getMessage().contains("error_code: 20002"));
67          } finally {
68              nettyClient.close();
69              nettyServer.close();
70          }
71      }
72      @Test
73      public void testNettyRequestDecodeException() throws Exception {
74          NettyServer nettyServer;
75          nettyServer = new NettyServer(url, new MessageHandler() {
76              @Override
77              public Object handle(Channel channel, Object message) {
78                  Request request = (Request) message;
79                  DefaultResponse response = new DefaultResponse();
80                  response.setRequestId(request.getRequestId());
81                  response.setValue("success");
82                  return response;
83              }
84          });
85          nettyServer.open();
86          NettyClient nettyClient = new NettyClient(url);
87          nettyClient.open();
88          DefaultRequest request = new DefaultRequest();
89          request.setRequestId(RequestIdGenerator.getRequestId());
90          request.setInterfaceName(url.getPath());
91          request.setMethodName("hello");
92          request.setParamtersDesc("void");
93          try {
94              nettyClient.request(request);
95              Assert.assertTrue(false);
96          } catch (Exception e) {
97              Assert.assertTrue(e.getMessage().contains("framework decode error"));
98          } finally {
99              nettyClient.close();
100              nettyServer.close();
101          }
102      }
103      @Test
104      public void testNettyDecodeException() throws Exception {
105          NettyServer nettyServer;
106          nettyServer = new NettyServer(url, new MessageHandler() {
107              @Override
108              public Object handle(Channel channel, Object message) {
109                  Request request = (Request) message;
110                  DefaultResponse response = new DefaultResponse();
111                  response.setRequestId(request.getRequestId());
112                  response.setValue("error");
113                  return response;
114              }
115          });
116          nettyServer.open();
117          NettyClient nettyClient = new NettyClient(url);
118          nettyClient.open();
119          DefaultRequest request = new DefaultRequest();
120          request.setRequestId(RequestIdGenerator.getRequestId());
121          request.setInterfaceName(url.getPath());
122          request.setMethodName("hello");
123          request.setParamtersDesc("void");
124          try {
125              nettyClient.request(request);
126              Assert.assertTrue(false);
127          } catch (Exception e) {
128              Assert.assertTrue(e.getMessage().contains("response dataType not support"));
129          } finally {
130              nettyClient.close();
131              nettyServer.close();
132          }
133      }
134  }
135  class UnSerializableClass {
136      public String hello() {
137          return "I am a unserializable class";
138      }
139  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Protocol.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package redis.clients.jedis;
2  import java.io.IOException;
3  import java.nio.charset.Charset;
4  import java.nio.charset.StandardCharsets;
5  import java.util.ArrayList;
6  import java.util.List;
7  import java.util.Locale;
8  import redis.clients.jedis.exceptions.*;
9  import redis.clients.jedis.args.Rawable;
10  import redis.clients.jedis.commands.ProtocolCommand;
11  import redis.clients.jedis.util.RedisInputStream;
12  import redis.clients.jedis.util.RedisOutputStream;
13  import redis.clients.jedis.util.SafeEncoder;
</span>14  public final class Protocol {
15    public static final String DEFAULT_HOST = "127.0.0.1";
16    public static final int DEFAULT_PORT = 6379;
17    public static final int DEFAULT_SENTINEL_PORT = 26379;
18    public static final int DEFAULT_TIMEOUT = 2000;
19    public static final int DEFAULT_DATABASE = 0;
20    public static final int CLUSTER_HASHSLOTS = 16384;
21    public static final Charset CHARSET = StandardCharsets.UTF_8;
22    public static final byte ASTERISK_BYTE = '*';
23    public static final byte COLON_BYTE = ':';
24    public static final byte COMMA_BYTE = ',';
25    public static final byte DOLLAR_BYTE = '$';
26    public static final byte EQUAL_BYTE = '=';
27    public static final byte GREATER_THAN_BYTE = '>';
28    public static final byte HASH_BYTE = '#';
29    public static final byte LEFT_BRACE_BYTE = '(';
30    public static final byte MINUS_BYTE = '-';
31    public static final byte PERCENT_BYTE = '%';
32    public static final byte PLUS_BYTE = '+';
33    public static final byte TILDE_BYTE = '~';
34    public static final byte UNDERSCORE_BYTE = '_';
35    public static final byte[] BYTES_TRUE = toByteArray(1);
36    public static final byte[] BYTES_FALSE = toByteArray(0);
37    public static final byte[] BYTES_TILDE = SafeEncoder.encode("~");
38    public static final byte[] BYTES_EQUAL = SafeEncoder.encode("=");
39    public static final byte[] BYTES_ASTERISK = SafeEncoder.encode("*");
40    public static final byte[] POSITIVE_INFINITY_BYTES = "+inf".getBytes();
41    public static final byte[] NEGATIVE_INFINITY_BYTES = "-inf".getBytes();
42    private static final String ASK_PREFIX = "ASK ";
43    private static final String MOVED_PREFIX = "MOVED ";
44    private static final String CLUSTERDOWN_PREFIX = "CLUSTERDOWN ";
45    private static final String BUSY_PREFIX = "BUSY ";
46    private static final String NOSCRIPT_PREFIX = "NOSCRIPT ";
47    private static final String WRONGPASS_PREFIX = "WRONGPASS";
48    private static final String NOPERM_PREFIX = "NOPERM";
49    private Protocol() {
50      throw new InstantiationError("Must not instantiate this class");
51    }
52    public static void sendCommand(final RedisOutputStream os, CommandArguments args) {
53      try {
54        os.write(ASTERISK_BYTE);
55        os.writeIntCrLf(args.size());
56        for (Rawable arg : args) {
57          os.write(DOLLAR_BYTE);
58          final byte[] bin = arg.getRaw();
59          os.writeIntCrLf(bin.length);
60          os.write(bin);
61          os.writeCrLf();
62        }
63      } catch (IOException e) {
64        throw new JedisConnectionException(e);
65      }
66    }
67    private static void processError(final RedisInputStream is) {
68      String message = is.readLine();
69      if (message.startsWith(MOVED_PREFIX)) {
70        String[] movedInfo = parseTargetHostAndSlot(message);
71        throw new JedisMovedDataException(message, HostAndPort.from(movedInfo[1]), Integer.parseInt(movedInfo[0]));
72      } else if (message.startsWith(ASK_PREFIX)) {
73        String[] askInfo = parseTargetHostAndSlot(message);
74        throw new JedisAskDataException(message, HostAndPort.from(askInfo[1]), Integer.parseInt(askInfo[0]));
75      } else if (message.startsWith(CLUSTERDOWN_PREFIX)) {
76        throw new JedisClusterException(message);
77      } else if (message.startsWith(BUSY_PREFIX)) {
78        throw new JedisBusyException(message);
79      } else if (message.startsWith(NOSCRIPT_PREFIX)) {
80        throw new JedisNoScriptException(message);
81      } else if (message.startsWith(WRONGPASS_PREFIX)) {
82        throw new JedisAccessControlException(message);
83      } else if (message.startsWith(NOPERM_PREFIX)) {
84        throw new JedisAccessControlException(message);
85      }
86      throw new JedisDataException(message);
87    }
88    public static String readErrorLineIfPossible(RedisInputStream is) {
89      final byte b = is.readByte();
90      if (b != MINUS_BYTE) {
91        return null;
92      }
93      return is.readLine();
94    }
95    private static String[] parseTargetHostAndSlot(String clusterRedirectResponse) {
96      String[] response = new String[2];
97      String[] messageInfo = clusterRedirectResponse.split(" ");
98      response[0] = messageInfo[1];
99      response[1] = messageInfo[2];
100      return response;
101    }
102    private static Object process(final RedisInputStream is) {
103      final byte b = is.readByte();
104      int num;
105      switch (b) {
106        case PLUS_BYTE:
107          return is.readLineBytes();
108        case DOLLAR_BYTE:
109        case EQUAL_BYTE:
110          return processBulkReply(is);
111        case ASTERISK_BYTE:
112          num = is.readIntCrLf();
113          if (num == -1) return null;
114          return processMultiBulkReply(num, is);
115        case UNDERSCORE_BYTE:
116          return is.readNullCrLf();
117        case HASH_BYTE:
118          return is.readBooleanCrLf();
119        case COLON_BYTE:
120          return is.readLongCrLf();
121        case COMMA_BYTE:
122          return is.readDoubleCrLf();
123        case LEFT_BRACE_BYTE:
124          return is.readBigIntegerCrLf();
125        case PERCENT_BYTE: 
126          num = is.readIntCrLf();
127          if (num == -1) return null;
128          return processMultiBulkReply(2 * num, is);
129        case TILDE_BYTE: 
130          num = is.readIntCrLf();
131          if (num == -1) return null;
132          return processMultiBulkReply(num, is);
133        case GREATER_THAN_BYTE:
134          num = is.readIntCrLf();
135          if (num == -1) return null;
136          return processMultiBulkReply(num, is);
137        case MINUS_BYTE:
138          processError(is);
139          return null;
140        default:
141          throw new JedisConnectionException("Unknown reply: " + (char) b);
142      }
143    }
144    private static byte[] processBulkReply(final RedisInputStream is) {
145      final int len = is.readIntCrLf();
146      if (len == -1) {
147        return null;
148      }
149      final byte[] read = new byte[len];
150      int offset = 0;
151      while (offset < len) {
152        final int size = is.read(read, offset, (len - offset));
153        if (size == -1) {
154          throw new JedisConnectionException("It seems like server has closed the connection.");
155        }
156        offset += size;
157      }
158      is.readByte();
159      is.readByte();
160      return read;
161    }
162    private static List<Object> processMultiBulkReply(final int num, final RedisInputStream is) {
163      final List<Object> ret = new ArrayList<>(num);
164      for (int i = 0; i < num; i++) {
165        try {
166          ret.add(process(is));
167        } catch (JedisDataException e) {
168          ret.add(e);
169        }
170      }
171      return ret;
172    }
173    public static Object read(final RedisInputStream is) {
174      return process(is);
175    }
176    public static final byte[] toByteArray(final boolean value) {
177      return value ? BYTES_TRUE : BYTES_FALSE;
178    }
179    public static final byte[] toByteArray(final int value) {
180      return SafeEncoder.encode(String.valueOf(value));
181    }
182    public static final byte[] toByteArray(final long value) {
183      return SafeEncoder.encode(String.valueOf(value));
184    }
185    public static final byte[] toByteArray(final double value) {
186      if (value == Double.POSITIVE_INFINITY) {
187        return POSITIVE_INFINITY_BYTES;
188      } else if (value == Double.NEGATIVE_INFINITY) {
189        return NEGATIVE_INFINITY_BYTES;
190      } else {
191        return SafeEncoder.encode(String.valueOf(value));
192      }
193    }
194    public static enum Command implements ProtocolCommand {
195      PING, AUTH, HELLO, SET, GET, GETDEL, GETEX, EXISTS, DEL, UNLINK, TYPE, FLUSHDB, FLUSHALL, MOVE,
196      KEYS, RANDOMKEY, RENAME, RENAMENX, DUMP, RESTORE, DBSIZE, SELECT, SWAPDB, MIGRATE, ECHO, 
197      EXPIRE, EXPIREAT, EXPIRETIME, PEXPIRE, PEXPIREAT, PEXPIRETIME, TTL, PTTL, 
198      MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, SORT_RO, INFO, SHUTDOWN, MONITOR, CONFIG, LCS, 
199      GETSET, MGET, SETNX, SETEX, PSETEX, MSET, MSETNX, DECR, DECRBY, INCR, INCRBY, INCRBYFLOAT,
200      STRLEN, APPEND, SUBSTR, 
201      SETBIT, GETBIT, BITPOS, SETRANGE, GETRANGE, BITCOUNT, BITOP, BITFIELD, BITFIELD_RO, 
202      HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, HSTRLEN,
203      HRANDFIELD, HINCRBYFLOAT, 
204      RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, BLPOP, BRPOP, LINSERT, LPOS,
205      RPOPLPUSH, BRPOPLPUSH, BLMOVE, LMOVE, LMPOP, BLMPOP, LPUSHX, RPUSHX, 
206      SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SRANDMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE,
207      SDIFF, SDIFFSTORE, SISMEMBER, SMISMEMBER, SINTERCARD, 
208      ZADD, ZDIFF, ZDIFFSTORE, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZRANDMEMBER, ZCARD,
209      ZSCORE, ZPOPMAX, ZPOPMIN, ZCOUNT, ZUNION, ZUNIONSTORE, ZINTER, ZINTERSTORE, ZRANGEBYSCORE,
210      ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZLEXCOUNT, ZRANGEBYLEX, ZREVRANGEBYLEX,
211      ZREMRANGEBYLEX, ZMSCORE, ZRANGESTORE, ZINTERCARD, ZMPOP, BZMPOP, BZPOPMIN, BZPOPMAX, 
212      GEOADD, GEODIST, GEOHASH, GEOPOS, GEORADIUS, GEORADIUS_RO, GEOSEARCH, GEOSEARCHSTORE,
213      GEORADIUSBYMEMBER, GEORADIUSBYMEMBER_RO, 
214      PFADD, PFCOUNT, PFMERGE, 
215      XADD, XLEN, XDEL, XTRIM, XRANGE, XREVRANGE, XREAD, XACK, XGROUP, XREADGROUP, XPENDING, XCLAIM,
216      XAUTOCLAIM, XINFO, 
217      EVAL, EVALSHA, SCRIPT, EVAL_RO, EVALSHA_RO, FUNCTION, FCALL, FCALL_RO, 
218      SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,
219      SSUBSCRIBE, SUNSUBSCRIBE, SPUBLISH, 
220      SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, PERSIST, ROLE, FAILOVER, SLOWLOG, OBJECT, CLIENT, TIME,
221      SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING, READONLY, READWRITE, SLAVEOF, REPLICAOF, COPY,
222      SENTINEL, MODULE, ACL, TOUCH, MEMORY, LOLWUT, COMMAND, LATENCY, WAITAOF;
223      private final byte[] raw;
224      private Command() {
225        raw = SafeEncoder.encode(name());
226      }
227      @Override
228      public byte[] getRaw() {
229        return raw;
230      }
231    }
232    public static enum Keyword implements Rawable {
233      AGGREGATE, ALPHA, BY, GET, LIMIT, NO, NOSORT, ONE, SET, STORE, WEIGHTS, WITHSCORE, WITHSCORES,
234      RESETSTAT, REWRITE, RESET, FLUSH, EXISTS, LOAD, LEN, HELP, SCHEDULE, MATCH, COUNT, TYPE, KEYS,
235      REFCOUNT, ENCODING, IDLETIME, FREQ, REPLACE, GETNAME, SETNAME, SETINFO, LIST, ID, KILL, PERSIST,
236      STREAMS, CREATE, MKSTREAM, SETID, DESTROY, DELCONSUMER, MAXLEN, GROUP, IDLE, TIME, BLOCK, NOACK,
237      RETRYCOUNT, STREAM, GROUPS, CONSUMERS, JUSTID, WITHVALUES, NOMKSTREAM, MINID, CREATECONSUMER,
238      SETUSER, GETUSER, DELUSER, WHOAMI, USERS, CAT, GENPASS, LOG, SAVE, DRYRUN, COPY, AUTH, AUTH2,
239      NX, XX, EX, PX, EXAT, PXAT, ABSTTL, KEEPTTL, INCR, LT, GT, CH, INFO, PAUSE, UNPAUSE, UNBLOCK,
240      REV, WITHCOORD, WITHDIST, WITHHASH, ANY, FROMMEMBER, FROMLONLAT, BYRADIUS, BYBOX, BYLEX, BYSCORE,
241      STOREDIST, TO, FORCE, TIMEOUT, DB, UNLOAD, ABORT, IDX, MINMATCHLEN, WITHMATCHLEN, FULL,
242      DELETE, LIBRARYNAME, WITHCODE, DESCRIPTION, GETKEYS, GETKEYSANDFLAGS, DOCS, FILTERBY, DUMP,
243      MODULE, ACLCAT, PATTERN, DOCTOR, USAGE, SAMPLES, PURGE, STATS, LOADEX, CONFIG, ARGS, RANK,
244      NOW, VERSION, ADDR, SKIPME, USER, LADDR,
245      CHANNELS, NUMPAT, NUMSUB, SHARDCHANNELS, SHARDNUMSUB;
246      private final byte[] raw;
247      private Keyword() {
248        raw = SafeEncoder.encode(name());
249      }
250      @Override
251      public byte[] getRaw() {
252        return raw;
253      }
254    }
255    public static enum SentinelKeyword implements Rawable {
256      MYID, MASTERS, MASTER, SENTINELS, SLAVES, REPLICAS, RESET, FAILOVER, REMOVE, SET, MONITOR,
257      GET_MASTER_ADDR_BY_NAME("GET-MASTER-ADDR-BY-NAME");
258      private final byte[] raw;
259      private SentinelKeyword() {
260        raw = SafeEncoder.encode(name());
261      }
262      private SentinelKeyword(String str) {
263        raw = SafeEncoder.encode(str);
264      }
265      @Override
266      public byte[] getRaw() {
267        return raw;
268      }
269    }
270    public static enum ResponseKeyword implements Rawable {
271      SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE, MESSAGE, PMESSAGE, PONG,
272      SSUBSCRIBE, SUNSUBSCRIBE, SMESSAGE;
273      private final byte[] raw;
274      private ResponseKeyword() {
275        raw = SafeEncoder.encode(name().toLowerCase(Locale.ENGLISH));
276      }
277      @Override
278      public byte[] getRaw() {
279        return raw;
280      }
281    }
282    public static enum ClusterKeyword implements Rawable {
283      MEET, RESET, INFO, FAILOVER, SLOTS, NODES, REPLICAS, SLAVES, MYID, ADDSLOTS, DELSLOTS,
284      GETKEYSINSLOT, SETSLOT, NODE, MIGRATING, IMPORTING, STABLE, FORGET, FLUSHSLOTS, KEYSLOT,
285      COUNTKEYSINSLOT, SAVECONFIG, REPLICATE, LINKS, ADDSLOTSRANGE, DELSLOTSRANGE, BUMPEPOCH,
286      MYSHARDID;
287      private final byte[] raw;
288      private ClusterKeyword() {
289        raw = SafeEncoder.encode(name());
290      }
291      @Override
292      public byte[] getRaw() {
293        return raw;
294      }
295    }
296  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyExampleTest.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-Protocol.java</div>
                <div class="column column_space"><pre><code>1  package com.weibo.api.motan.transport.netty;
2  import junit.framework.TestCase;
3  import org.junit.Assert;
4  import org.junit.Before;
5  import org.junit.Test;
6  import com.weibo.api.motan.codec.Codec;
7  import com.weibo.api.motan.common.URLParamType;
8  import com.weibo.api.motan.core.extension.ExtensionLoader;
9  import com.weibo.api.motan.rpc.DefaultRequest;
10  import com.weibo.api.motan.rpc.DefaultResponse;
11  import com.weibo.api.motan.rpc.Request;
12  import com.weibo.api.motan.rpc.URL;
13  import com.weibo.api.motan.transport.Channel;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package redis.clients.jedis;
2  import java.io.IOException;
3  import java.nio.charset.Charset;
4  import java.nio.charset.StandardCharsets;
5  import java.util.ArrayList;
6  import java.util.List;
7  import java.util.Locale;
8  import redis.clients.jedis.exceptions.*;
9  import redis.clients.jedis.args.Rawable;
10  import redis.clients.jedis.commands.ProtocolCommand;
11  import redis.clients.jedis.util.RedisInputStream;
12  import redis.clients.jedis.util.RedisOutputStream;
13  import redis.clients.jedis.util.SafeEncoder;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    