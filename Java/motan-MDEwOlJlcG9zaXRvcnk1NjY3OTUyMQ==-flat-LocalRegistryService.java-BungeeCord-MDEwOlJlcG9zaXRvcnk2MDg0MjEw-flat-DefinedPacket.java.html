
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.00900900900901%, Tokens: 10</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-LocalRegistryService.java</h3>
            <pre><code>1  package com.weibo.api.motan.registry.support;
2  import java.util.ArrayList;
3  import java.util.HashMap;
4  import java.util.List;
5  import java.util.Map;
6  import java.util.concurrent.ConcurrentHashMap;
7  import java.util.concurrent.ConcurrentMap;
8  import org.apache.commons.lang3.ObjectUtils;
9  import com.weibo.api.motan.common.MotanConstants;
10  import com.weibo.api.motan.common.URLParamType;
11  import com.weibo.api.motan.core.extension.SpiMeta;
12  import com.weibo.api.motan.registry.NotifyListener;
13  import com.weibo.api.motan.registry.RegistryService;
14  import com.weibo.api.motan.rpc.URL;
15  import com.weibo.api.motan.util.CollectionUtil;
16  import com.weibo.api.motan.util.ConcurrentHashSet;
17  import com.weibo.api.motan.util.LoggerUtil;
18  import com.weibo.api.motan.util.NetUtils;
19  @SpiMeta(name = "local")
20  public class LocalRegistryService extends AbstractRegistry {
21      private ConcurrentMap<String, List<URL>> registeredServices = new ConcurrentHashMap<String, List<URL>>();
22      private ConcurrentHashMap<String, ConcurrentHashMap<URL, ConcurrentHashSet<NotifyListener>>> subscribeListeners =
23              new ConcurrentHashMap<String, ConcurrentHashMap<URL, ConcurrentHashSet<NotifyListener>>>();
24      private URL registryUrl;
25      public LocalRegistryService() {
26          this(new URL(MotanConstants.REGISTRY_PROTOCOL_LOCAL, NetUtils.LOCALHOST, MotanConstants.DEFAULT_INT_VALUE,
27                  RegistryService.class.getName()));
28      }
29      public LocalRegistryService(URL url) {
30          super(url);
31          this.registryUrl = url;
32      }
33      @Override
34      public void doSubscribe(URL url, NotifyListener listener) {
35          String subscribeKey = getSubscribeKey(url);
36          ConcurrentHashMap<URL, ConcurrentHashSet<NotifyListener>> urlListeners = subscribeListeners.get(subscribeKey);
37          if (urlListeners == null) {
38              subscribeListeners.putIfAbsent(subscribeKey, new ConcurrentHashMap<URL, ConcurrentHashSet<NotifyListener>>());
39              urlListeners = subscribeListeners.get(subscribeKey);
40          }
41          ConcurrentHashSet<NotifyListener> listeners = urlListeners.get(url);
42          if (listeners == null) {
43              urlListeners.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());
44              listeners = urlListeners.get(url);
45          }
46          listeners.add(listener);
47          List<URL> urls = discover(url);
48          if (urls != null && urls.size() > 0) {
49              listener.notify(getUrl(), urls);
50          }
51          LoggerUtil.info("LocalRegistryService subscribe: url={}", url);
52      }
53      @Override
54      public void doUnsubscribe(URL url, NotifyListener listener) {
55          String subscribeKey = getSubscribeKey(url);
56          ConcurrentHashMap<URL, ConcurrentHashSet<NotifyListener>> urlListeners = subscribeListeners.get(subscribeKey);
57          if (urlListeners != null) {
58              urlListeners.remove(url);
59          }
60          LoggerUtil.info("LocalRegistryService unsubscribe: url={}", url);
61      }
62      @Override
63      public List<URL> doDiscover(URL url) {
64          return registeredServices.get(getRegistryKey(url));
65      }
66      @Override
67      protected void doAvailable(URL url) {
68      }
69      @Override
70      protected void doUnavailable(URL url) {
71      }
72      @Override
73      public void doRegister(URL url) {
74          String registryKey = getRegistryKey(url);
75          synchronized (registeredServices) {
76              List<URL> urls = registeredServices.get(registryKey);
77              if (urls == null) {
78                  registeredServices.putIfAbsent(registryKey, new ArrayList<URL>());
79                  urls = registeredServices.get(registryKey);
80              }
81              add(url, urls);
82              LoggerUtil.info("LocalRegistryService register: url={}", url);
83              notifyListeners(url);
84          }
85      }
86      @Override
87      public void doUnregister(URL url) {
88          synchronized (registeredServices) {
89              List<URL> urls = registeredServices.get(getRegistryKey(url));
90              if (urls == null) {
91                  return;
92              }
93              remove(url, urls);
94              LoggerUtil.info("LocalRegistryService unregister: url={}", url);
95              notifyListeners(url);
96          }
97      }
98      @Override
99      public URL getUrl() {
100          return registryUrl;
101      }
102      public Map<String, List<URL>> getAllUrl() {
103          Map<String, List<URL>> copyMap = new HashMap<String, List<URL>>(registeredServices.size());
104          for (Map.Entry<String, List<URL>> entry : registeredServices.entrySet()) {
105              String key = entry.getKey();
106              List<URL> copyList = new ArrayList<URL>(entry.getValue().size());
107              for (URL url : entry.getValue()) {
108                  copyList.add(url.createCopy());
109              }
110              copyMap.put(key, copyList);
111          }
112          return copyMap;
113      }
114      private void remove(URL url, List<URL> urls) {
115          if (CollectionUtil.isEmpty(urls)) {
116              return;
117          }
118          removeCachedUrlByIdentity(url, urls);
119      }
120      private void add(URL url, List<URL> urls) {
<span onclick='openModal()' class='match'>121          removeCachedUrlByIdentity(url, urls);
122          urls.add(url);
123      }
124      private void removeCachedUrlByIdentity(URL url, List<URL> urls) {
125          if (CollectionUtil.isEmpty(urls)) {
126              return;
127          }
</span>128          URL oldUrl = null;
129          for (URL cachedUrl : urls) {
130              if (ObjectUtils.equals(url, cachedUrl)) {
131                  oldUrl = cachedUrl;
132                  break;
133              }
134          }
135          if (oldUrl != null) {
136              urls.remove(oldUrl);
137          }
138      }
139      private void notifyListeners(URL changedUrl) {
140          List<URL> interestingUrls = discover(changedUrl);
141          if (interestingUrls != null) {
142              ConcurrentHashMap<URL, ConcurrentHashSet<NotifyListener>> urlListeners = subscribeListeners.get(getSubscribeKey(changedUrl));
143              if (urlListeners == null) {
144                  return;
145              }
146              for (ConcurrentHashSet<NotifyListener> listeners : urlListeners.values()) {
147                  for (NotifyListener ln : listeners) {
148                      try {
149                          ln.notify(getUrl(), interestingUrls);
150                      } catch (Exception e) {
151                          LoggerUtil.warn(String.format("Exception when notify listerner %s, changedUrl: %s", ln, changedUrl), e);
152                      }
153                  }
154              }
155          }
156      }
157      private String getRegistryKey(URL url) {
158          String keyPrefix = url.getPath();
159          String nodeType = url.getParameter(URLParamType.nodeType.getName());
160          if (nodeType != null) {
161              return keyPrefix + MotanConstants.PATH_SEPARATOR + nodeType;
162          } else {
163              LoggerUtil.warn("Url need a nodeType as param in localRegistry, url={}", url);
164              return keyPrefix;
165          }
166      }
167      private String getSubscribeKey(URL url) {
168          return getRegistryKey(url);
169      }
170  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DefinedPacket.java</h3>
            <pre><code>1  package net.md_5.bungee.protocol;
2  import com.google.common.base.Charsets;
3  import com.google.common.base.Preconditions;
4  import io.netty.buffer.ByteBuf;
5  import io.netty.buffer.ByteBufInputStream;
6  import io.netty.buffer.ByteBufOutputStream;
7  import java.io.DataInputStream;
8  import java.io.DataOutputStream;
9  import java.io.IOException;
10  import java.util.ArrayList;
11  import java.util.Arrays;
12  import java.util.BitSet;
13  import java.util.EnumSet;
14  import java.util.List;
15  import java.util.UUID;
16  import lombok.RequiredArgsConstructor;
17  import se.llbit.nbt.NamedTag;
18  import se.llbit.nbt.Tag;
19  @RequiredArgsConstructor
20  public abstract class DefinedPacket
21  {
22      public static void writeString(String s, ByteBuf buf)
23      {
24          writeString( s, buf, Short.MAX_VALUE );
25      }
26      public static void writeString(String s, ByteBuf buf, int maxLength)
27      {
28          if ( s.length() > maxLength )
29          {
30              throw new OverflowPacketException( "Cannot send string longer than " + maxLength + " (got " + s.length() + " characters)" );
31          }
32          byte[] b = s.getBytes( Charsets.UTF_8 );
33          if ( b.length > maxLength * 3 )
34          {
35              throw new OverflowPacketException( "Cannot send string longer than " + ( maxLength * 3 ) + " (got " + b.length + " bytes)" );
36          }
37          writeVarInt( b.length, buf );
38          buf.writeBytes( b );
39      }
40      public static String readString(ByteBuf buf)
41      {
42          return readString( buf, Short.MAX_VALUE );
43      }
44      public static String readString(ByteBuf buf, int maxLen)
45      {
46          int len = readVarInt( buf );
47          if ( len > maxLen * 3 )
48          {
49              throw new OverflowPacketException( "Cannot receive string longer than " + maxLen * 3 + " (got " + len + " bytes)" );
50          }
51          String s = buf.toString( buf.readerIndex(), len, Charsets.UTF_8 );
52          buf.readerIndex( buf.readerIndex() + len );
53          if ( s.length() > maxLen )
54          {
55              throw new OverflowPacketException( "Cannot receive string longer than " + maxLen + " (got " + s.length() + " characters)" );
56          }
57          return s;
58      }
59      public static void writeArray(byte[] b, ByteBuf buf)
60      {
61          if ( b.length > Short.MAX_VALUE )
62          {
63              throw new OverflowPacketException( "Cannot send byte array longer than Short.MAX_VALUE (got " + b.length + " bytes)" );
64          }
65          writeVarInt( b.length, buf );
66          buf.writeBytes( b );
67      }
68      public static byte[] toArray(ByteBuf buf)
69      {
70          byte[] ret = new byte[ buf.readableBytes() ];
71          buf.readBytes( ret );
72          return ret;
73      }
74      public static byte[] readArray(ByteBuf buf)
75      {
76          return readArray( buf, buf.readableBytes() );
77      }
78      public static byte[] readArray(ByteBuf buf, int limit)
79      {
80          int len = readVarInt( buf );
81          if ( len > limit )
82          {
83              throw new OverflowPacketException( "Cannot receive byte array longer than " + limit + " (got " + len + " bytes)" );
84          }
85          byte[] ret = new byte[ len ];
86          buf.readBytes( ret );
87          return ret;
88      }
89      public static int[] readVarIntArray(ByteBuf buf)
90      {
91          int len = readVarInt( buf );
92          int[] ret = new int[ len ];
93          for ( int i = 0; i < len; i++ )
94          {
95              ret[i] = readVarInt( buf );
96          }
97          return ret;
98      }
99      public static void writeStringArray(List<String> s, ByteBuf buf)
100      {
101          writeVarInt( s.size(), buf );
102          for ( String str : s )
103          {
104              writeString( str, buf );
105          }
106      }
107      public static List<String> readStringArray(ByteBuf buf)
108      {
109          int len = readVarInt( buf );
110          List<String> ret = new ArrayList<>( len );
111          for ( int i = 0; i < len; i++ )
112          {
113              ret.add( readString( buf ) );
114          }
115          return ret;
116      }
117      public static int readVarInt(ByteBuf input)
118      {
119          return readVarInt( input, 5 );
120      }
121      public static int readVarInt(ByteBuf input, int maxBytes)
122      {
123          int out = 0;
124          int bytes = 0;
125          byte in;
126          while ( true )
127          {
128              in = input.readByte();
129              out |= ( in & 0x7F ) << ( bytes++ * 7 );
130              if ( bytes > maxBytes )
131              {
132                  throw new RuntimeException( "VarInt too big" );
133              }
134              if ( ( in & 0x80 ) != 0x80 )
135              {
136                  break;
137              }
138          }
139          return out;
140      }
141      public static void writeVarInt(int value, ByteBuf output)
142      {
143          int part;
144          while ( true )
145          {
146              part = value & 0x7F;
147              value >>>= 7;
148              if ( value != 0 )
149              {
150                  part |= 0x80;
151              }
152              output.writeByte( part );
153              if ( value == 0 )
154              {
155                  break;
156              }
157          }
158      }
159      public static int readVarShort(ByteBuf buf)
160      {
161          int low = buf.readUnsignedShort();
162          int high = 0;
163          if ( ( low & 0x8000 ) != 0 )
164          {
165              low = low & 0x7FFF;
166              high = buf.readUnsignedByte();
167          }
168          return ( ( high & 0xFF ) << 15 ) | low;
169      }
170      public static void writeVarShort(ByteBuf buf, int toWrite)
171      {
172          int low = toWrite & 0x7FFF;
173          int high = ( toWrite & 0x7F8000 ) >> 15;
174          if ( high != 0 )
175          {
176              low = low | 0x8000;
177          }
178          buf.writeShort( low );
179          if ( high != 0 )
180          {
181              buf.writeByte( high );
182          }
183      }
184      public static void writeUUID(UUID value, ByteBuf output)
185      {
186          output.writeLong( value.getMostSignificantBits() );
187          output.writeLong( value.getLeastSignificantBits() );
188      }
189      public static UUID readUUID(ByteBuf input)
190      {
<span onclick='openModal()' class='match'>191          return new UUID( input.readLong(), input.readLong() );
192      }
193      public static void writeProperties(Property[] properties, ByteBuf buf)
194      {
195          if ( properties == null )
196          {
197              writeVarInt( 0, buf );
198              return;
199          }
</span>200          writeVarInt( properties.length, buf );
201          for ( Property prop : properties )
202          {
203              writeString( prop.getName(), buf );
204              writeString( prop.getValue(), buf );
205              if ( prop.getSignature() != null )
206              {
207                  buf.writeBoolean( true );
208                  writeString( prop.getSignature(), buf );
209              } else
210              {
211                  buf.writeBoolean( false );
212              }
213          }
214      }
215      public static Property[] readProperties(ByteBuf buf)
216      {
217          Property[] properties = new Property[ DefinedPacket.readVarInt( buf ) ];
218          for ( int j = 0; j < properties.length; j++ )
219          {
220              String name = readString( buf );
221              String value = readString( buf );
222              if ( buf.readBoolean() )
223              {
224                  properties[j] = new Property( name, value, DefinedPacket.readString( buf ) );
225              } else
226              {
227                  properties[j] = new Property( name, value );
228              }
229          }
230          return properties;
231      }
232      public static void writePublicKey(PlayerPublicKey publicKey, ByteBuf buf)
233      {
234          if ( publicKey != null )
235          {
236              buf.writeBoolean( true );
237              buf.writeLong( publicKey.getExpiry() );
238              writeArray( publicKey.getKey(), buf );
239              writeArray( publicKey.getSignature(), buf );
240          } else
241          {
242              buf.writeBoolean( false );
243          }
244      }
245      public static PlayerPublicKey readPublicKey(ByteBuf buf)
246      {
247          if ( buf.readBoolean() )
248          {
249              return new PlayerPublicKey( buf.readLong(), readArray( buf, 512 ), readArray( buf, 4096 ) );
250          }
251          return null;
252      }
253      public static Tag readTag(ByteBuf input)
254      {
255          Tag tag = NamedTag.read( new DataInputStream( new ByteBufInputStream( input ) ) );
256          Preconditions.checkArgument( !tag.isError(), "Error reading tag: %s", tag.error() );
257          return tag;
258      }
259      public static void writeTag(Tag tag, ByteBuf output)
260      {
261          try
262          {
263              tag.write( new DataOutputStream( new ByteBufOutputStream( output ) ) );
264          } catch ( IOException ex )
265          {
266              throw new RuntimeException( "Exception writing tag", ex );
267          }
268      }
269      public static <E extends Enum<E>> void writeEnumSet(EnumSet<E> enumset, Class<E> oclass, ByteBuf buf)
270      {
271          E[] enums = oclass.getEnumConstants();
272          BitSet bits = new BitSet( enums.length );
273          for ( int i = 0; i < enums.length; ++i )
274          {
275              bits.set( i, enumset.contains( enums[i] ) );
276          }
277          writeFixedBitSet( bits, enums.length, buf );
278      }
279      public static <E extends Enum<E>> EnumSet<E> readEnumSet(Class<E> oclass, ByteBuf buf)
280      {
281          E[] enums = oclass.getEnumConstants();
282          BitSet bits = readFixedBitSet( enums.length, buf );
283          EnumSet<E> set = EnumSet.noneOf( oclass );
284          for ( int i = 0; i < enums.length; ++i )
285          {
286              if ( bits.get( i ) )
287              {
288                  set.add( enums[i] );
289              }
290          }
291          return set;
292      }
293      public static BitSet readFixedBitSet(int i, ByteBuf buf)
294      {
295          byte[] bits = new byte[ ( i + 8 ) >> 3 ];
296          buf.readBytes( bits );
297          return BitSet.valueOf( bits );
298      }
299      public static void writeFixedBitSet(BitSet bits, int size, ByteBuf buf)
300      {
301          if ( bits.length() > size )
302          {
303              throw new OverflowPacketException( "BitSet too large (expected " + size + " got " + bits.size() + ")" );
304          }
305          buf.writeBytes( Arrays.copyOf( bits.toByteArray(), ( size + 8 ) >> 3 ) );
306      }
307      public void read(ByteBuf buf)
308      {
309          throw new UnsupportedOperationException( "Packet must implement read method" );
310      }
311      public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
312      {
313          read( buf );
314      }
315      public void write(ByteBuf buf)
316      {
317          throw new UnsupportedOperationException( "Packet must implement write method" );
318      }
319      public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
320      {
321          write( buf );
322      }
323      public abstract void handle(AbstractPacketHandler handler) throws Exception;
324      @Override
325      public abstract boolean equals(Object obj);
326      @Override
327      public abstract int hashCode();
328      @Override
329      public abstract String toString();
330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-LocalRegistryService.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DefinedPacket.java</div>
                </div>
                <div class="column column_space"><pre><code>121          removeCachedUrlByIdentity(url, urls);
122          urls.add(url);
123      }
124      private void removeCachedUrlByIdentity(URL url, List<URL> urls) {
125          if (CollectionUtil.isEmpty(urls)) {
126              return;
127          }
</pre></code></div>
                <div class="column column_space"><pre><code>191          return new UUID( input.readLong(), input.readLong() );
192      }
193      public static void writeProperties(Property[] properties, ByteBuf buf)
194      {
195          if ( properties == null )
196          {
197              writeVarInt( 0, buf );
198              return;
199          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    