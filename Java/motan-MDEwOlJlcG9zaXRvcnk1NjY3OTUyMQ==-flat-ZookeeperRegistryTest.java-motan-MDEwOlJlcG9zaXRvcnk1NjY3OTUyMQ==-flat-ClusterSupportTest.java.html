
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.313642756680731%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ZookeeperRegistryTest.java</h3>
            <pre><code>1  package com.weibo.api.motan.registry.zookeeper;
2  import com.weibo.api.motan.common.MotanConstants;
3  import com.weibo.api.motan.registry.support.command.CommandListener;
4  import com.weibo.api.motan.registry.support.command.ServiceListener;
5  import com.weibo.api.motan.rpc.URL;
6  import junit.framework.Assert;
7  import org.I0Itec.zkclient.ZkClient;
8  import org.junit.After;
9  import org.junit.BeforeClass;
10  import org.junit.Test;
11  import java.io.InputStream;
12  import java.util.List;
13  import java.util.Properties;
14  public class ZookeeperRegistryTest {
15      private static ZookeeperRegistry registry;
16      private static URL serviceUrl, clientUrl;
17      private static EmbeddedZookeeper zookeeper;
18      private static ZkClient zkClient;
19      private static String service = "com.weibo.motan.demoService";
20      @BeforeClass
21      public static void setUp() throws Exception {
22          Properties properties = new Properties();
23          InputStream in = EmbeddedZookeeper.class.getResourceAsStream("/zoo.cfg");
24          properties.load(in);
25          int port = Integer.parseInt(properties.getProperty("clientPort"));
26          in.close();
27          URL zkUrl = new URL(MotanConstants.REGISTRY_PROTOCOL_ZOOKEEPER, "127.0.0.1", port, "com.weibo.api.motan.registry.RegistryService");
28          clientUrl = new URL(MotanConstants.PROTOCOL_MOTAN, "127.0.0.1", 0, service);
29          clientUrl.addParameter("group", "aaa");
30          serviceUrl = new URL(MotanConstants.PROTOCOL_MOTAN, "127.0.0.1", 8001, service);
31          serviceUrl.addParameter("group", "aaa");
32          zookeeper = new EmbeddedZookeeper();
33          zookeeper.start();
34          Thread.sleep(1000);
35          zkClient = new ZkClient("127.0.0.1:" + port, 5000);
36          registry = new ZookeeperRegistry(zkUrl, zkClient);
37      }
38      @After
39      public void tearDown() {
40          zkClient.deleteRecursive(MotanConstants.ZOOKEEPER_REGISTRY_NAMESPACE);
41      }
42      @Test
43      public void subAndUnsubService() throws Exception {
44          ServiceListener serviceListener = new ServiceListener() {
45              @Override
46              public void notifyService(URL refUrl, URL registryUrl, List<URL> urls) {
47                  if (!urls.isEmpty()) {
48                      Assert.assertTrue(urls.contains(serviceUrl));
49                  }
50              }
51          };
<span onclick='openModal()' class='match'>52          registry.subscribeService(clientUrl, serviceListener);
53          Assert.assertTrue(containsServiceListener(clientUrl, serviceListener));
54          registry.doRegister(serviceUrl);
55          registry.doAvailable(serviceUrl);
56          Thread.sleep(2000);
57          registry.unsubscribeService(clientUrl, serviceListener);
58          Assert.assertFalse(containsServiceListener(clientUrl, serviceListener));
59      }
60      private boolean containsServiceListener(URL clientUrl, ServiceListener serviceListener) {
</span>61          return registry.getServiceListeners().get(clientUrl).containsKey(serviceListener);
62      }
63      @Test
64      public void subAndUnsubCommand() throws Exception {
65          final String command = "{\"index\":0,\"mergeGroups\":[\"aaa:1\",\"bbb:1\"],\"pattern\":\"*\",\"routeRules\":[]}\n";
66          CommandListener commandListener = new CommandListener() {
67              @Override
68              public void notifyCommand(URL refUrl, String commandString) {
69                  if (commandString != null) {
70                      Assert.assertTrue(commandString.equals(command));
71                  }
72              }
73          };
74          registry.subscribeCommand(clientUrl, commandListener);
75          Assert.assertTrue(containsCommandListener(clientUrl, commandListener));
76          String commandPath = ZkUtils.toCommandPath(clientUrl);
77          if (!zkClient.exists(commandPath)) {
78              zkClient.createPersistent(commandPath, true);
79          }
80          zkClient.writeData(commandPath, command);
81          Thread.sleep(2000);
82          zkClient.delete(commandPath);
83          registry.unsubscribeCommand(clientUrl, commandListener);
84          Assert.assertFalse(containsCommandListener(clientUrl, commandListener));
85      }
86      private boolean containsCommandListener(URL clientUrl, CommandListener commandListener) {
87          return registry.getCommandListeners().get(clientUrl).containsKey(commandListener);
88      }
89      @Test
90      public void discoverService() throws Exception {
91          registry.doRegister(serviceUrl);
92          List<URL> results = registry.discoverService(clientUrl);
93          Assert.assertTrue(results.isEmpty());
94          registry.doAvailable(serviceUrl);
95          results = registry.discoverService(clientUrl);
96          Assert.assertTrue(results.contains(serviceUrl));
97      }
98      @Test
99      public void discoverCommand() throws Exception {
100          String result = registry.discoverCommand(clientUrl);
101          Assert.assertTrue(result.equals(""));
102          String command = "{\"index\":0,\"mergeGroups\":[\"aaa:1\",\"bbb:1\"],\"pattern\":\"*\",\"routeRules\":[]}\n";
103          String commandPath = ZkUtils.toCommandPath(clientUrl);
104          if (!zkClient.exists(commandPath)) {
105              zkClient.createPersistent(commandPath, true);
106          }
107          zkClient.writeData(commandPath, command);
108          result = registry.discoverCommand(clientUrl);
109          Assert.assertTrue(result.equals(command));
110      }
111      @Test
112      public void doRegisterAndAvailable() throws Exception {
113          String node = serviceUrl.getServerPortStr();
114          List<String> available, unavailable;
115          String unavailablePath = ZkUtils.toNodeTypePath(serviceUrl, ZkNodeType.UNAVAILABLE_SERVER);
116          String availablePath = ZkUtils.toNodeTypePath(serviceUrl, ZkNodeType.AVAILABLE_SERVER);
117          registry.doRegister(serviceUrl);
118          unavailable = zkClient.getChildren(unavailablePath);
119          Assert.assertTrue(unavailable.contains(node));
120          registry.doAvailable(serviceUrl);
121          unavailable = zkClient.getChildren(unavailablePath);
122          Assert.assertFalse(unavailable.contains(node));
123          available = zkClient.getChildren(availablePath);
124          Assert.assertTrue(available.contains(node));
125          registry.doUnavailable(serviceUrl);
126          unavailable = zkClient.getChildren(unavailablePath);
127          Assert.assertTrue(unavailable.contains(node));
128          available = zkClient.getChildren(availablePath);
129          Assert.assertFalse(available.contains(node));
130          registry.doUnregister(serviceUrl);
131          unavailable = zkClient.getChildren(unavailablePath);
132          Assert.assertFalse(unavailable.contains(node));
133          available = zkClient.getChildren(availablePath);
134          Assert.assertFalse(available.contains(node));
135      }
136  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ClusterSupportTest.java</h3>
            <pre><code>1  package com.weibo.api.motan.cluster;
2  import com.weibo.api.motan.cluster.support.ClusterSupport;
3  import com.weibo.api.motan.common.MotanConstants;
4  import com.weibo.api.motan.common.URLParamType;
5  import com.weibo.api.motan.protocol.example.IHello;
6  import com.weibo.api.motan.registry.NotifyListener;
7  import com.weibo.api.motan.registry.Registry;
8  import com.weibo.api.motan.registry.RegistryService;
9  import com.weibo.api.motan.rpc.Protocol;
10  import com.weibo.api.motan.rpc.Referer;
11  import com.weibo.api.motan.rpc.URL;
12  import com.weibo.api.motan.util.MotanSwitcherUtil;
13  import com.weibo.api.motan.util.NetUtils;
14  import junit.framework.Assert;
15  import org.hamcrest.Description;
16  import org.jmock.Expectations;
17  import org.jmock.api.Action;
18  import org.jmock.api.Invocation;
19  import org.jmock.integration.junit4.JUnit4Mockery;
20  import org.jmock.lib.legacy.ClassImposteriser;
21  import org.junit.Before;
22  import org.junit.Test;
23  import java.util.ArrayList;
24  import java.util.HashMap;
25  import java.util.List;
26  import java.util.Map;
27  public class ClusterSupportTest {
28      private static JUnit4Mockery mockery = new JUnit4Mockery() {
29          {
30              setImposteriser(ClassImposteriser.INSTANCE);
31          }
32      };
33      private static ClusterSupportMask<IHello> clusterSupport;
34      private static Protocol protocol = mockery.mock(Protocol.class);
35      private static Map<String, Registry> registries = new HashMap<String, Registry>();
36      private static String regProtocol1 = "reg_1";
37      private static String regProtocol2 = "reg_2";
38      private static String maxConnectionPerGroup = "40"; 
39      private static String localAddress = NetUtils.getLocalAddress().getHostAddress();
40      private static Map<String, Referer<IHello>> portReferers = new HashMap<String, Referer<IHello>>();
41      private static List<URL> serviceUrls1 = new ArrayList<URL>();
42      private static Map<String, Boolean> availableMap = new HashMap<>();
43      static {
44          registries.put(regProtocol1, mockery.mock(Registry.class, regProtocol1));
45          registries.put(regProtocol2, mockery.mock(Registry.class, regProtocol2));
46      }
47      @Before
48      public void initCluster() {
49          clusterSupport = new ClusterSupportMask<IHello>(IHello.class, mockRegistryUrls(), mockRefUrl());
50          mockery.checking(new Expectations() {
51              {
52                  allowing(any(Registry.class)).method("register").with(any(URL.class));
53                  allowing(any(Registry.class)).method("subscribe").with(any(URL.class), any(NotifyListener.class));
54              }
55          });
56          clusterSupport.init();
57          final int urlsCount = 10;
58          for (int i = 0; i < urlsCount; i++) {
59              URL url = new URL(MotanConstants.PROTOCOL_MOTAN, localAddress, 1000 + i, IHello.class.getName());
60              url.addParameter(URLParamType.nodeType.getName(), MotanConstants.NODE_TYPE_SERVICE);
61              serviceUrls1.add(url);
62          }
63          final URL reg1Url = new URL("reg_protocol_1", NetUtils.getLocalAddress().getHostAddress(), 0, RegistryService.class.getName());
64          final URL reg2Url = new URL("reg_protocol_2", NetUtils.getLocalAddress().getHostAddress(), 0, RegistryService.class.getName());
65          mockery.checking(new Expectations() {
66              {
67                  for (int i = 0; i < urlsCount; i++) {
68                      URL serviceUrl = serviceUrls1.get(i).createCopy();
69                      URL refererUrl = serviceUrls1.get(i).createCopy();
70                      String application = serviceUrl.getParameter(URLParamType.application.getName(), URLParamType.application.getValue());
71                      String module = serviceUrl.getParameter(URLParamType.module.getName(), URLParamType.module.getValue());
72                      refererUrl.addParameters(serviceUrl.getParameters());
73                      refererUrl.addParameter(URLParamType.application.getName(), application);
74                      refererUrl.addParameter(URLParamType.module.getName(), module);
75                      refererUrl.addParameter(URLParamType.check.getName(), "false");
76                      refererUrl.addParameter(URLParamType.maxConnectionPerGroup.getName(), maxConnectionPerGroup);
77                      atLeast(1).of(protocol).refer(IHello.class, refererUrl, serviceUrl);
78                      will(returnValue(mockReferer(refererUrl)));
79                      atLeast(1).of(mockReferer(refererUrl)).getUrl();
80                      will(returnValue(serviceUrls1.get(i)));
81                      atLeast(1).of(mockReferer(refererUrl)).getServiceUrl();
82                      will(returnValue(serviceUrls1.get(i)));
83                      atLeast(1).of(mockReferer(refererUrl)).isAvailable();
84                      will(new Action() {
85                          @Override
86                          public void describeTo(Description description) {
87                              description.appendText("returns ");
88                              description.appendValue(availableMap.getOrDefault(refererUrl.toString(), true));
89                          }
90                          @Override
91                          public Object invoke(Invocation invocation) throws Throwable {
92                              return availableMap.getOrDefault(refererUrl.toString(), true);
93                          }
94                      });
95                  }
96                  for (int i = 0; i < 3; i++) {
97                      atLeast(1).of(mockReferer(serviceUrls1.get(i))).destroy();
98                  }
99                  atLeast(1).of(registries.get(regProtocol1)).getUrl();
100                  will(returnValue(reg1Url));
101                  atLeast(1).of(registries.get(regProtocol2)).getUrl();
102                  will(returnValue(reg2Url));
103              }
104          });
105      }
106      @SuppressWarnings({"rawtypes", "unchecked"})
107      @Test
108      public void testNotify() {
109          MotanSwitcherUtil.setSwitcherValue("feature.motan.partial.server", false);
110          List copy = new ArrayList<URL>();
111          clusterSupport.notify(registries.get(regProtocol1).getUrl(), copy(copy, serviceUrls1.subList(0, 2)));
112          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 2);
113          clusterSupport.notify(registries.get(regProtocol1).getUrl(), copy(copy, serviceUrls1.subList(0, 3)));
114          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 3);
115          clusterSupport.notify(registries.get(regProtocol1).getUrl(), copy(copy, serviceUrls1.subList(0, 0)));
116          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 3);
117          clusterSupport.notify(registries.get(regProtocol1).getUrl(), copy(copy, serviceUrls1.subList(1, 3)));
118          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 2);
119          clusterSupport.notify(registries.get(regProtocol1).getUrl(), copy(copy, serviceUrls1.subList(0, 3)));
120          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 3);
121          clusterSupport.notify(registries.get(regProtocol2).getUrl(), copy(copy, serviceUrls1.subList(3, 5)));
122          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 5);
123          clusterSupport.notify(registries.get(regProtocol1).getUrl(), copy(copy, serviceUrls1.subList(1, 3)));
124          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 4);
125          clusterSupport.notify(registries.get(regProtocol1).getUrl(), null);
126          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 2);
127          List<Referer<IHello>> oldReferers = clusterSupport.getCluster().getReferers();
128          clusterSupport.notify(registries.get(regProtocol2).getUrl(), copy(copy, serviceUrls1.subList(3, 5)));
129          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 2);
130          for (Referer<IHello> referer : clusterSupport.getCluster().getReferers()) {
131              if (!oldReferers.contains(referer)) {
132                  Assert.fail();
133              }
134          }
135          MotanSwitcherUtil.setSwitcherValue("feature.motan.partial.server", true);
136          clusterSupport.notify(registries.get(regProtocol2).getUrl(), copy(copy, serviceUrls1.subList(0, 2)));
137          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 2);
138          clusterSupport.notify(registries.get(regProtocol2).getUrl(), copy(copy, serviceUrls1.subList(0, 5)));
139          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 4);
140          clusterSupport.notify(registries.get(regProtocol2).getUrl(), copy(copy, serviceUrls1.subList(0, 0)));
141          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 4);
<span onclick='openModal()' class='match'>142          clusterSupport.notify(registries.get(regProtocol2).getUrl(), copy(copy, serviceUrls1.subList(3, 4)));
143          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 1);
144      }
145      private static List<URL> mockRegistryUrls() {
146          URL url1 = new URL(regProtocol1, "192.168.1.1", 18081, RegistryService.class.getName());
</span>147          URL url2 = new URL(regProtocol2, "192.168.1.2", 8082, RegistryService.class.getName());
148          List<URL> urls = new ArrayList<URL>();
149          urls.add(url1);
150          urls.add(url2);
151          return urls;
152      }
153      private static URL mockRefUrl(){
154          Map<String, String> params = new HashMap<>();
155          params.put(URLParamType.maxConnectionPerGroup.getName(), maxConnectionPerGroup);
156          URL refUrl = new URL(MotanConstants.PROTOCOL_MOTAN, NetUtils.getLocalAddress().getHostAddress(), 0, IHello.class.getName(), params);
157          refUrl.addParameter(URLParamType.check.getName(), "false");
158          return refUrl;
159      }
160      @Test
161      public void testRefreshReferers(){
162          MotanSwitcherUtil.setSwitcherValue("feature.motan.partial.server", true);
163          List<URL> copy = new ArrayList<URL>();
164          clusterSupport.notify(registries.get(regProtocol1).getUrl(), copy(copy, serviceUrls1.subList(0, 2)));
165          clusterSupport.notify(registries.get(regProtocol2).getUrl(), null);
166          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 2);
167          clusterSupport.refreshReferers();
168          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 2);
169          clusterSupport.notify(registries.get(regProtocol1).getUrl(), copy(copy, serviceUrls1.subList(0, 6)));
170          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 4);
171          Assert.assertEquals(getAvailableReferersCount(),4);
172          Referer referer1 = clusterSupport.getCluster().getReferers().get(0);
173          Referer referer2 = clusterSupport.getCluster().getReferers().get(1);
174          availableMap.put(referer1.getUrl().toString(), false);
175          clusterSupport.refreshReferers();
176          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 4);
177          Assert.assertEquals(getAvailableReferersCount(),3);
178          availableMap.put(referer2.getUrl().toString(), false);
179          clusterSupport.refreshReferers();
180          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 6);
181          Assert.assertEquals(getAvailableReferersCount(),4);
182          availableMap.put(referer2.getUrl().toString(), true);
183          clusterSupport.refreshReferers();
184          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 6);
185          Assert.assertEquals(getAvailableReferersCount(),5);
186          availableMap.put(referer1.getUrl().toString(), true);
187          clusterSupport.refreshReferers();
188          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 4);
189          Assert.assertEquals(getAvailableReferersCount(),4);
190      }
191      private int getAvailableReferersCount() {
192          int result = 0;
193          for (Referer<IHello> referer : clusterSupport.getCluster().getReferers()) {
194              if (referer.isAvailable()) {
195                  result++;
196              }
197          }
198          return result;
199      }
200      private static class ClusterSupportMask<T> extends ClusterSupport<T> {
201          public ClusterSupportMask(Class<T> interfaceClass, List<URL> registryUrls, URL refUrl) {
202              super(interfaceClass, registryUrls, refUrl);
203          }
204          @Override
205          protected Protocol getDecorateProtocol(String protocolName) {
206              return protocol;
207          }
208          @Override
209          protected Registry getRegistry(URL url) {
210              return registries.get(url.getProtocol());
211          }
212          @Override
213          public void refreshReferers(){
214              super.refreshReferers();
215          }
216      }
217      @SuppressWarnings("unchecked")
218      private synchronized Referer<IHello> mockReferer(URL url) {
219          if (portReferers.get(url.getIdentity()) != null) {
220              return portReferers.get(url.getIdentity());
221          }
222          portReferers.put(url.getIdentity(), mockery.mock(Referer.class, url.getIdentity()));
223          return portReferers.get(url.getIdentity());
224      }
225      private List<URL> copy(List<URL> dest, List<URL> source) {
226          dest.clear();
227          for (URL url : source) {
228              dest.add(url.createCopy());
229          }
230          return dest;
231      }
232  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ZookeeperRegistryTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-ClusterSupportTest.java</div>
                </div>
                <div class="column column_space"><pre><code>52          registry.subscribeService(clientUrl, serviceListener);
53          Assert.assertTrue(containsServiceListener(clientUrl, serviceListener));
54          registry.doRegister(serviceUrl);
55          registry.doAvailable(serviceUrl);
56          Thread.sleep(2000);
57          registry.unsubscribeService(clientUrl, serviceListener);
58          Assert.assertFalse(containsServiceListener(clientUrl, serviceListener));
59      }
60      private boolean containsServiceListener(URL clientUrl, ServiceListener serviceListener) {
</pre></code></div>
                <div class="column column_space"><pre><code>142          clusterSupport.notify(registries.get(regProtocol2).getUrl(), copy(copy, serviceUrls1.subList(3, 4)));
143          Assert.assertEquals(clusterSupport.getCluster().getReferers().size(), 1);
144      }
145      private static List<URL> mockRegistryUrls() {
146          URL url1 = new URL(regProtocol1, "192.168.1.1", 18081, RegistryService.class.getName());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    