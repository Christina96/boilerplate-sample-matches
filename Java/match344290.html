<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ObjectArraysTest.java & AbstractFutureTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ObjectArraysTest.java & AbstractFutureTest.java
      </h3>
      <h1 align="center">
        15.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ObjectArraysTest.java (46.42857%)<TH>AbstractFutureTest.java (9.333333%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#0',2,'match344290-1.html#0',3)" NAME="0">(118-127)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#0',2,'match344290-1.html#0',3)" NAME="0">(207-216)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#1',2,'match344290-1.html#1',3)" NAME="1">(129-135)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#1',2,'match344290-1.html#1',3)" NAME="1">(345-355)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#2',2,'match344290-1.html#2',3)" NAME="2">(216-228)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#2',2,'match344290-1.html#2',3)" NAME="2">(1177-1184)</A><TD ALIGN=center><FONT COLOR="#bb0000">11</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#3',2,'match344290-1.html#3',3)" NAME="3">(74-80)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#3',2,'match344290-1.html#3',3)" NAME="3">(894-898)</A><TD ALIGN=center><FONT COLOR="#bb0000">11</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#4',2,'match344290-1.html#4',3)" NAME="4">(60-67)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#4',2,'match344290-1.html#4',3)" NAME="4">(82-90)</A><TD ALIGN=center><FONT COLOR="#bb0000">11</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#5',2,'match344290-1.html#5',3)" NAME="5">(186-190)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#5',2,'match344290-1.html#5',3)" NAME="5">(1053-1059)</A><TD ALIGN=center><FONT COLOR="#aa0000">10</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#6',2,'match344290-1.html#6',3)" NAME="6">(176-180)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#6',2,'match344290-1.html#6',3)" NAME="6">(965-970)</A><TD ALIGN=center><FONT COLOR="#aa0000">10</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#7',2,'match344290-1.html#7',3)" NAME="7">(171-175)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#7',2,'match344290-1.html#7',3)" NAME="7">(959-964)</A><TD ALIGN=center><FONT COLOR="#aa0000">10</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#8',2,'match344290-1.html#8',3)" NAME="8">(160-165)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#8',2,'match344290-1.html#8',3)" NAME="8">(931-936)</A><TD ALIGN=center><FONT COLOR="#aa0000">10</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#9',2,'match344290-1.html#9',3)" NAME="9">(44-50)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#9',2,'match344290-1.html#9',3)" NAME="9">(950-957)</A><TD ALIGN=center><FONT COLOR="#aa0000">10</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#10',2,'match344290-1.html#10',3)" NAME="10">(181-185)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#10',2,'match344290-1.html#10',3)" NAME="10">(1061-1065)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#11',2,'match344290-1.html#11',3)" NAME="11">(166-170)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#11',2,'match344290-1.html#11',3)" NAME="11">(978-985)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#12',2,'match344290-1.html#12',3)" NAME="12">(111-115)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#12',2,'match344290-1.html#12',3)" NAME="12">(945-950)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#13',2,'match344290-1.html#13',3)" NAME="13">(103-107)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#13',2,'match344290-1.html#13',3)" NAME="13">(177-187)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#14',2,'match344290-1.html#14',3)" NAME="14">(96-100)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#14',2,'match344290-1.html#14',3)" NAME="14">(128-133)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#15',2,'match344290-1.html#15',3)" NAME="15">(68-73)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#15',2,'match344290-1.html#15',3)" NAME="15">(853-858)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#16',2,'match344290-1.html#16',3)" NAME="16">(50-55)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#16',2,'match344290-1.html#16',3)" NAME="16">(633-637)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match344290-0.html#17',2,'match344290-1.html#17',3)" NAME="17">(17-27)<TD><A HREF="javascript:ZweiFrames('match344290-0.html#17',2,'match344290-1.html#17',3)" NAME="17">(17-27)</A><TD ALIGN=center><FONT COLOR="#990000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ObjectArraysTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="17"></A> * limitations under the License.
 */

<FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match344290-1.html#17',3,'match344290-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package com.google.common.collect;

import static com.google.common.truth.Truth.assertThat;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.testing.NullPointerTester;
import java.io.Serializable;
import java.util.Arrays;
import java.util.List;
import</B></FONT> junit.framework.TestCase;

/**
 * Unit test for {@code ObjectArrays}.
 *
 * @author Kevin Bourrillion
 */
@GwtCompatible(emulated = true)
public class ObjectArraysTest extends TestCase {

  @GwtIncompatible // NullPointerTester
  public void testNullPointerExceptions() {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicStaticMethods(ObjectArrays.class);
<A NAME="9"></A>  }

  @GwtIncompatible // ObjectArrays.newArray(Class, int)
  public void testNewArray_fromClass_Empty() <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match344290-1.html#9',3,'match344290-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    String[] empty = ObjectArrays.newArray(String.class, 0);
    assertEquals(String[].class, empty.getClass());
<A NAME="16"></A>    assertThat(empty).isEmpty();
  }

  <FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match344290-1.html#16',3,'match344290-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@GwtIncompatible // ObjectArray</B></FONT>s.newArray(Class, int)
  public void testNewArray_fromClass_Nonempty() {
    String[] array = ObjectArrays.newArray(String.class, 2);
    assertEquals(String[].class, array.getClass());
    assertThat(array).hasLength(2);
    assertNull</B></FONT>(array[0]);
  }
<A NAME="4"></A>
  @GwtIncompatible // ObjectArrays.newArray(Class, int)
  public void testNewArray_fromClass_OfArray() {
    String[][] array = <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match344290-1.html#4',3,'match344290-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ObjectArrays.newArray(String[].class, 1);
    assertEquals(String[][].class, array.getClass());
    assertThat(array).hasLength(1);
    assertNull(array[0]);
  }
<A NAME="15"></A>
  public void testNewArray_fromArray_Empty() {
    String[] in = new String[0]</B></FONT>;
    String[] empty = <FONT color="#f52887"><A HREF="javascript:ZweiFrames('match344290-1.html#15',3,'match344290-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ObjectArrays.newArray(in, 0);
    assertThat(empty).isEmpty();
  }
<A NAME="3"></A>
  public void testNewArray_fromArray_Nonempty() {
    String[] array = ObjectArrays.newArray</B></FONT>(new String[0], 2);
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match344290-1.html#3',3,'match344290-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(String[].class, array.getClass());
    assertThat(array).hasLength(2);
    assertNull(array[0]);
  }

  public void testNewArray_fromArray_OfArray() {
    String[][] array = ObjectArrays.newArray</B></FONT>(new String[0][0], 1);
    assertEquals(String[][].class, array.getClass());
    assertThat(array).hasLength(1);
    assertNull(array[0]);
  }

  @GwtIncompatible // ObjectArrays.concat(Object[], Object[], Class)
  public void testConcatEmptyEmpty() {
    String[] result = ObjectArrays.concat(new String[0], new String[0], String.class);
    assertEquals(String[].class, result.getClass());
    assertThat(result).isEmpty();
  }

<A NAME="14"></A>  @GwtIncompatible // ObjectArrays.concat(Object[], Object[], Class)
  public void testConcatEmptyNonempty() {
    String[] result = ObjectArrays.concat(new String[0], new String[] {&quot;a&quot;, &quot;b&quot;}, String.class);
    <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match344290-1.html#14',3,'match344290-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly(&quot;a&quot;, &quot;b&quot;).inOrder();
  }

<A NAME="13"></A>  @GwtIncompatible // Obj</B></FONT>ectArrays.concat(Object[], Object[], Class)
  public void testConcatNonemptyEmpty() {
    String[] result = ObjectArrays.concat(new String[] {&quot;a&quot;, &quot;b&quot;}, new String[0], String.class);
    <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match344290-1.html#13',3,'match344290-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly(&quot;a&quot;, &quot;b&quot;).inOrder();
  }

  @GwtIncompatibl</B></FONT>e // ObjectArrays.concat(Object[], Object[], Class)
<A NAME="12"></A>  public void testConcatBasic() {
    String[] result =
        ObjectArrays.concat(new String[] {&quot;a&quot;, &quot;b&quot;}, new String[] {&quot;c&quot;, &quot;d&quot;}, String.class);
    <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match344290-1.html#12',3,'match344290-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;).inOrder();
  }

<A NAME="0"></A>  @GwtIncompatible // ObjectArr</B></FONT>ays.concat(Object[], Object[], Class)
  public void testConcatWithMoreGeneralType() {
    Serializable[] result = ObjectArrays.concat(new String[0], new String[0], Serializable.class);
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match344290-1.html#0',3,'match344290-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertEquals(Serializable[].class, result.getClass());
  }

  public void testToArrayImpl1() {
    doTestToArrayImpl1(Lists.&lt;Integer&gt;newArrayList());
    doTestToArrayImpl1(Lists.newArrayList(1));
    doTestToArrayImpl1(Lists.newArrayList(1, null, 3));
  }
<A NAME="1"></A>
  private void doTes</B></FONT>tToArrayImpl1(List&lt;Integer&gt; list) {
    Object[] reference = list.toArray();
    Object[] target = <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match344290-1.html#1',3,'match344290-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ObjectArrays.toArrayImpl(list);
    assertEquals(reference.getClass(), target.getClass());
    assertTrue(Arrays.equals(reference, target));
  }

  public void testToArrayImpl2() {
    doTestToArrayImpl2(Lists.&lt;Integer&gt;newArrayList</B></FONT>(), new Integer[0], false);
    doTestToArrayImpl2(Lists.&lt;Integer&gt;newArrayList(), new Integer[1], true);

    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[0], false);
    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[1], true);
    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[] {2, 3}, true);

    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[0], false);
    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[2], false);
    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[3], true);
  }

  private void doTestToArrayImpl2(List&lt;Integer&gt; list, Integer[] array1, boolean expectModify) {
    Integer[] starting = Arrays.copyOf(array1, array1.length);
    Integer[] array2 = Arrays.copyOf(array1, array1.length);
    Object[] reference = list.toArray(array1);

    Object[] target = ObjectArrays.toArrayImpl(list, array2);

    assertEquals(reference.getClass(), target.getClass());
    assertTrue(Arrays.equals(reference, target));
    assertTrue(Arrays.equals(reference, target));
<A NAME="8"></A>
    Object[] expectedArray1 = expectModify ? reference : starting;
    Object[] expectedArray2 = expectModify ? target : starting;
    <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match344290-1.html#8',3,'match344290-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertTrue(Arrays.equals(expectedArray1, array1));
    assertTrue(Arrays.equals(expectedArray2, array2));
  }
<A NAME="11"></A>
  public void testPrependZeroElements() {
    String[] result = ObjectArrays.concat</B></FONT>(&quot;foo&quot;, new String[] {});
    <FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match344290-1.html#11',3,'match344290-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(result).asList().contains(&quot;foo&quot;);
  }
<A NAME="7"></A>
  public void testPrependOneElement() {
    String[] result = ObjectArrays.concat</B></FONT>(&quot;foo&quot;, new String[] {&quot;bar&quot;});
    <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match344290-1.html#7',3,'match344290-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(result).asList().containsExactly(&quot;foo&quot;, &quot;bar&quot;).inOrder();
  }
<A NAME="6"></A>
  public void testPrependTwoElements() {
    String[] result = ObjectArrays.concat</B></FONT>(&quot;foo&quot;, new String[] {&quot;bar&quot;, &quot;baz&quot;});
    <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match344290-1.html#6',3,'match344290-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(result).asList().containsExactly(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;).inOrder();
  }
<A NAME="10"></A>
  public void testAppendZeroElements() {
    String[] result = ObjectArrays.concat</B></FONT>(new String[] {}, &quot;foo&quot;);
    <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match344290-1.html#10',3,'match344290-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(result).asList().contains(&quot;foo&quot;);
  }
<A NAME="5"></A>
  public void testAppendOneElement() {
    String[] result = ObjectArrays.concat</B></FONT>(new String[] {&quot;foo&quot;}, &quot;bar&quot;);
    <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match344290-1.html#5',3,'match344290-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(result).asList().containsExactly(&quot;foo&quot;, &quot;bar&quot;).inOrder();
  }

  public void testAppendTwoElements() {
    String[] result = ObjectArrays.concat</B></FONT>(new String[] {&quot;foo&quot;, &quot;bar&quot;}, &quot;baz&quot;);
    assertThat(result).asList().containsExactly(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;).inOrder();
  }

  public void testEmptyArrayToEmpty() {
    doTestNewArrayEquals(new Object[0], 0);
  }

  public void testEmptyArrayToNonEmpty() {
    checkArrayEquals(new Long[5], ObjectArrays.newArray(new Long[0], 5));
  }

  public void testNonEmptyToShorter() {
    checkArrayEquals(new String[9], ObjectArrays.newArray(new String[10], 9));
  }

  public void testNonEmptyToSameLength() {
    doTestNewArrayEquals(new String[10], 10);
  }

  public void testNonEmptyToLonger() {
    checkArrayEquals(
        new String[10], ObjectArrays.newArray(new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;}, 10));
<A NAME="2"></A>  }

  private static void checkArrayEquals(Object[] expected, Object[] actual) {
    <FONT color="#980517"><A HREF="javascript:ZweiFrames('match344290-1.html#2',3,'match344290-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertTrue(
        &quot;expected(&quot;
            + expected.getClass()
            + &quot;): &quot;
            + Arrays.toString(expected)
            + &quot; actual(&quot;
            + actual.getClass()
            + &quot;): &quot;
            + Arrays.toString(actual),
        arrayEquals(expected, actual));
  }

  private static boolean arrayEquals(Object[] array1, Object[] array2</B></FONT>) {
    assertSame(array1.getClass(), array2.getClass());
    return Arrays.equals(array1, array2);
  }

  private static void doTestNewArrayEquals(Object[] expected, int length) {
    checkArrayEquals(expected, ObjectArrays.newArray(expected, length));
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractFutureTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
<A NAME="17"></A> * limitations under the License.
 */

<FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#17',2,'match344290-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.google.common.util.concurrent;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.Iterables;
import com.google.common.collect.Range;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
import</B></FONT> java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.LockSupport;
import junit.framework.AssertionFailedError;
import junit.framework.TestCase;

/**
 * Tests for {@link AbstractFuture}.
 *
 * @author Brian Stoler
 */
public class AbstractFutureTest extends TestCase {
  public void testSuccess() throws ExecutionException, InterruptedException {
    final Object value = new Object();
    assertSame(
        value,
        new AbstractFuture&lt;Object&gt;() {
          {
            set(value);
          }
        }.get());
  }

  public void testException() throws InterruptedException {
    final Throwable failure = new Throwable();
    AbstractFuture&lt;String&gt; future =
        new AbstractFuture&lt;String&gt;() {
          {
            setException(failure);
          }
        };

    ExecutionException ee1 = getExpectingExecutionException(future);
    ExecutionException ee2 = getExpectingExecutionException(future);

<A NAME="4"></A>    // Ensure we get a unique execution exception on each get
    assertNotSame(ee1, ee2);

    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#4',2,'match344290-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(ee1).hasCauseThat().isSameInstanceAs(failure);
    assertThat(ee2).hasCauseThat().isSameInstanceAs(failure);

    checkStackTrace(ee1);
    checkStackTrace(ee2);
  }

  public void testCancel_notDoneNoInterrupt() throws Exception {
    InterruptibleFuture future = new InterruptibleFuture()</B></FONT>;
    assertTrue(future.cancel(false));
    assertTrue(future.isCancelled());
    assertTrue(future.isDone());
    assertFalse(future.wasInterrupted());
    assertFalse(future.interruptTaskWasCalled);
    try {
      future.get();
      fail(&quot;Expected CancellationException&quot;);
    } catch (CancellationException e) {
      // See AbstractFutureCancellationCauseTest for how to set causes
      assertThat(e).hasCauseThat().isNull();
    }
  }

  public void testCancel_notDoneInterrupt() throws Exception {
    InterruptibleFuture future = new InterruptibleFuture();
    assertTrue(future.cancel(true));
    assertTrue(future.isCancelled());
    assertTrue(future.isDone());
    assertTrue(future.wasInterrupted());
    assertTrue(future.interruptTaskWasCalled);
    try {
      future.get();
      fail(&quot;Expected CancellationException&quot;);
    } catch (CancellationException e) {
      // See AbstractFutureCancellationCauseTest for how to set causes
      assertThat(e).hasCauseThat().isNull();
    }
  }

  public void testCancel_done() throws Exception {
    AbstractFuture&lt;String&gt; future =
        new AbstractFuture&lt;String&gt;() {
          {
<A NAME="14"></A>            set(&quot;foo&quot;);
          }
        };
    <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#14',2,'match344290-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertFalse(future.cancel(true));
    assertFalse(future.isCancelled());
    assertTrue(future.isDone());
  }

  public void testGetWithTimeo</B></FONT>utDoneFuture() throws Exception {
    AbstractFuture&lt;String&gt; future =
        new AbstractFuture&lt;String&gt;() {
          {
            set(&quot;foo&quot;);
          }
        };
    assertEquals(&quot;foo&quot;, future.get(0, TimeUnit.SECONDS));
  }

  public void testEvilFuture_setFuture() throws Exception {
    final RuntimeException exception = new RuntimeException(&quot;you didn't say the magic word!&quot;);
    AbstractFuture&lt;String&gt; evilFuture =
        new AbstractFuture&lt;String&gt;() {
          @Override
          public void addListener(Runnable r, Executor e) {
            throw exception;
          }
        };
    AbstractFuture&lt;String&gt; normalFuture = new AbstractFuture&lt;String&gt;() {};
    normalFuture.setFuture(evilFuture);
    assertTrue(normalFuture.isDone());
    try {
      normalFuture.get();
      fail();
    } catch (ExecutionException e) {
      assertThat(e).hasCauseThat().isSameInstanceAs(exception);
    }
  }

  public void testRemoveWaiter_interruption() throws Exception {
    final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    WaiterThread waiter1 = new WaiterThread(future);
    waiter1.start();
    waiter1.awaitWaiting();

    WaiterThread waiter2 = new WaiterThread(future);
    waiter2.start();
    waiter2.awaitWaiting();
    // The waiter queue should be waiter2-&gt;waiter1

<A NAME="13"></A>    // This should wake up waiter1 and cause the waiter1 node to be removed.
    waiter1.interrupt();

    <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#13',2,'match344290-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>waiter1.join();
    waiter2.awaitWaiting(); // should still be blocked

    LockSupport.unpark(waiter2); // spurious wakeup
    waiter2.awaitWaiting(); // should eventually re-park

    future.set(null);
    waiter2.join();
  }

  public void testRemoveWa</B></FONT>iter_polling() throws Exception {
    final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    WaiterThread waiter = new WaiterThread(future);
    waiter.start();
    waiter.awaitWaiting();
    PollingThread poller = new PollingThread(future);
    poller.start();
    PollingThread poller2 = new PollingThread(future);
    poller2.start();
    PollingThread poller3 = new PollingThread(future);
    poller3.start();
    poller.awaitInLoop();
    poller2.awaitInLoop();
    poller3.awaitInLoop();

    // The waiter queue should be {poller x 3}-&gt;waiter1
    waiter.interrupt();
<A NAME="0"></A>
    // This should wake up waiter1 and cause the waiter1 node to be removed.
    waiter.join();
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#0',2,'match344290-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>future.set(null);
    poller.join();
  }

  public void testToString_allUnique() throws Exception {
    // Two futures should not have the same toString, to avoid people asserting on it
    assertThat(SettableFuture.create().toString()).isNotEqualTo(SettableFuture.create().toString());
  }

  public void test</B></FONT>ToString_oom() throws Exception {
    SettableFuture&lt;Object&gt; future = SettableFuture.create();
    future.set(
        new Object() {
          @Override
          public String toString() {
            throw new OutOfMemoryError();
          }

          @Override
          public int hashCode() {
            throw new OutOfMemoryError();
          }
        });

    String unused = future.toString();

    SettableFuture&lt;Object&gt; future2 = SettableFuture.create();

    // A more organic OOM from a toString implementation
    Object object =
        new Object() {
          @Override
          public String toString() {
            return new String(new char[50_000]);
          }
        };
    List&lt;Object&gt; list = Collections.singletonList(object);
    for (int i = 0; i &lt; 10; i++) {
      Object[] array = new Object[500];
      Arrays.fill(array, list);
      list = Arrays.asList(array);
    }
    future2.set(list);

    unused = future.toString();
  }

  public void testToString_notDone() throws Exception {
    AbstractFuture&lt;Object&gt; testFuture =
        new AbstractFuture&lt;Object&gt;() {
          @Override
          public String pendingToString() {
            return &quot;cause=[Because this test isn't done]&quot;;
          }
        };
    assertThat(testFuture.toString())
        .matches(
            &quot;[^\\[]+\\[status=PENDING, info=\\[cause=\\[Because this test isn't done\\]\\]\\]&quot;);
    try {
      testFuture.get(1, TimeUnit.NANOSECONDS);
      fail();
    } catch (TimeoutException e) {
      assertThat(e.getMessage()).contains(&quot;1 nanoseconds&quot;);
      assertThat(e.getMessage()).contains(&quot;Because this test isn't done&quot;);
    }
  }

  public void testToString_completesDuringToString() throws Exception {
    AbstractFuture&lt;Object&gt; testFuture =
        new AbstractFuture&lt;Object&gt;() {
          @Override
          public String pendingToString() {
            // Complete ourselves during the toString calculation
            this.set(true);
            return &quot;cause=[Because this test isn't done]&quot;;
          }
        };
    assertThat(testFuture.toString())
        .matches(&quot;[^\\[]+\\[status=SUCCESS, result=\\[java.lang.Boolean@\\w+\\]\\]&quot;);
  }

  /**
   * This test attempts to cause a future to wait for longer than it was requested to from a timed
   * get() call. As measurements of time are prone to flakiness, it tries to assert based on ranges
   * derived from observing how much time actually passed for various operations.
   */
  @SuppressWarnings({&quot;DeprecatedThreadMethods&quot;, &quot;ThreadPriorityCheck&quot;})
  @AndroidIncompatible // Thread.suspend
  public void testToString_delayedTimeout() throws Exception {
    TimedWaiterThread thread =
        new TimedWaiterThread(new AbstractFuture&lt;Object&gt;() {}, 2, TimeUnit.SECONDS);
    thread.start();
    thread.awaitWaiting();
    thread.suspend();
    // Sleep for enough time to add 1500 milliseconds of overwait to the get() call.
    long toWaitMillis = 3500 - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - thread.startTime);
    Thread.sleep(toWaitMillis);
    thread.setPriority(Thread.MAX_PRIORITY);
    thread.resume();
    thread.join();
    // It's possible to race and suspend the thread just before the park call actually takes effect,
    // causing the thread to be suspended for 3.5 seconds, and then park itself for 2 seconds after
    // being resumed. To avoid a flake in this scenario, calculate how long that thread actually
    // waited and assert based on that time. Empirically, the race where the thread ends up waiting
    // for 5.5 seconds happens about 2% of the time.
    boolean longWait = TimeUnit.NANOSECONDS.toSeconds(thread.timeSpentBlocked) &gt;= 5;
    // Count how long it actually took to return; we'll accept any number between the expected delay
    // and the approximate actual delay, to be robust to variance in thread scheduling.
    char overWaitNanosFirstDigit =
        Long.toString(
                thread.timeSpentBlocked - TimeUnit.MILLISECONDS.toNanos(longWait ? 5000 : 3000))
            .charAt(0);
    if (overWaitNanosFirstDigit &lt; '4') {
      overWaitNanosFirstDigit = '9';
    }
    String nanosRegex = &quot;[4-&quot; + overWaitNanosFirstDigit + &quot;][0-9]+&quot;;
    assertWithMessage(
            &quot;Spent &quot; + thread.timeSpentBlocked + &quot; ns blocked; slept for &quot; + toWaitMillis + &quot; ms&quot;)
        .that(thread.exception)
        .hasMessageThat()
        .matches(
            &quot;Waited 2 seconds \\(plus &quot;
                + (longWait ? &quot;3&quot; : &quot;1&quot;)
                + &quot; seconds, &quot;
                + nanosRegex
                + &quot; nanoseconds delay\\).*&quot;);
  }

  public void testToString_completed() throws Exception {
    AbstractFuture&lt;Object&gt; testFuture2 =
        new AbstractFuture&lt;Object&gt;() {
          @Override
          public String pendingToString() {
            return &quot;cause=[Someday...]&quot;;
          }
<A NAME="1"></A>        };
    AbstractFuture&lt;Object&gt; testFuture3 = new AbstractFuture&lt;Object&gt;() {};
    testFuture3.setFuture(testFuture2);
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#1',2,'match344290-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(testFuture3.toString())
        .matches(
            &quot;[^\\[]+\\[status=PENDING, setFuture=\\[[^\\[]+\\[status=PENDING,&quot;
                + &quot; info=\\[cause=\\[Someday...]]]]]&quot;);
    testFuture2.set(&quot;result string&quot;);
    assertThat(testFuture3.toString())
        .matches(&quot;[^\\[]+\\[status=SUCCESS, result=\\[java.lang.String@\\w+\\]\\]&quot;);
  }

  public void testToString_cancelled() throws Exception {
    assertThat</B></FONT>(Futures.immediateCancelledFuture().toString())
        .matches(&quot;[^\\[]+\\[status=CANCELLED\\]&quot;);
  }

  public void testToString_failed() {
    assertThat(Futures.immediateFailedFuture(new RuntimeException(&quot;foo&quot;)).toString())
        .matches(&quot;[^\\[]+\\[status=FAILURE, cause=\\[java.lang.RuntimeException: foo\\]\\]&quot;);
  }

  public void testToString_misbehaving() throws Exception {
    assertThat(
            new AbstractFuture&lt;Object&gt;() {
              @Override
              public String pendingToString() {
                throw new RuntimeException(&quot;I'm a misbehaving implementation&quot;);
              }
            }.toString())
        .matches(
            &quot;[^\\[]+\\[status=PENDING, info=\\[Exception thrown from implementation: &quot;
                + &quot;class java.lang.RuntimeException\\]\\]&quot;);
  }

  public void testCompletionFinishesWithDone() {
    ExecutorService executor = Executors.newFixedThreadPool(10);
    for (int i = 0; i &lt; 50000; i++) {
      final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
      final AtomicReference&lt;String&gt; errorMessage = Atomics.newReference();
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              future.set(&quot;success&quot;);
              if (!future.isDone()) {
                errorMessage.set(&quot;Set call exited before future was complete.&quot;);
              }
            }
          });
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              future.setException(new IllegalArgumentException(&quot;failure&quot;));
              if (!future.isDone()) {
                errorMessage.set(&quot;SetException call exited before future was complete.&quot;);
              }
            }
          });
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              future.cancel(true);
              if (!future.isDone()) {
                errorMessage.set(&quot;Cancel call exited before future was complete.&quot;);
              }
            }
          });
      try {
        future.get();
      } catch (Throwable t) {
        // Ignore, we just wanted to block.
      }
      String error = errorMessage.get();
      assertNull(error, error);
    }
    executor.shutdown();
  }

  /**
   * He did the bash, he did the future bash The future bash, it was a concurrency smash He did the
   * bash, it caught on in a flash He did the bash, he did the future bash
   */

  public void testFutureBash() {
    final CyclicBarrier barrier =
        new CyclicBarrier(
            6 // for the setter threads
                + 50 // for the listeners
                + 50 // for the blocking get threads,
                + 1); // for the main thread
    final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
    final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
    final AtomicInteger numSuccessfulSetCalls = new AtomicInteger();
    Callable&lt;Void&gt; completeSuccessfullyRunnable =
        new Callable&lt;Void&gt;() {
          @Override
          public Void call() {
            if (currentFuture.get().set(&quot;set&quot;)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; completeExceptionallyRunnable =
        new Callable&lt;Void&gt;() {
          Exception failureCause = new Exception(&quot;setException&quot;);

          @Override
          public Void call() {
            if (currentFuture.get().setException(failureCause)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; cancelRunnable =
        new Callable&lt;Void&gt;() {
          @Override
          public Void call() {
            if (currentFuture.get().cancel(true)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; setFutureCompleteSuccessfullyRunnable =
        new Callable&lt;Void&gt;() {
          ListenableFuture&lt;String&gt; future = Futures.immediateFuture(&quot;setFuture&quot;);

          @Override
          public Void call() {
            if (currentFuture.get().setFuture(future)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; setFutureCompleteExceptionallyRunnable =
        new Callable&lt;Void&gt;() {
          ListenableFuture&lt;String&gt; future =
              Futures.immediateFailedFuture(new Exception(&quot;setFuture&quot;));

          @Override
          public Void call() {
            if (currentFuture.get().setFuture(future)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; setFutureCancelRunnable =
        new Callable&lt;Void&gt;() {
          ListenableFuture&lt;String&gt; future = Futures.immediateCancelledFuture();

          @Override
          public Void call() {
            if (currentFuture.get().setFuture(future)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
    Runnable collectResultsRunnable =
        new Runnable() {
          @Override
          public void run() {
            try {
              String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
              finalResults.add(result);
            } catch (ExecutionException e) {
              finalResults.add(e.getCause());
            } catch (CancellationException e) {
              finalResults.add(CancellationException.class);
            } finally {
              awaitUnchecked(barrier);
            }
          }
        };
    Runnable collectResultsTimedGetRunnable =
        new Runnable() {
          @Override
          public void run() {
            Future&lt;String&gt; future = currentFuture.get();
            while (true) {
              try {
                String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);
                finalResults.add(result);
                break;
              } catch (ExecutionException e) {
                finalResults.add(e.getCause());
                break;
              } catch (CancellationException e) {
                finalResults.add(CancellationException.class);
                break;
              } catch (TimeoutException e) {
                // loop
              }
            }
            awaitUnchecked(barrier);
          }
        };
    List&lt;Callable&lt;?&gt;&gt; allTasks = new ArrayList&lt;&gt;();
    allTasks.add(completeSuccessfullyRunnable);
    allTasks.add(completeExceptionallyRunnable);
    allTasks.add(cancelRunnable);
    allTasks.add(setFutureCompleteSuccessfullyRunnable);
    allTasks.add(setFutureCompleteExceptionallyRunnable);
    allTasks.add(setFutureCancelRunnable);
    for (int k = 0; k &lt; 50; k++) {
      // For each listener we add a task that submits it to the executor directly for the blocking
      // get usecase and another task that adds it as a listener to the future to exercise both
      // racing addListener calls and addListener calls completing after the future completes.
      final Runnable listener =
          k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;
      allTasks.add(Executors.callable(listener));
      allTasks.add(
          new Callable&lt;Void&gt;() {
            @Override
            public Void call() throws Exception {
              currentFuture.get().addListener(listener, executor);
              return null;
            }
          });
    }
    assertEquals(allTasks.size() + 1, barrier.getParties());
    for (int i = 0; i &lt; 1000; i++) {
      Collections.shuffle(allTasks);
      final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
      currentFuture.set(future);
      for (Callable&lt;?&gt; task : allTasks) {
        @SuppressWarnings(&quot;unused&quot;) // https://errorprone.info/bugpattern/FutureReturnValueIgnored
        Future&lt;?&gt; possiblyIgnoredError = executor.submit(task);
      }
      awaitUnchecked(barrier);
      assertThat(future.isDone()).isTrue();
      // inspect state and ensure it is correct!
      // asserts that all get calling threads received the same value
      Object result = Iterables.getOnlyElement(finalResults);
      if (result == CancellationException.class) {
        assertTrue(future.isCancelled());
        if (future.wasInterrupted()) {
          // We were cancelled, it is possible that setFuture could have succeeded too.
          assertThat(numSuccessfulSetCalls.get()).isIn(Range.closed(1, 2));
        } else {
          assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);
        }
      } else {
        assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);
      }
      // reset for next iteration
      numSuccessfulSetCalls.set(0);
      finalResults.clear();
    }
    executor.shutdown();
  }

  // setFuture and cancel() interact in more complicated ways than the other setters.
  public void testSetFutureCancelBash() {
    final int size = 50;
    final CyclicBarrier barrier =
        new CyclicBarrier(
            2 // for the setter threads
                + size // for the listeners
                + size // for the get threads,
                + 1); // for the main thread
    final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
    final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
    final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; setFutureFuture = Atomics.newReference();
    final AtomicBoolean setFutureSetSuccess = new AtomicBoolean();
    final AtomicBoolean setFutureCompletionSuccess = new AtomicBoolean();
    final AtomicBoolean cancellationSuccess = new AtomicBoolean();
    Runnable cancelRunnable =
        new Runnable() {
          @Override
          public void run() {
            cancellationSuccess.set(currentFuture.get().cancel(true));
            awaitUnchecked(barrier);
          }
<A NAME="16"></A>        };
    Runnable setFutureCompleteSuccessfullyRunnable =
        new Runnable() {
          <FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#16',2,'match344290-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
          public void run() {
            AbstractFuture&lt;String&gt; future = setFutureFuture.get();
            setFutureSetSuccess.set(currentFuture.get().setFuture(future));
            setFutureCompletionSuccess.set(future.set</B></FONT>(&quot;hello-async-world&quot;));
            awaitUnchecked(barrier);
          }
        };
    final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
    Runnable collectResultsRunnable =
        new Runnable() {
          @Override
          public void run() {
            try {
              String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
              finalResults.add(result);
            } catch (ExecutionException e) {
              finalResults.add(e.getCause());
            } catch (CancellationException e) {
              finalResults.add(CancellationException.class);
            } finally {
              awaitUnchecked(barrier);
            }
          }
        };
    Runnable collectResultsTimedGetRunnable =
        new Runnable() {
          @Override
          public void run() {
            Future&lt;String&gt; future = currentFuture.get();
            while (true) {
              try {
                String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);
                finalResults.add(result);
                break;
              } catch (ExecutionException e) {
                finalResults.add(e.getCause());
                break;
              } catch (CancellationException e) {
                finalResults.add(CancellationException.class);
                break;
              } catch (TimeoutException e) {
                // loop
              }
            }
            awaitUnchecked(barrier);
          }
        };
    List&lt;Runnable&gt; allTasks = new ArrayList&lt;&gt;();
    allTasks.add(cancelRunnable);
    allTasks.add(setFutureCompleteSuccessfullyRunnable);
    for (int k = 0; k &lt; size; k++) {
      // For each listener we add a task that submits it to the executor directly for the blocking
      // get usecase and another task that adds it as a listener to the future to exercise both
      // racing addListener calls and addListener calls completing after the future completes.
      final Runnable listener =
          k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;
      allTasks.add(listener);
      allTasks.add(
          new Runnable() {
            @Override
            public void run() {
              currentFuture.get().addListener(listener, executor);
            }
          });
    }
    assertEquals(allTasks.size() + 1, barrier.getParties()); // sanity check
    for (int i = 0; i &lt; 1000; i++) {
      Collections.shuffle(allTasks);
      final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
      final AbstractFuture&lt;String&gt; setFuture = new AbstractFuture&lt;String&gt;() {};
      currentFuture.set(future);
      setFutureFuture.set(setFuture);
      for (Runnable task : allTasks) {
        executor.execute(task);
      }
      awaitUnchecked(barrier);
      assertThat(future.isDone()).isTrue();
      // inspect state and ensure it is correct!
      // asserts that all get calling threads received the same value
      Object result = Iterables.getOnlyElement(finalResults);
      if (result == CancellationException.class) {
        assertTrue(future.isCancelled());
        assertTrue(cancellationSuccess.get());
        // cancellation can interleave in 3 ways
        // 1. prior to setFuture
        // 2. after setFuture before set() on the future assigned
        // 3. after setFuture and set() are called but before the listener completes.
        if (!setFutureSetSuccess.get() || !setFutureCompletionSuccess.get()) {
          // If setFuture fails or set on the future fails then it must be because that future was
          // cancelled
          assertTrue(setFuture.isCancelled());
          assertTrue(setFuture.wasInterrupted()); // we only call cancel(true)
        }
      } else {
        // set on the future completed
        assertFalse(cancellationSuccess.get());
        assertTrue(setFutureSetSuccess.get());
        assertTrue(setFutureCompletionSuccess.get());
      }
      // reset for next iteration
      setFutureSetSuccess.set(false);
      setFutureCompletionSuccess.set(false);
      cancellationSuccess.set(false);
      finalResults.clear();
    }
    executor.shutdown();
  }

  // Test to ensure that when calling setFuture with a done future only setFuture or cancel can
  // return true.
  public void testSetFutureCancelBash_withDoneFuture() {
    final CyclicBarrier barrier =
        new CyclicBarrier(
            2 // for the setter threads
                + 1 // for the blocking get thread,
                + 1); // for the main thread
    final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
    final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
    final AtomicBoolean setFutureSuccess = new AtomicBoolean();
    final AtomicBoolean cancellationSuccess = new AtomicBoolean();
    Callable&lt;Void&gt; cancelRunnable =
        new Callable&lt;Void&gt;() {
          @Override
          public Void call() {
            cancellationSuccess.set(currentFuture.get().cancel(true));
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; setFutureCompleteSuccessfullyRunnable =
        new Callable&lt;Void&gt;() {
          final ListenableFuture&lt;String&gt; future = Futures.immediateFuture(&quot;hello&quot;);

          @Override
          public Void call() {
            setFutureSuccess.set(currentFuture.get().setFuture(future));
            awaitUnchecked(barrier);
            return null;
          }
        };
    final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
    final Runnable collectResultsRunnable =
        new Runnable() {
          @Override
          public void run() {
            try {
              String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
              finalResults.add(result);
            } catch (ExecutionException e) {
              finalResults.add(e.getCause());
            } catch (CancellationException e) {
              finalResults.add(CancellationException.class);
            } finally {
              awaitUnchecked(barrier);
            }
          }
        };
    List&lt;Callable&lt;?&gt;&gt; allTasks = new ArrayList&lt;&gt;();
    allTasks.add(cancelRunnable);
    allTasks.add(setFutureCompleteSuccessfullyRunnable);
    allTasks.add(Executors.callable(collectResultsRunnable));
    assertEquals(allTasks.size() + 1, barrier.getParties()); // sanity check
    for (int i = 0; i &lt; 1000; i++) {
      Collections.shuffle(allTasks);
      final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
      currentFuture.set(future);
      for (Callable&lt;?&gt; task : allTasks) {
        @SuppressWarnings(&quot;unused&quot;) // https://errorprone.info/bugpattern/FutureReturnValueIgnored
        Future&lt;?&gt; possiblyIgnoredError = executor.submit(task);
      }
      awaitUnchecked(barrier);
      assertThat(future.isDone()).isTrue();
      // inspect state and ensure it is correct!
      // asserts that all get calling threads received the same value
      Object result = Iterables.getOnlyElement(finalResults);
      if (result == CancellationException.class) {
        assertTrue(future.isCancelled());
        assertTrue(cancellationSuccess.get());
        assertFalse(setFutureSuccess.get());
      } else {
        assertTrue(setFutureSuccess.get());
        assertFalse(cancellationSuccess.get());
      }
      // reset for next iteration
      setFutureSuccess.set(false);
      cancellationSuccess.set(false);
      finalResults.clear();
    }
    executor.shutdown();
  }

  // In a previous implementation this would cause a stack overflow after ~2000 futures chained
  // together.  Now it should only be limited by available memory (and time)
  public void testSetFuture_stackOverflow() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create();
    SettableFuture&lt;String&gt; prev = orig;
    for (int i = 0; i &lt; 100000; i++) {
      SettableFuture&lt;String&gt; curr = SettableFuture.create();
      prev.setFuture(curr);
      prev = curr;
    }
    // prev represents the 'innermost' future
    prev.set(&quot;done&quot;);
    assertTrue(orig.isDone());
  }

  // Verify that StackOverflowError in a long chain of SetFuture doesn't cause the entire toString
  // call to fail
  @GwtIncompatible
  @AndroidIncompatible
  public void testSetFutureToString_stackOverflow() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create();
    SettableFuture&lt;String&gt; prev = orig;
    for (int i = 0; i &lt; 100000; i++) {
      SettableFuture&lt;String&gt; curr = SettableFuture.create();
      prev.setFuture(curr);
<A NAME="15"></A>      prev = curr;
    }
    // orig represents the 'outermost' future
    <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#15',2,'match344290-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(orig.toString())
        .contains(&quot;Exception thrown from implementation: class java.lang.StackOverflowError&quot;);
  }

  public void testSetFuture_misbehavingFutureThrows() throws Exception {
    SettableFuture&lt;String&gt; future = SettableFuture.create</B></FONT>();
    ListenableFuture&lt;String&gt; badFuture =
        new ListenableFuture&lt;String&gt;() {
          @Override
          public boolean cancel(boolean interrupt) {
            return false;
          }

          @Override
          public boolean isDone() {
            return true;
          }

          @Override
          public boolean isCancelled() {
            return false; // BAD!!
          }

          @Override
          public String get() {
            throw new CancellationException(); // BAD!!
          }

          @Override
          public String get(long time, TimeUnit unit) {
            throw new CancellationException(); // BAD!!
          }

          @Override
          public void addListener(Runnable runnable, Executor executor) {
            executor.execute(runnable);
          }
        };
<A NAME="3"></A>    future.setFuture(badFuture);
    ExecutionException expected = getExpectingExecutionException(future);
    assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#3',2,'match344290-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(expected).hasCauseThat().hasMessageThat().contains(badFuture.toString());
  }

  public void testSetFuture_misbehavingFutureDoesNotThrow() throws Exception {
    SettableFuture&lt;String&gt; future = SettableFuture.create</B></FONT>();
    ListenableFuture&lt;String&gt; badFuture =
        new ListenableFuture&lt;String&gt;() {
          @Override
          public boolean cancel(boolean interrupt) {
            return false;
          }

          @Override
          public boolean isDone() {
            return true;
          }

          @Override
          public boolean isCancelled() {
            return true; // BAD!!
          }

          @Override
          public String get() {
            return &quot;foo&quot;; // BAD!!
          }

          @Override
          public String get(long time, TimeUnit unit) {
            return &quot;foo&quot;; // BAD!!
          }

          @Override
          public void addListener(Runnable runnable, Executor executor) {
<A NAME="8"></A>            executor.execute(runnable);
          }
        };
    <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#8',2,'match344290-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>future.setFuture(badFuture);
    assertThat(future.isCancelled()).isTrue();
  }

  public void testCancel_stackOverflow() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create</B></FONT>();
    SettableFuture&lt;String&gt; prev = orig;
    for (int i = 0; i &lt; 100000; i++) {
      SettableFuture&lt;String&gt; curr = SettableFuture.create();
      prev.setFuture(curr);
      prev = curr;
<A NAME="12"></A>    }
    // orig is the 'outermost future', this should propagate fully down the stack of futures.
    orig.cancel(true);
    <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#12',2,'match344290-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertTrue(orig.isCancelled());
    assertTrue(prev.isCancelled());
<A NAME="9"></A>    assertTrue(prev.wasInterrupted());
  }

  public void testSetFutur</B></FONT>eSelf_cancel() <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#9',2,'match344290-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    SettableFuture&lt;String&gt; orig = SettableFuture.create();
    orig.setFuture(orig);
    orig.cancel(true);
    assertTrue(orig.isCancelled());
  }
<A NAME="7"></A>
  public void testSetFutureS</B></FONT>elf_toString() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create();
    <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#7',2,'match344290-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>orig.setFuture(orig);
    assertThat(orig.toString()).contains(&quot;[status=PENDING, setFuture=[this future]]&quot;);
  }
<A NAME="6"></A>
  public void testSetSelf_toString() {
    SettableFuture&lt;Object&gt; orig = SettableFuture.create</B></FONT>();
    <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#6',2,'match344290-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>orig.set(orig);
    assertThat(orig.toString()).contains(&quot;[status=SUCCESS, result=[this future]]&quot;);
  }

  public void testSetFutureSelf_toStringException() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create</B></FONT>();
    orig.setFuture(
        new AbstractFuture&lt;String&gt;() {
          @Override
          public String toString() {
<A NAME="11"></A>            throw new NullPointerException();
          }
        });
    <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#11',2,'match344290-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(orig.toString())
        .contains(
            &quot;[status=PENDING, setFuture=[Exception thrown from implementation: class&quot;
                + &quot; java.lang.NullPointerException]]&quot;);
  }

  public void testSetIndirectSelf_toString() {
    final SettableFuture&lt;Object&gt; orig = SettableFuture.create</B></FONT>();
    // unlike the above this indirection defeats the trivial cycle detection and causes a SOE
    orig.setFuture(
        new ForwardingListenableFuture&lt;Object&gt;() {
          @Override
          protected ListenableFuture&lt;Object&gt; delegate() {
            return orig;
          }
        });
    assertThat(orig.toString())
        .contains(&quot;Exception thrown from implementation: class java.lang.StackOverflowError&quot;);
  }

  // Regression test for a case where we would fail to execute listeners immediately on done futures
  // this would be observable from an afterDone callback
  public void testListenersExecuteImmediately_fromAfterDone() {
    AbstractFuture&lt;String&gt; f =
        new AbstractFuture&lt;String&gt;() {
          @Override
          protected void afterDone() {
            final AtomicBoolean ranImmediately = new AtomicBoolean();
            addListener(
                new Runnable() {
                  @Override
                  public void run() {
                    ranImmediately.set(true);
                  }
                },
                MoreExecutors.directExecutor());
            assertThat(ranImmediately.get()).isTrue();
          }
        };
    f.set(&quot;foo&quot;);
  }

  // Regression test for a case where we would fail to execute listeners immediately on done futures
  // this would be observable from a waiter that was just unblocked.
  public void testListenersExecuteImmediately_afterWaiterWakesUp() throws Exception {
    final AbstractFuture&lt;String&gt; f =
        new AbstractFuture&lt;String&gt;() {
          @Override
          protected void afterDone() {
            // this simply delays executing listeners
            try {
              Thread.sleep(TimeUnit.SECONDS.toMillis(10));
            } catch (InterruptedException ignored) {
              Thread.currentThread().interrupt(); // preserve status
            }
          }
        };
    Thread t =
        new Thread() {
          @Override
          public void run() {
            f.set(&quot;foo&quot;);
          }
        };
    t.start();
    f.get();
    final AtomicBoolean ranImmediately = new AtomicBoolean();
    f.addListener(
        new Runnable() {
          @Override
          public void run() {
            ranImmediately.set(true);
<A NAME="5"></A>          }
        },
        MoreExecutors.directExecutor());
    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#5',2,'match344290-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(ranImmediately.get()).isTrue();
    t.interrupt();
    t.join();
  }

<A NAME="10"></A>  public void testTrustedGetFailure_Completed() {
    SettableFuture&lt;String&gt; future = SettableFuture.create</B></FONT>();
    future.set(&quot;261&quot;);
    <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#10',2,'match344290-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }

  public void testTrustedGetFailure_Failed() {
    SettableFuture&lt;String&gt; future = SettableFuture.create</B></FONT>();
    Throwable failure = new Throwable();
    future.setException(failure);
    assertThat(future.tryInternalFastPathGetFailure()).isEqualTo(failure);
  }

  public void testTrustedGetFailure_NotCompleted() {
    SettableFuture&lt;String&gt; future = SettableFuture.create();
    assertThat(future.isDone()).isFalse();
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }

  public void testTrustedGetFailure_CanceledNoCause() {
    SettableFuture&lt;String&gt; future = SettableFuture.create();
    future.cancel(false);
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }

  public void testGetFailure_Completed() {
    AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    future.set(&quot;261&quot;);
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }

  public void testGetFailure_Failed() {
    AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    final Throwable failure = new Throwable();
    future.setException(failure);
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }

  public void testGetFailure_NotCompleted() {
    AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    assertThat(future.isDone()).isFalse();
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }

  public void testGetFailure_CanceledNoCause() {
    AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    future.cancel(false);
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }

  public void testForwardExceptionFastPath() throws Exception {
    class FailFuture extends InternalFutureFailureAccess implements ListenableFuture&lt;String&gt; {
      Throwable failure;

      FailFuture(Throwable throwable) {
        failure = throwable;
      }

      @Override
      public boolean cancel(boolean mayInterruptIfRunning) {
        throw new AssertionFailedError(&quot;cancel shouldn't be called on this object&quot;);
      }

      @Override
      public boolean isCancelled() {
        return false;
      }

      @Override
      public boolean isDone() {
        return true;
      }

      @Override
      public String get() throws InterruptedException, ExecutionException {
        throw new AssertionFailedError(&quot;get() shouldn't be called on this object&quot;);
      }

      @Override
      public String get(long timeout, TimeUnit unit)
          throws InterruptedException, ExecutionException, TimeoutException {
        return get();
      }

      @Override
      protected Throwable tryInternalFastPathGetFailure() {
        return failure;
      }

      @Override
      public void addListener(Runnable listener, Executor executor) {
        throw new AssertionFailedError(&quot;addListener() shouldn't be called on this object&quot;);
      }
    }

    final RuntimeException exception = new RuntimeException(&quot;you still didn't say the magic word!&quot;);
    SettableFuture&lt;String&gt; normalFuture = SettableFuture.create();
    normalFuture.setFuture(new FailFuture(exception));
    assertTrue(normalFuture.isDone());
    try {
      normalFuture.get();
      fail();
    } catch (ExecutionException e) {
      assertSame(exception, e.getCause());
    }
  }

  private static void awaitUnchecked(final CyclicBarrier barrier) {
    try {
      barrier.await();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private void checkStackTrace(ExecutionException e) {
<A NAME="2"></A>    // Our call site for get() should be in the trace.
    int index = findStackFrame(e, getClass().getName(), &quot;getExpectingExecutionException&quot;);

    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344290-0.html#2',2,'match344290-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(index).isNotEqualTo(0);

    // Above our method should be the call to get(). Don't assert on the class
    // because it could be some superclass.
    assertThat(e.getStackTrace()[index - 1].getMethodName()).isEqualTo(&quot;get&quot;);
  }

  private static int findStackFrame(ExecutionException e, String clazz</B></FONT>, String method) {
    StackTraceElement[] elements = e.getStackTrace();
    for (int i = 0; i &lt; elements.length; i++) {
      StackTraceElement element = elements[i];
      if (element.getClassName().equals(clazz) &amp;&amp; element.getMethodName().equals(method)) {
        return i;
      }
    }
    AssertionFailedError failure =
        new AssertionFailedError(
            &quot;Expected element &quot; + clazz + &quot;.&quot; + method + &quot; not found in stack trace&quot;);
    failure.initCause(e);
    throw failure;
  }

  private ExecutionException getExpectingExecutionException(AbstractFuture&lt;String&gt; future)
      throws InterruptedException {
    try {
      String got = future.get();
      fail(&quot;Expected exception but got &quot; + got);
    } catch (ExecutionException e) {
      return e;
    }

    // unreachable, but compiler doesn't know that fail() always throws
    return null;
  }

  private static final class WaiterThread extends Thread {
    private final AbstractFuture&lt;?&gt; future;

    private WaiterThread(AbstractFuture&lt;?&gt; future) {
      this.future = future;
    }

    @Override
    public void run() {
      try {
        future.get();
      } catch (Exception e) {
        // nothing
      }
    }

    void awaitWaiting() {
      while (!isBlocked()) {
        if (getState() == State.TERMINATED) {
          throw new RuntimeException(&quot;Thread exited&quot;);
        }
        Thread.yield();
      }
    }

    private boolean isBlocked() {
      return getState() == Thread.State.WAITING &amp;&amp; LockSupport.getBlocker(this) == future;
    }
  }

  static final class TimedWaiterThread extends Thread {
    private final AbstractFuture&lt;?&gt; future;
    private final long timeout;
    private final TimeUnit unit;
    private Exception exception;
    private volatile long startTime;
    private long timeSpentBlocked;

    TimedWaiterThread(AbstractFuture&lt;?&gt; future, long timeout, TimeUnit unit) {
      this.future = future;
      this.timeout = timeout;
      this.unit = unit;
    }

    @Override
    public void run() {
      startTime = System.nanoTime();
      try {
        future.get(timeout, unit);
      } catch (Exception e) {
        // nothing
        exception = e;
      } finally {
        timeSpentBlocked = System.nanoTime() - startTime;
      }
    }

    void awaitWaiting() {
      while (!isBlocked()) {
        if (getState() == State.TERMINATED) {
          throw new RuntimeException(&quot;Thread exited&quot;);
        }
        Thread.yield();
      }
    }

    private boolean isBlocked() {
      return getState() == Thread.State.TIMED_WAITING &amp;&amp; LockSupport.getBlocker(this) == future;
    }
  }

  private static final class PollingThread extends Thread {
    private final AbstractFuture&lt;?&gt; future;
    private final CountDownLatch completedIteration = new CountDownLatch(10);

    private PollingThread(AbstractFuture&lt;?&gt; future) {
      this.future = future;
    }

    @Override
    public void run() {
      while (true) {
        try {
          future.get(0, TimeUnit.SECONDS);
          return;
        } catch (InterruptedException | ExecutionException e) {
          return;
        } catch (TimeoutException e) {
          // do nothing
        } finally {
          completedIteration.countDown();
        }
      }
    }

    void awaitInLoop() {
      Uninterruptibles.awaitUninterruptibly(completedIteration);
    }
  }

  private static final class InterruptibleFuture extends AbstractFuture&lt;String&gt; {
    boolean interruptTaskWasCalled;

    @Override
    protected void interruptTask() {
      assertFalse(interruptTaskWasCalled);
      interruptTaskWasCalled = true;
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
