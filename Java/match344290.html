<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ObjectArraysTest.java &amp; AbstractFutureTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ObjectArraysTest.java &amp; AbstractFutureTest.java
      </h3>
<h1 align="center">
        15.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ObjectArraysTest.java (46.42857%)<th>AbstractFutureTest.java (9.333333%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(118-127)<td><a href="#" name="0">(207-216)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(129-135)<td><a href="#" name="1">(345-355)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(216-228)<td><a href="#" name="2">(1177-1184)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(74-80)<td><a href="#" name="3">(894-898)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(60-67)<td><a href="#" name="4">(82-90)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(186-190)<td><a href="#" name="5">(1053-1059)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(176-180)<td><a href="#" name="6">(965-970)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(171-175)<td><a href="#" name="7">(959-964)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(160-165)<td><a href="#" name="8">(931-936)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(44-50)<td><a href="#" name="9">(950-957)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(181-185)<td><a href="#" name="10">(1061-1065)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(166-170)<td><a href="#" name="11">(978-985)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(111-115)<td><a href="#" name="12">(945-950)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(103-107)<td><a href="#" name="13">(177-187)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(96-100)<td><a href="#" name="14">(128-133)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(68-73)<td><a href="#" name="15">(853-858)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(50-55)<td><a href="#" name="16">(633-637)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(17-27)<td><a href="#" name="17">(17-27)</a><td align="center"><font color="#990000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ObjectArraysTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.collect;
import static com.google.common.truth.Truth.assertThat;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.testing.NullPointerTester;
import java.io.Serializable;
import java.util.Arrays;
import java.util.List;
import</b></font> junit.framework.TestCase;
@GwtCompatible(emulated = true)
public class ObjectArraysTest extends TestCase {
  @GwtIncompatible   public void testNullPointerExceptions() {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicStaticMethods(ObjectArrays.class);
<a name="9"></a>  }
  @GwtIncompatible   public void testNewArray_fromClass_Empty() <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
    String[] empty = ObjectArrays.newArray(String.class, 0);
    assertEquals(String[].class, empty.getClass());
<a name="16"></a>    assertThat(empty).isEmpty();
  }
  <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@GwtIncompatible   public void testNewArray_fromClass_Nonempty() {
    String[] array = ObjectArrays.newArray(String.class, 2);
    assertEquals(String[].class, array.getClass());
    assertThat(array).hasLength(2);
    assertNull</b></font>(array[0]);
  }
<a name="4"></a>
  @GwtIncompatible   public void testNewArray_fromClass_OfArray() {
    String[][] array = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ObjectArrays.newArray(String[].class, 1);
    assertEquals(String[][].class, array.getClass());
    assertThat(array).hasLength(1);
    assertNull(array[0]);
  }
<a name="15"></a>
  public void testNewArray_fromArray_Empty() {
    String[] in = new String[0]</b></font>;
    String[] empty = <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ObjectArrays.newArray(in, 0);
    assertThat(empty).isEmpty();
  }
<a name="3"></a>
  public void testNewArray_fromArray_Nonempty() {
    String[] array = ObjectArrays.newArray</b></font>(new String[0], 2);
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(String[].class, array.getClass());
    assertThat(array).hasLength(2);
    assertNull(array[0]);
  }
  public void testNewArray_fromArray_OfArray() {
    String[][] array = ObjectArrays.newArray</b></font>(new String[0][0], 1);
    assertEquals(String[][].class, array.getClass());
    assertThat(array).hasLength(1);
    assertNull(array[0]);
  }
  @GwtIncompatible   public void testConcatEmptyEmpty() {
    String[] result = ObjectArrays.concat(new String[0], new String[0], String.class);
    assertEquals(String[].class, result.getClass());
    assertThat(result).isEmpty();
  }
<a name="14"></a>  @GwtIncompatible   public void testConcatEmptyNonempty() {
    String[] result = ObjectArrays.concat(new String[0], new String[] {"a", "b"}, String.class);
    <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly("a", "b").inOrder();
  }
<a name="13"></a>  @GwtIncompatible   public void testConcatNonemptyEmpty() {
    String[] result = ObjectArrays.concat(new String[] {"a", "b"}, new String[0], String.class);
    <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly("a", "b").inOrder();
  }
  @GwtIncompatibl</b></font>e <a name="12"></a>  public void testConcatBasic() {
    String[] result =
        ObjectArrays.concat(new String[] {"a", "b"}, new String[] {"c", "d"}, String.class);
    <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(String[].class, result.getClass());
    assertThat(result).asList().containsExactly("a", "b", "c", "d").inOrder();
  }
<a name="0"></a>  @GwtIncompatible   public void testConcatWithMoreGeneralType() {
    Serializable[] result = ObjectArrays.concat(new String[0], new String[0], Serializable.class);
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(Serializable[].class, result.getClass());
  }
  public void testToArrayImpl1() {
    doTestToArrayImpl1(Lists.&lt;Integer&gt;newArrayList());
    doTestToArrayImpl1(Lists.newArrayList(1));
    doTestToArrayImpl1(Lists.newArrayList(1, null, 3));
  }
<a name="1"></a>
  private void doTes</b></font>tToArrayImpl1(List&lt;Integer&gt; list) {
    Object[] reference = list.toArray();
    Object[] target = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ObjectArrays.toArrayImpl(list);
    assertEquals(reference.getClass(), target.getClass());
    assertTrue(Arrays.equals(reference, target));
  }
  public void testToArrayImpl2() {
    doTestToArrayImpl2(Lists.&lt;Integer&gt;newArrayList</b></font>(), new Integer[0], false);
    doTestToArrayImpl2(Lists.&lt;Integer&gt;newArrayList(), new Integer[1], true);
    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[0], false);
    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[1], true);
    doTestToArrayImpl2(Lists.newArrayList(1), new Integer[] {2, 3}, true);
    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[0], false);
    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[2], false);
    doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[3], true);
  }
  private void doTestToArrayImpl2(List&lt;Integer&gt; list, Integer[] array1, boolean expectModify) {
    Integer[] starting = Arrays.copyOf(array1, array1.length);
    Integer[] array2 = Arrays.copyOf(array1, array1.length);
    Object[] reference = list.toArray(array1);
    Object[] target = ObjectArrays.toArrayImpl(list, array2);
    assertEquals(reference.getClass(), target.getClass());
    assertTrue(Arrays.equals(reference, target));
    assertTrue(Arrays.equals(reference, target));
<a name="8"></a>
    Object[] expectedArray1 = expectModify ? reference : starting;
    Object[] expectedArray2 = expectModify ? target : starting;
    <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertTrue(Arrays.equals(expectedArray1, array1));
    assertTrue(Arrays.equals(expectedArray2, array2));
  }
<a name="11"></a>
  public void testPrependZeroElements() {
    String[] result = ObjectArrays.concat</b></font>("foo", new String[] {});
    <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().contains("foo");
  }
<a name="7"></a>
  public void testPrependOneElement() {
    String[] result = ObjectArrays.concat</b></font>("foo", new String[] {"bar"});
    <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().containsExactly("foo", "bar").inOrder();
  }
<a name="6"></a>
  public void testPrependTwoElements() {
    String[] result = ObjectArrays.concat</b></font>("foo", new String[] {"bar", "baz"});
    <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().containsExactly("foo", "bar", "baz").inOrder();
  }
<a name="10"></a>
  public void testAppendZeroElements() {
    String[] result = ObjectArrays.concat</b></font>(new String[] {}, "foo");
    <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().contains("foo");
  }
<a name="5"></a>
  public void testAppendOneElement() {
    String[] result = ObjectArrays.concat</b></font>(new String[] {"foo"}, "bar");
    <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().containsExactly("foo", "bar").inOrder();
  }
  public void testAppendTwoElements() {
    String[] result = ObjectArrays.concat</b></font>(new String[] {"foo", "bar"}, "baz");
    assertThat(result).asList().containsExactly("foo", "bar", "baz").inOrder();
  }
  public void testEmptyArrayToEmpty() {
    doTestNewArrayEquals(new Object[0], 0);
  }
  public void testEmptyArrayToNonEmpty() {
    checkArrayEquals(new Long[5], ObjectArrays.newArray(new Long[0], 5));
  }
  public void testNonEmptyToShorter() {
    checkArrayEquals(new String[9], ObjectArrays.newArray(new String[10], 9));
  }
  public void testNonEmptyToSameLength() {
    doTestNewArrayEquals(new String[10], 10);
  }
  public void testNonEmptyToLonger() {
    checkArrayEquals(
        new String[10], ObjectArrays.newArray(new String[] {"a", "b", "c", "d", "e"}, 10));
<a name="2"></a>  }
  private static void checkArrayEquals(Object[] expected, Object[] actual) {
    <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertTrue(
        "expected("
            + expected.getClass()
            + "): "
            + Arrays.toString(expected)
            + " actual("
            + actual.getClass()
            + "): "
            + Arrays.toString(actual),
        arrayEquals(expected, actual));
  }
  private static boolean arrayEquals(Object[] array1, Object[] array2</b></font>) {
    assertSame(array1.getClass(), array2.getClass());
    return Arrays.equals(array1, array2);
  }
  private static void doTestNewArrayEquals(Object[] expected, int length) {
    checkArrayEquals(expected, ObjectArrays.newArray(expected, length));
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractFutureTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.util.concurrent;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.Iterables;
import com.google.common.collect.Range;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
import</b></font> java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.LockSupport;
import junit.framework.AssertionFailedError;
import junit.framework.TestCase;
public class AbstractFutureTest extends TestCase {
  public void testSuccess() throws ExecutionException, InterruptedException {
    final Object value = new Object();
    assertSame(
        value,
        new AbstractFuture&lt;Object&gt;() {
          {
            set(value);
          }
        }.get());
  }
  public void testException() throws InterruptedException {
    final Throwable failure = new Throwable();
    AbstractFuture&lt;String&gt; future =
        new AbstractFuture&lt;String&gt;() {
          {
            setException(failure);
          }
        };
    ExecutionException ee1 = getExpectingExecutionException(future);
    ExecutionException ee2 = getExpectingExecutionException(future);
<a name="4"></a>        assertNotSame(ee1, ee2);
    <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(ee1).hasCauseThat().isSameInstanceAs(failure);
    assertThat(ee2).hasCauseThat().isSameInstanceAs(failure);
    checkStackTrace(ee1);
    checkStackTrace(ee2);
  }
  public void testCancel_notDoneNoInterrupt() throws Exception {
    InterruptibleFuture future = new InterruptibleFuture()</b></font>;
    assertTrue(future.cancel(false));
    assertTrue(future.isCancelled());
    assertTrue(future.isDone());
    assertFalse(future.wasInterrupted());
    assertFalse(future.interruptTaskWasCalled);
    try {
      future.get();
      fail("Expected CancellationException");
    } catch (CancellationException e) {
      assertThat(e).hasCauseThat().isNull();
    }
  }
  public void testCancel_notDoneInterrupt() throws Exception {
    InterruptibleFuture future = new InterruptibleFuture();
    assertTrue(future.cancel(true));
    assertTrue(future.isCancelled());
    assertTrue(future.isDone());
    assertTrue(future.wasInterrupted());
    assertTrue(future.interruptTaskWasCalled);
    try {
      future.get();
      fail("Expected CancellationException");
    } catch (CancellationException e) {
      assertThat(e).hasCauseThat().isNull();
    }
  }
  public void testCancel_done() throws Exception {
    AbstractFuture&lt;String&gt; future =
        new AbstractFuture&lt;String&gt;() {
          {
<a name="14"></a>            set("foo");
          }
        };
    <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertFalse(future.cancel(true));
    assertFalse(future.isCancelled());
    assertTrue(future.isDone());
  }
  public void testGetWithTimeo</b></font>utDoneFuture() throws Exception {
    AbstractFuture&lt;String&gt; future =
        new AbstractFuture&lt;String&gt;() {
          {
            set("foo");
          }
        };
    assertEquals("foo", future.get(0, TimeUnit.SECONDS));
  }
  public void testEvilFuture_setFuture() throws Exception {
    final RuntimeException exception = new RuntimeException("you didn't say the magic word!");
    AbstractFuture&lt;String&gt; evilFuture =
        new AbstractFuture&lt;String&gt;() {
          @Override
          public void addListener(Runnable r, Executor e) {
            throw exception;
          }
        };
    AbstractFuture&lt;String&gt; normalFuture = new AbstractFuture&lt;String&gt;() {};
    normalFuture.setFuture(evilFuture);
    assertTrue(normalFuture.isDone());
    try {
      normalFuture.get();
      fail();
    } catch (ExecutionException e) {
      assertThat(e).hasCauseThat().isSameInstanceAs(exception);
    }
  }
  public void testRemoveWaiter_interruption() throws Exception {
    final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    WaiterThread waiter1 = new WaiterThread(future);
    waiter1.start();
    waiter1.awaitWaiting();
    WaiterThread waiter2 = new WaiterThread(future);
    waiter2.start();
    waiter2.awaitWaiting();
<a name="13"></a>        waiter1.interrupt();
    <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>waiter1.join();
    waiter2.awaitWaiting(); 
    LockSupport.unpark(waiter2);     waiter2.awaitWaiting(); 
    future.set(null);
    waiter2.join();
  }
  public void testRemoveWa</b></font>iter_polling() throws Exception {
    final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    WaiterThread waiter = new WaiterThread(future);
    waiter.start();
    waiter.awaitWaiting();
    PollingThread poller = new PollingThread(future);
    poller.start();
    PollingThread poller2 = new PollingThread(future);
    poller2.start();
    PollingThread poller3 = new PollingThread(future);
    poller3.start();
    poller.awaitInLoop();
    poller2.awaitInLoop();
    poller3.awaitInLoop();
    waiter.interrupt();
<a name="0"></a>
    waiter.join();
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>future.set(null);
    poller.join();
  }
  public void testToString_allUnique() throws Exception {
    assertThat(SettableFuture.create().toString()).isNotEqualTo(SettableFuture.create().toString());
  }
  public void test</b></font>ToString_oom() throws Exception {
    SettableFuture&lt;Object&gt; future = SettableFuture.create();
    future.set(
        new Object() {
          @Override
          public String toString() {
            throw new OutOfMemoryError();
          }
          @Override
          public int hashCode() {
            throw new OutOfMemoryError();
          }
        });
    String unused = future.toString();
    SettableFuture&lt;Object&gt; future2 = SettableFuture.create();
    Object object =
        new Object() {
          @Override
          public String toString() {
            return new String(new char[50_000]);
          }
        };
    List&lt;Object&gt; list = Collections.singletonList(object);
    for (int i = 0; i &lt; 10; i++) {
      Object[] array = new Object[500];
      Arrays.fill(array, list);
      list = Arrays.asList(array);
    }
    future2.set(list);
    unused = future.toString();
  }
  public void testToString_notDone() throws Exception {
    AbstractFuture&lt;Object&gt; testFuture =
        new AbstractFuture&lt;Object&gt;() {
          @Override
          public String pendingToString() {
            return "cause=[Because this test isn't done]";
          }
        };
    assertThat(testFuture.toString())
        .matches(
            "[^\\[]+\\[status=PENDING, info=\\[cause=\\[Because this test isn't done\\]\\]\\]");
    try {
      testFuture.get(1, TimeUnit.NANOSECONDS);
      fail();
    } catch (TimeoutException e) {
      assertThat(e.getMessage()).contains("1 nanoseconds");
      assertThat(e.getMessage()).contains("Because this test isn't done");
    }
  }
  public void testToString_completesDuringToString() throws Exception {
    AbstractFuture&lt;Object&gt; testFuture =
        new AbstractFuture&lt;Object&gt;() {
          @Override
          public String pendingToString() {
            this.set(true);
            return "cause=[Because this test isn't done]";
          }
        };
    assertThat(testFuture.toString())
        .matches("[^\\[]+\\[status=SUCCESS, result=\\[java.lang.Boolean@\\w+\\]\\]");
  }
  @SuppressWarnings({"DeprecatedThreadMethods", "ThreadPriorityCheck"})
  @AndroidIncompatible   public void testToString_delayedTimeout() throws Exception {
    TimedWaiterThread thread =
        new TimedWaiterThread(new AbstractFuture&lt;Object&gt;() {}, 2, TimeUnit.SECONDS);
    thread.start();
    thread.awaitWaiting();
    thread.suspend();
    long toWaitMillis = 3500 - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - thread.startTime);
    Thread.sleep(toWaitMillis);
    thread.setPriority(Thread.MAX_PRIORITY);
    thread.resume();
    thread.join();
    boolean longWait = TimeUnit.NANOSECONDS.toSeconds(thread.timeSpentBlocked) &gt;= 5;
    char overWaitNanosFirstDigit =
        Long.toString(
                thread.timeSpentBlocked - TimeUnit.MILLISECONDS.toNanos(longWait ? 5000 : 3000))
            .charAt(0);
    if (overWaitNanosFirstDigit &lt; '4') {
      overWaitNanosFirstDigit = '9';
    }
    String nanosRegex = "[4-" + overWaitNanosFirstDigit + "][0-9]+";
    assertWithMessage(
            "Spent " + thread.timeSpentBlocked + " ns blocked; slept for " + toWaitMillis + " ms")
        .that(thread.exception)
        .hasMessageThat()
        .matches(
            "Waited 2 seconds \\(plus "
                + (longWait ? "3" : "1")
                + " seconds, "
                + nanosRegex
                + " nanoseconds delay\\).*");
  }
  public void testToString_completed() throws Exception {
    AbstractFuture&lt;Object&gt; testFuture2 =
        new AbstractFuture&lt;Object&gt;() {
          @Override
          public String pendingToString() {
            return "cause=[Someday...]";
          }
<a name="1"></a>        };
    AbstractFuture&lt;Object&gt; testFuture3 = new AbstractFuture&lt;Object&gt;() {};
    testFuture3.setFuture(testFuture2);
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(testFuture3.toString())
        .matches(
            "[^\\[]+\\[status=PENDING, setFuture=\\[[^\\[]+\\[status=PENDING,"
                + " info=\\[cause=\\[Someday...]]]]]");
    testFuture2.set("result string");
    assertThat(testFuture3.toString())
        .matches("[^\\[]+\\[status=SUCCESS, result=\\[java.lang.String@\\w+\\]\\]");
  }
  public void testToString_cancelled() throws Exception {
    assertThat</b></font>(Futures.immediateCancelledFuture().toString())
        .matches("[^\\[]+\\[status=CANCELLED\\]");
  }
  public void testToString_failed() {
    assertThat(Futures.immediateFailedFuture(new RuntimeException("foo")).toString())
        .matches("[^\\[]+\\[status=FAILURE, cause=\\[java.lang.RuntimeException: foo\\]\\]");
  }
  public void testToString_misbehaving() throws Exception {
    assertThat(
            new AbstractFuture&lt;Object&gt;() {
              @Override
              public String pendingToString() {
                throw new RuntimeException("I'm a misbehaving implementation");
              }
            }.toString())
        .matches(
            "[^\\[]+\\[status=PENDING, info=\\[Exception thrown from implementation: "
                + "class java.lang.RuntimeException\\]\\]");
  }
  public void testCompletionFinishesWithDone() {
    ExecutorService executor = Executors.newFixedThreadPool(10);
    for (int i = 0; i &lt; 50000; i++) {
      final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
      final AtomicReference&lt;String&gt; errorMessage = Atomics.newReference();
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              future.set("success");
              if (!future.isDone()) {
                errorMessage.set("Set call exited before future was complete.");
              }
            }
          });
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              future.setException(new IllegalArgumentException("failure"));
              if (!future.isDone()) {
                errorMessage.set("SetException call exited before future was complete.");
              }
            }
          });
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              future.cancel(true);
              if (!future.isDone()) {
                errorMessage.set("Cancel call exited before future was complete.");
              }
            }
          });
      try {
        future.get();
      } catch (Throwable t) {
      }
      String error = errorMessage.get();
      assertNull(error, error);
    }
    executor.shutdown();
  }
  public void testFutureBash() {
    final CyclicBarrier barrier =
        new CyclicBarrier(
            6                 + 50                 + 50                 + 1);     final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
    final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
    final AtomicInteger numSuccessfulSetCalls = new AtomicInteger();
    Callable&lt;Void&gt; completeSuccessfullyRunnable =
        new Callable&lt;Void&gt;() {
          @Override
          public Void call() {
            if (currentFuture.get().set("set")) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; completeExceptionallyRunnable =
        new Callable&lt;Void&gt;() {
          Exception failureCause = new Exception("setException");
          @Override
          public Void call() {
            if (currentFuture.get().setException(failureCause)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; cancelRunnable =
        new Callable&lt;Void&gt;() {
          @Override
          public Void call() {
            if (currentFuture.get().cancel(true)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; setFutureCompleteSuccessfullyRunnable =
        new Callable&lt;Void&gt;() {
          ListenableFuture&lt;String&gt; future = Futures.immediateFuture("setFuture");
          @Override
          public Void call() {
            if (currentFuture.get().setFuture(future)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; setFutureCompleteExceptionallyRunnable =
        new Callable&lt;Void&gt;() {
          ListenableFuture&lt;String&gt; future =
              Futures.immediateFailedFuture(new Exception("setFuture"));
          @Override
          public Void call() {
            if (currentFuture.get().setFuture(future)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; setFutureCancelRunnable =
        new Callable&lt;Void&gt;() {
          ListenableFuture&lt;String&gt; future = Futures.immediateCancelledFuture();
          @Override
          public Void call() {
            if (currentFuture.get().setFuture(future)) {
              numSuccessfulSetCalls.incrementAndGet();
            }
            awaitUnchecked(barrier);
            return null;
          }
        };
    final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
    Runnable collectResultsRunnable =
        new Runnable() {
          @Override
          public void run() {
            try {
              String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
              finalResults.add(result);
            } catch (ExecutionException e) {
              finalResults.add(e.getCause());
            } catch (CancellationException e) {
              finalResults.add(CancellationException.class);
            } finally {
              awaitUnchecked(barrier);
            }
          }
        };
    Runnable collectResultsTimedGetRunnable =
        new Runnable() {
          @Override
          public void run() {
            Future&lt;String&gt; future = currentFuture.get();
            while (true) {
              try {
                String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);
                finalResults.add(result);
                break;
              } catch (ExecutionException e) {
                finalResults.add(e.getCause());
                break;
              } catch (CancellationException e) {
                finalResults.add(CancellationException.class);
                break;
              } catch (TimeoutException e) {
              }
            }
            awaitUnchecked(barrier);
          }
        };
    List&lt;Callable&lt;?&gt;&gt; allTasks = new ArrayList&lt;&gt;();
    allTasks.add(completeSuccessfullyRunnable);
    allTasks.add(completeExceptionallyRunnable);
    allTasks.add(cancelRunnable);
    allTasks.add(setFutureCompleteSuccessfullyRunnable);
    allTasks.add(setFutureCompleteExceptionallyRunnable);
    allTasks.add(setFutureCancelRunnable);
    for (int k = 0; k &lt; 50; k++) {
      final Runnable listener =
          k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;
      allTasks.add(Executors.callable(listener));
      allTasks.add(
          new Callable&lt;Void&gt;() {
            @Override
            public Void call() throws Exception {
              currentFuture.get().addListener(listener, executor);
              return null;
            }
          });
    }
    assertEquals(allTasks.size() + 1, barrier.getParties());
    for (int i = 0; i &lt; 1000; i++) {
      Collections.shuffle(allTasks);
      final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
      currentFuture.set(future);
      for (Callable&lt;?&gt; task : allTasks) {
        @SuppressWarnings("unused")         Future&lt;?&gt; possiblyIgnoredError = executor.submit(task);
      }
      awaitUnchecked(barrier);
      assertThat(future.isDone()).isTrue();
      Object result = Iterables.getOnlyElement(finalResults);
      if (result == CancellationException.class) {
        assertTrue(future.isCancelled());
        if (future.wasInterrupted()) {
          assertThat(numSuccessfulSetCalls.get()).isIn(Range.closed(1, 2));
        } else {
          assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);
        }
      } else {
        assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);
      }
      numSuccessfulSetCalls.set(0);
      finalResults.clear();
    }
    executor.shutdown();
  }
  public void testSetFutureCancelBash() {
    final int size = 50;
    final CyclicBarrier barrier =
        new CyclicBarrier(
            2                 + size                 + size                 + 1);     final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
    final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
    final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; setFutureFuture = Atomics.newReference();
    final AtomicBoolean setFutureSetSuccess = new AtomicBoolean();
    final AtomicBoolean setFutureCompletionSuccess = new AtomicBoolean();
    final AtomicBoolean cancellationSuccess = new AtomicBoolean();
    Runnable cancelRunnable =
        new Runnable() {
          @Override
          public void run() {
            cancellationSuccess.set(currentFuture.get().cancel(true));
            awaitUnchecked(barrier);
          }
<a name="16"></a>        };
    Runnable setFutureCompleteSuccessfullyRunnable =
        new Runnable() {
          <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
          public void run() {
            AbstractFuture&lt;String&gt; future = setFutureFuture.get();
            setFutureSetSuccess.set(currentFuture.get().setFuture(future));
            setFutureCompletionSuccess.set(future.set</b></font>("hello-async-world"));
            awaitUnchecked(barrier);
          }
        };
    final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
    Runnable collectResultsRunnable =
        new Runnable() {
          @Override
          public void run() {
            try {
              String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
              finalResults.add(result);
            } catch (ExecutionException e) {
              finalResults.add(e.getCause());
            } catch (CancellationException e) {
              finalResults.add(CancellationException.class);
            } finally {
              awaitUnchecked(barrier);
            }
          }
        };
    Runnable collectResultsTimedGetRunnable =
        new Runnable() {
          @Override
          public void run() {
            Future&lt;String&gt; future = currentFuture.get();
            while (true) {
              try {
                String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);
                finalResults.add(result);
                break;
              } catch (ExecutionException e) {
                finalResults.add(e.getCause());
                break;
              } catch (CancellationException e) {
                finalResults.add(CancellationException.class);
                break;
              } catch (TimeoutException e) {
              }
            }
            awaitUnchecked(barrier);
          }
        };
    List&lt;Runnable&gt; allTasks = new ArrayList&lt;&gt;();
    allTasks.add(cancelRunnable);
    allTasks.add(setFutureCompleteSuccessfullyRunnable);
    for (int k = 0; k &lt; size; k++) {
      final Runnable listener =
          k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;
      allTasks.add(listener);
      allTasks.add(
          new Runnable() {
            @Override
            public void run() {
              currentFuture.get().addListener(listener, executor);
            }
          });
    }
    assertEquals(allTasks.size() + 1, barrier.getParties());     for (int i = 0; i &lt; 1000; i++) {
      Collections.shuffle(allTasks);
      final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
      final AbstractFuture&lt;String&gt; setFuture = new AbstractFuture&lt;String&gt;() {};
      currentFuture.set(future);
      setFutureFuture.set(setFuture);
      for (Runnable task : allTasks) {
        executor.execute(task);
      }
      awaitUnchecked(barrier);
      assertThat(future.isDone()).isTrue();
      Object result = Iterables.getOnlyElement(finalResults);
      if (result == CancellationException.class) {
        assertTrue(future.isCancelled());
        assertTrue(cancellationSuccess.get());
        if (!setFutureSetSuccess.get() || !setFutureCompletionSuccess.get()) {
          assertTrue(setFuture.isCancelled());
          assertTrue(setFuture.wasInterrupted());         }
      } else {
        assertFalse(cancellationSuccess.get());
        assertTrue(setFutureSetSuccess.get());
        assertTrue(setFutureCompletionSuccess.get());
      }
      setFutureSetSuccess.set(false);
      setFutureCompletionSuccess.set(false);
      cancellationSuccess.set(false);
      finalResults.clear();
    }
    executor.shutdown();
  }
  public void testSetFutureCancelBash_withDoneFuture() {
    final CyclicBarrier barrier =
        new CyclicBarrier(
            2                 + 1                 + 1);     final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
    final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
    final AtomicBoolean setFutureSuccess = new AtomicBoolean();
    final AtomicBoolean cancellationSuccess = new AtomicBoolean();
    Callable&lt;Void&gt; cancelRunnable =
        new Callable&lt;Void&gt;() {
          @Override
          public Void call() {
            cancellationSuccess.set(currentFuture.get().cancel(true));
            awaitUnchecked(barrier);
            return null;
          }
        };
    Callable&lt;Void&gt; setFutureCompleteSuccessfullyRunnable =
        new Callable&lt;Void&gt;() {
          final ListenableFuture&lt;String&gt; future = Futures.immediateFuture("hello");
          @Override
          public Void call() {
            setFutureSuccess.set(currentFuture.get().setFuture(future));
            awaitUnchecked(barrier);
            return null;
          }
        };
    final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
    final Runnable collectResultsRunnable =
        new Runnable() {
          @Override
          public void run() {
            try {
              String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
              finalResults.add(result);
            } catch (ExecutionException e) {
              finalResults.add(e.getCause());
            } catch (CancellationException e) {
              finalResults.add(CancellationException.class);
            } finally {
              awaitUnchecked(barrier);
            }
          }
        };
    List&lt;Callable&lt;?&gt;&gt; allTasks = new ArrayList&lt;&gt;();
    allTasks.add(cancelRunnable);
    allTasks.add(setFutureCompleteSuccessfullyRunnable);
    allTasks.add(Executors.callable(collectResultsRunnable));
    assertEquals(allTasks.size() + 1, barrier.getParties());     for (int i = 0; i &lt; 1000; i++) {
      Collections.shuffle(allTasks);
      final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
      currentFuture.set(future);
      for (Callable&lt;?&gt; task : allTasks) {
        @SuppressWarnings("unused")         Future&lt;?&gt; possiblyIgnoredError = executor.submit(task);
      }
      awaitUnchecked(barrier);
      assertThat(future.isDone()).isTrue();
      Object result = Iterables.getOnlyElement(finalResults);
      if (result == CancellationException.class) {
        assertTrue(future.isCancelled());
        assertTrue(cancellationSuccess.get());
        assertFalse(setFutureSuccess.get());
      } else {
        assertTrue(setFutureSuccess.get());
        assertFalse(cancellationSuccess.get());
      }
      setFutureSuccess.set(false);
      cancellationSuccess.set(false);
      finalResults.clear();
    }
    executor.shutdown();
  }
  public void testSetFuture_stackOverflow() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create();
    SettableFuture&lt;String&gt; prev = orig;
    for (int i = 0; i &lt; 100000; i++) {
      SettableFuture&lt;String&gt; curr = SettableFuture.create();
      prev.setFuture(curr);
      prev = curr;
    }
    prev.set("done");
    assertTrue(orig.isDone());
  }
  @GwtIncompatible
  @AndroidIncompatible
  public void testSetFutureToString_stackOverflow() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create();
    SettableFuture&lt;String&gt; prev = orig;
    for (int i = 0; i &lt; 100000; i++) {
      SettableFuture&lt;String&gt; curr = SettableFuture.create();
      prev.setFuture(curr);
<a name="15"></a>      prev = curr;
    }
    <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(orig.toString())
        .contains("Exception thrown from implementation: class java.lang.StackOverflowError");
  }
  public void testSetFuture_misbehavingFutureThrows() throws Exception {
    SettableFuture&lt;String&gt; future = SettableFuture.create</b></font>();
    ListenableFuture&lt;String&gt; badFuture =
        new ListenableFuture&lt;String&gt;() {
          @Override
          public boolean cancel(boolean interrupt) {
            return false;
          }
          @Override
          public boolean isDone() {
            return true;
          }
          @Override
          public boolean isCancelled() {
            return false;           }
          @Override
          public String get() {
            throw new CancellationException();           }
          @Override
          public String get(long time, TimeUnit unit) {
            throw new CancellationException();           }
          @Override
          public void addListener(Runnable runnable, Executor executor) {
            executor.execute(runnable);
          }
        };
<a name="3"></a>    future.setFuture(badFuture);
    ExecutionException expected = getExpectingExecutionException(future);
    assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(expected).hasCauseThat().hasMessageThat().contains(badFuture.toString());
  }
  public void testSetFuture_misbehavingFutureDoesNotThrow() throws Exception {
    SettableFuture&lt;String&gt; future = SettableFuture.create</b></font>();
    ListenableFuture&lt;String&gt; badFuture =
        new ListenableFuture&lt;String&gt;() {
          @Override
          public boolean cancel(boolean interrupt) {
            return false;
          }
          @Override
          public boolean isDone() {
            return true;
          }
          @Override
          public boolean isCancelled() {
            return true;           }
          @Override
          public String get() {
            return "foo";           }
          @Override
          public String get(long time, TimeUnit unit) {
            return "foo";           }
          @Override
          public void addListener(Runnable runnable, Executor executor) {
<a name="8"></a>            executor.execute(runnable);
          }
        };
    <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>future.setFuture(badFuture);
    assertThat(future.isCancelled()).isTrue();
  }
  public void testCancel_stackOverflow() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create</b></font>();
    SettableFuture&lt;String&gt; prev = orig;
    for (int i = 0; i &lt; 100000; i++) {
      SettableFuture&lt;String&gt; curr = SettableFuture.create();
      prev.setFuture(curr);
      prev = curr;
<a name="12"></a>    }
    orig.cancel(true);
    <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(orig.isCancelled());
    assertTrue(prev.isCancelled());
<a name="9"></a>    assertTrue(prev.wasInterrupted());
  }
  public void testSetFutur</b></font>eSelf_cancel() <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
    SettableFuture&lt;String&gt; orig = SettableFuture.create();
    orig.setFuture(orig);
    orig.cancel(true);
    assertTrue(orig.isCancelled());
  }
<a name="7"></a>
  public void testSetFutureS</b></font>elf_toString() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create();
    <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>orig.setFuture(orig);
    assertThat(orig.toString()).contains("[status=PENDING, setFuture=[this future]]");
  }
<a name="6"></a>
  public void testSetSelf_toString() {
    SettableFuture&lt;Object&gt; orig = SettableFuture.create</b></font>();
    <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>orig.set(orig);
    assertThat(orig.toString()).contains("[status=SUCCESS, result=[this future]]");
  }
  public void testSetFutureSelf_toStringException() {
    SettableFuture&lt;String&gt; orig = SettableFuture.create</b></font>();
    orig.setFuture(
        new AbstractFuture&lt;String&gt;() {
          @Override
          public String toString() {
<a name="11"></a>            throw new NullPointerException();
          }
        });
    <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(orig.toString())
        .contains(
            "[status=PENDING, setFuture=[Exception thrown from implementation: class"
                + " java.lang.NullPointerException]]");
  }
  public void testSetIndirectSelf_toString() {
    final SettableFuture&lt;Object&gt; orig = SettableFuture.create</b></font>();
    orig.setFuture(
        new ForwardingListenableFuture&lt;Object&gt;() {
          @Override
          protected ListenableFuture&lt;Object&gt; delegate() {
            return orig;
          }
        });
    assertThat(orig.toString())
        .contains("Exception thrown from implementation: class java.lang.StackOverflowError");
  }
  public void testListenersExecuteImmediately_fromAfterDone() {
    AbstractFuture&lt;String&gt; f =
        new AbstractFuture&lt;String&gt;() {
          @Override
          protected void afterDone() {
            final AtomicBoolean ranImmediately = new AtomicBoolean();
            addListener(
                new Runnable() {
                  @Override
                  public void run() {
                    ranImmediately.set(true);
                  }
                },
                MoreExecutors.directExecutor());
            assertThat(ranImmediately.get()).isTrue();
          }
        };
    f.set("foo");
  }
  public void testListenersExecuteImmediately_afterWaiterWakesUp() throws Exception {
    final AbstractFuture&lt;String&gt; f =
        new AbstractFuture&lt;String&gt;() {
          @Override
          protected void afterDone() {
            try {
              Thread.sleep(TimeUnit.SECONDS.toMillis(10));
            } catch (InterruptedException ignored) {
              Thread.currentThread().interrupt();             }
          }
        };
    Thread t =
        new Thread() {
          @Override
          public void run() {
            f.set("foo");
          }
        };
    t.start();
    f.get();
    final AtomicBoolean ranImmediately = new AtomicBoolean();
    f.addListener(
        new Runnable() {
          @Override
          public void run() {
            ranImmediately.set(true);
<a name="5"></a>          }
        },
        MoreExecutors.directExecutor());
    <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(ranImmediately.get()).isTrue();
    t.interrupt();
    t.join();
  }
<a name="10"></a>  public void testTrustedGetFailure_Completed() {
    SettableFuture&lt;String&gt; future = SettableFuture.create</b></font>();
    future.set("261");
    <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }
  public void testTrustedGetFailure_Failed() {
    SettableFuture&lt;String&gt; future = SettableFuture.create</b></font>();
    Throwable failure = new Throwable();
    future.setException(failure);
    assertThat(future.tryInternalFastPathGetFailure()).isEqualTo(failure);
  }
  public void testTrustedGetFailure_NotCompleted() {
    SettableFuture&lt;String&gt; future = SettableFuture.create();
    assertThat(future.isDone()).isFalse();
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }
  public void testTrustedGetFailure_CanceledNoCause() {
    SettableFuture&lt;String&gt; future = SettableFuture.create();
    future.cancel(false);
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }
  public void testGetFailure_Completed() {
    AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    future.set("261");
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }
  public void testGetFailure_Failed() {
    AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    final Throwable failure = new Throwable();
    future.setException(failure);
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }
  public void testGetFailure_NotCompleted() {
    AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    assertThat(future.isDone()).isFalse();
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }
  public void testGetFailure_CanceledNoCause() {
    AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
    future.cancel(false);
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }
  public void testForwardExceptionFastPath() throws Exception {
    class FailFuture extends InternalFutureFailureAccess implements ListenableFuture&lt;String&gt; {
      Throwable failure;
      FailFuture(Throwable throwable) {
        failure = throwable;
      }
      @Override
      public boolean cancel(boolean mayInterruptIfRunning) {
        throw new AssertionFailedError("cancel shouldn't be called on this object");
      }
      @Override
      public boolean isCancelled() {
        return false;
      }
      @Override
      public boolean isDone() {
        return true;
      }
      @Override
      public String get() throws InterruptedException, ExecutionException {
        throw new AssertionFailedError("get() shouldn't be called on this object");
      }
      @Override
      public String get(long timeout, TimeUnit unit)
          throws InterruptedException, ExecutionException, TimeoutException {
        return get();
      }
      @Override
      protected Throwable tryInternalFastPathGetFailure() {
        return failure;
      }
      @Override
      public void addListener(Runnable listener, Executor executor) {
        throw new AssertionFailedError("addListener() shouldn't be called on this object");
      }
    }
    final RuntimeException exception = new RuntimeException("you still didn't say the magic word!");
    SettableFuture&lt;String&gt; normalFuture = SettableFuture.create();
    normalFuture.setFuture(new FailFuture(exception));
    assertTrue(normalFuture.isDone());
    try {
      normalFuture.get();
      fail();
    } catch (ExecutionException e) {
      assertSame(exception, e.getCause());
    }
  }
  private static void awaitUnchecked(final CyclicBarrier barrier) {
    try {
      barrier.await();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }
  private void checkStackTrace(ExecutionException e) {
<a name="2"></a>        int index = findStackFrame(e, getClass().getName(), "getExpectingExecutionException");
    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(index).isNotEqualTo(0);
    assertThat(e.getStackTrace()[index - 1].getMethodName()).isEqualTo("get");
  }
  private static int findStackFrame(ExecutionException e, String clazz</b></font>, String method) {
    StackTraceElement[] elements = e.getStackTrace();
    for (int i = 0; i &lt; elements.length; i++) {
      StackTraceElement element = elements[i];
      if (element.getClassName().equals(clazz) &amp;&amp; element.getMethodName().equals(method)) {
        return i;
      }
    }
    AssertionFailedError failure =
        new AssertionFailedError(
            "Expected element " + clazz + "." + method + " not found in stack trace");
    failure.initCause(e);
    throw failure;
  }
  private ExecutionException getExpectingExecutionException(AbstractFuture&lt;String&gt; future)
      throws InterruptedException {
    try {
      String got = future.get();
      fail("Expected exception but got " + got);
    } catch (ExecutionException e) {
      return e;
    }
    return null;
  }
  private static final class WaiterThread extends Thread {
    private final AbstractFuture&lt;?&gt; future;
    private WaiterThread(AbstractFuture&lt;?&gt; future) {
      this.future = future;
    }
    @Override
    public void run() {
      try {
        future.get();
      } catch (Exception e) {
      }
    }
    void awaitWaiting() {
      while (!isBlocked()) {
        if (getState() == State.TERMINATED) {
          throw new RuntimeException("Thread exited");
        }
        Thread.yield();
      }
    }
    private boolean isBlocked() {
      return getState() == Thread.State.WAITING &amp;&amp; LockSupport.getBlocker(this) == future;
    }
  }
  static final class TimedWaiterThread extends Thread {
    private final AbstractFuture&lt;?&gt; future;
    private final long timeout;
    private final TimeUnit unit;
    private Exception exception;
    private volatile long startTime;
    private long timeSpentBlocked;
    TimedWaiterThread(AbstractFuture&lt;?&gt; future, long timeout, TimeUnit unit) {
      this.future = future;
      this.timeout = timeout;
      this.unit = unit;
    }
    @Override
    public void run() {
      startTime = System.nanoTime();
      try {
        future.get(timeout, unit);
      } catch (Exception e) {
        exception = e;
      } finally {
        timeSpentBlocked = System.nanoTime() - startTime;
      }
    }
    void awaitWaiting() {
      while (!isBlocked()) {
        if (getState() == State.TERMINATED) {
          throw new RuntimeException("Thread exited");
        }
        Thread.yield();
      }
    }
    private boolean isBlocked() {
      return getState() == Thread.State.TIMED_WAITING &amp;&amp; LockSupport.getBlocker(this) == future;
    }
  }
  private static final class PollingThread extends Thread {
    private final AbstractFuture&lt;?&gt; future;
    private final CountDownLatch completedIteration = new CountDownLatch(10);
    private PollingThread(AbstractFuture&lt;?&gt; future) {
      this.future = future;
    }
    @Override
    public void run() {
      while (true) {
        try {
          future.get(0, TimeUnit.SECONDS);
          return;
        } catch (InterruptedException | ExecutionException e) {
          return;
        } catch (TimeoutException e) {
        } finally {
          completedIteration.countDown();
        }
      }
    }
    void awaitInLoop() {
      Uninterruptibles.awaitUninterruptibly(completedIteration);
    }
  }
  private static final class InterruptibleFuture extends AbstractFuture&lt;String&gt; {
    boolean interruptTaskWasCalled;
    @Override
    protected void interruptTask() {
      assertFalse(interruptTaskWasCalled);
      interruptTaskWasCalled = true;
    }
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
