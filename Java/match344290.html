<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ObjectArraysTest.java &amp; AbstractFutureTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ObjectArraysTest.java &amp; AbstractFutureTest.java
      </h3>
<h1 align="center">
        15.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ObjectArraysTest.java (46.42857%)<th>AbstractFutureTest.java (9.333333%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(118-127)<td><a href="#" name="0">(207-216)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(129-135)<td><a href="#" name="1">(345-355)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(216-228)<td><a href="#" name="2">(1177-1184)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(74-80)<td><a href="#" name="3">(894-898)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(60-67)<td><a href="#" name="4">(82-90)</a><td align="center"><font color="#bb0000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(186-190)<td><a href="#" name="5">(1053-1059)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(176-180)<td><a href="#" name="6">(965-970)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(171-175)<td><a href="#" name="7">(959-964)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(160-165)<td><a href="#" name="8">(931-936)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(44-50)<td><a href="#" name="9">(950-957)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(181-185)<td><a href="#" name="10">(1061-1065)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(166-170)<td><a href="#" name="11">(978-985)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(111-115)<td><a href="#" name="12">(945-950)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(103-107)<td><a href="#" name="13">(177-187)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(96-100)<td><a href="#" name="14">(128-133)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(68-73)<td><a href="#" name="15">(853-858)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(50-55)<td><a href="#" name="16">(633-637)</a><td align="center"><font color="#990000">9</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(17-27)<td><a href="#" name="17">(17-27)</a><td align="center"><font color="#990000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ObjectArraysTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.collect;
2 import static com.google.common.truth.Truth.assertThat;
3 import com.google.common.annotations.GwtCompatible;
4 import com.google.common.annotations.GwtIncompatible;
5 import com.google.common.testing.NullPointerTester;
6 import java.io.Serializable;
7 import java.util.Arrays;
8 import java.util.List;
9 import</b></font> junit.framework.TestCase;
10 @GwtCompatible(emulated = true)
11 public class ObjectArraysTest extends TestCase {
12   @GwtIncompatible   public void testNullPointerExceptions() {
13     NullPointerTester tester = new NullPointerTester();
14     tester.testAllPublicStaticMethods(ObjectArrays.class);
15 <a name="9"></a>  }
16   @GwtIncompatible   public void testNewArray_fromClass_Empty() <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
17     String[] empty = ObjectArrays.newArray(String.class, 0);
18     assertEquals(String[].class, empty.getClass());
19 <a name="16"></a>    assertThat(empty).isEmpty();
20   }
21   <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@GwtIncompatible   public void testNewArray_fromClass_Nonempty() {
22     String[] array = ObjectArrays.newArray(String.class, 2);
23     assertEquals(String[].class, array.getClass());
24     assertThat(array).hasLength(2);
25     assertNull</b></font>(array[0]);
26   }
27 <a name="4"></a>
28   @GwtIncompatible   public void testNewArray_fromClass_OfArray() {
29     String[][] array = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ObjectArrays.newArray(String[].class, 1);
30     assertEquals(String[][].class, array.getClass());
31     assertThat(array).hasLength(1);
32     assertNull(array[0]);
33   }
34 <a name="15"></a>
35   public void testNewArray_fromArray_Empty() {
36     String[] in = new String[0]</b></font>;
37     String[] empty = <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ObjectArrays.newArray(in, 0);
38     assertThat(empty).isEmpty();
39   }
40 <a name="3"></a>
41   public void testNewArray_fromArray_Nonempty() {
42     String[] array = ObjectArrays.newArray</b></font>(new String[0], 2);
43     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(String[].class, array.getClass());
44     assertThat(array).hasLength(2);
45     assertNull(array[0]);
46   }
47   public void testNewArray_fromArray_OfArray() {
48     String[][] array = ObjectArrays.newArray</b></font>(new String[0][0], 1);
49     assertEquals(String[][].class, array.getClass());
50     assertThat(array).hasLength(1);
51     assertNull(array[0]);
52   }
53   @GwtIncompatible   public void testConcatEmptyEmpty() {
54     String[] result = ObjectArrays.concat(new String[0], new String[0], String.class);
55     assertEquals(String[].class, result.getClass());
56     assertThat(result).isEmpty();
57   }
58 <a name="14"></a>  @GwtIncompatible   public void testConcatEmptyNonempty() {
59     String[] result = ObjectArrays.concat(new String[0], new String[] {"a", "b"}, String.class);
60     <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(String[].class, result.getClass());
61     assertThat(result).asList().containsExactly("a", "b").inOrder();
62   }
63 <a name="13"></a>  @GwtIncompatible   public void testConcatNonemptyEmpty() {
64     String[] result = ObjectArrays.concat(new String[] {"a", "b"}, new String[0], String.class);
65     <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(String[].class, result.getClass());
66     assertThat(result).asList().containsExactly("a", "b").inOrder();
67   }
68   @GwtIncompatibl</b></font>e <a name="12"></a>  public void testConcatBasic() {
69     String[] result =
70         ObjectArrays.concat(new String[] {"a", "b"}, new String[] {"c", "d"}, String.class);
71     <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(String[].class, result.getClass());
72     assertThat(result).asList().containsExactly("a", "b", "c", "d").inOrder();
73   }
74 <a name="0"></a>  @GwtIncompatible   public void testConcatWithMoreGeneralType() {
75     Serializable[] result = ObjectArrays.concat(new String[0], new String[0], Serializable.class);
76     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(Serializable[].class, result.getClass());
77   }
78   public void testToArrayImpl1() {
79     doTestToArrayImpl1(Lists.&lt;Integer&gt;newArrayList());
80     doTestToArrayImpl1(Lists.newArrayList(1));
81     doTestToArrayImpl1(Lists.newArrayList(1, null, 3));
82   }
83 <a name="1"></a>
84   private void doTes</b></font>tToArrayImpl1(List&lt;Integer&gt; list) {
85     Object[] reference = list.toArray();
86     Object[] target = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ObjectArrays.toArrayImpl(list);
87     assertEquals(reference.getClass(), target.getClass());
88     assertTrue(Arrays.equals(reference, target));
89   }
90   public void testToArrayImpl2() {
91     doTestToArrayImpl2(Lists.&lt;Integer&gt;newArrayList</b></font>(), new Integer[0], false);
92     doTestToArrayImpl2(Lists.&lt;Integer&gt;newArrayList(), new Integer[1], true);
93     doTestToArrayImpl2(Lists.newArrayList(1), new Integer[0], false);
94     doTestToArrayImpl2(Lists.newArrayList(1), new Integer[1], true);
95     doTestToArrayImpl2(Lists.newArrayList(1), new Integer[] {2, 3}, true);
96     doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[0], false);
97     doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[2], false);
98     doTestToArrayImpl2(Lists.newArrayList(1, null, 3), new Integer[3], true);
99   }
100   private void doTestToArrayImpl2(List&lt;Integer&gt; list, Integer[] array1, boolean expectModify) {
101     Integer[] starting = Arrays.copyOf(array1, array1.length);
102     Integer[] array2 = Arrays.copyOf(array1, array1.length);
103     Object[] reference = list.toArray(array1);
104     Object[] target = ObjectArrays.toArrayImpl(list, array2);
105     assertEquals(reference.getClass(), target.getClass());
106     assertTrue(Arrays.equals(reference, target));
107     assertTrue(Arrays.equals(reference, target));
108 <a name="8"></a>
109     Object[] expectedArray1 = expectModify ? reference : starting;
110     Object[] expectedArray2 = expectModify ? target : starting;
111     <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertTrue(Arrays.equals(expectedArray1, array1));
112     assertTrue(Arrays.equals(expectedArray2, array2));
113   }
114 <a name="11"></a>
115   public void testPrependZeroElements() {
116     String[] result = ObjectArrays.concat</b></font>("foo", new String[] {});
117     <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().contains("foo");
118   }
119 <a name="7"></a>
120   public void testPrependOneElement() {
121     String[] result = ObjectArrays.concat</b></font>("foo", new String[] {"bar"});
122     <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().containsExactly("foo", "bar").inOrder();
123   }
124 <a name="6"></a>
125   public void testPrependTwoElements() {
126     String[] result = ObjectArrays.concat</b></font>("foo", new String[] {"bar", "baz"});
127     <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().containsExactly("foo", "bar", "baz").inOrder();
128   }
129 <a name="10"></a>
130   public void testAppendZeroElements() {
131     String[] result = ObjectArrays.concat</b></font>(new String[] {}, "foo");
132     <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().contains("foo");
133   }
134 <a name="5"></a>
135   public void testAppendOneElement() {
136     String[] result = ObjectArrays.concat</b></font>(new String[] {"foo"}, "bar");
137     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(result).asList().containsExactly("foo", "bar").inOrder();
138   }
139   public void testAppendTwoElements() {
140     String[] result = ObjectArrays.concat</b></font>(new String[] {"foo", "bar"}, "baz");
141     assertThat(result).asList().containsExactly("foo", "bar", "baz").inOrder();
142   }
143   public void testEmptyArrayToEmpty() {
144     doTestNewArrayEquals(new Object[0], 0);
145   }
146   public void testEmptyArrayToNonEmpty() {
147     checkArrayEquals(new Long[5], ObjectArrays.newArray(new Long[0], 5));
148   }
149   public void testNonEmptyToShorter() {
150     checkArrayEquals(new String[9], ObjectArrays.newArray(new String[10], 9));
151   }
152   public void testNonEmptyToSameLength() {
153     doTestNewArrayEquals(new String[10], 10);
154   }
155   public void testNonEmptyToLonger() {
156     checkArrayEquals(
157         new String[10], ObjectArrays.newArray(new String[] {"a", "b", "c", "d", "e"}, 10));
158 <a name="2"></a>  }
159   private static void checkArrayEquals(Object[] expected, Object[] actual) {
160     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertTrue(
161         "expected("
162             + expected.getClass()
163             + "): "
164             + Arrays.toString(expected)
165             + " actual("
166             + actual.getClass()
167             + "): "
168             + Arrays.toString(actual),
169         arrayEquals(expected, actual));
170   }
171   private static boolean arrayEquals(Object[] array1, Object[] array2</b></font>) {
172     assertSame(array1.getClass(), array2.getClass());
173     return Arrays.equals(array1, array2);
174   }
175   private static void doTestNewArrayEquals(Object[] expected, int length) {
176     checkArrayEquals(expected, ObjectArrays.newArray(expected, length));
177   }
178 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractFutureTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.util.concurrent;
2 import static com.google.common.truth.Truth.assertThat;
3 import static com.google.common.truth.Truth.assertWithMessage;
4 import com.google.common.annotations.GwtIncompatible;
5 import com.google.common.collect.Iterables;
6 import com.google.common.collect.Range;
7 import com.google.common.collect.Sets;
8 import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
9 import</b></font> java.util.ArrayList;
10 import java.util.Arrays;
11 import java.util.Collections;
12 import java.util.List;
13 import java.util.Set;
14 import java.util.concurrent.Callable;
15 import java.util.concurrent.CancellationException;
16 import java.util.concurrent.CountDownLatch;
17 import java.util.concurrent.CyclicBarrier;
18 import java.util.concurrent.ExecutionException;
19 import java.util.concurrent.Executor;
20 import java.util.concurrent.ExecutorService;
21 import java.util.concurrent.Executors;
22 import java.util.concurrent.Future;
23 import java.util.concurrent.TimeUnit;
24 import java.util.concurrent.TimeoutException;
25 import java.util.concurrent.atomic.AtomicBoolean;
26 import java.util.concurrent.atomic.AtomicInteger;
27 import java.util.concurrent.atomic.AtomicReference;
28 import java.util.concurrent.locks.LockSupport;
29 import junit.framework.AssertionFailedError;
30 import junit.framework.TestCase;
31 public class AbstractFutureTest extends TestCase {
32   public void testSuccess() throws ExecutionException, InterruptedException {
33     final Object value = new Object();
34     assertSame(
35         value,
36         new AbstractFuture&lt;Object&gt;() {
37           {
38             set(value);
39           }
40         }.get());
41   }
42   public void testException() throws InterruptedException {
43     final Throwable failure = new Throwable();
44     AbstractFuture&lt;String&gt; future =
45         new AbstractFuture&lt;String&gt;() {
46           {
47             setException(failure);
48           }
49         };
50     ExecutionException ee1 = getExpectingExecutionException(future);
51     ExecutionException ee2 = getExpectingExecutionException(future);
52 <a name="4"></a>        assertNotSame(ee1, ee2);
53     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(ee1).hasCauseThat().isSameInstanceAs(failure);
54     assertThat(ee2).hasCauseThat().isSameInstanceAs(failure);
55     checkStackTrace(ee1);
56     checkStackTrace(ee2);
57   }
58   public void testCancel_notDoneNoInterrupt() throws Exception {
59     InterruptibleFuture future = new InterruptibleFuture()</b></font>;
60     assertTrue(future.cancel(false));
61     assertTrue(future.isCancelled());
62     assertTrue(future.isDone());
63     assertFalse(future.wasInterrupted());
64     assertFalse(future.interruptTaskWasCalled);
65     try {
66       future.get();
67       fail("Expected CancellationException");
68     } catch (CancellationException e) {
69       assertThat(e).hasCauseThat().isNull();
70     }
71   }
72   public void testCancel_notDoneInterrupt() throws Exception {
73     InterruptibleFuture future = new InterruptibleFuture();
74     assertTrue(future.cancel(true));
75     assertTrue(future.isCancelled());
76     assertTrue(future.isDone());
77     assertTrue(future.wasInterrupted());
78     assertTrue(future.interruptTaskWasCalled);
79     try {
80       future.get();
81       fail("Expected CancellationException");
82     } catch (CancellationException e) {
83       assertThat(e).hasCauseThat().isNull();
84     }
85   }
86   public void testCancel_done() throws Exception {
87     AbstractFuture&lt;String&gt; future =
88         new AbstractFuture&lt;String&gt;() {
89           {
90 <a name="14"></a>            set("foo");
91           }
92         };
93     <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertFalse(future.cancel(true));
94     assertFalse(future.isCancelled());
95     assertTrue(future.isDone());
96   }
97   public void testGetWithTimeo</b></font>utDoneFuture() throws Exception {
98     AbstractFuture&lt;String&gt; future =
99         new AbstractFuture&lt;String&gt;() {
100           {
101             set("foo");
102           }
103         };
104     assertEquals("foo", future.get(0, TimeUnit.SECONDS));
105   }
106   public void testEvilFuture_setFuture() throws Exception {
107     final RuntimeException exception = new RuntimeException("you didn't say the magic word!");
108     AbstractFuture&lt;String&gt; evilFuture =
109         new AbstractFuture&lt;String&gt;() {
110           @Override
111           public void addListener(Runnable r, Executor e) {
112             throw exception;
113           }
114         };
115     AbstractFuture&lt;String&gt; normalFuture = new AbstractFuture&lt;String&gt;() {};
116     normalFuture.setFuture(evilFuture);
117     assertTrue(normalFuture.isDone());
118     try {
119       normalFuture.get();
120       fail();
121     } catch (ExecutionException e) {
122       assertThat(e).hasCauseThat().isSameInstanceAs(exception);
123     }
124   }
125   public void testRemoveWaiter_interruption() throws Exception {
126     final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
127     WaiterThread waiter1 = new WaiterThread(future);
128     waiter1.start();
129     waiter1.awaitWaiting();
130     WaiterThread waiter2 = new WaiterThread(future);
131     waiter2.start();
132     waiter2.awaitWaiting();
133 <a name="13"></a>        waiter1.interrupt();
134     <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>waiter1.join();
135     waiter2.awaitWaiting(); 
136     LockSupport.unpark(waiter2);     waiter2.awaitWaiting(); 
137     future.set(null);
138     waiter2.join();
139   }
140   public void testRemoveWa</b></font>iter_polling() throws Exception {
141     final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
142     WaiterThread waiter = new WaiterThread(future);
143     waiter.start();
144     waiter.awaitWaiting();
145     PollingThread poller = new PollingThread(future);
146     poller.start();
147     PollingThread poller2 = new PollingThread(future);
148     poller2.start();
149     PollingThread poller3 = new PollingThread(future);
150     poller3.start();
151     poller.awaitInLoop();
152     poller2.awaitInLoop();
153     poller3.awaitInLoop();
154     waiter.interrupt();
155 <a name="0"></a>
156     waiter.join();
157     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>future.set(null);
158     poller.join();
159   }
160   public void testToString_allUnique() throws Exception {
161     assertThat(SettableFuture.create().toString()).isNotEqualTo(SettableFuture.create().toString());
162   }
163   public void test</b></font>ToString_oom() throws Exception {
164     SettableFuture&lt;Object&gt; future = SettableFuture.create();
165     future.set(
166         new Object() {
167           @Override
168           public String toString() {
169             throw new OutOfMemoryError();
170           }
171           @Override
172           public int hashCode() {
173             throw new OutOfMemoryError();
174           }
175         });
176     String unused = future.toString();
177     SettableFuture&lt;Object&gt; future2 = SettableFuture.create();
178     Object object =
179         new Object() {
180           @Override
181           public String toString() {
182             return new String(new char[50_000]);
183           }
184         };
185     List&lt;Object&gt; list = Collections.singletonList(object);
186     for (int i = 0; i &lt; 10; i++) {
187       Object[] array = new Object[500];
188       Arrays.fill(array, list);
189       list = Arrays.asList(array);
190     }
191     future2.set(list);
192     unused = future.toString();
193   }
194   public void testToString_notDone() throws Exception {
195     AbstractFuture&lt;Object&gt; testFuture =
196         new AbstractFuture&lt;Object&gt;() {
197           @Override
198           public String pendingToString() {
199             return "cause=[Because this test isn't done]";
200           }
201         };
202     assertThat(testFuture.toString())
203         .matches(
204             "[^\\[]+\\[status=PENDING, info=\\[cause=\\[Because this test isn't done\\]\\]\\]");
205     try {
206       testFuture.get(1, TimeUnit.NANOSECONDS);
207       fail();
208     } catch (TimeoutException e) {
209       assertThat(e.getMessage()).contains("1 nanoseconds");
210       assertThat(e.getMessage()).contains("Because this test isn't done");
211     }
212   }
213   public void testToString_completesDuringToString() throws Exception {
214     AbstractFuture&lt;Object&gt; testFuture =
215         new AbstractFuture&lt;Object&gt;() {
216           @Override
217           public String pendingToString() {
218             this.set(true);
219             return "cause=[Because this test isn't done]";
220           }
221         };
222     assertThat(testFuture.toString())
223         .matches("[^\\[]+\\[status=SUCCESS, result=\\[java.lang.Boolean@\\w+\\]\\]");
224   }
225   @SuppressWarnings({"DeprecatedThreadMethods", "ThreadPriorityCheck"})
226   @AndroidIncompatible   public void testToString_delayedTimeout() throws Exception {
227     TimedWaiterThread thread =
228         new TimedWaiterThread(new AbstractFuture&lt;Object&gt;() {}, 2, TimeUnit.SECONDS);
229     thread.start();
230     thread.awaitWaiting();
231     thread.suspend();
232     long toWaitMillis = 3500 - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - thread.startTime);
233     Thread.sleep(toWaitMillis);
234     thread.setPriority(Thread.MAX_PRIORITY);
235     thread.resume();
236     thread.join();
237     boolean longWait = TimeUnit.NANOSECONDS.toSeconds(thread.timeSpentBlocked) &gt;= 5;
238     char overWaitNanosFirstDigit =
239         Long.toString(
240                 thread.timeSpentBlocked - TimeUnit.MILLISECONDS.toNanos(longWait ? 5000 : 3000))
241             .charAt(0);
242     if (overWaitNanosFirstDigit &lt; '4') {
243       overWaitNanosFirstDigit = '9';
244     }
245     String nanosRegex = "[4-" + overWaitNanosFirstDigit + "][0-9]+";
246     assertWithMessage(
247             "Spent " + thread.timeSpentBlocked + " ns blocked; slept for " + toWaitMillis + " ms")
248         .that(thread.exception)
249         .hasMessageThat()
250         .matches(
251             "Waited 2 seconds \\(plus "
252                 + (longWait ? "3" : "1")
253                 + " seconds, "
254                 + nanosRegex
255                 + " nanoseconds delay\\).*");
256   }
257   public void testToString_completed() throws Exception {
258     AbstractFuture&lt;Object&gt; testFuture2 =
259         new AbstractFuture&lt;Object&gt;() {
260           @Override
261           public String pendingToString() {
262             return "cause=[Someday...]";
263           }
264 <a name="1"></a>        };
265     AbstractFuture&lt;Object&gt; testFuture3 = new AbstractFuture&lt;Object&gt;() {};
266     testFuture3.setFuture(testFuture2);
267     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(testFuture3.toString())
268         .matches(
269             "[^\\[]+\\[status=PENDING, setFuture=\\[[^\\[]+\\[status=PENDING,"
270                 + " info=\\[cause=\\[Someday...]]]]]");
271     testFuture2.set("result string");
272     assertThat(testFuture3.toString())
273         .matches("[^\\[]+\\[status=SUCCESS, result=\\[java.lang.String@\\w+\\]\\]");
274   }
275   public void testToString_cancelled() throws Exception {
276     assertThat</b></font>(Futures.immediateCancelledFuture().toString())
277         .matches("[^\\[]+\\[status=CANCELLED\\]");
278   }
279   public void testToString_failed() {
280     assertThat(Futures.immediateFailedFuture(new RuntimeException("foo")).toString())
281         .matches("[^\\[]+\\[status=FAILURE, cause=\\[java.lang.RuntimeException: foo\\]\\]");
282   }
283   public void testToString_misbehaving() throws Exception {
284     assertThat(
285             new AbstractFuture&lt;Object&gt;() {
286               @Override
287               public String pendingToString() {
288                 throw new RuntimeException("I'm a misbehaving implementation");
289               }
290             }.toString())
291         .matches(
292             "[^\\[]+\\[status=PENDING, info=\\[Exception thrown from implementation: "
293                 + "class java.lang.RuntimeException\\]\\]");
294   }
295   public void testCompletionFinishesWithDone() {
296     ExecutorService executor = Executors.newFixedThreadPool(10);
297     for (int i = 0; i &lt; 50000; i++) {
298       final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
299       final AtomicReference&lt;String&gt; errorMessage = Atomics.newReference();
300       executor.execute(
301           new Runnable() {
302             @Override
303             public void run() {
304               future.set("success");
305               if (!future.isDone()) {
306                 errorMessage.set("Set call exited before future was complete.");
307               }
308             }
309           });
310       executor.execute(
311           new Runnable() {
312             @Override
313             public void run() {
314               future.setException(new IllegalArgumentException("failure"));
315               if (!future.isDone()) {
316                 errorMessage.set("SetException call exited before future was complete.");
317               }
318             }
319           });
320       executor.execute(
321           new Runnable() {
322             @Override
323             public void run() {
324               future.cancel(true);
325               if (!future.isDone()) {
326                 errorMessage.set("Cancel call exited before future was complete.");
327               }
328             }
329           });
330       try {
331         future.get();
332       } catch (Throwable t) {
333       }
334       String error = errorMessage.get();
335       assertNull(error, error);
336     }
337     executor.shutdown();
338   }
339   public void testFutureBash() {
340     final CyclicBarrier barrier =
341         new CyclicBarrier(
342             6                 + 50                 + 50                 + 1);     final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
343     final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
344     final AtomicInteger numSuccessfulSetCalls = new AtomicInteger();
345     Callable&lt;Void&gt; completeSuccessfullyRunnable =
346         new Callable&lt;Void&gt;() {
347           @Override
348           public Void call() {
349             if (currentFuture.get().set("set")) {
350               numSuccessfulSetCalls.incrementAndGet();
351             }
352             awaitUnchecked(barrier);
353             return null;
354           }
355         };
356     Callable&lt;Void&gt; completeExceptionallyRunnable =
357         new Callable&lt;Void&gt;() {
358           Exception failureCause = new Exception("setException");
359           @Override
360           public Void call() {
361             if (currentFuture.get().setException(failureCause)) {
362               numSuccessfulSetCalls.incrementAndGet();
363             }
364             awaitUnchecked(barrier);
365             return null;
366           }
367         };
368     Callable&lt;Void&gt; cancelRunnable =
369         new Callable&lt;Void&gt;() {
370           @Override
371           public Void call() {
372             if (currentFuture.get().cancel(true)) {
373               numSuccessfulSetCalls.incrementAndGet();
374             }
375             awaitUnchecked(barrier);
376             return null;
377           }
378         };
379     Callable&lt;Void&gt; setFutureCompleteSuccessfullyRunnable =
380         new Callable&lt;Void&gt;() {
381           ListenableFuture&lt;String&gt; future = Futures.immediateFuture("setFuture");
382           @Override
383           public Void call() {
384             if (currentFuture.get().setFuture(future)) {
385               numSuccessfulSetCalls.incrementAndGet();
386             }
387             awaitUnchecked(barrier);
388             return null;
389           }
390         };
391     Callable&lt;Void&gt; setFutureCompleteExceptionallyRunnable =
392         new Callable&lt;Void&gt;() {
393           ListenableFuture&lt;String&gt; future =
394               Futures.immediateFailedFuture(new Exception("setFuture"));
395           @Override
396           public Void call() {
397             if (currentFuture.get().setFuture(future)) {
398               numSuccessfulSetCalls.incrementAndGet();
399             }
400             awaitUnchecked(barrier);
401             return null;
402           }
403         };
404     Callable&lt;Void&gt; setFutureCancelRunnable =
405         new Callable&lt;Void&gt;() {
406           ListenableFuture&lt;String&gt; future = Futures.immediateCancelledFuture();
407           @Override
408           public Void call() {
409             if (currentFuture.get().setFuture(future)) {
410               numSuccessfulSetCalls.incrementAndGet();
411             }
412             awaitUnchecked(barrier);
413             return null;
414           }
415         };
416     final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
417     Runnable collectResultsRunnable =
418         new Runnable() {
419           @Override
420           public void run() {
421             try {
422               String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
423               finalResults.add(result);
424             } catch (ExecutionException e) {
425               finalResults.add(e.getCause());
426             } catch (CancellationException e) {
427               finalResults.add(CancellationException.class);
428             } finally {
429               awaitUnchecked(barrier);
430             }
431           }
432         };
433     Runnable collectResultsTimedGetRunnable =
434         new Runnable() {
435           @Override
436           public void run() {
437             Future&lt;String&gt; future = currentFuture.get();
438             while (true) {
439               try {
440                 String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);
441                 finalResults.add(result);
442                 break;
443               } catch (ExecutionException e) {
444                 finalResults.add(e.getCause());
445                 break;
446               } catch (CancellationException e) {
447                 finalResults.add(CancellationException.class);
448                 break;
449               } catch (TimeoutException e) {
450               }
451             }
452             awaitUnchecked(barrier);
453           }
454         };
455     List&lt;Callable&lt;?&gt;&gt; allTasks = new ArrayList&lt;&gt;();
456     allTasks.add(completeSuccessfullyRunnable);
457     allTasks.add(completeExceptionallyRunnable);
458     allTasks.add(cancelRunnable);
459     allTasks.add(setFutureCompleteSuccessfullyRunnable);
460     allTasks.add(setFutureCompleteExceptionallyRunnable);
461     allTasks.add(setFutureCancelRunnable);
462     for (int k = 0; k &lt; 50; k++) {
463       final Runnable listener =
464           k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;
465       allTasks.add(Executors.callable(listener));
466       allTasks.add(
467           new Callable&lt;Void&gt;() {
468             @Override
469             public Void call() throws Exception {
470               currentFuture.get().addListener(listener, executor);
471               return null;
472             }
473           });
474     }
475     assertEquals(allTasks.size() + 1, barrier.getParties());
476     for (int i = 0; i &lt; 1000; i++) {
477       Collections.shuffle(allTasks);
478       final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
479       currentFuture.set(future);
480       for (Callable&lt;?&gt; task : allTasks) {
481         @SuppressWarnings("unused")         Future&lt;?&gt; possiblyIgnoredError = executor.submit(task);
482       }
483       awaitUnchecked(barrier);
484       assertThat(future.isDone()).isTrue();
485       Object result = Iterables.getOnlyElement(finalResults);
486       if (result == CancellationException.class) {
487         assertTrue(future.isCancelled());
488         if (future.wasInterrupted()) {
489           assertThat(numSuccessfulSetCalls.get()).isIn(Range.closed(1, 2));
490         } else {
491           assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);
492         }
493       } else {
494         assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);
495       }
496       numSuccessfulSetCalls.set(0);
497       finalResults.clear();
498     }
499     executor.shutdown();
500   }
501   public void testSetFutureCancelBash() {
502     final int size = 50;
503     final CyclicBarrier barrier =
504         new CyclicBarrier(
505             2                 + size                 + size                 + 1);     final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
506     final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
507     final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; setFutureFuture = Atomics.newReference();
508     final AtomicBoolean setFutureSetSuccess = new AtomicBoolean();
509     final AtomicBoolean setFutureCompletionSuccess = new AtomicBoolean();
510     final AtomicBoolean cancellationSuccess = new AtomicBoolean();
511     Runnable cancelRunnable =
512         new Runnable() {
513           @Override
514           public void run() {
515             cancellationSuccess.set(currentFuture.get().cancel(true));
516             awaitUnchecked(barrier);
517           }
518 <a name="16"></a>        };
519     Runnable setFutureCompleteSuccessfullyRunnable =
520         new Runnable() {
521           <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
522           public void run() {
523             AbstractFuture&lt;String&gt; future = setFutureFuture.get();
524             setFutureSetSuccess.set(currentFuture.get().setFuture(future));
525             setFutureCompletionSuccess.set(future.set</b></font>("hello-async-world"));
526             awaitUnchecked(barrier);
527           }
528         };
529     final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
530     Runnable collectResultsRunnable =
531         new Runnable() {
532           @Override
533           public void run() {
534             try {
535               String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
536               finalResults.add(result);
537             } catch (ExecutionException e) {
538               finalResults.add(e.getCause());
539             } catch (CancellationException e) {
540               finalResults.add(CancellationException.class);
541             } finally {
542               awaitUnchecked(barrier);
543             }
544           }
545         };
546     Runnable collectResultsTimedGetRunnable =
547         new Runnable() {
548           @Override
549           public void run() {
550             Future&lt;String&gt; future = currentFuture.get();
551             while (true) {
552               try {
553                 String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);
554                 finalResults.add(result);
555                 break;
556               } catch (ExecutionException e) {
557                 finalResults.add(e.getCause());
558                 break;
559               } catch (CancellationException e) {
560                 finalResults.add(CancellationException.class);
561                 break;
562               } catch (TimeoutException e) {
563               }
564             }
565             awaitUnchecked(barrier);
566           }
567         };
568     List&lt;Runnable&gt; allTasks = new ArrayList&lt;&gt;();
569     allTasks.add(cancelRunnable);
570     allTasks.add(setFutureCompleteSuccessfullyRunnable);
571     for (int k = 0; k &lt; size; k++) {
572       final Runnable listener =
573           k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;
574       allTasks.add(listener);
575       allTasks.add(
576           new Runnable() {
577             @Override
578             public void run() {
579               currentFuture.get().addListener(listener, executor);
580             }
581           });
582     }
583     assertEquals(allTasks.size() + 1, barrier.getParties());     for (int i = 0; i &lt; 1000; i++) {
584       Collections.shuffle(allTasks);
585       final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
586       final AbstractFuture&lt;String&gt; setFuture = new AbstractFuture&lt;String&gt;() {};
587       currentFuture.set(future);
588       setFutureFuture.set(setFuture);
589       for (Runnable task : allTasks) {
590         executor.execute(task);
591       }
592       awaitUnchecked(barrier);
593       assertThat(future.isDone()).isTrue();
594       Object result = Iterables.getOnlyElement(finalResults);
595       if (result == CancellationException.class) {
596         assertTrue(future.isCancelled());
597         assertTrue(cancellationSuccess.get());
598         if (!setFutureSetSuccess.get() || !setFutureCompletionSuccess.get()) {
599           assertTrue(setFuture.isCancelled());
600           assertTrue(setFuture.wasInterrupted());         }
601       } else {
602         assertFalse(cancellationSuccess.get());
603         assertTrue(setFutureSetSuccess.get());
604         assertTrue(setFutureCompletionSuccess.get());
605       }
606       setFutureSetSuccess.set(false);
607       setFutureCompletionSuccess.set(false);
608       cancellationSuccess.set(false);
609       finalResults.clear();
610     }
611     executor.shutdown();
612   }
613   public void testSetFutureCancelBash_withDoneFuture() {
614     final CyclicBarrier barrier =
615         new CyclicBarrier(
616             2                 + 1                 + 1);     final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());
617     final AtomicReference&lt;AbstractFuture&lt;String&gt;&gt; currentFuture = Atomics.newReference();
618     final AtomicBoolean setFutureSuccess = new AtomicBoolean();
619     final AtomicBoolean cancellationSuccess = new AtomicBoolean();
620     Callable&lt;Void&gt; cancelRunnable =
621         new Callable&lt;Void&gt;() {
622           @Override
623           public Void call() {
624             cancellationSuccess.set(currentFuture.get().cancel(true));
625             awaitUnchecked(barrier);
626             return null;
627           }
628         };
629     Callable&lt;Void&gt; setFutureCompleteSuccessfullyRunnable =
630         new Callable&lt;Void&gt;() {
631           final ListenableFuture&lt;String&gt; future = Futures.immediateFuture("hello");
632           @Override
633           public Void call() {
634             setFutureSuccess.set(currentFuture.get().setFuture(future));
635             awaitUnchecked(barrier);
636             return null;
637           }
638         };
639     final Set&lt;Object&gt; finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());
640     final Runnable collectResultsRunnable =
641         new Runnable() {
642           @Override
643           public void run() {
644             try {
645               String result = Uninterruptibles.getUninterruptibly(currentFuture.get());
646               finalResults.add(result);
647             } catch (ExecutionException e) {
648               finalResults.add(e.getCause());
649             } catch (CancellationException e) {
650               finalResults.add(CancellationException.class);
651             } finally {
652               awaitUnchecked(barrier);
653             }
654           }
655         };
656     List&lt;Callable&lt;?&gt;&gt; allTasks = new ArrayList&lt;&gt;();
657     allTasks.add(cancelRunnable);
658     allTasks.add(setFutureCompleteSuccessfullyRunnable);
659     allTasks.add(Executors.callable(collectResultsRunnable));
660     assertEquals(allTasks.size() + 1, barrier.getParties());     for (int i = 0; i &lt; 1000; i++) {
661       Collections.shuffle(allTasks);
662       final AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
663       currentFuture.set(future);
664       for (Callable&lt;?&gt; task : allTasks) {
665         @SuppressWarnings("unused")         Future&lt;?&gt; possiblyIgnoredError = executor.submit(task);
666       }
667       awaitUnchecked(barrier);
668       assertThat(future.isDone()).isTrue();
669       Object result = Iterables.getOnlyElement(finalResults);
670       if (result == CancellationException.class) {
671         assertTrue(future.isCancelled());
672         assertTrue(cancellationSuccess.get());
673         assertFalse(setFutureSuccess.get());
674       } else {
675         assertTrue(setFutureSuccess.get());
676         assertFalse(cancellationSuccess.get());
677       }
678       setFutureSuccess.set(false);
679       cancellationSuccess.set(false);
680       finalResults.clear();
681     }
682     executor.shutdown();
683   }
684   public void testSetFuture_stackOverflow() {
685     SettableFuture&lt;String&gt; orig = SettableFuture.create();
686     SettableFuture&lt;String&gt; prev = orig;
687     for (int i = 0; i &lt; 100000; i++) {
688       SettableFuture&lt;String&gt; curr = SettableFuture.create();
689       prev.setFuture(curr);
690       prev = curr;
691     }
692     prev.set("done");
693     assertTrue(orig.isDone());
694   }
695   @GwtIncompatible
696   @AndroidIncompatible
697   public void testSetFutureToString_stackOverflow() {
698     SettableFuture&lt;String&gt; orig = SettableFuture.create();
699     SettableFuture&lt;String&gt; prev = orig;
700     for (int i = 0; i &lt; 100000; i++) {
701       SettableFuture&lt;String&gt; curr = SettableFuture.create();
702       prev.setFuture(curr);
703 <a name="15"></a>      prev = curr;
704     }
705     <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(orig.toString())
706         .contains("Exception thrown from implementation: class java.lang.StackOverflowError");
707   }
708   public void testSetFuture_misbehavingFutureThrows() throws Exception {
709     SettableFuture&lt;String&gt; future = SettableFuture.create</b></font>();
710     ListenableFuture&lt;String&gt; badFuture =
711         new ListenableFuture&lt;String&gt;() {
712           @Override
713           public boolean cancel(boolean interrupt) {
714             return false;
715           }
716           @Override
717           public boolean isDone() {
718             return true;
719           }
720           @Override
721           public boolean isCancelled() {
722             return false;           }
723           @Override
724           public String get() {
725             throw new CancellationException();           }
726           @Override
727           public String get(long time, TimeUnit unit) {
728             throw new CancellationException();           }
729           @Override
730           public void addListener(Runnable runnable, Executor executor) {
731             executor.execute(runnable);
732           }
733         };
734 <a name="3"></a>    future.setFuture(badFuture);
735     ExecutionException expected = getExpectingExecutionException(future);
736     assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
737     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(expected).hasCauseThat().hasMessageThat().contains(badFuture.toString());
738   }
739   public void testSetFuture_misbehavingFutureDoesNotThrow() throws Exception {
740     SettableFuture&lt;String&gt; future = SettableFuture.create</b></font>();
741     ListenableFuture&lt;String&gt; badFuture =
742         new ListenableFuture&lt;String&gt;() {
743           @Override
744           public boolean cancel(boolean interrupt) {
745             return false;
746           }
747           @Override
748           public boolean isDone() {
749             return true;
750           }
751           @Override
752           public boolean isCancelled() {
753             return true;           }
754           @Override
755           public String get() {
756             return "foo";           }
757           @Override
758           public String get(long time, TimeUnit unit) {
759             return "foo";           }
760           @Override
761           public void addListener(Runnable runnable, Executor executor) {
762 <a name="8"></a>            executor.execute(runnable);
763           }
764         };
765     <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>future.setFuture(badFuture);
766     assertThat(future.isCancelled()).isTrue();
767   }
768   public void testCancel_stackOverflow() {
769     SettableFuture&lt;String&gt; orig = SettableFuture.create</b></font>();
770     SettableFuture&lt;String&gt; prev = orig;
771     for (int i = 0; i &lt; 100000; i++) {
772       SettableFuture&lt;String&gt; curr = SettableFuture.create();
773       prev.setFuture(curr);
774       prev = curr;
775 <a name="12"></a>    }
776     orig.cancel(true);
777     <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(orig.isCancelled());
778     assertTrue(prev.isCancelled());
779 <a name="9"></a>    assertTrue(prev.wasInterrupted());
780   }
781   public void testSetFutur</b></font>eSelf_cancel() <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
782     SettableFuture&lt;String&gt; orig = SettableFuture.create();
783     orig.setFuture(orig);
784     orig.cancel(true);
785     assertTrue(orig.isCancelled());
786   }
787 <a name="7"></a>
788   public void testSetFutureS</b></font>elf_toString() {
789     SettableFuture&lt;String&gt; orig = SettableFuture.create();
790     <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>orig.setFuture(orig);
791     assertThat(orig.toString()).contains("[status=PENDING, setFuture=[this future]]");
792   }
793 <a name="6"></a>
794   public void testSetSelf_toString() {
795     SettableFuture&lt;Object&gt; orig = SettableFuture.create</b></font>();
796     <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>orig.set(orig);
797     assertThat(orig.toString()).contains("[status=SUCCESS, result=[this future]]");
798   }
799   public void testSetFutureSelf_toStringException() {
800     SettableFuture&lt;String&gt; orig = SettableFuture.create</b></font>();
801     orig.setFuture(
802         new AbstractFuture&lt;String&gt;() {
803           @Override
804           public String toString() {
805 <a name="11"></a>            throw new NullPointerException();
806           }
807         });
808     <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(orig.toString())
809         .contains(
810             "[status=PENDING, setFuture=[Exception thrown from implementation: class"
811                 + " java.lang.NullPointerException]]");
812   }
813   public void testSetIndirectSelf_toString() {
814     final SettableFuture&lt;Object&gt; orig = SettableFuture.create</b></font>();
815     orig.setFuture(
816         new ForwardingListenableFuture&lt;Object&gt;() {
817           @Override
818           protected ListenableFuture&lt;Object&gt; delegate() {
819             return orig;
820           }
821         });
822     assertThat(orig.toString())
823         .contains("Exception thrown from implementation: class java.lang.StackOverflowError");
824   }
825   public void testListenersExecuteImmediately_fromAfterDone() {
826     AbstractFuture&lt;String&gt; f =
827         new AbstractFuture&lt;String&gt;() {
828           @Override
829           protected void afterDone() {
830             final AtomicBoolean ranImmediately = new AtomicBoolean();
831             addListener(
832                 new Runnable() {
833                   @Override
834                   public void run() {
835                     ranImmediately.set(true);
836                   }
837                 },
838                 MoreExecutors.directExecutor());
839             assertThat(ranImmediately.get()).isTrue();
840           }
841         };
842     f.set("foo");
843   }
844   public void testListenersExecuteImmediately_afterWaiterWakesUp() throws Exception {
845     final AbstractFuture&lt;String&gt; f =
846         new AbstractFuture&lt;String&gt;() {
847           @Override
848           protected void afterDone() {
849             try {
850               Thread.sleep(TimeUnit.SECONDS.toMillis(10));
851             } catch (InterruptedException ignored) {
852               Thread.currentThread().interrupt();             }
853           }
854         };
855     Thread t =
856         new Thread() {
857           @Override
858           public void run() {
859             f.set("foo");
860           }
861         };
862     t.start();
863     f.get();
864     final AtomicBoolean ranImmediately = new AtomicBoolean();
865     f.addListener(
866         new Runnable() {
867           @Override
868           public void run() {
869             ranImmediately.set(true);
870 <a name="5"></a>          }
871         },
872         MoreExecutors.directExecutor());
873     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(ranImmediately.get()).isTrue();
874     t.interrupt();
875     t.join();
876   }
877 <a name="10"></a>  public void testTrustedGetFailure_Completed() {
878     SettableFuture&lt;String&gt; future = SettableFuture.create</b></font>();
879     future.set("261");
880     <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(future.tryInternalFastPathGetFailure()).isNull();
881   }
882   public void testTrustedGetFailure_Failed() {
883     SettableFuture&lt;String&gt; future = SettableFuture.create</b></font>();
884     Throwable failure = new Throwable();
885     future.setException(failure);
886     assertThat(future.tryInternalFastPathGetFailure()).isEqualTo(failure);
887   }
888   public void testTrustedGetFailure_NotCompleted() {
889     SettableFuture&lt;String&gt; future = SettableFuture.create();
890     assertThat(future.isDone()).isFalse();
891     assertThat(future.tryInternalFastPathGetFailure()).isNull();
892   }
893   public void testTrustedGetFailure_CanceledNoCause() {
894     SettableFuture&lt;String&gt; future = SettableFuture.create();
895     future.cancel(false);
896     assertThat(future.tryInternalFastPathGetFailure()).isNull();
897   }
898   public void testGetFailure_Completed() {
899     AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
900     future.set("261");
901     assertThat(future.tryInternalFastPathGetFailure()).isNull();
902   }
903   public void testGetFailure_Failed() {
904     AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
905     final Throwable failure = new Throwable();
906     future.setException(failure);
907     assertThat(future.tryInternalFastPathGetFailure()).isNull();
908   }
909   public void testGetFailure_NotCompleted() {
910     AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
911     assertThat(future.isDone()).isFalse();
912     assertThat(future.tryInternalFastPathGetFailure()).isNull();
913   }
914   public void testGetFailure_CanceledNoCause() {
915     AbstractFuture&lt;String&gt; future = new AbstractFuture&lt;String&gt;() {};
916     future.cancel(false);
917     assertThat(future.tryInternalFastPathGetFailure()).isNull();
918   }
919   public void testForwardExceptionFastPath() throws Exception {
920     class FailFuture extends InternalFutureFailureAccess implements ListenableFuture&lt;String&gt; {
921       Throwable failure;
922       FailFuture(Throwable throwable) {
923         failure = throwable;
924       }
925       @Override
926       public boolean cancel(boolean mayInterruptIfRunning) {
927         throw new AssertionFailedError("cancel shouldn't be called on this object");
928       }
929       @Override
930       public boolean isCancelled() {
931         return false;
932       }
933       @Override
934       public boolean isDone() {
935         return true;
936       }
937       @Override
938       public String get() throws InterruptedException, ExecutionException {
939         throw new AssertionFailedError("get() shouldn't be called on this object");
940       }
941       @Override
942       public String get(long timeout, TimeUnit unit)
943           throws InterruptedException, ExecutionException, TimeoutException {
944         return get();
945       }
946       @Override
947       protected Throwable tryInternalFastPathGetFailure() {
948         return failure;
949       }
950       @Override
951       public void addListener(Runnable listener, Executor executor) {
952         throw new AssertionFailedError("addListener() shouldn't be called on this object");
953       }
954     }
955     final RuntimeException exception = new RuntimeException("you still didn't say the magic word!");
956     SettableFuture&lt;String&gt; normalFuture = SettableFuture.create();
957     normalFuture.setFuture(new FailFuture(exception));
958     assertTrue(normalFuture.isDone());
959     try {
960       normalFuture.get();
961       fail();
962     } catch (ExecutionException e) {
963       assertSame(exception, e.getCause());
964     }
965   }
966   private static void awaitUnchecked(final CyclicBarrier barrier) {
967     try {
968       barrier.await();
969     } catch (Exception e) {
970       throw new RuntimeException(e);
971     }
972   }
973   private void checkStackTrace(ExecutionException e) {
974 <a name="2"></a>        int index = findStackFrame(e, getClass().getName(), "getExpectingExecutionException");
975     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(index).isNotEqualTo(0);
976     assertThat(e.getStackTrace()[index - 1].getMethodName()).isEqualTo("get");
977   }
978   private static int findStackFrame(ExecutionException e, String clazz</b></font>, String method) {
979     StackTraceElement[] elements = e.getStackTrace();
980     for (int i = 0; i &lt; elements.length; i++) {
981       StackTraceElement element = elements[i];
982       if (element.getClassName().equals(clazz) &amp;&amp; element.getMethodName().equals(method)) {
983         return i;
984       }
985     }
986     AssertionFailedError failure =
987         new AssertionFailedError(
988             "Expected element " + clazz + "." + method + " not found in stack trace");
989     failure.initCause(e);
990     throw failure;
991   }
992   private ExecutionException getExpectingExecutionException(AbstractFuture&lt;String&gt; future)
993       throws InterruptedException {
994     try {
995       String got = future.get();
996       fail("Expected exception but got " + got);
997     } catch (ExecutionException e) {
998       return e;
999     }
1000     return null;
1001   }
1002   private static final class WaiterThread extends Thread {
1003     private final AbstractFuture&lt;?&gt; future;
1004     private WaiterThread(AbstractFuture&lt;?&gt; future) {
1005       this.future = future;
1006     }
1007     @Override
1008     public void run() {
1009       try {
1010         future.get();
1011       } catch (Exception e) {
1012       }
1013     }
1014     void awaitWaiting() {
1015       while (!isBlocked()) {
1016         if (getState() == State.TERMINATED) {
1017           throw new RuntimeException("Thread exited");
1018         }
1019         Thread.yield();
1020       }
1021     }
1022     private boolean isBlocked() {
1023       return getState() == Thread.State.WAITING &amp;&amp; LockSupport.getBlocker(this) == future;
1024     }
1025   }
1026   static final class TimedWaiterThread extends Thread {
1027     private final AbstractFuture&lt;?&gt; future;
1028     private final long timeout;
1029     private final TimeUnit unit;
1030     private Exception exception;
1031     private volatile long startTime;
1032     private long timeSpentBlocked;
1033     TimedWaiterThread(AbstractFuture&lt;?&gt; future, long timeout, TimeUnit unit) {
1034       this.future = future;
1035       this.timeout = timeout;
1036       this.unit = unit;
1037     }
1038     @Override
1039     public void run() {
1040       startTime = System.nanoTime();
1041       try {
1042         future.get(timeout, unit);
1043       } catch (Exception e) {
1044         exception = e;
1045       } finally {
1046         timeSpentBlocked = System.nanoTime() - startTime;
1047       }
1048     }
1049     void awaitWaiting() {
1050       while (!isBlocked()) {
1051         if (getState() == State.TERMINATED) {
1052           throw new RuntimeException("Thread exited");
1053         }
1054         Thread.yield();
1055       }
1056     }
1057     private boolean isBlocked() {
1058       return getState() == Thread.State.TIMED_WAITING &amp;&amp; LockSupport.getBlocker(this) == future;
1059     }
1060   }
1061   private static final class PollingThread extends Thread {
1062     private final AbstractFuture&lt;?&gt; future;
1063     private final CountDownLatch completedIteration = new CountDownLatch(10);
1064     private PollingThread(AbstractFuture&lt;?&gt; future) {
1065       this.future = future;
1066     }
1067     @Override
1068     public void run() {
1069       while (true) {
1070         try {
1071           future.get(0, TimeUnit.SECONDS);
1072           return;
1073         } catch (InterruptedException | ExecutionException e) {
1074           return;
1075         } catch (TimeoutException e) {
1076         } finally {
1077           completedIteration.countDown();
1078         }
1079       }
1080     }
1081     void awaitInLoop() {
1082       Uninterruptibles.awaitUninterruptibly(completedIteration);
1083     }
1084   }
1085   private static final class InterruptibleFuture extends AbstractFuture&lt;String&gt; {
1086     boolean interruptTaskWasCalled;
1087     @Override
1088     protected void interruptTask() {
1089       assertFalse(interruptTaskWasCalled);
1090       interruptTaskWasCalled = true;
1091     }
1092   }
1093 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
