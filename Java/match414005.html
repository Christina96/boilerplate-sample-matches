<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for AbstractScheduledServiceTest.java &amp; CacheLoadingTest_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for AbstractScheduledServiceTest.java &amp; CacheLoadingTest_1.java
      </h3>
<h1 align="center">
        13.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>AbstractScheduledServiceTest.java (37.32913%)<th>CacheLoadingTest_1.java (8.606061%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-54)<td><a href="#" name="0">(31-64)</a><td align="center"><font color="#ff0000">28</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(248-258)<td><a href="#" name="1">(598-607)</a><td align="center"><font color="#ad0000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(532-544)<td><a href="#" name="2">(1837-1855)</a><td align="center"><font color="#a30000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(519-531)<td><a href="#" name="3">(1819-1831)</a><td align="center"><font color="#a30000">18</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(153-162)<td><a href="#" name="4">(1749-1758)</a><td align="center"><font color="#a30000">18</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(264-278)<td><a href="#" name="5">(531-538)</a><td align="center"><font color="#9a0000">17</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(169-180)<td><a href="#" name="6">(490-498)</a><td align="center"><font color="#9a0000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(217-226)<td><a href="#" name="7">(371-380)</a><td align="center"><font color="#910000">16</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(114-120)<td><a href="#" name="8">(1252-1257)</a><td align="center"><font color="#7f0000">14</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(500-506)<td><a href="#" name="9">(207-213)</a><td align="center"><font color="#760000">13</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(460-469)<td><a href="#" name="10">(420-427)</a><td align="center"><font color="#760000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(189-198)<td><a href="#" name="11">(325-333)</a><td align="center"><font color="#760000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(136-146)<td><a href="#" name="12">(2444-2459)</a><td align="center"><font color="#760000">13</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(567-575)<td><a href="#" name="13">(454-460)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(480-485)<td><a href="#" name="14">(2067-2072)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(434-440)<td><a href="#" name="15">(464-470)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(299-305)<td><a href="#" name="16">(1911-1915)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(99-106)<td><a href="#" name="17">(2024-2029)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(120-126)<td><a href="#" name="18">(157-164)</a><td align="center"><font color="#640000">11</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(455-459)<td><a href="#" name="19">(2117-2121)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(387-394)<td><a href="#" name="20">(75-82)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(181-187)<td><a href="#" name="21">(2056-2063)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(72-76)<td><a href="#" name="22">(201-205)</a><td align="center"><font color="#5b0000">10</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(641-644)<td><a href="#" name="23">(524-527)</a><td align="center"><font color="#510000">9</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(313-318)<td><a href="#" name="24">(2249-2254)</a><td align="center"><font color="#510000">9</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(57-65)<td><a href="#" name="25">(2192-2199)</a><td align="center"><font color="#510000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>AbstractScheduledServiceTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.util.concurrent;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.truth.Truth.assertThat;
4 import static com.google.common.util.concurrent.AbstractScheduledService.Scheduler.newFixedDelaySchedule;
5 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
6 import static java.util.concurrent.TimeUnit.MILLISECONDS;
7 import static java.util.concurrent.TimeUnit.NANOSECONDS;
8 import static java.util.concurrent.TimeUnit.SECONDS;
9 import com.google.common.util.concurrent.AbstractScheduledService.Cancellable;
10 import com.google.common.util.concurrent.AbstractScheduledService.Scheduler;
11 import com.google.common.util.concurrent.Service.State;
12 import com.google.common.util.concurrent.testing.TestingExecutors;
13 import java.util.concurrent.BrokenBarrierException;
14 import java.util.concurrent.CancellationException;
15 import java.util.concurrent.CountDownLatch;
16 import java.util.concurrent.CyclicBarrier;
17 import java.util.concurrent.Delayed;
18 import java.util.concurrent.Executors;
19 import java.util.concurrent.Future;
20 import java.util.concurrent.ScheduledExecutorService;
21 import java.util.concurrent.ScheduledFuture;
22 import java.util.concurrent.ScheduledThreadPoolExecutor;
23 import java.util.concurrent.TimeUnit;
24 import java.util.concurrent.TimeoutException;
25 import java.util.concurrent.atomic.AtomicBoolean;
26 import java.util.concurrent.atomic.AtomicInteger;
27 import java.util.concurrent.atomic.AtomicReference;
28 import junit.framework.TestCase;
29 public class AbstractScheduledServiceTest extends TestCase {
30 <a name="25"></a>  volatile Scheduler configuration = newFixedDelaySchedule(0, 10, MILLISECONDS)</b></font>;
31   volatile ScheduledFuture&lt;?&gt; future = null;
32   <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>volatile boolean atFixedRateCalled = false;
33   volatile boolean withFixedDelayCalled = false;
34   volatile boolean scheduleCalled = false;
35   final ScheduledExecutorService executor =
36       new ScheduledThreadPoolExecutor(10) {
37         @Override
38         public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(
39             Runnable command</b></font>, long initialDelay, long delay, TimeUnit unit) {
40           return future = super.scheduleWithFixedDelay(command, initialDelay, delay, unit);
41         }
42       };
43 <a name="22"></a>
44   public void testServiceStartStop() throws Exception {
45     NullService service = new NullService();
46     <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.startAsync().awaitRunning();
47     assertFalse(future.isDone());
48     service.stopAsync().awaitTerminated();
49     assertTrue(future.isCancelled());
50   }</b></font>
51   private class NullService extends AbstractScheduledService {
52     @Override
53     protected void runOneIteration() throws Exception {}
54     @Override
55     protected Scheduler scheduler() {
56       return configuration;
57     }
58     @Override
59     protected ScheduledExecutorService executor() {
60       return executor;
61     }
62   }
63   public void testFailOnExceptionFromRun() throws Exception {
64     TestService service = new TestService();
65     service.runException = new Exception();
66 <a name="17"></a>    service.startAsync().awaitRunning();
67     service.runFirstBarrier.await();
68     service.runSecondBarrier.await();
69     <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
70       future.get();
71       fail();
72     } catch (CancellationException expected) {
73     }
74     assertEquals(service.runException, service.failureCause</b></font>());
75     assertEquals(Service.State.FAILED, service.state());
76   }
77   public void testFailOnExceptionFromStartUp() {
78 <a name="8"></a>    TestService service = new TestService();
79     service.startUpException = new Exception();
80     try {
81       <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.startAsync().awaitRunning();
82       fail();
83     } catch (IllegalStateException e) {
84 <a name="18"></a>      assertThat(e).hasCauseThat().isEqualTo(service.startUpException);
85     }
86     assertEquals(0, service.numberOfTimesRunCalled.get());
87     assertEquals</b></font>(Service.State.FAILED, <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.state());
88   }
89   public void testFailOnErrorFromStartUpListener() throws InterruptedException {
90     final Error error = new Error();
91     final CountDownLatch latch = new CountDownLatch(1);
92     TestService service = new</b></font> TestService();
93     service.addListener(
94         new Service.Listener() {
95           @Override
96           public void running() {
97             throw error;
98           }
99 <a name="12"></a>
100           @Override
101           public void failed(State from, Throwable failure) {
102             <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(State.RUNNING, from);
103             assertEquals(error, failure);
104             latch.countDown();
105           }
106         },
107         directExecutor());
108     service.startAsync();
109     latch.await();
110     assertEquals(0, service.numberOfTimesRunCalled.get());
111     assertEquals(Service.State.FAILED, service.state</b></font>());
112   }
113   public void testFailOnExceptionFromShutDown() throws Exception {
114 <a name="4"></a>    TestService service = new TestService();
115     service.shutDownException = new Exception();
116     service.startAsync().awaitRunning();
117     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.runFirstBarrier.await();
118     service.stopAsync();
119     service.runSecondBarrier.await();
120     try {
121       service.awaitTerminated();
122       fail();
123     } catch (IllegalStateException e) {
124       assertThat(e).hasCauseThat().isEqualTo(service.shutDownException);
125     }
126     assertEquals(Service.State.FAILED, service.state</b></font>());
127   }
128   public void testRunOneIterationCalledMultipleTimes() throws Exception {
129 <a name="6"></a>    TestService service = new TestService();
130     service.startAsync().awaitRunning();
131     for (int i = 1; i &lt; 10; i++) {
132       <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.runFirstBarrier.await();
133       assertEquals(i, service.numberOfTimesRunCalled.get());
134       service.runSecondBarrier.await();
135     }
136     service.runFirstBarrier.await();
137     service.stopAsync();
138     service.runSecondBarrier.await();
139     service.stopAsync().awaitTerminated();
140   }
141 <a name="21"></a>
142   public void testExecutorOnlyCalledOnce() throws Exception {
143     TestService service = new</b></font> TestService();
144     <font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.startAsync().awaitRunning();
145     assertEquals(1, service.numberOfTimesExecutorCalled.get());
146     for (int i = 1; i &lt; 10; i++) {
147       service.runFirstBarrier.await();
148 <a name="11"></a>      assertEquals(i, service.numberOfTimesRunCalled.get());
149       service.runSecondBarrier.await</b></font>();
150     }
151     <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.runFirstBarrier.await();
152     service.stopAsync();
153     service.runSecondBarrier.await();
154     service.stopAsync().awaitTerminated();
155     assertEquals(1, service.numberOfTimesExecutorCalled.get());
156   }
157   public void testDefaultExecutorIsShutdownWhenServiceIsStopped() throws Exception {
158     final AtomicReference&lt;ScheduledExecutorService&gt; executor = Atomics.newReference</b></font>();
159     AbstractScheduledService service =
160         new AbstractScheduledService() {
161           @Override
162           protected void runOneIteration() throws Exception {}
163           @Override
164           protected ScheduledExecutorService executor() {
165             executor.set(super.executor());
166             return executor.get();
167           }
168           @Override
169           protected Scheduler scheduler() {
170             return newFixedDelaySchedule(0, 1, MILLISECONDS);
171           }
172 <a name="7"></a>        };
173     service.startAsync();
174     <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertFalse(service.executor().isShutdown());
175     service.awaitRunning();
176     service.stopAsync();
177     service.awaitTerminated();
178     assertTrue(executor.get().awaitTermination(100, MILLISECONDS));
179   }
180   public void testDefaultExecutorIsShutdownWhenServiceFails() throws Exception {
181     final AtomicReference&lt;ScheduledExecutorService&gt; executor = Atomics.newReference();
182     AbstractScheduledService service =</b></font>
183         new AbstractScheduledService() {
184           @Override
185           protected void startUp() throws Exception {
186             throw new Exception("Failed");
187           }
188           @Override
189           protected void runOneIteration() throws Exception {}
190           @Override
191           protected ScheduledExecutorService executor() {
192             executor.set(super.executor());
193             return executor.get();
194           }
195           @Override
196           protected Scheduler scheduler() {
197             return newFixedDelaySchedule(0, 1, MILLISECONDS);
198 <a name="1"></a>          }
199         };
200     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
201       service.startAsync().awaitRunning();
202       fail("Expected service to fail during startup");
203     } catch (IllegalStateException expected) {
204     }
205     assertTrue(executor.get().awaitTermination(100, MILLISECONDS));
206   }
207   public void testSchedulerOnlyCalledOnce() throws Exception {
208     TestService service = new TestService()</b></font>;
209     service.startAsync().awaitRunning();
210 <a name="5"></a>    assertEquals(1, service.numberOfTimesSchedulerCalled.get());
211     for (int i = 1; i &lt; 10; i++) {
212       service.runFirstBarrier.await();
213       <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(i, service.numberOfTimesRunCalled.get());
214       service.runSecondBarrier.await();
215     }
216     service.runFirstBarrier.await();
217     service.stopAsync();
218     service.runSecondBarrier.await();
219     service.awaitTerminated();
220     assertEquals(1, service.numberOfTimesSchedulerCalled.get());
221   }
222   public void testTimeout() {
223     Service service =
224         new</b></font> AbstractScheduledService() {
225           @Override
226           protected Scheduler scheduler() {
227             return Scheduler.newFixedDelaySchedule(0, 1, NANOSECONDS);
228           }
229           @Override
230           protected ScheduledExecutorService executor() {
231             return TestingExecutors.noOpScheduledExecutor();
232           }
233           @Override
234           protected void runOneIteration() throws Exception {}
235           @Override
236           protected String serviceName() {
237             return "Foo";
238           }
239 <a name="16"></a>        };
240     try {
241       service.startAsync().awaitRunning(1, MILLISECONDS);
242       <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>fail("Expected timeout");
243     } catch (TimeoutException e) {
244       assertThat(e)
245           .hasMessageThat()
246           .isEqualTo("Timed out waiting for Foo [STARTING] to reach the RUNNING state.");
247     }
248   }</b></font>
249   private class TestService extends AbstractScheduledService {
250     CyclicBarrier runFirstBarrier = new CyclicBarrier(2);
251     CyclicBarrier runSecondBarrier = new CyclicBarrier(2);
252 <a name="24"></a>
253     volatile boolean startUpCalled = false;
254     volatile boolean shutDownCalled = false;
255     <font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>AtomicInteger numberOfTimesRunCalled = new AtomicInteger(0);
256     AtomicInteger numberOfTimesExecutorCalled = new AtomicInteger(0);
257     AtomicInteger numberOfTimesSchedulerCalled = new AtomicInteger(0);
258     volatile Exception runException = null;
259     volatile Exception startUpException = null;
260     volatile Exception shutDownException = null</b></font>;
261     @Override
262     protected void runOneIteration() throws Exception {
263       assertTrue(startUpCalled);
264       assertFalse(shutDownCalled);
265       numberOfTimesRunCalled.incrementAndGet();
266       assertEquals(State.RUNNING, state());
267       runFirstBarrier.await();
268       runSecondBarrier.await();
269       if (runException != null) {
270         throw runException;
271       }
272     }
273     @Override
274     protected void startUp() throws Exception {
275       assertFalse(startUpCalled);
276       assertFalse(shutDownCalled);
277       startUpCalled = true;
278       assertEquals(State.STARTING, state());
279       if (startUpException != null) {
280         throw startUpException;
281       }
282     }
283     @Override
284     protected void shutDown() throws Exception {
285       assertTrue(startUpCalled);
286       assertFalse(shutDownCalled);
287       shutDownCalled = true;
288       if (shutDownException != null) {
289         throw shutDownException;
290       }
291     }
292     @Override
293     protected ScheduledExecutorService executor() {
294       numberOfTimesExecutorCalled.incrementAndGet();
295       return executor;
296     }
297     @Override
298     protected Scheduler scheduler() {
299       numberOfTimesSchedulerCalled.incrementAndGet();
300       return configuration;
301     }
302   }
303   private static final int INITIAL_DELAY = 10;
304   private static final int DELAY = 20;
305   private static final TimeUnit UNIT = MILLISECONDS;
306   final Runnable testRunnable =
307       new Runnable() {
308         @Override
309         public void run() {}
310       };
311   boolean called = false;
312   private void assertSingleCallWithCorrectParameters(
313 <a name="20"></a>      Runnable command, long initialDelay, long delay, TimeUnit unit) {
314     assertFalse(called);     called = true;
315     <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(INITIAL_DELAY, initialDelay);
316     assertEquals(DELAY, delay);
317     assertEquals(UNIT, unit);
318     assertEquals(testRunnable, command);
319   }
320   public void testFixedRateSchedule() {
321     Scheduler schedule = Scheduler.newFixedRateSchedule</b></font>(INITIAL_DELAY, DELAY, UNIT);
322     Cancellable unused =
323         schedule.schedule(
324             null,
325             new ScheduledThreadPoolExecutor(1) {
326               @Override
327               public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(
328                   Runnable command, long initialDelay, long period, TimeUnit unit) {
329                 assertSingleCallWithCorrectParameters(command, initialDelay, period, unit);
330                 return new ThrowingScheduledFuture&lt;&gt;();
331               }
332             },
333             testRunnable);
334     assertTrue(called);
335   }
336   public void testFixedDelaySchedule() {
337     Scheduler schedule = newFixedDelaySchedule(INITIAL_DELAY, DELAY, UNIT);
338     Cancellable unused =
339         schedule.schedule(
340             null,
341             new ScheduledThreadPoolExecutor(10) {
342               @Override
343               public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(
344                   Runnable command, long initialDelay, long delay, TimeUnit unit) {
345                 assertSingleCallWithCorrectParameters(command, initialDelay, delay, unit);
346                 return new ThrowingScheduledFuture&lt;&gt;();
347               }
348             },
349             testRunnable);
350     assertTrue(called);
351   }
352   private static final class ThrowingScheduledFuture&lt;V&gt; extends ForwardingFuture&lt;V&gt;
353       implements ScheduledFuture&lt;V&gt; {
354     @Override
355     protected Future&lt;V&gt; delegate() {
356 <a name="15"></a>      throw new UnsupportedOperationException("test should not care about this");
357     }
358     <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
359     public long getDelay(TimeUnit unit) {
360       throw new UnsupportedOperationException("test should not care about this");
361     }
362     @Override
363     public int compareTo(Delayed other) {</b></font>
364       throw new UnsupportedOperationException("test should not care about this");
365     }
366   }
367   public void testFixedDelayScheduleFarFuturePotentiallyOverflowingScheduleIsNeverReached()
368       throws Exception {
369     TestAbstractScheduledCustomService service =
370         new TestAbstractScheduledCustomService() {
371           @Override
372           protected Scheduler scheduler() {
373             return newFixedDelaySchedule(Long.MAX_VALUE, Long.MAX_VALUE, SECONDS);
374 <a name="19"></a>          }
375         };
376     service.startAsync().awaitRunning();
377     <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
378       service.firstBarrier.await(5, SECONDS);
379 <a name="10"></a>      fail();
380     } catch (TimeoutException expected) {
381     }</b></font>
382     <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(0, service.numIterations.get());
383     service.stopAsync();
384     service.awaitTerminated();
385   }
386   public void testCustomSchedulerFarFuturePotentiallyOverflowingScheduleIsNeverReached()
387       throws Exception {
388     TestAbstractScheduledCustomService service =
389         new TestAbstractScheduledCustomService() {
390           @</b></font>Override
391           protected Scheduler scheduler() {
392             return new AbstractScheduledService.CustomScheduler() {
393               @Override
394               protected Schedule getNextSchedule() throws Exception {
395                 return new Schedule(Long.MAX_VALUE, SECONDS);
396               }
397             };
398 <a name="14"></a>          }
399         };
400     service.startAsync().awaitRunning();
401     <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
402       service.firstBarrier.await(5, SECONDS);
403       fail();
404     } catch (TimeoutException expected) {
405     }
406     assertEquals(0, service.numIterations.get</b></font>());
407     service.stopAsync();
408     service.awaitTerminated();
409   }
410   private static class TestCustomScheduler extends AbstractScheduledService.CustomScheduler {
411     public AtomicInteger scheduleCounter = new AtomicInteger(0);
412     @Override
413     protected Schedule getNextSchedule() throws Exception {
414       scheduleCounter.incrementAndGet();
415       return new Schedule(0, SECONDS);
416 <a name="9"></a>    }
417   }
418   <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>public void testCustomSchedule_startStop() throws Exception {
419     final CyclicBarrier firstBarrier = new CyclicBarrier(2);
420     final CyclicBarrier secondBarrier = new CyclicBarrier(2);
421     final AtomicBoolean shouldWait = new AtomicBoolean(true);
422     Runnable task =
423         new Runnable() {
424           @</b></font>Override
425           public void run() {
426             try {
427               if (shouldWait.get()) {
428                 firstBarrier.await();
429                 secondBarrier.await();
430               }
431             } catch (Exception e) {
432               throw new RuntimeException(e);
433             }
434 <a name="3"></a>          }
435         };
436     TestCustomScheduler scheduler = new TestCustomScheduler();
437     Cancellable future = <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);
438     firstBarrier.await();
439     assertEquals(1, scheduler.scheduleCounter.get());
440     secondBarrier.await();
441     firstBarrier.await();
442     assertEquals(2, scheduler.scheduleCounter.get());
443     shouldWait.set(false);
444     secondBarrier.await();
445     future.cancel(false);
446   }
447 <a name="2"></a>
448   public void testCustomSchedulerServiceStop() throws Exception {
449     TestAbstractScheduledCustomService service = new</b></font> TestAbstractScheduledCustomService();
450     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.startAsync().awaitRunning();
451     service.firstBarrier.await();
452     assertEquals(1, service.numIterations.get());
453     service.stopAsync();
454     service.secondBarrier.await();
455     service.awaitTerminated();
456     Thread.sleep(UNIT.toMillis(3 * DELAY));
457     assertEquals(1, service.numIterations.get());
458   }
459   public void testCustomScheduler_deadlock() throws InterruptedException, BrokenBarrierException {
460     final CyclicBarrier inGetNextSchedule = new</b></font> CyclicBarrier(2);
461     for (int i = 0; i &lt; 1000; i++) {
462       Service service =
463           new AbstractScheduledService() {
464             @Override
465             protected void runOneIteration() {}
466             @Override
467             protected Scheduler scheduler() {
468               return new CustomScheduler() {
469                 @Override
470                 protected Schedule getNextSchedule() throws Exception {
471                   if (state() != State.STARTING) {
472                     inGetNextSchedule.await();
473                     Thread.yield();
474                     throw new RuntimeException("boom");
475                   }
476                   return new Schedule(0, NANOSECONDS);
477                 }
478 <a name="13"></a>              };
479             }
480           };
481       <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>service.startAsync().awaitRunning();
482       inGetNextSchedule.await();
483       service.stopAsync();
484     }
485   }
486   public void testBig() throws Exception {
487     TestAbstractScheduledCustomService service =
488         new</b></font> TestAbstractScheduledCustomService() {
489           @Override
490           protected Scheduler scheduler() {
491             return new AbstractScheduledService.CustomScheduler() {
492               @Override
493               protected Schedule getNextSchedule() throws Exception {
494                 Thread.yield();
495                 return new Schedule(0, SECONDS);
496               }
497             };
498           }
499         };
500     service.useBarriers = false;
501     service.startAsync().awaitRunning();
502     Thread.sleep(50);
503     service.useBarriers = true;
504     service.firstBarrier.await();
505     int numIterations = service.numIterations.get();
506     service.stopAsync();
507     service.secondBarrier.await();
508     service.awaitTerminated();
509     assertEquals(numIterations, service.numIterations.get());
510   }
511   private static class TestAbstractScheduledCustomService extends AbstractScheduledService {
512     final AtomicInteger numIterations = new AtomicInteger(0);
513     volatile boolean useBarriers = true;
514     final CyclicBarrier firstBarrier = new CyclicBarrier(2);
515     final CyclicBarrier secondBarrier = new CyclicBarrier(2);
516     @Override
517     protected void runOneIteration() throws Exception {
518       numIterations.incrementAndGet();
519       if (useBarriers) {
520         firstBarrier.await();
521         secondBarrier.await();
522       }
523     }
524     @Override
525     protected ScheduledExecutorService executor() {
526       return Executors.newScheduledThreadPool(10);
527     }
528     @Override
529     protected Scheduler scheduler() {
530       return new CustomScheduler() {
531         @Override
532         protected Schedule getNextSchedule() throws Exception {
533           return new Schedule(DELAY, UNIT);
534         }
535       };
536     }
537   }
538   public void testCustomSchedulerFailure() throws Exception {
539     TestFailingCustomScheduledService service = new TestFailingCustomScheduledService();
540     service.startAsync().awaitRunning();
541     for (int i = 1; i &lt; 4; i++) {
542       service.firstBarrier.await();
543       assertEquals(i, service.numIterations.get());
544 <a name="23"></a>      service.secondBarrier.await();
545     }
546     Thread.sleep(1000);
547     <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try {
548       service.stopAsync().awaitTerminated(100, SECONDS);
549       fail();
550     } catch (IllegalStateException e) {</b></font>
551       assertEquals(State.FAILED, service.state());
552     }
553   }
554   private static class TestFailingCustomScheduledService extends AbstractScheduledService {
555     final AtomicInteger numIterations = new AtomicInteger(0);
556     final CyclicBarrier firstBarrier = new CyclicBarrier(2);
557     final CyclicBarrier secondBarrier = new CyclicBarrier(2);
558     @Override
559     protected void runOneIteration() throws Exception {
560       numIterations.incrementAndGet();
561       firstBarrier.await();
562       secondBarrier.await();
563     }
564     @Override
565     protected ScheduledExecutorService executor() {
566       return Executors.newScheduledThreadPool(10);
567     }
568     @Override
569     protected Scheduler scheduler() {
570       return new CustomScheduler() {
571         @Override
572         protected Schedule getNextSchedule() throws Exception {
573           if (numIterations.get() &gt; 2) {
574             throw new IllegalStateException("Failed");
575           }
576           return new Schedule(DELAY, UNIT);
577         }
578       };
579     }
580   }
581 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CacheLoadingTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.cache;
2 import static com.google.common.cache.TestingCacheLoaders.bulkLoader;
3 import static com.google.common.cache.TestingCacheLoaders.constantLoader;
4 import static com.google.common.cache.TestingCacheLoaders.errorLoader;
5 import static com.google.common.cache.TestingCacheLoaders.exceptionLoader;
6 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
7 import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;
8 import static com.google.common.truth.Truth.assertThat;
9 import static java.lang.Thread.currentThread;
10 import static java.util.Arrays.asList;
11 import static java.util.concurrent.TimeUnit.MILLISECONDS;
12 <a name="0"></a>import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
13 import com.google.common.cache.TestingCacheLoaders.CountingLoader;
14 import com.google.common.cache.TestingCacheLoaders.IdentityLoader;
15 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;
16 import com.google.common.collect.ImmutableList;
17 import com.google.common.collect.ImmutableMap;
18 import com.google.common.collect.Lists;
19 import com.google.common.collect.Maps;
20 import com.google.common.testing.FakeTicker;
21 import com.google.common.testing.TestLogHandler;
22 import com.google.common.util.concurrent.Callables;
23 import com.google.common.util.concurrent.ExecutionError;
24 import com.google.common.util.concurrent.Futures;
25 import com.google.common.util.concurrent.ListenableFuture;
26 import com.google.common.util.concurrent.UncheckedExecutionException;
27 import java.io.IOException;
28 import java.lang.ref.WeakReference;
29 import java.util.List;
30 import java.util.Map;
31 import java.util.Map.Entry;
32 import java.util.concurrent.Callable;
33 import java.util.concurrent.ConcurrentMap;
34 import java.util.concurrent.CountDownLatch;
35 import java.util.concurrent.ExecutionException;
36 import java.util.concurrent.TimeUnit;
37 import java.util.concurrent.atomic.AtomicInteger;
38 import java.util.concurrent.atomic.AtomicReferenceArray;
39 import java.util.logging.LogRecord;
40 import junit.framework.TestCase;
41 public class CacheLoadingTest extends TestCase {
42   TestLogHandler logHandler</b></font>;
43   @Override
44   public void setUp() throws Exception {
45     super.setUp();
46     logHandler = new TestLogHandler();
47     LocalCache.logger.addHandler(logHandler);
48   }
49 <a name="20"></a>
50   @Override
51   public void tearDown() throws Exception {
52     <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.tearDown();
53     currentThread().interrupted();
54     LocalCache.logger.removeHandler(logHandler);
55   }
56   private Throwable popLoggedThrowable() {
57     List&lt;LogRecord&gt; logRecords = logHandler.getStoredLogRecords</b></font>();
58     assertEquals(1, logRecords.size());
59     LogRecord logRecord = logRecords.get(0);
60     logHandler.clear();
61     return logRecord.getThrown();
62   }
63   private void checkNothingLogged() {
64     assertThat(logHandler.getStoredLogRecords()).isEmpty();
65   }
66   private void checkLoggedCause(Throwable t) {
67     assertThat(popLoggedThrowable()).hasCauseThat().isSameInstanceAs(t);
68   }
69   private void checkLoggedInvalidLoad() {
70     assertThat(popLoggedThrowable()).isInstanceOf(InvalidCacheLoadException.class);
71   }
72   public void testLoad() throws ExecutionException {
73     LoadingCache&lt;Object, Object&gt; cache =
74         CacheBuilder.newBuilder().recordStats().build(identityLoader());
75     CacheStats stats = cache.stats();
76     assertEquals(0, stats.missCount());
77     assertEquals(0, stats.loadSuccessCount());
78     assertEquals(0, stats.loadExceptionCount());
79     assertEquals(0, stats.hitCount());
80     Object key = new Object();
81     assertSame(key, cache.get(key));
82     stats = cache.stats();
83     assertEquals(1, stats.missCount());
84     assertEquals(1, stats.loadSuccessCount());
85     assertEquals(0, stats.loadExceptionCount());
86     assertEquals(0, stats.hitCount());
87     key = new Object();
88     assertSame(key, cache.getUnchecked(key));
89     stats = cache.stats();
90     assertEquals(2, stats.missCount());
91     assertEquals(2, stats.loadSuccessCount());
92     assertEquals(0, stats.loadExceptionCount());
93     assertEquals(0, stats.hitCount());
94     key = new Object();
95     cache.refresh(key);
96     checkNothingLogged();
97     stats = cache.stats();
98     assertEquals(2, stats.missCount());
99     assertEquals(3, stats.loadSuccessCount());
100     assertEquals(0, stats.loadExceptionCount());
101     assertEquals(0, stats.hitCount());
102     assertSame(key, cache.get(key));
103     stats = cache.stats();
104     assertEquals(2, stats.missCount());
105     assertEquals(3, stats.loadSuccessCount());
106     assertEquals(0, stats.loadExceptionCount());
107     assertEquals(1, stats.hitCount());
108     Object value = new Object();
109     assertSame(key, cache.get(key, throwing(new Exception())));
110     stats = cache.stats();
111     assertEquals(2, stats.missCount());
112     assertEquals(3, stats.loadSuccessCount());
113     assertEquals(0, stats.loadExceptionCount());
114     assertEquals(2, stats.hitCount());
115     key = new Object();
116     assertSame(value, cache.get(key, Callables.returning(value)));
117     stats = cache.stats();
118 <a name="18"></a>    assertEquals(3, stats.missCount());
119     assertEquals(4, stats.loadSuccessCount());
120     assertEquals(0, stats.loadExceptionCount());
121     assertEquals(2, <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>stats.hitCount());
122   }
123   public void testReload() throws ExecutionException {
124     final Object one = new Object();
125     final Object two = new Object();
126     CacheLoader&lt;Object, Object&gt; loader =
127         new</b></font> CacheLoader&lt;Object, Object&gt;() {
128           @Override
129           public Object load(Object key) {
130             return one;
131           }
132           @Override
133           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
134             return Futures.immediateFuture(two);
135           }
136         };
137     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
138     Object key = new Object();
139     CacheStats stats = cache.stats();
140     assertEquals(0, stats.missCount());
141     assertEquals(0, stats.loadSuccessCount());
142     assertEquals(0, stats.loadExceptionCount());
143     assertEquals(0, stats.hitCount());
144     assertSame(one, cache.getUnchecked(key));
145     stats = cache.stats();
146     assertEquals(1, stats.missCount());
147     assertEquals(1, stats.loadSuccessCount());
148     assertEquals(0, stats.loadExceptionCount());
149     assertEquals(0, stats.hitCount());
150     cache.refresh(key);
151     checkNothingLogged();
152     stats = cache.stats();
153     assertEquals(1, stats.missCount());
154     assertEquals(2, stats.loadSuccessCount());
155     assertEquals(0, stats.loadExceptionCount());
156     assertEquals(0, stats.hitCount());
157 <a name="22"></a>
158     assertSame(two, cache.getUnchecked(key));
159     stats = cache.stats();
160     <font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(1, stats.missCount());
161     assertEquals(2, stats.loadSuccessCount());
162     assertEquals(0, stats.loadExceptionCount());
163 <a name="9"></a>    assertEquals(1, stats.hitCount());
164   }</b></font>
165   <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>public void testRefresh() {
166     final Object one = new Object();
167     final Object two = new Object();
168     FakeTicker ticker = new FakeTicker();
169     CacheLoader&lt;Object, Object&gt; loader =
170         new CacheLoader&lt;Object, Object&gt;() {
171           @</b></font>Override
172           public Object load(Object key) {
173             return one;
174           }
175           @Override
176           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
177             return Futures.immediateFuture(two);
178           }
179         };
180     LoadingCache&lt;Object, Object&gt; cache =
181         CacheBuilder.newBuilder()
182             .recordStats()
183             .ticker(ticker)
184             .refreshAfterWrite(1, MILLISECONDS)
185             .build(loader);
186     Object key = new Object();
187     CacheStats stats = cache.stats();
188     assertEquals(0, stats.missCount());
189     assertEquals(0, stats.loadSuccessCount());
190     assertEquals(0, stats.loadExceptionCount());
191     assertEquals(0, stats.hitCount());
192     assertSame(one, cache.getUnchecked(key));
193     stats = cache.stats();
194     assertEquals(1, stats.missCount());
195     assertEquals(1, stats.loadSuccessCount());
196     assertEquals(0, stats.loadExceptionCount());
197     assertEquals(0, stats.hitCount());
198     ticker.advance(1, MILLISECONDS);
199     assertSame(one, cache.getUnchecked(key));
200     stats = cache.stats();
201     assertEquals(1, stats.missCount());
202     assertEquals(1, stats.loadSuccessCount());
203     assertEquals(0, stats.loadExceptionCount());
204     assertEquals(1, stats.hitCount());
205     ticker.advance(1, MILLISECONDS);
206     assertSame(two, cache.getUnchecked(key));
207     stats = cache.stats();
208     assertEquals(1, stats.missCount());
209     assertEquals(2, stats.loadSuccessCount());
210     assertEquals(0, stats.loadExceptionCount());
211     assertEquals(2, stats.hitCount());
212     ticker.advance(1, MILLISECONDS);
213     assertSame(two, cache.getUnchecked(key));
214     stats = cache.stats();
215     assertEquals(1, stats.missCount());
216     assertEquals(2, stats.loadSuccessCount());
217     assertEquals(0, stats.loadExceptionCount());
218     assertEquals(3, stats.hitCount());
219   }
220   public void testRefresh_getIfPresent() {
221     final Object one = new Object();
222     final Object two = new Object();
223     FakeTicker ticker = new FakeTicker();
224     CacheLoader&lt;Object, Object&gt; loader =
225         new CacheLoader&lt;Object, Object&gt;() {
226           @Override
227           public Object load(Object key) {
228             return one;
229           }
230           @Override
231           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
232             return Futures.immediateFuture(two);
233           }
234         };
235     LoadingCache&lt;Object, Object&gt; cache =
236         CacheBuilder.newBuilder()
237             .recordStats()
238             .ticker(ticker)
239             .refreshAfterWrite(1, MILLISECONDS)
240             .build(loader);
241     Object key = new Object();
242     CacheStats stats = cache.stats();
243     assertEquals(0, stats.missCount());
244     assertEquals(0, stats.loadSuccessCount());
245     assertEquals(0, stats.loadExceptionCount());
246     assertEquals(0, stats.hitCount());
247     assertSame(one, cache.getUnchecked(key));
248     stats = cache.stats();
249     assertEquals(1, stats.missCount());
250     assertEquals(1, stats.loadSuccessCount());
251     assertEquals(0, stats.loadExceptionCount());
252     assertEquals(0, stats.hitCount());
253     ticker.advance(1, MILLISECONDS);
254     assertSame(one, cache.getIfPresent(key));
255     stats = cache.stats();
256     assertEquals(1, stats.missCount());
257     assertEquals(1, stats.loadSuccessCount());
258     assertEquals(0, stats.loadExceptionCount());
259     assertEquals(1, stats.hitCount());
260     ticker.advance(1, MILLISECONDS);
261     assertSame(two, cache.getIfPresent(key));
262     stats = cache.stats();
263     assertEquals(1, stats.missCount());
264     assertEquals(2, stats.loadSuccessCount());
265     assertEquals(0, stats.loadExceptionCount());
266     assertEquals(2, stats.hitCount());
267 <a name="11"></a>    ticker.advance(1, MILLISECONDS);
268     assertSame(two, cache.getIfPresent(key));
269     stats = cache.stats();
270     assertEquals(1, <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>stats.missCount());
271     assertEquals(2, stats.loadSuccessCount());
272     assertEquals(0, stats.loadExceptionCount());
273     assertEquals(3, stats.hitCount());
274   }
275   public void testBulkLoad_default() throws ExecutionException {
276     LoadingCache&lt;Integer, Integer&gt; cache =
277         CacheBuilder.newBuilder()</b></font>
278             .recordStats()
279             .build(TestingCacheLoaders.&lt;Integer&gt;identityLoader());
280     CacheStats stats = cache.stats();
281     assertEquals(0, stats.missCount());
282     assertEquals(0, stats.loadSuccessCount());
283     assertEquals(0, stats.loadExceptionCount());
284     assertEquals(0, stats.hitCount());
285     assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.&lt;Integer&gt;of()));
286     assertEquals(0, stats.missCount());
287     assertEquals(0, stats.loadSuccessCount());
288     assertEquals(0, stats.loadExceptionCount());
289     assertEquals(0, stats.hitCount());
290     assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
291     stats = cache.stats();
292     assertEquals(1, stats.missCount());
293     assertEquals(1, stats.loadSuccessCount());
294     assertEquals(0, stats.loadExceptionCount());
295     assertEquals(0, stats.hitCount());
296     assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
297     stats = cache.stats();
298     assertEquals(4, stats.missCount());
299     assertEquals(4, stats.loadSuccessCount());
300     assertEquals(0, stats.loadExceptionCount());
301     assertEquals(1, stats.hitCount());
302     assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
303     stats = cache.stats();
304     assertEquals(4, stats.missCount());
305     assertEquals(4, stats.loadSuccessCount());
306     assertEquals(0, stats.loadExceptionCount());
307     assertEquals(3, stats.hitCount());
308 <a name="7"></a>
309     assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
310     stats = <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.stats();
311     assertEquals(5, stats.missCount());
312     assertEquals(5, stats.loadSuccessCount());
313     assertEquals(0, stats.loadExceptionCount());
314     assertEquals(4, stats.hitCount());
315   }
316   public void testBulkLoad_loadAll() throws ExecutionException {
317     IdentityLoader&lt;Integer&gt; backingLoader = identityLoader();
318     CacheLoader&lt;Integer, Integer&gt; loader = bulkLoader(backingLoader)</b></font>;
319     LoadingCache&lt;Integer, Integer&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
320     CacheStats stats = cache.stats();
321     assertEquals(0, stats.missCount());
322     assertEquals(0, stats.loadSuccessCount());
323     assertEquals(0, stats.loadExceptionCount());
324     assertEquals(0, stats.hitCount());
325     assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.&lt;Integer&gt;of()));
326     assertEquals(0, stats.missCount());
327     assertEquals(0, stats.loadSuccessCount());
328     assertEquals(0, stats.loadExceptionCount());
329     assertEquals(0, stats.hitCount());
330     assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
331     stats = cache.stats();
332     assertEquals(1, stats.missCount());
333     assertEquals(1, stats.loadSuccessCount());
334     assertEquals(0, stats.loadExceptionCount());
335     assertEquals(0, stats.hitCount());
336     assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
337     stats = cache.stats();
338     assertEquals(4, stats.missCount());
339     assertEquals(2, stats.loadSuccessCount());
340     assertEquals(0, stats.loadExceptionCount());
341     assertEquals(1, stats.hitCount());
342     assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
343     stats = cache.stats();
344     assertEquals(4, stats.missCount());
345     assertEquals(2, stats.loadSuccessCount());
346     assertEquals(0, stats.loadExceptionCount());
347     assertEquals(3, stats.hitCount());
348     assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
349 <a name="10"></a>    stats = cache.stats();
350     assertEquals(5, stats.missCount());
351     assertEquals(3, stats.loadSuccessCount());
352     <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(0, stats.loadExceptionCount());
353     assertEquals(4, stats.hitCount());
354   }
355   public void testBulkLoad_extra() throws ExecutionException {
356     CacheLoader&lt;Object, Object&gt; loader =
357         new CacheLoader&lt;Object, Object&gt;() {
358           @</b></font>Override
359           public Object load(Object key) throws Exception {
360             return new Object();
361           }
362           @Override
363           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
364             Map&lt;Object, Object&gt; result = Maps.newHashMap();
365             for (Object key : keys) {
366               Object value = new Object();
367               result.put(key, value);
368               result.put(value, key);
369             }
370             return result;
371           }
372         };
373     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
374     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
375     Map&lt;Object, Object&gt; result = cache.getAll(asList(lookupKeys));
376     assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
377     for (Entry&lt;Object, Object&gt; entry : result.entrySet()) {
378       Object key = entry.getKey();
379 <a name="13"></a>      Object value = entry.getValue();
380       assertSame(value, result.get(key));
381       assertNull(result.get(value));
382       assertSame(value, <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.asMap().get(key));
383       assertSame(key, cache.asMap().get(value));
384     }
385   }
386   public void testBulkLoad_clobber() throws ExecutionException {
387     final Object extraKey = new</b></font> Object();
388 <a name="15"></a>    final Object extraValue = new Object();
389     CacheLoader&lt;Object, Object&gt; loader =
390         new CacheLoader&lt;Object, Object&gt;() {
391           <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
392           public Object load(Object key) throws Exception {
393             throw new AssertionError();
394           }
395           @Override
396           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {</b></font>
397             Map&lt;Object, Object&gt; result = Maps.newHashMap();
398             for (Object key : keys) {
399               Object value = new Object();
400               result.put(key, value);
401             }
402             result.put(extraKey, extraValue);
403             return result;
404           }
405         };
406     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
407     cache.asMap().put(extraKey, extraKey);
408     assertSame(extraKey, cache.asMap().get(extraKey));
409     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
410     Map&lt;Object, Object&gt; result = cache.getAll(asList(lookupKeys));
411     assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
412 <a name="6"></a>    for (Entry&lt;Object, Object&gt; entry : result.entrySet()) {
413       Object key = entry.getKey();
414       Object value = entry.getValue();
415       assertSame(value, <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>result.get(key));
416       assertSame(value, cache.asMap().get(key));
417     }
418     assertNull(result.get(extraKey));
419     assertSame(extraValue, cache.asMap().get(extraKey));
420   }
421   public void testBulkLoad_clobberNullValue() throws ExecutionException {
422     final Object extraKey = new</b></font> Object();
423     final Object extraValue = new Object();
424     CacheLoader&lt;Object, Object&gt; loader =
425         new CacheLoader&lt;Object, Object&gt;() {
426           @Override
427           public Object load(Object key) throws Exception {
428             throw new AssertionError();
429           }
430           @Override
431           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
432             Map&lt;Object, Object&gt; result = Maps.newHashMap();
433             for (Object key : keys) {
434               Object value = new Object();
435               result.put(key, value);
436             }
437             result.put(extraKey, extraValue);
438             result.put(extraValue, null);
439             return result;
440           }
441         };
442     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
443     cache.asMap().put(extraKey, extraKey);
444 <a name="23"></a>    assertSame(extraKey, cache.asMap().get(extraKey));
445     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
446     <font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
447       cache.getAll(asList(lookupKeys));
448       fail();
449     } catch (InvalidCacheLoadException expected) {</b></font>
450 <a name="5"></a>    }
451     for (Object key : lookupKeys) {
452       <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(cache.asMap().containsKey(key));
453     }
454     assertSame(extraValue, cache.asMap().get(extraKey));
455     assertFalse(cache.asMap().containsKey(extraValue));
456   }
457   public void testBulkLoad_clobberNullKey() throws ExecutionException {
458     final Object extraKey = new</b></font> Object();
459     final Object extraValue = new Object();
460     CacheLoader&lt;Object, Object&gt; loader =
461         new CacheLoader&lt;Object, Object&gt;() {
462           @Override
463           public Object load(Object key) throws Exception {
464             throw new AssertionError();
465           }
466           @Override
467           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
468             Map&lt;Object, Object&gt; result = Maps.newHashMap();
469             for (Object key : keys) {
470               Object value = new Object();
471               result.put(key, value);
472             }
473             result.put(extraKey, extraValue);
474             result.put(null, extraKey);
475             return result;
476           }
477         };
478     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
479     cache.asMap().put(extraKey, extraKey);
480     assertSame(extraKey, cache.asMap().get(extraKey));
481     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
482     try {
483       cache.getAll(asList(lookupKeys));
484       fail();
485     } catch (InvalidCacheLoadException expected) {
486     }
487     for (Object key : lookupKeys) {
488       assertTrue(cache.asMap().containsKey(key));
489     }
490     assertSame(extraValue, cache.asMap().get(extraKey));
491     assertFalse(cache.asMap().containsValue(extraKey));
492   }
493   public void testBulkLoad_partial() throws ExecutionException {
494     final Object extraKey = new Object();
495     final Object extraValue = new Object();
496     CacheLoader&lt;Object, Object&gt; loader =
497         new CacheLoader&lt;Object, Object&gt;() {
498           @Override
499           public Object load(Object key) throws Exception {
500             throw new AssertionError();
501           }
502           @Override
503           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
504             Map&lt;Object, Object&gt; result = Maps.newHashMap();
505             result.put(extraKey, extraValue);
506             return result;
507           }
508         };
509 <a name="1"></a>    LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
510     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
511     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
512       cache.getAll(asList(lookupKeys));
513       fail();
514     } catch (InvalidCacheLoadException expected) {
515     }
516     assertSame(extraValue, cache.asMap().get(extraKey));
517   }
518   public void testLoadNull() throws ExecutionException {
519     LoadingCache&lt;Object, Object&gt; cache =</b></font>
520         CacheBuilder.newBuilder().recordStats().build(constantLoader(null));
521     CacheStats stats = cache.stats();
522     assertEquals(0, stats.missCount());
523     assertEquals(0, stats.loadSuccessCount());
524     assertEquals(0, stats.loadExceptionCount());
525     assertEquals(0, stats.hitCount());
526     try {
527       cache.get(new Object());
528       fail();
529     } catch (InvalidCacheLoadException expected) {
530     }
531     stats = cache.stats();
532     assertEquals(1, stats.missCount());
533     assertEquals(0, stats.loadSuccessCount());
534     assertEquals(1, stats.loadExceptionCount());
535     assertEquals(0, stats.hitCount());
536     try {
537       cache.getUnchecked(new Object());
538       fail();
539     } catch (InvalidCacheLoadException expected) {
540     }
541     stats = cache.stats();
542     assertEquals(2, stats.missCount());
543     assertEquals(0, stats.loadSuccessCount());
544     assertEquals(2, stats.loadExceptionCount());
545     assertEquals(0, stats.hitCount());
546     cache.refresh(new Object());
547     checkLoggedInvalidLoad();
548     stats = cache.stats();
549     assertEquals(2, stats.missCount());
550     assertEquals(0, stats.loadSuccessCount());
551     assertEquals(3, stats.loadExceptionCount());
552     assertEquals(0, stats.hitCount());
553     try {
554       cache.get(new Object(), Callables.returning(null));
555       fail();
556     } catch (InvalidCacheLoadException expected) {
557     }
558     stats = cache.stats();
559     assertEquals(3, stats.missCount());
560     assertEquals(0, stats.loadSuccessCount());
561     assertEquals(4, stats.loadExceptionCount());
562     assertEquals(0, stats.hitCount());
563     try {
564       cache.getAll(asList(new Object()));
565       fail();
566     } catch (InvalidCacheLoadException expected) {
567     }
568     stats = cache.stats();
569     assertEquals(4, stats.missCount());
570     assertEquals(0, stats.loadSuccessCount());
571     assertEquals(5, stats.loadExceptionCount());
572     assertEquals(0, stats.hitCount());
573   }
574   public void testReloadNull() throws ExecutionException {
575     final Object one = new Object();
576     CacheLoader&lt;Object, Object&gt; loader =
577         new CacheLoader&lt;Object, Object&gt;() {
578           @Override
579           public Object load(Object key) {
580             return one;
581           }
582           @Override
583           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
584             return null;
585           }
586         };
587     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
588     Object key = new Object();
589     CacheStats stats = cache.stats();
590     assertEquals(0, stats.missCount());
591     assertEquals(0, stats.loadSuccessCount());
592     assertEquals(0, stats.loadExceptionCount());
593     assertEquals(0, stats.hitCount());
594     assertSame(one, cache.getUnchecked(key));
595     stats = cache.stats();
596     assertEquals(1, stats.missCount());
597     assertEquals(1, stats.loadSuccessCount());
598     assertEquals(0, stats.loadExceptionCount());
599     assertEquals(0, stats.hitCount());
600     cache.refresh(key);
601     checkLoggedInvalidLoad();
602     stats = cache.stats();
603     assertEquals(1, stats.missCount());
604     assertEquals(1, stats.loadSuccessCount());
605     assertEquals(1, stats.loadExceptionCount());
606     assertEquals(0, stats.hitCount());
607     assertSame(one, cache.getUnchecked(key));
608     stats = cache.stats();
609     assertEquals(1, stats.missCount());
610     assertEquals(1, stats.loadSuccessCount());
611     assertEquals(1, stats.loadExceptionCount());
612     assertEquals(1, stats.hitCount());
613   }
614   public void testReloadNullFuture() throws ExecutionException {
615     final Object one = new Object();
616     CacheLoader&lt;Object, Object&gt; loader =
617         new CacheLoader&lt;Object, Object&gt;() {
618           @Override
619           public Object load(Object key) {
620             return one;
621           }
622           @Override
623           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
624             return Futures.immediateFuture(null);
625           }
626         };
627     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
628     Object key = new Object();
629     CacheStats stats = cache.stats();
630     assertEquals(0, stats.missCount());
631     assertEquals(0, stats.loadSuccessCount());
632     assertEquals(0, stats.loadExceptionCount());
633     assertEquals(0, stats.hitCount());
634     assertSame(one, cache.getUnchecked(key));
635     stats = cache.stats();
636     assertEquals(1, stats.missCount());
637     assertEquals(1, stats.loadSuccessCount());
638     assertEquals(0, stats.loadExceptionCount());
639     assertEquals(0, stats.hitCount());
640     cache.refresh(key);
641     checkLoggedInvalidLoad();
642     stats = cache.stats();
643     assertEquals(1, stats.missCount());
644     assertEquals(1, stats.loadSuccessCount());
645     assertEquals(1, stats.loadExceptionCount());
646     assertEquals(0, stats.hitCount());
647     assertSame(one, cache.getUnchecked(key));
648     stats = cache.stats();
649     assertEquals(1, stats.missCount());
650     assertEquals(1, stats.loadSuccessCount());
651     assertEquals(1, stats.loadExceptionCount());
652     assertEquals(1, stats.hitCount());
653   }
654   public void testRefreshNull() {
655     final Object one = new Object();
656     FakeTicker ticker = new FakeTicker();
657     CacheLoader&lt;Object, Object&gt; loader =
658         new CacheLoader&lt;Object, Object&gt;() {
659           @Override
660           public Object load(Object key) {
661             return one;
662           }
663           @Override
664           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
665             return Futures.immediateFuture(null);
666           }
667         };
668     LoadingCache&lt;Object, Object&gt; cache =
669         CacheBuilder.newBuilder()
670             .recordStats()
671             .ticker(ticker)
672             .refreshAfterWrite(1, MILLISECONDS)
673             .build(loader);
674     Object key = new Object();
675     CacheStats stats = cache.stats();
676     assertEquals(0, stats.missCount());
677     assertEquals(0, stats.loadSuccessCount());
678     assertEquals(0, stats.loadExceptionCount());
679     assertEquals(0, stats.hitCount());
680     assertSame(one, cache.getUnchecked(key));
681     stats = cache.stats();
682     assertEquals(1, stats.missCount());
683     assertEquals(1, stats.loadSuccessCount());
684     assertEquals(0, stats.loadExceptionCount());
685     assertEquals(0, stats.hitCount());
686     ticker.advance(1, MILLISECONDS);
687     assertSame(one, cache.getUnchecked(key));
688     stats = cache.stats();
689     assertEquals(1, stats.missCount());
690     assertEquals(1, stats.loadSuccessCount());
691     assertEquals(0, stats.loadExceptionCount());
692     assertEquals(1, stats.hitCount());
693     ticker.advance(1, MILLISECONDS);
694     assertSame(one, cache.getUnchecked(key));
695     stats = cache.stats();
696     assertEquals(1, stats.missCount());
697     assertEquals(1, stats.loadSuccessCount());
698     assertEquals(1, stats.loadExceptionCount());
699     assertEquals(2, stats.hitCount());
700     ticker.advance(1, MILLISECONDS);
701     assertSame(one, cache.getUnchecked(key));
702     stats = cache.stats();
703     assertEquals(1, stats.missCount());
704     assertEquals(1, stats.loadSuccessCount());
705     assertEquals(2, stats.loadExceptionCount());
706     assertEquals(3, stats.hitCount());
707   }
708   public void testBulkLoadNull() throws ExecutionException {
709     LoadingCache&lt;Object, Object&gt; cache =
710         CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));
711     CacheStats stats = cache.stats();
712     assertEquals(0, stats.missCount());
713     assertEquals(0, stats.loadSuccessCount());
714     assertEquals(0, stats.loadExceptionCount());
715     assertEquals(0, stats.hitCount());
716     try {
717       cache.getAll(asList(new Object()));
718       fail();
719     } catch (InvalidCacheLoadException expected) {
720     }
721     stats = cache.stats();
722     assertEquals(1, stats.missCount());
723     assertEquals(0, stats.loadSuccessCount());
724     assertEquals(1, stats.loadExceptionCount());
725     assertEquals(0, stats.hitCount());
726   }
727   public void testBulkLoadNullMap() throws ExecutionException {
728     LoadingCache&lt;Object, Object&gt; cache =
729         CacheBuilder.newBuilder()
730             .recordStats()
731             .build(
732                 new CacheLoader&lt;Object, Object&gt;() {
733                   @Override
734                   public Object load(Object key) {
735                     throw new AssertionError();
736                   }
737                   @Override
738                   public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) {
739                     return null;
740                   }
741                 });
742     CacheStats stats = cache.stats();
743     assertEquals(0, stats.missCount());
744     assertEquals(0, stats.loadSuccessCount());
745     assertEquals(0, stats.loadExceptionCount());
746     assertEquals(0, stats.hitCount());
747     try {
748       cache.getAll(asList(new Object()));
749       fail();
750     } catch (InvalidCacheLoadException expected) {
751     }
752     stats = cache.stats();
753     assertEquals(1, stats.missCount());
754     assertEquals(0, stats.loadSuccessCount());
755     assertEquals(1, stats.loadExceptionCount());
756     assertEquals(0, stats.hitCount());
757   }
758   public void testLoadError() throws ExecutionException {
759     Error e = new Error();
760     CacheLoader&lt;Object, Object&gt; loader = errorLoader(e);
761     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
762     CacheStats stats = cache.stats();
763     assertEquals(0, stats.missCount());
764     assertEquals(0, stats.loadSuccessCount());
765     assertEquals(0, stats.loadExceptionCount());
766     assertEquals(0, stats.hitCount());
767     try {
768       cache.get(new Object());
769       fail();
770     } catch (ExecutionError expected) {
771       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
772     }
773     stats = cache.stats();
774     assertEquals(1, stats.missCount());
775     assertEquals(0, stats.loadSuccessCount());
776     assertEquals(1, stats.loadExceptionCount());
777     assertEquals(0, stats.hitCount());
778     try {
779       cache.getUnchecked(new Object());
780       fail();
781     } catch (ExecutionError expected) {
782       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
783     }
784     stats = cache.stats();
785     assertEquals(2, stats.missCount());
786     assertEquals(0, stats.loadSuccessCount());
787     assertEquals(2, stats.loadExceptionCount());
788     assertEquals(0, stats.hitCount());
789     cache.refresh(new Object());
790     checkLoggedCause(e);
791     stats = cache.stats();
792     assertEquals(2, stats.missCount());
793     assertEquals(0, stats.loadSuccessCount());
794     assertEquals(3, stats.loadExceptionCount());
795     assertEquals(0, stats.hitCount());
796     final Error callableError = new Error();
797     try {
798       cache.get(
799           new Object(),
800           new Callable&lt;Object&gt;() {
801             @Override
802             public Object call() {
803               throw callableError;
804             }
805           });
806       fail();
807     } catch (ExecutionError expected) {
808       assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);
809     }
810     stats = cache.stats();
811     assertEquals(3, stats.missCount());
812     assertEquals(0, stats.loadSuccessCount());
813     assertEquals(4, stats.loadExceptionCount());
814     assertEquals(0, stats.hitCount());
815     try {
816       cache.getAll(asList(new Object()));
817       fail();
818     } catch (ExecutionError expected) {
819       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
820     }
821     stats = cache.stats();
822     assertEquals(4, stats.missCount());
823     assertEquals(0, stats.loadSuccessCount());
824     assertEquals(5, stats.loadExceptionCount());
825     assertEquals(0, stats.hitCount());
826   }
827   public void testReloadError() throws ExecutionException {
828     final Object one = new Object();
829     final Error e = new Error();
830     CacheLoader&lt;Object, Object&gt; loader =
831         new CacheLoader&lt;Object, Object&gt;() {
832           @Override
833           public Object load(Object key) {
834             return one;
835           }
836           @Override
837           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
838             throw e;
839           }
840         };
841     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
842     Object key = new Object();
843     CacheStats stats = cache.stats();
844     assertEquals(0, stats.missCount());
845     assertEquals(0, stats.loadSuccessCount());
846     assertEquals(0, stats.loadExceptionCount());
847     assertEquals(0, stats.hitCount());
848     assertSame(one, cache.getUnchecked(key));
849     stats = cache.stats();
850     assertEquals(1, stats.missCount());
851     assertEquals(1, stats.loadSuccessCount());
852     assertEquals(0, stats.loadExceptionCount());
853     assertEquals(0, stats.hitCount());
854     cache.refresh(key);
855     checkLoggedCause(e);
856     stats = cache.stats();
857     assertEquals(1, stats.missCount());
858     assertEquals(1, stats.loadSuccessCount());
859     assertEquals(1, stats.loadExceptionCount());
860     assertEquals(0, stats.hitCount());
861     assertSame(one, cache.getUnchecked(key));
862     stats = cache.stats();
863     assertEquals(1, stats.missCount());
864     assertEquals(1, stats.loadSuccessCount());
865     assertEquals(1, stats.loadExceptionCount());
866     assertEquals(1, stats.hitCount());
867   }
868   public void testReloadFutureError() throws ExecutionException {
869     final Object one = new Object();
870     final Error e = new Error();
871     CacheLoader&lt;Object, Object&gt; loader =
872         new CacheLoader&lt;Object, Object&gt;() {
873           @Override
874           public Object load(Object key) {
875             return one;
876           }
877           @Override
878           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
879             return Futures.immediateFailedFuture(e);
880           }
881         };
882     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
883     Object key = new Object();
884     CacheStats stats = cache.stats();
885     assertEquals(0, stats.missCount());
886     assertEquals(0, stats.loadSuccessCount());
887     assertEquals(0, stats.loadExceptionCount());
888     assertEquals(0, stats.hitCount());
889     assertSame(one, cache.getUnchecked(key));
890     stats = cache.stats();
891     assertEquals(1, stats.missCount());
892     assertEquals(1, stats.loadSuccessCount());
893     assertEquals(0, stats.loadExceptionCount());
894     assertEquals(0, stats.hitCount());
895     cache.refresh(key);
896     checkLoggedCause(e);
897     stats = cache.stats();
898     assertEquals(1, stats.missCount());
899     assertEquals(1, stats.loadSuccessCount());
900     assertEquals(1, stats.loadExceptionCount());
901     assertEquals(0, stats.hitCount());
902     assertSame(one, cache.getUnchecked(key));
903     stats = cache.stats();
904     assertEquals(1, stats.missCount());
905     assertEquals(1, stats.loadSuccessCount());
906     assertEquals(1, stats.loadExceptionCount());
907     assertEquals(1, stats.hitCount());
908   }
909   public void testRefreshError() {
910     final Object one = new Object();
911     final Error e = new Error();
912     FakeTicker ticker = new FakeTicker();
913     CacheLoader&lt;Object, Object&gt; loader =
914         new CacheLoader&lt;Object, Object&gt;() {
915           @Override
916           public Object load(Object key) {
917             return one;
918           }
919           @Override
920           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
921             return Futures.immediateFailedFuture(e);
922           }
923         };
924     LoadingCache&lt;Object, Object&gt; cache =
925         CacheBuilder.newBuilder()
926             .recordStats()
927             .ticker(ticker)
928             .refreshAfterWrite(1, MILLISECONDS)
929             .build(loader);
930     Object key = new Object();
931     CacheStats stats = cache.stats();
932     assertEquals(0, stats.missCount());
933     assertEquals(0, stats.loadSuccessCount());
934     assertEquals(0, stats.loadExceptionCount());
935     assertEquals(0, stats.hitCount());
936     assertSame(one, cache.getUnchecked(key));
937     stats = cache.stats();
938     assertEquals(1, stats.missCount());
939     assertEquals(1, stats.loadSuccessCount());
940     assertEquals(0, stats.loadExceptionCount());
941     assertEquals(0, stats.hitCount());
942     ticker.advance(1, MILLISECONDS);
943     assertSame(one, cache.getUnchecked(key));
944     stats = cache.stats();
945     assertEquals(1, stats.missCount());
946     assertEquals(1, stats.loadSuccessCount());
947     assertEquals(0, stats.loadExceptionCount());
948     assertEquals(1, stats.hitCount());
949     ticker.advance(1, MILLISECONDS);
950     assertSame(one, cache.getUnchecked(key));
951     stats = cache.stats();
952     assertEquals(1, stats.missCount());
953     assertEquals(1, stats.loadSuccessCount());
954     assertEquals(1, stats.loadExceptionCount());
955     assertEquals(2, stats.hitCount());
956     ticker.advance(1, MILLISECONDS);
957     assertSame(one, cache.getUnchecked(key));
958     stats = cache.stats();
959     assertEquals(1, stats.missCount());
960     assertEquals(1, stats.loadSuccessCount());
961     assertEquals(2, stats.loadExceptionCount());
962     assertEquals(3, stats.hitCount());
963   }
964   public void testBulkLoadError() throws ExecutionException {
965     Error e = new Error();
966     CacheLoader&lt;Object, Object&gt; loader = errorLoader(e);
967     LoadingCache&lt;Object, Object&gt; cache =
968         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
969     CacheStats stats = cache.stats();
970     assertEquals(0, stats.missCount());
971     assertEquals(0, stats.loadSuccessCount());
972     assertEquals(0, stats.loadExceptionCount());
973     assertEquals(0, stats.hitCount());
974     try {
975       cache.getAll(asList(new Object()));
976       fail();
977     } catch (ExecutionError expected) {
978       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
979     }
980     stats = cache.stats();
981     assertEquals(1, stats.missCount());
982     assertEquals(0, stats.loadSuccessCount());
983     assertEquals(1, stats.loadExceptionCount());
984     assertEquals(0, stats.hitCount());
985   }
986   public void testLoadCheckedException() {
987     Exception e = new Exception();
988     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
989     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
990     CacheStats stats = cache.stats();
991     assertEquals(0, stats.missCount());
992     assertEquals(0, stats.loadSuccessCount());
993     assertEquals(0, stats.loadExceptionCount());
994     assertEquals(0, stats.hitCount());
995     try {
996       cache.get(new Object());
997       fail();
998     } catch (ExecutionException expected) {
999       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1000     }
1001     stats = cache.stats();
1002     assertEquals(1, stats.missCount());
1003     assertEquals(0, stats.loadSuccessCount());
1004     assertEquals(1, stats.loadExceptionCount());
1005     assertEquals(0, stats.hitCount());
1006     try {
1007       cache.getUnchecked(new Object());
1008       fail();
1009     } catch (UncheckedExecutionException expected) {
1010       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1011     }
1012     stats = cache.stats();
1013     assertEquals(2, stats.missCount());
1014     assertEquals(0, stats.loadSuccessCount());
1015     assertEquals(2, stats.loadExceptionCount());
1016     assertEquals(0, stats.hitCount());
1017     cache.refresh(new Object());
1018     checkLoggedCause(e);
1019     stats = cache.stats();
1020     assertEquals(2, stats.missCount());
1021     assertEquals(0, stats.loadSuccessCount());
1022     assertEquals(3, stats.loadExceptionCount());
1023     assertEquals(0, stats.hitCount());
1024     Exception callableException = new Exception();
1025     try {
1026       cache.get(new Object(), throwing(callableException));
1027       fail();
1028     } catch (ExecutionException expected) {
1029       assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
1030     }
1031     stats = cache.stats();
1032     assertEquals(3, stats.missCount());
1033     assertEquals(0, stats.loadSuccessCount());
1034     assertEquals(4, stats.loadExceptionCount());
1035     assertEquals(0, stats.hitCount());
1036     try {
1037       cache.getAll(asList(new Object()));
1038       fail();
1039     } catch (ExecutionException expected) {
1040       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1041     }
1042     stats = cache.stats();
1043     assertEquals(4, stats.missCount());
1044     assertEquals(0, stats.loadSuccessCount());
1045     assertEquals(5, stats.loadExceptionCount());
1046     assertEquals(0, stats.hitCount());
1047   }
1048   public void testLoadInterruptedException() {
1049     Exception e = new InterruptedException();
1050     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1051     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1052     CacheStats stats = cache.stats();
1053     assertEquals(0, stats.missCount());
1054     assertEquals(0, stats.loadSuccessCount());
1055     assertEquals(0, stats.loadExceptionCount());
1056     assertEquals(0, stats.hitCount());
1057     assertFalse(currentThread().interrupted());
1058     try {
1059       cache.get(new Object());
1060       fail();
1061     } catch (ExecutionException expected) {
1062       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1063     }
1064     assertTrue(currentThread().interrupted());
1065     stats = cache.stats();
1066     assertEquals(1, stats.missCount());
1067     assertEquals(0, stats.loadSuccessCount());
1068     assertEquals(1, stats.loadExceptionCount());
1069     assertEquals(0, stats.hitCount());
1070     try {
1071       cache.getUnchecked(new Object());
1072       fail();
1073     } catch (UncheckedExecutionException expected) {
1074       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1075     }
1076     assertTrue(currentThread().interrupted());
1077     stats = cache.stats();
1078     assertEquals(2, stats.missCount());
1079     assertEquals(0, stats.loadSuccessCount());
1080     assertEquals(2, stats.loadExceptionCount());
1081     assertEquals(0, stats.hitCount());
1082     cache.refresh(new Object());
1083     assertTrue(currentThread().interrupted());
1084     checkLoggedCause(e);
1085     stats = cache.stats();
1086     assertEquals(2, stats.missCount());
1087     assertEquals(0, stats.loadSuccessCount());
1088     assertEquals(3, stats.loadExceptionCount());
1089     assertEquals(0, stats.hitCount());
1090 <a name="8"></a>
1091     Exception callableException = new InterruptedException();
1092     try {
1093       cache.get(new Object(), <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>throwing(callableException));
1094       fail();
1095     } catch (ExecutionException expected) {
1096       assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
1097     }
1098     assertTrue(currentThread</b></font>().interrupted());
1099     stats = cache.stats();
1100     assertEquals(3, stats.missCount());
1101     assertEquals(0, stats.loadSuccessCount());
1102     assertEquals(4, stats.loadExceptionCount());
1103     assertEquals(0, stats.hitCount());
1104     try {
1105       cache.getAll(asList(new Object()));
1106       fail();
1107     } catch (ExecutionException expected) {
1108       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1109     }
1110     assertTrue(currentThread().interrupted());
1111     stats = cache.stats();
1112     assertEquals(4, stats.missCount());
1113     assertEquals(0, stats.loadSuccessCount());
1114     assertEquals(5, stats.loadExceptionCount());
1115     assertEquals(0, stats.hitCount());
1116   }
1117   public void testReloadCheckedException() {
1118     final Object one = new Object();
1119     final Exception e = new Exception();
1120     CacheLoader&lt;Object, Object&gt; loader =
1121         new CacheLoader&lt;Object, Object&gt;() {
1122           @Override
1123           public Object load(Object key) {
1124             return one;
1125           }
1126           @Override
1127           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) throws Exception {
1128             throw e;
1129           }
1130         };
1131     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1132     Object key = new Object();
1133     CacheStats stats = cache.stats();
1134     assertEquals(0, stats.missCount());
1135     assertEquals(0, stats.loadSuccessCount());
1136     assertEquals(0, stats.loadExceptionCount());
1137     assertEquals(0, stats.hitCount());
1138     assertSame(one, cache.getUnchecked(key));
1139     stats = cache.stats();
1140     assertEquals(1, stats.missCount());
1141     assertEquals(1, stats.loadSuccessCount());
1142     assertEquals(0, stats.loadExceptionCount());
1143     assertEquals(0, stats.hitCount());
1144     cache.refresh(key);
1145     checkLoggedCause(e);
1146     stats = cache.stats();
1147     assertEquals(1, stats.missCount());
1148     assertEquals(1, stats.loadSuccessCount());
1149     assertEquals(1, stats.loadExceptionCount());
1150     assertEquals(0, stats.hitCount());
1151     assertSame(one, cache.getUnchecked(key));
1152     stats = cache.stats();
1153     assertEquals(1, stats.missCount());
1154     assertEquals(1, stats.loadSuccessCount());
1155     assertEquals(1, stats.loadExceptionCount());
1156     assertEquals(1, stats.hitCount());
1157   }
1158   public void testReloadFutureCheckedException() {
1159     final Object one = new Object();
1160     final Exception e = new Exception();
1161     CacheLoader&lt;Object, Object&gt; loader =
1162         new CacheLoader&lt;Object, Object&gt;() {
1163           @Override
1164           public Object load(Object key) {
1165             return one;
1166           }
1167           @Override
1168           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
1169             return Futures.immediateFailedFuture(e);
1170           }
1171         };
1172     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1173     Object key = new Object();
1174     CacheStats stats = cache.stats();
1175     assertEquals(0, stats.missCount());
1176     assertEquals(0, stats.loadSuccessCount());
1177     assertEquals(0, stats.loadExceptionCount());
1178     assertEquals(0, stats.hitCount());
1179     assertSame(one, cache.getUnchecked(key));
1180     stats = cache.stats();
1181     assertEquals(1, stats.missCount());
1182     assertEquals(1, stats.loadSuccessCount());
1183     assertEquals(0, stats.loadExceptionCount());
1184     assertEquals(0, stats.hitCount());
1185     cache.refresh(key);
1186     checkLoggedCause(e);
1187     stats = cache.stats();
1188     assertEquals(1, stats.missCount());
1189     assertEquals(1, stats.loadSuccessCount());
1190     assertEquals(1, stats.loadExceptionCount());
1191     assertEquals(0, stats.hitCount());
1192     assertSame(one, cache.getUnchecked(key));
1193     stats = cache.stats();
1194     assertEquals(1, stats.missCount());
1195     assertEquals(1, stats.loadSuccessCount());
1196     assertEquals(1, stats.loadExceptionCount());
1197     assertEquals(1, stats.hitCount());
1198   }
1199   public void testRefreshCheckedException() {
1200     final Object one = new Object();
1201     final Exception e = new Exception();
1202     FakeTicker ticker = new FakeTicker();
1203     CacheLoader&lt;Object, Object&gt; loader =
1204         new CacheLoader&lt;Object, Object&gt;() {
1205           @Override
1206           public Object load(Object key) {
1207             return one;
1208           }
1209           @Override
1210           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
1211             return Futures.immediateFailedFuture(e);
1212           }
1213         };
1214     LoadingCache&lt;Object, Object&gt; cache =
1215         CacheBuilder.newBuilder()
1216             .recordStats()
1217             .ticker(ticker)
1218             .refreshAfterWrite(1, MILLISECONDS)
1219             .build(loader);
1220     Object key = new Object();
1221     CacheStats stats = cache.stats();
1222     assertEquals(0, stats.missCount());
1223     assertEquals(0, stats.loadSuccessCount());
1224     assertEquals(0, stats.loadExceptionCount());
1225     assertEquals(0, stats.hitCount());
1226     assertSame(one, cache.getUnchecked(key));
1227     stats = cache.stats();
1228     assertEquals(1, stats.missCount());
1229     assertEquals(1, stats.loadSuccessCount());
1230     assertEquals(0, stats.loadExceptionCount());
1231     assertEquals(0, stats.hitCount());
1232     ticker.advance(1, MILLISECONDS);
1233     assertSame(one, cache.getUnchecked(key));
1234     stats = cache.stats();
1235     assertEquals(1, stats.missCount());
1236     assertEquals(1, stats.loadSuccessCount());
1237     assertEquals(0, stats.loadExceptionCount());
1238     assertEquals(1, stats.hitCount());
1239     ticker.advance(1, MILLISECONDS);
1240     assertSame(one, cache.getUnchecked(key));
1241     stats = cache.stats();
1242     assertEquals(1, stats.missCount());
1243     assertEquals(1, stats.loadSuccessCount());
1244     assertEquals(1, stats.loadExceptionCount());
1245     assertEquals(2, stats.hitCount());
1246     ticker.advance(1, MILLISECONDS);
1247     assertSame(one, cache.getUnchecked(key));
1248     stats = cache.stats();
1249     assertEquals(1, stats.missCount());
1250     assertEquals(1, stats.loadSuccessCount());
1251     assertEquals(2, stats.loadExceptionCount());
1252     assertEquals(3, stats.hitCount());
1253   }
1254   public void testBulkLoadCheckedException() {
1255     Exception e = new Exception();
1256     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1257     LoadingCache&lt;Object, Object&gt; cache =
1258         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
1259     CacheStats stats = cache.stats();
1260     assertEquals(0, stats.missCount());
1261     assertEquals(0, stats.loadSuccessCount());
1262     assertEquals(0, stats.loadExceptionCount());
1263     assertEquals(0, stats.hitCount());
1264     try {
1265       cache.getAll(asList(new Object()));
1266       fail();
1267     } catch (ExecutionException expected) {
1268       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1269     }
1270     stats = cache.stats();
1271     assertEquals(1, stats.missCount());
1272     assertEquals(0, stats.loadSuccessCount());
1273     assertEquals(1, stats.loadExceptionCount());
1274     assertEquals(0, stats.hitCount());
1275   }
1276   public void testBulkLoadInterruptedException() {
1277     Exception e = new InterruptedException();
1278     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1279     LoadingCache&lt;Object, Object&gt; cache =
1280         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
1281     CacheStats stats = cache.stats();
1282     assertEquals(0, stats.missCount());
1283     assertEquals(0, stats.loadSuccessCount());
1284     assertEquals(0, stats.loadExceptionCount());
1285     assertEquals(0, stats.hitCount());
1286     try {
1287       cache.getAll(asList(new Object()));
1288       fail();
1289     } catch (ExecutionException expected) {
1290       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1291     }
1292     assertTrue(currentThread().interrupted());
1293     stats = cache.stats();
1294     assertEquals(1, stats.missCount());
1295     assertEquals(0, stats.loadSuccessCount());
1296     assertEquals(1, stats.loadExceptionCount());
1297     assertEquals(0, stats.hitCount());
1298   }
1299   public void testLoadUncheckedException() throws ExecutionException {
1300     Exception e = new RuntimeException();
1301     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1302     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1303     CacheStats stats = cache.stats();
1304     assertEquals(0, stats.missCount());
1305     assertEquals(0, stats.loadSuccessCount());
1306     assertEquals(0, stats.loadExceptionCount());
1307     assertEquals(0, stats.hitCount());
1308     try {
1309       cache.get(new Object());
1310       fail();
1311     } catch (UncheckedExecutionException expected) {
1312       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1313     }
1314     stats = cache.stats();
1315     assertEquals(1, stats.missCount());
1316     assertEquals(0, stats.loadSuccessCount());
1317     assertEquals(1, stats.loadExceptionCount());
1318     assertEquals(0, stats.hitCount());
1319     try {
1320       cache.getUnchecked(new Object());
1321       fail();
1322     } catch (UncheckedExecutionException expected) {
1323       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1324     }
1325     stats = cache.stats();
1326     assertEquals(2, stats.missCount());
1327     assertEquals(0, stats.loadSuccessCount());
1328     assertEquals(2, stats.loadExceptionCount());
1329     assertEquals(0, stats.hitCount());
1330     cache.refresh(new Object());
1331     checkLoggedCause(e);
1332     stats = cache.stats();
1333     assertEquals(2, stats.missCount());
1334     assertEquals(0, stats.loadSuccessCount());
1335     assertEquals(3, stats.loadExceptionCount());
1336     assertEquals(0, stats.hitCount());
1337     Exception callableException = new RuntimeException();
1338     try {
1339       cache.get(new Object(), throwing(callableException));
1340       fail();
1341     } catch (UncheckedExecutionException expected) {
1342       assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
1343     }
1344     stats = cache.stats();
1345     assertEquals(3, stats.missCount());
1346     assertEquals(0, stats.loadSuccessCount());
1347     assertEquals(4, stats.loadExceptionCount());
1348     assertEquals(0, stats.hitCount());
1349     try {
1350       cache.getAll(asList(new Object()));
1351       fail();
1352     } catch (UncheckedExecutionException expected) {
1353       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1354     }
1355     stats = cache.stats();
1356     assertEquals(4, stats.missCount());
1357     assertEquals(0, stats.loadSuccessCount());
1358     assertEquals(5, stats.loadExceptionCount());
1359     assertEquals(0, stats.hitCount());
1360   }
1361   public void testReloadUncheckedException() throws ExecutionException {
1362     final Object one = new Object();
1363     final Exception e = new RuntimeException();
1364     CacheLoader&lt;Object, Object&gt; loader =
1365         new CacheLoader&lt;Object, Object&gt;() {
1366           @Override
1367           public Object load(Object key) {
1368             return one;
1369           }
1370           @Override
1371           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) throws Exception {
1372             throw e;
1373           }
1374         };
1375     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1376     Object key = new Object();
1377     CacheStats stats = cache.stats();
1378     assertEquals(0, stats.missCount());
1379     assertEquals(0, stats.loadSuccessCount());
1380     assertEquals(0, stats.loadExceptionCount());
1381     assertEquals(0, stats.hitCount());
1382     assertSame(one, cache.getUnchecked(key));
1383     stats = cache.stats();
1384     assertEquals(1, stats.missCount());
1385     assertEquals(1, stats.loadSuccessCount());
1386     assertEquals(0, stats.loadExceptionCount());
1387     assertEquals(0, stats.hitCount());
1388     cache.refresh(key);
1389     checkLoggedCause(e);
1390     stats = cache.stats();
1391     assertEquals(1, stats.missCount());
1392     assertEquals(1, stats.loadSuccessCount());
1393     assertEquals(1, stats.loadExceptionCount());
1394     assertEquals(0, stats.hitCount());
1395     assertSame(one, cache.getUnchecked(key));
1396     stats = cache.stats();
1397     assertEquals(1, stats.missCount());
1398     assertEquals(1, stats.loadSuccessCount());
1399     assertEquals(1, stats.loadExceptionCount());
1400     assertEquals(1, stats.hitCount());
1401   }
1402   public void testReloadFutureUncheckedException() throws ExecutionException {
1403     final Object one = new Object();
1404     final Exception e = new RuntimeException();
1405     CacheLoader&lt;Object, Object&gt; loader =
1406         new CacheLoader&lt;Object, Object&gt;() {
1407           @Override
1408           public Object load(Object key) {
1409             return one;
1410           }
1411           @Override
1412           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
1413             return Futures.immediateFailedFuture(e);
1414           }
1415         };
1416     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1417     Object key = new Object();
1418     CacheStats stats = cache.stats();
1419     assertEquals(0, stats.missCount());
1420     assertEquals(0, stats.loadSuccessCount());
1421     assertEquals(0, stats.loadExceptionCount());
1422     assertEquals(0, stats.hitCount());
1423     assertSame(one, cache.getUnchecked(key));
1424     stats = cache.stats();
1425     assertEquals(1, stats.missCount());
1426     assertEquals(1, stats.loadSuccessCount());
1427     assertEquals(0, stats.loadExceptionCount());
1428     assertEquals(0, stats.hitCount());
1429     cache.refresh(key);
1430     checkLoggedCause(e);
1431     stats = cache.stats();
1432     assertEquals(1, stats.missCount());
1433     assertEquals(1, stats.loadSuccessCount());
1434     assertEquals(1, stats.loadExceptionCount());
1435     assertEquals(0, stats.hitCount());
1436     assertSame(one, cache.getUnchecked(key));
1437     stats = cache.stats();
1438     assertEquals(1, stats.missCount());
1439     assertEquals(1, stats.loadSuccessCount());
1440     assertEquals(1, stats.loadExceptionCount());
1441     assertEquals(1, stats.hitCount());
1442   }
1443   public void testRefreshUncheckedException() {
1444     final Object one = new Object();
1445     final Exception e = new RuntimeException();
1446     FakeTicker ticker = new FakeTicker();
1447     CacheLoader&lt;Object, Object&gt; loader =
1448         new CacheLoader&lt;Object, Object&gt;() {
1449           @Override
1450           public Object load(Object key) {
1451             return one;
1452           }
1453           @Override
1454           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
1455             return Futures.immediateFailedFuture(e);
1456           }
1457         };
1458     LoadingCache&lt;Object, Object&gt; cache =
1459         CacheBuilder.newBuilder()
1460             .recordStats()
1461             .ticker(ticker)
1462             .refreshAfterWrite(1, MILLISECONDS)
1463             .build(loader);
1464     Object key = new Object();
1465     CacheStats stats = cache.stats();
1466     assertEquals(0, stats.missCount());
1467     assertEquals(0, stats.loadSuccessCount());
1468     assertEquals(0, stats.loadExceptionCount());
1469     assertEquals(0, stats.hitCount());
1470     assertSame(one, cache.getUnchecked(key));
1471     stats = cache.stats();
1472     assertEquals(1, stats.missCount());
1473     assertEquals(1, stats.loadSuccessCount());
1474     assertEquals(0, stats.loadExceptionCount());
1475     assertEquals(0, stats.hitCount());
1476     ticker.advance(1, MILLISECONDS);
1477     assertSame(one, cache.getUnchecked(key));
1478     stats = cache.stats();
1479     assertEquals(1, stats.missCount());
1480     assertEquals(1, stats.loadSuccessCount());
1481     assertEquals(0, stats.loadExceptionCount());
1482     assertEquals(1, stats.hitCount());
1483     ticker.advance(1, MILLISECONDS);
1484     assertSame(one, cache.getUnchecked(key));
1485     stats = cache.stats();
1486     assertEquals(1, stats.missCount());
1487     assertEquals(1, stats.loadSuccessCount());
1488     assertEquals(1, stats.loadExceptionCount());
1489     assertEquals(2, stats.hitCount());
1490     ticker.advance(1, MILLISECONDS);
1491     assertSame(one, cache.getUnchecked(key));
1492     stats = cache.stats();
1493     assertEquals(1, stats.missCount());
1494     assertEquals(1, stats.loadSuccessCount());
1495     assertEquals(2, stats.loadExceptionCount());
1496     assertEquals(3, stats.hitCount());
1497   }
1498   public void testBulkLoadUncheckedException() throws ExecutionException {
1499     Exception e = new RuntimeException();
1500     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1501     LoadingCache&lt;Object, Object&gt; cache =
1502         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
1503     CacheStats stats = cache.stats();
1504     assertEquals(0, stats.missCount());
1505     assertEquals(0, stats.loadSuccessCount());
1506     assertEquals(0, stats.loadExceptionCount());
1507     assertEquals(0, stats.hitCount());
1508     try {
1509       cache.getAll(asList(new Object()));
1510       fail();
1511     } catch (UncheckedExecutionException expected) {
1512       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1513     }
1514     stats = cache.stats();
1515     assertEquals(1, stats.missCount());
1516     assertEquals(0, stats.loadSuccessCount());
1517     assertEquals(1, stats.loadExceptionCount());
1518     assertEquals(0, stats.hitCount());
1519   }
1520   public void testReloadAfterFailure() throws ExecutionException {
1521     final AtomicInteger count = new AtomicInteger();
1522     final Exception e = new IllegalStateException("exception to trigger failure on first load()");
1523     CacheLoader&lt;Integer, String&gt; failOnceFunction =
1524         new CacheLoader&lt;Integer, String&gt;() {
1525           @Override
1526           public String load(Integer key) throws Exception {
1527             if (count.getAndIncrement() == 0) {
1528               throw e;
1529             }
1530             return key.toString();
1531           }
1532 <a name="4"></a>        };
1533     CountingRemovalListener&lt;Integer, String&gt; removalListener = countingRemovalListener();
1534     LoadingCache&lt;Integer, String&gt; cache =
1535         <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CacheBuilder.newBuilder().removalListener(removalListener).build(failOnceFunction);
1536     try {
1537       cache.getUnchecked(1);
1538       fail();
1539     } catch (UncheckedExecutionException ue) {
1540       assertThat(ue).hasCauseThat().isSameInstanceAs(e);
1541     }
1542     assertEquals("1", cache.getUnchecked</b></font>(1));
1543     assertEquals(0, removalListener.getCount());
1544     count.set(0);
1545     cache.refresh(2);
1546     checkLoggedCause(e);
1547     assertEquals("2", cache.getUnchecked(2));
1548     assertEquals(0, removalListener.getCount());
1549   }
1550   public void testReloadAfterValueReclamation() throws InterruptedException, ExecutionException {
1551     CountingLoader countingLoader = new CountingLoader();
1552     LoadingCache&lt;Object, Object&gt; cache =
1553         CacheBuilder.newBuilder().weakValues().build(countingLoader);
1554     ConcurrentMap&lt;Object, Object&gt; map = cache.asMap();
1555     int iterations = 10;
1556     WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(null);
1557     int expectedComputations = 0;
1558     for (int i = 0; i &lt; iterations; i++) {
1559       Object oldValue = ref.get();
1560       if (oldValue == null) {
1561         expectedComputations++;
1562       }
1563       ref = new WeakReference&lt;&gt;(cache.getUnchecked(1));
1564       oldValue = null;
1565       Thread.sleep(i);
1566       System.gc();
1567     }
1568     assertEquals(expectedComputations, countingLoader.getCount());
1569     for (int i = 0; i &lt; iterations; i++) {
1570       Object oldValue = ref.get();
1571       if (oldValue == null) {
1572         expectedComputations++;
1573       }
1574       cache.refresh(1);
1575       checkNothingLogged();
1576       ref = new WeakReference&lt;&gt;(map.get(1));
1577       oldValue = null;
1578       Thread.sleep(i);
1579       System.gc();
1580     }
1581     assertEquals(expectedComputations, countingLoader.getCount());
1582   }
1583   public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {
1584     CountingLoader countingLoader = new CountingLoader();
1585     LoadingCache&lt;Object, Object&gt; cache =
1586         CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);
1587     Object key = new Object();
1588     assertNotNull(cache.getUnchecked(key));
1589 <a name="3"></a>    CacheTesting.simulateValueReclamation(cache, key);
1590     assertNotNull(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cache.getUnchecked(key));
1591     assertEquals(1, cache.size());
1592     assertEquals(2, countingLoader.getCount());
1593     CacheTesting.simulateValueReclamation(cache, key);
1594     cache.refresh(key);
1595     checkNothingLogged();
1596     assertEquals(1, cache.size());
1597     assertEquals(3, countingLoader.getCount());
1598   }
1599   public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {
1600     CountingLoader countingLoader = new</b></font> CountingLoader();
1601     LoadingCache&lt;Object, Object&gt; cache =
1602         CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);
1603 <a name="2"></a>
1604     Object key = new Object();
1605     assertNotNull(cache.getUnchecked(key));
1606     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertEquals(1, cache.size());
1607     CacheTesting.simulateKeyReclamation(cache, key);
1608     assertNotNull(cache.getUnchecked(key));
1609     assertEquals(2, countingLoader.getCount());
1610     CacheTesting.simulateKeyReclamation(cache, key);
1611     cache.refresh(key);
1612     checkNothingLogged();
1613     assertEquals(3, countingLoader.getCount());
1614   }
1615   public void testLoadingExceptionWithCause() {
1616     final Exception cause = new</b></font> Exception();
1617     final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
1618     final ExecutionException ee = new ExecutionException(cause);
1619     LoadingCache&lt;Object, Object&gt; cacheUnchecked =
1620         CacheBuilder.newBuilder().build(exceptionLoader(uee));
1621     LoadingCache&lt;Object, Object&gt; cacheChecked =
1622         CacheBuilder.newBuilder().build(exceptionLoader(ee));
1623     try {
1624       cacheUnchecked.get(new Object());
1625       fail();
1626     } catch (ExecutionException e) {
1627       fail();
1628     } catch (UncheckedExecutionException caughtEe) {
1629       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
1630     }
1631     try {
1632       cacheUnchecked.getUnchecked(new Object());
1633       fail();
1634     } catch (UncheckedExecutionException caughtUee) {
1635       assertThat(caughtUee).hasCauseThat().isSameInstanceAs(uee);
1636     }
1637     cacheUnchecked.refresh(new Object());
1638     checkLoggedCause(uee);
1639     try {
1640       cacheUnchecked.getAll(asList(new Object()));
1641       fail();
1642     } catch (ExecutionException e) {
1643       fail();
1644     } catch (UncheckedExecutionException caughtEe) {
1645       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
1646     }
1647     try {
1648       cacheChecked.get(new Object());
1649       fail();
1650     } catch (ExecutionException caughtEe) {
1651       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
1652     }
1653     try {
1654       cacheChecked.getUnchecked(new Object());
1655       fail();
1656     } catch (UncheckedExecutionException caughtUee) {
1657       assertThat(caughtUee).hasCauseThat().isSameInstanceAs(ee);
1658     }
1659     cacheChecked.refresh(new Object());
1660     checkLoggedCause(ee);
1661 <a name="16"></a>
1662     try {
1663       cacheChecked.getAll(asList(new Object()));
1664       <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>fail();
1665     } catch (ExecutionException caughtEe) {
1666       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
1667     }
1668   }</b></font>
1669   public void testBulkLoadingExceptionWithCause() {
1670     final Exception cause = new Exception();
1671     final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
1672     final ExecutionException ee = new ExecutionException(cause);
1673     LoadingCache&lt;Object, Object&gt; cacheUnchecked =
1674         CacheBuilder.newBuilder().build(bulkLoader(exceptionLoader(uee)));
1675     LoadingCache&lt;Object, Object&gt; cacheChecked =
1676         CacheBuilder.newBuilder().build(bulkLoader(exceptionLoader(ee)));
1677     try {
1678       cacheUnchecked.getAll(asList(new Object()));
1679       fail();
1680     } catch (ExecutionException e) {
1681       fail();
1682     } catch (UncheckedExecutionException caughtEe) {
1683       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
1684     }
1685     try {
1686       cacheChecked.getAll(asList(new Object()));
1687       fail();
1688     } catch (ExecutionException caughtEe) {
1689       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
1690     }
1691   }
1692   public void testConcurrentLoading() throws InterruptedException {
1693     testConcurrentLoading(CacheBuilder.newBuilder());
1694   }
1695   private static void testConcurrentLoading(CacheBuilder&lt;Object, Object&gt; builder)
1696       throws InterruptedException {
1697     testConcurrentLoadingDefault(builder);
1698     testConcurrentLoadingNull(builder);
1699     testConcurrentLoadingUncheckedException(builder);
1700     testConcurrentLoadingCheckedException(builder);
1701   }
1702   public void testConcurrentExpirationLoading() throws InterruptedException {
1703     testConcurrentLoading(CacheBuilder.newBuilder().expireAfterWrite(10, TimeUnit.SECONDS));
1704   }
1705   private static void testConcurrentLoadingDefault(CacheBuilder&lt;Object, Object&gt; builder)
1706       throws InterruptedException {
1707     int count = 10;
1708     final AtomicInteger callCount = new AtomicInteger();
1709     final CountDownLatch startSignal = new CountDownLatch(count + 1);
1710     final Object result = new Object();
1711     LoadingCache&lt;String, Object&gt; cache =
1712         builder.build(
1713             new CacheLoader&lt;String, Object&gt;() {
1714               @Override
1715               public Object load(String key) throws InterruptedException {
1716                 callCount.incrementAndGet();
1717                 startSignal.await();
1718                 return result;
1719               }
1720             });
1721     List&lt;Object&gt; resultArray = doConcurrentGet(cache, "bar", count, startSignal);
1722     assertEquals(1, callCount.get());
1723     for (int i = 0; i &lt; count; i++) {
1724       assertSame("result(" + i + ") didn't match expected", result, resultArray.get(i));
1725     }
1726   }
1727   private static void testConcurrentLoadingNull(CacheBuilder&lt;Object, Object&gt; builder)
1728       throws InterruptedException {
1729     int count = 10;
1730     final AtomicInteger callCount = new AtomicInteger();
1731     final CountDownLatch startSignal = new CountDownLatch(count + 1);
1732     LoadingCache&lt;String, String&gt; cache =
1733         builder.build(
1734             new CacheLoader&lt;String, String&gt;() {
1735               @Override
1736               public String load(String key) throws InterruptedException {
1737                 callCount.incrementAndGet();
1738                 startSignal.await();
1739                 return null;
1740               }
1741             });
1742     List&lt;Object&gt; result = doConcurrentGet(cache, "bar", count, startSignal);
1743     assertEquals(1, callCount.get());
1744     for (int i = 0; i &lt; count; i++) {
1745       assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);
1746 <a name="17"></a>    }
1747     <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
1748       cache.getUnchecked("bar");
1749       fail();
1750     } catch (InvalidCacheLoadException expected) {
1751     }
1752     assertEquals(2, callCount.get</b></font>());
1753   }
1754   private static void testConcurrentLoadingUncheckedException(CacheBuilder&lt;Object, Object&gt; builder)
1755       throws InterruptedException {
1756     int count = 10;
1757     final AtomicInteger callCount = new AtomicInteger();
1758     final CountDownLatch startSignal = new CountDownLatch(count + 1);
1759     final RuntimeException e = new RuntimeException();
1760     LoadingCache&lt;String, String&gt; cache =
1761         builder.build(
1762             new CacheLoader&lt;String, String&gt;() {
1763               @Override
1764               public String load(String key) throws InterruptedException {
1765                 callCount.incrementAndGet();
1766                 startSignal.await();
1767                 throw e;
1768 <a name="21"></a>              }
1769             });
1770     List&lt;Object&gt; result = <font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>doConcurrentGet(cache, "bar", count, startSignal);
1771     assertEquals(1, callCount.get());
1772     for (int i = 0; i &lt; count; i++) {
1773       assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
1774       assertThat(((UncheckedExecutionException) result.get(i))).hasCauseThat().isSameInstanceAs</b></font>(e);
1775 <a name="14"></a>    }
1776     <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
1777       cache.getUnchecked("bar");
1778       fail();
1779     } catch (UncheckedExecutionException expected) {
1780     }
1781     assertEquals(2, callCount.get</b></font>());
1782   }
1783   private static void testConcurrentLoadingCheckedException(CacheBuilder&lt;Object, Object&gt; builder)
1784       throws InterruptedException {
1785     int count = 10;
1786     final AtomicInteger callCount = new AtomicInteger();
1787     final CountDownLatch startSignal = new CountDownLatch(count + 1);
1788     final IOException e = new IOException();
1789     LoadingCache&lt;String, String&gt; cache =
1790         builder.build(
1791             new CacheLoader&lt;String, String&gt;() {
1792               @Override
1793               public String load(String key) throws IOException, InterruptedException {
1794                 callCount.incrementAndGet();
1795                 startSignal.await();
1796                 throw e;
1797               }
1798             });
1799     List&lt;Object&gt; result = doConcurrentGet(cache, "bar", count, startSignal);
1800     assertEquals(1, callCount.get());
1801     for (int i = 0; i &lt; count; i++) {
1802       int mod = i % 3;
1803       if (mod == 0 || mod == 2) {
1804         assertThat(result.get(i)).isInstanceOf(ExecutionException.class);
1805         assertThat((ExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);
1806       } else {
1807         assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
1808         assertThat((UncheckedExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);
1809       }
1810 <a name="19"></a>    }
1811     <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try {
1812       cache.getUnchecked("bar");
1813       fail();
1814     } catch (UncheckedExecutionException expected) {
1815     }</b></font>
1816     assertEquals(2, callCount.get());
1817   }
1818   private static &lt;K&gt; List&lt;Object&gt; doConcurrentGet(
1819       final LoadingCache&lt;K, ?&gt; cache,
1820       final K key,
1821       int nThreads,
1822       final CountDownLatch gettersStartedSignal)
1823       throws InterruptedException {
1824     final AtomicReferenceArray&lt;Object&gt; result = new AtomicReferenceArray&lt;&gt;(nThreads);
1825     final CountDownLatch gettersComplete = new CountDownLatch(nThreads);
1826     for (int i = 0; i &lt; nThreads; i++) {
1827       final int index = i;
1828       Thread thread =
1829           new Thread(
1830               new Runnable() {
1831                 @Override
1832                 public void run() {
1833                   gettersStartedSignal.countDown();
1834                   Object value = null;
1835                   try {
1836                     int mod = index % 3;
1837                     if (mod == 0) {
1838                       value = cache.get(key);
1839                     } else if (mod == 1) {
1840                       value = cache.getUnchecked(key);
1841                     } else {
1842                       cache.refresh(key);
1843                       value = cache.get(key);
1844                     }
1845                     result.set(index, value);
1846                   } catch (Throwable t) {
1847                     result.set(index, t);
1848                   }
1849                   gettersComplete.countDown();
1850                 }
1851               });
1852       thread.start();
1853       while (thread.isAlive() &amp;&amp; thread.getState() != Thread.State.WAITING) {
1854         Thread.yield();
1855       }
1856     }
1857     gettersStartedSignal.countDown();
1858     gettersComplete.await();
1859     List&lt;Object&gt; resultList = Lists.newArrayListWithExpectedSize(nThreads);
1860     for (int i = 0; i &lt; nThreads; i++) {
1861       resultList.add(result.get(i));
1862     }
1863     return resultList;
1864   }
1865   public void testAsMapDuringLoading() throws InterruptedException, ExecutionException {
1866 <a name="25"></a>    final CountDownLatch getStartedSignal = new CountDownLatch(2);
1867     final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
1868     final CountDownLatch getFinishedSignal = new CountDownLatch(2);
1869     <font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final String getKey = "get";
1870     final String refreshKey = "refresh";
1871     final String suffix = "Suffix";
1872     CacheLoader&lt;String, String&gt; computeFunction =
1873         new CacheLoader&lt;String, String&gt;() {
1874           @Override
1875           public String load(String key</b></font>) throws InterruptedException {
1876             getStartedSignal.countDown();
1877             letGetFinishSignal.await();
1878             return key + suffix;
1879           }
1880         };
1881     final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
1882     ConcurrentMap&lt;String, String&gt; map = cache.asMap();
1883     map.put(refreshKey, refreshKey);
1884     assertEquals(1, map.size());
1885     assertFalse(map.containsKey(getKey));
1886     assertSame(refreshKey, map.get(refreshKey));
1887     new Thread() {
1888       @Override
1889       public void run() {
1890         cache.getUnchecked(getKey);
1891         getFinishedSignal.countDown();
1892       }
1893     }.start();
1894     new Thread() {
1895       @Override
1896       public void run() {
1897         cache.refresh(refreshKey);
1898         getFinishedSignal.countDown();
1899       }
1900     }.start();
1901     getStartedSignal.await();
1902     assertEquals(1, map.size());
1903     assertFalse(map.containsKey(getKey));
1904     assertSame(refreshKey, map.get(refreshKey));
1905     letGetFinishSignal.countDown();
1906     getFinishedSignal.await();
1907     checkNothingLogged();
1908     assertEquals(2, cache.size());
1909     assertEquals(getKey + suffix, map.get(getKey));
1910     assertEquals(refreshKey + suffix, map.get(refreshKey));
1911   }
1912 <a name="24"></a>
1913   public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {
1914     <font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final CountDownLatch computationStarted = new CountDownLatch(2);
1915     final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
1916     final CountDownLatch getFinishedSignal = new CountDownLatch(2);
1917     final String getKey = "get";
1918     final String refreshKey = "refresh";
1919     final String suffix = "Suffix"</b></font>;
1920     CacheLoader&lt;String, String&gt; computeFunction =
1921         new CacheLoader&lt;String, String&gt;() {
1922           @Override
1923           public String load(String key) throws InterruptedException {
1924             computationStarted.countDown();
1925             letGetFinishSignal.await();
1926             return key + suffix;
1927           }
1928         };
1929     final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
1930     ConcurrentMap&lt;String, String&gt; map = cache.asMap();
1931     map.put(refreshKey, refreshKey);
1932     new Thread() {
1933       @Override
1934       public void run() {
1935         cache.getUnchecked(getKey);
1936         getFinishedSignal.countDown();
1937       }
1938     }.start();
1939     new Thread() {
1940       @Override
1941       public void run() {
1942         cache.refresh(refreshKey);
1943         getFinishedSignal.countDown();
1944       }
1945     }.start();
1946     computationStarted.await();
1947     cache.invalidate(getKey);
1948     cache.invalidate(refreshKey);
1949     assertFalse(map.containsKey(getKey));
1950     assertFalse(map.containsKey(refreshKey));
1951     letGetFinishSignal.countDown();
1952     getFinishedSignal.await();
1953     checkNothingLogged();
1954     assertEquals(2, cache.size());
1955     assertEquals(getKey + suffix, map.get(getKey));
1956     assertEquals(refreshKey + suffix, map.get(refreshKey));
1957     assertEquals(2, cache.size());
1958   }
1959   public void testInvalidateAndReloadDuringLoading()
1960       throws InterruptedException, ExecutionException {
1961     final CountDownLatch computationStarted = new CountDownLatch(2);
1962     final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
1963     final CountDownLatch getFinishedSignal = new CountDownLatch(4);
1964     final String getKey = "get";
1965     final String refreshKey = "refresh";
1966     final String suffix = "Suffix";
1967     CacheLoader&lt;String, String&gt; computeFunction =
1968         new CacheLoader&lt;String, String&gt;() {
1969           @Override
1970           public String load(String key) throws InterruptedException {
1971             computationStarted.countDown();
1972             letGetFinishSignal.await();
1973             return key + suffix;
1974           }
1975         };
1976     final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
1977     ConcurrentMap&lt;String, String&gt; map = cache.asMap();
1978     map.put(refreshKey, refreshKey);
1979     new Thread() {
1980       @Override
1981       public void run() {
1982         cache.getUnchecked(getKey);
1983         getFinishedSignal.countDown();
1984       }
1985     }.start();
1986     new Thread() {
1987       @Override
1988       public void run() {
1989         cache.refresh(refreshKey);
1990         getFinishedSignal.countDown();
1991       }
1992     }.start();
1993     computationStarted.await();
1994     cache.invalidate(getKey);
1995     cache.invalidate(refreshKey);
1996     assertFalse(map.containsKey(getKey));
1997     assertFalse(map.containsKey(refreshKey));
1998     new Thread() {
1999       @Override
2000       public void run() {
2001         cache.getUnchecked(getKey);
2002         getFinishedSignal.countDown();
2003       }
2004     }.start();
2005     new Thread() {
2006       @Override
2007       public void run() {
2008         cache.refresh(refreshKey);
2009         getFinishedSignal.countDown();
2010       }
2011     }.start();
2012     letGetFinishSignal.countDown();
2013     getFinishedSignal.await();
2014     checkNothingLogged();
2015     assertEquals(2, cache.size());
2016     assertEquals(getKey + suffix, map.get(getKey));
2017     assertEquals(refreshKey + suffix, map.get(refreshKey));
2018   }
2019   public void testExpandDuringLoading() throws InterruptedException {
2020     final int count = 3;
2021     final AtomicInteger callCount = new AtomicInteger();
2022     final CountDownLatch computeSignal = new CountDownLatch(1);
2023     final CountDownLatch secondSignal = new CountDownLatch(1);
2024     final CountDownLatch thirdSignal = new CountDownLatch(1);
2025     final CountDownLatch fourthSignal = new CountDownLatch(1);
2026     final CountDownLatch doneSignal = new CountDownLatch(count);
2027     CacheLoader&lt;String, String&gt; computeFunction =
2028         new CacheLoader&lt;String, String&gt;() {
2029           @Override
2030           public String load(String key) throws InterruptedException {
2031             callCount.incrementAndGet();
2032             secondSignal.countDown();
2033             computeSignal.await();
2034             return key + "foo";
2035           }
2036         };
2037     final LoadingCache&lt;String, String&gt; cache =
2038         CacheBuilder.newBuilder().weakKeys().build(computeFunction);
2039     final AtomicReferenceArray&lt;String&gt; result = new AtomicReferenceArray&lt;&gt;(count);
2040     final String key = "bar";
2041     new Thread() {
2042       @Override
2043       public void run() {
2044         result.set(0, cache.getUnchecked(key));
2045         doneSignal.countDown();
2046       }
2047     }.start();
2048     secondSignal.await();
2049     new Thread() {
2050       @Override
2051       public void run() {
2052         thirdSignal.countDown();
2053         result.set(1, cache.getUnchecked(key));
2054         doneSignal.countDown();
2055       }
2056     }.start();
2057     thirdSignal.await();
2058     Thread.yield();
2059     CacheTesting.forceExpandSegment(cache, key);
2060     new Thread() {
2061 <a name="12"></a>      @Override
2062       public void run() {
2063         fourthSignal.countDown();
2064         <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>result.set(2, cache.getUnchecked(key));
2065         doneSignal.countDown();
2066       }
2067     }.start();
2068     fourthSignal.await();
2069     Thread.yield();
2070     computeSignal.countDown();
2071     doneSignal.await();
2072     assertTrue(callCount.get() == 1);
2073     assertEquals</b></font>("barfoo", result.get(0));
2074     assertEquals("barfoo", result.get(1));
2075     assertEquals("barfoo", result.get(2));
2076     assertEquals("barfoo", cache.getUnchecked(key));
2077   }
2078   public void
2079       ignoreTestExpandDuringRefresh()
2080       throws InterruptedException, ExecutionException {
2081     final AtomicInteger callCount = new AtomicInteger();
2082     final CountDownLatch computeSignal = new CountDownLatch(1);
2083     final CountDownLatch secondSignal = new CountDownLatch(1);
2084     final CountDownLatch thirdSignal = new CountDownLatch(1);
2085     final CountDownLatch fourthSignal = new CountDownLatch(1);
2086     final CountDownLatch doneSignal = new CountDownLatch(3);
2087     final String suffix = "Suffix";
2088     CacheLoader&lt;String, String&gt; computeFunction =
2089         new CacheLoader&lt;String, String&gt;() {
2090           @Override
2091           public String load(String key) throws InterruptedException {
2092             callCount.incrementAndGet();
2093             secondSignal.countDown();
2094             computeSignal.await();
2095             return key + suffix;
2096           }
2097         };
2098     final AtomicReferenceArray&lt;String&gt; result = new AtomicReferenceArray&lt;&gt;(2);
2099     final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
2100     final String key = "bar";
2101     cache.asMap().put(key, key);
2102     new Thread() {
2103       @Override
2104       public void run() {
2105         cache.refresh(key);
2106         doneSignal.countDown();
2107       }
2108     }.start();
2109     secondSignal.await();
2110     checkNothingLogged();
2111     new Thread() {
2112       @Override
2113       public void run() {
2114         thirdSignal.countDown();
2115         result.set(0, cache.getUnchecked(key));
2116         doneSignal.countDown();
2117       }
2118     }.start();
2119     thirdSignal.await();
2120     Thread.yield();
2121     CacheTesting.forceExpandSegment(cache, key);
2122     new Thread() {
2123       @Override
2124       public void run() {
2125         fourthSignal.countDown();
2126         result.set(1, cache.getUnchecked(key));
2127         doneSignal.countDown();
2128       }
2129     }.start();
2130     fourthSignal.await();
2131     Thread.yield();
2132     computeSignal.countDown();
2133     doneSignal.await();
2134     assertTrue(callCount.get() == 1);
2135     assertEquals(key, result.get(0));
2136     assertEquals(key, result.get(1));
2137     assertEquals(key + suffix, cache.getUnchecked(key));
2138   }
2139   static &lt;T&gt; Callable&lt;T&gt; throwing(final Exception exception) {
2140     return new Callable&lt;T&gt;() {
2141       @Override
2142       public T call() throws Exception {
2143         throw exception;
2144       }
2145     };
2146   }
2147 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
