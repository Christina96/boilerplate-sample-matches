<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for InputFactoryTest.java & SubQueryPlannerTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for InputFactoryTest.java & SubQueryPlannerTest.java
      </h3>
      <h1 align="center">
        42.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>InputFactoryTest.java (45.801525%)<TH>SubQueryPlannerTest.java (40.40404%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match64776-0.html#0',2,'match64776-1.html#0',3)" NAME="0">(28-61)<TD><A HREF="javascript:ZweiFrames('match64776-0.html#0',2,'match64776-1.html#0',3)" NAME="0">(24-57)</A><TD ALIGN=center><FONT COLOR="#ff0000">30</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match64776-0.html#1',2,'match64776-1.html#1',3)" NAME="1">(171-181)<TD><A HREF="javascript:ZweiFrames('match64776-0.html#1',2,'match64776-1.html#1',3)" NAME="1">(84-98)</A><TD ALIGN=center><FONT COLOR="#cc0000">24</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match64776-0.html#2',2,'match64776-1.html#2',3)" NAME="2">(122-130)<TD><A HREF="javascript:ZweiFrames('match64776-0.html#2',2,'match64776-1.html#2',3)" NAME="2">(166-176)</A><TD ALIGN=center><FONT COLOR="#b20000">21</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match64776-0.html#3',2,'match64776-1.html#3',3)" NAME="3">(188-196)<TD><A HREF="javascript:ZweiFrames('match64776-0.html#3',2,'match64776-1.html#3',3)" NAME="3">(236-248)</A><TD ALIGN=center><FONT COLOR="#7f0000">15</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match64776-0.html#4',2,'match64776-1.html#4',3)" NAME="4">(82-89)<TD><A HREF="javascript:ZweiFrames('match64776-0.html#4',2,'match64776-1.html#4',3)" NAME="4">(65-75)</A><TD ALIGN=center><FONT COLOR="#5d0000">11</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match64776-0.html#5',2,'match64776-1.html#5',3)" NAME="5">(99-109)<TD><A HREF="javascript:ZweiFrames('match64776-0.html#5',2,'match64776-1.html#5',3)" NAME="5">(76-81)</A><TD ALIGN=center><FONT COLOR="#550000">10</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match64776-0.html#6',2,'match64776-1.html#6',3)" NAME="6">(161-165)<TD><A HREF="javascript:ZweiFrames('match64776-0.html#6',2,'match64776-1.html#6',3)" NAME="6">(201-207)</A><TD ALIGN=center><FONT COLOR="#4c0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>InputFactoryTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.expression;

import io.crate.analyze.relations.AnalyzedRelation;
<A NAME="0"></A>import io.crate.analyze.relations.DocTableRelation;
import io.crate.data.Input;
import io.crate.data.Row;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match64776-1.html#0',3,'match64776-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.data.RowN;
import io.crate.execution.engine.aggregation.AggregationContext;
import io.crate.execution.engine.collect.CollectExpression;
import io.crate.expression.scalar.arithmetic.ArithmeticFunctions;
import io.crate.expression.symbol.Aggregation;
import io.crate.expression.symbol.Function;
import io.crate.expression.symbol.InputColumn;
import io.crate.expression.symbol.Literal;
import io.crate.expression.symbol.Symbol;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.FunctionImplementation;
import io.crate.metadata.RelationName;
import io.crate.metadata.Scalar;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.functions.Signature;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SqlExpressions;
import io.crate.testing.T3;
import io.crate.types.DataTypes;
import org.junit.Before;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.sameInstance;
import static org.hamcrest.core.Is.is;

public class InputFactoryTest extends CrateDummyClusterServiceUnitTest {

    private SqlExpressions expressions</B></FONT>;
    private InputFactory factory;
    private TransactionContext txnCtx = CoordinatorTxnCtx.systemTransactionContext();
    private Function add = new Function(
        Signature.scalar(
            ArithmeticFunctions.Names.ADD,
            DataTypes.INTEGER.getTypeSignature(),
            DataTypes.INTEGER.getTypeSignature(),
            DataTypes.INTEGER.getTypeSignature()
        ).withFeatures(Scalar.DETERMINISTIC_AND_COMPARISON_REPLACEMENT),
        List.of(new InputColumn(1, DataTypes.INTEGER), Literal.of(10)),
        DataTypes.INTEGER
    );

    @Before
    public void prepare() throws Exception {
        Map&lt;RelationName, AnalyzedRelation&gt; sources = T3.sources(List.of(T3.T1), clusterService);

<A NAME="4"></A>        DocTableRelation tr1 = (DocTableRelation) sources.get(T3.T1);
        expressions = new SqlExpressions(sources, tr1);
        factory = new InputFactory(expressions.nodeCtx);
    <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match64776-1.html#4',3,'match64776-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void testAggregationSymbolsInputReuse() throws Exception {
        Function countX = (Function) expressions.asSymbol(&quot;count(x)&quot;);
        Function avgX = (Function) expressions.asSymbol(&quot;avg(x)&quot;);

        List&lt;Symbol&gt; aggregations = Arrays.asList</B></FONT>(
            new Aggregation( countX.signature(), countX.signature().getReturnType().createType(), List.of(new InputColumn(0))),
            new Aggregation(avgX.signature(), avgX.signature().getReturnType().createType(), List.of(new InputColumn(0)))
        );

        InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; ctx = factory.ctxForAggregations(txnCtx);
        ctx.add(aggregations);
<A NAME="5"></A>        List&lt;AggregationContext&gt; aggregationContexts = ctx.aggregations();

        Input&lt;?&gt; inputCount = aggregationContexts.get(0).inputs()[0];
        Input&lt;?&gt; inputAverage = <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match64776-1.html#5',3,'match64776-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>aggregationContexts.get(1).inputs()[0];

        assertSame(inputCount, inputAverage);
    }

    @Test
    public void testProcessGroupByProjectionSymbols() throws Exception {
        // select x, y * 2 ... group by x, y * 2

        // keys: [ in(0), in(1) + 10 ]
        List&lt;Symbol&gt; keys = Arrays.asList</B></FONT>(new InputColumn(0, DataTypes.LONG), add);

        InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; ctx = factory.ctxForAggregations(txnCtx);
        ctx.add(keys);
        ArrayList&lt;CollectExpression&lt;Row, ?&gt;&gt; expressions = new ArrayList&lt;&gt;(ctx.expressions());
        assertThat(expressions.size(), is(2));

        // keyExpressions: [ in0, in1 ]

        RowN row = new RowN(1L, 2L);
<A NAME="2"></A>        for (CollectExpression&lt;Row, ?&gt; expression : expressions) {
            expression.setNextRow(row);
        }
        <FONT color="#980517"><A HREF="javascript:ZweiFrames('match64776-1.html#2',3,'match64776-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(expressions.get(0).value(), is(1L));
        assertThat(expressions.get(1).value(), is(2L)); // raw input value

        // inputs: [ x, add ]
        List&lt;Input&lt;?&gt;&gt; inputs = ctx.topLevelInputs();

        assertThat(inputs.size(), is(2));
        assertThat(inputs.get(0).value(), is(1L));
        assertThat(inputs.get(1).value(), is</B></FONT>(12));  // + 10
    }

    @Test
    public void testProcessGroupByProjectionSymbolsAggregation() throws Exception {
        // select count(x), x, y * 2 ... group by x, y * 2

        // keys: [ in(0), in(1) + 10 ]
        List&lt;Symbol&gt; keys = Arrays.asList(new InputColumn(0, DataTypes.LONG), add);

        Function countX = (Function) expressions.asSymbol(&quot;count(x)&quot;);

        // values: [ count(in(0)) ]
        List&lt;Aggregation&gt; values = List.of(new Aggregation(
            countX.signature(),
            countX.valueType(),
            List.of(new InputColumn(0))
        ));

        InputFactory.Context&lt;CollectExpression&lt;Row, ?&gt;&gt; ctx = factory.ctxForAggregations(txnCtx);
        ctx.add(keys);

        // inputs: [ x, add ]
        List&lt;Input&lt;?&gt;&gt; keyInputs = ctx.topLevelInputs();

        ctx.add(values);

        List&lt;AggregationContext&gt; aggregations = ctx.aggregations();
<A NAME="6"></A>        assertThat(aggregations.size(), is(1));

        // collectExpressions: [ in0, in1 ]
        List&lt;CollectExpression&lt;Row, ?&gt;&gt; expressions = new ArrayList&lt;&gt;(<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match64776-1.html#6',3,'match64776-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ctx.expressions());
        assertThat(expressions.size(), is(2));

        List&lt;Input&lt;?&gt;&gt; allInputs = ctx.topLevelInputs();
        assertThat(allInputs.size(), is</B></FONT>(2)); // only 2 because count is no input

        RowN row = new RowN(1L, 2L);
<A NAME="1"></A>        for (CollectExpression&lt;Row, ?&gt; expression : expressions) {
            expression.setNextRow(row);
        }
        assertThat(<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match64776-1.html#1',3,'match64776-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>expressions.get(0).value(), is(1L));
        assertThat(expressions.get(1).value(), is(2L)); // raw input value

        assertThat(keyInputs.size(), is(2));
        assertThat(keyInputs.get(0).value(), is(1L));
        assertThat(keyInputs.get(1).value(), is(12));  // 2 + 10
    }

    @Test
    public void testCompiled() throws Exception {
        Function function = (Function) expressions.normalize</B></FONT>(expressions.asSymbol(&quot;a like 'f%'&quot;));
        InputFactory.Context&lt;Input&lt;?&gt;&gt; ctx = factory.ctxForRefs(txnCtx, i -&gt; Literal.of(&quot;foo&quot;));
        Input&lt;?&gt; input = ctx.add(function);

<A NAME="3"></A>        FunctionExpression expression = (FunctionExpression) input;
        java.lang.reflect.Field f = FunctionExpression.class.getDeclaredField(&quot;scalar&quot;);
        f.setAccessible(true);
        FunctionImplementation impl = (FunctionImplementation) <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match64776-1.html#3',3,'match64776-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>f.get(expression);
        assertThat(impl.signature(), is(function.signature()));

        FunctionImplementation uncompiled = expressions.nodeCtx.functions().getQualified(
            function,
            txnCtx.sessionSettings().searchPath()
        );
        assertThat(uncompiled, not(sameInstance(impl)));
    }</B></FONT>

    @Test
    public void testSameReferenceResultsInSameExpressionInstance() {
        Symbol symbol = expressions.normalize(expressions.asSymbol(&quot;a&quot;));
        InputFactory.Context&lt;Input&lt;?&gt;&gt; ctx = factory.ctxForRefs(txnCtx, i -&gt; Literal.of(&quot;foo&quot;));
        Input&lt;?&gt; input1 = ctx.add(symbol);
        Input&lt;?&gt; input2 = ctx.add(symbol);

        assertThat(input1, sameInstance(input2));
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SubQueryPlannerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.planner;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match64776-0.html#0',2,'match64776-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import io.crate.execution.dsl.phases.CollectPhase;
import io.crate.execution.dsl.phases.RoutedCollectPhase;
import io.crate.execution.dsl.projection.AggregationProjection;
import io.crate.execution.dsl.projection.EvalProjection;
import io.crate.execution.dsl.projection.FetchProjection;
import io.crate.execution.dsl.projection.FilterProjection;
import io.crate.execution.dsl.projection.GroupProjection;
import io.crate.execution.dsl.projection.OrderedTopNProjection;
import io.crate.execution.dsl.projection.Projection;
import io.crate.execution.dsl.projection.TopNProjection;
import io.crate.planner.node.dql.Collect;
import io.crate.planner.node.dql.QueryThenFetch;
import io.crate.planner.node.dql.join.Join;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import io.crate.testing.T3;
import org.hamcrest.Matchers;
import org.junit.Before;
import org.junit.Test;

import java.util.List;

import static io.crate.testing.ProjectionMatchers.isTopN;
import static io.crate.testing.SymbolMatchers.isFunction;
import static io.crate.testing.SymbolMatchers.isLiteral;
import static io.crate.testing.SymbolMatchers.isReference;
import static io.crate.testing.TestingHelpers.isSQL;
import static org.hamcrest.Matchers.contains;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;

public class SubQueryPlannerTest extends CrateDummyClusterServiceUnitTest {

    private SQLExecutor e</B></FONT>;

    @Before
    public void setUpExecutor() throws Exception {
        e = SQLExecutor.builder(clusterService)
<A NAME="4"></A>            .addTable(T3.T1_DEFINITION)
            .addTable(T3.T2_DEFINITION)
            .build();
    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match64776-0.html#4',2,'match64776-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Test
    public void testNestedSimpleSelectContainsFilterProjectionForWhereClause() throws Exception {
        QueryThenFetch qtf = e.plan(
            &quot;select x, i from &quot; +
            &quot;   (select x, i from t1 order by x asc limit 10) ti &quot; +
            &quot;where ti.x = 10 &quot; +
<A NAME="5"></A>            &quot;order by x desc limit 3&quot;);
        Collect collect = (Collect) qtf.subPlan();
        List&lt;Projection&gt; projections = collect.collectPhase().projections</B></FONT>();
        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match64776-0.html#5',2,'match64776-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertThat(projections, Matchers.hasItem(instanceOf(FilterProjection.class)));
    }

    @Test
    public void testNestedSimpleSelectWithJoin() throws Exception {
<A NAME="1"></A>        Join nl= e.plan</B></FONT>(&quot;select t1x from (&quot; +
                        &quot;select t1.x as t1x, t2.i as t2i from t1 as t1, t1 as t2 order by t1x asc limit 10&quot; +
                        &quot;) t order by t1x desc limit 3&quot;);
        List&lt;Projection&gt; projections = <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match64776-0.html#1',2,'match64776-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>nl.joinPhase().projections();
        assertThat(projections, Matchers.contains(
            instanceOf(EvalProjection.class),
            isTopN(10, 0),
            instanceOf(OrderedTopNProjection.class),
            instanceOf(EvalProjection.class),
            isTopN(3, 0)
        ));
        assertThat(projections.get(0).outputs(), isSQL(&quot;INPUT(1), INPUT(1)&quot;));
        assertThat(projections.get(4).outputs(), isSQL(&quot;INPUT(0)&quot;));
    }

    @Test
    public void testNestedSimpleSelectContainsGroupProjectionWithFunction() throws Exception {
        Collect collect = e.plan</B></FONT>(&quot;select c + 100, max(max) from &quot; +
                                 &quot;    (select x + 10::int as c, max(i) as max from t1 group by x + 10::int) t &quot; +
                                 &quot;group by c + 100 order by c + 100 &quot; +
                                 &quot;limit 100&quot;);
        CollectPhase collectPhase = collect.collectPhase();
        assertThat(
            collectPhase.toCollect(),
            contains(
                isReference(&quot;i&quot;),
                isFunction(&quot;add&quot;, isReference(&quot;x&quot;), isLiteral(10))
            )
        );
        assertThat(
            collectPhase.projections(),
            contains(
                instanceOf(GroupProjection.class),
                instanceOf(GroupProjection.class),
                instanceOf(EvalProjection.class),
                instanceOf(GroupProjection.class),
                instanceOf(OrderedTopNProjection.class),
                instanceOf(TopNProjection.class)
            )
        );
    }

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testJoinOnSubSelectsWithLimitAndOffset() throws Exception {
        Join join = e.plan(&quot;select * from &quot; +
                         &quot; (select i, a from t1 order by a limit 10 offset 2) t1 &quot; +
                         &quot;join&quot; +
                         &quot; (select i from t2 order by b limit 5 offset 5) t2 &quot; +
                         &quot;on t1.i = t2.i&quot;);
        assertThat(join.joinPhase().projections().size(), is(1));
        assertThat(join.joinPhase().projections().get(0), instanceOf(EvalProjection.class));

        QueryThenFetch leftQtf = (QueryThenFetch) join.left();
        Collect left = (Collect) leftQtf.subPlan();
        assertThat(&quot;1 node, otherwise mergePhases would be required&quot;, left.nodeIds().size(), is(1));
        assertThat(left.orderBy(), isSQL(&quot;OrderByPositions{indices=[1], reverseFlags=[false], nullsFirst=[false]}&quot;));
        assertThat(left.collectPhase().projections(), contains(
            isTopN(10, 2),
            instanceOf(FetchProjection.class)
        ));
        QueryThenFetch rightQtf = (QueryThenFetch) join.right();
        Collect right = (Collect) rightQtf.subPlan();
        assertThat(&quot;1 node, otherwise mergePhases would be required&quot;, right.nodeIds().size(), is(1));
        assertThat(((RoutedCollectPhase) right.collectPhase()).orderBy(), isSQL(&quot;doc.t2.b&quot;));
        assertThat(right.collectPhase().projections(), contains(
            isTopN(5, 5),
            instanceOf(FetchProjection.class),
            instanceOf(EvalProjection.class) // strips `b` used in order by from the outputs
        ));
    }

    @Test
    public void testJoinWithAggregationOnSubSelectsWithLimitAndOffset() throws Exception {
        Join join = e.plan(&quot;select t1.a, count(*) from &quot; +
                         &quot; (select i, a from t1 order by a limit 10 offset 2) t1 &quot; +
                         &quot;join&quot; +
                         &quot; (select i from t2 order by i desc limit 5 offset 5) t2 &quot; +
                         &quot;on t1.i = t2.i &quot; +
                         &quot;group by t1.a&quot;);

        QueryThenFetch qtf = (QueryThenFetch) join.left();
<A NAME="2"></A>        Collect left = (Collect) qtf.subPlan();
        assertThat(&quot;1 node, otherwise mergePhases would be required&quot;, left.nodeIds().size(), is(1));
        assertThat(((RoutedCollectPhase) left.collectPhase()).orderBy(), isSQL(&quot;doc.t1.a&quot;));
        assertThat(<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match64776-0.html#2',2,'match64776-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>left.collectPhase().projections(), contains(
            isTopN(10, 2),
            instanceOf(FetchProjection.class)
        ));
        assertThat(left.collectPhase().toCollect(), isSQL(&quot;doc.t1._fetchid, doc.t1.a&quot;));


        Collect right = (Collect) join.right();
        assertThat(&quot;1 node, otherwise mergePhases would be required&quot;, right.nodeIds().size(), is(1));
        assertThat(((RoutedCollectPhase) right.collectPhase()).orderBy(), isSQL(&quot;doc.t2.i DESC&quot;));
        assertThat(right.collectPhase</B></FONT>().projections(), contains(
            isTopN(5, 5)
        ));


        List&lt;Projection&gt; nlProjections = join.joinPhase().projections();
        assertThat(nlProjections, contains(
            instanceOf(EvalProjection.class),
            instanceOf(GroupProjection.class)
        ));
    }

    @Test
    public void testJoinWithGlobalAggregationOnSubSelectsWithLimitAndOffset() throws Exception {
        Join join = e.plan(&quot;select count(*) from &quot; +
                         &quot; (select i, a from t1 order by a limit 10 offset 2) t1 &quot; +
                         &quot;join&quot; +
                         &quot; (select i from t2 order by i desc limit 5 offset 5) t2 &quot; +
                         &quot;on t1.i = t2.i&quot;);

        QueryThenFetch leftQtf = (QueryThenFetch) join.left();
        Collect left = (Collect) leftQtf.subPlan();
<A NAME="6"></A>        assertThat(&quot;1 node, otherwise mergePhases would be required&quot;, left.nodeIds().size(), is(1));
        assertThat(left.collectPhase().toCollect(), isSQL(&quot;doc.t1._fetchid, doc.t1.a&quot;));
        assertThat(((RoutedCollectPhase) left.collectPhase()).orderBy(), isSQL(&quot;doc.t1.a&quot;));
        assertThat(<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match64776-0.html#6',2,'match64776-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>left.collectPhase().projections(), contains(
            isTopN(10, 2),
            instanceOf(FetchProjection.class)
        ));

        Collect right = (Collect) join.right();
        assertThat(&quot;1 node, otherwise mergePhases would be required&quot;, right.nodeIds</B></FONT>().size(), is(1));
        assertThat(((RoutedCollectPhase) right.collectPhase()).orderBy(), isSQL(&quot;doc.t2.i DESC&quot;));
        assertThat(right.collectPhase().projections(), contains(
            isTopN(5, 5)
        ));

        List&lt;Projection&gt; nlProjections = join.joinPhase().projections();
        assertThat(nlProjections, contains(
            instanceOf(EvalProjection.class),
            instanceOf(AggregationProjection.class)
        ));
    }

    @Test
    public void testJoinWithAggregationOnSubSelectsWithAggregations() throws Exception {
        Join nl = e.plan(&quot;select t1.a, count(*) from &quot; +
                         &quot; (select a, count(*) as cnt from t1 group by a) t1 &quot; +
                         &quot;join&quot; +
                         &quot; (select distinct i from t2) t2 &quot; +
                         &quot;on t1.cnt = t2.i::long &quot; +
                         &quot;group by t1.a&quot;);
        assertThat(nl.joinPhase().projections(), contains(
            instanceOf(EvalProjection.class),
            instanceOf(GroupProjection.class)
        ));
        assertThat(nl.left(), instanceOf(Collect.class));
<A NAME="3"></A>        Collect leftPlan = (Collect) nl.left();
        CollectPhase leftCollectPhase = leftPlan.collectPhase();
        assertThat(
            <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match64776-0.html#3',2,'match64776-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>leftCollectPhase.projections(),
            contains(
                instanceOf(GroupProjection.class),
                instanceOf(GroupProjection.class),
                instanceOf(EvalProjection.class)
            )
        );
        Collect rightPlan = (Collect) nl.right();
        assertThat(rightPlan.collectPhase().projections(), contains(
            instanceOf(GroupProjection.class),
            instanceOf(GroupProjection.class)
        ));
    }</B></FONT>
}
</PRE>
</div>
  </div>
</body>
</html>
