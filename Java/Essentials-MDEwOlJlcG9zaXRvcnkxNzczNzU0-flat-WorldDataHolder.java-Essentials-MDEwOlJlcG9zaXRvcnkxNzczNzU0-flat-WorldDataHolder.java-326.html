
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldDataHolder.java</h3>
            <pre><code>1  package org.anjocaido.groupmanager.dataholder;
2  import java.io.File;
3  import java.io.FileInputStream;
4  import java.io.FileNotFoundException;
5  import java.io.FileOutputStream;
6  import java.io.IOException;
7  import java.io.OutputStreamWriter;
8  import java.io.UnsupportedEncodingException;
9  import java.util.ArrayList;
10  import java.util.Collection;
11  import java.util.HashMap;
12  import java.util.Iterator;
13  import java.util.LinkedHashMap;
14  import java.util.List;
15  import java.util.Map;
16  import java.util.TreeSet;
17  import java.util.logging.Level;
18  import java.util.logging.Logger;
19  import org.anjocaido.groupmanager.GroupManager;
20  import org.anjocaido.groupmanager.data.Group;
21  import org.anjocaido.groupmanager.data.User;
22  import org.anjocaido.groupmanager.events.GMGroupEvent;
23  import org.anjocaido.groupmanager.events.GMSystemEvent;
24  import org.anjocaido.groupmanager.events.GMUserEvent;
25  import org.anjocaido.groupmanager.events.GMUserEvent.Action;
26  import org.anjocaido.groupmanager.permissions.AnjoPermissionsHandler;
27  import org.bukkit.Server;
28  import org.bukkit.plugin.Plugin;
29  import org.bukkit.plugin.PluginManager;
30  import org.yaml.snakeyaml.DumperOptions;
31  import org.yaml.snakeyaml.Yaml;
32  import org.yaml.snakeyaml.constructor.SafeConstructor;
33  import org.yaml.snakeyaml.reader.UnicodeReader;
34  public class WorldDataHolder {
35  	protected String name;
36  	protected GroupsDataHolder groups = new GroupsDataHolder();
37  	protected UsersDataHolder users = new UsersDataHolder();
38  	protected AnjoPermissionsHandler permissionsHandler;
39  	public WorldDataHolder(String worldName) {
40  		name = worldName;
41  	}
42  	public WorldDataHolder(String worldName, GroupsDataHolder groups, UsersDataHolder users) {
43  		this.name = worldName;
44  		this.groups = groups;
45  		this.users = users;
46  	}
47  	public void updateDataSource() {
48  		this.groups.setDataSource(this);
49  		this.users.setDataSource(this);
50  	}
51  	public User getUser(String userId) {
52  		if (getUsers().containsKey(userId.toLowerCase())) {
53  			return getUsers().get(userId.toLowerCase());
54  		}
55  		if (userId.length() &lt; 36) {
56  			for (User user : getUserList()) {
57  				if (user.getLastName().equalsIgnoreCase(userId)) {
58  					return user;
59  				}
60  			}
61  		}
62  		User newUser = createUser(userId);
63  		return newUser;
64  	}
65  	public User getUser(String uUID, String currentName) {
66  		User user = getUsers().get(uUID.toLowerCase());
67  		if (user != null) {
68  			user.setLastName(currentName);
69  			return user;
70  		}
71  		for (User usr : getUserList()) {
72  			if (usr.getLastName().equalsIgnoreCase(currentName) &amp;&amp; usr.getUUID().equalsIgnoreCase(usr.getLastName())) {
73  				user = usr.clone(uUID, currentName);
74  				this.removeUser(usr.getUUID());
75  				this.addUser(user);
76  				return getUsers().get(uUID.toLowerCase());
77  			}
78  		}
79  		User newUser = createUser(uUID);
80  		newUser.setLastName(currentName);
81  		return newUser;
82  	}
83  	public void addUser(User theUser) {
84  		if (theUser.getDataSource() != this) {
85  			theUser = theUser.clone(this);
86  		}
87  		if (theUser == null) {
88  			return;
89  		}
90  		if ((theUser.getGroup() == null)) {
91  			theUser.setGroup(groups.getDefaultGroup());
92  		}
93  		removeUser(theUser.getUUID());
94  		getUsers().put(theUser.getUUID().toLowerCase(), theUser);
95  		setUsersChanged(true);
96  		if (GroupManager.isLoaded())
97  			GroupManager.getGMEventHandler().callEvent(theUser, Action.USER_ADDED);
98  	}
99  	public boolean removeUser(String userId) {
100  		if (getUsers().containsKey(userId.toLowerCase())) {
101  			getUsers().remove(userId.toLowerCase());
102  			setUsersChanged(true);
103  			if (GroupManager.isLoaded())
104  				GroupManager.getGMEventHandler().callEvent(userId, GMUserEvent.Action.USER_REMOVED);
105  			return true;
106  		}
107  		return false;
108  	}
109  	public boolean isUserDeclared(String userId) {
110  		return getUsers().containsKey(userId.toLowerCase());
111  	}
112  	public void setDefaultGroup(Group group) {
113  		if (!getGroups().containsKey(group.getName().toLowerCase()) || (group.getDataSource() != this)) {
114  			addGroup(group);
115  		}
116  		groups.setDefaultGroup(getGroup(group.getName()));
117  		setGroupsChanged(true);
118  		if (GroupManager.isLoaded())
119  			GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.DEFAULT_GROUP_CHANGED);
120  	}
121  	public Group getDefaultGroup() {
122  		return groups.getDefaultGroup();
123  	}
124  	public Group getGroup(String groupName) {
125  		if (groupName.toLowerCase().startsWith(&quot;g:&quot;))
126  			return GroupManager.getGlobalGroups().getGroup(groupName);
127  		else
128  			return getGroups().get(groupName.toLowerCase());
129  	}
130  	public boolean groupExists(String groupName) {
131  		if (groupName.toLowerCase().startsWith(&quot;g:&quot;))
132  			return GroupManager.getGlobalGroups().hasGroup(groupName);
133  		else
134  			return getGroups().containsKey(groupName.toLowerCase());
135  	}
136  	public void addGroup(Group groupToAdd) {
137  		if (groupToAdd.getName().toLowerCase().startsWith(&quot;g:&quot;)) {
138  			GroupManager.getGlobalGroups().addGroup(groupToAdd);
139  			GroupManager.getGMEventHandler().callEvent(groupToAdd, GMGroupEvent.Action.GROUP_ADDED);
140  			return;
141  		}
142  		if (groupToAdd.getDataSource() != this) {
143  			groupToAdd = groupToAdd.clone(this);
144  		}
145  		removeGroup(groupToAdd.getName());
146  		getGroups().put(groupToAdd.getName().toLowerCase(), groupToAdd);
147  		setGroupsChanged(true);
148  		if (GroupManager.isLoaded())
149  			GroupManager.getGMEventHandler().callEvent(groupToAdd, GMGroupEvent.Action.GROUP_ADDED);
150  	}
151  	public boolean removeGroup(String groupName) {
152  		if (groupName.toLowerCase().startsWith(&quot;g:&quot;)) {
153  			return GroupManager.getGlobalGroups().removeGroup(groupName);
154  		}
155  		if (getDefaultGroup() != null &amp;&amp; groupName.equalsIgnoreCase(getDefaultGroup().getName())) {
156  			return false;
157  		}
158  		if (getGroups().containsKey(groupName.toLowerCase())) {
159  			getGroups().remove(groupName.toLowerCase());
160  			setGroupsChanged(true);
161  			if (GroupManager.isLoaded())
162  				GroupManager.getGMEventHandler().callEvent(groupName.toLowerCase(), GMGroupEvent.Action.GROUP_REMOVED);
163  			return true;
164  		}
165  		return false;
166  	}
167  	public User createUser(String userId) {
168  		if (getUsers().containsKey(userId.toLowerCase())) {
169  			return null;
170  		}
171  		User newUser = new User(this, userId);
172  		newUser.setGroup(groups.getDefaultGroup(), false);
173  		addUser(newUser);
174  		setUsersChanged(true);
175  		return newUser;
176  	}
177  	public Group createGroup(String groupName) {
178  		if (groupName.toLowerCase().startsWith(&quot;g:&quot;)) {
179  			Group newGroup = new Group(groupName);
180  			return GroupManager.getGlobalGroups().newGroup(newGroup);
181  		}
182  		if (getGroups().containsKey(groupName.toLowerCase())) {
183  			return null;
184  		}
185  		Group newGroup = new Group(this, groupName);
186  		addGroup(newGroup);
187  		setGroupsChanged(true);
188  		return newGroup;
189  	}
190  	public Collection&lt;Group&gt; getGroupList() {
191  		synchronized (getGroups()) {
192  			return new ArrayList&lt;Group&gt;(getGroups().values());
193  		}
194  	}
195  	public Collection&lt;User&gt; getUserList() {
196  		synchronized (getUsers()) {
197  			return new ArrayList&lt;User&gt;(getUsers().values());
198  		}
199  	}
200  	public void reload() {
201  		try {
202  			reloadGroups();
203  			reloadUsers();
204  		} catch (Exception ex) {
205  			Logger.getLogger(WorldDataHolder.class.getName()).log(Level.SEVERE, null, ex);
206  		}
207  	}
<span onclick='openModal()' class='match'>208  	public void reloadGroups() {
209  		GroupManager.setLoaded(false);
210  		try {
211  			WorldDataHolder ph = new WorldDataHolder(this.getName());
212  			loadGroups(ph, getGroupsFile());
</span>213  			resetGroups();
214  			for (Group tempGroup : ph.getGroupList()) {
215  				tempGroup.clone(this);
216  			}
217  			this.setDefaultGroup(getGroup(ph.getDefaultGroup().getName()));
218  			this.removeGroupsChangedFlag();
219  			this.setTimeStampGroups(getGroupsFile().lastModified());
220  			ph = null;
221  		} catch (Exception ex) {
222  			Logger.getLogger(WorldDataHolder.class.getName()).log(Level.WARNING, null, ex);
223  		}
224  		GroupManager.setLoaded(true);
225  		GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.RELOADED);
226  	}
227  	public void reloadUsers() {
228  		GroupManager.setLoaded(false);
229  		try {
230  			WorldDataHolder ph = new WorldDataHolder(this.getName());
231  			for (Group tempGroup : this.getGroupList()) {
232  				tempGroup.clone(ph);
233  			}
234  			ph.setDefaultGroup(ph.getGroup(getDefaultGroup().getName()));
235  			loadUsers(ph, getUsersFile());
236  			resetUsers();
237  			for (User tempUser : ph.getUserList()) {
238  				tempUser.clone(this);
239  			}
240  			this.removeUsersChangedFlag();
241  			this.setTimeStampUsers(getUsersFile().lastModified());
242  			ph = null;
243  		} catch (Exception ex) {
244  			Logger.getLogger(WorldDataHolder.class.getName()).log(Level.WARNING, null, ex);
245  		}
246  		GroupManager.setLoaded(true);
247  		GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.RELOADED);
248  	}
249  	public void loadGroups(File groupsFile) {
250  		GroupManager.setLoaded(false);
251  		try {
252  			setGroupsFile(groupsFile);
253  			loadGroups(this, groupsFile);
254  		} catch (FileNotFoundException e) {
255  			e.printStackTrace();
256  			throw new IllegalArgumentException(&quot;The file which should contain groups does not exist!\n&quot; + groupsFile.getPath());
257  		} catch (IOException e) {
258  			e.printStackTrace();
259  			throw new IllegalArgumentException(&quot;Error accessing the groups file!\n&quot; + groupsFile.getPath());
260  		}
261  		GroupManager.setLoaded(true);
262  	}
263  	public void loadUsers(File usersFile) {
264  		GroupManager.setLoaded(false);
265  		try {
266  			setUsersFile(usersFile);
267  			loadUsers(this, usersFile);
268  		} catch (FileNotFoundException e) {
269  			e.printStackTrace();
270  			throw new IllegalArgumentException(&quot;The file which should contain users does not exist!\n&quot; + usersFile.getPath());
271  		} catch (IOException e) {
272  			e.printStackTrace();
273  			throw new IllegalArgumentException(&quot;Error accessing the users file!\n&quot; + usersFile.getPath());
274  		}
275  		GroupManager.setLoaded(true);
276  	}
277  	public static WorldDataHolder load(String worldName, File groupsFile, File usersFile) throws FileNotFoundException, IOException {
278  		WorldDataHolder ph = new WorldDataHolder(worldName);
279  		GroupManager.setLoaded(false);
280  		if (groupsFile != null)
281  			loadGroups(ph, groupsFile);
282  		if (usersFile != null)
283  			loadUsers(ph, usersFile);
284  		GroupManager.setLoaded(true);
285  		return ph;
286  	}
287  	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
288  	protected static void loadGroups(WorldDataHolder ph, File groupsFile) throws FileNotFoundException, IOException {
289  		Yaml yamlGroups = new Yaml(new SafeConstructor());
290  		Map&lt;String, Object&gt; groupsRootDataNode;
291  		if (!groupsFile.exists()) {
292  			throw new IllegalArgumentException(&quot;The file which should contain groups does not exist!\n&quot; + groupsFile.getPath());
293  		}
294  		FileInputStream groupsInputStream = new FileInputStream(groupsFile);
295  		try {
296  			groupsRootDataNode = (Map&lt;String, Object&gt;) yamlGroups.load(new UnicodeReader(groupsInputStream));
297  			if (groupsRootDataNode == null) {
298  				throw new NullPointerException();
299  			}
300  		} catch (Exception ex) {
301  			throw new IllegalArgumentException(&quot;The following file couldn&#x27;t pass on Parser.\n&quot; + groupsFile.getPath(), ex);
302  		} finally {
303  			groupsInputStream.close();
304  		}
305  		Map&lt;String, List&lt;String&gt;&gt; inheritance = new HashMap&lt;String, List&lt;String&gt;&gt;();
306  		Map&lt;String, Object&gt; allGroupsNode = null;
307  		try {
308  			allGroupsNode = (Map&lt;String, Object&gt;) groupsRootDataNode.get(&quot;groups&quot;);
309  		} catch (Exception ex) {
310  			throw new IllegalArgumentException(&quot;Your &quot; + groupsFile.getPath() + &quot; file is invalid. See console for details.&quot;, ex);
311  		}
312  		if (allGroupsNode == null) {
313  			throw new IllegalArgumentException(&quot;You have no groups in &quot; + groupsFile.getPath() + &quot;.&quot;);
314  		}
315  		Iterator&lt;String&gt; groupItr = allGroupsNode.keySet().iterator();
316  		String groupKey;
317  		Integer groupCount = 0;
318  		while (groupItr.hasNext()) {
319  			try {
320  				groupCount++;
321  				groupKey = groupItr.next();
322  			} catch (Exception ex) {
323  				throw new IllegalArgumentException(&quot;Invalid group name for group entry (&quot; + groupCount + &quot;) in file: &quot; + groupsFile.getPath(), ex);
324  			}
325  			Map&lt;String, Object&gt; thisGroupNode = null;
326  			try {
327  				thisGroupNode = (Map&lt;String, Object&gt;) allGroupsNode.get(groupKey);
328  			} catch (Exception ex) {
329  				throw new IllegalArgumentException(&quot;Invalid child nodes for group &#x27;&quot; + groupKey + &quot;&#x27; in file: &quot; + groupsFile.getPath(), ex);
330  			}
331  			Group thisGrp = ph.createGroup(groupKey);
332  			if (thisGrp == null) {
333  				throw new IllegalArgumentException(&quot;I think this Group was declared more than once: &quot; + groupKey + &quot; in file: &quot; + groupsFile.getPath());
334  			}
335  			Object nodeData = null;
336  			try {
337  				nodeData = thisGroupNode.get(&quot;default&quot;);
338  			} catch (Exception ex) {
339  				throw new IllegalArgumentException(&quot;Bad format found in &#x27;permissions&#x27; for group: &quot; + groupKey + &quot; in file: &quot; + groupsFile.getPath());
340  			}
341  			if (nodeData == null) {
342  			} else if ((Boolean.parseBoolean(nodeData.toString()))) {
343  				if (ph.getDefaultGroup() != null) {
344  					GroupManager.logger.warning(&quot;The group &#x27;&quot; + thisGrp.getName() + &quot;&#x27; is claiming to be default where &#x27;&quot; + ph.getDefaultGroup().getName() + &quot;&#x27; already was.&quot;);
345  					GroupManager.logger.warning(&quot;Overriding first default request in file: &quot; + groupsFile.getPath());
346  				}
347  				ph.setDefaultGroup(thisGrp);
348  			}
349  			nodeData = null;
350  			try {
351  				nodeData = thisGroupNode.get(&quot;permissions&quot;);
352  			} catch (Exception ex) {
353  				throw new IllegalArgumentException(&quot;Bad format found in &#x27;permissions&#x27; for &#x27;&quot; + groupKey + &quot;&#x27; in file: &quot; + groupsFile.getPath());
354  			}
355  			if (nodeData == null) {
356  			} else {
357  				if (nodeData instanceof List) {
358  					try {
359  						for (Object o : ((List) nodeData)) {
360  							try {
361  								if (!o.toString().isEmpty())
362  									thisGrp.addPermission(o.toString());
363  							} catch (NullPointerException ex) {
364  							}
365  						}
366  					} catch (Exception ex) {
367  						throw new IllegalArgumentException(&quot;Invalid formatting found in &#x27;permissions&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath(), ex);
368  					}
369  				} else if (nodeData instanceof String) {
370  					if (!nodeData.toString().isEmpty())
371  						thisGrp.addPermission((String) nodeData);
372  				} else {
373  					throw new IllegalArgumentException(&quot;Unknown type of &#x27;permissions&#x27; node(Should be String or List&lt;String&gt;) for group:  &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath());
374  				}
375  				thisGrp.sortPermissions();
376  			}
377  			nodeData = null;
378  			try {
379  				nodeData = thisGroupNode.get(&quot;info&quot;);
380  			} catch (Exception ex) {
381  				throw new IllegalArgumentException(&quot;Bad format found in &#x27;info&#x27; section for group: &quot; + groupKey + &quot; in file: &quot; + groupsFile.getPath());
382  			}
383  			if (nodeData == null) {
384  				GroupManager.logger.warning(&quot;The group &#x27;&quot; + thisGrp.getName() + &quot;&#x27; has no &#x27;info&#x27; section!&quot;);
385  				GroupManager.logger.warning(&quot;Using default values: &quot; + groupsFile.getPath());
386  			} else if (nodeData instanceof Map) {
387  				try {
388  					if (nodeData != null) {
389  						thisGrp.setVariables((Map&lt;String, Object&gt;) nodeData);
390  					}
391  				} catch (Exception ex) {
392  					throw new IllegalArgumentException(&quot;Invalid formatting found in &#x27;info&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath(), ex);
393  				}
394  			} else
395  				throw new IllegalArgumentException(&quot;Unknown entry found in &#x27;info&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath());
396  			nodeData = null;
397  			try {
398  				nodeData = thisGroupNode.get(&quot;inheritance&quot;);
399  			} catch (Exception ex) {
400  				throw new IllegalArgumentException(&quot;Bad format found in &#x27;inheritance&#x27; section for group: &quot; + groupKey + &quot; in file: &quot; + groupsFile.getPath());
401  			}
402  			if (nodeData == null || nodeData instanceof List) {
403  				if (nodeData == null) {
404  				} else if (nodeData instanceof List) {
405  					try {
406  						for (String grp : (List&lt;String&gt;) nodeData) {
407  							if (inheritance.get(groupKey) == null) {
408  								inheritance.put(groupKey, new ArrayList&lt;String&gt;());
409  							}
410  							inheritance.get(groupKey).add(grp);
411  						}
412  					} catch (Exception ex) {
413  						throw new IllegalArgumentException(&quot;Invalid formatting found in &#x27;inheritance&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath(), ex);
414  					}
415  				}
416  			} else
417  				throw new IllegalArgumentException(&quot;Unknown entry found in &#x27;inheritance&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath());
418  		}
419  		if (ph.getDefaultGroup() == null) {
420  			throw new IllegalArgumentException(&quot;There was no Default Group declared in file: &quot; + groupsFile.getPath());
421  		}
422  		for (String group : inheritance.keySet()) {
423  			List&lt;String&gt; inheritedList = inheritance.get(group);
424  			Group thisGroup = ph.getGroup(group);
425  			if (thisGroup != null)
426  				for (String inheritedKey : inheritedList) {
427  					if (inheritedKey != null) {
428  						Group inheritedGroup = ph.getGroup(inheritedKey);
429  						if (inheritedGroup != null) {
430  							thisGroup.addInherits(inheritedGroup);
431  						} else
432  							GroupManager.logger.warning(&quot;Inherited group &#x27;&quot; + inheritedKey + &quot;&#x27; not found for group &quot; + thisGroup.getName() + &quot;. Ignoring entry in file: &quot; + groupsFile.getPath());
433  					}
434  				}
435  		}
436  		ph.removeGroupsChangedFlag();
437  		ph.setGroupsFile(groupsFile);
438  		ph.setTimeStampGroups(groupsFile.lastModified());
439  	}
440  	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
441  	protected static void loadUsers(WorldDataHolder ph, File usersFile) throws FileNotFoundException, IOException {
442  		Yaml yamlUsers = new Yaml(new SafeConstructor());
443  		Map&lt;String, Object&gt; usersRootDataNode;
444  		if (!usersFile.exists()) {
445  			throw new IllegalArgumentException(&quot;The file which should contain users does not exist!\n&quot; + usersFile.getPath());
446  		}
447  		FileInputStream usersInputStream = new FileInputStream(usersFile);
448  		try {
449  			usersRootDataNode = (Map&lt;String, Object&gt;) yamlUsers.load(new UnicodeReader(usersInputStream));
450  			if (usersRootDataNode == null) {
451  				throw new NullPointerException();
452  			}
453  		} catch (Exception ex) {
454  			throw new IllegalArgumentException(&quot;The following file couldn&#x27;t pass on Parser.\n&quot; + usersFile.getPath(), ex);
455  		} finally {
456  			usersInputStream.close();
457  		}
458  		Map&lt;String, Object&gt; allUsersNode = null;
459  		try {
460  			allUsersNode = (Map&lt;String, Object&gt;) usersRootDataNode.get(&quot;users&quot;);
461  		} catch (Exception ex) {
462  			throw new IllegalArgumentException(&quot;Your &quot; + usersFile.getPath() + &quot; file is invalid. See console for details.&quot;, ex);
463  		}
464  		if (allUsersNode != null) {
465  			Iterator&lt;String&gt; usersItr = allUsersNode.keySet().iterator();
466  			String usersKey;
467  			Object node;
468  			Integer userCount = 0;
469  			while (usersItr.hasNext()) {
470  				try {
471  					userCount++;
472  					node = usersItr.next();
473  					if (node instanceof Integer)
474  						usersKey = Integer.toString((Integer) node);
475  					else
476  						usersKey = node.toString();
477  				} catch (Exception ex) {
478  					throw new IllegalArgumentException(&quot;Invalid node type for user entry (&quot; + userCount + &quot;) in file: &quot; + usersFile.getPath(), ex);
479  				}
480  				Map&lt;String, Object&gt; thisUserNode = null;
481  				try {
482  					thisUserNode = (Map&lt;String, Object&gt;) allUsersNode.get(node);
483  				} catch (Exception ex) {
484  					throw new IllegalArgumentException(&quot;Bad format found for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
485  				}
486  				User thisUser = ph.createUser(usersKey);
487  				if (thisUser == null) {
488  					throw new IllegalArgumentException(&quot;I think this user was declared more than once: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
489  				}
490  				Object nodeData = null;
491  				try {
492  					nodeData = thisUserNode.get(&quot;lastname&quot;);
493  				} catch (Exception ex) {
494  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;subgroups&#x27; for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
495  				}
496  				if ((nodeData != null) &amp;&amp; (nodeData instanceof String)) {
497  					thisUser.setLastName((String) nodeData);
498  				}
499  				nodeData = null;
500  				try {
501  					nodeData = thisUserNode.get(&quot;permissions&quot;);
502  				} catch (Exception ex) {
503  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;permissions&#x27; for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
504  				}
505  				if (nodeData == null) {
506  				} else {
507  					try {
508  						if (nodeData instanceof List) {
509  							for (Object o : ((List) nodeData)) {
510  								if (!o.toString().isEmpty()) {
511  									thisUser.addPermission(o.toString());
512  								}
513  							}
514  						} else if (nodeData instanceof String) {
515  							if (!nodeData.toString().isEmpty()) {
516  								thisUser.addPermission(nodeData.toString());
517  							}
518  						}
519  					} catch (NullPointerException e) {
520  					}
521  					thisUser.sortPermissions();
522  				}
523  				nodeData = null;
524  				try {
525  					nodeData = thisUserNode.get(&quot;subgroups&quot;);
526  				} catch (Exception ex) {
527  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;subgroups&#x27; for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
528  				}
529  				if (nodeData == null) {
530  				} else if (nodeData instanceof List) {
531  					for (Object o : ((List) nodeData)) {
532  						if (o == null) {
533  							GroupManager.logger.warning(&quot;Invalid Subgroup data for user: &quot; + thisUser.getLastName() + &quot;. Ignoring entry in file: &quot; + usersFile.getPath());
534  						} else {
535  							Group subGrp = ph.getGroup(o.toString());
536  							if (subGrp != null) {
537  								thisUser.addSubGroup(subGrp);
538  							} else {
539  								GroupManager.logger.warning(&quot;Subgroup &#x27;&quot; + o.toString() + &quot;&#x27; not found for user: &quot; + thisUser.getLastName() + &quot;. Ignoring entry in file: &quot; + usersFile.getPath());
540  							}
541  						}
542  					}
543  				} else if (nodeData instanceof String) {
544  					Group subGrp = ph.getGroup(nodeData.toString());
545  					if (subGrp != null) {
546  						thisUser.addSubGroup(subGrp);
547  					} else {
548  						GroupManager.logger.warning(&quot;Subgroup &#x27;&quot; + nodeData.toString() + &quot;&#x27; not found for user: &quot; + thisUser.getLastName() + &quot;. Ignoring entry in file: &quot; + usersFile.getPath());
549  					}
550  				}
551  				nodeData = null;
552  				try {
553  					nodeData = thisUserNode.get(&quot;info&quot;);
554  				} catch (Exception ex) {
555  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;info&#x27; section for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
556  				}
557  				if (nodeData == null) {
558  				} else if (nodeData instanceof Map) {
559  					thisUser.setVariables((Map&lt;String, Object&gt;) nodeData);
560  				} else
561  					throw new IllegalArgumentException(&quot;Unknown entry found in &#x27;info&#x27; section for user: &quot; + thisUser.getLastName() + &quot; in file: &quot; + usersFile.getPath());
562  				nodeData = null;
563  				try {
564  					nodeData = thisUserNode.get(&quot;group&quot;);
565  				} catch (Exception ex) {
566  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;group&#x27; section for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
567  				}
568  				if (nodeData != null) {
569  					Group hisGroup = ph.getGroup(nodeData.toString());
570  					if (hisGroup == null) {
571  						GroupManager.logger.warning(&quot;There is no group &quot; + thisUserNode.get(&quot;group&quot;).toString() + &quot;, as stated for player &quot; + thisUser.getLastName() + &quot;: Set to &#x27;&quot; + ph.getDefaultGroup().getName() + &quot;&#x27; for file: &quot; + usersFile.getPath());
572  						hisGroup = ph.getDefaultGroup();
573  					}
574  					thisUser.setGroup(hisGroup);
575  				} else {
576  					thisUser.setGroup(ph.getDefaultGroup());
577  				}
578  			}
579  		}
580  		ph.removeUsersChangedFlag();
581  		ph.setUsersFile(usersFile);
582  		ph.setTimeStampUsers(usersFile.lastModified());
583  	}
584  	public static void writeGroups(WorldDataHolder ph, File groupsFile) {
585  		Map&lt;String, Object&gt; root = new HashMap&lt;String, Object&gt;();
586  		Map&lt;String, Object&gt; groupsMap = new HashMap&lt;String, Object&gt;();
587  		root.put(&quot;groups&quot;, groupsMap);
588  		synchronized (ph.getGroups()) {
589  			for (String groupKey : ph.getGroups().keySet()) {
590  				Group group = ph.getGroups().get(groupKey);
591  				Map&lt;String, Object&gt; aGroupMap = new HashMap&lt;String, Object&gt;();
592  				groupsMap.put(group.getName(), aGroupMap);
593  				if (ph.getDefaultGroup() == null) {
594  					GroupManager.logger.severe(&quot;There is no default group for world: &quot; + ph.getName());
595  				}
596  				aGroupMap.put(&quot;default&quot;, group.equals(ph.getDefaultGroup()));
597  				Map&lt;String, Object&gt; infoMap = new HashMap&lt;String, Object&gt;();
598  				aGroupMap.put(&quot;info&quot;, infoMap);
599  				for (String infoKey : group.getVariables().getVarKeyList()) {
600  					infoMap.put(infoKey, group.getVariables().getVarObject(infoKey));
601  				}
602  				aGroupMap.put(&quot;inheritance&quot;, group.getInherits());
603  				aGroupMap.put(&quot;permissions&quot;, group.getPermissionList());
604  			}
605  		}
606  		if (!root.isEmpty()) {
607  			DumperOptions opt = new DumperOptions();
608  			opt.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
609  			final Yaml yaml = new Yaml(opt);
610  			try {
611  				OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(groupsFile), &quot;UTF-8&quot;);
612  				String newLine = System.getProperty(&quot;line.separator&quot;);
613  				out.write(&quot;# Group inheritance&quot; + newLine);
614  				out.write(&quot;#&quot; + newLine);
615  				out.write(&quot;# Any inherited groups prefixed with a g: are global groups&quot; + newLine);
616  				out.write(&quot;# and are inherited from the GlobalGroups.yml.&quot; + newLine);
617  				out.write(&quot;#&quot; + newLine);
618  				out.write(&quot;# Groups without the g: prefix are groups local to this world&quot; + newLine);
619  				out.write(&quot;# and are defined in the this groups.yml file.&quot; + newLine);
620  				out.write(&quot;#&quot; + newLine);
621  				out.write(&quot;# Local group inheritances define your promotion tree when using &#x27;manpromote/mandemote&#x27;&quot; + newLine);
622  				out.write(newLine);
623  				yaml.dump(root, out);
624  				out.close();
625  			} catch (UnsupportedEncodingException ex) {
626  			} catch (FileNotFoundException ex) {
627  			} catch (IOException e) {
628  			}
629  		}
630  		ph.setGroupsFile(groupsFile);
631  		ph.setTimeStampGroups(groupsFile.lastModified());
632  		ph.removeGroupsChangedFlag();
633  		if (GroupManager.isLoaded())
634  			GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.SAVED);
635  	}
636  	public static void writeUsers(WorldDataHolder ph, File usersFile) {
637  		Map&lt;String, Object&gt; root = new HashMap&lt;String, Object&gt;();
638  		LinkedHashMap&lt;String, Object&gt; usersMap = new LinkedHashMap&lt;String, Object&gt;();
639  		root.put(&quot;users&quot;, usersMap);
640  		synchronized (ph.getUsers()) {
641  			for (String userKey : new TreeSet&lt;String&gt;(ph.getUsers().keySet())) {
642  				User user = ph.getUsers().get(userKey);
643  				if ((user.getGroup() == null || user.getGroup().equals(ph.getDefaultGroup())) &amp;&amp; user.getPermissionList().isEmpty() &amp;&amp; user.getVariables().isEmpty() &amp;&amp; user.isSubGroupsEmpty()) {
644  					continue;
645  				}
646  				LinkedHashMap&lt;String, Object&gt; aUserMap = new LinkedHashMap&lt;String, Object&gt;();
647  				usersMap.put(user.getUUID(), aUserMap);
648  				if (!user.getUUID().equalsIgnoreCase(user.getLastName())) {
649  					aUserMap.put(&quot;lastname&quot;, user.getLastName());
650  				}
651  				if (user.getGroup() == null) {
652  					aUserMap.put(&quot;group&quot;, ph.getDefaultGroup().getName());
653  				} else {
654  					aUserMap.put(&quot;group&quot;, user.getGroup().getName());
655  				}
656  				aUserMap.put(&quot;subgroups&quot;, user.subGroupListStringCopy());
657  				aUserMap.put(&quot;permissions&quot;, user.getPermissionList());
658  				if (user.getVariables().getSize() &gt; 0) {
659  					Map&lt;String, Object&gt; infoMap = new HashMap&lt;String, Object&gt;();
660  					aUserMap.put(&quot;info&quot;, infoMap);
661  					for (String infoKey : user.getVariables().getVarKeyList()) {
662  						infoMap.put(infoKey, user.getVariables().getVarObject(infoKey));
663  					}
664  				}
665  			}
666  		}
667  		if (!root.isEmpty()) {
668  			DumperOptions opt = new DumperOptions();
669  			opt.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
670  			final Yaml yaml = new Yaml(opt);
671  			try {
672  				OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(usersFile), &quot;UTF-8&quot;);
673  				yaml.dump(root, out);
674  				out.close();
675  			} catch (UnsupportedEncodingException ex) {
676  			} catch (FileNotFoundException ex) {
677  			} catch (IOException e) {
678  			}
679  		}
680  		ph.setUsersFile(usersFile);
681  		ph.setTimeStampUsers(usersFile.lastModified());
682  		ph.removeUsersChangedFlag();
683  		if (GroupManager.isLoaded())
684  			GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.SAVED);
685  	}
686  	@Deprecated
687  	public static void reloadOldPlugins(Server server) {
688  		PluginManager pm = server.getPluginManager();
689  		Plugin[] plugins = pm.getPlugins();
690  		for (int i = 0; i &lt; plugins.length; i++) {
691  			try {
692  				plugins[i].getClass().getMethod(&quot;setupPermissions&quot;).invoke(plugins[i]);
693  			} catch (Exception ex) {
694  				continue;
695  			}
696  		}
697  	}
698  	public AnjoPermissionsHandler getPermissionsHandler() {
699  		if (permissionsHandler == null) {
700  			permissionsHandler = new AnjoPermissionsHandler(this);
701  		}
702  		return permissionsHandler;
703  	}
704  	public void setUsersChanged(boolean haveUsersChanged) {
705  		users.setUsersChanged(haveUsersChanged);
706  	}
707  	public boolean haveUsersChanged() {
708  		if (users.HaveUsersChanged()) {
709  			return true;
710  		}
711  		synchronized (users.getUsers()) {
712  			for (User u : users.getUsers().values()) {
713  				if (u.isChanged()) {
714  					return true;
715  				}
716  			}
717  		}
718  		return false;
719  	}
720  	public void setGroupsChanged(boolean setGroupsChanged) {
721  		groups.setGroupsChanged(setGroupsChanged);
722  	}
723  	public boolean haveGroupsChanged() {
724  		if (groups.HaveGroupsChanged()) {
725  			return true;
726  		}
727  		synchronized (groups.getGroups()) {
728  			for (Group g : groups.getGroups().values()) {
729  				if (g.isChanged()) {
730  					return true;
731  				}
732  			}
733  		}
734  		return false;
735  	}
736  	public void removeUsersChangedFlag() {
737  		setUsersChanged(false);
738  		synchronized (getUsers()) {
739  			for (User u : getUsers().values()) {
740  				u.flagAsSaved();
741  			}
742  		}
743  	}
744  	public void removeGroupsChangedFlag() {
745  		setGroupsChanged(false);
746  		synchronized (getGroups()) {
747  			for (Group g : getGroups().values()) {
748  				g.flagAsSaved();
749  			}
750  		}
751  	}
752  	public File getUsersFile() {
753  		return users.getUsersFile();
754  	}
755  	public void setUsersFile(File file) {
756  		users.setUsersFile(file);
757  	}
758  	public File getGroupsFile() {
759  		return groups.getGroupsFile();
760  	}
761  	public void setGroupsFile(File file) {
762  		groups.setGroupsFile(file);
763  	}
764  	public String getName() {
765  		return name;
766  	}
767  	public void resetGroups() {
768  		groups.resetGroups();
769  	}
770  	public void resetUsers() {
771  		users.resetUsers();
772  	}
773  	public Map&lt;String, Group&gt; getGroups() {
774  		return groups.getGroups();
775  	}
776  	public Map&lt;String, User&gt; getUsers() {
777  		return users.getUsers();
778  	}
779  	public GroupsDataHolder getGroupsObject() {
780  		return groups;
781  	}
782  	public void setGroupsObject(GroupsDataHolder groupsDataHolder) {
783  		groups = groupsDataHolder;
784  	}
785  	public UsersDataHolder getUsersObject() {
786  		return users;
787  	}
788  	public void setUsersObject(UsersDataHolder usersDataHolder) {
789  		users = usersDataHolder;
790  	}
791  	public long getTimeStampGroups() {
792  		return groups.getTimeStampGroups();
793  	}
794  	public long getTimeStampUsers() {
795  		return users.getTimeStampUsers();
796  	}
797  	protected void setTimeStampGroups(long timeStampGroups) {
798  		groups.setTimeStampGroups(timeStampGroups);
799  	}
800  	protected void setTimeStampUsers(long timeStampUsers) {
801  		users.setTimeStampUsers(timeStampUsers);
802  	}
803  	public void setTimeStamps() {
804  		if (getGroupsFile() != null)
805  			setTimeStampGroups(getGroupsFile().lastModified());
806  		if (getUsersFile() != null)
807  			setTimeStampUsers(getUsersFile().lastModified());
808  	}
809  }
</code></pre>
        </div>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldDataHolder.java</h3>
            <pre><code>1  package org.anjocaido.groupmanager.dataholder;
2  import java.io.File;
3  import java.io.FileInputStream;
4  import java.io.FileNotFoundException;
5  import java.io.FileOutputStream;
6  import java.io.IOException;
7  import java.io.OutputStreamWriter;
8  import java.io.UnsupportedEncodingException;
9  import java.util.ArrayList;
10  import java.util.Collection;
11  import java.util.HashMap;
12  import java.util.Iterator;
13  import java.util.LinkedHashMap;
14  import java.util.List;
15  import java.util.Map;
16  import java.util.TreeSet;
17  import java.util.logging.Level;
18  import java.util.logging.Logger;
19  import org.anjocaido.groupmanager.GroupManager;
20  import org.anjocaido.groupmanager.data.Group;
21  import org.anjocaido.groupmanager.data.User;
22  import org.anjocaido.groupmanager.events.GMGroupEvent;
23  import org.anjocaido.groupmanager.events.GMSystemEvent;
24  import org.anjocaido.groupmanager.events.GMUserEvent;
25  import org.anjocaido.groupmanager.events.GMUserEvent.Action;
26  import org.anjocaido.groupmanager.permissions.AnjoPermissionsHandler;
27  import org.bukkit.Server;
28  import org.bukkit.plugin.Plugin;
29  import org.bukkit.plugin.PluginManager;
30  import org.yaml.snakeyaml.DumperOptions;
31  import org.yaml.snakeyaml.Yaml;
32  import org.yaml.snakeyaml.constructor.SafeConstructor;
33  import org.yaml.snakeyaml.reader.UnicodeReader;
34  public class WorldDataHolder {
35  	protected String name;
36  	protected GroupsDataHolder groups = new GroupsDataHolder();
37  	protected UsersDataHolder users = new UsersDataHolder();
38  	protected AnjoPermissionsHandler permissionsHandler;
39  	public WorldDataHolder(String worldName) {
40  		name = worldName;
41  	}
42  	public WorldDataHolder(String worldName, GroupsDataHolder groups, UsersDataHolder users) {
43  		this.name = worldName;
44  		this.groups = groups;
45  		this.users = users;
46  	}
47  	public void updateDataSource() {
48  		this.groups.setDataSource(this);
49  		this.users.setDataSource(this);
50  	}
51  	public User getUser(String userId) {
52  		if (getUsers().containsKey(userId.toLowerCase())) {
53  			return getUsers().get(userId.toLowerCase());
54  		}
55  		if (userId.length() &lt; 36) {
56  			for (User user : getUserList()) {
57  				if (user.getLastName().equalsIgnoreCase(userId)) {
58  					return user;
59  				}
60  			}
61  		}
62  		User newUser = createUser(userId);
63  		return newUser;
64  	}
65  	public User getUser(String uUID, String currentName) {
66  		User user = getUsers().get(uUID.toLowerCase());
67  		if (user != null) {
68  			user.setLastName(currentName);
69  			return user;
70  		}
71  		for (User usr : getUserList()) {
72  			if (usr.getLastName().equalsIgnoreCase(currentName) &amp;&amp; usr.getUUID().equalsIgnoreCase(usr.getLastName())) {
73  				user = usr.clone(uUID, currentName);
74  				this.removeUser(usr.getUUID());
75  				this.addUser(user);
76  				return getUsers().get(uUID.toLowerCase());
77  			}
78  		}
79  		User newUser = createUser(uUID);
80  		newUser.setLastName(currentName);
81  		return newUser;
82  	}
83  	public void addUser(User theUser) {
84  		if (theUser.getDataSource() != this) {
85  			theUser = theUser.clone(this);
86  		}
87  		if (theUser == null) {
88  			return;
89  		}
90  		if ((theUser.getGroup() == null)) {
91  			theUser.setGroup(groups.getDefaultGroup());
92  		}
93  		removeUser(theUser.getUUID());
94  		getUsers().put(theUser.getUUID().toLowerCase(), theUser);
95  		setUsersChanged(true);
96  		if (GroupManager.isLoaded())
97  			GroupManager.getGMEventHandler().callEvent(theUser, Action.USER_ADDED);
98  	}
99  	public boolean removeUser(String userId) {
100  		if (getUsers().containsKey(userId.toLowerCase())) {
101  			getUsers().remove(userId.toLowerCase());
102  			setUsersChanged(true);
103  			if (GroupManager.isLoaded())
104  				GroupManager.getGMEventHandler().callEvent(userId, GMUserEvent.Action.USER_REMOVED);
105  			return true;
106  		}
107  		return false;
108  	}
109  	public boolean isUserDeclared(String userId) {
110  		return getUsers().containsKey(userId.toLowerCase());
111  	}
112  	public void setDefaultGroup(Group group) {
113  		if (!getGroups().containsKey(group.getName().toLowerCase()) || (group.getDataSource() != this)) {
114  			addGroup(group);
115  		}
116  		groups.setDefaultGroup(getGroup(group.getName()));
117  		setGroupsChanged(true);
118  		if (GroupManager.isLoaded())
119  			GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.DEFAULT_GROUP_CHANGED);
120  	}
121  	public Group getDefaultGroup() {
122  		return groups.getDefaultGroup();
123  	}
124  	public Group getGroup(String groupName) {
125  		if (groupName.toLowerCase().startsWith(&quot;g:&quot;))
126  			return GroupManager.getGlobalGroups().getGroup(groupName);
127  		else
128  			return getGroups().get(groupName.toLowerCase());
129  	}
130  	public boolean groupExists(String groupName) {
131  		if (groupName.toLowerCase().startsWith(&quot;g:&quot;))
132  			return GroupManager.getGlobalGroups().hasGroup(groupName);
133  		else
134  			return getGroups().containsKey(groupName.toLowerCase());
135  	}
136  	public void addGroup(Group groupToAdd) {
137  		if (groupToAdd.getName().toLowerCase().startsWith(&quot;g:&quot;)) {
138  			GroupManager.getGlobalGroups().addGroup(groupToAdd);
139  			GroupManager.getGMEventHandler().callEvent(groupToAdd, GMGroupEvent.Action.GROUP_ADDED);
140  			return;
141  		}
142  		if (groupToAdd.getDataSource() != this) {
143  			groupToAdd = groupToAdd.clone(this);
144  		}
145  		removeGroup(groupToAdd.getName());
146  		getGroups().put(groupToAdd.getName().toLowerCase(), groupToAdd);
147  		setGroupsChanged(true);
148  		if (GroupManager.isLoaded())
149  			GroupManager.getGMEventHandler().callEvent(groupToAdd, GMGroupEvent.Action.GROUP_ADDED);
150  	}
151  	public boolean removeGroup(String groupName) {
152  		if (groupName.toLowerCase().startsWith(&quot;g:&quot;)) {
153  			return GroupManager.getGlobalGroups().removeGroup(groupName);
154  		}
155  		if (getDefaultGroup() != null &amp;&amp; groupName.equalsIgnoreCase(getDefaultGroup().getName())) {
156  			return false;
157  		}
158  		if (getGroups().containsKey(groupName.toLowerCase())) {
159  			getGroups().remove(groupName.toLowerCase());
160  			setGroupsChanged(true);
161  			if (GroupManager.isLoaded())
162  				GroupManager.getGMEventHandler().callEvent(groupName.toLowerCase(), GMGroupEvent.Action.GROUP_REMOVED);
163  			return true;
164  		}
165  		return false;
166  	}
167  	public User createUser(String userId) {
168  		if (getUsers().containsKey(userId.toLowerCase())) {
169  			return null;
170  		}
171  		User newUser = new User(this, userId);
172  		newUser.setGroup(groups.getDefaultGroup(), false);
173  		addUser(newUser);
174  		setUsersChanged(true);
175  		return newUser;
176  	}
177  	public Group createGroup(String groupName) {
178  		if (groupName.toLowerCase().startsWith(&quot;g:&quot;)) {
179  			Group newGroup = new Group(groupName);
180  			return GroupManager.getGlobalGroups().newGroup(newGroup);
181  		}
182  		if (getGroups().containsKey(groupName.toLowerCase())) {
183  			return null;
184  		}
185  		Group newGroup = new Group(this, groupName);
186  		addGroup(newGroup);
187  		setGroupsChanged(true);
188  		return newGroup;
189  	}
190  	public Collection&lt;Group&gt; getGroupList() {
191  		synchronized (getGroups()) {
192  			return new ArrayList&lt;Group&gt;(getGroups().values());
193  		}
194  	}
195  	public Collection&lt;User&gt; getUserList() {
196  		synchronized (getUsers()) {
197  			return new ArrayList&lt;User&gt;(getUsers().values());
198  		}
199  	}
200  	public void reload() {
201  		try {
202  			reloadGroups();
203  			reloadUsers();
204  		} catch (Exception ex) {
205  			Logger.getLogger(WorldDataHolder.class.getName()).log(Level.SEVERE, null, ex);
206  		}
207  	}
208  	public void reloadGroups() {
209  		GroupManager.setLoaded(false);
210  		try {
211  			WorldDataHolder ph = new WorldDataHolder(this.getName());
212  			loadGroups(ph, getGroupsFile());
213  			resetGroups();
214  			for (Group tempGroup : ph.getGroupList()) {
215  				tempGroup.clone(this);
216  			}
217  			this.setDefaultGroup(getGroup(ph.getDefaultGroup().getName()));
218  			this.removeGroupsChangedFlag();
219  			this.setTimeStampGroups(getGroupsFile().lastModified());
220  			ph = null;
221  		} catch (Exception ex) {
222  			Logger.getLogger(WorldDataHolder.class.getName()).log(Level.WARNING, null, ex);
223  		}
224  		GroupManager.setLoaded(true);
225  		GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.RELOADED);
226  	}
<span onclick='openModal()' class='match'>227  	public void reloadUsers() {
228  		GroupManager.setLoaded(false);
229  		try {
230  			WorldDataHolder ph = new WorldDataHolder(this.getName());
231  			for (Group tempGroup : this.getGroupList()) {
</span>232  				tempGroup.clone(ph);
233  			}
234  			ph.setDefaultGroup(ph.getGroup(getDefaultGroup().getName()));
235  			loadUsers(ph, getUsersFile());
236  			resetUsers();
237  			for (User tempUser : ph.getUserList()) {
238  				tempUser.clone(this);
239  			}
240  			this.removeUsersChangedFlag();
241  			this.setTimeStampUsers(getUsersFile().lastModified());
242  			ph = null;
243  		} catch (Exception ex) {
244  			Logger.getLogger(WorldDataHolder.class.getName()).log(Level.WARNING, null, ex);
245  		}
246  		GroupManager.setLoaded(true);
247  		GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.RELOADED);
248  	}
249  	public void loadGroups(File groupsFile) {
250  		GroupManager.setLoaded(false);
251  		try {
252  			setGroupsFile(groupsFile);
253  			loadGroups(this, groupsFile);
254  		} catch (FileNotFoundException e) {
255  			e.printStackTrace();
256  			throw new IllegalArgumentException(&quot;The file which should contain groups does not exist!\n&quot; + groupsFile.getPath());
257  		} catch (IOException e) {
258  			e.printStackTrace();
259  			throw new IllegalArgumentException(&quot;Error accessing the groups file!\n&quot; + groupsFile.getPath());
260  		}
261  		GroupManager.setLoaded(true);
262  	}
263  	public void loadUsers(File usersFile) {
264  		GroupManager.setLoaded(false);
265  		try {
266  			setUsersFile(usersFile);
267  			loadUsers(this, usersFile);
268  		} catch (FileNotFoundException e) {
269  			e.printStackTrace();
270  			throw new IllegalArgumentException(&quot;The file which should contain users does not exist!\n&quot; + usersFile.getPath());
271  		} catch (IOException e) {
272  			e.printStackTrace();
273  			throw new IllegalArgumentException(&quot;Error accessing the users file!\n&quot; + usersFile.getPath());
274  		}
275  		GroupManager.setLoaded(true);
276  	}
277  	public static WorldDataHolder load(String worldName, File groupsFile, File usersFile) throws FileNotFoundException, IOException {
278  		WorldDataHolder ph = new WorldDataHolder(worldName);
279  		GroupManager.setLoaded(false);
280  		if (groupsFile != null)
281  			loadGroups(ph, groupsFile);
282  		if (usersFile != null)
283  			loadUsers(ph, usersFile);
284  		GroupManager.setLoaded(true);
285  		return ph;
286  	}
287  	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
288  	protected static void loadGroups(WorldDataHolder ph, File groupsFile) throws FileNotFoundException, IOException {
289  		Yaml yamlGroups = new Yaml(new SafeConstructor());
290  		Map&lt;String, Object&gt; groupsRootDataNode;
291  		if (!groupsFile.exists()) {
292  			throw new IllegalArgumentException(&quot;The file which should contain groups does not exist!\n&quot; + groupsFile.getPath());
293  		}
294  		FileInputStream groupsInputStream = new FileInputStream(groupsFile);
295  		try {
296  			groupsRootDataNode = (Map&lt;String, Object&gt;) yamlGroups.load(new UnicodeReader(groupsInputStream));
297  			if (groupsRootDataNode == null) {
298  				throw new NullPointerException();
299  			}
300  		} catch (Exception ex) {
301  			throw new IllegalArgumentException(&quot;The following file couldn&#x27;t pass on Parser.\n&quot; + groupsFile.getPath(), ex);
302  		} finally {
303  			groupsInputStream.close();
304  		}
305  		Map&lt;String, List&lt;String&gt;&gt; inheritance = new HashMap&lt;String, List&lt;String&gt;&gt;();
306  		Map&lt;String, Object&gt; allGroupsNode = null;
307  		try {
308  			allGroupsNode = (Map&lt;String, Object&gt;) groupsRootDataNode.get(&quot;groups&quot;);
309  		} catch (Exception ex) {
310  			throw new IllegalArgumentException(&quot;Your &quot; + groupsFile.getPath() + &quot; file is invalid. See console for details.&quot;, ex);
311  		}
312  		if (allGroupsNode == null) {
313  			throw new IllegalArgumentException(&quot;You have no groups in &quot; + groupsFile.getPath() + &quot;.&quot;);
314  		}
315  		Iterator&lt;String&gt; groupItr = allGroupsNode.keySet().iterator();
316  		String groupKey;
317  		Integer groupCount = 0;
318  		while (groupItr.hasNext()) {
319  			try {
320  				groupCount++;
321  				groupKey = groupItr.next();
322  			} catch (Exception ex) {
323  				throw new IllegalArgumentException(&quot;Invalid group name for group entry (&quot; + groupCount + &quot;) in file: &quot; + groupsFile.getPath(), ex);
324  			}
325  			Map&lt;String, Object&gt; thisGroupNode = null;
326  			try {
327  				thisGroupNode = (Map&lt;String, Object&gt;) allGroupsNode.get(groupKey);
328  			} catch (Exception ex) {
329  				throw new IllegalArgumentException(&quot;Invalid child nodes for group &#x27;&quot; + groupKey + &quot;&#x27; in file: &quot; + groupsFile.getPath(), ex);
330  			}
331  			Group thisGrp = ph.createGroup(groupKey);
332  			if (thisGrp == null) {
333  				throw new IllegalArgumentException(&quot;I think this Group was declared more than once: &quot; + groupKey + &quot; in file: &quot; + groupsFile.getPath());
334  			}
335  			Object nodeData = null;
336  			try {
337  				nodeData = thisGroupNode.get(&quot;default&quot;);
338  			} catch (Exception ex) {
339  				throw new IllegalArgumentException(&quot;Bad format found in &#x27;permissions&#x27; for group: &quot; + groupKey + &quot; in file: &quot; + groupsFile.getPath());
340  			}
341  			if (nodeData == null) {
342  			} else if ((Boolean.parseBoolean(nodeData.toString()))) {
343  				if (ph.getDefaultGroup() != null) {
344  					GroupManager.logger.warning(&quot;The group &#x27;&quot; + thisGrp.getName() + &quot;&#x27; is claiming to be default where &#x27;&quot; + ph.getDefaultGroup().getName() + &quot;&#x27; already was.&quot;);
345  					GroupManager.logger.warning(&quot;Overriding first default request in file: &quot; + groupsFile.getPath());
346  				}
347  				ph.setDefaultGroup(thisGrp);
348  			}
349  			nodeData = null;
350  			try {
351  				nodeData = thisGroupNode.get(&quot;permissions&quot;);
352  			} catch (Exception ex) {
353  				throw new IllegalArgumentException(&quot;Bad format found in &#x27;permissions&#x27; for &#x27;&quot; + groupKey + &quot;&#x27; in file: &quot; + groupsFile.getPath());
354  			}
355  			if (nodeData == null) {
356  			} else {
357  				if (nodeData instanceof List) {
358  					try {
359  						for (Object o : ((List) nodeData)) {
360  							try {
361  								if (!o.toString().isEmpty())
362  									thisGrp.addPermission(o.toString());
363  							} catch (NullPointerException ex) {
364  							}
365  						}
366  					} catch (Exception ex) {
367  						throw new IllegalArgumentException(&quot;Invalid formatting found in &#x27;permissions&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath(), ex);
368  					}
369  				} else if (nodeData instanceof String) {
370  					if (!nodeData.toString().isEmpty())
371  						thisGrp.addPermission((String) nodeData);
372  				} else {
373  					throw new IllegalArgumentException(&quot;Unknown type of &#x27;permissions&#x27; node(Should be String or List&lt;String&gt;) for group:  &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath());
374  				}
375  				thisGrp.sortPermissions();
376  			}
377  			nodeData = null;
378  			try {
379  				nodeData = thisGroupNode.get(&quot;info&quot;);
380  			} catch (Exception ex) {
381  				throw new IllegalArgumentException(&quot;Bad format found in &#x27;info&#x27; section for group: &quot; + groupKey + &quot; in file: &quot; + groupsFile.getPath());
382  			}
383  			if (nodeData == null) {
384  				GroupManager.logger.warning(&quot;The group &#x27;&quot; + thisGrp.getName() + &quot;&#x27; has no &#x27;info&#x27; section!&quot;);
385  				GroupManager.logger.warning(&quot;Using default values: &quot; + groupsFile.getPath());
386  			} else if (nodeData instanceof Map) {
387  				try {
388  					if (nodeData != null) {
389  						thisGrp.setVariables((Map&lt;String, Object&gt;) nodeData);
390  					}
391  				} catch (Exception ex) {
392  					throw new IllegalArgumentException(&quot;Invalid formatting found in &#x27;info&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath(), ex);
393  				}
394  			} else
395  				throw new IllegalArgumentException(&quot;Unknown entry found in &#x27;info&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath());
396  			nodeData = null;
397  			try {
398  				nodeData = thisGroupNode.get(&quot;inheritance&quot;);
399  			} catch (Exception ex) {
400  				throw new IllegalArgumentException(&quot;Bad format found in &#x27;inheritance&#x27; section for group: &quot; + groupKey + &quot; in file: &quot; + groupsFile.getPath());
401  			}
402  			if (nodeData == null || nodeData instanceof List) {
403  				if (nodeData == null) {
404  				} else if (nodeData instanceof List) {
405  					try {
406  						for (String grp : (List&lt;String&gt;) nodeData) {
407  							if (inheritance.get(groupKey) == null) {
408  								inheritance.put(groupKey, new ArrayList&lt;String&gt;());
409  							}
410  							inheritance.get(groupKey).add(grp);
411  						}
412  					} catch (Exception ex) {
413  						throw new IllegalArgumentException(&quot;Invalid formatting found in &#x27;inheritance&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath(), ex);
414  					}
415  				}
416  			} else
417  				throw new IllegalArgumentException(&quot;Unknown entry found in &#x27;inheritance&#x27; section for group: &quot; + thisGrp.getName() + &quot; in file: &quot; + groupsFile.getPath());
418  		}
419  		if (ph.getDefaultGroup() == null) {
420  			throw new IllegalArgumentException(&quot;There was no Default Group declared in file: &quot; + groupsFile.getPath());
421  		}
422  		for (String group : inheritance.keySet()) {
423  			List&lt;String&gt; inheritedList = inheritance.get(group);
424  			Group thisGroup = ph.getGroup(group);
425  			if (thisGroup != null)
426  				for (String inheritedKey : inheritedList) {
427  					if (inheritedKey != null) {
428  						Group inheritedGroup = ph.getGroup(inheritedKey);
429  						if (inheritedGroup != null) {
430  							thisGroup.addInherits(inheritedGroup);
431  						} else
432  							GroupManager.logger.warning(&quot;Inherited group &#x27;&quot; + inheritedKey + &quot;&#x27; not found for group &quot; + thisGroup.getName() + &quot;. Ignoring entry in file: &quot; + groupsFile.getPath());
433  					}
434  				}
435  		}
436  		ph.removeGroupsChangedFlag();
437  		ph.setGroupsFile(groupsFile);
438  		ph.setTimeStampGroups(groupsFile.lastModified());
439  	}
440  	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
441  	protected static void loadUsers(WorldDataHolder ph, File usersFile) throws FileNotFoundException, IOException {
442  		Yaml yamlUsers = new Yaml(new SafeConstructor());
443  		Map&lt;String, Object&gt; usersRootDataNode;
444  		if (!usersFile.exists()) {
445  			throw new IllegalArgumentException(&quot;The file which should contain users does not exist!\n&quot; + usersFile.getPath());
446  		}
447  		FileInputStream usersInputStream = new FileInputStream(usersFile);
448  		try {
449  			usersRootDataNode = (Map&lt;String, Object&gt;) yamlUsers.load(new UnicodeReader(usersInputStream));
450  			if (usersRootDataNode == null) {
451  				throw new NullPointerException();
452  			}
453  		} catch (Exception ex) {
454  			throw new IllegalArgumentException(&quot;The following file couldn&#x27;t pass on Parser.\n&quot; + usersFile.getPath(), ex);
455  		} finally {
456  			usersInputStream.close();
457  		}
458  		Map&lt;String, Object&gt; allUsersNode = null;
459  		try {
460  			allUsersNode = (Map&lt;String, Object&gt;) usersRootDataNode.get(&quot;users&quot;);
461  		} catch (Exception ex) {
462  			throw new IllegalArgumentException(&quot;Your &quot; + usersFile.getPath() + &quot; file is invalid. See console for details.&quot;, ex);
463  		}
464  		if (allUsersNode != null) {
465  			Iterator&lt;String&gt; usersItr = allUsersNode.keySet().iterator();
466  			String usersKey;
467  			Object node;
468  			Integer userCount = 0;
469  			while (usersItr.hasNext()) {
470  				try {
471  					userCount++;
472  					node = usersItr.next();
473  					if (node instanceof Integer)
474  						usersKey = Integer.toString((Integer) node);
475  					else
476  						usersKey = node.toString();
477  				} catch (Exception ex) {
478  					throw new IllegalArgumentException(&quot;Invalid node type for user entry (&quot; + userCount + &quot;) in file: &quot; + usersFile.getPath(), ex);
479  				}
480  				Map&lt;String, Object&gt; thisUserNode = null;
481  				try {
482  					thisUserNode = (Map&lt;String, Object&gt;) allUsersNode.get(node);
483  				} catch (Exception ex) {
484  					throw new IllegalArgumentException(&quot;Bad format found for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
485  				}
486  				User thisUser = ph.createUser(usersKey);
487  				if (thisUser == null) {
488  					throw new IllegalArgumentException(&quot;I think this user was declared more than once: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
489  				}
490  				Object nodeData = null;
491  				try {
492  					nodeData = thisUserNode.get(&quot;lastname&quot;);
493  				} catch (Exception ex) {
494  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;subgroups&#x27; for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
495  				}
496  				if ((nodeData != null) &amp;&amp; (nodeData instanceof String)) {
497  					thisUser.setLastName((String) nodeData);
498  				}
499  				nodeData = null;
500  				try {
501  					nodeData = thisUserNode.get(&quot;permissions&quot;);
502  				} catch (Exception ex) {
503  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;permissions&#x27; for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
504  				}
505  				if (nodeData == null) {
506  				} else {
507  					try {
508  						if (nodeData instanceof List) {
509  							for (Object o : ((List) nodeData)) {
510  								if (!o.toString().isEmpty()) {
511  									thisUser.addPermission(o.toString());
512  								}
513  							}
514  						} else if (nodeData instanceof String) {
515  							if (!nodeData.toString().isEmpty()) {
516  								thisUser.addPermission(nodeData.toString());
517  							}
518  						}
519  					} catch (NullPointerException e) {
520  					}
521  					thisUser.sortPermissions();
522  				}
523  				nodeData = null;
524  				try {
525  					nodeData = thisUserNode.get(&quot;subgroups&quot;);
526  				} catch (Exception ex) {
527  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;subgroups&#x27; for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
528  				}
529  				if (nodeData == null) {
530  				} else if (nodeData instanceof List) {
531  					for (Object o : ((List) nodeData)) {
532  						if (o == null) {
533  							GroupManager.logger.warning(&quot;Invalid Subgroup data for user: &quot; + thisUser.getLastName() + &quot;. Ignoring entry in file: &quot; + usersFile.getPath());
534  						} else {
535  							Group subGrp = ph.getGroup(o.toString());
536  							if (subGrp != null) {
537  								thisUser.addSubGroup(subGrp);
538  							} else {
539  								GroupManager.logger.warning(&quot;Subgroup &#x27;&quot; + o.toString() + &quot;&#x27; not found for user: &quot; + thisUser.getLastName() + &quot;. Ignoring entry in file: &quot; + usersFile.getPath());
540  							}
541  						}
542  					}
543  				} else if (nodeData instanceof String) {
544  					Group subGrp = ph.getGroup(nodeData.toString());
545  					if (subGrp != null) {
546  						thisUser.addSubGroup(subGrp);
547  					} else {
548  						GroupManager.logger.warning(&quot;Subgroup &#x27;&quot; + nodeData.toString() + &quot;&#x27; not found for user: &quot; + thisUser.getLastName() + &quot;. Ignoring entry in file: &quot; + usersFile.getPath());
549  					}
550  				}
551  				nodeData = null;
552  				try {
553  					nodeData = thisUserNode.get(&quot;info&quot;);
554  				} catch (Exception ex) {
555  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;info&#x27; section for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
556  				}
557  				if (nodeData == null) {
558  				} else if (nodeData instanceof Map) {
559  					thisUser.setVariables((Map&lt;String, Object&gt;) nodeData);
560  				} else
561  					throw new IllegalArgumentException(&quot;Unknown entry found in &#x27;info&#x27; section for user: &quot; + thisUser.getLastName() + &quot; in file: &quot; + usersFile.getPath());
562  				nodeData = null;
563  				try {
564  					nodeData = thisUserNode.get(&quot;group&quot;);
565  				} catch (Exception ex) {
566  					throw new IllegalArgumentException(&quot;Bad format found in &#x27;group&#x27; section for user: &quot; + usersKey + &quot; in file: &quot; + usersFile.getPath());
567  				}
568  				if (nodeData != null) {
569  					Group hisGroup = ph.getGroup(nodeData.toString());
570  					if (hisGroup == null) {
571  						GroupManager.logger.warning(&quot;There is no group &quot; + thisUserNode.get(&quot;group&quot;).toString() + &quot;, as stated for player &quot; + thisUser.getLastName() + &quot;: Set to &#x27;&quot; + ph.getDefaultGroup().getName() + &quot;&#x27; for file: &quot; + usersFile.getPath());
572  						hisGroup = ph.getDefaultGroup();
573  					}
574  					thisUser.setGroup(hisGroup);
575  				} else {
576  					thisUser.setGroup(ph.getDefaultGroup());
577  				}
578  			}
579  		}
580  		ph.removeUsersChangedFlag();
581  		ph.setUsersFile(usersFile);
582  		ph.setTimeStampUsers(usersFile.lastModified());
583  	}
584  	public static void writeGroups(WorldDataHolder ph, File groupsFile) {
585  		Map&lt;String, Object&gt; root = new HashMap&lt;String, Object&gt;();
586  		Map&lt;String, Object&gt; groupsMap = new HashMap&lt;String, Object&gt;();
587  		root.put(&quot;groups&quot;, groupsMap);
588  		synchronized (ph.getGroups()) {
589  			for (String groupKey : ph.getGroups().keySet()) {
590  				Group group = ph.getGroups().get(groupKey);
591  				Map&lt;String, Object&gt; aGroupMap = new HashMap&lt;String, Object&gt;();
592  				groupsMap.put(group.getName(), aGroupMap);
593  				if (ph.getDefaultGroup() == null) {
594  					GroupManager.logger.severe(&quot;There is no default group for world: &quot; + ph.getName());
595  				}
596  				aGroupMap.put(&quot;default&quot;, group.equals(ph.getDefaultGroup()));
597  				Map&lt;String, Object&gt; infoMap = new HashMap&lt;String, Object&gt;();
598  				aGroupMap.put(&quot;info&quot;, infoMap);
599  				for (String infoKey : group.getVariables().getVarKeyList()) {
600  					infoMap.put(infoKey, group.getVariables().getVarObject(infoKey));
601  				}
602  				aGroupMap.put(&quot;inheritance&quot;, group.getInherits());
603  				aGroupMap.put(&quot;permissions&quot;, group.getPermissionList());
604  			}
605  		}
606  		if (!root.isEmpty()) {
607  			DumperOptions opt = new DumperOptions();
608  			opt.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
609  			final Yaml yaml = new Yaml(opt);
610  			try {
611  				OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(groupsFile), &quot;UTF-8&quot;);
612  				String newLine = System.getProperty(&quot;line.separator&quot;);
613  				out.write(&quot;# Group inheritance&quot; + newLine);
614  				out.write(&quot;#&quot; + newLine);
615  				out.write(&quot;# Any inherited groups prefixed with a g: are global groups&quot; + newLine);
616  				out.write(&quot;# and are inherited from the GlobalGroups.yml.&quot; + newLine);
617  				out.write(&quot;#&quot; + newLine);
618  				out.write(&quot;# Groups without the g: prefix are groups local to this world&quot; + newLine);
619  				out.write(&quot;# and are defined in the this groups.yml file.&quot; + newLine);
620  				out.write(&quot;#&quot; + newLine);
621  				out.write(&quot;# Local group inheritances define your promotion tree when using &#x27;manpromote/mandemote&#x27;&quot; + newLine);
622  				out.write(newLine);
623  				yaml.dump(root, out);
624  				out.close();
625  			} catch (UnsupportedEncodingException ex) {
626  			} catch (FileNotFoundException ex) {
627  			} catch (IOException e) {
628  			}
629  		}
630  		ph.setGroupsFile(groupsFile);
631  		ph.setTimeStampGroups(groupsFile.lastModified());
632  		ph.removeGroupsChangedFlag();
633  		if (GroupManager.isLoaded())
634  			GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.SAVED);
635  	}
636  	public static void writeUsers(WorldDataHolder ph, File usersFile) {
637  		Map&lt;String, Object&gt; root = new HashMap&lt;String, Object&gt;();
638  		LinkedHashMap&lt;String, Object&gt; usersMap = new LinkedHashMap&lt;String, Object&gt;();
639  		root.put(&quot;users&quot;, usersMap);
640  		synchronized (ph.getUsers()) {
641  			for (String userKey : new TreeSet&lt;String&gt;(ph.getUsers().keySet())) {
642  				User user = ph.getUsers().get(userKey);
643  				if ((user.getGroup() == null || user.getGroup().equals(ph.getDefaultGroup())) &amp;&amp; user.getPermissionList().isEmpty() &amp;&amp; user.getVariables().isEmpty() &amp;&amp; user.isSubGroupsEmpty()) {
644  					continue;
645  				}
646  				LinkedHashMap&lt;String, Object&gt; aUserMap = new LinkedHashMap&lt;String, Object&gt;();
647  				usersMap.put(user.getUUID(), aUserMap);
648  				if (!user.getUUID().equalsIgnoreCase(user.getLastName())) {
649  					aUserMap.put(&quot;lastname&quot;, user.getLastName());
650  				}
651  				if (user.getGroup() == null) {
652  					aUserMap.put(&quot;group&quot;, ph.getDefaultGroup().getName());
653  				} else {
654  					aUserMap.put(&quot;group&quot;, user.getGroup().getName());
655  				}
656  				aUserMap.put(&quot;subgroups&quot;, user.subGroupListStringCopy());
657  				aUserMap.put(&quot;permissions&quot;, user.getPermissionList());
658  				if (user.getVariables().getSize() &gt; 0) {
659  					Map&lt;String, Object&gt; infoMap = new HashMap&lt;String, Object&gt;();
660  					aUserMap.put(&quot;info&quot;, infoMap);
661  					for (String infoKey : user.getVariables().getVarKeyList()) {
662  						infoMap.put(infoKey, user.getVariables().getVarObject(infoKey));
663  					}
664  				}
665  			}
666  		}
667  		if (!root.isEmpty()) {
668  			DumperOptions opt = new DumperOptions();
669  			opt.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
670  			final Yaml yaml = new Yaml(opt);
671  			try {
672  				OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(usersFile), &quot;UTF-8&quot;);
673  				yaml.dump(root, out);
674  				out.close();
675  			} catch (UnsupportedEncodingException ex) {
676  			} catch (FileNotFoundException ex) {
677  			} catch (IOException e) {
678  			}
679  		}
680  		ph.setUsersFile(usersFile);
681  		ph.setTimeStampUsers(usersFile.lastModified());
682  		ph.removeUsersChangedFlag();
683  		if (GroupManager.isLoaded())
684  			GroupManager.getGMEventHandler().callEvent(GMSystemEvent.Action.SAVED);
685  	}
686  	@Deprecated
687  	public static void reloadOldPlugins(Server server) {
688  		PluginManager pm = server.getPluginManager();
689  		Plugin[] plugins = pm.getPlugins();
690  		for (int i = 0; i &lt; plugins.length; i++) {
691  			try {
692  				plugins[i].getClass().getMethod(&quot;setupPermissions&quot;).invoke(plugins[i]);
693  			} catch (Exception ex) {
694  				continue;
695  			}
696  		}
697  	}
698  	public AnjoPermissionsHandler getPermissionsHandler() {
699  		if (permissionsHandler == null) {
700  			permissionsHandler = new AnjoPermissionsHandler(this);
701  		}
702  		return permissionsHandler;
703  	}
704  	public void setUsersChanged(boolean haveUsersChanged) {
705  		users.setUsersChanged(haveUsersChanged);
706  	}
707  	public boolean haveUsersChanged() {
708  		if (users.HaveUsersChanged()) {
709  			return true;
710  		}
711  		synchronized (users.getUsers()) {
712  			for (User u : users.getUsers().values()) {
713  				if (u.isChanged()) {
714  					return true;
715  				}
716  			}
717  		}
718  		return false;
719  	}
720  	public void setGroupsChanged(boolean setGroupsChanged) {
721  		groups.setGroupsChanged(setGroupsChanged);
722  	}
723  	public boolean haveGroupsChanged() {
724  		if (groups.HaveGroupsChanged()) {
725  			return true;
726  		}
727  		synchronized (groups.getGroups()) {
728  			for (Group g : groups.getGroups().values()) {
729  				if (g.isChanged()) {
730  					return true;
731  				}
732  			}
733  		}
734  		return false;
735  	}
736  	public void removeUsersChangedFlag() {
737  		setUsersChanged(false);
738  		synchronized (getUsers()) {
739  			for (User u : getUsers().values()) {
740  				u.flagAsSaved();
741  			}
742  		}
743  	}
744  	public void removeGroupsChangedFlag() {
745  		setGroupsChanged(false);
746  		synchronized (getGroups()) {
747  			for (Group g : getGroups().values()) {
748  				g.flagAsSaved();
749  			}
750  		}
751  	}
752  	public File getUsersFile() {
753  		return users.getUsersFile();
754  	}
755  	public void setUsersFile(File file) {
756  		users.setUsersFile(file);
757  	}
758  	public File getGroupsFile() {
759  		return groups.getGroupsFile();
760  	}
761  	public void setGroupsFile(File file) {
762  		groups.setGroupsFile(file);
763  	}
764  	public String getName() {
765  		return name;
766  	}
767  	public void resetGroups() {
768  		groups.resetGroups();
769  	}
770  	public void resetUsers() {
771  		users.resetUsers();
772  	}
773  	public Map&lt;String, Group&gt; getGroups() {
774  		return groups.getGroups();
775  	}
776  	public Map&lt;String, User&gt; getUsers() {
777  		return users.getUsers();
778  	}
779  	public GroupsDataHolder getGroupsObject() {
780  		return groups;
781  	}
782  	public void setGroupsObject(GroupsDataHolder groupsDataHolder) {
783  		groups = groupsDataHolder;
784  	}
785  	public UsersDataHolder getUsersObject() {
786  		return users;
787  	}
788  	public void setUsersObject(UsersDataHolder usersDataHolder) {
789  		users = usersDataHolder;
790  	}
791  	public long getTimeStampGroups() {
792  		return groups.getTimeStampGroups();
793  	}
794  	public long getTimeStampUsers() {
795  		return users.getTimeStampUsers();
796  	}
797  	protected void setTimeStampGroups(long timeStampGroups) {
798  		groups.setTimeStampGroups(timeStampGroups);
799  	}
800  	protected void setTimeStampUsers(long timeStampUsers) {
801  		users.setTimeStampUsers(timeStampUsers);
802  	}
803  	public void setTimeStamps() {
804  		if (getGroupsFile() != null)
805  			setTimeStampGroups(getGroupsFile().lastModified());
806  		if (getUsersFile() != null)
807  			setTimeStampUsers(getUsersFile().lastModified());
808  	}
809  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldDataHolder.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-WorldDataHolder.java</div>
                </div>
                <div class="column column_space"><pre><code>208  	public void reloadGroups() {
209  		GroupManager.setLoaded(false);
210  		try {
211  			WorldDataHolder ph = new WorldDataHolder(this.getName());
212  			loadGroups(ph, getGroupsFile());
</pre></code></div>
                <div class="column column_space"><pre><code>227  	public void reloadUsers() {
228  		GroupManager.setLoaded(false);
229  		try {
230  			WorldDataHolder ph = new WorldDataHolder(this.getName());
231  			for (Group tempGroup : this.getGroupList()) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    