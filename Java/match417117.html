<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for SafeTreeSet.java &amp; CompactHashMap.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for SafeTreeSet.java &amp; CompactHashMap.java
      </h3>
<h1 align="center">
        13.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>SafeTreeSet.java (31.955923%)<th>CompactHashMap.java (8.902533%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(149-165)<td><a href="#" name="0">(1042-1064)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(170-179)<td><a href="#" name="1">(887-896)</a><td align="center"><font color="#840000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(120-129)<td><a href="#" name="2">(750-759)</a><td align="center"><font color="#840000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(110-119)<td><a href="#" name="3">(701-710)</a><td align="center"><font color="#840000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(131-138)<td><a href="#" name="4">(1065-1072)</a><td align="center"><font color="#700000">11</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(85-93)<td><a href="#" name="5">(924-932)</a><td align="center"><font color="#700000">11</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(244-250)<td><a href="#" name="6">(743-749)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(193-200)<td><a href="#" name="7">(686-692)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(19-34)<td><a href="#" name="8">(43-78)</a><td align="center"><font color="#660000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SafeTreeSet.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="8"></a>
2 package com.google.common.collect.testing;
3 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import com.google.common.annotations.GwtIncompatible;
4 import java.io.Serializable;
5 import java.util.Collection;
6 import java.util.Comparator;
7 import java.util.Iterator;
8 import java.util.NavigableSet;
9 import java.util.SortedSet;
10 import java.util.TreeSet;
11 @</b></font>GwtIncompatible
12 public final class SafeTreeSet&lt;E&gt; implements Serializable, NavigableSet&lt;E&gt; {
13   @SuppressWarnings("unchecked")
14   private static final Comparator&lt;Object&gt; NATURAL_ORDER =
15       new Comparator&lt;Object&gt;() {
16         @Override
17         public int compare(Object o1, Object o2) {
18           return ((Comparable&lt;Object&gt;) o1).compareTo(o2);
19         }
20       };
21   private final NavigableSet&lt;E&gt; delegate;
22   public SafeTreeSet() {
23     this(new TreeSet&lt;E&gt;());
24   }
25   public SafeTreeSet(Collection&lt;? extends E&gt; collection) {
26     this(new TreeSet&lt;E&gt;(collection));
27   }
28   public SafeTreeSet(Comparator&lt;? super E&gt; comparator) {
29     this(new TreeSet&lt;E&gt;(comparator));
30   }
31   public SafeTreeSet(SortedSet&lt;E&gt; set) {
32     this(new TreeSet&lt;E&gt;(set));
33   }
34   private SafeTreeSet(NavigableSet&lt;E&gt; delegate) {
35     this.delegate = delegate;
36     for (E e : this) {
37       checkValid(e);
38     }
39   }
40   @Override
41   public boolean add(E element) {
42     return delegate.add(checkValid(element));
43   }
44   @Override
45   public boolean addAll(Collection&lt;? extends E&gt; collection) {
46     for (E e : collection) {
47       checkValid(e);
48     }
49     return delegate.addAll(collection);
50   }
51 <a name="5"></a>
52   @Override
53   public E ceiling(E e) {
54     return delegate.ceiling(<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>checkValid(e));
55   }
56   @Override
57   public void clear() {
58     delegate.clear();
59   }
60   @</b></font>SuppressWarnings("unchecked")
61   @Override
62   public Comparator&lt;? super E&gt; comparator() {
63     Comparator&lt;? super E&gt; comparator = delegate.comparator();
64     if (comparator == null) {
65       comparator = (Comparator&lt;? super E&gt;) NATURAL_ORDER;
66     }
67     return comparator;
68   }
69   @Override
70   public boolean contains(Object object) {
71     return delegate.contains(checkValid(object));
72   }
73 <a name="3"></a>
74   @Override
75   public boolean containsAll(Collection&lt;?&gt; c) {
76     return <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.containsAll(c);
77   }
78   @Override
79   public Iterator&lt;E&gt; descendingIterator() {
80     return delegate.descendingIterator();
81   }
82 <a name="2"></a>
83   @Override
84   public NavigableSet&lt;E&gt; descendingSet() {</b></font>
85     return new SafeTreeSet&lt;&gt;(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.descendingSet());
86   }
87   @Override
88   public E first() {
89     return delegate.first();
90   }
91 <a name="4"></a>  @Override
92   public E floor(E e</b></font>) {
93     return delegate.floor(checkValid(e));
94   <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
95   @Override
96   public SortedSet&lt;E&gt; headSet(E toElement) {
97     return headSet(toElement, false);
98   }
99   @Overri</b></font>de
100   public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
101     return new SafeTreeSet&lt;&gt;(delegate.headSet(checkValid(toElement), inclusive));
102   }
103   @Override
104   public E higher(E e) {
105     return delegate.higher(checkValid(e));
106 <a name="0"></a>  }
107   @Override
108   public boolean isEmpty() <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
109     return delegate.isEmpty();
110   }
111   @Override
112   public Iterator&lt;E&gt; iterator() {
113     return delegate.iterator();
114   }
115   @Override
116   public E last() {
117     return delegate.last();
118   }
119   @Override
120   public E lower(E e) {
121     return delegate.lower</b></font>(checkValid(e));
122   }
123 <a name="1"></a>
124   @Override
125   public E pollFirst() {
126     return <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>delegate.pollFirst();
127   }
128   @Override
129   public E pollLast() {
130     return delegate.pollLast();
131   }
132   @Override
133   public boolean remove(Object object</b></font>) {
134     return delegate.remove(checkValid(object));
135   }
136   @Override
137   public boolean removeAll(Collection&lt;?&gt; c) {
138     return delegate.removeAll(c);
139   }
140   @Override
141   public boolean retainAll(Collection&lt;?&gt; c) {
142 <a name="7"></a>    return delegate.retainAll(c);
143   }
144   <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
145   public int size() {
146     return delegate.size();
147   }
148   @Override
149   public NavigableSet&lt;E&gt; subSet(
150       E fromElement</b></font>, boolean fromInclusive, E toElement, boolean toInclusive) {
151     return new SafeTreeSet&lt;&gt;(
152         delegate.subSet(
153             checkValid(fromElement), fromInclusive, checkValid(toElement), toInclusive));
154   }
155   @Override
156   public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
157     return subSet(fromElement, true, toElement, false);
158   }
159   @Override
160   public SortedSet&lt;E&gt; tailSet(E fromElement) {
161     return tailSet(fromElement, true);
162   }
163   @Override
164   public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
165     return new SafeTreeSet&lt;&gt;(delegate.tailSet(checkValid(fromElement), inclusive));
166   }
167   @Override
168   public Object[] toArray() {
169     return delegate.toArray();
170   }
171   @Override
172   public &lt;T&gt; T[] toArray(T[] a) {
173     return delegate.toArray(a);
174   }
175   private &lt;T&gt; T checkValid(T t) {
176     @SuppressWarnings("unchecked")
177     E e = (E) t;
178     comparator().compare(e, e);
179     return t;
180   }
181   @Override
182   public boolean equals(Object obj) {
183 <a name="6"></a>    return delegate.equals(obj);
184   }
185   <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Override
186   public int hashCode() {
187     return delegate.hashCode();
188   }
189   @Override
190   public String toString() {</b></font>
191     return delegate.toString();
192   }
193   private static final long serialVersionUID = 0L;
194 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CompactHashMap.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.collect.CollectPreconditions.checkRemove;
3 import static com.google.common.collect.CompactHashing.UNSET;
4 import static com.google.common.collect.Hashing.smearedHash;
5 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
6 import static com.google.common.collect.NullnessCasts.unsafeNull;
7 import static java.util.Objects.requireNonNull;
8 import com.google.common.annotations.GwtIncompatible;
9 import com.google.common.annotations.VisibleForTesting;
10 import com.google.common.base.Objects;
11 import com.google.common.base.Preconditions;
12 import com.google.common.primitives.Ints;
13 import com.google.errorprone.annotations.CanIgnoreReturnValue;
14 import com.google.j2objc.annotations.WeakOuter;
15 import java.io.IOException;
16 import java.io.InvalidObjectException;
17 import java.io.ObjectInputStream;
18 import java.io.ObjectOutputStream;
19 import java.io.Serializable;
20 import java.util.AbstractCollection;
21 import java.util.AbstractMap;
22 <a name="8"></a>import java.util.AbstractSet;
23 import java.util.Arrays;
24 import java.util.Collection;
25 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import java.util.ConcurrentModificationException;
26 import java.util.Iterator;
27 import java.util.LinkedHashMap;
28 import java.util.Map;
29 import java.util.NoSuchElementException;
30 import java.util.Set;
31 import javax.annotation.CheckForNull;
32 import org.checkerframework.checker.nullness.qual.Nullable;
33 @</b></font>GwtIncompatible @ElementTypesAreNonnullByDefault
34 class CompactHashMap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
35     extends AbstractMap&lt;K, V&gt; implements Serializable {
36   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
37       CompactHashMap&lt;K, V&gt; create() {
38     return new CompactHashMap&lt;&gt;();
39   }
40   public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
41       CompactHashMap&lt;K, V&gt; createWithExpectedSize(int expectedSize) {
42     return new CompactHashMap&lt;&gt;(expectedSize);
43   }
44   private static final Object NOT_FOUND = new Object();
45   @VisibleForTesting(
46       )
47   static final double HASH_FLOODING_FPP = 0.001;
48   private static final int MAX_HASH_BUCKET_LENGTH = 9;
49   //
50   //
51   //
52   //
53   //
54   //
55   //
56   @CheckForNull private transient Object table;
57   @VisibleForTesting @CheckForNull transient int[] entries;
58   @VisibleForTesting @CheckForNull transient @Nullable Object[] keys;
59   @VisibleForTesting @CheckForNull transient @Nullable Object[] values;
60   private transient int metadata;
61   private transient int size;
62   CompactHashMap() {
63     init(CompactHashing.DEFAULT_SIZE);
64   }
65   CompactHashMap(int expectedSize) {
66     init(expectedSize);
67   }
68   void init(int expectedSize) {
69     Preconditions.checkArgument(expectedSize &gt;= 0, "Expected size must be &gt;= 0");
70     this.metadata = Ints.constrainToRange(expectedSize, 1, CompactHashing.MAX_SIZE);
71   }
72   @VisibleForTesting
73   boolean needsAllocArrays() {
74     return table == null;
75   }
76   @CanIgnoreReturnValue
77   int allocArrays() {
78     Preconditions.checkState(needsAllocArrays(), "Arrays already allocated");
79     int expectedSize = metadata;
80     int buckets = CompactHashing.tableSize(expectedSize);
81     this.table = CompactHashing.createTable(buckets);
82     setHashTableMask(buckets - 1);
83     this.entries = new int[expectedSize];
84     this.keys = new Object[expectedSize];
85     this.values = new Object[expectedSize];
86     return expectedSize;
87   }
88   @SuppressWarnings("unchecked")
89   @VisibleForTesting
90   @CheckForNull
91   Map&lt;K, V&gt; delegateOrNull() {
92     if (table instanceof Map) {
93       return (Map&lt;K, V&gt;) table;
94     }
95     return null;
96   }
97   Map&lt;K, V&gt; createHashFloodingResistantDelegate(int tableSize) {
98     return new LinkedHashMap&lt;&gt;(tableSize, 1.0f);
99   }
100   @VisibleForTesting
101   @CanIgnoreReturnValue
102   Map&lt;K, V&gt; convertToHashFloodingResistantImplementation() {
103     Map&lt;K, V&gt; newDelegate = createHashFloodingResistantDelegate(hashTableMask() + 1);
104     for (int i = firstEntryIndex(); i &gt;= 0; i = getSuccessor(i)) {
105       newDelegate.put(key(i), value(i));
106     }
107     this.table = newDelegate;
108     this.entries = null;
109     this.keys = null;
110     this.values = null;
111     incrementModCount();
112     return newDelegate;
113   }
114   private void setHashTableMask(int mask) {
115     int hashTableBits = Integer.SIZE - Integer.numberOfLeadingZeros(mask);
116     metadata =
117         CompactHashing.maskCombine(metadata, hashTableBits, CompactHashing.HASH_TABLE_BITS_MASK);
118   }
119   private int hashTableMask() {
120     return (1 &lt;&lt; (metadata &amp; CompactHashing.HASH_TABLE_BITS_MASK)) - 1;
121   }
122   void incrementModCount() {
123     metadata += CompactHashing.MODIFICATION_COUNT_INCREMENT;
124   }
125   void accessEntry(int index) {
126   }
127   @CanIgnoreReturnValue
128   @Override
129   @CheckForNull
130   public V put(@ParametricNullness K key, @ParametricNullness V value) {
131     if (needsAllocArrays()) {
132       allocArrays();
133     }
134     Map&lt;K, V&gt; delegate = delegateOrNull();
135     if (delegate != null) {
136       return delegate.put(key, value);
137     }
138     int[] entries = requireEntries();
139     @Nullable Object[] keys = requireKeys();
140     @Nullable Object[] values = requireValues();
141     int newEntryIndex = this.size;     int newSize = newEntryIndex + 1;
142     int hash = smearedHash(key);
143     int mask = hashTableMask();
144     int tableIndex = hash &amp; mask;
145     int next = CompactHashing.tableGet(requireTable(), tableIndex);
146     if (next == UNSET) {       if (newSize &gt; mask) {
147         mask = resizeTable(mask, CompactHashing.newCapacity(mask), hash, newEntryIndex);
148       } else {
149         CompactHashing.tableSet(requireTable(), tableIndex, newEntryIndex + 1);
150       }
151     } else {
152       int entryIndex;
153       int entry;
154       int hashPrefix = CompactHashing.getHashPrefix(hash, mask);
155       int bucketLength = 0;
156       do {
157         entryIndex = next - 1;
158         entry = entries[entryIndex];
159         if (CompactHashing.getHashPrefix(entry, mask) == hashPrefix
160             &amp;&amp; Objects.equal(key, keys[entryIndex])) {
161           @SuppressWarnings("unchecked")           V oldValue = (V) values[entryIndex];
162           values[entryIndex] = value;
163           accessEntry(entryIndex);
164           return oldValue;
165         }
166         next = CompactHashing.getNext(entry, mask);
167         bucketLength++;
168       } while (next != UNSET);
169       if (bucketLength &gt;= MAX_HASH_BUCKET_LENGTH) {
170         return convertToHashFloodingResistantImplementation().put(key, value);
171       }
172       if (newSize &gt; mask) {
173         mask = resizeTable(mask, CompactHashing.newCapacity(mask), hash, newEntryIndex);
174       } else {
175         entries[entryIndex] = CompactHashing.maskCombine(entry, newEntryIndex + 1, mask);
176       }
177     }
178     resizeMeMaybe(newSize);
179     insertEntry(newEntryIndex, key, value, hash, mask);
180     this.size = newSize;
181     incrementModCount();
182     return null;
183   }
184   void insertEntry(
185       int entryIndex, @ParametricNullness K key, @ParametricNullness V value, int hash, int mask) {
186     this.setEntry(entryIndex, CompactHashing.maskCombine(hash, UNSET, mask));
187     this.setKey(entryIndex, key);
188     this.setValue(entryIndex, value);
189   }
190   private void resizeMeMaybe(int newSize) {
191     int entriesSize = requireEntries().length;
192     if (newSize &gt; entriesSize) {
193       int newCapacity =
194           Math.min(CompactHashing.MAX_SIZE, (entriesSize + Math.max(1, entriesSize &gt;&gt;&gt; 1)) | 1);
195       if (newCapacity != entriesSize) {
196         resizeEntries(newCapacity);
197       }
198     }
199   }
200   void resizeEntries(int newCapacity) {
201     this.entries = Arrays.copyOf(requireEntries(), newCapacity);
202     this.keys = Arrays.copyOf(requireKeys(), newCapacity);
203     this.values = Arrays.copyOf(requireValues(), newCapacity);
204   }
205   @CanIgnoreReturnValue
206   private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {
207     Object newTable = CompactHashing.createTable(newCapacity);
208     int newMask = newCapacity - 1;
209     if (targetEntryIndex != UNSET) {
210       CompactHashing.tableSet(newTable, targetHash &amp; newMask, targetEntryIndex + 1);
211     }
212     Object oldTable = requireTable();
213     int[] entries = requireEntries();
214     for (int oldTableIndex = 0; oldTableIndex &lt;= oldMask; oldTableIndex++) {
215       int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);
216       while (oldNext != UNSET) {
217         int entryIndex = oldNext - 1;
218         int oldEntry = entries[entryIndex];
219         int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;
220         int newTableIndex = hash &amp; newMask;
221         int newNext = CompactHashing.tableGet(newTable, newTableIndex);
222         CompactHashing.tableSet(newTable, newTableIndex, oldNext);
223         entries[entryIndex] = CompactHashing.maskCombine(hash, newNext, newMask);
224         oldNext = CompactHashing.getNext(oldEntry, oldMask);
225       }
226     }
227     this.table = newTable;
228     setHashTableMask(newMask);
229     return newMask;
230   }
231   private int indexOf(@CheckForNull Object key) {
232     if (needsAllocArrays()) {
233       return -1;
234     }
235     int hash = smearedHash(key);
236     int mask = hashTableMask();
237     int next = CompactHashing.tableGet(requireTable(), hash &amp; mask);
238     if (next == UNSET) {
239       return -1;
240     }
241     int hashPrefix = CompactHashing.getHashPrefix(hash, mask);
242     do {
243       int entryIndex = next - 1;
244       int entry = entry(entryIndex);
245       if (CompactHashing.getHashPrefix(entry, mask) == hashPrefix
246           &amp;&amp; Objects.equal(key, key(entryIndex))) {
247         return entryIndex;
248       }
249       next = CompactHashing.getNext(entry, mask);
250     } while (next != UNSET);
251     return -1;
252   }
253   @Override
254   public boolean containsKey(@CheckForNull Object key) {
255     Map&lt;K, V&gt; delegate = delegateOrNull();
256     return (delegate != null) ? delegate.containsKey(key) : indexOf(key) != -1;
257   }
258   @Override
259   @CheckForNull
260   public V get(@CheckForNull Object key) {
261     Map&lt;K, V&gt; delegate = delegateOrNull();
262     if (delegate != null) {
263       return delegate.get(key);
264     }
265     int index = indexOf(key);
266     if (index == -1) {
267       return null;
268     }
269     accessEntry(index);
270     return value(index);
271   }
272   @CanIgnoreReturnValue
273   @SuppressWarnings("unchecked")   @Override
274   @CheckForNull
275   public V remove(@CheckForNull Object key) {
276     Map&lt;K, V&gt; delegate = delegateOrNull();
277     if (delegate != null) {
278       return delegate.remove(key);
279     }
280     Object oldValue = removeHelper(key);
281     return (oldValue == NOT_FOUND) ? null : (V) oldValue;
282   }
283   private @Nullable Object removeHelper(@CheckForNull Object key) {
284     if (needsAllocArrays()) {
285       return NOT_FOUND;
286     }
287     int mask = hashTableMask();
288     int index =
289         CompactHashing.remove(
290             key,
291             mask,
292             requireTable(),
293             requireEntries(),
294             requireKeys(),
295     if (index == -1) {
296       return NOT_FOUND;
297     }
298     Object oldValue = value(index);
299     moveLastEntry(index, mask);
300     size--;
301     incrementModCount();
302     return oldValue;
303   }
304   void moveLastEntry(int dstIndex, int mask) {
305     Object table = requireTable();
306     int[] entries = requireEntries();
307     @Nullable Object[] keys = requireKeys();
308     @Nullable Object[] values = requireValues();
309     int srcIndex = size() - 1;
310     if (dstIndex &lt; srcIndex) {
311       Object key = keys[srcIndex];
312       keys[dstIndex] = key;
313       values[dstIndex] = values[srcIndex];
314       keys[srcIndex] = null;
315       values[srcIndex] = null;
316       entries[dstIndex] = entries[srcIndex];
317       entries[srcIndex] = 0;
318       int tableIndex = smearedHash(key) &amp; mask;
319       int next = CompactHashing.tableGet(table, tableIndex);
320       int srcNext = srcIndex + 1;
321       if (next == srcNext) {
322         CompactHashing.tableSet(table, tableIndex, dstIndex + 1);
323       } else {
324         int entryIndex;
325         int entry;
326         do {
327           entryIndex = next - 1;
328           entry = entries[entryIndex];
329           next = CompactHashing.getNext(entry, mask);
330         } while (next != srcNext);
331         entries[entryIndex] = CompactHashing.maskCombine(entry, dstIndex + 1, mask);
332       }
333     } else {
334       keys[dstIndex] = null;
335       values[dstIndex] = null;
336       entries[dstIndex] = 0;
337     }
338   }
339   int firstEntryIndex() {
340     return isEmpty() ? -1 : 0;
341   }
342   int getSuccessor(int entryIndex) {
343     return (entryIndex + 1 &lt; size) ? entryIndex + 1 : -1;
344   }
345   int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings("unused") int indexRemoved) {
346     return indexBeforeRemove - 1;
347   }
348   private abstract class Itr&lt;T extends @Nullable Object&gt; implements Iterator&lt;T&gt; {
349     int expectedMetadata = metadata;
350     int currentIndex = firstEntryIndex();
351     int indexToRemove = -1;
352     @Override
353     public boolean hasNext() {
354       return currentIndex &gt;= 0;
355     }
356     @ParametricNullness
357     abstract T getOutput(int entry);
358     @Override
359     @ParametricNullness
360     public T next() {
361       checkForConcurrentModification();
362       if (!hasNext()) {
363         throw new NoSuchElementException();
364       }
365       indexToRemove = currentIndex;
366       T result = getOutput(currentIndex);
367       currentIndex = getSuccessor(currentIndex);
368       return result;
369     }
370     @Override
371     public void remove() {
372       checkForConcurrentModification();
373       checkRemove(indexToRemove &gt;= 0);
374       incrementExpectedModCount();
375       CompactHashMap.this.remove(key(indexToRemove));
376       currentIndex = adjustAfterRemove(currentIndex, indexToRemove);
377       indexToRemove = -1;
378     }
379     void incrementExpectedModCount() {
380       expectedMetadata += CompactHashing.MODIFICATION_COUNT_INCREMENT;
381     }
382     private void checkForConcurrentModification() {
383       if (metadata != expectedMetadata) {
384         throw new ConcurrentModificationException();
385       }
386     }
387   }
388   @CheckForNull private transient Set&lt;K&gt; keySetView;
389   @Override
390   public Set&lt;K&gt; keySet() {
391     return (keySetView == null) ? keySetView = createKeySet() : keySetView;
392   }
393   Set&lt;K&gt; createKeySet() {
394     return new KeySetView();
395   }
396 <a name="7"></a>
397   @WeakOuter
398   class KeySetView extends AbstractSet&lt;K&gt; {
399     <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
400     public int size() {
401       return CompactHashMap.this.size();
402     }
403     @Override
404     public boolean contains(@CheckForNull Object o</b></font>) {
405       return CompactHashMap.this.containsKey(o);
406     }
407     @Override
408     public boolean remove(@CheckForNull Object o) {
409 <a name="3"></a>      Map&lt;K, V&gt; delegate = delegateOrNull();
410       return (delegate != null)
411           ? delegate.keySet().remove(o)
412           : <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CompactHashMap.this.removeHelper(o) != NOT_FOUND;
413     }
414     @Override
415     public Iterator&lt;K&gt; iterator() {
416       return keySetIterator();
417     }
418     @Override
419     public void clear() {</b></font>
420       CompactHashMap.this.clear();
421     }
422   }
423   Iterator&lt;K&gt; keySetIterator() {
424     Map&lt;K, V&gt; delegate = delegateOrNull();
425     if (delegate != null) {
426       return delegate.keySet().iterator();
427     }
428     return new Itr&lt;K&gt;() {
429       @Override
430       @ParametricNullness
431       K getOutput(int entry) {
432         return key(entry);
433       }
434     };
435   }
436   @CheckForNull private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySetView;
437   @Override
438   public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
439     return (entrySetView == null) ? entrySetView = createEntrySet() : entrySetView;
440   }
441   Set&lt;Entry&lt;K, V&gt;&gt; createEntrySet() {
442     return new EntrySetView();
443   }
444 <a name="6"></a>  @WeakOuter
445   class EntrySetView extends AbstractSet&lt;Entry&lt;K, V&gt;&gt; {
446     <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
447     public int size() {
448       return CompactHashMap.this.size();
449     }
450 <a name="2"></a>
451     @Override
452     public void clear() {</b></font>
453       <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CompactHashMap.this.clear();
454     }
455     @Override
456     public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
457       return entrySetIterator();
458     }
459     @Override
460     public boolean contains(@CheckForNull Object o</b></font>) {
461       Map&lt;K, V&gt; delegate = delegateOrNull();
462       if (delegate != null) {
463         return delegate.entrySet().contains(o);
464       } else if (o instanceof Entry) {
465         Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) o;
466         int index = indexOf(entry.getKey());
467         return index != -1 &amp;&amp; Objects.equal(value(index), entry.getValue());
468       }
469       return false;
470     }
471     @Override
472     public boolean remove(@CheckForNull Object o) {
473       Map&lt;K, V&gt; delegate = delegateOrNull();
474       if (delegate != null) {
475         return delegate.entrySet().remove(o);
476       } else if (o instanceof Entry) {
477         Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) o;
478         if (needsAllocArrays()) {
479           return false;
480         }
481         int mask = hashTableMask();
482         int index =
483             CompactHashing.remove(
484                 entry.getKey(),
485                 entry.getValue(),
486                 mask,
487                 requireTable(),
488                 requireEntries(),
489                 requireKeys(),
490                 requireValues());
491         if (index == -1) {
492           return false;
493         }
494         moveLastEntry(index, mask);
495         size--;
496         incrementModCount();
497         return true;
498       }
499       return false;
500     }
501   }
502   Iterator&lt;Entry&lt;K, V&gt;&gt; entrySetIterator() {
503     Map&lt;K, V&gt; delegate = delegateOrNull();
504     if (delegate != null) {
505       return delegate.entrySet().iterator();
506     }
507     return new Itr&lt;Entry&lt;K, V&gt;&gt;() {
508       @Override
509       Entry&lt;K, V&gt; getOutput(int entry) {
510         return new MapEntry(entry);
511       }
512     };
513   }
514   final class MapEntry extends AbstractMapEntry&lt;K, V&gt; {
515     @ParametricNullness private final K key;
516     private int lastKnownIndex;
517     MapEntry(int index) {
518       this.key = key(index);
519       this.lastKnownIndex = index;
520     }
521     @Override
522     @ParametricNullness
523     public K getKey() {
524       return key;
525     }
526     private void updateLastKnownIndex() {
527       if (lastKnownIndex == -1
528           || lastKnownIndex &gt;= size()
529           || !Objects.equal(key, key(lastKnownIndex))) {
530         lastKnownIndex = indexOf(key);
531       }
532     }
533     @Override
534     @ParametricNullness
535     public V getValue() {
536       Map&lt;K, V&gt; delegate = delegateOrNull();
537       if (delegate != null) {
538         return uncheckedCastNullableTToT(delegate.get(key));
539       }
540       updateLastKnownIndex();
541       return (lastKnownIndex == -1) ? unsafeNull() : value(lastKnownIndex);
542     }
543     @Override
544     @ParametricNullness
545     public V setValue(@ParametricNullness V value) {
546       Map&lt;K, V&gt; delegate = delegateOrNull();
547       if (delegate != null) {
548         return uncheckedCastNullableTToT(delegate.put(key, value));       }
549       updateLastKnownIndex();
550       if (lastKnownIndex == -1) {
551         put(key, value);
552         return unsafeNull();       } else {
553         V old = value(lastKnownIndex);
554         CompactHashMap.this.setValue(lastKnownIndex, value);
555         return old;
556       }
557     }
558   }
559 <a name="1"></a>  @Override
560   public int size() {
561     Map&lt;K, V&gt; delegate = delegateOrNull();
562     return (delegate != null) ? <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>delegate.size() : size;
563   }
564   @Override
565   public boolean isEmpty() {
566     return size() == 0;
567   }
568   @Override
569   public boolean containsValue(@CheckForNull Object value</b></font>) {
570     Map&lt;K, V&gt; delegate = delegateOrNull();
571     if (delegate != null) {
572       return delegate.containsValue(value);
573     }
574     for (int i = 0; i &lt; size; i++) {
575       if (Objects.equal(value, value(i))) {
576         return true;
577       }
578     }
579     return false;
580   }
581   @CheckForNull private transient Collection&lt;V&gt; valuesView;
582   @Override
583   public Collection&lt;V&gt; values() {
584     return (valuesView == null) ? valuesView = createValues() : valuesView;
585   }
586   Collection&lt;V&gt; createValues() {
587     return new ValuesView();
588   }
589   @WeakOuter
590 <a name="5"></a>  class ValuesView extends AbstractCollection&lt;V&gt; {
591     @Override
592     public int size() {
593       return <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>CompactHashMap.this.size();
594     }
595     @Override
596     public void clear() {
597       CompactHashMap.this.clear();
598     }
599     @</b></font>Override
600     public Iterator&lt;V&gt; iterator() {
601       return valuesIterator();
602     }
603   }
604   Iterator&lt;V&gt; valuesIterator() {
605     Map&lt;K, V&gt; delegate = delegateOrNull();
606     if (delegate != null) {
607       return delegate.values().iterator();
608     }
609     return new Itr&lt;V&gt;() {
610       @Override
611       @ParametricNullness
612       V getOutput(int entry) {
613         return value(entry);
614       }
615     };
616   }
617   public void trimToSize() {
618     if (needsAllocArrays()) {
619       return;
620     }
621     Map&lt;K, V&gt; delegate = delegateOrNull();
622     if (delegate != null) {
623       Map&lt;K, V&gt; newDelegate = createHashFloodingResistantDelegate(size());
624       newDelegate.putAll(delegate);
625       this.table = newDelegate;
626       return;
627     }
628     int size = this.size;
629     if (size &lt; requireEntries().length) {
630       resizeEntries(size);
631     }
632     int minimumTableSize = CompactHashing.tableSize(size);
633     int mask = hashTableMask();
634     if (minimumTableSize &lt; mask) {       resizeTable(mask, minimumTableSize, UNSET, UNSET);
635     }
636   }
637   @Override
638   public void clear() {
639     if (needsAllocArrays()) {
640       return;
641     }
642     incrementModCount();
643     Map&lt;K, V&gt; delegate = delegateOrNull();
644     if (delegate != null) {
645       metadata =
646           Ints.constrainToRange(size(), CompactHashing.DEFAULT_SIZE, CompactHashing.MAX_SIZE);
647       delegate.clear();       table = null;
648       size = 0;
649     } else {
650       Arrays.fill(requireKeys(), 0, size, null);
651       Arrays.fill(requireValues(), 0, size, null);
652       CompactHashing.tableClear(requireTable());
653       Arrays.fill(requireEntries(), 0, size, 0);
654       this.size = 0;
655     }
656   }
657   private void writeObject(ObjectOutputStream stream) throws IOException {
658     stream.defaultWriteObject();
659     stream.writeInt(size());
660     Iterator&lt;Entry&lt;K, V&gt;&gt; entryIterator = entrySetIterator();
661     while (entryIterator.hasNext()) {
662       Entry&lt;K, V&gt; e = entryIterator.next();
663       stream.writeObject(e.getKey());
664       stream.writeObject(e.getValue());
665     }
666   }
667   @SuppressWarnings("unchecked")
668   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
669     stream.defaultReadObject();
670     int elementCount = stream.readInt();
671     if (elementCount &lt; 0) {
672       throw new InvalidObjectException("Invalid size: " + elementCount);
673     }
674     init(elementCount);
675     for (int i = 0; i &lt; elementCount; i++) {
676       K key = (K) stream.readObject();
677       V value = (V) stream.readObject();
678       put(key, value);
679     }
680   }
681   /*
682    * The following methods are safe to call as long as both of the following hold:
683    *
684    * - allocArrays() has been called. Callers can confirm this by checking needsAllocArrays().
685    *
686    * - The map has not switched to delegating to a java.util implementation to mitigate hash
687    *   flooding. Callers can confirm this by null-checking delegateOrNull().
688    *
689    * In an ideal world, we would document why we know those things are true every time we call these
690    * methods. But that is a bit too painful....
691    */
692   private Object requireTable() {
693 <a name="0"></a>    return requireNonNull(table);
694   }
695   private int[] requireEntries() <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
696     return requireNonNull(entries);
697   }
698   private @Nullable Object[] requireKeys() {
699     return requireNonNull(keys);
700   }
701   private @Nullable Object[] requireValues() {
702     return requireNonNull(values);
703   }
704   /*
705    * The following methods are safe to call as long as the conditions in the *previous* comment are
706    * met *and* the index is less than size().
707    *
708    * (The above explains when these methods are safe from a `nullness` perspective. From an
709    * `unchecked` perspective, they're safe because we put only K/V elements into each array.)
710    */
711 <a name="4"></a>  @SuppressWarnings("unchecked")
712   private K key(int i) {
713     return (K) requireKeys</b></font>()[i];
714   <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
715   @SuppressWarnings("unchecked")
716   private V value(int i) {
717     return (V) requireValues()[i];
718   }
719   priva</b></font>te int entry(int i) {
720     return requireEntries()[i];
721   }
722   private void setKey(int i, K key) {
723     requireKeys()[i] = key;
724   }
725   private void setValue(int i, V value) {
726     requireValues()[i] = value;
727   }
728   private void setEntry(int i, int value) {
729     requireEntries()[i] = value;
730   }
731 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
