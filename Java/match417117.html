<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for SafeTreeSet.java & CompactHashMap.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for SafeTreeSet.java & CompactHashMap.java
      </h3>
      <h1 align="center">
        13.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>SafeTreeSet.java (31.955923%)<TH>CompactHashMap.java (8.902533%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#0',2,'match417117-1.html#0',3)" NAME="0">(149-165)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#0',2,'match417117-1.html#0',3)" NAME="0">(1042-1064)</A><TD ALIGN=center><FONT COLOR="#ff0000">25</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#1',2,'match417117-1.html#1',3)" NAME="1">(170-179)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#1',2,'match417117-1.html#1',3)" NAME="1">(887-896)</A><TD ALIGN=center><FONT COLOR="#840000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#2',2,'match417117-1.html#2',3)" NAME="2">(120-129)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#2',2,'match417117-1.html#2',3)" NAME="2">(750-759)</A><TD ALIGN=center><FONT COLOR="#840000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#3',2,'match417117-1.html#3',3)" NAME="3">(110-119)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#3',2,'match417117-1.html#3',3)" NAME="3">(701-710)</A><TD ALIGN=center><FONT COLOR="#840000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#4',2,'match417117-1.html#4',3)" NAME="4">(131-138)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#4',2,'match417117-1.html#4',3)" NAME="4">(1065-1072)</A><TD ALIGN=center><FONT COLOR="#700000">11</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#5',2,'match417117-1.html#5',3)" NAME="5">(85-93)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#5',2,'match417117-1.html#5',3)" NAME="5">(924-932)</A><TD ALIGN=center><FONT COLOR="#700000">11</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#6',2,'match417117-1.html#6',3)" NAME="6">(244-250)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#6',2,'match417117-1.html#6',3)" NAME="6">(743-749)</A><TD ALIGN=center><FONT COLOR="#660000">10</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#7',2,'match417117-1.html#7',3)" NAME="7">(193-200)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#7',2,'match417117-1.html#7',3)" NAME="7">(686-692)</A><TD ALIGN=center><FONT COLOR="#660000">10</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match417117-0.html#8',2,'match417117-1.html#8',3)" NAME="8">(19-34)<TD><A HREF="javascript:ZweiFrames('match417117-0.html#8',2,'match417117-1.html#8',3)" NAME="8">(43-78)</A><TD ALIGN=center><FONT COLOR="#660000">10</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SafeTreeSet.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2010 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<A NAME="8"></A>
package com.google.common.collect.testing;

<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match417117-1.html#8',3,'match417117-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import com.google.common.annotations.GwtIncompatible;
import java.io.Serializable;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NavigableSet;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * A wrapper around {@code TreeSet} that aggressively checks to see if elements are mutually
 * comparable. This implementation passes the navigable set test suites.
 *
 * @author Louis Wasserman
 */
@</B></FONT>GwtIncompatible
public final class SafeTreeSet&lt;E&gt; implements Serializable, NavigableSet&lt;E&gt; {
  @SuppressWarnings(&quot;unchecked&quot;)
  private static final Comparator&lt;Object&gt; NATURAL_ORDER =
      new Comparator&lt;Object&gt;() {
        @Override
        public int compare(Object o1, Object o2) {
          return ((Comparable&lt;Object&gt;) o1).compareTo(o2);
        }
      };

  private final NavigableSet&lt;E&gt; delegate;

  public SafeTreeSet() {
    this(new TreeSet&lt;E&gt;());
  }

  public SafeTreeSet(Collection&lt;? extends E&gt; collection) {
    this(new TreeSet&lt;E&gt;(collection));
  }

  public SafeTreeSet(Comparator&lt;? super E&gt; comparator) {
    this(new TreeSet&lt;E&gt;(comparator));
  }

  public SafeTreeSet(SortedSet&lt;E&gt; set) {
    this(new TreeSet&lt;E&gt;(set));
  }

  private SafeTreeSet(NavigableSet&lt;E&gt; delegate) {
    this.delegate = delegate;
    for (E e : this) {
      checkValid(e);
    }
  }

  @Override
  public boolean add(E element) {
    return delegate.add(checkValid(element));
  }

  @Override
  public boolean addAll(Collection&lt;? extends E&gt; collection) {
    for (E e : collection) {
      checkValid(e);
    }
    return delegate.addAll(collection);
  }
<A NAME="5"></A>
  @Override
  public E ceiling(E e) {
    return delegate.ceiling(<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match417117-1.html#5',3,'match417117-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>checkValid(e));
  }

  @Override
  public void clear() {
    delegate.clear();
  }

  @</B></FONT>SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public Comparator&lt;? super E&gt; comparator() {
    Comparator&lt;? super E&gt; comparator = delegate.comparator();
    if (comparator == null) {
      comparator = (Comparator&lt;? super E&gt;) NATURAL_ORDER;
    }
    return comparator;
  }

  @Override
  public boolean contains(Object object) {
    return delegate.contains(checkValid(object));
  }
<A NAME="3"></A>
  @Override
  public boolean containsAll(Collection&lt;?&gt; c) {
    return <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match417117-1.html#3',3,'match417117-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>delegate.containsAll(c);
  }

  @Override
  public Iterator&lt;E&gt; descendingIterator() {
    return delegate.descendingIterator();
  }
<A NAME="2"></A>
  @Override
  public NavigableSet&lt;E&gt; descendingSet() {</B></FONT>
    return new SafeTreeSet&lt;&gt;(<FONT color="#980517"><A HREF="javascript:ZweiFrames('match417117-1.html#2',3,'match417117-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>delegate.descendingSet());
  }

  @Override
  public E first() {
    return delegate.first();
  }

<A NAME="4"></A>  @Override
  public E floor(E e</B></FONT>) {
    return delegate.floor(checkValid(e));
  <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match417117-1.html#4',3,'match417117-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

  @Override
  public SortedSet&lt;E&gt; headSet(E toElement) {
    return headSet(toElement, false);
  }

  @Overri</B></FONT>de
  public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
    return new SafeTreeSet&lt;&gt;(delegate.headSet(checkValid(toElement), inclusive));
  }

  @Override
  public E higher(E e) {
    return delegate.higher(checkValid(e));
<A NAME="0"></A>  }

  @Override
  public boolean isEmpty() <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match417117-1.html#0',3,'match417117-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    return delegate.isEmpty();
  }

  @Override
  public Iterator&lt;E&gt; iterator() {
    return delegate.iterator();
  }

  @Override
  public E last() {
    return delegate.last();
  }

  @Override
  public E lower(E e) {
    return delegate.lower</B></FONT>(checkValid(e));
  }
<A NAME="1"></A>
  @Override
  public E pollFirst() {
    return <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match417117-1.html#1',3,'match417117-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>delegate.pollFirst();
  }

  @Override
  public E pollLast() {
    return delegate.pollLast();
  }

  @Override
  public boolean remove(Object object</B></FONT>) {
    return delegate.remove(checkValid(object));
  }

  @Override
  public boolean removeAll(Collection&lt;?&gt; c) {
    return delegate.removeAll(c);
  }

  @Override
  public boolean retainAll(Collection&lt;?&gt; c) {
<A NAME="7"></A>    return delegate.retainAll(c);
  }

  <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match417117-1.html#7',3,'match417117-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
  public int size() {
    return delegate.size();
  }

  @Override
  public NavigableSet&lt;E&gt; subSet(
      E fromElement</B></FONT>, boolean fromInclusive, E toElement, boolean toInclusive) {
    return new SafeTreeSet&lt;&gt;(
        delegate.subSet(
            checkValid(fromElement), fromInclusive, checkValid(toElement), toInclusive));
  }

  @Override
  public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
    return subSet(fromElement, true, toElement, false);
  }

  @Override
  public SortedSet&lt;E&gt; tailSet(E fromElement) {
    return tailSet(fromElement, true);
  }

  @Override
  public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
    return new SafeTreeSet&lt;&gt;(delegate.tailSet(checkValid(fromElement), inclusive));
  }

  @Override
  public Object[] toArray() {
    return delegate.toArray();
  }

  @Override
  public &lt;T&gt; T[] toArray(T[] a) {
    return delegate.toArray(a);
  }

  private &lt;T&gt; T checkValid(T t) {
    // a ClassCastException is what's supposed to happen!
    @SuppressWarnings(&quot;unchecked&quot;)
    E e = (E) t;
    comparator().compare(e, e);
    return t;
  }

  @Override
  public boolean equals(Object obj) {
<A NAME="6"></A>    return delegate.equals(obj);
  }

  <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match417117-1.html#6',3,'match417117-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Override
  public int hashCode() {
    return delegate.hashCode();
  }

  @Override
  public String toString() {</B></FONT>
    return delegate.toString();
  }

  private static final long serialVersionUID = 0L;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CompactHashMap.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.collect.CollectPreconditions.checkRemove;
import static com.google.common.collect.CompactHashing.UNSET;
import static com.google.common.collect.Hashing.smearedHash;
import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
import static com.google.common.collect.NullnessCasts.unsafeNull;
import static java.util.Objects.requireNonNull;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.j2objc.annotations.WeakOuter;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.AbstractMap;
<A NAME="8"></A>import java.util.AbstractSet;
import java.util.Arrays;
import java.util.Collection;
<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#8',2,'match417117-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * CompactHashMap is an implementation of a Map. All optional operations (put and remove) are
 * supported. Null keys and values are supported.
 *
 * &lt;p&gt;{@code containsKey(k)}, {@code put(k, v)} and {@code remove(k)} are all (expected and
 * amortized) constant time operations. Expected in the hashtable sense (depends on the hash
 * function doing a good job of distributing the elements to the buckets to a distribution not far
 * from uniform), and amortized since some operations can trigger a hash table resize.
 *
 * &lt;p&gt;Unlike {@code java.util.HashMap}, iteration is only proportional to the actual {@code size()},
 * which is optimal, and &lt;i&gt;not&lt;/i&gt; the size of the internal hashtable, which could be much larger
 * than {@code size()}. Furthermore, this structure places significantly reduced load on the garbage
 * collector by only using a constant number of internal objects.
 *
 * &lt;p&gt;If there are no removals, then iteration order for the {@link #entrySet}, {@link #keySet}, and
 * {@link #values} views is the same as insertion order. Any removal invalidates any ordering
 * guarantees.
 *
 * &lt;p&gt;This class should not be assumed to be universally superior to {@code java.util.HashMap}.
 * Generally speaking, this class reduces object allocation and memory consumption at the price of
 * moderately increased constant factors of CPU. Only use this class when there is a specific reason
 * to prioritize memory over CPU.
 *
 * @author Louis Wasserman
 * @author Jon Noack
 */
@</B></FONT>GwtIncompatible // not worth using in GWT for now
@ElementTypesAreNonnullByDefault
class CompactHashMap&lt;K extends @Nullable Object, V extends @Nullable Object&gt;
    extends AbstractMap&lt;K, V&gt; implements Serializable {
  /*
   * TODO: Make this a drop-in replacement for j.u. versions, actually drop them in, and test the
   * world. Figure out what sort of space-time tradeoff we're actually going to get here with the
   * *Map variants. This class is particularly hard to benchmark, because the benefit is not only in
   * less allocation, but also having the GC do less work to scan the heap because of fewer
   * references, which is particularly hard to quantify.
   */

  /** Creates an empty {@code CompactHashMap} instance. */
  public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
      CompactHashMap&lt;K, V&gt; create() {
    return new CompactHashMap&lt;&gt;();
  }

  /**
   * Creates a {@code CompactHashMap} instance, with a high enough &quot;initial capacity&quot; that it
   * &lt;i&gt;should&lt;/i&gt; hold {@code expectedSize} elements without growth.
   *
   * @param expectedSize the number of elements you expect to add to the returned set
   * @return a new, empty {@code CompactHashMap} with enough capacity to hold {@code expectedSize}
   *     elements without resizing
   * @throws IllegalArgumentException if {@code expectedSize} is negative
   */
  public static &lt;K extends @Nullable Object, V extends @Nullable Object&gt;
      CompactHashMap&lt;K, V&gt; createWithExpectedSize(int expectedSize) {
    return new CompactHashMap&lt;&gt;(expectedSize);
  }

  private static final Object NOT_FOUND = new Object();

  /**
   * Maximum allowed false positive probability of detecting a hash flooding attack given random
   * input.
   */
  @VisibleForTesting(
      )
  static final double HASH_FLOODING_FPP = 0.001;

  /**
   * Maximum allowed length of a hash table bucket before falling back to a j.u.LinkedHashMap-based
   * implementation. Experimentally determined.
   */
  private static final int MAX_HASH_BUCKET_LENGTH = 9;

  // The way the `table`, `entries`, `keys`, and `values` arrays work together is as follows.
  //
  // The `table` array always has a size that is a power of 2. The hashcode of a key in the map
  // is masked in order to correspond to the current table size. For example, if the table size
  // is 128 then the mask is 127 == 0x7f, keeping the bottom 7 bits of the hash value.
  // If a key hashes to 0x89abcdef the mask reduces it to 0x89abcdef &amp; 0x7f == 0x6f. We'll call this
  // the &quot;short hash&quot;.
  //
  // The `keys`, `values`, and `entries` arrays always have the same size as each other. They can be
  // seen as fields of an imaginary `Entry` object like this:
  //
  // class Entry {
  //    int hash;
  //    Entry next;
  //    K key;
  //    V value;
  // }
  //
  // The imaginary `hash` and `next` values are combined into a single `int` value in the `entries`
  // array. The top bits of this value are the remaining bits of the hash value that were not used
  // in the short hash. We saw that a mask of 0x7f would keep the 7-bit value 0x6f from a full
  // hashcode of 0x89abcdef. The imaginary `hash` value would then be the remaining top 25 bits,
  // 0x89abcd80. To this is added (or'd) the `next` value, which is an index within `entries`
  // (and therefore within `keys` and `values`) of another entry that has the same short hash
  // value. In our example, it would be another entry for a key whose short hash is also 0x6f.
  //
  // Essentially, then, `table[h]` gives us the start of a linked list in `entries`, where every
  // element of the list has the short hash value h.
  //
  // A wrinkle here is that the value 0 (called UNSET in the code) is used as the equivalent of a
  // null pointer. If `table[h] == 0` that means there are no keys in the map whose short hash is h.
  // If the `next` bits in `entries[i]` are 0 that means there are no further entries for the given
  // short hash. But 0 is also a valid index in `entries`, so we add 1 to these indices before
  // putting them in `table` or in `next` bits, and subtract 1 again when we need an index value.
  //
  // The elements of `keys`, `values`, and `entries` are added sequentially, so that elements 0 to
  // `size() - 1` are used and remaining elements are not. This makes iteration straightforward.
  // Removing an entry generally involves moving the last element of each array to where the removed
  // entry was, and adjusting index links accordingly.

  /**
   * The hashtable object. This can be either:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;a byte[], short[], or int[], with size a power of two, created by
   *       CompactHashing.createTable, whose values are either
   *       &lt;ul&gt;
   *         &lt;li&gt;UNSET, meaning &quot;null pointer&quot;
   *         &lt;li&gt;one plus an index into the keys, values, and entries arrays
   *       &lt;/ul&gt;
   *   &lt;li&gt;another java.util.Map delegate implementation. In most modern JDKs, normal java.util hash
   *       collections intelligently fall back to a binary search tree if hash table collisions are
   *       detected. Rather than going to all the trouble of reimplementing this ourselves, we
   *       simply switch over to use the JDK implementation wholesale if probable hash flooding is
   *       detected, sacrificing the compactness guarantee in very rare cases in exchange for much
   *       more reliable worst-case behavior.
   *   &lt;li&gt;null, if no entries have yet been added to the map
   * &lt;/ul&gt;
   */
  @CheckForNull private transient Object table;

  /**
   * Contains the logical entries, in the range of [0, size()). The high bits of each int are the
   * part of the smeared hash of the key not covered by the hashtable mask, whereas the low bits are
   * the &quot;next&quot; pointer (pointing to the next entry in the bucket chain), which will always be less
   * than or equal to the hashtable mask.
   *
   * &lt;pre&gt;
   * hash  = aaaaaaaa
   * mask  = 00000fff
   * next  = 00000bbb
   * entry = aaaaabbb
   * &lt;/pre&gt;
   *
   * &lt;p&gt;The pointers in [size(), entries.length) are all &quot;null&quot; (UNSET).
   */
  @VisibleForTesting @CheckForNull transient int[] entries;

  /**
   * The keys of the entries in the map, in the range of [0, size()). The keys in [size(),
   * keys.length) are all {@code null}.
   */
  @VisibleForTesting @CheckForNull transient @Nullable Object[] keys;

  /**
   * The values of the entries in the map, in the range of [0, size()). The values in [size(),
   * values.length) are all {@code null}.
   */
  @VisibleForTesting @CheckForNull transient @Nullable Object[] values;

  /**
   * Keeps track of metadata like the number of hash table bits and modifications of this data
   * structure (to make it possible to throw ConcurrentModificationException in the iterator). Note
   * that we choose not to make this volatile, so we do less of a &quot;best effort&quot; to track such
   * errors, for better performance.
   *
   * &lt;p&gt;For a new instance, where the arrays above have not yet been allocated, the value of {@code
   * metadata} is the size that the arrays should be allocated with. Once the arrays have been
   * allocated, the value of {@code metadata} combines the number of bits in the &quot;short hash&quot;, in
   * its bottom {@value CompactHashing#HASH_TABLE_BITS_MAX_BITS} bits, with a modification count in
   * the remaining bits that is used to detect concurrent modification during iteration.
   */
  private transient int metadata;

  /** The number of elements contained in the set. */
  private transient int size;

  /** Constructs a new empty instance of {@code CompactHashMap}. */
  CompactHashMap() {
    init(CompactHashing.DEFAULT_SIZE);
  }

  /**
   * Constructs a new instance of {@code CompactHashMap} with the specified capacity.
   *
   * @param expectedSize the initial capacity of this {@code CompactHashMap}.
   */
  CompactHashMap(int expectedSize) {
    init(expectedSize);
  }

  /** Pseudoconstructor for serialization support. */
  void init(int expectedSize) {
    Preconditions.checkArgument(expectedSize &gt;= 0, &quot;Expected size must be &gt;= 0&quot;);

    // Save expectedSize for use in allocArrays()
    this.metadata = Ints.constrainToRange(expectedSize, 1, CompactHashing.MAX_SIZE);
  }

  /** Returns whether arrays need to be allocated. */
  @VisibleForTesting
  boolean needsAllocArrays() {
    return table == null;
  }

  /** Handle lazy allocation of arrays. */
  @CanIgnoreReturnValue
  int allocArrays() {
    Preconditions.checkState(needsAllocArrays(), &quot;Arrays already allocated&quot;);

    int expectedSize = metadata;
    int buckets = CompactHashing.tableSize(expectedSize);
    this.table = CompactHashing.createTable(buckets);
    setHashTableMask(buckets - 1);

    this.entries = new int[expectedSize];
    this.keys = new Object[expectedSize];
    this.values = new Object[expectedSize];

    return expectedSize;
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @VisibleForTesting
  @CheckForNull
  Map&lt;K, V&gt; delegateOrNull() {
    if (table instanceof Map) {
      return (Map&lt;K, V&gt;) table;
    }
    return null;
  }

  Map&lt;K, V&gt; createHashFloodingResistantDelegate(int tableSize) {
    return new LinkedHashMap&lt;&gt;(tableSize, 1.0f);
  }

  @VisibleForTesting
  @CanIgnoreReturnValue
  Map&lt;K, V&gt; convertToHashFloodingResistantImplementation() {
    Map&lt;K, V&gt; newDelegate = createHashFloodingResistantDelegate(hashTableMask() + 1);
    for (int i = firstEntryIndex(); i &gt;= 0; i = getSuccessor(i)) {
      newDelegate.put(key(i), value(i));
    }
    this.table = newDelegate;
    this.entries = null;
    this.keys = null;
    this.values = null;
    incrementModCount();
    return newDelegate;
  }

  /** Stores the hash table mask as the number of bits needed to represent an index. */
  private void setHashTableMask(int mask) {
    int hashTableBits = Integer.SIZE - Integer.numberOfLeadingZeros(mask);
    metadata =
        CompactHashing.maskCombine(metadata, hashTableBits, CompactHashing.HASH_TABLE_BITS_MASK);
  }

  /** Gets the hash table mask using the stored number of hash table bits. */
  private int hashTableMask() {
    return (1 &lt;&lt; (metadata &amp; CompactHashing.HASH_TABLE_BITS_MASK)) - 1;
  }

  void incrementModCount() {
    metadata += CompactHashing.MODIFICATION_COUNT_INCREMENT;
  }

  /**
   * Mark an access of the specified entry. Used only in {@code CompactLinkedHashMap} for LRU
   * ordering.
   */
  void accessEntry(int index) {
    // no-op by default
  }

  @CanIgnoreReturnValue
  @Override
  @CheckForNull
  public V put(@ParametricNullness K key, @ParametricNullness V value) {
    if (needsAllocArrays()) {
      allocArrays();
    }
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      return delegate.put(key, value);
    }
    int[] entries = requireEntries();
    @Nullable Object[] keys = requireKeys();
    @Nullable Object[] values = requireValues();

    int newEntryIndex = this.size; // current size, and pointer to the entry to be appended
    int newSize = newEntryIndex + 1;
    int hash = smearedHash(key);
    int mask = hashTableMask();
    int tableIndex = hash &amp; mask;
    int next = CompactHashing.tableGet(requireTable(), tableIndex);
    if (next == UNSET) { // uninitialized bucket
      if (newSize &gt; mask) {
        // Resize and add new entry
        mask = resizeTable(mask, CompactHashing.newCapacity(mask), hash, newEntryIndex);
      } else {
        CompactHashing.tableSet(requireTable(), tableIndex, newEntryIndex + 1);
      }
    } else {
      int entryIndex;
      int entry;
      int hashPrefix = CompactHashing.getHashPrefix(hash, mask);
      int bucketLength = 0;
      do {
        entryIndex = next - 1;
        entry = entries[entryIndex];
        if (CompactHashing.getHashPrefix(entry, mask) == hashPrefix
            &amp;&amp; Objects.equal(key, keys[entryIndex])) {
          @SuppressWarnings(&quot;unchecked&quot;) // known to be a V
          V oldValue = (V) values[entryIndex];

          values[entryIndex] = value;
          accessEntry(entryIndex);
          return oldValue;
        }
        next = CompactHashing.getNext(entry, mask);
        bucketLength++;
      } while (next != UNSET);

      if (bucketLength &gt;= MAX_HASH_BUCKET_LENGTH) {
        return convertToHashFloodingResistantImplementation().put(key, value);
      }

      if (newSize &gt; mask) {
        // Resize and add new entry
        mask = resizeTable(mask, CompactHashing.newCapacity(mask), hash, newEntryIndex);
      } else {
        entries[entryIndex] = CompactHashing.maskCombine(entry, newEntryIndex + 1, mask);
      }
    }
    resizeMeMaybe(newSize);
    insertEntry(newEntryIndex, key, value, hash, mask);
    this.size = newSize;
    incrementModCount();
    return null;
  }

  /**
   * Creates a fresh entry with the specified object at the specified position in the entry arrays.
   */
  void insertEntry(
      int entryIndex, @ParametricNullness K key, @ParametricNullness V value, int hash, int mask) {
    this.setEntry(entryIndex, CompactHashing.maskCombine(hash, UNSET, mask));
    this.setKey(entryIndex, key);
    this.setValue(entryIndex, value);
  }

  /** Resizes the entries storage if necessary. */
  private void resizeMeMaybe(int newSize) {
    int entriesSize = requireEntries().length;
    if (newSize &gt; entriesSize) {
      // 1.5x but round up to nearest odd (this is optimal for memory consumption on Android)
      int newCapacity =
          Math.min(CompactHashing.MAX_SIZE, (entriesSize + Math.max(1, entriesSize &gt;&gt;&gt; 1)) | 1);
      if (newCapacity != entriesSize) {
        resizeEntries(newCapacity);
      }
    }
  }

  /**
   * Resizes the internal entries array to the specified capacity, which may be greater or less than
   * the current capacity.
   */
  void resizeEntries(int newCapacity) {
    this.entries = Arrays.copyOf(requireEntries(), newCapacity);
    this.keys = Arrays.copyOf(requireKeys(), newCapacity);
    this.values = Arrays.copyOf(requireValues(), newCapacity);
  }

  @CanIgnoreReturnValue
  private int resizeTable(int oldMask, int newCapacity, int targetHash, int targetEntryIndex) {
    Object newTable = CompactHashing.createTable(newCapacity);
    int newMask = newCapacity - 1;

    if (targetEntryIndex != UNSET) {
      // Add target first; it must be last in the chain because its entry hasn't yet been created
      CompactHashing.tableSet(newTable, targetHash &amp; newMask, targetEntryIndex + 1);
    }

    Object oldTable = requireTable();
    int[] entries = requireEntries();

    // Loop over `oldTable` to construct its replacement, ``newTable`. The entries do not move, so
    // the `keys` and `values` arrays do not need to change. But because the &quot;short hash&quot; now has a
    // different number of bits, we must rewrite each element of `entries` so that its contribution
    // to the full hashcode reflects the change, and so that its `next` link corresponds to the new
    // linked list of entries with the new short hash.
    for (int oldTableIndex = 0; oldTableIndex &lt;= oldMask; oldTableIndex++) {
      int oldNext = CompactHashing.tableGet(oldTable, oldTableIndex);
      // Each element of `oldTable` is the head of a (possibly empty) linked list of elements in
      // `entries`. The `oldNext` loop is going to traverse that linked list.
      // We need to rewrite the `next` link of each of the elements so that it is in the appropriate
      // linked list starting from `newTable`. In general, each element from the old linked list
      // belongs to a different linked list from `newTable`. We insert each element in turn at the
      // head of its appropriate `newTable` linked list.
      while (oldNext != UNSET) {
        int entryIndex = oldNext - 1;
        int oldEntry = entries[entryIndex];

        // Rebuild the full 32-bit hash using entry hashPrefix and oldTableIndex (&quot;hashSuffix&quot;).
        int hash = CompactHashing.getHashPrefix(oldEntry, oldMask) | oldTableIndex;

        int newTableIndex = hash &amp; newMask;
        int newNext = CompactHashing.tableGet(newTable, newTableIndex);
        CompactHashing.tableSet(newTable, newTableIndex, oldNext);
        entries[entryIndex] = CompactHashing.maskCombine(hash, newNext, newMask);

        oldNext = CompactHashing.getNext(oldEntry, oldMask);
      }
    }

    this.table = newTable;
    setHashTableMask(newMask);
    return newMask;
  }

  private int indexOf(@CheckForNull Object key) {
    if (needsAllocArrays()) {
      return -1;
    }
    int hash = smearedHash(key);
    int mask = hashTableMask();
    int next = CompactHashing.tableGet(requireTable(), hash &amp; mask);
    if (next == UNSET) {
      return -1;
    }
    int hashPrefix = CompactHashing.getHashPrefix(hash, mask);
    do {
      int entryIndex = next - 1;
      int entry = entry(entryIndex);
      if (CompactHashing.getHashPrefix(entry, mask) == hashPrefix
          &amp;&amp; Objects.equal(key, key(entryIndex))) {
        return entryIndex;
      }
      next = CompactHashing.getNext(entry, mask);
    } while (next != UNSET);
    return -1;
  }

  @Override
  public boolean containsKey(@CheckForNull Object key) {
    Map&lt;K, V&gt; delegate = delegateOrNull();
    return (delegate != null) ? delegate.containsKey(key) : indexOf(key) != -1;
  }

  @Override
  @CheckForNull
  public V get(@CheckForNull Object key) {
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      return delegate.get(key);
    }
    int index = indexOf(key);
    if (index == -1) {
      return null;
    }
    accessEntry(index);
    return value(index);
  }

  @CanIgnoreReturnValue
  @SuppressWarnings(&quot;unchecked&quot;) // known to be a V
  @Override
  @CheckForNull
  public V remove(@CheckForNull Object key) {
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      return delegate.remove(key);
    }
    Object oldValue = removeHelper(key);
    return (oldValue == NOT_FOUND) ? null : (V) oldValue;
  }

  private @Nullable Object removeHelper(@CheckForNull Object key) {
    if (needsAllocArrays()) {
      return NOT_FOUND;
    }
    int mask = hashTableMask();
    int index =
        CompactHashing.remove(
            key,
            /* value= */ null,
            mask,
            requireTable(),
            requireEntries(),
            requireKeys(),
            /* values= */ null);
    if (index == -1) {
      return NOT_FOUND;
    }

    Object oldValue = value(index);

    moveLastEntry(index, mask);
    size--;
    incrementModCount();

    return oldValue;
  }

  /**
   * Moves the last entry in the entry array into {@code dstIndex}, and nulls out its old position.
   */
  void moveLastEntry(int dstIndex, int mask) {
    Object table = requireTable();
    int[] entries = requireEntries();
    @Nullable Object[] keys = requireKeys();
    @Nullable Object[] values = requireValues();
    int srcIndex = size() - 1;
    if (dstIndex &lt; srcIndex) {
      // move last entry to deleted spot
      Object key = keys[srcIndex];
      keys[dstIndex] = key;
      values[dstIndex] = values[srcIndex];
      keys[srcIndex] = null;
      values[srcIndex] = null;

      // move the last entry to the removed spot, just like we moved the element
      entries[dstIndex] = entries[srcIndex];
      entries[srcIndex] = 0;

      // also need to update whoever's &quot;next&quot; pointer was pointing to the last entry place
      int tableIndex = smearedHash(key) &amp; mask;
      int next = CompactHashing.tableGet(table, tableIndex);
      int srcNext = srcIndex + 1;
      if (next == srcNext) {
        // we need to update the root pointer
        CompactHashing.tableSet(table, tableIndex, dstIndex + 1);
      } else {
        // we need to update a pointer in an entry
        int entryIndex;
        int entry;
        do {
          entryIndex = next - 1;
          entry = entries[entryIndex];
          next = CompactHashing.getNext(entry, mask);
        } while (next != srcNext);
        // here, entries[entryIndex] points to the old entry location; update it
        entries[entryIndex] = CompactHashing.maskCombine(entry, dstIndex + 1, mask);
      }
    } else {
      keys[dstIndex] = null;
      values[dstIndex] = null;
      entries[dstIndex] = 0;
    }
  }

  int firstEntryIndex() {
    return isEmpty() ? -1 : 0;
  }

  int getSuccessor(int entryIndex) {
    return (entryIndex + 1 &lt; size) ? entryIndex + 1 : -1;
  }

  /**
   * Updates the index an iterator is pointing to after a call to remove: returns the index of the
   * entry that should be looked at after a removal on indexRemoved, with indexBeforeRemove as the
   * index that *was* the next entry that would be looked at.
   */
  int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings(&quot;unused&quot;) int indexRemoved) {
    return indexBeforeRemove - 1;
  }

  private abstract class Itr&lt;T extends @Nullable Object&gt; implements Iterator&lt;T&gt; {
    int expectedMetadata = metadata;
    int currentIndex = firstEntryIndex();
    int indexToRemove = -1;

    @Override
    public boolean hasNext() {
      return currentIndex &gt;= 0;
    }

    @ParametricNullness
    abstract T getOutput(int entry);

    @Override
    @ParametricNullness
    public T next() {
      checkForConcurrentModification();
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      indexToRemove = currentIndex;
      T result = getOutput(currentIndex);
      currentIndex = getSuccessor(currentIndex);
      return result;
    }

    @Override
    public void remove() {
      checkForConcurrentModification();
      checkRemove(indexToRemove &gt;= 0);
      incrementExpectedModCount();
      CompactHashMap.this.remove(key(indexToRemove));
      currentIndex = adjustAfterRemove(currentIndex, indexToRemove);
      indexToRemove = -1;
    }

    void incrementExpectedModCount() {
      expectedMetadata += CompactHashing.MODIFICATION_COUNT_INCREMENT;
    }

    private void checkForConcurrentModification() {
      if (metadata != expectedMetadata) {
        throw new ConcurrentModificationException();
      }
    }
  }

  @CheckForNull private transient Set&lt;K&gt; keySetView;

  @Override
  public Set&lt;K&gt; keySet() {
    return (keySetView == null) ? keySetView = createKeySet() : keySetView;
  }

  Set&lt;K&gt; createKeySet() {
    return new KeySetView();
  }
<A NAME="7"></A>
  @WeakOuter
  class KeySetView extends AbstractSet&lt;K&gt; {
    <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#7',2,'match417117-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    public int size() {
      return CompactHashMap.this.size();
    }

    @Override
    public boolean contains(@CheckForNull Object o</B></FONT>) {
      return CompactHashMap.this.containsKey(o);
    }

    @Override
    public boolean remove(@CheckForNull Object o) {
<A NAME="3"></A>      Map&lt;K, V&gt; delegate = delegateOrNull();
      return (delegate != null)
          ? delegate.keySet().remove(o)
          : <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#3',2,'match417117-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CompactHashMap.this.removeHelper(o) != NOT_FOUND;
    }

    @Override
    public Iterator&lt;K&gt; iterator() {
      return keySetIterator();
    }

    @Override
    public void clear() {</B></FONT>
      CompactHashMap.this.clear();
    }
  }

  Iterator&lt;K&gt; keySetIterator() {
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      return delegate.keySet().iterator();
    }
    return new Itr&lt;K&gt;() {
      @Override
      @ParametricNullness
      K getOutput(int entry) {
        return key(entry);
      }
    };
  }

  @CheckForNull private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySetView;

  @Override
  public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
    return (entrySetView == null) ? entrySetView = createEntrySet() : entrySetView;
  }

  Set&lt;Entry&lt;K, V&gt;&gt; createEntrySet() {
    return new EntrySetView();
  }

<A NAME="6"></A>  @WeakOuter
  class EntrySetView extends AbstractSet&lt;Entry&lt;K, V&gt;&gt; {

    <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#6',2,'match417117-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    public int size() {
      return CompactHashMap.this.size();
    }
<A NAME="2"></A>
    @Override
    public void clear() {</B></FONT>
      <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#2',2,'match417117-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CompactHashMap.this.clear();
    }

    @Override
    public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
      return entrySetIterator();
    }

    @Override
    public boolean contains(@CheckForNull Object o</B></FONT>) {
      Map&lt;K, V&gt; delegate = delegateOrNull();
      if (delegate != null) {
        return delegate.entrySet().contains(o);
      } else if (o instanceof Entry) {
        Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) o;
        int index = indexOf(entry.getKey());
        return index != -1 &amp;&amp; Objects.equal(value(index), entry.getValue());
      }
      return false;
    }

    @Override
    public boolean remove(@CheckForNull Object o) {
      Map&lt;K, V&gt; delegate = delegateOrNull();
      if (delegate != null) {
        return delegate.entrySet().remove(o);
      } else if (o instanceof Entry) {
        Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) o;
        if (needsAllocArrays()) {
          return false;
        }
        int mask = hashTableMask();
        int index =
            CompactHashing.remove(
                entry.getKey(),
                entry.getValue(),
                mask,
                requireTable(),
                requireEntries(),
                requireKeys(),
                requireValues());
        if (index == -1) {
          return false;
        }

        moveLastEntry(index, mask);
        size--;
        incrementModCount();

        return true;
      }
      return false;
    }
  }

  Iterator&lt;Entry&lt;K, V&gt;&gt; entrySetIterator() {
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      return delegate.entrySet().iterator();
    }
    return new Itr&lt;Entry&lt;K, V&gt;&gt;() {
      @Override
      Entry&lt;K, V&gt; getOutput(int entry) {
        return new MapEntry(entry);
      }
    };
  }

  final class MapEntry extends AbstractMapEntry&lt;K, V&gt; {
    @ParametricNullness private final K key;

    private int lastKnownIndex;

    MapEntry(int index) {
      this.key = key(index);
      this.lastKnownIndex = index;
    }

    @Override
    @ParametricNullness
    public K getKey() {
      return key;
    }

    private void updateLastKnownIndex() {
      if (lastKnownIndex == -1
          || lastKnownIndex &gt;= size()
          || !Objects.equal(key, key(lastKnownIndex))) {
        lastKnownIndex = indexOf(key);
      }
    }

    @Override
    @ParametricNullness
    public V getValue() {
      Map&lt;K, V&gt; delegate = delegateOrNull();
      if (delegate != null) {
        /*
         * The cast is safe because the entry is present in the map. Or, if it has been removed by a
         * concurrent modification, behavior is undefined.
         */
        return uncheckedCastNullableTToT(delegate.get(key));
      }
      updateLastKnownIndex();
      /*
       * If the entry has been removed from the map, we return null, even though that might not be a
       * valid value. That's the best we can do, short of holding a reference to the most recently
       * seen value. And while we *could* do that, we aren't required to: Map.Entry explicitly says
       * that behavior is undefined when the backing map is modified through another API. (It even
       * permits us to throw IllegalStateException. Maybe we should have done that, but we probably
       * shouldn't change now for fear of breaking people.)
       */
      return (lastKnownIndex == -1) ? unsafeNull() : value(lastKnownIndex);
    }

    @Override
    @ParametricNullness
    public V setValue(@ParametricNullness V value) {
      Map&lt;K, V&gt; delegate = delegateOrNull();
      if (delegate != null) {
        return uncheckedCastNullableTToT(delegate.put(key, value)); // See discussion in getValue().
      }
      updateLastKnownIndex();
      if (lastKnownIndex == -1) {
        put(key, value);
        return unsafeNull(); // See discussion in getValue().
      } else {
        V old = value(lastKnownIndex);
        CompactHashMap.this.setValue(lastKnownIndex, value);
        return old;
      }
    }
  }

<A NAME="1"></A>  @Override
  public int size() {
    Map&lt;K, V&gt; delegate = delegateOrNull();
    return (delegate != null) ? <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#1',2,'match417117-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>delegate.size() : size;
  }

  @Override
  public boolean isEmpty() {
    return size() == 0;
  }

  @Override
  public boolean containsValue(@CheckForNull Object value</B></FONT>) {
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      return delegate.containsValue(value);
    }
    for (int i = 0; i &lt; size; i++) {
      if (Objects.equal(value, value(i))) {
        return true;
      }
    }
    return false;
  }

  @CheckForNull private transient Collection&lt;V&gt; valuesView;

  @Override
  public Collection&lt;V&gt; values() {
    return (valuesView == null) ? valuesView = createValues() : valuesView;
  }

  Collection&lt;V&gt; createValues() {
    return new ValuesView();
  }

  @WeakOuter
<A NAME="5"></A>  class ValuesView extends AbstractCollection&lt;V&gt; {
    @Override
    public int size() {
      return <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#5',2,'match417117-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>CompactHashMap.this.size();
    }

    @Override
    public void clear() {
      CompactHashMap.this.clear();
    }

    @</B></FONT>Override
    public Iterator&lt;V&gt; iterator() {
      return valuesIterator();
    }
  }

  Iterator&lt;V&gt; valuesIterator() {
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      return delegate.values().iterator();
    }
    return new Itr&lt;V&gt;() {
      @Override
      @ParametricNullness
      V getOutput(int entry) {
        return value(entry);
      }
    };
  }

  /**
   * Ensures that this {@code CompactHashMap} has the smallest representation in memory, given its
   * current size.
   */
  public void trimToSize() {
    if (needsAllocArrays()) {
      return;
    }
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      Map&lt;K, V&gt; newDelegate = createHashFloodingResistantDelegate(size());
      newDelegate.putAll(delegate);
      this.table = newDelegate;
      return;
    }
    int size = this.size;
    if (size &lt; requireEntries().length) {
      resizeEntries(size);
    }
    int minimumTableSize = CompactHashing.tableSize(size);
    int mask = hashTableMask();
    if (minimumTableSize &lt; mask) { // smaller table size will always be less than current mask
      resizeTable(mask, minimumTableSize, UNSET, UNSET);
    }
  }

  @Override
  public void clear() {
    if (needsAllocArrays()) {
      return;
    }
    incrementModCount();
    Map&lt;K, V&gt; delegate = delegateOrNull();
    if (delegate != null) {
      metadata =
          Ints.constrainToRange(size(), CompactHashing.DEFAULT_SIZE, CompactHashing.MAX_SIZE);
      delegate.clear(); // invalidate any iterators left over!
      table = null;
      size = 0;
    } else {
      Arrays.fill(requireKeys(), 0, size, null);
      Arrays.fill(requireValues(), 0, size, null);
      CompactHashing.tableClear(requireTable());
      Arrays.fill(requireEntries(), 0, size, 0);
      this.size = 0;
    }
  }

  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeInt(size());
    Iterator&lt;Entry&lt;K, V&gt;&gt; entryIterator = entrySetIterator();
    while (entryIterator.hasNext()) {
      Entry&lt;K, V&gt; e = entryIterator.next();
      stream.writeObject(e.getKey());
      stream.writeObject(e.getValue());
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    int elementCount = stream.readInt();
    if (elementCount &lt; 0) {
      throw new InvalidObjectException(&quot;Invalid size: &quot; + elementCount);
    }
    init(elementCount);
    for (int i = 0; i &lt; elementCount; i++) {
      K key = (K) stream.readObject();
      V value = (V) stream.readObject();
      put(key, value);
    }
  }

  /*
   * The following methods are safe to call as long as both of the following hold:
   *
   * - allocArrays() has been called. Callers can confirm this by checking needsAllocArrays().
   *
   * - The map has not switched to delegating to a java.util implementation to mitigate hash
   *   flooding. Callers can confirm this by null-checking delegateOrNull().
   *
   * In an ideal world, we would document why we know those things are true every time we call these
   * methods. But that is a bit too painful....
   */

  private Object requireTable() {
<A NAME="0"></A>    return requireNonNull(table);
  }

  private int[] requireEntries() <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#0',2,'match417117-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    return requireNonNull(entries);
  }

  private @Nullable Object[] requireKeys() {
    return requireNonNull(keys);
  }

  private @Nullable Object[] requireValues() {
    return requireNonNull(values);
  }

  /*
   * The following methods are safe to call as long as the conditions in the *previous* comment are
   * met *and* the index is less than size().
   *
   * (The above explains when these methods are safe from a `nullness` perspective. From an
   * `unchecked` perspective, they're safe because we put only K/V elements into each array.)
   */

<A NAME="4"></A>  @SuppressWarnings(&quot;unchecked&quot;)
  private K key(int i) {
    return (K) requireKeys</B></FONT>()[i];
  <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match417117-0.html#4',2,'match417117-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  @SuppressWarnings(&quot;unchecked&quot;)
  private V value(int i) {
    return (V) requireValues()[i];
  }

  priva</B></FONT>te int entry(int i) {
    return requireEntries()[i];
  }

  private void setKey(int i, K key) {
    requireKeys()[i] = key;
  }

  private void setValue(int i, V value) {
    requireValues()[i] = value;
  }

  private void setEntry(int i, int value) {
    requireEntries()[i] = value;
  }
}
</PRE>
</div>
  </div>
</body>
</html>
