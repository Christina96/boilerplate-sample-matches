<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Resources.java & MultimapBuilder_1.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Resources.java & MultimapBuilder_1.java
      </h3>
      <h1 align="center">
        9.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Resources.java (20.64516%)<TH>MultimapBuilder_1.java (5.9479556%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match761894-0.html#0',2,'match761894-1.html#0',3)" NAME="0">(17-44)<TD><A HREF="javascript:ZweiFrames('match761894-0.html#0',2,'match761894-1.html#0',3)" NAME="0">(24-65)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match761894-0.html#1',2,'match761894-1.html#1',3)" NAME="1">(60-69)<TD><A HREF="javascript:ZweiFrames('match761894-0.html#1',2,'match761894-1.html#1',3)" NAME="1">(217-226)</A><TD ALIGN=center><FONT COLOR="#e10000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Resources.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
<A NAME="0"></A>
package com.google.common.io;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match761894-1.html#0',3,'match761894-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Charsets;
import com.google.common.base.MoreObjects;
import com.google.common.collect.Lists;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.List;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Provides utility methods for working with resources in the classpath. Note that even though these
 * methods use {@link URL} parameters, they are usually not appropriate for HTTP or other
 * non-classpath resources.
 *
 * @author Chris Nokleberg
 * @author Ben Yu
 * @author Colin Decker
 * @since 1.0
 */
@GwtIncompatible
@</B></FONT>ElementTypesAreNonnullByDefault
public final class Resources {
  private Resources() {}

  /**
   * Returns a {@link ByteSource} that reads from the given URL.
   *
   * @since 14.0
   */
  public static ByteSource asByteSource(URL url) {
    return new UrlByteSource(url);
  }

<A NAME="1"></A>  /** A byte source that reads from a URL using {@link URL#openStream()}. */
  private static final class UrlByteSource extends ByteSource {

    <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match761894-1.html#1',3,'match761894-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>private final URL url;

    private UrlByteSource(URL url) {
      this.url = checkNotNull(url);
    }

    @Override
    public InputStream openStream() throws IOException {
      return url.openStream();
    }</B></FONT>

    @Override
    public String toString() {
      return &quot;Resources.asByteSource(&quot; + url + &quot;)&quot;;
    }
  }

  /**
   * Returns a {@link CharSource} that reads from the given URL using the given character set.
   *
   * @since 14.0
   */
  public static CharSource asCharSource(URL url, Charset charset) {
    return asByteSource(url).asCharSource(charset);
  }

  /**
   * Reads all bytes from a URL into a byte array.
   *
   * @param url the URL to read from
   * @return a byte array containing all the bytes from the URL
   * @throws IOException if an I/O error occurs
   */
  public static byte[] toByteArray(URL url) throws IOException {
    return asByteSource(url).read();
  }

  /**
   * Reads all characters from a URL into a {@link String}, using the given character set.
   *
   * @param url the URL to read from
   * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful
   *     predefined constants
   * @return a string containing all the characters from the URL
   * @throws IOException if an I/O error occurs.
   */
  public static String toString(URL url, Charset charset) throws IOException {
    return asCharSource(url, charset).read();
  }

  /**
   * Streams lines from a URL, stopping when our callback returns false, or we have read all of the
   * lines.
   *
   * @param url the URL to read from
   * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful
   *     predefined constants
   * @param callback the LineProcessor to use to handle the lines
   * @return the output of processing the lines
   * @throws IOException if an I/O error occurs
   */
  @CanIgnoreReturnValue // some processors won't return a useful result
  @ParametricNullness
  public static &lt;T extends @Nullable Object&gt; T readLines(
      URL url, Charset charset, LineProcessor&lt;T&gt; callback) throws IOException {
    return asCharSource(url, charset).readLines(callback);
  }

  /**
   * Reads all of the lines from a URL. The lines do not include line-termination characters, but do
   * include other leading and trailing whitespace.
   *
   * &lt;p&gt;This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code
   * Resources.asCharSource(url, charset).readLines()}.
   *
   * @param url the URL to read from
   * @param charset the charset used to decode the input stream; see {@link Charsets} for helpful
   *     predefined constants
   * @return a mutable {@link List} containing all the lines
   * @throws IOException if an I/O error occurs
   */
  public static List&lt;String&gt; readLines(URL url, Charset charset) throws IOException {
    // don't use asCharSource(url, charset).readLines() because that returns
    // an immutable list, which would change the behavior of this method
    return readLines(
        url,
        charset,
        new LineProcessor&lt;List&lt;String&gt;&gt;() {
          final List&lt;String&gt; result = Lists.newArrayList();

          @Override
          public boolean processLine(String line) {
            result.add(line);
            return true;
          }

          @Override
          public List&lt;String&gt; getResult() {
            return result;
          }
        });
  }

  /**
   * Copies all bytes from a URL to an output stream.
   *
   * @param from the URL to read from
   * @param to the output stream
   * @throws IOException if an I/O error occurs
   */
  public static void copy(URL from, OutputStream to) throws IOException {
    asByteSource(from).copyTo(to);
  }

  /**
   * Returns a {@code URL} pointing to {@code resourceName} if the resource is found using the
   * {@linkplain Thread#getContextClassLoader() context class loader}. In simple environments, the
   * context class loader will find resources from the class path. In environments where different
   * threads can have different class loaders, for example app servers, the context class loader
   * will typically have been set to an appropriate loader for the current thread.
   *
   * &lt;p&gt;In the unusual case where the context class loader is null, the class loader that loaded
   * this class ({@code Resources}) will be used instead.
   *
   * @throws IllegalArgumentException if the resource is not found
   */
  @CanIgnoreReturnValue // being used to check if a resource exists
  // TODO(cgdecker): maybe add a better way to check if a resource exists
  // e.g. Optional&lt;URL&gt; tryGetResource or boolean resourceExists
  public static URL getResource(String resourceName) {
    ClassLoader loader =
        MoreObjects.firstNonNull(
            Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader());
    URL url = loader.getResource(resourceName);
    checkArgument(url != null, &quot;resource %s not found.&quot;, resourceName);
    return url;
  }

  /**
   * Given a {@code resourceName} that is relative to {@code contextClass}, returns a {@code URL}
   * pointing to the named resource.
   *
   * @throws IllegalArgumentException if the resource is not found
   */
  @CanIgnoreReturnValue // being used to check if a resource exists
  public static URL getResource(Class&lt;?&gt; contextClass, String resourceName) {
    URL url = contextClass.getResource(resourceName);
    checkArgument(
        url != null, &quot;resource %s relative to %s not found.&quot;, resourceName, contextClass.getName());
    return url;
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MultimapBuilder_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2013 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.CollectPreconditions.checkNonnegative;
<A NAME="0"></A>
import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Supplier;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match761894-0.html#0',2,'match761894-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A builder for a multimap implementation that allows customization of the backing map and value
 * collection implementations used in a particular multimap.
 *
 * &lt;p&gt;This can be used to easily configure multimap data structure implementations not provided
 * explicitly in {@code com.google.common.collect}, for example:
 *
 * &lt;pre&gt;{@code
 * ListMultimap&lt;String, Integer&gt; treeListMultimap =
 *     MultimapBuilder.treeKeys().arrayListValues().build();
 * SetMultimap&lt;Integer, MyEnum&gt; hashEnumMultimap =
 *     MultimapBuilder.hashKeys().enumSetValues(MyEnum.class).build();
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;{@code MultimapBuilder} instances are immutable. Invoking a configuration method has no effect
 * on the receiving instance; you must store and use the new builder instance it returns instead.
 *
 * &lt;p&gt;The generated multimaps are serializable if the key and value types are serializable, unless
 * stated otherwise in one of the configuration methods.
 *
 * @author Louis Wasserman
 * @param &lt;K0&gt; An upper bound on the key type of the generated multimap.
 * @param &lt;V0&gt; An upper bound on the value type of the generated multimap.
 * @since 16.0
 */
@GwtCompatible
@</B></FONT>ElementTypesAreNonnullByDefault
public abstract class MultimapBuilder&lt;K0 extends @Nullable Object, V0 extends @Nullable Object&gt; {
  /*
   * Leaving K and V as upper bounds rather than the actual key and value types allows type
   * parameters to be left implicit more often. CacheBuilder uses the same technique.
   */

  private MultimapBuilder() {}

  private static final int DEFAULT_EXPECTED_KEYS = 8;

  /** Uses a hash table to map keys to value collections. */
  public static MultimapBuilderWithKeys&lt;@Nullable Object&gt; hashKeys() {
    return hashKeys(DEFAULT_EXPECTED_KEYS);
  }

  /**
   * Uses a hash table to map keys to value collections, initialized to expect the specified number
   * of keys.
   *
   * @throws IllegalArgumentException if {@code expectedKeys &lt; 0}
   */
  public static MultimapBuilderWithKeys&lt;@Nullable Object&gt; hashKeys(int expectedKeys) {
    checkNonnegative(expectedKeys, &quot;expectedKeys&quot;);
    return new MultimapBuilderWithKeys&lt;@Nullable Object&gt;() {
      @Override
      &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap() {
        return Platform.newHashMapWithExpectedSize(expectedKeys);
      }
    };
  }

  /**
   * Uses a hash table to map keys to value collections.
   *
   * &lt;p&gt;The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
   * Multimap#asMap()} will iterate through the keys in the order that they were first added to the
   * multimap, save that if all values associated with a key are removed and then the key is added
   * back into the multimap, that key will come last in the key iteration order.
   */
  public static MultimapBuilderWithKeys&lt;@Nullable Object&gt; linkedHashKeys() {
    return linkedHashKeys(DEFAULT_EXPECTED_KEYS);
  }

  /**
   * Uses an hash table to map keys to value collections, initialized to expect the specified number
   * of keys.
   *
   * &lt;p&gt;The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
   * Multimap#asMap()} will iterate through the keys in the order that they were first added to the
   * multimap, save that if all values associated with a key are removed and then the key is added
   * back into the multimap, that key will come last in the key iteration order.
   */
  public static MultimapBuilderWithKeys&lt;@Nullable Object&gt; linkedHashKeys(int expectedKeys) {
    checkNonnegative(expectedKeys, &quot;expectedKeys&quot;);
    return new MultimapBuilderWithKeys&lt;@Nullable Object&gt;() {
      @Override
      &lt;K extends @Nullable Object, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap() {
        return Platform.newLinkedHashMapWithExpectedSize(expectedKeys);
      }
    };
  }

  /**
   * Uses a naturally-ordered {@link TreeMap} to map keys to value collections.
   *
   * &lt;p&gt;The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
   * Multimap#asMap()} will iterate through the keys in sorted order.
   *
   * &lt;p&gt;For all multimaps generated by the resulting builder, the {@link Multimap#keySet()} can be
   * safely cast to a {@link java.util.SortedSet}, and the {@link Multimap#asMap()} can safely be
   * cast to a {@link java.util.SortedMap}.
   */
  @SuppressWarnings(&quot;rawtypes&quot;)
  public static MultimapBuilderWithKeys&lt;Comparable&gt; treeKeys() {
    return treeKeys(Ordering.natural());
  }

  /**
   * Uses a {@link TreeMap} sorted by the specified comparator to map keys to value collections.
   *
   * &lt;p&gt;The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
   * Multimap#asMap()} will iterate through the keys in sorted order.
   *
   * &lt;p&gt;For all multimaps generated by the resulting builder, the {@link Multimap#keySet()} can be
   * safely cast to a {@link java.util.SortedSet}, and the {@link Multimap#asMap()} can safely be
   * cast to a {@link java.util.SortedMap}.
   *
   * &lt;p&gt;Multimaps generated by the resulting builder will not be serializable if {@code comparator}
   * is not serializable.
   */
  public static &lt;K0 extends @Nullable Object&gt; MultimapBuilderWithKeys&lt;K0&gt; treeKeys(
      Comparator&lt;K0&gt; comparator) {
    checkNotNull(comparator);
    return new MultimapBuilderWithKeys&lt;K0&gt;() {
      @Override
      &lt;K extends K0, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap() {
        return new TreeMap&lt;&gt;(comparator);
      }
    };
  }

  /**
   * Uses an {@link EnumMap} to map keys to value collections.
   *
   * @since 16.0
   */
  public static &lt;K0 extends Enum&lt;K0&gt;&gt; MultimapBuilderWithKeys&lt;K0&gt; enumKeys(Class&lt;K0&gt; keyClass) {
    checkNotNull(keyClass);
    return new MultimapBuilderWithKeys&lt;K0&gt;() {
      @SuppressWarnings(&quot;unchecked&quot;)
      @Override
      &lt;K extends K0, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap() {
        // K must actually be K0, since enums are effectively final
        // (their subclasses are inaccessible)
        return (Map&lt;K, Collection&lt;V&gt;&gt;) new EnumMap&lt;K0, Collection&lt;V&gt;&gt;(keyClass);
      }
    };
  }

  private static final class ArrayListSupplier&lt;V extends @Nullable Object&gt;
      implements Supplier&lt;List&lt;V&gt;&gt;, Serializable {
    private final int expectedValuesPerKey;

    ArrayListSupplier(int expectedValuesPerKey) {
      this.expectedValuesPerKey = checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
    }

    @Override
    public List&lt;V&gt; get() {
      return new ArrayList&lt;&gt;(expectedValuesPerKey);
    }
  }

  private enum LinkedListSupplier implements Supplier&lt;List&lt;?&gt;&gt; {
    INSTANCE;

    public static &lt;V extends @Nullable Object&gt; Supplier&lt;List&lt;V&gt;&gt; instance() {
      // Each call generates a fresh LinkedList, which can serve as a List&lt;V&gt; for any V.
      @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
      Supplier&lt;List&lt;V&gt;&gt; result = (Supplier) INSTANCE;
      return result;
    }

    @Override
    public List&lt;?&gt; get() {
      return new LinkedList&lt;&gt;();
    }
  }
<A NAME="1"></A>
  private static final class HashSetSupplier&lt;V extends @Nullable Object&gt;
      implements Supplier&lt;Set&lt;V&gt;&gt;, Serializable {
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match761894-0.html#1',2,'match761894-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private final int expectedValuesPerKey;

    HashSetSupplier(int expectedValuesPerKey) {
      this.expectedValuesPerKey = checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
    }

    @Override
    public Set&lt;V&gt; get() {
      return Platform.newHashSetWithExpectedSize(expectedValuesPerKey);
    }</B></FONT>
  }

  private static final class LinkedHashSetSupplier&lt;V extends @Nullable Object&gt;
      implements Supplier&lt;Set&lt;V&gt;&gt;, Serializable {
    private final int expectedValuesPerKey;

    LinkedHashSetSupplier(int expectedValuesPerKey) {
      this.expectedValuesPerKey = checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
    }

    @Override
    public Set&lt;V&gt; get() {
      return Platform.newLinkedHashSetWithExpectedSize(expectedValuesPerKey);
    }
  }

  private static final class TreeSetSupplier&lt;V extends @Nullable Object&gt;
      implements Supplier&lt;SortedSet&lt;V&gt;&gt;, Serializable {
    private final Comparator&lt;? super V&gt; comparator;

    TreeSetSupplier(Comparator&lt;? super V&gt; comparator) {
      this.comparator = checkNotNull(comparator);
    }

    @Override
    public SortedSet&lt;V&gt; get() {
      return new TreeSet&lt;&gt;(comparator);
    }
  }

  private static final class EnumSetSupplier&lt;V extends Enum&lt;V&gt;&gt;
      implements Supplier&lt;Set&lt;V&gt;&gt;, Serializable {
    private final Class&lt;V&gt; clazz;

    EnumSetSupplier(Class&lt;V&gt; clazz) {
      this.clazz = checkNotNull(clazz);
    }

    @Override
    public Set&lt;V&gt; get() {
      return EnumSet.noneOf(clazz);
    }
  }

  /**
   * An intermediate stage in a {@link MultimapBuilder} in which the key-value collection map
   * implementation has been specified, but the value collection implementation has not.
   *
   * @param &lt;K0&gt; The upper bound on the key type of the generated multimap.
   * @since 16.0
   */
  public abstract static class MultimapBuilderWithKeys&lt;K0 extends @Nullable Object&gt; {

    private static final int DEFAULT_EXPECTED_VALUES_PER_KEY = 2;

    MultimapBuilderWithKeys() {}

    abstract &lt;K extends K0, V extends @Nullable Object&gt; Map&lt;K, Collection&lt;V&gt;&gt; createMap();

    /** Uses an {@link ArrayList} to store value collections. */
    public ListMultimapBuilder&lt;K0, @Nullable Object&gt; arrayListValues() {
      return arrayListValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
    }

    /**
     * Uses an {@link ArrayList} to store value collections, initialized to expect the specified
     * number of values per key.
     *
     * @throws IllegalArgumentException if {@code expectedValuesPerKey &lt; 0}
     */
    public ListMultimapBuilder&lt;K0, @Nullable Object&gt; arrayListValues(int expectedValuesPerKey) {
      checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
      return new ListMultimapBuilder&lt;K0, @Nullable Object&gt;() {
        @Override
        public &lt;K extends K0, V extends @Nullable Object&gt; ListMultimap&lt;K, V&gt; build() {
          return Multimaps.newListMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(),
              new ArrayListSupplier&lt;V&gt;(expectedValuesPerKey));
        }
      };
    }

    /** Uses a {@link LinkedList} to store value collections. */
    public ListMultimapBuilder&lt;K0, @Nullable Object&gt; linkedListValues() {
      return new ListMultimapBuilder&lt;K0, @Nullable Object&gt;() {
        @Override
        public &lt;K extends K0, V extends @Nullable Object&gt; ListMultimap&lt;K, V&gt; build() {
          return Multimaps.newListMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(), LinkedListSupplier.&lt;V&gt;instance());
        }
      };
    }

    /** Uses a hash-based {@code Set} to store value collections. */
    public SetMultimapBuilder&lt;K0, @Nullable Object&gt; hashSetValues() {
      return hashSetValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
    }

    /**
     * Uses a hash-based {@code Set} to store value collections, initialized to expect the specified
     * number of values per key.
     *
     * @throws IllegalArgumentException if {@code expectedValuesPerKey &lt; 0}
     */
    public SetMultimapBuilder&lt;K0, @Nullable Object&gt; hashSetValues(int expectedValuesPerKey) {
      checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
      return new SetMultimapBuilder&lt;K0, @Nullable Object&gt;() {
        @Override
        public &lt;K extends K0, V extends @Nullable Object&gt; SetMultimap&lt;K, V&gt; build() {
          return Multimaps.newSetMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(),
              new HashSetSupplier&lt;V&gt;(expectedValuesPerKey));
        }
      };
    }

    /** Uses an insertion-ordered hash-based {@code Set} to store value collections. */
    public SetMultimapBuilder&lt;K0, @Nullable Object&gt; linkedHashSetValues() {
      return linkedHashSetValues(DEFAULT_EXPECTED_VALUES_PER_KEY);
    }

    /**
     * Uses an insertion-ordered hash-based {@code Set} to store value collections, initialized to
     * expect the specified number of values per key.
     *
     * @throws IllegalArgumentException if {@code expectedValuesPerKey &lt; 0}
     */
    public SetMultimapBuilder&lt;K0, @Nullable Object&gt; linkedHashSetValues(int expectedValuesPerKey) {
      checkNonnegative(expectedValuesPerKey, &quot;expectedValuesPerKey&quot;);
      return new SetMultimapBuilder&lt;K0, @Nullable Object&gt;() {
        @Override
        public &lt;K extends K0, V extends @Nullable Object&gt; SetMultimap&lt;K, V&gt; build() {
          return Multimaps.newSetMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(),
              new LinkedHashSetSupplier&lt;V&gt;(expectedValuesPerKey));
        }
      };
    }

    /** Uses a naturally-ordered {@link TreeSet} to store value collections. */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public SortedSetMultimapBuilder&lt;K0, Comparable&gt; treeSetValues() {
      return treeSetValues(Ordering.natural());
    }

    /**
     * Uses a {@link TreeSet} ordered by the specified comparator to store value collections.
     *
     * &lt;p&gt;Multimaps generated by the resulting builder will not be serializable if {@code
     * comparator} is not serializable.
     */
    public &lt;V0 extends @Nullable Object&gt; SortedSetMultimapBuilder&lt;K0, V0&gt; treeSetValues(
        Comparator&lt;V0&gt; comparator) {
      checkNotNull(comparator, &quot;comparator&quot;);
      return new SortedSetMultimapBuilder&lt;K0, V0&gt;() {
        @Override
        public &lt;K extends K0, V extends V0&gt; SortedSetMultimap&lt;K, V&gt; build() {
          return Multimaps.newSortedSetMultimap(
              MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(), new TreeSetSupplier&lt;V&gt;(comparator));
        }
      };
    }

    /** Uses an {@link EnumSet} to store value collections. */
    public &lt;V0 extends Enum&lt;V0&gt;&gt; SetMultimapBuilder&lt;K0, V0&gt; enumSetValues(Class&lt;V0&gt; valueClass) {
      checkNotNull(valueClass, &quot;valueClass&quot;);
      return new SetMultimapBuilder&lt;K0, V0&gt;() {
        @Override
        public &lt;K extends K0, V extends V0&gt; SetMultimap&lt;K, V&gt; build() {
          // V must actually be V0, since enums are effectively final
          // (their subclasses are inaccessible)
          @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
          Supplier&lt;Set&lt;V&gt;&gt; factory = (Supplier) new EnumSetSupplier&lt;V0&gt;(valueClass);
          return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.&lt;K, V&gt;createMap(), factory);
        }
      };
    }
  }

  /** Returns a new, empty {@code Multimap} with the specified implementation. */
  public abstract &lt;K extends K0, V extends V0&gt; Multimap&lt;K, V&gt; build();

  /**
   * Returns a {@code Multimap} with the specified implementation, initialized with the entries of
   * {@code multimap}.
   */
  public &lt;K extends K0, V extends V0&gt; Multimap&lt;K, V&gt; build(
      Multimap&lt;? extends K, ? extends V&gt; multimap) {
    Multimap&lt;K, V&gt; result = build();
    result.putAll(multimap);
    return result;
  }

  /**
   * A specialization of {@link MultimapBuilder} that generates {@link ListMultimap} instances.
   *
   * @since 16.0
   */
  public abstract static class ListMultimapBuilder&lt;
          K0 extends @Nullable Object, V0 extends @Nullable Object&gt;
      extends MultimapBuilder&lt;K0, V0&gt; {
    ListMultimapBuilder() {}

    @Override
    public abstract &lt;K extends K0, V extends V0&gt; ListMultimap&lt;K, V&gt; build();

    @Override
    public &lt;K extends K0, V extends V0&gt; ListMultimap&lt;K, V&gt; build(
        Multimap&lt;? extends K, ? extends V&gt; multimap) {
      return (ListMultimap&lt;K, V&gt;) super.build(multimap);
    }
  }

  /**
   * A specialization of {@link MultimapBuilder} that generates {@link SetMultimap} instances.
   *
   * @since 16.0
   */
  public abstract static class SetMultimapBuilder&lt;
          K0 extends @Nullable Object, V0 extends @Nullable Object&gt;
      extends MultimapBuilder&lt;K0, V0&gt; {
    SetMultimapBuilder() {}

    @Override
    public abstract &lt;K extends K0, V extends V0&gt; SetMultimap&lt;K, V&gt; build();

    @Override
    public &lt;K extends K0, V extends V0&gt; SetMultimap&lt;K, V&gt; build(
        Multimap&lt;? extends K, ? extends V&gt; multimap) {
      return (SetMultimap&lt;K, V&gt;) super.build(multimap);
    }
  }

  /**
   * A specialization of {@link MultimapBuilder} that generates {@link SortedSetMultimap} instances.
   *
   * @since 16.0
   */
  public abstract static class SortedSetMultimapBuilder&lt;
          K0 extends @Nullable Object, V0 extends @Nullable Object&gt;
      extends SetMultimapBuilder&lt;K0, V0&gt; {
    SortedSetMultimapBuilder() {}

    @Override
    public abstract &lt;K extends K0, V extends V0&gt; SortedSetMultimap&lt;K, V&gt; build();

    @Override
    public &lt;K extends K0, V extends V0&gt; SortedSetMultimap&lt;K, V&gt; build(
        Multimap&lt;? extends K, ? extends V&gt; multimap) {
      return (SortedSetMultimap&lt;K, V&gt;) super.build(multimap);
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
