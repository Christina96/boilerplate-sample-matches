<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ChannelInitializerTest.java &amp; SSLEngineTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ChannelInitializerTest.java &amp; SSLEngineTest.java
      </h3>
<h1 align="center">
        8.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ChannelInitializerTest.java (53.084415%)<th>SSLEngineTest.java (4.8689694%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(16-46)<td><a href="#" name="0">(16-43)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(368-383)<td><a href="#" name="1">(3586-3600)</a><td align="center"><font color="#c60000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(301-313)<td><a href="#" name="2">(439-451)</a><td align="center"><font color="#c60000">21</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(148-153)<td><a href="#" name="3">(935-948)</a><td align="center"><font color="#a00000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(333-338)<td><a href="#" name="4">(1918-1924)</a><td align="center"><font color="#840000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(322-329)<td><a href="#" name="5">(1521-1526)</a><td align="center"><font color="#7a0000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(253-258)<td><a href="#" name="6">(2711-2721)</a><td align="center"><font color="#7a0000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(108-113)<td><a href="#" name="7">(3906-3910)</a><td align="center"><font color="#7a0000">13</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(188-195)<td><a href="#" name="8">(1269-1278)</a><td align="center"><font color="#710000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(155-162)<td><a href="#" name="9">(3065-3073)</a><td align="center"><font color="#710000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(126-130)<td><a href="#" name="10">(1912-1915)</a><td align="center"><font color="#710000">12</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(98-105)<td><a href="#" name="11">(179-186)</a><td align="center"><font color="#710000">12</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(168-173)<td><a href="#" name="12">(818-823)</a><td align="center"><font color="#670000">11</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(352-358)<td><a href="#" name="13">(896-902)</a><td align="center"><font color="#5e0000">10</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(340-346)<td><a href="#" name="14">(1499-1505)</a><td align="center"><font color="#5e0000">10</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(280-288)<td><a href="#" name="15">(211-221)</a><td align="center"><font color="#5e0000">10</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(360-362)<td><a href="#" name="16">(714-721)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(347-352)<td><a href="#" name="17">(845-850)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(291-295)<td><a href="#" name="18">(3692-3696)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(245-250)<td><a href="#" name="19">(752-758)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(238-241)<td><a href="#" name="20">(3895-3898)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(209-212)<td><a href="#" name="21">(1030-1033)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(198-201)<td><a href="#" name="22">(987-990)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(178-182)<td><a href="#" name="23">(3348-3360)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(138-142)<td><a href="#" name="24">(3143-3151)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(121-125)<td><a href="#" name="25">(863-867)</a><td align="center"><font color="#550000">9</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(59-63)<td><a href="#" name="26">(1510-1512)</a><td align="center"><font color="#550000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ChannelInitializerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.channel;
2 import io.netty.bootstrap.Bootstrap;
3 import io.netty.bootstrap.ServerBootstrap;
4 import io.netty.channel.embedded.EmbeddedChannel;
5 import io.netty.channel.local.LocalAddress;
6 import io.netty.channel.local.LocalChannel;
7 import io.netty.channel.local.LocalServerChannel;
8 import io.netty.util.concurrent.EventExecutor;
9 import io.netty.util.concurrent.Future;
10 import org.junit.jupiter.api.AfterEach;
11 import org.junit.jupiter.api.BeforeEach;
12 import org.junit.jupiter.api.Test;
13 import org.junit.jupiter.api.Timeout;
14 import java.util.Iterator;
15 import java.util.Map;
16 import java.util.concurrent.CountDownLatch;
17 import java.util.concurrent.Executors;
18 import java.util.concurrent.ScheduledExecutorService;
19 import java.util.concurrent.TimeUnit;
20 import java.util.concurrent.atomic.AtomicBoolean;
21 import java.util.concurrent.atomic.AtomicInteger;
22 import java.util.concurrent.atomic.AtomicReference;
23 import static org.junit.jupiter.api.Assertions.assertEquals;
24 import static org.junit.jupiter.api.Assertions.assertNotNull;
25 import static org.junit.jupiter.api.Assertions.assertTrue;
26 import static org.junit.jupiter.api.Assertions.assertFalse;
27 import</b></font> static org.junit.jupiter.api.Assertions.assertSame;
28 public class ChannelInitializerTest {
29     private static final int TIMEOUT_MILLIS = 1000;
30     private static final LocalAddress SERVER_ADDRESS = new LocalAddress("addr");
31     private EventLoopGroup group;
32     private ServerBootstrap server;
33     private Bootstrap client;
34     private InspectableHandler testHandler;
35 <a name="26"></a>    @BeforeEach
36     public void setUp() {
37         group = new DefaultEventLoopGroup(1);
38         <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>server = new ServerBootstrap()
39                 .group(group)
40                 .channel(LocalServerChannel.class)
41                 .localAddress(SERVER_ADDRESS);
42         client = new Bootstrap()</b></font>
43                 .group(group)
44                 .channel(LocalChannel.class)
45                 .handler(new ChannelInboundHandlerAdapter());
46         testHandler = new InspectableHandler();
47     }
48     @AfterEach
49     public void tearDown() {
50         group.shutdownGracefully(0, TIMEOUT_MILLIS, TimeUnit.MILLISECONDS).syncUninterruptibly();
51     }
52     @Test
53     public void testInitChannelThrowsRegisterFirst() {
54         testInitChannelThrows(true);
55     }
56     @Test
57     public void testInitChannelThrowsRegisterAfter() {
58         testInitChannelThrows(false);
59     }
60     private void testInitChannelThrows(boolean registerFirst) {
61         final Exception exception = new Exception();
62         final AtomicReference&lt;Throwable&gt; causeRef = new AtomicReference&lt;Throwable&gt;();
63         ChannelPipeline pipeline = new LocalChannel().pipeline();
64         if (registerFirst) {
65             group.register(pipeline.channel()).syncUninterruptibly();
66         }
67         pipeline.addFirst(new ChannelInitializer&lt;Channel&gt;() {
68 <a name="11"></a>            @Override
69             protected void initChannel(Channel ch) throws Exception {
70                 throw exception;
71             <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
72             @Override
73             public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
74                 causeRef.set(cause);
75                 super.exceptionCaught(ctx, cause);
76             }
77 <a name="7"></a>        }</b></font>);
78         if (!registerFirst) {
79             <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>group.register(pipeline.channel()).syncUninterruptibly();
80         }
81         pipeline.channel().close().syncUninterruptibly();
82         pipeline.channel().closeFuture().syncUninterruptibly();
83         assertSame(exception, causeRef.get</b></font>());
84     }
85     @Test
86     public void testChannelInitializerInInitializerCorrectOrdering() {
87 <a name="25"></a>        final ChannelInboundHandlerAdapter handler1 = new ChannelInboundHandlerAdapter();
88         final ChannelInboundHandlerAdapter handler2 = new ChannelInboundHandlerAdapter();
89         final ChannelInboundHandlerAdapter handler3 = new ChannelInboundHandlerAdapter();
90         final ChannelInboundHandlerAdapter handler4 = <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new ChannelInboundHandlerAdapter();
91 <a name="10"></a>        client.handler(new ChannelInitializer&lt;Channel&gt;() {
92             @Override
93             protected void initChannel(Channel ch) {</b></font>
94                 <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ch.pipeline().addLast(handler1);
95                 ch.pipeline().addLast(new ChannelInitializer&lt;Channel&gt;() {
96                     @Override
97                     protected void initChannel(Channel ch) {
98                         ch.pipeline</b></font>().addLast(handler2);
99                         ch.pipeline().addLast(handler3);
100                     }
101                 });
102                 ch.pipeline().addLast(handler4);
103 <a name="24"></a>            }
104         }).localAddress(LocalAddress.ANY);
105         Channel channel = <font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>client.bind().syncUninterruptibly().channel();
106         try {
107             channel.eventLoop</b></font>().submit(new Runnable() {
108                 @Override
109                 public void run() {
110 <a name="3"></a>                                    }
111             }).syncUninterruptibly();
112             <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Iterator&lt;Map.Entry&lt;String, ChannelHandler&gt;&gt; handlers = channel.pipeline().iterator();
113             assertSame(handler1, handlers.next().getValue());
114             assertSame(handler2, handlers.next().getValue());
115             assertSame(handler3, handlers.next().getValue());
116 <a name="9"></a>            assertSame(handler4, handlers.next().getValue());
117             assertFalse(handlers.hasNext</b></font>());
118         } finally {
119             <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.close().syncUninterruptibly();
120         }
121     }
122     @Test
123     public void testChannelInitializerReentrance() {
124         final AtomicInteger registeredCalled = new AtomicInteger(0);
125         final ChannelInboundHandlerAdapter handler1 = new</b></font> ChannelInboundHandlerAdapter() {
126             @Override
127             public void channelRegistered(ChannelHandlerContext ctx) {
128 <a name="12"></a>                registeredCalled.incrementAndGet();
129             }
130         };
131         final AtomicInteger initChannelCalled = <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new AtomicInteger(0);
132         client.handler(new ChannelInitializer&lt;Channel&gt;() {
133             @Override
134             protected void initChannel(Channel ch) {
135                 initChannelCalled.incrementAndGet();
136                 ch.pipeline().addLast</b></font>(handler1);
137                 ch.pipeline().fireChannelRegistered();
138 <a name="23"></a>            }
139         }).localAddress(LocalAddress.ANY);
140         Channel channel = <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>client.bind().syncUninterruptibly().channel();
141         try {
142             channel.eventLoop</b></font>().submit(new Runnable() {
143                 @Override
144                 public void run() {
145 <a name="8"></a>                                    }
146             }).syncUninterruptibly();
147             <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertEquals(1, initChannelCalled.get());
148             assertEquals(2, registeredCalled.get());
149         } finally {
150             channel.close().syncUninterruptibly();
151         }
152     }
153 <a name="22"></a>    @Test</b></font>
154     @Timeout(value = TIMEOUT_MILLIS, unit = TimeUnit.MILLISECONDS)
155     public void firstHandlerInPipelineShouldReceiveChannelRegisteredEvent() {
156         <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>testChannelRegisteredEventPropagation(new ChannelInitializer&lt;LocalChannel&gt;() {
157             @Override
158             public void initChannel(LocalChannel channel) {
159                 channel.pipeline</b></font>().addFirst(testHandler);
160             }
161         });
162     }
163 <a name="21"></a>    @Test
164     @Timeout(value = TIMEOUT_MILLIS, unit = TimeUnit.MILLISECONDS)
165     public void lastHandlerInPipelineShouldReceiveChannelRegisteredEvent() {
166         <font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>testChannelRegisteredEventPropagation(new ChannelInitializer&lt;LocalChannel&gt;() {
167             @Override
168             public void initChannel(LocalChannel channel) {
169                 channel.pipeline</b></font>().addLast(testHandler);
170             }
171         });
172     }
173     @Test
174     public void testAddFirstChannelInitializer() {
175         testAddChannelInitializer(true);
176     }
177     @Test
178     public void testAddLastChannelInitializer() {
179         testAddChannelInitializer(false);
180     }
181     private static void testAddChannelInitializer(final boolean first) {
182         final AtomicBoolean called = new AtomicBoolean();
183         EmbeddedChannel channel = new EmbeddedChannel(new ChannelInitializer&lt;Channel&gt;() {
184             @Override
185             protected void initChannel(Channel ch) {
186                 ChannelHandler handler = new ChannelInitializer&lt;Channel&gt;() {
187                     @Override
188                     protected void initChannel(Channel ch) {
189 <a name="20"></a>                        called.set(true);
190                     }
191                 };
192                 <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if (first) {
193                     ch.pipeline().addFirst(handler);
194                 } else {
195                     ch.pipeline</b></font>().addLast(handler);
196 <a name="19"></a>                }
197             }
198         });
199         <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.finish();
200         assertTrue(called.get());
201     }
202     private void testChannelRegisteredEventPropagation(ChannelInitializer&lt;LocalChannel&gt; init) {
203 <a name="6"></a>        Channel clientChannel = null</b></font>, serverChannel = null;
204         try {
205             server.childHandler(init);
206             serverChannel = <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>server.bind().syncUninterruptibly().channel();
207             clientChannel = client.connect(SERVER_ADDRESS).syncUninterruptibly().channel();
208             assertEquals(1, testHandler.channelRegisteredCount.get());
209         } finally {
210             closeChannel(clientChannel);
211             closeChannel</b></font>(serverChannel);
212         }
213     }
214     @SuppressWarnings("deprecation")
215     @Test
216     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
217     public void testChannelInitializerEventExecutor() throws Throwable {
218         final AtomicInteger invokeCount = new AtomicInteger();
219         final AtomicInteger completeCount = new AtomicInteger();
220         final AtomicReference&lt;Throwable&gt; errorRef = new AtomicReference&lt;Throwable&gt;();
221         LocalAddress addr = new LocalAddress("test");
222         final EventExecutor executor = new DefaultEventLoop() {
223             private final ScheduledExecutorService execService = Executors.newSingleThreadScheduledExecutor();
224             @Override
225             public void shutdown() {
226                 execService.shutdown();
227 <a name="15"></a>            }
228             @Override
229             public boolean inEventLoop(Thread thread) <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
230                 return false;
231             }
232             @Override
233             public boolean isShuttingDown() {
234                 return false;
235 <a name="18"></a>            }</b></font>
236             @Override
237             public Future&lt;?&gt; shutdownGracefully(long quietPeriod, <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>long timeout, TimeUnit unit) {
238                 throw new IllegalStateException();
239             }
240             @</b></font>Override
241             public Future&lt;?&gt; terminationFuture() {
242                 throw new IllegalStateException();
243 <a name="2"></a>            }
244             @Override
245             public boolean isShutdown() <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
246                 return execService.isShutdown();
247             }
248             @Override
249             public boolean isTerminated() {
250                 return execService.isTerminated();
251             }
252             @Override
253             public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
254                 return execService.awaitTermination(timeout, unit);
255             }</b></font>
256             @Override
257             public void execute(Runnable command) {
258                 execService.execute(command);
259             }
260 <a name="5"></a>        };
261         final CountDownLatch latch = new CountDownLatch(1);
262         ServerBootstrap serverBootstrap = <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new ServerBootstrap()
263                 .channel(LocalServerChannel.class)
264                 .group(group)
265                 .localAddress(addr)
266                 .childHandler(new ChannelInitializer&lt;LocalChannel&gt;() {
267                     @Override
268                     protected void initChannel(LocalChannel ch) {
269                         ch.pipeline().addLast(executor, new</b></font> ChannelInitializer&lt;Channel&gt;() {
270 <a name="4"></a>                            @Override
271                             protected void initChannel(Channel ch) {
272                                 invokeCount.incrementAndGet();
273                                 ChannelHandlerContext ctx = <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ch.pipeline().context(this);
274                                 assertNotNull(ctx);
275                                 ch.pipeline().addAfter(ctx.executor(),
276                                         ctx.name(), null, new ChannelInboundHandlerAdapter() {
277 <a name="14"></a>                                            @Override
278                                             public void channelRead(ChannelHandlerContext ctx, Object msg)  {</b></font>
279                                             <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
280                                             @Override
281                                             public void handlerRemoved(ChannelHandlerContext ctx) {
282 <a name="17"></a>                                                latch.countDown();
283                                             }
284                                         }</b></font>);
285                                 <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>completeCount.incrementAndGet();
286                             }
287 <a name="13"></a>
288                             @Override
289                             public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
290                                 if</b></font> (cause instanceof AssertionError) <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
291                                     errorRef.set(cause);
292                                 }
293                             }
294                         });
295 <a name="16"></a>                    }
296                 }</b></font>);
297         <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Channel server = serverBootstrap.bind().sync().channel();
298         Bootstrap clientBootstrap = new Bootstrap()</b></font>
299                 .channel(LocalChannel.class)
300                 .group(group)
301 <a name="1"></a>                .remoteAddress(addr)
302                 .handler(new ChannelInboundHandlerAdapter());
303         Channel client = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>clientBootstrap.connect().sync().channel();
304         client.writeAndFlush("Hello World").sync();
305         client.close().sync();
306         server.close().sync();
307         client.closeFuture().sync();
308         server.closeFuture().sync();
309         latch.await();
310         assertEquals(1, invokeCount.get());
311         assertEquals(invokeCount.get(), completeCount.get());
312         Throwable cause = errorRef.get</b></font>();
313         if (cause != null) {
314             throw cause;
315         }
316         executor.shutdown();
317         assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));
318     }
319     private static void closeChannel(Channel c) {
320         if (c != null) {
321             c.close().syncUninterruptibly();
322         }
323     }
324     private static final class InspectableHandler extends ChannelDuplexHandler {
325         final AtomicInteger channelRegisteredCount = new AtomicInteger(0);
326         @Override
327         public void channelRegistered(ChannelHandlerContext ctx) {
328             channelRegisteredCount.incrementAndGet();
329             ctx.fireChannelRegistered();
330         }
331     }
332 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>SSLEngineTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.handler.ssl;
2 import io.netty.bootstrap.Bootstrap;
3 import io.netty.bootstrap.ServerBootstrap;
4 import io.netty.buffer.ByteBuf;
5 import io.netty.buffer.ByteBufAllocator;
6 import io.netty.buffer.CompositeByteBuf;
7 import io.netty.buffer.Unpooled;
8 import io.netty.buffer.UnpooledByteBufAllocator;
9 import io.netty.channel.Channel;
10 import io.netty.channel.ChannelFuture;
11 import io.netty.channel.ChannelHandlerContext;
12 import io.netty.channel.ChannelInboundHandlerAdapter;
13 import io.netty.channel.ChannelInitializer;
14 import io.netty.channel.ChannelPipeline;
15 import io.netty.channel.SimpleChannelInboundHandler;
16 import io.netty.channel.nio.NioEventLoopGroup;
17 import io.netty.channel.socket.SocketChannel;
18 import io.netty.channel.socket.nio.NioServerSocketChannel;
19 import io.netty.channel.socket.nio.NioSocketChannel;
20 import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;
21 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
22 import io.netty.handler.ssl.util.SelfSignedCertificate;
23 import io.netty.handler.ssl.util.SimpleTrustManagerFactory;
24 import io.netty.util.CharsetUtil;
25 import io.netty.util.NetUtil;
26 import io.netty.util.ReferenceCountUtil;
27 import</b></font> io.netty.util.concurrent.ImmediateEventExecutor;
28 import io.netty.util.concurrent.PromiseNotifier;
29 import io.netty.util.internal.ResourcesUtil;
30 import io.netty.util.concurrent.Future;
31 import io.netty.util.concurrent.Promise;
32 import io.netty.util.internal.EmptyArrays;
33 import io.netty.util.internal.PlatformDependent;
34 import io.netty.util.internal.StringUtil;
35 import io.netty.util.internal.SystemPropertyUtil;
36 import org.conscrypt.OpenSSLProvider;
37 import org.junit.jupiter.api.AfterEach;
38 import org.junit.jupiter.api.BeforeEach;
39 import org.junit.jupiter.api.Test;
40 import org.junit.jupiter.api.TestInstance;
41 import org.junit.jupiter.api.Timeout;
42 import org.junit.jupiter.api.function.Executable;
43 import org.junit.jupiter.params.ParameterizedTest;
44 import org.junit.jupiter.params.provider.MethodSource;
45 import org.mockito.ArgumentCaptor;
46 import org.mockito.Mock;
47 import org.mockito.MockitoAnnotations;
48 import org.opentest4j.AssertionFailedError;
49 import java.io.ByteArrayInputStream;
50 import java.io.ByteArrayOutputStream;
51 import java.io.Closeable;
52 import java.io.File;
53 import java.io.FileInputStream;
54 import java.io.IOException;
55 import java.io.InputStream;
56 import java.io.OutputStream;
57 import java.net.InetSocketAddress;
58 import java.net.Socket;
59 import java.nio.ByteBuffer;
60 import java.nio.channels.ClosedChannelException;
61 import java.nio.file.Files;
62 import java.security.KeyStore;
63 import java.security.KeyStoreException;
64 import java.security.NoSuchAlgorithmException;
65 import java.security.Principal;
66 import java.security.PrivateKey;
67 import java.security.Provider;
68 import java.security.UnrecoverableKeyException;
69 import java.security.cert.Certificate;
70 import java.security.cert.CertificateException;
71 import java.util.ArrayList;
72 import java.util.Arrays;
73 import java.util.Collections;
74 import java.util.Enumeration;
75 import java.util.HashSet;
76 import java.util.List;
77 import java.util.Set;
78 import java.util.concurrent.CountDownLatch;
79 import java.util.concurrent.ExecutorService;
80 import java.util.concurrent.Executors;
81 import java.util.concurrent.TimeUnit;
82 import javax.crypto.SecretKey;
83 import javax.net.ssl.ExtendedSSLSession;
84 import javax.net.ssl.KeyManager;
85 import javax.net.ssl.KeyManagerFactory;
86 import javax.net.ssl.KeyManagerFactorySpi;
87 import javax.net.ssl.ManagerFactoryParameters;
88 import javax.net.ssl.SNIHostName;
89 import javax.net.ssl.SNIServerName;
90 import javax.net.ssl.SSLContext;
91 import javax.net.ssl.SSLEngine;
92 import javax.net.ssl.SSLEngineResult;
93 import javax.net.ssl.SSLEngineResult.Status;
94 import javax.net.ssl.SSLException;
95 import javax.net.ssl.SSLHandshakeException;
96 import javax.net.ssl.SSLParameters;
97 import javax.net.ssl.SSLPeerUnverifiedException;
98 import javax.net.ssl.SSLSession;
99 import javax.net.ssl.SSLSessionBindingEvent;
100 import javax.net.ssl.SSLSessionBindingListener;
101 import javax.net.ssl.SSLSessionContext;
102 import javax.net.ssl.SSLSocketFactory;
103 import javax.net.ssl.TrustManager;
104 import javax.net.ssl.TrustManagerFactory;
105 import javax.net.ssl.TrustManagerFactorySpi;
106 import javax.net.ssl.X509ExtendedKeyManager;
107 import javax.net.ssl.X509ExtendedTrustManager;
108 import javax.net.ssl.X509TrustManager;
109 import javax.security.cert.X509Certificate;
110 import static io.netty.handler.ssl.SslUtils.*;
111 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
112 import static org.junit.jupiter.api.Assertions.assertEquals;
113 import static org.junit.jupiter.api.Assertions.assertFalse;
114 import static org.junit.jupiter.api.Assertions.assertNotEquals;
115 import static org.junit.jupiter.api.Assertions.assertNotNull;
116 import static org.junit.jupiter.api.Assertions.assertNull;
117 import static org.junit.jupiter.api.Assertions.assertSame;
118 import static org.junit.jupiter.api.Assertions.assertThrows;
119 import static org.junit.jupiter.api.Assertions.assertTrue;
120 import static org.junit.jupiter.api.Assertions.fail;
121 import static org.junit.jupiter.api.Assumptions.assumeFalse;
122 import static org.junit.jupiter.api.Assumptions.assumeTrue;
123 import static org.mockito.Mockito.verify;
124 @TestInstance(TestInstance.Lifecycle.PER_CLASS)
125 public abstract class SSLEngineTest {
126     private static final String PRINCIPAL_NAME = "CN=e8ac02fa0d65a84219016045db8b05c485b4ecdf.netty.test";
127     private final boolean tlsv13Supported;
128     @Mock
129     protected MessageReceiver serverReceiver;
130     @Mock
131     protected MessageReceiver clientReceiver;
132     protected Throwable serverException;
133     protected Throwable clientException;
134     protected SslContext serverSslCtx;
135     protected SslContext clientSslCtx;
136     protected ServerBootstrap sb;
137     protected Bootstrap cb;
138     protected Channel serverChannel;
139     protected Channel serverConnectedChannel;
140     protected Channel clientChannel;
141     protected CountDownLatch serverLatch;
142     protected CountDownLatch clientLatch;
143     interface MessageReceiver {
144         void messageReceived(ByteBuf msg);
145     }
146     protected static final class MessageDelegatorChannelHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {
147         private final MessageReceiver receiver;
148         private final CountDownLatch latch;
149         public MessageDelegatorChannelHandler(MessageReceiver receiver, CountDownLatch latch) {
150 <a name="11"></a>            super(false);
151             this.receiver = receiver;
152             this.latch = latch;
153         <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
154         @Override
155         protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
156             receiver.messageReceived(msg);
157             latch.countDown();
158         }
159     }</b></font>
160     enum BufferType {
161         Direct,
162         Heap,
163         Mixed
164     }
165     static final class ProtocolCipherCombo {
166         private static final ProtocolCipherCombo TLSV12 = new ProtocolCipherCombo(
167                 SslProtocols.TLS_v1_2, "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256");
168         private static final ProtocolCipherCombo TLSV13 = new ProtocolCipherCombo(
169                 SslProtocols.TLS_v1_3, "TLS_AES_128_GCM_SHA256");
170         final String protocol;
171         final String cipher;
172         private ProtocolCipherCombo(String protocol, String cipher) {
173             this.protocol = protocol;
174             this.cipher = cipher;
175         }
176         static ProtocolCipherCombo tlsv12() {
177 <a name="15"></a>            return TLSV12;
178         }
179         static ProtocolCipherCombo tlsv13() <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
180             return TLSV13;
181         }
182         @Override
183         public String toString() {
184             return "ProtocolCipherCombo{" +
185                    "protocol='" + protocol + '\'' +
186                    ", cipher='" + cipher + '\'' +
187                    '}';
188         }</b></font>
189     }
190     protected SSLEngineTest(boolean tlsv13Supported) {
191         this.tlsv13Supported = tlsv13Supported;
192     }
193     protected static class SSLEngineTestParam {
194         private final BufferType type;
195         private final ProtocolCipherCombo protocolCipherCombo;
196         private final boolean delegate;
197         SSLEngineTestParam(BufferType type, ProtocolCipherCombo protocolCipherCombo, boolean delegate) {
198             this.type = type;
199             this.protocolCipherCombo = protocolCipherCombo;
200             this.delegate = delegate;
201         }
202         final BufferType type() {
203             return type;
204         }
205         final ProtocolCipherCombo combo() {
206             return protocolCipherCombo;
207         }
208         final boolean delegate() {
209             return delegate;
210         }
211         final List&lt;String&gt; protocols() {
212             return Collections.singletonList(protocolCipherCombo.protocol);
213         }
214         final List&lt;String&gt; ciphers() {
215             return Collections.singletonList(protocolCipherCombo.cipher);
216         }
217     }
218     protected List&lt;SSLEngineTestParam&gt; newTestParams() {
219         List&lt;SSLEngineTestParam&gt; params = new ArrayList&lt;SSLEngineTestParam&gt;();
220         for (BufferType type: BufferType.values()) {
221             params.add(new SSLEngineTestParam(type, ProtocolCipherCombo.tlsv12(), false));
222             params.add(new SSLEngineTestParam(type, ProtocolCipherCombo.tlsv12(), true));
223             if (tlsv13Supported) {
224                 params.add(new SSLEngineTestParam(type, ProtocolCipherCombo.tlsv13(), false));
225                 params.add(new SSLEngineTestParam(type, ProtocolCipherCombo.tlsv13(), true));
226             }
227         }
228         return params;
229     }
230     private ExecutorService delegatingExecutor;
231     protected ByteBuffer allocateBuffer(BufferType type, int len) {
232         switch (type) {
233             case Direct:
234                 return ByteBuffer.allocateDirect(len);
235             case Heap:
236                 return ByteBuffer.allocate(len);
237             case Mixed:
238                 return PlatformDependent.threadLocalRandom().nextBoolean() ?
239                         ByteBuffer.allocateDirect(len) : ByteBuffer.allocate(len);
240             default:
241                 throw new Error();
242         }
243     }
244     private static final class TestByteBufAllocator implements ByteBufAllocator {
245         private final ByteBufAllocator allocator;
246         private final BufferType type;
247         TestByteBufAllocator(ByteBufAllocator allocator, BufferType type) {
248             this.allocator = allocator;
249             this.type = type;
250         }
251         @Override
252         public ByteBuf buffer() {
253             switch (type) {
254                 case Direct:
255                     return allocator.directBuffer();
256                 case Heap:
257                     return allocator.heapBuffer();
258                 case Mixed:
259                     return PlatformDependent.threadLocalRandom().nextBoolean() ?
260                             allocator.directBuffer() : allocator.heapBuffer();
261                 default:
262                     throw new Error();
263             }
264         }
265         @Override
266         public ByteBuf buffer(int initialCapacity) {
267             switch (type) {
268                 case Direct:
269                     return allocator.directBuffer(initialCapacity);
270                 case Heap:
271                     return allocator.heapBuffer(initialCapacity);
272                 case Mixed:
273                     return PlatformDependent.threadLocalRandom().nextBoolean() ?
274                             allocator.directBuffer(initialCapacity) : allocator.heapBuffer(initialCapacity);
275                 default:
276                     throw new Error();
277             }
278         }
279         @Override
280         public ByteBuf buffer(int initialCapacity, int maxCapacity) {
281             switch (type) {
282                 case Direct:
283                     return allocator.directBuffer(initialCapacity, maxCapacity);
284                 case Heap:
285                     return allocator.heapBuffer(initialCapacity, maxCapacity);
286                 case Mixed:
287                     return PlatformDependent.threadLocalRandom().nextBoolean() ?
288                             allocator.directBuffer(initialCapacity, maxCapacity) :
289                             allocator.heapBuffer(initialCapacity, maxCapacity);
290                 default:
291                     throw new Error();
292             }
293         }
294         @Override
295         public ByteBuf ioBuffer() {
296             return allocator.ioBuffer();
297         }
298         @Override
299         public ByteBuf ioBuffer(int initialCapacity) {
300             return allocator.ioBuffer(initialCapacity);
301         }
302         @Override
303         public ByteBuf ioBuffer(int initialCapacity, int maxCapacity) {
304             return allocator.ioBuffer(initialCapacity, maxCapacity);
305         }
306         @Override
307         public ByteBuf heapBuffer() {
308             return allocator.heapBuffer();
309         }
310         @Override
311         public ByteBuf heapBuffer(int initialCapacity) {
312             return allocator.heapBuffer(initialCapacity);
313         }
314         @Override
315         public ByteBuf heapBuffer(int initialCapacity, int maxCapacity) {
316             return allocator.heapBuffer(initialCapacity, maxCapacity);
317         }
318         @Override
319         public ByteBuf directBuffer() {
320             return allocator.directBuffer();
321         }
322         @Override
323         public ByteBuf directBuffer(int initialCapacity) {
324             return allocator.directBuffer(initialCapacity);
325         }
326         @Override
327         public ByteBuf directBuffer(int initialCapacity, int maxCapacity) {
328             return allocator.directBuffer(initialCapacity, maxCapacity);
329         }
330         @Override
331         public CompositeByteBuf compositeBuffer() {
332             switch (type) {
333                 case Direct:
334                     return allocator.compositeDirectBuffer();
335                 case Heap:
336                     return allocator.compositeHeapBuffer();
337                 case Mixed:
338                     return PlatformDependent.threadLocalRandom().nextBoolean() ?
339                             allocator.compositeDirectBuffer() :
340                             allocator.compositeHeapBuffer();
341                 default:
342                     throw new Error();
343             }
344         }
345         @Override
346         public CompositeByteBuf compositeBuffer(int maxNumComponents) {
347             switch (type) {
348                 case Direct:
349                     return allocator.compositeDirectBuffer(maxNumComponents);
350                 case Heap:
351                     return allocator.compositeHeapBuffer(maxNumComponents);
352                 case Mixed:
353                     return PlatformDependent.threadLocalRandom().nextBoolean() ?
354                             allocator.compositeDirectBuffer(maxNumComponents) :
355                             allocator.compositeHeapBuffer(maxNumComponents);
356                 default:
357                     throw new Error();
358             }
359         }
360         @Override
361         public CompositeByteBuf compositeHeapBuffer() {
362             return allocator.compositeHeapBuffer();
363         }
364         @Override
365         public CompositeByteBuf compositeHeapBuffer(int maxNumComponents) {
366             return allocator.compositeHeapBuffer(maxNumComponents);
367         }
368         @Override
369         public CompositeByteBuf compositeDirectBuffer() {
370             return allocator.compositeDirectBuffer();
371 <a name="2"></a>        }
372         @Override
373         public CompositeByteBuf compositeDirectBuffer(int maxNumComponents) <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
374             return allocator.compositeDirectBuffer(maxNumComponents);
375         }
376         @Override
377         public boolean isDirectBufferPooled() {
378             return allocator.isDirectBufferPooled();
379         }
380         @Override
381         public int calculateNewCapacity(int minNewCapacity, int maxCapacity) {
382             return allocator.calculateNewCapacity(minNewCapacity, maxCapacity);
383         }</b></font>
384     }
385     @BeforeEach
386     public void setup() {
387         MockitoAnnotations.initMocks(this);
388         serverLatch = new CountDownLatch(1);
389         clientLatch = new CountDownLatch(1);
390         delegatingExecutor = Executors.newCachedThreadPool();
391     }
392     @AfterEach
393     public void tearDown() throws InterruptedException {
394         ChannelFuture clientCloseFuture = null;
395         ChannelFuture serverConnectedCloseFuture = null;
396         ChannelFuture serverCloseFuture = null;
397         if (clientChannel != null) {
398             clientCloseFuture = clientChannel.close();
399             clientChannel = null;
400         }
401         if (serverConnectedChannel != null) {
402             serverConnectedCloseFuture = serverConnectedChannel.close();
403             serverConnectedChannel = null;
404         }
405         if (serverChannel != null) {
406             serverCloseFuture = serverChannel.close();
407             serverChannel = null;
408         }
409         //
410         if (clientCloseFuture != null) {
411             clientCloseFuture.sync();
412         }
413         if (serverConnectedCloseFuture != null) {
414             serverConnectedCloseFuture.sync();
415         }
416         if (serverCloseFuture != null) {
417             serverCloseFuture.sync();
418         }
419         if (serverSslCtx != null) {
420             cleanupServerSslContext(serverSslCtx);
421             serverSslCtx = null;
422         }
423         if (clientSslCtx != null) {
424             cleanupClientSslContext(clientSslCtx);
425             clientSslCtx = null;
426         }
427         Future&lt;?&gt; serverGroupShutdownFuture = null;
428         Future&lt;?&gt; serverChildGroupShutdownFuture = null;
429         Future&lt;?&gt; clientGroupShutdownFuture = null;
430         if (sb != null) {
431             serverGroupShutdownFuture = sb.config().group().shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);
432             serverChildGroupShutdownFuture = sb.config().childGroup().shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);
433         }
434         if (cb != null) {
435             clientGroupShutdownFuture = cb.config().group().shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);
436         }
437         if (serverGroupShutdownFuture != null) {
438             serverGroupShutdownFuture.sync();
439             serverChildGroupShutdownFuture.sync();
440         }
441         if (clientGroupShutdownFuture != null) {
442             clientGroupShutdownFuture.sync();
443         }
444         delegatingExecutor.shutdown();
445         serverException = null;
446         clientException = null;
447     }
448     @MethodSource("newTestParams")
449     @ParameterizedTest
450     public void testMutualAuthSameCerts(SSLEngineTestParam param) throws Throwable {
451         mySetupMutualAuth(param, ResourcesUtil.getFile(getClass(), "test_unencrypted.pem"),
452                 ResourcesUtil.getFile(getClass(), "test.crt"),
453                 null);
454         runTest(null);
455         assertTrue(serverLatch.await(2, TimeUnit.SECONDS));
456         Throwable cause = serverException;
457         if (cause != null) {
458             throw cause;
459         }
460     }
461     @MethodSource("newTestParams")
462     @ParameterizedTest
463     public void testSetSupportedCiphers(SSLEngineTestParam param) throws Exception {
464         if (param.protocolCipherCombo != ProtocolCipherCombo.tlsv12()) {
465             return;
466         }
467         SelfSignedCertificate cert = new SelfSignedCertificate();
468         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(cert.key(), cert.cert())
469             .protocols(param.protocols())
470             .ciphers(param.ciphers())
471             .sslProvider(sslServerProvider()).build());
472         final SSLEngine serverEngine =
473             wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
474         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
475             .trustManager(cert.certificate())
476             .protocols(param.protocols())
477             .ciphers(param.ciphers())
478             .sslProvider(sslClientProvider()).build());
479         final SSLEngine clientEngine =
480             wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
481         final String[] enabledCiphers = new String[]{ param.ciphers().get(0) };
482         try {
483             clientEngine.setEnabledCipherSuites(enabledCiphers);
484             serverEngine.setEnabledCipherSuites(enabledCiphers);
485             assertArrayEquals(enabledCiphers, clientEngine.getEnabledCipherSuites());
486             assertArrayEquals(enabledCiphers, serverEngine.getEnabledCipherSuites());
487         } finally {
488             cleanupClientSslEngine(clientEngine);
489             cleanupServerSslEngine(serverEngine);
490             cert.delete();
491         }
492     }
493     @MethodSource("newTestParams")
494     @ParameterizedTest
495     public void testIncompatibleCiphers(final SSLEngineTestParam param) throws Exception {
496         assumeTrue(SslProvider.isTlsv13Supported(sslClientProvider()));
497         assumeTrue(SslProvider.isTlsv13Supported(sslServerProvider()));
498         SelfSignedCertificate ssc = new SelfSignedCertificate();
499         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
500                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
501                 .protocols(SslProtocols.TLS_v1_3, SslProtocols.TLS_v1_2, SslProtocols.TLS_v1)
502                 .sslContextProvider(clientSslContextProvider())
503                 .sslProvider(sslClientProvider())
504                 .build());
505         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
506                 .protocols(SslProtocols.TLS_v1_3, SslProtocols.TLS_v1_2, SslProtocols.TLS_v1)
507                 .sslContextProvider(serverSslContextProvider())
508                 .sslProvider(sslServerProvider())
509                 .build());
510         SSLEngine clientEngine = null;
511         SSLEngine serverEngine = null;
512         try {
513             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
514             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
515             final String serverCipher = "TLS_RSA_WITH_AES_128_CBC_SHA";
516             serverEngine.setEnabledCipherSuites(new String[] { serverCipher });
517             final String clientCipher = "TLS_AES_256_GCM_SHA384";
518             clientEngine.setEnabledCipherSuites(new String[] { clientCipher });
519             final SSLEngine client = clientEngine;
520             final SSLEngine server = serverEngine;
521             assertThrows(SSLHandshakeException.class, new Executable() {
522                 @Override
523                 public void execute() throws Throwable {
524                     handshake(param.type(), param.delegate(), client, server);
525                 }
526             });
527         } finally {
528             cleanupClientSslEngine(clientEngine);
529             cleanupServerSslEngine(serverEngine);
530             ssc.delete();
531         }
532     }
533     @MethodSource("newTestParams")
534     @ParameterizedTest
535     public void testMutualAuthDiffCerts(SSLEngineTestParam param) throws Exception {
536         File serverKeyFile =  ResourcesUtil.getFile(getClass(), "test_encrypted.pem");
537         File serverCrtFile = ResourcesUtil.getFile(getClass(), "test.crt");
538         String serverKeyPassword = "12345";
539         File clientKeyFile = ResourcesUtil.getFile(getClass(), "test2_encrypted.pem");
540         File clientCrtFile = ResourcesUtil.getFile(getClass(), "test2.crt");
541         String clientKeyPassword = "12345";
542         mySetupMutualAuth(param, clientCrtFile, serverKeyFile, serverCrtFile, serverKeyPassword,
543                           serverCrtFile, clientKeyFile, clientCrtFile, clientKeyPassword);
544         runTest(null);
545         assertTrue(serverLatch.await(2, TimeUnit.SECONDS));
546     }
547     @MethodSource("newTestParams")
548     @ParameterizedTest
549     public void testMutualAuthDiffCertsServerFailure(SSLEngineTestParam param) throws Exception {
550         File serverKeyFile = ResourcesUtil.getFile(getClass(), "test_encrypted.pem");
551         File serverCrtFile = ResourcesUtil.getFile(getClass(), "test.crt");
552         String serverKeyPassword = "12345";
553         File clientKeyFile = ResourcesUtil.getFile(getClass(), "test2_encrypted.pem");
554         File clientCrtFile = ResourcesUtil.getFile(getClass(), "test2.crt");
555         String clientKeyPassword = "12345";
556         mySetupMutualAuth(param, serverCrtFile, serverKeyFile, serverCrtFile, serverKeyPassword,
557                           serverCrtFile, clientKeyFile, clientCrtFile, clientKeyPassword);
558         assertTrue(serverLatch.await(10, TimeUnit.SECONDS));
559         assertTrue(serverException instanceof SSLHandshakeException);
560     }
561     @MethodSource("newTestParams")
562     @ParameterizedTest
563     public void testMutualAuthDiffCertsClientFailure(SSLEngineTestParam param) throws Exception {
564         File serverKeyFile = ResourcesUtil.getFile(getClass(), "test_unencrypted.pem");
565         File serverCrtFile = ResourcesUtil.getFile(getClass(), "test.crt");
566         String serverKeyPassword = null;
567         File clientKeyFile = ResourcesUtil.getFile(getClass(), "test2_unencrypted.pem");
568         File clientCrtFile = ResourcesUtil.getFile(getClass(), "test2.crt");
569         String clientKeyPassword = null;
570         mySetupMutualAuth(param, clientCrtFile, serverKeyFile, serverCrtFile, serverKeyPassword,
571                           clientCrtFile, clientKeyFile, clientCrtFile, clientKeyPassword);
572         assertTrue(clientLatch.await(10, TimeUnit.SECONDS));
573         assertTrue(clientException instanceof SSLHandshakeException);
574     }
575     @MethodSource("newTestParams")
576     @ParameterizedTest
577     public void testMutualAuthInvalidIntermediateCASucceedWithOptionalClientAuth(SSLEngineTestParam param)
578             throws Exception {
579         testMutualAuthInvalidClientCertSucceed(param, ClientAuth.NONE);
580     }
581     @MethodSource("newTestParams")
582     @ParameterizedTest
583     public void testMutualAuthInvalidIntermediateCAFailWithOptionalClientAuth(SSLEngineTestParam param)
584             throws Exception {
585         testMutualAuthClientCertFail(param, ClientAuth.OPTIONAL);
586     }
587     @MethodSource("newTestParams")
588     @ParameterizedTest
589     public void testMutualAuthInvalidIntermediateCAFailWithRequiredClientAuth(SSLEngineTestParam param)
590             throws Exception {
591         testMutualAuthClientCertFail(param, ClientAuth.REQUIRE);
592     }
593     @MethodSource("newTestParams")
594     @ParameterizedTest
595     public void testMutualAuthValidClientCertChainTooLongFailOptionalClientAuth(SSLEngineTestParam param)
596             throws Exception {
597         testMutualAuthClientCertFail(param, ClientAuth.OPTIONAL, "mutual_auth_client.p12", true);
598     }
599     @MethodSource("newTestParams")
600     @ParameterizedTest
601     public void testMutualAuthValidClientCertChainTooLongFailRequireClientAuth(SSLEngineTestParam param)
602             throws Exception {
603         testMutualAuthClientCertFail(param, ClientAuth.REQUIRE, "mutual_auth_client.p12", true);
604     }
605     private void testMutualAuthInvalidClientCertSucceed(SSLEngineTestParam param, ClientAuth auth) throws Exception {
606         char[] password = "example".toCharArray();
607         final KeyStore serverKeyStore = KeyStore.getInstance("PKCS12");
608         serverKeyStore.load(getClass().getResourceAsStream("mutual_auth_server.p12"), password);
609         final KeyStore clientKeyStore = KeyStore.getInstance("PKCS12");
610         clientKeyStore.load(getClass().getResourceAsStream("mutual_auth_invalid_client.p12"), password);
611 <a name="16"></a>        final KeyManagerFactory serverKeyManagerFactory =
612                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
613         serverKeyManagerFactory.init(serverKeyStore, password);
614         <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final KeyManagerFactory clientKeyManagerFactory =
615                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
616         clientKeyManagerFactory.init(clientKeyStore, password);
617         File commonCertChain = ResourcesUtil.getFile(getClass(), "mutual_auth_ca.pem");
618         mySetupMutualAuth(param, serverKeyManagerFactory, commonCertChain, clientKeyManagerFactory, commonCertChain,
619                 auth, false, false);
620         assertTrue</b></font>(clientLatch.await(10, TimeUnit.SECONDS));
621         rethrowIfNotNull(clientException);
622         assertTrue(serverLatch.await(5, TimeUnit.SECONDS));
623         rethrowIfNotNull(serverException);
624     }
625     private void testMutualAuthClientCertFail(SSLEngineTestParam param, ClientAuth auth) throws Exception {
626         testMutualAuthClientCertFail(param, auth, "mutual_auth_invalid_client.p12", false);
627     }
628     private void testMutualAuthClientCertFail(SSLEngineTestParam param, ClientAuth auth, String clientCert,
629                                               boolean serverInitEngine)
630             throws Exception {
631         char[] password = "example".toCharArray();
632         final KeyStore serverKeyStore = KeyStore.getInstance("PKCS12");
633         serverKeyStore.load(getClass().getResourceAsStream("mutual_auth_server.p12"), password);
634         final KeyStore clientKeyStore = KeyStore.getInstance("PKCS12");
635         clientKeyStore.load(getClass().getResourceAsStream(clientCert), password);
636         final KeyManagerFactory serverKeyManagerFactory =
637                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
638         serverKeyManagerFactory.init(serverKeyStore, password);
639         final KeyManagerFactory clientKeyManagerFactory =
640                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
641         clientKeyManagerFactory.init(clientKeyStore, password);
642         File commonCertChain = ResourcesUtil.getFile(getClass(), "mutual_auth_ca.pem");
643         mySetupMutualAuth(param, serverKeyManagerFactory, commonCertChain, clientKeyManagerFactory, commonCertChain,
644                           auth, true, serverInitEngine);
645 <a name="19"></a>        assertTrue(clientLatch.await(10, TimeUnit.SECONDS));
646         assertTrue(mySetupMutualAuthServerIsValidClientException(clientException),
647                 "unexpected exception: " + clientException);
648         assertTrue(<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>serverLatch.await(5, TimeUnit.SECONDS));
649         assertTrue(mySetupMutualAuthServerIsValidServerException(serverException),
650                 "unexpected exception: " + serverException);
651     }
652     protected static boolean causedBySSLException(Throwable cause) {
653         Throwable next = cause</b></font>;
654         do {
655             if (next instanceof SSLException) {
656                 return true;
657             }
658             next = next.getCause();
659         } while (next != null);
660         return false;
661     }
662     protected boolean mySetupMutualAuthServerIsValidServerException(Throwable cause) {
663         return mySetupMutualAuthServerIsValidException(cause);
664     }
665     protected boolean mySetupMutualAuthServerIsValidClientException(Throwable cause) {
666         return mySetupMutualAuthServerIsValidException(cause);
667     }
668     protected boolean mySetupMutualAuthServerIsValidException(Throwable cause) {
669         return cause instanceof SSLException || cause instanceof ClosedChannelException;
670     }
671     protected void mySetupMutualAuthServerInitSslHandler(SslHandler handler) {
672     }
673     protected void mySetupMutualAuth(final SSLEngineTestParam param, KeyManagerFactory serverKMF,
674                                      final File serverTrustManager,
675                                      KeyManagerFactory clientKMF, File clientTrustManager,
676                                      ClientAuth clientAuth, final boolean failureExpected,
677                                      final boolean serverInitEngine)
678             throws SSLException, InterruptedException {
679         serverSslCtx =
680                 wrapContext(param, SslContextBuilder.forServer(serverKMF)
681                                  .protocols(param.protocols())
682                                  .ciphers(param.ciphers())
683                                  .sslProvider(sslServerProvider())
684                                  .sslContextProvider(serverSslContextProvider())
685                                  .trustManager(serverTrustManager)
686                                  .clientAuth(clientAuth)
687                                  .ciphers(null, IdentityCipherSuiteFilter.INSTANCE)
688                                  .sessionCacheSize(0)
689                                  .sessionTimeout(0).build());
690         clientSslCtx =
691                 wrapContext(param, SslContextBuilder.forClient()
692                                  .protocols(param.protocols())
693                                  .ciphers(param.ciphers())
694                                  .sslProvider(sslClientProvider())
695                                  .sslContextProvider(clientSslContextProvider())
696                                  .trustManager(clientTrustManager)
697                                  .keyManager(clientKMF)
698                                  .ciphers(null, IdentityCipherSuiteFilter.INSTANCE)
699                                  .sessionCacheSize(0)
700                                  .sessionTimeout(0).build());
701         serverConnectedChannel = null;
702 <a name="12"></a>        sb = new ServerBootstrap();
703         cb = new Bootstrap();
704         sb.group(new NioEventLoopGroup(), <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new NioEventLoopGroup());
705         sb.channel(NioServerSocketChannel.class);
706         sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
707             @Override
708             protected void initChannel(Channel ch) throws Exception {
709                 ch.config</b></font>().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type()));
710                 ChannelPipeline p = ch.pipeline();
711                 SslHandler handler = !param.delegate ? serverSslCtx.newHandler(ch.alloc()) :
712                         serverSslCtx.newHandler(ch.alloc(), delegatingExecutor);
713                 if (serverInitEngine) {
714                     mySetupMutualAuthServerInitSslHandler(handler);
715                 }
716                 p.addLast(handler);
717                 p.addLast(new MessageDelegatorChannelHandler(serverReceiver, serverLatch));
718                 p.addLast(new ChannelInboundHandlerAdapter() {
719                     @Override
720                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
721                         if (evt == SslHandshakeCompletionEvent.SUCCESS) {
722                             if (failureExpected) {
723                                 serverException = new IllegalStateException("handshake complete. expected failure");
724                             }
725                             serverLatch.countDown();
726                         } else if (evt instanceof SslHandshakeCompletionEvent) {
727 <a name="17"></a>                            serverException = ((SslHandshakeCompletionEvent) evt).cause();
728                             serverLatch.countDown();
729                         }
730                         <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ctx.fireUserEventTriggered(evt);
731                     }
732                     @Override
733                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
734                         if</b></font> (cause.getCause() instanceof SSLHandshakeException) {
735                             serverException = cause.getCause();
736                             serverLatch.countDown();
737                         } else {
738                             serverException = cause;
739                             ctx.fireExceptionCaught(cause);
740                         }
741                     }
742                 });
743                 serverConnectedChannel = ch;
744 <a name="25"></a>            }
745         });
746         cb.group(<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new NioEventLoopGroup());
747         cb.channel(NioSocketChannel.class);
748         cb.handler(new ChannelInitializer&lt;Channel&gt;() {
749             @Override
750             protected void initChannel(Channel ch) throws Exception {</b></font>
751                 ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type));
752                 ChannelPipeline p = ch.pipeline();
753                 SslHandler handler = !param.delegate ? clientSslCtx.newHandler(ch.alloc()) :
754                         clientSslCtx.newHandler(ch.alloc(), delegatingExecutor);
755                 p.addLast(handler);
756                 p.addLast(new MessageDelegatorChannelHandler(clientReceiver, clientLatch));
757                 p.addLast(new ChannelInboundHandlerAdapter() {
758                     @Override
759                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
760                         if (evt == SslHandshakeCompletionEvent.SUCCESS) {
761                             if (!failureExpected) {
762                                 clientLatch.countDown();
763                             }
764                         } else if (evt instanceof SslHandshakeCompletionEvent) {
765                             clientException = ((SslHandshakeCompletionEvent) evt).cause();
766                             clientLatch.countDown();
767                         }
768                         ctx.fireUserEventTriggered(evt);
769                     }
770                     @Override
771                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
772 <a name="13"></a>                        if (cause.getCause() instanceof SSLException) {
773                             clientException = cause.getCause();
774                             clientLatch.countDown();
775                         } else <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
776                             ctx.fireExceptionCaught(cause);
777                         }
778                     }
779                 });
780             }
781         }</b></font>);
782         serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();
783         int port = ((InetSocketAddress) serverChannel.localAddress()).getPort();
784         ChannelFuture ccf = cb.connect(new InetSocketAddress(NetUtil.LOCALHOST, port));
785         assertTrue(ccf.awaitUninterruptibly().isSuccess());
786         clientChannel = ccf.channel();
787     }
788     protected static void rethrowIfNotNull(Throwable error) {
789         if (error != null) {
790             throw new AssertionFailedError("Expected no error", error);
791         }
792     }
793     @MethodSource("newTestParams")
794     @ParameterizedTest
795     public void testClientHostnameValidationSuccess(SSLEngineTestParam param) throws Exception {
796         mySetupClientHostnameValidation(param, ResourcesUtil.getFile(getClass(),  "localhost_server.pem"),
797                                         ResourcesUtil.getFile(getClass(), "localhost_server.key"),
798                                         ResourcesUtil.getFile(getClass(), "mutual_auth_ca.pem"),
799                                         false);
800         assertTrue(clientLatch.await(10, TimeUnit.SECONDS));
801         rethrowIfNotNull(clientException);
802         assertTrue(serverLatch.await(5, TimeUnit.SECONDS));
803         rethrowIfNotNull(serverException);
804     }
805 <a name="3"></a>    @MethodSource("newTestParams")
806     @ParameterizedTest
807     public void testClientHostnameValidationFail(SSLEngineTestParam param) throws Exception {
808         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>Future&lt;Void&gt; clientWriteFuture =
809             mySetupClientHostnameValidation(param, ResourcesUtil.getFile(getClass(),  "notlocalhost_server.pem"),
810                                             ResourcesUtil.getFile(getClass(), "notlocalhost_server.key"),
811                                             ResourcesUtil.getFile(getClass(), "mutual_auth_ca.pem"),
812                                             true);
813         assertTrue(clientLatch.await(10, TimeUnit.SECONDS));
814         assertTrue(mySetupMutualAuthServerIsValidClientException(clientException),
815                 "unexpected exception: " + clientException);
816         assertTrue(serverLatch.await(5, TimeUnit.SECONDS));
817         assertTrue(mySetupMutualAuthServerIsValidServerException(serverException),
818                 "unexpected exception: " + serverException);
819         clientWriteFuture.awaitUninterruptibly</b></font>();
820         Throwable actualCause = clientWriteFuture.cause();
821         assertSame(clientException, actualCause);
822     }
823     private Future&lt;Void&gt; mySetupClientHostnameValidation(final SSLEngineTestParam param, File serverCrtFile,
824                                                          File serverKeyFile,
825                                                          File clientTrustCrtFile,
826                                                          final boolean failureExpected)
827             throws SSLException, InterruptedException {
828         final String expectedHost = "localhost";
829         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(serverCrtFile, serverKeyFile, null)
830                 .sslProvider(sslServerProvider())
831                 .protocols(param.protocols())
832                 .ciphers(param.ciphers())
833                 .sslContextProvider(serverSslContextProvider())
834                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
835                 .ciphers(null, IdentityCipherSuiteFilter.INSTANCE)
836                 .sessionCacheSize(0)
837                 .sessionTimeout(0)
838                 .build());
839         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
840                 .sslProvider(sslClientProvider())
841                 .protocols(param.protocols())
842                 .ciphers(param.ciphers())
843                 .sslContextProvider(clientSslContextProvider())
844                 .trustManager(clientTrustCrtFile)
845                 .ciphers(null, IdentityCipherSuiteFilter.INSTANCE)
846                 .sessionCacheSize(0)
847                 .sessionTimeout(0)
848                 .build());
849         serverConnectedChannel = null;
850         sb = new ServerBootstrap();
851         cb = new Bootstrap();
852 <a name="22"></a>
853         sb.group(new NioEventLoopGroup(), new NioEventLoopGroup());
854         sb.channel(NioServerSocketChannel.class);
855         <font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
856             @Override
857             protected void initChannel(Channel ch) throws Exception {
858                 ch.config</b></font>().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type));
859                 ChannelPipeline p = ch.pipeline();
860                 SslHandler handler = !param.delegate ? serverSslCtx.newHandler(ch.alloc()) :
861                         serverSslCtx.newHandler(ch.alloc(), delegatingExecutor);
862                 p.addLast(handler);
863                 p.addLast(new MessageDelegatorChannelHandler(serverReceiver, serverLatch));
864                 p.addLast(new ChannelInboundHandlerAdapter() {
865                     @Override
866                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
867                         if (evt == SslHandshakeCompletionEvent.SUCCESS) {
868                             if (failureExpected) {
869                                 serverException = new IllegalStateException("handshake complete. expected failure");
870                             }
871                             serverLatch.countDown();
872                         } else if (evt instanceof SslHandshakeCompletionEvent) {
873                             serverException = ((SslHandshakeCompletionEvent) evt).cause();
874                             serverLatch.countDown();
875                         }
876                         ctx.fireUserEventTriggered(evt);
877                     }
878                     @Override
879                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
880                         if (cause.getCause() instanceof SSLHandshakeException) {
881                             serverException = cause.getCause();
882                             serverLatch.countDown();
883                         } else {
884                             serverException = cause;
885                             ctx.fireExceptionCaught(cause);
886                         }
887                     }
888                 });
889                 serverConnectedChannel = ch;
890             }
891         });
892 <a name="21"></a>        final Promise&lt;Void&gt; clientWritePromise = ImmediateEventExecutor.INSTANCE.newPromise();
893         cb.group(new NioEventLoopGroup());
894         cb.channel(NioSocketChannel.class);
895         <font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cb.handler(new ChannelInitializer&lt;Channel&gt;() {
896             @Override
897             protected void initChannel(Channel ch) throws Exception {
898                 ch.config</b></font>().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type));
899                 ChannelPipeline p = ch.pipeline();
900                 InetSocketAddress remoteAddress = (InetSocketAddress) serverChannel.localAddress();
901                 SslHandler sslHandler = !param.delegate ?
902                         clientSslCtx.newHandler(ch.alloc(), expectedHost, 0) :
903                         clientSslCtx.newHandler(ch.alloc(), expectedHost, 0,  delegatingExecutor);
904                 SSLParameters parameters = sslHandler.engine().getSSLParameters();
905                 if (SslUtils.isValidHostNameForSNI(expectedHost)) {
906                     assertEquals(1, parameters.getServerNames().size());
907                     assertEquals(new SNIHostName(expectedHost), parameters.getServerNames().get(0));
908                 }
909                 parameters.setEndpointIdentificationAlgorithm("HTTPS");
910                 sslHandler.engine().setSSLParameters(parameters);
911                 p.addLast(sslHandler);
912                 p.addLast(new MessageDelegatorChannelHandler(clientReceiver, clientLatch));
913                 p.addLast(new ChannelInboundHandlerAdapter() {
914                     @Override
915                     public void handlerAdded(ChannelHandlerContext ctx) {
916                         if (failureExpected) {
917                             ChannelFuture f = ctx.write(ctx.alloc().buffer(1).writeByte(1));
918                             PromiseNotifier.cascade(f, clientWritePromise);
919                         }
920                     }
921                     @Override
922                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
923                         if (evt == SslHandshakeCompletionEvent.SUCCESS) {
924                             if (failureExpected) {
925                                 clientException = new IllegalStateException("handshake complete. expected failure");
926                             }
927                             clientLatch.countDown();
928                         } else if (evt instanceof SslHandshakeCompletionEvent) {
929                             clientException = ((SslHandshakeCompletionEvent) evt).cause();
930                             clientLatch.countDown();
931                         }
932                         ctx.fireUserEventTriggered(evt);
933                     }
934                     @Override
935                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
936                         if (cause.getCause() instanceof SSLHandshakeException) {
937                             clientException = cause.getCause();
938                             clientLatch.countDown();
939                         } else {
940                             ctx.fireExceptionCaught(cause);
941                         }
942                     }
943                 });
944             }
945         });
946         serverChannel = sb.bind(new InetSocketAddress(expectedHost, 0)).sync().channel();
947         final int port = ((InetSocketAddress) serverChannel.localAddress()).getPort();
948         ChannelFuture ccf = cb.connect(new InetSocketAddress(expectedHost, port));
949         assertTrue(ccf.awaitUninterruptibly().isSuccess());
950         clientChannel = ccf.channel();
951         return clientWritePromise;
952     }
953     private void mySetupMutualAuth(SSLEngineTestParam param, File keyFile, File crtFile, String keyPassword)
954             throws SSLException, InterruptedException {
955         mySetupMutualAuth(param, crtFile, keyFile, crtFile, keyPassword, crtFile, keyFile, crtFile, keyPassword);
956     }
957     private void verifySSLSessionForMutualAuth(
958             SSLEngineTestParam param, SSLSession session, File certFile, String principalName)
959             throws Exception {
960         InputStream in = null;
961         try {
962             assertEquals(principalName, session.getLocalPrincipal().getName());
963             assertEquals(principalName, session.getPeerPrincipal().getName());
964             assertNotNull(session.getId());
965             assertEquals(param.combo().cipher, session.getCipherSuite());
966             assertEquals(param.combo().protocol, session.getProtocol());
967             assertTrue(session.getApplicationBufferSize() &gt; 0);
968             assertTrue(session.getCreationTime() &gt; 0);
969             assertTrue(session.isValid());
970             assertTrue(session.getLastAccessedTime() &gt; 0);
971             in = new FileInputStream(certFile);
972             final byte[] certBytes = SslContext.X509_CERT_FACTORY
973                     .generateCertificate(in).getEncoded();
974             assertEquals(1, session.getPeerCertificates().length);
975             assertArrayEquals(certBytes, session.getPeerCertificates()[0].getEncoded());
976             try {
977                 assertEquals(1, session.getPeerCertificateChain().length);
978                 assertArrayEquals(certBytes, session.getPeerCertificateChain()[0].getEncoded());
979             } catch (UnsupportedOperationException e) {
980                 assertTrue(PlatformDependent.javaVersion() &gt;= 15);
981             }
982             assertEquals(1, session.getLocalCertificates().length);
983             assertArrayEquals(certBytes, session.getLocalCertificates()[0].getEncoded());
984         } finally {
985             if (in != null) {
986                 in.close();
987             }
988         }
989     }
990     private void mySetupMutualAuth(final SSLEngineTestParam param,
991             File servertTrustCrtFile, File serverKeyFile, final File serverCrtFile, String serverKeyPassword,
992             File clientTrustCrtFile, File clientKeyFile, final File clientCrtFile, String clientKeyPassword)
993             throws InterruptedException, SSLException {
994         serverSslCtx =
995                 wrapContext(param, SslContextBuilder.forServer(serverCrtFile, serverKeyFile, serverKeyPassword)
996                                  .sslProvider(sslServerProvider())
997                                  .sslContextProvider(serverSslContextProvider())
998                                  .protocols(param.protocols())
999                                  .ciphers(param.ciphers())
1000                                  .trustManager(servertTrustCrtFile)
1001                                  .ciphers(null, IdentityCipherSuiteFilter.INSTANCE)
1002                                  .sessionCacheSize(0)
1003                                  .sessionTimeout(0).build());
1004         clientSslCtx =
1005                 wrapContext(param, SslContextBuilder.forClient()
1006                                  .sslProvider(sslClientProvider())
1007                                  .sslContextProvider(clientSslContextProvider())
1008                                  .protocols(param.protocols())
1009                                  .ciphers(param.ciphers())
1010                                  .trustManager(clientTrustCrtFile)
1011                                  .keyManager(clientCrtFile, clientKeyFile, clientKeyPassword)
1012                                  .ciphers(null, IdentityCipherSuiteFilter.INSTANCE)
1013                                  .sessionCacheSize(0)
1014                                  .sessionTimeout(0).build());
1015         serverConnectedChannel = null;
1016         sb = new ServerBootstrap();
1017         cb = new Bootstrap();
1018         sb.group(new NioEventLoopGroup(), new NioEventLoopGroup());
1019         sb.channel(NioServerSocketChannel.class);
1020         sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
1021             @Override
1022             protected void initChannel(Channel ch) {
1023                 ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type));
1024                 ChannelPipeline p = ch.pipeline();
1025                 final SSLEngine engine = wrapEngine(serverSslCtx.newEngine(ch.alloc()));
1026                 engine.setUseClientMode(false);
1027                 engine.setNeedClientAuth(true);
1028                 p.addLast(new SslHandler(engine));
1029                 p.addLast(new MessageDelegatorChannelHandler(serverReceiver, serverLatch));
1030                 p.addLast(new ChannelInboundHandlerAdapter() {
1031                     @Override
1032                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
1033                         if (cause.getCause() instanceof SSLHandshakeException) {
1034                             serverException = cause.getCause();
1035                             serverLatch.countDown();
1036                         } else {
1037                             serverException = cause;
1038                             ctx.fireExceptionCaught(cause);
1039                         }
1040                     }
1041                     @Override
1042                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
1043                         if (evt == SslHandshakeCompletionEvent.SUCCESS) {
1044                             try {
1045                                 verifySSLSessionForMutualAuth(
1046                                         param, engine.getSession(), serverCrtFile, PRINCIPAL_NAME);
1047                             } catch (Throwable cause) {
1048                                 serverException = cause;
1049                             }
1050                         }
1051                     }
1052                 });
1053                 serverConnectedChannel = ch;
1054             }
1055         });
1056         cb.group(new NioEventLoopGroup());
1057         cb.channel(NioSocketChannel.class);
1058         cb.handler(new ChannelInitializer&lt;Channel&gt;() {
1059             @Override
1060             protected void initChannel(Channel ch) throws Exception {
1061                 ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type));
1062                 final SslHandler handler = !param.delegate ?
1063                         clientSslCtx.newHandler(ch.alloc()) :
1064                         clientSslCtx.newHandler(ch.alloc(), delegatingExecutor);
1065                 handler.engine().setNeedClientAuth(true);
1066                 ChannelPipeline p = ch.pipeline();
1067                 p.addLast(handler);
1068                 p.addLast(new MessageDelegatorChannelHandler(clientReceiver, clientLatch));
1069                 p.addLast(new ChannelInboundHandlerAdapter() {
1070                     @Override
1071                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
1072                         if (evt == SslHandshakeCompletionEvent.SUCCESS) {
1073                             try {
1074                                 verifySSLSessionForMutualAuth(
1075                                         param, handler.engine().getSession(), clientCrtFile, PRINCIPAL_NAME);
1076                             } catch (Throwable cause) {
1077                                 clientException = cause;
1078                             }
1079                         }
1080                     }
1081                     @Override
1082                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
1083                         if (cause.getCause() instanceof SSLHandshakeException) {
1084                             clientException = cause.getCause();
1085                             clientLatch.countDown();
1086                         } else {
1087                             ctx.fireExceptionCaught(cause);
1088                         }
1089                     }
1090                 });
1091             }
1092         });
1093         serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();
1094         int port = ((InetSocketAddress) serverChannel.localAddress()).getPort();
1095         ChannelFuture ccf = cb.connect(new InetSocketAddress(NetUtil.LOCALHOST, port));
1096         assertTrue(ccf.awaitUninterruptibly().isSuccess());
1097         clientChannel = ccf.channel();
1098     }
1099     protected void runTest(String expectedApplicationProtocol) throws Exception {
1100         final ByteBuf clientMessage = Unpooled.copiedBuffer("I am a client".getBytes());
1101 <a name="8"></a>        final ByteBuf serverMessage = Unpooled.copiedBuffer("I am a server".getBytes());
1102         try {
1103             writeAndVerifyReceived(clientMessage.retain(), clientChannel, serverLatch, serverReceiver);
1104             <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>writeAndVerifyReceived(serverMessage.retain(), serverConnectedChannel, clientLatch, clientReceiver);
1105             verifyApplicationLevelProtocol(clientChannel, expectedApplicationProtocol);
1106             verifyApplicationLevelProtocol(serverConnectedChannel, expectedApplicationProtocol);
1107         } finally {
1108             clientMessage.release();
1109             serverMessage.release();
1110         }
1111     }
1112     private static void verifyAppl</b></font>icationLevelProtocol(Channel channel, String expectedApplicationProtocol) {
1113         SslHandler handler = channel.pipeline().get(SslHandler.class);
1114         assertNotNull(handler);
1115         String appProto = handler.applicationProtocol();
1116         assertEquals(expectedApplicationProtocol, appProto);
1117         SSLEngine engine = handler.engine();
1118         if (engine instanceof JdkAlpnSslEngine) {
1119             JdkAlpnSslEngine java9SslEngine = (JdkAlpnSslEngine) engine;
1120             assertEquals(expectedApplicationProtocol == null ? StringUtil.EMPTY_STRING : expectedApplicationProtocol,
1121                     java9SslEngine.getApplicationProtocol());
1122         }
1123     }
1124     private static void writeAndVerifyReceived(ByteBuf message, Channel sendChannel, CountDownLatch receiverLatch,
1125                                                MessageReceiver receiver) throws Exception {
1126         List&lt;ByteBuf&gt; dataCapture = null;
1127         try {
1128             assertTrue(sendChannel.writeAndFlush(message).await(10, TimeUnit.SECONDS));
1129             receiverLatch.await(5, TimeUnit.SECONDS);
1130             message.resetReaderIndex();
1131             ArgumentCaptor&lt;ByteBuf&gt; captor = ArgumentCaptor.forClass(ByteBuf.class);
1132             verify(receiver).messageReceived(captor.capture());
1133             dataCapture = captor.getAllValues();
1134             assertEquals(message, dataCapture.get(0));
1135         } finally {
1136             if (dataCapture != null) {
1137                 for (ByteBuf data : dataCapture) {
1138                     data.release();
1139                 }
1140             }
1141         }
1142     }
1143     @Test
1144     public void testGetCreationTime() throws Exception {
1145         clientSslCtx = wrapContext(null, SslContextBuilder.forClient()
1146                 .sslProvider(sslClientProvider())
1147                 .sslContextProvider(clientSslContextProvider()).build());
1148         SSLEngine engine = null;
1149         try {
1150             engine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1151             assertTrue(engine.getSession().getCreationTime() &lt;= System.currentTimeMillis());
1152         } finally {
1153             cleanupClientSslEngine(engine);
1154         }
1155     }
1156     @MethodSource("newTestParams")
1157     @ParameterizedTest
1158     public void testSessionInvalidate(SSLEngineTestParam param) throws Exception {
1159         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
1160                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
1161                 .sslProvider(sslClientProvider())
1162                 .sslContextProvider(clientSslContextProvider())
1163                 .protocols(param.protocols())
1164                 .ciphers(param.ciphers())
1165                 .build());
1166         SelfSignedCertificate ssc = new SelfSignedCertificate();
1167         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
1168                 .sslProvider(sslServerProvider())
1169                 .sslContextProvider(serverSslContextProvider())
1170                 .protocols(param.protocols())
1171                 .ciphers(param.ciphers())
1172                 .build());
1173         SSLEngine clientEngine = null;
1174         SSLEngine serverEngine = null;
1175         try {
1176             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1177             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1178             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
1179             SSLSession session = serverEngine.getSession();
1180             assertTrue(session.isValid());
1181             session.invalidate();
1182             assertFalse(session.isValid());
1183         } finally {
1184             cleanupClientSslEngine(clientEngine);
1185             cleanupServerSslEngine(serverEngine);
1186             ssc.delete();
1187         }
1188     }
1189     @MethodSource("newTestParams")
1190     @ParameterizedTest
1191     public void testSSLSessionId(SSLEngineTestParam param) throws Exception {
1192         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
1193                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
1194                 .sslProvider(sslClientProvider())
1195                 .protocols(param.protocols())
1196                 .sslContextProvider(clientSslContextProvider())
1197                 .build());
1198         SelfSignedCertificate ssc = new SelfSignedCertificate();
1199         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
1200                 .sslProvider(sslServerProvider())
1201                 .protocols(param.protocols())
1202                 .sslContextProvider(serverSslContextProvider())
1203                 .build());
1204         SSLEngine clientEngine = null;
1205         SSLEngine serverEngine = null;
1206         try {
1207             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1208             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1209             assertEquals(0, clientEngine.getSession().getId().length);
1210             assertEquals(0, serverEngine.getSession().getId().length);
1211             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
1212             if (param.protocolCipherCombo == ProtocolCipherCombo.TLSV13) {
1213                 ByteBuffer packetBuffer = allocateBuffer(param.type(), 32 * 1024);
1214                 ByteBuffer appBuffer = allocateBuffer(param.type(), 32 * 1024);
1215                 appBuffer.clear().position(4).flip();
1216                 packetBuffer.clear();
1217                 do {
1218                     SSLEngineResult result;
1219                     do {
1220                         result = serverEngine.wrap(appBuffer, packetBuffer);
1221                     } while (appBuffer.hasRemaining() || result.bytesProduced() &gt; 0);
1222                     appBuffer.clear();
1223                     packetBuffer.flip();
1224                     do {
1225                         result = clientEngine.unwrap(packetBuffer, appBuffer);
1226                     } while (packetBuffer.hasRemaining() || result.bytesProduced() &gt; 0);
1227                     packetBuffer.clear();
1228                     appBuffer.clear().position(4).flip();
1229                     do {
1230                         result = clientEngine.wrap(appBuffer, packetBuffer);
1231                     } while (appBuffer.hasRemaining() || result.bytesProduced() &gt; 0);
1232                     appBuffer.clear();
1233                     packetBuffer.flip();
1234                     do {
1235                         result = serverEngine.unwrap(packetBuffer, appBuffer);
1236                     } while (packetBuffer.hasRemaining() || result.bytesProduced() &gt; 0);
1237                     packetBuffer.clear();
1238                     appBuffer.clear().position(4).flip();
1239                 } while (clientEngine.getSession().getId().length == 0);
1240                 assertFalse(Arrays.equals(clientEngine.getSession().getId(), serverEngine.getSession().getId()));
1241             } else {
1242                 assertNotEquals(0, clientEngine.getSession().getId().length);
1243                 assertNotEquals(0, serverEngine.getSession().getId().length);
1244                 assertArrayEquals(clientEngine.getSession().getId(), serverEngine.getSession().getId());
1245             }
1246         } finally {
1247             cleanupClientSslEngine(clientEngine);
1248             cleanupServerSslEngine(serverEngine);
1249             ssc.delete();
1250         }
1251     }
1252     @MethodSource("newTestParams")
1253     @ParameterizedTest
1254     @Timeout(30)
1255     public void clientInitiatedRenegotiationWithFatalAlertDoesNotInfiniteLoopServer(final SSLEngineTestParam param)
1256             throws Exception {
1257         assumeTrue(PlatformDependent.javaVersion() &gt;= 11);
1258         final SelfSignedCertificate ssc = new SelfSignedCertificate();
1259         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
1260                                         .sslProvider(sslServerProvider())
1261                                         .sslContextProvider(serverSslContextProvider())
1262                                         .protocols(param.protocols())
1263                                         .ciphers(param.ciphers())
1264                                         .build());
1265         sb = new ServerBootstrap()
1266                 .group(new NioEventLoopGroup(1))
1267                 .channel(NioServerSocketChannel.class)
1268                 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
1269                     @Override
1270                     public void initChannel(SocketChannel ch) {
1271                         ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type));
1272                         ChannelPipeline p = ch.pipeline();
1273                         SslHandler handler = !param.delegate ?
1274                                 serverSslCtx.newHandler(ch.alloc()) :
1275                                 serverSslCtx.newHandler(ch.alloc(), delegatingExecutor);
1276                         p.addLast(handler);
1277                         p.addLast(new ChannelInboundHandlerAdapter() {
1278                             @Override
1279                             public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
1280                                 if (evt instanceof SslHandshakeCompletionEvent &amp;&amp;
1281                                         ((SslHandshakeCompletionEvent) evt).isSuccess()) {
1282                                     ctx.writeAndFlush(ctx.alloc().buffer(1).writeByte(100));
1283                                 }
1284                                 ctx.fireUserEventTriggered(evt);
1285                             }
1286                             @Override
1287                             public void channelRead(final ChannelHandlerContext ctx, Object msg) {
1288                                 ReferenceCountUtil.release(msg);
1289                                 ctx.channel().eventLoop().schedule(new Runnable() {
1290                                     @Override
1291                                     public void run() {
1292 <a name="14"></a>                                        ctx.writeAndFlush(ctx.alloc().buffer(1).writeByte(101));
1293                                     }
1294                                 }, 500, TimeUnit.MILLISECONDS);
1295                             <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1296                             @Override
1297                             public void channelInactive(ChannelHandlerContext ctx) {
1298                                 serverLatch.countDown();
1299                             }
1300                         }</b></font>);
1301                         serverConnectedChannel = ch;
1302 <a name="26"></a>                    }
1303                 });
1304         <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>serverChannel = sb.bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
1305         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()</b></font>
1306                                         .sslProvider(SslProvider.JDK)
1307                                         .trustManager(InsecureTrustManagerFactory.INSTANCE)
1308                                         .protocols(param.protocols())
1309                                         .ciphers(param.ciphers())
1310 <a name="5"></a>                                        .build());
1311         cb = new Bootstrap();
1312         <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cb.group(new NioEventLoopGroup(1))
1313                 .channel(NioSocketChannel.class)
1314                 .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
1315                     @Override
1316                     public void initChannel(SocketChannel ch) {
1317                         ch.config().setAllocator(new</b></font> TestByteBufAllocator(ch.config().getAllocator(), param.type()));
1318                         ChannelPipeline p = ch.pipeline();
1319                         SslHandler sslHandler = !param.delegate ?
1320                                 clientSslCtx.newHandler(ch.alloc()) :
1321                                 clientSslCtx.newHandler(ch.alloc(), delegatingExecutor);
1322                         sslHandler.setHandshakeTimeout(1, TimeUnit.SECONDS);
1323                         p.addLast(sslHandler);
1324                         p.addLast(new ChannelInboundHandlerAdapter() {
1325                             private int handshakeCount;
1326                             @Override
1327                             public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
1328                                 if (evt instanceof SslHandshakeCompletionEvent &amp;&amp; ++handshakeCount == 2) {
1329                                     ctx.close();
1330                                     return;
1331                                 }
1332                                 ctx.fireUserEventTriggered(evt);
1333                             }
1334                             @Override
1335                             public void channelRead(ChannelHandlerContext ctx, Object msg) {
1336                                 ReferenceCountUtil.release(msg);
1337                                 ctx.writeAndFlush(ctx.alloc().buffer(1).writeByte(102));
1338                                 ctx.pipeline().get(SslHandler.class).renegotiate();
1339                             }
1340                         });
1341                     }
1342                 });
1343         ChannelFuture ccf = cb.connect(serverChannel.localAddress());
1344         assertTrue(ccf.syncUninterruptibly().isSuccess());
1345         clientChannel = ccf.channel();
1346         serverLatch.await();
1347         ssc.delete();
1348     }
1349     protected void testEnablingAnAlreadyDisabledSslProtocol(SSLEngineTestParam param,
1350                                                             String[] protocols1, String[] protocols2) throws Exception {
1351         SSLEngine sslEngine = null;
1352         try {
1353             File serverKeyFile = ResourcesUtil.getFile(getClass(), "test_unencrypted.pem");
1354             File serverCrtFile = ResourcesUtil.getFile(getClass(), "test.crt");
1355             serverSslCtx = wrapContext(param, SslContextBuilder.forServer(serverCrtFile, serverKeyFile)
1356                                             .sslProvider(sslServerProvider())
1357                                             .sslContextProvider(serverSslContextProvider())
1358                                             .protocols(param.protocols())
1359                                             .ciphers(param.ciphers())
1360                                             .build());
1361             sslEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1362             sslEngine.setEnabledProtocols(EmptyArrays.EMPTY_STRINGS);
1363             String[] enabledProtocols = sslEngine.getEnabledProtocols();
1364             assertArrayEquals(protocols1, enabledProtocols);
1365             sslEngine.setEnabledProtocols(new String[]{ SslProtocols.TLS_v1_2 });
1366             enabledProtocols = sslEngine.getEnabledProtocols();
1367             assertEquals(protocols2.length, enabledProtocols.length);
1368             assertArrayEquals(protocols2, enabledProtocols);
1369         } finally {
1370             if (sslEngine != null) {
1371                 sslEngine.closeInbound();
1372                 sslEngine.closeOutbound();
1373                 cleanupServerSslEngine(sslEngine);
1374             }
1375         }
1376     }
1377     protected void handshake(BufferType type, boolean delegate, SSLEngine clientEngine, SSLEngine serverEngine)
1378             throws Exception {
1379         ByteBuffer cTOs = allocateBuffer(type, clientEngine.getSession().getPacketBufferSize());
1380         ByteBuffer sTOc = allocateBuffer(type, serverEngine.getSession().getPacketBufferSize());
1381         ByteBuffer serverAppReadBuffer = allocateBuffer(type, serverEngine.getSession().getApplicationBufferSize());
1382         ByteBuffer clientAppReadBuffer = allocateBuffer(type, clientEngine.getSession().getApplicationBufferSize());
1383         clientEngine.beginHandshake();
1384         serverEngine.beginHandshake();
1385         ByteBuffer empty = allocateBuffer(type, 0);
1386         SSLEngineResult clientResult;
1387         SSLEngineResult serverResult;
1388         boolean clientHandshakeFinished = false;
1389         boolean serverHandshakeFinished = false;
1390         boolean cTOsHasRemaining;
1391         boolean sTOcHasRemaining;
1392         do {
1393             int cTOsPos = cTOs.position();
1394             int sTOcPos = sTOc.position();
1395             if (!clientHandshakeFinished) {
1396                 clientResult = clientEngine.wrap(empty, cTOs);
1397                 runDelegatedTasks(delegate, clientResult, clientEngine);
1398                 assertEquals(empty.remaining(), clientResult.bytesConsumed());
1399                 assertEquals(cTOs.position() - cTOsPos,  clientResult.bytesProduced());
1400                 if (isHandshakeFinished(clientResult)) {
1401                     clientHandshakeFinished = true;
1402                 }
1403             }
1404             if (!serverHandshakeFinished) {
1405                 serverResult = serverEngine.wrap(empty, sTOc);
1406                 runDelegatedTasks(delegate, serverResult, serverEngine);
1407                 assertEquals(empty.remaining(), serverResult.bytesConsumed());
1408                 assertEquals(sTOc.position() - sTOcPos, serverResult.bytesProduced());
1409                 if (isHandshakeFinished(serverResult)) {
1410                     serverHandshakeFinished = true;
1411                 }
1412             }
1413             cTOs.flip();
1414             sTOc.flip();
1415             cTOsPos = cTOs.position();
1416             sTOcPos = sTOc.position();
1417             if (!clientHandshakeFinished ||
1418                 SslProtocols.TLS_v1_3.equals(clientEngine.getSession().getProtocol())) {
1419                 int clientAppReadBufferPos = clientAppReadBuffer.position();
1420                 clientResult = clientEngine.unwrap(sTOc, clientAppReadBuffer);
1421                 runDelegatedTasks(delegate, clientResult, clientEngine);
1422                 assertEquals(sTOc.position() - sTOcPos, clientResult.bytesConsumed());
1423                 assertEquals(clientAppReadBuffer.position() - clientAppReadBufferPos, clientResult.bytesProduced());
1424                 if (isHandshakeFinished(clientResult)) {
1425                     clientHandshakeFinished = true;
1426                 }
1427             } else {
1428                 assertEquals(0, sTOc.remaining());
1429             }
1430             if (!serverHandshakeFinished) {
1431                 int serverAppReadBufferPos = serverAppReadBuffer.position();
1432                 serverResult = serverEngine.unwrap(cTOs, serverAppReadBuffer);
1433                 runDelegatedTasks(delegate, serverResult, serverEngine);
1434                 assertEquals(cTOs.position() - cTOsPos, serverResult.bytesConsumed());
1435                 assertEquals(serverAppReadBuffer.position() - serverAppReadBufferPos, serverResult.bytesProduced());
1436                 if (isHandshakeFinished(serverResult)) {
1437                     serverHandshakeFinished = true;
1438                 }
1439             } else {
1440                 assertFalse(cTOs.hasRemaining());
1441             }
1442             cTOsHasRemaining = cTOs.hasRemaining();
1443             sTOcHasRemaining = sTOc.hasRemaining();
1444             sTOc.compact();
1445             cTOs.compact();
1446         } while (!clientHandshakeFinished || !serverHandshakeFinished ||
1447                 cTOsHasRemaining || sTOcHasRemaining);
1448     }
1449     private static boolean isHandshakeFinished(SSLEngineResult result) {
1450         return result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED;
1451     }
1452     private void runDelegatedTasks(boolean delegate, SSLEngineResult result, SSLEngine engine) {
1453         if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {
1454             for (;;) {
1455                 Runnable task = engine.getDelegatedTask();
1456                 if (task == null) {
1457                     break;
1458                 }
1459                 if (!delegate) {
1460                     task.run();
1461                 } else {
1462                     delegatingExecutor.execute(task);
1463                 }
1464             }
1465         }
1466     }
1467     protected abstract SslProvider sslClientProvider();
1468     protected abstract SslProvider sslServerProvider();
1469     protected Provider clientSslContextProvider() {
1470         return null;
1471     }
1472     protected Provider serverSslContextProvider() {
1473         return null;
1474     }
1475     protected void cleanupClientSslContext(SslContext ctx) {
1476     }
1477     protected void cleanupServerSslContext(SslContext ctx) {
1478     }
1479     protected void cleanupClientSslEngine(SSLEngine engine) {
1480     }
1481     protected void cleanupServerSslEngine(SSLEngine engine) {
1482     }
1483     protected void setupHandlers(SSLEngineTestParam param, ApplicationProtocolConfig apn)
1484             throws InterruptedException, SSLException, CertificateException {
1485         setupHandlers(param, apn, apn);
1486     }
1487     protected void setupHandlers(SSLEngineTestParam param,
1488                                  ApplicationProtocolConfig serverApn, ApplicationProtocolConfig clientApn)
1489             throws InterruptedException, SSLException, CertificateException {
1490         SelfSignedCertificate ssc = new SelfSignedCertificate();
1491         try {
1492             SslContextBuilder serverCtxBuilder = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey(), null)
1493                                                          .sslProvider(sslServerProvider())
1494                                                          .sslContextProvider(serverSslContextProvider())
1495                                                          .ciphers(null, IdentityCipherSuiteFilter.INSTANCE)
1496                                                          .applicationProtocolConfig(serverApn)
1497                                                          .sessionCacheSize(0)
1498                                                          .sessionTimeout(0);
1499             if (serverApn.protocol() == Protocol.NPN || serverApn.protocol() == Protocol.NPN_AND_ALPN) {
1500                 serverCtxBuilder.protocols(SslProtocols.TLS_v1_2);
1501             }
1502             SslContextBuilder clientCtxBuilder = SslContextBuilder.forClient()
1503                              .sslProvider(sslClientProvider())
1504                              .sslContextProvider(clientSslContextProvider())
1505                              .applicationProtocolConfig(clientApn)
1506                              .trustManager(InsecureTrustManagerFactory.INSTANCE)
1507                              .ciphers(null, IdentityCipherSuiteFilter.INSTANCE)
1508                              .sessionCacheSize(0)
1509                              .sessionTimeout(0);
1510             if (clientApn.protocol() == Protocol.NPN || clientApn.protocol() == Protocol.NPN_AND_ALPN) {
1511                 clientCtxBuilder.protocols(SslProtocols.TLS_v1_2);
1512             }
1513             setupHandlers(param.type(), param.delegate(),
1514                     wrapContext(param, serverCtxBuilder.build()), wrapContext(param, clientCtxBuilder.build()));
1515         } finally {
1516           ssc.delete();
1517         }
1518     }
1519     protected void setupHandlers(final BufferType type, final boolean delegate,
1520                                  SslContext serverCtx, SslContext clientCtx)
1521             throws InterruptedException, SSLException, CertificateException {
1522         serverSslCtx = serverCtx;
1523         clientSslCtx = clientCtx;
1524         serverConnectedChannel = null;
1525         sb = new ServerBootstrap();
1526         cb = new Bootstrap();
1527         sb.group(new NioEventLoopGroup(), new NioEventLoopGroup());
1528         sb.channel(NioServerSocketChannel.class);
1529         sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
1530             @Override
1531             protected void initChannel(Channel ch) throws Exception {
1532                 ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), type));
1533                 ChannelPipeline p = ch.pipeline();
1534                 SslHandler sslHandler = !delegate ?
1535                         serverSslCtx.newHandler(ch.alloc()) :
1536                         serverSslCtx.newHandler(ch.alloc(), delegatingExecutor);
1537                 p.addLast(sslHandler);
1538                 p.addLast(new MessageDelegatorChannelHandler(serverReceiver, serverLatch));
1539                 p.addLast(new ChannelInboundHandlerAdapter() {
1540                     @Override
1541                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
1542                         if (cause.getCause() instanceof SSLHandshakeException) {
1543                             serverException = cause.getCause();
1544                             serverLatch.countDown();
1545                         } else {
1546                             ctx.fireExceptionCaught(cause);
1547                         }
1548                     }
1549                 });
1550                 serverConnectedChannel = ch;
1551             }
1552         });
1553         cb.group(new NioEventLoopGroup());
1554         cb.channel(NioSocketChannel.class);
1555         cb.handler(new ChannelInitializer&lt;Channel&gt;() {
1556             @Override
1557             protected void initChannel(Channel ch) throws Exception {
1558                 ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), type));
1559                 ChannelPipeline p = ch.pipeline();
1560                 SslHandler sslHandler = !delegate ?
1561                         clientSslCtx.newHandler(ch.alloc()) :
1562                         clientSslCtx.newHandler(ch.alloc(), delegatingExecutor);
1563                 p.addLast(sslHandler);
1564                 p.addLast(new MessageDelegatorChannelHandler(clientReceiver, clientLatch));
1565                 p.addLast(new ChannelInboundHandlerAdapter() {
1566                     @Override
1567                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
1568                         if (cause.getCause() instanceof SSLHandshakeException) {
1569                             clientException = cause.getCause();
1570                             clientLatch.countDown();
1571                         } else {
1572                             ctx.fireExceptionCaught(cause);
1573                         }
1574                     }
1575                     @Override
1576                     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
1577                         clientLatch.countDown();
1578                     }
1579                 });
1580             }
1581         });
1582         serverChannel = sb.bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
1583         ChannelFuture ccf = cb.connect(serverChannel.localAddress());
1584         assertTrue(ccf.syncUninterruptibly().isSuccess());
1585         clientChannel = ccf.channel();
1586     }
1587     @MethodSource("newTestParams")
1588     @ParameterizedTest
1589     @Timeout(30)
1590     public void testMutualAuthSameCertChain(final SSLEngineTestParam param) throws Exception {
1591         SelfSignedCertificate serverCert = new SelfSignedCertificate();
1592         SelfSignedCertificate clientCert = new SelfSignedCertificate();
1593         serverSslCtx =
1594                 wrapContext(param, SslContextBuilder.forServer(serverCert.certificate(), serverCert.privateKey())
1595                                 .trustManager(clientCert.cert())
1596                                  .clientAuth(ClientAuth.REQUIRE).sslProvider(sslServerProvider())
1597                                  .sslContextProvider(serverSslContextProvider())
1598                                  .protocols(param.protocols())
1599                                  .ciphers(param.ciphers()).build());
1600         sb = new ServerBootstrap();
1601         sb.group(new NioEventLoopGroup(), new NioEventLoopGroup());
1602 <a name="10"></a>        sb.channel(NioServerSocketChannel.class);
1603         final Promise&lt;String&gt; promise = sb.config().group().next().newPromise();
1604         serverChannel = <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
1605             @Override
1606             protected void initChannel(Channel ch) throws Exception {
1607 <a name="4"></a>                ch.config</b></font>().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type()));
1608                 SslHandler sslHandler = !param.delegate ?
1609                         serverSslCtx.newHandler(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.alloc()) :
1610                         serverSslCtx.newHandler(ch.alloc(), delegatingExecutor);
1611                 ch.pipeline().addFirst(sslHandler);
1612                 ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
1613                     @Override
1614                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {</b></font>
1615                         if (evt instanceof SslHandshakeCompletionEvent) {
1616                             Throwable cause = ((SslHandshakeCompletionEvent) evt).cause();
1617                             if (cause == null) {
1618                                 SSLSession session = ((SslHandler) ctx.pipeline().first()).engine().getSession();
1619                                 Certificate[] peerCertificates = session.getPeerCertificates();
1620                                 if (peerCertificates == null) {
1621                                     promise.setFailure(new NullPointerException("peerCertificates"));
1622                                     return;
1623                                 }
1624                                 try {
1625                                     X509Certificate[] peerCertificateChain = session.getPeerCertificateChain();
1626                                     if (peerCertificateChain == null) {
1627                                         promise.setFailure(new NullPointerException("peerCertificateChain"));
1628                                     } else if (peerCertificateChain.length + peerCertificates.length != 4) {
1629                                         String excTxtFmt = "peerCertificateChain.length:%s, peerCertificates.length:%s";
1630                                         promise.setFailure(new IllegalStateException(String.format(excTxtFmt,
1631                                                 peerCertificateChain.length,
1632                                                 peerCertificates.length)));
1633                                     } else {
1634                                         for (int i = 0; i &lt; peerCertificateChain.length; i++) {
1635                                             if (peerCertificateChain[i] == null || peerCertificates[i] == null) {
1636                                                 promise.setFailure(
1637                                                         new IllegalStateException("Certificate in chain is null"));
1638                                                 return;
1639                                             }
1640                                         }
1641                                         promise.setSuccess(null);
1642                                     }
1643                                 } catch (UnsupportedOperationException e) {
1644                                     assertTrue(PlatformDependent.javaVersion() &gt;= 15);
1645                                     assertEquals(2, peerCertificates.length);
1646                                     for (int i = 0; i &lt; peerCertificates.length; i++) {
1647                                         if (peerCertificates[i] == null) {
1648                                             promise.setFailure(
1649                                                     new IllegalStateException("Certificate in chain is null"));
1650                                             return;
1651                                         }
1652                                     }
1653                                     promise.setSuccess(null);
1654                                 }
1655                             } else {
1656                                 promise.setFailure(cause);
1657                             }
1658                         }
1659                     }
1660                 });
1661                 serverConnectedChannel = ch;
1662             }
1663         }).bind(new InetSocketAddress(0)).syncUninterruptibly().channel();
1664         ByteArrayOutputStream chainStream = new ByteArrayOutputStream();
1665         chainStream.write(Files.readAllBytes(clientCert.certificate().toPath()));
1666         chainStream.write(Files.readAllBytes(serverCert.certificate().toPath()));
1667         clientSslCtx =
1668                 wrapContext(param, SslContextBuilder.forClient().keyManager(
1669                         new ByteArrayInputStream(chainStream.toByteArray()),
1670                         new FileInputStream(clientCert.privateKey()))
1671                 .trustManager(new FileInputStream(serverCert.certificate()))
1672                 .sslProvider(sslClientProvider())
1673                 .sslContextProvider(clientSslContextProvider())
1674                 .protocols(param.protocols()).ciphers(param.ciphers()).build());
1675         cb = new Bootstrap();
1676         cb.group(new NioEventLoopGroup());
1677         cb.channel(NioSocketChannel.class);
1678         clientChannel = cb.handler(new ChannelInitializer&lt;Channel&gt;() {
1679             @Override
1680             protected void initChannel(Channel ch) throws Exception {
1681                 ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type()));
1682                 ch.pipeline().addLast(new SslHandler(wrapEngine(clientSslCtx.newEngine(ch.alloc()))));
1683             }
1684         }).connect(serverChannel.localAddress()).syncUninterruptibly().channel();
1685         promise.syncUninterruptibly();
1686         serverCert.delete();
1687         clientCert.delete();
1688     }
1689     @MethodSource("newTestParams")
1690     @ParameterizedTest
1691     public void testUnwrapBehavior(SSLEngineTestParam param) throws Exception {
1692         SelfSignedCertificate cert = new SelfSignedCertificate();
1693         clientSslCtx = wrapContext(param, SslContextBuilder
1694                 .forClient()
1695                 .trustManager(cert.cert())
1696                 .sslProvider(sslClientProvider())
1697                 .protocols(param.protocols())
1698                 .ciphers(param.ciphers())
1699                 .build());
1700         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1701         serverSslCtx = wrapContext(param, SslContextBuilder
1702                 .forServer(cert.certificate(), cert.privateKey())
1703                 .sslProvider(sslServerProvider())
1704                 .protocols(param.protocols())
1705                 .ciphers(param.ciphers())
1706                 .build());
1707         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1708         byte[] bytes = "Hello World".getBytes(CharsetUtil.US_ASCII);
1709         try {
1710             ByteBuffer plainClientOut = allocateBuffer(param.type, client.getSession().getApplicationBufferSize());
1711             ByteBuffer encryptedClientToServer = allocateBuffer(
1712                     param.type, server.getSession().getPacketBufferSize() * 2);
1713             ByteBuffer plainServerIn = allocateBuffer(param.type, server.getSession().getApplicationBufferSize());
1714             handshake(param.type(), param.delegate(), client, server);
1715             plainClientOut.put(bytes, 0, 5);
1716             plainClientOut.flip();
1717             SSLEngineResult result = client.wrap(plainClientOut, encryptedClientToServer);
1718             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
1719             assertEquals(5, result.bytesConsumed());
1720             assertTrue(result.bytesProduced() &gt; 0);
1721             assertFalse(plainClientOut.hasRemaining());
1722             plainClientOut.clear();
1723             plainClientOut.put(bytes, 5, 6);
1724             plainClientOut.flip();
1725             result = client.wrap(plainClientOut, encryptedClientToServer);
1726             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
1727             assertEquals(6, result.bytesConsumed());
1728             assertTrue(result.bytesProduced() &gt; 0);
1729             encryptedClientToServer.flip();
1730             int remaining = encryptedClientToServer.remaining();
1731             ByteBuffer small = allocateBuffer(param.type, 3);
1732             result = server.unwrap(encryptedClientToServer, small);
1733             assertEquals(SSLEngineResult.Status.BUFFER_OVERFLOW, result.getStatus());
1734             assertEquals(remaining, encryptedClientToServer.remaining());
1735             result = server.unwrap(encryptedClientToServer, plainServerIn);
1736             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
1737             assertEquals(5, result.bytesProduced());
1738             assertTrue(encryptedClientToServer.hasRemaining());
1739             result = server.unwrap(encryptedClientToServer, plainServerIn);
1740             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
1741             assertEquals(6, result.bytesProduced());
1742             assertFalse(encryptedClientToServer.hasRemaining());
1743             plainServerIn.flip();
1744             assertEquals(ByteBuffer.wrap(bytes), plainServerIn);
1745         } finally {
1746             cleanupClientSslEngine(client);
1747             cleanupServerSslEngine(server);
1748             cert.delete();
1749         }
1750     }
1751     @MethodSource("newTestParams")
1752     @ParameterizedTest
1753     public void testProtocolMatch(SSLEngineTestParam param) throws Exception {
1754         testProtocol(param, false, new String[] {"TLSv1.2"}, new String[] {"TLSv1", "TLSv1.1", "TLSv1.2"});
1755     }
1756     @MethodSource("newTestParams")
1757     @ParameterizedTest
1758     public void testProtocolNoMatch(SSLEngineTestParam param) throws Exception {
1759         testProtocol(param, true, new String[] {"TLSv1.2"}, new String[] {"TLSv1", "TLSv1.1"});
1760     }
1761     private void testProtocol(final SSLEngineTestParam param, boolean handshakeFails,
1762                               String[] clientProtocols, String[] serverProtocols)
1763             throws Exception {
1764         SelfSignedCertificate cert = new SelfSignedCertificate();
1765         clientSslCtx = wrapContext(param, SslContextBuilder
1766                 .forClient()
1767                 .trustManager(cert.cert())
1768                 .sslProvider(sslClientProvider())
1769                 .protocols(clientProtocols)
1770                 .build());
1771         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1772         serverSslCtx = wrapContext(param, SslContextBuilder
1773                 .forServer(cert.certificate(), cert.privateKey())
1774                 .sslProvider(sslServerProvider())
1775                 .protocols(serverProtocols)
1776                 .build());
1777         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1778         try {
1779             if (handshakeFails) {
1780                 final SSLEngine clientEngine = client;
1781                 final SSLEngine serverEngine = server;
1782                 assertThrows(SSLHandshakeException.class, new Executable() {
1783                     @Override
1784                     public void execute() throws Throwable {
1785                         handshake(param.type(), param.delegate(), clientEngine, serverEngine);
1786                     }
1787                 });
1788             } else {
1789                 handshake(param.type(), param.delegate(), client, server);
1790             }
1791         } finally {
1792             cleanupClientSslEngine(client);
1793             cleanupServerSslEngine(server);
1794             cert.delete();
1795         }
1796     }
1797     private String[] nonContiguousProtocols(SslProvider provider) {
1798         if (provider != null) {
1799             return new String[] { SslProtocols.TLS_v1_2 };
1800         }
1801         return new String[] {SslProtocols.TLS_v1_2, SslProtocols.TLS_v1};
1802     }
1803     @MethodSource("newTestParams")
1804     @ParameterizedTest
1805     public void testHandshakeCompletesWithNonContiguousProtocolsTLSv1_2CipherOnly(SSLEngineTestParam param)
1806             throws Exception {
1807         SelfSignedCertificate ssc = new SelfSignedCertificate();
1808         final String sharedCipher = "TLS_RSA_WITH_AES_128_CBC_SHA";
1809         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
1810                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
1811                 .ciphers(Collections.singletonList(sharedCipher))
1812                 .protocols(nonContiguousProtocols(sslClientProvider()))
1813                 .sslContextProvider(clientSslContextProvider())
1814                 .sslProvider(sslClientProvider())
1815                 .build());
1816         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
1817                 .ciphers(Collections.singletonList(sharedCipher))
1818                 .protocols(nonContiguousProtocols(sslServerProvider()))
1819                 .sslContextProvider(serverSslContextProvider())
1820                 .sslProvider(sslServerProvider())
1821                 .build());
1822         SSLEngine clientEngine = null;
1823         SSLEngine serverEngine = null;
1824         try {
1825             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1826             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1827             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
1828         } finally {
1829             cleanupClientSslEngine(clientEngine);
1830             cleanupServerSslEngine(serverEngine);
1831             ssc.delete();
1832         }
1833     }
1834     @MethodSource("newTestParams")
1835     @ParameterizedTest
1836     public void testHandshakeCompletesWithoutFilteringSupportedCipher(SSLEngineTestParam param) throws Exception {
1837         SelfSignedCertificate ssc = new SelfSignedCertificate();
1838         final String sharedCipher = "TLS_RSA_WITH_AES_128_CBC_SHA";
1839         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
1840                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
1841                 .ciphers(Collections.singletonList(sharedCipher), SupportedCipherSuiteFilter.INSTANCE)
1842                 .protocols(nonContiguousProtocols(sslClientProvider()))
1843                 .sslContextProvider(clientSslContextProvider())
1844                 .sslProvider(sslClientProvider())
1845                 .build());
1846         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
1847                 .ciphers(Collections.singletonList(sharedCipher), SupportedCipherSuiteFilter.INSTANCE)
1848                 .protocols(nonContiguousProtocols(sslServerProvider()))
1849                 .sslContextProvider(serverSslContextProvider())
1850                 .sslProvider(sslServerProvider())
1851                 .build());
1852         SSLEngine clientEngine = null;
1853         SSLEngine serverEngine = null;
1854         try {
1855             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1856             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1857             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
1858         } finally {
1859             cleanupClientSslEngine(clientEngine);
1860             cleanupServerSslEngine(serverEngine);
1861             ssc.delete();
1862         }
1863     }
1864     @MethodSource("newTestParams")
1865     @ParameterizedTest
1866     public void testPacketBufferSizeLimit(SSLEngineTestParam param) throws Exception {
1867         SelfSignedCertificate cert = new SelfSignedCertificate();
1868         clientSslCtx = wrapContext(param, SslContextBuilder
1869                 .forClient()
1870                 .trustManager(cert.cert())
1871                 .sslContextProvider(clientSslContextProvider())
1872                 .sslProvider(sslClientProvider())
1873                 .protocols(param.protocols())
1874                 .ciphers(param.ciphers())
1875                 .build());
1876         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1877         serverSslCtx = wrapContext(param, SslContextBuilder
1878                 .forServer(cert.certificate(), cert.privateKey())
1879                 .sslContextProvider(serverSslContextProvider())
1880                 .sslProvider(sslServerProvider())
1881                 .protocols(param.protocols())
1882                 .ciphers(param.ciphers())
1883                 .build());
1884         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1885         try {
1886             ByteBuffer plainServerOut = allocateBuffer(
1887                     param.type(), server.getSession().getApplicationBufferSize() * 2);
1888             handshake(param.type(), param.delegate(), client, server);
1889             plainServerOut.position(plainServerOut.capacity());
1890             plainServerOut.flip();
1891             ByteBuffer encryptedServerToClient = allocateBuffer(
1892                     param.type(), server.getSession().getPacketBufferSize());
1893             int encryptedServerToClientPos = encryptedServerToClient.position();
1894             int plainServerOutPos = plainServerOut.position();
1895             SSLEngineResult result = server.wrap(plainServerOut, encryptedServerToClient);
1896             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
1897             assertEquals(plainServerOut.position() - plainServerOutPos, result.bytesConsumed());
1898             assertEquals(encryptedServerToClient.position() - encryptedServerToClientPos, result.bytesProduced());
1899         } finally {
1900             cleanupClientSslEngine(client);
1901             cleanupServerSslEngine(server);
1902             cert.delete();
1903         }
1904     }
1905     @MethodSource("newTestParams")
1906     @ParameterizedTest
1907     public void testSSLEngineUnwrapNoSslRecord(SSLEngineTestParam param) throws Exception {
1908         clientSslCtx = wrapContext(param, SslContextBuilder
1909                 .forClient()
1910                 .sslContextProvider(clientSslContextProvider())
1911                 .sslProvider(sslClientProvider())
1912                 .protocols(param.protocols())
1913                 .ciphers(param.ciphers())
1914                 .build());
1915         final SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1916         try {
1917             final ByteBuffer src = allocateBuffer(param.type(), client.getSession().getApplicationBufferSize());
1918             final ByteBuffer dst = allocateBuffer(param.type(), client.getSession().getPacketBufferSize());
1919             ByteBuffer empty = allocateBuffer(param.type(), 0);
1920             SSLEngineResult clientResult = client.wrap(empty, dst);
1921             assertEquals(SSLEngineResult.Status.OK, clientResult.getStatus());
1922             assertEquals(SSLEngineResult.HandshakeStatus.NEED_UNWRAP, clientResult.getHandshakeStatus());
1923             assertThrows(SSLException.class, new Executable() {
1924                 @Override
1925                 public void execute() throws Throwable {
1926                     client.unwrap(src, dst);
1927                 }
1928             });
1929         } finally {
1930             cleanupClientSslEngine(client);
1931         }
1932     }
1933     @MethodSource("newTestParams")
1934     @ParameterizedTest
1935     public void testBeginHandshakeAfterEngineClosed(SSLEngineTestParam param) throws SSLException {
1936         clientSslCtx = wrapContext(param, SslContextBuilder
1937                 .forClient()
1938                 .sslContextProvider(clientSslContextProvider())
1939                 .sslProvider(sslClientProvider())
1940                 .protocols(param.protocols())
1941                 .ciphers(param.ciphers())
1942                 .build());
1943         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1944         try {
1945             client.closeInbound();
1946             client.closeOutbound();
1947             try {
1948                 client.beginHandshake();
1949                 fail();
1950             } catch (SSLException expected) {
1951             } catch (IllegalStateException e) {
1952                 if (!Conscrypt.isEngineSupported(client)) {
1953                     throw e;
1954                 }
1955             }
1956         } finally {
1957             cleanupClientSslEngine(client);
1958         }
1959     }
1960     @MethodSource("newTestParams")
1961     @ParameterizedTest
1962     public void testBeginHandshakeCloseOutbound(SSLEngineTestParam param) throws Exception {
1963         SelfSignedCertificate cert = new SelfSignedCertificate();
1964         clientSslCtx = wrapContext(param, SslContextBuilder
1965                 .forClient()
1966                 .sslContextProvider(clientSslContextProvider())
1967                 .sslProvider(sslClientProvider())
1968                 .protocols(param.protocols())
1969                 .ciphers(param.ciphers())
1970                 .build());
1971         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1972         serverSslCtx = wrapContext(param, SslContextBuilder
1973                 .forServer(cert.certificate(), cert.privateKey())
1974                 .sslContextProvider(serverSslContextProvider())
1975                 .sslProvider(sslServerProvider())
1976                 .protocols(param.protocols())
1977                 .ciphers(param.ciphers())
1978                 .build());
1979         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
1980         try {
1981             testBeginHandshakeCloseOutbound(param, client);
1982             testBeginHandshakeCloseOutbound(param, server);
1983         } finally {
1984             cleanupClientSslEngine(client);
1985             cleanupServerSslEngine(server);
1986             cert.delete();
1987         }
1988     }
1989     private void testBeginHandshakeCloseOutbound(SSLEngineTestParam param, SSLEngine engine) throws SSLException {
1990         ByteBuffer dst = allocateBuffer(param.type(), engine.getSession().getPacketBufferSize());
1991         ByteBuffer empty = allocateBuffer(param.type(), 0);
1992         engine.beginHandshake();
1993         engine.closeOutbound();
1994         SSLEngineResult result;
1995         for (;;) {
1996             result = engine.wrap(empty, dst);
1997             dst.flip();
1998             assertEquals(0, result.bytesConsumed());
1999             assertEquals(dst.remaining(), result.bytesProduced());
2000             if (result.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_WRAP) {
2001                 break;
2002             }
2003             dst.clear();
2004         }
2005         assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());
2006     }
2007     @MethodSource("newTestParams")
2008     @ParameterizedTest
2009     public void testCloseInboundAfterBeginHandshake(SSLEngineTestParam param) throws Exception {
2010         SelfSignedCertificate cert = new SelfSignedCertificate();
2011         clientSslCtx = wrapContext(param, SslContextBuilder
2012                 .forClient()
2013                 .sslContextProvider(clientSslContextProvider())
2014                 .sslProvider(sslClientProvider())
2015                 .protocols(param.protocols())
2016                 .ciphers(param.ciphers())
2017                 .build());
2018         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2019         serverSslCtx = wrapContext(param, SslContextBuilder
2020                 .forServer(cert.certificate(), cert.privateKey())
2021                 .sslContextProvider(serverSslContextProvider())
2022                 .sslProvider(sslServerProvider())
2023                 .protocols(param.protocols())
2024                 .ciphers(param.ciphers())
2025                 .build());
2026         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2027         try {
2028             testCloseInboundAfterBeginHandshake(client);
2029             testCloseInboundAfterBeginHandshake(server);
2030         } finally {
2031             cleanupClientSslEngine(client);
2032             cleanupServerSslEngine(server);
2033             cert.delete();
2034         }
2035     }
2036     private static void testCloseInboundAfterBeginHandshake(SSLEngine engine) throws SSLException {
2037         engine.beginHandshake();
2038         try {
2039             engine.closeInbound();
2040             if (!Conscrypt.isEngineSupported(engine)) {
2041                 fail();
2042             }
2043         } catch (SSLException expected) {
2044         }
2045     }
2046     @MethodSource("newTestParams")
2047     @ParameterizedTest
2048     public void testCloseNotifySequence(SSLEngineTestParam param) throws Exception {
2049         SelfSignedCertificate cert = new SelfSignedCertificate();
2050         clientSslCtx = wrapContext(param, SslContextBuilder
2051                 .forClient()
2052                 .trustManager(cert.cert())
2053                 .sslContextProvider(clientSslContextProvider())
2054                 .sslProvider(sslClientProvider())
2055                 .protocols(SslProtocols.TLS_v1_2)
2056                 .build());
2057         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2058         serverSslCtx = wrapContext(param, SslContextBuilder
2059                 .forServer(cert.certificate(), cert.privateKey())
2060                 .sslContextProvider(serverSslContextProvider())
2061                 .sslProvider(sslServerProvider())
2062                 .protocols(SslProtocols.TLS_v1_2)
2063                 .build());
2064         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2065         try {
2066             ByteBuffer plainClientOut = allocateBuffer(param.type(), client.getSession().getApplicationBufferSize());
2067             ByteBuffer plainServerOut = allocateBuffer(param.type(), server.getSession().getApplicationBufferSize());
2068             ByteBuffer encryptedClientToServer =
2069                     allocateBuffer(param.type(), client.getSession().getPacketBufferSize());
2070             ByteBuffer encryptedServerToClient =
2071                     allocateBuffer(param.type(), server.getSession().getPacketBufferSize());
2072             ByteBuffer empty = allocateBuffer(param.type(), 0);
2073             handshake(param.type(), param.delegate(), client, server);
2074             client.closeOutbound();
2075             assertFalse(client.isOutboundDone());
2076             assertFalse(client.isInboundDone());
2077             SSLEngineResult result = client.wrap(empty, encryptedClientToServer);
2078             encryptedClientToServer.flip();
2079             assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());
2080             SSLEngineResult.HandshakeStatus hs = result.getHandshakeStatus();
2081             if (sslClientProvider() == SslProvider.JDK || Conscrypt.isEngineSupported(client)) {
2082                 assertTrue(hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING
2083                         || hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP);
2084             } else {
2085                 assertEquals(SSLEngineResult.HandshakeStatus.NEED_UNWRAP, hs);
2086             }
2087             int produced = result.bytesProduced();
2088             int consumed = result.bytesConsumed();
2089             int closeNotifyLen = produced;
2090             assertTrue(produced &gt; 0);
2091             assertEquals(0, consumed);
2092             assertEquals(produced, encryptedClientToServer.remaining());
2093             assertTrue(client.isOutboundDone());
2094             assertFalse(client.isInboundDone());
2095             assertFalse(server.isOutboundDone());
2096             assertFalse(server.isInboundDone());
2097             result = server.unwrap(encryptedClientToServer, plainServerOut);
2098             plainServerOut.flip();
2099             assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());
2100             assertEquals(SSLEngineResult.HandshakeStatus.NEED_WRAP, result.getHandshakeStatus());
2101             produced = result.bytesProduced();
2102             consumed = result.bytesConsumed();
2103             assertEquals(closeNotifyLen, consumed);
2104             assertEquals(0, produced);
2105             assertEquals(0, encryptedClientToServer.remaining());
2106             assertEquals(0, plainServerOut.remaining());
2107             assertFalse(server.isOutboundDone());
2108             assertTrue(server.isInboundDone());
2109             result = server.wrap(empty, encryptedServerToClient);
2110             encryptedServerToClient.flip();
2111             assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());
2112             assertEquals(SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, result.getHandshakeStatus());
2113             produced = result.bytesProduced();
2114             consumed = result.bytesConsumed();
2115             assertEquals(closeNotifyLen, produced);
2116             assertEquals(0, consumed);
2117             assertEquals(produced, encryptedServerToClient.remaining());
2118             assertTrue(server.isOutboundDone());
2119             assertTrue(server.isInboundDone());
2120             result = client.unwrap(encryptedServerToClient, plainClientOut);
2121             plainClientOut.flip();
2122             assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());
2123             assertEquals(SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, result.getHandshakeStatus());
2124             produced = result.bytesProduced();
2125             consumed = result.bytesConsumed();
2126             assertEquals(closeNotifyLen, consumed);
2127             assertEquals(0, produced);
2128             assertEquals(0, encryptedServerToClient.remaining());
2129             assertTrue(client.isOutboundDone());
2130             assertTrue(client.isInboundDone());
2131             encryptedServerToClient.clear();
2132             plainServerOut.clear();
2133             result = server.wrap(plainServerOut, encryptedServerToClient);
2134             assertEngineRemainsClosed(result);
2135             encryptedClientToServer.clear();
2136             plainServerOut.clear();
2137             result = server.unwrap(encryptedClientToServer, plainServerOut);
2138             assertEngineRemainsClosed(result);
2139             encryptedClientToServer.clear();
2140             plainClientOut.clear();
2141             result = client.wrap(plainClientOut, encryptedClientToServer);
2142             assertEngineRemainsClosed(result);
2143             encryptedServerToClient.clear();
2144             plainClientOut.clear();
2145             result = client.unwrap(encryptedServerToClient, plainClientOut);
2146             assertEngineRemainsClosed(result);
2147         } finally {
2148             cert.delete();
2149             cleanupClientSslEngine(client);
2150             cleanupServerSslEngine(server);
2151         }
2152     }
2153     private static void assertEngineRemainsClosed(SSLEngineResult result) {
2154         assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());
2155         assertEquals(SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, result.getHandshakeStatus());
2156         assertEquals(0, result.bytesConsumed());
2157         assertEquals(0, result.bytesProduced());
2158     }
2159     @MethodSource("newTestParams")
2160     @ParameterizedTest
2161     public void testWrapAfterCloseOutbound(SSLEngineTestParam param) throws Exception {
2162         SelfSignedCertificate cert = new SelfSignedCertificate();
2163         clientSslCtx = wrapContext(param, SslContextBuilder
2164                 .forClient()
2165                 .trustManager(cert.cert())
2166                 .sslProvider(sslClientProvider())
2167                 .sslContextProvider(clientSslContextProvider())
2168                 .protocols(param.protocols())
2169                 .ciphers(param.ciphers())
2170                 .build());
2171         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2172         serverSslCtx = wrapContext(param, SslContextBuilder
2173                 .forServer(cert.certificate(), cert.privateKey())
2174                 .sslProvider(sslServerProvider())
2175                 .sslContextProvider(serverSslContextProvider())
2176                 .protocols(param.protocols())
2177                 .ciphers(param.ciphers())
2178                 .build());
2179         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2180         try {
2181             ByteBuffer dst = allocateBuffer(param.type(), client.getSession().getPacketBufferSize());
2182             ByteBuffer src = allocateBuffer(param.type(), 1024);
2183             handshake(param.type(), param.delegate(), client, server);
2184             client.closeOutbound();
2185             SSLEngineResult result = client.wrap(src, dst);
2186             assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());
2187             assertEquals(0, result.bytesConsumed());
2188             assertTrue(result.bytesProduced() &gt; 0);
2189             assertTrue(client.isOutboundDone());
2190             assertFalse(client.isInboundDone());
2191         } finally {
2192             cert.delete();
2193             cleanupClientSslEngine(client);
2194             cleanupServerSslEngine(server);
2195         }
2196     }
2197     @MethodSource("newTestParams")
2198     @ParameterizedTest
2199     public void testMultipleRecordsInOneBufferWithNonZeroPosition(SSLEngineTestParam param) throws Exception {
2200         SelfSignedCertificate cert = new SelfSignedCertificate();
2201         clientSslCtx = wrapContext(param, SslContextBuilder
2202                 .forClient()
2203                 .trustManager(cert.cert())
2204                 .sslContextProvider(clientSslContextProvider())
2205                 .sslProvider(sslClientProvider())
2206                 .protocols(param.protocols())
2207                 .ciphers(param.ciphers())
2208                 .build());
2209         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2210         serverSslCtx = wrapContext(param, SslContextBuilder
2211                 .forServer(cert.certificate(), cert.privateKey())
2212                 .sslContextProvider(serverSslContextProvider())
2213                 .sslProvider(sslServerProvider())
2214                 .protocols(param.protocols())
2215                 .ciphers(param.ciphers())
2216                 .build());
2217         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2218         try {
2219             ByteBuffer plainClientOut = allocateBuffer(param.type(), 1024);
2220             ByteBuffer plainServerOut = allocateBuffer(param.type(), server.getSession().getApplicationBufferSize());
2221             ByteBuffer encClientToServer = allocateBuffer(param.type(), client.getSession().getPacketBufferSize());
2222             int positionOffset = 1;
2223             ByteBuffer combinedEncClientToServer = allocateBuffer(
2224                     param.type(), encClientToServer.capacity() * 2 + positionOffset);
2225             combinedEncClientToServer.position(positionOffset);
2226             handshake(param.type(), param.delegate(), client, server);
2227             plainClientOut.limit(plainClientOut.capacity());
2228             SSLEngineResult result = client.wrap(plainClientOut, encClientToServer);
2229             assertEquals(plainClientOut.capacity(), result.bytesConsumed());
2230             assertTrue(result.bytesProduced() &gt; 0);
2231             encClientToServer.flip();
2232             combinedEncClientToServer.put(encClientToServer);
2233             plainClientOut.clear();
2234             encClientToServer.clear();
2235             result = client.wrap(plainClientOut, encClientToServer);
2236             assertEquals(plainClientOut.capacity(), result.bytesConsumed());
2237             assertTrue(result.bytesProduced() &gt; 0);
2238             encClientToServer.flip();
2239             int encClientToServerLen = encClientToServer.remaining();
2240             combinedEncClientToServer.put(encClientToServer);
2241 <a name="6"></a>            encClientToServer.clear();
2242             combinedEncClientToServer.flip();
2243             <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>combinedEncClientToServer.position(positionOffset);
2244             combinedEncClientToServer.limit(
2245                     combinedEncClientToServer.limit() - (encClientToServerLen - positionOffset));
2246             result = server.unwrap(combinedEncClientToServer, plainServerOut);
2247             assertEquals(encClientToServerLen, result.bytesConsumed());
2248             assertTrue(result.bytesProduced() &gt; 0);
2249         } finally {
2250             cert.delete();
2251             cleanupClientSslEngine</b></font>(client);
2252             cleanupServerSslEngine(server);
2253         }
2254     }
2255     @MethodSource("newTestParams")
2256     @ParameterizedTest
2257     public void testMultipleRecordsInOneBufferBiggerThenPacketBufferSize(SSLEngineTestParam param) throws Exception {
2258         SelfSignedCertificate cert = new SelfSignedCertificate();
2259         clientSslCtx = wrapContext(param, SslContextBuilder
2260                 .forClient()
2261                 .trustManager(cert.cert())
2262                 .sslContextProvider(clientSslContextProvider())
2263                 .sslProvider(sslClientProvider())
2264                 .protocols(param.protocols())
2265                 .ciphers(param.ciphers())
2266                 .build());
2267         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2268         serverSslCtx = wrapContext(param, SslContextBuilder
2269                 .forServer(cert.certificate(), cert.privateKey())
2270                 .sslContextProvider(serverSslContextProvider())
2271                 .sslProvider(sslServerProvider())
2272                 .protocols(param.protocols())
2273                 .ciphers(param.ciphers())
2274                 .build());
2275         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2276         try {
2277             ByteBuffer plainClientOut = allocateBuffer(param.type(), 4096);
2278             ByteBuffer plainServerOut = allocateBuffer(param.type(), server.getSession().getApplicationBufferSize());
2279             ByteBuffer encClientToServer = allocateBuffer(param.type(), server.getSession().getPacketBufferSize() * 2);
2280             handshake(param.type(), param.delegate(), client, server);
2281             int srcLen = plainClientOut.remaining();
2282             SSLEngineResult result;
2283             int count = 0;
2284             do {
2285                 int plainClientOutPosition = plainClientOut.position();
2286                 int encClientToServerPosition = encClientToServer.position();
2287                 result = client.wrap(plainClientOut, encClientToServer);
2288                 if (result.getStatus() == Status.BUFFER_OVERFLOW) {
2289                     assertEquals(plainClientOutPosition, plainClientOut.position());
2290                     assertEquals(encClientToServerPosition, encClientToServer.position());
2291                     break;
2292                 }
2293                 assertEquals(SSLEngineResult.Status.OK, result.getStatus());
2294                 assertEquals(srcLen, result.bytesConsumed());
2295                 assertTrue(result.bytesProduced() &gt; 0);
2296                 plainClientOut.clear();
2297                 ++count;
2298             } while (encClientToServer.position() &lt; server.getSession().getPacketBufferSize());
2299             assertTrue(count &gt;= 2);
2300             encClientToServer.flip();
2301             result = server.unwrap(encClientToServer, plainServerOut);
2302             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
2303             assertTrue(result.bytesConsumed() &gt; 0);
2304             assertTrue(result.bytesProduced() &gt; 0);
2305             assertTrue(encClientToServer.hasRemaining());
2306         } finally {
2307             cert.delete();
2308             cleanupClientSslEngine(client);
2309             cleanupServerSslEngine(server);
2310         }
2311     }
2312     @MethodSource("newTestParams")
2313     @ParameterizedTest
2314     public void testBufferUnderFlow(SSLEngineTestParam param) throws Exception {
2315         SelfSignedCertificate cert = new SelfSignedCertificate();
2316         clientSslCtx = wrapContext(param, SslContextBuilder
2317                 .forClient()
2318                 .trustManager(cert.cert())
2319                 .sslContextProvider(clientSslContextProvider())
2320                 .sslProvider(sslClientProvider())
2321                 .protocols(param.protocols())
2322                 .ciphers(param.ciphers())
2323                 .build());
2324         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2325         serverSslCtx = wrapContext(param, SslContextBuilder
2326                 .forServer(cert.certificate(), cert.privateKey())
2327                 .sslContextProvider(serverSslContextProvider())
2328                 .sslProvider(sslServerProvider())
2329                 .protocols(param.protocols())
2330                 .ciphers(param.ciphers())
2331                 .build());
2332         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2333         try {
2334             ByteBuffer plainClient = allocateBuffer(param.type(), 1024);
2335             plainClient.limit(plainClient.capacity());
2336             ByteBuffer encClientToServer = allocateBuffer(param.type(), client.getSession().getPacketBufferSize());
2337             ByteBuffer plainServer = allocateBuffer(param.type(), server.getSession().getApplicationBufferSize());
2338             handshake(param.type(), param.delegate(), client, server);
2339             SSLEngineResult result = client.wrap(plainClient, encClientToServer);
2340             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
2341             assertEquals(result.bytesConsumed(), plainClient.capacity());
2342             encClientToServer.flip();
2343             int remaining = encClientToServer.remaining();
2344             encClientToServer.limit(SSL_RECORD_HEADER_LENGTH - 1);
2345             result = server.unwrap(encClientToServer, plainServer);
2346             assertResultIsBufferUnderflow(result);
2347             encClientToServer.limit(SSL_RECORD_HEADER_LENGTH);
2348             result = server.unwrap(encClientToServer, plainServer);
2349             assertResultIsBufferUnderflow(result);
2350             encClientToServer.limit(SSL_RECORD_HEADER_LENGTH  + remaining - 1 - SSL_RECORD_HEADER_LENGTH);
2351             result = server.unwrap(encClientToServer, plainServer);
2352             assertResultIsBufferUnderflow(result);
2353             encClientToServer.limit(remaining);
2354             result = server.unwrap(encClientToServer, plainServer);
2355             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
2356             assertEquals(result.bytesConsumed(), remaining);
2357             assertTrue(result.bytesProduced() &gt; 0);
2358         } finally {
2359             cert.delete();
2360             cleanupClientSslEngine(client);
2361             cleanupServerSslEngine(server);
2362         }
2363     }
2364     private static void assertResultIsBufferUnderflow(SSLEngineResult result) {
2365         assertEquals(SSLEngineResult.Status.BUFFER_UNDERFLOW, result.getStatus());
2366         assertEquals(0, result.bytesConsumed());
2367         assertEquals(0, result.bytesProduced());
2368     }
2369     @MethodSource("newTestParams")
2370     @ParameterizedTest
2371     public void testWrapDoesNotZeroOutSrc(SSLEngineTestParam param) throws Exception {
2372         SelfSignedCertificate cert = new SelfSignedCertificate();
2373         clientSslCtx = wrapContext(param, SslContextBuilder
2374                 .forClient()
2375                 .trustManager(cert.cert())
2376                 .sslContextProvider(clientSslContextProvider())
2377                 .sslProvider(sslClientProvider())
2378                 .protocols(param.protocols())
2379                 .ciphers(param.ciphers())
2380                 .build());
2381         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2382         serverSslCtx = wrapContext(param, SslContextBuilder
2383                 .forServer(cert.certificate(), cert.privateKey())
2384                 .sslContextProvider(serverSslContextProvider())
2385                 .sslProvider(sslServerProvider())
2386                 .protocols(param.protocols())
2387                 .ciphers(param.ciphers())
2388                 .build());
2389         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2390         try {
2391             ByteBuffer plainServerOut =
2392                     allocateBuffer(param.type(), server.getSession().getApplicationBufferSize() / 2);
2393             handshake(param.type(), param.delegate(), client, server);
2394             for (int i = 0; i &lt; plainServerOut.capacity(); i++) {
2395                 plainServerOut.put(i, (byte) i);
2396             }
2397             plainServerOut.position(plainServerOut.capacity());
2398             plainServerOut.flip();
2399             ByteBuffer encryptedServerToClient =
2400                     allocateBuffer(param.type(), server.getSession().getPacketBufferSize());
2401             SSLEngineResult result = server.wrap(plainServerOut, encryptedServerToClient);
2402             assertEquals(SSLEngineResult.Status.OK, result.getStatus());
2403             assertTrue(result.bytesConsumed() &gt; 0);
2404             for (int i = 0; i &lt; plainServerOut.capacity(); i++) {
2405                 assertEquals((byte) i, plainServerOut.get(i));
2406             }
2407         } finally {
2408             cleanupClientSslEngine(client);
2409             cleanupServerSslEngine(server);
2410             cert.delete();
2411         }
2412     }
2413     @MethodSource("newTestParams")
2414     @ParameterizedTest
2415     public void testDisableProtocols(SSLEngineTestParam param) throws Exception {
2416         testDisableProtocols(param, SslProtocols.SSL_v2, SslProtocols.SSL_v2);
2417         testDisableProtocols(param, SslProtocols.SSL_v3, SslProtocols.SSL_v2, SslProtocols.SSL_v3);
2418         testDisableProtocols(param, SslProtocols.TLS_v1, SslProtocols.SSL_v2, SslProtocols.SSL_v3, SslProtocols.TLS_v1);
2419         testDisableProtocols(param,
2420                 SslProtocols.TLS_v1_1, SslProtocols.SSL_v2, SslProtocols.SSL_v3,
2421                 SslProtocols.TLS_v1, SslProtocols.TLS_v1_1);
2422         testDisableProtocols(param, SslProtocols.TLS_v1_2, SslProtocols.SSL_v2,
2423                 SslProtocols.SSL_v3, SslProtocols.TLS_v1, SslProtocols.TLS_v1_1, SslProtocols.TLS_v1_2);
2424     }
2425     private void testDisableProtocols(SSLEngineTestParam param,
2426                                       String protocol, String... disabledProtocols) throws Exception {
2427         SelfSignedCertificate cert = new SelfSignedCertificate();
2428         SslContext ctx = wrapContext(param, SslContextBuilder
2429                 .forServer(cert.certificate(), cert.privateKey())
2430                 .sslContextProvider(serverSslContextProvider())
2431                 .sslProvider(sslServerProvider())
2432                 .protocols(param.protocols())
2433                 .ciphers(param.ciphers())
2434                 .build());
2435         SSLEngine server = wrapEngine(ctx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2436         try {
2437             Set&lt;String&gt; supported = new HashSet&lt;String&gt;(Arrays.asList(server.getSupportedProtocols()));
2438             if (supported.contains(protocol)) {
2439                 server.setEnabledProtocols(server.getSupportedProtocols());
2440                 assertEquals(supported, new HashSet&lt;String&gt;(Arrays.asList(server.getSupportedProtocols())));
2441                 for (String disabled : disabledProtocols) {
2442                     supported.remove(disabled);
2443                 }
2444                 if (supported.contains(SslProtocols.SSL_v2_HELLO) &amp;&amp; supported.size() == 1) {
2445                     return;
2446                 }
2447                 server.setEnabledProtocols(supported.toArray(new String[0]));
2448                 assertEquals(supported, new HashSet&lt;String&gt;(Arrays.asList(server.getEnabledProtocols())));
2449                 server.setEnabledProtocols(server.getSupportedProtocols());
2450             }
2451         } finally {
2452             cleanupServerSslEngine(server);
2453             cleanupClientSslContext(ctx);
2454             cert.delete();
2455         }
2456     }
2457     @MethodSource("newTestParams")
2458     @ParameterizedTest
2459     public void testUsingX509TrustManagerVerifiesHostname(SSLEngineTestParam param) throws Exception {
2460         testUsingX509TrustManagerVerifiesHostname(param, false);
2461     }
2462     @MethodSource("newTestParams")
2463     @ParameterizedTest
2464     public void testUsingX509TrustManagerVerifiesSNIHostname(SSLEngineTestParam param) throws Exception {
2465         testUsingX509TrustManagerVerifiesHostname(param, true);
2466     }
2467     private void testUsingX509TrustManagerVerifiesHostname(SSLEngineTestParam param, boolean useSNI) throws Exception {
2468         if (clientSslContextProvider() != null) {
2469             return;
2470         }
2471         String fqdn = "something.netty.io";
2472         SelfSignedCertificate cert = new SelfSignedCertificate(fqdn);
2473         clientSslCtx = wrapContext(param, SslContextBuilder
2474                 .forClient()
2475                 .trustManager(new TrustManagerFactory(new TrustManagerFactorySpi() {
2476                     @Override
2477                     protected void engineInit(KeyStore keyStore) {
2478                     }
2479                     @Override
2480                     protected TrustManager[] engineGetTrustManagers() {
2481                         return new TrustManager[] {
2482                                 new X509TrustManager() {
2483                                     @Override
2484                                     public void checkClientTrusted(
2485                                             java.security.cert.X509Certificate[] x509Certificates, String s) {
2486                                     }
2487                                     @Override
2488                                     public void checkServerTrusted(
2489                                             java.security.cert.X509Certificate[] x509Certificates, String s) {
2490                                     }
2491                                     @Override
2492                                     public java.security.cert.X509Certificate[] getAcceptedIssuers() {
2493                                         return EmptyArrays.EMPTY_X509_CERTIFICATES;
2494                                     }
2495                                 }
2496                         };
2497                     }
2498                     @Override
2499                     protected void engineInit(ManagerFactoryParameters managerFactoryParameters) {
2500                     }
2501                 }, null, TrustManagerFactory.getDefaultAlgorithm()) {
2502                 })
2503                 .sslContextProvider(clientSslContextProvider())
2504                 .sslProvider(sslClientProvider())
2505                 .build());
2506         SSLEngine client = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT, "127.0.0.1", 1234));
2507         SSLParameters sslParameters = client.getSSLParameters();
2508         sslParameters.setEndpointIdentificationAlgorithm("HTTPS");
2509         if (useSNI) {
2510             sslParameters.setServerNames(Collections.&lt;SNIServerName&gt;singletonList(new SNIHostName(fqdn)));
2511         }
2512         client.setSSLParameters(sslParameters);
2513         serverSslCtx = wrapContext(param, SslContextBuilder
2514                 .forServer(cert.certificate(), cert.privateKey())
2515                 .sslContextProvider(serverSslContextProvider())
2516                 .sslProvider(sslServerProvider())
2517                 .build());
2518         SSLEngine server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2519         try {
2520             handshake(param.type(), param.delegate(), client, server);
2521             if (!useSNI) {
2522                 fail();
2523             }
2524         } catch (SSLException exception) {
2525             if (useSNI) {
2526                 throw exception;
2527             }
2528 <a name="9"></a>                    } finally {
2529             cleanupClientSslEngine(client);
2530             <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>cleanupServerSslEngine(server);
2531             cert.delete();
2532         }
2533     }
2534     @Test
2535     public void testInvalidCipher() throws Exception {
2536         SelfSignedCertificate cert = new SelfSignedCertificate();
2537         List&lt;String&gt; cipherList = new</b></font> ArrayList&lt;String&gt;();
2538         Collections.addAll(cipherList, ((SSLSocketFactory) SSLSocketFactory.getDefault()).getDefaultCipherSuites());
2539         cipherList.add("InvalidCipher");
2540         SSLEngine server = null;
2541         try {
2542             serverSslCtx = wrapContext(null, SslContextBuilder.forServer(cert.key(), cert.cert())
2543                     .sslContextProvider(serverSslContextProvider())
2544                     .sslProvider(sslServerProvider())
2545                     .ciphers(cipherList).build());
2546             server = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2547             fail();
2548         } catch (IllegalArgumentException expected) {
2549         } catch (SSLException expected) {
2550         } finally {
2551             cert.delete();
2552             cleanupServerSslEngine(server);
2553         }
2554     }
2555     @MethodSource("newTestParams")
2556     @ParameterizedTest
2557     public void testGetCiphersuite(SSLEngineTestParam param) throws Exception {
2558         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
2559                                         .trustManager(InsecureTrustManagerFactory.INSTANCE)
2560                                         .sslProvider(sslClientProvider())
2561                                         .sslContextProvider(clientSslContextProvider())
2562                                         .protocols(param.protocols())
2563                                         .ciphers(param.ciphers())
2564                                         .build());
2565         SelfSignedCertificate ssc = new SelfSignedCertificate();
2566         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
2567                                         .sslProvider(sslServerProvider())
2568                                         .sslContextProvider(serverSslContextProvider())
2569                                         .protocols(param.protocols())
2570                                         .ciphers(param.ciphers())
2571                                         .build());
2572         SSLEngine clientEngine = null;
2573         SSLEngine serverEngine = null;
2574         try {
2575             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2576             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2577             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
2578             String clientCipher = clientEngine.getSession().getCipherSuite();
2579             String serverCipher = serverEngine.getSession().getCipherSuite();
2580             assertEquals(clientCipher, serverCipher);
2581             assertEquals(param.protocolCipherCombo.cipher, clientCipher);
2582         } finally {
2583             cleanupClientSslEngine(clientEngine);
2584             cleanupServerSslEngine(serverEngine);
2585             ssc.delete();
2586         }
2587     }
2588     @MethodSource("newTestParams")
2589     @ParameterizedTest
2590     public void testSessionCache(SSLEngineTestParam param) throws Exception {
2591         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
2592                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
2593                 .sslProvider(sslClientProvider())
2594                 .sslContextProvider(clientSslContextProvider())
2595                 .protocols(param.protocols())
2596                 .ciphers(param.ciphers())
2597                 .build());
2598 <a name="24"></a>        SelfSignedCertificate ssc = new SelfSignedCertificate();
2599         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
2600                 .sslProvider(sslServerProvider())
2601                 .sslContextProvider(<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>serverSslContextProvider())
2602                 .protocols(param.protocols())
2603                 .ciphers(param.ciphers())
2604                 .build());
2605         try {
2606             doHandshakeVerifyReusedAndClose(param, "a.netty.io", 9999, false);
2607             doHandshakeVerifyReusedAndClose(param, "a.netty.io", 9999, true);
2608             doHandshakeVerifyReusedAndClose</b></font>(param, "b.netty.io", 9999, false);
2609             invalidateSessionsAndAssert(serverSslCtx.sessionContext());
2610             invalidateSessionsAndAssert(clientSslCtx.sessionContext());
2611         } finally {
2612             ssc.delete();
2613         }
2614     }
2615     protected void invalidateSessionsAndAssert(SSLSessionContext context) {
2616         Enumeration&lt;byte[]&gt; ids = context.getIds();
2617         while (ids.hasMoreElements()) {
2618             byte[] id = ids.nextElement();
2619             SSLSession session = context.getSession(id);
2620             if (session != null) {
2621                 session.invalidate();
2622                 assertFalse(session.isValid());
2623                 assertNull(context.getSession(id));
2624             }
2625         }
2626     }
2627     private static void assertSessionCache(SSLSessionContext sessionContext, int numSessions) {
2628         Enumeration&lt;byte[]&gt; ids = sessionContext.getIds();
2629         int numIds = 0;
2630         while (ids.hasMoreElements()) {
2631             numIds++;
2632             byte[] id = ids.nextElement();
2633             assertNotEquals(0, id.length);
2634             SSLSession session = sessionContext.getSession(id);
2635             assertArrayEquals(id, session.getId());
2636         }
2637         assertEquals(numSessions, numIds);
2638     }
2639     private void doHandshakeVerifyReusedAndClose(SSLEngineTestParam param, String host, int port, boolean reuse)
2640             throws Exception {
2641         SSLEngine clientEngine = null;
2642         SSLEngine serverEngine = null;
2643         try {
2644             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT, host, port));
2645             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2646             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
2647             int clientSessions = currentSessionCacheSize(clientSslCtx.sessionContext());
2648             int serverSessions = currentSessionCacheSize(serverSslCtx.sessionContext());
2649             int nCSessions = clientSessions;
2650             int nSSessions = serverSessions;
2651             boolean clientSessionReused = false;
2652             boolean serverSessionReused = false;
2653             if (param.protocolCipherCombo == ProtocolCipherCombo.TLSV13) {
2654                 ByteBuffer packetBuffer = allocateBuffer(param.type(), 32 * 1024);
2655                 ByteBuffer appBuffer = allocateBuffer(param.type(), 32 * 1024);
2656                 appBuffer.clear().position(4).flip();
2657                 packetBuffer.clear();
2658                 do {
2659                     SSLEngineResult result;
2660                     do {
2661                         result = serverEngine.wrap(appBuffer, packetBuffer);
2662                     } while (appBuffer.hasRemaining() || result.bytesProduced() &gt; 0);
2663                     appBuffer.clear();
2664                     packetBuffer.flip();
2665                     do {
2666                         result = clientEngine.unwrap(packetBuffer, appBuffer);
2667                     } while (packetBuffer.hasRemaining() || result.bytesProduced() &gt; 0);
2668                     packetBuffer.clear();
2669                     appBuffer.clear().position(4).flip();
2670                     do {
2671                         result = clientEngine.wrap(appBuffer, packetBuffer);
2672                     } while (appBuffer.hasRemaining() || result.bytesProduced() &gt; 0);
2673                     appBuffer.clear();
2674                     packetBuffer.flip();
2675                     do {
2676                         result = serverEngine.unwrap(packetBuffer, appBuffer);
2677                     } while (packetBuffer.hasRemaining() || result.bytesProduced() &gt; 0);
2678                     packetBuffer.clear();
2679                     appBuffer.clear().position(4).flip();
2680                     nCSessions = currentSessionCacheSize(clientSslCtx.sessionContext());
2681                     nSSessions = currentSessionCacheSize(serverSslCtx.sessionContext());
2682                     clientSessionReused = isSessionMaybeReused(clientEngine);
2683                     serverSessionReused = isSessionMaybeReused(serverEngine);
2684                 } while ((reuse &amp;&amp; (!clientSessionReused || !serverSessionReused))
2685                         || (!reuse &amp;&amp; (nCSessions &lt; clientSessions ||
2686                         nSSessions &lt; serverSessions)));
2687             }
2688             assertSessionReusedForEngine(clientEngine, serverEngine, reuse);
2689             closeOutboundAndInbound(param.type(), clientEngine, serverEngine);
2690         } finally {
2691             cleanupClientSslEngine(clientEngine);
2692             cleanupServerSslEngine(serverEngine);
2693         }
2694     }
2695     protected boolean isSessionMaybeReused(SSLEngine engine) {
2696         return true;
2697     }
2698     private static int currentSessionCacheSize(SSLSessionContext ctx) {
2699         Enumeration&lt;byte[]&gt; ids = ctx.getIds();
2700         int i = 0;
2701         while (ids.hasMoreElements()) {
2702             i++;
2703             ids.nextElement();
2704         }
2705         return i;
2706     }
2707     private void closeOutboundAndInbound(
2708             BufferType type, SSLEngine clientEngine, SSLEngine serverEngine) throws SSLException {
2709         assertFalse(clientEngine.isInboundDone());
2710         assertFalse(clientEngine.isOutboundDone());
2711         assertFalse(serverEngine.isInboundDone());
2712         assertFalse(serverEngine.isOutboundDone());
2713         ByteBuffer empty = allocateBuffer(type, 0);
2714         ByteBuffer cTOs = allocateBuffer(type, clientEngine.getSession().getPacketBufferSize() * 4);
2715         ByteBuffer sTOs = allocateBuffer(type, serverEngine.getSession().getPacketBufferSize() * 4);
2716         ByteBuffer cApps = allocateBuffer(type, clientEngine.getSession().getApplicationBufferSize() * 4);
2717         ByteBuffer sApps = allocateBuffer(type, serverEngine.getSession().getApplicationBufferSize() * 4);
2718         clientEngine.closeOutbound();
2719         for (;;) {
2720             SSLEngineResult result = clientEngine.wrap(empty, cTOs);
2721             if (result.getStatus() == Status.CLOSED &amp;&amp; result.bytesProduced() == 0) {
2722                 break;
2723             }
2724             assertTrue(cTOs.hasRemaining());
2725         }
2726         cTOs.flip();
2727         for (;;) {
2728             SSLEngineResult result = serverEngine.unwrap(cTOs, sApps);
2729             if (result.getStatus() == Status.CLOSED &amp;&amp; result.bytesProduced() == 0) {
2730                 break;
2731             }
2732             assertTrue(sApps.hasRemaining());
2733         }
2734         serverEngine.closeOutbound();
2735         for (;;) {
2736             SSLEngineResult result = serverEngine.wrap(empty, sTOs);
2737             if (result.getStatus() == Status.CLOSED &amp;&amp; result.bytesProduced() == 0) {
2738                 break;
2739             }
2740             assertTrue(sTOs.hasRemaining());
2741         }
2742         sTOs.flip();
2743         for (;;) {
2744             SSLEngineResult result = clientEngine.unwrap(sTOs, cApps);
2745             if (result.getStatus() == Status.CLOSED &amp;&amp; result.bytesProduced() == 0) {
2746                 break;
2747             }
2748             assertTrue(cApps.hasRemaining());
2749         }
2750         clientEngine.closeInbound();
2751         serverEngine.closeInbound();
2752     }
2753     protected void assertSessionReusedForEngine(SSLEngine clientEngine, SSLEngine serverEngine, boolean reuse) {
2754     }
2755     @MethodSource("newTestParams")
2756     @ParameterizedTest
2757     public void testSessionCacheTimeout(SSLEngineTestParam param) throws Exception {
2758         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
2759                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
2760                 .sslProvider(sslClientProvider())
2761                 .sslContextProvider(clientSslContextProvider())
2762                 .protocols(param.protocols())
2763                 .ciphers(param.ciphers())
2764                 .sessionTimeout(1)
2765                 .build());
2766 <a name="23"></a>        SelfSignedCertificate ssc = new SelfSignedCertificate();
2767         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
2768                 .sslProvider(sslServerProvider())
2769                 .sslContextProvider(<font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>serverSslContextProvider())
2770                 .protocols(param.protocols())
2771                 .ciphers(param.ciphers())
2772                 .sessionTimeout(1)
2773                 .build());
2774         try {
2775             doHandshakeVerifyReusedAndClose(param, "a.netty.io", 9999, false);
2776             Thread.sleep(1500);
2777             assertSessionCache</b></font>(serverSslCtx.sessionContext(), 0);
2778             assertSessionCache(clientSslCtx.sessionContext(), 0);
2779         } finally {
2780             ssc.delete();
2781         }
2782     }
2783     @MethodSource("newTestParams")
2784     @ParameterizedTest
2785     public void testSessionCacheSize(SSLEngineTestParam param) throws Exception {
2786         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
2787                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
2788                 .sslProvider(sslClientProvider())
2789                 .sslContextProvider(clientSslContextProvider())
2790                 .protocols(param.protocols())
2791                 .ciphers(param.ciphers())
2792                 .sessionCacheSize(1)
2793                 .build());
2794         SelfSignedCertificate ssc = new SelfSignedCertificate();
2795         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
2796                 .sslProvider(sslServerProvider())
2797                 .sslContextProvider(serverSslContextProvider())
2798                 .protocols(param.protocols())
2799                 .ciphers(param.ciphers())
2800                 .build());
2801         try {
2802             doHandshakeVerifyReusedAndClose(param, "a.netty.io", 9999, false);
2803             doHandshakeVerifyReusedAndClose(param, "b.netty.io", 9999, false);
2804             doHandshakeVerifyReusedAndClose(param, "b.netty.io", 9999, true);
2805         } finally {
2806             ssc.delete();
2807         }
2808     }
2809     @MethodSource("newTestParams")
2810     @ParameterizedTest
2811     public void testSessionBindingEvent(SSLEngineTestParam param) throws Exception {
2812         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
2813                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
2814                 .sslProvider(sslClientProvider())
2815                 .sslContextProvider(clientSslContextProvider())
2816                 .protocols(param.protocols())
2817                 .ciphers(param.ciphers())
2818                 .build());
2819         SelfSignedCertificate ssc = new SelfSignedCertificate();
2820         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
2821                 .sslProvider(sslServerProvider())
2822                 .sslContextProvider(serverSslContextProvider())
2823                 .protocols(param.protocols())
2824                 .ciphers(param.ciphers())
2825                 .build());
2826         SSLEngine clientEngine = null;
2827         SSLEngine serverEngine = null;
2828         try {
2829             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2830             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2831             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
2832             SSLSession session = clientEngine.getSession();
2833             assertEquals(0, session.getValueNames().length);
2834             class SSLSessionBindingEventValue implements SSLSessionBindingListener {
2835                 SSLSessionBindingEvent boundEvent;
2836                 SSLSessionBindingEvent unboundEvent;
2837                 @Override
2838                 public void valueBound(SSLSessionBindingEvent sslSessionBindingEvent) {
2839                     assertNull(boundEvent);
2840                     boundEvent = sslSessionBindingEvent;
2841                 }
2842                 @Override
2843                 public void valueUnbound(SSLSessionBindingEvent sslSessionBindingEvent) {
2844                     assertNull(unboundEvent);
2845                     unboundEvent = sslSessionBindingEvent;
2846                 }
2847             }
2848             String name = "name";
2849             String name2 = "name2";
2850             SSLSessionBindingEventValue value1 = new SSLSessionBindingEventValue();
2851             session.putValue(name, value1);
2852             assertSSLSessionBindingEventValue(name, session, value1.boundEvent);
2853             assertNull(value1.unboundEvent);
2854             assertEquals(1, session.getValueNames().length);
2855             session.putValue(name2, "value");
2856             SSLSessionBindingEventValue value2 = new SSLSessionBindingEventValue();
2857             session.putValue(name, value2);
2858             assertEquals(2, session.getValueNames().length);
2859             assertSSLSessionBindingEventValue(name, session, value1.unboundEvent);
2860             assertSSLSessionBindingEventValue(name, session, value2.boundEvent);
2861             assertNull(value2.unboundEvent);
2862             assertEquals(2, session.getValueNames().length);
2863             session.removeValue(name);
2864             assertSSLSessionBindingEventValue(name, session, value2.unboundEvent);
2865             assertEquals(1, session.getValueNames().length);
2866             session.removeValue(name2);
2867         } finally {
2868             cleanupClientSslEngine(clientEngine);
2869             cleanupServerSslEngine(serverEngine);
2870             ssc.delete();
2871         }
2872     }
2873     private static void assertSSLSessionBindingEventValue(
2874             String name, SSLSession session, SSLSessionBindingEvent event) {
2875         assertEquals(name, event.getName());
2876         assertEquals(session, event.getSession());
2877         assertEquals(session, event.getSource());
2878     }
2879     @MethodSource("newTestParams")
2880     @ParameterizedTest
2881     public void testSessionAfterHandshake(SSLEngineTestParam param) throws Exception {
2882         testSessionAfterHandshake0(param, false, false);
2883     }
2884     @MethodSource("newTestParams")
2885     @ParameterizedTest
2886     public void testSessionAfterHandshakeMutualAuth(SSLEngineTestParam param) throws Exception {
2887         testSessionAfterHandshake0(param, false, true);
2888     }
2889     @MethodSource("newTestParams")
2890     @ParameterizedTest
2891     public void testSessionAfterHandshakeKeyManagerFactory(SSLEngineTestParam param) throws Exception {
2892         testSessionAfterHandshake0(param, true, false);
2893     }
2894     @MethodSource("newTestParams")
2895     @ParameterizedTest
2896     public void testSessionAfterHandshakeKeyManagerFactoryMutualAuth(SSLEngineTestParam param) throws Exception {
2897         testSessionAfterHandshake0(param, true, true);
2898     }
2899     private void testSessionAfterHandshake0(
2900             SSLEngineTestParam param, boolean useKeyManagerFactory, boolean mutualAuth) throws Exception {
2901         SelfSignedCertificate ssc = new SelfSignedCertificate();
2902         KeyManagerFactory kmf = useKeyManagerFactory ?
2903                 SslContext.buildKeyManagerFactory(
2904                         new java.security.cert.X509Certificate[] { ssc.cert()}, null,
2905                         ssc.key(), null, null, null) : null;
2906         SslContextBuilder clientContextBuilder = SslContextBuilder.forClient();
2907         if (mutualAuth) {
2908             if (kmf != null) {
2909                 clientContextBuilder.keyManager(kmf);
2910             } else {
2911                 clientContextBuilder.keyManager(ssc.key(), ssc.cert());
2912             }
2913         }
2914         clientSslCtx = wrapContext(param, clientContextBuilder
2915                                         .trustManager(InsecureTrustManagerFactory.INSTANCE)
2916                                         .sslProvider(sslClientProvider())
2917                                         .sslContextProvider(clientSslContextProvider())
2918                                         .protocols(param.protocols())
2919                                         .ciphers(param.ciphers())
2920                                         .build());
2921         SslContextBuilder serverContextBuilder = kmf != null ?
2922                 SslContextBuilder.forServer(kmf) :
2923                 SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey());
2924         if (mutualAuth) {
2925             serverContextBuilder.clientAuth(ClientAuth.REQUIRE);
2926         }
2927         serverSslCtx = wrapContext(param, serverContextBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE)
2928                                      .sslProvider(sslServerProvider())
2929                                      .sslContextProvider(serverSslContextProvider())
2930                                      .protocols(param.protocols())
2931                                      .ciphers(param.ciphers())
2932                                      .build());
2933         SSLEngine clientEngine = null;
2934         SSLEngine serverEngine = null;
2935         try {
2936             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2937             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
2938             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
2939             SSLSession clientSession = clientEngine.getSession();
2940             SSLSession serverSession = serverEngine.getSession();
2941             assertNull(clientSession.getPeerHost());
2942             assertNull(serverSession.getPeerHost());
2943             assertEquals(-1, clientSession.getPeerPort());
2944             assertEquals(-1, serverSession.getPeerPort());
2945             assertTrue(clientSession.getCreationTime() &gt; 0);
2946             assertTrue(serverSession.getCreationTime() &gt; 0);
2947             assertTrue(clientSession.getLastAccessedTime() &gt; 0);
2948             assertTrue(serverSession.getLastAccessedTime() &gt; 0);
2949             assertEquals(param.combo().protocol, clientSession.getProtocol());
2950             assertEquals(param.combo().protocol, serverSession.getProtocol());
2951             assertEquals(param.combo().cipher, clientSession.getCipherSuite());
2952             assertEquals(param.combo().cipher, serverSession.getCipherSuite());
2953             assertNotNull(clientSession.getId());
2954             assertNotNull(serverSession.getId());
2955             assertTrue(clientSession.getApplicationBufferSize() &gt; 0);
2956             assertTrue(serverSession.getApplicationBufferSize() &gt; 0);
2957             assertTrue(clientSession.getPacketBufferSize() &gt; 0);
2958             assertTrue(serverSession.getPacketBufferSize() &gt; 0);
2959             assertNotNull(clientSession.getSessionContext());
2960             if (PlatformDependent.javaVersion() != 14) {
2961                 assertNotNull(serverSession.getSessionContext());
2962             }
2963 <a name="1"></a>
2964             Object value = new Object();
2965             assertEquals(0, <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>clientSession.getValueNames().length);
2966             clientSession.putValue("test", value);
2967             assertEquals("test", clientSession.getValueNames()[0]);
2968             assertSame(value, clientSession.getValue("test"));
2969             clientSession.removeValue("test");
2970             assertEquals(0, clientSession.getValueNames().length);
2971             assertEquals(0, serverSession.getValueNames().length);
2972             serverSession.putValue("test", value);
2973             assertEquals("test", serverSession.getValueNames()[0]);
2974             assertSame(value, serverSession.getValue("test"));
2975             serverSession.removeValue("test");
2976             assertEquals(0, serverSession.getValueNames().length);
2977             Certificate[] serverLocalCertificates = serverSession.getLocalCertificates</b></font>();
2978             assertEquals(1, serverLocalCertificates.length);
2979             assertArrayEquals(ssc.cert().getEncoded(), serverLocalCertificates[0].getEncoded());
2980             Principal serverLocalPrincipal = serverSession.getLocalPrincipal();
2981             assertNotNull(serverLocalPrincipal);
2982             if (mutualAuth) {
2983                 Certificate[] clientLocalCertificates = clientSession.getLocalCertificates();
2984                 assertEquals(1, clientLocalCertificates.length);
2985                 Certificate[] serverPeerCertificates = serverSession.getPeerCertificates();
2986                 assertEquals(1, serverPeerCertificates.length);
2987                 assertArrayEquals(clientLocalCertificates[0].getEncoded(), serverPeerCertificates[0].getEncoded());
2988                 try {
2989                     X509Certificate[] serverPeerX509Certificates = serverSession.getPeerCertificateChain();
2990                     assertEquals(1, serverPeerX509Certificates.length);
2991                     assertArrayEquals(clientLocalCertificates[0].getEncoded(),
2992                             serverPeerX509Certificates[0].getEncoded());
2993                 } catch (UnsupportedOperationException e) {
2994                     assertTrue(PlatformDependent.javaVersion() &gt;= 15);
2995                 }
2996                 Principal clientLocalPrincipial = clientSession.getLocalPrincipal();
2997                 assertNotNull(clientLocalPrincipial);
2998                 Principal serverPeerPrincipal = serverSession.getPeerPrincipal();
2999                 assertEquals(clientLocalPrincipial, serverPeerPrincipal);
3000             } else {
3001                 assertNull(clientSession.getLocalCertificates());
3002                 assertNull(clientSession.getLocalPrincipal());
3003                 try {
3004                     serverSession.getPeerCertificates();
3005                     fail();
3006                 } catch (SSLPeerUnverifiedException expected) {
3007                 }
3008                 try {
3009                     serverSession.getPeerCertificateChain();
3010                     fail();
3011                 } catch (SSLPeerUnverifiedException expected) {
3012                 } catch (UnsupportedOperationException e) {
3013                     assertTrue(PlatformDependent.javaVersion() &gt;= 15);
3014                 }
3015                 try {
3016                     serverSession.getPeerPrincipal();
3017                     fail();
3018                 } catch (SSLPeerUnverifiedException expected) {
3019                 }
3020             }
3021             Certificate[] clientPeerCertificates = clientSession.getPeerCertificates();
3022             assertEquals(1, clientPeerCertificates.length);
3023             assertArrayEquals(serverLocalCertificates[0].getEncoded(), clientPeerCertificates[0].getEncoded());
3024             try {
3025                 X509Certificate[] clientPeerX509Certificates = clientSession.getPeerCertificateChain();
3026                 assertEquals(1, clientPeerX509Certificates.length);
3027                 assertArrayEquals(serverLocalCertificates[0].getEncoded(), clientPeerX509Certificates[0].getEncoded());
3028             } catch (UnsupportedOperationException e) {
3029                 assertTrue(PlatformDependent.javaVersion() &gt;= 15);
3030             }
3031             Principal clientPeerPrincipal = clientSession.getPeerPrincipal();
3032             assertEquals(serverLocalPrincipal, clientPeerPrincipal);
3033         } finally {
3034             cleanupClientSslEngine(clientEngine);
3035             cleanupServerSslEngine(serverEngine);
3036             ssc.delete();
3037         }
3038     }
3039     @MethodSource("newTestParams")
3040     @ParameterizedTest
3041     public void testSupportedSignatureAlgorithms(SSLEngineTestParam param) throws Exception {
3042         final SelfSignedCertificate ssc = new SelfSignedCertificate();
3043         final class TestKeyManagerFactory extends KeyManagerFactory {
3044             TestKeyManagerFactory(final KeyManagerFactory factory) {
3045                 super(new KeyManagerFactorySpi() {
3046 <a name="18"></a>                    private final KeyManager[] managers = factory.getKeyManagers();
3047                     @Override
3048                     protected void engineInit(<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>KeyStore keyStore, char[] chars)  {
3049                         throw new UnsupportedOperationException();
3050                     }
3051                     @</b></font>Override
3052                     protected void engineInit(ManagerFactoryParameters managerFactoryParameters) {
3053                         throw new UnsupportedOperationException();
3054                     }
3055                     @Override
3056                     protected KeyManager[] engineGetKeyManagers() {
3057                         KeyManager[] array = new KeyManager[managers.length];
3058                         for (int i = 0 ; i &lt; array.length; i++) {
3059                             final X509ExtendedKeyManager x509ExtendedKeyManager = (X509ExtendedKeyManager) managers[i];
3060                             array[i] = new X509ExtendedKeyManager() {
3061                                 @Override
3062                                 public String[] getClientAliases(String s, Principal[] principals) {
3063                                     fail();
3064                                     return null;
3065                                 }
3066                                 @Override
3067                                 public String chooseClientAlias(
3068                                         String[] strings, Principal[] principals, Socket socket) {
3069                                     fail();
3070                                     return null;
3071                                 }
3072                                 @Override
3073                                 public String[] getServerAliases(String s, Principal[] principals) {
3074                                     fail();
3075                                     return null;
3076                                 }
3077                                 @Override
3078                                 public String chooseServerAlias(String s, Principal[] principals, Socket socket) {
3079                                     fail();
3080                                     return null;
3081                                 }
3082                                 @Override
3083                                 public String chooseEngineClientAlias(
3084                                         String[] strings, Principal[] principals, SSLEngine sslEngine) {
3085                                     assertNotEquals(0, ((ExtendedSSLSession) sslEngine.getHandshakeSession())
3086                                             .getPeerSupportedSignatureAlgorithms().length);
3087                                     assertNotEquals(0, ((ExtendedSSLSession) sslEngine.getHandshakeSession())
3088                                             .getLocalSupportedSignatureAlgorithms().length);
3089                                     return x509ExtendedKeyManager.chooseEngineClientAlias(
3090                                             strings, principals, sslEngine);
3091                                 }
3092                                 @Override
3093                                 public String chooseEngineServerAlias(
3094                                         String s, Principal[] principals, SSLEngine sslEngine) {
3095                                     assertNotEquals(0, ((ExtendedSSLSession) sslEngine.getHandshakeSession())
3096                                             .getPeerSupportedSignatureAlgorithms().length);
3097                                     assertNotEquals(0, ((ExtendedSSLSession) sslEngine.getHandshakeSession())
3098                                             .getLocalSupportedSignatureAlgorithms().length);
3099                                     return x509ExtendedKeyManager.chooseEngineServerAlias(s, principals, sslEngine);
3100                                 }
3101                                 @Override
3102                                 public java.security.cert.X509Certificate[] getCertificateChain(String s) {
3103                                     return x509ExtendedKeyManager.getCertificateChain(s);
3104                                 }
3105                                 @Override
3106                                 public PrivateKey getPrivateKey(String s) {
3107                                     return x509ExtendedKeyManager.getPrivateKey(s);
3108                                 }
3109                             };
3110                         }
3111                         return array;
3112                     }
3113                 }, factory.getProvider(), factory.getAlgorithm());
3114             }
3115         }
3116         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
3117                 .keyManager(new TestKeyManagerFactory(newKeyManagerFactory(ssc)))
3118                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
3119                 .sslProvider(sslClientProvider())
3120                 .sslContextProvider(clientSslContextProvider())
3121                 .protocols(param.protocols())
3122                 .ciphers(param.ciphers())
3123                 .build());
3124         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(
3125                 new TestKeyManagerFactory(newKeyManagerFactory(ssc)))
3126                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
3127                 .sslContextProvider(serverSslContextProvider())
3128                 .sslProvider(sslServerProvider())
3129                 .protocols(param.protocols())
3130                 .ciphers(param.ciphers())
3131                 .clientAuth(ClientAuth.REQUIRE)
3132                 .build());
3133         SSLEngine clientEngine = null;
3134         SSLEngine serverEngine = null;
3135         try {
3136             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3137             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3138             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
3139         } finally {
3140             cleanupClientSslEngine(clientEngine);
3141             cleanupServerSslEngine(serverEngine);
3142             ssc.delete();
3143         }
3144     }
3145     @MethodSource("newTestParams")
3146     @ParameterizedTest
3147     public void testHandshakeSession(SSLEngineTestParam param) throws Exception {
3148         final SelfSignedCertificate ssc = new SelfSignedCertificate();
3149         final TestTrustManagerFactory clientTmf = new TestTrustManagerFactory(ssc.cert());
3150         final TestTrustManagerFactory serverTmf = new TestTrustManagerFactory(ssc.cert());
3151         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
3152                 .trustManager(new SimpleTrustManagerFactory() {
3153                     @Override
3154                     protected void engineInit(KeyStore keyStore) {
3155                     }
3156                     @Override
3157                     protected void engineInit(ManagerFactoryParameters managerFactoryParameters) {
3158                     }
3159                     @Override
3160                     protected TrustManager[] engineGetTrustManagers() {
3161                         return new TrustManager[] { clientTmf };
3162                     }
3163                 })
3164                 .keyManager(newKeyManagerFactory(ssc))
3165                 .sslProvider(sslClientProvider())
3166                 .sslContextProvider(clientSslContextProvider())
3167                 .protocols(param.protocols())
3168                 .ciphers(param.ciphers())
3169                 .build());
3170         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(newKeyManagerFactory(ssc))
3171                 .trustManager(new SimpleTrustManagerFactory() {
3172                     @Override
3173                     protected void engineInit(KeyStore keyStore) {
3174                     }
3175                     @Override
3176                     protected void engineInit(ManagerFactoryParameters managerFactoryParameters) {
3177                     }
3178                     @Override
3179                     protected TrustManager[] engineGetTrustManagers() {
3180                         return new TrustManager[] { serverTmf };
3181                     }
3182                 })
3183                 .sslProvider(sslServerProvider())
3184                 .sslContextProvider(serverSslContextProvider())
3185                 .protocols(param.protocols())
3186                 .ciphers(param.ciphers())
3187                 .clientAuth(ClientAuth.REQUIRE)
3188                 .build());
3189         SSLEngine clientEngine = null;
3190         SSLEngine serverEngine = null;
3191         try {
3192             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3193             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3194             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
3195             assertTrue(clientTmf.isVerified());
3196             assertTrue(serverTmf.isVerified());
3197         } finally {
3198             cleanupClientSslEngine(clientEngine);
3199             cleanupServerSslEngine(serverEngine);
3200             ssc.delete();
3201         }
3202     }
3203     @MethodSource("newTestParams")
3204     @ParameterizedTest
3205     public void testSessionLocalWhenNonMutualWithKeyManager(SSLEngineTestParam param) throws Exception {
3206         testSessionLocalWhenNonMutual(param, true);
3207     }
3208     @MethodSource("newTestParams")
3209     @ParameterizedTest
3210     public void testSessionLocalWhenNonMutualWithoutKeyManager(SSLEngineTestParam param) throws Exception {
3211         testSessionLocalWhenNonMutual(param, false);
3212     }
3213     private void testSessionLocalWhenNonMutual(SSLEngineTestParam param, boolean useKeyManager) throws Exception {
3214         final SelfSignedCertificate ssc = new SelfSignedCertificate();
3215         SslContextBuilder clientSslCtxBuilder = SslContextBuilder.forClient()
3216                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
3217                 .sslProvider(sslClientProvider())
3218                 .sslContextProvider(clientSslContextProvider())
3219 <a name="20"></a>                .protocols(param.protocols())
3220                 .ciphers(param.ciphers());
3221         <font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if (useKeyManager) {
3222             clientSslCtxBuilder.keyManager(newKeyManagerFactory(ssc));
3223         } else {
3224             clientSslCtxBuilder.keyManager(ssc.certificate</b></font>(), ssc.privateKey());
3225         }
3226         clientSslCtx = wrapContext(param, clientSslCtxBuilder.build());
3227         final SslContextBuilder serverSslCtxBuilder;
3228 <a name="7"></a>        if (useKeyManager) {
3229             serverSslCtxBuilder = SslContextBuilder.forServer(newKeyManagerFactory(ssc));
3230         } else {
3231             serverSslCtxBuilder = <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey());
3232         }
3233         serverSslCtxBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE)
3234                 .sslProvider(sslServerProvider())
3235                 .sslContextProvider(serverSslContextProvider</b></font>())
3236                 .protocols(param.protocols())
3237                 .ciphers(param.ciphers())
3238                 .clientAuth(ClientAuth.NONE);
3239         serverSslCtx = wrapContext(param, serverSslCtxBuilder.build());
3240         SSLEngine clientEngine = null;
3241         SSLEngine serverEngine = null;
3242         try {
3243             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3244             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3245             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
3246             SSLSession clientSession = clientEngine.getSession();
3247             assertNull(clientSession.getLocalCertificates());
3248             assertNull(clientSession.getLocalPrincipal());
3249             SSLSession serverSession = serverEngine.getSession();
3250             assertNotNull(serverSession.getLocalCertificates());
3251             assertNotNull(serverSession.getLocalPrincipal());
3252         } finally {
3253             cleanupClientSslEngine(clientEngine);
3254             cleanupServerSslEngine(serverEngine);
3255             ssc.delete();
3256         }
3257     }
3258     @MethodSource("newTestParams")
3259     @ParameterizedTest
3260     public void testEnabledProtocolsAndCiphers(SSLEngineTestParam param) throws Exception {
3261         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
3262                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
3263                 .sslProvider(sslClientProvider())
3264                 .sslContextProvider(clientSslContextProvider())
3265                 .protocols(param.protocols())
3266                 .ciphers(param.ciphers())
3267                 .build());
3268         SelfSignedCertificate ssc = new SelfSignedCertificate();
3269         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
3270                 .sslProvider(sslServerProvider())
3271                 .sslContextProvider(serverSslContextProvider())
3272                 .protocols(param.protocols())
3273                 .ciphers(param.ciphers())
3274                 .build());
3275         SSLEngine clientEngine = null;
3276         SSLEngine serverEngine = null;
3277         try {
3278             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3279             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3280             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
3281             assertEnabledProtocolsAndCipherSuites(clientEngine);
3282             assertEnabledProtocolsAndCipherSuites(serverEngine);
3283         } finally {
3284             cleanupClientSslEngine(clientEngine);
3285             cleanupServerSslEngine(serverEngine);
3286             ssc.delete();
3287         }
3288     }
3289     private static void assertEnabledProtocolsAndCipherSuites(SSLEngine engine) {
3290         String protocol = engine.getSession().getProtocol();
3291         String cipherSuite = engine.getSession().getCipherSuite();
3292         assertArrayContains(protocol, engine.getEnabledProtocols());
3293         assertArrayContains(cipherSuite, engine.getEnabledCipherSuites());
3294     }
3295     private static void assertArrayContains(String expected, String[] array) {
3296         for (String value: array) {
3297             if (expected.equals(value)) {
3298                 return;
3299             }
3300         }
3301         fail("Array did not contain '" + expected + "':" + Arrays.toString(array));
3302     }
3303     @MethodSource("newTestParams")
3304     @ParameterizedTest
3305     public void testMasterKeyLogging(final SSLEngineTestParam param) throws Exception {
3306         if (param.combo() != ProtocolCipherCombo.tlsv12()) {
3307             return;
3308         }
3309         /*
3310          * At the moment master key logging is not supported for conscrypt
3311          */
3312         assumeFalse(serverSslContextProvider() instanceof OpenSSLProvider);
3313         /*
3314          * The JDK SSL engine master key retrieval relies on being able to set field access to true.
3315          * That is not available in JDK9+
3316          */
3317         assumeFalse(sslServerProvider() == SslProvider.JDK &amp;&amp; PlatformDependent.javaVersion() &gt; 8);
3318         String originalSystemPropertyValue = SystemPropertyUtil.get(SslMasterKeyHandler.SYSTEM_PROP_KEY);
3319         System.setProperty(SslMasterKeyHandler.SYSTEM_PROP_KEY, Boolean.TRUE.toString());
3320         SelfSignedCertificate ssc = new SelfSignedCertificate();
3321         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
3322                 .sslProvider(sslServerProvider())
3323                 .sslContextProvider(serverSslContextProvider())
3324                 .protocols(param.protocols())
3325                 .ciphers(param.ciphers())
3326                 .build());
3327         Socket socket = null;
3328         try {
3329             sb = new ServerBootstrap();
3330             sb.group(new NioEventLoopGroup(), new NioEventLoopGroup());
3331             sb.channel(NioServerSocketChannel.class);
3332             final Promise&lt;SecretKey&gt; promise = sb.config().group().next().newPromise();
3333             serverChannel = sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
3334                 @Override
3335                 protected void initChannel(Channel ch) {
3336                     ch.config().setAllocator(new TestByteBufAllocator(ch.config().getAllocator(), param.type()));
3337                     SslHandler sslHandler = !param.delegate() ?
3338                             serverSslCtx.newHandler(ch.alloc()) :
3339                             serverSslCtx.newHandler(ch.alloc(), delegatingExecutor);
3340                     ch.pipeline().addLast(sslHandler);
3341                     ch.pipeline().addLast(new SslMasterKeyHandler() {
3342                         @Override
3343                         protected void accept(SecretKey masterKey, SSLSession session) {
3344                             promise.setSuccess(masterKey);
3345                         }
3346                     });
3347                     serverConnectedChannel = ch;
3348                 }
3349             }).bind(new InetSocketAddress(0)).sync().channel();
3350             int port = ((InetSocketAddress) serverChannel.localAddress()).getPort();
3351             SSLContext sslContext = SSLContext.getInstance("TLS");
3352             sslContext.init(null, InsecureTrustManagerFactory.INSTANCE.getTrustManagers(), null);
3353             socket = sslContext.getSocketFactory().createSocket(NetUtil.LOCALHOST, port);
3354             OutputStream out = socket.getOutputStream();
3355             out.write(1);
3356             out.flush();
3357             assertTrue(promise.await(10, TimeUnit.SECONDS));
3358             SecretKey key = promise.get();
3359             assertEquals(48, key.getEncoded().length, "AES secret key must be 48 bytes");
3360         } finally {
3361             closeQuietly(socket);
3362             if (originalSystemPropertyValue != null) {
3363                 System.setProperty(SslMasterKeyHandler.SYSTEM_PROP_KEY, originalSystemPropertyValue);
3364             } else {
3365                 System.clearProperty(SslMasterKeyHandler.SYSTEM_PROP_KEY);
3366             }
3367             ssc.delete();
3368         }
3369     }
3370     private static void closeQuietly(Closeable c) {
3371         if (c != null) {
3372             try {
3373                 c.close();
3374             } catch (IOException ignore) {
3375             }
3376         }
3377     }
3378     private static KeyManagerFactory newKeyManagerFactory(SelfSignedCertificate ssc)
3379             throws UnrecoverableKeyException, KeyStoreException, NoSuchAlgorithmException,
3380             CertificateException, IOException {
3381         return SslContext.buildKeyManagerFactory(
3382                 new java.security.cert.X509Certificate[] { ssc.cert() }, null, ssc.key(), null, null, null);
3383     }
3384     private static final class TestTrustManagerFactory extends X509ExtendedTrustManager {
3385         private final Certificate localCert;
3386         private volatile boolean verified;
3387         TestTrustManagerFactory(Certificate localCert) {
3388             this.localCert = localCert;
3389         }
3390         boolean isVerified() {
3391             return verified;
3392         }
3393         @Override
3394         public void checkClientTrusted(
3395                 java.security.cert.X509Certificate[] x509Certificates, String s, Socket socket) {
3396             fail();
3397         }
3398         @Override
3399         public void checkServerTrusted(
3400                 java.security.cert.X509Certificate[] x509Certificates, String s, Socket socket) {
3401             fail();
3402         }
3403         @Override
3404         public void checkClientTrusted(
3405                 java.security.cert.X509Certificate[] x509Certificates, String s, SSLEngine sslEngine) {
3406             verified = true;
3407             assertFalse(sslEngine.getUseClientMode());
3408             SSLSession session = sslEngine.getHandshakeSession();
3409             assertNotNull(session);
3410             Certificate[] localCertificates = session.getLocalCertificates();
3411             assertNotNull(localCertificates);
3412             assertEquals(1, localCertificates.length);
3413             assertEquals(localCert, localCertificates[0]);
3414             assertNotNull(session.getLocalPrincipal());
3415         }
3416         @Override
3417         public void checkServerTrusted(
3418                 java.security.cert.X509Certificate[] x509Certificates, String s, SSLEngine sslEngine) {
3419             verified = true;
3420             assertTrue(sslEngine.getUseClientMode());
3421             SSLSession session = sslEngine.getHandshakeSession();
3422             assertNotNull(session);
3423             assertNull(session.getLocalCertificates());
3424             assertNull(session.getLocalPrincipal());
3425         }
3426         @Override
3427         public void checkClientTrusted(
3428                 java.security.cert.X509Certificate[] x509Certificates, String s) {
3429             fail();
3430         }
3431         @Override
3432         public void checkServerTrusted(
3433                 java.security.cert.X509Certificate[] x509Certificates, String s) {
3434             fail();
3435         }
3436         @Override
3437         public java.security.cert.X509Certificate[] getAcceptedIssuers() {
3438             return EmptyArrays.EMPTY_X509_CERTIFICATES;
3439         }
3440     }
3441     @MethodSource("newTestParams")
3442     @ParameterizedTest
3443     public void testDefaultProtocolsIncludeTLSv13(SSLEngineTestParam param) throws Exception {
3444         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
3445                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
3446                 .sslProvider(sslClientProvider())
3447                 .sslContextProvider(clientSslContextProvider())
3448                 .ciphers(param.ciphers())
3449                 .build());
3450         SelfSignedCertificate ssc = new SelfSignedCertificate();
3451         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
3452                 .sslProvider(sslServerProvider())
3453                 .sslContextProvider(serverSslContextProvider())
3454                 .ciphers(param.ciphers())
3455                 .build());
3456         SSLEngine clientEngine = null;
3457         SSLEngine serverEngine = null;
3458         String[] clientProtocols;
3459         String[] serverProtocols;
3460         try {
3461             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3462             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3463             clientProtocols = clientEngine.getEnabledProtocols();
3464             serverProtocols = serverEngine.getEnabledProtocols();
3465         } finally {
3466             cleanupClientSslEngine(clientEngine);
3467             cleanupServerSslEngine(serverEngine);
3468             ssc.delete();
3469         }
3470         assertEquals(SslProvider.isTlsv13EnabledByDefault(sslClientProvider(), clientSslContextProvider()),
3471                 arrayContains(clientProtocols, SslProtocols.TLS_v1_3));
3472         assertEquals(SslProvider.isTlsv13EnabledByDefault(sslServerProvider(), serverSslContextProvider()),
3473                 arrayContains(serverProtocols, SslProtocols.TLS_v1_3));
3474     }
3475     @MethodSource("newTestParams")
3476     @ParameterizedTest
3477     public void testRSASSAPSS(SSLEngineTestParam param) throws Exception {
3478         char[] password = "password".toCharArray();
3479         final KeyStore serverKeyStore = KeyStore.getInstance("PKCS12");
3480         serverKeyStore.load(getClass().getResourceAsStream("rsaValidations-server-keystore.p12"), password);
3481         final KeyStore clientKeyStore = KeyStore.getInstance("PKCS12");
3482         clientKeyStore.load(getClass().getResourceAsStream("rsaValidation-user-certs.p12"), password);
3483         final KeyManagerFactory serverKeyManagerFactory =
3484                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
3485         serverKeyManagerFactory.init(serverKeyStore, password);
3486         final KeyManagerFactory clientKeyManagerFactory =
3487                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
3488         clientKeyManagerFactory.init(clientKeyStore, password);
3489         File commonChain = ResourcesUtil.getFile(getClass(), "rsapss-ca-cert.cert");
3490         ClientAuth auth = ClientAuth.REQUIRE;
3491         mySetupMutualAuth(param, serverKeyManagerFactory, commonChain, clientKeyManagerFactory, commonChain,
3492                 auth, false, true);
3493         assertTrue(clientLatch.await(10, TimeUnit.SECONDS));
3494         rethrowIfNotNull(clientException);
3495         assertTrue(serverLatch.await(5, TimeUnit.SECONDS));
3496         rethrowIfNotNull(serverException);
3497     }
3498     @MethodSource("newTestParams")
3499     @ParameterizedTest
3500     public void testInvalidSNIIsIgnoredAndNotThrow(SSLEngineTestParam param) throws Exception {
3501         clientSslCtx = wrapContext(param, SslContextBuilder.forClient()
3502                 .trustManager(InsecureTrustManagerFactory.INSTANCE)
3503                 .sslProvider(sslClientProvider())
3504                 .sslContextProvider(clientSslContextProvider())
3505                 .protocols(param.protocols())
3506                 .ciphers(param.ciphers())
3507                 .build());
3508         SelfSignedCertificate ssc = new SelfSignedCertificate();
3509         serverSslCtx = wrapContext(param, SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
3510                 .sslProvider(sslServerProvider())
3511                 .sslContextProvider(serverSslContextProvider())
3512                 .protocols(param.protocols())
3513                 .ciphers(param.ciphers())
3514                 .build());
3515         SSLEngine clientEngine = null;
3516         SSLEngine serverEngine = null;
3517         try {
3518             clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT, "/invalid.path", 80));
3519             serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));
3520             handshake(param.type(), param.delegate(), clientEngine, serverEngine);
3521             assertNotNull(clientEngine.getSSLParameters());
3522             assertNotNull(serverEngine.getSSLParameters());
3523         } finally {
3524             cleanupClientSslEngine(clientEngine);
3525             cleanupServerSslEngine(serverEngine);
3526         }
3527     }
3528     protected SSLEngine wrapEngine(SSLEngine engine) {
3529         return engine;
3530     }
3531     protected SslContext wrapContext(SSLEngineTestParam param, SslContext context) {
3532         return context;
3533     }
3534 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
