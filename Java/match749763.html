<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for CharArrayAsListTest.java &amp; FluentIterable_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for CharArrayAsListTest.java &amp; FluentIterable_1.java
      </h3>
<h1 align="center">
        9.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>CharArrayAsListTest.java (18.65285%)<th>FluentIterable_1.java (6.239168%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-40)<td><a href="#" name="0">(24-111)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(80-85)<td><a href="#" name="1">(301-306)</a><td align="center"><font color="#960000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(48-55)<td><a href="#" name="2">(509-524)</a><td align="center"><font color="#870000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CharArrayAsListTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2008 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<a name="0"></a>
package com.google.common.primitives;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.testing.ListTestSuiteBuilder;
import com.google.common.collect.testing.SampleElements;
import com.google.common.collect.testing.TestListGenerator;
import com.google.common.collect.testing.features.CollectionFeature;
import com.google.common.collect.testing.features.CollectionSize;
import com.google.common.collect.testing.features.ListFeature;
import java.util.List;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

/**
 * Test suite covering {@link Chars#asList(char[])}.
 *
 * @author Kevin Bourrillion
 */
@GwtCompatible(e</b></font>mulated = true)
public class CharArrayAsListTest extends TestCase {

  private static List&lt;Character&gt; asList(Character[] values) {
    char[] temp = new char[values.length];
<a name="2"></a>    for (int i = 0; i &lt; values.length; i++) {
      temp[i] = checkNotNull(values[i]); // checkNotNull for GWT (do not optimize).
    }
    return <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Chars.asList(temp);
  }

  @GwtIncompatible // suite
  public static Test suite() {
    List&lt;ListTestSuiteBuilder&lt;Character&gt;&gt; builders =
        ImmutableList.of(
            ListTestSuiteBuilder.using(new CharsAsListGenerator()).named</b></font>("Chars.asList"),
            ListTestSuiteBuilder.using(new CharsAsListHeadSubListGenerator())
                .named("Chars.asList, head subList"),
            ListTestSuiteBuilder.using(new CharsAsListTailSubListGenerator())
                .named("Chars.asList, tail subList"),
            ListTestSuiteBuilder.using(new CharsAsListMiddleSubListGenerator())
                .named("Chars.asList, middle subList"));

    TestSuite suite = new TestSuite();
    for (ListTestSuiteBuilder&lt;Character&gt; builder : builders) {
      suite.addTest(
          builder
              .withFeatures(
                  CollectionSize.ONE,
                  CollectionSize.SEVERAL,
                  CollectionFeature.RESTRICTS_ELEMENTS,
                  ListFeature.SUPPORTS_SET)
              .createTestSuite());
    }
    return suite;
  }

<a name="1"></a>  // Test generators.  To let the GWT test suite generator access them, they need to be
  // public named classes with a public default constructor.

  <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>public static final class CharsAsListGenerator extends TestCharListGenerator {
    @Override
    protected List&lt;Character&gt; create(Character[] elements) {
      return asList(elements);
    }
  }</b></font>

  public static final class CharsAsListHeadSubListGenerator extends TestCharListGenerator {
    @Override
    protected List&lt;Character&gt; create(Character[] elements) {
      Character[] suffix = {Character.MIN_VALUE, Character.MAX_VALUE};
      Character[] all = concat(elements, suffix);
      return asList(all).subList(0, elements.length);
    }
  }

  public static final class CharsAsListTailSubListGenerator extends TestCharListGenerator {
    @Override
    protected List&lt;Character&gt; create(Character[] elements) {
      Character[] prefix = {(char) 86, (char) 99};
      Character[] all = concat(prefix, elements);
      return asList(all).subList(2, elements.length + 2);
    }
  }

  public static final class CharsAsListMiddleSubListGenerator extends TestCharListGenerator {
    @Override
    protected List&lt;Character&gt; create(Character[] elements) {
      Character[] prefix = {Character.MIN_VALUE, Character.MAX_VALUE};
      Character[] suffix = {(char) 86, (char) 99};
      Character[] all = concat(concat(prefix, elements), suffix);
      return asList(all).subList(2, elements.length + 2);
    }
  }

  private static Character[] concat(Character[] left, Character[] right) {
    Character[] result = new Character[left.length + right.length];
    System.arraycopy(left, 0, result, 0, left.length);
    System.arraycopy(right, 0, result, left.length, right.length);
    return result;
  }

  public abstract static class TestCharListGenerator implements TestListGenerator&lt;Character&gt; {
    @Override
    public SampleElements&lt;Character&gt; samples() {
      return new SampleChars();
    }

    @Override
    public List&lt;Character&gt; create(Object... elements) {
      Character[] array = new Character[elements.length];
      int i = 0;
      for (Object e : elements) {
        array[i++] = (Character) e;
      }
      return create(array);
    }

    /**
     * Creates a new collection containing the given elements; implement this method instead of
     * {@link #create(Object...)}.
     */
    protected abstract List&lt;Character&gt; create(Character[] elements);

    @Override
    public Character[] createArray(int length) {
      return new Character[length];
    }

    /** Returns the original element list, unchanged. */
    @Override
    public List&lt;Character&gt; order(List&lt;Character&gt; insertionOrder) {
      return insertionOrder;
    }
  }

  public static class SampleChars extends SampleElements&lt;Character&gt; {
    public SampleChars() {
      super((char) 0, (char) 1, (char) 2, (char) 3, (char) 4);
    }
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>FluentIterable_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (C) 2008 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
<a name="0"></a>import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.InlineMe;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.SortedSet;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A discouraged (but not deprecated) precursor to Java's superior {@link Stream} library.
 *
 * &lt;p&gt;The following types of methods are provided:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;chaining methods which return a new {@code FluentIterable} based in some way on the
 *       contents of the current one (for example {@link #transform})
 *   &lt;li&gt;element extraction methods which facilitate the retrieval of certain elements (for example
 *       {@link #last})
 *   &lt;li&gt;query methods which answer questions about the {@code FluentIterable}'s contents (for
 *       example {@link #anyMatch})
 *   &lt;li&gt;conversion methods which copy the {@code FluentIterable}'s contents into a new collection
 *       or array (for example {@link #toList})
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Several lesser-used features are currently available only as static methods on the {@link
 * Iterables} class.
 *
 * &lt;p&gt;&lt;a id="streams"&gt;&lt;/a&gt;
 *
 * &lt;h3&gt;Comparison to streams&lt;/h3&gt;
 *
 * &lt;p&gt;{@link Stream} is similar to this class, but generally more powerful, and certainly more
 * standard. Key differences include:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;A stream is &lt;i&gt;single-use&lt;/i&gt;; it becomes invalid as soon as any "terminal operation" such
 *       as {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream}
 *       contains all the right method &lt;i&gt;signatures&lt;/i&gt; to implement {@link Iterable}, it does not
 *       actually do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other
 *       hand, is multiple-use, and does implement {@link Iterable}.
 *   &lt;li&gt;Streams offer many features not found here, including {@code min/max}, {@code distinct},
 *       {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in support for
 *       parallelizing stream operations.
 *   &lt;li&gt;{@code FluentIterable} contains several features not available on {@code Stream}, which are
 *       noted in the method descriptions below.
 *   &lt;li&gt;Streams include primitive-specialized variants such as {@code IntStream}, the use of which
 *       is strongly recommended.
 *   &lt;li&gt;Streams are standard Java, not requiring a third-party dependency.
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example&lt;/h3&gt;
 *
 * &lt;p&gt;Here is an example that accepts a list from a database call, filters it based on a predicate,
 * transforms it by invoking {@code toString()} on each element, and returns the first 10 elements
 * as a {@code List}:
 *
 * &lt;pre&gt;{@code
 * ImmutableList&lt;String&gt; results =
 *     FluentIterable.from(database.getClientList())
 *         .filter(Client::isActiveInLastMonth)
 *         .transform(Object::toString)
 *         .limit(10)
 *         .toList();
 * }&lt;/pre&gt;
 *
 * The approximate stream equivalent is:
 *
 * &lt;pre&gt;{@code
 * List&lt;String&gt; results =
 *     database.getClientList()
 *         .stream()
 *         .filter(Client::isActiveInLastMonth)
 *         .map(Object::toString)
 *         .limit(10)
 *         .collect(Collectors.toList());
 * }&lt;/pre&gt;
 *
 * @author Marcin Mikosik
 * @since 12.0
 */
@GwtCompatible(e</b></font>mulated = true)
@ElementTypesAreNonnullByDefault
public abstract class FluentIterable&lt;E extends @Nullable Object&gt; implements Iterable&lt;E&gt; {
  // We store 'iterable' and use it instead of 'this' to allow Iterables to perform instanceof
  // checks on the _original_ iterable when FluentIterable.from is used.
  // To avoid a self retain cycle under j2objc, we store Optional.absent() instead of
  // Optional.of(this). To access the delegate iterable, call #getDelegate(), which converts to
  // absent() back to 'this'.
  private final Optional&lt;Iterable&lt;E&gt;&gt; iterableDelegate;

  /** Constructor for use by subclasses. */
  protected FluentIterable() {
    this.iterableDelegate = Optional.absent();
  }

  FluentIterable(Iterable&lt;E&gt; iterable) {
    this.iterableDelegate = Optional.of(iterable);
  }

  private Iterable&lt;E&gt; getDelegate() {
    return iterableDelegate.or(this);
  }

  /**
   * Returns a fluent iterable that wraps {@code iterable}, or {@code iterable} itself if it is
   * already a {@code FluentIterable}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Collection#stream} if {@code iterable} is a {@link
   * Collection}; {@link Streams#stream(Iterable)} otherwise.
   */
  public static &lt;E extends @Nullable Object&gt; FluentIterable&lt;E&gt; from(final Iterable&lt;E&gt; iterable) {
    return (iterable instanceof FluentIterable)
        ? (FluentIterable&lt;E&gt;) iterable
        : new FluentIterable&lt;E&gt;(iterable) {
          @Override
          public Iterator&lt;E&gt; iterator() {
            return iterable.iterator();
          }
        };
  }

  /**
   * Returns a fluent iterable containing {@code elements} in the specified order.
   *
   * &lt;p&gt;The returned iterable is an unmodifiable view of the input array.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link java.util.stream.Stream#of(Object[])
   * Stream.of(T...)}.
   *
   * @since 20.0 (since 18.0 as an overload of {@code of})
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; FluentIterable&lt;E&gt; from(E[] elements) {
    return from(Arrays.asList(elements));
  }

  /**
   * Construct a fluent iterable from another fluent iterable. This is obviously never necessary,
   * but is intended to help call out cases where one migration from {@code Iterable} to {@code
   * FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.
   *
   * @deprecated instances of {@code FluentIterable} don't need to be converted to {@code
   *     FluentIterable}
   */
  @Deprecated
  @InlineMe(
      replacement = "checkNotNull(iterable)",
      staticImports = {"com.google.common.base.Preconditions.checkNotNull"})
  public static &lt;E extends @Nullable Object&gt; FluentIterable&lt;E&gt; from(FluentIterable&lt;E&gt; iterable) {
    return checkNotNull(iterable);
  }

  /**
   * Returns a fluent iterable that combines two iterables. The returned iterable has an iterator
   * that traverses the elements in {@code a}, followed by the elements in {@code b}. The source
   * iterators are not polled until necessary.
   *
   * &lt;p&gt;The returned iterable's iterator supports {@code remove()} when the corresponding input
   * iterator supports it.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#concat}.
   *
   * @since 20.0
   */
  @Beta
  public static &lt;T extends @Nullable Object&gt; FluentIterable&lt;T&gt; concat(
      Iterable&lt;? extends T&gt; a, Iterable&lt;? extends T&gt; b) {
    return concatNoDefensiveCopy(a, b);
  }

  /**
   * Returns a fluent iterable that combines three iterables. The returned iterable has an iterator
   * that traverses the elements in {@code a}, followed by the elements in {@code b}, followed by
   * the elements in {@code c}. The source iterators are not polled until necessary.
   *
   * &lt;p&gt;The returned iterable's iterator supports {@code remove()} when the corresponding input
   * iterator supports it.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; use nested calls to {@link Stream#concat}, or see the
   * advice in {@link #concat(Iterable...)}.
   *
   * @since 20.0
   */
  @Beta
  public static &lt;T extends @Nullable Object&gt; FluentIterable&lt;T&gt; concat(
      Iterable&lt;? extends T&gt; a, Iterable&lt;? extends T&gt; b, Iterable&lt;? extends T&gt; c) {
    return concatNoDefensiveCopy(a, b, c);
  }

  /**
   * Returns a fluent iterable that combines four iterables. The returned iterable has an iterator
   * that traverses the elements in {@code a}, followed by the elements in {@code b}, followed by
   * the elements in {@code c}, followed by the elements in {@code d}. The source iterators are not
   * polled until necessary.
   *
   * &lt;p&gt;The returned iterable's iterator supports {@code remove()} when the corresponding input
   * iterator supports it.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; use nested calls to {@link Stream#concat}, or see the
   * advice in {@link #concat(Iterable...)}.
   *
   * @since 20.0
   */
  @Beta
  public static &lt;T extends @Nullable Object&gt; FluentIterable&lt;T&gt; concat(
      Iterable&lt;? extends T&gt; a,
      Iterable&lt;? extends T&gt; b,
      Iterable&lt;? extends T&gt; c,
      Iterable&lt;? extends T&gt; d) {
    return concatNoDefensiveCopy(a, b, c, d);
  }

  /**
   * Returns a fluent iterable that combines several iterables. The returned iterable has an
   * iterator that traverses the elements of each iterable in {@code inputs}. The input iterators
   * are not polled until necessary.
   *
   * &lt;p&gt;The returned iterable's iterator supports {@code remove()} when the corresponding input
   * iterator supports it.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; to concatenate an arbitrary number of streams, use {@code
   * Stream.of(stream1, stream2, ...).flatMap(s -&gt; s)}. If the sources are iterables, use {@code
   * Stream.of(iter1, iter2, ...).flatMap(Streams::stream)}.
   *
   * @throws NullPointerException if any of the provided iterables is {@code null}
   * @since 20.0
   */
  @Beta
  public static &lt;T extends @Nullable Object&gt; FluentIterable&lt;T&gt; concat(
      Iterable&lt;? extends T&gt;... inputs) {
    return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));
  }

  /**
   * Returns a fluent iterable that combines several iterables. The returned iterable has an
   * iterator that traverses the elements of each iterable in {@code inputs}. The input iterators
   * are not polled until necessary.
   *
   * &lt;p&gt;The returned iterable's iterator supports {@code remove()} when the corresponding input
   * iterator supports it. The methods of the returned iterable may throw {@code
   * NullPointerException} if any of the input iterators is {@code null}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code streamOfStreams.flatMap(s -&gt; s)} or {@code
   * streamOfIterables.flatMap(Streams::stream)}. (See {@link Streams#stream}.)
   *
   * @since 20.0
   */
  @Beta
  public static &lt;T extends @Nullable Object&gt; FluentIterable&lt;T&gt; concat(
      final Iterable&lt;? extends Iterable&lt;? extends T&gt;&gt; inputs) {
    checkNotNull(inputs);
    return new FluentIterable&lt;T&gt;() {
      @Override
      public Iterator&lt;T&gt; iterator() {
        return Iterators.concat(Iterators.transform(inputs.iterator(), Iterables.&lt;T&gt;toIterator()));
      }
    };
  }

  /** Concatenates a varargs array of iterables without making a defensive copy of the array. */
  private static &lt;T extends @Nullable Object&gt; FluentIterable&lt;T&gt; concatNoDefensiveCopy(
      final Iterable&lt;? extends T&gt;... inputs) {
    for (Iterable&lt;? extends T&gt; input : inputs) {
      checkNotNull(input);
    }
    return new FluentIterable&lt;T&gt;() {
      @Override
<a name="1"></a>      public Iterator&lt;T&gt; iterator() {
        return Iterators.concat(
            /* lazily generate the iterators on each input only as needed */
            new AbstractIndexedListIterator&lt;Iterator&lt;? extends T&gt;&gt;(inputs.length) <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
              @Override
              public Iterator&lt;? extends T&gt; get(int i) {
                return inputs[i].iterator();
              }
            }</b></font>);
      }
    };
  }

  /**
   * Returns a fluent iterable containing no elements.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#empty}.
   *
   * @since 20.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; FluentIterable&lt;E&gt; of() {
    return FluentIterable.from(Collections.&lt;E&gt;emptyList());
  }

  /**
   * Returns a fluent iterable containing the specified elements in order.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link java.util.stream.Stream#of(Object[])
   * Stream.of(T...)}.
   *
   * @since 20.0
   */
  @Beta
  public static &lt;E extends @Nullable Object&gt; FluentIterable&lt;E&gt; of(
      @ParametricNullness E element, E... elements) {
    return from(Lists.asList(element, elements));
  }

  /**
   * Returns a string representation of this fluent iterable, with the format {@code [e1, e2, ...,
   * en]}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.collect(Collectors.joining(", ", "[", "]"))}
   * or (less efficiently) {@code stream.collect(Collectors.toList()).toString()}.
   */
  @Override
  public String toString() {
    return Iterables.toString(getDelegate());
  }

  /**
   * Returns the number of elements in this fluent iterable.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#count}.
   */
  public final int size() {
    return Iterables.size(getDelegate());
  }

  /**
   * Returns {@code true} if this fluent iterable contains any object for which {@code
   * equals(target)} is true.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.anyMatch(Predicate.isEqual(target))}.
   */
  public final boolean contains(@CheckForNull Object target) {
    return Iterables.contains(getDelegate(), target);
  }

  /**
   * Returns a fluent iterable whose {@code Iterator} cycles indefinitely over the elements of this
   * fluent iterable.
   *
   * &lt;p&gt;That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code
   * remove()} is called, subsequent cycles omit the removed element, which is no longer in this
   * fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until this fluent
   * iterable is empty.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Typical uses of the resulting iterator may produce an infinite loop. You
   * should use an explicit {@code break} or be certain that you will eventually remove all the
   * elements.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; if the source iterable has only a single element {@code
   * e}, use {@code Stream.generate(() -&gt; e)}. Otherwise, collect your stream into a collection and
   * use {@code Stream.generate(() -&gt; collection).flatMap(Collection::stream)}.
   */
  public final FluentIterable&lt;E&gt; cycle() {
    return from(Iterables.cycle(getDelegate()));
  }

  /**
   * Returns a fluent iterable whose iterators traverse first the elements of this fluent iterable,
   * followed by those of {@code other}. The iterators are not polled until necessary.
   *
   * &lt;p&gt;The returned iterable's {@code Iterator} supports {@code remove()} when the corresponding
   * {@code Iterator} supports it.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#concat}.
   *
   * @since 18.0
   */
  @Beta
  public final FluentIterable&lt;E&gt; append(Iterable&lt;? extends E&gt; other) {
    return FluentIterable.concat(getDelegate(), other);
  }

  /**
   * Returns a fluent iterable whose iterators traverse first the elements of this fluent iterable,
   * followed by {@code elements}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code Stream.concat(thisStream, Stream.of(elements))}.
   *
   * @since 18.0
   */
  @Beta
  public final FluentIterable&lt;E&gt; append(E... elements) {
    return FluentIterable.concat(getDelegate(), Arrays.asList(elements));
  }

  /**
   * Returns the elements from this fluent iterable that satisfy a predicate. The resulting fluent
   * iterable's iterator does not support {@code remove()}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#filter} (same).
   */
  public final FluentIterable&lt;E&gt; filter(Predicate&lt;? super E&gt; predicate) {
    return from(Iterables.filter(getDelegate(), predicate));
  }

  /**
   * Returns the elements from this fluent iterable that are instances of class {@code type}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.filter(type::isInstance).map(type::cast)}.
   * This does perform a little more work than necessary, so another option is to insert an
   * unchecked cast at some later point:
   *
   * &lt;pre&gt;
   * {@code @SuppressWarnings("unchecked") // safe because of ::isInstance check
   * ImmutableList&lt;NewType&gt; result =
   *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}
   * &lt;/pre&gt;
   */
  @GwtIncompatible // Class.isInstance
  public final &lt;T&gt; FluentIterable&lt;T&gt; filter(Class&lt;T&gt; type) {
    return from(Iterables.filter(getDelegate(), type));
  }

  /**
   * Returns {@code true} if any element in this fluent iterable satisfies the predicate.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#anyMatch} (same).
   */
  public final boolean anyMatch(Predicate&lt;? super E&gt; predicate) {
    return Iterables.any(getDelegate(), predicate);
  }

  /**
   * Returns {@code true} if every element in this fluent iterable satisfies the predicate. If this
   * fluent iterable is empty, {@code true} is returned.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#allMatch} (same).
   */
  public final boolean allMatch(Predicate&lt;? super E&gt; predicate) {
    return Iterables.all(getDelegate(), predicate);
  }

  /**
   * Returns an {@link Optional} containing the first element in this fluent iterable that satisfies
   * the given predicate, if such an element exists.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; avoid using a {@code predicate} that matches {@code null}. If {@code null}
   * is matched in this fluent iterable, a {@link NullPointerException} will be thrown.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.filter(predicate).findFirst()}.
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final Optional&lt;E&gt; firstMatch(Predicate&lt;? super E&gt; predicate) {
    return Iterables.tryFind(getDelegate(), predicate);
  }

  /**
   * Returns a fluent iterable that applies {@code function} to each element of this fluent
   * iterable.
   *
   * &lt;p&gt;The returned fluent iterable's iterator supports {@code remove()} if this iterable's
   * iterator does. After a successful {@code remove()} call, this fluent iterable no longer
   * contains the corresponding element.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#map}.
   */
  public final &lt;T extends @Nullable Object&gt; FluentIterable&lt;T&gt; transform(
      Function&lt;? super E, T&gt; function) {
    return from(Iterables.transform(getDelegate(), function));
  }

  /**
   * Applies {@code function} to each element of this fluent iterable and returns a fluent iterable
   * with the concatenated combination of results. {@code function} returns an Iterable of results.
   *
   * &lt;p&gt;The returned fluent iterable's iterator supports {@code remove()} if this function-returned
   * iterables' iterator does. After a successful {@code remove()} call, the returned fluent
   * iterable no longer contains the corresponding element.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#flatMap} (using a function that produces
   * streams, not iterables).
   *
   * @since 13.0 (required {@code Function&lt;E, Iterable&lt;T&gt;&gt;} until 14.0)
<a name="2"></a>   */
  public &lt;T extends @Nullable Object&gt; FluentIterable&lt;T&gt; transformAndConcat(
      Function&lt;? super E, ? extends Iterable&lt;? extends T&gt;&gt; function) {
    return FluentIterable.concat(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>transform(function));
  }

  /**
   * Returns an {@link Optional} containing the first element in this fluent iterable. If the
   * iterable is empty, {@code Optional.absent()} is returned.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; if the goal is to obtain any element, {@link
   * Stream#findAny}; if it must specifically be the &lt;i&gt;first&lt;/i&gt; element, {@code Stream#findFirst}.
   *
   * @throws NullPointerException if the first element is null; if this is a possibility, use {@code
   *     iterator().next()} or {@link Iterables#getFirst} instead.
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final Optional&lt;E&gt; first() {
    Iterator&lt;E&gt; iterator = getDelegate</b></font>().iterator();
    return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.&lt;E&gt;absent();
  }

  /**
   * Returns an {@link Optional} containing the last element in this fluent iterable. If the
   * iterable is empty, {@code Optional.absent()} is returned. If the underlying {@code iterable} is
   * a {@link List} with {@link java.util.RandomAccess} support, then this operation is guaranteed
   * to be {@code O(1)}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.reduce((a, b) -&gt; b)}.
   *
   * @throws NullPointerException if the last element is null; if this is a possibility, use {@link
   *     Iterables#getLast} instead.
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final Optional&lt;E&gt; last() {
    // Iterables#getLast was inlined here so we don't have to throw/catch a NSEE

    // TODO(kevinb): Support a concurrently modified collection?
    Iterable&lt;E&gt; iterable = getDelegate();
    if (iterable instanceof List) {
      List&lt;E&gt; list = (List&lt;E&gt;) iterable;
      if (list.isEmpty()) {
        return Optional.absent();
      }
      return Optional.of(list.get(list.size() - 1));
    }
    Iterator&lt;E&gt; iterator = iterable.iterator();
    if (!iterator.hasNext()) {
      return Optional.absent();
    }

    /*
     * TODO(kevinb): consider whether this "optimization" is worthwhile. Users with SortedSets tend
     * to know they are SortedSets and probably would not call this method.
     */
    if (iterable instanceof SortedSet) {
      SortedSet&lt;E&gt; sortedSet = (SortedSet&lt;E&gt;) iterable;
      return Optional.of(sortedSet.last());
    }

    while (true) {
      E current = iterator.next();
      if (!iterator.hasNext()) {
        return Optional.of(current);
      }
    }
  }

  /**
   * Returns a view of this fluent iterable that skips its first {@code numberToSkip} elements. If
   * this fluent iterable contains fewer than {@code numberToSkip} elements, the returned fluent
   * iterable skips all of its elements.
   *
   * &lt;p&gt;Modifications to this fluent iterable before a call to {@code iterator()} are reflected in
   * the returned fluent iterable. That is, the its iterator skips the first {@code numberToSkip}
   * elements that exist when the iterator is created, not when {@code skip()} is called.
   *
   * &lt;p&gt;The returned fluent iterable's iterator supports {@code remove()} if the {@code Iterator} of
   * this fluent iterable supports it. Note that it is &lt;i&gt;not&lt;/i&gt; possible to delete the last
   * skipped element by immediately calling {@code remove()} on the returned fluent iterable's
   * iterator, as the {@code Iterator} contract states that a call to {@code * remove()} before a
   * call to {@code next()} will throw an {@link IllegalStateException}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#skip} (same).
   */
  public final FluentIterable&lt;E&gt; skip(int numberToSkip) {
    return from(Iterables.skip(getDelegate(), numberToSkip));
  }

  /**
   * Creates a fluent iterable with the first {@code size} elements of this fluent iterable. If this
   * fluent iterable does not contain that many elements, the returned fluent iterable will have the
   * same behavior as this fluent iterable. The returned fluent iterable's iterator supports {@code
   * remove()} if this fluent iterable's iterator does.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@link Stream#limit} (same).
   *
   * @param maxSize the maximum number of elements in the returned fluent iterable
   * @throws IllegalArgumentException if {@code size} is negative
   */
  public final FluentIterable&lt;E&gt; limit(int maxSize) {
    return from(Iterables.limit(getDelegate(), maxSize));
  }

  /**
   * Determines whether this fluent iterable is empty.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code !stream.findAny().isPresent()}.
   */
  public final boolean isEmpty() {
    return !getDelegate().iterator().hasNext();
  }

  /**
   * Returns an {@code ImmutableList} containing all of the elements from this fluent iterable in
   * proper sequence.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; pass {@link ImmutableList#toImmutableList} to {@code
   * stream.collect()}.
   *
   * @throws NullPointerException if any element is {@code null}
   * @since 14.0 (since 12.0 as {@code toImmutableList()}).
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final ImmutableList&lt;E&gt; toList() {
    return ImmutableList.copyOf(getDelegate());
  }

  /**
   * Returns an {@code ImmutableList} containing all of the elements from this {@code
   * FluentIterable} in the order specified by {@code comparator}. To produce an {@code
   * ImmutableList} sorted by its natural ordering, use {@code toSortedList(Ordering.natural())}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; pass {@link ImmutableList#toImmutableList} to {@code
   * stream.sorted(comparator).collect()}.
   *
   * @param comparator the function by which to sort list elements
   * @throws NullPointerException if any element of this iterable is {@code null}
   * @since 14.0 (since 13.0 as {@code toSortedImmutableList()}).
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final ImmutableList&lt;E&gt; toSortedList(Comparator&lt;? super E&gt; comparator) {
    return Ordering.from(comparator).immutableSortedCopy(getDelegate());
  }

  /**
   * Returns an {@code ImmutableSet} containing all of the elements from this fluent iterable with
   * duplicates removed.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; pass {@link ImmutableSet#toImmutableSet} to {@code
   * stream.collect()}.
   *
   * @throws NullPointerException if any element is {@code null}
   * @since 14.0 (since 12.0 as {@code toImmutableSet()}).
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final ImmutableSet&lt;E&gt; toSet() {
    return ImmutableSet.copyOf(getDelegate());
  }

  /**
   * Returns an {@code ImmutableSortedSet} containing all of the elements from this {@code
   * FluentIterable} in the order specified by {@code comparator}, with duplicates (determined by
   * {@code comparator.compare(x, y) == 0}) removed. To produce an {@code ImmutableSortedSet} sorted
   * by its natural ordering, use {@code toSortedSet(Ordering.natural())}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; pass {@link ImmutableSortedSet#toImmutableSortedSet} to
   * {@code stream.collect()}.
   *
   * @param comparator the function by which to sort set elements
   * @throws NullPointerException if any element of this iterable is {@code null}
   * @since 14.0 (since 12.0 as {@code toImmutableSortedSet()}).
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final ImmutableSortedSet&lt;E&gt; toSortedSet(Comparator&lt;? super E&gt; comparator) {
    return ImmutableSortedSet.copyOf(comparator, getDelegate());
  }

  /**
   * Returns an {@code ImmutableMultiset} containing all of the elements from this fluent iterable.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; pass {@link ImmutableMultiset#toImmutableMultiset} to
   * {@code stream.collect()}.
   *
   * @throws NullPointerException if any element is null
   * @since 19.0
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final ImmutableMultiset&lt;E&gt; toMultiset() {
    return ImmutableMultiset.copyOf(getDelegate());
  }

  /**
   * Returns an immutable map whose keys are the distinct elements of this {@code FluentIterable}
   * and whose value for each key was computed by {@code valueFunction}. The map's iteration order
   * is the order of the first appearance of each key in this iterable.
   *
   * &lt;p&gt;When there are multiple instances of a key in this iterable, it is unspecified whether
   * {@code valueFunction} will be applied to more than one instance of that key and, if it is,
   * which result will be mapped to that key in the returned map.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.collect(ImmutableMap.toImmutableMap(k -&gt; k,
   * valueFunction))}.
   *
   * @throws NullPointerException if any element of this iterable is {@code null}, or if {@code
   *     valueFunction} produces {@code null} for any key
   * @since 14.0
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final &lt;V&gt; ImmutableMap&lt;E, V&gt; toMap(Function&lt;? super E, V&gt; valueFunction) {
    return Maps.toMap(getDelegate(), valueFunction);
  }

  /**
   * Creates an index {@code ImmutableListMultimap} that contains the results of applying a
   * specified function to each item in this {@code FluentIterable} of values. Each element of this
   * iterable will be stored as a value in the resulting multimap, yielding a multimap with the same
   * size as this iterable. The key used to store that value in the multimap will be the result of
   * calling the function on that value. The resulting multimap is created as an immutable snapshot.
   * In the returned multimap, keys appear in the order they are first encountered, and the values
   * corresponding to each key appear in the same order as they are encountered.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.collect(Collectors.groupingBy(keyFunction))}
   * behaves similarly, but returns a mutable {@code Map&lt;K, List&lt;E&gt;&gt;} instead, and may not preserve
   * the order of entries).
   *
   * @param keyFunction the function used to produce the key for each value
   * @throws NullPointerException if any element of this iterable is {@code null}, or if {@code
   *     keyFunction} produces {@code null} for any key
   * @since 14.0
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final &lt;K&gt; ImmutableListMultimap&lt;K, E&gt; index(Function&lt;? super E, K&gt; keyFunction) {
    return Multimaps.index(getDelegate(), keyFunction);
  }

  /**
   * Returns a map with the contents of this {@code FluentIterable} as its {@code values}, indexed
   * by keys derived from those values. In other words, each input value produces an entry in the
   * map whose key is the result of applying {@code keyFunction} to that value. These entries appear
   * in the same order as they appeared in this fluent iterable. Example usage:
   *
   * &lt;pre&gt;{@code
   * Color red = new Color("red", 255, 0, 0);
   * ...
   * FluentIterable&lt;Color&gt; allColors = FluentIterable.from(ImmutableSet.of(red, green, blue));
   *
   * Map&lt;String, Color&gt; colorForName = allColors.uniqueIndex(toStringFunction());
   * assertThat(colorForName).containsEntry("red", red);
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;If your index may associate multiple values with each key, use {@link #index(Function)
   * index}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code
   * stream.collect(ImmutableMap.toImmutableMap(keyFunction, v -&gt; v))}.
   *
   * @param keyFunction the function used to produce the key for each value
   * @return a map mapping the result of evaluating the function {@code keyFunction} on each value
   *     in this fluent iterable to that value
   * @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one
   *     value in this fluent iterable
   * @throws NullPointerException if any element of this iterable is {@code null}, or if {@code
   *     keyFunction} produces {@code null} for any key
   * @since 14.0
   */
  @SuppressWarnings("nullness") // Unsafe, but we can't do much about it now.
  public final &lt;K&gt; ImmutableMap&lt;K, E&gt; uniqueIndex(Function&lt;? super E, K&gt; keyFunction) {
    return Maps.uniqueIndex(getDelegate(), keyFunction);
  }

  /**
   * Returns an array containing all of the elements from this fluent iterable in iteration order.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; if an object array is acceptable, use {@code
   * stream.toArray()}; if {@code type} is a class literal such as {@code MyType.class}, use {@code
   * stream.toArray(MyType[]::new)}. Otherwise use {@code stream.toArray( len -&gt; (E[])
   * Array.newInstance(type, len))}.
   *
   * @param type the type of the elements
   * @return a newly-allocated array into which all the elements of this fluent iterable have been
   *     copied
   */
  @GwtIncompatible // Array.newArray(Class, int)
  /*
   * Both the declaration of our Class&lt;E&gt; parameter and its usage in a call to Iterables.toArray
   * produce a nullness error: E may be a nullable type, and our nullness checker has Class's type
   * parameter bounded to non-null types. To avoid that, we'd use Class&lt;@Nonnull E&gt; if we could.
   * (Granted, this is only one of many nullness-checking problems that arise from letting
   * FluentIterable support null elements, and most of the other produce outright unsoundness.)
   */
  @SuppressWarnings("nullness")
  public final @Nullable E[] toArray(Class&lt;E&gt; type) {
    return Iterables.toArray(getDelegate(), type);
  }

  /**
   * Copies all the elements from this fluent iterable to {@code collection}. This is equivalent to
   * calling {@code Iterables.addAll(collection, this)}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.forEachOrdered(collection::add)} or {@code
   * stream.forEach(collection::add)}.
   *
   * @param collection the collection to copy elements to
   * @return {@code collection}, for convenience
   * @since 14.0
   */
  @CanIgnoreReturnValue
  public final &lt;C extends Collection&lt;? super E&gt;&gt; C copyInto(C collection) {
    checkNotNull(collection);
    Iterable&lt;E&gt; iterable = getDelegate();
    if (iterable instanceof Collection) {
      collection.addAll((Collection&lt;E&gt;) iterable);
    } else {
      for (E item : iterable) {
        collection.add(item);
      }
    }
    return collection;
  }

  /**
   * Returns a {@link String} containing all of the elements of this fluent iterable joined with
   * {@code joiner}.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code joiner.join(stream.iterator())}, or, if you are not
   * using any optional {@code Joiner} features, {@code
   * stream.collect(Collectors.joining(delimiter)}.
   *
   * @since 18.0
   */
  @Beta
  public final String join(Joiner joiner) {
    return joiner.join(this);
  }

  /**
   * Returns the element at the specified position in this fluent iterable.
   *
   * &lt;p&gt;&lt;b&gt;{@code Stream} equivalent:&lt;/b&gt; {@code stream.skip(position).findFirst().get()} (but note
   * that this throws different exception types, and throws an exception if {@code null} would be
   * returned).
   *
   * @param position position of the element to return
   * @return the element at the specified position in this fluent iterable
   * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to
   *     the size of this fluent iterable
   */
  @ParametricNullness
  public final E get(int position) {
    return Iterables.get(getDelegate(), position);
  }

  /**
   * Returns a stream of this fluent iterable's contents (similar to calling {@link
   * Collection#stream} on a collection).
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; the earlier in the chain you can switch to {@code Stream} usage (ideally not
   * going through {@code FluentIterable} at all), the more performant and idiomatic your code will
   * be. This method is a transitional aid, to be used only when really necessary.
   *
   * @since 21.0
   */
  public final Stream&lt;E&gt; stream() {
    return Streams.stream(getDelegate());
  }

  /** Function that transforms {@code Iterable&lt;E&gt;} into a fluent iterable. */
  private static class FromIterableFunction&lt;E extends @Nullable Object&gt;
      implements Function&lt;Iterable&lt;E&gt;, FluentIterable&lt;E&gt;&gt; {
    @Override
    public FluentIterable&lt;E&gt; apply(Iterable&lt;E&gt; fromObject) {
      return FluentIterable.from(fromObject);
    }
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
