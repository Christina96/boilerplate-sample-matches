
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.159420289855073%, Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-MethodTemplateExecutorTest.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.netflix.ribbon.proxy;
2  import com.netflix.ribbon.CacheProvider;
3  import com.netflix.ribbon.RibbonRequest;
4  import com.netflix.ribbon.http.HttpRequestBuilder;
5  import com.netflix.ribbon.http.HttpRequestTemplate;
6  import com.netflix.ribbon.http.HttpRequestTemplate.Builder;
7  import com.netflix.ribbon.http.HttpResourceGroup;
8  import com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider;
9  import com.netflix.ribbon.proxy.sample.HystrixHandlers.MovieFallbackHandler;
10  import com.netflix.ribbon.proxy.sample.HystrixHandlers.SampleHttpResponseValidator;
11  import com.netflix.ribbon.proxy.sample.Movie;
12  import com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService;
13  import com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.ShortMovieService;
14  import io.netty.buffer.ByteBuf;
15  import io.reactivex.netty.channel.ContentTransformer;
16  import org.junit.Before;
17  import org.junit.BeforeClass;
</span>18  import org.junit.Test;
19  import org.junit.runner.RunWith;
20  import org.powermock.api.easymock.annotation.Mock;
21  import org.powermock.core.classloader.annotations.PowerMockIgnore;
22  import org.powermock.core.classloader.annotations.PrepareForTest;
23  import org.powermock.modules.junit4.PowerMockRunner;
24  import rx.Observable;
25  import java.lang.reflect.Method;
26  import java.util.Map;
27  import static com.netflix.ribbon.proxy.Utils.methodByName;
28  import static junit.framework.Assert.assertEquals;
29  import static org.easymock.EasyMock.anyObject;
30  import static org.easymock.EasyMock.expect;
31  import static org.powermock.api.easymock.PowerMock.*;
32  @RunWith(PowerMockRunner.class)
33  @PrepareForTest({MethodTemplateExecutor.class})
34  @PowerMockIgnore("javax.management.*")
35  public class MethodTemplateExecutorTest {
36      @Mock
37      private RibbonRequest ribbonRequestMock = createMock(RibbonRequest.class);
38      @Mock
39      private HttpRequestBuilder requestBuilderMock = createMock(HttpRequestBuilder.class);
40      @Mock
41      private Builder httpRequestTemplateBuilderMock = createMock(Builder.class);
42      @Mock
43      private HttpRequestTemplate httpRequestTemplateMock = createMock(HttpRequestTemplate.class);
44      @Mock
45      private HttpResourceGroup httpResourceGroupMock = createMock(HttpResourceGroup.class);
46      @BeforeClass
47      public static void setup() {
48          RibbonDynamicProxy.registerAnnotationProcessors(AnnotationProcessorsProvider.DEFAULT);
49      }
50      @Before
51      public void setUp() throws Exception {
52          expect(requestBuilderMock.build()).andReturn(ribbonRequestMock);
53          expect(httpRequestTemplateBuilderMock.build()).andReturn(httpRequestTemplateMock);
54          expect(httpRequestTemplateMock.requestBuilder()).andReturn(requestBuilderMock);
55      }
56      @Test
57      public void testGetQueryWithDomainObjectResult() throws Exception {
58          expectUrlBase("GET", "/movies/{id}");
59          expect(requestBuilderMock.withRequestProperty("id", "id123")).andReturn(requestBuilderMock);
60          expect(httpResourceGroupMock.newTemplateBuilder("findMovieById")).andReturn(httpRequestTemplateBuilderMock);
61          expect(httpRequestTemplateBuilderMock.withHeader("X-MyHeader1", "value1.1")).andReturn(httpRequestTemplateBuilderMock);
62          expect(httpRequestTemplateBuilderMock.withHeader("X-MyHeader1", "value1.2")).andReturn(httpRequestTemplateBuilderMock);
63          expect(httpRequestTemplateBuilderMock.withHeader("X-MyHeader2", "value2")).andReturn(httpRequestTemplateBuilderMock);
64          expect(httpRequestTemplateBuilderMock.withRequestCacheKey("findMovieById/{id}")).andReturn(httpRequestTemplateBuilderMock);
65          expect(httpRequestTemplateBuilderMock.withFallbackProvider(anyObject(MovieFallbackHandler.class))).andReturn(httpRequestTemplateBuilderMock);
66          expect(httpRequestTemplateBuilderMock.withResponseValidator(anyObject(SampleHttpResponseValidator.class))).andReturn(httpRequestTemplateBuilderMock);
67          expect(httpRequestTemplateBuilderMock.withCacheProvider(anyObject(String.class), anyObject(CacheProvider.class))).andReturn(httpRequestTemplateBuilderMock);
68          replayAll();
69          MethodTemplateExecutor executor = createExecutor(SampleMovieService.class, "findMovieById");
70          RibbonRequest ribbonRequest = executor.executeFromTemplate(new Object[]{"id123"});
71          verifyAll();
72          assertEquals(ribbonRequestMock, ribbonRequest);
73      }
74      @Test
75      public void testGetQueryWithByteBufResult() throws Exception {
76          expectUrlBase("GET", "/rawMovies/{id}");
77          expect(requestBuilderMock.withRequestProperty("id", "id123")).andReturn(requestBuilderMock);
78          expect(httpResourceGroupMock.newTemplateBuilder("findRawMovieById")).andReturn(httpRequestTemplateBuilderMock);
79          replayAll();
80          MethodTemplateExecutor executor = createExecutor(SampleMovieService.class, "findRawMovieById");
81          RibbonRequest ribbonRequest = executor.executeFromTemplate(new Object[]{"id123"});
82          verifyAll();
83          assertEquals(ribbonRequestMock, ribbonRequest);
84      }
85      @Test
86      public void testPostWithDomainObjectAndTransformer() throws Exception {
87          doTestPostWith("/movies", "registerMovie", new Movie());
88      }
89      @Test
90      public void testPostWithString() throws Exception {
91          doTestPostWith("/titles", "registerTitle", "some title");
92      }
93      @Test
94      public void testPostWithByteBuf() throws Exception {
95          doTestPostWith("/binaries/byteBuf", "registerByteBufBinary", createMock(ByteBuf.class));
96      }
97      @Test
98      public void testPostWithByteArray() throws Exception {
99          doTestPostWith("/binaries/byteArray", "registerByteArrayBinary", new byte[]{1});
100      }
101      private void doTestPostWith(String uriTemplate, String methodName, Object contentObject) {
102          expectUrlBase("POST", uriTemplate);
103          expect(httpResourceGroupMock.newTemplateBuilder(methodName)).andReturn(httpRequestTemplateBuilderMock);
104          expect(httpRequestTemplateBuilderMock.withRequestCacheKey(methodName)).andReturn(httpRequestTemplateBuilderMock);
105          expect(httpRequestTemplateBuilderMock.withFallbackProvider(anyObject(MovieFallbackHandler.class))).andReturn(httpRequestTemplateBuilderMock);
106          expect(requestBuilderMock.withRawContentSource(anyObject(Observable.class), anyObject(ContentTransformer.class))).andReturn(requestBuilderMock);
107          replayAll();
108          MethodTemplateExecutor executor = createExecutor(SampleMovieService.class, methodName);
109          RibbonRequest ribbonRequest = executor.executeFromTemplate(new Object[]{contentObject});
110          verifyAll();
111          assertEquals(ribbonRequestMock, ribbonRequest);
112      }
113      @Test
114      public void testFromFactory() throws Exception {
115          expect(httpResourceGroupMock.newTemplateBuilder(anyObject(String.class))).andReturn(httpRequestTemplateBuilderMock).anyTimes();
116          expect(httpRequestTemplateBuilderMock.withMethod(anyObject(String.class))).andReturn(httpRequestTemplateBuilderMock).anyTimes();
117          expect(httpRequestTemplateBuilderMock.withUriTemplate(anyObject(String.class))).andReturn(httpRequestTemplateBuilderMock).anyTimes();
118          replayAll();
119          Map<Method, MethodTemplateExecutor> executorMap = MethodTemplateExecutor.from(httpResourceGroupMock, ShortMovieService.class, AnnotationProcessorsProvider.DEFAULT);
120          assertEquals(ShortMovieService.class.getMethods().length, executorMap.size());
121      }
122      private void expectUrlBase(String method, String path) {
123          expect(httpRequestTemplateBuilderMock.withMethod(method)).andReturn(httpRequestTemplateBuilderMock);
124          expect(httpRequestTemplateBuilderMock.withUriTemplate(path)).andReturn(httpRequestTemplateBuilderMock);
125      }
126      private MethodTemplateExecutor createExecutor(Class<?> clientInterface, String methodName) {
127          MethodTemplate methodTemplate = new MethodTemplate(methodByName(clientInterface, methodName));
128          return new MethodTemplateExecutor(httpResourceGroupMock, methodTemplate, AnnotationProcessorsProvider.DEFAULT);
129      }
130  }
</code></pre>
        </div>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Vitamio.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package io.vov.vitamio;
2  import android.content.Context;
3  import io.vov.vitamio.utils.CPU;
4  import io.vov.vitamio.utils.ContextUtils;
5  import io.vov.vitamio.utils.IOUtils;
6  import io.vov.vitamio.utils.Log;
7  import java.io.BufferedInputStream;
8  import java.io.BufferedReader;
9  import java.io.File;
10  import java.io.FileOutputStream;
11  import java.io.FileReader;
12  import java.io.FileWriter;
13  import java.io.IOException;
14  import java.io.InputStream;
15  import java.util.ArrayList;
16  import java.util.Arrays;
17  import java.util.List;
</span>18  public class Vitamio {
19    private static final String[] LIBS_ARM_CODECS = {"libvvo.7.so", "libvvo.8.so", "libffmpeg.so", "libOMX.9.so", "libOMX.11.so", "libOMX.14.so", "libOMX.18.so"};
20    private static final String[] LIBS_X86_CODECS = {"libffmpeg.so", "libOMX.9.so", "libOMX.14.so", "libOMX.18.so"};
21    private static final String[] LIBS_MIPS_CODECS = {"libffmpeg.so", "libOMX.14.so"};
22    private static final String[] LIBS_PLAYER = {"libvplayer.so"};
23    private static final String[] LIBS_SCANNER = {"libvscanner.so"};
24    private static final String[] LIBS_AV = {"libvao.0.so", "libvvo.0.so", "libvvo.9.so", "libvvo.j.so"};
25    private static final String LIBS_LOCK = ".lock";
26    private static final int VITAMIO_NOT_SUPPORTED = -1;
27    private static final int VITAMIO_MIPS = 40;
28    private static final int VITAMIO_X86 = 50;
29    private static final int VITAMIO_ARMV6 = 60;
30    private static final int VITAMIO_ARMV6_VFP = 61;
31    private static final int VITAMIO_ARMV7_VFPV3 = 70;
32    private static final int VITAMIO_ARMV7_NEON = 71;
33    private static final int vitamioType;
34    static {
35      int cpu = CPU.getFeature();
36      if ((cpu & CPU.FEATURE_ARM_NEON) > 0)
37        vitamioType = VITAMIO_ARMV7_NEON;
38      else if ((cpu & CPU.FEATURE_ARM_VFPV3) > 0 && (cpu & CPU.FEATURE_ARM_V7A) > 0)
39        vitamioType = VITAMIO_ARMV7_VFPV3;
40      else if ((cpu & CPU.FEATURE_ARM_VFP) > 0 && (cpu & CPU.FEATURE_ARM_V6) > 0)
41        vitamioType = VITAMIO_ARMV6_VFP;
42      else if ((cpu & CPU.FEATURE_ARM_V6) > 0)
43      	vitamioType = VITAMIO_ARMV6;
44      else if ((cpu & CPU.FEATURE_X86) > 0)
45      	vitamioType = VITAMIO_X86;
46      else if ((cpu & CPU.FEATURE_MIPS) > 0) 
47      	vitamioType = VITAMIO_MIPS;
48      else
49      	vitamioType = VITAMIO_NOT_SUPPORTED;
50    }
51    private static String vitamioPackage;
52    private static String vitamioLibraryPath;
53    public static boolean initialize(Context ctx) {
54      return isInitialized(ctx) || extractLibs(ctx, R.raw.libarm);
55    }
56    public static boolean initialize(Context ctx, int rawId) {
57      return isInitialized(ctx) || extractLibs(ctx, rawId);
58    }
59    public static boolean isInitialized(Context ctx) {
60      vitamioPackage = ctx.getPackageName();
61      vitamioLibraryPath = ContextUtils.getDataDir(ctx) + "libs/";
62      File dir = new File(getLibraryPath());
63      if (dir.exists() && dir.isDirectory()) {
64        String[] libs = dir.list();
65        if (libs != null) {
66          Arrays.sort(libs);
67          for (String L : getRequiredLibs()) {
68            if (Arrays.binarySearch(libs, L) < 0) {
69              Log.e("Native libs %s not exists!", L);
70              return false;
71            }
72          }
73          File lock = new File(getLibraryPath() + LIBS_LOCK);
74          BufferedReader buffer = null; 
75          try {
76            buffer = new BufferedReader(new FileReader(lock));  
77            int appVersion = ContextUtils.getVersionCode(ctx);
78            int libVersion = Integer.valueOf(buffer.readLine());  
79            Log.i("isNativeLibsInited, APP VERSION: %d, Vitamio Library version: %d", appVersion, libVersion);
80            if (libVersion == appVersion)
81              return true;
82          } catch (IOException e) {
83            Log.e("isNativeLibsInited", e);
84          } catch (NumberFormatException e) {
85          	Log.e("isNativeLibsInited", e);
86          } finally {
87            IOUtils.closeSilently(buffer);
88          }
89        }
90      }
91      return false;
92    }
93    public static String getVitamioPackage() {
94      return vitamioPackage;
95    }
96    public static int getVitamioType() {
97      return vitamioType;
98    }
99    public static final String getLibraryPath() {
100      return vitamioLibraryPath;
101    }
102    private static final List<String> getRequiredLibs() {
103      List<String> libs = new ArrayList<String>();
104      String[][] vitamioLibs = null;
105      switch (vitamioType) {
106  		case VITAMIO_ARMV6:
107  		case VITAMIO_ARMV6_VFP:
108  		case VITAMIO_ARMV7_VFPV3:
109  		case VITAMIO_ARMV7_NEON:
110  			vitamioLibs = new String[][]{LIBS_ARM_CODECS, LIBS_PLAYER, LIBS_SCANNER, LIBS_AV};
111  			break;
112  		case VITAMIO_X86:
113  			vitamioLibs = new String[][]{LIBS_X86_CODECS, LIBS_PLAYER, LIBS_SCANNER, LIBS_AV};
114  			break;
115  		case VITAMIO_MIPS:
116  			vitamioLibs = new String[][]{LIBS_MIPS_CODECS, LIBS_PLAYER, LIBS_SCANNER, LIBS_AV};
117  			break;
118  		default:
119  			break;
120  		}
121      if (vitamioLibs == null)
122      	return libs;
123      for (String[] libArray : vitamioLibs) {
124        for (String lib : libArray)
125          libs.add(lib);
126      }
127      libs.add(LIBS_LOCK);
128      return libs;
129    }
130    private static boolean extractLibs(Context ctx, int rawID) {
131      long begin = System.currentTimeMillis();
132      final int version = ContextUtils.getVersionCode(ctx);
133      Log.d("loadLibs start " + version);
134      File lock = new File(getLibraryPath() + LIBS_LOCK);
135      if (lock.exists())
136        lock.delete();
137      String libPath = copyCompressedLib(ctx, rawID, "libarm.so");
138      Log.d("copyCompressedLib time: " + (System.currentTimeMillis() - begin) / 1000.0);
139      boolean inited = native_initializeLibs(libPath, getLibraryPath(), String.valueOf(Vitamio.getVitamioType()));
140      new File(libPath).delete();
141      FileWriter fw = null;
142      try {
143        lock.createNewFile();
144        fw = new FileWriter(lock);
145        fw.write(String.valueOf(version));
146        return true;
147      } catch (IOException e) {
148        Log.e("Error creating lock file", e);
149      } finally {
150        Log.d("initializeNativeLibs: " + inited);
151        Log.d("loadLibs time: " + (System.currentTimeMillis() - begin) / 1000.0);
152        IOUtils.closeSilently(fw);
153      }
154      return false;
155    }
156    private static String copyCompressedLib(Context ctx, int rawID, String destName) {
157      byte[] buffer = new byte[1024];
158      InputStream is = null;
159      BufferedInputStream bis = null;
160      FileOutputStream fos = null;
161      String destPath = null;
162      try {
163        try {
164          String destDir = getLibraryPath();
165          destPath = destDir + destName;
166          File f = new File(destDir);
167          if (f.exists() && !f.isDirectory())
168            f.delete();
169          if (!f.exists())
170            f.mkdirs();
171          f = new File(destPath);
172          if (f.exists() && !f.isFile())
173            f.delete();
174          if (!f.exists())
175            f.createNewFile();
176        } catch (Exception fe) {
177          Log.e("loadLib", fe);
178        }
179        is = ctx.getResources().openRawResource(rawID);
180        bis = new BufferedInputStream(is);
181        fos = new FileOutputStream(destPath);
182        while (bis.read(buffer) != -1) {
183          fos.write(buffer);
184        }
185      } catch (Exception e) {
186        Log.e("loadLib", e);
187        return null;
188      } finally {
189        IOUtils.closeSilently(fos);
190        IOUtils.closeSilently(bis);
191        IOUtils.closeSilently(is);
192      }
193      return destPath;
194    }
195    static {
196      System.loadLibrary("vinit");
197    }
198    private native static boolean native_initializeLibs(String libPath, String destDir, String prefix);
199  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-MethodTemplateExecutorTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Vitamio.java</div>
                </div>
                <div class="column column_space"><pre><code>1  package com.netflix.ribbon.proxy;
2  import com.netflix.ribbon.CacheProvider;
3  import com.netflix.ribbon.RibbonRequest;
4  import com.netflix.ribbon.http.HttpRequestBuilder;
5  import com.netflix.ribbon.http.HttpRequestTemplate;
6  import com.netflix.ribbon.http.HttpRequestTemplate.Builder;
7  import com.netflix.ribbon.http.HttpResourceGroup;
8  import com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider;
9  import com.netflix.ribbon.proxy.sample.HystrixHandlers.MovieFallbackHandler;
10  import com.netflix.ribbon.proxy.sample.HystrixHandlers.SampleHttpResponseValidator;
11  import com.netflix.ribbon.proxy.sample.Movie;
12  import com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService;
13  import com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.ShortMovieService;
14  import io.netty.buffer.ByteBuf;
15  import io.reactivex.netty.channel.ContentTransformer;
16  import org.junit.Before;
17  import org.junit.BeforeClass;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package io.vov.vitamio;
2  import android.content.Context;
3  import io.vov.vitamio.utils.CPU;
4  import io.vov.vitamio.utils.ContextUtils;
5  import io.vov.vitamio.utils.IOUtils;
6  import io.vov.vitamio.utils.Log;
7  import java.io.BufferedInputStream;
8  import java.io.BufferedReader;
9  import java.io.File;
10  import java.io.FileOutputStream;
11  import java.io.FileReader;
12  import java.io.FileWriter;
13  import java.io.IOException;
14  import java.io.InputStream;
15  import java.util.ArrayList;
16  import java.util.Arrays;
17  import java.util.List;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    