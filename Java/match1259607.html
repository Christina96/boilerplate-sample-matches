<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for SysUpdateProjection.java &amp; HostBasedAuthentication.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for SysUpdateProjection.java &amp; HostBasedAuthentication.java
      </h3>
<h1 align="center">
        14.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>SysUpdateProjection.java (17.391304%)<th>HostBasedAuthentication.java (12.42236%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-46)<td><a href="#" name="0">(27-50)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(97-105)<td><a href="#" name="1">(146-154)</a><td align="center"><font color="#8c0000">11</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(145-149)<td><a href="#" name="2">(179-184)</a><td align="center"><font color="#720000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SysUpdateProjection.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<a name="0"></a>
package io.crate.execution.dsl.projection;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.crate.expression.symbol.InputColumn;
import io.crate.expression.symbol.SelectSymbol;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.SymbolVisitors;
import io.crate.expression.symbol.Symbols;
import io.crate.metadata.Reference;
import io.crate.metadata.RowGranularity;
import io.crate.types.DataTypes;
import org.elasticsearch.Version;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;
import javax.annotation.Nullable;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
public class SysUpdateProjection extends Projection {
    private final Symbol uidSymbol</b></font>;
    private Map&lt;Reference, Symbol&gt; assignments;
    private Symbol[] outputs;
    @Nullable
    private Symbol[] returnValues;
    public SysUpdateProjection(Symbol uidSymbol,
                               Map&lt;Reference, Symbol&gt; assignments,
                               Symbol[] outputs,
                               @Nullable Symbol[] returnValues
    ) {
        this.uidSymbol = uidSymbol;
        this.assignments = assignments;
        this.returnValues = returnValues;
        assert Arrays.stream(outputs).noneMatch(s -&gt; SymbolVisitors.any(Symbols.IS_COLUMN.or(x -&gt; x instanceof SelectSymbol), s))
            : "Cannot operate on Reference, Field or SelectSymbol symbols: " + outputs;
        this.outputs = outputs;
    }
    public SysUpdateProjection(StreamInput in) throws IOException {
        uidSymbol = Symbols.fromStream(in);
        int numAssignments = in.readVInt();
        assignments = new HashMap&lt;&gt;(numAssignments, 1.0f);
        for (int i = 0; i &lt; numAssignments; i++) {
            assignments.put(Reference.fromStream(in), Symbols.fromStream(in));
        }
        if (in.getVersion().onOrAfter(Version.V_4_2_0)) {
            int outputSize = in.readVInt();
            outputs = new Symbol[outputSize];
            for (int i = 0; i &lt; outputSize; i++) {
                outputs[i] = Symbols.fromStream(in);
            }
            int returnValuesSize = in.readVInt();
            if (returnValuesSize &gt; 0) {
                returnValues = new Symbol[returnValuesSize];
                for (int i = 0; i &lt; returnValuesSize; i++) {
                    returnValues[i] = Symbols.fromStream(in);
                }
            }
        } else {
            //Outputs should never be null and for BwC reasons
            //the default value in pre 4.1 was a long for a count
            outputs = new Symbol[]{new InputColumn(0, DataTypes.LONG)};
        }
    }
<a name="1"></a>
    @Override
    public ProjectionType projectionType() {
        <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ProjectionType.SYS_UPDATE;
    }
    @Nullable
    public Symbol[] returnValues() {
        return returnValues;
    }
    @</b></font>Override
    public List&lt;? extends Symbol&gt; outputs() {
        return List.of(outputs);
    }
    @Override
    public &lt;C, R&gt; R accept(ProjectionVisitor&lt;C, R&gt; visitor, C context) {
        return visitor.visitSysUpdateProjection(this, context);
    }
    public Map&lt;Reference, Symbol&gt; assignments() {
        return assignments;
    }
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        Symbols.toStream(uidSymbol, out);
        out.writeVInt(assignments.size());
        for (Map.Entry&lt;Reference, Symbol&gt; e : assignments.entrySet()) {
            Reference.toStream(e.getKey(), out);
            Symbols.toStream(e.getValue(), out);
        }
        if (out.getVersion().onOrAfter(Version.V_4_2_0)) {
            out.writeVInt(outputs.length);
            for (int i = 0; i &lt; outputs.length; i++) {
                Symbols.toStream(outputs[i], out);
            }
            if (returnValues != null) {
                out.writeVInt(returnValues.length);
                for (int i = 0; i &lt; returnValues.length; i++) {
                    Symbols.toStream(returnValues[i], out);
                }
            } else {
                out.writeVInt(0);
            }
        }
<a name="2"></a>    }
    @Override
    public boolean equals(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass</b></font>() != o.getClass()) {
            return false;
        }
        SysUpdateProjection that = (SysUpdateProjection) o;
        return Objects.equals(uidSymbol, that.uidSymbol) &amp;&amp;
               Objects.equals(assignments, that.assignments) &amp;&amp;
               Arrays.equals(outputs, that.outputs) &amp;&amp;
               Arrays.equals(returnValues, that.returnValues);
    }
    @Override
    public int hashCode() {
        int result = Objects.hash(super.hashCode(), uidSymbol, assignments);
        result = 31 * result + Arrays.hashCode(outputs);
        result = 31 * result + Arrays.hashCode(returnValues);
        return result;
    }
    @Override
    public RowGranularity requiredGranularity() {
        return RowGranularity.NODE;
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HostBasedAuthentication.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
package io.crate.auth;
<a name="0"></a>import io.crate.common.annotations.VisibleForTesting;
import io.crate.user.UserLookup;
import io.crate.protocols.postgres.ConnectionProperties;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.apache.http.conn.DnsResolver;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.network.Cidrs;
import org.elasticsearch.common.network.InetAddresses;
import org.elasticsearch.common.settings.Settings;
import javax.annotation.Nullable;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.SortedMap;
import java.util.TreeMap;
public class HostBasedAuthentication implements Authentication {
    private static final Logger LOGGER = LogManager.getLogger(HostBasedAuthentication.class)</b></font>;
    private static final String DEFAULT_AUTH_METHOD = "trust";
    private static final String KEY_USER = "user";
    private static final String KEY_ADDRESS = "address";
    private static final String KEY_METHOD = "method";
    private static final String KEY_PROTOCOL = "protocol";
    enum SSL {
        REQUIRED("on"),
        NEVER("off"),
        OPTIONAL("optional");
        static final String KEY = "ssl";
        final String VALUE;
        SSL(String value) {
            this.VALUE = value;
        }
        static SSL parseValue(String value) {
            return switch (value.toLowerCase(Locale.ENGLISH)) {
                case "on" -&gt; REQUIRED;
                case "true" -&gt; REQUIRED;
                case "off" -&gt; NEVER;
                case "false" -&gt; NEVER;
                case "optional" -&gt; OPTIONAL;
                default -&gt; throw new IllegalArgumentException(value + " is not a valid HBA SSL setting");
            };
        }
    }
    /*
     * The cluster state contains the hbaConf from the setting in this format:
     {
       "&lt;ident&gt;": {
         "address": "&lt;cidr&gt;",
         "method": "auth",
         "user": "&lt;username&gt;"
         "protocol": "pg"
       },
       ...
     }
     */
    private SortedMap&lt;String, Map&lt;String, String&gt;&gt; hbaConf;
    private final UserLookup userLookup;
    private final DnsResolver dnsResolver;
    @Inject
    public HostBasedAuthentication(Settings settings, UserLookup userLookup, DnsResolver dnsResolver) {
        hbaConf = convertHbaSettingsToHbaConf(settings);
        this.userLookup = userLookup;
        this.dnsResolver = dnsResolver;
    }
    @VisibleForTesting
    SortedMap&lt;String, Map&lt;String, String&gt;&gt; convertHbaSettingsToHbaConf(Settings settings) {
        Settings hbaSettings = AuthSettings.AUTH_HOST_BASED_CONFIG_SETTING.get(settings);
        SortedMap&lt;String, Map&lt;String, String&gt;&gt; hostBasedConf = new TreeMap&lt;&gt;();
        for (Map.Entry&lt;String, Settings&gt; entry : hbaSettings.getAsGroups().entrySet()) {
            Settings hbaEntry = entry.getValue();
            HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(hbaEntry.size());
            for (String name : hbaEntry.keySet()) {
                map.put(name, hbaEntry.get(name));
            }
            hostBasedConf.put(entry.getKey(), map);
        }
        return Collections.unmodifiableSortedMap(hostBasedConf);
    }
    @Nullable
    private AuthenticationMethod methodForName(String method) {
        switch (method) {
            case (TrustAuthenticationMethod.NAME):
                return new TrustAuthenticationMethod(userLookup);
            case (ClientCertAuth.NAME):
                return new ClientCertAuth(userLookup);
            case (PasswordAuthenticationMethod.NAME):
                return new PasswordAuthenticationMethod(userLookup);
            default:
                return null;
        }
    }
    @Override
    @Nullable
    public AuthenticationMethod resolveAuthenticationType(String user, ConnectionProperties connProperties) {
        assert hbaConf != null : "hba configuration is missing";
        Optional&lt;Map.Entry&lt;String, Map&lt;String, String&gt;&gt;&gt; entry = getEntry(user, connProperties);
        if (entry.isPresent()) {
            String methodName = entry.get()
                .getValue()
<a name="1"></a>                .getOrDefault(KEY_METHOD, DEFAULT_AUTH_METHOD);
            return methodForName(methodName);
        }
        <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return null;
    }
    @VisibleForTesting
    Map&lt;String, Map&lt;String, String&gt;&gt; hbaConf() {
        return hbaConf;
    }
    @</b></font>VisibleForTesting
    Optional&lt;Map.Entry&lt;String, Map&lt;String, String&gt;&gt;&gt; getEntry(String user, ConnectionProperties connectionProperties) {
        if (user == null || connectionProperties == null) {
            return Optional.empty();
        }
        return hbaConf.entrySet().stream()
            .filter(e -&gt; Matchers.isValidUser(e, user))
            .filter(e -&gt; Matchers.isValidAddress(e.getValue().get(KEY_ADDRESS), connectionProperties.address(), dnsResolver))
            .filter(e -&gt; Matchers.isValidProtocol(e.getValue().get(KEY_PROTOCOL), connectionProperties.protocol()))
            .filter(e -&gt; Matchers.isValidConnection(e.getValue().get(SSL.KEY), connectionProperties))
            .findFirst();
    }
    static class Matchers {
        private static final long IPV4_LOCALHOST = inetAddressToInt(InetAddresses.forString("127.0.0.1"));
        private static final long IPV6_LOCALHOST = inetAddressToInt(InetAddresses.forString("::1"));
        static boolean isValidUser(Map.Entry&lt;String, Map&lt;String, String&gt;&gt; entry, String user) {
            String hbaUser = entry.getValue().get(KEY_USER);
<a name="2"></a>            return hbaUser == null || user.equals(hbaUser);
        }
        static boolean isValidAddress(@Nullable String hbaAddressOrHostname, InetAddress address, <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>DnsResolver resolver) {
            if (hbaAddressOrHostname == null) {
                return true;
            }
            if (hbaAddressOrHostname.equals</b></font>("_local_")) {
                return inetAddressToInt(address) == IPV4_LOCALHOST || inetAddressToInt(address) == IPV6_LOCALHOST;
            }
            int p = hbaAddressOrHostname.indexOf('/');
            if (p &lt; 0) {
                try {
                    if (hbaAddressOrHostname.startsWith(".")) {
                        var clientHostName = address.getCanonicalHostName();
                        return clientHostName != null ? clientHostName.endsWith(hbaAddressOrHostname) : false;
                    } else {
                        return Arrays.stream(resolver.resolve(hbaAddressOrHostname)).anyMatch(inetAddress -&gt; inetAddress.equals(address));
                    }
                } catch (UnknownHostException e) {
                    LOGGER.warn("Cannot resolve hostname {} specified in the HBA configuration.", hbaAddressOrHostname);
                    return false;
                }
            }
            long[] minAndMax = Cidrs.cidrMaskToMinMax(hbaAddressOrHostname);
            long addressAsLong = inetAddressToInt(address);
            return minAndMax[0] &lt;= addressAsLong &amp;&amp; addressAsLong &lt; minAndMax[1];
        }
        static boolean isValidProtocol(String hbaProtocol, Protocol protocol) {
            return hbaProtocol == null || hbaProtocol.equals(protocol.toString());
        }
        static boolean isValidConnection(String hbaConnectionMode, ConnectionProperties connectionProperties) {
            if (hbaConnectionMode == null || hbaConnectionMode.isEmpty()) {
                return true;
            }
            SSL sslMode = SSL.parseValue(hbaConnectionMode);
            return switch (sslMode) {
                case OPTIONAL -&gt; true;
                case NEVER -&gt; !connectionProperties.hasSSL();
                case REQUIRED -&gt; connectionProperties.hasSSL();
            };
        }
        private static long inetAddressToInt(InetAddress address) {
            long net = 0;
            for (byte a : address.getAddress()) {
                net &lt;&lt;= 8;
                net |= a &amp; 0xFF;
            }
            return net;
        }
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
