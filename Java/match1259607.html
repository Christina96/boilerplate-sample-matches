<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for SysUpdateProjection.java & HostBasedAuthentication.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for SysUpdateProjection.java & HostBasedAuthentication.java
      </h3>
      <h1 align="center">
        14.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>SysUpdateProjection.java (17.391304%)<TH>HostBasedAuthentication.java (12.42236%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1259607-0.html#0',2,'match1259607-1.html#0',3)" NAME="0">(24-46)<TD><A HREF="javascript:ZweiFrames('match1259607-0.html#0',2,'match1259607-1.html#0',3)" NAME="0">(27-50)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1259607-0.html#1',2,'match1259607-1.html#1',3)" NAME="1">(97-105)<TD><A HREF="javascript:ZweiFrames('match1259607-0.html#1',2,'match1259607-1.html#1',3)" NAME="1">(146-154)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1259607-0.html#2',2,'match1259607-1.html#2',3)" NAME="2">(145-149)<TD><A HREF="javascript:ZweiFrames('match1259607-0.html#2',2,'match1259607-1.html#2',3)" NAME="2">(179-184)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SysUpdateProjection.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.execution.dsl.projection;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1259607-1.html#0',3,'match1259607-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.expression.symbol.InputColumn;
import io.crate.expression.symbol.SelectSymbol;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.SymbolVisitors;
import io.crate.expression.symbol.Symbols;
import io.crate.metadata.Reference;
import io.crate.metadata.RowGranularity;
import io.crate.types.DataTypes;
import org.elasticsearch.Version;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;

import javax.annotation.Nullable;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class SysUpdateProjection extends Projection {

    private final Symbol uidSymbol</B></FONT>;

    private Map&lt;Reference, Symbol&gt; assignments;

    private Symbol[] outputs;

    @Nullable
    private Symbol[] returnValues;

    public SysUpdateProjection(Symbol uidSymbol,
                               Map&lt;Reference, Symbol&gt; assignments,
                               Symbol[] outputs,
                               @Nullable Symbol[] returnValues
    ) {
        this.uidSymbol = uidSymbol;
        this.assignments = assignments;
        this.returnValues = returnValues;
        assert Arrays.stream(outputs).noneMatch(s -&gt; SymbolVisitors.any(Symbols.IS_COLUMN.or(x -&gt; x instanceof SelectSymbol), s))
            : &quot;Cannot operate on Reference, Field or SelectSymbol symbols: &quot; + outputs;
        this.outputs = outputs;
    }

    public SysUpdateProjection(StreamInput in) throws IOException {
        uidSymbol = Symbols.fromStream(in);
        int numAssignments = in.readVInt();
        assignments = new HashMap&lt;&gt;(numAssignments, 1.0f);
        for (int i = 0; i &lt; numAssignments; i++) {
            assignments.put(Reference.fromStream(in), Symbols.fromStream(in));
        }
        if (in.getVersion().onOrAfter(Version.V_4_2_0)) {
            int outputSize = in.readVInt();
            outputs = new Symbol[outputSize];
            for (int i = 0; i &lt; outputSize; i++) {
                outputs[i] = Symbols.fromStream(in);
            }
            int returnValuesSize = in.readVInt();
            if (returnValuesSize &gt; 0) {
                returnValues = new Symbol[returnValuesSize];
                for (int i = 0; i &lt; returnValuesSize; i++) {
                    returnValues[i] = Symbols.fromStream(in);
                }
            }
        } else {
            //Outputs should never be null and for BwC reasons
            //the default value in pre 4.1 was a long for a count
            outputs = new Symbol[]{new InputColumn(0, DataTypes.LONG)};
        }
    }
<A NAME="1"></A>
    @Override
    public ProjectionType projectionType() {
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1259607-1.html#1',3,'match1259607-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return ProjectionType.SYS_UPDATE;
    }

    @Nullable
    public Symbol[] returnValues() {
        return returnValues;
    }

    @</B></FONT>Override
    public List&lt;? extends Symbol&gt; outputs() {
        return List.of(outputs);
    }

    @Override
    public &lt;C, R&gt; R accept(ProjectionVisitor&lt;C, R&gt; visitor, C context) {
        return visitor.visitSysUpdateProjection(this, context);
    }

    public Map&lt;Reference, Symbol&gt; assignments() {
        return assignments;
    }

    @Override
    public void writeTo(StreamOutput out) throws IOException {
        Symbols.toStream(uidSymbol, out);
        out.writeVInt(assignments.size());
        for (Map.Entry&lt;Reference, Symbol&gt; e : assignments.entrySet()) {
            Reference.toStream(e.getKey(), out);
            Symbols.toStream(e.getValue(), out);
        }

        if (out.getVersion().onOrAfter(Version.V_4_2_0)) {
            out.writeVInt(outputs.length);
            for (int i = 0; i &lt; outputs.length; i++) {
                Symbols.toStream(outputs[i], out);
            }
            if (returnValues != null) {
                out.writeVInt(returnValues.length);
                for (int i = 0; i &lt; returnValues.length; i++) {
                    Symbols.toStream(returnValues[i], out);
                }
            } else {
                out.writeVInt(0);
            }
        }
<A NAME="2"></A>    }

    @Override
    public boolean equals(<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1259607-1.html#2',3,'match1259607-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass</B></FONT>() != o.getClass()) {
            return false;
        }
        SysUpdateProjection that = (SysUpdateProjection) o;
        return Objects.equals(uidSymbol, that.uidSymbol) &amp;&amp;
               Objects.equals(assignments, that.assignments) &amp;&amp;
               Arrays.equals(outputs, that.outputs) &amp;&amp;
               Arrays.equals(returnValues, that.returnValues);
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(super.hashCode(), uidSymbol, assignments);
        result = 31 * result + Arrays.hashCode(outputs);
        result = 31 * result + Arrays.hashCode(returnValues);
        return result;
    }

    @Override
    public RowGranularity requiredGranularity() {
        return RowGranularity.NODE;
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>HostBasedAuthentication.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.auth;

<A NAME="0"></A>import io.crate.common.annotations.VisibleForTesting;
import io.crate.user.UserLookup;
import io.crate.protocols.postgres.ConnectionProperties;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1259607-0.html#0',2,'match1259607-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import org.apache.http.conn.DnsResolver;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.network.Cidrs;
import org.elasticsearch.common.network.InetAddresses;
import org.elasticsearch.common.settings.Settings;

import javax.annotation.Nullable;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.SortedMap;
import java.util.TreeMap;


public class HostBasedAuthentication implements Authentication {

    private static final Logger LOGGER = LogManager.getLogger(HostBasedAuthentication.class)</B></FONT>;

    private static final String DEFAULT_AUTH_METHOD = &quot;trust&quot;;
    private static final String KEY_USER = &quot;user&quot;;
    private static final String KEY_ADDRESS = &quot;address&quot;;
    private static final String KEY_METHOD = &quot;method&quot;;
    private static final String KEY_PROTOCOL = &quot;protocol&quot;;

    enum SSL {
        REQUIRED(&quot;on&quot;),
        NEVER(&quot;off&quot;),
        OPTIONAL(&quot;optional&quot;);

        static final String KEY = &quot;ssl&quot;;
        final String VALUE;

        SSL(String value) {
            this.VALUE = value;
        }

        static SSL parseValue(String value) {
            return switch (value.toLowerCase(Locale.ENGLISH)) {
                // allow true/false as well because YAML `on` is interpreted as true
                case &quot;on&quot; -&gt; REQUIRED;
                case &quot;true&quot; -&gt; REQUIRED;
                case &quot;off&quot; -&gt; NEVER;
                case &quot;false&quot; -&gt; NEVER;
                case &quot;optional&quot; -&gt; OPTIONAL;
                default -&gt; throw new IllegalArgumentException(value + &quot; is not a valid HBA SSL setting&quot;);
            };
        }
    }

    /*
     * The cluster state contains the hbaConf from the setting in this format:
     {
       &quot;&lt;ident&gt;&quot;: {
         &quot;address&quot;: &quot;&lt;cidr&gt;&quot;,
         &quot;method&quot;: &quot;auth&quot;,
         &quot;user&quot;: &quot;&lt;username&gt;&quot;
         &quot;protocol&quot;: &quot;pg&quot;
       },
       ...
     }
     */
    private SortedMap&lt;String, Map&lt;String, String&gt;&gt; hbaConf;
    private final UserLookup userLookup;
    private final DnsResolver dnsResolver;

    @Inject
    public HostBasedAuthentication(Settings settings, UserLookup userLookup, DnsResolver dnsResolver) {
        hbaConf = convertHbaSettingsToHbaConf(settings);
        this.userLookup = userLookup;
        this.dnsResolver = dnsResolver;
    }

    @VisibleForTesting
    SortedMap&lt;String, Map&lt;String, String&gt;&gt; convertHbaSettingsToHbaConf(Settings settings) {
        Settings hbaSettings = AuthSettings.AUTH_HOST_BASED_CONFIG_SETTING.get(settings);
        SortedMap&lt;String, Map&lt;String, String&gt;&gt; hostBasedConf = new TreeMap&lt;&gt;();
        for (Map.Entry&lt;String, Settings&gt; entry : hbaSettings.getAsGroups().entrySet()) {
            Settings hbaEntry = entry.getValue();
            HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(hbaEntry.size());
            for (String name : hbaEntry.keySet()) {
                map.put(name, hbaEntry.get(name));
            }
            hostBasedConf.put(entry.getKey(), map);
        }
        return Collections.unmodifiableSortedMap(hostBasedConf);
    }

    @Nullable
    private AuthenticationMethod methodForName(String method) {
        switch (method) {
            case (TrustAuthenticationMethod.NAME):
                return new TrustAuthenticationMethod(userLookup);
            case (ClientCertAuth.NAME):
                return new ClientCertAuth(userLookup);
            case (PasswordAuthenticationMethod.NAME):
                return new PasswordAuthenticationMethod(userLookup);
            default:
                return null;
        }
    }

    @Override
    @Nullable
    public AuthenticationMethod resolveAuthenticationType(String user, ConnectionProperties connProperties) {
        assert hbaConf != null : &quot;hba configuration is missing&quot;;
        Optional&lt;Map.Entry&lt;String, Map&lt;String, String&gt;&gt;&gt; entry = getEntry(user, connProperties);
        if (entry.isPresent()) {
            String methodName = entry.get()
                .getValue()
<A NAME="1"></A>                .getOrDefault(KEY_METHOD, DEFAULT_AUTH_METHOD);
            return methodForName(methodName);
        }
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1259607-0.html#1',2,'match1259607-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return null;
    }

    @VisibleForTesting
    Map&lt;String, Map&lt;String, String&gt;&gt; hbaConf() {
        return hbaConf;
    }

    @</B></FONT>VisibleForTesting
    Optional&lt;Map.Entry&lt;String, Map&lt;String, String&gt;&gt;&gt; getEntry(String user, ConnectionProperties connectionProperties) {
        if (user == null || connectionProperties == null) {
            return Optional.empty();
        }
        return hbaConf.entrySet().stream()
            .filter(e -&gt; Matchers.isValidUser(e, user))
            .filter(e -&gt; Matchers.isValidAddress(e.getValue().get(KEY_ADDRESS), connectionProperties.address(), dnsResolver))
            .filter(e -&gt; Matchers.isValidProtocol(e.getValue().get(KEY_PROTOCOL), connectionProperties.protocol()))
            .filter(e -&gt; Matchers.isValidConnection(e.getValue().get(SSL.KEY), connectionProperties))
            .findFirst();
    }

    static class Matchers {

        // IPv4 127.0.0.1 -&gt; 2130706433
        private static final long IPV4_LOCALHOST = inetAddressToInt(InetAddresses.forString(&quot;127.0.0.1&quot;));
        // IPv6 ::1 -&gt; 1
        private static final long IPV6_LOCALHOST = inetAddressToInt(InetAddresses.forString(&quot;::1&quot;));

        static boolean isValidUser(Map.Entry&lt;String, Map&lt;String, String&gt;&gt; entry, String user) {
            String hbaUser = entry.getValue().get(KEY_USER);
<A NAME="2"></A>            return hbaUser == null || user.equals(hbaUser);
        }

        static boolean isValidAddress(@Nullable String hbaAddressOrHostname, InetAddress address, <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1259607-0.html#2',2,'match1259607-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>DnsResolver resolver) {
            if (hbaAddressOrHostname == null) {
                // no IP/CIDR --&gt; 0.0.0.0/0 --&gt; match all
                return true;
            }
            if (hbaAddressOrHostname.equals</B></FONT>(&quot;_local_&quot;)) {
                // special case &quot;_local_&quot; which matches both IPv4 and IPv6 localhost addresses
                return inetAddressToInt(address) == IPV4_LOCALHOST || inetAddressToInt(address) == IPV6_LOCALHOST;
            }
            int p = hbaAddressOrHostname.indexOf('/');
            if (p &lt; 0) {
                try {
                    if (hbaAddressOrHostname.startsWith(&quot;.&quot;)) {
                        // not an ip address, subdomain
                        var clientHostName = address.getCanonicalHostName();
                        return clientHostName != null ? clientHostName.endsWith(hbaAddressOrHostname) : false;
                    } else {
                        // SystemDefaultDnsResolver is injected here and internally it uses InetAddress.getAllByName
                        // which tries to treat argument as an ip address and then as a hostname.
                        return Arrays.stream(resolver.resolve(hbaAddressOrHostname)).anyMatch(inetAddress -&gt; inetAddress.equals(address));
                    }
                } catch (UnknownHostException e) {
                    LOGGER.warn(&quot;Cannot resolve hostname {} specified in the HBA configuration.&quot;, hbaAddressOrHostname);
                    return false;
                }
            }
            long[] minAndMax = Cidrs.cidrMaskToMinMax(hbaAddressOrHostname);
            long addressAsLong = inetAddressToInt(address);
            return minAndMax[0] &lt;= addressAsLong &amp;&amp; addressAsLong &lt; minAndMax[1];
        }

        static boolean isValidProtocol(String hbaProtocol, Protocol protocol) {
            return hbaProtocol == null || hbaProtocol.equals(protocol.toString());
        }

        static boolean isValidConnection(String hbaConnectionMode, ConnectionProperties connectionProperties) {
            if (hbaConnectionMode == null || hbaConnectionMode.isEmpty()) {
                return true;
            }
            SSL sslMode = SSL.parseValue(hbaConnectionMode);
            return switch (sslMode) {
                case OPTIONAL -&gt; true;
                case NEVER -&gt; !connectionProperties.hasSSL();
                case REQUIRED -&gt; connectionProperties.hasSSL();
            };
        }

        private static long inetAddressToInt(InetAddress address) {
            long net = 0;
            for (byte a : address.getAddress()) {
                net &lt;&lt;= 8;
                net |= a &amp; 0xFF;
            }
            return net;
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
