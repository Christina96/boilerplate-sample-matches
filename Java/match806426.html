<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ForwardingMapTest_1.java &amp; BigIntegerMathTest_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ForwardingMapTest_1.java &amp; BigIntegerMathTest_1.java
      </h3>
<h1 align="center">
        8.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ForwardingMapTest_1.java (14.235501%)<th>BigIntegerMathTest_1.java (6.398104%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-49)<td><a href="#" name="0">(17-49)</a><td align="center"><font color="#ff0000">31</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(236-240)<td><a href="#" name="1">(353-357)</a><td align="center"><font color="#620000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(264-268)<td><a href="#" name="2">(341-345)</a><td align="center"><font color="#5a0000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(291-295)<td><a href="#" name="3">(61-65)</a><td align="center"><font color="#4a0000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(203-209)<td><a href="#" name="4">(613-618)</a><td align="center"><font color="#4a0000">9</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(123-130)<td><a href="#" name="5">(516-524)</a><td align="center"><font color="#4a0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ForwardingMapTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.collect;
2 import static java.lang.reflect.Modifier.STATIC;
3 import static org.mockito.ArgumentMatchers.any;
4 import static org.mockito.Mockito.atLeast;
5 import static org.mockito.Mockito.mock;
6 import static org.mockito.Mockito.verify;
7 import static org.mockito.Mockito.verifyNoMoreInteractions;
8 import com.google.common.base.Function;
9 import com.google.common.collect.testing.MapTestSuiteBuilder;
10 import com.google.common.collect.testing.TestStringMapGenerator;
11 import com.google.common.collect.testing.features.CollectionFeature;
12 import com.google.common.collect.testing.features.CollectionSize;
13 import com.google.common.collect.testing.features.MapFeature;
14 import com.google.common.reflect.AbstractInvocationHandler;
15 import com.google.common.reflect.Parameter;
16 import com.google.common.reflect.Reflection;
17 import com.google.common.reflect.TypeToken;
18 import com.google.common.testing.ArbitraryInstances;
19 import com.google.common.testing.EqualsTester;
20 import com.google.common.testing.ForwardingWrapperTester;
21 import java.lang.reflect.InvocationTargetException;
22 import java.lang.reflect.Method;
23 import java.util.Arrays;
24 import java.util.Collection;
25 import java.util.Iterator;
26 import java.util.Map;
27 import java.util.Map.Entry;
28 import java.util.Set;
29 import junit.framework.Test;
30 import junit.framework.TestCase;
31 import</b></font> junit.framework.TestSuite;
32 public class ForwardingMapTest extends TestCase {
33   static class StandardImplForwardingMap&lt;K, V&gt; extends ForwardingMap&lt;K, V&gt; {
34     private final Map&lt;K, V&gt; backingMap;
35     StandardImplForwardingMap(Map&lt;K, V&gt; backingMap) {
36       this.backingMap = backingMap;
37     }
38     @Override
39     protected Map&lt;K, V&gt; delegate() {
40       return backingMap;
41     }
42     @Override
43     public boolean containsKey(Object key) {
44       return standardContainsKey(key);
45     }
46     @Override
47     public boolean containsValue(Object value) {
48       return standardContainsValue(value);
49     }
50     @Override
51     public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
52       standardPutAll(map);
53     }
54     @Override
55     public V remove(Object object) {
56       return standardRemove(object);
57     }
58     @Override
59     public boolean equals(Object object) {
60       return standardEquals(object);
61     }
62     @Override
63     public int hashCode() {
64       return standardHashCode();
65     }
66     @Override
67     public Set&lt;K&gt; keySet() {
68       return new StandardKeySet();
69     }
70     @Override
71     public Collection&lt;V&gt; values() {
72       return new StandardValues();
73     }
74     @Override
75     public String toString() {
76       return standardToString();
77     }
78     @Override
79     public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
80       return new StandardEntrySet() {
81         @Override
82         public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
83 <a name="5"></a>          return delegate().entrySet().iterator();
84         }
85       };
86     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
87     @Override
88     public void clear() {
89       standardClear();
90     }
91     @Overri</b></font>de
92     public boolean isEmpty() {
93       return standardIsEmpty();
94     }
95   }
96   public static Test suite() {
97     TestSuite suite = new TestSuite();
98     suite.addTestSuite(ForwardingMapTest.class);
99     suite.addTest(
100         MapTestSuiteBuilder.using(
101                 new TestStringMapGenerator() {
102                   @Override
103                   protected Map&lt;String, String&gt; create(Entry&lt;String, String&gt;[] entries) {
104                     Map&lt;String, String&gt; map = Maps.newLinkedHashMap();
105                     for (Entry&lt;String, String&gt; entry : entries) {
106                       map.put(entry.getKey(), entry.getValue());
107                     }
108                     return new StandardImplForwardingMap&lt;&gt;(map);
109                   }
110                 })
111             .named("ForwardingMap[LinkedHashMap] with standard implementations")
112             .withFeatures(
113                 CollectionSize.ANY,
114                 MapFeature.ALLOWS_NULL_VALUES,
115                 MapFeature.ALLOWS_NULL_KEYS,
116                 MapFeature.ALLOWS_ANY_NULL_QUERIES,
117                 MapFeature.GENERAL_PURPOSE,
118                 CollectionFeature.SUPPORTS_ITERATOR_REMOVE,
119                 CollectionFeature.KNOWN_ORDER)
120             .createTestSuite());
121     suite.addTest(
122         MapTestSuiteBuilder.using(
123                 new TestStringMapGenerator() {
124                   @Override
125                   protected Map&lt;String, String&gt; create(Entry&lt;String, String&gt;[] entries) {
126                     ImmutableMap.Builder&lt;String, String&gt; builder = ImmutableMap.builder();
127                     for (Entry&lt;String, String&gt; entry : entries) {
128                       builder.put(entry.getKey(), entry.getValue());
129                     }
130                     return new StandardImplForwardingMap&lt;&gt;(builder.buildOrThrow());
131                   }
132                 })
133             .named("ForwardingMap[ImmutableMap] with standard implementations")
134             .withFeatures(
135                 CollectionSize.ANY,
136                 MapFeature.REJECTS_DUPLICATES_AT_CREATION,
137                 MapFeature.ALLOWS_ANY_NULL_QUERIES,
138                 CollectionFeature.KNOWN_ORDER)
139             .createTestSuite());
140     return suite;
141   }
142   @SuppressWarnings({"rawtypes", "unchecked"})
143   public void testForwarding() {
144     new ForwardingWrapperTester()
145         .testForwarding(
146             Map.class,
147             new Function&lt;Map, Map&gt;() {
148               @Override
149               public Map apply(Map delegate) {
150                 return wrap(delegate);
151               }
152             });
153   }
154 <a name="4"></a>  public void testEquals() {
155     Map&lt;Integer, String&gt; map1 = ImmutableMap.of(1, "one");
156     Map&lt;Integer, String&gt; map2 = ImmutableMap.of(2, "two");
157     <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new EqualsTester()
158         .addEqualityGroup(map1, wrap(map1), wrap(map1))
159         .addEqualityGroup(map2, wrap(map2))
160         .testEquals();
161   }
162   public void testStan</b></font>dardEntrySet() throws InvocationTargetException {
163     @SuppressWarnings("unchecked")
164     final Map&lt;String, Boolean&gt; map = mock(Map.class);
165     Map&lt;String, Boolean&gt; forward =
166         new ForwardingMap&lt;String, Boolean&gt;() {
167           @Override
168           protected Map&lt;String, Boolean&gt; delegate() {
169             return map;
170           }
171           @Override
172           public Set&lt;Entry&lt;String, Boolean&gt;&gt; entrySet() {
173             return new StandardEntrySet() {
174               @Override
175               public Iterator&lt;Entry&lt;String, Boolean&gt;&gt; iterator() {
176                 return Iterators.emptyIterator();
177               }
178             };
179           }
180         };
181     callAllPublicMethods(new TypeToken&lt;Set&lt;Entry&lt;String, Boolean&gt;&gt;&gt;() {}, forward.entrySet());
182 <a name="1"></a>    verify(map, atLeast(0)).clear();
183     verify(map, atLeast(0)).containsKey(any());
184     verify(map, atLeast(0)).get(any());
185     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>verify(map, atLeast(0)).isEmpty();
186     verify(map, atLeast(0)).remove(any());
187     verify(map, atLeast(0)).size();
188     verifyNoMoreInteractions(map);
189   }</b></font>
190   public void testStandardKeySet() throws InvocationTargetException {
191     @SuppressWarnings("unchecked")
192     final Map&lt;String, Boolean&gt; map = mock(Map.class);
193     Map&lt;String, Boolean&gt; forward =
194         new ForwardingMap&lt;String, Boolean&gt;() {
195           @Override
196           protected Map&lt;String, Boolean&gt; delegate() {
197             return map;
198           }
199           @Override
200           public Set&lt;String&gt; keySet() {
201             return new StandardKeySet();
202           }
203         };
204     callAllPublicMethods(new TypeToken&lt;Set&lt;String&gt;&gt;() {}, forward.keySet());
205 <a name="2"></a>    verify(map, atLeast(0)).clear();
206     verify(map, atLeast(0)).containsKey(any());
207     verify(map, atLeast(0)).isEmpty();
208     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>verify(map, atLeast(0)).remove(any());
209     verify(map, atLeast(0)).size();
210     verify(map, atLeast(0)).entrySet();
211     verifyNoMoreInteractions(map);
212   }</b></font>
213   public void testStandardValues() throws InvocationTargetException {
214     @SuppressWarnings("unchecked")
215     final Map&lt;String, Boolean&gt; map = mock(Map.class);
216     Map&lt;String, Boolean&gt; forward =
217         new ForwardingMap&lt;String, Boolean&gt;() {
218           @Override
219           protected Map&lt;String, Boolean&gt; delegate() {
220             return map;
221           }
222           @Override
223           public Collection&lt;Boolean&gt; values() {
224             return new StandardValues();
225           }
226         };
227     callAllPublicMethods(new TypeToken&lt;Collection&lt;Boolean&gt;&gt;() {}, forward.values());
228 <a name="3"></a>        verify(map, atLeast(0)).clear();
229     verify(map, atLeast(0)).containsValue(any());
230     verify(map, <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>atLeast(0)).isEmpty();
231     verify(map, atLeast(0)).size();
232     verify(map, atLeast(0)).entrySet();
233     verifyNoMoreInteractions(map);
234   }</b></font>
235   public void testToStringWithNullKeys() throws Exception {
236     Map&lt;String, String&gt; hashmap = Maps.newHashMap();
237     hashmap.put("foo", "bar");
238     hashmap.put(null, "baz");
239     StandardImplForwardingMap&lt;String, String&gt; forwardingMap =
240         new StandardImplForwardingMap&lt;&gt;(Maps.&lt;String, String&gt;newHashMap());
241     forwardingMap.put("foo", "bar");
242     forwardingMap.put(null, "baz");
243     assertEquals(hashmap.toString(), forwardingMap.toString());
244   }
245   public void testToStringWithNullValues() throws Exception {
246     Map&lt;String, String&gt; hashmap = Maps.newHashMap();
247     hashmap.put("foo", "bar");
248     hashmap.put("baz", null);
249     StandardImplForwardingMap&lt;String, String&gt; forwardingMap =
250         new StandardImplForwardingMap&lt;&gt;(Maps.&lt;String, String&gt;newHashMap());
251     forwardingMap.put("foo", "bar");
252     forwardingMap.put("baz", null);
253     assertEquals(hashmap.toString(), forwardingMap.toString());
254   }
255   private static &lt;K, V&gt; Map&lt;K, V&gt; wrap(final Map&lt;K, V&gt; delegate) {
256     return new ForwardingMap&lt;K, V&gt;() {
257       @Override
258       protected Map&lt;K, V&gt; delegate() {
259         return delegate;
260       }
261     };
262   }
263   private static final ImmutableMap&lt;String, String&gt; JUF_METHODS =
264       ImmutableMap.of(
265           "java.util.function.Predicate", "test",
266           "java.util.function.Consumer", "accept",
267           "java.util.function.IntFunction", "apply");
268   private static Object getDefaultValue(final TypeToken&lt;?&gt; type) {
269     Class&lt;?&gt; rawType = type.getRawType();
270     Object defaultValue = ArbitraryInstances.get(rawType);
271     if (defaultValue != null) {
272       return defaultValue;
273     }
274     final String typeName = rawType.getCanonicalName();
275     if (JUF_METHODS.containsKey(typeName)) {
276       return Reflection.newProxy(
277           rawType,
278           new AbstractInvocationHandler() {
279             @Override
280             public Object handleInvocation(Object proxy, Method method, Object[] args) {
281               if (method.getName().equals(JUF_METHODS.get(typeName))) {
282                 return getDefaultValue(type.method(method).getReturnType());
283               }
284               throw new IllegalStateException("Unexpected " + method + " invoked on " + proxy);
285             }
286           });
287     } else {
288       return null;
289     }
290   }
291   private static &lt;T&gt; void callAllPublicMethods(TypeToken&lt;T&gt; type, T object)
292       throws InvocationTargetException {
293     for (Method method : type.getRawType().getMethods()) {
294       if ((method.getModifiers() &amp; STATIC) != 0) {
295         continue;
296       }
297       ImmutableList&lt;Parameter&gt; parameters = type.method(method).getParameters();
298       Object[] args = new Object[parameters.size()];
299       for (int i = 0; i &lt; parameters.size(); i++) {
300         args[i] = getDefaultValue(parameters.get(i).getType());
301       }
302       try {
303         try {
304           method.invoke(object, args);
305         } catch (InvocationTargetException ex) {
306           try {
307             throw ex.getCause();
308           } catch (UnsupportedOperationException unsupported) {
309           }
310         }
311       } catch (Throwable cause) {
312         throw new InvocationTargetException(cause, method + " with args: " + Arrays.toString(args));
313       }
314     }
315   }
316 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BigIntegerMathTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.math;
2 import static com.google.common.math.MathTesting.ALL_BIGINTEGER_CANDIDATES;
3 import static com.google.common.math.MathTesting.ALL_ROUNDING_MODES;
4 import static com.google.common.math.MathTesting.ALL_SAFE_ROUNDING_MODES;
5 import static com.google.common.math.MathTesting.NEGATIVE_BIGINTEGER_CANDIDATES;
6 import static com.google.common.math.MathTesting.NONZERO_BIGINTEGER_CANDIDATES;
7 import static com.google.common.math.MathTesting.POSITIVE_BIGINTEGER_CANDIDATES;
8 import static com.google.common.truth.Truth.assertThat;
9 import static com.google.common.truth.Truth.assertWithMessage;
10 import static java.math.BigInteger.ONE;
11 import static java.math.BigInteger.TEN;
12 import static java.math.BigInteger.ZERO;
13 import static java.math.RoundingMode.CEILING;
14 import static java.math.RoundingMode.DOWN;
15 import static java.math.RoundingMode.FLOOR;
16 import static java.math.RoundingMode.HALF_DOWN;
17 import static java.math.RoundingMode.HALF_EVEN;
18 import static java.math.RoundingMode.HALF_UP;
19 import static java.math.RoundingMode.UNNECESSARY;
20 import static java.math.RoundingMode.UP;
21 import static java.math.RoundingMode.values;
22 import static java.util.Arrays.asList;
23 import com.google.common.annotations.GwtCompatible;
24 import com.google.common.annotations.GwtIncompatible;
25 import com.google.common.testing.NullPointerTester;
26 import java.math.BigDecimal;
27 import java.math.BigInteger;
28 import java.math.RoundingMode;
29 import java.util.EnumMap;
30 import java.util.EnumSet;
31 import</b></font> java.util.Map;
32 import junit.framework.TestCase;
33 @GwtCompatible(emulated = true)
34 <a name="3"></a>public class BigIntegerMathTest extends TestCase {
35   public void testCeilingPowerOfTwo() {
36     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
37       BigInteger result = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BigIntegerMath.ceilingPowerOfTwo(x);
38       assertTrue(BigIntegerMath.isPowerOfTwo(result));
39       assertTrue(result.compareTo(x) &gt;= 0);
40       assertTrue(result.compareTo(x.add(x)) &lt; 0);
41     }</b></font>
42   }
43   public void testFloorPowerOfTwo() {
44     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
45       BigInteger result = BigIntegerMath.floorPowerOfTwo(x);
46       assertTrue(BigIntegerMath.isPowerOfTwo(result));
47       assertTrue(result.compareTo(x) &lt;= 0);
48       assertTrue(result.add(result).compareTo(x) &gt; 0);
49     }
50   }
51   public void testCeilingPowerOfTwoNegative() {
52     for (BigInteger x : NEGATIVE_BIGINTEGER_CANDIDATES) {
53       try {
54         BigIntegerMath.ceilingPowerOfTwo(x);
55         fail("Expected IllegalArgumentException");
56       } catch (IllegalArgumentException expected) {
57       }
58     }
59   }
60   public void testFloorPowerOfTwoNegative() {
61     for (BigInteger x : NEGATIVE_BIGINTEGER_CANDIDATES) {
62       try {
63         BigIntegerMath.floorPowerOfTwo(x);
64         fail("Expected IllegalArgumentException");
65       } catch (IllegalArgumentException expected) {
66       }
67     }
68   }
69   public void testCeilingPowerOfTwoZero() {
70     try {
71       BigIntegerMath.ceilingPowerOfTwo(BigInteger.ZERO);
72       fail("Expected IllegalArgumentException");
73     } catch (IllegalArgumentException expected) {
74     }
75   }
76   public void testFloorPowerOfTwoZero() {
77     try {
78       BigIntegerMath.floorPowerOfTwo(BigInteger.ZERO);
79       fail("Expected IllegalArgumentException");
80     } catch (IllegalArgumentException expected) {
81     }
82   }
83   @GwtIncompatible   public void testConstantSqrt2PrecomputedBits() {
84     assertEquals(
85         BigIntegerMath.sqrt(
86             BigInteger.ZERO.setBit(2 * BigIntegerMath.SQRT2_PRECOMPUTE_THRESHOLD + 1), FLOOR),
87         BigIntegerMath.SQRT2_PRECOMPUTED_BITS);
88   }
89   public void testIsPowerOfTwo() {
90     for (BigInteger x : ALL_BIGINTEGER_CANDIDATES) {
91       boolean expected = x.signum() &gt; 0 &amp; x.and(x.subtract(ONE)).equals(ZERO);
92       assertEquals(expected, BigIntegerMath.isPowerOfTwo(x));
93     }
94   }
95   public void testLog2ZeroAlwaysThrows() {
96     for (RoundingMode mode : ALL_ROUNDING_MODES) {
97       try {
98         BigIntegerMath.log2(ZERO, mode);
99         fail("Expected IllegalArgumentException");
100       } catch (IllegalArgumentException expected) {
101       }
102     }
103   }
104   public void testLog2NegativeAlwaysThrows() {
105     for (RoundingMode mode : ALL_ROUNDING_MODES) {
106       try {
107         BigIntegerMath.log2(BigInteger.valueOf(-1), mode);
108         fail("Expected IllegalArgumentException");
109       } catch (IllegalArgumentException expected) {
110       }
111     }
112   }
113   public void testLog2Floor() {
114     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
115       for (RoundingMode mode : asList(FLOOR, DOWN)) {
116         int result = BigIntegerMath.log2(x, mode);
117         assertTrue(ZERO.setBit(result).compareTo(x) &lt;= 0);
118         assertTrue(ZERO.setBit(result + 1).compareTo(x) &gt; 0);
119       }
120     }
121   }
122   public void testLog2Ceiling() {
123     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
124       for (RoundingMode mode : asList(CEILING, UP)) {
125         int result = BigIntegerMath.log2(x, mode);
126         assertTrue(ZERO.setBit(result).compareTo(x) &gt;= 0);
127         assertTrue(result == 0 || ZERO.setBit(result - 1).compareTo(x) &lt; 0);
128       }
129     }
130   }
131   public void testLog2Exact() {
132     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
133       boolean isPowerOf2 = BigIntegerMath.isPowerOfTwo(x);
134       try {
135         assertEquals(x, ZERO.setBit(BigIntegerMath.log2(x, UNNECESSARY)));
136         assertTrue(isPowerOf2);
137       } catch (ArithmeticException e) {
138         assertFalse(isPowerOf2);
139       }
140     }
141   }
142   public void testLog2HalfUp() {
143     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
144       int result = BigIntegerMath.log2(x, HALF_UP);
145       BigInteger x2 = x.pow(2);
146       assertTrue(ZERO.setBit(2 * result + 1).compareTo(x2) &gt; 0);
147       assertTrue(result == 0 || ZERO.setBit(2 * result - 1).compareTo(x2) &lt;= 0);
148     }
149   }
150   public void testLog2HalfDown() {
151     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
152       int result = BigIntegerMath.log2(x, HALF_DOWN);
153       BigInteger x2 = x.pow(2);
154       assertTrue(ZERO.setBit(2 * result + 1).compareTo(x2) &gt;= 0);
155       assertTrue(result == 0 || ZERO.setBit(2 * result - 1).compareTo(x2) &lt; 0);
156     }
157   }
158   public void testLog2HalfEven() {
159     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
160       int halfEven = BigIntegerMath.log2(x, HALF_EVEN);
161       boolean floorWasEven = (BigIntegerMath.log2(x, FLOOR) &amp; 1) == 0;
162       assertEquals(BigIntegerMath.log2(x, floorWasEven ? HALF_DOWN : HALF_UP), halfEven);
163     }
164   }
165   @GwtIncompatible   public void testLog10ZeroAlwaysThrows() {
166     for (RoundingMode mode : ALL_ROUNDING_MODES) {
167       try {
168         BigIntegerMath.log10(ZERO, mode);
169         fail("Expected IllegalArgumentException");
170       } catch (IllegalArgumentException expected) {
171       }
172     }
173   }
174   @GwtIncompatible   public void testLog10NegativeAlwaysThrows() {
175     for (RoundingMode mode : ALL_ROUNDING_MODES) {
176       try {
177         BigIntegerMath.log10(BigInteger.valueOf(-1), mode);
178         fail("Expected IllegalArgumentException");
179       } catch (IllegalArgumentException expected) {
180       }
181     }
182   }
183   @GwtIncompatible   public void testLog10Floor() {
184     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
185       for (RoundingMode mode : asList(FLOOR, DOWN)) {
186         int result = BigIntegerMath.log10(x, mode);
187         assertTrue(TEN.pow(result).compareTo(x) &lt;= 0);
188         assertTrue(TEN.pow(result + 1).compareTo(x) &gt; 0);
189       }
190     }
191   }
192   @GwtIncompatible   public void testLog10Ceiling() {
193     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
194       for (RoundingMode mode : asList(CEILING, UP)) {
195         int result = BigIntegerMath.log10(x, mode);
196         assertTrue(TEN.pow(result).compareTo(x) &gt;= 0);
197         assertTrue(result == 0 || TEN.pow(result - 1).compareTo(x) &lt; 0);
198       }
199     }
200   }
201   @GwtIncompatible   public void testLog10Exact() {
202     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
203       int logFloor = BigIntegerMath.log10(x, FLOOR);
204       boolean expectSuccess = TEN.pow(logFloor).equals(x);
205       try {
206         assertEquals(logFloor, BigIntegerMath.log10(x, UNNECESSARY));
207         assertTrue(expectSuccess);
208       } catch (ArithmeticException e) {
209         assertFalse(expectSuccess);
210       }
211     }
212   }
213   @GwtIncompatible   public void testLog10HalfUp() {
214     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
215       int result = BigIntegerMath.log10(x, HALF_UP);
216       BigInteger x2 = x.pow(2);
217       assertTrue(TEN.pow(2 * result + 1).compareTo(x2) &gt; 0);
218       assertTrue(result == 0 || TEN.pow(2 * result - 1).compareTo(x2) &lt;= 0);
219     }
220   }
221   @GwtIncompatible   public void testLog10HalfDown() {
222     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
223       int result = BigIntegerMath.log10(x, HALF_DOWN);
224       BigInteger x2 = x.pow(2);
225       assertTrue(TEN.pow(2 * result + 1).compareTo(x2) &gt;= 0);
226       assertTrue(result == 0 || TEN.pow(2 * result - 1).compareTo(x2) &lt; 0);
227     }
228   }
229   @GwtIncompatible   public void testLog10HalfEven() {
230     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
231       int halfEven = BigIntegerMath.log10(x, HALF_EVEN);
232       boolean floorWasEven = (BigIntegerMath.log10(x, FLOOR) &amp; 1) == 0;
233       assertEquals(BigIntegerMath.log10(x, floorWasEven ? HALF_DOWN : HALF_UP), halfEven);
234     }
235   }
236   @GwtIncompatible   public void testLog10TrivialOnPowerOf10() {
237     BigInteger x = BigInteger.TEN.pow(100);
238     for (RoundingMode mode : ALL_ROUNDING_MODES) {
239       assertEquals(100, BigIntegerMath.log10(x, mode));
240     }
241   }
242   @GwtIncompatible   public void testSqrtZeroAlwaysZero() {
243     for (RoundingMode mode : ALL_ROUNDING_MODES) {
244       assertEquals(ZERO, BigIntegerMath.sqrt(ZERO, mode));
245     }
246   }
247   @GwtIncompatible   public void testSqrtNegativeAlwaysThrows() {
248     for (RoundingMode mode : ALL_ROUNDING_MODES) {
249       try {
250         BigIntegerMath.sqrt(BigInteger.valueOf(-1), mode);
251         fail("Expected IllegalArgumentException");
252       } catch (IllegalArgumentException expected) {
253       }
254     }
255   }
256   @GwtIncompatible <a name="2"></a>  public void testSqrtFloor() {
257     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
258       for (RoundingMode mode : asList(FLOOR, DOWN)) {
259         BigInteger result = <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BigIntegerMath.sqrt(x, mode);
260         assertTrue(result.compareTo(ZERO) &gt; 0);
261         assertTrue(result.pow(2).compareTo(x) &lt;= 0);
262         assertTrue(result.add(ONE).pow(2).compareTo(x) &gt; 0);
263       }</b></font>
264     }
265   }
266   @GwtIncompatible <a name="1"></a>  public void testSqrtCeiling() {
267     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
268       for (RoundingMode mode : asList(CEILING, UP)) {
269         BigInteger result = <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>BigIntegerMath.sqrt(x, mode);
270         assertTrue(result.compareTo(ZERO) &gt; 0);
271         assertTrue(result.pow(2).compareTo(x) &gt;= 0);
272         assertTrue(result.signum() == 0 || result.subtract(ONE).pow(2).compareTo(x) &lt; 0);
273       }</b></font>
274     }
275   }
276   @GwtIncompatible   public void testSqrtExact() {
277     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
278       BigInteger floor = BigIntegerMath.sqrt(x, FLOOR);
279       boolean isPerfectSquare = floor.pow(2).equals(x);
280       try {
281         assertEquals(floor, BigIntegerMath.sqrt(x, UNNECESSARY));
282         assertTrue(isPerfectSquare);
283       } catch (ArithmeticException e) {
284         assertFalse(isPerfectSquare);
285       }
286     }
287   }
288   @GwtIncompatible   public void testSqrtHalfUp() {
289     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
290       BigInteger result = BigIntegerMath.sqrt(x, HALF_UP);
291       BigInteger plusHalfSquared = result.pow(2).add(result).shiftLeft(2).add(ONE);
292       BigInteger x4 = x.shiftLeft(2);
293       assertTrue(x4.compareTo(plusHalfSquared) &lt; 0);
294       BigInteger minusHalfSquared = result.pow(2).subtract(result).shiftLeft(2).add(ONE);
295       assertTrue(result.equals(ZERO) || x4.compareTo(minusHalfSquared) &gt;= 0);
296     }
297   }
298   @GwtIncompatible   public void testSqrtHalfDown() {
299     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
300       BigInteger result = BigIntegerMath.sqrt(x, HALF_DOWN);
301       BigInteger plusHalfSquared = result.pow(2).add(result).shiftLeft(2).add(ONE);
302       BigInteger x4 = x.shiftLeft(2);
303       assertTrue(x4.compareTo(plusHalfSquared) &lt;= 0);
304       BigInteger minusHalfSquared = result.pow(2).subtract(result).shiftLeft(2).add(ONE);
305       assertTrue(result.equals(ZERO) || x4.compareTo(minusHalfSquared) &gt; 0);
306     }
307   }
308   @GwtIncompatible   public void testSqrtHalfEven() {
309     for (BigInteger x : POSITIVE_BIGINTEGER_CANDIDATES) {
310       BigInteger halfEven = BigIntegerMath.sqrt(x, HALF_EVEN);
311       boolean floorWasOdd = BigIntegerMath.sqrt(x, FLOOR).testBit(0);
312       assertEquals(BigIntegerMath.sqrt(x, floorWasOdd ? HALF_UP : HALF_DOWN), halfEven);
313     }
314   }
315   @GwtIncompatible   @AndroidIncompatible   public void testDivNonZero() {
316     for (BigInteger p : NONZERO_BIGINTEGER_CANDIDATES) {
317       for (BigInteger q : NONZERO_BIGINTEGER_CANDIDATES) {
318         for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {
319           BigInteger expected =
320               new BigDecimal(p).divide(new BigDecimal(q), 0, mode).toBigIntegerExact();
321           assertEquals(expected, BigIntegerMath.divide(p, q, mode));
322         }
323       }
324     }
325   }
326   private static final BigInteger BAD_FOR_ANDROID_P = new BigInteger("-9223372036854775808");
327   private static final BigInteger BAD_FOR_ANDROID_Q = new BigInteger("-1");
328   private static final BigInteger BAD_FOR_GINGERBREAD_P = new BigInteger("-9223372036854775808");
329   private static final BigInteger BAD_FOR_GINGERBREAD_Q = new BigInteger("-4294967296");
330   @GwtIncompatible   @AndroidIncompatible   public void testDivNonZeroExact() {
331     boolean isAndroid = System.getProperty("java.runtime.name").contains("Android");
332     for (BigInteger p : NONZERO_BIGINTEGER_CANDIDATES) {
333       for (BigInteger q : NONZERO_BIGINTEGER_CANDIDATES) {
334         if (isAndroid &amp;&amp; p.equals(BAD_FOR_ANDROID_P) &amp;&amp; q.equals(BAD_FOR_ANDROID_Q)) {
335           continue;
336         }
337         if (isAndroid &amp;&amp; p.equals(BAD_FOR_GINGERBREAD_P) &amp;&amp; q.equals(BAD_FOR_GINGERBREAD_Q)) {
338           continue;
339         }
340         boolean dividesEvenly = p.remainder(q).equals(ZERO);
341         try {
342           BigInteger quotient = BigIntegerMath.divide(p, q, UNNECESSARY);
343           BigInteger undone = quotient.multiply(q);
344           if (!p.equals(undone)) {
345             failFormat("expected %s.multiply(%s) = %s; got %s", quotient, q, p, undone);
346           }
347           assertTrue(dividesEvenly);
348         } catch (ArithmeticException e) {
349           assertFalse(dividesEvenly);
350         }
351       }
352     }
353   }
354   @GwtIncompatible   public void testZeroDivIsAlwaysZero() {
355     for (BigInteger q : NONZERO_BIGINTEGER_CANDIDATES) {
356       for (RoundingMode mode : ALL_ROUNDING_MODES) {
357         assertEquals(ZERO, BigIntegerMath.divide(ZERO, q, mode));
358       }
359     }
360   }
361   @GwtIncompatible   public void testDivByZeroAlwaysFails() {
362     for (BigInteger p : ALL_BIGINTEGER_CANDIDATES) {
363       for (RoundingMode mode : ALL_ROUNDING_MODES) {
364         try {
365           BigIntegerMath.divide(p, ZERO, mode);
366           fail("Expected ArithmeticException");
367         } catch (ArithmeticException expected) {
368         }
369       }
370     }
371   }
372   public void testFactorial() {
373     BigInteger expected = BigInteger.ONE;
374     for (int i = 1; i &lt;= 200; i++) {
375       expected = expected.multiply(BigInteger.valueOf(i));
376       assertEquals(expected, BigIntegerMath.factorial(i));
377     }
378   }
379   public void testFactorial0() {
380     assertEquals(BigInteger.ONE, BigIntegerMath.factorial(0));
381   }
382   public void testFactorialNegative() {
383     try {
384       BigIntegerMath.factorial(-1);
385       fail("Expected IllegalArgumentException");
386     } catch (IllegalArgumentException expected) {
387     }
388   }
389 <a name="5"></a>
390   public void testBinomialSmall() {
391     runBinomialTest(0, 30);
392   <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
393   @GwtIncompatible   public void testBinomialLarge() {
394     runBinomialTest(31, 100);
395   }
396   private static </b></font>void runBinomialTest(int firstN, int lastN) {
397     for (int n = firstN; n &lt;= lastN; n++) {
398       for (int k = 0; k &lt;= n; k++) {
399         BigInteger expected =
400             BigIntegerMath.factorial(n)
401                 .divide(BigIntegerMath.factorial(k))
402                 .divide(BigIntegerMath.factorial(n - k));
403         assertEquals(expected, BigIntegerMath.binomial(n, k));
404       }
405     }
406   }
407   public void testBinomialOutside() {
408     for (int n = 0; n &lt;= 50; n++) {
409       try {
410         BigIntegerMath.binomial(n, -1);
411         fail("Expected IllegalArgumentException");
412       } catch (IllegalArgumentException expected) {
413       }
414       try {
415         BigIntegerMath.binomial(n, n + 1);
416         fail("Expected IllegalArgumentException");
417       } catch (IllegalArgumentException expected) {
418       }
419     }
420   }
421   @GwtIncompatible
422   private static final class RoundToDoubleTester {
423     private final BigInteger input;
424     private final Map&lt;RoundingMode, Double&gt; expectedValues = new EnumMap&lt;&gt;(RoundingMode.class);
425     private boolean unnecessaryShouldThrow = false;
426     RoundToDoubleTester(BigInteger input) {
427       this.input = input;
428     }
429     RoundToDoubleTester setExpectation(double expectedValue, RoundingMode... modes) {
430       for (RoundingMode mode : modes) {
431         Double previous = expectedValues.put(mode, expectedValue);
432         if (previous != null) {
433           throw new AssertionError();
434         }
435       }
436       return this;
437     }
438     public RoundToDoubleTester roundUnnecessaryShouldThrow() {
439       unnecessaryShouldThrow = true;
440       return this;
441     }
442     public void test() {
443       assertThat(expectedValues.keySet())
444           .containsAtLeastElementsIn(EnumSet.complementOf(EnumSet.of(UNNECESSARY)));
445       for (Map.Entry&lt;RoundingMode, Double&gt; entry : expectedValues.entrySet()) {
446         RoundingMode mode = entry.getKey();
447         Double expectation = entry.getValue();
448         assertWithMessage("roundToDouble(" + input + ", " + mode + ")")
449             .that(BigIntegerMath.roundToDouble(input, mode))
450             .isEqualTo(expectation);
451       }
452       if (!expectedValues.containsKey(UNNECESSARY)) {
453         assertWithMessage("Expected roundUnnecessaryShouldThrow call")
454             .that(unnecessaryShouldThrow)
455             .isTrue();
456         try {
457           BigIntegerMath.roundToDouble(input, UNNECESSARY);
458           fail("Expected ArithmeticException for roundToDouble(" + input + ", UNNECESSARY)");
459         } catch (ArithmeticException expected) {
460         }
461       }
462     }
463   }
464   @GwtIncompatible
465   public void testRoundToDouble_Zero() {
466     new RoundToDoubleTester(BigInteger.ZERO).setExpectation(0.0, values()).test();
467   }
468   @GwtIncompatible
469   public void testRoundToDouble_smallPositive() {
470     new RoundToDoubleTester(BigInteger.valueOf(16)).setExpectation(16.0, values()).test();
471   }
472 <a name="4"></a>
473   @GwtIncompatible
474   public void testRoundToDouble_maxPreciselyRepresentable() {
475     <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>new RoundToDoubleTester(BigInteger.valueOf(1L &lt;&lt; 53))
476         .setExpectation(Math.pow(2, 53), values())
477         .test();
478   }
479   @GwtIncompatible</b></font>
480   public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
481     double twoToThe53 = Math.pow(2, 53);
482     new RoundToDoubleTester(BigInteger.valueOf((1L &lt;&lt; 53) + 1))
483         .setExpectation(twoToThe53, DOWN, FLOOR, HALF_DOWN, HALF_EVEN)
484         .setExpectation(Math.nextUp(twoToThe53), CEILING, UP, HALF_UP)
485         .roundUnnecessaryShouldThrow()
486         .test();
487   }
488   @GwtIncompatible
489   public void testRoundToDouble_twoToThe54PlusOne() {
490     double twoToThe54 = Math.pow(2, 54);
491     new RoundToDoubleTester(BigInteger.valueOf((1L &lt;&lt; 54) + 1))
492         .setExpectation(twoToThe54, DOWN, FLOOR, HALF_DOWN, HALF_UP, HALF_EVEN)
493         .setExpectation(Math.nextUp(twoToThe54), CEILING, UP)
494         .roundUnnecessaryShouldThrow()
495         .test();
496   }
497   @GwtIncompatible
498   public void testRoundToDouble_twoToThe54PlusThree() {
499     double twoToThe54 = Math.pow(2, 54);
500     new RoundToDoubleTester(BigInteger.valueOf((1L &lt;&lt; 54) + 3))
501         .setExpectation(twoToThe54, DOWN, FLOOR)
502         .setExpectation(Math.nextUp(twoToThe54), CEILING, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
503         .roundUnnecessaryShouldThrow()
504         .test();
505   }
506   @GwtIncompatible
507   public void testRoundToDouble_twoToThe54PlusFour() {
508     new RoundToDoubleTester(BigInteger.valueOf((1L &lt;&lt; 54) + 4))
509         .setExpectation(Math.pow(2, 54) + 4, values())
510         .test();
511   }
512   @GwtIncompatible
513   public void testRoundToDouble_maxDouble() {
514     BigInteger maxDoubleAsBI = DoubleMath.roundToBigInteger(Double.MAX_VALUE, UNNECESSARY);
515     new RoundToDoubleTester(maxDoubleAsBI).setExpectation(Double.MAX_VALUE, values()).test();
516   }
517   @GwtIncompatible
518   public void testRoundToDouble_maxDoublePlusOne() {
519     BigInteger maxDoubleAsBI =
520         DoubleMath.roundToBigInteger(Double.MAX_VALUE, UNNECESSARY).add(BigInteger.ONE);
521     new RoundToDoubleTester(maxDoubleAsBI)
522         .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
523         .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
524         .roundUnnecessaryShouldThrow()
525         .test();
526   }
527   @GwtIncompatible
528   public void testRoundToDouble_wayTooBig() {
529     BigInteger bi = BigInteger.ONE.shiftLeft(2 * Double.MAX_EXPONENT);
530     new RoundToDoubleTester(bi)
531         .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
532         .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
533         .roundUnnecessaryShouldThrow()
534         .test();
535   }
536   @GwtIncompatible
537   public void testRoundToDouble_smallNegative() {
538     new RoundToDoubleTester(BigInteger.valueOf(-16)).setExpectation(-16.0, values()).test();
539   }
540   @GwtIncompatible
541   public void testRoundToDouble_minPreciselyRepresentable() {
542     new RoundToDoubleTester(BigInteger.valueOf(-1L &lt;&lt; 53))
543         .setExpectation(-Math.pow(2, 53), values())
544         .test();
545   }
546   @GwtIncompatible
547   public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
548     new RoundToDoubleTester(BigInteger.valueOf((-1L &lt;&lt; 53) - 1))
549         .setExpectation(-Math.pow(2, 53), DOWN, CEILING, HALF_DOWN, HALF_EVEN)
550         .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 53)), FLOOR, UP, HALF_UP)
551         .roundUnnecessaryShouldThrow()
552         .test();
553   }
554   @GwtIncompatible
555   public void testRoundToDouble_negativeTwoToThe54MinusOne() {
556     new RoundToDoubleTester(BigInteger.valueOf((-1L &lt;&lt; 54) - 1))
557         .setExpectation(-Math.pow(2, 54), DOWN, CEILING, HALF_DOWN, HALF_UP, HALF_EVEN)
558         .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP)
559         .roundUnnecessaryShouldThrow()
560         .test();
561   }
562   @GwtIncompatible
563   public void testRoundToDouble_negativeTwoToThe54MinusThree() {
564     new RoundToDoubleTester(BigInteger.valueOf((-1L &lt;&lt; 54) - 3))
565         .setExpectation(-Math.pow(2, 54), DOWN, CEILING)
566         .setExpectation(
567             DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
568         .roundUnnecessaryShouldThrow()
569         .test();
570   }
571   @GwtIncompatible
572   public void testRoundToDouble_negativeTwoToThe54MinusFour() {
573     new RoundToDoubleTester(BigInteger.valueOf((-1L &lt;&lt; 54) - 4))
574         .setExpectation(-Math.pow(2, 54) - 4, values())
575         .test();
576   }
577   @GwtIncompatible
578   public void testRoundToDouble_minDouble() {
579     BigInteger minDoubleAsBI = DoubleMath.roundToBigInteger(-Double.MAX_VALUE, UNNECESSARY);
580     new RoundToDoubleTester(minDoubleAsBI).setExpectation(-Double.MAX_VALUE, values()).test();
581   }
582   @GwtIncompatible
583   public void testRoundToDouble_minDoubleMinusOne() {
584     BigInteger minDoubleAsBI =
585         DoubleMath.roundToBigInteger(-Double.MAX_VALUE, UNNECESSARY).subtract(BigInteger.ONE);
586     new RoundToDoubleTester(minDoubleAsBI)
587         .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
588         .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
589         .roundUnnecessaryShouldThrow()
590         .test();
591   }
592   @GwtIncompatible
593   public void testRoundToDouble_negativeWayTooBig() {
594     BigInteger bi = BigInteger.ONE.shiftLeft(2 * Double.MAX_EXPONENT).negate();
595     new RoundToDoubleTester(bi)
596         .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
597         .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
598         .roundUnnecessaryShouldThrow()
599         .test();
600   }
601   @GwtIncompatible   public void testNullPointers() {
602     NullPointerTester tester = new NullPointerTester();
603     tester.setDefault(BigInteger.class, ONE);
604     tester.setDefault(int.class, 1);
605     tester.setDefault(long.class, 1L);
606     tester.testAllPublicStaticMethods(BigIntegerMath.class);
607   }
608   @GwtIncompatible   private static void failFormat(String template, Object... args) {
609     fail(String.format(template, args));
610   }
611 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
