<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for MapContainsValueTester_1.java &amp; ExecutionSequencerTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for MapContainsValueTester_1.java &amp; ExecutionSequencerTest.java
      </h3>
<h1 align="center">
        5.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>MapContainsValueTester_1.java (22.988506%)<th>ExecutionSequencerTest.java (3.04414%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-68)<td><a href="#" name="0">(146-151)</a><td align="center"><font color="#ff0000">10</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(17-28)<td><a href="#" name="1">(15-26)</a><td align="center"><font color="#ff0000">10</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>MapContainsValueTester_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.collect.testing.testers;
2 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
3 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;
4 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUE_QUERIES;
5 import com.google.common.annotations.GwtCompatible;
6 import com.google.common.collect.testing.AbstractMapTester;
7 import com.google.common.collect.testing.WrongType;
8 import com.google.common.collect.testing.features.CollectionSize;
9 import com.google.common.collect.testing.features.MapFeature;
10 import</b></font> org.junit.Ignore;
11 @GwtCompatible
12 @Ignore public class MapContainsValueTester&lt;K, V&gt; extends AbstractMapTester&lt;K, V&gt; {
13   @CollectionSize.Require(absent = ZERO)
14   public void testContains_yes() {
15     assertTrue("containsValue(present) should return true", getMap().containsValue(v0()));
16   }
17   public void testContains_no() {
18     assertFalse("containsValue(notPresent) should return false", getMap().containsValue(v3()));
19   }
20   @MapFeature.Require(ALLOWS_NULL_VALUE_QUERIES)
21   public void testContains_nullNotContainedButAllowed() {
22     assertFalse("containsValue(null) should return false", getMap().containsValue(null));
23   }
24   @MapFeature.Require(absent = ALLOWS_NULL_VALUE_QUERIES)
25   public void testContains_nullNotContainedAndUnsupported() {
26     expectNullValueMissingWhenNullValuesUnsupported(
27         "containsValue(null) should return false or throw");
28   }
29 <a name="0"></a>  @MapFeature.Require(ALLOWS_NULL_VALUES)
30   @CollectionSize.Require(absent = ZERO)
31   public void testContains_nonNullWhenNullContained() {
32     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>initMapWithNullValue();
33     assertFalse("containsValue(notPresent) should return false", getMap().containsValue(v3()));
34   }
35   @MapFeature.Require(ALLOWS_NULL_VALUES)
36   @</b></font>CollectionSize.Require(absent = ZERO)
37   public void testContains_nullContained() {
38     initMapWithNullValue();
39     assertTrue("containsValue(null) should return true", getMap().containsValue(null));
40   }
41   public void testContains_wrongType() {
42     try {
43       assertFalse(
44           "containsValue(wrongType) should return false or throw",
45           getMap().containsValue(WrongType.VALUE));
46     } catch (ClassCastException tolerated) {
47     }
48   }
49 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ExecutionSequencerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright (C) 2018 The Guava Authors
3  *
4  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
5  * in compliance with the License. You may obtain a copy of the License at
6  *
7  * http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software distributed under the License
10  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
11  * or implied. See the License for the specific language governing permissions and limitations under
12 <a name="1"></a> * the License.
13  */
14 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.util.concurrent;
15 import static com.google.common.truth.Truth.assertThat;
16 import static com.google.common.util.concurrent.Futures.allAsList;
17 import static com.google.common.util.concurrent.Futures.getDone;
18 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
19 import static java.util.concurrent.TimeUnit.SECONDS;
20 import com.google.common.annotations.GwtIncompatible;
21 import com.google.common.base.Function;
22 import com.google.common.testing.GcFinalization;
23 import</b></font> com.google.common.testing.TestLogHandler;
24 import com.google.j2objc.annotations.J2ObjCIncompatible;
25 import java.lang.ref.WeakReference;
26 import java.util.ArrayList;
27 import java.util.List;
28 import java.util.concurrent.Callable;
29 import java.util.concurrent.CountDownLatch;
30 import java.util.concurrent.Executor;
31 import java.util.concurrent.ExecutorService;
32 import java.util.concurrent.Executors;
33 import java.util.concurrent.Future;
34 import java.util.concurrent.TimeUnit;
35 import java.util.logging.Logger;
36 import junit.framework.TestCase;
37 public class ExecutionSequencerTest extends TestCase {
38   ExecutorService executor;
39   private ExecutionSequencer serializer;
40   private SettableFuture&lt;Void&gt; firstFuture;
41   private TestCallable firstCallable;
42   @Override
43   public void setUp() throws Exception {
44     executor = Executors.newCachedThreadPool();
45     serializer = ExecutionSequencer.create();
46     firstFuture = SettableFuture.create();
47     firstCallable = new TestCallable(firstFuture);
48   }
49   @Override
50   public void tearDown() throws Exception {
51     executor.shutdown();
52   }
53   public void testCallableStartsAfterFirstFutureCompletes() {
54     @SuppressWarnings({"unused", "nullness"})
55     Future&lt;?&gt; possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
56     TestCallable secondCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
57     @SuppressWarnings({"unused", "nullness"})
58     Future&lt;?&gt; possiblyIgnoredError1 = serializer.submitAsync(secondCallable, directExecutor());
59     assertThat(firstCallable.called).isTrue();
60     assertThat(secondCallable.called).isFalse();
61     firstFuture.set(null);
62     assertThat(secondCallable.called).isTrue();
63   }
64   public void testCancellationDoesNotViolateSerialization() {
65     @SuppressWarnings({"unused", "nullness"})
66     Future&lt;?&gt; possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
67     TestCallable secondCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
68     ListenableFuture&lt;Void&gt; secondFuture = serializer.submitAsync(secondCallable, directExecutor());
69     TestCallable thirdCallable = new TestCallable(Futures.&lt;Void&gt;immediateFuture(null));
70     @SuppressWarnings({"unused", "nullness"})
71     Future&lt;?&gt; possiblyIgnoredError1 = serializer.submitAsync(thirdCallable, directExecutor());
72     secondFuture.cancel(true);
73     assertThat(secondCallable.called).isFalse();
74     assertThat(thirdCallable.called).isFalse();
75     firstFuture.set(null);
76     assertThat(secondCallable.called).isFalse();
77     assertThat(thirdCallable.called).isTrue();
78   }
79   public void testCancellationMultipleThreads() throws Exception {
80     final BlockingCallable blockingCallable = new BlockingCallable();
81     ListenableFuture&lt;Void&gt; unused = serializer.submit(blockingCallable, executor);
82     ListenableFuture&lt;Boolean&gt; future2 =
83         serializer.submit(
84             new Callable&lt;Boolean&gt;() {
85               @Override
86               public Boolean call() {
87                 return blockingCallable.isRunning();
88               }
89             },
90             directExecutor());
91     blockingCallable.waitForStart();
92     assertThat(future2.isDone()).isFalse();
93     blockingCallable.stop();
94     executor.shutdown();
95     assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
96     assertThat(getDone(future2)).isFalse();
97   }
98   public void testSecondTaskWaitsForFirstEvenIfCancelled() throws Exception {
99     final BlockingCallable blockingCallable = new BlockingCallable();
100     ListenableFuture&lt;Void&gt; future1 = serializer.submit(blockingCallable, executor);
101     ListenableFuture&lt;Boolean&gt; future2 =
102         serializer.submit(
103             new Callable&lt;Boolean&gt;() {
104               @Override
105               public Boolean call() {
106                 return blockingCallable.isRunning();
107               }
108             },
109             directExecutor());
110     blockingCallable.waitForStart();
111     future1.cancel(false);
112     assertThat(future2.isDone()).isFalse();
113 <a name="0"></a>        blockingCallable.stop();
114     executor.shutdown();
115     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
116     assertThat(getDone(future2)).isFalse();
117   }
118   @GwtIncompatible
119   @</b></font>J2ObjCIncompatible   @AndroidIncompatible
120   public void testCancellationWithReferencedObject() throws Exception {
121     Object toBeGCed = new Object();
122     WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(toBeGCed);
123     final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
124     ListenableFuture&lt;?&gt; ignored =
125         serializer.submitAsync(
126             new AsyncCallable&lt;Void&gt;() {
127               @Override
128               public ListenableFuture&lt;Void&gt; call() {
129                 return settableFuture;
130               }
131             },
132             directExecutor());
133     serializer.submit(toStringCallable(toBeGCed), directExecutor()).cancel(true);
134     toBeGCed = null;
135     GcFinalization.awaitClear(ref);
136   }
137   private static Callable&lt;String&gt; toStringCallable(final Object object) {
138     return new Callable&lt;String&gt;() {
139       @Override
140       public String call() {
141         return object.toString();
142       }
143     };
144   }
145   public void testCancellationDuringReentrancy() throws Exception {
146     TestLogHandler logHandler = new TestLogHandler();
147     Logger.getLogger(AbstractFuture.class.getName()).addHandler(logHandler);
148     List&lt;Future&lt;?&gt;&gt; results = new ArrayList&lt;&gt;();
149     final Runnable[] manualExecutorTask = new Runnable[1];
150     Executor manualExecutor =
151         new Executor() {
152           @Override
153           public void execute(Runnable task) {
154             manualExecutorTask[0] = task;
155           }
156         };
157     results.add(serializer.submit(Callables.returning(null), manualExecutor));
158     final Future&lt;?&gt;[] thingToCancel = new Future&lt;?&gt;[1];
159     results.add(
160         serializer.submit(
161             new Callable&lt;Void&gt;() {
162               @Override
163               public Void call() {
164                 thingToCancel[0].cancel(false);
165                 return null;
166               }
167             },
168             directExecutor()));
169     thingToCancel[0] = serializer.submit(Callables.returning(null), directExecutor());
170     results.add(thingToCancel[0]);
171     for (int i = 0; i &lt; 5; i++) {
172       results.add(serializer.submit(Callables.returning(null), directExecutor()));
173     }
174     manualExecutorTask[0].run();
175     for (Future&lt;?&gt; result : results) {
176       if (!result.isCancelled()) {
177         result.get(10, SECONDS);
178       }
179     }
180     assertThat(logHandler.getStoredLogRecords()).isEmpty();
181   }
182   public void testAvoidsStackOverflow_manySubmitted() throws Exception {
183     final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
184     ArrayList&lt;ListenableFuture&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;(50_001);
185     results.add(
186         serializer.submitAsync(
187             new AsyncCallable&lt;Void&gt;() {
188               @Override
189               public ListenableFuture&lt;Void&gt; call() {
190                 return settableFuture;
191               }
192             },
193             directExecutor()));
194     for (int i = 0; i &lt; 50_000; i++) {
195       results.add(serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()));
196     }
197     settableFuture.set(null);
198     getDone(allAsList(results));
199   }
200   public void testAvoidsStackOverflow_manyCancelled() throws Exception {
201     final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
202     ListenableFuture&lt;Void&gt; unused =
203         serializer.submitAsync(
204             new AsyncCallable&lt;Void&gt;() {
205               @Override
206               public ListenableFuture&lt;Void&gt; call() {
207                 return settableFuture;
208               }
209             },
210             directExecutor());
211     for (int i = 0; i &lt; 50_000; i++) {
212       serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()).cancel(true);
213     }
214     ListenableFuture&lt;Integer&gt; stackDepthCheck =
215         serializer.submit(
216             new Callable&lt;Integer&gt;() {
217               @Override
218               public Integer call() {
219                 return Thread.currentThread().getStackTrace().length;
220               }
221             },
222             directExecutor());
223     settableFuture.set(null);
224     assertThat(getDone(stackDepthCheck))
225         .isLessThan(Thread.currentThread().getStackTrace().length + 100);
226   }
227   public void testAvoidsStackOverflow_alternatingCancelledAndSubmitted() throws Exception {
228     final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
229     ListenableFuture&lt;Void&gt; unused =
230         serializer.submitAsync(
231             new AsyncCallable&lt;Void&gt;() {
232               @Override
233               public ListenableFuture&lt;Void&gt; call() {
234                 return settableFuture;
235               }
236             },
237             directExecutor());
238     for (int i = 0; i &lt; 25_000; i++) {
239       serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor()).cancel(true);
240       unused = serializer.submit(Callables.&lt;Void&gt;returning(null), directExecutor());
241     }
242     ListenableFuture&lt;Integer&gt; stackDepthCheck =
243         serializer.submit(
244             new Callable&lt;Integer&gt;() {
245               @Override
246               public Integer call() {
247                 return Thread.currentThread().getStackTrace().length;
248               }
249             },
250             directExecutor());
251     settableFuture.set(null);
252     assertThat(getDone(stackDepthCheck))
253         .isLessThan(Thread.currentThread().getStackTrace().length + 100);
254   }
255   private static Function&lt;Integer, Integer&gt; add(final int delta) {
256     return new Function&lt;Integer, Integer&gt;() {
257       @Override
258       public Integer apply(Integer input) {
259         return input + delta;
260       }
261     };
262   }
263   private static AsyncCallable&lt;Integer&gt; asyncAdd(
264       final ListenableFuture&lt;Integer&gt; future, final int delta, final Executor executor) {
265     return new AsyncCallable&lt;Integer&gt;() {
266       @Override
267       public ListenableFuture&lt;Integer&gt; call() throws Exception {
268         return Futures.transform(future, add(delta), executor);
269       }
270     };
271   }
272   private static final class LongHolder {
273     long count;
274   }
275   private static final int ITERATION_COUNT = 50_000;
276   private static final int DIRECT_EXECUTIONS_PER_THREAD = 100;
277   @GwtIncompatible   public void testAvoidsStackOverflow_multipleThreads() throws Exception {
278     final LongHolder holder = new LongHolder();
279     final ArrayList&lt;ListenableFuture&lt;Integer&gt;&gt; lengthChecks = new ArrayList&lt;&gt;();
280     final List&lt;Integer&gt; completeLengthChecks;
281     final int baseStackDepth;
282     ExecutorService service = Executors.newFixedThreadPool(5);
283     try {
284       baseStackDepth =
285           serializer
286               .submit(
287                   new Callable&lt;Integer&gt;() {
288                     @Override
289                     public Integer call() {
290                       return Thread.currentThread().getStackTrace().length;
291                     }
292                   },
293                   service)
294               .get();
295       final SettableFuture&lt;Void&gt; settableFuture = SettableFuture.create();
296       ListenableFuture&lt;?&gt; unused =
297           serializer.submitAsync(
298               new AsyncCallable&lt;Void&gt;() {
299                 @Override
300                 public ListenableFuture&lt;Void&gt; call() {
301                   return settableFuture;
302                 }
303               },
304               directExecutor());
305       for (int i = 0; i &lt; 50_000; i++) {
306         if (i % DIRECT_EXECUTIONS_PER_THREAD == 0) {
307           unused =
308               serializer.submit(
309                   new Callable&lt;Void&gt;() {
310                     @Override
311                     public Void call() {
312                       holder.count++;
313                       return null;
314                     }
315                   },
316                   service);
317         } else if (i % DIRECT_EXECUTIONS_PER_THREAD == DIRECT_EXECUTIONS_PER_THREAD - 1) {
318           lengthChecks.add(
319               serializer.submit(
320                   new Callable&lt;Integer&gt;() {
321                     @Override
322                     public Integer call() {
323                       holder.count++;
324                       return Thread.currentThread().getStackTrace().length;
325                     }
326                   },
327                   directExecutor()));
328         } else {
329           unused =
330               serializer.submit(
331                   new Callable&lt;Void&gt;() {
332                     @Override
333                     public Void call() {
334                       holder.count++;
335                       return null;
336                     }
337                   },
338                   directExecutor());
339         }
340       }
341       settableFuture.set(null);
342       completeLengthChecks = allAsList(lengthChecks).get();
343     } finally {
344       service.shutdown();
345     }
346     assertThat(holder.count).isEqualTo(ITERATION_COUNT);
347     for (int length : completeLengthChecks) {
348       assertThat(length - baseStackDepth).isLessThan(DIRECT_EXECUTIONS_PER_THREAD / 2);
349     }
350   }
351   @SuppressWarnings("ObjectToString")   public void testToString() {
352     Future&lt;?&gt; unused = serializer.submitAsync(firstCallable, directExecutor());
353     TestCallable secondCallable = new TestCallable(SettableFuture.&lt;Void&gt;create());
354     Future&lt;?&gt; second = serializer.submitAsync(secondCallable, directExecutor());
355     assertThat(secondCallable.called).isFalse();
356     assertThat(second.toString()).contains(secondCallable.toString());
357     firstFuture.set(null);
358     assertThat(second.toString()).contains(secondCallable.future.toString());
359   }
360   private static class BlockingCallable implements Callable&lt;Void&gt; {
361     private final CountDownLatch startLatch = new CountDownLatch(1);
362     private final CountDownLatch stopLatch = new CountDownLatch(1);
363     private volatile boolean running = false;
364     @Override
365     public Void call() throws InterruptedException {
366       running = true;
367       startLatch.countDown();
368       stopLatch.await();
369       running = false;
370       return null;
371     }
372     public void waitForStart() throws InterruptedException {
373       startLatch.await();
374     }
375     public void stop() {
376       stopLatch.countDown();
377     }
378     public boolean isRunning() {
379       return running;
380     }
381   }
382   private static final class TestCallable implements AsyncCallable&lt;Void&gt; {
383     private final ListenableFuture&lt;Void&gt; future;
384     private boolean called = false;
385     private TestCallable(ListenableFuture&lt;Void&gt; future) {
386       this.future = future;
387     }
388     @Override
389     public ListenableFuture&lt;Void&gt; call() throws Exception {
390       called = true;
391       return future;
392     }
393   }
394 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
