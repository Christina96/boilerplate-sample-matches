<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ColumnsIterableTest.java & AlterTableReroutePlan.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ColumnsIterableTest.java & AlterTableReroutePlan.java
      </h3>
      <h1 align="center">
        17.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ColumnsIterableTest.java (28.571428%)<TH>AlterTableReroutePlan.java (12.969283%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match821785-0.html#0',2,'match821785-1.html#0',3)" NAME="0">(24-45)<TD><A HREF="javascript:ZweiFrames('match821785-0.html#0',2,'match821785-1.html#0',3)" NAME="0">(46-67)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match821785-0.html#1',2,'match821785-1.html#1',3)" NAME="1">(85-90)<TD><A HREF="javascript:ZweiFrames('match821785-0.html#1',2,'match821785-1.html#1',3)" NAME="1">(85-97)</A><TD ALIGN=center><FONT COLOR="#9b0000">11</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match821785-0.html#2',2,'match821785-1.html#2',3)" NAME="2">(93-97)<TD><A HREF="javascript:ZweiFrames('match821785-0.html#2',2,'match821785-1.html#2',3)" NAME="2">(156-163)</A><TD ALIGN=center><FONT COLOR="#7f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ColumnsIterableTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */
<A NAME="0"></A>
package io.crate.execution.engine.collect.sources;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match821785-1.html#0',3,'match821785-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.crate.expression.reference.information.ColumnContext;
import io.crate.metadata.RelationInfo;
import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
import io.crate.testing.SQLExecutor;
import org.hamcrest.Matchers;
import org.junit.Before;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import static io.crate.testing.T3.T1;
import static io.crate.testing.T3.T1_DEFINITION;
import static io.crate.testing.T3.T4;
import static io.crate.testing.T3.T4_DEFINITION;
import static org.hamcrest.Matchers.is;

public class ColumnsIterableTest extends CrateDummyClusterServiceUnitTest {

    private RelationInfo t1Info</B></FONT>;
    private RelationInfo t4Info;

    @Before
    public void prepare() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable(T1_DEFINITION)
            .addTable(T4_DEFINITION)
            .build();
        t1Info = e.resolveTableInfo(T1.fqn());
        t4Info = e.resolveTableInfo(T4.fqn());
    }

    @Test
    public void testColumnsIteratorCanBeMaterializedToList() {
        InformationSchemaIterables.ColumnsIterable columns = new InformationSchemaIterables.ColumnsIterable(t1Info);
        List&lt;ColumnContext&gt; contexts = StreamSupport.stream(columns.spliterator(), false)
            .collect(Collectors.toList());

        assertThat(
            contexts.stream().map(c -&gt; c.info.column().name()).collect(Collectors.toList()),
            Matchers.contains(&quot;a&quot;, &quot;x&quot;, &quot;i&quot;));
    }

    @Test
    public void testColumnsIterableCanBeConsumedTwice() {
        List&lt;String&gt; names = new ArrayList&lt;&gt;(6);
        InformationSchemaIterables.ColumnsIterable columns = new InformationSchemaIterables.ColumnsIterable(t1Info);
        for (ColumnContext column : columns) {
            names.add(column.info.column().name());
        }
        for (ColumnContext column : columns) {
            names.add(column.info.column().name());
        }
        assertThat(names, Matchers.contains(&quot;a&quot;, &quot;x&quot;, &quot;i&quot;, &quot;a&quot;, &quot;x&quot;, &quot;i&quot;));
    }

<A NAME="1"></A>    @Test
    public void testOrdinalIsNotNullOnSubColumns() throws Exception {
        InformationSchemaIterables.ColumnsIterable columns = new InformationSchemaIterables.ColumnsIterable(t4Info);
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match821785-1.html#1',3,'match821785-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>List&lt;ColumnContext&gt; contexts = StreamSupport.stream(columns.spliterator(), false)
            .collect(Collectors.toList());

        // sub columns must have NON-NULL ordinal value
        assertThat(contexts.get(1).info.position(), is(2));
<A NAME="2"></A>        assertThat(contexts.get(2).info.position</B></FONT>(), is(3));

        // array of object sub columns also
        assertThat(contexts.get(3).info.position(), <FONT color="#980517"><A HREF="javascript:ZweiFrames('match821785-1.html#2',3,'match821785-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>is(4));
        assertThat(contexts.get(4).info.position(), is(5));
    }

    @</B></FONT>Test
    public void test_bit_type_has_character_maximum_length_set() throws Exception {
        SQLExecutor e = SQLExecutor.builder(clusterService)
            .addTable(&quot;create table bit_table (xs bit(12))&quot;)
            .build();
        var columns = new InformationSchemaIterables.ColumnsIterable(e.resolveTableInfo(&quot;bit_table&quot;));
        var contexts = StreamSupport.stream(columns.spliterator(), false).toList();

        assertThat(contexts.get(0).characterMaximumLength(), is(12));
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>AlterTableReroutePlan.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
 * software solely pursuant to the terms of the relevant commercial agreement.
 */

package io.crate.planner.node.management;

import io.crate.analyze.AnalyzedPromoteReplica;
import io.crate.analyze.AnalyzedRerouteAllocateReplicaShard;
import io.crate.analyze.AnalyzedRerouteCancelShard;
import io.crate.analyze.AnalyzedRerouteMoveShard;
import io.crate.analyze.AnalyzedStatement;
import io.crate.analyze.AnalyzedStatementVisitor;
import io.crate.analyze.PartitionPropertiesAnalyzer;
import io.crate.analyze.SymbolEvaluator;
import io.crate.common.annotations.VisibleForTesting;
import io.crate.common.collections.Lists2;
import io.crate.data.Row;
import io.crate.data.Row1;
import io.crate.data.RowConsumer;
import io.crate.execution.support.OneRowActionListener;
import io.crate.expression.symbol.Symbol;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.NodeContext;
import io.crate.metadata.PartitionName;
import io.crate.metadata.doc.DocTableInfo;
<A NAME="0"></A>import io.crate.metadata.table.ShardedTable;
import io.crate.planner.DependencyCarrier;
import io.crate.planner.Plan;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match821785-0.html#0',2,'match821785-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import io.crate.planner.PlannerContext;
import io.crate.planner.operators.SubQueryResults;
import io.crate.sql.tree.Assignment;
import io.crate.sql.tree.GenericProperties;
import io.crate.types.DataTypes;
import org.elasticsearch.action.admin.cluster.reroute.ClusterRerouteRequest;
import org.elasticsearch.cluster.node.DiscoveryNodes;
import org.elasticsearch.cluster.routing.allocation.command.AllocateReplicaAllocationCommand;
import org.elasticsearch.cluster.routing.allocation.command.AllocateStalePrimaryAllocationCommand;
import org.elasticsearch.cluster.routing.allocation.command.AllocationCommand;
import org.elasticsearch.cluster.routing.allocation.command.CancelAllocationCommand;
import org.elasticsearch.cluster.routing.allocation.command.MoveAllocationCommand;

import java.util.List;
import java.util.Locale;
import java.util.function.Function;

import static io.crate.planner.NodeSelection.resolveNodeId;

public class AlterTableReroutePlan implements Plan {

    private static final InnerVisitor REROUTE_STATEMENTS_VISITOR = new InnerVisitor()</B></FONT>;
    private final AnalyzedStatement rerouteStatement;

    public AlterTableReroutePlan(AnalyzedStatement rerouteStatement) {
        this.rerouteStatement = rerouteStatement;
    }

    @Override
    public StatementType type() {
        return StatementType.MANAGEMENT;
    }

    @Override
    public void executeOrFail(DependencyCarrier dependencies,
                              PlannerContext plannerContext,
<A NAME="1"></A>                              RowConsumer consumer,
                              Row params,
                              SubQueryResults subQueryResults) {
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match821785-0.html#1',2,'match821785-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>var rerouteCommand = createRerouteCommand(
            rerouteStatement,
            plannerContext.transactionContext(),
            dependencies.nodeContext(),
            params,
            subQueryResults,
            dependencies.clusterService().state().nodes());

        dependencies
            .transportActionProvider()
            .transportClusterRerouteAction()
            .execute(
                new ClusterRerouteRequest().add</B></FONT>(rerouteCommand),
                new OneRowActionListener&lt;&gt;(
                    consumer, r -&gt; new Row1(r == null ? -1L : 1L)));
    }

    @VisibleForTesting
    public static AllocationCommand createRerouteCommand(AnalyzedStatement reroute,
                                                         CoordinatorTxnCtx txnCtx,
                                                         NodeContext nodeCtx,
                                                         Row parameters,
                                                         SubQueryResults subQueryResults,
                                                         DiscoveryNodes nodes) {
        Function&lt;? super Symbol, Object&gt; eval = x -&gt; SymbolEvaluator.evaluate(
            txnCtx,
            nodeCtx,
            x,
            parameters,
            subQueryResults
        );

        return reroute.accept(
            REROUTE_STATEMENTS_VISITOR,
            new Context(nodes, eval));
    }

    private static class Context {

        private final DiscoveryNodes nodes;
        private final Function&lt;? super Symbol, Object&gt; eval;

        Context(DiscoveryNodes nodes,
                Function&lt;? super Symbol, Object&gt; eval) {
            this.nodes = nodes;
            this.eval = eval;
        }
    }

    private static class InnerVisitor extends AnalyzedStatementVisitor&lt;Context, AllocationCommand&gt; {

        @Override
        protected AllocationCommand visitAnalyzedStatement(AnalyzedStatement analyzedStatement, Context context) {
            throw new UnsupportedOperationException(
                String.format(Locale.ENGLISH, &quot;Can't handle \&quot;%s\&quot;&quot;, analyzedStatement));
        }

        @Override
        public AllocationCommand visitReroutePromoteReplica(AnalyzedPromoteReplica statement,
                                                            Context context) {
            var boundedPromoteReplica = statement.promoteReplica().map(context.eval);

            String index = getRerouteIndex(
                statement.shardedTable(),
                Lists2.map(statement.partitionProperties(), x -&gt; x.map(context.eval)));
            String toNodeId = resolveNodeId(
                context.nodes,
                DataTypes.STRING.sanitizeValue(boundedPromoteReplica.node()));
<A NAME="2"></A>
            return new AllocateStalePrimaryAllocationCommand(
                index,
                <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match821785-0.html#2',2,'match821785-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>DataTypes.INTEGER.sanitizeValue(boundedPromoteReplica.shardId()),
                toNodeId,
                DataTypes.BOOLEAN.sanitizeValue(context.eval.apply(statement.acceptDataLoss()))
            );

        }

        @</B></FONT>Override
        protected AllocationCommand visitRerouteMoveShard(AnalyzedRerouteMoveShard statement,
                                                          Context context) {
            var boundedMoveShard = statement.rerouteMoveShard().map(context.eval);

            String index = getRerouteIndex(
                statement.shardedTable(),
                Lists2.map(statement.partitionProperties(), x -&gt; x.map(context.eval)));
            String toNodeId = resolveNodeId(
                context.nodes,
                DataTypes.STRING.sanitizeValue(boundedMoveShard.toNodeIdOrName()));

            return new MoveAllocationCommand(
                index,
                DataTypes.INTEGER.sanitizeValue(boundedMoveShard.shardId()),
                DataTypes.STRING.sanitizeValue(boundedMoveShard.fromNodeIdOrName()),
                toNodeId
            );
        }

        @Override
        protected AllocationCommand visitRerouteAllocateReplicaShard(AnalyzedRerouteAllocateReplicaShard statement,
                                                                     Context context) {
            var boundedRerouteAllocateReplicaShard = statement
                .rerouteAllocateReplicaShard()
                .map(context.eval);

            String index = getRerouteIndex(
                statement.shardedTable(),
                Lists2.map(statement.partitionProperties(), x -&gt; x.map(context.eval)));
            String toNodeId = resolveNodeId(
                context.nodes,
                DataTypes.STRING.sanitizeValue(boundedRerouteAllocateReplicaShard.nodeIdOrName()));

            return new AllocateReplicaAllocationCommand(
                index,
                DataTypes.INTEGER.sanitizeValue(boundedRerouteAllocateReplicaShard.shardId()),
                toNodeId
            );
        }

        @Override
        protected AllocationCommand visitRerouteCancelShard(AnalyzedRerouteCancelShard statement,
                                                            Context context) {
            var boundedRerouteCancelShard = statement
                .rerouteCancelShard()
                .map(context.eval);

            boolean allowPrimary = validateCancelRerouteProperty(
                &quot;allow_primary&quot;, boundedRerouteCancelShard.properties());

            String index = getRerouteIndex(
                statement.shardedTable(),
                Lists2.map(statement.partitionProperties(), x -&gt; x.map(context.eval)));
            String nodeId = resolveNodeId(
                context.nodes,
                DataTypes.STRING.sanitizeValue(boundedRerouteCancelShard.nodeIdOrName()));

            return new CancelAllocationCommand(
                index,
                DataTypes.INTEGER.sanitizeValue(boundedRerouteCancelShard.shardId()),
                nodeId,
                allowPrimary
            );
        }

        private static String getRerouteIndex(ShardedTable shardedTable,
                                              List&lt;Assignment&lt;Object&gt;&gt; partitionsProperties) {
            if (shardedTable instanceof DocTableInfo) {
                DocTableInfo docTableInfo = (DocTableInfo) shardedTable;

                String indexName = docTableInfo.ident().indexNameOrAlias();
                PartitionName partitionName = PartitionPropertiesAnalyzer
                    .createPartitionName(partitionsProperties, docTableInfo);
                if (partitionName != null) {
                    indexName = partitionName.asIndexName();
                } else if (docTableInfo.isPartitioned()) {
                    throw new IllegalArgumentException(
                        &quot;table is partitioned however no partition clause has been specified&quot;);
                }

                return indexName;
            }

            // Table is a blob table
            assert shardedTable.concreteIndices().length == 1 : &quot;table has to contain only 1 index name&quot;;
            return shardedTable.concreteIndices()[0];
        }

        private static boolean validateCancelRerouteProperty(String propertyKey,
                                                             GenericProperties&lt;Object&gt; properties) {
            for (String key : properties.keys()) {
                if (propertyKey.equals(key)) {
                    return DataTypes.BOOLEAN.sanitizeValue(properties.get(propertyKey));
                } else {
                    throw new IllegalArgumentException(
                        String.format(Locale.ENGLISH, &quot;\&quot;%s\&quot; is not a valid setting for CANCEL SHARD&quot;, key));
                }
            }
            return false;
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
