
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.120906801007557%, Tokens: 12</h2>
        <div class="column">
            <h3>Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-Commandspawn.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.earth2me.essentials.spawn;
2  import com.earth2me.essentials.CommandSource;
3  import static com.earth2me.essentials.I18n.tl;
4  import com.earth2me.essentials.Console;
5  import com.earth2me.essentials.Trade;
6  import com.earth2me.essentials.User;
7  import com.earth2me.essentials.commands.EssentialsCommand;
8  import com.earth2me.essentials.commands.NoChargeException;
9  import com.earth2me.essentials.commands.NotEnoughArgumentsException;
10  import org.bukkit.Location;
11  import org.bukkit.Server;
12  import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
</span>13  public class Commandspawn extends EssentialsCommand
14  {
15  	public Commandspawn()
16  	{
17  		super("spawn");
18  	}
19  	@Override
20  	public void run(final Server server, final User user, final String commandLabel, final String[] args) throws Exception
21  	{
22  		final Trade charge = new Trade(this.getName(), ess);
23  		charge.isAffordableFor(user);
24  		if (args.length > 0 && user.isAuthorized("essentials.spawn.others"))
25  		{
26  			final User otherUser = getPlayer(server, user, args, 0);
27  			respawn(user.getSource(), user, otherUser, charge);
28  			if (!otherUser.equals(user))
29  			{
30  				otherUser.sendMessage(tl("teleportAtoB", user.getDisplayName(), "spawn"));
31  			}
32  		}
33  		else
34  		{
35  			respawn(user.getSource(), user, user, charge);
36  		}
37  		throw new NoChargeException();
38  	}
39  	@Override
40  	protected void run(final Server server, final CommandSource sender, final String commandLabel, final String[] args) throws Exception
41  	{
42  		if (args.length < 1)
43  		{
44  			throw new NotEnoughArgumentsException();
45  		}
46  		final User user = getPlayer(server, args, 0, true, false);
47  		respawn(sender, null, user, null);
48  		user.sendMessage(tl("teleportAtoB", Console.NAME, "spawn"));
49  	}
50  	private void respawn(final CommandSource sender, final User teleportOwner, final User teleportee, final Trade charge) throws Exception
51  	{
52  		final SpawnStorage spawns = (SpawnStorage)this.module;
53  		final Location spawn = spawns.getSpawn(teleportee.getGroup());
54  		sender.sendMessage(tl("teleporting", spawn.getWorld().getName(), spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()));
55  		if (teleportOwner == null)
56  		{
57  			teleportee.getTeleport().now(spawn, false, TeleportCause.COMMAND);
58  		}
59  		else
60  		{
61  			teleportOwner.getTeleport().teleportPlayer(teleportee, spawn, charge, TeleportCause.COMMAND);
62  		}
63  	}
64  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-MultiClusterPooledConnectionProvider.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package redis.clients.jedis.providers;
2  import io.github.resilience4j.circuitbreaker.CircuitBreaker;
3  import io.github.resilience4j.circuitbreaker.CircuitBreaker.State;
4  import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
5  import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
6  import io.github.resilience4j.core.IntervalFunction;
7  import io.github.resilience4j.retry.Retry;
8  import io.github.resilience4j.retry.RetryConfig;
9  import io.github.resilience4j.retry.RetryRegistry;
10  import org.slf4j.Logger;
11  import org.slf4j.LoggerFactory;
12  import redis.clients.jedis.*;
</span>13  import redis.clients.jedis.MultiClusterClientConfig.ClusterConfig;
14  import redis.clients.jedis.exceptions.JedisConnectionException;
15  import redis.clients.jedis.exceptions.JedisValidationException;
16  import redis.clients.jedis.util.Pool;
17  import java.util.*;
18  import java.util.concurrent.ConcurrentHashMap;
19  import java.util.function.Consumer;
20  public class MultiClusterPooledConnectionProvider implements ConnectionProvider {
21      private final Logger log = LoggerFactory.getLogger(getClass());
22      private final Map<Integer, Cluster> multiClusterMap = new ConcurrentHashMap<>();
23      private volatile Integer activeMultiClusterIndex = 1;
24      private volatile boolean lastClusterCircuitBreakerForcedOpen = false;
25      private Consumer<String> clusterFailoverPostProcessor;
26      public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) {
27          if (multiClusterClientConfig == null)
28              throw new JedisValidationException("MultiClusterClientConfig must not be NULL for MultiClusterPooledConnectionProvider");
29          RetryConfig.Builder retryConfigBuilder = RetryConfig.custom();
30          retryConfigBuilder.maxAttempts(multiClusterClientConfig.getRetryMaxAttempts());
31          retryConfigBuilder.intervalFunction(IntervalFunction.ofExponentialBackoff(multiClusterClientConfig.getRetryWaitDuration(),
32                  multiClusterClientConfig.getRetryWaitDurationExponentialBackoffMultiplier()));
33          retryConfigBuilder.failAfterMaxAttempts(false); 
34          retryConfigBuilder.retryExceptions(multiClusterClientConfig.getRetryIncludedExceptionList().stream().toArray(Class[]::new));
35          List<Class> retryIgnoreExceptionList = multiClusterClientConfig.getRetryIgnoreExceptionList();
36          if (retryIgnoreExceptionList != null && !retryIgnoreExceptionList.isEmpty())
37              retryConfigBuilder.ignoreExceptions(retryIgnoreExceptionList.stream().toArray(Class[]::new));
38          RetryConfig retryConfig = retryConfigBuilder.build();
39          CircuitBreakerConfig.Builder circuitBreakerConfigBuilder = CircuitBreakerConfig.custom();
40          circuitBreakerConfigBuilder.failureRateThreshold(multiClusterClientConfig.getCircuitBreakerFailureRateThreshold());
41          circuitBreakerConfigBuilder.slowCallRateThreshold(multiClusterClientConfig.getCircuitBreakerSlowCallRateThreshold());
42          circuitBreakerConfigBuilder.slowCallDurationThreshold(multiClusterClientConfig.getCircuitBreakerSlowCallDurationThreshold());
43          circuitBreakerConfigBuilder.minimumNumberOfCalls(multiClusterClientConfig.getCircuitBreakerSlidingWindowMinCalls());
44          circuitBreakerConfigBuilder.slidingWindowType(multiClusterClientConfig.getCircuitBreakerSlidingWindowType());
45          circuitBreakerConfigBuilder.slidingWindowSize(multiClusterClientConfig.getCircuitBreakerSlidingWindowSize());
46          circuitBreakerConfigBuilder.recordExceptions(multiClusterClientConfig.getCircuitBreakerIncludedExceptionList().stream().toArray(Class[]::new));
47          circuitBreakerConfigBuilder.automaticTransitionFromOpenToHalfOpenEnabled(false); 
48          List<Class> circuitBreakerIgnoreExceptionList = multiClusterClientConfig.getCircuitBreakerIgnoreExceptionList();
49          if (circuitBreakerIgnoreExceptionList != null && !circuitBreakerIgnoreExceptionList.isEmpty())
50              circuitBreakerConfigBuilder.ignoreExceptions(circuitBreakerIgnoreExceptionList.stream().toArray(Class[]::new));
51          CircuitBreakerConfig circuitBreakerConfig = circuitBreakerConfigBuilder.build();
52          ClusterConfig[] clusterConfigs = multiClusterClientConfig.getClusterConfigs();
53          for (ClusterConfig config : clusterConfigs) {
54              String clusterId = "cluster:" + config.getPriority() + ":" + config.getHostAndPort();
55              Retry retry = RetryRegistry.of(retryConfig).retry(clusterId);
56              Retry.EventPublisher retryPublisher = retry.getEventPublisher();
57              retryPublisher.onRetry(event -> log.warn(String.valueOf(event)));
58              retryPublisher.onError(event -> log.error(String.valueOf(event)));
59              CircuitBreaker circuitBreaker = CircuitBreakerRegistry.of(circuitBreakerConfig).circuitBreaker(clusterId);
60              CircuitBreaker.EventPublisher circuitBreakerEventPublisher = circuitBreaker.getEventPublisher();
61              circuitBreakerEventPublisher.onCallNotPermitted(event -> log.error(String.valueOf(event)));
62              circuitBreakerEventPublisher.onError(event -> log.error(String.valueOf(event)));
63              circuitBreakerEventPublisher.onFailureRateExceeded(event -> log.error(String.valueOf(event)));
64              circuitBreakerEventPublisher.onSlowCallRateExceeded(event -> log.error(String.valueOf(event)));
65              circuitBreakerEventPublisher.onStateTransition(event -> log.warn(String.valueOf(event)));
66              multiClusterMap.put(config.getPriority(), new Cluster(new ConnectionPool(config.getHostAndPort(),
67                                                                                       config.getJedisClientConfig()),
68                                                                                       retry, circuitBreaker));
69          }
70      }
71      public int incrementActiveMultiClusterIndex() {
72          synchronized (activeMultiClusterIndex) {
73              String originalClusterName = getClusterCircuitBreaker().getName();
74              if (activeMultiClusterIndex + 1 > multiClusterMap.size()) {
75                  lastClusterCircuitBreakerForcedOpen = true;
76                  throw new JedisConnectionException("Cluster/database endpoint could not failover since the MultiClusterClientConfig was not " +
77                                                     "provided with an additional cluster/database endpoint according to its prioritized sequence. " +
78                                                     "If applicable, consider failing back OR restarting with an available cluster/database endpoint");
79              }
80              else activeMultiClusterIndex++;
81              CircuitBreaker circuitBreaker = getClusterCircuitBreaker();
82              if (CircuitBreaker.State.FORCED_OPEN.equals(circuitBreaker.getState()))
83                  incrementActiveMultiClusterIndex();
84              else log.warn("Cluster/database endpoint successfully updated from '{}' to '{}'", originalClusterName, circuitBreaker.getName());
85          }
86          return activeMultiClusterIndex;
87      }
88      public void validateTargetConnection(int multiClusterIndex) {
89          CircuitBreaker circuitBreaker = getClusterCircuitBreaker(multiClusterIndex);
90          State originalState = circuitBreaker.getState();
91          try {
92              circuitBreaker.transitionToClosedState();
93              try (Connection targetConnection = getConnection(multiClusterIndex)) {
94                  targetConnection.ping();
95              }
96          }
97          catch (Exception e) {
98              if (CircuitBreaker.State.FORCED_OPEN.equals(originalState))
99                  circuitBreaker.transitionToForcedOpenState();
100              throw new JedisValidationException(circuitBreaker.getName() + " failed to connect. Please check configuration and try again.", e);
101          }
102      }
103      public synchronized void setActiveMultiClusterIndex(int multiClusterIndex) {
104          synchronized (activeMultiClusterIndex) {
105              if (activeMultiClusterIndex == multiClusterIndex &&
106                  !CircuitBreaker.State.FORCED_OPEN.equals(getClusterCircuitBreaker(multiClusterIndex).getState()))
107                      return;
108              if (multiClusterIndex < 1 || multiClusterIndex > multiClusterMap.size())
109                  throw new JedisValidationException("MultiClusterIndex: " + multiClusterIndex + " is not within " +
110                            "the configured range. Please choose an index between 1 and " + multiClusterMap.size());
111              validateTargetConnection(multiClusterIndex);
112              String originalClusterName = getClusterCircuitBreaker().getName();
113              if (activeMultiClusterIndex == multiClusterIndex)
114                  log.warn("Cluster/database endpoint '{}' successfully closed its circuit breaker", originalClusterName);
115              else
116                  log.warn("Cluster/database endpoint successfully updated from '{}' to '{}'",
117                           originalClusterName, getClusterCircuitBreaker(multiClusterIndex).getName());
118              activeMultiClusterIndex = multiClusterIndex;
119              lastClusterCircuitBreakerForcedOpen = false;
120          }
121      }
122      @Override
123      public void close() {
124          multiClusterMap.get(activeMultiClusterIndex).getConnectionPool().close();
125      }
126      @Override
127      public Connection getConnection() {
128          return multiClusterMap.get(activeMultiClusterIndex).getConnection();
129      }
130      public Connection getConnection(int multiClusterIndex) {
131          return multiClusterMap.get(multiClusterIndex).getConnection();
132      }
133      @Override
134      public Connection getConnection(CommandArguments args) {
135          return multiClusterMap.get(activeMultiClusterIndex).getConnection();
136      }
137      @Override
138      public Map<?, Pool<Connection>> getConnectionMap() {
139          ConnectionPool connectionPool = multiClusterMap.get(activeMultiClusterIndex).getConnectionPool();
140          return Collections.singletonMap(connectionPool.getFactory(), connectionPool);
141      }
142      public Cluster getCluster() {
143          return multiClusterMap.get(activeMultiClusterIndex);
144      }
145      public CircuitBreaker getClusterCircuitBreaker() {
146          return multiClusterMap.get(activeMultiClusterIndex).getCircuitBreaker();
147      }
148      public CircuitBreaker getClusterCircuitBreaker(int multiClusterIndex) {
149          return multiClusterMap.get(multiClusterIndex).getCircuitBreaker();
150      }
151      public boolean isLastClusterCircuitBreakerForcedOpen() {
152          return lastClusterCircuitBreakerForcedOpen;
153      }
154      public void runClusterFailoverPostProcessor(Integer multiClusterIndex) {
155          if (clusterFailoverPostProcessor != null)
156              clusterFailoverPostProcessor.accept(getClusterCircuitBreaker(multiClusterIndex).getName());
157      }
158      public void setClusterFailoverPostProcessor(Consumer<String> clusterFailoverPostProcessor) {
159          this.clusterFailoverPostProcessor = clusterFailoverPostProcessor;
160      }
161      public static class Cluster {
162          private final ConnectionPool connectionPool;
163          private final Retry retry;
164          private final CircuitBreaker circuitBreaker;
165          public Cluster(ConnectionPool connectionPool, Retry retry, CircuitBreaker circuitBreaker) {
166              this.connectionPool = connectionPool;
167              this.retry = retry;
168              this.circuitBreaker = circuitBreaker;
169          }
170          public Connection getConnection() {
171              return connectionPool.getResource();
172          }
173          public ConnectionPool getConnectionPool() {
174              return connectionPool;
175          }
176          public Retry getRetry() {
177              return retry;
178          }
179          public CircuitBreaker getCircuitBreaker() {
180              return circuitBreaker;
181          }
182      }
183  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Essentials-MDEwOlJlcG9zaXRvcnkxNzczNzU0-flat-Commandspawn.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-MultiClusterPooledConnectionProvider.java</div>
                </div>
                <div class="column column_space"><pre><code>1  package com.earth2me.essentials.spawn;
2  import com.earth2me.essentials.CommandSource;
3  import static com.earth2me.essentials.I18n.tl;
4  import com.earth2me.essentials.Console;
5  import com.earth2me.essentials.Trade;
6  import com.earth2me.essentials.User;
7  import com.earth2me.essentials.commands.EssentialsCommand;
8  import com.earth2me.essentials.commands.NoChargeException;
9  import com.earth2me.essentials.commands.NotEnoughArgumentsException;
10  import org.bukkit.Location;
11  import org.bukkit.Server;
12  import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package redis.clients.jedis.providers;
2  import io.github.resilience4j.circuitbreaker.CircuitBreaker;
3  import io.github.resilience4j.circuitbreaker.CircuitBreaker.State;
4  import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
5  import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
6  import io.github.resilience4j.core.IntervalFunction;
7  import io.github.resilience4j.retry.Retry;
8  import io.github.resilience4j.retry.RetryConfig;
9  import io.github.resilience4j.retry.RetryRegistry;
10  import org.slf4j.Logger;
11  import org.slf4j.LoggerFactory;
12  import redis.clients.jedis.*;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    