<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for WebSocketServerExtensionHandlerTest.java &amp; Http2MultiplexTransportTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for WebSocketServerExtensionHandlerTest.java &amp; Http2MultiplexTransportTest.java
      </h3>
<h1 align="center">
        12.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>WebSocketServerExtensionHandlerTest.java (24.545454%)<th>Http2MultiplexTransportTest.java (8.681672%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(18-40)<td><a href="#" name="0">(53-73)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(98-104)<td><a href="#" name="1">(192-205)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(82-88)<td><a href="#" name="2">(364-365)</a><td align="center"><font color="#9b0000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(59-64)<td><a href="#" name="3">(319-320)</a><td align="center"><font color="#9b0000">11</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(207-212)<td><a href="#" name="4">(389-392)</a><td align="center"><font color="#8d0000">10</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(114-120)<td><a href="#" name="5">(357-359)</a><td align="center"><font color="#8d0000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(123-126)<td><a href="#" name="6">(544-546)</a><td align="center"><font color="#7f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WebSocketServerExtensionHandlerTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.handler.codec.http.websocketx.extensions;
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.netty.channel.ChannelPromise;
3 import io.netty.channel.embedded.EmbeddedChannel;
4 import io.netty.handler.codec.http.HttpHeaderNames;
5 import io.netty.handler.codec.http.HttpRequest;
6 import io.netty.handler.codec.http.HttpResponse;
7 import java.io.IOException;
8 import java.util.Collections;
9 import java.util.List;
10 import org.junit.jupiter.api.Test;
11 import static io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionTestUtil.*;
12 import static org.junit.jupiter.api.Assertions.assertEquals;
13 import static org.junit.jupiter.api.Assertions.assertFalse;
14 import static org.junit.jupiter.api.Assertions.assertNotNull;
15 import static org.junit.jupiter.api.Assertions.assertNull;
16 import static org.junit.jupiter.api.Assertions.assertTrue;
17 import static org.mockito.Mockito.*;
18 public class WebSocketServerExtensionHandlerTest {
19     WebSocketServerExtensionHandshaker mainHandshakerMock =</b></font>
20             mock(WebSocketServerExtensionHandshaker.class, "mainHandshaker");
21     WebSocketServerExtensionHandshaker fallbackHandshakerMock =
22             mock(WebSocketServerExtensionHandshaker.class, "fallbackHandshaker");
23     WebSocketServerExtension mainExtensionMock =
24             mock(WebSocketServerExtension.class, "mainExtension");
25     WebSocketServerExtension fallbackExtensionMock =
26             mock(WebSocketServerExtension.class, "fallbackExtension");
27     @Test
28     public void testMainSuccess() {
29         when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("main"))).
30                 thenReturn(mainExtensionMock);
31         when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("fallback"))).
32                 thenReturn(null);
33 <a name="3"></a>
34         when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("fallback"))).
35                 thenReturn(fallbackExtensionMock);
36         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("main"))).
37                 thenReturn(null);
38         when(mainExtensionMock.rsv()).thenReturn(WebSocketExtension.RSV1);
39         when(mainExtensionMock.newReponseData()).thenReturn(
40                 new</b></font> WebSocketExtensionData("main", Collections.&lt;String, String&gt;emptyMap()));
41         when(mainExtensionMock.newExtensionEncoder()).thenReturn(new DummyEncoder());
42         when(mainExtensionMock.newExtensionDecoder()).thenReturn(new DummyDecoder());
43         when(fallbackExtensionMock.rsv()).thenReturn(WebSocketExtension.RSV1);
44         WebSocketServerExtensionHandler extensionHandler =
45                 new WebSocketServerExtensionHandler(mainHandshakerMock, fallbackHandshakerMock);
46         EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);
47         HttpRequest req = newUpgradeRequest("main, fallback");
48         ch.writeInbound(req);
49         HttpResponse res = newUpgradeResponse(null);
50 <a name="2"></a>        ch.writeOutbound(res);
51         HttpResponse res2 = ch.readOutbound();
52         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>List&lt;WebSocketExtensionData&gt; resExts = WebSocketExtensionUtil.extractExtensions(
53                 res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));
54         assertNull(ch.pipeline().context(extensionHandler));
55         assertEquals(1, resExts.size());
56         assertEquals("main", resExts.get(0).name</b></font>());
57         assertTrue(resExts.get(0).parameters().isEmpty());
58         assertNotNull(ch.pipeline().get(DummyDecoder.class));
59         assertNotNull(ch.pipeline().get(DummyEncoder.class));
60         verify(mainHandshakerMock, atLeastOnce()).handshakeExtension(webSocketExtensionDataMatcher("main"));
61         verify(mainHandshakerMock, atLeastOnce()).handshakeExtension(webSocketExtensionDataMatcher("fallback"));
62 <a name="1"></a>        verify(fallbackHandshakerMock, atLeastOnce()).handshakeExtension(webSocketExtensionDataMatcher("fallback"));
63         verify(mainExtensionMock, atLeastOnce()).rsv();
64         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>verify(mainExtensionMock).newReponseData();
65         verify(mainExtensionMock).newExtensionEncoder();
66         verify(mainExtensionMock).newExtensionDecoder();
67         verify(fallbackExtensionMock, atLeastOnce()).rsv();
68     }
69     @</b></font>Test
70     public void testCompatibleExtensionTogetherSuccess() {
71         when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("main"))).
72                 thenReturn(mainExtensionMock);
73         when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("fallback"))).
74                 thenReturn(null);
75 <a name="5"></a>
76         when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("fallback"))).
77                 thenReturn(fallbackExtensionMock);
78         when(fallbackHandshakerMock.handshakeExtension(<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>webSocketExtensionDataMatcher("main"))).
79                 thenReturn(null);
80         when(mainExtensionMock.rsv()).thenReturn(WebSocketExtension.RSV1);
81         when(mainExtensionMock.newReponseData()).thenReturn(
82                 new WebSocketExtensionData("main", Collections.&lt;String, String&gt;emptyMap()));
83 <a name="6"></a>        when(mainExtensionMock.newExtensionEncoder()).thenReturn</b></font>(new DummyEncoder());
84         when(mainExtensionMock.newExtensionDecoder()).thenReturn(new DummyDecoder());
85         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>when(fallbackExtensionMock.rsv()).thenReturn(WebSocketExtension.RSV2);
86         when(fallbackExtensionMock.newReponseData()).thenReturn(
87                 new WebSocketExtensionData("fallback", Collections.&lt;String, String&gt;emptyMap()));
88         when(fallbackExtensionMock.newExtensionEncoder()).thenReturn</b></font>(new Dummy2Encoder());
89         when(fallbackExtensionMock.newExtensionDecoder()).thenReturn(new Dummy2Decoder());
90         WebSocketServerExtensionHandler extensionHandler =
91                 new WebSocketServerExtensionHandler(mainHandshakerMock, fallbackHandshakerMock);
92         EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);
93         HttpRequest req = newUpgradeRequest("main, fallback");
94         ch.writeInbound(req);
95         HttpResponse res = newUpgradeResponse(null);
96         ch.writeOutbound(res);
97         HttpResponse res2 = ch.readOutbound();
98         List&lt;WebSocketExtensionData&gt; resExts = WebSocketExtensionUtil.extractExtensions(
99                 res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));
100         assertNull(ch.pipeline().context(extensionHandler));
101         assertEquals(2, resExts.size());
102         assertEquals("main", resExts.get(0).name());
103         assertEquals("fallback", resExts.get(1).name());
104         assertNotNull(ch.pipeline().get(DummyDecoder.class));
105         assertNotNull(ch.pipeline().get(DummyEncoder.class));
106         assertNotNull(ch.pipeline().get(Dummy2Decoder.class));
107         assertNotNull(ch.pipeline().get(Dummy2Encoder.class));
108         verify(mainHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher("main"));
109         verify(mainHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher("fallback"));
110         verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher("fallback"));
111         verify(mainExtensionMock, times(2)).rsv();
112         verify(mainExtensionMock).newReponseData();
113         verify(mainExtensionMock).newExtensionEncoder();
114         verify(mainExtensionMock).newExtensionDecoder();
115         verify(fallbackExtensionMock, times(2)).rsv();
116         verify(fallbackExtensionMock).newReponseData();
117         verify(fallbackExtensionMock).newExtensionEncoder();
118         verify(fallbackExtensionMock).newExtensionDecoder();
119     }
120     @Test
121     public void testNoneExtensionMatchingSuccess() {
122         when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("unknown"))).
123                 thenReturn(null);
124         when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("unknown2"))).
125                 thenReturn(null);
126         when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("unknown"))).
127                 thenReturn(null);
128         when(fallbackHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("unknown2"))).
129                 thenReturn(null);
130         WebSocketServerExtensionHandler extensionHandler =
131                 new WebSocketServerExtensionHandler(mainHandshakerMock, fallbackHandshakerMock);
132         EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);
133         HttpRequest req = newUpgradeRequest("unknown, unknown2");
134         ch.writeInbound(req);
135         HttpResponse res = newUpgradeResponse(null);
136         ch.writeOutbound(res);
137         HttpResponse res2 = ch.readOutbound();
138         assertNull(ch.pipeline().context(extensionHandler));
139         assertFalse(res2.headers().contains(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));
140         verify(mainHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher("unknown"));
141         verify(mainHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher("unknown2"));
142         verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher("unknown"));
143         verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher("unknown2"));
144 <a name="4"></a>    }
145     @Test
146     public void testExtensionHandlerNotRemovedByFailureWritePromise() <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
147         when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher("main")))
148                 .thenReturn(mainExtensionMock);
149         when(mainExtensionMock.newReponseData()).thenReturn(
150                 new WebSocketExtensionData("main", Collections.&lt;String, String&gt;emptyMap</b></font>()));
151         WebSocketServerExtensionHandler extensionHandler =
152                 new WebSocketServerExtensionHandler(mainHandshakerMock);
153         EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);
154         HttpRequest req = newUpgradeRequest("main");
155         ch.writeInbound(req);
156         HttpResponse res = newUpgradeResponse(null);
157         ChannelPromise failurePromise = ch.newPromise();
158         ch.writeOneOutbound(res, failurePromise);
159         failurePromise.setFailure(new IOException("Cannot write response"));
160         assertNull(ch.readOutbound());
161         assertNotNull(ch.pipeline().context(extensionHandler));
162         assertTrue(ch.finish());
163     }
164 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Http2MultiplexTransportTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.handler.codec.http2;
2 import io.netty.bootstrap.Bootstrap;
3 import io.netty.bootstrap.ServerBootstrap;
4 import io.netty.buffer.Unpooled;
5 import io.netty.channel.Channel;
6 import io.netty.channel.ChannelFuture;
7 import io.netty.channel.ChannelFutureListener;
8 import io.netty.channel.ChannelHandler;
9 import io.netty.channel.ChannelHandlerContext;
10 import io.netty.channel.ChannelInboundHandlerAdapter;
11 import io.netty.channel.ChannelInitializer;
12 import io.netty.channel.EventLoopGroup;
13 import io.netty.channel.nio.NioEventLoopGroup;
14 import io.netty.channel.socket.nio.NioServerSocketChannel;
15 import io.netty.channel.socket.nio.NioSocketChannel;
16 import io.netty.handler.ssl.ApplicationProtocolConfig;
17 import io.netty.handler.ssl.ApplicationProtocolNames;
18 import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler;
19 import io.netty.handler.ssl.ClientAuth;
20 import io.netty.handler.ssl.OpenSsl;
21 import io.netty.handler.ssl.SslContext;
22 import io.netty.handler.ssl.SslContextBuilder;
23 import io.netty.handler.ssl.SslHandshakeCompletionEvent;
24 import io.netty.handler.ssl.SslProvider;
25 import io.netty.handler.ssl.SupportedCipherSuiteFilter;
26 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
27 import io.netty.handler.ssl.util.SelfSignedCertificate;
28 import io.netty.util.CharsetUtil;
29 import io.netty.util.NetUtil;
30 import io.netty.util.ReferenceCountUtil;
31 import io.netty.util.concurrent.Future;
32 import io.netty.util.concurrent.FutureListener;
33 import org.junit.jupiter.api.AfterEach;
34 <a name="0"></a>import org.junit.jupiter.api.BeforeEach;
35 import org.junit.jupiter.api.Disabled;
36 import org.junit.jupiter.api.Test;
37 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.junit.jupiter.api.Timeout;
38 import org.junit.jupiter.api.condition.DisabledOnOs;
39 import org.junit.jupiter.api.condition.OS;
40 import javax.net.ssl.SSLException;
41 import javax.net.ssl.X509TrustManager;
42 import java.net.InetSocketAddress;
43 import java.security.cert.CertificateException;
44 import java.security.cert.CertificateExpiredException;
45 import java.security.cert.X509Certificate;
46 import java.util.concurrent.CountDownLatch;
47 import java.util.concurrent.Executors;
48 import java.util.concurrent.ScheduledExecutorService;
49 import java.util.concurrent.atomic.AtomicReference;
50 import static java.util.concurrent.TimeUnit.MILLISECONDS;
51 import static org.junit.jupiter.api.Assertions.assertFalse;
52 import static org.junit.jupiter.api.Assumptions.assumeTrue;
53 public class Http2MultiplexTransportTest {
54     private static final ChannelHandler DISCARD_HANDLER = new ChannelInboundHandlerAdapter() {</b></font>
55         @Override
56         public boolean isSharable() {
57             return true;
58         }
59         @Override
60         public void channelRead(ChannelHandlerContext ctx, Object msg) {
61             ReferenceCountUtil.release(msg);
62         }
63         @Override
64         public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
65             ReferenceCountUtil.release(evt);
66         }
67     };
68     private EventLoopGroup eventLoopGroup;
69     private Channel clientChannel;
70     private Channel serverChannel;
71     private Channel serverConnectedChannel;
72     @BeforeEach
73     public void setup() {
74         eventLoopGroup = new NioEventLoopGroup();
75     }
76     @AfterEach
77     public void teardown() {
78         if (clientChannel != null) {
79             clientChannel.close();
80         }
81         if (serverChannel != null) {
82             serverChannel.close();
83         }
84         if (serverConnectedChannel != null) {
85             serverConnectedChannel.close();
86         }
87         eventLoopGroup.shutdownGracefully(0, 0, MILLISECONDS);
88     }
89     @Test
90     @Timeout(value = 10000, unit = MILLISECONDS)
91     public void asyncSettingsAckWithMultiplexCodec() throws InterruptedException {
92         asyncSettingsAck0(new Http2MultiplexCodecBuilder(true, DISCARD_HANDLER).build(), null);
93     }
94     @Test
95     @Timeout(value = 10000, unit = MILLISECONDS)
96     public void asyncSettingsAckWithMultiplexHandler() throws InterruptedException {
97         asyncSettingsAck0(new Http2FrameCodecBuilder(true).build(),
98                 new Http2MultiplexHandler(DISCARD_HANDLER));
99     }
100     private void asyncSettingsAck0(final Http2FrameCodec codec, final ChannelHandler multiplexer)
101             throws InterruptedException {
102         final CountDownLatch serverAckOneLatch = new CountDownLatch(1);
103         final CountDownLatch serverAckAllLatch = new CountDownLatch(2);
104         final CountDownLatch clientSettingsLatch = new CountDownLatch(2);
105         final CountDownLatch serverConnectedChannelLatch = new CountDownLatch(1);
106         final AtomicReference&lt;Channel&gt; serverConnectedChannelRef = new AtomicReference&lt;Channel&gt;();
107         ServerBootstrap sb = new ServerBootstrap();
108         sb.group(eventLoopGroup);
109         sb.channel(NioServerSocketChannel.class);
110         sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
111             @Override
112             protected void initChannel(Channel ch) {
113                 ch.pipeline().addLast(codec);
114                 if (multiplexer != null) {
115                     ch.pipeline().addLast(multiplexer);
116                 }
117                 ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
118                     @Override
119                     public void channelActive(ChannelHandlerContext ctx) {
120                         serverConnectedChannelRef.set(ctx.channel());
121                         serverConnectedChannelLatch.countDown();
122                     }
123                     @Override
124                     public void channelRead(ChannelHandlerContext ctx, Object msg) {
125                         if (msg instanceof Http2SettingsAckFrame) {
126                             serverAckOneLatch.countDown();
127                             serverAckAllLatch.countDown();
128                         }
129                         ReferenceCountUtil.release(msg);
130                     }
131                 });
132             }
133         });
134         serverChannel = sb.bind(new InetSocketAddress(NetUtil.LOCALHOST, 0)).awaitUninterruptibly().channel();
135         Bootstrap bs = new Bootstrap();
136         bs.group(eventLoopGroup);
137         bs.channel(NioSocketChannel.class);
138         bs.handler(new ChannelInitializer&lt;Channel&gt;() {
139             @Override
140             protected void initChannel(Channel ch) {
141                 ch.pipeline().addLast(Http2MultiplexCodecBuilder
142                         .forClient(DISCARD_HANDLER).autoAckSettingsFrame(false).build());
143                 ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
144                     @Override
145                     public void channelRead(ChannelHandlerContext ctx, Object msg) {
146                         if (msg instanceof Http2SettingsFrame) {
147                             clientSettingsLatch.countDown();
148                         }
149                         ReferenceCountUtil.release(msg);
150                     }
151                 });
152             }
153         });
154         clientChannel = bs.connect(serverChannel.localAddress()).awaitUninterruptibly().channel();
155         serverConnectedChannelLatch.await();
156         serverConnectedChannel = serverConnectedChannelRef.get();
157 <a name="1"></a>        serverConnectedChannel.writeAndFlush(new DefaultHttp2SettingsFrame(new Http2Settings()
158                 .maxConcurrentStreams(10))).sync();
159         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>clientSettingsLatch.await();
160         assertFalse(serverAckOneLatch.await(300, MILLISECONDS));
161         clientChannel.writeAndFlush(Http2SettingsAckFrame.INSTANCE).sync();
162         clientChannel.writeAndFlush(Http2SettingsAckFrame.INSTANCE).sync();
163         serverAckAllLatch.await();
164     }
165     @</b></font>Test
166     @Timeout(value = 5000L, unit = MILLISECONDS)
167     public void testFlushNotDiscarded()
168             throws InterruptedException {
169         final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
170         try {
171             ServerBootstrap sb = new ServerBootstrap();
172             sb.group(eventLoopGroup);
173             sb.channel(NioServerSocketChannel.class);
174             sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
175                 @Override
176                 protected void initChannel(Channel ch) {
177                     ch.pipeline().addLast(new Http2FrameCodecBuilder(true).build());
178                     ch.pipeline().addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter() {
179                         @Override
180                         public void channelRead(final ChannelHandlerContext ctx, Object msg) {
181                             if (msg instanceof Http2HeadersFrame &amp;&amp; ((Http2HeadersFrame) msg).isEndStream()) {
182                                 executorService.schedule(new Runnable() {
183                                     @Override
184                                     public void run() {
185                                         ctx.writeAndFlush(new DefaultHttp2HeadersFrame(
186                                                 new DefaultHttp2Headers(), false)).addListener(
187                                                         new ChannelFutureListener() {
188                                             @Override
189                                             public void operationComplete(ChannelFuture future) {
190                                                 ctx.write(new DefaultHttp2DataFrame(
191                                                         Unpooled.copiedBuffer("Hello World", CharsetUtil.US_ASCII),
192                                                         true));
193                                                 ctx.channel().eventLoop().execute(new Runnable() {
194                                                     @Override
195                                                     public void run() {
196                                                         ctx.flush();
197                                                     }
198                                                 });
199                                             }
200                                         });
201                                     }
202                                 }, 500, MILLISECONDS);
203                             }
204                             ReferenceCountUtil.release(msg);
205                         }
206                     }));
207                 }
208             });
209             serverChannel = sb.bind(new InetSocketAddress(NetUtil.LOCALHOST, 0)).syncUninterruptibly().channel();
210             final CountDownLatch latch = new CountDownLatch(1);
211             Bootstrap bs = new Bootstrap();
212             bs.group(eventLoopGroup);
213             bs.channel(NioSocketChannel.class);
214             bs.handler(new ChannelInitializer&lt;Channel&gt;() {
215                 @Override
216                 protected void initChannel(Channel ch) {
217                     ch.pipeline().addLast(new Http2FrameCodecBuilder(false).build());
218                     ch.pipeline().addLast(new Http2MultiplexHandler(DISCARD_HANDLER));
219                 }
220             });
221             clientChannel = bs.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
222             Http2StreamChannelBootstrap h2Bootstrap = new Http2StreamChannelBootstrap(clientChannel);
223             h2Bootstrap.handler(new ChannelInboundHandlerAdapter() {
224                 @Override
225                 public void channelRead(ChannelHandlerContext ctx, Object msg) {
226                     if (msg instanceof Http2DataFrame &amp;&amp; ((Http2DataFrame) msg).isEndStream()) {
227                         latch.countDown();
228                     }
229                     ReferenceCountUtil.release(msg);
230                 }
231             });
232             Http2StreamChannel streamChannel = h2Bootstrap.open().syncUninterruptibly().getNow();
233             streamChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers(), true))
234                     .syncUninterruptibly();
235             latch.await();
236         } finally {
237             executorService.shutdown();
238         }
239     }
240     @Test
241     @Timeout(value = 5000L, unit = MILLISECONDS)
242     public void testSSLExceptionOpenSslTLSv12() throws Exception {
243         testSslException(SslProvider.OPENSSL, false);
244     }
245     @Test
246     @Timeout(value = 5000L, unit = MILLISECONDS)
247     public void testSSLExceptionOpenSslTLSv13() throws Exception {
248         testSslException(SslProvider.OPENSSL, true);
249     }
250     @Disabled("JDK SSLEngine does not produce an alert")
251     @Test
252     @Timeout(value = 5000L, unit = MILLISECONDS)
253     public void testSSLExceptionJDKTLSv12() throws Exception {
254         testSslException(SslProvider.JDK, false);
255     }
256     @Disabled("JDK SSLEngine does not produce an alert")
257     @Test
258     @Timeout(value = 5000L, unit = MILLISECONDS)
259     public void testSSLExceptionJDKTLSv13() throws Exception {
260         testSslException(SslProvider.JDK, true);
261     }
262     private void testSslException(SslProvider provider, final boolean tlsv13) throws Exception {
263         assumeTrue(SslProvider.isAlpnSupported(provider));
264         if (tlsv13) {
265             assumeTrue(SslProvider.isTlsv13Supported(provider));
266         }
267         final String protocol = tlsv13 ? "TLSv1.3" : "TLSv1.2";
268 <a name="3"></a>        SelfSignedCertificate ssc = null;
269         try {
270             ssc = new SelfSignedCertificate();
271             final SslContext sslCtx = <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
272                     .trustManager(new</b></font> X509TrustManager() {
273                         @Override
274                         public void checkClientTrusted(X509Certificate[] chain, String authType)
275                                 throws CertificateException {
276                             throw new CertificateExpiredException();
277                         }
278                         @Override
279                         public void checkServerTrusted(X509Certificate[] chain, String authType)
280                                 throws CertificateException {
281                             throw new CertificateExpiredException();
282                         }
283                         @Override
284                         public X509Certificate[] getAcceptedIssuers() {
285                             return new X509Certificate[0];
286                         }
287                     }).sslProvider(provider)
288                     .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE)
289                     .protocols(protocol)
290                     .applicationProtocolConfig(new ApplicationProtocolConfig(
291                             ApplicationProtocolConfig.Protocol.ALPN,
292                             ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,
293                             ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,
294                             ApplicationProtocolNames.HTTP_2,
295                             ApplicationProtocolNames.HTTP_1_1)).clientAuth(ClientAuth.REQUIRE)
296                     .build();
297             ServerBootstrap sb = new ServerBootstrap();
298             sb.group(eventLoopGroup);
299             sb.channel(NioServerSocketChannel.class);
300             sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
301 <a name="5"></a>
302                 @Override
303                 protected void initChannel(Channel ch) {
304                     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));
305                     ch.pipeline().addLast(new Http2FrameCodecBuilder(true).build());
306                     ch.pipeline</b></font>().addLast(new Http2MultiplexHandler(DISCARD_HANDLER));
307                 }
308 <a name="2"></a>            });
309             serverChannel = sb.bind(new InetSocketAddress(NetUtil.LOCALHOST, 0)).syncUninterruptibly().channel();
310             <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>final SslContext clientCtx = SslContextBuilder.forClient()
311                     .keyManager(ssc.key(), ssc.cert</b></font>())
312                     .sslProvider(provider)
313                     .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE)
314                     .trustManager(InsecureTrustManagerFactory.INSTANCE)
315                     .protocols(protocol)
316                     .applicationProtocolConfig(new ApplicationProtocolConfig(
317                             ApplicationProtocolConfig.Protocol.ALPN,
318                             ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,
319                             ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,
320                             ApplicationProtocolNames.HTTP_2,
321                             ApplicationProtocolNames.HTTP_1_1))
322                     .build();
323             final CountDownLatch latch = new CountDownLatch(2);
324             final AtomicReference&lt;AssertionError&gt; errorRef = new AtomicReference&lt;AssertionError&gt;();
325             Bootstrap bs = new Bootstrap();
326             bs.group(eventLoopGroup);
327 <a name="4"></a>            bs.channel(NioSocketChannel.class);
328             bs.handler(new ChannelInitializer&lt;Channel&gt;() {
329                 @Override
330                 protected void initChannel(Channel ch) <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
331                     ch.pipeline().addLast(clientCtx.newHandler(ch.alloc()));
332                     ch.pipeline().addLast(new Http2FrameCodecBuilder(false).build());
333                     ch.pipeline().addLast</b></font>(new Http2MultiplexHandler(DISCARD_HANDLER));
334                     ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
335                         @Override
336                         public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
337                             if (evt instanceof SslHandshakeCompletionEvent) {
338                                 SslHandshakeCompletionEvent handshakeCompletionEvent =
339                                         (SslHandshakeCompletionEvent) evt;
340                                 if (handshakeCompletionEvent.isSuccess()) {
341                                     if (!tlsv13) {
342                                         errorRef.set(new AssertionError("TLSv1.3 expected"));
343                                     }
344                                     Http2StreamChannelBootstrap h2Bootstrap =
345                                             new Http2StreamChannelBootstrap(ctx.channel());
346                                     h2Bootstrap.handler(new ChannelInboundHandlerAdapter() {
347                                         @Override
348                                         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
349                                             if (cause.getCause() instanceof SSLException) {
350                                                 latch.countDown();
351                                             }
352                                         }
353                                         @Override
354                                         public void channelInactive(ChannelHandlerContext ctx) {
355                                             latch.countDown();
356                                         }
357                                     });
358                                     h2Bootstrap.open().addListener(new FutureListener&lt;Channel&gt;() {
359                                                 @Override
360                                                 public void operationComplete(Future&lt;Channel&gt; future) {
361                                                     if (future.isSuccess()) {
362                                                         future.getNow().writeAndFlush(new DefaultHttp2HeadersFrame(
363                                                                 new DefaultHttp2Headers(), false));
364                                                     }
365                                                 }
366                                             });
367                                 } else if (handshakeCompletionEvent.cause() instanceof SSLException) {
368                                     if (tlsv13) {
369                                         errorRef.set(new AssertionError("TLSv1.2 expected"));
370                                     }
371                                     latch.countDown();
372                                     latch.countDown();
373                                 }
374                             }
375                         }
376                     });
377                 }
378             });
379             clientChannel = bs.connect(serverChannel.localAddress()).syncUninterruptibly().channel();
380             latch.await();
381             AssertionError error = errorRef.get();
382             if (error != null) {
383                 throw error;
384             }
385         } finally {
386             if (ssc != null) {
387                 ssc.delete();
388             }
389         }
390     }
391     @Test
392     @DisabledOnOs(value = OS.WINDOWS, disabledReason = "See: https://github.com/netty/netty/issues/11542")
393     @Timeout(value = 5000L, unit = MILLISECONDS)
394     public void testFireChannelReadAfterHandshakeSuccess_JDK() throws Exception {
395         assumeTrue(SslProvider.isAlpnSupported(SslProvider.JDK));
396         testFireChannelReadAfterHandshakeSuccess(SslProvider.JDK);
397     }
398     @Test
399     @DisabledOnOs(value = OS.WINDOWS, disabledReason = "See: https://github.com/netty/netty/issues/11542")
400     @Timeout(value = 5000L, unit = MILLISECONDS)
401     public void testFireChannelReadAfterHandshakeSuccess_OPENSSL() throws Exception {
402         assumeTrue(OpenSsl.isAvailable());
403         assumeTrue(SslProvider.isAlpnSupported(SslProvider.OPENSSL));
404         testFireChannelReadAfterHandshakeSuccess(SslProvider.OPENSSL);
405     }
406     private void testFireChannelReadAfterHandshakeSuccess(SslProvider provider) throws Exception {
407         SelfSignedCertificate ssc = null;
408         try {
409             ssc = new SelfSignedCertificate();
410             final SslContext serverCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
411                     .sslProvider(provider)
412                     .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE)
413                     .applicationProtocolConfig(new ApplicationProtocolConfig(
414                             ApplicationProtocolConfig.Protocol.ALPN,
415                             ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,
416                             ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,
417                             ApplicationProtocolNames.HTTP_2,
418                             ApplicationProtocolNames.HTTP_1_1))
419                     .build();
420             ServerBootstrap sb = new ServerBootstrap();
421             sb.group(eventLoopGroup);
422             sb.channel(NioServerSocketChannel.class);
423             sb.childHandler(new ChannelInitializer&lt;Channel&gt;() {
424                 @Override
425                 protected void initChannel(Channel ch) {
426                     ch.pipeline().addLast(serverCtx.newHandler(ch.alloc()));
427                     ch.pipeline().addLast(new ApplicationProtocolNegotiationHandler(ApplicationProtocolNames.HTTP_1_1) {
428                         @Override
429                         protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {
430                             ctx.pipeline().addLast(new Http2FrameCodecBuilder(true).build());
431                             ctx.pipeline().addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter() {
432                                 @Override
433                                 public void channelRead(final ChannelHandlerContext ctx, Object msg) {
434                                     if (msg instanceof Http2HeadersFrame &amp;&amp; ((Http2HeadersFrame) msg).isEndStream()) {
435                                         ctx.writeAndFlush(new DefaultHttp2HeadersFrame(
436                                                 new DefaultHttp2Headers(), false))
437                                            .addListener(new ChannelFutureListener() {
438                                                @Override
439                                                public void operationComplete(ChannelFuture future) {
440                                                    ctx.writeAndFlush(new DefaultHttp2DataFrame(
441                                                            Unpooled.copiedBuffer("Hello World", CharsetUtil.US_ASCII),
442                                                            true));
443                                                }
444                                            });
445                                     }
446                                     ReferenceCountUtil.release(msg);
447                                 }
448                             }));
449                         }
450                     });
451                 }
452             });
453             serverChannel = sb.bind(new InetSocketAddress(NetUtil.LOCALHOST, 0)).sync().channel();
454             final SslContext clientCtx = SslContextBuilder.forClient()
455                     .sslProvider(provider)
456                     .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE)
457                     .trustManager(InsecureTrustManagerFactory.INSTANCE)
458                     .applicationProtocolConfig(new ApplicationProtocolConfig(
459                             ApplicationProtocolConfig.Protocol.ALPN,
460                             ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,
461                             ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,
462                             ApplicationProtocolNames.HTTP_2,
463                             ApplicationProtocolNames.HTTP_1_1))
464                     .build();
465             final CountDownLatch latch = new CountDownLatch(1);
466             Bootstrap bs = new Bootstrap();
467             bs.group(eventLoopGroup);
468             bs.channel(NioSocketChannel.class);
469 <a name="6"></a>            bs.handler(new ChannelInitializer&lt;Channel&gt;() {
470                 @Override
471                 protected void initChannel(Channel ch) {
472                     <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ch.pipeline().addLast(clientCtx.newHandler(ch.alloc()));
473                     ch.pipeline().addLast(new Http2FrameCodecBuilder(false).build());
474                     ch.pipeline</b></font>().addLast(new Http2MultiplexHandler(DISCARD_HANDLER));
475                     ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
476                         @Override
477                         public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
478                             if (evt instanceof SslHandshakeCompletionEvent) {
479                                 SslHandshakeCompletionEvent handshakeCompletionEvent =
480                                         (SslHandshakeCompletionEvent) evt;
481                                 if (handshakeCompletionEvent.isSuccess()) {
482                                     Http2StreamChannelBootstrap h2Bootstrap =
483                                             new Http2StreamChannelBootstrap(clientChannel);
484                                     h2Bootstrap.handler(new ChannelInboundHandlerAdapter() {
485                                         @Override
486                                         public void channelRead(ChannelHandlerContext ctx, Object msg) {
487                                             if (msg instanceof Http2DataFrame &amp;&amp; ((Http2DataFrame) msg).isEndStream()) {
488                                                 latch.countDown();
489                                             }
490                                             ReferenceCountUtil.release(msg);
491                                         }
492                                     });
493                                     h2Bootstrap.open().addListener(new FutureListener&lt;Channel&gt;() {
494                                         @Override
495                                         public void operationComplete(Future&lt;Channel&gt; future) {
496                                             if (future.isSuccess()) {
497                                                 future.getNow().writeAndFlush(new DefaultHttp2HeadersFrame(
498                                                         new DefaultHttp2Headers(), true));
499                                             }
500                                         }
501                                     });
502                                 }
503                             }
504                         }
505                     });
506                 }
507             });
508             clientChannel = bs.connect(serverChannel.localAddress()).sync().channel();
509             latch.await();
510         } finally {
511             if (ssc != null) {
512                 ssc.delete();
513             }
514         }
515     }
516 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
