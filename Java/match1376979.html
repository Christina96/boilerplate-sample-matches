<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for WhereClauseOptimizer.java & GroupingCollector.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for WhereClauseOptimizer.java & GroupingCollector.java
      </h3>
      <h1 align="center">
        13.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>WhereClauseOptimizer.java (15.492958%)<TH>GroupingCollector.java (12.4293785%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1376979-0.html#0',2,'match1376979-1.html#0',3)" NAME="0">(22-48)<TD><A HREF="javascript:ZweiFrames('match1376979-0.html#0',2,'match1376979-1.html#0',3)" NAME="0">(22-48)</A><TD ALIGN=center><FONT COLOR="#ff0000">25</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1376979-0.html#1',2,'match1376979-1.html#1',3)" NAME="1">(117-120)<TD><A HREF="javascript:ZweiFrames('match1376979-0.html#1',2,'match1376979-1.html#1',3)" NAME="1">(141-144)</A><TD ALIGN=center><FONT COLOR="#660000">10</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1376979-0.html#2',2,'match1376979-1.html#2',3)" NAME="2">(68-76)<TD><A HREF="javascript:ZweiFrames('match1376979-0.html#2',2,'match1376979-1.html#2',3)" NAME="2">(69-77)</A><TD ALIGN=center><FONT COLOR="#5b0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WhereClauseOptimizer.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1376979-1.html#0',3,'match1376979-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.crate.planner;

import io.crate.analyze.GeneratedColumnExpander;
import io.crate.analyze.WhereClause;
import io.crate.analyze.where.DocKeys;
import io.crate.analyze.where.EqualityExtractor;
import io.crate.analyze.where.WhereClauseAnalyzer;
import io.crate.analyze.where.WhereClauseValidator;
import io.crate.common.collections.Lists2;
import io.crate.data.Row;
import io.crate.expression.eval.EvaluatingNormalizer;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.Symbols;
import io.crate.metadata.ColumnIdent;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.NodeContext;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.doc.DocSysColumns;
import io.crate.metadata.doc.DocTableInfo;
import io.crate.planner.operators.SubQueryAndParamBinder;
import io.crate.planner.operators.SubQueryResults;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import</B></FONT> java.util.Objects;
import java.util.Optional;
import java.util.Set;

/**
 * Used to analyze a query for primaryKey/partition &quot;direct access&quot; possibilities.
 *
 * This is similar to {@link io.crate.analyze.where.WhereClauseAnalyzer} - the difference is that this works also if
 * the query still contains ParameterSymbols.
 *
 * Once all Analyzers are migrated to be &quot;unbound&quot;,
 * the WhereClauseAnalyzer should be removed (or reworked, to just do the final partition selection / tie-breaking)
 */
public final class WhereClauseOptimizer {

    private WhereClauseOptimizer() {
    }
<A NAME="2"></A>
    public static class DetailedQuery {

        <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1376979-1.html#2',3,'match1376979-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>private final Symbol query;
        private final DocKeys docKeys;
        private final List&lt;List&lt;Symbol&gt;&gt; partitions;
        private final Set&lt;Symbol&gt; clusteredByValues;

        DetailedQuery(Symbol query,
                      DocKeys docKeys,
                      List&lt;List&lt;Symbol&gt;&gt; partitionValues,
                      Set&lt;Symbol&gt; clusteredByValues</B></FONT>) {
            this.query = query;
            this.docKeys = docKeys;
            this.partitions = Objects.requireNonNullElse(partitionValues, Collections.emptyList());
            this.clusteredByValues = clusteredByValues;
        }

        public Optional&lt;DocKeys&gt; docKeys() {
            return Optional.ofNullable(docKeys);
        }

        /**
         * @return Symbols &quot;pointing&quot; to the values of any `partition_col = S` expressions:
         *         The outer list contains 1 entry per &quot;equals pair&quot; (e.g. `pcol = ? or pcol = ?` -&gt; 2 entries
         *
         *         The inner list contains 1 entry per partitioned by column.
         *         The order matches the order of the partitioned by column definition.
         */
        public List&lt;List&lt;Symbol&gt;&gt; partitions() {
            return partitions;
        }

        public Symbol query() {
            return query;
        }

        public Set&lt;Symbol&gt; clusteredBy() {
            return clusteredByValues;
        }

        public WhereClause toBoundWhereClause(DocTableInfo table,
                                              Row params,
                                              SubQueryResults subQueryResults,
                                              CoordinatorTxnCtx txnCtx,
                                              NodeContext nodeCtx) {
            if (docKeys != null) {
                throw new IllegalStateException(getClass().getSimpleName()
                                                + &quot; must not be converted to a WhereClause if docKeys are present&quot;);
<A NAME="1"></A>            }
            SubQueryAndParamBinder binder = new SubQueryAndParamBinder(params, subQueryResults);
            Symbol boundQuery = binder.apply(query);
            <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1376979-1.html#1',3,'match1376979-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>HashSet&lt;Symbol&gt; clusteredBy = new HashSet&lt;&gt;(clusteredByValues.size());
            for (Symbol clusteredByValue : clusteredByValues) {
                clusteredBy.add(binder.apply(clusteredByValue));
            }</B></FONT>
            if (table.isPartitioned()) {
                if (table.partitions().isEmpty()) {
                    return WhereClause.NO_MATCH;
                }
                WhereClauseAnalyzer.PartitionResult partitionResult =
                    WhereClauseAnalyzer.resolvePartitions(boundQuery, table, txnCtx, nodeCtx);
                return new WhereClause(
                    partitionResult.query,
                    partitionResult.partitions,
                    clusteredBy
                );
            } else {
                return new WhereClause(
                    boundQuery,
                    Collections.emptyList(),
                    clusteredBy
                );
            }
        }
    }

    public static DetailedQuery optimize(EvaluatingNormalizer normalizer,
                                         Symbol query,
                                         DocTableInfo table,
                                         TransactionContext txnCtx,
                                         NodeContext nodeCtx) {
        Symbol queryGenColsProcessed = GeneratedColumnExpander.maybeExpand(
            query,
            table.generatedColumns(),
            Lists2.concat(table.partitionedByColumns(), Lists2.map(table.primaryKey(), table::getReference)),
            nodeCtx);
        if (!query.equals(queryGenColsProcessed)) {
            query = normalizer.normalize(queryGenColsProcessed, txnCtx);
        }
        WhereClause.validateVersioningColumnsUsage(query);

        boolean versionInQuery = Symbols.containsColumn(query, DocSysColumns.VERSION);
        boolean sequenceVersioningInQuery = Symbols.containsColumn(query, DocSysColumns.SEQ_NO) &amp;&amp;
                                            Symbols.containsColumn(query, DocSysColumns.PRIMARY_TERM);
        List&lt;ColumnIdent&gt; pkCols = pkColsInclVersioning(table, versionInQuery, sequenceVersioningInQuery);

        EqualityExtractor eqExtractor = new EqualityExtractor(normalizer);
        List&lt;List&lt;Symbol&gt;&gt; pkValues = eqExtractor.extractExactMatches(pkCols, query, txnCtx);

        int clusterIdxWithinPK = table.primaryKey().indexOf(table.clusteredBy());
        final DocKeys docKeys;
        if (pkValues == null) {
            docKeys = null;
        } else {
            List&lt;Integer&gt; partitionIndicesWithinPks = null;
            if (table.isPartitioned()) {
                partitionIndicesWithinPks = getPartitionIndices(table.primaryKey(), table.partitionedBy());
            }
            docKeys = new DocKeys(pkValues,
                                  versionInQuery,
                                  sequenceVersioningInQuery,
                                  clusterIdxWithinPK,
                                  partitionIndicesWithinPks);
        }
        List&lt;List&lt;Symbol&gt;&gt; partitionValues = null;
        if (table.isPartitioned()) {
            partitionValues = eqExtractor.extractExactMatches(table.partitionedBy(), query, txnCtx);
        }
        Set&lt;Symbol&gt; clusteredBy = Collections.emptySet();
        if (table.clusteredBy() != null) {
            List&lt;List&lt;Symbol&gt;&gt; clusteredByValues = eqExtractor.extractParentMatches(
                Collections.singletonList(table.clusteredBy()), query, txnCtx);
            if (clusteredByValues != null) {
                clusteredBy = new HashSet&lt;&gt;(clusteredByValues.size());
                for (List&lt;Symbol&gt; s : clusteredByValues) {
                    clusteredBy.add(s.get(0));
                }
            }
        }
        WhereClauseValidator.validate(query);
        return new DetailedQuery(query, docKeys, partitionValues, clusteredBy);
    }

    public static List&lt;Integer&gt; getPartitionIndices(List&lt;ColumnIdent&gt; pkCols, List&lt;ColumnIdent&gt; partitionCols) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(partitionCols.size());
        for (int i = 0; i &lt; partitionCols.size(); i++) {
            ColumnIdent partitionCol = partitionCols.get(i);
            int partColIdxInPks = pkCols.indexOf(partitionCol);
            if (partColIdxInPks &gt;= 0) {
                result.add(partColIdxInPks);
            }
        }
        return result;
    }

    private static List&lt;ColumnIdent&gt; pkColsInclVersioning(DocTableInfo table,
                                                          boolean versionInQuery,
                                                          boolean seqNoAndPrimaryTermInQuery) {
        if (versionInQuery) {
            ArrayList&lt;ColumnIdent&gt; pkCols = new ArrayList&lt;&gt;(table.primaryKey().size() + 1);
            pkCols.addAll(table.primaryKey());
            pkCols.add(DocSysColumns.VERSION);
            return pkCols;
        } else if (seqNoAndPrimaryTermInQuery) {
            ArrayList&lt;ColumnIdent&gt; pkCols = new ArrayList&lt;&gt;(table.primaryKey().size() + 1);
            pkCols.addAll(table.primaryKey());
            pkCols.add(DocSysColumns.SEQ_NO);
            pkCols.add(DocSysColumns.PRIMARY_TERM);
            return pkCols;
        }
        return table.primaryKey();
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>GroupingCollector.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Licensed to Crate.io GmbH (&quot;Crate&quot;) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<A NAME="0"></A> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1376979-0.html#0',2,'match1376979-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.crate.execution.engine.aggregation;

import io.crate.breaker.MultiSizeEstimator;
import io.crate.breaker.RamAccounting;
import io.crate.breaker.SizeEstimatorFactory;
import io.crate.data.Input;
import io.crate.data.Row;
import io.crate.data.RowN;
import io.crate.execution.engine.collect.CollectExpression;
import io.crate.expression.InputCondition;
import io.crate.expression.symbol.AggregateMode;
import io.crate.memory.MemoryManager;
import io.crate.types.DataType;
import org.elasticsearch.Version;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Iterator;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import</B></FONT> java.util.stream.Collector;

/**
 * Collector implementation which uses {@link AggregateMode}s and {@code keyInputs}
 * to group rows by key and aggregate the grouped values.
 *
 * @param &lt;K&gt; type of the key
 */
public class GroupingCollector&lt;K&gt; implements Collector&lt;Row, Map&lt;K, Object[]&gt;, Iterable&lt;Row&gt;&gt; {

    private final CollectExpression&lt;Row, ?&gt;[] expressions;
    private final AggregationFunction[] aggregations;
    private final AggregateMode mode;
    private final Input[][] inputs;
    private final Input&lt;Boolean&gt;[] filters;
    private final RamAccounting ramAccounting;
    private final MemoryManager memoryManager;
    private final BiConsumer&lt;K, Object[]&gt; applyKeyToCells;
<A NAME="2"></A>    private final int numKeyColumns;
    private final BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewEntry;
    private final Function&lt;Row, K&gt; keyExtractor;
    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1376979-0.html#2',2,'match1376979-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private final Version indexVersionCreated;
    private final BiConsumer&lt;Map&lt;K, Object[]&gt;, Row&gt; accumulator;
    private final Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier;
    private final Version minNodeVersion;

    static GroupingCollector&lt;Object&gt; singleKey(CollectExpression&lt;Row, ?&gt;[] expressions,
                                               AggregateMode mode,
                                               AggregationFunction[] aggregations,
                                               Input[][] inputs</B></FONT>,
                                               Input&lt;Boolean&gt;[] filters,
                                               RamAccounting ramAccounting,
                                               MemoryManager memoryManager,
                                               Version minNodeVersion,
                                               Input&lt;?&gt; keyInput,
                                               DataType keyType,
                                               Version indexVersionCreated) {
        return new GroupingCollector&lt;&gt;(
            expressions,
            aggregations,
            mode,
            inputs,
            filters,
            ramAccounting,
            memoryManager,
            minNodeVersion,
            (key, cells) -&gt; cells[0] = key,
            1,
            GroupByMaps.accountForNewEntry(
                ramAccounting,
                SizeEstimatorFactory.create(keyType),
                keyType
            ),
            row -&gt; keyInput.value(),
            indexVersionCreated,
            GroupByMaps.mapForType(keyType)
        );
    }

    static GroupingCollector&lt;List&lt;Object&gt;&gt; manyKeys(CollectExpression&lt;Row, ?&gt;[] expressions,
                                                    AggregateMode mode,
                                                    AggregationFunction[] aggregations,
                                                    Input[][] inputs,
                                                    Input&lt;Boolean&gt;[] filters,
                                                    RamAccounting ramAccountingContext,
                                                    MemoryManager memoryManager,
                                                    Version minNodeVersion,
                                                    List&lt;Input&lt;?&gt;&gt; keyInputs,
                                                    List&lt;? extends DataType&gt; keyTypes,
                                                    Version indexVersionCreated) {
        return new GroupingCollector&lt;&gt;(
            expressions,
            aggregations,
            mode,
            inputs,
            filters,
            ramAccountingContext,
            memoryManager,
            minNodeVersion,
            GroupingCollector::applyKeysToCells,
            keyInputs.size(),
            GroupByMaps.accountForNewEntry(
                ramAccountingContext,
                new MultiSizeEstimator(keyTypes),
                null
            ),
            row -&gt; evalKeyInputs(keyInputs),
            indexVersionCreated,
            HashMap::new
        );
<A NAME="1"></A>    }

    private static List&lt;Object&gt; evalKeyInputs(List&lt;Input&lt;?&gt;&gt; keyInputs) {
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1376979-0.html#1',2,'match1376979-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>List&lt;Object&gt; key = new ArrayList&lt;&gt;(keyInputs.size());
        for (Input&lt;?&gt; keyInput : keyInputs) {
            key.add(keyInput.value());
        }</B></FONT>
        return key;
    }

    private static void applyKeysToCells(List&lt;Object&gt; keys, Object[] cells) {
        for (int i = 0; i &lt; keys.size(); i++) {
            cells[i] = keys.get(i);
        }
    }

    private GroupingCollector(CollectExpression&lt;Row, ?&gt;[] expressions,
                              AggregationFunction[] aggregations,
                              AggregateMode mode,
                              Input[][] inputs,
                              Input&lt;Boolean&gt;[] filters,
                              RamAccounting ramAccounting,
                              MemoryManager memoryManager,
                              Version minNodeVersion,
                              BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
                              int numKeyColumns,
                              BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewEntry,
                              Function&lt;Row, K&gt; keyExtractor,
                              Version indexVersionCreated,
                              Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier) {
        this.expressions = expressions;
        this.aggregations = aggregations;
        this.mode = mode;
        this.inputs = inputs;
        this.filters = filters;
        this.ramAccounting = ramAccounting;
        this.memoryManager = memoryManager;
        this.applyKeyToCells = applyKeyToCells;
        this.numKeyColumns = numKeyColumns;
        this.accountForNewEntry = accountForNewEntry;
        this.keyExtractor = keyExtractor;
        this.indexVersionCreated = indexVersionCreated;
        this.accumulator = mode == AggregateMode.PARTIAL_FINAL ? this::reduce : this::iter;
        this.supplier = supplier;
        this.minNodeVersion = minNodeVersion;
    }

    @Override
    public Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier() {
        return supplier;
    }

    @Override
    public BiConsumer&lt;Map&lt;K, Object[]&gt;, Row&gt; accumulator() {
        return accumulator;
    }

    @Override
    public BinaryOperator&lt;Map&lt;K, Object[]&gt;&gt; combiner() {
        return (state1, state2) -&gt; {
            throw new UnsupportedOperationException(&quot;combine not supported&quot;);
        };
    }

    @Override
    public Function&lt;Map&lt;K, Object[]&gt;, Iterable&lt;Row&gt;&gt; finisher() {
        return this::mapToRows;
    }

    @Override
    public Set&lt;Characteristics&gt; characteristics() {
        return Collections.emptySet();
    }

    private void reduce(Map&lt;K, Object[]&gt; statesByKey, Row row) {
        for (CollectExpression&lt;Row, ?&gt; expression : expressions) {
            expression.setNextRow(row);
        }
        K key = keyExtractor.apply(row);
        Object[] states = statesByKey.get(key);
        if (states == null) {
            states = new Object[aggregations.length];
            for (int i = 0; i &lt; aggregations.length; i++) {
                states[i] = inputs[i][0].value();
            }
            addWithAccounting(statesByKey, key, states);
        } else {
            for (int i = 0; i &lt; aggregations.length; i++) {
                states[i] = aggregations[i].reduce(ramAccounting, states[i], inputs[i][0].value());
            }
        }
    }

    private void addWithAccounting(Map&lt;K, Object[]&gt; statesByKey, K key, Object[] states) {
        accountForNewEntry.accept(statesByKey, key);
        statesByKey.put(key, states);
    }

    private void iter(Map&lt;K, Object[]&gt; statesByKey, Row row) {
        for (CollectExpression&lt;Row, ?&gt; expression : expressions) {
            expression.setNextRow(row);
        }
        K key = keyExtractor.apply(row);
        Object[] states = statesByKey.get(key);
        if (states == null) {
            addNewEntry(statesByKey, key);
        } else {
            for (int i = 0; i &lt; aggregations.length; i++) {
                if (InputCondition.matches(filters[i])) {
                    //noinspection unchecked
                    states[i] = aggregations[i].iterate(ramAccounting, memoryManager, states[i], inputs[i]);
                }
            }
        }
    }

    private void addNewEntry(Map&lt;K, Object[]&gt; statesByKey, K key) {
        Object[] states;
        states = new Object[aggregations.length];
        for (int i = 0; i &lt; aggregations.length; i++) {
            AggregationFunction aggregation = aggregations[i];

            var newState = aggregation.newState(ramAccounting, indexVersionCreated, minNodeVersion, memoryManager);
            if (InputCondition.matches(filters[i])) {
                //noinspection unchecked
                states[i] = aggregation.iterate(ramAccounting, memoryManager, newState, inputs[i]);
            } else {
                states[i] = newState;
            }
        }
        addWithAccounting(statesByKey, key, states);
    }

    private Iterable&lt;Row&gt; mapToRows(Map&lt;K, Object[]&gt; statesByKey) {

        return () -&gt; new Iterator&lt;&gt;() {
            final Iterator&lt;Map.Entry&lt;K, Object[]&gt;&gt; iterator = statesByKey.entrySet().iterator();
            final RowN row = new RowN(numKeyColumns + aggregations.length);
            final Object[] cells = new Object[row.numColumns()];

            {
                row.cells(cells);
            }

            @Override
            public boolean hasNext() {
                return iterator.hasNext();
            }

            @Override
            public Row next() {
                Map.Entry&lt;K, Object[]&gt; input = iterator.next();
                assert input != null : &quot;input must not be null&quot;;
                applyKeyToCells.accept(input.getKey(), cells);
                int c = numKeyColumns;
                Object[] states = input.getValue();
                for (int i = 0; i &lt; states.length; i++) {
                    cells[c] = mode.finishCollect(ramAccounting, aggregations[i], states[i]);
                    c++;
                }
                return row;
            }
        };
    }
}
</PRE>
</div>
  </div>
</body>
</html>
