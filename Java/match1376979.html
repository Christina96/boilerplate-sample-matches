<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for WhereClauseOptimizer.java &amp; GroupingCollector.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for WhereClauseOptimizer.java &amp; GroupingCollector.java
      </h3>
<h1 align="center">
        13.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>WhereClauseOptimizer.java (15.492958%)<th>GroupingCollector.java (12.4293785%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-48)<td><a href="#" name="0">(22-48)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(117-120)<td><a href="#" name="1">(141-144)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(68-76)<td><a href="#" name="2">(69-77)</a><td align="center"><font color="#5b0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WhereClauseOptimizer.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.planner;
2 import io.crate.analyze.GeneratedColumnExpander;
3 import io.crate.analyze.WhereClause;
4 import io.crate.analyze.where.DocKeys;
5 import io.crate.analyze.where.EqualityExtractor;
6 import io.crate.analyze.where.WhereClauseAnalyzer;
7 import io.crate.analyze.where.WhereClauseValidator;
8 import io.crate.common.collections.Lists2;
9 import io.crate.data.Row;
10 import io.crate.expression.eval.EvaluatingNormalizer;
11 import io.crate.expression.symbol.Symbol;
12 import io.crate.expression.symbol.Symbols;
13 import io.crate.metadata.ColumnIdent;
14 import io.crate.metadata.CoordinatorTxnCtx;
15 import io.crate.metadata.NodeContext;
16 import io.crate.metadata.TransactionContext;
17 import io.crate.metadata.doc.DocSysColumns;
18 import io.crate.metadata.doc.DocTableInfo;
19 import io.crate.planner.operators.SubQueryAndParamBinder;
20 import io.crate.planner.operators.SubQueryResults;
21 import java.util.ArrayList;
22 import java.util.Collections;
23 import java.util.HashSet;
24 import java.util.List;
25 import</b></font> java.util.Objects;
26 import java.util.Optional;
27 import java.util.Set;
28 public final class WhereClauseOptimizer {
29     private WhereClauseOptimizer() {
30     }
31 <a name="2"></a>
32     public static class DetailedQuery {
33         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private final Symbol query;
34         private final DocKeys docKeys;
35         private final List&lt;List&lt;Symbol&gt;&gt; partitions;
36         private final Set&lt;Symbol&gt; clusteredByValues;
37         DetailedQuery(Symbol query,
38                       DocKeys docKeys,
39                       List&lt;List&lt;Symbol&gt;&gt; partitionValues,
40                       Set&lt;Symbol&gt; clusteredByValues</b></font>) {
41             this.query = query;
42             this.docKeys = docKeys;
43             this.partitions = Objects.requireNonNullElse(partitionValues, Collections.emptyList());
44             this.clusteredByValues = clusteredByValues;
45         }
46         public Optional&lt;DocKeys&gt; docKeys() {
47             return Optional.ofNullable(docKeys);
48         }
49         public List&lt;List&lt;Symbol&gt;&gt; partitions() {
50             return partitions;
51         }
52         public Symbol query() {
53             return query;
54         }
55         public Set&lt;Symbol&gt; clusteredBy() {
56             return clusteredByValues;
57         }
58         public WhereClause toBoundWhereClause(DocTableInfo table,
59                                               Row params,
60                                               SubQueryResults subQueryResults,
61                                               CoordinatorTxnCtx txnCtx,
62                                               NodeContext nodeCtx) {
63             if (docKeys != null) {
64                 throw new IllegalStateException(getClass().getSimpleName()
65                                                 + " must not be converted to a WhereClause if docKeys are present");
66 <a name="1"></a>            }
67             SubQueryAndParamBinder binder = new SubQueryAndParamBinder(params, subQueryResults);
68             Symbol boundQuery = binder.apply(query);
69             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>HashSet&lt;Symbol&gt; clusteredBy = new HashSet&lt;&gt;(clusteredByValues.size());
70             for (Symbol clusteredByValue : clusteredByValues) {
71                 clusteredBy.add(binder.apply(clusteredByValue));
72             }</b></font>
73             if (table.isPartitioned()) {
74                 if (table.partitions().isEmpty()) {
75                     return WhereClause.NO_MATCH;
76                 }
77                 WhereClauseAnalyzer.PartitionResult partitionResult =
78                     WhereClauseAnalyzer.resolvePartitions(boundQuery, table, txnCtx, nodeCtx);
79                 return new WhereClause(
80                     partitionResult.query,
81                     partitionResult.partitions,
82                     clusteredBy
83                 );
84             } else {
85                 return new WhereClause(
86                     boundQuery,
87                     Collections.emptyList(),
88                     clusteredBy
89                 );
90             }
91         }
92     }
93     public static DetailedQuery optimize(EvaluatingNormalizer normalizer,
94                                          Symbol query,
95                                          DocTableInfo table,
96                                          TransactionContext txnCtx,
97                                          NodeContext nodeCtx) {
98         Symbol queryGenColsProcessed = GeneratedColumnExpander.maybeExpand(
99             query,
100             table.generatedColumns(),
101             Lists2.concat(table.partitionedByColumns(), Lists2.map(table.primaryKey(), table::getReference)),
102             nodeCtx);
103         if (!query.equals(queryGenColsProcessed)) {
104             query = normalizer.normalize(queryGenColsProcessed, txnCtx);
105         }
106         WhereClause.validateVersioningColumnsUsage(query);
107         boolean versionInQuery = Symbols.containsColumn(query, DocSysColumns.VERSION);
108         boolean sequenceVersioningInQuery = Symbols.containsColumn(query, DocSysColumns.SEQ_NO) &amp;&amp;
109                                             Symbols.containsColumn(query, DocSysColumns.PRIMARY_TERM);
110         List&lt;ColumnIdent&gt; pkCols = pkColsInclVersioning(table, versionInQuery, sequenceVersioningInQuery);
111         EqualityExtractor eqExtractor = new EqualityExtractor(normalizer);
112         List&lt;List&lt;Symbol&gt;&gt; pkValues = eqExtractor.extractExactMatches(pkCols, query, txnCtx);
113         int clusterIdxWithinPK = table.primaryKey().indexOf(table.clusteredBy());
114         final DocKeys docKeys;
115         if (pkValues == null) {
116             docKeys = null;
117         } else {
118             List&lt;Integer&gt; partitionIndicesWithinPks = null;
119             if (table.isPartitioned()) {
120                 partitionIndicesWithinPks = getPartitionIndices(table.primaryKey(), table.partitionedBy());
121             }
122             docKeys = new DocKeys(pkValues,
123                                   versionInQuery,
124                                   sequenceVersioningInQuery,
125                                   clusterIdxWithinPK,
126                                   partitionIndicesWithinPks);
127         }
128         List&lt;List&lt;Symbol&gt;&gt; partitionValues = null;
129         if (table.isPartitioned()) {
130             partitionValues = eqExtractor.extractExactMatches(table.partitionedBy(), query, txnCtx);
131         }
132         Set&lt;Symbol&gt; clusteredBy = Collections.emptySet();
133         if (table.clusteredBy() != null) {
134             List&lt;List&lt;Symbol&gt;&gt; clusteredByValues = eqExtractor.extractParentMatches(
135                 Collections.singletonList(table.clusteredBy()), query, txnCtx);
136             if (clusteredByValues != null) {
137                 clusteredBy = new HashSet&lt;&gt;(clusteredByValues.size());
138                 for (List&lt;Symbol&gt; s : clusteredByValues) {
139                     clusteredBy.add(s.get(0));
140                 }
141             }
142         }
143         WhereClauseValidator.validate(query);
144         return new DetailedQuery(query, docKeys, partitionValues, clusteredBy);
145     }
146     public static List&lt;Integer&gt; getPartitionIndices(List&lt;ColumnIdent&gt; pkCols, List&lt;ColumnIdent&gt; partitionCols) {
147         ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(partitionCols.size());
148         for (int i = 0; i &lt; partitionCols.size(); i++) {
149             ColumnIdent partitionCol = partitionCols.get(i);
150             int partColIdxInPks = pkCols.indexOf(partitionCol);
151             if (partColIdxInPks &gt;= 0) {
152                 result.add(partColIdxInPks);
153             }
154         }
155         return result;
156     }
157     private static List&lt;ColumnIdent&gt; pkColsInclVersioning(DocTableInfo table,
158                                                           boolean versionInQuery,
159                                                           boolean seqNoAndPrimaryTermInQuery) {
160         if (versionInQuery) {
161             ArrayList&lt;ColumnIdent&gt; pkCols = new ArrayList&lt;&gt;(table.primaryKey().size() + 1);
162             pkCols.addAll(table.primaryKey());
163             pkCols.add(DocSysColumns.VERSION);
164             return pkCols;
165         } else if (seqNoAndPrimaryTermInQuery) {
166             ArrayList&lt;ColumnIdent&gt; pkCols = new ArrayList&lt;&gt;(table.primaryKey().size() + 1);
167             pkCols.addAll(table.primaryKey());
168             pkCols.add(DocSysColumns.SEQ_NO);
169             pkCols.add(DocSysColumns.PRIMARY_TERM);
170             return pkCols;
171         }
172         return table.primaryKey();
173     }
174 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>GroupingCollector.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.execution.engine.aggregation;
2 import io.crate.breaker.MultiSizeEstimator;
3 import io.crate.breaker.RamAccounting;
4 import io.crate.breaker.SizeEstimatorFactory;
5 import io.crate.data.Input;
6 import io.crate.data.Row;
7 import io.crate.data.RowN;
8 import io.crate.execution.engine.collect.CollectExpression;
9 import io.crate.expression.InputCondition;
10 import io.crate.expression.symbol.AggregateMode;
11 import io.crate.memory.MemoryManager;
12 import io.crate.types.DataType;
13 import org.elasticsearch.Version;
14 import java.util.ArrayList;
15 import java.util.Collections;
16 import java.util.HashMap;
17 import java.util.List;
18 import java.util.Map;
19 import java.util.Set;
20 import java.util.Iterator;
21 import java.util.function.BiConsumer;
22 import java.util.function.BinaryOperator;
23 import java.util.function.Function;
24 import java.util.function.Supplier;
25 import</b></font> java.util.stream.Collector;
26 public class GroupingCollector&lt;K&gt; implements Collector&lt;Row, Map&lt;K, Object[]&gt;, Iterable&lt;Row&gt;&gt; {
27     private final CollectExpression&lt;Row, ?&gt;[] expressions;
28     private final AggregationFunction[] aggregations;
29     private final AggregateMode mode;
30     private final Input[][] inputs;
31     private final Input&lt;Boolean&gt;[] filters;
32     private final RamAccounting ramAccounting;
33     private final MemoryManager memoryManager;
34     private final BiConsumer&lt;K, Object[]&gt; applyKeyToCells;
35 <a name="2"></a>    private final int numKeyColumns;
36     private final BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewEntry;
37     private final Function&lt;Row, K&gt; keyExtractor;
38     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private final Version indexVersionCreated;
39     private final BiConsumer&lt;Map&lt;K, Object[]&gt;, Row&gt; accumulator;
40     private final Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier;
41     private final Version minNodeVersion;
42     static GroupingCollector&lt;Object&gt; singleKey(CollectExpression&lt;Row, ?&gt;[] expressions,
43                                                AggregateMode mode,
44                                                AggregationFunction[] aggregations,
45                                                Input[][] inputs</b></font>,
46                                                Input&lt;Boolean&gt;[] filters,
47                                                RamAccounting ramAccounting,
48                                                MemoryManager memoryManager,
49                                                Version minNodeVersion,
50                                                Input&lt;?&gt; keyInput,
51                                                DataType keyType,
52                                                Version indexVersionCreated) {
53         return new GroupingCollector&lt;&gt;(
54             expressions,
55             aggregations,
56             mode,
57             inputs,
58             filters,
59             ramAccounting,
60             memoryManager,
61             minNodeVersion,
62             (key, cells) -&gt; cells[0] = key,
63             1,
64             GroupByMaps.accountForNewEntry(
65                 ramAccounting,
66                 SizeEstimatorFactory.create(keyType),
67                 keyType
68             ),
69             row -&gt; keyInput.value(),
70             indexVersionCreated,
71             GroupByMaps.mapForType(keyType)
72         );
73     }
74     static GroupingCollector&lt;List&lt;Object&gt;&gt; manyKeys(CollectExpression&lt;Row, ?&gt;[] expressions,
75                                                     AggregateMode mode,
76                                                     AggregationFunction[] aggregations,
77                                                     Input[][] inputs,
78                                                     Input&lt;Boolean&gt;[] filters,
79                                                     RamAccounting ramAccountingContext,
80                                                     MemoryManager memoryManager,
81                                                     Version minNodeVersion,
82                                                     List&lt;Input&lt;?&gt;&gt; keyInputs,
83                                                     List&lt;? extends DataType&gt; keyTypes,
84                                                     Version indexVersionCreated) {
85         return new GroupingCollector&lt;&gt;(
86             expressions,
87             aggregations,
88             mode,
89             inputs,
90             filters,
91             ramAccountingContext,
92             memoryManager,
93             minNodeVersion,
94             GroupingCollector::applyKeysToCells,
95             keyInputs.size(),
96             GroupByMaps.accountForNewEntry(
97                 ramAccountingContext,
98                 new MultiSizeEstimator(keyTypes),
99                 null
100             ),
101             row -&gt; evalKeyInputs(keyInputs),
102             indexVersionCreated,
103             HashMap::new
104         );
105 <a name="1"></a>    }
106     private static List&lt;Object&gt; evalKeyInputs(List&lt;Input&lt;?&gt;&gt; keyInputs) {
107         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>List&lt;Object&gt; key = new ArrayList&lt;&gt;(keyInputs.size());
108         for (Input&lt;?&gt; keyInput : keyInputs) {
109             key.add(keyInput.value());
110         }</b></font>
111         return key;
112     }
113     private static void applyKeysToCells(List&lt;Object&gt; keys, Object[] cells) {
114         for (int i = 0; i &lt; keys.size(); i++) {
115             cells[i] = keys.get(i);
116         }
117     }
118     private GroupingCollector(CollectExpression&lt;Row, ?&gt;[] expressions,
119                               AggregationFunction[] aggregations,
120                               AggregateMode mode,
121                               Input[][] inputs,
122                               Input&lt;Boolean&gt;[] filters,
123                               RamAccounting ramAccounting,
124                               MemoryManager memoryManager,
125                               Version minNodeVersion,
126                               BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
127                               int numKeyColumns,
128                               BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewEntry,
129                               Function&lt;Row, K&gt; keyExtractor,
130                               Version indexVersionCreated,
131                               Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier) {
132         this.expressions = expressions;
133         this.aggregations = aggregations;
134         this.mode = mode;
135         this.inputs = inputs;
136         this.filters = filters;
137         this.ramAccounting = ramAccounting;
138         this.memoryManager = memoryManager;
139         this.applyKeyToCells = applyKeyToCells;
140         this.numKeyColumns = numKeyColumns;
141         this.accountForNewEntry = accountForNewEntry;
142         this.keyExtractor = keyExtractor;
143         this.indexVersionCreated = indexVersionCreated;
144         this.accumulator = mode == AggregateMode.PARTIAL_FINAL ? this::reduce : this::iter;
145         this.supplier = supplier;
146         this.minNodeVersion = minNodeVersion;
147     }
148     @Override
149     public Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier() {
150         return supplier;
151     }
152     @Override
153     public BiConsumer&lt;Map&lt;K, Object[]&gt;, Row&gt; accumulator() {
154         return accumulator;
155     }
156     @Override
157     public BinaryOperator&lt;Map&lt;K, Object[]&gt;&gt; combiner() {
158         return (state1, state2) -&gt; {
159             throw new UnsupportedOperationException("combine not supported");
160         };
161     }
162     @Override
163     public Function&lt;Map&lt;K, Object[]&gt;, Iterable&lt;Row&gt;&gt; finisher() {
164         return this::mapToRows;
165     }
166     @Override
167     public Set&lt;Characteristics&gt; characteristics() {
168         return Collections.emptySet();
169     }
170     private void reduce(Map&lt;K, Object[]&gt; statesByKey, Row row) {
171         for (CollectExpression&lt;Row, ?&gt; expression : expressions) {
172             expression.setNextRow(row);
173         }
174         K key = keyExtractor.apply(row);
175         Object[] states = statesByKey.get(key);
176         if (states == null) {
177             states = new Object[aggregations.length];
178             for (int i = 0; i &lt; aggregations.length; i++) {
179                 states[i] = inputs[i][0].value();
180             }
181             addWithAccounting(statesByKey, key, states);
182         } else {
183             for (int i = 0; i &lt; aggregations.length; i++) {
184                 states[i] = aggregations[i].reduce(ramAccounting, states[i], inputs[i][0].value());
185             }
186         }
187     }
188     private void addWithAccounting(Map&lt;K, Object[]&gt; statesByKey, K key, Object[] states) {
189         accountForNewEntry.accept(statesByKey, key);
190         statesByKey.put(key, states);
191     }
192     private void iter(Map&lt;K, Object[]&gt; statesByKey, Row row) {
193         for (CollectExpression&lt;Row, ?&gt; expression : expressions) {
194             expression.setNextRow(row);
195         }
196         K key = keyExtractor.apply(row);
197         Object[] states = statesByKey.get(key);
198         if (states == null) {
199             addNewEntry(statesByKey, key);
200         } else {
201             for (int i = 0; i &lt; aggregations.length; i++) {
202                 if (InputCondition.matches(filters[i])) {
203                     //noinspection unchecked
204                     states[i] = aggregations[i].iterate(ramAccounting, memoryManager, states[i], inputs[i]);
205                 }
206             }
207         }
208     }
209     private void addNewEntry(Map&lt;K, Object[]&gt; statesByKey, K key) {
210         Object[] states;
211         states = new Object[aggregations.length];
212         for (int i = 0; i &lt; aggregations.length; i++) {
213             AggregationFunction aggregation = aggregations[i];
214             var newState = aggregation.newState(ramAccounting, indexVersionCreated, minNodeVersion, memoryManager);
215             if (InputCondition.matches(filters[i])) {
216                 //noinspection unchecked
217                 states[i] = aggregation.iterate(ramAccounting, memoryManager, newState, inputs[i]);
218             } else {
219                 states[i] = newState;
220             }
221         }
222         addWithAccounting(statesByKey, key, states);
223     }
224     private Iterable&lt;Row&gt; mapToRows(Map&lt;K, Object[]&gt; statesByKey) {
225         return () -&gt; new Iterator&lt;&gt;() {
226             final Iterator&lt;Map.Entry&lt;K, Object[]&gt;&gt; iterator = statesByKey.entrySet().iterator();
227             final RowN row = new RowN(numKeyColumns + aggregations.length);
228             final Object[] cells = new Object[row.numColumns()];
229             {
230                 row.cells(cells);
231             }
232             @Override
233             public boolean hasNext() {
234                 return iterator.hasNext();
235             }
236             @Override
237             public Row next() {
238                 Map.Entry&lt;K, Object[]&gt; input = iterator.next();
239                 assert input != null : "input must not be null";
240                 applyKeyToCells.accept(input.getKey(), cells);
241                 int c = numKeyColumns;
242                 Object[] states = input.getValue();
243                 for (int i = 0; i &lt; states.length; i++) {
244                     cells[c] = mode.finishCollect(ramAccounting, aggregations[i], states[i]);
245                     c++;
246                 }
247                 return row;
248             }
249         };
250     }
251 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
