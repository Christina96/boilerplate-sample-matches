<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for WhereClauseOptimizer.java &amp; GroupingCollector.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for WhereClauseOptimizer.java &amp; GroupingCollector.java
      </h3>
<h1 align="center">
        13.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>WhereClauseOptimizer.java (15.492958%)<th>GroupingCollector.java (12.4293785%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-48)<td><a href="#" name="0">(22-48)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(117-120)<td><a href="#" name="1">(141-144)</a><td align="center"><font color="#660000">10</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(68-76)<td><a href="#" name="2">(69-77)</a><td align="center"><font color="#5b0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>WhereClauseOptimizer.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.planner;

import io.crate.analyze.GeneratedColumnExpander;
import io.crate.analyze.WhereClause;
import io.crate.analyze.where.DocKeys;
import io.crate.analyze.where.EqualityExtractor;
import io.crate.analyze.where.WhereClauseAnalyzer;
import io.crate.analyze.where.WhereClauseValidator;
import io.crate.common.collections.Lists2;
import io.crate.data.Row;
import io.crate.expression.eval.EvaluatingNormalizer;
import io.crate.expression.symbol.Symbol;
import io.crate.expression.symbol.Symbols;
import io.crate.metadata.ColumnIdent;
import io.crate.metadata.CoordinatorTxnCtx;
import io.crate.metadata.NodeContext;
import io.crate.metadata.TransactionContext;
import io.crate.metadata.doc.DocSysColumns;
import io.crate.metadata.doc.DocTableInfo;
import io.crate.planner.operators.SubQueryAndParamBinder;
import io.crate.planner.operators.SubQueryResults;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import</b></font> java.util.Objects;
import java.util.Optional;
import java.util.Set;

/**
 * Used to analyze a query for primaryKey/partition "direct access" possibilities.
 *
 * This is similar to {@link io.crate.analyze.where.WhereClauseAnalyzer} - the difference is that this works also if
 * the query still contains ParameterSymbols.
 *
 * Once all Analyzers are migrated to be "unbound",
 * the WhereClauseAnalyzer should be removed (or reworked, to just do the final partition selection / tie-breaking)
 */
public final class WhereClauseOptimizer {

    private WhereClauseOptimizer() {
    }
<a name="2"></a>
    public static class DetailedQuery {

        <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>private final Symbol query;
        private final DocKeys docKeys;
        private final List&lt;List&lt;Symbol&gt;&gt; partitions;
        private final Set&lt;Symbol&gt; clusteredByValues;

        DetailedQuery(Symbol query,
                      DocKeys docKeys,
                      List&lt;List&lt;Symbol&gt;&gt; partitionValues,
                      Set&lt;Symbol&gt; clusteredByValues</b></font>) {
            this.query = query;
            this.docKeys = docKeys;
            this.partitions = Objects.requireNonNullElse(partitionValues, Collections.emptyList());
            this.clusteredByValues = clusteredByValues;
        }

        public Optional&lt;DocKeys&gt; docKeys() {
            return Optional.ofNullable(docKeys);
        }

        /**
         * @return Symbols "pointing" to the values of any `partition_col = S` expressions:
         *         The outer list contains 1 entry per "equals pair" (e.g. `pcol = ? or pcol = ?` -&gt; 2 entries
         *
         *         The inner list contains 1 entry per partitioned by column.
         *         The order matches the order of the partitioned by column definition.
         */
        public List&lt;List&lt;Symbol&gt;&gt; partitions() {
            return partitions;
        }

        public Symbol query() {
            return query;
        }

        public Set&lt;Symbol&gt; clusteredBy() {
            return clusteredByValues;
        }

        public WhereClause toBoundWhereClause(DocTableInfo table,
                                              Row params,
                                              SubQueryResults subQueryResults,
                                              CoordinatorTxnCtx txnCtx,
                                              NodeContext nodeCtx) {
            if (docKeys != null) {
                throw new IllegalStateException(getClass().getSimpleName()
                                                + " must not be converted to a WhereClause if docKeys are present");
<a name="1"></a>            }
            SubQueryAndParamBinder binder = new SubQueryAndParamBinder(params, subQueryResults);
            Symbol boundQuery = binder.apply(query);
            <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>HashSet&lt;Symbol&gt; clusteredBy = new HashSet&lt;&gt;(clusteredByValues.size());
            for (Symbol clusteredByValue : clusteredByValues) {
                clusteredBy.add(binder.apply(clusteredByValue));
            }</b></font>
            if (table.isPartitioned()) {
                if (table.partitions().isEmpty()) {
                    return WhereClause.NO_MATCH;
                }
                WhereClauseAnalyzer.PartitionResult partitionResult =
                    WhereClauseAnalyzer.resolvePartitions(boundQuery, table, txnCtx, nodeCtx);
                return new WhereClause(
                    partitionResult.query,
                    partitionResult.partitions,
                    clusteredBy
                );
            } else {
                return new WhereClause(
                    boundQuery,
                    Collections.emptyList(),
                    clusteredBy
                );
            }
        }
    }

    public static DetailedQuery optimize(EvaluatingNormalizer normalizer,
                                         Symbol query,
                                         DocTableInfo table,
                                         TransactionContext txnCtx,
                                         NodeContext nodeCtx) {
        Symbol queryGenColsProcessed = GeneratedColumnExpander.maybeExpand(
            query,
            table.generatedColumns(),
            Lists2.concat(table.partitionedByColumns(), Lists2.map(table.primaryKey(), table::getReference)),
            nodeCtx);
        if (!query.equals(queryGenColsProcessed)) {
            query = normalizer.normalize(queryGenColsProcessed, txnCtx);
        }
        WhereClause.validateVersioningColumnsUsage(query);

        boolean versionInQuery = Symbols.containsColumn(query, DocSysColumns.VERSION);
        boolean sequenceVersioningInQuery = Symbols.containsColumn(query, DocSysColumns.SEQ_NO) &amp;&amp;
                                            Symbols.containsColumn(query, DocSysColumns.PRIMARY_TERM);
        List&lt;ColumnIdent&gt; pkCols = pkColsInclVersioning(table, versionInQuery, sequenceVersioningInQuery);

        EqualityExtractor eqExtractor = new EqualityExtractor(normalizer);
        List&lt;List&lt;Symbol&gt;&gt; pkValues = eqExtractor.extractExactMatches(pkCols, query, txnCtx);

        int clusterIdxWithinPK = table.primaryKey().indexOf(table.clusteredBy());
        final DocKeys docKeys;
        if (pkValues == null) {
            docKeys = null;
        } else {
            List&lt;Integer&gt; partitionIndicesWithinPks = null;
            if (table.isPartitioned()) {
                partitionIndicesWithinPks = getPartitionIndices(table.primaryKey(), table.partitionedBy());
            }
            docKeys = new DocKeys(pkValues,
                                  versionInQuery,
                                  sequenceVersioningInQuery,
                                  clusterIdxWithinPK,
                                  partitionIndicesWithinPks);
        }
        List&lt;List&lt;Symbol&gt;&gt; partitionValues = null;
        if (table.isPartitioned()) {
            partitionValues = eqExtractor.extractExactMatches(table.partitionedBy(), query, txnCtx);
        }
        Set&lt;Symbol&gt; clusteredBy = Collections.emptySet();
        if (table.clusteredBy() != null) {
            List&lt;List&lt;Symbol&gt;&gt; clusteredByValues = eqExtractor.extractParentMatches(
                Collections.singletonList(table.clusteredBy()), query, txnCtx);
            if (clusteredByValues != null) {
                clusteredBy = new HashSet&lt;&gt;(clusteredByValues.size());
                for (List&lt;Symbol&gt; s : clusteredByValues) {
                    clusteredBy.add(s.get(0));
                }
            }
        }
        WhereClauseValidator.validate(query);
        return new DetailedQuery(query, docKeys, partitionValues, clusteredBy);
    }

    public static List&lt;Integer&gt; getPartitionIndices(List&lt;ColumnIdent&gt; pkCols, List&lt;ColumnIdent&gt; partitionCols) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(partitionCols.size());
        for (int i = 0; i &lt; partitionCols.size(); i++) {
            ColumnIdent partitionCol = partitionCols.get(i);
            int partColIdxInPks = pkCols.indexOf(partitionCol);
            if (partColIdxInPks &gt;= 0) {
                result.add(partColIdxInPks);
            }
        }
        return result;
    }

    private static List&lt;ColumnIdent&gt; pkColsInclVersioning(DocTableInfo table,
                                                          boolean versionInQuery,
                                                          boolean seqNoAndPrimaryTermInQuery) {
        if (versionInQuery) {
            ArrayList&lt;ColumnIdent&gt; pkCols = new ArrayList&lt;&gt;(table.primaryKey().size() + 1);
            pkCols.addAll(table.primaryKey());
            pkCols.add(DocSysColumns.VERSION);
            return pkCols;
        } else if (seqNoAndPrimaryTermInQuery) {
            ArrayList&lt;ColumnIdent&gt; pkCols = new ArrayList&lt;&gt;(table.primaryKey().size() + 1);
            pkCols.addAll(table.primaryKey());
            pkCols.add(DocSysColumns.SEQ_NO);
            pkCols.add(DocSysColumns.PRIMARY_TERM);
            return pkCols;
        }
        return table.primaryKey();
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>GroupingCollector.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Licensed to Crate.io GmbH ("Crate") under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  Crate licenses
 * this file to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * However, if you have executed another commercial license agreement
 * with Crate these terms will supersede the license and you may use the
<a name="0"></a> * software solely pursuant to the terms of the relevant commercial agreement.
 */

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.crate.execution.engine.aggregation;

import io.crate.breaker.MultiSizeEstimator;
import io.crate.breaker.RamAccounting;
import io.crate.breaker.SizeEstimatorFactory;
import io.crate.data.Input;
import io.crate.data.Row;
import io.crate.data.RowN;
import io.crate.execution.engine.collect.CollectExpression;
import io.crate.expression.InputCondition;
import io.crate.expression.symbol.AggregateMode;
import io.crate.memory.MemoryManager;
import io.crate.types.DataType;
import org.elasticsearch.Version;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Iterator;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import</b></font> java.util.stream.Collector;

/**
 * Collector implementation which uses {@link AggregateMode}s and {@code keyInputs}
 * to group rows by key and aggregate the grouped values.
 *
 * @param &lt;K&gt; type of the key
 */
public class GroupingCollector&lt;K&gt; implements Collector&lt;Row, Map&lt;K, Object[]&gt;, Iterable&lt;Row&gt;&gt; {

    private final CollectExpression&lt;Row, ?&gt;[] expressions;
    private final AggregationFunction[] aggregations;
    private final AggregateMode mode;
    private final Input[][] inputs;
    private final Input&lt;Boolean&gt;[] filters;
    private final RamAccounting ramAccounting;
    private final MemoryManager memoryManager;
    private final BiConsumer&lt;K, Object[]&gt; applyKeyToCells;
<a name="2"></a>    private final int numKeyColumns;
    private final BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewEntry;
    private final Function&lt;Row, K&gt; keyExtractor;
    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>private final Version indexVersionCreated;
    private final BiConsumer&lt;Map&lt;K, Object[]&gt;, Row&gt; accumulator;
    private final Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier;
    private final Version minNodeVersion;

    static GroupingCollector&lt;Object&gt; singleKey(CollectExpression&lt;Row, ?&gt;[] expressions,
                                               AggregateMode mode,
                                               AggregationFunction[] aggregations,
                                               Input[][] inputs</b></font>,
                                               Input&lt;Boolean&gt;[] filters,
                                               RamAccounting ramAccounting,
                                               MemoryManager memoryManager,
                                               Version minNodeVersion,
                                               Input&lt;?&gt; keyInput,
                                               DataType keyType,
                                               Version indexVersionCreated) {
        return new GroupingCollector&lt;&gt;(
            expressions,
            aggregations,
            mode,
            inputs,
            filters,
            ramAccounting,
            memoryManager,
            minNodeVersion,
            (key, cells) -&gt; cells[0] = key,
            1,
            GroupByMaps.accountForNewEntry(
                ramAccounting,
                SizeEstimatorFactory.create(keyType),
                keyType
            ),
            row -&gt; keyInput.value(),
            indexVersionCreated,
            GroupByMaps.mapForType(keyType)
        );
    }

    static GroupingCollector&lt;List&lt;Object&gt;&gt; manyKeys(CollectExpression&lt;Row, ?&gt;[] expressions,
                                                    AggregateMode mode,
                                                    AggregationFunction[] aggregations,
                                                    Input[][] inputs,
                                                    Input&lt;Boolean&gt;[] filters,
                                                    RamAccounting ramAccountingContext,
                                                    MemoryManager memoryManager,
                                                    Version minNodeVersion,
                                                    List&lt;Input&lt;?&gt;&gt; keyInputs,
                                                    List&lt;? extends DataType&gt; keyTypes,
                                                    Version indexVersionCreated) {
        return new GroupingCollector&lt;&gt;(
            expressions,
            aggregations,
            mode,
            inputs,
            filters,
            ramAccountingContext,
            memoryManager,
            minNodeVersion,
            GroupingCollector::applyKeysToCells,
            keyInputs.size(),
            GroupByMaps.accountForNewEntry(
                ramAccountingContext,
                new MultiSizeEstimator(keyTypes),
                null
            ),
            row -&gt; evalKeyInputs(keyInputs),
            indexVersionCreated,
            HashMap::new
        );
<a name="1"></a>    }

    private static List&lt;Object&gt; evalKeyInputs(List&lt;Input&lt;?&gt;&gt; keyInputs) {
        <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>List&lt;Object&gt; key = new ArrayList&lt;&gt;(keyInputs.size());
        for (Input&lt;?&gt; keyInput : keyInputs) {
            key.add(keyInput.value());
        }</b></font>
        return key;
    }

    private static void applyKeysToCells(List&lt;Object&gt; keys, Object[] cells) {
        for (int i = 0; i &lt; keys.size(); i++) {
            cells[i] = keys.get(i);
        }
    }

    private GroupingCollector(CollectExpression&lt;Row, ?&gt;[] expressions,
                              AggregationFunction[] aggregations,
                              AggregateMode mode,
                              Input[][] inputs,
                              Input&lt;Boolean&gt;[] filters,
                              RamAccounting ramAccounting,
                              MemoryManager memoryManager,
                              Version minNodeVersion,
                              BiConsumer&lt;K, Object[]&gt; applyKeyToCells,
                              int numKeyColumns,
                              BiConsumer&lt;Map&lt;K, Object[]&gt;, K&gt; accountForNewEntry,
                              Function&lt;Row, K&gt; keyExtractor,
                              Version indexVersionCreated,
                              Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier) {
        this.expressions = expressions;
        this.aggregations = aggregations;
        this.mode = mode;
        this.inputs = inputs;
        this.filters = filters;
        this.ramAccounting = ramAccounting;
        this.memoryManager = memoryManager;
        this.applyKeyToCells = applyKeyToCells;
        this.numKeyColumns = numKeyColumns;
        this.accountForNewEntry = accountForNewEntry;
        this.keyExtractor = keyExtractor;
        this.indexVersionCreated = indexVersionCreated;
        this.accumulator = mode == AggregateMode.PARTIAL_FINAL ? this::reduce : this::iter;
        this.supplier = supplier;
        this.minNodeVersion = minNodeVersion;
    }

    @Override
    public Supplier&lt;Map&lt;K, Object[]&gt;&gt; supplier() {
        return supplier;
    }

    @Override
    public BiConsumer&lt;Map&lt;K, Object[]&gt;, Row&gt; accumulator() {
        return accumulator;
    }

    @Override
    public BinaryOperator&lt;Map&lt;K, Object[]&gt;&gt; combiner() {
        return (state1, state2) -&gt; {
            throw new UnsupportedOperationException("combine not supported");
        };
    }

    @Override
    public Function&lt;Map&lt;K, Object[]&gt;, Iterable&lt;Row&gt;&gt; finisher() {
        return this::mapToRows;
    }

    @Override
    public Set&lt;Characteristics&gt; characteristics() {
        return Collections.emptySet();
    }

    private void reduce(Map&lt;K, Object[]&gt; statesByKey, Row row) {
        for (CollectExpression&lt;Row, ?&gt; expression : expressions) {
            expression.setNextRow(row);
        }
        K key = keyExtractor.apply(row);
        Object[] states = statesByKey.get(key);
        if (states == null) {
            states = new Object[aggregations.length];
            for (int i = 0; i &lt; aggregations.length; i++) {
                states[i] = inputs[i][0].value();
            }
            addWithAccounting(statesByKey, key, states);
        } else {
            for (int i = 0; i &lt; aggregations.length; i++) {
                states[i] = aggregations[i].reduce(ramAccounting, states[i], inputs[i][0].value());
            }
        }
    }

    private void addWithAccounting(Map&lt;K, Object[]&gt; statesByKey, K key, Object[] states) {
        accountForNewEntry.accept(statesByKey, key);
        statesByKey.put(key, states);
    }

    private void iter(Map&lt;K, Object[]&gt; statesByKey, Row row) {
        for (CollectExpression&lt;Row, ?&gt; expression : expressions) {
            expression.setNextRow(row);
        }
        K key = keyExtractor.apply(row);
        Object[] states = statesByKey.get(key);
        if (states == null) {
            addNewEntry(statesByKey, key);
        } else {
            for (int i = 0; i &lt; aggregations.length; i++) {
                if (InputCondition.matches(filters[i])) {
                    //noinspection unchecked
                    states[i] = aggregations[i].iterate(ramAccounting, memoryManager, states[i], inputs[i]);
                }
            }
        }
    }

    private void addNewEntry(Map&lt;K, Object[]&gt; statesByKey, K key) {
        Object[] states;
        states = new Object[aggregations.length];
        for (int i = 0; i &lt; aggregations.length; i++) {
            AggregationFunction aggregation = aggregations[i];

            var newState = aggregation.newState(ramAccounting, indexVersionCreated, minNodeVersion, memoryManager);
            if (InputCondition.matches(filters[i])) {
                //noinspection unchecked
                states[i] = aggregation.iterate(ramAccounting, memoryManager, newState, inputs[i]);
            } else {
                states[i] = newState;
            }
        }
        addWithAccounting(statesByKey, key, states);
    }

    private Iterable&lt;Row&gt; mapToRows(Map&lt;K, Object[]&gt; statesByKey) {

        return () -&gt; new Iterator&lt;&gt;() {
            final Iterator&lt;Map.Entry&lt;K, Object[]&gt;&gt; iterator = statesByKey.entrySet().iterator();
            final RowN row = new RowN(numKeyColumns + aggregations.length);
            final Object[] cells = new Object[row.numColumns()];

            {
                row.cells(cells);
            }

            @Override
            public boolean hasNext() {
                return iterator.hasNext();
            }

            @Override
            public Row next() {
                Map.Entry&lt;K, Object[]&gt; input = iterator.next();
                assert input != null : "input must not be null";
                applyKeyToCells.accept(input.getKey(), cells);
                int c = numKeyColumns;
                Object[] states = input.getValue();
                for (int i = 0; i &lt; states.length; i++) {
                    cells[c] = mode.finishCollect(ramAccounting, aggregations[i], states[i]);
                    c++;
                }
                return row;
            }
        };
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
