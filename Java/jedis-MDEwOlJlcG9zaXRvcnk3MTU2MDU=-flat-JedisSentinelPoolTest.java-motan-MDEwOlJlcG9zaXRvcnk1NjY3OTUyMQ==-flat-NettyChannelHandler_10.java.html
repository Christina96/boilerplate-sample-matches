
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.70464135021097%, Tokens: 13</h2>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-JedisSentinelPoolTest.java</h3>
            <pre><code>1  package redis.clients.jedis;
<span onclick='openModal()' class='match'>2  import static org.junit.Assert.assertEquals;
3  import static org.junit.Assert.assertTrue;
4  import static org.junit.Assert.assertSame;
5  import java.util.HashSet;
6  import java.util.Set;
7  import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
8  import org.junit.Before;
9  import org.junit.Test;
10  import redis.clients.jedis.exceptions.JedisConnectionException;
11  import redis.clients.jedis.exceptions.JedisException;
12  public class JedisSentinelPoolTest {
13    private static final String MASTER_NAME = "mymaster";
14    protected static final HostAndPort sentinel1 = HostAndPorts.getSentinelServers().get(1);
</span>15    protected static final HostAndPort sentinel2 = HostAndPorts.getSentinelServers().get(3);
16    protected final Set<String> sentinels = new HashSet<>();
17    @Before
18    public void setUp() throws Exception {
19      sentinels.clear();
20      sentinels.add(sentinel1.toString());
21      sentinels.add(sentinel2.toString());
22    }
23    @Test
24    public void repeatedSentinelPoolInitialization() {
25      for (int i = 0; i < 20; ++i) {
26        GenericObjectPoolConfig<Jedis> config = new GenericObjectPoolConfig<>();
27        JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels, config, 1000,
28            "foobared", 2);
29        pool.getResource().close();
30        pool.destroy();
31      }
32    }
33    @Test(expected = JedisConnectionException.class)
34    public void initializeWithNotAvailableSentinelsShouldThrowException() {
35      Set<String> wrongSentinels = new HashSet<String>();
36      wrongSentinels.add(new HostAndPort("localhost", 65432).toString());
37      wrongSentinels.add(new HostAndPort("localhost", 65431).toString());
38      JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, wrongSentinels);
39      pool.destroy();
40    }
41    @Test(expected = JedisException.class)
42    public void initializeWithNotMonitoredMasterNameShouldThrowException() {
43      final String wrongMasterName = "wrongMasterName";
44      JedisSentinelPool pool = new JedisSentinelPool(wrongMasterName, sentinels);
45      pool.destroy();
46    }
47    @Test
48    public void checkCloseableConnections() throws Exception {
49      GenericObjectPoolConfig<Jedis> config = new GenericObjectPoolConfig<>();
50      JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels, config, 1000,
51          "foobared", 2);
52      Jedis jedis = pool.getResource();
53      jedis.auth("foobared");
54      jedis.set("foo", "bar");
55      assertEquals("bar", jedis.get("foo"));
56      jedis.close();
57      pool.close();
58      assertTrue(pool.isClosed());
59    }
60    @Test
61    public void returnResourceShouldResetState() {
62      GenericObjectPoolConfig<Jedis> config = new GenericObjectPoolConfig<>();
63      config.setMaxTotal(1);
64      config.setBlockWhenExhausted(false);
65      try (JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels, config, 1000,
66          "foobared", 2)) {
67        Jedis jedis = null;
68        try (Jedis jedis1 = pool.getResource()) {
69          jedis = jedis1;
70          jedis1.set("hello", "jedis");
71          Transaction t = jedis1.multi();
72          t.set("hello", "world");
73        }
74        try (Jedis jedis2 = pool.getResource()) {
75          assertSame(jedis, jedis2);
76          assertEquals("jedis", jedis2.get("hello"));
77        }
78      }
79    }
80    @Test
81    public void checkResourceIsCloseable() {
82      GenericObjectPoolConfig<Jedis> config = new GenericObjectPoolConfig<>();
83      config.setMaxTotal(1);
84      config.setBlockWhenExhausted(false);
85      JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels, config, 1000,
86          "foobared", 2);
87      Jedis jedis = pool.getResource();
88      try {
89        jedis.set("hello", "jedis");
90      } finally {
91        jedis.close();
92      }
93      Jedis jedis2 = pool.getResource();
94      try {
95        assertEquals(jedis, jedis2);
96      } finally {
97        jedis2.close();
98      }
99    }
100    @Test
101    public void customClientName() {
102      GenericObjectPoolConfig<Jedis> config = new GenericObjectPoolConfig<>();
103      config.setMaxTotal(1);
104      config.setBlockWhenExhausted(false);
105      JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels, config, 1000,
106          "foobared", 0, "my_shiny_client_name");
107      Jedis jedis = pool.getResource();
108      try {
109        assertEquals("my_shiny_client_name", jedis.clientGetname());
110      } finally {
111        jedis.close();
112        pool.destroy();
113      }
114      assertTrue(pool.isClosed());
115    }
116  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyChannelHandler_10.java</h3>
            <pre><code>1  package com.weibo.api.motan.transport.netty4;
2  import com.weibo.api.motan.codec.Codec;
3  import com.weibo.api.motan.common.MotanConstants;
4  import com.weibo.api.motan.common.URLParamType;
5  import com.weibo.api.motan.core.extension.ExtensionLoader;
6  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
7  import com.weibo.api.motan.exception.MotanFrameworkException;
8  import com.weibo.api.motan.exception.MotanServiceException;
9  import com.weibo.api.motan.protocol.rpc.RpcProtocolVersion;
10  import com.weibo.api.motan.rpc.DefaultResponse;
11  import com.weibo.api.motan.rpc.Request;
12  import com.weibo.api.motan.rpc.Response;
13  import com.weibo.api.motan.rpc.RpcContext;
14  import com.weibo.api.motan.transport.Channel;
15  import com.weibo.api.motan.transport.MessageHandler;
16  import com.weibo.api.motan.util.LoggerUtil;
<span onclick='openModal()' class='match'>17  import com.weibo.api.motan.util.MotanFrameworkUtil;
18  import com.weibo.api.motan.util.NetUtils;
19  import io.netty.channel.ChannelDuplexHandler;
20  import io.netty.channel.ChannelFuture;
21  import io.netty.channel.ChannelFutureListener;
22  import io.netty.channel.ChannelHandlerContext;
23  import java.net.InetSocketAddress;
24  import java.net.SocketAddress;
25  import java.util.concurrent.RejectedExecutionException;
26  import java.util.concurrent.ThreadPoolExecutor;
27  public class NettyChannelHandler extends ChannelDuplexHandler {
28      private ThreadPoolExecutor threadPoolExecutor;
29      private MessageHandler messageHandler;
</span>30      private Channel channel;
31      private Codec codec;
32      public NettyChannelHandler(Channel channel, MessageHandler messageHandler) {
33          this.channel = channel;
34          this.messageHandler = messageHandler;
35          codec = ExtensionLoader.getExtensionLoader(Codec.class).getExtension(channel.getUrl().getParameter(URLParamType.codec.getName(), URLParamType.codec.getValue()));
36      }
37      public NettyChannelHandler(Channel channel, MessageHandler messageHandler,
38                                 ThreadPoolExecutor threadPoolExecutor) {
39          this.channel = channel;
40          this.messageHandler = messageHandler;
41          this.threadPoolExecutor = threadPoolExecutor;
42          codec = ExtensionLoader.getExtensionLoader(Codec.class).getExtension(channel.getUrl().getParameter(URLParamType.codec.getName(), URLParamType.codec.getValue()));
43      }
44      private String getRemoteIp(ChannelHandlerContext ctx) {
45          String ip = "";
46          SocketAddress remote = ctx.channel().remoteAddress();
47          if (remote != null) {
48              try {
49                  ip = ((InetSocketAddress) remote).getAddress().getHostAddress();
50              } catch (Exception e) {
51                  LoggerUtil.warn("get remoteIp error! default will use. msg:{}, remote:{}", e.getMessage(), remote.toString());
52              }
53          }
54          return ip;
55      }
56      @Override
57      public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
58          if (msg instanceof NettyMessage) {
59              if (threadPoolExecutor != null) {
60                  try {
61                      threadPoolExecutor.execute(() -> processMessage(ctx, ((NettyMessage) msg)));
62                  } catch (RejectedExecutionException rejectException) {
63                      if (((NettyMessage) msg).isRequest()) {
64                          rejectMessage(ctx, (NettyMessage) msg);
65                      } else {
66                          LoggerUtil.warn("process thread pool is full, run in io thread, active={} poolSize={} corePoolSize={} maxPoolSize={} taskCount={} requestId={}",
67                                  threadPoolExecutor.getActiveCount(), threadPoolExecutor.getPoolSize(), threadPoolExecutor.getCorePoolSize(),
68                                  threadPoolExecutor.getMaximumPoolSize(), threadPoolExecutor.getTaskCount(), ((NettyMessage) msg).getRequestId());
69                          processMessage(ctx, (NettyMessage) msg);
70                      }
71                  }
72              } else {
73                  processMessage(ctx, (NettyMessage) msg);
74              }
75          } else {
76              LoggerUtil.error("NettyChannelHandler messageReceived type not support: class=" + msg.getClass());
77              throw new MotanFrameworkException("NettyChannelHandler messageReceived type not support: class=" + msg.getClass());
78          }
79      }
80      private void rejectMessage(ChannelHandlerContext ctx, NettyMessage msg) {
81          if (msg.isRequest()) {
82              sendResponse(ctx, MotanFrameworkUtil.buildErrorResponse(msg.getRequestId(), msg.getVersion().getVersion(), new MotanServiceException("process thread pool is full, reject by server: " + ctx.channel().localAddress(), MotanErrorMsgConstant.SERVICE_REJECT, false)));
83              LoggerUtil.error("process thread pool is full, reject, active={} poolSize={} corePoolSize={} maxPoolSize={} taskCount={} requestId={}",
84                      threadPoolExecutor.getActiveCount(), threadPoolExecutor.getPoolSize(), threadPoolExecutor.getCorePoolSize(),
85                      threadPoolExecutor.getMaximumPoolSize(), threadPoolExecutor.getTaskCount(), msg.getRequestId());
86              if (channel instanceof NettyServer) {
87                  ((NettyServer) channel).getRejectCounter().incrementAndGet();
88              }
89          }
90      }
91      private void processMessage(ChannelHandlerContext ctx, NettyMessage msg) {
92          long startTime = System.currentTimeMillis();
93          String remoteIp = getRemoteIp(ctx);
94          Object result;
95          try {
96              result = codec.decode(channel, remoteIp, msg.getData());
97          } catch (Exception e) {
98              LoggerUtil.error("NettyDecoder decode fail! requestId" + msg.getRequestId() + ", size:" + msg.getData().length + ", ip:" + remoteIp + ", e:" + e.getMessage());
99              Response response = MotanFrameworkUtil.buildErrorResponse(msg.getRequestId(), msg.getVersion().getVersion(), e);
100              if (msg.isRequest()) {
101                  sendResponse(ctx, response);
102              } else {
103                  processResponse(response);
104              }
105              return;
106          }
107          long length = msg.getData().length;
108          if (RpcProtocolVersion.VERSION_1 == msg.getVersion() || RpcProtocolVersion.VERSION_1_Compress == msg.getVersion()) {
109              length += RpcProtocolVersion.VERSION_1.getHeaderLength();
110          }
111          if (result instanceof Request) {
112              Request request = (Request) result;
113              MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_SRECEIVE, msg.getStartTime());
114              MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_SEXECUTOR_START, startTime);
115              MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_SDECODE);
116              request.setAttachment(MotanConstants.CONTENT_LENGTH, String.valueOf(length));
117              processRequest(ctx, request);
118          } else if (result instanceof Response) {
119              Response response = (Response) result;
120              MotanFrameworkUtil.logEvent(response, MotanConstants.TRACE_CRECEIVE, msg.getStartTime());
121              MotanFrameworkUtil.logEvent(response, MotanConstants.TRACE_CDECODE);
122              response.setAttachment(MotanConstants.CONTENT_LENGTH, String.valueOf(length));
123              processResponse(result);
124          }
125      }
126      private void processRequest(final ChannelHandlerContext ctx, final Request request) {
127          request.setAttachment(URLParamType.host.getName(), NetUtils.getHostName(ctx.channel().remoteAddress()));
128          final long processStartTime = System.currentTimeMillis();
129          try {
130              RpcContext.init(request);
131              Object result;
132              try {
133                  result = messageHandler.handle(channel, request);
134              } catch (Exception e) {
135                  LoggerUtil.error("NettyChannelHandler processRequest fail! request:" + MotanFrameworkUtil.toString(request), e);
136                  result = MotanFrameworkUtil.buildErrorResponse(request, new MotanServiceException("process request fail. errMsg:" + e.getMessage()));
137              }
138              if (result instanceof Response) {
139                  MotanFrameworkUtil.logEvent((Response) result, MotanConstants.TRACE_PROCESS);
140              }
141              final DefaultResponse response;
142              if (result instanceof DefaultResponse) {
143                  response = (DefaultResponse) result;
144              } else {
145                  response = new DefaultResponse(result);
146              }
147              response.setRpcProtocolVersion(request.getRpcProtocolVersion());
148              response.setRequestId(request.getRequestId());
149              response.setProcessTime(System.currentTimeMillis() - processStartTime);
150              ChannelFuture channelFuture = sendResponse(ctx, response);
151              if (channelFuture != null) {
152                  channelFuture.addListener((ChannelFutureListener) future -> {
153                      MotanFrameworkUtil.logEvent(response, MotanConstants.TRACE_SSEND, System.currentTimeMillis());
154                      response.onFinish();
155                  });
156              } else { 
157                  response.onFinish();
158              }
159          } finally {
160              RpcContext.destroy();
161          }
162      }
163      private ChannelFuture sendResponse(ChannelHandlerContext ctx, Response response) {
164          byte[] msg = CodecUtil.encodeObjectToBytes(channel, codec, response);
165          response.setAttachment(MotanConstants.CONTENT_LENGTH, String.valueOf(msg.length));
166          if (ctx.channel().isActive()) {
167              return ctx.channel().writeAndFlush(msg);
168          }
169          return null;
170      }
171      private void processResponse(Object msg) {
172          messageHandler.handle(channel, msg);
173      }
174      @Override
175      public void channelActive(ChannelHandlerContext ctx) throws Exception {
176          LoggerUtil.info("NettyChannelHandler channelActive: remote={} local={}", ctx.channel().remoteAddress(), ctx.channel().localAddress());
177          ctx.fireChannelActive();
178      }
179      @Override
180      public void channelInactive(ChannelHandlerContext ctx) throws Exception {
181          LoggerUtil.info("NettyChannelHandler channelInactive: remote={} local={}", ctx.channel().remoteAddress(), ctx.channel().localAddress());
182          ctx.fireChannelInactive();
183      }
184      @Override
185      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
186          LoggerUtil.error("NettyChannelHandler exceptionCaught: remote={} local={} event={}", ctx.channel().remoteAddress(), ctx.channel().localAddress(), cause.getMessage(), cause);
187          ctx.channel().close();
188      }
189  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-JedisSentinelPoolTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyChannelHandler_10.java</div>
                </div>
                <div class="column column_space"><pre><code>2  import static org.junit.Assert.assertEquals;
3  import static org.junit.Assert.assertTrue;
4  import static org.junit.Assert.assertSame;
5  import java.util.HashSet;
6  import java.util.Set;
7  import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
8  import org.junit.Before;
9  import org.junit.Test;
10  import redis.clients.jedis.exceptions.JedisConnectionException;
11  import redis.clients.jedis.exceptions.JedisException;
12  public class JedisSentinelPoolTest {
13    private static final String MASTER_NAME = "mymaster";
14    protected static final HostAndPort sentinel1 = HostAndPorts.getSentinelServers().get(1);
</pre></code></div>
                <div class="column column_space"><pre><code>17  import com.weibo.api.motan.util.MotanFrameworkUtil;
18  import com.weibo.api.motan.util.NetUtils;
19  import io.netty.channel.ChannelDuplexHandler;
20  import io.netty.channel.ChannelFuture;
21  import io.netty.channel.ChannelFutureListener;
22  import io.netty.channel.ChannelHandlerContext;
23  import java.net.InetSocketAddress;
24  import java.net.SocketAddress;
25  import java.util.concurrent.RejectedExecutionException;
26  import java.util.concurrent.ThreadPoolExecutor;
27  public class NettyChannelHandler extends ChannelDuplexHandler {
28      private ThreadPoolExecutor threadPoolExecutor;
29      private MessageHandler messageHandler;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    