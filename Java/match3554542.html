<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TypeSignaturesASTVisitor.java &amp; CancelAllocationCommand.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TypeSignaturesASTVisitor.java &amp; CancelAllocationCommand.java
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TypeSignaturesASTVisitor.java (7.1770334%)<th>CancelAllocationCommand.java (4.8076925%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-39)<td><a href="#" name="0">(20-35)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TypeSignaturesASTVisitor.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.crate.signatures;
2 import java.util.ArrayList;
3 import java.util.List;
4 import javax.annotation.Nullable;
5 import io.crate.types.ArrayType;
6 import io.crate.types.DataTypes;
7 import io.crate.types.IntegerLiteralTypeSignature;
8 import io.crate.types.ObjectType;
9 import io.crate.types.ParameterTypeSignature;
10 import io.crate.types.RowType;
11 import io.crate.types.TimeTZType;
12 import io.crate.types.TimestampType;
13 import io.crate.types.TypeSignature;
14 import io.crate.signatures.antlr.TypeSignaturesBaseVisitor;
15 import</b></font> io.crate.signatures.antlr.TypeSignaturesParser;
16 class TypeSignaturesASTVisitor extends TypeSignaturesBaseVisitor&lt;TypeSignature&gt; {
17     @Override
18     public TypeSignature visitDoublePrecision(TypeSignaturesParser.DoublePrecisionContext context) {
19         return new TypeSignature(DataTypes.DOUBLE.getName(), List.of());
20     }
21     @Override
22     public TypeSignature visitTimeStampWithoutTimeZone(TypeSignaturesParser.TimeStampWithoutTimeZoneContext context) {
23         return new TypeSignature(TimestampType.INSTANCE_WITHOUT_TZ.getName(), List.of());
24     }
25     @Override
26     public TypeSignature visitTimeStampWithTimeZone(TypeSignaturesParser.TimeStampWithTimeZoneContext context) {
27         return new TypeSignature(TimestampType.INSTANCE_WITH_TZ.getName(), List.of());
28     }
29     @Override
30     public TypeSignature visitTimeWithTimeZone(TypeSignaturesParser.TimeWithTimeZoneContext context) {
31         return new TypeSignature(TimeTZType.NAME, List.of());
32     }
33     @Override
34     public TypeSignature visitArray(TypeSignaturesParser.ArrayContext context) {
35         var parameter = visitOptionalContext(context.type());
36         List&lt;TypeSignature&gt; parameters = parameter == null ? List.of() : List.of(parameter);
37         return new TypeSignature(ArrayType.NAME, parameters);
38     }
39     @Override
40     public TypeSignature visitObject(TypeSignaturesParser.ObjectContext context) {
41         return new TypeSignature(ObjectType.NAME, getParameters(context.parameters()));
42     }
43     @Override
44     public TypeSignature visitGeneric(TypeSignaturesParser.GenericContext context) {
45         return new TypeSignature(getIdentifier(context.identifier()), getParameters(context.parameters()));
46     }
47     @Override
48     public TypeSignature visitRow(TypeSignaturesParser.RowContext context) {
49         return new TypeSignature(RowType.NAME, getParameters(context.parameters()));
50     }
51     @Override
52     public TypeSignature visitParameter(TypeSignaturesParser.ParameterContext context) {
53         if (context.INTEGER_VALUE() != null) {
54             return new IntegerLiteralTypeSignature(Integer.parseInt(context.INTEGER_VALUE().getText()));
55         } else if (context.identifier() != null) {
56             return new ParameterTypeSignature(getIdentifier(context.identifier()), visitOptionalContext(context.type()));
57         } else {
58             return visit(context.type());
59         }
60     }
61     @Nullable
62     private String getIdentifier(@Nullable TypeSignaturesParser.IdentifierContext context) {
63         if (context != null) {
64             if (context.QUOTED_INDENTIFIER() != null) {
65                 var token = context.QUOTED_INDENTIFIER().getText();
66                 return token.substring(1, token.length() - 1);
67             }
68             if (context.UNQUOTED_INDENTIFIER() != null) {
69                 return context.UNQUOTED_INDENTIFIER().getText();
70             }
71         }
72         return null;
73     }
74     @Nullable
75     private TypeSignature visitOptionalContext(@Nullable TypeSignaturesParser.TypeContext context) {
76         if (context != null) {
77             return visit(context);
78         }
79         return null;
80     }
81     private List&lt;TypeSignature&gt; getParameters(@Nullable TypeSignaturesParser.ParametersContext context) {
82         if (context == null || context.parameter().isEmpty()) {
83             return List.of();
84         }
85         var result = new ArrayList&lt;TypeSignature&gt;(context.parameter().size());
86         for (var p : context.parameter()) {
87             result.add(p.accept(this));
88         }
89         return result;
90     }
91 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CancelAllocationCommand.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package org.elasticsearch.cluster.routing.allocation.command;
2 import org.apache.logging.log4j.LogManager;
3 import org.elasticsearch.ElasticsearchParseException;
4 import org.elasticsearch.cluster.metadata.IndexMetadata;
5 import org.elasticsearch.cluster.node.DiscoveryNode;
6 import org.elasticsearch.cluster.routing.RoutingNode;
7 import org.elasticsearch.cluster.routing.RoutingNodes;
8 import org.elasticsearch.cluster.routing.ShardRouting;
9 import org.elasticsearch.cluster.routing.UnassignedInfo;
10 import org.elasticsearch.cluster.routing.allocation.RerouteExplanation;
11 import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;
12 import org.elasticsearch.cluster.routing.allocation.decider.Decision;
13 import org.elasticsearch.common.ParseField;
14 import org.elasticsearch.common.io.stream.StreamInput;
15 import</b></font> org.elasticsearch.common.io.stream.StreamOutput;
16 import org.elasticsearch.common.xcontent.XContentBuilder;
17 import org.elasticsearch.common.xcontent.XContentParser;
18 import org.elasticsearch.index.IndexNotFoundException;
19 import org.elasticsearch.index.shard.ShardId;
20 import java.io.IOException;
21 import java.util.Locale;
22 import java.util.Objects;
23 public class CancelAllocationCommand implements AllocationCommand {
24     public static final String NAME = "cancel";
25     public static final ParseField COMMAND_NAME_FIELD = new ParseField(NAME);
26     private final String index;
27     private final int shardId;
28     private final String node;
29     private final boolean allowPrimary;
30     public CancelAllocationCommand(String index, int shardId, String node, boolean allowPrimary) {
31         this.index = index;
32         this.shardId = shardId;
33         this.node = node;
34         this.allowPrimary = allowPrimary;
35     }
36     public CancelAllocationCommand(StreamInput in) throws IOException {
37         index = in.readString();
38         shardId = in.readVInt();
39         node = in.readString();
40         allowPrimary = in.readBoolean();
41     }
42     @Override
43     public void writeTo(StreamOutput out) throws IOException {
44         out.writeString(index);
45         out.writeVInt(shardId);
46         out.writeString(node);
47         out.writeBoolean(allowPrimary);
48     }
49     @Override
50     public String name() {
51         return NAME;
52     }
53     public String index() {
54         return this.index;
55     }
56     public int shardId() {
57         return this.shardId;
58     }
59     public String node() {
60         return this.node;
61     }
62     public boolean allowPrimary() {
63         return this.allowPrimary;
64     }
65     @Override
66     public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {
67         DiscoveryNode discoNode = allocation.nodes().resolveNode(node);
68         ShardRouting shardRouting = null;
69         RoutingNodes routingNodes = allocation.routingNodes();
70         RoutingNode routingNode = routingNodes.node(discoNode.getId());
71         IndexMetadata indexMetadata = null;
72         if (routingNode != null) {
73             indexMetadata = allocation.metadata().index(index());
74             if (indexMetadata == null) {
75                 throw new IndexNotFoundException(index());
76             }
77             ShardId shardId = new ShardId(indexMetadata.getIndex(), shardId());
78             shardRouting = routingNode.getByShardId(shardId);
79         }
80         if (shardRouting == null) {
81             if (explain) {
82                 return new RerouteExplanation(this, allocation.decision(Decision.NO, "cancel_allocation_command",
83                     "can't cancel " + shardId + ", failed to find it on node " + discoNode));
84             }
85             throw new IllegalArgumentException("[cancel_allocation] can't cancel " + shardId + ", failed to find it on node " + discoNode);
86         }
87         if (shardRouting.primary() &amp;&amp; allowPrimary == false) {
88             if ((shardRouting.initializing() &amp;&amp; shardRouting.relocatingNodeId() != null) == false) {
89                 if (explain) {
90                     return new RerouteExplanation(this, allocation.decision(Decision.NO, "cancel_allocation_command",
91                         "can't cancel " + shardId + " on node " + discoNode + ", shard is primary and " +
92                             shardRouting.state().name().toLowerCase(Locale.ROOT)));
93                 }
94                 throw new IllegalArgumentException("[cancel_allocation] can't cancel " + shardId + " on node " +
95                     discoNode + ", shard is primary and " + shardRouting.state().name().toLowerCase(Locale.ROOT));
96             }
97         }
98         routingNodes.failShard(LogManager.getLogger(CancelAllocationCommand.class), shardRouting,
99             new UnassignedInfo(UnassignedInfo.Reason.REROUTE_CANCELLED, null), indexMetadata, allocation.changes());
100         allocation.removeAllocationId(shardRouting);
101         return new RerouteExplanation(this, allocation.decision(Decision.YES, "cancel_allocation_command",
102                 "shard " + shardId + " on node " + discoNode + " can be cancelled"));
103     }
104     @Override
105     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
106         builder.startObject();
107         builder.field("index", index());
108         builder.field("shard", shardId());
109         builder.field("node", node());
110         builder.field("allow_primary", allowPrimary());
111         return builder.endObject();
112     }
113     public static CancelAllocationCommand fromXContent(XContentParser parser) throws IOException {
114         String index = null;
115         int shardId = -1;
116         String nodeId = null;
117         boolean allowPrimary = false;
118         String currentFieldName = null;
119         XContentParser.Token token;
120         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
121             if (token == XContentParser.Token.FIELD_NAME) {
122                 currentFieldName = parser.currentName();
123             } else if (token.isValue()) {
124                 if ("index".equals(currentFieldName)) {
125                     index = parser.text();
126                 } else if ("shard".equals(currentFieldName)) {
127                     shardId = parser.intValue();
128                 } else if ("node".equals(currentFieldName)) {
129                     nodeId = parser.text();
130                 } else if ("allow_primary".equals(currentFieldName) || "allowPrimary".equals(currentFieldName)) {
131                     allowPrimary = parser.booleanValue();
132                 } else {
133                     throw new ElasticsearchParseException("[{}] command does not support field [{}]", NAME, currentFieldName);
134                 }
135             } else {
136                 throw new ElasticsearchParseException("[{}] command does not support complex json tokens [{}]", NAME, token);
137             }
138         }
139         if (index == null) {
140             throw new ElasticsearchParseException("[{}] command missing the index parameter", NAME);
141         }
142         if (shardId == -1) {
143             throw new ElasticsearchParseException("[{}] command missing the shard parameter", NAME);
144         }
145         if (nodeId == null) {
146             throw new ElasticsearchParseException("[{}] command missing the node parameter", NAME);
147         }
148         return new CancelAllocationCommand(index, shardId, nodeId, allowPrimary);
149     }
150     @Override
151     public boolean equals(Object obj) {
152         if (obj == null || getClass() != obj.getClass()) {
153             return false;
154         }
155         CancelAllocationCommand other = (CancelAllocationCommand) obj;
156         return Objects.equals(index, other.index) &amp;&amp;
157                 Objects.equals(shardId, other.shardId) &amp;&amp;
158                 Objects.equals(node, other.node) &amp;&amp;
159                 Objects.equals(allowPrimary, other.allowPrimary);
160     }
161     @Override
162     public int hashCode() {
163         return Objects.hash(index, shardId, node, allowPrimary);
164     }
165 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
