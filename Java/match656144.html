<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for IntMath_1.java &amp; ImmutableSortedSet_2.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for IntMath_1.java &amp; ImmutableSortedSet_2.java
      </h3>
<h1 align="center">
        10.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>IntMath_1.java (10.940171%)<th>ImmutableSortedSet_2.java (9.785933%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-50)<td><a href="#" name="0">(23-59)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(537-557)<td><a href="#" name="1">(562-583)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(558-569)<td><a href="#" name="2">(555-561)</a><td align="center"><font color="#8c0000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(303-317)<td><a href="#" name="3">(604-610)</a><td align="center"><font color="#7f0000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(708-725)<td><a href="#" name="4">(631-637)</a><td align="center"><font color="#720000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>IntMath_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
package com.google.common.math;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.math.MathPreconditions.checkNoOverflow;
import static com.google.common.math.MathPreconditions.checkNonNegative;
import static com.google.common.math.MathPreconditions.checkPositive;
import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
import static java.lang.Math.abs;
import static java.lang.Math.min;
import static java.math.RoundingMode.HALF_EVEN;
import static java.math.RoundingMode.HALF_UP;
import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.primitives.Ints;
import java.math.BigInteger;
import java.math.RoundingMode;
@GwtCompatible(e</b></font>mulated = true)
@ElementTypesAreNonnullByDefault
public final class IntMath {
  @VisibleForTesting static final int MAX_SIGNED_POWER_OF_TWO = 1 &lt;&lt; (Integer.SIZE - 2);
  @Beta
  public static int ceilingPowerOfTwo(int x) {
    checkPositive("x", x);
    if (x &gt; MAX_SIGNED_POWER_OF_TWO) {
      throw new ArithmeticException("ceilingPowerOfTwo(" + x + ") not representable as an int");
    }
    return 1 &lt;&lt; -Integer.numberOfLeadingZeros(x - 1);
  }
  @Beta
  public static int floorPowerOfTwo(int x) {
    checkPositive("x", x);
    return Integer.highestOneBit(x);
  }
  public static boolean isPowerOfTwo(int x) {
    return x &gt; 0 &amp; (x &amp; (x - 1)) == 0;
  }
  @VisibleForTesting
  static int lessThanBranchFree(int x, int y) {
    return ~~(x - y) &gt;&gt;&gt; (Integer.SIZE - 1);
  }
  @SuppressWarnings("fallthrough")
  public static int log2(int x, RoundingMode mode) {
    checkPositive("x", x);
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(isPowerOfTwo(x));
      case DOWN:
      case FLOOR:
        return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);
      case UP:
      case CEILING:
        return Integer.SIZE - Integer.numberOfLeadingZeros(x - 1);
      case HALF_DOWN:
      case HALF_UP:
      case HALF_EVEN:
        int leadingZeros = Integer.numberOfLeadingZeros(x);
        int cmp = MAX_POWER_OF_SQRT2_UNSIGNED &gt;&gt;&gt; leadingZeros;
        int logFloor = (Integer.SIZE - 1) - leadingZeros;
        return logFloor + lessThanBranchFree(cmp, x);
      default:
        throw new AssertionError();
    }
  }
  @VisibleForTesting static final int MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333;
  @GwtIncompatible   @SuppressWarnings("fallthrough")
  public static int log10(int x, RoundingMode mode) {
    checkPositive("x", x);
    int logFloor = log10Floor(x);
    int floorPow = powersOf10[logFloor];
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(x == floorPow);
      case FLOOR:
      case DOWN:
        return logFloor;
      case CEILING:
      case UP:
        return logFloor + lessThanBranchFree(floorPow, x);
      case HALF_DOWN:
      case HALF_UP:
      case HALF_EVEN:
        return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);
      default:
        throw new AssertionError();
    }
  }
  private static int log10Floor(int x) {
    int y = maxLog10ForLeadingZeros[Integer.numberOfLeadingZeros(x)];
    return y - lessThanBranchFree(x, powersOf10[y]);
  }
  @VisibleForTesting
  static final byte[] maxLog10ForLeadingZeros = {
    9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0,
    0
  };
  @VisibleForTesting
  static final int[] powersOf10 = {
    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
  };
  @VisibleForTesting
  static final int[] halfPowersOf10 = {
    3, 31, 316, 3162, 31622, 316227, 3162277, 31622776, 316227766, Integer.MAX_VALUE
  };
  @GwtIncompatible   public static int pow(int b, int k) {
    checkNonNegative("exponent", k);
    switch (b) {
      case 0:
        return (k == 0) ? 1 : 0;
      case 1:
        return 1;
      case (-1):
        return ((k &amp; 1) == 0) ? 1 : -1;
      case 2:
        return (k &lt; Integer.SIZE) ? (1 &lt;&lt; k) : 0;
      case (-2):
        if (k &lt; Integer.SIZE) {
          return ((k &amp; 1) == 0) ? (1 &lt;&lt; k) : -(1 &lt;&lt; k);
        } else {
          return 0;
        }
      default:
    }
    for (int accum = 1; ; k &gt;&gt;= 1) {
      switch (k) {
        case 0:
          return accum;
        case 1:
          return b * accum;
        default:
          accum *= ((k &amp; 1) == 0) ? 1 : b;
          b *= b;
      }
    }
  }
  @GwtIncompatible   @SuppressWarnings("fallthrough")
  public static int sqrt(int x, RoundingMode mode) {
    checkNonNegative("x", x);
    int sqrtFloor = sqrtFloor(x);
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(sqrtFloor * sqrtFloor == x);       case FLOOR:
      case DOWN:
        return sqrtFloor;
      case CEILING:
      case UP:
        return sqrtFloor + lessThanBranchFree(sqrtFloor * sqrtFloor, x);
      case HALF_DOWN:
      case HALF_UP:
      case HALF_EVEN:
        int halfSquare = sqrtFloor * sqrtFloor + sqrtFloor;
        return sqrtFloor + lessThanBranchFree(halfSquare, x);
      default:
        throw new AssertionError();
<a name="3"></a>    }
  }
  private static int sqrtFloor(<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int x) {
    return (int) Math.sqrt(x);
  }
  @SuppressWarnings("fallthrough")
  public static int divide(int p, int q</b></font>, RoundingMode mode) {
    checkNotNull(mode);
    if (q == 0) {
      throw new ArithmeticException("/ by zero");     }
    int div = p / q;
    int rem = p - q * div; 
    if (rem == 0) {
      return div;
    }
    int signum = 1 | ((p ^ q) &gt;&gt; (Integer.SIZE - 1));
    boolean increment;
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(rem == 0);
      case DOWN:
        increment = false;
        break;
      case UP:
        increment = true;
        break;
      case CEILING:
        increment = signum &gt; 0;
        break;
      case FLOOR:
        increment = signum &lt; 0;
        break;
      case HALF_EVEN:
      case HALF_DOWN:
      case HALF_UP:
        int absRem = abs(rem);
        int cmpRemToHalfDivisor = absRem - (abs(q) - absRem);
        if (cmpRemToHalfDivisor == 0) {           increment = (mode == HALF_UP || (mode == HALF_EVEN &amp; (div &amp; 1) != 0));
        } else {
          increment = cmpRemToHalfDivisor &gt; 0;         }
        break;
      default:
        throw new AssertionError();
    }
    return increment ? div + signum : div;
  }
  public static int mod(int x, int m) {
    if (m &lt;= 0) {
      throw new ArithmeticException("Modulus " + m + " must be &gt; 0");
    }
    int result = x % m;
    return (result &gt;= 0) ? result : result + m;
  }
  public static int gcd(int a, int b) {
    checkNonNegative("a", a);
    checkNonNegative("b", b);
    if (a == 0) {
      return b;
    } else if (b == 0) {
      return a;     }
    int aTwos = Integer.numberOfTrailingZeros(a);
    a &gt;&gt;= aTwos;     int bTwos = Integer.numberOfTrailingZeros(b);
    b &gt;&gt;= bTwos;     while (a != b) { 
      int delta = a - b; 
      int minDeltaOrZero = delta &amp; (delta &gt;&gt; (Integer.SIZE - 1));
      a = delta - minDeltaOrZero - minDeltaOrZero; 
      b += minDeltaOrZero;       a &gt;&gt;= Integer.numberOfTrailingZeros(a);     }
    return a &lt;&lt; min(aTwos, bTwos);
  }
  public static int checkedAdd(int a, int b) {
    long result = (long) a + b;
    checkNoOverflow(result == (int) result, "checkedAdd", a, b);
    return (int) result;
  }
  public static int checkedSubtract(int a, int b) {
    long result = (long) a - b;
    checkNoOverflow(result == (int) result, "checkedSubtract", a, b);
    return (int) result;
  }
  public static int checkedMultiply(int a, int b) {
    long result = (long) a * b;
    checkNoOverflow(result == (int) result, "checkedMultiply", a, b);
    return (int) result;
  }
  public static int checkedPow(int b, int k) {
    checkNonNegative("exponent", k);
    switch (b) {
      case 0:
        return (k == 0) ? 1 : 0;
      case 1:
        return 1;
      case (-1):
        return ((k &amp; 1) == 0) ? 1 : -1;
      case 2:
        checkNoOverflow(k &lt; Integer.SIZE - 1, "checkedPow", b, k);
        return 1 &lt;&lt; k;
      case (-2):
        checkNoOverflow(k &lt; Integer.SIZE, "checkedPow", b, k);
        return ((k &amp; 1) == 0) ? 1 &lt;&lt; k : -1 &lt;&lt; k;
      default:
    }
    int accum = 1;
    while (true) {
      switch (k) {
        case 0:
          return accum;
        case 1:
          return checkedMultiply(accum, b);
        default:
          if ((k &amp; 1) != 0) {
            accum = checkedMultiply(accum, b);
          }
          k &gt;&gt;= 1;
          if (k &gt; 0) {
            checkNoOverflow(-FLOOR_SQRT_MAX_INT &lt;= b &amp; b &lt;= FLOOR_SQRT_MAX_INT, "checkedPow", b, k);
            b *= b;
          }
      }
    }
  }
  @Beta
  public static int saturatedAdd(int a, int b) {
    return <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Ints.saturatedCast((long) a + b);
  }
  @Beta
  public static int saturatedSubtract(int a, int b) {
    return Ints.saturatedCast((long) a - b);
  }
  @</b></font>Beta
  public static int saturatedMultiply(int a, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int b) {
    return Ints.saturatedCast((long) a * b);
  }
  @Beta
  public static int saturatedPow(int b, int k) {</b></font>
    checkNonNegative("exponent", k);
    switch (b) {
      case 0:
        return (k == 0) ? 1 : 0;
      case 1:
        return 1;
      case (-1):
        return ((k &amp; 1) == 0) ? 1 : -1;
      case 2:
        if (k &gt;= Integer.SIZE - 1) {
          return Integer.MAX_VALUE;
        }
        return 1 &lt;&lt; k;
      case (-2):
        if (k &gt;= Integer.SIZE) {
          return Integer.MAX_VALUE + (k &amp; 1);
        }
        return ((k &amp; 1) == 0) ? 1 &lt;&lt; k : -1 &lt;&lt; k;
      default:
    }
    int accum = 1;
    int limit = Integer.MAX_VALUE + ((b &gt;&gt;&gt; Integer.SIZE - 1) &amp; (k &amp; 1));
    while (true) {
      switch (k) {
        case 0:
          return accum;
        case 1:
          return saturatedMultiply(accum, b);
        default:
          if ((k &amp; 1) != 0) {
            accum = saturatedMultiply(accum, b);
          }
          k &gt;&gt;= 1;
          if (k &gt; 0) {
            if (-FLOOR_SQRT_MAX_INT &gt; b | b &gt; FLOOR_SQRT_MAX_INT) {
              return limit;
            }
            b *= b;
          }
      }
    }
  }
  @VisibleForTesting static final int FLOOR_SQRT_MAX_INT = 46340;
  public static int factorial(int n) {
    checkNonNegative("n", n);
    return (n &lt; factorials.length) ? factorials[n] : Integer.MAX_VALUE;
  }
  private static final int[] factorials = {
    1,
    1,
    1 * 2,
    1 * 2 * 3,
    1 * 2 * 3 * 4,
    1 * 2 * 3 * 4 * 5,
    1 * 2 * 3 * 4 * 5 * 6,
    1 * 2 * 3 * 4 * 5 * 6 * 7,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12
  };
  public static int binomial(int n, int k) {
    checkNonNegative("n", n);
    checkNonNegative("k", k);
    checkArgument(k &lt;= n, "k (%s) &gt; n (%s)", k, n);
    if (k &gt; (n &gt;&gt; 1)) {
      k = n - k;
    }
    if (k &gt;= biggestBinomials.length || n &gt; biggestBinomials[k]) {
      return Integer.MAX_VALUE;
    }
    switch (k) {
      case 0:
        return 1;
      case 1:
        return n;
      default:
        long result = 1;
        for (int i = 0; i &lt; k; i++) {
          result *= n - i;
          result /= i + 1;
        }
        return (int) result;
    }
  }
  @VisibleForTesting
  static int[] biggestBinomials = {
    Integer.MAX_VALUE,
    Integer.MAX_VALUE,
    65536,
    2345,
    477,
    193,
    110,
    75,
    58,
    49,
    43,
    39,
    37,
    35,
    34,
    34,
    33
  };
  public static int mean(int x, int y) {
<a name="4"></a>        return (x &amp; y) + ((x ^ y) &gt;&gt; 1);
  <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
  @GwtIncompatible   @Beta
  public static boolean isPrime(int n) {
    return LongMath.isPrime</b></font>(n);
  }
  private IntMath() {}
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableSortedSet_2.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
package com.google.common.collect;
import static com.google.common.base.Preconditions.checkArgument;
<a name="0"></a>import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NavigableSet;
import java.util.SortedSet;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;
@GwtCompatible(s</b></font>erializable = true, emulated = true)
@SuppressWarnings("serial") @ElementTypesAreNonnullByDefault
public abstract class ImmutableSortedSet&lt;E&gt; extends ImmutableSortedSetFauxverideShim&lt;E&gt;
    implements NavigableSet&lt;E&gt;, SortedIterable&lt;E&gt; {
  static &lt;E&gt; RegularImmutableSortedSet&lt;E&gt; emptySet(Comparator&lt;? super E&gt; comparator) {
    if (Ordering.natural().equals(comparator)) {
      return (RegularImmutableSortedSet&lt;E&gt;) RegularImmutableSortedSet.NATURAL_EMPTY_SET;
    } else {
      return new RegularImmutableSortedSet&lt;E&gt;(ImmutableList.&lt;E&gt;of(), comparator);
    }
  }
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; of() {
    return (ImmutableSortedSet&lt;E&gt;) RegularImmutableSortedSet.NATURAL_EMPTY_SET;
  }
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E element) {
    return new RegularImmutableSortedSet&lt;E&gt;(ImmutableList.of(element), Ordering.natural());
  }
  @SuppressWarnings("unchecked")
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2) {
    return construct(Ordering.natural(), 2, e1, e2);
  }
  @SuppressWarnings("unchecked")
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2, E e3) {
    return construct(Ordering.natural(), 3, e1, e2, e3);
  }
  @SuppressWarnings("unchecked")
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2, E e3, E e4) {
    return construct(Ordering.natural(), 4, e1, e2, e3, e4);
  }
  @SuppressWarnings("unchecked")
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5) {
    return construct(Ordering.natural(), 5, e1, e2, e3, e4, e5);
  }
  @SuppressWarnings("unchecked")
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
    Comparable[] contents = new Comparable[6 + remaining.length];
    contents[0] = e1;
    contents[1] = e2;
    contents[2] = e3;
    contents[3] = e4;
    contents[4] = e5;
    contents[5] = e6;
    System.arraycopy(remaining, 0, contents, 6, remaining.length);
    return construct(Ordering.natural(), contents.length, (E[]) contents);
  }
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; copyOf(E[] elements) {
    return construct(Ordering.natural(), elements.length, elements.clone());
  }
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Iterable&lt;? extends E&gt; elements) {
    @SuppressWarnings("unchecked")
    Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
    return copyOf(naturalOrder, elements);
  }
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Collection&lt;? extends E&gt; elements) {
    @SuppressWarnings("unchecked")
    Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
    return copyOf(naturalOrder, elements);
  }
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Iterator&lt;? extends E&gt; elements) {
    @SuppressWarnings("unchecked")
    Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
    return copyOf(naturalOrder, elements);
  }
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
      Comparator&lt;? super E&gt; comparator, Iterator&lt;? extends E&gt; elements) {
    return new Builder&lt;E&gt;(comparator).addAll(elements).build();
  }
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
      Comparator&lt;? super E&gt; comparator, Iterable&lt;? extends E&gt; elements) {
    checkNotNull(comparator);
    boolean hasSameComparator = SortedIterables.hasSameComparator(comparator, elements);
    if (hasSameComparator &amp;&amp; (elements instanceof ImmutableSortedSet)) {
      @SuppressWarnings("unchecked")
      ImmutableSortedSet&lt;E&gt; original = (ImmutableSortedSet&lt;E&gt;) elements;
      if (!original.isPartialView()) {
        return original;
      }
    }
    @SuppressWarnings("unchecked")     E[] array = (E[]) Iterables.toArray(elements);
    return construct(comparator, array.length, array);
  }
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
      Comparator&lt;? super E&gt; comparator, Collection&lt;? extends E&gt; elements) {
    return copyOf(comparator, (Iterable&lt;? extends E&gt;) elements);
  }
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOfSorted(SortedSet&lt;E&gt; sortedSet) {
    Comparator&lt;? super E&gt; comparator = SortedIterables.comparator(sortedSet);
    ImmutableList&lt;E&gt; list = ImmutableList.copyOf(sortedSet);
    if (list.isEmpty()) {
      return emptySet(comparator);
    } else {
      return new RegularImmutableSortedSet&lt;E&gt;(list, comparator);
    }
  }
  static &lt;E&gt; ImmutableSortedSet&lt;E&gt; construct(
      Comparator&lt;? super E&gt; comparator, int n, E... contents) {
    if (n == 0) {
      return emptySet(comparator);
    }
    checkElementsNotNull(contents, n);
    Arrays.sort(contents, 0, n, comparator);
    int uniques = 1;
    for (int i = 1; i &lt; n; i++) {
      E cur = contents[i];
      E prev = contents[uniques - 1];
      if (comparator.compare(cur, prev) != 0) {
        contents[uniques++] = cur;
      }
    }
    Arrays.fill(contents, uniques, n, null);
    if (uniques &lt; contents.length / 2) {
      contents = Arrays.copyOf(contents, uniques);
    }
    return new RegularImmutableSortedSet&lt;E&gt;(
        ImmutableList.&lt;E&gt;asImmutableList(contents, uniques), comparator);
  }
  public static &lt;E&gt; Builder&lt;E&gt; orderedBy(Comparator&lt;E&gt; comparator) {
    return new Builder&lt;E&gt;(comparator);
  }
  public static &lt;E extends Comparable&lt;?&gt;&gt; Builder&lt;E&gt; reverseOrder() {
    return new Builder&lt;E&gt;(Collections.reverseOrder());
  }
  public static &lt;E extends Comparable&lt;?&gt;&gt; Builder&lt;E&gt; naturalOrder() {
    return new Builder&lt;E&gt;(Ordering.natural());
  }
  public static final class Builder&lt;E&gt; extends ImmutableSet.Builder&lt;E&gt; {
    private final Comparator&lt;? super E&gt; comparator;
    public Builder(Comparator&lt;? super E&gt; comparator) {
      this.comparator = checkNotNull(comparator);
    }
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E element) {
      super.add(element);
      return this;
    }
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E... elements) {
      super.add(elements);
      return this;
    }
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterable&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }
    @CanIgnoreReturnValue
    @Override
    Builder&lt;E&gt; combine(ImmutableSet.Builder&lt;E&gt; builder) {
      super.combine(builder);
      return this;
    }
    @Override
    public ImmutableSortedSet&lt;E&gt; build() {
      @SuppressWarnings("unchecked")       E[] contentsArray = (E[]) contents;
      ImmutableSortedSet&lt;E&gt; result = construct(comparator, size, contentsArray);
      this.size = result.size();       this.forceCopy = true;
      return result;
    }
  }
  int unsafeCompare(Object a, @CheckForNull Object b) {
    return unsafeCompare(comparator, a, b);
  }
  static int unsafeCompare(Comparator&lt;?&gt; comparator, Object a, @CheckForNull Object b) {
    @SuppressWarnings({"unchecked", "nullness"})
    Comparator&lt;@Nullable Object&gt; unsafeComparator = (Comparator&lt;@Nullable Object&gt;) comparator;
    return unsafeComparator.compare(a, b);
  }
  final transient Comparator&lt;? super E&gt; comparator;
  ImmutableSortedSet(Comparator&lt;? super E&gt; comparator) {
    this.comparator = comparator;
  }
  @Override
  public Comparator&lt;? super E&gt; comparator() {
    return comparator;
  }
  @Override   public abstract UnmodifiableIterator&lt;E&gt; iterator();
  @Override
  public ImmutableSortedSet&lt;E&gt; headSet(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>E toElement) {
    return headSet(toElement, false);
  }
<a name="1"></a>    @Override
  public ImmutableSortedSet&lt;E&gt; headSet(E toElement, boolean inclusive) {</b></font>
    return headSetImpl(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>checkNotNull(toElement), inclusive);
  }
  @Override
  public ImmutableSortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
    return subSet(fromElement, true, toElement, false);
  }
  @</b></font>GwtIncompatible   @Override
  public ImmutableSortedSet&lt;E&gt; subSet(
      E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
    checkNotNull(fromElement);
    checkNotNull(toElement);
    checkArgument(comparator.compare(fromElement, toElement) &lt;= 0);
    return subSetImpl(fromElement, fromInclusive, toElement, toInclusive);
  }
  @Override
  public ImmutableSortedSet&lt;E&gt; tailSet(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>E fromElement) {
    return tailSet(fromElement, true);
  }
  @Override
  public ImmutableSortedSet&lt;E&gt; tailSet(E fromElement, boolean inclusive</b></font>) {
    return tailSetImpl(checkNotNull(fromElement), inclusive);
  }
  abstract ImmutableSortedSet&lt;E&gt; headSetImpl(E toElement, boolean inclusive);
  abstract ImmutableSortedSet&lt;E&gt; subSetImpl(
      E fromElement, boolean fromInclusive, E toElement, boolean toInclusive);
  abstract ImmutableSortedSet&lt;E&gt; tailSetImpl(E fromElement, boolean inclusive);
  @GwtIncompatible   @Override
<a name="4"></a>  @CheckForNull
  public E lower(E e) {
    return Iterators.getNext(headSet(e, false).descendingIterator(), null);
  <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
  @Override
  @CheckForNull
  public E floor(E e) {
    return Iterators.getNext</b></font>(headSet(e, true).descendingIterator(), null);
  }
  @Override
  @CheckForNull
  public E ceiling(E e) {
    return Iterables.getFirst(tailSet(e, true), null);
  }
  @GwtIncompatible   @Override
  @CheckForNull
  public E higher(E e) {
    return Iterables.getFirst(tailSet(e, false), null);
  }
  @Override
  public E first() {
    return iterator().next();
  }
  @Override
  public E last() {
    return descendingIterator().next();
  }
  @CanIgnoreReturnValue
  @Deprecated
  @GwtIncompatible   @Override
  @DoNotCall("Always throws UnsupportedOperationException")
  @CheckForNull
  public final E pollFirst() {
    throw new UnsupportedOperationException();
  }
  @CanIgnoreReturnValue
  @Deprecated
  @GwtIncompatible   @Override
  @DoNotCall("Always throws UnsupportedOperationException")
  @CheckForNull
  public final E pollLast() {
    throw new UnsupportedOperationException();
  }
  @GwtIncompatible   @LazyInit
  @CheckForNull
  transient ImmutableSortedSet&lt;E&gt; descendingSet;
  @GwtIncompatible   @Override
  public ImmutableSortedSet&lt;E&gt; descendingSet() {
    ImmutableSortedSet&lt;E&gt; result = descendingSet;
    if (result == null) {
      result = descendingSet = createDescendingSet();
      result.descendingSet = this;
    }
    return result;
  }
  @GwtIncompatible   abstract ImmutableSortedSet&lt;E&gt; createDescendingSet();
  @GwtIncompatible   @Override
  public abstract UnmodifiableIterator&lt;E&gt; descendingIterator();
  abstract int indexOf(@CheckForNull Object target);
  /*
   * This class is used to serialize all ImmutableSortedSet instances,
   * regardless of implementation type. It captures their "logical contents"
   * only. This is necessary to ensure that the existence of a particular
   * implementation type is an implementation detail.
   */
  private static class SerializedForm&lt;E&gt; implements Serializable {
    final Comparator&lt;? super E&gt; comparator;
    final Object[] elements;
    public SerializedForm(Comparator&lt;? super E&gt; comparator, Object[] elements) {
      this.comparator = comparator;
      this.elements = elements;
    }
    @SuppressWarnings("unchecked")
    Object readResolve() {
      return new Builder&lt;E&gt;(comparator).add((E[]) elements).build();
    }
    private static final long serialVersionUID = 0;
  }
  private void readObject(ObjectInputStream unused) throws InvalidObjectException {
    throw new InvalidObjectException("Use SerializedForm");
  }
  @Override
  Object writeReplace() {
    return new SerializedForm&lt;E&gt;(comparator, toArray());
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
