<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for IntMath_1.java &amp; ImmutableSortedSet_2.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for IntMath_1.java &amp; ImmutableSortedSet_2.java
      </h3>
<h1 align="center">
        10.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>IntMath_1.java (10.940171%)<th>ImmutableSortedSet_2.java (9.785933%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-50)<td><a href="#" name="0">(23-59)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(537-557)<td><a href="#" name="1">(562-583)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(558-569)<td><a href="#" name="2">(555-561)</a><td align="center"><font color="#8c0000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(303-317)<td><a href="#" name="3">(604-610)</a><td align="center"><font color="#7f0000">10</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(708-725)<td><a href="#" name="4">(631-637)</a><td align="center"><font color="#720000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>IntMath_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package com.google.common.math;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import static com.google.common.base.Preconditions.checkArgument;
4 import static com.google.common.base.Preconditions.checkNotNull;
5 import static com.google.common.math.MathPreconditions.checkNoOverflow;
6 import static com.google.common.math.MathPreconditions.checkNonNegative;
7 import static com.google.common.math.MathPreconditions.checkPositive;
8 import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
9 import static java.lang.Math.abs;
10 import static java.lang.Math.min;
11 import static java.math.RoundingMode.HALF_EVEN;
12 import static java.math.RoundingMode.HALF_UP;
13 import com.google.common.annotations.Beta;
14 import com.google.common.annotations.GwtCompatible;
15 import com.google.common.annotations.GwtIncompatible;
16 import com.google.common.annotations.VisibleForTesting;
17 import com.google.common.primitives.Ints;
18 import java.math.BigInteger;
19 import java.math.RoundingMode;
20 @GwtCompatible(e</b></font>mulated = true)
21 @ElementTypesAreNonnullByDefault
22 public final class IntMath {
23   @VisibleForTesting static final int MAX_SIGNED_POWER_OF_TWO = 1 &lt;&lt; (Integer.SIZE - 2);
24   @Beta
25   public static int ceilingPowerOfTwo(int x) {
26     checkPositive("x", x);
27     if (x &gt; MAX_SIGNED_POWER_OF_TWO) {
28       throw new ArithmeticException("ceilingPowerOfTwo(" + x + ") not representable as an int");
29     }
30     return 1 &lt;&lt; -Integer.numberOfLeadingZeros(x - 1);
31   }
32   @Beta
33   public static int floorPowerOfTwo(int x) {
34     checkPositive("x", x);
35     return Integer.highestOneBit(x);
36   }
37   public static boolean isPowerOfTwo(int x) {
38     return x &gt; 0 &amp; (x &amp; (x - 1)) == 0;
39   }
40   @VisibleForTesting
41   static int lessThanBranchFree(int x, int y) {
42     return ~~(x - y) &gt;&gt;&gt; (Integer.SIZE - 1);
43   }
44   @SuppressWarnings("fallthrough")
45   public static int log2(int x, RoundingMode mode) {
46     checkPositive("x", x);
47     switch (mode) {
48       case UNNECESSARY:
49         checkRoundingUnnecessary(isPowerOfTwo(x));
50       case DOWN:
51       case FLOOR:
52         return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);
53       case UP:
54       case CEILING:
55         return Integer.SIZE - Integer.numberOfLeadingZeros(x - 1);
56       case HALF_DOWN:
57       case HALF_UP:
58       case HALF_EVEN:
59         int leadingZeros = Integer.numberOfLeadingZeros(x);
60         int cmp = MAX_POWER_OF_SQRT2_UNSIGNED &gt;&gt;&gt; leadingZeros;
61         int logFloor = (Integer.SIZE - 1) - leadingZeros;
62         return logFloor + lessThanBranchFree(cmp, x);
63       default:
64         throw new AssertionError();
65     }
66   }
67   @VisibleForTesting static final int MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333;
68   @GwtIncompatible   @SuppressWarnings("fallthrough")
69   public static int log10(int x, RoundingMode mode) {
70     checkPositive("x", x);
71     int logFloor = log10Floor(x);
72     int floorPow = powersOf10[logFloor];
73     switch (mode) {
74       case UNNECESSARY:
75         checkRoundingUnnecessary(x == floorPow);
76       case FLOOR:
77       case DOWN:
78         return logFloor;
79       case CEILING:
80       case UP:
81         return logFloor + lessThanBranchFree(floorPow, x);
82       case HALF_DOWN:
83       case HALF_UP:
84       case HALF_EVEN:
85         return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);
86       default:
87         throw new AssertionError();
88     }
89   }
90   private static int log10Floor(int x) {
91     int y = maxLog10ForLeadingZeros[Integer.numberOfLeadingZeros(x)];
92     return y - lessThanBranchFree(x, powersOf10[y]);
93   }
94   @VisibleForTesting
95   static final byte[] maxLog10ForLeadingZeros = {
96     9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0,
97     0
98   };
99   @VisibleForTesting
100   static final int[] powersOf10 = {
101     1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
102   };
103   @VisibleForTesting
104   static final int[] halfPowersOf10 = {
105     3, 31, 316, 3162, 31622, 316227, 3162277, 31622776, 316227766, Integer.MAX_VALUE
106   };
107   @GwtIncompatible   public static int pow(int b, int k) {
108     checkNonNegative("exponent", k);
109     switch (b) {
110       case 0:
111         return (k == 0) ? 1 : 0;
112       case 1:
113         return 1;
114       case (-1):
115         return ((k &amp; 1) == 0) ? 1 : -1;
116       case 2:
117         return (k &lt; Integer.SIZE) ? (1 &lt;&lt; k) : 0;
118       case (-2):
119         if (k &lt; Integer.SIZE) {
120           return ((k &amp; 1) == 0) ? (1 &lt;&lt; k) : -(1 &lt;&lt; k);
121         } else {
122           return 0;
123         }
124       default:
125     }
126     for (int accum = 1; ; k &gt;&gt;= 1) {
127       switch (k) {
128         case 0:
129           return accum;
130         case 1:
131           return b * accum;
132         default:
133           accum *= ((k &amp; 1) == 0) ? 1 : b;
134           b *= b;
135       }
136     }
137   }
138   @GwtIncompatible   @SuppressWarnings("fallthrough")
139   public static int sqrt(int x, RoundingMode mode) {
140     checkNonNegative("x", x);
141     int sqrtFloor = sqrtFloor(x);
142     switch (mode) {
143       case UNNECESSARY:
144         checkRoundingUnnecessary(sqrtFloor * sqrtFloor == x);       case FLOOR:
145       case DOWN:
146         return sqrtFloor;
147       case CEILING:
148       case UP:
149         return sqrtFloor + lessThanBranchFree(sqrtFloor * sqrtFloor, x);
150       case HALF_DOWN:
151       case HALF_UP:
152       case HALF_EVEN:
153         int halfSquare = sqrtFloor * sqrtFloor + sqrtFloor;
154         return sqrtFloor + lessThanBranchFree(halfSquare, x);
155       default:
156         throw new AssertionError();
157 <a name="3"></a>    }
158   }
159   private static int sqrtFloor(<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int x) {
160     return (int) Math.sqrt(x);
161   }
162   @SuppressWarnings("fallthrough")
163   public static int divide(int p, int q</b></font>, RoundingMode mode) {
164     checkNotNull(mode);
165     if (q == 0) {
166       throw new ArithmeticException("/ by zero");     }
167     int div = p / q;
168     int rem = p - q * div; 
169     if (rem == 0) {
170       return div;
171     }
172     int signum = 1 | ((p ^ q) &gt;&gt; (Integer.SIZE - 1));
173     boolean increment;
174     switch (mode) {
175       case UNNECESSARY:
176         checkRoundingUnnecessary(rem == 0);
177       case DOWN:
178         increment = false;
179         break;
180       case UP:
181         increment = true;
182         break;
183       case CEILING:
184         increment = signum &gt; 0;
185         break;
186       case FLOOR:
187         increment = signum &lt; 0;
188         break;
189       case HALF_EVEN:
190       case HALF_DOWN:
191       case HALF_UP:
192         int absRem = abs(rem);
193         int cmpRemToHalfDivisor = absRem - (abs(q) - absRem);
194         if (cmpRemToHalfDivisor == 0) {           increment = (mode == HALF_UP || (mode == HALF_EVEN &amp; (div &amp; 1) != 0));
195         } else {
196           increment = cmpRemToHalfDivisor &gt; 0;         }
197         break;
198       default:
199         throw new AssertionError();
200     }
201     return increment ? div + signum : div;
202   }
203   public static int mod(int x, int m) {
204     if (m &lt;= 0) {
205       throw new ArithmeticException("Modulus " + m + " must be &gt; 0");
206     }
207     int result = x % m;
208     return (result &gt;= 0) ? result : result + m;
209   }
210   public static int gcd(int a, int b) {
211     checkNonNegative("a", a);
212     checkNonNegative("b", b);
213     if (a == 0) {
214       return b;
215     } else if (b == 0) {
216       return a;     }
217     int aTwos = Integer.numberOfTrailingZeros(a);
218     a &gt;&gt;= aTwos;     int bTwos = Integer.numberOfTrailingZeros(b);
219     b &gt;&gt;= bTwos;     while (a != b) { 
220       int delta = a - b; 
221       int minDeltaOrZero = delta &amp; (delta &gt;&gt; (Integer.SIZE - 1));
222       a = delta - minDeltaOrZero - minDeltaOrZero; 
223       b += minDeltaOrZero;       a &gt;&gt;= Integer.numberOfTrailingZeros(a);     }
224     return a &lt;&lt; min(aTwos, bTwos);
225   }
226   public static int checkedAdd(int a, int b) {
227     long result = (long) a + b;
228     checkNoOverflow(result == (int) result, "checkedAdd", a, b);
229     return (int) result;
230   }
231   public static int checkedSubtract(int a, int b) {
232     long result = (long) a - b;
233     checkNoOverflow(result == (int) result, "checkedSubtract", a, b);
234     return (int) result;
235   }
236   public static int checkedMultiply(int a, int b) {
237     long result = (long) a * b;
238     checkNoOverflow(result == (int) result, "checkedMultiply", a, b);
239     return (int) result;
240   }
241   public static int checkedPow(int b, int k) {
242     checkNonNegative("exponent", k);
243     switch (b) {
244       case 0:
245         return (k == 0) ? 1 : 0;
246       case 1:
247         return 1;
248       case (-1):
249         return ((k &amp; 1) == 0) ? 1 : -1;
250       case 2:
251         checkNoOverflow(k &lt; Integer.SIZE - 1, "checkedPow", b, k);
252         return 1 &lt;&lt; k;
253       case (-2):
254         checkNoOverflow(k &lt; Integer.SIZE, "checkedPow", b, k);
255         return ((k &amp; 1) == 0) ? 1 &lt;&lt; k : -1 &lt;&lt; k;
256       default:
257     }
258     int accum = 1;
259     while (true) {
260       switch (k) {
261         case 0:
262           return accum;
263         case 1:
264           return checkedMultiply(accum, b);
265         default:
266           if ((k &amp; 1) != 0) {
267             accum = checkedMultiply(accum, b);
268           }
269           k &gt;&gt;= 1;
270           if (k &gt; 0) {
271             checkNoOverflow(-FLOOR_SQRT_MAX_INT &lt;= b &amp; b &lt;= FLOOR_SQRT_MAX_INT, "checkedPow", b, k);
272             b *= b;
273           }
274       }
275     }
276   }
277   @Beta
278   public static int saturatedAdd(int a, int b) {
279     return <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Ints.saturatedCast((long) a + b);
280   }
281   @Beta
282   public static int saturatedSubtract(int a, int b) {
283     return Ints.saturatedCast((long) a - b);
284   }
285   @</b></font>Beta
286   public static int saturatedMultiply(int a, <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int b) {
287     return Ints.saturatedCast((long) a * b);
288   }
289   @Beta
290   public static int saturatedPow(int b, int k) {</b></font>
291     checkNonNegative("exponent", k);
292     switch (b) {
293       case 0:
294         return (k == 0) ? 1 : 0;
295       case 1:
296         return 1;
297       case (-1):
298         return ((k &amp; 1) == 0) ? 1 : -1;
299       case 2:
300         if (k &gt;= Integer.SIZE - 1) {
301           return Integer.MAX_VALUE;
302         }
303         return 1 &lt;&lt; k;
304       case (-2):
305         if (k &gt;= Integer.SIZE) {
306           return Integer.MAX_VALUE + (k &amp; 1);
307         }
308         return ((k &amp; 1) == 0) ? 1 &lt;&lt; k : -1 &lt;&lt; k;
309       default:
310     }
311     int accum = 1;
312     int limit = Integer.MAX_VALUE + ((b &gt;&gt;&gt; Integer.SIZE - 1) &amp; (k &amp; 1));
313     while (true) {
314       switch (k) {
315         case 0:
316           return accum;
317         case 1:
318           return saturatedMultiply(accum, b);
319         default:
320           if ((k &amp; 1) != 0) {
321             accum = saturatedMultiply(accum, b);
322           }
323           k &gt;&gt;= 1;
324           if (k &gt; 0) {
325             if (-FLOOR_SQRT_MAX_INT &gt; b | b &gt; FLOOR_SQRT_MAX_INT) {
326               return limit;
327             }
328             b *= b;
329           }
330       }
331     }
332   }
333   @VisibleForTesting static final int FLOOR_SQRT_MAX_INT = 46340;
334   public static int factorial(int n) {
335     checkNonNegative("n", n);
336     return (n &lt; factorials.length) ? factorials[n] : Integer.MAX_VALUE;
337   }
338   private static final int[] factorials = {
339     1,
340     1,
341     1 * 2,
342     1 * 2 * 3,
343     1 * 2 * 3 * 4,
344     1 * 2 * 3 * 4 * 5,
345     1 * 2 * 3 * 4 * 5 * 6,
346     1 * 2 * 3 * 4 * 5 * 6 * 7,
347     1 * 2 * 3 * 4 * 5 * 6 * 7 * 8,
348     1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,
349     1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,
350     1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,
351     1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12
352   };
353   public static int binomial(int n, int k) {
354     checkNonNegative("n", n);
355     checkNonNegative("k", k);
356     checkArgument(k &lt;= n, "k (%s) &gt; n (%s)", k, n);
357     if (k &gt; (n &gt;&gt; 1)) {
358       k = n - k;
359     }
360     if (k &gt;= biggestBinomials.length || n &gt; biggestBinomials[k]) {
361       return Integer.MAX_VALUE;
362     }
363     switch (k) {
364       case 0:
365         return 1;
366       case 1:
367         return n;
368       default:
369         long result = 1;
370         for (int i = 0; i &lt; k; i++) {
371           result *= n - i;
372           result /= i + 1;
373         }
374         return (int) result;
375     }
376   }
377   @VisibleForTesting
378   static int[] biggestBinomials = {
379     Integer.MAX_VALUE,
380     Integer.MAX_VALUE,
381     65536,
382     2345,
383     477,
384     193,
385     110,
386     75,
387     58,
388     49,
389     43,
390     39,
391     37,
392     35,
393     34,
394     34,
395     33
396   };
397   public static int mean(int x, int y) {
398 <a name="4"></a>        return (x &amp; y) + ((x ^ y) &gt;&gt; 1);
399   <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
400   @GwtIncompatible   @Beta
401   public static boolean isPrime(int n) {
402     return LongMath.isPrime</b></font>(n);
403   }
404   private IntMath() {}
405 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableSortedSet_2.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.base.Preconditions.checkArgument;
3 <a name="0"></a>import static com.google.common.base.Preconditions.checkNotNull;
4 import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
5 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import com.google.common.annotations.GwtCompatible;
6 import com.google.common.annotations.GwtIncompatible;
7 import com.google.errorprone.annotations.CanIgnoreReturnValue;
8 import com.google.errorprone.annotations.DoNotCall;
9 import com.google.errorprone.annotations.concurrent.LazyInit;
10 import java.io.InvalidObjectException;
11 import java.io.ObjectInputStream;
12 import java.io.Serializable;
13 import java.util.Arrays;
14 import java.util.Collection;
15 import java.util.Collections;
16 import java.util.Comparator;
17 import java.util.Iterator;
18 import java.util.NavigableSet;
19 import java.util.SortedSet;
20 import javax.annotation.CheckForNull;
21 import org.checkerframework.checker.nullness.qual.Nullable;
22 @GwtCompatible(s</b></font>erializable = true, emulated = true)
23 @SuppressWarnings("serial") @ElementTypesAreNonnullByDefault
24 public abstract class ImmutableSortedSet&lt;E&gt; extends ImmutableSortedSetFauxverideShim&lt;E&gt;
25     implements NavigableSet&lt;E&gt;, SortedIterable&lt;E&gt; {
26   static &lt;E&gt; RegularImmutableSortedSet&lt;E&gt; emptySet(Comparator&lt;? super E&gt; comparator) {
27     if (Ordering.natural().equals(comparator)) {
28       return (RegularImmutableSortedSet&lt;E&gt;) RegularImmutableSortedSet.NATURAL_EMPTY_SET;
29     } else {
30       return new RegularImmutableSortedSet&lt;E&gt;(ImmutableList.&lt;E&gt;of(), comparator);
31     }
32   }
33   public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; of() {
34     return (ImmutableSortedSet&lt;E&gt;) RegularImmutableSortedSet.NATURAL_EMPTY_SET;
35   }
36   public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E element) {
37     return new RegularImmutableSortedSet&lt;E&gt;(ImmutableList.of(element), Ordering.natural());
38   }
39   @SuppressWarnings("unchecked")
40   public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2) {
41     return construct(Ordering.natural(), 2, e1, e2);
42   }
43   @SuppressWarnings("unchecked")
44   public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2, E e3) {
45     return construct(Ordering.natural(), 3, e1, e2, e3);
46   }
47   @SuppressWarnings("unchecked")
48   public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2, E e3, E e4) {
49     return construct(Ordering.natural(), 4, e1, e2, e3, e4);
50   }
51   @SuppressWarnings("unchecked")
52   public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(
53       E e1, E e2, E e3, E e4, E e5) {
54     return construct(Ordering.natural(), 5, e1, e2, e3, e4, e5);
55   }
56   @SuppressWarnings("unchecked")
57   public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(
58       E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
59     Comparable[] contents = new Comparable[6 + remaining.length];
60     contents[0] = e1;
61     contents[1] = e2;
62     contents[2] = e3;
63     contents[3] = e4;
64     contents[4] = e5;
65     contents[5] = e6;
66     System.arraycopy(remaining, 0, contents, 6, remaining.length);
67     return construct(Ordering.natural(), contents.length, (E[]) contents);
68   }
69   public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; copyOf(E[] elements) {
70     return construct(Ordering.natural(), elements.length, elements.clone());
71   }
72   public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Iterable&lt;? extends E&gt; elements) {
73     @SuppressWarnings("unchecked")
74     Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
75     return copyOf(naturalOrder, elements);
76   }
77   public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Collection&lt;? extends E&gt; elements) {
78     @SuppressWarnings("unchecked")
79     Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
80     return copyOf(naturalOrder, elements);
81   }
82   public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Iterator&lt;? extends E&gt; elements) {
83     @SuppressWarnings("unchecked")
84     Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
85     return copyOf(naturalOrder, elements);
86   }
87   public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
88       Comparator&lt;? super E&gt; comparator, Iterator&lt;? extends E&gt; elements) {
89     return new Builder&lt;E&gt;(comparator).addAll(elements).build();
90   }
91   public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
92       Comparator&lt;? super E&gt; comparator, Iterable&lt;? extends E&gt; elements) {
93     checkNotNull(comparator);
94     boolean hasSameComparator = SortedIterables.hasSameComparator(comparator, elements);
95     if (hasSameComparator &amp;&amp; (elements instanceof ImmutableSortedSet)) {
96       @SuppressWarnings("unchecked")
97       ImmutableSortedSet&lt;E&gt; original = (ImmutableSortedSet&lt;E&gt;) elements;
98       if (!original.isPartialView()) {
99         return original;
100       }
101     }
102     @SuppressWarnings("unchecked")     E[] array = (E[]) Iterables.toArray(elements);
103     return construct(comparator, array.length, array);
104   }
105   public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
106       Comparator&lt;? super E&gt; comparator, Collection&lt;? extends E&gt; elements) {
107     return copyOf(comparator, (Iterable&lt;? extends E&gt;) elements);
108   }
109   public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOfSorted(SortedSet&lt;E&gt; sortedSet) {
110     Comparator&lt;? super E&gt; comparator = SortedIterables.comparator(sortedSet);
111     ImmutableList&lt;E&gt; list = ImmutableList.copyOf(sortedSet);
112     if (list.isEmpty()) {
113       return emptySet(comparator);
114     } else {
115       return new RegularImmutableSortedSet&lt;E&gt;(list, comparator);
116     }
117   }
118   static &lt;E&gt; ImmutableSortedSet&lt;E&gt; construct(
119       Comparator&lt;? super E&gt; comparator, int n, E... contents) {
120     if (n == 0) {
121       return emptySet(comparator);
122     }
123     checkElementsNotNull(contents, n);
124     Arrays.sort(contents, 0, n, comparator);
125     int uniques = 1;
126     for (int i = 1; i &lt; n; i++) {
127       E cur = contents[i];
128       E prev = contents[uniques - 1];
129       if (comparator.compare(cur, prev) != 0) {
130         contents[uniques++] = cur;
131       }
132     }
133     Arrays.fill(contents, uniques, n, null);
134     if (uniques &lt; contents.length / 2) {
135       contents = Arrays.copyOf(contents, uniques);
136     }
137     return new RegularImmutableSortedSet&lt;E&gt;(
138         ImmutableList.&lt;E&gt;asImmutableList(contents, uniques), comparator);
139   }
140   public static &lt;E&gt; Builder&lt;E&gt; orderedBy(Comparator&lt;E&gt; comparator) {
141     return new Builder&lt;E&gt;(comparator);
142   }
143   public static &lt;E extends Comparable&lt;?&gt;&gt; Builder&lt;E&gt; reverseOrder() {
144     return new Builder&lt;E&gt;(Collections.reverseOrder());
145   }
146   public static &lt;E extends Comparable&lt;?&gt;&gt; Builder&lt;E&gt; naturalOrder() {
147     return new Builder&lt;E&gt;(Ordering.natural());
148   }
149   public static final class Builder&lt;E&gt; extends ImmutableSet.Builder&lt;E&gt; {
150     private final Comparator&lt;? super E&gt; comparator;
151     public Builder(Comparator&lt;? super E&gt; comparator) {
152       this.comparator = checkNotNull(comparator);
153     }
154     @CanIgnoreReturnValue
155     @Override
156     public Builder&lt;E&gt; add(E element) {
157       super.add(element);
158       return this;
159     }
160     @CanIgnoreReturnValue
161     @Override
162     public Builder&lt;E&gt; add(E... elements) {
163       super.add(elements);
164       return this;
165     }
166     @CanIgnoreReturnValue
167     @Override
168     public Builder&lt;E&gt; addAll(Iterable&lt;? extends E&gt; elements) {
169       super.addAll(elements);
170       return this;
171     }
172     @CanIgnoreReturnValue
173     @Override
174     public Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {
175       super.addAll(elements);
176       return this;
177     }
178     @CanIgnoreReturnValue
179     @Override
180     Builder&lt;E&gt; combine(ImmutableSet.Builder&lt;E&gt; builder) {
181       super.combine(builder);
182       return this;
183     }
184     @Override
185     public ImmutableSortedSet&lt;E&gt; build() {
186       @SuppressWarnings("unchecked")       E[] contentsArray = (E[]) contents;
187       ImmutableSortedSet&lt;E&gt; result = construct(comparator, size, contentsArray);
188       this.size = result.size();       this.forceCopy = true;
189       return result;
190     }
191   }
192   int unsafeCompare(Object a, @CheckForNull Object b) {
193     return unsafeCompare(comparator, a, b);
194   }
195   static int unsafeCompare(Comparator&lt;?&gt; comparator, Object a, @CheckForNull Object b) {
196     @SuppressWarnings({"unchecked", "nullness"})
197     Comparator&lt;@Nullable Object&gt; unsafeComparator = (Comparator&lt;@Nullable Object&gt;) comparator;
198     return unsafeComparator.compare(a, b);
199   }
200   final transient Comparator&lt;? super E&gt; comparator;
201   ImmutableSortedSet(Comparator&lt;? super E&gt; comparator) {
202     this.comparator = comparator;
203   }
204   @Override
205   public Comparator&lt;? super E&gt; comparator() {
206     return comparator;
207   }
208   @Override   public abstract UnmodifiableIterator&lt;E&gt; iterator();
209   @Override
210   public ImmutableSortedSet&lt;E&gt; headSet(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>E toElement) {
211     return headSet(toElement, false);
212   }
213 <a name="1"></a>    @Override
214   public ImmutableSortedSet&lt;E&gt; headSet(E toElement, boolean inclusive) {</b></font>
215     return headSetImpl(<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>checkNotNull(toElement), inclusive);
216   }
217   @Override
218   public ImmutableSortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
219     return subSet(fromElement, true, toElement, false);
220   }
221   @</b></font>GwtIncompatible   @Override
222   public ImmutableSortedSet&lt;E&gt; subSet(
223       E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
224     checkNotNull(fromElement);
225     checkNotNull(toElement);
226     checkArgument(comparator.compare(fromElement, toElement) &lt;= 0);
227     return subSetImpl(fromElement, fromInclusive, toElement, toInclusive);
228   }
229   @Override
230   public ImmutableSortedSet&lt;E&gt; tailSet(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>E fromElement) {
231     return tailSet(fromElement, true);
232   }
233   @Override
234   public ImmutableSortedSet&lt;E&gt; tailSet(E fromElement, boolean inclusive</b></font>) {
235     return tailSetImpl(checkNotNull(fromElement), inclusive);
236   }
237   abstract ImmutableSortedSet&lt;E&gt; headSetImpl(E toElement, boolean inclusive);
238   abstract ImmutableSortedSet&lt;E&gt; subSetImpl(
239       E fromElement, boolean fromInclusive, E toElement, boolean toInclusive);
240   abstract ImmutableSortedSet&lt;E&gt; tailSetImpl(E fromElement, boolean inclusive);
241   @GwtIncompatible   @Override
242 <a name="4"></a>  @CheckForNull
243   public E lower(E e) {
244     return Iterators.getNext(headSet(e, false).descendingIterator(), null);
245   <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
246   @Override
247   @CheckForNull
248   public E floor(E e) {
249     return Iterators.getNext</b></font>(headSet(e, true).descendingIterator(), null);
250   }
251   @Override
252   @CheckForNull
253   public E ceiling(E e) {
254     return Iterables.getFirst(tailSet(e, true), null);
255   }
256   @GwtIncompatible   @Override
257   @CheckForNull
258   public E higher(E e) {
259     return Iterables.getFirst(tailSet(e, false), null);
260   }
261   @Override
262   public E first() {
263     return iterator().next();
264   }
265   @Override
266   public E last() {
267     return descendingIterator().next();
268   }
269   @CanIgnoreReturnValue
270   @Deprecated
271   @GwtIncompatible   @Override
272   @DoNotCall("Always throws UnsupportedOperationException")
273   @CheckForNull
274   public final E pollFirst() {
275     throw new UnsupportedOperationException();
276   }
277   @CanIgnoreReturnValue
278   @Deprecated
279   @GwtIncompatible   @Override
280   @DoNotCall("Always throws UnsupportedOperationException")
281   @CheckForNull
282   public final E pollLast() {
283     throw new UnsupportedOperationException();
284   }
285   @GwtIncompatible   @LazyInit
286   @CheckForNull
287   transient ImmutableSortedSet&lt;E&gt; descendingSet;
288   @GwtIncompatible   @Override
289   public ImmutableSortedSet&lt;E&gt; descendingSet() {
290     ImmutableSortedSet&lt;E&gt; result = descendingSet;
291     if (result == null) {
292       result = descendingSet = createDescendingSet();
293       result.descendingSet = this;
294     }
295     return result;
296   }
297   @GwtIncompatible   abstract ImmutableSortedSet&lt;E&gt; createDescendingSet();
298   @GwtIncompatible   @Override
299   public abstract UnmodifiableIterator&lt;E&gt; descendingIterator();
300   abstract int indexOf(@CheckForNull Object target);
301   /*
302    * This class is used to serialize all ImmutableSortedSet instances,
303    * regardless of implementation type. It captures their "logical contents"
304    * only. This is necessary to ensure that the existence of a particular
305    * implementation type is an implementation detail.
306    */
307   private static class SerializedForm&lt;E&gt; implements Serializable {
308     final Comparator&lt;? super E&gt; comparator;
309     final Object[] elements;
310     public SerializedForm(Comparator&lt;? super E&gt; comparator, Object[] elements) {
311       this.comparator = comparator;
312       this.elements = elements;
313     }
314     @SuppressWarnings("unchecked")
315     Object readResolve() {
316       return new Builder&lt;E&gt;(comparator).add((E[]) elements).build();
317     }
318     private static final long serialVersionUID = 0;
319   }
320   private void readObject(ObjectInputStream unused) throws InvalidObjectException {
321     throw new InvalidObjectException("Use SerializedForm");
322   }
323   @Override
324   Object writeReplace() {
325     return new SerializedForm&lt;E&gt;(comparator, toArray());
326   }
327 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
