<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for IntMath_1.java & ImmutableSortedSet_2.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for IntMath_1.java & ImmutableSortedSet_2.java
      </h3>
      <h1 align="center">
        10.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>IntMath_1.java (10.940171%)<TH>ImmutableSortedSet_2.java (9.785933%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match656144-0.html#0',2,'match656144-1.html#0',3)" NAME="0">(17-50)<TD><A HREF="javascript:ZweiFrames('match656144-0.html#0',2,'match656144-1.html#0',3)" NAME="0">(23-59)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match656144-0.html#1',2,'match656144-1.html#1',3)" NAME="1">(537-557)<TD><A HREF="javascript:ZweiFrames('match656144-0.html#1',2,'match656144-1.html#1',3)" NAME="1">(562-583)</A><TD ALIGN=center><FONT COLOR="#b20000">14</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match656144-0.html#2',2,'match656144-1.html#2',3)" NAME="2">(558-569)<TD><A HREF="javascript:ZweiFrames('match656144-0.html#2',2,'match656144-1.html#2',3)" NAME="2">(555-561)</A><TD ALIGN=center><FONT COLOR="#8c0000">11</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match656144-0.html#3',2,'match656144-1.html#3',3)" NAME="3">(303-317)<TD><A HREF="javascript:ZweiFrames('match656144-0.html#3',2,'match656144-1.html#3',3)" NAME="3">(604-610)</A><TD ALIGN=center><FONT COLOR="#7f0000">10</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match656144-0.html#4',2,'match656144-1.html#4',3)" NAME="4">(708-725)<TD><A HREF="javascript:ZweiFrames('match656144-0.html#4',2,'match656144-1.html#4',3)" NAME="4">(631-637)</A><TD ALIGN=center><FONT COLOR="#720000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>IntMath_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2011 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
<A NAME="0"></A>
package com.google.common.math;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match656144-1.html#0',3,'match656144-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.math.MathPreconditions.checkNoOverflow;
import static com.google.common.math.MathPreconditions.checkNonNegative;
import static com.google.common.math.MathPreconditions.checkPositive;
import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
import static java.lang.Math.abs;
import static java.lang.Math.min;
import static java.math.RoundingMode.HALF_EVEN;
import static java.math.RoundingMode.HALF_UP;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.primitives.Ints;
import java.math.BigInteger;
import java.math.RoundingMode;

/**
 * A class for arithmetic on values of type {@code int}. Where possible, methods are defined and
 * named analogously to their {@code BigInteger} counterparts.
 *
 * &lt;p&gt;The implementations of many methods in this class are based on material from Henry S. Warren,
 * Jr.'s &lt;i&gt;Hacker's Delight&lt;/i&gt;, (Addison Wesley, 2002).
 *
 * &lt;p&gt;Similar functionality for {@code long} and for {@link BigInteger} can be found in {@link
 * LongMath} and {@link BigIntegerMath} respectively. For other common operations on {@code int}
 * values, see {@link com.google.common.primitives.Ints}.
 *
 * @author Louis Wasserman
 * @since 11.0
 */
@GwtCompatible(e</B></FONT>mulated = true)
@ElementTypesAreNonnullByDefault
public final class IntMath {
  // NOTE: Whenever both tests are cheap and functional, it's faster to use &amp;, | instead of &amp;&amp;, ||

  @VisibleForTesting static final int MAX_SIGNED_POWER_OF_TWO = 1 &lt;&lt; (Integer.SIZE - 2);

  /**
   * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to
   * {@code checkedPow(2, log2(x, CEILING))}.
   *
   * @throws IllegalArgumentException if {@code x &lt;= 0}
   * @throws ArithmeticException of the next-higher power of two is not representable as an {@code
   *     int}, i.e. when {@code x &gt; 2^30}
   * @since 20.0
   */
  @Beta
  public static int ceilingPowerOfTwo(int x) {
    checkPositive(&quot;x&quot;, x);
    if (x &gt; MAX_SIGNED_POWER_OF_TWO) {
      throw new ArithmeticException(&quot;ceilingPowerOfTwo(&quot; + x + &quot;) not representable as an int&quot;);
    }
    return 1 &lt;&lt; -Integer.numberOfLeadingZeros(x - 1);
  }

  /**
   * Returns the largest power of two less than or equal to {@code x}. This is equivalent to {@code
   * checkedPow(2, log2(x, FLOOR))}.
   *
   * @throws IllegalArgumentException if {@code x &lt;= 0}
   * @since 20.0
   */
  @Beta
  public static int floorPowerOfTwo(int x) {
    checkPositive(&quot;x&quot;, x);
    return Integer.highestOneBit(x);
  }

  /**
   * Returns {@code true} if {@code x} represents a power of two.
   *
   * &lt;p&gt;This differs from {@code Integer.bitCount(x) == 1}, because {@code
   * Integer.bitCount(Integer.MIN_VALUE) == 1}, but {@link Integer#MIN_VALUE} is not a power of two.
   */
  public static boolean isPowerOfTwo(int x) {
    return x &gt; 0 &amp; (x &amp; (x - 1)) == 0;
  }

  /**
   * Returns 1 if {@code x &lt; y} as unsigned integers, and 0 otherwise. Assumes that x - y fits into
   * a signed int. The implementation is branch-free, and benchmarks suggest it is measurably (if
   * narrowly) faster than the straightforward ternary expression.
   */
  @VisibleForTesting
  static int lessThanBranchFree(int x, int y) {
    // The double negation is optimized away by normal Java, but is necessary for GWT
    // to make sure bit twiddling works as expected.
    return ~~(x - y) &gt;&gt;&gt; (Integer.SIZE - 1);
  }

  /**
   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.
   *
   * @throws IllegalArgumentException if {@code x &lt;= 0}
   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
   *     is not a power of two
   */
  @SuppressWarnings(&quot;fallthrough&quot;)
  // TODO(kevinb): remove after this warning is disabled globally
  public static int log2(int x, RoundingMode mode) {
    checkPositive(&quot;x&quot;, x);
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(isPowerOfTwo(x));
        // fall through
      case DOWN:
      case FLOOR:
        return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);

      case UP:
      case CEILING:
        return Integer.SIZE - Integer.numberOfLeadingZeros(x - 1);

      case HALF_DOWN:
      case HALF_UP:
      case HALF_EVEN:
        // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5
        int leadingZeros = Integer.numberOfLeadingZeros(x);
        int cmp = MAX_POWER_OF_SQRT2_UNSIGNED &gt;&gt;&gt; leadingZeros;
        // floor(2^(logFloor + 0.5))
        int logFloor = (Integer.SIZE - 1) - leadingZeros;
        return logFloor + lessThanBranchFree(cmp, x);

      default:
        throw new AssertionError();
    }
  }

  /** The biggest half power of two that can fit in an unsigned int. */
  @VisibleForTesting static final int MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333;

  /**
   * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.
   *
   * @throws IllegalArgumentException if {@code x &lt;= 0}
   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
   *     is not a power of ten
   */
  @GwtIncompatible // need BigIntegerMath to adequately test
  @SuppressWarnings(&quot;fallthrough&quot;)
  public static int log10(int x, RoundingMode mode) {
    checkPositive(&quot;x&quot;, x);
    int logFloor = log10Floor(x);
    int floorPow = powersOf10[logFloor];
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(x == floorPow);
        // fall through
      case FLOOR:
      case DOWN:
        return logFloor;
      case CEILING:
      case UP:
        return logFloor + lessThanBranchFree(floorPow, x);
      case HALF_DOWN:
      case HALF_UP:
      case HALF_EVEN:
        // sqrt(10) is irrational, so log10(x) - logFloor is never exactly 0.5
        return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);
      default:
        throw new AssertionError();
    }
  }

  private static int log10Floor(int x) {
    /*
     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation.
     *
     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))), we
     * can narrow the possible floor(log10(x)) values to two. For example, if floor(log2(x)) is 6,
     * then 64 &lt;= x &lt; 128, so floor(log10(x)) is either 1 or 2.
     */
    int y = maxLog10ForLeadingZeros[Integer.numberOfLeadingZeros(x)];
    /*
     * y is the higher of the two possible values of floor(log10(x)). If x &lt; 10^y, then we want the
     * lower of the two possible values, or y - 1, otherwise, we want y.
     */
    return y - lessThanBranchFree(x, powersOf10[y]);
  }

  // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))
  @VisibleForTesting
  static final byte[] maxLog10ForLeadingZeros = {
    9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0,
    0
  };

  @VisibleForTesting
  static final int[] powersOf10 = {
    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
  };

  // halfPowersOf10[i] = largest int less than 10^(i + 0.5)
  @VisibleForTesting
  static final int[] halfPowersOf10 = {
    3, 31, 316, 3162, 31622, 316227, 3162277, 31622776, 316227766, Integer.MAX_VALUE
  };

  /**
   * Returns {@code b} to the {@code k}th power. Even if the result overflows, it will be equal to
   * {@code BigInteger.valueOf(b).pow(k).intValue()}. This implementation runs in {@code O(log k)}
   * time.
   *
   * &lt;p&gt;Compare {@link #checkedPow}, which throws an {@link ArithmeticException} upon overflow.
   *
   * @throws IllegalArgumentException if {@code k &lt; 0}
   */
  @GwtIncompatible // failing tests
  public static int pow(int b, int k) {
    checkNonNegative(&quot;exponent&quot;, k);
    switch (b) {
      case 0:
        return (k == 0) ? 1 : 0;
      case 1:
        return 1;
      case (-1):
        return ((k &amp; 1) == 0) ? 1 : -1;
      case 2:
        return (k &lt; Integer.SIZE) ? (1 &lt;&lt; k) : 0;
      case (-2):
        if (k &lt; Integer.SIZE) {
          return ((k &amp; 1) == 0) ? (1 &lt;&lt; k) : -(1 &lt;&lt; k);
        } else {
          return 0;
        }
      default:
        // continue below to handle the general case
    }
    for (int accum = 1; ; k &gt;&gt;= 1) {
      switch (k) {
        case 0:
          return accum;
        case 1:
          return b * accum;
        default:
          accum *= ((k &amp; 1) == 0) ? 1 : b;
          b *= b;
      }
    }
  }

  /**
   * Returns the square root of {@code x}, rounded with the specified rounding mode.
   *
   * @throws IllegalArgumentException if {@code x &lt; 0}
   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code
   *     sqrt(x)} is not an integer
   */
  @GwtIncompatible // need BigIntegerMath to adequately test
  @SuppressWarnings(&quot;fallthrough&quot;)
  public static int sqrt(int x, RoundingMode mode) {
    checkNonNegative(&quot;x&quot;, x);
    int sqrtFloor = sqrtFloor(x);
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(sqrtFloor * sqrtFloor == x); // fall through
      case FLOOR:
      case DOWN:
        return sqrtFloor;
      case CEILING:
      case UP:
        return sqrtFloor + lessThanBranchFree(sqrtFloor * sqrtFloor, x);
      case HALF_DOWN:
      case HALF_UP:
      case HALF_EVEN:
        int halfSquare = sqrtFloor * sqrtFloor + sqrtFloor;
        /*
         * We wish to test whether or not x &lt;= (sqrtFloor + 0.5)^2 = halfSquare + 0.25. Since both x
         * and halfSquare are integers, this is equivalent to testing whether or not x &lt;=
         * halfSquare. (We have to deal with overflow, though.)
         *
         * If we treat halfSquare as an unsigned int, we know that
         *            sqrtFloor^2 &lt;= x &lt; (sqrtFloor + 1)^2
         * halfSquare - sqrtFloor &lt;= x &lt; halfSquare + sqrtFloor + 1
         * so |x - halfSquare| &lt;= sqrtFloor.  Therefore, it's safe to treat x - halfSquare as a
         * signed int, so lessThanBranchFree is safe for use.
         */
        return sqrtFloor + lessThanBranchFree(halfSquare, x);
      default:
        throw new AssertionError();
<A NAME="3"></A>    }
  }

  private static int sqrtFloor(<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match656144-1.html#3',3,'match656144-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>int x) {
    // There is no loss of precision in converting an int to a double, according to
    // http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#5.1.2
    return (int) Math.sqrt(x);
  }

  /**
   * Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code
   * RoundingMode}.
   *
   * @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
   *     is not an integer multiple of {@code b}
   */
  @SuppressWarnings(&quot;fallthrough&quot;)
  public static int divide(int p, int q</B></FONT>, RoundingMode mode) {
    checkNotNull(mode);
    if (q == 0) {
      throw new ArithmeticException(&quot;/ by zero&quot;); // for GWT
    }
    int div = p / q;
    int rem = p - q * div; // equal to p % q

    if (rem == 0) {
      return div;
    }

    /*
     * Normal Java division rounds towards 0, consistently with RoundingMode.DOWN. We just have to
     * deal with the cases where rounding towards 0 is wrong, which typically depends on the sign of
     * p / q.
     *
     * signum is 1 if p and q are both nonnegative or both negative, and -1 otherwise.
     */
    int signum = 1 | ((p ^ q) &gt;&gt; (Integer.SIZE - 1));
    boolean increment;
    switch (mode) {
      case UNNECESSARY:
        checkRoundingUnnecessary(rem == 0);
        // fall through
      case DOWN:
        increment = false;
        break;
      case UP:
        increment = true;
        break;
      case CEILING:
        increment = signum &gt; 0;
        break;
      case FLOOR:
        increment = signum &lt; 0;
        break;
      case HALF_EVEN:
      case HALF_DOWN:
      case HALF_UP:
        int absRem = abs(rem);
        int cmpRemToHalfDivisor = absRem - (abs(q) - absRem);
        // subtracting two nonnegative ints can't overflow
        // cmpRemToHalfDivisor has the same sign as compare(abs(rem), abs(q) / 2).
        if (cmpRemToHalfDivisor == 0) { // exactly on the half mark
          increment = (mode == HALF_UP || (mode == HALF_EVEN &amp; (div &amp; 1) != 0));
        } else {
          increment = cmpRemToHalfDivisor &gt; 0; // closer to the UP value
        }
        break;
      default:
        throw new AssertionError();
    }
    return increment ? div + signum : div;
  }

  /**
   * Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x %
   * m}, which might be negative.
   *
   * &lt;p&gt;For example:
   *
   * &lt;pre&gt;{@code
   * mod(7, 4) == 3
   * mod(-7, 4) == 1
   * mod(-1, 4) == 3
   * mod(-8, 4) == 0
   * mod(8, 4) == 0
   * }&lt;/pre&gt;
   *
   * @throws ArithmeticException if {@code m &lt;= 0}
   * @see &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3&quot;&gt;
   *     Remainder Operator&lt;/a&gt;
   */
  public static int mod(int x, int m) {
    if (m &lt;= 0) {
      throw new ArithmeticException(&quot;Modulus &quot; + m + &quot; must be &gt; 0&quot;);
    }
    int result = x % m;
    return (result &gt;= 0) ? result : result + m;
  }

  /**
   * Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if {@code a == 0 &amp;&amp; b ==
   * 0}.
   *
   * @throws IllegalArgumentException if {@code a &lt; 0} or {@code b &lt; 0}
   */
  public static int gcd(int a, int b) {
    /*
     * The reason we require both arguments to be &gt;= 0 is because otherwise, what do you return on
     * gcd(0, Integer.MIN_VALUE)? BigInteger.gcd would return positive 2^31, but positive 2^31 isn't
     * an int.
     */
    checkNonNegative(&quot;a&quot;, a);
    checkNonNegative(&quot;b&quot;, b);
    if (a == 0) {
      // 0 % b == 0, so b divides a, but the converse doesn't hold.
      // BigInteger.gcd is consistent with this decision.
      return b;
    } else if (b == 0) {
      return a; // similar logic
    }
    /*
     * Uses the binary GCD algorithm; see http://en.wikipedia.org/wiki/Binary_GCD_algorithm. This is
     * &gt;40% faster than the Euclidean algorithm in benchmarks.
     */
    int aTwos = Integer.numberOfTrailingZeros(a);
    a &gt;&gt;= aTwos; // divide out all 2s
    int bTwos = Integer.numberOfTrailingZeros(b);
    b &gt;&gt;= bTwos; // divide out all 2s
    while (a != b) { // both a, b are odd
      // The key to the binary GCD algorithm is as follows:
      // Both a and b are odd. Assume a &gt; b; then gcd(a - b, b) = gcd(a, b).
      // But in gcd(a - b, b), a - b is even and b is odd, so we can divide out powers of two.

      // We bend over backwards to avoid branching, adapting a technique from
      // http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax

      int delta = a - b; // can't overflow, since a and b are nonnegative

      int minDeltaOrZero = delta &amp; (delta &gt;&gt; (Integer.SIZE - 1));
      // equivalent to Math.min(delta, 0)

      a = delta - minDeltaOrZero - minDeltaOrZero; // sets a to Math.abs(a - b)
      // a is now nonnegative and even

      b += minDeltaOrZero; // sets b to min(old a, b)
      a &gt;&gt;= Integer.numberOfTrailingZeros(a); // divide out all 2s, since 2 doesn't divide b
    }
    return a &lt;&lt; min(aTwos, bTwos);
  }

  /**
   * Returns the sum of {@code a} and {@code b}, provided it does not overflow.
   *
   * @throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic
   */
  public static int checkedAdd(int a, int b) {
    long result = (long) a + b;
    checkNoOverflow(result == (int) result, &quot;checkedAdd&quot;, a, b);
    return (int) result;
  }

  /**
   * Returns the difference of {@code a} and {@code b}, provided it does not overflow.
   *
   * @throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic
   */
  public static int checkedSubtract(int a, int b) {
    long result = (long) a - b;
    checkNoOverflow(result == (int) result, &quot;checkedSubtract&quot;, a, b);
    return (int) result;
  }

  /**
   * Returns the product of {@code a} and {@code b}, provided it does not overflow.
   *
   * @throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic
   */
  public static int checkedMultiply(int a, int b) {
    long result = (long) a * b;
    checkNoOverflow(result == (int) result, &quot;checkedMultiply&quot;, a, b);
    return (int) result;
  }

  /**
   * Returns the {@code b} to the {@code k}th power, provided it does not overflow.
   *
   * &lt;p&gt;{@link #pow} may be faster, but does not check for overflow.
   *
   * @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed {@code
   *     int} arithmetic
   */
  public static int checkedPow(int b, int k) {
    checkNonNegative(&quot;exponent&quot;, k);
    switch (b) {
      case 0:
        return (k == 0) ? 1 : 0;
      case 1:
        return 1;
      case (-1):
        return ((k &amp; 1) == 0) ? 1 : -1;
      case 2:
        checkNoOverflow(k &lt; Integer.SIZE - 1, &quot;checkedPow&quot;, b, k);
        return 1 &lt;&lt; k;
      case (-2):
        checkNoOverflow(k &lt; Integer.SIZE, &quot;checkedPow&quot;, b, k);
        return ((k &amp; 1) == 0) ? 1 &lt;&lt; k : -1 &lt;&lt; k;
      default:
        // continue below to handle the general case
    }
    int accum = 1;
    while (true) {
      switch (k) {
        case 0:
          return accum;
        case 1:
          return checkedMultiply(accum, b);
        default:
          if ((k &amp; 1) != 0) {
            accum = checkedMultiply(accum, b);
          }
          k &gt;&gt;= 1;
          if (k &gt; 0) {
            checkNoOverflow(-FLOOR_SQRT_MAX_INT &lt;= b &amp; b &lt;= FLOOR_SQRT_MAX_INT, &quot;checkedPow&quot;, b, k);
            b *= b;
          }
      }
    }
  }

  /**
   * Returns the sum of {@code a} and {@code b} unless it would overflow or underflow in which case
   * {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.
   *
   * @since 20.0
<A NAME="1"></A>   */
  @Beta
  public static int saturatedAdd(int a, int b) {
    return <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match656144-1.html#1',3,'match656144-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Ints.saturatedCast((long) a + b);
  }

  /**
   * Returns the difference of {@code a} and {@code b} unless it would overflow or underflow in
   * which case {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.
   *
   * @since 20.0
   */
  @Beta
  public static int saturatedSubtract(int a, int b) {
    return Ints.saturatedCast((long) a - b);
  }

  /**
   * Returns the product of {@code a} and {@code b} unless it would overflow or underflow in which
   * case {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.
   *
<A NAME="2"></A>   * @since 20.0
   */
  @</B></FONT>Beta
  public static int saturatedMultiply(int a, <FONT color="#980517"><A HREF="javascript:ZweiFrames('match656144-1.html#2',3,'match656144-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>int b) {
    return Ints.saturatedCast((long) a * b);
  }

  /**
   * Returns the {@code b} to the {@code k}th power, unless it would overflow or underflow in which
   * case {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.
   *
   * @since 20.0
   */
  @Beta
  public static int saturatedPow(int b, int k) {</B></FONT>
    checkNonNegative(&quot;exponent&quot;, k);
    switch (b) {
      case 0:
        return (k == 0) ? 1 : 0;
      case 1:
        return 1;
      case (-1):
        return ((k &amp; 1) == 0) ? 1 : -1;
      case 2:
        if (k &gt;= Integer.SIZE - 1) {
          return Integer.MAX_VALUE;
        }
        return 1 &lt;&lt; k;
      case (-2):
        if (k &gt;= Integer.SIZE) {
          return Integer.MAX_VALUE + (k &amp; 1);
        }
        return ((k &amp; 1) == 0) ? 1 &lt;&lt; k : -1 &lt;&lt; k;
      default:
        // continue below to handle the general case
    }
    int accum = 1;
    // if b is negative and k is odd then the limit is MIN otherwise the limit is MAX
    int limit = Integer.MAX_VALUE + ((b &gt;&gt;&gt; Integer.SIZE - 1) &amp; (k &amp; 1));
    while (true) {
      switch (k) {
        case 0:
          return accum;
        case 1:
          return saturatedMultiply(accum, b);
        default:
          if ((k &amp; 1) != 0) {
            accum = saturatedMultiply(accum, b);
          }
          k &gt;&gt;= 1;
          if (k &gt; 0) {
            if (-FLOOR_SQRT_MAX_INT &gt; b | b &gt; FLOOR_SQRT_MAX_INT) {
              return limit;
            }
            b *= b;
          }
      }
    }
  }

  @VisibleForTesting static final int FLOOR_SQRT_MAX_INT = 46340;

  /**
   * Returns {@code n!}, that is, the product of the first {@code n} positive integers, {@code 1} if
   * {@code n == 0}, or {@link Integer#MAX_VALUE} if the result does not fit in a {@code int}.
   *
   * @throws IllegalArgumentException if {@code n &lt; 0}
   */
  public static int factorial(int n) {
    checkNonNegative(&quot;n&quot;, n);
    return (n &lt; factorials.length) ? factorials[n] : Integer.MAX_VALUE;
  }

  private static final int[] factorials = {
    1,
    1,
    1 * 2,
    1 * 2 * 3,
    1 * 2 * 3 * 4,
    1 * 2 * 3 * 4 * 5,
    1 * 2 * 3 * 4 * 5 * 6,
    1 * 2 * 3 * 4 * 5 * 6 * 7,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,
    1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12
  };

  /**
   * Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and
   * {@code k}, or {@link Integer#MAX_VALUE} if the result does not fit in an {@code int}.
   *
   * @throws IllegalArgumentException if {@code n &lt; 0}, {@code k &lt; 0} or {@code k &gt; n}
   */
  public static int binomial(int n, int k) {
    checkNonNegative(&quot;n&quot;, n);
    checkNonNegative(&quot;k&quot;, k);
    checkArgument(k &lt;= n, &quot;k (%s) &gt; n (%s)&quot;, k, n);
    if (k &gt; (n &gt;&gt; 1)) {
      k = n - k;
    }
    if (k &gt;= biggestBinomials.length || n &gt; biggestBinomials[k]) {
      return Integer.MAX_VALUE;
    }
    switch (k) {
      case 0:
        return 1;
      case 1:
        return n;
      default:
        long result = 1;
        for (int i = 0; i &lt; k; i++) {
          result *= n - i;
          result /= i + 1;
        }
        return (int) result;
    }
  }

  // binomial(biggestBinomials[k], k) fits in an int, but not binomial(biggestBinomials[k]+1,k).
  @VisibleForTesting
  static int[] biggestBinomials = {
    Integer.MAX_VALUE,
    Integer.MAX_VALUE,
    65536,
    2345,
    477,
    193,
    110,
    75,
    58,
    49,
    43,
    39,
    37,
    35,
    34,
    34,
    33
  };

  /**
   * Returns the arithmetic mean of {@code x} and {@code y}, rounded towards negative infinity. This
   * method is overflow resilient.
   *
   * @since 14.0
   */
  public static int mean(int x, int y) {
    // Efficient method for computing the arithmetic mean.
<A NAME="4"></A>    // The alternative (x + y) / 2 fails for large values.
    // The alternative (x + y) &gt;&gt;&gt; 1 fails for negative values.
    return (x &amp; y) + ((x ^ y) &gt;&gt; 1);
  <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match656144-1.html#4',3,'match656144-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

  /**
   * Returns {@code true} if {@code n} is a &lt;a
   * href=&quot;http://mathworld.wolfram.com/PrimeNumber.html&quot;&gt;prime number&lt;/a&gt;: an integer &lt;i&gt;greater
   * than one&lt;/i&gt; that cannot be factored into a product of &lt;i&gt;smaller&lt;/i&gt; positive integers.
   * Returns {@code false} if {@code n} is zero, one, or a composite number (one which &lt;i&gt;can&lt;/i&gt; be
   * factored into smaller positive integers).
   *
   * &lt;p&gt;To test larger numbers, use {@link LongMath#isPrime} or {@link BigInteger#isProbablePrime}.
   *
   * @throws IllegalArgumentException if {@code n} is negative
   * @since 20.0
   */
  @GwtIncompatible // TODO
  @Beta
  public static boolean isPrime(int n) {
    return LongMath.isPrime</B></FONT>(n);
  }

  private IntMath() {}
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ImmutableSortedSet_2.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2008 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.base.Preconditions.checkArgument;
<A NAME="0"></A>import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.ObjectArrays.checkElementsNotNull;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match656144-0.html#0',2,'match656144-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NavigableSet;
import java.util.SortedSet;
import javax.annotation.CheckForNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A {@link NavigableSet} whose contents will never change, with many other important properties
 * detailed at {@link ImmutableCollection}.
 *
 * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; as with any sorted collection, you are strongly advised not to use a {@link
 * Comparator} or {@link Comparable} type whose comparison behavior is &lt;i&gt;inconsistent with
 * equals&lt;/i&gt;. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero
 * &lt;i&gt;if and only if&lt;/i&gt; {@code a.equals(b)}. If this advice is not followed, the resulting
 * collection will not correctly obey its specification.
 *
 * &lt;p&gt;See the Guava User Guide article on &lt;a href=
 * &quot;https://github.com/google/guava/wiki/ImmutableCollectionsExplained&quot;&gt;immutable collections&lt;/a&gt;.
 *
 * @author Jared Levy
 * @author Louis Wasserman
 * @since 2.0 (implements {@code NavigableSet} since 12.0)
 */
// TODO(benyu): benchmark and optimize all creation paths, which are a mess now
@GwtCompatible(s</B></FONT>erializable = true, emulated = true)
@SuppressWarnings(&quot;serial&quot;) // we're overriding default serialization
@ElementTypesAreNonnullByDefault
public abstract class ImmutableSortedSet&lt;E&gt; extends ImmutableSortedSetFauxverideShim&lt;E&gt;
    implements NavigableSet&lt;E&gt;, SortedIterable&lt;E&gt; {
  static &lt;E&gt; RegularImmutableSortedSet&lt;E&gt; emptySet(Comparator&lt;? super E&gt; comparator) {
    if (Ordering.natural().equals(comparator)) {
      return (RegularImmutableSortedSet&lt;E&gt;) RegularImmutableSortedSet.NATURAL_EMPTY_SET;
    } else {
      return new RegularImmutableSortedSet&lt;E&gt;(ImmutableList.&lt;E&gt;of(), comparator);
    }
  }

  /**
   * Returns the empty immutable sorted set.
   *
   * &lt;p&gt;&lt;b&gt;Performance note:&lt;/b&gt; the instance returned is a singleton.
   */
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; of() {
    return (ImmutableSortedSet&lt;E&gt;) RegularImmutableSortedSet.NATURAL_EMPTY_SET;
  }

  /** Returns an immutable sorted set containing a single element. */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E element) {
    return new RegularImmutableSortedSet&lt;E&gt;(ImmutableList.of(element), Ordering.natural());
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
   * one specified is included.
   *
   * @throws NullPointerException if any element is null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2) {
    return construct(Ordering.natural(), 2, e1, e2);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
   * one specified is included.
   *
   * @throws NullPointerException if any element is null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2, E e3) {
    return construct(Ordering.natural(), 3, e1, e2, e3);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
   * one specified is included.
   *
   * @throws NullPointerException if any element is null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(E e1, E e2, E e3, E e4) {
    return construct(Ordering.natural(), 4, e1, e2, e3, e4);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
   * one specified is included.
   *
   * @throws NullPointerException if any element is null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5) {
    return construct(Ordering.natural(), 5, e1, e2, e3, e4, e5);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
   * one specified is included.
   *
   * @throws NullPointerException if any element is null
   * @since 3.0 (source-compatible since 2.0)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; of(
      E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
    Comparable[] contents = new Comparable[6 + remaining.length];
    contents[0] = e1;
    contents[1] = e2;
    contents[2] = e3;
    contents[3] = e4;
    contents[4] = e5;
    contents[5] = e6;
    System.arraycopy(remaining, 0, contents, 6, remaining.length);
    return construct(Ordering.natural(), contents.length, (E[]) contents);
  }

  // TODO(kevinb): Consider factory methods that reject duplicates

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
   * one specified is included.
   *
   * @throws NullPointerException if any of {@code elements} is null
   * @since 3.0
   */
  public static &lt;E extends Comparable&lt;? super E&gt;&gt; ImmutableSortedSet&lt;E&gt; copyOf(E[] elements) {
    return construct(Ordering.natural(), elements.length, elements.clone());
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@code compareTo()}, only the first one
   * specified is included. To create a copy of a {@code SortedSet} that preserves the comparator,
   * call {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.
   *
   * &lt;p&gt;Note that if {@code s} is a {@code Set&lt;String&gt;}, then {@code ImmutableSortedSet.copyOf(s)}
   * returns an {@code ImmutableSortedSet&lt;String&gt;} containing each of the strings in {@code s},
   * while {@code ImmutableSortedSet.of(s)} returns an {@code ImmutableSortedSet&lt;Set&lt;String&gt;&gt;}
   * containing one element (the given set itself).
   *
   * &lt;p&gt;Despite the method name, this method attempts to avoid actually copying the data when it is
   * safe to do so. The exact circumstances under which a copy will or will not be performed are
   * undocumented and subject to change.
   *
   * &lt;p&gt;This method is not type-safe, as it may be called on elements that are not mutually
   * comparable.
   *
   * @throws ClassCastException if the elements are not mutually comparable
   * @throws NullPointerException if any of {@code elements} is null
   */
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Iterable&lt;? extends E&gt; elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedSetFauxverideShim.
    @SuppressWarnings(&quot;unchecked&quot;)
    Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@code compareTo()}, only the first one
   * specified is included. To create a copy of a {@code SortedSet} that preserves the comparator,
   * call {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.
   *
   * &lt;p&gt;Note that if {@code s} is a {@code Set&lt;String&gt;}, then {@code ImmutableSortedSet.copyOf(s)}
   * returns an {@code ImmutableSortedSet&lt;String&gt;} containing each of the strings in {@code s},
   * while {@code ImmutableSortedSet.of(s)} returns an {@code ImmutableSortedSet&lt;Set&lt;String&gt;&gt;}
   * containing one element (the given set itself).
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; Despite what the method name suggests, if {@code elements} is an {@code
   * ImmutableSortedSet}, it may be returned instead of a copy.
   *
   * &lt;p&gt;This method is not type-safe, as it may be called on elements that are not mutually
   * comparable.
   *
   * &lt;p&gt;This method is safe to use even when {@code elements} is a synchronized or concurrent
   * collection that is currently being modified by another thread.
   *
   * @throws ClassCastException if the elements are not mutually comparable
   * @throws NullPointerException if any of {@code elements} is null
   * @since 7.0 (source-compatible since 2.0)
   */
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Collection&lt;? extends E&gt; elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedSetFauxverideShim.
    @SuppressWarnings(&quot;unchecked&quot;)
    Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by their natural ordering.
   * When multiple elements are equivalent according to {@code compareTo()}, only the first one
   * specified is included.
   *
   * &lt;p&gt;This method is not type-safe, as it may be called on elements that are not mutually
   * comparable.
   *
   * @throws ClassCastException if the elements are not mutually comparable
   * @throws NullPointerException if any of {@code elements} is null
   */
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(Iterator&lt;? extends E&gt; elements) {
    // Hack around E not being a subtype of Comparable.
    // Unsafe, see ImmutableSortedSetFauxverideShim.
    @SuppressWarnings(&quot;unchecked&quot;)
    Ordering&lt;E&gt; naturalOrder = (Ordering&lt;E&gt;) Ordering.&lt;Comparable&gt;natural();
    return copyOf(naturalOrder, elements);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by the given {@code
   * Comparator}. When multiple elements are equivalent according to {@code compareTo()}, only the
   * first one specified is included.
   *
   * @throws NullPointerException if {@code comparator} or any of {@code elements} is null
   */
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
      Comparator&lt;? super E&gt; comparator, Iterator&lt;? extends E&gt; elements) {
    return new Builder&lt;E&gt;(comparator).addAll(elements).build();
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by the given {@code
   * Comparator}. When multiple elements are equivalent according to {@code compare()}, only the
   * first one specified is included. This method iterates over {@code elements} at most once.
   *
   * &lt;p&gt;Despite the method name, this method attempts to avoid actually copying the data when it is
   * safe to do so. The exact circumstances under which a copy will or will not be performed are
   * undocumented and subject to change.
   *
   * @throws NullPointerException if {@code comparator} or any of {@code elements} is null
   */
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
      Comparator&lt;? super E&gt; comparator, Iterable&lt;? extends E&gt; elements) {
    checkNotNull(comparator);
    boolean hasSameComparator = SortedIterables.hasSameComparator(comparator, elements);

    if (hasSameComparator &amp;&amp; (elements instanceof ImmutableSortedSet)) {
      @SuppressWarnings(&quot;unchecked&quot;)
      ImmutableSortedSet&lt;E&gt; original = (ImmutableSortedSet&lt;E&gt;) elements;
      if (!original.isPartialView()) {
        return original;
      }
    }
    @SuppressWarnings(&quot;unchecked&quot;) // elements only contains E's; it's safe.
    E[] array = (E[]) Iterables.toArray(elements);
    return construct(comparator, array.length, array);
  }

  /**
   * Returns an immutable sorted set containing the given elements sorted by the given {@code
   * Comparator}. When multiple elements are equivalent according to {@code compareTo()}, only the
   * first one specified is included.
   *
   * &lt;p&gt;Despite the method name, this method attempts to avoid actually copying the data when it is
   * safe to do so. The exact circumstances under which a copy will or will not be performed are
   * undocumented and subject to change.
   *
   * &lt;p&gt;This method is safe to use even when {@code elements} is a synchronized or concurrent
   * collection that is currently being modified by another thread.
   *
   * @throws NullPointerException if {@code comparator} or any of {@code elements} is null
   * @since 7.0 (source-compatible since 2.0)
   */
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOf(
      Comparator&lt;? super E&gt; comparator, Collection&lt;? extends E&gt; elements) {
    return copyOf(comparator, (Iterable&lt;? extends E&gt;) elements);
  }

  /**
   * Returns an immutable sorted set containing the elements of a sorted set, sorted by the same
   * {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always uses the
   * natural ordering of the elements.
   *
   * &lt;p&gt;Despite the method name, this method attempts to avoid actually copying the data when it is
   * safe to do so. The exact circumstances under which a copy will or will not be performed are
   * undocumented and subject to change.
   *
   * &lt;p&gt;This method is safe to use even when {@code sortedSet} is a synchronized or concurrent
   * collection that is currently being modified by another thread.
   *
   * @throws NullPointerException if {@code sortedSet} or any of its elements is null
   */
  public static &lt;E&gt; ImmutableSortedSet&lt;E&gt; copyOfSorted(SortedSet&lt;E&gt; sortedSet) {
    Comparator&lt;? super E&gt; comparator = SortedIterables.comparator(sortedSet);
    ImmutableList&lt;E&gt; list = ImmutableList.copyOf(sortedSet);
    if (list.isEmpty()) {
      return emptySet(comparator);
    } else {
      return new RegularImmutableSortedSet&lt;E&gt;(list, comparator);
    }
  }

  /**
   * Constructs an {@code ImmutableSortedSet} from the first {@code n} elements of {@code contents}.
   * If {@code k} is the size of the returned {@code ImmutableSortedSet}, then the sorted unique
   * elements are in the first {@code k} positions of {@code contents}, and {@code contents[i] ==
   * null} for {@code k &lt;= i &lt; n}.
   *
   * &lt;p&gt;This method takes ownership of {@code contents}; do not modify {@code contents} after this
   * returns.
   *
   * @throws NullPointerException if any of the first {@code n} elements of {@code contents} is null
   */
  static &lt;E&gt; ImmutableSortedSet&lt;E&gt; construct(
      Comparator&lt;? super E&gt; comparator, int n, E... contents) {
    if (n == 0) {
      return emptySet(comparator);
    }
    checkElementsNotNull(contents, n);
    Arrays.sort(contents, 0, n, comparator);
    int uniques = 1;
    for (int i = 1; i &lt; n; i++) {
      E cur = contents[i];
      E prev = contents[uniques - 1];
      if (comparator.compare(cur, prev) != 0) {
        contents[uniques++] = cur;
      }
    }
    Arrays.fill(contents, uniques, n, null);
    if (uniques &lt; contents.length / 2) {
      // Deduplication eliminated many of the elements.  We don't want to retain an arbitrarily
      // large array relative to the number of elements, so we cap the ratio.
      contents = Arrays.copyOf(contents, uniques);
    }
    return new RegularImmutableSortedSet&lt;E&gt;(
        ImmutableList.&lt;E&gt;asImmutableList(contents, uniques), comparator);
  }

  /**
   * Returns a builder that creates immutable sorted sets with an explicit comparator. If the
   * comparator has a more general type than the set being generated, such as creating a {@code
   * SortedSet&lt;Integer&gt;} with a {@code Comparator&lt;Number&gt;}, use the {@link Builder} constructor
   * instead.
   *
   * @throws NullPointerException if {@code comparator} is null
   */
  public static &lt;E&gt; Builder&lt;E&gt; orderedBy(Comparator&lt;E&gt; comparator) {
    return new Builder&lt;E&gt;(comparator);
  }

  /**
   * Returns a builder that creates immutable sorted sets whose elements are ordered by the reverse
   * of their natural ordering.
   */
  public static &lt;E extends Comparable&lt;?&gt;&gt; Builder&lt;E&gt; reverseOrder() {
    return new Builder&lt;E&gt;(Collections.reverseOrder());
  }

  /**
   * Returns a builder that creates immutable sorted sets whose elements are ordered by their
   * natural ordering. The sorted sets use {@link Ordering#natural()} as the comparator. This method
   * provides more type-safety than {@link #builder}, as it can be called only for classes that
   * implement {@link Comparable}.
   */
  public static &lt;E extends Comparable&lt;?&gt;&gt; Builder&lt;E&gt; naturalOrder() {
    return new Builder&lt;E&gt;(Ordering.natural());
  }

  /**
   * A builder for creating immutable sorted set instances, especially {@code public static final}
   * sets (&quot;constant sets&quot;), with a given comparator. Example:
   *
   * &lt;pre&gt;{@code
   * public static final ImmutableSortedSet&lt;Number&gt; LUCKY_NUMBERS =
   *     new ImmutableSortedSet.Builder&lt;Number&gt;(ODDS_FIRST_COMPARATOR)
   *         .addAll(SINGLE_DIGIT_PRIMES)
   *         .add(42)
   *         .build();
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;Builder instances can be reused; it is safe to call {@link #build} multiple times to build
   * multiple sets in series. Each set is a superset of the set created before it.
   *
   * @since 2.0
   */
  public static final class Builder&lt;E&gt; extends ImmutableSet.Builder&lt;E&gt; {
    private final Comparator&lt;? super E&gt; comparator;

    /**
     * Creates a new builder. The returned builder is equivalent to the builder generated by {@link
     * ImmutableSortedSet#orderedBy}.
     */
    public Builder(Comparator&lt;? super E&gt; comparator) {
      this.comparator = checkNotNull(comparator);
    }

    /**
     * Adds {@code element} to the {@code ImmutableSortedSet}. If the {@code ImmutableSortedSet}
     * already contains {@code element}, then {@code add} has no effect. (only the previously added
     * element is retained).
     *
     * @param element the element to add
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code element} is null
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E element) {
      super.add(element);
      return this;
    }

    /**
     * Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate
     * elements (only the first duplicate element is added).
     *
     * @param elements the elements to add
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code elements} contains a null element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; add(E... elements) {
      super.add(elements);
      return this;
    }

    /**
     * Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate
     * elements (only the first duplicate element is added).
     *
     * @param elements the elements to add to the {@code ImmutableSortedSet}
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code elements} contains a null element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterable&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }

    /**
     * Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate
     * elements (only the first duplicate element is added).
     *
     * @param elements the elements to add to the {@code ImmutableSortedSet}
     * @return this {@code Builder} object
     * @throws NullPointerException if {@code elements} contains a null element
     */
    @CanIgnoreReturnValue
    @Override
    public Builder&lt;E&gt; addAll(Iterator&lt;? extends E&gt; elements) {
      super.addAll(elements);
      return this;
    }

    @CanIgnoreReturnValue
    @Override
    Builder&lt;E&gt; combine(ImmutableSet.Builder&lt;E&gt; builder) {
      super.combine(builder);
      return this;
    }

    /**
     * Returns a newly-created {@code ImmutableSortedSet} based on the contents of the {@code
     * Builder} and its comparator.
     */
    @Override
    public ImmutableSortedSet&lt;E&gt; build() {
      @SuppressWarnings(&quot;unchecked&quot;) // we're careful to put only E's in here
      E[] contentsArray = (E[]) contents;
      ImmutableSortedSet&lt;E&gt; result = construct(comparator, size, contentsArray);
      this.size = result.size(); // we eliminated duplicates in-place in contentsArray
      this.forceCopy = true;
      return result;
    }
  }

  int unsafeCompare(Object a, @CheckForNull Object b) {
    return unsafeCompare(comparator, a, b);
  }

  static int unsafeCompare(Comparator&lt;?&gt; comparator, Object a, @CheckForNull Object b) {
    // Pretend the comparator can compare anything. If it turns out it can't
    // compare a and b, we should get a CCE or NPE on the subsequent line. Only methods
    // that are spec'd to throw CCE and NPE should call this.
    @SuppressWarnings({&quot;unchecked&quot;, &quot;nullness&quot;})
    Comparator&lt;@Nullable Object&gt; unsafeComparator = (Comparator&lt;@Nullable Object&gt;) comparator;
    return unsafeComparator.compare(a, b);
  }

  final transient Comparator&lt;? super E&gt; comparator;

  ImmutableSortedSet(Comparator&lt;? super E&gt; comparator) {
    this.comparator = comparator;
  }

  /**
   * Returns the comparator that orders the elements, which is {@link Ordering#natural()} when the
   * natural ordering of the elements is used. Note that its behavior is not consistent with {@link
   * SortedSet#comparator()}, which returns {@code null} to indicate natural ordering.
   */
  @Override
  public Comparator&lt;? super E&gt; comparator() {
    return comparator;
  }

  @Override // needed to unify the iterator() methods in Collection and SortedIterable
  public abstract UnmodifiableIterator&lt;E&gt; iterator();

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;This method returns a serializable {@code ImmutableSortedSet}.
   *
   * &lt;p&gt;The {@link SortedSet#headSet} documentation states that a subset of a subset throws an
   * {@link IllegalArgumentException} if passed a {@code toElement} greater than an earlier {@code
   * toElement}. However, this method doesn't throw an exception in that situation, but instead
<A NAME="2"></A>   * keeps the original {@code toElement}.
   */
  @Override
  public ImmutableSortedSet&lt;E&gt; headSet(<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match656144-0.html#2',2,'match656144-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>E toElement) {
    return headSet(toElement, false);
  }

<A NAME="1"></A>  /** @since 12.0 */
  @Override
  public ImmutableSortedSet&lt;E&gt; headSet(E toElement, boolean inclusive) {</B></FONT>
    return headSetImpl(<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match656144-0.html#1',2,'match656144-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>checkNotNull(toElement), inclusive);
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;This method returns a serializable {@code ImmutableSortedSet}.
   *
   * &lt;p&gt;The {@link SortedSet#subSet} documentation states that a subset of a subset throws an {@link
   * IllegalArgumentException} if passed a {@code fromElement} smaller than an earlier {@code
   * fromElement}. However, this method doesn't throw an exception in that situation, but instead
   * keeps the original {@code fromElement}. Similarly, this method keeps the original {@code
   * toElement}, instead of throwing an exception, if passed a {@code toElement} greater than an
   * earlier {@code toElement}.
   */
  @Override
  public ImmutableSortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
    return subSet(fromElement, true, toElement, false);
  }

  /** @since 12.0 */
  @</B></FONT>GwtIncompatible // NavigableSet
  @Override
  public ImmutableSortedSet&lt;E&gt; subSet(
      E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
    checkNotNull(fromElement);
    checkNotNull(toElement);
    checkArgument(comparator.compare(fromElement, toElement) &lt;= 0);
    return subSetImpl(fromElement, fromInclusive, toElement, toInclusive);
  }

  /**
   * {@inheritDoc}
   *
   * &lt;p&gt;This method returns a serializable {@code ImmutableSortedSet}.
   *
   * &lt;p&gt;The {@link SortedSet#tailSet} documentation states that a subset of a subset throws an
   * {@link IllegalArgumentException} if passed a {@code fromElement} smaller than an earlier {@code
   * fromElement}. However, this method doesn't throw an exception in that situation, but instead
<A NAME="3"></A>   * keeps the original {@code fromElement}.
   */
  @Override
  public ImmutableSortedSet&lt;E&gt; tailSet(<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match656144-0.html#3',2,'match656144-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>E fromElement) {
    return tailSet(fromElement, true);
  }

  /** @since 12.0 */
  @Override
  public ImmutableSortedSet&lt;E&gt; tailSet(E fromElement, boolean inclusive</B></FONT>) {
    return tailSetImpl(checkNotNull(fromElement), inclusive);
  }

  /*
   * These methods perform most headSet, subSet, and tailSet logic, besides
   * parameter validation.
   */
  abstract ImmutableSortedSet&lt;E&gt; headSetImpl(E toElement, boolean inclusive);

  abstract ImmutableSortedSet&lt;E&gt; subSetImpl(
      E fromElement, boolean fromInclusive, E toElement, boolean toInclusive);

  abstract ImmutableSortedSet&lt;E&gt; tailSetImpl(E fromElement, boolean inclusive);

  /** @since 12.0 */
  @GwtIncompatible // NavigableSet
  @Override
<A NAME="4"></A>  @CheckForNull
  public E lower(E e) {
    return Iterators.getNext(headSet(e, false).descendingIterator(), null);
  <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match656144-0.html#4',2,'match656144-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

  /** @since 12.0 */
  @Override
  @CheckForNull
  public E floor(E e) {
    return Iterators.getNext</B></FONT>(headSet(e, true).descendingIterator(), null);
  }

  /** @since 12.0 */
  @Override
  @CheckForNull
  public E ceiling(E e) {
    return Iterables.getFirst(tailSet(e, true), null);
  }

  /** @since 12.0 */
  @GwtIncompatible // NavigableSet
  @Override
  @CheckForNull
  public E higher(E e) {
    return Iterables.getFirst(tailSet(e, false), null);
  }

  @Override
  public E first() {
    return iterator().next();
  }

  @Override
  public E last() {
    return descendingIterator().next();
  }

  /**
   * Guaranteed to throw an exception and leave the set unmodified.
   *
   * @since 12.0
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @CanIgnoreReturnValue
  @Deprecated
  @GwtIncompatible // NavigableSet
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  @CheckForNull
  public final E pollFirst() {
    throw new UnsupportedOperationException();
  }

  /**
   * Guaranteed to throw an exception and leave the set unmodified.
   *
   * @since 12.0
   * @throws UnsupportedOperationException always
   * @deprecated Unsupported operation.
   */
  @CanIgnoreReturnValue
  @Deprecated
  @GwtIncompatible // NavigableSet
  @Override
  @DoNotCall(&quot;Always throws UnsupportedOperationException&quot;)
  @CheckForNull
  public final E pollLast() {
    throw new UnsupportedOperationException();
  }

  @GwtIncompatible // NavigableSet
  @LazyInit
  @CheckForNull
  transient ImmutableSortedSet&lt;E&gt; descendingSet;

  /** @since 12.0 */
  @GwtIncompatible // NavigableSet
  @Override
  public ImmutableSortedSet&lt;E&gt; descendingSet() {
    // racy single-check idiom
    ImmutableSortedSet&lt;E&gt; result = descendingSet;
    if (result == null) {
      result = descendingSet = createDescendingSet();
      result.descendingSet = this;
    }
    return result;
  }

  // Most classes should implement this as new DescendingImmutableSortedSet&lt;E&gt;(this),
  // but we push down that implementation because ProGuard can't eliminate it even when it's always
  // overridden.
  @GwtIncompatible // NavigableSet
  abstract ImmutableSortedSet&lt;E&gt; createDescendingSet();

  /** @since 12.0 */
  @GwtIncompatible // NavigableSet
  @Override
  public abstract UnmodifiableIterator&lt;E&gt; descendingIterator();

  /** Returns the position of an element within the set, or -1 if not present. */
  abstract int indexOf(@CheckForNull Object target);

  /*
   * This class is used to serialize all ImmutableSortedSet instances,
   * regardless of implementation type. It captures their &quot;logical contents&quot;
   * only. This is necessary to ensure that the existence of a particular
   * implementation type is an implementation detail.
   */
  private static class SerializedForm&lt;E&gt; implements Serializable {
    final Comparator&lt;? super E&gt; comparator;
    final Object[] elements;

    public SerializedForm(Comparator&lt;? super E&gt; comparator, Object[] elements) {
      this.comparator = comparator;
      this.elements = elements;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    Object readResolve() {
      return new Builder&lt;E&gt;(comparator).add((E[]) elements).build();
    }

    private static final long serialVersionUID = 0;
  }

  private void readObject(ObjectInputStream unused) throws InvalidObjectException {
    throw new InvalidObjectException(&quot;Use SerializedForm&quot;);
  }

  @Override
  Object writeReplace() {
    return new SerializedForm&lt;E&gt;(comparator, toArray());
  }
}
</PRE>
</div>
  </div>
</body>
</html>
