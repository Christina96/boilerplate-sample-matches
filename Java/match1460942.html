<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for CacheLoadingTest_1.java &amp; ListMultimapRemoveTester_1.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for CacheLoadingTest_1.java &amp; ListMultimapRemoveTester_1.java
      </h3>
<h1 align="center">
        4.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>CacheLoadingTest_1.java (2.4%)<th>ListMultimapRemoveTester_1.java (60.365852%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(333-342)<td><a href="#" name="0">(45-49)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(15-31)<td><a href="#" name="1">(15-31)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(824-829)<td><a href="#" name="2">(59-65)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(2056-2063)<td><a href="#" name="3">(73-76)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(453-459)<td><a href="#" name="4">(79-87)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(129-135)<td><a href="#" name="5">(94-94)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(103-106)<td><a href="#" name="6">(97-102)</a><td align="center"><font color="#aa0000">10</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(2016-2020)<td><a href="#" name="7">(56-59)</a><td align="center"><font color="#990000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>CacheLoadingTest_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package com.google.common.cache;
2 import static com.google.common.cache.TestingCacheLoaders.bulkLoader;
3 import static com.google.common.cache.TestingCacheLoaders.constantLoader;
4 import static com.google.common.cache.TestingCacheLoaders.errorLoader;
5 import static com.google.common.cache.TestingCacheLoaders.exceptionLoader;
6 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
7 import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;
8 import static com.google.common.truth.Truth.assertThat;
9 import static java.lang.Thread.currentThread;
10 import static java.util.Arrays.asList;
11 import static java.util.concurrent.TimeUnit.MILLISECONDS;
12 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
13 import com.google.common.cache.TestingCacheLoaders.CountingLoader;
14 import com.google.common.cache.TestingCacheLoaders.IdentityLoader;
15 import</b></font> com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;
16 import com.google.common.collect.ImmutableList;
17 import com.google.common.collect.ImmutableMap;
18 import com.google.common.collect.Lists;
19 import com.google.common.collect.Maps;
20 import com.google.common.testing.FakeTicker;
21 import com.google.common.testing.TestLogHandler;
22 import com.google.common.util.concurrent.Callables;
23 import com.google.common.util.concurrent.ExecutionError;
24 import com.google.common.util.concurrent.Futures;
25 import com.google.common.util.concurrent.ListenableFuture;
26 import com.google.common.util.concurrent.UncheckedExecutionException;
27 import java.io.IOException;
28 import java.lang.ref.WeakReference;
29 import java.util.List;
30 import java.util.Map;
31 import java.util.Map.Entry;
32 import java.util.concurrent.Callable;
33 import java.util.concurrent.ConcurrentMap;
34 import java.util.concurrent.CountDownLatch;
35 import java.util.concurrent.ExecutionException;
36 import java.util.concurrent.TimeUnit;
37 import java.util.concurrent.atomic.AtomicInteger;
38 import java.util.concurrent.atomic.AtomicReferenceArray;
39 import java.util.logging.LogRecord;
40 import junit.framework.TestCase;
41 public class CacheLoadingTest extends TestCase {
42   TestLogHandler logHandler;
43   @Override
44   public void setUp() throws Exception {
45     super.setUp();
46     logHandler = new TestLogHandler();
47     LocalCache.logger.addHandler(logHandler);
48   }
49   @Override
50   public void tearDown() throws Exception {
51     super.tearDown();
52     currentThread().interrupted();
53     LocalCache.logger.removeHandler(logHandler);
54   }
55   private Throwable popLoggedThrowable() {
56     List&lt;LogRecord&gt; logRecords = logHandler.getStoredLogRecords();
57     assertEquals(1, logRecords.size());
58     LogRecord logRecord = logRecords.get(0);
59     logHandler.clear();
60     return logRecord.getThrown();
61   }
62   private void checkNothingLogged() {
63     assertThat(logHandler.getStoredLogRecords()).isEmpty();
64   }
65   private void checkLoggedCause(Throwable t) {
66     assertThat(popLoggedThrowable()).hasCauseThat().isSameInstanceAs(t);
67   }
68   private void checkLoggedInvalidLoad() {
69     assertThat(popLoggedThrowable()).isInstanceOf(InvalidCacheLoadException.class);
70   }
71 <a name="6"></a>
72   public void testLoad() throws ExecutionException {
73     LoadingCache&lt;Object, Object&gt; cache =
74         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>CacheBuilder.newBuilder().recordStats().build(identityLoader());
75     CacheStats stats = cache.stats();
76     assertEquals(0, stats.missCount());
77     assertEquals(0, stats.loadSuccessCount</b></font>());
78     assertEquals(0, stats.loadExceptionCount());
79     assertEquals(0, stats.hitCount());
80     Object key = new Object();
81     assertSame(key, cache.get(key));
82     stats = cache.stats();
83     assertEquals(1, stats.missCount());
84     assertEquals(1, stats.loadSuccessCount());
85     assertEquals(0, stats.loadExceptionCount());
86     assertEquals(0, stats.hitCount());
87     key = new Object();
88     assertSame(key, cache.getUnchecked(key));
89     stats = cache.stats();
90     assertEquals(2, stats.missCount());
91     assertEquals(2, stats.loadSuccessCount());
92     assertEquals(0, stats.loadExceptionCount());
93     assertEquals(0, stats.hitCount());
94 <a name="5"></a>    key = new Object();
95     cache.refresh(key);
96     checkNothingLogged();
97     stats = <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>cache.stats();
98     assertEquals(2, stats.missCount());
99     assertEquals(3, stats.loadSuccessCount());
100     assertEquals(0, stats.loadExceptionCount());
101     assertEquals(0, stats.hitCount());
102     assertSame</b></font>(key, cache.get(key));
103     stats = cache.stats();
104     assertEquals(2, stats.missCount());
105     assertEquals(3, stats.loadSuccessCount());
106     assertEquals(0, stats.loadExceptionCount());
107     assertEquals(1, stats.hitCount());
108     Object value = new Object();
109     assertSame(key, cache.get(key, throwing(new Exception())));
110     stats = cache.stats();
111     assertEquals(2, stats.missCount());
112     assertEquals(3, stats.loadSuccessCount());
113     assertEquals(0, stats.loadExceptionCount());
114     assertEquals(2, stats.hitCount());
115     key = new Object();
116     assertSame(value, cache.get(key, Callables.returning(value)));
117     stats = cache.stats();
118     assertEquals(3, stats.missCount());
119     assertEquals(4, stats.loadSuccessCount());
120     assertEquals(0, stats.loadExceptionCount());
121     assertEquals(2, stats.hitCount());
122   }
123   public void testReload() throws ExecutionException {
124     final Object one = new Object();
125     final Object two = new Object();
126     CacheLoader&lt;Object, Object&gt; loader =
127         new CacheLoader&lt;Object, Object&gt;() {
128           @Override
129           public Object load(Object key) {
130             return one;
131           }
132           @Override
133           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
134             return Futures.immediateFuture(two);
135           }
136         };
137     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
138     Object key = new Object();
139     CacheStats stats = cache.stats();
140     assertEquals(0, stats.missCount());
141     assertEquals(0, stats.loadSuccessCount());
142     assertEquals(0, stats.loadExceptionCount());
143     assertEquals(0, stats.hitCount());
144     assertSame(one, cache.getUnchecked(key));
145     stats = cache.stats();
146     assertEquals(1, stats.missCount());
147     assertEquals(1, stats.loadSuccessCount());
148     assertEquals(0, stats.loadExceptionCount());
149     assertEquals(0, stats.hitCount());
150     cache.refresh(key);
151     checkNothingLogged();
152     stats = cache.stats();
153     assertEquals(1, stats.missCount());
154     assertEquals(2, stats.loadSuccessCount());
155     assertEquals(0, stats.loadExceptionCount());
156     assertEquals(0, stats.hitCount());
157     assertSame(two, cache.getUnchecked(key));
158     stats = cache.stats();
159     assertEquals(1, stats.missCount());
160     assertEquals(2, stats.loadSuccessCount());
161     assertEquals(0, stats.loadExceptionCount());
162     assertEquals(1, stats.hitCount());
163   }
164   public void testRefresh() {
165     final Object one = new Object();
166     final Object two = new Object();
167     FakeTicker ticker = new FakeTicker();
168     CacheLoader&lt;Object, Object&gt; loader =
169         new CacheLoader&lt;Object, Object&gt;() {
170           @Override
171           public Object load(Object key) {
172             return one;
173           }
174           @Override
175           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
176             return Futures.immediateFuture(two);
177           }
178         };
179     LoadingCache&lt;Object, Object&gt; cache =
180         CacheBuilder.newBuilder()
181             .recordStats()
182             .ticker(ticker)
183             .refreshAfterWrite(1, MILLISECONDS)
184             .build(loader);
185     Object key = new Object();
186     CacheStats stats = cache.stats();
187     assertEquals(0, stats.missCount());
188     assertEquals(0, stats.loadSuccessCount());
189     assertEquals(0, stats.loadExceptionCount());
190     assertEquals(0, stats.hitCount());
191     assertSame(one, cache.getUnchecked(key));
192     stats = cache.stats();
193     assertEquals(1, stats.missCount());
194     assertEquals(1, stats.loadSuccessCount());
195     assertEquals(0, stats.loadExceptionCount());
196     assertEquals(0, stats.hitCount());
197     ticker.advance(1, MILLISECONDS);
198     assertSame(one, cache.getUnchecked(key));
199     stats = cache.stats();
200     assertEquals(1, stats.missCount());
201     assertEquals(1, stats.loadSuccessCount());
202     assertEquals(0, stats.loadExceptionCount());
203     assertEquals(1, stats.hitCount());
204     ticker.advance(1, MILLISECONDS);
205     assertSame(two, cache.getUnchecked(key));
206     stats = cache.stats();
207     assertEquals(1, stats.missCount());
208     assertEquals(2, stats.loadSuccessCount());
209     assertEquals(0, stats.loadExceptionCount());
210     assertEquals(2, stats.hitCount());
211     ticker.advance(1, MILLISECONDS);
212     assertSame(two, cache.getUnchecked(key));
213     stats = cache.stats();
214     assertEquals(1, stats.missCount());
215     assertEquals(2, stats.loadSuccessCount());
216     assertEquals(0, stats.loadExceptionCount());
217     assertEquals(3, stats.hitCount());
218   }
219   public void testRefresh_getIfPresent() {
220     final Object one = new Object();
221     final Object two = new Object();
222     FakeTicker ticker = new FakeTicker();
223     CacheLoader&lt;Object, Object&gt; loader =
224         new CacheLoader&lt;Object, Object&gt;() {
225           @Override
226           public Object load(Object key) {
227             return one;
228           }
229           @Override
230           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
231             return Futures.immediateFuture(two);
232           }
233         };
234     LoadingCache&lt;Object, Object&gt; cache =
235         CacheBuilder.newBuilder()
236             .recordStats()
237             .ticker(ticker)
238             .refreshAfterWrite(1, MILLISECONDS)
239             .build(loader);
240     Object key = new Object();
241     CacheStats stats = cache.stats();
242     assertEquals(0, stats.missCount());
243     assertEquals(0, stats.loadSuccessCount());
244     assertEquals(0, stats.loadExceptionCount());
245     assertEquals(0, stats.hitCount());
246     assertSame(one, cache.getUnchecked(key));
247     stats = cache.stats();
248     assertEquals(1, stats.missCount());
249     assertEquals(1, stats.loadSuccessCount());
250     assertEquals(0, stats.loadExceptionCount());
251     assertEquals(0, stats.hitCount());
252     ticker.advance(1, MILLISECONDS);
253     assertSame(one, cache.getIfPresent(key));
254     stats = cache.stats();
255     assertEquals(1, stats.missCount());
256     assertEquals(1, stats.loadSuccessCount());
257     assertEquals(0, stats.loadExceptionCount());
258     assertEquals(1, stats.hitCount());
259     ticker.advance(1, MILLISECONDS);
260     assertSame(two, cache.getIfPresent(key));
261     stats = cache.stats();
262     assertEquals(1, stats.missCount());
263     assertEquals(2, stats.loadSuccessCount());
264     assertEquals(0, stats.loadExceptionCount());
265     assertEquals(2, stats.hitCount());
266     ticker.advance(1, MILLISECONDS);
267     assertSame(two, cache.getIfPresent(key));
268     stats = cache.stats();
269     assertEquals(1, stats.missCount());
270     assertEquals(2, stats.loadSuccessCount());
271     assertEquals(0, stats.loadExceptionCount());
272     assertEquals(3, stats.hitCount());
273   }
274 <a name="0"></a>
275   public void testBulkLoad_default() throws ExecutionException {
276     LoadingCache&lt;Integer, Integer&gt; cache =
277         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>CacheBuilder.newBuilder()
278             .recordStats()
279             .build(TestingCacheLoaders.&lt;Integer&gt;identityLoader());
280     CacheStats stats = cache.stats();
281     assertEquals(0, stats.missCount());
282     assertEquals(0, stats.loadSuccessCount());
283     assertEquals(0, stats.loadExceptionCount());
284     assertEquals(0, stats.hitCount());
285     assertEquals</b></font>(ImmutableMap.of(), cache.getAll(ImmutableList.&lt;Integer&gt;of()));
286     assertEquals(0, stats.missCount());
287     assertEquals(0, stats.loadSuccessCount());
288     assertEquals(0, stats.loadExceptionCount());
289     assertEquals(0, stats.hitCount());
290     assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
291     stats = cache.stats();
292     assertEquals(1, stats.missCount());
293     assertEquals(1, stats.loadSuccessCount());
294     assertEquals(0, stats.loadExceptionCount());
295     assertEquals(0, stats.hitCount());
296     assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
297     stats = cache.stats();
298     assertEquals(4, stats.missCount());
299     assertEquals(4, stats.loadSuccessCount());
300     assertEquals(0, stats.loadExceptionCount());
301     assertEquals(1, stats.hitCount());
302     assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
303     stats = cache.stats();
304     assertEquals(4, stats.missCount());
305     assertEquals(4, stats.loadSuccessCount());
306     assertEquals(0, stats.loadExceptionCount());
307     assertEquals(3, stats.hitCount());
308     assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
309     stats = cache.stats();
310     assertEquals(5, stats.missCount());
311     assertEquals(5, stats.loadSuccessCount());
312     assertEquals(0, stats.loadExceptionCount());
313     assertEquals(4, stats.hitCount());
314   }
315   public void testBulkLoad_loadAll() throws ExecutionException {
316     IdentityLoader&lt;Integer&gt; backingLoader = identityLoader();
317     CacheLoader&lt;Integer, Integer&gt; loader = bulkLoader(backingLoader);
318     LoadingCache&lt;Integer, Integer&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
319     CacheStats stats = cache.stats();
320     assertEquals(0, stats.missCount());
321     assertEquals(0, stats.loadSuccessCount());
322     assertEquals(0, stats.loadExceptionCount());
323     assertEquals(0, stats.hitCount());
324     assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.&lt;Integer&gt;of()));
325     assertEquals(0, stats.missCount());
326     assertEquals(0, stats.loadSuccessCount());
327     assertEquals(0, stats.loadExceptionCount());
328     assertEquals(0, stats.hitCount());
329     assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
330     stats = cache.stats();
331     assertEquals(1, stats.missCount());
332     assertEquals(1, stats.loadSuccessCount());
333     assertEquals(0, stats.loadExceptionCount());
334     assertEquals(0, stats.hitCount());
335     assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
336     stats = cache.stats();
337     assertEquals(4, stats.missCount());
338     assertEquals(2, stats.loadSuccessCount());
339     assertEquals(0, stats.loadExceptionCount());
340     assertEquals(1, stats.hitCount());
341     assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
342     stats = cache.stats();
343     assertEquals(4, stats.missCount());
344     assertEquals(2, stats.loadSuccessCount());
345     assertEquals(0, stats.loadExceptionCount());
346     assertEquals(3, stats.hitCount());
347     assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
348     stats = cache.stats();
349     assertEquals(5, stats.missCount());
350     assertEquals(3, stats.loadSuccessCount());
351     assertEquals(0, stats.loadExceptionCount());
352     assertEquals(4, stats.hitCount());
353   }
354   public void testBulkLoad_extra() throws ExecutionException {
355     CacheLoader&lt;Object, Object&gt; loader =
356         new CacheLoader&lt;Object, Object&gt;() {
357           @Override
358           public Object load(Object key) throws Exception {
359             return new Object();
360           }
361           @Override
362           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
363             Map&lt;Object, Object&gt; result = Maps.newHashMap();
364             for (Object key : keys) {
365               Object value = new Object();
366               result.put(key, value);
367               result.put(value, key);
368             }
369             return result;
370           }
371         };
372     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
373     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
374     Map&lt;Object, Object&gt; result = cache.getAll(asList(lookupKeys));
375     assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
376     for (Entry&lt;Object, Object&gt; entry : result.entrySet()) {
377 <a name="4"></a>      Object key = entry.getKey();
378       Object value = entry.getValue();
379       assertSame(value, result.get(key));
380       <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertNull(result.get(value));
381       assertSame(value, cache.asMap().get(key));
382       assertSame(key, cache.asMap().get(value));
383     }
384   }
385   public void testBulk</b></font>Load_clobber() throws ExecutionException {
386     final Object extraKey = new Object();
387     final Object extraValue = new Object();
388     CacheLoader&lt;Object, Object&gt; loader =
389         new CacheLoader&lt;Object, Object&gt;() {
390           @Override
391           public Object load(Object key) throws Exception {
392             throw new AssertionError();
393           }
394           @Override
395           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
396             Map&lt;Object, Object&gt; result = Maps.newHashMap();
397             for (Object key : keys) {
398               Object value = new Object();
399               result.put(key, value);
400             }
401             result.put(extraKey, extraValue);
402             return result;
403           }
404         };
405     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
406     cache.asMap().put(extraKey, extraKey);
407     assertSame(extraKey, cache.asMap().get(extraKey));
408     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
409     Map&lt;Object, Object&gt; result = cache.getAll(asList(lookupKeys));
410     assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
411     for (Entry&lt;Object, Object&gt; entry : result.entrySet()) {
412       Object key = entry.getKey();
413       Object value = entry.getValue();
414       assertSame(value, result.get(key));
415       assertSame(value, cache.asMap().get(key));
416     }
417     assertNull(result.get(extraKey));
418     assertSame(extraValue, cache.asMap().get(extraKey));
419   }
420   public void testBulkLoad_clobberNullValue() throws ExecutionException {
421     final Object extraKey = new Object();
422     final Object extraValue = new Object();
423     CacheLoader&lt;Object, Object&gt; loader =
424         new CacheLoader&lt;Object, Object&gt;() {
425           @Override
426           public Object load(Object key) throws Exception {
427             throw new AssertionError();
428           }
429           @Override
430           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
431             Map&lt;Object, Object&gt; result = Maps.newHashMap();
432             for (Object key : keys) {
433               Object value = new Object();
434               result.put(key, value);
435             }
436             result.put(extraKey, extraValue);
437             result.put(extraValue, null);
438             return result;
439           }
440         };
441     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
442     cache.asMap().put(extraKey, extraKey);
443     assertSame(extraKey, cache.asMap().get(extraKey));
444     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
445     try {
446       cache.getAll(asList(lookupKeys));
447       fail();
448     } catch (InvalidCacheLoadException expected) {
449     }
450     for (Object key : lookupKeys) {
451       assertTrue(cache.asMap().containsKey(key));
452     }
453     assertSame(extraValue, cache.asMap().get(extraKey));
454     assertFalse(cache.asMap().containsKey(extraValue));
455   }
456   public void testBulkLoad_clobberNullKey() throws ExecutionException {
457     final Object extraKey = new Object();
458     final Object extraValue = new Object();
459     CacheLoader&lt;Object, Object&gt; loader =
460         new CacheLoader&lt;Object, Object&gt;() {
461           @Override
462           public Object load(Object key) throws Exception {
463             throw new AssertionError();
464           }
465           @Override
466           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
467             Map&lt;Object, Object&gt; result = Maps.newHashMap();
468             for (Object key : keys) {
469               Object value = new Object();
470               result.put(key, value);
471             }
472             result.put(extraKey, extraValue);
473             result.put(null, extraKey);
474             return result;
475           }
476         };
477     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
478     cache.asMap().put(extraKey, extraKey);
479     assertSame(extraKey, cache.asMap().get(extraKey));
480     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
481     try {
482       cache.getAll(asList(lookupKeys));
483       fail();
484     } catch (InvalidCacheLoadException expected) {
485     }
486     for (Object key : lookupKeys) {
487       assertTrue(cache.asMap().containsKey(key));
488     }
489     assertSame(extraValue, cache.asMap().get(extraKey));
490     assertFalse(cache.asMap().containsValue(extraKey));
491   }
492   public void testBulkLoad_partial() throws ExecutionException {
493     final Object extraKey = new Object();
494     final Object extraValue = new Object();
495     CacheLoader&lt;Object, Object&gt; loader =
496         new CacheLoader&lt;Object, Object&gt;() {
497           @Override
498           public Object load(Object key) throws Exception {
499             throw new AssertionError();
500           }
501           @Override
502           public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) throws Exception {
503             Map&lt;Object, Object&gt; result = Maps.newHashMap();
504             result.put(extraKey, extraValue);
505             return result;
506           }
507         };
508     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().build(loader);
509     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
510     try {
511       cache.getAll(asList(lookupKeys));
512       fail();
513     } catch (InvalidCacheLoadException expected) {
514     }
515     assertSame(extraValue, cache.asMap().get(extraKey));
516   }
517   public void testLoadNull() throws ExecutionException {
518     LoadingCache&lt;Object, Object&gt; cache =
519         CacheBuilder.newBuilder().recordStats().build(constantLoader(null));
520     CacheStats stats = cache.stats();
521     assertEquals(0, stats.missCount());
522     assertEquals(0, stats.loadSuccessCount());
523     assertEquals(0, stats.loadExceptionCount());
524     assertEquals(0, stats.hitCount());
525     try {
526       cache.get(new Object());
527       fail();
528     } catch (InvalidCacheLoadException expected) {
529     }
530     stats = cache.stats();
531     assertEquals(1, stats.missCount());
532     assertEquals(0, stats.loadSuccessCount());
533     assertEquals(1, stats.loadExceptionCount());
534     assertEquals(0, stats.hitCount());
535     try {
536       cache.getUnchecked(new Object());
537       fail();
538     } catch (InvalidCacheLoadException expected) {
539     }
540     stats = cache.stats();
541     assertEquals(2, stats.missCount());
542     assertEquals(0, stats.loadSuccessCount());
543     assertEquals(2, stats.loadExceptionCount());
544     assertEquals(0, stats.hitCount());
545     cache.refresh(new Object());
546     checkLoggedInvalidLoad();
547     stats = cache.stats();
548     assertEquals(2, stats.missCount());
549     assertEquals(0, stats.loadSuccessCount());
550     assertEquals(3, stats.loadExceptionCount());
551     assertEquals(0, stats.hitCount());
552     try {
553       cache.get(new Object(), Callables.returning(null));
554       fail();
555     } catch (InvalidCacheLoadException expected) {
556     }
557     stats = cache.stats();
558     assertEquals(3, stats.missCount());
559     assertEquals(0, stats.loadSuccessCount());
560     assertEquals(4, stats.loadExceptionCount());
561     assertEquals(0, stats.hitCount());
562     try {
563       cache.getAll(asList(new Object()));
564       fail();
565     } catch (InvalidCacheLoadException expected) {
566     }
567     stats = cache.stats();
568     assertEquals(4, stats.missCount());
569     assertEquals(0, stats.loadSuccessCount());
570     assertEquals(5, stats.loadExceptionCount());
571     assertEquals(0, stats.hitCount());
572   }
573   public void testReloadNull() throws ExecutionException {
574     final Object one = new Object();
575     CacheLoader&lt;Object, Object&gt; loader =
576         new CacheLoader&lt;Object, Object&gt;() {
577           @Override
578           public Object load(Object key) {
579             return one;
580           }
581           @Override
582           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
583             return null;
584           }
585         };
586     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
587     Object key = new Object();
588     CacheStats stats = cache.stats();
589     assertEquals(0, stats.missCount());
590     assertEquals(0, stats.loadSuccessCount());
591     assertEquals(0, stats.loadExceptionCount());
592     assertEquals(0, stats.hitCount());
593     assertSame(one, cache.getUnchecked(key));
594     stats = cache.stats();
595     assertEquals(1, stats.missCount());
596     assertEquals(1, stats.loadSuccessCount());
597     assertEquals(0, stats.loadExceptionCount());
598     assertEquals(0, stats.hitCount());
599     cache.refresh(key);
600     checkLoggedInvalidLoad();
601     stats = cache.stats();
602     assertEquals(1, stats.missCount());
603     assertEquals(1, stats.loadSuccessCount());
604     assertEquals(1, stats.loadExceptionCount());
605     assertEquals(0, stats.hitCount());
606     assertSame(one, cache.getUnchecked(key));
607     stats = cache.stats();
608     assertEquals(1, stats.missCount());
609     assertEquals(1, stats.loadSuccessCount());
610     assertEquals(1, stats.loadExceptionCount());
611     assertEquals(1, stats.hitCount());
612   }
613   public void testReloadNullFuture() throws ExecutionException {
614     final Object one = new Object();
615     CacheLoader&lt;Object, Object&gt; loader =
616         new CacheLoader&lt;Object, Object&gt;() {
617           @Override
618           public Object load(Object key) {
619             return one;
620           }
621           @Override
622           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
623             return Futures.immediateFuture(null);
624           }
625         };
626     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
627     Object key = new Object();
628     CacheStats stats = cache.stats();
629     assertEquals(0, stats.missCount());
630     assertEquals(0, stats.loadSuccessCount());
631     assertEquals(0, stats.loadExceptionCount());
632     assertEquals(0, stats.hitCount());
633     assertSame(one, cache.getUnchecked(key));
634     stats = cache.stats();
635     assertEquals(1, stats.missCount());
636     assertEquals(1, stats.loadSuccessCount());
637     assertEquals(0, stats.loadExceptionCount());
638     assertEquals(0, stats.hitCount());
639     cache.refresh(key);
640     checkLoggedInvalidLoad();
641     stats = cache.stats();
642     assertEquals(1, stats.missCount());
643     assertEquals(1, stats.loadSuccessCount());
644     assertEquals(1, stats.loadExceptionCount());
645     assertEquals(0, stats.hitCount());
646     assertSame(one, cache.getUnchecked(key));
647     stats = cache.stats();
648     assertEquals(1, stats.missCount());
649     assertEquals(1, stats.loadSuccessCount());
650     assertEquals(1, stats.loadExceptionCount());
651     assertEquals(1, stats.hitCount());
652   }
653   public void testRefreshNull() {
654     final Object one = new Object();
655     FakeTicker ticker = new FakeTicker();
656     CacheLoader&lt;Object, Object&gt; loader =
657         new CacheLoader&lt;Object, Object&gt;() {
658           @Override
659           public Object load(Object key) {
660             return one;
661           }
662           @Override
663           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
664             return Futures.immediateFuture(null);
665           }
666         };
667     LoadingCache&lt;Object, Object&gt; cache =
668         CacheBuilder.newBuilder()
669             .recordStats()
670             .ticker(ticker)
671             .refreshAfterWrite(1, MILLISECONDS)
672             .build(loader);
673     Object key = new Object();
674     CacheStats stats = cache.stats();
675     assertEquals(0, stats.missCount());
676     assertEquals(0, stats.loadSuccessCount());
677     assertEquals(0, stats.loadExceptionCount());
678     assertEquals(0, stats.hitCount());
679     assertSame(one, cache.getUnchecked(key));
680     stats = cache.stats();
681     assertEquals(1, stats.missCount());
682     assertEquals(1, stats.loadSuccessCount());
683     assertEquals(0, stats.loadExceptionCount());
684     assertEquals(0, stats.hitCount());
685     ticker.advance(1, MILLISECONDS);
686     assertSame(one, cache.getUnchecked(key));
687     stats = cache.stats();
688     assertEquals(1, stats.missCount());
689     assertEquals(1, stats.loadSuccessCount());
690     assertEquals(0, stats.loadExceptionCount());
691     assertEquals(1, stats.hitCount());
692     ticker.advance(1, MILLISECONDS);
693     assertSame(one, cache.getUnchecked(key));
694     stats = cache.stats();
695     assertEquals(1, stats.missCount());
696     assertEquals(1, stats.loadSuccessCount());
697     assertEquals(1, stats.loadExceptionCount());
698     assertEquals(2, stats.hitCount());
699     ticker.advance(1, MILLISECONDS);
700     assertSame(one, cache.getUnchecked(key));
701     stats = cache.stats();
702     assertEquals(1, stats.missCount());
703     assertEquals(1, stats.loadSuccessCount());
704     assertEquals(2, stats.loadExceptionCount());
705     assertEquals(3, stats.hitCount());
706   }
707 <a name="2"></a>
708   public void testBulkLoadNull() throws ExecutionException {
709     LoadingCache&lt;Object, Object&gt; cache =
710         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));
711     CacheStats stats = cache.stats();
712     assertEquals(0, stats.missCount());
713     assertEquals(0, stats.loadSuccessCount());
714     assertEquals(0, stats.loadExceptionCount());
715     assertEquals</b></font>(0, stats.hitCount());
716     try {
717       cache.getAll(asList(new Object()));
718       fail();
719     } catch (InvalidCacheLoadException expected) {
720     }
721     stats = cache.stats();
722     assertEquals(1, stats.missCount());
723     assertEquals(0, stats.loadSuccessCount());
724     assertEquals(1, stats.loadExceptionCount());
725     assertEquals(0, stats.hitCount());
726   }
727   public void testBulkLoadNullMap() throws ExecutionException {
728     LoadingCache&lt;Object, Object&gt; cache =
729         CacheBuilder.newBuilder()
730             .recordStats()
731             .build(
732                 new CacheLoader&lt;Object, Object&gt;() {
733                   @Override
734                   public Object load(Object key) {
735                     throw new AssertionError();
736                   }
737                   @Override
738                   public Map&lt;Object, Object&gt; loadAll(Iterable&lt;?&gt; keys) {
739                     return null;
740                   }
741                 });
742     CacheStats stats = cache.stats();
743     assertEquals(0, stats.missCount());
744     assertEquals(0, stats.loadSuccessCount());
745     assertEquals(0, stats.loadExceptionCount());
746     assertEquals(0, stats.hitCount());
747     try {
748       cache.getAll(asList(new Object()));
749       fail();
750     } catch (InvalidCacheLoadException expected) {
751     }
752     stats = cache.stats();
753     assertEquals(1, stats.missCount());
754     assertEquals(0, stats.loadSuccessCount());
755     assertEquals(1, stats.loadExceptionCount());
756     assertEquals(0, stats.hitCount());
757   }
758   public void testLoadError() throws ExecutionException {
759     Error e = new Error();
760     CacheLoader&lt;Object, Object&gt; loader = errorLoader(e);
761     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
762     CacheStats stats = cache.stats();
763     assertEquals(0, stats.missCount());
764     assertEquals(0, stats.loadSuccessCount());
765     assertEquals(0, stats.loadExceptionCount());
766     assertEquals(0, stats.hitCount());
767     try {
768       cache.get(new Object());
769       fail();
770     } catch (ExecutionError expected) {
771       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
772     }
773     stats = cache.stats();
774     assertEquals(1, stats.missCount());
775     assertEquals(0, stats.loadSuccessCount());
776     assertEquals(1, stats.loadExceptionCount());
777     assertEquals(0, stats.hitCount());
778     try {
779       cache.getUnchecked(new Object());
780       fail();
781     } catch (ExecutionError expected) {
782       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
783     }
784     stats = cache.stats();
785     assertEquals(2, stats.missCount());
786     assertEquals(0, stats.loadSuccessCount());
787     assertEquals(2, stats.loadExceptionCount());
788     assertEquals(0, stats.hitCount());
789     cache.refresh(new Object());
790     checkLoggedCause(e);
791     stats = cache.stats();
792     assertEquals(2, stats.missCount());
793     assertEquals(0, stats.loadSuccessCount());
794     assertEquals(3, stats.loadExceptionCount());
795     assertEquals(0, stats.hitCount());
796     final Error callableError = new Error();
797     try {
798       cache.get(
799           new Object(),
800           new Callable&lt;Object&gt;() {
801             @Override
802             public Object call() {
803               throw callableError;
804             }
805           });
806       fail();
807     } catch (ExecutionError expected) {
808       assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);
809     }
810     stats = cache.stats();
811     assertEquals(3, stats.missCount());
812     assertEquals(0, stats.loadSuccessCount());
813     assertEquals(4, stats.loadExceptionCount());
814     assertEquals(0, stats.hitCount());
815     try {
816       cache.getAll(asList(new Object()));
817       fail();
818     } catch (ExecutionError expected) {
819       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
820     }
821     stats = cache.stats();
822     assertEquals(4, stats.missCount());
823     assertEquals(0, stats.loadSuccessCount());
824     assertEquals(5, stats.loadExceptionCount());
825     assertEquals(0, stats.hitCount());
826   }
827   public void testReloadError() throws ExecutionException {
828     final Object one = new Object();
829     final Error e = new Error();
830     CacheLoader&lt;Object, Object&gt; loader =
831         new CacheLoader&lt;Object, Object&gt;() {
832           @Override
833           public Object load(Object key) {
834             return one;
835           }
836           @Override
837           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
838             throw e;
839           }
840         };
841     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
842     Object key = new Object();
843     CacheStats stats = cache.stats();
844     assertEquals(0, stats.missCount());
845     assertEquals(0, stats.loadSuccessCount());
846     assertEquals(0, stats.loadExceptionCount());
847     assertEquals(0, stats.hitCount());
848     assertSame(one, cache.getUnchecked(key));
849     stats = cache.stats();
850     assertEquals(1, stats.missCount());
851     assertEquals(1, stats.loadSuccessCount());
852     assertEquals(0, stats.loadExceptionCount());
853     assertEquals(0, stats.hitCount());
854     cache.refresh(key);
855     checkLoggedCause(e);
856     stats = cache.stats();
857     assertEquals(1, stats.missCount());
858     assertEquals(1, stats.loadSuccessCount());
859     assertEquals(1, stats.loadExceptionCount());
860     assertEquals(0, stats.hitCount());
861     assertSame(one, cache.getUnchecked(key));
862     stats = cache.stats();
863     assertEquals(1, stats.missCount());
864     assertEquals(1, stats.loadSuccessCount());
865     assertEquals(1, stats.loadExceptionCount());
866     assertEquals(1, stats.hitCount());
867   }
868   public void testReloadFutureError() throws ExecutionException {
869     final Object one = new Object();
870     final Error e = new Error();
871     CacheLoader&lt;Object, Object&gt; loader =
872         new CacheLoader&lt;Object, Object&gt;() {
873           @Override
874           public Object load(Object key) {
875             return one;
876           }
877           @Override
878           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
879             return Futures.immediateFailedFuture(e);
880           }
881         };
882     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
883     Object key = new Object();
884     CacheStats stats = cache.stats();
885     assertEquals(0, stats.missCount());
886     assertEquals(0, stats.loadSuccessCount());
887     assertEquals(0, stats.loadExceptionCount());
888     assertEquals(0, stats.hitCount());
889     assertSame(one, cache.getUnchecked(key));
890     stats = cache.stats();
891     assertEquals(1, stats.missCount());
892     assertEquals(1, stats.loadSuccessCount());
893     assertEquals(0, stats.loadExceptionCount());
894     assertEquals(0, stats.hitCount());
895     cache.refresh(key);
896     checkLoggedCause(e);
897     stats = cache.stats();
898     assertEquals(1, stats.missCount());
899     assertEquals(1, stats.loadSuccessCount());
900     assertEquals(1, stats.loadExceptionCount());
901     assertEquals(0, stats.hitCount());
902     assertSame(one, cache.getUnchecked(key));
903     stats = cache.stats();
904     assertEquals(1, stats.missCount());
905     assertEquals(1, stats.loadSuccessCount());
906     assertEquals(1, stats.loadExceptionCount());
907     assertEquals(1, stats.hitCount());
908   }
909   public void testRefreshError() {
910     final Object one = new Object();
911     final Error e = new Error();
912     FakeTicker ticker = new FakeTicker();
913     CacheLoader&lt;Object, Object&gt; loader =
914         new CacheLoader&lt;Object, Object&gt;() {
915           @Override
916           public Object load(Object key) {
917             return one;
918           }
919           @Override
920           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
921             return Futures.immediateFailedFuture(e);
922           }
923         };
924     LoadingCache&lt;Object, Object&gt; cache =
925         CacheBuilder.newBuilder()
926             .recordStats()
927             .ticker(ticker)
928             .refreshAfterWrite(1, MILLISECONDS)
929             .build(loader);
930     Object key = new Object();
931     CacheStats stats = cache.stats();
932     assertEquals(0, stats.missCount());
933     assertEquals(0, stats.loadSuccessCount());
934     assertEquals(0, stats.loadExceptionCount());
935     assertEquals(0, stats.hitCount());
936     assertSame(one, cache.getUnchecked(key));
937     stats = cache.stats();
938     assertEquals(1, stats.missCount());
939     assertEquals(1, stats.loadSuccessCount());
940     assertEquals(0, stats.loadExceptionCount());
941     assertEquals(0, stats.hitCount());
942     ticker.advance(1, MILLISECONDS);
943     assertSame(one, cache.getUnchecked(key));
944     stats = cache.stats();
945     assertEquals(1, stats.missCount());
946     assertEquals(1, stats.loadSuccessCount());
947     assertEquals(0, stats.loadExceptionCount());
948     assertEquals(1, stats.hitCount());
949     ticker.advance(1, MILLISECONDS);
950     assertSame(one, cache.getUnchecked(key));
951     stats = cache.stats();
952     assertEquals(1, stats.missCount());
953     assertEquals(1, stats.loadSuccessCount());
954     assertEquals(1, stats.loadExceptionCount());
955     assertEquals(2, stats.hitCount());
956     ticker.advance(1, MILLISECONDS);
957     assertSame(one, cache.getUnchecked(key));
958     stats = cache.stats();
959     assertEquals(1, stats.missCount());
960     assertEquals(1, stats.loadSuccessCount());
961     assertEquals(2, stats.loadExceptionCount());
962     assertEquals(3, stats.hitCount());
963   }
964   public void testBulkLoadError() throws ExecutionException {
965     Error e = new Error();
966     CacheLoader&lt;Object, Object&gt; loader = errorLoader(e);
967     LoadingCache&lt;Object, Object&gt; cache =
968         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
969     CacheStats stats = cache.stats();
970     assertEquals(0, stats.missCount());
971     assertEquals(0, stats.loadSuccessCount());
972     assertEquals(0, stats.loadExceptionCount());
973     assertEquals(0, stats.hitCount());
974     try {
975       cache.getAll(asList(new Object()));
976       fail();
977     } catch (ExecutionError expected) {
978       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
979     }
980     stats = cache.stats();
981     assertEquals(1, stats.missCount());
982     assertEquals(0, stats.loadSuccessCount());
983     assertEquals(1, stats.loadExceptionCount());
984     assertEquals(0, stats.hitCount());
985   }
986   public void testLoadCheckedException() {
987     Exception e = new Exception();
988     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
989     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
990     CacheStats stats = cache.stats();
991     assertEquals(0, stats.missCount());
992     assertEquals(0, stats.loadSuccessCount());
993     assertEquals(0, stats.loadExceptionCount());
994     assertEquals(0, stats.hitCount());
995     try {
996       cache.get(new Object());
997       fail();
998     } catch (ExecutionException expected) {
999       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1000     }
1001     stats = cache.stats();
1002     assertEquals(1, stats.missCount());
1003     assertEquals(0, stats.loadSuccessCount());
1004     assertEquals(1, stats.loadExceptionCount());
1005     assertEquals(0, stats.hitCount());
1006     try {
1007       cache.getUnchecked(new Object());
1008       fail();
1009     } catch (UncheckedExecutionException expected) {
1010       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1011     }
1012     stats = cache.stats();
1013     assertEquals(2, stats.missCount());
1014     assertEquals(0, stats.loadSuccessCount());
1015     assertEquals(2, stats.loadExceptionCount());
1016     assertEquals(0, stats.hitCount());
1017     cache.refresh(new Object());
1018     checkLoggedCause(e);
1019     stats = cache.stats();
1020     assertEquals(2, stats.missCount());
1021     assertEquals(0, stats.loadSuccessCount());
1022     assertEquals(3, stats.loadExceptionCount());
1023     assertEquals(0, stats.hitCount());
1024     Exception callableException = new Exception();
1025     try {
1026       cache.get(new Object(), throwing(callableException));
1027       fail();
1028     } catch (ExecutionException expected) {
1029       assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
1030     }
1031     stats = cache.stats();
1032     assertEquals(3, stats.missCount());
1033     assertEquals(0, stats.loadSuccessCount());
1034     assertEquals(4, stats.loadExceptionCount());
1035     assertEquals(0, stats.hitCount());
1036     try {
1037       cache.getAll(asList(new Object()));
1038       fail();
1039     } catch (ExecutionException expected) {
1040       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1041     }
1042     stats = cache.stats();
1043     assertEquals(4, stats.missCount());
1044     assertEquals(0, stats.loadSuccessCount());
1045     assertEquals(5, stats.loadExceptionCount());
1046     assertEquals(0, stats.hitCount());
1047   }
1048   public void testLoadInterruptedException() {
1049     Exception e = new InterruptedException();
1050     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1051     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1052     CacheStats stats = cache.stats();
1053     assertEquals(0, stats.missCount());
1054     assertEquals(0, stats.loadSuccessCount());
1055     assertEquals(0, stats.loadExceptionCount());
1056     assertEquals(0, stats.hitCount());
1057     assertFalse(currentThread().interrupted());
1058     try {
1059       cache.get(new Object());
1060       fail();
1061     } catch (ExecutionException expected) {
1062       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1063     }
1064     assertTrue(currentThread().interrupted());
1065     stats = cache.stats();
1066     assertEquals(1, stats.missCount());
1067     assertEquals(0, stats.loadSuccessCount());
1068     assertEquals(1, stats.loadExceptionCount());
1069     assertEquals(0, stats.hitCount());
1070     try {
1071       cache.getUnchecked(new Object());
1072       fail();
1073     } catch (UncheckedExecutionException expected) {
1074       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1075     }
1076     assertTrue(currentThread().interrupted());
1077     stats = cache.stats();
1078     assertEquals(2, stats.missCount());
1079     assertEquals(0, stats.loadSuccessCount());
1080     assertEquals(2, stats.loadExceptionCount());
1081     assertEquals(0, stats.hitCount());
1082     cache.refresh(new Object());
1083     assertTrue(currentThread().interrupted());
1084     checkLoggedCause(e);
1085     stats = cache.stats();
1086     assertEquals(2, stats.missCount());
1087     assertEquals(0, stats.loadSuccessCount());
1088     assertEquals(3, stats.loadExceptionCount());
1089     assertEquals(0, stats.hitCount());
1090     Exception callableException = new InterruptedException();
1091     try {
1092       cache.get(new Object(), throwing(callableException));
1093       fail();
1094     } catch (ExecutionException expected) {
1095       assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
1096     }
1097     assertTrue(currentThread().interrupted());
1098     stats = cache.stats();
1099     assertEquals(3, stats.missCount());
1100     assertEquals(0, stats.loadSuccessCount());
1101     assertEquals(4, stats.loadExceptionCount());
1102     assertEquals(0, stats.hitCount());
1103     try {
1104       cache.getAll(asList(new Object()));
1105       fail();
1106     } catch (ExecutionException expected) {
1107       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1108     }
1109     assertTrue(currentThread().interrupted());
1110     stats = cache.stats();
1111     assertEquals(4, stats.missCount());
1112     assertEquals(0, stats.loadSuccessCount());
1113     assertEquals(5, stats.loadExceptionCount());
1114     assertEquals(0, stats.hitCount());
1115   }
1116   public void testReloadCheckedException() {
1117     final Object one = new Object();
1118     final Exception e = new Exception();
1119     CacheLoader&lt;Object, Object&gt; loader =
1120         new CacheLoader&lt;Object, Object&gt;() {
1121           @Override
1122           public Object load(Object key) {
1123             return one;
1124           }
1125           @Override
1126           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) throws Exception {
1127             throw e;
1128           }
1129         };
1130     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1131     Object key = new Object();
1132     CacheStats stats = cache.stats();
1133     assertEquals(0, stats.missCount());
1134     assertEquals(0, stats.loadSuccessCount());
1135     assertEquals(0, stats.loadExceptionCount());
1136     assertEquals(0, stats.hitCount());
1137     assertSame(one, cache.getUnchecked(key));
1138     stats = cache.stats();
1139     assertEquals(1, stats.missCount());
1140     assertEquals(1, stats.loadSuccessCount());
1141     assertEquals(0, stats.loadExceptionCount());
1142     assertEquals(0, stats.hitCount());
1143     cache.refresh(key);
1144     checkLoggedCause(e);
1145     stats = cache.stats();
1146     assertEquals(1, stats.missCount());
1147     assertEquals(1, stats.loadSuccessCount());
1148     assertEquals(1, stats.loadExceptionCount());
1149     assertEquals(0, stats.hitCount());
1150     assertSame(one, cache.getUnchecked(key));
1151     stats = cache.stats();
1152     assertEquals(1, stats.missCount());
1153     assertEquals(1, stats.loadSuccessCount());
1154     assertEquals(1, stats.loadExceptionCount());
1155     assertEquals(1, stats.hitCount());
1156   }
1157   public void testReloadFutureCheckedException() {
1158     final Object one = new Object();
1159     final Exception e = new Exception();
1160     CacheLoader&lt;Object, Object&gt; loader =
1161         new CacheLoader&lt;Object, Object&gt;() {
1162           @Override
1163           public Object load(Object key) {
1164             return one;
1165           }
1166           @Override
1167           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
1168             return Futures.immediateFailedFuture(e);
1169           }
1170         };
1171     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1172     Object key = new Object();
1173     CacheStats stats = cache.stats();
1174     assertEquals(0, stats.missCount());
1175     assertEquals(0, stats.loadSuccessCount());
1176     assertEquals(0, stats.loadExceptionCount());
1177     assertEquals(0, stats.hitCount());
1178     assertSame(one, cache.getUnchecked(key));
1179     stats = cache.stats();
1180     assertEquals(1, stats.missCount());
1181     assertEquals(1, stats.loadSuccessCount());
1182     assertEquals(0, stats.loadExceptionCount());
1183     assertEquals(0, stats.hitCount());
1184     cache.refresh(key);
1185     checkLoggedCause(e);
1186     stats = cache.stats();
1187     assertEquals(1, stats.missCount());
1188     assertEquals(1, stats.loadSuccessCount());
1189     assertEquals(1, stats.loadExceptionCount());
1190     assertEquals(0, stats.hitCount());
1191     assertSame(one, cache.getUnchecked(key));
1192     stats = cache.stats();
1193     assertEquals(1, stats.missCount());
1194     assertEquals(1, stats.loadSuccessCount());
1195     assertEquals(1, stats.loadExceptionCount());
1196     assertEquals(1, stats.hitCount());
1197   }
1198   public void testRefreshCheckedException() {
1199     final Object one = new Object();
1200     final Exception e = new Exception();
1201     FakeTicker ticker = new FakeTicker();
1202     CacheLoader&lt;Object, Object&gt; loader =
1203         new CacheLoader&lt;Object, Object&gt;() {
1204           @Override
1205           public Object load(Object key) {
1206             return one;
1207           }
1208           @Override
1209           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
1210             return Futures.immediateFailedFuture(e);
1211           }
1212         };
1213     LoadingCache&lt;Object, Object&gt; cache =
1214         CacheBuilder.newBuilder()
1215             .recordStats()
1216             .ticker(ticker)
1217             .refreshAfterWrite(1, MILLISECONDS)
1218             .build(loader);
1219     Object key = new Object();
1220     CacheStats stats = cache.stats();
1221     assertEquals(0, stats.missCount());
1222     assertEquals(0, stats.loadSuccessCount());
1223     assertEquals(0, stats.loadExceptionCount());
1224     assertEquals(0, stats.hitCount());
1225     assertSame(one, cache.getUnchecked(key));
1226     stats = cache.stats();
1227     assertEquals(1, stats.missCount());
1228     assertEquals(1, stats.loadSuccessCount());
1229     assertEquals(0, stats.loadExceptionCount());
1230     assertEquals(0, stats.hitCount());
1231     ticker.advance(1, MILLISECONDS);
1232     assertSame(one, cache.getUnchecked(key));
1233     stats = cache.stats();
1234     assertEquals(1, stats.missCount());
1235     assertEquals(1, stats.loadSuccessCount());
1236     assertEquals(0, stats.loadExceptionCount());
1237     assertEquals(1, stats.hitCount());
1238     ticker.advance(1, MILLISECONDS);
1239     assertSame(one, cache.getUnchecked(key));
1240     stats = cache.stats();
1241     assertEquals(1, stats.missCount());
1242     assertEquals(1, stats.loadSuccessCount());
1243     assertEquals(1, stats.loadExceptionCount());
1244     assertEquals(2, stats.hitCount());
1245     ticker.advance(1, MILLISECONDS);
1246     assertSame(one, cache.getUnchecked(key));
1247     stats = cache.stats();
1248     assertEquals(1, stats.missCount());
1249     assertEquals(1, stats.loadSuccessCount());
1250     assertEquals(2, stats.loadExceptionCount());
1251     assertEquals(3, stats.hitCount());
1252   }
1253   public void testBulkLoadCheckedException() {
1254     Exception e = new Exception();
1255     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1256     LoadingCache&lt;Object, Object&gt; cache =
1257         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
1258     CacheStats stats = cache.stats();
1259     assertEquals(0, stats.missCount());
1260     assertEquals(0, stats.loadSuccessCount());
1261     assertEquals(0, stats.loadExceptionCount());
1262     assertEquals(0, stats.hitCount());
1263     try {
1264       cache.getAll(asList(new Object()));
1265       fail();
1266     } catch (ExecutionException expected) {
1267       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1268     }
1269     stats = cache.stats();
1270     assertEquals(1, stats.missCount());
1271     assertEquals(0, stats.loadSuccessCount());
1272     assertEquals(1, stats.loadExceptionCount());
1273     assertEquals(0, stats.hitCount());
1274   }
1275   public void testBulkLoadInterruptedException() {
1276     Exception e = new InterruptedException();
1277     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1278     LoadingCache&lt;Object, Object&gt; cache =
1279         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
1280     CacheStats stats = cache.stats();
1281     assertEquals(0, stats.missCount());
1282     assertEquals(0, stats.loadSuccessCount());
1283     assertEquals(0, stats.loadExceptionCount());
1284     assertEquals(0, stats.hitCount());
1285     try {
1286       cache.getAll(asList(new Object()));
1287       fail();
1288     } catch (ExecutionException expected) {
1289       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1290     }
1291     assertTrue(currentThread().interrupted());
1292     stats = cache.stats();
1293     assertEquals(1, stats.missCount());
1294     assertEquals(0, stats.loadSuccessCount());
1295     assertEquals(1, stats.loadExceptionCount());
1296     assertEquals(0, stats.hitCount());
1297   }
1298   public void testLoadUncheckedException() throws ExecutionException {
1299     Exception e = new RuntimeException();
1300     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1301     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1302     CacheStats stats = cache.stats();
1303     assertEquals(0, stats.missCount());
1304     assertEquals(0, stats.loadSuccessCount());
1305     assertEquals(0, stats.loadExceptionCount());
1306     assertEquals(0, stats.hitCount());
1307     try {
1308       cache.get(new Object());
1309       fail();
1310     } catch (UncheckedExecutionException expected) {
1311       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1312     }
1313     stats = cache.stats();
1314     assertEquals(1, stats.missCount());
1315     assertEquals(0, stats.loadSuccessCount());
1316     assertEquals(1, stats.loadExceptionCount());
1317     assertEquals(0, stats.hitCount());
1318     try {
1319       cache.getUnchecked(new Object());
1320       fail();
1321     } catch (UncheckedExecutionException expected) {
1322       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1323     }
1324     stats = cache.stats();
1325     assertEquals(2, stats.missCount());
1326     assertEquals(0, stats.loadSuccessCount());
1327     assertEquals(2, stats.loadExceptionCount());
1328     assertEquals(0, stats.hitCount());
1329     cache.refresh(new Object());
1330     checkLoggedCause(e);
1331     stats = cache.stats();
1332     assertEquals(2, stats.missCount());
1333     assertEquals(0, stats.loadSuccessCount());
1334     assertEquals(3, stats.loadExceptionCount());
1335     assertEquals(0, stats.hitCount());
1336     Exception callableException = new RuntimeException();
1337     try {
1338       cache.get(new Object(), throwing(callableException));
1339       fail();
1340     } catch (UncheckedExecutionException expected) {
1341       assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
1342     }
1343     stats = cache.stats();
1344     assertEquals(3, stats.missCount());
1345     assertEquals(0, stats.loadSuccessCount());
1346     assertEquals(4, stats.loadExceptionCount());
1347     assertEquals(0, stats.hitCount());
1348     try {
1349       cache.getAll(asList(new Object()));
1350       fail();
1351     } catch (UncheckedExecutionException expected) {
1352       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1353     }
1354     stats = cache.stats();
1355     assertEquals(4, stats.missCount());
1356     assertEquals(0, stats.loadSuccessCount());
1357     assertEquals(5, stats.loadExceptionCount());
1358     assertEquals(0, stats.hitCount());
1359   }
1360   public void testReloadUncheckedException() throws ExecutionException {
1361     final Object one = new Object();
1362     final Exception e = new RuntimeException();
1363     CacheLoader&lt;Object, Object&gt; loader =
1364         new CacheLoader&lt;Object, Object&gt;() {
1365           @Override
1366           public Object load(Object key) {
1367             return one;
1368           }
1369           @Override
1370           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) throws Exception {
1371             throw e;
1372           }
1373         };
1374     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1375     Object key = new Object();
1376     CacheStats stats = cache.stats();
1377     assertEquals(0, stats.missCount());
1378     assertEquals(0, stats.loadSuccessCount());
1379     assertEquals(0, stats.loadExceptionCount());
1380     assertEquals(0, stats.hitCount());
1381     assertSame(one, cache.getUnchecked(key));
1382     stats = cache.stats();
1383     assertEquals(1, stats.missCount());
1384     assertEquals(1, stats.loadSuccessCount());
1385     assertEquals(0, stats.loadExceptionCount());
1386     assertEquals(0, stats.hitCount());
1387     cache.refresh(key);
1388     checkLoggedCause(e);
1389     stats = cache.stats();
1390     assertEquals(1, stats.missCount());
1391     assertEquals(1, stats.loadSuccessCount());
1392     assertEquals(1, stats.loadExceptionCount());
1393     assertEquals(0, stats.hitCount());
1394     assertSame(one, cache.getUnchecked(key));
1395     stats = cache.stats();
1396     assertEquals(1, stats.missCount());
1397     assertEquals(1, stats.loadSuccessCount());
1398     assertEquals(1, stats.loadExceptionCount());
1399     assertEquals(1, stats.hitCount());
1400   }
1401   public void testReloadFutureUncheckedException() throws ExecutionException {
1402     final Object one = new Object();
1403     final Exception e = new RuntimeException();
1404     CacheLoader&lt;Object, Object&gt; loader =
1405         new CacheLoader&lt;Object, Object&gt;() {
1406           @Override
1407           public Object load(Object key) {
1408             return one;
1409           }
1410           @Override
1411           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
1412             return Futures.immediateFailedFuture(e);
1413           }
1414         };
1415     LoadingCache&lt;Object, Object&gt; cache = CacheBuilder.newBuilder().recordStats().build(loader);
1416     Object key = new Object();
1417     CacheStats stats = cache.stats();
1418     assertEquals(0, stats.missCount());
1419     assertEquals(0, stats.loadSuccessCount());
1420     assertEquals(0, stats.loadExceptionCount());
1421     assertEquals(0, stats.hitCount());
1422     assertSame(one, cache.getUnchecked(key));
1423     stats = cache.stats();
1424     assertEquals(1, stats.missCount());
1425     assertEquals(1, stats.loadSuccessCount());
1426     assertEquals(0, stats.loadExceptionCount());
1427     assertEquals(0, stats.hitCount());
1428     cache.refresh(key);
1429     checkLoggedCause(e);
1430     stats = cache.stats();
1431     assertEquals(1, stats.missCount());
1432     assertEquals(1, stats.loadSuccessCount());
1433     assertEquals(1, stats.loadExceptionCount());
1434     assertEquals(0, stats.hitCount());
1435     assertSame(one, cache.getUnchecked(key));
1436     stats = cache.stats();
1437     assertEquals(1, stats.missCount());
1438     assertEquals(1, stats.loadSuccessCount());
1439     assertEquals(1, stats.loadExceptionCount());
1440     assertEquals(1, stats.hitCount());
1441   }
1442   public void testRefreshUncheckedException() {
1443     final Object one = new Object();
1444     final Exception e = new RuntimeException();
1445     FakeTicker ticker = new FakeTicker();
1446     CacheLoader&lt;Object, Object&gt; loader =
1447         new CacheLoader&lt;Object, Object&gt;() {
1448           @Override
1449           public Object load(Object key) {
1450             return one;
1451           }
1452           @Override
1453           public ListenableFuture&lt;Object&gt; reload(Object key, Object oldValue) {
1454             return Futures.immediateFailedFuture(e);
1455           }
1456         };
1457     LoadingCache&lt;Object, Object&gt; cache =
1458         CacheBuilder.newBuilder()
1459             .recordStats()
1460             .ticker(ticker)
1461             .refreshAfterWrite(1, MILLISECONDS)
1462             .build(loader);
1463     Object key = new Object();
1464     CacheStats stats = cache.stats();
1465     assertEquals(0, stats.missCount());
1466     assertEquals(0, stats.loadSuccessCount());
1467     assertEquals(0, stats.loadExceptionCount());
1468     assertEquals(0, stats.hitCount());
1469     assertSame(one, cache.getUnchecked(key));
1470     stats = cache.stats();
1471     assertEquals(1, stats.missCount());
1472     assertEquals(1, stats.loadSuccessCount());
1473     assertEquals(0, stats.loadExceptionCount());
1474     assertEquals(0, stats.hitCount());
1475     ticker.advance(1, MILLISECONDS);
1476     assertSame(one, cache.getUnchecked(key));
1477     stats = cache.stats();
1478     assertEquals(1, stats.missCount());
1479     assertEquals(1, stats.loadSuccessCount());
1480     assertEquals(0, stats.loadExceptionCount());
1481     assertEquals(1, stats.hitCount());
1482     ticker.advance(1, MILLISECONDS);
1483     assertSame(one, cache.getUnchecked(key));
1484     stats = cache.stats();
1485     assertEquals(1, stats.missCount());
1486     assertEquals(1, stats.loadSuccessCount());
1487     assertEquals(1, stats.loadExceptionCount());
1488     assertEquals(2, stats.hitCount());
1489     ticker.advance(1, MILLISECONDS);
1490     assertSame(one, cache.getUnchecked(key));
1491     stats = cache.stats();
1492     assertEquals(1, stats.missCount());
1493     assertEquals(1, stats.loadSuccessCount());
1494     assertEquals(2, stats.loadExceptionCount());
1495     assertEquals(3, stats.hitCount());
1496   }
1497   public void testBulkLoadUncheckedException() throws ExecutionException {
1498     Exception e = new RuntimeException();
1499     CacheLoader&lt;Object, Object&gt; loader = exceptionLoader(e);
1500     LoadingCache&lt;Object, Object&gt; cache =
1501         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
1502     CacheStats stats = cache.stats();
1503     assertEquals(0, stats.missCount());
1504     assertEquals(0, stats.loadSuccessCount());
1505     assertEquals(0, stats.loadExceptionCount());
1506     assertEquals(0, stats.hitCount());
1507     try {
1508       cache.getAll(asList(new Object()));
1509       fail();
1510     } catch (UncheckedExecutionException expected) {
1511       assertThat(expected).hasCauseThat().isSameInstanceAs(e);
1512     }
1513     stats = cache.stats();
1514     assertEquals(1, stats.missCount());
1515     assertEquals(0, stats.loadSuccessCount());
1516     assertEquals(1, stats.loadExceptionCount());
1517     assertEquals(0, stats.hitCount());
1518   }
1519   public void testReloadAfterFailure() throws ExecutionException {
1520     final AtomicInteger count = new AtomicInteger();
1521     final Exception e = new IllegalStateException("exception to trigger failure on first load()");
1522     CacheLoader&lt;Integer, String&gt; failOnceFunction =
1523         new CacheLoader&lt;Integer, String&gt;() {
1524           @Override
1525           public String load(Integer key) throws Exception {
1526             if (count.getAndIncrement() == 0) {
1527               throw e;
1528             }
1529             return key.toString();
1530           }
1531         };
1532     CountingRemovalListener&lt;Integer, String&gt; removalListener = countingRemovalListener();
1533     LoadingCache&lt;Integer, String&gt; cache =
1534         CacheBuilder.newBuilder().removalListener(removalListener).build(failOnceFunction);
1535     try {
1536       cache.getUnchecked(1);
1537       fail();
1538     } catch (UncheckedExecutionException ue) {
1539       assertThat(ue).hasCauseThat().isSameInstanceAs(e);
1540     }
1541     assertEquals("1", cache.getUnchecked(1));
1542     assertEquals(0, removalListener.getCount());
1543     count.set(0);
1544     cache.refresh(2);
1545     checkLoggedCause(e);
1546     assertEquals("2", cache.getUnchecked(2));
1547     assertEquals(0, removalListener.getCount());
1548   }
1549   public void testReloadAfterValueReclamation() throws InterruptedException, ExecutionException {
1550     CountingLoader countingLoader = new CountingLoader();
1551     LoadingCache&lt;Object, Object&gt; cache =
1552         CacheBuilder.newBuilder().weakValues().build(countingLoader);
1553     ConcurrentMap&lt;Object, Object&gt; map = cache.asMap();
1554     int iterations = 10;
1555     WeakReference&lt;Object&gt; ref = new WeakReference&lt;&gt;(null);
1556     int expectedComputations = 0;
1557     for (int i = 0; i &lt; iterations; i++) {
1558       Object oldValue = ref.get();
1559       if (oldValue == null) {
1560         expectedComputations++;
1561       }
1562       ref = new WeakReference&lt;&gt;(cache.getUnchecked(1));
1563       oldValue = null;
1564       Thread.sleep(i);
1565       System.gc();
1566     }
1567     assertEquals(expectedComputations, countingLoader.getCount());
1568     for (int i = 0; i &lt; iterations; i++) {
1569       Object oldValue = ref.get();
1570       if (oldValue == null) {
1571         expectedComputations++;
1572       }
1573       cache.refresh(1);
1574       checkNothingLogged();
1575       ref = new WeakReference&lt;&gt;(map.get(1));
1576       oldValue = null;
1577       Thread.sleep(i);
1578       System.gc();
1579     }
1580     assertEquals(expectedComputations, countingLoader.getCount());
1581   }
1582   public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {
1583     CountingLoader countingLoader = new CountingLoader();
1584     LoadingCache&lt;Object, Object&gt; cache =
1585         CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);
1586     Object key = new Object();
1587     assertNotNull(cache.getUnchecked(key));
1588     CacheTesting.simulateValueReclamation(cache, key);
1589     assertNotNull(cache.getUnchecked(key));
1590     assertEquals(1, cache.size());
1591     assertEquals(2, countingLoader.getCount());
1592     CacheTesting.simulateValueReclamation(cache, key);
1593     cache.refresh(key);
1594     checkNothingLogged();
1595     assertEquals(1, cache.size());
1596     assertEquals(3, countingLoader.getCount());
1597   }
1598   public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {
1599     CountingLoader countingLoader = new CountingLoader();
1600     LoadingCache&lt;Object, Object&gt; cache =
1601         CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);
1602     Object key = new Object();
1603     assertNotNull(cache.getUnchecked(key));
1604     assertEquals(1, cache.size());
1605     CacheTesting.simulateKeyReclamation(cache, key);
1606     assertNotNull(cache.getUnchecked(key));
1607     assertEquals(2, countingLoader.getCount());
1608     CacheTesting.simulateKeyReclamation(cache, key);
1609     cache.refresh(key);
1610     checkNothingLogged();
1611     assertEquals(3, countingLoader.getCount());
1612   }
1613   public void testLoadingExceptionWithCause() {
1614     final Exception cause = new Exception();
1615     final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
1616     final ExecutionException ee = new ExecutionException(cause);
1617     LoadingCache&lt;Object, Object&gt; cacheUnchecked =
1618         CacheBuilder.newBuilder().build(exceptionLoader(uee));
1619     LoadingCache&lt;Object, Object&gt; cacheChecked =
1620         CacheBuilder.newBuilder().build(exceptionLoader(ee));
1621     try {
1622       cacheUnchecked.get(new Object());
1623       fail();
1624     } catch (ExecutionException e) {
1625       fail();
1626     } catch (UncheckedExecutionException caughtEe) {
1627       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
1628     }
1629     try {
1630       cacheUnchecked.getUnchecked(new Object());
1631       fail();
1632     } catch (UncheckedExecutionException caughtUee) {
1633       assertThat(caughtUee).hasCauseThat().isSameInstanceAs(uee);
1634     }
1635     cacheUnchecked.refresh(new Object());
1636     checkLoggedCause(uee);
1637     try {
1638       cacheUnchecked.getAll(asList(new Object()));
1639       fail();
1640     } catch (ExecutionException e) {
1641       fail();
1642     } catch (UncheckedExecutionException caughtEe) {
1643       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
1644     }
1645     try {
1646       cacheChecked.get(new Object());
1647       fail();
1648     } catch (ExecutionException caughtEe) {
1649       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
1650     }
1651     try {
1652       cacheChecked.getUnchecked(new Object());
1653       fail();
1654     } catch (UncheckedExecutionException caughtUee) {
1655       assertThat(caughtUee).hasCauseThat().isSameInstanceAs(ee);
1656     }
1657     cacheChecked.refresh(new Object());
1658     checkLoggedCause(ee);
1659     try {
1660       cacheChecked.getAll(asList(new Object()));
1661       fail();
1662     } catch (ExecutionException caughtEe) {
1663       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
1664     }
1665   }
1666   public void testBulkLoadingExceptionWithCause() {
1667     final Exception cause = new Exception();
1668     final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
1669     final ExecutionException ee = new ExecutionException(cause);
1670     LoadingCache&lt;Object, Object&gt; cacheUnchecked =
1671         CacheBuilder.newBuilder().build(bulkLoader(exceptionLoader(uee)));
1672     LoadingCache&lt;Object, Object&gt; cacheChecked =
1673         CacheBuilder.newBuilder().build(bulkLoader(exceptionLoader(ee)));
1674     try {
1675       cacheUnchecked.getAll(asList(new Object()));
1676       fail();
1677     } catch (ExecutionException e) {
1678       fail();
1679     } catch (UncheckedExecutionException caughtEe) {
1680       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);
1681     }
1682     try {
1683       cacheChecked.getAll(asList(new Object()));
1684       fail();
1685     } catch (ExecutionException caughtEe) {
1686       assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);
1687     }
1688   }
1689   public void testConcurrentLoading() throws InterruptedException {
1690     testConcurrentLoading(CacheBuilder.newBuilder());
1691   }
1692   private static void testConcurrentLoading(CacheBuilder&lt;Object, Object&gt; builder)
1693       throws InterruptedException {
1694     testConcurrentLoadingDefault(builder);
1695     testConcurrentLoadingNull(builder);
1696     testConcurrentLoadingUncheckedException(builder);
1697     testConcurrentLoadingCheckedException(builder);
1698   }
1699   public void testConcurrentExpirationLoading() throws InterruptedException {
1700     testConcurrentLoading(CacheBuilder.newBuilder().expireAfterWrite(10, TimeUnit.SECONDS));
1701   }
1702   private static void testConcurrentLoadingDefault(CacheBuilder&lt;Object, Object&gt; builder)
1703       throws InterruptedException {
1704     int count = 10;
1705     final AtomicInteger callCount = new AtomicInteger();
1706     final CountDownLatch startSignal = new CountDownLatch(count + 1);
1707     final Object result = new Object();
1708     LoadingCache&lt;String, Object&gt; cache =
1709         builder.build(
1710             new CacheLoader&lt;String, Object&gt;() {
1711               @Override
1712               public Object load(String key) throws InterruptedException {
1713                 callCount.incrementAndGet();
1714                 startSignal.await();
1715                 return result;
1716               }
1717             });
1718     List&lt;Object&gt; resultArray = doConcurrentGet(cache, "bar", count, startSignal);
1719     assertEquals(1, callCount.get());
1720     for (int i = 0; i &lt; count; i++) {
1721       assertSame("result(" + i + ") didn't match expected", result, resultArray.get(i));
1722     }
1723   }
1724   private static void testConcurrentLoadingNull(CacheBuilder&lt;Object, Object&gt; builder)
1725       throws InterruptedException {
1726     int count = 10;
1727     final AtomicInteger callCount = new AtomicInteger();
1728     final CountDownLatch startSignal = new CountDownLatch(count + 1);
1729     LoadingCache&lt;String, String&gt; cache =
1730         builder.build(
1731             new CacheLoader&lt;String, String&gt;() {
1732               @Override
1733               public String load(String key) throws InterruptedException {
1734                 callCount.incrementAndGet();
1735                 startSignal.await();
1736                 return null;
1737 <a name="7"></a>              }
1738             });
1739     List&lt;Object&gt; result = <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>doConcurrentGet(cache, "bar", count, startSignal);
1740     assertEquals(1, callCount.get());
1741     for (int i = 0; i &lt; count; i++) {
1742       assertThat(result.get</b></font>(i)).isInstanceOf(InvalidCacheLoadException.class);
1743     }
1744     try {
1745       cache.getUnchecked("bar");
1746       fail();
1747     } catch (InvalidCacheLoadException expected) {
1748     }
1749     assertEquals(2, callCount.get());
1750   }
1751   private static void testConcurrentLoadingUncheckedException(CacheBuilder&lt;Object, Object&gt; builder)
1752       throws InterruptedException {
1753     int count = 10;
1754     final AtomicInteger callCount = new AtomicInteger();
1755     final CountDownLatch startSignal = new CountDownLatch(count + 1);
1756     final RuntimeException e = new RuntimeException();
1757     LoadingCache&lt;String, String&gt; cache =
1758         builder.build(
1759             new CacheLoader&lt;String, String&gt;() {
1760               @Override
1761               public String load(String key) throws InterruptedException {
1762                 callCount.incrementAndGet();
1763                 startSignal.await();
1764                 throw e;
1765 <a name="3"></a>              }
1766             });
1767     List&lt;Object&gt; result = <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>doConcurrentGet(cache, "bar", count, startSignal);
1768     assertEquals(1, callCount.get());
1769     for (int i = 0; i &lt; count; i++) {
1770       assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
1771       assertThat(((UncheckedExecutionException) result.get</b></font>(i))).hasCauseThat().isSameInstanceAs(e);
1772     }
1773     try {
1774       cache.getUnchecked("bar");
1775       fail();
1776     } catch (UncheckedExecutionException expected) {
1777     }
1778     assertEquals(2, callCount.get());
1779   }
1780   private static void testConcurrentLoadingCheckedException(CacheBuilder&lt;Object, Object&gt; builder)
1781       throws InterruptedException {
1782     int count = 10;
1783     final AtomicInteger callCount = new AtomicInteger();
1784     final CountDownLatch startSignal = new CountDownLatch(count + 1);
1785     final IOException e = new IOException();
1786     LoadingCache&lt;String, String&gt; cache =
1787         builder.build(
1788             new CacheLoader&lt;String, String&gt;() {
1789               @Override
1790               public String load(String key) throws IOException, InterruptedException {
1791                 callCount.incrementAndGet();
1792                 startSignal.await();
1793                 throw e;
1794               }
1795             });
1796     List&lt;Object&gt; result = doConcurrentGet(cache, "bar", count, startSignal);
1797     assertEquals(1, callCount.get());
1798     for (int i = 0; i &lt; count; i++) {
1799       int mod = i % 3;
1800       if (mod == 0 || mod == 2) {
1801         assertThat(result.get(i)).isInstanceOf(ExecutionException.class);
1802         assertThat((ExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);
1803       } else {
1804         assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
1805         assertThat((UncheckedExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);
1806       }
1807     }
1808     try {
1809       cache.getUnchecked("bar");
1810       fail();
1811     } catch (UncheckedExecutionException expected) {
1812     }
1813     assertEquals(2, callCount.get());
1814   }
1815   private static &lt;K&gt; List&lt;Object&gt; doConcurrentGet(
1816       final LoadingCache&lt;K, ?&gt; cache,
1817       final K key,
1818       int nThreads,
1819       final CountDownLatch gettersStartedSignal)
1820       throws InterruptedException {
1821     final AtomicReferenceArray&lt;Object&gt; result = new AtomicReferenceArray&lt;&gt;(nThreads);
1822     final CountDownLatch gettersComplete = new CountDownLatch(nThreads);
1823     for (int i = 0; i &lt; nThreads; i++) {
1824       final int index = i;
1825       Thread thread =
1826           new Thread(
1827               new Runnable() {
1828                 @Override
1829                 public void run() {
1830                   gettersStartedSignal.countDown();
1831                   Object value = null;
1832                   try {
1833                     int mod = index % 3;
1834                     if (mod == 0) {
1835                       value = cache.get(key);
1836                     } else if (mod == 1) {
1837                       value = cache.getUnchecked(key);
1838                     } else {
1839                       cache.refresh(key);
1840                       value = cache.get(key);
1841                     }
1842                     result.set(index, value);
1843                   } catch (Throwable t) {
1844                     result.set(index, t);
1845                   }
1846                   gettersComplete.countDown();
1847                 }
1848               });
1849       thread.start();
1850       while (thread.isAlive() &amp;&amp; thread.getState() != Thread.State.WAITING) {
1851         Thread.yield();
1852       }
1853     }
1854     gettersStartedSignal.countDown();
1855     gettersComplete.await();
1856     List&lt;Object&gt; resultList = Lists.newArrayListWithExpectedSize(nThreads);
1857     for (int i = 0; i &lt; nThreads; i++) {
1858       resultList.add(result.get(i));
1859     }
1860     return resultList;
1861   }
1862   public void testAsMapDuringLoading() throws InterruptedException, ExecutionException {
1863     final CountDownLatch getStartedSignal = new CountDownLatch(2);
1864     final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
1865     final CountDownLatch getFinishedSignal = new CountDownLatch(2);
1866     final String getKey = "get";
1867     final String refreshKey = "refresh";
1868     final String suffix = "Suffix";
1869     CacheLoader&lt;String, String&gt; computeFunction =
1870         new CacheLoader&lt;String, String&gt;() {
1871           @Override
1872           public String load(String key) throws InterruptedException {
1873             getStartedSignal.countDown();
1874             letGetFinishSignal.await();
1875             return key + suffix;
1876           }
1877         };
1878     final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
1879     ConcurrentMap&lt;String, String&gt; map = cache.asMap();
1880     map.put(refreshKey, refreshKey);
1881     assertEquals(1, map.size());
1882     assertFalse(map.containsKey(getKey));
1883     assertSame(refreshKey, map.get(refreshKey));
1884     new Thread() {
1885       @Override
1886       public void run() {
1887         cache.getUnchecked(getKey);
1888         getFinishedSignal.countDown();
1889       }
1890     }.start();
1891     new Thread() {
1892       @Override
1893       public void run() {
1894         cache.refresh(refreshKey);
1895         getFinishedSignal.countDown();
1896       }
1897     }.start();
1898     getStartedSignal.await();
1899     assertEquals(1, map.size());
1900     assertFalse(map.containsKey(getKey));
1901     assertSame(refreshKey, map.get(refreshKey));
1902     letGetFinishSignal.countDown();
1903     getFinishedSignal.await();
1904     checkNothingLogged();
1905     assertEquals(2, cache.size());
1906     assertEquals(getKey + suffix, map.get(getKey));
1907     assertEquals(refreshKey + suffix, map.get(refreshKey));
1908   }
1909   public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {
1910     final CountDownLatch computationStarted = new CountDownLatch(2);
1911     final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
1912     final CountDownLatch getFinishedSignal = new CountDownLatch(2);
1913     final String getKey = "get";
1914     final String refreshKey = "refresh";
1915     final String suffix = "Suffix";
1916     CacheLoader&lt;String, String&gt; computeFunction =
1917         new CacheLoader&lt;String, String&gt;() {
1918           @Override
1919           public String load(String key) throws InterruptedException {
1920             computationStarted.countDown();
1921             letGetFinishSignal.await();
1922             return key + suffix;
1923           }
1924         };
1925     final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
1926     ConcurrentMap&lt;String, String&gt; map = cache.asMap();
1927     map.put(refreshKey, refreshKey);
1928     new Thread() {
1929       @Override
1930       public void run() {
1931         cache.getUnchecked(getKey);
1932         getFinishedSignal.countDown();
1933       }
1934     }.start();
1935     new Thread() {
1936       @Override
1937       public void run() {
1938         cache.refresh(refreshKey);
1939         getFinishedSignal.countDown();
1940       }
1941     }.start();
1942     computationStarted.await();
1943     cache.invalidate(getKey);
1944     cache.invalidate(refreshKey);
1945     assertFalse(map.containsKey(getKey));
1946     assertFalse(map.containsKey(refreshKey));
1947     letGetFinishSignal.countDown();
1948     getFinishedSignal.await();
1949     checkNothingLogged();
1950     assertEquals(2, cache.size());
1951     assertEquals(getKey + suffix, map.get(getKey));
1952     assertEquals(refreshKey + suffix, map.get(refreshKey));
1953     assertEquals(2, cache.size());
1954   }
1955   public void testInvalidateAndReloadDuringLoading()
1956       throws InterruptedException, ExecutionException {
1957     final CountDownLatch computationStarted = new CountDownLatch(2);
1958     final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
1959     final CountDownLatch getFinishedSignal = new CountDownLatch(4);
1960     final String getKey = "get";
1961     final String refreshKey = "refresh";
1962     final String suffix = "Suffix";
1963     CacheLoader&lt;String, String&gt; computeFunction =
1964         new CacheLoader&lt;String, String&gt;() {
1965           @Override
1966           public String load(String key) throws InterruptedException {
1967             computationStarted.countDown();
1968             letGetFinishSignal.await();
1969             return key + suffix;
1970           }
1971         };
1972     final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
1973     ConcurrentMap&lt;String, String&gt; map = cache.asMap();
1974     map.put(refreshKey, refreshKey);
1975     new Thread() {
1976       @Override
1977       public void run() {
1978         cache.getUnchecked(getKey);
1979         getFinishedSignal.countDown();
1980       }
1981     }.start();
1982     new Thread() {
1983       @Override
1984       public void run() {
1985         cache.refresh(refreshKey);
1986         getFinishedSignal.countDown();
1987       }
1988     }.start();
1989     computationStarted.await();
1990     cache.invalidate(getKey);
1991     cache.invalidate(refreshKey);
1992     assertFalse(map.containsKey(getKey));
1993     assertFalse(map.containsKey(refreshKey));
1994     new Thread() {
1995       @Override
1996       public void run() {
1997         cache.getUnchecked(getKey);
1998         getFinishedSignal.countDown();
1999       }
2000     }.start();
2001     new Thread() {
2002       @Override
2003       public void run() {
2004         cache.refresh(refreshKey);
2005         getFinishedSignal.countDown();
2006       }
2007     }.start();
2008     letGetFinishSignal.countDown();
2009     getFinishedSignal.await();
2010     checkNothingLogged();
2011     assertEquals(2, cache.size());
2012     assertEquals(getKey + suffix, map.get(getKey));
2013     assertEquals(refreshKey + suffix, map.get(refreshKey));
2014   }
2015   public void testExpandDuringLoading() throws InterruptedException {
2016     final int count = 3;
2017     final AtomicInteger callCount = new AtomicInteger();
2018     final CountDownLatch computeSignal = new CountDownLatch(1);
2019     final CountDownLatch secondSignal = new CountDownLatch(1);
2020     final CountDownLatch thirdSignal = new CountDownLatch(1);
2021     final CountDownLatch fourthSignal = new CountDownLatch(1);
2022     final CountDownLatch doneSignal = new CountDownLatch(count);
2023     CacheLoader&lt;String, String&gt; computeFunction =
2024         new CacheLoader&lt;String, String&gt;() {
2025           @Override
2026           public String load(String key) throws InterruptedException {
2027             callCount.incrementAndGet();
2028             secondSignal.countDown();
2029             computeSignal.await();
2030             return key + "foo";
2031           }
2032         };
2033     final LoadingCache&lt;String, String&gt; cache =
2034         CacheBuilder.newBuilder().weakKeys().build(computeFunction);
2035     final AtomicReferenceArray&lt;String&gt; result = new AtomicReferenceArray&lt;&gt;(count);
2036     final String key = "bar";
2037     new Thread() {
2038       @Override
2039       public void run() {
2040         result.set(0, cache.getUnchecked(key));
2041         doneSignal.countDown();
2042       }
2043     }.start();
2044     secondSignal.await();
2045     new Thread() {
2046       @Override
2047       public void run() {
2048         thirdSignal.countDown();
2049         result.set(1, cache.getUnchecked(key));
2050         doneSignal.countDown();
2051       }
2052     }.start();
2053     thirdSignal.await();
2054     Thread.yield();
2055     CacheTesting.forceExpandSegment(cache, key);
2056     new Thread() {
2057       @Override
2058       public void run() {
2059         fourthSignal.countDown();
2060         result.set(2, cache.getUnchecked(key));
2061         doneSignal.countDown();
2062       }
2063     }.start();
2064     fourthSignal.await();
2065     Thread.yield();
2066     computeSignal.countDown();
2067     doneSignal.await();
2068     assertTrue(callCount.get() == 1);
2069     assertEquals("barfoo", result.get(0));
2070     assertEquals("barfoo", result.get(1));
2071     assertEquals("barfoo", result.get(2));
2072     assertEquals("barfoo", cache.getUnchecked(key));
2073   }
2074   public void
2075       ignoreTestExpandDuringRefresh()
2076       throws InterruptedException, ExecutionException {
2077     final AtomicInteger callCount = new AtomicInteger();
2078     final CountDownLatch computeSignal = new CountDownLatch(1);
2079     final CountDownLatch secondSignal = new CountDownLatch(1);
2080     final CountDownLatch thirdSignal = new CountDownLatch(1);
2081     final CountDownLatch fourthSignal = new CountDownLatch(1);
2082     final CountDownLatch doneSignal = new CountDownLatch(3);
2083     final String suffix = "Suffix";
2084     CacheLoader&lt;String, String&gt; computeFunction =
2085         new CacheLoader&lt;String, String&gt;() {
2086           @Override
2087           public String load(String key) throws InterruptedException {
2088             callCount.incrementAndGet();
2089             secondSignal.countDown();
2090             computeSignal.await();
2091             return key + suffix;
2092           }
2093         };
2094     final AtomicReferenceArray&lt;String&gt; result = new AtomicReferenceArray&lt;&gt;(2);
2095     final LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(computeFunction);
2096     final String key = "bar";
2097     cache.asMap().put(key, key);
2098     new Thread() {
2099       @Override
2100       public void run() {
2101         cache.refresh(key);
2102         doneSignal.countDown();
2103       }
2104     }.start();
2105     secondSignal.await();
2106     checkNothingLogged();
2107     new Thread() {
2108       @Override
2109       public void run() {
2110         thirdSignal.countDown();
2111         result.set(0, cache.getUnchecked(key));
2112         doneSignal.countDown();
2113       }
2114     }.start();
2115     thirdSignal.await();
2116     Thread.yield();
2117     CacheTesting.forceExpandSegment(cache, key);
2118     new Thread() {
2119       @Override
2120       public void run() {
2121         fourthSignal.countDown();
2122         result.set(1, cache.getUnchecked(key));
2123         doneSignal.countDown();
2124       }
2125     }.start();
2126     fourthSignal.await();
2127     Thread.yield();
2128     computeSignal.countDown();
2129     doneSignal.await();
2130     assertTrue(callCount.get() == 1);
2131     assertEquals(key, result.get(0));
2132     assertEquals(key, result.get(1));
2133     assertEquals(key + suffix, cache.getUnchecked(key));
2134   }
2135   static &lt;T&gt; Callable&lt;T&gt; throwing(final Exception exception) {
2136     return new Callable&lt;T&gt;() {
2137       @Override
2138       public T call() throws Exception {
2139         throw exception;
2140       }
2141     };
2142   }
2143 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ListMultimapRemoveTester_1.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package com.google.common.collect.testing.google;
2 import static com.google.common.collect.testing.Helpers.assertContentsInOrder;
3 import static com.google.common.collect.testing.Helpers.copyToList;
4 import static com.google.common.collect.testing.Helpers.mapEntry;
5 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
6 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;
7 import com.google.common.annotations.GwtCompatible;
8 import com.google.common.collect.ListMultimap;
9 import com.google.common.collect.testing.features.CollectionSize;
10 import com.google.common.collect.testing.features.MapFeature;
11 import java.util.Arrays;
12 import java.util.Collection;
13 import java.util.List;
14 import java.util.Map.Entry;
15 import</b></font> org.junit.Ignore;
16 @GwtCompatible
17 @Ignore public class ListMultimapRemoveTester&lt;K, V&gt; extends AbstractListMultimapTester&lt;K, V&gt; {
18   @SuppressWarnings("unchecked")
19 <a name="0"></a>  @MapFeature.Require(SUPPORTS_REMOVE)
20   @CollectionSize.Require(SEVERAL)
21   public void testMultimapRemoveDeletesFirstOccurrence() {
22     resetContainer(mapEntry(k0(), v0()), mapEntry(k0(), <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>v1()), mapEntry(k0(), v0()));
23     List&lt;V&gt; list = multimap().get(k0());
24     multimap().remove(k0(), v0());
25     assertContentsInOrder(list, v1(), v0</b></font>());
26   }
27   @SuppressWarnings("unchecked")
28 <a name="7"></a>  @MapFeature.Require(SUPPORTS_REMOVE)
29   @CollectionSize.Require(SEVERAL)
30   public void testRemoveAtIndexFromGetPropagates() {
31 <a name="2"></a>    List&lt;V&gt; values = Arrays.asList(<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>v0(), v1(), v0());
32     for (int i = 0; i &lt; 3; i++) {
33       resetContainer(mapEntry(k0</b></font>(), v0()), mapEntry(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>k0(), v1()), mapEntry(k0(), v0()));
34       List&lt;V&gt; expectedValues = copyToList(values);
35       multimap().get(k0()).remove(i);
36       expectedValues.remove(i);
37       assertGet(k0</b></font>(), expectedValues);
38     }
39   }
40   @SuppressWarnings("unchecked")
41 <a name="3"></a>  @MapFeature.Require(SUPPORTS_REMOVE)
42   @CollectionSize.Require(SEVERAL)
43   public void testRemoveAtIndexFromAsMapPropagates() {
44     List&lt;V&gt; values = Arrays.asList(<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>v0(), v1(), v0());
45     for (int i = 0; i &lt; 3; i++) {
46 <a name="4"></a>      resetContainer(mapEntry(k0(), v0()), mapEntry(k0(), v1</b></font>()), mapEntry(k0(), v0()));
47       List&lt;V&gt; expectedValues = copyToList(values);
48       List&lt;V&gt; asMapValue = (List&lt;V&gt;) <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>multimap().asMap().get(k0());
49       asMapValue.remove(i);
50       expectedValues.remove(i);
51       assertGet(k0(), expectedValues);
52     }
53   }
54   @SuppressWarnings("unchecked")</b></font>
55   @MapFeature.Require(SUPPORTS_REMOVE)
56   @CollectionSize.Require(SEVERAL)
57   public void testRemoveAtIndexFromAsMapEntrySetPropagates() {
58 <a name="5"></a>    List&lt;V&gt; values = Arrays.asList(v0(), v1(), v0());
59     for (int i = 0; i &lt; 3; i++) {
60 <a name="6"></a>      <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>resetContainer(mapEntry(k0(), v0()), mapEntry(k0(), v1()), mapEntry(k0(), v0</b></font>()));
61       List&lt;V&gt; expectedValues = copyToList(values);
62       Entry&lt;K, Collection&lt;V&gt;&gt; asMapEntry = <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>multimap().asMap().entrySet().iterator().next();
63       List&lt;V&gt; asMapValue = (List&lt;V&gt;) asMapEntry.getValue();
64       asMapValue.remove(i);
65       expectedValues.remove(i);
66       assertGet(k0</b></font>(), expectedValues);
67     }
68   }
69 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
