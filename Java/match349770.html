<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for UdtNetty.java & DatagramUnicastInetTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for UdtNetty.java & DatagramUnicastInetTest.java
      </h3>
      <h1 align="center">
        10.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>UdtNetty.java (17.647058%)<TH>DatagramUnicastInetTest.java (7.4733095%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match349770-0.html#0',2,'match349770-1.html#0',3)" NAME="0">(17-44)<TD><A HREF="javascript:ZweiFrames('match349770-0.html#0',2,'match349770-1.html#0',3)" NAME="0">(16-41)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>UdtNetty.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
<A NAME="0"></A> * under the License.
 */

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match349770-1.html#0',3,'match349770-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.netty.test.udt.bench.xfer;

import com.yammer.metrics.Metrics;
import com.yammer.metrics.core.Counter;
import com.yammer.metrics.core.Meter;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.udt.nio.NioUdtProvider;
import io.netty.test.udt.util.CustomReporter;
import io.netty.test.udt.util.EchoMessageHandler;
import io.netty.test.udt.util.TrafficControl;
import io.netty.test.udt.util.UnitHelp;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * perform two way netty send/recv
 */
public final class UdtNetty {

    privat</B></FONT>e UdtNetty() {
    }

    static final InternalLogger log = InternalLoggerFactory.getInstance(UdtNetty.class);

    /** benchmark duration */
    static final int time = 10 * 60 * 1000;

    /** transfer chunk size */
    static final int size = 64 * 1024;

    static final Counter benchTime = Metrics.newCounter(UdtNetty.class,
            &quot;bench time&quot;);

    static final Counter benchSize = Metrics.newCounter(UdtNetty.class,
            &quot;bench size&quot;);

    static {
        benchTime.inc(time);
        benchSize.inc(size);
    }

    static final Meter rate = Metrics.newMeter(UdtNetty.class, &quot;rate&quot;,
            &quot;bytes&quot;, TimeUnit.SECONDS);

    static {
        Runtime.getRuntime().addShutdownHook(new Thread() {
            @Override
            public void run() {
                try {
                    TrafficControl.delay(0);
                } catch (final Exception e) {
                    log.error(&quot;&quot;, e);
                }
            }
        });
    }

    public static void main(final String[] args) throws Exception {

        log.info(&quot;init&quot;);
        TrafficControl.delay(0);

        final AtomicBoolean isOn = new AtomicBoolean(true);

        final InetSocketAddress addr1 = UnitHelp.localSocketAddress();
        final InetSocketAddress addr2 = UnitHelp.localSocketAddress();

        final ChannelHandler handler1 = new EchoMessageHandler(rate, size);
        final ChannelHandler handler2 = new EchoMessageHandler(null, size);

        final NioEventLoopGroup group1 = new NioEventLoopGroup(
                1, Executors.defaultThreadFactory(), NioUdtProvider.MESSAGE_PROVIDER);
        final NioEventLoopGroup group2 = new NioEventLoopGroup(
                1, Executors.defaultThreadFactory(), NioUdtProvider.MESSAGE_PROVIDER);

        final Bootstrap peerBoot1 = new Bootstrap();
        peerBoot1.group(group1)
                 .channelFactory(NioUdtProvider.MESSAGE_RENDEZVOUS)
                 .localAddress(addr1).remoteAddress(addr2).handler(handler1);

        final Bootstrap peerBoot2 = new Bootstrap();
        peerBoot2.group(group2)
                 .channelFactory(NioUdtProvider.MESSAGE_RENDEZVOUS)
                 .localAddress(addr2).remoteAddress(addr1).handler(handler2);

        final ChannelFuture peerFuture1 = peerBoot1.connect();
        final ChannelFuture peerFuture2 = peerBoot2.connect();

        CustomReporter.enable(3, TimeUnit.SECONDS);

        Thread.sleep(time);

        isOn.set(false);

        Thread.sleep(1000);

        peerFuture1.channel().close().sync();
        peerFuture2.channel().close().sync();

        Thread.sleep(1000);

        group1.shutdownGracefully();
        group2.shutdownGracefully();

        Metrics.defaultRegistry().shutdown();

        TrafficControl.delay(0);
        log.info(&quot;done&quot;);
    }

}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>DatagramUnicastInetTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2021 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
<A NAME="0"></A> * License for the specific language governing permissions and limitations
 * under the License.
 */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match349770-0.html#0',2,'match349770-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.netty.testsuite.transport.socket;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerAdapter;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.socket.DatagramChannel;
import io.netty.channel.socket.DatagramPacket;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

public class DatagramUnicastInetTest extends DatagramUnicastTest {

    @Test</B></FONT>
    public void testBindWithPortOnly(TestInfo testInfo) throws Throwable {
        run(testInfo, new Runner&lt;Bootstrap, Bootstrap&gt;() {
            @Override
            public void run(Bootstrap bootstrap, Bootstrap bootstrap2) throws Throwable {
                testBindWithPortOnly(bootstrap2);
            }
        });
    }

    private static void testBindWithPortOnly(Bootstrap cb) throws Throwable {
        Channel channel = null;
        try {
            cb.handler(new ChannelHandlerAdapter() { });
            channel = cb.bind(0).sync().channel();
        } finally {
            closeChannel(channel);
        }
    }

    @Override
    protected boolean isConnected(Channel channel) {
        return ((DatagramChannel) channel).isConnected();
    }

    @Override
    protected Channel setupClientChannel(Bootstrap cb, final byte[] bytes, final CountDownLatch latch,
                                         final AtomicReference&lt;Throwable&gt; errorRef) throws Throwable {
        cb.handler(new SimpleChannelInboundHandler&lt;DatagramPacket&gt;() {

            @Override
            public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) {
                try {
                    ByteBuf buf = msg.content();
                    assertEquals(bytes.length, buf.readableBytes());
                    for (int i = 0; i &lt; bytes.length; i++) {
                        assertEquals(bytes[i], buf.getByte(buf.readerIndex() + i));
                    }

                    InetSocketAddress localAddress = (InetSocketAddress) ctx.channel().localAddress();
                    if (localAddress.getAddress().isAnyLocalAddress()) {
                        assertEquals(localAddress.getPort(), msg.recipient().getPort());
                    } else {
                        // Test that the channel's localAddress is equal to the message's recipient
                        assertEquals(localAddress, msg.recipient());
                    }
                } finally {
                    latch.countDown();
                }
            }

            @Override
            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                errorRef.compareAndSet(null, cause);
            }
        });
        return cb.bind(newSocketAddress()).sync().channel();
    }

    @Override
    protected Channel setupServerChannel(Bootstrap sb, final byte[] bytes, final SocketAddress sender,
                                         final CountDownLatch latch, final AtomicReference&lt;Throwable&gt; errorRef,
                                         final boolean echo) throws Throwable {
        sb.handler(new ChannelInitializer&lt;Channel&gt;() {
            @Override
            protected void initChannel(Channel ch) {
                ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;DatagramPacket&gt;() {

                    @Override
                    public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) {
                        try {
                            if (sender == null) {
                                assertNotNull(msg.sender());
                            } else {
                                InetSocketAddress senderAddress = (InetSocketAddress) sender;
                                if (senderAddress.getAddress().isAnyLocalAddress()) {
                                    assertEquals(senderAddress.getPort(), msg.sender().getPort());
                                } else {
                                    assertEquals(sender, msg.sender());
                                }
                            }

                            ByteBuf buf = msg.content();
                            assertEquals(bytes.length, buf.readableBytes());
                            for (int i = 0; i &lt; bytes.length; i++) {
                                assertEquals(bytes[i], buf.getByte(buf.readerIndex() + i));
                            }

                            // Test that the channel's localAddress is equal to the message's recipient
                            assertEquals(ctx.channel().localAddress(), msg.recipient());

                            if (echo) {
                                ctx.writeAndFlush(new DatagramPacket(buf.retainedDuplicate(), msg.sender()));
                            }
                        } finally {
                            latch.countDown();
                        }
                    }

                    @Override
                    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                        errorRef.compareAndSet(null, cause);
                    }
                });
            }
        });
        return sb.bind(newSocketAddress()).sync().channel();
    }

    @Override
    protected boolean supportDisconnect() {
        return true;
    }

    @Override
    protected ChannelFuture write(Channel cc, ByteBuf buf, SocketAddress remote, WrapType wrapType) {
        switch (wrapType) {
            case DUP:
                return cc.write(new DatagramPacket(buf.retainedDuplicate(), (InetSocketAddress) remote));
            case SLICE:
                return cc.write(new DatagramPacket(buf.retainedSlice(), (InetSocketAddress) remote));
            case READ_ONLY:
                return cc.write(new DatagramPacket(buf.retain().asReadOnly(), (InetSocketAddress) remote));
            case NONE:
                return cc.write(new DatagramPacket(buf.retain(), (InetSocketAddress) remote));
            default:
                throw new Error(&quot;unknown wrap type: &quot; + wrapType);
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
