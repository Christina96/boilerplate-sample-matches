
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaPlayer.java</h3>
            <pre><code>1  package io.vov.vitamio;
2  import android.annotation.SuppressLint;
3  import android.content.ContentResolver;
4  import android.content.Context;
5  import android.content.res.AssetFileDescriptor;
6  import android.graphics.Bitmap;
7  import android.graphics.Canvas;
8  import android.media.AudioFormat;
9  import android.media.AudioManager;
10  import android.media.AudioTrack;
11  import android.net.Uri;
12  import android.os.Build;
13  import android.os.Bundle;
14  import android.os.Handler;
15  import android.os.Looper;
16  import android.os.Message;
17  import android.os.PowerManager;
18  import android.text.TextUtils;
19  import android.util.SparseArray;
20  import android.view.Surface;
21  import android.view.SurfaceHolder;
22  import io.vov.vitamio.utils.FileUtils;
23  import io.vov.vitamio.utils.Log;
24  import java.io.File;
25  import java.io.FileDescriptor;
26  import java.io.FileInputStream;
27  import java.io.IOException;
28  import java.io.UnsupportedEncodingException;
29  import java.nio.ByteBuffer;
30  import java.nio.charset.Charset;
31  import java.util.HashMap;
32  import java.util.Map;
33  import java.util.concurrent.atomic.AtomicBoolean;
34  public class MediaPlayer {
35    public static final int CACHE_TYPE_NOT_AVAILABLE = 1;
36    public static final int CACHE_TYPE_START = 2;
37    public static final int CACHE_TYPE_UPDATE = 3;
38    public static final int CACHE_TYPE_SPEED = 4;
39    public static final int CACHE_TYPE_COMPLETE = 5;
40    public static final int CACHE_INFO_NO_SPACE = 1;
41    public static final int CACHE_INFO_STREAM_NOT_SUPPORT = 2;
42    public static final int MEDIA_ERROR_UNKNOWN = 1;
43    public static final int MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = 200;
44    public static final int MEDIA_ERROR_IO = -5;
45    public static final int MEDIA_ERROR_MALFORMED = -1007;
46    public static final int MEDIA_ERROR_UNSUPPORTED = -1010;
47    public static final int MEDIA_ERROR_TIMED_OUT = -110;
48    public static final int MEDIA_INFO_VIDEO_TRACK_LAGGING = 700;
49    public static final int MEDIA_INFO_BUFFERING_START = 701;
50    public static final int MEDIA_INFO_BUFFERING_END = 702;
51    public static final int MEDIA_INFO_NOT_SEEKABLE = 801;
52    public static final int MEDIA_INFO_DOWNLOAD_RATE_CHANGED = 901;
53    public static final int VIDEOQUALITY_LOW = -16;
54    public static final int VIDEOQUALITY_MEDIUM = 0;
55    public static final int VIDEOQUALITY_HIGH = 16;
56    public static final int VIDEOCHROMA_RGB565 = 0;
57    public static final int VIDEOCHROMA_RGBA = 1;
58    public static final int SUBTITLE_INTERNAL = 0;
59    public static final int SUBTITLE_EXTERNAL = 1;
60    public static final String[] SUB_TYPES = {".srt", ".ssa", ".smi", ".txt", ".sub", ".ass", ".webvtt"};
61    private static final int MEDIA_NOP = 0;
62    private static final int MEDIA_PREPARED = 1;
63    private static final int MEDIA_PLAYBACK_COMPLETE = 2;
64    private static final int MEDIA_BUFFERING_UPDATE = 3;
65    private static final int MEDIA_SEEK_COMPLETE = 4;
66    private static final int MEDIA_SET_VIDEO_SIZE = 5;
67    private static final int MEDIA_ERROR = 100;
68    private static final int MEDIA_INFO = 200;
69    private static final int MEDIA_CACHE = 300;
70    private static final int MEDIA_HW_ERROR = 400;
71    private static final int MEDIA_TIMED_TEXT = 1000;
72    private static final int MEDIA_CACHING_UPDATE = 2000;
73    private static final String MEDIA_CACHING_SEGMENTS = "caching_segment";
74    private static final String MEDIA_CACHING_TYPE = "caching_type";
75    private static final String MEDIA_CACHING_INFO = "caching_info";
76    private static final String MEDIA_SUBTITLE_STRING = "sub_string";
77    private static final String MEDIA_SUBTITLE_BYTES = "sub_bytes";
78    private static final String MEDIA_SUBTITLE_TYPE = "sub_type";
79    private static final int SUBTITLE_TEXT = 0;
80    private static final int SUBTITLE_BITMAP = 1;
81    private static AtomicBoolean NATIVE_OMX_LOADED = new AtomicBoolean(false);
82    private Context mContext;
83    private Surface mSurface;
84    private SurfaceHolder mSurfaceHolder;
85    private EventHandler mEventHandler;
86    private PowerManager.WakeLock mWakeLock = null;
87    private boolean mScreenOnWhilePlaying;
88    private boolean mStayAwake;
89    private Metadata mMeta;
90    private TrackInfo[] mInbandTracks;
91    private TrackInfo mOutOfBandTracks;
92    private AssetFileDescriptor mFD = null;
93    private OnHWRenderFailedListener mOnHWRenderFailedListener;
94    private OnPreparedListener mOnPreparedListener;
95    private OnCompletionListener mOnCompletionListener;
96    private OnBufferingUpdateListener mOnBufferingUpdateListener;
97    private OnCachingUpdateListener mOnCachingUpdateListener;
98    private OnSeekCompleteListener mOnSeekCompleteListener;
99    private OnVideoSizeChangedListener mOnVideoSizeChangedListener;
100    private OnErrorListener mOnErrorListener;
101    private OnInfoListener mOnInfoListener;
102    private OnTimedTextListener mOnTimedTextListener;
103    private AudioTrack mAudioTrack;
104    private int mAudioTrackBufferSize;
105    private Surface mLocalSurface;
106    private Bitmap mBitmap;
107    private ByteBuffer mByteBuffer;
108    public MediaPlayer(Context ctx) {
109      this(ctx, false);
110    }
111    public MediaPlayer(Context ctx, boolean preferHWDecoder) {
112      mContext = ctx;
113      String LIB_ROOT = Vitamio.getLibraryPath();
114      if (preferHWDecoder) {
115        if (!NATIVE_OMX_LOADED.get()) {
116          if (Build.VERSION.SDK_INT > 17)
117            loadOMX_native(LIB_ROOT + "libOMX.18.so");
118          else if (Build.VERSION.SDK_INT > 13)
119            loadOMX_native(LIB_ROOT + "libOMX.14.so");
120          else if (Build.VERSION.SDK_INT > 10)
121            loadOMX_native(LIB_ROOT + "libOMX.11.so");
122          else
123            loadOMX_native(LIB_ROOT + "libOMX.9.so");
124          NATIVE_OMX_LOADED.set(true);
125        }
126      } else {
127        try {
128          unloadOMX_native();
129        } catch (UnsatisfiedLinkError e) {
130          Log.e("unloadOMX failed %s", e.toString());
131        }
132        NATIVE_OMX_LOADED.set(false);
133      }
134      Looper looper;
135      if ((looper = Looper.myLooper()) != null)
136        mEventHandler = new EventHandler(this, looper);
137      else if ((looper = Looper.getMainLooper()) != null)
138        mEventHandler = new EventHandler(this, looper);
139      else
140        mEventHandler = null;
141      native_init();
142    }
143    static {
144      String LIB_ROOT = Vitamio.getLibraryPath();
145      try {
146        Log.i("LIB ROOT: %s", LIB_ROOT);
147        System.load(LIB_ROOT + "libstlport_shared.so");
148        System.load(LIB_ROOT + "libvplayer.so");
149        loadFFmpeg_native(LIB_ROOT + "libffmpeg.so");
150        boolean vvo_loaded = false;
151        if (Build.VERSION.SDK_INT > 8)
152          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.9.so");
153        else if (Build.VERSION.SDK_INT > 7)
154          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.8.so");
155        else
156          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.7.so");
157        if (!vvo_loaded) {
158          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.j.so");
159          Log.d("FALLBACK TO VVO JNI " + vvo_loaded);
160        }
161        loadVAO_native(LIB_ROOT + "libvao.0.so");
162      } catch (java.lang.UnsatisfiedLinkError e) {
163        Log.e("Error loading libs", e);
164      }
165    }
166    private static void postEventFromNative(Object mediaplayer_ref, int what, int arg1, int arg2, Object obj) {
167      MediaPlayer mp = (MediaPlayer) (mediaplayer_ref);
168      if (mp == null)
169        return;
170      if (mp.mEventHandler != null) {
171        Message m = mp.mEventHandler.obtainMessage(what, arg1, arg2, obj);
172        mp.mEventHandler.sendMessage(m);
173      }
174    }
175    private static native boolean loadVAO_native(String vaoPath);
176    private static native boolean loadVVO_native(String vvoPath);
177    private static native boolean loadOMX_native(String omxPath);
178    private static native void unloadOMX_native();
179    private static native boolean loadFFmpeg_native(String ffmpegPath);
180    private native void _setVideoSurface(Surface surface);
181    public void setDisplay(SurfaceHolder sh) {
182      if (sh == null) {
183        releaseDisplay();
184      } else {
185        mSurfaceHolder = sh;
186        mSurface = sh.getSurface();
187        _setVideoSurface(mSurface);
188        updateSurfaceScreenOn();
189      }
190    }
191    public void setSurface(Surface surface) {
192      if (surface == null) {
193        releaseDisplay();
194      } else {
195        mSurfaceHolder = null;
196        mSurface = surface;
197        _setVideoSurface(mSurface);
198        updateSurfaceScreenOn();
199      }
200    }
201    public void setDataSource(String path) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
202      _setDataSource(path, null, null);
203    }
204    public void setDataSource(Context context, Uri uri) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
205      setDataSource(context, uri, null);
206    }
207    public void setDataSource(Context context, Uri uri, Map<String, String> headers) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
208      if (context == null || uri == null)
209        throw new IllegalArgumentException();
210      String scheme = uri.getScheme();
211      if (scheme == null || scheme.equals("file")) {
212        setDataSource(FileUtils.getPath(uri.toString()));
213        return;
214      }
215      try {
216        ContentResolver resolver = context.getContentResolver();
217        mFD = resolver.openAssetFileDescriptor(uri, "r");
218        if (mFD == null)
219          return;
220        setDataSource(mFD.getParcelFileDescriptor().getFileDescriptor());
221        return;
222      } catch (Exception e) {
223        closeFD();
224      }
225      setDataSource(uri.toString(), headers);
226    }
227    public void setDataSource(String path, Map<String, String> headers)
228            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException
229    {
230        String[] keys = null;
231        String[] values = null;
232        if (headers != null) {
233            keys = new String[headers.size()];
234            values = new String[headers.size()];
235            int i = 0;
236            for (Map.Entry<String, String> entry: headers.entrySet()) {
237                keys[i] = entry.getKey();
238                values[i] = entry.getValue();
239                ++i;
240            }
241        }
242        setDataSource(path, keys, values);
243    }
244  	public void setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
245  		final Uri uri = Uri.parse(path);
246  		if ("file".equals(uri.getScheme())) {
247  			path = uri.getPath();
248  		}
249  		final File file = new File(path);
250  		if (file.exists()) {
251  			FileInputStream is = new FileInputStream(file);
252  			FileDescriptor fd = is.getFD();
253  			setDataSource(fd);
254  			is.close();
255  		} else {
256  			_setDataSource(path, keys, values);
257  		}
258  	}
259    public void setDataSegments(String[] uris, String cacheDir) {
260    	_setDataSegmentsSource(uris, cacheDir);
261    }
262    public void setOnHWRenderFailedListener(OnHWRenderFailedListener l) {
263      mOnHWRenderFailedListener = l;
264    }
265    private native void _setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, IllegalStateException;
266    public native void setDataSource(FileDescriptor fd) throws IOException, IllegalArgumentException, IllegalStateException;
267    private native void _setDataSegmentsSource(String[] segments, String cacheDir);
268    public native void prepare() throws IOException, IllegalStateException;
269    public native void prepareAsync() throws IllegalStateException;
270    public void start() throws IllegalStateException {
271      stayAwake(true);
272      _start();
273    }
274    private native void _start() throws IllegalStateException;
275    public void stop() throws IllegalStateException {
276      stayAwake(false);
277      _stop();
278    }
279    private native void _stop() throws IllegalStateException;
280    public void pause() throws IllegalStateException {
281      stayAwake(false);
282      _pause();
283    }
284    private native void _pause() throws IllegalStateException;
285    @SuppressLint("Wakelock")
286    public void setWakeMode(Context context, int mode) {
287      boolean washeld = false;
288      if (mWakeLock != null) {
289        if (mWakeLock.isHeld()) {
290          washeld = true;
291          mWakeLock.release();
292        }
293        mWakeLock = null;
294      }
295      PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
296      mWakeLock = pm.newWakeLock(mode | PowerManager.ON_AFTER_RELEASE, MediaPlayer.class.getName());
297      mWakeLock.setReferenceCounted(false);
298      if (washeld) {
299        mWakeLock.acquire();
300      }
301    }
302    public void setScreenOnWhilePlaying(boolean screenOn) {
303      if (mScreenOnWhilePlaying != screenOn) {
304        mScreenOnWhilePlaying = screenOn;
305        updateSurfaceScreenOn();
306      }
307    }
308    @SuppressLint("Wakelock")
309    private void stayAwake(boolean awake) {
310      if (mWakeLock != null) {
311        if (awake && !mWakeLock.isHeld()) {
312          mWakeLock.acquire();
313        } else if (!awake && mWakeLock.isHeld()) {
314          mWakeLock.release();
315        }
316      }
317      mStayAwake = awake;
318      updateSurfaceScreenOn();
319    }
320    private void updateSurfaceScreenOn() {
321      if (mSurfaceHolder != null)
322        mSurfaceHolder.setKeepScreenOn(mScreenOnWhilePlaying && mStayAwake);
323    }
324    public native int getVideoWidth();
325    private native int getVideoWidth_a();
326    public native int getVideoHeight();
327    private native int getVideoHeight_a();
328    public native boolean isPlaying();
329    public native void setUseCache(boolean cache);
330    public native void setCacheDirectory(String directory);
331    public native void setAdaptiveStream(boolean adaptive);
332    public native void seekTo(long msec) throws IllegalStateException;
333    public native long getCurrentPosition();
334    public native Bitmap getCurrentFrame();
335    public native long getDuration();
336    public Metadata getMetadata() {
337      if (mMeta == null) {
338        mMeta = new Metadata();
339        Map<byte[], byte[]> meta = new HashMap<byte[], byte[]>();
340        if (!native_getMetadata(meta)) {
341          return null;
342        }
343        if (!mMeta.parse(meta, getMetaEncoding())) {
344          return null;
345        }
346      }
347      return mMeta;
348    }
349    public void release() {
350      stayAwake(false);
351      updateSurfaceScreenOn();
352      mOnPreparedListener = null;
353      mOnBufferingUpdateListener = null;
354      mOnCompletionListener = null;
355      mOnSeekCompleteListener = null;
<span onclick='openModal()' class='match'>356      mOnErrorListener = null;
357      mOnInfoListener = null;
358      mOnVideoSizeChangedListener = null;
359      mOnCachingUpdateListener = null;
360      mOnHWRenderFailedListener = null;
</span>361      _release();
362      closeFD();
363    }
364    private native void _release();
365    public void reset() {
366      stayAwake(false);
367      _reset();
368      mEventHandler.removeCallbacksAndMessages(null);
369      closeFD();
370    }
371    private native void _reset();
372    private void closeFD() {
373      if (mFD != null) {
374        try {
375          mFD.close();
376        } catch (IOException e) {
377          Log.e("closeFD", e);
378        }
379        mFD = null;
380      }
381    }
382    public native void setLooping(boolean looping);
383    public native boolean isLooping();
384    public native void setAudioAmplify(float ratio);
385    public native void setVolume(float leftVolume, float rightVolume);
386    private native final boolean native_getTrackInfo(SparseArray<byte[]> trackSparse);
387    private native final boolean native_getMetadata(Map<byte[], byte[]> meta);
388    private native final void native_init();
389    private native final void native_finalize();
390    public TrackInfo[] getTrackInfo(String encoding) {
391    	TrackInfo[] trackInfo = getInbandTrackInfo(encoding);
392    	String timedTextPath = getTimedTextPath();
393    	if (TextUtils.isEmpty(timedTextPath)) {
394    		return trackInfo;
395    	}
396      TrackInfo[] allTrackInfo = new TrackInfo[trackInfo.length + 1];
397      System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
398      int i = trackInfo.length;
399      SparseArray<MediaFormat> trackInfoArray = new SparseArray<MediaFormat>();
400      MediaFormat mediaFormat = new MediaFormat();
401      mediaFormat.setString(MediaFormat.KEY_TITLE, timedTextPath.substring(timedTextPath.lastIndexOf("/")));
402      mediaFormat.setString(MediaFormat.KEY_PATH, timedTextPath);
403      SparseArray<MediaFormat> timedTextSparse = findTrackFromTrackInfo(TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT, trackInfo);
404      if (timedTextSparse == null || timedTextSparse.size() == 0)
405      	trackInfoArray.put(timedTextSparse.keyAt(0), mediaFormat);
406      else 
407      	trackInfoArray.put(timedTextSparse.keyAt(timedTextSparse.size() - 1), mediaFormat);
408      mOutOfBandTracks = new TrackInfo(TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE, trackInfoArray);
409      allTrackInfo[i] = mOutOfBandTracks;
410      return allTrackInfo;
411    }
412    private TrackInfo[] getInbandTrackInfo(String encoding) {
413    	if (mInbandTracks == null) {
414    		SparseArray<byte[]> trackSparse = new SparseArray<byte[]>();
415        if (!native_getTrackInfo(trackSparse)) {
416          return null;
417        }
418        int size = trackSparse.size();
419        mInbandTracks = new TrackInfo[size];
420        for (int i = 0; i < size; i++) {
421        	SparseArray<MediaFormat> sparseArray = parseTrackInfo(trackSparse.valueAt(i), encoding);
422          TrackInfo trackInfo = new TrackInfo(trackSparse.keyAt(i), sparseArray);
423          mInbandTracks[i] = trackInfo;
424        }
425    	}
426      return mInbandTracks;
427    }
428    public TrackInfo[] getTrackInfo() {
429      return getTrackInfo(Charset.defaultCharset().name());
430    }
431    private SparseArray<MediaFormat> parseTrackInfo(byte[] tracks, String encoding) {
432      SparseArray<MediaFormat> trackSparse = new SparseArray<MediaFormat>();
433      String trackString;
434      int trackNum;
435      try {
436        trackString = new String(tracks, encoding);
437      } catch (Exception e) {
438        Log.e("getTrackMap exception");
439        trackString = new String(tracks);
440      }
441      for (String s : trackString.split("!#!")) {
442        try {
443        	MediaFormat mediaFormat = null;
444        	String[] formats = s.split("\\.");
445        	if (formats == null)
446        		continue;
447        	trackNum = Integer.parseInt(formats[0]);
448        	if (formats.length == 3) {
449        		mediaFormat = MediaFormat.createSubtitleFormat(formats[2], formats[1]);
450        	} else if (formats.length == 2) {
451        		mediaFormat = MediaFormat.createSubtitleFormat("", formats[1]);
452        	}
453          trackSparse.put(trackNum, mediaFormat);
454        } catch (NumberFormatException e) {
455        }
456      }
457      return trackSparse;
458    }
459    public SparseArray<MediaFormat> findTrackFromTrackInfo(int mediaTrackType, TrackInfo[] trackInfo) {
460      for (int i = 0; i < trackInfo.length; i++) {
461        if (trackInfo[i].getTrackType() == mediaTrackType) {
462          return trackInfo[i].getTrackInfoArray();
463        }
464      }
465      return null;
466    }
467    public native void addTimedTextSource(String path);
468    public void selectTrack(int index) {
469    	selectOrDeselectBandTrack(index, true &bsol;* select */);
470    }
471    public void deselectTrack(int index) {
472    	selectOrDeselectBandTrack(index, false &bsol;* select */);
473    }
474    private void selectOrDeselectBandTrack(int index, boolean select) {
475    	if (mOutOfBandTracks != null) {
476    		SparseArray<MediaFormat> mediaSparse = mOutOfBandTracks.getTrackInfoArray();
477    		int trackIndex = mediaSparse.keyAt(0);
478    		MediaFormat mediaFormat = mediaSparse.valueAt(0);
479      	if (index == trackIndex  && select) {
480      		addTimedTextSource(mediaFormat.getString(MediaFormat.KEY_PATH));
481      		return;
482      	}
483    	}
484    	selectOrDeselectTrack(index, select);
485    }
486    private native void selectOrDeselectTrack(int index, boolean select);
487    @Override
488    protected void finalize() {
489      native_finalize();
490    }
491    public void setOnPreparedListener(OnPreparedListener listener) {
492      mOnPreparedListener = listener;
493    }
494    public void setOnCompletionListener(OnCompletionListener listener) {
495      mOnCompletionListener = listener;
496    }
497    public void setOnBufferingUpdateListener(OnBufferingUpdateListener listener) {
498      mOnBufferingUpdateListener = listener;
499    }
500    public void setOnCachingUpdateListener(OnCachingUpdateListener listener) {
501      mOnCachingUpdateListener = listener;
502    }
503    private void updateCacheStatus(int type, int info, long[] segments) {
504      if (mEventHandler != null) {
505        Message m = mEventHandler.obtainMessage(MEDIA_CACHING_UPDATE);
506        Bundle b = m.getData();
507        b.putInt(MEDIA_CACHING_TYPE, type);
508        b.putInt(MEDIA_CACHING_INFO, info);
509        b.putLongArray(MEDIA_CACHING_SEGMENTS, segments);
510        mEventHandler.sendMessage(m);
511      }
512    }
513    public void setOnSeekCompleteListener(OnSeekCompleteListener listener) {
514      mOnSeekCompleteListener = listener;
515    }
516    public void setOnVideoSizeChangedListener(OnVideoSizeChangedListener listener) {
517      mOnVideoSizeChangedListener = listener;
518    }
519    public void setOnErrorListener(OnErrorListener listener) {
520      mOnErrorListener = listener;
521    }
522    public void setOnInfoListener(OnInfoListener listener) {
523      mOnInfoListener = listener;
524    }
525    public void setOnTimedTextListener(OnTimedTextListener listener) {
526      mOnTimedTextListener = listener;
527    }
528    private void updateSub(int subType, byte[] bytes, String encoding, int width, int height) {
529      if (mEventHandler != null) {
530        Message m = mEventHandler.obtainMessage(MEDIA_TIMED_TEXT, width, height);
531        Bundle b = m.getData();
532        if (subType == SUBTITLE_TEXT) {
533          b.putInt(MEDIA_SUBTITLE_TYPE, SUBTITLE_TEXT);
534          if (encoding == null) {
535            b.putString(MEDIA_SUBTITLE_STRING, new String(bytes));
536          } else {
537            try {
538              b.putString(MEDIA_SUBTITLE_STRING, new String(bytes, encoding.trim()));
539            } catch (UnsupportedEncodingException e) {
540              Log.e("updateSub", e);
541              b.putString(MEDIA_SUBTITLE_STRING, new String(bytes));
542            }
543          }
544        } else if (subType == SUBTITLE_BITMAP) {
545          b.putInt(MEDIA_SUBTITLE_TYPE, SUBTITLE_BITMAP);
546          b.putByteArray(MEDIA_SUBTITLE_BYTES, bytes);
547        }
548        mEventHandler.sendMessage(m);
549      }
550    }
551    protected native void _releaseVideoSurface();
552    public void releaseDisplay() {
553      _releaseVideoSurface();
554      mSurfaceHolder = null;
555      mSurface = null;
556    }
557    public native float getVideoAspectRatio();
558    public native void setVideoQuality(int quality);
559    public native void setVideoChroma(int chroma);
560    public native void setDeinterlace(boolean deinterlace);
561    public native void setBufferSize(long bufSize);
562    public native void setPlaybackSpeed(float speed);
563    public native boolean isBuffering();
564    public native int getBufferProgress();
565    public native String getMetaEncoding();
566    public native void setMetaEncoding(String encoding);
567  	public native int getAudioTrack();
568  	public native int getVideoTrack();
569    public native void setTimedTextShown(boolean shown);
570    public native void setTimedTextEncoding(String encoding);
571    public native int getTimedTextLocation();
572    public native String getTimedTextPath();
573    public native int getTimedTextTrack();
574    private int audioTrackInit(int sampleRateInHz, int channels) {
575      audioTrackRelease();
576      int channelConfig = channels >= 2 ? AudioFormat.CHANNEL_OUT_STEREO : AudioFormat.CHANNEL_OUT_MONO;
577      try {
578        mAudioTrackBufferSize = AudioTrack.getMinBufferSize(sampleRateInHz, channelConfig, AudioFormat.ENCODING_PCM_16BIT);
579        mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRateInHz, channelConfig, AudioFormat.ENCODING_PCM_16BIT, mAudioTrackBufferSize, AudioTrack.MODE_STREAM);
580      } catch (Exception e) {
581        mAudioTrackBufferSize = 0;
582        Log.e("audioTrackInit", e);
583      }
584      return mAudioTrackBufferSize;
585    }
586    private void audioTrackSetVolume(float leftVolume, float rightVolume) {
587      if (mAudioTrack != null)
588        mAudioTrack.setStereoVolume(leftVolume, rightVolume);
589    }
590    private void audioTrackWrite(byte[] audioData, int offsetInBytes, int sizeInBytes) {
591      if (mAudioTrack != null && mAudioTrack.getPlayState() == AudioTrack.PLAYSTATE_PLAYING) {
592        int written;
593        while (sizeInBytes > 0) {
594          written = sizeInBytes > mAudioTrackBufferSize ? mAudioTrackBufferSize : sizeInBytes;
595          mAudioTrack.write(audioData, offsetInBytes, written);
596          sizeInBytes -= written;
597          offsetInBytes += written;
598        }
599      }
600    }
601    private void audioTrackStart() {
602      if (mAudioTrack != null && mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED && mAudioTrack.getPlayState() != AudioTrack.PLAYSTATE_PLAYING)
603        mAudioTrack.play();
604    }
605    private void audioTrackPause() {
606      if (mAudioTrack != null && mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)
607        mAudioTrack.pause();
608    }
609    private void audioTrackRelease() {
610      if (mAudioTrack != null) {
611        if (mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)
612          mAudioTrack.stop();
613        mAudioTrack.release();
614      }
615      mAudioTrack = null;
616    }
617    public int getAudioSessionId() {
618  	return mAudioTrack.getAudioSessionId();
619    }
620    private ByteBuffer surfaceInit() {
621      synchronized (this) {
622        mLocalSurface = mSurface;
623        int w = getVideoWidth_a();
624        int h = getVideoHeight_a();
625        if (mLocalSurface != null && w != 0 && h != 0) {
626          mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.RGB_565);
627          mByteBuffer = ByteBuffer.allocateDirect(w * h * 2);
628        } else {
629          mBitmap = null;
630          mByteBuffer = null;
631        }
632        return mByteBuffer;
633      }
634    }
635    private void surfaceRender() {
636      synchronized (this) {
637        if (mLocalSurface == null || !mLocalSurface.isValid() || mBitmap == null || mByteBuffer == null)
638          return;
639        try {
640          Canvas c = mLocalSurface.lockCanvas(null);
641          mBitmap.copyPixelsFromBuffer(mByteBuffer);
642          c.drawBitmap(mBitmap, 0, 0, null);
643          mLocalSurface.unlockCanvasAndPost(c);
644        } catch (Exception e) {
645          Log.e("surfaceRender", e);
646        }
647      }
648    }
649    private void surfaceRelease() {
650      synchronized (this) {
651        mLocalSurface = null;
652        mBitmap = null;
653        mByteBuffer = null;
654      }
655    }
656    public interface OnHWRenderFailedListener {
657      public void onFailed();
658    }
659    public interface OnPreparedListener {
660      void onPrepared(MediaPlayer mp);
661    }
662    public interface OnCompletionListener {
663      void onCompletion(MediaPlayer mp);
664    }
665    public interface OnBufferingUpdateListener {
666      void onBufferingUpdate(MediaPlayer mp, int percent);
667    }
668    public interface OnCachingUpdateListener {
669      void onCachingUpdate(MediaPlayer mp, long[] segments);
670      void onCachingSpeed(MediaPlayer mp, int speed);
671      void onCachingStart(MediaPlayer mp);
672     	void onCachingComplete(MediaPlayer mp); 
673      void onCachingNotAvailable(MediaPlayer mp, int info);
674    }
675    public interface OnSeekCompleteListener {
676      public void onSeekComplete(MediaPlayer mp);
677    }
678    public interface OnVideoSizeChangedListener {
679      public void onVideoSizeChanged(MediaPlayer mp, int width, int height);
680    }
681    public interface OnErrorListener {
682      boolean onError(MediaPlayer mp, int what, int extra);
683    }
684    public interface OnInfoListener {
685      boolean onInfo(MediaPlayer mp, int what, int extra);
686    }
687    public interface OnTimedTextListener {
688      public void onTimedText(String text);
689      public void onTimedTextUpdate(byte[] pixels, int width, int height);
690    }
691    static public class TrackInfo {
692      public static final int MEDIA_TRACK_TYPE_UNKNOWN = 0;
693      public static final int MEDIA_TRACK_TYPE_VIDEO = 1;
694      public static final int MEDIA_TRACK_TYPE_AUDIO = 2;
695      public static final int MEDIA_TRACK_TYPE_TIMEDTEXT = 3;
696      public static final int MEDIA_TRACK_TYPE_SUBTITLE = 4;
697      final int mTrackType;
698      final SparseArray<MediaFormat> mTrackInfoArray;
699      TrackInfo(int trackType, SparseArray<MediaFormat> trackInfoArray) {
700        mTrackType = trackType;
701        mTrackInfoArray = trackInfoArray;
702      }
703      public int getTrackType() {
704        return mTrackType;
705      }
706      public SparseArray<MediaFormat> getTrackInfoArray() {
707        return mTrackInfoArray;
708      }
709    }
710    @SuppressLint("HandlerLeak")
711    private class EventHandler extends Handler {
712      private MediaPlayer mMediaPlayer;
713      private Bundle mData;
714      public EventHandler(MediaPlayer mp, Looper looper) {
715        super(looper);
716        mMediaPlayer = mp;
717      }
718      @Override
719      public void handleMessage(Message msg) {
720        switch (msg.what) {
721          case MEDIA_PREPARED:
722            if (mOnPreparedListener != null)
723              mOnPreparedListener.onPrepared(mMediaPlayer);
724            return;
725          case MEDIA_PLAYBACK_COMPLETE:
726            if (mOnCompletionListener != null)
727              mOnCompletionListener.onCompletion(mMediaPlayer);
728            stayAwake(false);
729            return;
730          case MEDIA_BUFFERING_UPDATE:
731            if (mOnBufferingUpdateListener != null)
732              mOnBufferingUpdateListener.onBufferingUpdate(mMediaPlayer, msg.arg1);
733            return;
734          case MEDIA_SEEK_COMPLETE:
735            if (isPlaying())
736              stayAwake(true);
737            if (mOnSeekCompleteListener != null)
738              mOnSeekCompleteListener.onSeekComplete(mMediaPlayer);
739            return;
740          case MEDIA_SET_VIDEO_SIZE:
741            if (mOnVideoSizeChangedListener != null)
742              mOnVideoSizeChangedListener.onVideoSizeChanged(mMediaPlayer, msg.arg1, msg.arg2);
743            return;
744          case MEDIA_ERROR:
745            Log.e("Error (%d, %d)", msg.arg1, msg.arg2);
746            boolean error_was_handled = false;
747            if (mOnErrorListener != null)
748              error_was_handled = mOnErrorListener.onError(mMediaPlayer, msg.arg1, msg.arg2);
749            if (mOnCompletionListener != null && !error_was_handled)
750              mOnCompletionListener.onCompletion(mMediaPlayer);
751            stayAwake(false);
752            return;
753          case MEDIA_INFO:
754            Log.i("Info (%d, %d)", msg.arg1, msg.arg2);
755            if (mOnInfoListener != null)
756              mOnInfoListener.onInfo(mMediaPlayer, msg.arg1, msg.arg2);
757            return;
758          case MEDIA_CACHE:
759            return;
760          case MEDIA_TIMED_TEXT:
761            mData = msg.getData();
762            if (mData.getInt(MEDIA_SUBTITLE_TYPE) == SUBTITLE_TEXT) {
763              Log.i("Subtitle : %s", mData.getString(MEDIA_SUBTITLE_STRING));
764              if (mOnTimedTextListener != null)
765                mOnTimedTextListener.onTimedText(mData.getString(MEDIA_SUBTITLE_STRING));
766            } else if (mData.getInt(MEDIA_SUBTITLE_TYPE) == SUBTITLE_BITMAP) {
767              Log.i("Subtitle : bitmap");
768              if (mOnTimedTextListener != null)
769                mOnTimedTextListener.onTimedTextUpdate(mData.getByteArray(MEDIA_SUBTITLE_BYTES), msg.arg1, msg.arg2);
770            }
771            return;
772          case MEDIA_CACHING_UPDATE:
773            if (mOnCachingUpdateListener != null) {
774              int cacheType = msg.getData().getInt(MEDIA_CACHING_TYPE);
775              if (cacheType == CACHE_TYPE_NOT_AVAILABLE) {
776                mOnCachingUpdateListener.onCachingNotAvailable(mMediaPlayer, msg.getData().getInt(MEDIA_CACHING_INFO));
777              } else if (cacheType == CACHE_TYPE_UPDATE) {
778                mOnCachingUpdateListener.onCachingUpdate(mMediaPlayer, msg.getData().getLongArray(MEDIA_CACHING_SEGMENTS));
779              } else if (cacheType == CACHE_TYPE_SPEED) {
780                mOnCachingUpdateListener.onCachingSpeed(mMediaPlayer, msg.getData().getInt(MEDIA_CACHING_INFO));
781              } else if (cacheType == CACHE_TYPE_START) {
782              	mOnCachingUpdateListener.onCachingStart(mMediaPlayer);
783              } else if (cacheType == CACHE_TYPE_COMPLETE) {
784              	mOnCachingUpdateListener.onCachingComplete(mMediaPlayer);
785              }
786            }
787            return;
788          case MEDIA_NOP:
789            return;
790          case MEDIA_HW_ERROR:
791          	if (mOnHWRenderFailedListener != null)
792          		mOnHWRenderFailedListener.onFailed();
793          	return;
794          default:
795            Log.e("Unknown message type " + msg.what);
796            return;
797        }
798      }
799    }
800  }
</code></pre>
        </div>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaPlayer.java</h3>
            <pre><code>1  package io.vov.vitamio;
2  import android.annotation.SuppressLint;
3  import android.content.ContentResolver;
4  import android.content.Context;
5  import android.content.res.AssetFileDescriptor;
6  import android.graphics.Bitmap;
7  import android.graphics.Canvas;
8  import android.media.AudioFormat;
9  import android.media.AudioManager;
10  import android.media.AudioTrack;
11  import android.net.Uri;
12  import android.os.Build;
13  import android.os.Bundle;
14  import android.os.Handler;
15  import android.os.Looper;
16  import android.os.Message;
17  import android.os.PowerManager;
18  import android.text.TextUtils;
19  import android.util.SparseArray;
20  import android.view.Surface;
21  import android.view.SurfaceHolder;
22  import io.vov.vitamio.utils.FileUtils;
23  import io.vov.vitamio.utils.Log;
24  import java.io.File;
25  import java.io.FileDescriptor;
26  import java.io.FileInputStream;
27  import java.io.IOException;
28  import java.io.UnsupportedEncodingException;
29  import java.nio.ByteBuffer;
30  import java.nio.charset.Charset;
31  import java.util.HashMap;
32  import java.util.Map;
33  import java.util.concurrent.atomic.AtomicBoolean;
34  public class MediaPlayer {
35    public static final int CACHE_TYPE_NOT_AVAILABLE = 1;
36    public static final int CACHE_TYPE_START = 2;
37    public static final int CACHE_TYPE_UPDATE = 3;
38    public static final int CACHE_TYPE_SPEED = 4;
39    public static final int CACHE_TYPE_COMPLETE = 5;
40    public static final int CACHE_INFO_NO_SPACE = 1;
41    public static final int CACHE_INFO_STREAM_NOT_SUPPORT = 2;
42    public static final int MEDIA_ERROR_UNKNOWN = 1;
43    public static final int MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = 200;
44    public static final int MEDIA_ERROR_IO = -5;
45    public static final int MEDIA_ERROR_MALFORMED = -1007;
46    public static final int MEDIA_ERROR_UNSUPPORTED = -1010;
47    public static final int MEDIA_ERROR_TIMED_OUT = -110;
48    public static final int MEDIA_INFO_VIDEO_TRACK_LAGGING = 700;
49    public static final int MEDIA_INFO_BUFFERING_START = 701;
50    public static final int MEDIA_INFO_BUFFERING_END = 702;
51    public static final int MEDIA_INFO_NOT_SEEKABLE = 801;
52    public static final int MEDIA_INFO_DOWNLOAD_RATE_CHANGED = 901;
53    public static final int VIDEOQUALITY_LOW = -16;
54    public static final int VIDEOQUALITY_MEDIUM = 0;
55    public static final int VIDEOQUALITY_HIGH = 16;
56    public static final int VIDEOCHROMA_RGB565 = 0;
57    public static final int VIDEOCHROMA_RGBA = 1;
58    public static final int SUBTITLE_INTERNAL = 0;
59    public static final int SUBTITLE_EXTERNAL = 1;
60    public static final String[] SUB_TYPES = {".srt", ".ssa", ".smi", ".txt", ".sub", ".ass", ".webvtt"};
61    private static final int MEDIA_NOP = 0;
62    private static final int MEDIA_PREPARED = 1;
63    private static final int MEDIA_PLAYBACK_COMPLETE = 2;
64    private static final int MEDIA_BUFFERING_UPDATE = 3;
65    private static final int MEDIA_SEEK_COMPLETE = 4;
66    private static final int MEDIA_SET_VIDEO_SIZE = 5;
67    private static final int MEDIA_ERROR = 100;
68    private static final int MEDIA_INFO = 200;
69    private static final int MEDIA_CACHE = 300;
70    private static final int MEDIA_HW_ERROR = 400;
71    private static final int MEDIA_TIMED_TEXT = 1000;
72    private static final int MEDIA_CACHING_UPDATE = 2000;
73    private static final String MEDIA_CACHING_SEGMENTS = "caching_segment";
74    private static final String MEDIA_CACHING_TYPE = "caching_type";
75    private static final String MEDIA_CACHING_INFO = "caching_info";
76    private static final String MEDIA_SUBTITLE_STRING = "sub_string";
77    private static final String MEDIA_SUBTITLE_BYTES = "sub_bytes";
78    private static final String MEDIA_SUBTITLE_TYPE = "sub_type";
79    private static final int SUBTITLE_TEXT = 0;
80    private static final int SUBTITLE_BITMAP = 1;
81    private static AtomicBoolean NATIVE_OMX_LOADED = new AtomicBoolean(false);
82    private Context mContext;
83    private Surface mSurface;
84    private SurfaceHolder mSurfaceHolder;
85    private EventHandler mEventHandler;
86    private PowerManager.WakeLock mWakeLock = null;
87    private boolean mScreenOnWhilePlaying;
88    private boolean mStayAwake;
89    private Metadata mMeta;
90    private TrackInfo[] mInbandTracks;
91    private TrackInfo mOutOfBandTracks;
92    private AssetFileDescriptor mFD = null;
93    private OnHWRenderFailedListener mOnHWRenderFailedListener;
94    private OnPreparedListener mOnPreparedListener;
95    private OnCompletionListener mOnCompletionListener;
96    private OnBufferingUpdateListener mOnBufferingUpdateListener;
97    private OnCachingUpdateListener mOnCachingUpdateListener;
98    private OnSeekCompleteListener mOnSeekCompleteListener;
99    private OnVideoSizeChangedListener mOnVideoSizeChangedListener;
100    private OnErrorListener mOnErrorListener;
101    private OnInfoListener mOnInfoListener;
102    private OnTimedTextListener mOnTimedTextListener;
103    private AudioTrack mAudioTrack;
104    private int mAudioTrackBufferSize;
105    private Surface mLocalSurface;
106    private Bitmap mBitmap;
107    private ByteBuffer mByteBuffer;
108    public MediaPlayer(Context ctx) {
109      this(ctx, false);
110    }
111    public MediaPlayer(Context ctx, boolean preferHWDecoder) {
112      mContext = ctx;
113      String LIB_ROOT = Vitamio.getLibraryPath();
114      if (preferHWDecoder) {
115        if (!NATIVE_OMX_LOADED.get()) {
116          if (Build.VERSION.SDK_INT > 17)
117            loadOMX_native(LIB_ROOT + "libOMX.18.so");
118          else if (Build.VERSION.SDK_INT > 13)
119            loadOMX_native(LIB_ROOT + "libOMX.14.so");
120          else if (Build.VERSION.SDK_INT > 10)
121            loadOMX_native(LIB_ROOT + "libOMX.11.so");
122          else
123            loadOMX_native(LIB_ROOT + "libOMX.9.so");
124          NATIVE_OMX_LOADED.set(true);
125        }
126      } else {
127        try {
128          unloadOMX_native();
129        } catch (UnsatisfiedLinkError e) {
130          Log.e("unloadOMX failed %s", e.toString());
131        }
132        NATIVE_OMX_LOADED.set(false);
133      }
134      Looper looper;
135      if ((looper = Looper.myLooper()) != null)
136        mEventHandler = new EventHandler(this, looper);
137      else if ((looper = Looper.getMainLooper()) != null)
138        mEventHandler = new EventHandler(this, looper);
139      else
140        mEventHandler = null;
141      native_init();
142    }
143    static {
144      String LIB_ROOT = Vitamio.getLibraryPath();
145      try {
146        Log.i("LIB ROOT: %s", LIB_ROOT);
147        System.load(LIB_ROOT + "libstlport_shared.so");
148        System.load(LIB_ROOT + "libvplayer.so");
149        loadFFmpeg_native(LIB_ROOT + "libffmpeg.so");
150        boolean vvo_loaded = false;
151        if (Build.VERSION.SDK_INT > 8)
152          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.9.so");
153        else if (Build.VERSION.SDK_INT > 7)
154          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.8.so");
155        else
156          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.7.so");
157        if (!vvo_loaded) {
158          vvo_loaded = loadVVO_native(LIB_ROOT + "libvvo.j.so");
159          Log.d("FALLBACK TO VVO JNI " + vvo_loaded);
160        }
161        loadVAO_native(LIB_ROOT + "libvao.0.so");
162      } catch (java.lang.UnsatisfiedLinkError e) {
163        Log.e("Error loading libs", e);
164      }
165    }
166    private static void postEventFromNative(Object mediaplayer_ref, int what, int arg1, int arg2, Object obj) {
167      MediaPlayer mp = (MediaPlayer) (mediaplayer_ref);
168      if (mp == null)
169        return;
170      if (mp.mEventHandler != null) {
171        Message m = mp.mEventHandler.obtainMessage(what, arg1, arg2, obj);
172        mp.mEventHandler.sendMessage(m);
173      }
174    }
175    private static native boolean loadVAO_native(String vaoPath);
176    private static native boolean loadVVO_native(String vvoPath);
177    private static native boolean loadOMX_native(String omxPath);
178    private static native void unloadOMX_native();
179    private static native boolean loadFFmpeg_native(String ffmpegPath);
180    private native void _setVideoSurface(Surface surface);
181    public void setDisplay(SurfaceHolder sh) {
182      if (sh == null) {
183        releaseDisplay();
184      } else {
185        mSurfaceHolder = sh;
186        mSurface = sh.getSurface();
187        _setVideoSurface(mSurface);
188        updateSurfaceScreenOn();
189      }
190    }
191    public void setSurface(Surface surface) {
192      if (surface == null) {
193        releaseDisplay();
194      } else {
195        mSurfaceHolder = null;
196        mSurface = surface;
197        _setVideoSurface(mSurface);
198        updateSurfaceScreenOn();
199      }
200    }
201    public void setDataSource(String path) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
202      _setDataSource(path, null, null);
203    }
204    public void setDataSource(Context context, Uri uri) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
205      setDataSource(context, uri, null);
206    }
207    public void setDataSource(Context context, Uri uri, Map<String, String> headers) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
208      if (context == null || uri == null)
209        throw new IllegalArgumentException();
210      String scheme = uri.getScheme();
211      if (scheme == null || scheme.equals("file")) {
212        setDataSource(FileUtils.getPath(uri.toString()));
213        return;
214      }
215      try {
216        ContentResolver resolver = context.getContentResolver();
217        mFD = resolver.openAssetFileDescriptor(uri, "r");
218        if (mFD == null)
219          return;
220        setDataSource(mFD.getParcelFileDescriptor().getFileDescriptor());
221        return;
222      } catch (Exception e) {
223        closeFD();
224      }
225      setDataSource(uri.toString(), headers);
226    }
227    public void setDataSource(String path, Map<String, String> headers)
228            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException
229    {
230        String[] keys = null;
231        String[] values = null;
232        if (headers != null) {
233            keys = new String[headers.size()];
234            values = new String[headers.size()];
235            int i = 0;
236            for (Map.Entry<String, String> entry: headers.entrySet()) {
237                keys[i] = entry.getKey();
238                values[i] = entry.getValue();
239                ++i;
240            }
241        }
242        setDataSource(path, keys, values);
243    }
244  	public void setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
245  		final Uri uri = Uri.parse(path);
246  		if ("file".equals(uri.getScheme())) {
247  			path = uri.getPath();
248  		}
249  		final File file = new File(path);
250  		if (file.exists()) {
251  			FileInputStream is = new FileInputStream(file);
252  			FileDescriptor fd = is.getFD();
253  			setDataSource(fd);
254  			is.close();
255  		} else {
256  			_setDataSource(path, keys, values);
257  		}
258  	}
259    public void setDataSegments(String[] uris, String cacheDir) {
260    	_setDataSegmentsSource(uris, cacheDir);
261    }
262    public void setOnHWRenderFailedListener(OnHWRenderFailedListener l) {
263      mOnHWRenderFailedListener = l;
264    }
265    private native void _setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, IllegalStateException;
266    public native void setDataSource(FileDescriptor fd) throws IOException, IllegalArgumentException, IllegalStateException;
267    private native void _setDataSegmentsSource(String[] segments, String cacheDir);
268    public native void prepare() throws IOException, IllegalStateException;
269    public native void prepareAsync() throws IllegalStateException;
270    public void start() throws IllegalStateException {
271      stayAwake(true);
272      _start();
273    }
274    private native void _start() throws IllegalStateException;
275    public void stop() throws IllegalStateException {
276      stayAwake(false);
277      _stop();
278    }
279    private native void _stop() throws IllegalStateException;
280    public void pause() throws IllegalStateException {
281      stayAwake(false);
282      _pause();
283    }
284    private native void _pause() throws IllegalStateException;
285    @SuppressLint("Wakelock")
286    public void setWakeMode(Context context, int mode) {
287      boolean washeld = false;
288      if (mWakeLock != null) {
289        if (mWakeLock.isHeld()) {
290          washeld = true;
291          mWakeLock.release();
292        }
293        mWakeLock = null;
294      }
295      PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
296      mWakeLock = pm.newWakeLock(mode | PowerManager.ON_AFTER_RELEASE, MediaPlayer.class.getName());
297      mWakeLock.setReferenceCounted(false);
298      if (washeld) {
299        mWakeLock.acquire();
300      }
301    }
302    public void setScreenOnWhilePlaying(boolean screenOn) {
303      if (mScreenOnWhilePlaying != screenOn) {
304        mScreenOnWhilePlaying = screenOn;
305        updateSurfaceScreenOn();
306      }
307    }
308    @SuppressLint("Wakelock")
309    private void stayAwake(boolean awake) {
310      if (mWakeLock != null) {
311        if (awake && !mWakeLock.isHeld()) {
312          mWakeLock.acquire();
313        } else if (!awake && mWakeLock.isHeld()) {
314          mWakeLock.release();
315        }
316      }
317      mStayAwake = awake;
318      updateSurfaceScreenOn();
319    }
320    private void updateSurfaceScreenOn() {
321      if (mSurfaceHolder != null)
322        mSurfaceHolder.setKeepScreenOn(mScreenOnWhilePlaying && mStayAwake);
323    }
324    public native int getVideoWidth();
325    private native int getVideoWidth_a();
326    public native int getVideoHeight();
327    private native int getVideoHeight_a();
328    public native boolean isPlaying();
329    public native void setUseCache(boolean cache);
330    public native void setCacheDirectory(String directory);
331    public native void setAdaptiveStream(boolean adaptive);
332    public native void seekTo(long msec) throws IllegalStateException;
333    public native long getCurrentPosition();
334    public native Bitmap getCurrentFrame();
335    public native long getDuration();
336    public Metadata getMetadata() {
337      if (mMeta == null) {
338        mMeta = new Metadata();
339        Map<byte[], byte[]> meta = new HashMap<byte[], byte[]>();
340        if (!native_getMetadata(meta)) {
341          return null;
342        }
343        if (!mMeta.parse(meta, getMetaEncoding())) {
344          return null;
345        }
346      }
347      return mMeta;
348    }
349    public void release() {
350      stayAwake(false);
351      updateSurfaceScreenOn();
352      mOnPreparedListener = null;
353      mOnBufferingUpdateListener = null;
354      mOnCompletionListener = null;
<span onclick='openModal()' class='match'>355      mOnSeekCompleteListener = null;
356      mOnErrorListener = null;
357      mOnInfoListener = null;
358      mOnVideoSizeChangedListener = null;
359      mOnCachingUpdateListener = null;
</span>360      mOnHWRenderFailedListener = null;
361      _release();
362      closeFD();
363    }
364    private native void _release();
365    public void reset() {
366      stayAwake(false);
367      _reset();
368      mEventHandler.removeCallbacksAndMessages(null);
369      closeFD();
370    }
371    private native void _reset();
372    private void closeFD() {
373      if (mFD != null) {
374        try {
375          mFD.close();
376        } catch (IOException e) {
377          Log.e("closeFD", e);
378        }
379        mFD = null;
380      }
381    }
382    public native void setLooping(boolean looping);
383    public native boolean isLooping();
384    public native void setAudioAmplify(float ratio);
385    public native void setVolume(float leftVolume, float rightVolume);
386    private native final boolean native_getTrackInfo(SparseArray<byte[]> trackSparse);
387    private native final boolean native_getMetadata(Map<byte[], byte[]> meta);
388    private native final void native_init();
389    private native final void native_finalize();
390    public TrackInfo[] getTrackInfo(String encoding) {
391    	TrackInfo[] trackInfo = getInbandTrackInfo(encoding);
392    	String timedTextPath = getTimedTextPath();
393    	if (TextUtils.isEmpty(timedTextPath)) {
394    		return trackInfo;
395    	}
396      TrackInfo[] allTrackInfo = new TrackInfo[trackInfo.length + 1];
397      System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
398      int i = trackInfo.length;
399      SparseArray<MediaFormat> trackInfoArray = new SparseArray<MediaFormat>();
400      MediaFormat mediaFormat = new MediaFormat();
401      mediaFormat.setString(MediaFormat.KEY_TITLE, timedTextPath.substring(timedTextPath.lastIndexOf("/")));
402      mediaFormat.setString(MediaFormat.KEY_PATH, timedTextPath);
403      SparseArray<MediaFormat> timedTextSparse = findTrackFromTrackInfo(TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT, trackInfo);
404      if (timedTextSparse == null || timedTextSparse.size() == 0)
405      	trackInfoArray.put(timedTextSparse.keyAt(0), mediaFormat);
406      else 
407      	trackInfoArray.put(timedTextSparse.keyAt(timedTextSparse.size() - 1), mediaFormat);
408      mOutOfBandTracks = new TrackInfo(TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE, trackInfoArray);
409      allTrackInfo[i] = mOutOfBandTracks;
410      return allTrackInfo;
411    }
412    private TrackInfo[] getInbandTrackInfo(String encoding) {
413    	if (mInbandTracks == null) {
414    		SparseArray<byte[]> trackSparse = new SparseArray<byte[]>();
415        if (!native_getTrackInfo(trackSparse)) {
416          return null;
417        }
418        int size = trackSparse.size();
419        mInbandTracks = new TrackInfo[size];
420        for (int i = 0; i < size; i++) {
421        	SparseArray<MediaFormat> sparseArray = parseTrackInfo(trackSparse.valueAt(i), encoding);
422          TrackInfo trackInfo = new TrackInfo(trackSparse.keyAt(i), sparseArray);
423          mInbandTracks[i] = trackInfo;
424        }
425    	}
426      return mInbandTracks;
427    }
428    public TrackInfo[] getTrackInfo() {
429      return getTrackInfo(Charset.defaultCharset().name());
430    }
431    private SparseArray<MediaFormat> parseTrackInfo(byte[] tracks, String encoding) {
432      SparseArray<MediaFormat> trackSparse = new SparseArray<MediaFormat>();
433      String trackString;
434      int trackNum;
435      try {
436        trackString = new String(tracks, encoding);
437      } catch (Exception e) {
438        Log.e("getTrackMap exception");
439        trackString = new String(tracks);
440      }
441      for (String s : trackString.split("!#!")) {
442        try {
443        	MediaFormat mediaFormat = null;
444        	String[] formats = s.split("\\.");
445        	if (formats == null)
446        		continue;
447        	trackNum = Integer.parseInt(formats[0]);
448        	if (formats.length == 3) {
449        		mediaFormat = MediaFormat.createSubtitleFormat(formats[2], formats[1]);
450        	} else if (formats.length == 2) {
451        		mediaFormat = MediaFormat.createSubtitleFormat("", formats[1]);
452        	}
453          trackSparse.put(trackNum, mediaFormat);
454        } catch (NumberFormatException e) {
455        }
456      }
457      return trackSparse;
458    }
459    public SparseArray<MediaFormat> findTrackFromTrackInfo(int mediaTrackType, TrackInfo[] trackInfo) {
460      for (int i = 0; i < trackInfo.length; i++) {
461        if (trackInfo[i].getTrackType() == mediaTrackType) {
462          return trackInfo[i].getTrackInfoArray();
463        }
464      }
465      return null;
466    }
467    public native void addTimedTextSource(String path);
468    public void selectTrack(int index) {
469    	selectOrDeselectBandTrack(index, true &bsol;* select */);
470    }
471    public void deselectTrack(int index) {
472    	selectOrDeselectBandTrack(index, false &bsol;* select */);
473    }
474    private void selectOrDeselectBandTrack(int index, boolean select) {
475    	if (mOutOfBandTracks != null) {
476    		SparseArray<MediaFormat> mediaSparse = mOutOfBandTracks.getTrackInfoArray();
477    		int trackIndex = mediaSparse.keyAt(0);
478    		MediaFormat mediaFormat = mediaSparse.valueAt(0);
479      	if (index == trackIndex  && select) {
480      		addTimedTextSource(mediaFormat.getString(MediaFormat.KEY_PATH));
481      		return;
482      	}
483    	}
484    	selectOrDeselectTrack(index, select);
485    }
486    private native void selectOrDeselectTrack(int index, boolean select);
487    @Override
488    protected void finalize() {
489      native_finalize();
490    }
491    public void setOnPreparedListener(OnPreparedListener listener) {
492      mOnPreparedListener = listener;
493    }
494    public void setOnCompletionListener(OnCompletionListener listener) {
495      mOnCompletionListener = listener;
496    }
497    public void setOnBufferingUpdateListener(OnBufferingUpdateListener listener) {
498      mOnBufferingUpdateListener = listener;
499    }
500    public void setOnCachingUpdateListener(OnCachingUpdateListener listener) {
501      mOnCachingUpdateListener = listener;
502    }
503    private void updateCacheStatus(int type, int info, long[] segments) {
504      if (mEventHandler != null) {
505        Message m = mEventHandler.obtainMessage(MEDIA_CACHING_UPDATE);
506        Bundle b = m.getData();
507        b.putInt(MEDIA_CACHING_TYPE, type);
508        b.putInt(MEDIA_CACHING_INFO, info);
509        b.putLongArray(MEDIA_CACHING_SEGMENTS, segments);
510        mEventHandler.sendMessage(m);
511      }
512    }
513    public void setOnSeekCompleteListener(OnSeekCompleteListener listener) {
514      mOnSeekCompleteListener = listener;
515    }
516    public void setOnVideoSizeChangedListener(OnVideoSizeChangedListener listener) {
517      mOnVideoSizeChangedListener = listener;
518    }
519    public void setOnErrorListener(OnErrorListener listener) {
520      mOnErrorListener = listener;
521    }
522    public void setOnInfoListener(OnInfoListener listener) {
523      mOnInfoListener = listener;
524    }
525    public void setOnTimedTextListener(OnTimedTextListener listener) {
526      mOnTimedTextListener = listener;
527    }
528    private void updateSub(int subType, byte[] bytes, String encoding, int width, int height) {
529      if (mEventHandler != null) {
530        Message m = mEventHandler.obtainMessage(MEDIA_TIMED_TEXT, width, height);
531        Bundle b = m.getData();
532        if (subType == SUBTITLE_TEXT) {
533          b.putInt(MEDIA_SUBTITLE_TYPE, SUBTITLE_TEXT);
534          if (encoding == null) {
535            b.putString(MEDIA_SUBTITLE_STRING, new String(bytes));
536          } else {
537            try {
538              b.putString(MEDIA_SUBTITLE_STRING, new String(bytes, encoding.trim()));
539            } catch (UnsupportedEncodingException e) {
540              Log.e("updateSub", e);
541              b.putString(MEDIA_SUBTITLE_STRING, new String(bytes));
542            }
543          }
544        } else if (subType == SUBTITLE_BITMAP) {
545          b.putInt(MEDIA_SUBTITLE_TYPE, SUBTITLE_BITMAP);
546          b.putByteArray(MEDIA_SUBTITLE_BYTES, bytes);
547        }
548        mEventHandler.sendMessage(m);
549      }
550    }
551    protected native void _releaseVideoSurface();
552    public void releaseDisplay() {
553      _releaseVideoSurface();
554      mSurfaceHolder = null;
555      mSurface = null;
556    }
557    public native float getVideoAspectRatio();
558    public native void setVideoQuality(int quality);
559    public native void setVideoChroma(int chroma);
560    public native void setDeinterlace(boolean deinterlace);
561    public native void setBufferSize(long bufSize);
562    public native void setPlaybackSpeed(float speed);
563    public native boolean isBuffering();
564    public native int getBufferProgress();
565    public native String getMetaEncoding();
566    public native void setMetaEncoding(String encoding);
567  	public native int getAudioTrack();
568  	public native int getVideoTrack();
569    public native void setTimedTextShown(boolean shown);
570    public native void setTimedTextEncoding(String encoding);
571    public native int getTimedTextLocation();
572    public native String getTimedTextPath();
573    public native int getTimedTextTrack();
574    private int audioTrackInit(int sampleRateInHz, int channels) {
575      audioTrackRelease();
576      int channelConfig = channels >= 2 ? AudioFormat.CHANNEL_OUT_STEREO : AudioFormat.CHANNEL_OUT_MONO;
577      try {
578        mAudioTrackBufferSize = AudioTrack.getMinBufferSize(sampleRateInHz, channelConfig, AudioFormat.ENCODING_PCM_16BIT);
579        mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRateInHz, channelConfig, AudioFormat.ENCODING_PCM_16BIT, mAudioTrackBufferSize, AudioTrack.MODE_STREAM);
580      } catch (Exception e) {
581        mAudioTrackBufferSize = 0;
582        Log.e("audioTrackInit", e);
583      }
584      return mAudioTrackBufferSize;
585    }
586    private void audioTrackSetVolume(float leftVolume, float rightVolume) {
587      if (mAudioTrack != null)
588        mAudioTrack.setStereoVolume(leftVolume, rightVolume);
589    }
590    private void audioTrackWrite(byte[] audioData, int offsetInBytes, int sizeInBytes) {
591      if (mAudioTrack != null && mAudioTrack.getPlayState() == AudioTrack.PLAYSTATE_PLAYING) {
592        int written;
593        while (sizeInBytes > 0) {
594          written = sizeInBytes > mAudioTrackBufferSize ? mAudioTrackBufferSize : sizeInBytes;
595          mAudioTrack.write(audioData, offsetInBytes, written);
596          sizeInBytes -= written;
597          offsetInBytes += written;
598        }
599      }
600    }
601    private void audioTrackStart() {
602      if (mAudioTrack != null && mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED && mAudioTrack.getPlayState() != AudioTrack.PLAYSTATE_PLAYING)
603        mAudioTrack.play();
604    }
605    private void audioTrackPause() {
606      if (mAudioTrack != null && mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)
607        mAudioTrack.pause();
608    }
609    private void audioTrackRelease() {
610      if (mAudioTrack != null) {
611        if (mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)
612          mAudioTrack.stop();
613        mAudioTrack.release();
614      }
615      mAudioTrack = null;
616    }
617    public int getAudioSessionId() {
618  	return mAudioTrack.getAudioSessionId();
619    }
620    private ByteBuffer surfaceInit() {
621      synchronized (this) {
622        mLocalSurface = mSurface;
623        int w = getVideoWidth_a();
624        int h = getVideoHeight_a();
625        if (mLocalSurface != null && w != 0 && h != 0) {
626          mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.RGB_565);
627          mByteBuffer = ByteBuffer.allocateDirect(w * h * 2);
628        } else {
629          mBitmap = null;
630          mByteBuffer = null;
631        }
632        return mByteBuffer;
633      }
634    }
635    private void surfaceRender() {
636      synchronized (this) {
637        if (mLocalSurface == null || !mLocalSurface.isValid() || mBitmap == null || mByteBuffer == null)
638          return;
639        try {
640          Canvas c = mLocalSurface.lockCanvas(null);
641          mBitmap.copyPixelsFromBuffer(mByteBuffer);
642          c.drawBitmap(mBitmap, 0, 0, null);
643          mLocalSurface.unlockCanvasAndPost(c);
644        } catch (Exception e) {
645          Log.e("surfaceRender", e);
646        }
647      }
648    }
649    private void surfaceRelease() {
650      synchronized (this) {
651        mLocalSurface = null;
652        mBitmap = null;
653        mByteBuffer = null;
654      }
655    }
656    public interface OnHWRenderFailedListener {
657      public void onFailed();
658    }
659    public interface OnPreparedListener {
660      void onPrepared(MediaPlayer mp);
661    }
662    public interface OnCompletionListener {
663      void onCompletion(MediaPlayer mp);
664    }
665    public interface OnBufferingUpdateListener {
666      void onBufferingUpdate(MediaPlayer mp, int percent);
667    }
668    public interface OnCachingUpdateListener {
669      void onCachingUpdate(MediaPlayer mp, long[] segments);
670      void onCachingSpeed(MediaPlayer mp, int speed);
671      void onCachingStart(MediaPlayer mp);
672     	void onCachingComplete(MediaPlayer mp); 
673      void onCachingNotAvailable(MediaPlayer mp, int info);
674    }
675    public interface OnSeekCompleteListener {
676      public void onSeekComplete(MediaPlayer mp);
677    }
678    public interface OnVideoSizeChangedListener {
679      public void onVideoSizeChanged(MediaPlayer mp, int width, int height);
680    }
681    public interface OnErrorListener {
682      boolean onError(MediaPlayer mp, int what, int extra);
683    }
684    public interface OnInfoListener {
685      boolean onInfo(MediaPlayer mp, int what, int extra);
686    }
687    public interface OnTimedTextListener {
688      public void onTimedText(String text);
689      public void onTimedTextUpdate(byte[] pixels, int width, int height);
690    }
691    static public class TrackInfo {
692      public static final int MEDIA_TRACK_TYPE_UNKNOWN = 0;
693      public static final int MEDIA_TRACK_TYPE_VIDEO = 1;
694      public static final int MEDIA_TRACK_TYPE_AUDIO = 2;
695      public static final int MEDIA_TRACK_TYPE_TIMEDTEXT = 3;
696      public static final int MEDIA_TRACK_TYPE_SUBTITLE = 4;
697      final int mTrackType;
698      final SparseArray<MediaFormat> mTrackInfoArray;
699      TrackInfo(int trackType, SparseArray<MediaFormat> trackInfoArray) {
700        mTrackType = trackType;
701        mTrackInfoArray = trackInfoArray;
702      }
703      public int getTrackType() {
704        return mTrackType;
705      }
706      public SparseArray<MediaFormat> getTrackInfoArray() {
707        return mTrackInfoArray;
708      }
709    }
710    @SuppressLint("HandlerLeak")
711    private class EventHandler extends Handler {
712      private MediaPlayer mMediaPlayer;
713      private Bundle mData;
714      public EventHandler(MediaPlayer mp, Looper looper) {
715        super(looper);
716        mMediaPlayer = mp;
717      }
718      @Override
719      public void handleMessage(Message msg) {
720        switch (msg.what) {
721          case MEDIA_PREPARED:
722            if (mOnPreparedListener != null)
723              mOnPreparedListener.onPrepared(mMediaPlayer);
724            return;
725          case MEDIA_PLAYBACK_COMPLETE:
726            if (mOnCompletionListener != null)
727              mOnCompletionListener.onCompletion(mMediaPlayer);
728            stayAwake(false);
729            return;
730          case MEDIA_BUFFERING_UPDATE:
731            if (mOnBufferingUpdateListener != null)
732              mOnBufferingUpdateListener.onBufferingUpdate(mMediaPlayer, msg.arg1);
733            return;
734          case MEDIA_SEEK_COMPLETE:
735            if (isPlaying())
736              stayAwake(true);
737            if (mOnSeekCompleteListener != null)
738              mOnSeekCompleteListener.onSeekComplete(mMediaPlayer);
739            return;
740          case MEDIA_SET_VIDEO_SIZE:
741            if (mOnVideoSizeChangedListener != null)
742              mOnVideoSizeChangedListener.onVideoSizeChanged(mMediaPlayer, msg.arg1, msg.arg2);
743            return;
744          case MEDIA_ERROR:
745            Log.e("Error (%d, %d)", msg.arg1, msg.arg2);
746            boolean error_was_handled = false;
747            if (mOnErrorListener != null)
748              error_was_handled = mOnErrorListener.onError(mMediaPlayer, msg.arg1, msg.arg2);
749            if (mOnCompletionListener != null && !error_was_handled)
750              mOnCompletionListener.onCompletion(mMediaPlayer);
751            stayAwake(false);
752            return;
753          case MEDIA_INFO:
754            Log.i("Info (%d, %d)", msg.arg1, msg.arg2);
755            if (mOnInfoListener != null)
756              mOnInfoListener.onInfo(mMediaPlayer, msg.arg1, msg.arg2);
757            return;
758          case MEDIA_CACHE:
759            return;
760          case MEDIA_TIMED_TEXT:
761            mData = msg.getData();
762            if (mData.getInt(MEDIA_SUBTITLE_TYPE) == SUBTITLE_TEXT) {
763              Log.i("Subtitle : %s", mData.getString(MEDIA_SUBTITLE_STRING));
764              if (mOnTimedTextListener != null)
765                mOnTimedTextListener.onTimedText(mData.getString(MEDIA_SUBTITLE_STRING));
766            } else if (mData.getInt(MEDIA_SUBTITLE_TYPE) == SUBTITLE_BITMAP) {
767              Log.i("Subtitle : bitmap");
768              if (mOnTimedTextListener != null)
769                mOnTimedTextListener.onTimedTextUpdate(mData.getByteArray(MEDIA_SUBTITLE_BYTES), msg.arg1, msg.arg2);
770            }
771            return;
772          case MEDIA_CACHING_UPDATE:
773            if (mOnCachingUpdateListener != null) {
774              int cacheType = msg.getData().getInt(MEDIA_CACHING_TYPE);
775              if (cacheType == CACHE_TYPE_NOT_AVAILABLE) {
776                mOnCachingUpdateListener.onCachingNotAvailable(mMediaPlayer, msg.getData().getInt(MEDIA_CACHING_INFO));
777              } else if (cacheType == CACHE_TYPE_UPDATE) {
778                mOnCachingUpdateListener.onCachingUpdate(mMediaPlayer, msg.getData().getLongArray(MEDIA_CACHING_SEGMENTS));
779              } else if (cacheType == CACHE_TYPE_SPEED) {
780                mOnCachingUpdateListener.onCachingSpeed(mMediaPlayer, msg.getData().getInt(MEDIA_CACHING_INFO));
781              } else if (cacheType == CACHE_TYPE_START) {
782              	mOnCachingUpdateListener.onCachingStart(mMediaPlayer);
783              } else if (cacheType == CACHE_TYPE_COMPLETE) {
784              	mOnCachingUpdateListener.onCachingComplete(mMediaPlayer);
785              }
786            }
787            return;
788          case MEDIA_NOP:
789            return;
790          case MEDIA_HW_ERROR:
791          	if (mOnHWRenderFailedListener != null)
792          		mOnHWRenderFailedListener.onFailed();
793          	return;
794          default:
795            Log.e("Unknown message type " + msg.what);
796            return;
797        }
798      }
799    }
800  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaPlayer.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-MediaPlayer.java</div>
                </div>
                <div class="column column_space"><pre><code>356      mOnErrorListener = null;
357      mOnInfoListener = null;
358      mOnVideoSizeChangedListener = null;
359      mOnCachingUpdateListener = null;
360      mOnHWRenderFailedListener = null;
</pre></code></div>
                <div class="column column_space"><pre><code>355      mOnSeekCompleteListener = null;
356      mOnErrorListener = null;
357      mOnInfoListener = null;
358      mOnVideoSizeChangedListener = null;
359      mOnCachingUpdateListener = null;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    