<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for BrazilianAnalyzerProvider.java &amp; BackgroundIndexer.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for BrazilianAnalyzerProvider.java &amp; BackgroundIndexer.java
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>BrazilianAnalyzerProvider.java (28.125%)<th>BackgroundIndexer.java (2.2959185%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-32)<td><a href="#" name="0">(47-58)</a><td align="center"><font color="#ff0000">9</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>BrazilianAnalyzerProvider.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 package org.elasticsearch.analysis.common;
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import org.apache.lucene.analysis.CharArraySet;
4 import org.apache.lucene.analysis.br.BrazilianAnalyzer;
5 import org.elasticsearch.common.settings.Settings;
6 import org.elasticsearch.env.Environment;
7 import org.elasticsearch.index.IndexSettings;
8 import org.elasticsearch.index.analysis.AbstractIndexAnalyzerProvider;
9 import org.elasticsearch.index.analysis.Analysis;
10 public class BrazilianAnalyzerProvider extends AbstractIndexAnalyzerProvider&lt;BrazilianAnalyzer&gt; {
11     private final BrazilianAnalyzer analyzer</b></font>;
12     BrazilianAnalyzerProvider(IndexSettings indexSettings, Environment env, String name, Settings settings) {
13         super(indexSettings, name, settings);
14         analyzer = new BrazilianAnalyzer(
15             Analysis.parseStopWords(env, settings, BrazilianAnalyzer.getDefaultStopSet()),
16             Analysis.parseStemExclusion(settings, CharArraySet.EMPTY_SET)
17         );
18         analyzer.setVersion(version);
19     }
20     @Override
21     public BrazilianAnalyzer get() {
22         return this.analyzer;
23     }
24 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BackgroundIndexer.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package org.elasticsearch.test;
2 import static org.hamcrest.Matchers.emptyIterable;
3 import static org.hamcrest.Matchers.equalTo;
4 import java.sql.Connection;
5 import java.sql.DriverManager;
6 import java.sql.PreparedStatement;
7 import java.util.ArrayList;
8 import java.util.Collection;
9 import java.util.Locale;
10 import java.util.Properties;
11 import java.util.Random;
12 import java.util.Set;
13 import java.util.concurrent.CountDownLatch;
14 import java.util.concurrent.Semaphore;
15 import java.util.concurrent.TimeUnit;
16 import java.util.concurrent.atomic.AtomicBoolean;
17 import java.util.concurrent.atomic.AtomicLong;
18 import java.util.function.Consumer;
19 import javax.annotation.Nullable;
20 import com.carrotsearch.randomizedtesting.RandomizedTest;
21 <a name="0"></a>
22 import org.apache.logging.log4j.LogManager;
23 import org.apache.logging.log4j.Logger;
24 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import org.apache.logging.log4j.message.ParameterizedMessage;
25 import org.apache.logging.log4j.util.Supplier;
26 import org.elasticsearch.common.util.concurrent.ConcurrentCollections;
27 import org.junit.Assert;
28 import io.crate.common.unit.TimeValue;
29 import io.crate.testing.DataTypeTesting;
30 import io.crate.types.DataTypes;
31 public class BackgroundIndexer implements AutoCloseable {
32     private final Logger logger = LogManager.getLogger(getClass())</b></font>;
33     final Thread[] writers;
34     final CountDownLatch stopLatch;
35     final Collection&lt;Exception&gt; failures = new ArrayList&lt;&gt;();
36     final AtomicBoolean stop = new AtomicBoolean(false);
37     final AtomicLong idGenerator = new AtomicLong();
38     final CountDownLatch startLatch = new CountDownLatch(1);
39     final AtomicBoolean hasBudget = new AtomicBoolean(false);     final Semaphore availableBudget = new Semaphore(0);
40     private final Set&lt;String&gt; ids = ConcurrentCollections.newConcurrentSet();
41     private volatile Consumer&lt;Exception&gt; failureAssertion = null;
42     final String table;
43     volatile int minFieldSize = 10;
44     volatile int maxFieldSize = 140;
45     public BackgroundIndexer(String table,
46                              String column,
47                              String pgUrl,
48                              int numOfDocs,
49                              int writerCount,
50                              boolean autoStart,
51                              @Nullable Random random) {
52         if (random == null) {
53             random = RandomizedTest.getRandom();
54         }
55         this.table = table;
56         writers = new Thread[writerCount];
57         stopLatch = new CountDownLatch(writers.length);
58         logger.info("--&gt; creating {} indexing threads (auto start: [{}], numOfDocs: [{}])", writerCount, autoStart, numOfDocs);
59         for (int i = 0; i &lt; writers.length; i++) {
60             final int indexerId = i;
61             final boolean batch = random.nextBoolean();
62             final Random threadRandom = new Random(random.nextLong());
63             writers[i] = new Thread() {
64                 @Override
65                 public void run() {
66                     long id = -1;
67                     var textGenerator = DataTypeTesting.getDataGenerator(DataTypes.STRING);
68                     Properties properties = new Properties();
69                     properties.setProperty("user", "crate");
70                     try (Connection conn = DriverManager.getConnection(pgUrl, properties)) {
71                         PreparedStatement insertValues = conn.prepareStatement(String.format(
72                             Locale.ENGLISH,
73                             "insert into %s (id, %s) values (?, ?) returning _id",
74                             table,
75                             column
76                         ));
77                         PreparedStatement insertUnnest = conn.prepareStatement(String.format(
78                             Locale.ENGLISH,
79                             "insert into %s (id, %s) (select * from unnest(?, ?)) returning _id",
80                             table,
81                             column
82                         ));
83                         startLatch.await();
84                         logger.info("**** starting indexing thread {}", indexerId);
85                         while (!stop.get()) {
86                             if (batch) {
87                                 int batchSize = threadRandom.nextInt(20) + 1;
88                                 if (hasBudget.get()) {
89                                     batchSize = Math.max(Math.min(batchSize, availableBudget.availablePermits()), 1);
90                                     if (!availableBudget.tryAcquire(batchSize, 250, TimeUnit.MILLISECONDS)) {
91                                         continue;
92                                     }
93                                 }
94                                 Object[] insertIds = new Object[batchSize];
95                                 Object[] strings = new Object[batchSize];
96                                 for (int i = 0; i &lt; batchSize; i++) {
97                                     insertIds[i] = idGenerator.incrementAndGet();
98                                     strings[i] = textGenerator.get();
99                                 }
100                                 try {
101                                     insertUnnest.setObject(1, conn.createArrayOf("bigint", insertIds));
102                                     insertUnnest.setObject(2, conn.createArrayOf("text", strings));
103                                     var result = insertUnnest.executeQuery();
104                                     while (result.next()) {
105                                         ids.add(result.getString(1));
106                                     }
107                                 } catch (Exception e) {
108                                     if (ignoreIndexingFailures == false) {
109                                         throw e;
110                                     }
111                                 }
112                             } else {
113                                 if (hasBudget.get() &amp;&amp; !availableBudget.tryAcquire(250, TimeUnit.MILLISECONDS)) {
114                                     continue;
115                                 }
116                                 try {
117                                     insertValues.setLong(1, idGenerator.incrementAndGet());
118                                     insertValues.setObject(2, textGenerator.get());
119                                     var result = insertValues.executeQuery();
120                                     while (result.next()) {
121                                         ids.add(result.getString(1));
122                                     }
123                                 } catch (Exception e) {
124                                     if (ignoreIndexingFailures == false) {
125                                         throw e;
126                                     }
127                                 }
128                             }
129                         }
130                         logger.info("**** done indexing thread {}  stop: {} numDocsIndexed: {}", indexerId, stop.get(), ids.size());
131                     } catch (Exception e) {
132                         trackFailure(e);
133                         final long docId = id;
134                         logger.warn(
135                             (Supplier&lt;?&gt;)
136                                 () -&gt; new ParameterizedMessage("**** failed indexing thread {} on doc id {}", indexerId, docId), e);
137                     } finally {
138                         stopLatch.countDown();
139                     }
140                 }
141             };
142             writers[i].start();
143         }
144         if (autoStart) {
145             start(numOfDocs);
146         }
147     }
148     private void trackFailure(Exception e) {
149         synchronized (failures) {
150             if (failureAssertion != null) {
151                 failureAssertion.accept(e);
152             } else {
153                 failures.add(e);
154             }
155         }
156     }
157     private volatile TimeValue timeout = new TimeValue(1, TimeUnit.MINUTES);
158     public void setRequestTimeout(TimeValue timeout) {
159         this.timeout = timeout;
160     }
161     private volatile boolean ignoreIndexingFailures;
162     public void setIgnoreIndexingFailures(boolean ignoreIndexingFailures) {
163         this.ignoreIndexingFailures = ignoreIndexingFailures;
164     }
165     private void setBudget(int numOfDocs) {
166         logger.debug("updating budget to [{}]", numOfDocs);
167         if (numOfDocs &gt;= 0) {
168             hasBudget.set(true);
169             availableBudget.release(numOfDocs);
170         } else {
171             hasBudget.set(false);
172         }
173     }
174     public void start(int numOfDocs) {
175         assert !stop.get() : "background indexer can not be started after it has stopped";
176         setBudget(numOfDocs);
177         startLatch.countDown();
178     }
179     public void pauseIndexing() {
180         availableBudget.drainPermits();
181         setBudget(0);
182     }
183     public void continueIndexing(int numOfDocs) {
184         setBudget(numOfDocs);
185     }
186     public void stop() {
187         stop.set(true);
188     }
189     public void awaitStopped() throws InterruptedException {
190         assert stop.get();
191         Assert.assertThat("timeout while waiting for indexing threads to stop", stopLatch.await(6, TimeUnit.MINUTES), equalTo(true));
192         if (failureAssertion == null) {
193             assertNoFailures();
194         }
195     }
196     public void stopAndAwaitStopped() throws InterruptedException {
197         stop();
198         awaitStopped();
199     }
200     public long totalIndexedDocs() {
201         return ids.size();
202     }
203     public void assertNoFailures() {
204         synchronized (failures) {
205             Assert.assertThat(failures, emptyIterable());
206         }
207     }
208     public void setFailureAssertion(Consumer&lt;Exception&gt; failureAssertion) {
209         synchronized (failures) {
210             this.failureAssertion = failureAssertion;
211             boolean success = false;
212             try {
213                 for (Exception failure : failures) {
214                     failureAssertion.accept(failure);
215                 }
216                 failures.clear();
217                 success = true;
218             } finally {
219                 if (success == false) {
220                     stop();
221                 }
222             }
223         }
224     }
225     @Override
226     public void close() throws Exception {
227         stop();
228     }
229     public Set&lt;String&gt; getIds() {
230         return this.ids;
231     }
232 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
