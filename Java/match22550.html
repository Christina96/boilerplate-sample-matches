<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RedisDecoderTest.java &amp; PendingWriteQueueTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RedisDecoderTest.java &amp; PendingWriteQueueTest.java
      </h3>
<h1 align="center">
        35.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RedisDecoderTest.java (38.175045%)<th>PendingWriteQueueTest.java (32.9582%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(236-250)<td><a href="#" name="0">(259-277)</a><td align="center"><font color="#ff0000">29</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(267-278)<td><a href="#" name="1">(331-345)</a><td align="center"><font color="#ed0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(17-43)<td><a href="#" name="2">(16-41)</a><td align="center"><font color="#af0000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(172-178)<td><a href="#" name="3">(357-368)</a><td align="center"><font color="#a70000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(79-86)<td><a href="#" name="4">(287-297)</a><td align="center"><font color="#950000">17</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(108-112)<td><a href="#" name="5">(180-186)</a><td align="center"><font color="#720000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(180-189)<td><a href="#" name="6">(233-240)</a><td align="center"><font color="#690000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(193-200)<td><a href="#" name="7">(140-150)</a><td align="center"><font color="#600000">11</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(330-339)<td><a href="#" name="8">(76-83)</a><td align="center"><font color="#570000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(290-297)<td><a href="#" name="9">(99-106)</a><td align="center"><font color="#570000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(72-77)<td><a href="#" name="10">(60-65)</a><td align="center"><font color="#570000">10</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(310-316)<td><a href="#" name="11">(88-94)</a><td align="center"><font color="#4f0000">9</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(114-121)<td><a href="#" name="12">(401-406)</a><td align="center"><font color="#4f0000">9</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(100-107)<td><a href="#" name="13">(393-398)</a><td align="center"><font color="#4f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RedisDecoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.handler.codec.redis;
2 import io.netty.buffer.ByteBuf;
3 import io.netty.buffer.Unpooled;
4 import io.netty.channel.embedded.EmbeddedChannel;
5 import io.netty.handler.codec.DecoderException;
6 import io.netty.util.IllegalReferenceCountException;
7 import io.netty.util.ReferenceCountUtil;
8 import org.junit.jupiter.api.AfterEach;
9 import org.junit.jupiter.api.BeforeEach;
10 import org.junit.jupiter.api.Test;
11 import org.junit.jupiter.api.function.Executable;
12 import java.util.List;
13 import static io.netty.handler.codec.redis.RedisCodecTestUtil.*;
14 import static org.hamcrest.CoreMatchers.*;
15 import static org.hamcrest.MatcherAssert.assertThat;
16 import static org.junit.jupiter.api.Assertions.assertFalse;
17 import static org.junit.jupiter.api.Assertions.assertNotEquals;
18 import static org.junit.jupiter.api.Assertions.assertThrows;
19 import static org.junit.jupiter.api.Assertions.assertTrue;
20 publi</b></font>c class RedisDecoderTest {
21     private EmbeddedChannel channel;
22     @BeforeEach
23     public void setup() throws Exception {
24         channel = newChannel(false);
25     }
26     private static EmbeddedChannel newChannel(boolean decodeInlineCommands) {
27         return new EmbeddedChannel(
28                 new RedisDecoder(decodeInlineCommands),
29                 new RedisBulkStringAggregator(),
30                 new RedisArrayAggregator());
31     }
32     @AfterEach
33     public void teardown() throws Exception {
34         assertFalse(channel.finish());
35     }
36     @Test
37     public void splitEOLDoesNotInfiniteLoop() throws Exception {
38         assertFalse(channel.writeInbound(byteBufOf("$6\r\nfoobar\r")));
39         assertTrue(channel.writeInbound(byteBufOf("\n")));
40 <a name="10"></a>        RedisMessage msg = channel.readInbound();
41         assertTrue(msg instanceof FullBulkStringRedisMessage);
42         ReferenceCountUtil.release(msg);
43     <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
44     @Test
45     public void shouldNotDecodeInlineCommandByDefault() {
46 <a name="4"></a>        assertThrows(DecoderException.class, new Executable() {
47             @</b></font>Override
48             public void execute() {
49                 assertFalse(<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.writeInbound(byteBufOf("P")));
50                 assertFalse(channel.writeInbound(byteBufOf("I")));
51                 assertFalse(channel.writeInbound(byteBufOf("N")));
52                 assertFalse(channel.writeInbound(byteBufOf("G")));
53                 assertTrue(channel.writeInbound(byteBufOf("\r\n")));
54                 channel.readInbound();
55             }</b></font>
56         });
57     }
58     @Test
59     public void shouldDecodeInlineCommand() {
60         channel = newChannel(true);
61         assertFalse(channel.writeInbound(byteBufOf("P")));
62         assertFalse(channel.writeInbound(byteBufOf("I")));
63         assertFalse(channel.writeInbound(byteBufOf("N")));
64 <a name="13"></a>        assertFalse(channel.writeInbound(byteBufOf("G")));
65         assertTrue(channel.writeInbound(byteBufOf("\r\n")));
66         InlineCommandRedisMessage msg = <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.readInbound();
67         assertThat(msg.content(), is("PING"));
68         ReferenceCountUtil.release(msg);
69 <a name="5"></a>    }
70     @</b></font>Test
71     public void shouldDecodeSimpleString() <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
72         assertFalse(channel.writeInbound(byteBufOf("+")));
73         assertFalse(channel.writeInbound(byteBufOf("O")));
74 <a name="12"></a>        assertFalse(channel.writeInbound(byteBufOf("K")));
75         assertTrue(channel.writeInbound(byteBufOf</b></font>("\r\n")));
76         SimpleStringRedisMessage msg = <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.readInbound();
77         assertThat(msg.content(), is("OK"));
78         ReferenceCountUtil.release(msg);
79     }
80     @</b></font>Test
81     public void shouldDecodeTwoSimpleStrings() {
82         assertFalse(channel.writeInbound(byteBufOf("+")));
83         assertFalse(channel.writeInbound(byteBufOf("O")));
84         assertFalse(channel.writeInbound(byteBufOf("K")));
85         assertTrue(channel.writeInbound(byteBufOf("\r\n+SEC")));
86         assertTrue(channel.writeInbound(byteBufOf("OND\r\n")));
87         SimpleStringRedisMessage msg1 = channel.readInbound();
88         assertThat(msg1.content(), is("OK"));
89         ReferenceCountUtil.release(msg1);
90         SimpleStringRedisMessage msg2 = channel.readInbound();
91         assertThat(msg2.content(), is("SECOND"));
92         ReferenceCountUtil.release(msg2);
93     }
94     @Test
95     public void shouldDecodeError() {
96         String content = "ERROR sample message";
97         assertFalse(channel.writeInbound(byteBufOf("-")));
98         assertFalse(channel.writeInbound(byteBufOf(content)));
99         assertFalse(channel.writeInbound(byteBufOf("\r")));
100         assertTrue(channel.writeInbound(byteBufOf("\n")));
101         ErrorRedisMessage msg = channel.readInbound();
102         assertThat(msg.content(), is(content));
103         ReferenceCountUtil.release(msg);
104     }
105     @Test
106     public void shouldDecodeInteger() {
107         long value = 1234L;
108         byte[] content = bytesOf(value);
109         assertFalse(channel.writeInbound(byteBufOf(":")));
110         assertFalse(channel.writeInbound(byteBufOf(content)));
111         assertTrue(channel.writeInbound(byteBufOf("\r\n")));
112         IntegerRedisMessage msg = channel.readInbound();
113         assertThat(msg.value(), is(value));
114         ReferenceCountUtil.release(msg);
115     }
116     @Test
117 <a name="3"></a>    public void shouldDecodeBulkString() {
118         String buf1 = "bulk\nst";
119         String buf2 = "ring\ntest\n1234";
120         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>byte[] content = bytesOf(buf1 + buf2);
121         assertFalse(channel.writeInbound(byteBufOf("$")));
122         assertFalse(channel.writeInbound(byteBufOf(Integer.toString(content.length))));
123         assertFalse(channel.writeInbound(byteBufOf("\r\n")));
124         assertFalse(channel.writeInbound(byteBufOf(buf1)));
125 <a name="6"></a>        assertFalse(channel.writeInbound(byteBufOf(buf2)));
126         assertTrue</b></font>(channel.writeInbound(byteBufOf("\r\n")));
127         FullBulkStringRedisMessage msg = <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.readInbound();
128         assertThat(bytesOf(msg.content()), is(content));
129         ReferenceCountUtil.release(msg);
130     }
131     @Test
132     public void shouldDecodeEmptyBulkString() {
133         byte[] content = bytesOf("")</b></font>;
134 <a name="7"></a>        assertFalse(channel.writeInbound(byteBufOf("$")));
135         assertFalse(channel.writeInbound(byteBufOf(Integer.toString(content.length))));
136         assertFalse(channel.writeInbound(byteBufOf("\r\n")));
137         assertFalse(channel.writeInbound(<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>byteBufOf(content)));
138         assertTrue(channel.writeInbound(byteBufOf("\r\n")));
139         FullBulkStringRedisMessage msg = channel.readInbound();
140         assertThat(bytesOf(msg.content()), is(content));
141         ReferenceCountUtil.release</b></font>(msg);
142     }
143     @Test
144     public void shouldDecodeNullBulkString() {
145         assertFalse(channel.writeInbound(byteBufOf("$")));
146         assertFalse(channel.writeInbound(byteBufOf(Integer.toString(-1))));
147         assertTrue(channel.writeInbound(byteBufOf("\r\n")));
148         assertTrue(channel.writeInbound(byteBufOf("$")));
149         assertTrue(channel.writeInbound(byteBufOf(Integer.toString(-1))));
150         assertTrue(channel.writeInbound(byteBufOf("\r\n")));
151         FullBulkStringRedisMessage msg1 = channel.readInbound();
152         assertThat(msg1.isNull(), is(true));
153         ReferenceCountUtil.release(msg1);
154         FullBulkStringRedisMessage msg2 = channel.readInbound();
155         assertThat(msg2.isNull(), is(true));
156         ReferenceCountUtil.release(msg2);
157         FullBulkStringRedisMessage msg3 = channel.readInbound();
158         assertThat(msg3, is(nullValue()));
159     }
160     @Test
161     public void shouldDecodeSimpleArray() throws Exception {
162         assertFalse(channel.writeInbound(byteBufOf("*3\r\n")));
163         assertFalse(channel.writeInbound(byteBufOf(":1234\r\n")));
164         assertFalse(channel.writeInbound(byteBufOf("+sim")));
165         assertFalse(channel.writeInbound(byteBufOf("ple\r\n-err")));
166         assertTrue(channel.writeInbound(byteBufOf("or\r\n")));
167 <a name="0"></a>        ArrayRedisMessage msg = channel.readInbound();
168         List&lt;RedisMessage&gt; children = msg.children();
169         assertThat(msg.children().size(), is(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>equalTo(3)));
170         assertThat(children.get(0), instanceOf(IntegerRedisMessage.class));
171         assertThat(((IntegerRedisMessage) children.get(0)).value(), is(1234L));
172         assertThat(children.get(1), instanceOf(SimpleStringRedisMessage.class));
173         assertThat(((SimpleStringRedisMessage) children.get(1)).content(), is("simple"));
174         assertThat(children.get(2), instanceOf(ErrorRedisMessage.class));
175         assertThat(((ErrorRedisMessage) children.get(2)).content(), is("error"));
176         ReferenceCountUtil.release(msg);
177     }
178     @Test
179     public void shouldDecodeNestedArray() throws Exception {
180         ByteBuf buf = Unpooled.buffer()</b></font>;
181         buf.writeBytes(byteBufOf("*2\r\n"));
182         buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
183         buf.writeBytes(byteBufOf("*2\r\n+Foo\r\n-Bar\r\n"));
184         assertTrue(channel.writeInbound(buf));
185         ArrayRedisMessage msg = channel.readInbound();
186         List&lt;RedisMessage&gt; children = msg.children();
187         assertThat(msg.children().size(), is(2));
188         ArrayRedisMessage intArray = (ArrayRedisMessage) children.get(0);
189         ArrayRedisMessage strArray = (ArrayRedisMessage) children.get(1);
190 <a name="1"></a>        assertThat(intArray.children().size(), is(3));
191         assertThat(((IntegerRedisMessage) intArray.children().get(0)).value(), is(1L));
192         assertThat(((IntegerRedisMessage) intArray.children().get(1)).value(), is(2L));
193         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(((IntegerRedisMessage) intArray.children().get(2)).value(), is(3L));
194         assertThat(strArray.children().size(), is(2));
195         assertThat(((SimpleStringRedisMessage) strArray.children().get(0)).content(), is("Foo"));
196         assertThat(((ErrorRedisMessage) strArray.children().get(1)).content(), is("Bar"));
197         ReferenceCountUtil.release(msg);
198     }
199     @Test
200     public void shouldErrorOnDoubleReleaseArrayReferenceCounted() {
201         ByteBuf buf = Unpooled.buffer</b></font>();
202         buf.writeBytes(byteBufOf("*2\r\n"));
203         buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
204         buf.writeBytes(byteBufOf("*2\r\n+Foo\r\n-Bar\r\n"));
205         assertTrue(channel.writeInbound(buf));
206         final ArrayRedisMessage msg = channel.readInbound();
207         ReferenceCountUtil.release(msg);
208 <a name="9"></a>        assertThrows(IllegalReferenceCountException.class, new Executable() {
209             @Override
210             public void execute() {
211                 <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ReferenceCountUtil.release(msg);
212             }
213         });
214     }
215     @Test
216     public void shouldErrorOnReleaseArrayChildReferenceCounted() {
217         ByteBuf buf = Unpooled.buffer()</b></font>;
218         buf.writeBytes(byteBufOf("*2\r\n"));
219         buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
220         buf.writeBytes(byteBufOf("$3\r\nFoo\r\n"));
221         assertTrue(channel.writeInbound(buf));
222         ArrayRedisMessage msg = channel.readInbound();
223         final List&lt;RedisMessage&gt; children = msg.children();
224         ReferenceCountUtil.release(msg);
225 <a name="11"></a>        assertThrows(IllegalReferenceCountException.class, new Executable() {
226             @Override
227             public void execute() {
228                 ReferenceCountUtil.release(<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>children.get(1));
229             }
230         });
231     }
232     @Test
233     public void shouldErrorOnReleasecontentOfArrayChildReferenceCounted() throws Exception {</b></font>
234         ByteBuf buf = Unpooled.buffer();
235         buf.writeBytes(byteBufOf("*2\r\n"));
236         buf.writeBytes(byteBufOf("$3\r\nFoo\r\n$3\r\nBar\r\n"));
237         assertTrue(channel.writeInbound(buf));
238         ArrayRedisMessage msg = channel.readInbound();
239         List&lt;RedisMessage&gt; children = msg.children();
240         final ByteBuf childBuf = ((FullBulkStringRedisMessage) children.get(0)).content();
241         ReferenceCountUtil.release(msg);
242 <a name="8"></a>        assertThrows(IllegalReferenceCountException.class, new Executable() {
243             @Override
244             public void execute() {
245                 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ReferenceCountUtil.release(childBuf);
246             }
247         });
248     }
249     @Test
250     public void testPredefinedMessagesNotEqual() {
251         assertNotEquals</b></font>(FullBulkStringRedisMessage.EMPTY_INSTANCE, FullBulkStringRedisMessage.NULL_INSTANCE);
252         assertNotEquals(FullBulkStringRedisMessage.NULL_INSTANCE, FullBulkStringRedisMessage.EMPTY_INSTANCE);
253     }
254 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>PendingWriteQueueTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright 2014 The Netty Project
3  *
4  * The Netty Project licenses this file to you under the Apache License,
5  * version 2.0 (the "License"); you may not use this file except in compliance
6  * with the License. You may obtain a copy of the License at:
7  *
8  *   https://www.apache.org/licenses/LICENSE-2.0
9  *
10  * Unless required by applicable law or agreed to in writing, software
11  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
12  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
13 <a name="2"></a> * License for the specific language governing permissions and limitations
14  * under the License.
15  */
16 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.channel;
17 import io.netty.buffer.ByteBuf;
18 import io.netty.buffer.Unpooled;
19 import io.netty.channel.embedded.EmbeddedChannel;
20 import io.netty.util.CharsetUtil;
21 import org.junit.jupiter.api.Test;
22 import java.util.ArrayList;
23 import java.util.Collections;
24 import java.util.List;
25 import java.util.concurrent.atomic.AtomicReference;
26 import static org.hamcrest.MatcherAssert.assertThat;
27 import static org.hamcrest.Matchers.*;
28 import static org.junit.jupiter.api.Assertions.assertEquals;
29 import static org.junit.jupiter.api.Assertions.assertFalse;
30 import static org.junit.jupiter.api.Assertions.assertNotNull;
31 import static org.junit.jupiter.api.Assertions.assertNull;
32 import static org.junit.jupiter.api.Assertions.assertSame;
33 import static org.junit.jupiter.api.Assertions.assertTrue;
34 import static org.junit.jupiter.api.Assertions.fail;
35 publi</b></font>c class PendingWriteQueueTest {
36     @Test
37     public void testRemoveAndWrite() {
38         assertWrite(new TestHandler() {
39             @Override
40             public void flush(ChannelHandlerContext ctx) throws Exception {
41                 assertFalse(ctx.channel().isWritable(), "Should not be writable anymore");
42                 ChannelFuture future = queue.removeAndWrite();
43                 future.addListener(new ChannelFutureListener() {
44                     @Override
45                     public void operationComplete(ChannelFuture future) {
46                         assertQueueEmpty(queue);
47                     }
48                 });
49 <a name="10"></a>                super.flush(ctx);
50             }
51         }, 1);
52     <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
53     @Test
54     public void testRemoveAndWriteAll() {
55         assertWrite(new TestHandler() {
56             @</b></font>Override
57             public void flush(ChannelHandlerContext ctx) throws Exception {
58                 assertFalse(ctx.channel().isWritable(), "Should not be writable anymore");
59                 ChannelFuture future = queue.removeAndWriteAll();
60                 future.addListener(new ChannelFutureListener() {
61                     @Override
62                     public void operationComplete(ChannelFuture future) {
63 <a name="8"></a>                        assertQueueEmpty(queue);
64                     }
65                 });
66                 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.flush(ctx);
67             }
68         }, 3);
69     }
70     @Test
71     public void testRemoveAndFail() {
72         assertWriteFails</b></font>(new TestHandler() {
73 <a name="11"></a>            @Override
74             public void flush(ChannelHandlerContext ctx) throws Exception {
75                 queue.removeAndFail(new TestException());
76                 <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.flush(ctx);
77             }
78         }, 1);
79     }
80     @Test
81     public void testRemoveAndFailAll() {</b></font>
82         assertWriteFails(new TestHandler() {
83 <a name="9"></a>            @Override
84             public void flush(ChannelHandlerContext ctx) throws Exception {
85                 queue.removeAndFailAll(new TestException());
86                 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.flush(ctx);
87             }
88         }, 3);
89     }
90     @Test
91     public void shouldFireChannelWritabilityChangedAfterRemoval() {
92         final AtomicReference&lt;ChannelHandlerContext&gt; ctxRef = new AtomicReference&lt;ChannelHandlerContext&gt;()</b></font>;
93         final AtomicReference&lt;PendingWriteQueue&gt; queueRef = new AtomicReference&lt;PendingWriteQueue&gt;();
94         final ByteBuf msg = Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII);
95         final EmbeddedChannel channel = new EmbeddedChannel(new ChannelInboundHandlerAdapter() {
96             @Override
97             public void handlerAdded(ChannelHandlerContext ctx) {
98                 ctxRef.set(ctx);
99                 queueRef.set(new PendingWriteQueue(ctx));
100             }
101             @Override
102             public void channelWritabilityChanged(ChannelHandlerContext ctx) {
103                 final PendingWriteQueue queue = queueRef.get();
104                 final ByteBuf msg = (ByteBuf) queue.current();
105                 if (msg == null) {
106                     return;
107                 }
108                 assertThat(msg.refCnt(), is(1));
109                 //
110                 queue.remove();
111                 assertThat(msg.refCnt(), is(0));
112 <a name="7"></a>            }
113         });
114         <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>channel.config().setWriteBufferLowWaterMark(1);
115         channel.config().setWriteBufferHighWaterMark(3);
116         final PendingWriteQueue queue = queueRef.get();
117         queue.add(msg, channel.newPromise());
118         channel.finish();
119         assertThat(msg.refCnt</b></font>(), is(0));
120     }
121     private static void assertWrite(ChannelHandler handler, int count) {
122         final ByteBuf buffer = Unpooled.copiedBuffer("Test", CharsetUtil.US_ASCII);
123         final EmbeddedChannel channel = new EmbeddedChannel(handler);
124         channel.config().setWriteBufferLowWaterMark(1);
125         channel.config().setWriteBufferHighWaterMark(3);
126         ByteBuf[] buffers = new ByteBuf[count];
127         for (int i = 0; i &lt; buffers.length; i++) {
128             buffers[i] = buffer.retainedDuplicate();
129         }
130         assertTrue(channel.writeOutbound(buffers));
131         assertTrue(channel.finish());
132         channel.closeFuture().syncUninterruptibly();
133         for (int i = 0; i &lt; buffers.length; i++) {
134             assertBuffer(channel, buffer);
135         }
136         buffer.release();
137         assertNull(channel.readOutbound());
138     }
139     private static void assertBuffer(EmbeddedChannel channel, ByteBuf buffer) {
140         ByteBuf written = channel.readOutbound();
141         assertEquals(buffer, written);
142 <a name="5"></a>        written.release();
143     }
144     private static void assertQueueEmpty(PendingWriteQueue queue) <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
145         assertTrue(queue.isEmpty());
146         assertEquals(0, queue.size());
147         assertEquals(0, queue.bytes());
148         assertNull(queue.current());
149         assertNull(queue.removeAndWrite());
150         assertNull(queue.removeAndWriteAll</b></font>());
151     }
152     private static void assertWriteFails(ChannelHandler handler, int count) {
153         final ByteBuf buffer = Unpooled.copiedBuffer("Test", CharsetUtil.US_ASCII);
154         final EmbeddedChannel channel = new EmbeddedChannel(handler);
155         ByteBuf[] buffers = new ByteBuf[count];
156         for (int i = 0; i &lt; buffers.length; i++) {
157             buffers[i] = buffer.retainedDuplicate();
158         }
159         try {
160             assertFalse(channel.writeOutbound(buffers));
161             fail();
162         } catch (Exception e) {
163             assertTrue(e instanceof TestException);
164         }
165         assertFalse(channel.finish());
166         channel.closeFuture().syncUninterruptibly();
167         buffer.release();
168         assertNull(channel.readOutbound());
169     }
170     private static EmbeddedChannel newChannel() {
171         return new EmbeddedChannel(new ChannelHandlerAdapter() { });
172     }
173     @Test
174     public void testRemoveAndFailAllReentrantFailAll() {
175         EmbeddedChannel channel = newChannel();
176         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
177         ChannelPromise promise = channel.newPromise();
178         promise.addListener(new ChannelFutureListener() {
179             @Override
180             public void operationComplete(ChannelFuture future) {
181                 queue.removeAndFailAll(new IllegalStateException());
182             }
183         });
184         queue.add(1L, promise);
185         ChannelPromise promise2 = channel.newPromise();
186         queue.add(2L, promise2);
187 <a name="6"></a>        queue.removeAndFailAll(new Exception());
188         assertTrue(promise.isDone());
189         assertFalse(promise.isSuccess());
190         <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(promise2.isDone());
191         assertFalse(promise2.isSuccess());
192         assertFalse(channel.finish());
193     }
194     @Test
195     public void testRemoveAndWriteAllReentrantWrite() {
196         EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {</b></font>
197             @Override
198             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
199                 ctx.writeAndFlush(msg, promise);
200             }
201         }, new ChannelOutboundHandlerAdapter());
202         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().lastContext());
203         ChannelPromise promise = channel.newPromise();
204         final ChannelPromise promise3 = channel.newPromise();
205         promise.addListener(new ChannelFutureListener() {
206             @Override
207             public void operationComplete(ChannelFuture future) {
208                 queue.add(3L, promise3);
209 <a name="0"></a>            }
210         });
211         queue.add(1L, promise);
212         ChannelPromise promise2 = <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>channel.newPromise();
213         queue.add(2L, promise2);
214         queue.removeAndWriteAll();
215         assertTrue(promise.isDone());
216         assertTrue(promise.isSuccess());
217         assertTrue(promise2.isDone());
218         assertTrue(promise2.isSuccess());
219         assertTrue(promise3.isDone());
220         assertTrue(promise3.isSuccess());
221         assertTrue(channel.finish());
222         assertEquals(1L, (Long) channel.readOutbound());
223         assertEquals(2L, (Long) channel.readOutbound());
224         assertEquals(3L, (Long) channel.readOutbound());
225     }
226     @Test
227     public void testRemoveAndWriteAllWithVoidPromise() {
228         EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {</b></font>
229             @Override
230             public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
231                 ctx.writeAndFlush(msg, promise);
232             }
233         }, new ChannelOutboundHandlerAdapter());
234 <a name="4"></a>
235         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().lastContext());
236         ChannelPromise promise = <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>channel.newPromise();
237         queue.add(1L, promise);
238         queue.add(2L, channel.voidPromise());
239         queue.removeAndWriteAll();
240         assertTrue(channel.finish());
241         assertTrue(promise.isDone());
242         assertTrue(promise.isSuccess());
243         assertEquals(1L, (Long) channel.readOutbound());
244         assertEquals(2L, (Long) channel.readOutbound());
245     }</b></font>
246     @Test
247     public void testRemoveAndFailAllReentrantWrite() {
248         final List&lt;Integer&gt; failOrder = Collections.synchronizedList(new ArrayList&lt;Integer&gt;());
249         EmbeddedChannel channel = newChannel();
250         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
251         ChannelPromise promise = channel.newPromise();
252         final ChannelPromise promise3 = channel.newPromise();
253         promise3.addListener(new ChannelFutureListener() {
254             @Override
255             public void operationComplete(ChannelFuture future) {
256                 failOrder.add(3);
257             }
258         });
259         promise.addListener(new ChannelFutureListener() {
260             @Override
261             public void operationComplete(ChannelFuture future) {
262                 failOrder.add(1);
263                 queue.add(3L, promise3);
264             }
265         });
266         queue.add(1L, promise);
267         ChannelPromise promise2 = channel.newPromise();
268         promise2.addListener(new ChannelFutureListener() {
269             @Override
270             public void operationComplete(ChannelFuture future) {
271                 failOrder.add(2);
272             }
273 <a name="1"></a>        });
274         queue.add(2L, promise2);
275         queue.removeAndFailAll(new Exception());
276         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(promise.isDone());
277         assertFalse(promise.isSuccess());
278         assertTrue(promise2.isDone());
279         assertFalse(promise2.isSuccess());
280         assertTrue(promise3.isDone());
281         assertFalse(promise3.isSuccess());
282         assertFalse(channel.finish());
283         assertEquals(1, (int) failOrder.get(0));
284         assertEquals(2, (int) failOrder.get(1));
285         assertEquals(3, (int) failOrder.get(2));
286     }
287     @Test
288     public void testRemoveAndWriteAllReentrance() {
289         EmbeddedChannel channel = newChannel</b></font>();
290         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
291         ChannelPromise promise = channel.newPromise();
292         promise.addListener(new ChannelFutureListener() {
293             @Override
294             public void operationComplete(ChannelFuture future) {
295                 queue.removeAndWriteAll();
296             }
297 <a name="3"></a>        });
298         queue.add(1L, promise);
299         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ChannelPromise promise2 = channel.newPromise();
300         queue.add(2L, promise2);
301         queue.removeAndWriteAll();
302         channel.flush();
303         assertTrue(promise.isSuccess());
304         assertTrue(promise2.isSuccess());
305         assertTrue(channel.finish());
306         assertEquals(1L, (Long) channel.readOutbound());
307         assertEquals(2L, (Long) channel.readOutbound());
308         assertNull(channel.readOutbound());
309         assertNull(channel.readInbound</b></font>());
310     }
311     @Test
312     public void testCloseChannelOnCreation() {
313         EmbeddedChannel channel = newChannel();
314         ChannelHandlerContext context = channel.pipeline().firstContext();
315         channel.close().syncUninterruptibly();
316         final PendingWriteQueue queue = new PendingWriteQueue(context);
317         IllegalStateException ex = new IllegalStateException();
318         ChannelPromise promise = channel.newPromise();
319         queue.add(1L, promise);
320         queue.removeAndFailAll(ex);
321         assertSame(ex, promise.cause());
322     }
323     private static class TestHandler extends ChannelDuplexHandler {
324         protected PendingWriteQueue queue;
325         private int expectedSize;
326 <a name="13"></a>
327         @Override
328         public void channelActive(ChannelHandlerContext ctx) throws Exception {
329             <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.channelActive(ctx);
330             assertQueueEmpty(queue);
331             assertTrue(ctx.channel().isWritable(), "Should be writable");
332         }
333 <a name="12"></a>        @</b></font>Override
334         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
335             queue.add(msg, promise);
336             assertFalse(<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>queue.isEmpty());
337             assertEquals(++expectedSize, queue.size());
338             assertNotNull(queue.current());
339         }
340         @</b></font>Override
341         public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
342             queue = new PendingWriteQueue(ctx);
343         }
344     }
345     private static final class TestException extends Exception {
346         private static final long serialVersionUID = -9018570103039458401L;
347     }
348 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
