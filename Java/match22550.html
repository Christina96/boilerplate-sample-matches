<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for RedisDecoderTest.java & PendingWriteQueueTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for RedisDecoderTest.java & PendingWriteQueueTest.java
      </h3>
      <h1 align="center">
        35.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>RedisDecoderTest.java (38.175045%)<TH>PendingWriteQueueTest.java (32.9582%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#0',2,'match22550-1.html#0',3)" NAME="0">(236-250)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#0',2,'match22550-1.html#0',3)" NAME="0">(259-277)</A><TD ALIGN=center><FONT COLOR="#ff0000">29</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#1',2,'match22550-1.html#1',3)" NAME="1">(267-278)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#1',2,'match22550-1.html#1',3)" NAME="1">(331-345)</A><TD ALIGN=center><FONT COLOR="#ed0000">27</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#2',2,'match22550-1.html#2',3)" NAME="2">(17-43)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#2',2,'match22550-1.html#2',3)" NAME="2">(16-41)</A><TD ALIGN=center><FONT COLOR="#af0000">20</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#3',2,'match22550-1.html#3',3)" NAME="3">(172-178)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#3',2,'match22550-1.html#3',3)" NAME="3">(357-368)</A><TD ALIGN=center><FONT COLOR="#a70000">19</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#4',2,'match22550-1.html#4',3)" NAME="4">(79-86)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#4',2,'match22550-1.html#4',3)" NAME="4">(287-297)</A><TD ALIGN=center><FONT COLOR="#950000">17</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#5',2,'match22550-1.html#5',3)" NAME="5">(108-112)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#5',2,'match22550-1.html#5',3)" NAME="5">(180-186)</A><TD ALIGN=center><FONT COLOR="#720000">13</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#6',2,'match22550-1.html#6',3)" NAME="6">(180-189)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#6',2,'match22550-1.html#6',3)" NAME="6">(233-240)</A><TD ALIGN=center><FONT COLOR="#690000">12</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#7',2,'match22550-1.html#7',3)" NAME="7">(193-200)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#7',2,'match22550-1.html#7',3)" NAME="7">(140-150)</A><TD ALIGN=center><FONT COLOR="#600000">11</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#8',2,'match22550-1.html#8',3)" NAME="8">(330-339)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#8',2,'match22550-1.html#8',3)" NAME="8">(76-83)</A><TD ALIGN=center><FONT COLOR="#570000">10</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#9',2,'match22550-1.html#9',3)" NAME="9">(290-297)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#9',2,'match22550-1.html#9',3)" NAME="9">(99-106)</A><TD ALIGN=center><FONT COLOR="#570000">10</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#10',2,'match22550-1.html#10',3)" NAME="10">(72-77)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#10',2,'match22550-1.html#10',3)" NAME="10">(60-65)</A><TD ALIGN=center><FONT COLOR="#570000">10</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#11',2,'match22550-1.html#11',3)" NAME="11">(310-316)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#11',2,'match22550-1.html#11',3)" NAME="11">(88-94)</A><TD ALIGN=center><FONT COLOR="#4f0000">9</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#12',2,'match22550-1.html#12',3)" NAME="12">(114-121)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#12',2,'match22550-1.html#12',3)" NAME="12">(401-406)</A><TD ALIGN=center><FONT COLOR="#4f0000">9</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match22550-0.html#13',2,'match22550-1.html#13',3)" NAME="13">(100-107)<TD><A HREF="javascript:ZweiFrames('match22550-0.html#13',2,'match22550-1.html#13',3)" NAME="13">(393-398)</A><TD ALIGN=center><FONT COLOR="#4f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RedisDecoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2016 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
<A NAME="2"></A> * under the License.
 */

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match22550-1.html#2',3,'match22550-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>package io.netty.handler.codec.redis;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.handler.codec.DecoderException;
import io.netty.util.IllegalReferenceCountException;
import io.netty.util.ReferenceCountUtil;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import java.util.List;

import static io.netty.handler.codec.redis.RedisCodecTestUtil.*;
import static org.hamcrest.CoreMatchers.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Verifies the correct functionality of the {@link RedisDecoder} and {@link RedisArrayAggregator}.
 */
publi</B></FONT>c class RedisDecoderTest {

    private EmbeddedChannel channel;

    @BeforeEach
    public void setup() throws Exception {
        channel = newChannel(false);
    }

    private static EmbeddedChannel newChannel(boolean decodeInlineCommands) {
        return new EmbeddedChannel(
                new RedisDecoder(decodeInlineCommands),
                new RedisBulkStringAggregator(),
                new RedisArrayAggregator());
    }

    @AfterEach
    public void teardown() throws Exception {
        assertFalse(channel.finish());
    }

    @Test
    public void splitEOLDoesNotInfiniteLoop() throws Exception {
        assertFalse(channel.writeInbound(byteBufOf(&quot;$6\r\nfoobar\r&quot;)));
        assertTrue(channel.writeInbound(byteBufOf(&quot;\n&quot;)));

<A NAME="10"></A>        RedisMessage msg = channel.readInbound();
        assertTrue(msg instanceof FullBulkStringRedisMessage);
        ReferenceCountUtil.release(msg);
    <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match22550-1.html#10',3,'match22550-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

    @Test
    public void shouldNotDecodeInlineCommandByDefault() {
<A NAME="4"></A>        assertThrows(DecoderException.class, new Executable() {
            @</B></FONT>Override
            public void execute() {
                assertFalse(<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match22550-1.html#4',3,'match22550-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.writeInbound(byteBufOf(&quot;P&quot;)));
                assertFalse(channel.writeInbound(byteBufOf(&quot;I&quot;)));
                assertFalse(channel.writeInbound(byteBufOf(&quot;N&quot;)));
                assertFalse(channel.writeInbound(byteBufOf(&quot;G&quot;)));
                assertTrue(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));

                channel.readInbound();
            }</B></FONT>
        });
    }

    @Test
    public void shouldDecodeInlineCommand() {
        channel = newChannel(true);

        assertFalse(channel.writeInbound(byteBufOf(&quot;P&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;I&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;N&quot;)));
<A NAME="13"></A>        assertFalse(channel.writeInbound(byteBufOf(&quot;G&quot;)));
        assertTrue(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));

        InlineCommandRedisMessage msg = <FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match22550-1.html#13',3,'match22550-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();

        assertThat(msg.content(), is(&quot;PING&quot;));

        ReferenceCountUtil.release(msg);
<A NAME="5"></A>    }

    @</B></FONT>Test
    public void shouldDecodeSimpleString() <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match22550-1.html#5',3,'match22550-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
        assertFalse(channel.writeInbound(byteBufOf(&quot;+&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;O&quot;)));
<A NAME="12"></A>        assertFalse(channel.writeInbound(byteBufOf(&quot;K&quot;)));
        assertTrue(channel.writeInbound(byteBufOf</B></FONT>(&quot;\r\n&quot;)));

        SimpleStringRedisMessage msg = <FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match22550-1.html#12',3,'match22550-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();

        assertThat(msg.content(), is(&quot;OK&quot;));

        ReferenceCountUtil.release(msg);
    }

    @</B></FONT>Test
    public void shouldDecodeTwoSimpleStrings() {
        assertFalse(channel.writeInbound(byteBufOf(&quot;+&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;O&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;K&quot;)));
        assertTrue(channel.writeInbound(byteBufOf(&quot;\r\n+SEC&quot;)));
        assertTrue(channel.writeInbound(byteBufOf(&quot;OND\r\n&quot;)));

        SimpleStringRedisMessage msg1 = channel.readInbound();
        assertThat(msg1.content(), is(&quot;OK&quot;));
        ReferenceCountUtil.release(msg1);

        SimpleStringRedisMessage msg2 = channel.readInbound();
        assertThat(msg2.content(), is(&quot;SECOND&quot;));
        ReferenceCountUtil.release(msg2);
    }

    @Test
    public void shouldDecodeError() {
        String content = &quot;ERROR sample message&quot;;
        assertFalse(channel.writeInbound(byteBufOf(&quot;-&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(content)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;\r&quot;)));
        assertTrue(channel.writeInbound(byteBufOf(&quot;\n&quot;)));

        ErrorRedisMessage msg = channel.readInbound();

        assertThat(msg.content(), is(content));

        ReferenceCountUtil.release(msg);
    }

    @Test
    public void shouldDecodeInteger() {
        long value = 1234L;
        byte[] content = bytesOf(value);
        assertFalse(channel.writeInbound(byteBufOf(&quot;:&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(content)));
        assertTrue(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));

        IntegerRedisMessage msg = channel.readInbound();

        assertThat(msg.value(), is(value));

        ReferenceCountUtil.release(msg);
    }

    @Test
<A NAME="3"></A>    public void shouldDecodeBulkString() {
        String buf1 = &quot;bulk\nst&quot;;
        String buf2 = &quot;ring\ntest\n1234&quot;;
        <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match22550-1.html#3',3,'match22550-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>byte[] content = bytesOf(buf1 + buf2);
        assertFalse(channel.writeInbound(byteBufOf(&quot;$&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(content.length))));
        assertFalse(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(buf1)));
<A NAME="6"></A>        assertFalse(channel.writeInbound(byteBufOf(buf2)));
        assertTrue</B></FONT>(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));

        FullBulkStringRedisMessage msg = <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match22550-1.html#6',3,'match22550-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>channel.readInbound();

        assertThat(bytesOf(msg.content()), is(content));

        ReferenceCountUtil.release(msg);
    }

    @Test
    public void shouldDecodeEmptyBulkString() {
        byte[] content = bytesOf(&quot;&quot;)</B></FONT>;
<A NAME="7"></A>        assertFalse(channel.writeInbound(byteBufOf(&quot;$&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(content.length))));
        assertFalse(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));
        assertFalse(channel.writeInbound(<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match22550-1.html#7',3,'match22550-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>byteBufOf(content)));
        assertTrue(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));

        FullBulkStringRedisMessage msg = channel.readInbound();

        assertThat(bytesOf(msg.content()), is(content));

        ReferenceCountUtil.release</B></FONT>(msg);
    }

    @Test
    public void shouldDecodeNullBulkString() {
        assertFalse(channel.writeInbound(byteBufOf(&quot;$&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(-1))));
        assertTrue(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));

        assertTrue(channel.writeInbound(byteBufOf(&quot;$&quot;)));
        assertTrue(channel.writeInbound(byteBufOf(Integer.toString(-1))));
        assertTrue(channel.writeInbound(byteBufOf(&quot;\r\n&quot;)));

        FullBulkStringRedisMessage msg1 = channel.readInbound();
        assertThat(msg1.isNull(), is(true));
        ReferenceCountUtil.release(msg1);

        FullBulkStringRedisMessage msg2 = channel.readInbound();
        assertThat(msg2.isNull(), is(true));
        ReferenceCountUtil.release(msg2);

        FullBulkStringRedisMessage msg3 = channel.readInbound();
        assertThat(msg3, is(nullValue()));
    }

    @Test
    public void shouldDecodeSimpleArray() throws Exception {
        assertFalse(channel.writeInbound(byteBufOf(&quot;*3\r\n&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;:1234\r\n&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;+sim&quot;)));
        assertFalse(channel.writeInbound(byteBufOf(&quot;ple\r\n-err&quot;)));
        assertTrue(channel.writeInbound(byteBufOf(&quot;or\r\n&quot;)));

<A NAME="0"></A>        ArrayRedisMessage msg = channel.readInbound();
        List&lt;RedisMessage&gt; children = msg.children();

        assertThat(msg.children().size(), is(<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match22550-1.html#0',3,'match22550-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>equalTo(3)));

        assertThat(children.get(0), instanceOf(IntegerRedisMessage.class));
        assertThat(((IntegerRedisMessage) children.get(0)).value(), is(1234L));
        assertThat(children.get(1), instanceOf(SimpleStringRedisMessage.class));
        assertThat(((SimpleStringRedisMessage) children.get(1)).content(), is(&quot;simple&quot;));
        assertThat(children.get(2), instanceOf(ErrorRedisMessage.class));
        assertThat(((ErrorRedisMessage) children.get(2)).content(), is(&quot;error&quot;));

        ReferenceCountUtil.release(msg);
    }

    @Test
    public void shouldDecodeNestedArray() throws Exception {
        ByteBuf buf = Unpooled.buffer()</B></FONT>;
        buf.writeBytes(byteBufOf(&quot;*2\r\n&quot;));
        buf.writeBytes(byteBufOf(&quot;*3\r\n:1\r\n:2\r\n:3\r\n&quot;));
        buf.writeBytes(byteBufOf(&quot;*2\r\n+Foo\r\n-Bar\r\n&quot;));
        assertTrue(channel.writeInbound(buf));

        ArrayRedisMessage msg = channel.readInbound();
        List&lt;RedisMessage&gt; children = msg.children();

        assertThat(msg.children().size(), is(2));

        ArrayRedisMessage intArray = (ArrayRedisMessage) children.get(0);
        ArrayRedisMessage strArray = (ArrayRedisMessage) children.get(1);

<A NAME="1"></A>        assertThat(intArray.children().size(), is(3));
        assertThat(((IntegerRedisMessage) intArray.children().get(0)).value(), is(1L));
        assertThat(((IntegerRedisMessage) intArray.children().get(1)).value(), is(2L));
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match22550-1.html#1',3,'match22550-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>assertThat(((IntegerRedisMessage) intArray.children().get(2)).value(), is(3L));

        assertThat(strArray.children().size(), is(2));
        assertThat(((SimpleStringRedisMessage) strArray.children().get(0)).content(), is(&quot;Foo&quot;));
        assertThat(((ErrorRedisMessage) strArray.children().get(1)).content(), is(&quot;Bar&quot;));

        ReferenceCountUtil.release(msg);
    }

    @Test
    public void shouldErrorOnDoubleReleaseArrayReferenceCounted() {
        ByteBuf buf = Unpooled.buffer</B></FONT>();
        buf.writeBytes(byteBufOf(&quot;*2\r\n&quot;));
        buf.writeBytes(byteBufOf(&quot;*3\r\n:1\r\n:2\r\n:3\r\n&quot;));
        buf.writeBytes(byteBufOf(&quot;*2\r\n+Foo\r\n-Bar\r\n&quot;));
        assertTrue(channel.writeInbound(buf));

        final ArrayRedisMessage msg = channel.readInbound();

        ReferenceCountUtil.release(msg);
<A NAME="9"></A>        assertThrows(IllegalReferenceCountException.class, new Executable() {
            @Override
            public void execute() {
                <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match22550-1.html#9',3,'match22550-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ReferenceCountUtil.release(msg);
            }
        });
    }

    @Test
    public void shouldErrorOnReleaseArrayChildReferenceCounted() {
        ByteBuf buf = Unpooled.buffer()</B></FONT>;
        buf.writeBytes(byteBufOf(&quot;*2\r\n&quot;));
        buf.writeBytes(byteBufOf(&quot;*3\r\n:1\r\n:2\r\n:3\r\n&quot;));
        buf.writeBytes(byteBufOf(&quot;$3\r\nFoo\r\n&quot;));
        assertTrue(channel.writeInbound(buf));

        ArrayRedisMessage msg = channel.readInbound();

        final List&lt;RedisMessage&gt; children = msg.children();
        ReferenceCountUtil.release(msg);
<A NAME="11"></A>        assertThrows(IllegalReferenceCountException.class, new Executable() {
            @Override
            public void execute() {
                ReferenceCountUtil.release(<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match22550-1.html#11',3,'match22550-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>children.get(1));
            }
        });
    }

    @Test
    public void shouldErrorOnReleasecontentOfArrayChildReferenceCounted() throws Exception {</B></FONT>
        ByteBuf buf = Unpooled.buffer();
        buf.writeBytes(byteBufOf(&quot;*2\r\n&quot;));
        buf.writeBytes(byteBufOf(&quot;$3\r\nFoo\r\n$3\r\nBar\r\n&quot;));
        assertTrue(channel.writeInbound(buf));

        ArrayRedisMessage msg = channel.readInbound();

        List&lt;RedisMessage&gt; children = msg.children();
        final ByteBuf childBuf = ((FullBulkStringRedisMessage) children.get(0)).content();
        ReferenceCountUtil.release(msg);
<A NAME="8"></A>        assertThrows(IllegalReferenceCountException.class, new Executable() {
            @Override
            public void execute() {
                <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match22550-1.html#8',3,'match22550-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>ReferenceCountUtil.release(childBuf);
            }
        });
    }

    @Test
    public void testPredefinedMessagesNotEqual() {
        // both EMPTY_INSTANCE and NULL_INSTANCE have EMPTY_BUFFER as their 'data',
        // however we need to check that they are not equal between themselves.
        assertNotEquals</B></FONT>(FullBulkStringRedisMessage.EMPTY_INSTANCE, FullBulkStringRedisMessage.NULL_INSTANCE);
        assertNotEquals(FullBulkStringRedisMessage.NULL_INSTANCE, FullBulkStringRedisMessage.EMPTY_INSTANCE);
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>PendingWriteQueueTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2014 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
<A NAME="2"></A> * License for the specific language governing permissions and limitations
 * under the License.
 */
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#2',2,'match22550-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package io.netty.channel;


import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.util.CharsetUtil;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

publi</B></FONT>c class PendingWriteQueueTest {

    @Test
    public void testRemoveAndWrite() {
        assertWrite(new TestHandler() {
            @Override
            public void flush(ChannelHandlerContext ctx) throws Exception {
                assertFalse(ctx.channel().isWritable(), &quot;Should not be writable anymore&quot;);

                ChannelFuture future = queue.removeAndWrite();
                future.addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture future) {
                        assertQueueEmpty(queue);
                    }
                });
<A NAME="10"></A>                super.flush(ctx);
            }
        }, 1);
    <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#10',2,'match22550-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    @Test
    public void testRemoveAndWriteAll() {
        assertWrite(new TestHandler() {
            @</B></FONT>Override
            public void flush(ChannelHandlerContext ctx) throws Exception {
                assertFalse(ctx.channel().isWritable(), &quot;Should not be writable anymore&quot;);

                ChannelFuture future = queue.removeAndWriteAll();
                future.addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture future) {
<A NAME="8"></A>                        assertQueueEmpty(queue);
                    }
                });
                <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#8',2,'match22550-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super.flush(ctx);
            }
        }, 3);
    }

    @Test
    public void testRemoveAndFail() {
        assertWriteFails</B></FONT>(new TestHandler() {

<A NAME="11"></A>            @Override
            public void flush(ChannelHandlerContext ctx) throws Exception {
                queue.removeAndFail(new TestException());
                <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#11',2,'match22550-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super.flush(ctx);
            }
        }, 1);
    }

    @Test
    public void testRemoveAndFailAll() {</B></FONT>
        assertWriteFails(new TestHandler() {
<A NAME="9"></A>            @Override
            public void flush(ChannelHandlerContext ctx) throws Exception {
                queue.removeAndFailAll(new TestException());
                <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#9',2,'match22550-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super.flush(ctx);
            }
        }, 3);
    }

    @Test
    public void shouldFireChannelWritabilityChangedAfterRemoval() {
        final AtomicReference&lt;ChannelHandlerContext&gt; ctxRef = new AtomicReference&lt;ChannelHandlerContext&gt;()</B></FONT>;
        final AtomicReference&lt;PendingWriteQueue&gt; queueRef = new AtomicReference&lt;PendingWriteQueue&gt;();
        final ByteBuf msg = Unpooled.copiedBuffer(&quot;test&quot;, CharsetUtil.US_ASCII);

        final EmbeddedChannel channel = new EmbeddedChannel(new ChannelInboundHandlerAdapter() {
            @Override
            public void handlerAdded(ChannelHandlerContext ctx) {
                ctxRef.set(ctx);
                queueRef.set(new PendingWriteQueue(ctx));
            }

            @Override
            public void channelWritabilityChanged(ChannelHandlerContext ctx) {
                final PendingWriteQueue queue = queueRef.get();

                final ByteBuf msg = (ByteBuf) queue.current();
                if (msg == null) {
                    return;
                }

                assertThat(msg.refCnt(), is(1));

                // This call will trigger another channelWritabilityChanged() event because the number of
                // pending bytes will go below the low watermark.
                //
                // If PendingWriteQueue.remove() did not remove the current entry before triggering
                // channelWritabilityChanged() event, we will end up with attempting to remove the same
                // element twice, resulting in the double release.
                queue.remove();

                assertThat(msg.refCnt(), is(0));
<A NAME="7"></A>            }
        });

        <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#7',2,'match22550-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>channel.config().setWriteBufferLowWaterMark(1);
        channel.config().setWriteBufferHighWaterMark(3);

        final PendingWriteQueue queue = queueRef.get();

        // Trigger channelWritabilityChanged() by adding a message that's larger than the high watermark.
        queue.add(msg, channel.newPromise());

        channel.finish();

        assertThat(msg.refCnt</B></FONT>(), is(0));
    }

    private static void assertWrite(ChannelHandler handler, int count) {
        final ByteBuf buffer = Unpooled.copiedBuffer(&quot;Test&quot;, CharsetUtil.US_ASCII);
        final EmbeddedChannel channel = new EmbeddedChannel(handler);
        channel.config().setWriteBufferLowWaterMark(1);
        channel.config().setWriteBufferHighWaterMark(3);

        ByteBuf[] buffers = new ByteBuf[count];
        for (int i = 0; i &lt; buffers.length; i++) {
            buffers[i] = buffer.retainedDuplicate();
        }
        assertTrue(channel.writeOutbound(buffers));
        assertTrue(channel.finish());
        channel.closeFuture().syncUninterruptibly();

        for (int i = 0; i &lt; buffers.length; i++) {
            assertBuffer(channel, buffer);
        }
        buffer.release();
        assertNull(channel.readOutbound());
    }

    private static void assertBuffer(EmbeddedChannel channel, ByteBuf buffer) {
        ByteBuf written = channel.readOutbound();
        assertEquals(buffer, written);
<A NAME="5"></A>        written.release();
    }

    private static void assertQueueEmpty(PendingWriteQueue queue) <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#5',2,'match22550-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        assertTrue(queue.isEmpty());
        assertEquals(0, queue.size());
        assertEquals(0, queue.bytes());
        assertNull(queue.current());
        assertNull(queue.removeAndWrite());
        assertNull(queue.removeAndWriteAll</B></FONT>());
    }

    private static void assertWriteFails(ChannelHandler handler, int count) {
        final ByteBuf buffer = Unpooled.copiedBuffer(&quot;Test&quot;, CharsetUtil.US_ASCII);
        final EmbeddedChannel channel = new EmbeddedChannel(handler);
        ByteBuf[] buffers = new ByteBuf[count];
        for (int i = 0; i &lt; buffers.length; i++) {
            buffers[i] = buffer.retainedDuplicate();
        }
        try {
            assertFalse(channel.writeOutbound(buffers));
            fail();
        } catch (Exception e) {
            assertTrue(e instanceof TestException);
        }
        assertFalse(channel.finish());
        channel.closeFuture().syncUninterruptibly();

        buffer.release();
        assertNull(channel.readOutbound());
    }

    private static EmbeddedChannel newChannel() {
        // Add a handler so we can access a ChannelHandlerContext via the ChannelPipeline.
        return new EmbeddedChannel(new ChannelHandlerAdapter() { });
    }

    @Test
    public void testRemoveAndFailAllReentrantFailAll() {
        EmbeddedChannel channel = newChannel();
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());

        ChannelPromise promise = channel.newPromise();
        promise.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                queue.removeAndFailAll(new IllegalStateException());
            }
        });
        queue.add(1L, promise);

        ChannelPromise promise2 = channel.newPromise();
        queue.add(2L, promise2);
<A NAME="6"></A>        queue.removeAndFailAll(new Exception());
        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#6',2,'match22550-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertTrue(promise2.isDone());
        assertFalse(promise2.isSuccess());
        assertFalse(channel.finish());
    }

    @Test
    public void testRemoveAndWriteAllReentrantWrite() {
        EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {</B></FONT>
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                // Convert to writeAndFlush(...) so the promise will be notified by the transport.
                ctx.writeAndFlush(msg, promise);
            }
        }, new ChannelOutboundHandlerAdapter());

        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().lastContext());

        ChannelPromise promise = channel.newPromise();
        final ChannelPromise promise3 = channel.newPromise();
        promise.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                queue.add(3L, promise3);
<A NAME="0"></A>            }
        });
        queue.add(1L, promise);
        ChannelPromise promise2 = <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#0',2,'match22550-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>channel.newPromise();
        queue.add(2L, promise2);
        queue.removeAndWriteAll();

        assertTrue(promise.isDone());
        assertTrue(promise.isSuccess());
        assertTrue(promise2.isDone());
        assertTrue(promise2.isSuccess());
        assertTrue(promise3.isDone());
        assertTrue(promise3.isSuccess());
        assertTrue(channel.finish());
        assertEquals(1L, (Long) channel.readOutbound());
        assertEquals(2L, (Long) channel.readOutbound());
        assertEquals(3L, (Long) channel.readOutbound());
    }

    @Test
    public void testRemoveAndWriteAllWithVoidPromise() {
        EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {</B></FONT>
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                // Convert to writeAndFlush(...) so the promise will be notified by the transport.
                ctx.writeAndFlush(msg, promise);
            }
        }, new ChannelOutboundHandlerAdapter());
<A NAME="4"></A>
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().lastContext());

        ChannelPromise promise = <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#4',2,'match22550-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>channel.newPromise();
        queue.add(1L, promise);
        queue.add(2L, channel.voidPromise());
        queue.removeAndWriteAll();

        assertTrue(channel.finish());
        assertTrue(promise.isDone());
        assertTrue(promise.isSuccess());
        assertEquals(1L, (Long) channel.readOutbound());
        assertEquals(2L, (Long) channel.readOutbound());
    }</B></FONT>

    @Test
    public void testRemoveAndFailAllReentrantWrite() {
        final List&lt;Integer&gt; failOrder = Collections.synchronizedList(new ArrayList&lt;Integer&gt;());
        EmbeddedChannel channel = newChannel();
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());

        ChannelPromise promise = channel.newPromise();
        final ChannelPromise promise3 = channel.newPromise();
        promise3.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                failOrder.add(3);
            }
        });
        promise.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                failOrder.add(1);
                queue.add(3L, promise3);
            }
        });
        queue.add(1L, promise);

        ChannelPromise promise2 = channel.newPromise();
        promise2.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                failOrder.add(2);
            }
<A NAME="1"></A>        });
        queue.add(2L, promise2);
        queue.removeAndFailAll(new Exception());
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#1',2,'match22550-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertTrue(promise2.isDone());
        assertFalse(promise2.isSuccess());
        assertTrue(promise3.isDone());
        assertFalse(promise3.isSuccess());
        assertFalse(channel.finish());
        assertEquals(1, (int) failOrder.get(0));
        assertEquals(2, (int) failOrder.get(1));
        assertEquals(3, (int) failOrder.get(2));
    }

    @Test
    public void testRemoveAndWriteAllReentrance() {
        EmbeddedChannel channel = newChannel</B></FONT>();
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());

        ChannelPromise promise = channel.newPromise();
        promise.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                queue.removeAndWriteAll();
            }
<A NAME="3"></A>        });
        queue.add(1L, promise);

        <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#3',2,'match22550-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ChannelPromise promise2 = channel.newPromise();
        queue.add(2L, promise2);
        queue.removeAndWriteAll();
        channel.flush();
        assertTrue(promise.isSuccess());
        assertTrue(promise2.isSuccess());
        assertTrue(channel.finish());

        assertEquals(1L, (Long) channel.readOutbound());
        assertEquals(2L, (Long) channel.readOutbound());
        assertNull(channel.readOutbound());
        assertNull(channel.readInbound</B></FONT>());
    }

    // See https://github.com/netty/netty/issues/3967
    @Test
    public void testCloseChannelOnCreation() {
        EmbeddedChannel channel = newChannel();
        ChannelHandlerContext context = channel.pipeline().firstContext();
        channel.close().syncUninterruptibly();

        final PendingWriteQueue queue = new PendingWriteQueue(context);

        IllegalStateException ex = new IllegalStateException();
        ChannelPromise promise = channel.newPromise();
        queue.add(1L, promise);
        queue.removeAndFailAll(ex);
        assertSame(ex, promise.cause());
    }

    private static class TestHandler extends ChannelDuplexHandler {
        protected PendingWriteQueue queue;
        private int expectedSize;
<A NAME="13"></A>
        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
            <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#13',2,'match22550-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super.channelActive(ctx);
            assertQueueEmpty(queue);
            assertTrue(ctx.channel().isWritable(), &quot;Should be writable&quot;);
        }

<A NAME="12"></A>        @</B></FONT>Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            queue.add(msg, promise);
            assertFalse(<FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22550-0.html#12',2,'match22550-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>queue.isEmpty());
            assertEquals(++expectedSize, queue.size());
            assertNotNull(queue.current());
        }

        @</B></FONT>Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            queue = new PendingWriteQueue(ctx);
        }
    }

    private static final class TestException extends Exception {
        private static final long serialVersionUID = -9018570103039458401L;
    }
}
</PRE>
</div>
  </div>
</body>
</html>
