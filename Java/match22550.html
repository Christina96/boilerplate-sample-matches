<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for RedisDecoderTest.java &amp; PendingWriteQueueTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for RedisDecoderTest.java &amp; PendingWriteQueueTest.java
      </h3>
<h1 align="center">
        35.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>RedisDecoderTest.java (38.175045%)<th>PendingWriteQueueTest.java (32.9582%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(236-250)<td><a href="#" name="0">(259-277)</a><td align="center"><font color="#ff0000">29</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(267-278)<td><a href="#" name="1">(331-345)</a><td align="center"><font color="#ed0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(17-43)<td><a href="#" name="2">(16-41)</a><td align="center"><font color="#af0000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(172-178)<td><a href="#" name="3">(357-368)</a><td align="center"><font color="#a70000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(79-86)<td><a href="#" name="4">(287-297)</a><td align="center"><font color="#950000">17</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(108-112)<td><a href="#" name="5">(180-186)</a><td align="center"><font color="#720000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(180-189)<td><a href="#" name="6">(233-240)</a><td align="center"><font color="#690000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(193-200)<td><a href="#" name="7">(140-150)</a><td align="center"><font color="#600000">11</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(330-339)<td><a href="#" name="8">(76-83)</a><td align="center"><font color="#570000">10</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(290-297)<td><a href="#" name="9">(99-106)</a><td align="center"><font color="#570000">10</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(72-77)<td><a href="#" name="10">(60-65)</a><td align="center"><font color="#570000">10</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(310-316)<td><a href="#" name="11">(88-94)</a><td align="center"><font color="#4f0000">9</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(114-121)<td><a href="#" name="12">(401-406)</a><td align="center"><font color="#4f0000">9</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(100-107)<td><a href="#" name="13">(393-398)</a><td align="center"><font color="#4f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>RedisDecoderTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>package io.netty.handler.codec.redis;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.handler.codec.DecoderException;
import io.netty.util.IllegalReferenceCountException;
import io.netty.util.ReferenceCountUtil;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;
import java.util.List;
import static io.netty.handler.codec.redis.RedisCodecTestUtil.*;
import static org.hamcrest.CoreMatchers.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
publi</b></font>c class RedisDecoderTest {
    private EmbeddedChannel channel;
    @BeforeEach
    public void setup() throws Exception {
        channel = newChannel(false);
    }
    private static EmbeddedChannel newChannel(boolean decodeInlineCommands) {
        return new EmbeddedChannel(
                new RedisDecoder(decodeInlineCommands),
                new RedisBulkStringAggregator(),
                new RedisArrayAggregator());
    }
    @AfterEach
    public void teardown() throws Exception {
        assertFalse(channel.finish());
    }
    @Test
    public void splitEOLDoesNotInfiniteLoop() throws Exception {
        assertFalse(channel.writeInbound(byteBufOf("$6\r\nfoobar\r")));
        assertTrue(channel.writeInbound(byteBufOf("\n")));
<a name="10"></a>        RedisMessage msg = channel.readInbound();
        assertTrue(msg instanceof FullBulkStringRedisMessage);
        ReferenceCountUtil.release(msg);
    <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
    @Test
    public void shouldNotDecodeInlineCommandByDefault() {
<a name="4"></a>        assertThrows(DecoderException.class, new Executable() {
            @</b></font>Override
            public void execute() {
                assertFalse(<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.writeInbound(byteBufOf("P")));
                assertFalse(channel.writeInbound(byteBufOf("I")));
                assertFalse(channel.writeInbound(byteBufOf("N")));
                assertFalse(channel.writeInbound(byteBufOf("G")));
                assertTrue(channel.writeInbound(byteBufOf("\r\n")));
                channel.readInbound();
            }</b></font>
        });
    }
    @Test
    public void shouldDecodeInlineCommand() {
        channel = newChannel(true);
        assertFalse(channel.writeInbound(byteBufOf("P")));
        assertFalse(channel.writeInbound(byteBufOf("I")));
        assertFalse(channel.writeInbound(byteBufOf("N")));
<a name="13"></a>        assertFalse(channel.writeInbound(byteBufOf("G")));
        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
        InlineCommandRedisMessage msg = <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.readInbound();
        assertThat(msg.content(), is("PING"));
        ReferenceCountUtil.release(msg);
<a name="5"></a>    }
    @</b></font>Test
    public void shouldDecodeSimpleString() <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
        assertFalse(channel.writeInbound(byteBufOf("+")));
        assertFalse(channel.writeInbound(byteBufOf("O")));
<a name="12"></a>        assertFalse(channel.writeInbound(byteBufOf("K")));
        assertTrue(channel.writeInbound(byteBufOf</b></font>("\r\n")));
        SimpleStringRedisMessage msg = <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.readInbound();
        assertThat(msg.content(), is("OK"));
        ReferenceCountUtil.release(msg);
    }
    @</b></font>Test
    public void shouldDecodeTwoSimpleStrings() {
        assertFalse(channel.writeInbound(byteBufOf("+")));
        assertFalse(channel.writeInbound(byteBufOf("O")));
        assertFalse(channel.writeInbound(byteBufOf("K")));
        assertTrue(channel.writeInbound(byteBufOf("\r\n+SEC")));
        assertTrue(channel.writeInbound(byteBufOf("OND\r\n")));
        SimpleStringRedisMessage msg1 = channel.readInbound();
        assertThat(msg1.content(), is("OK"));
        ReferenceCountUtil.release(msg1);
        SimpleStringRedisMessage msg2 = channel.readInbound();
        assertThat(msg2.content(), is("SECOND"));
        ReferenceCountUtil.release(msg2);
    }
    @Test
    public void shouldDecodeError() {
        String content = "ERROR sample message";
        assertFalse(channel.writeInbound(byteBufOf("-")));
        assertFalse(channel.writeInbound(byteBufOf(content)));
        assertFalse(channel.writeInbound(byteBufOf("\r")));
        assertTrue(channel.writeInbound(byteBufOf("\n")));
        ErrorRedisMessage msg = channel.readInbound();
        assertThat(msg.content(), is(content));
        ReferenceCountUtil.release(msg);
    }
    @Test
    public void shouldDecodeInteger() {
        long value = 1234L;
        byte[] content = bytesOf(value);
        assertFalse(channel.writeInbound(byteBufOf(":")));
        assertFalse(channel.writeInbound(byteBufOf(content)));
        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
        IntegerRedisMessage msg = channel.readInbound();
        assertThat(msg.value(), is(value));
        ReferenceCountUtil.release(msg);
    }
    @Test
<a name="3"></a>    public void shouldDecodeBulkString() {
        String buf1 = "bulk\nst";
        String buf2 = "ring\ntest\n1234";
        <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>byte[] content = bytesOf(buf1 + buf2);
        assertFalse(channel.writeInbound(byteBufOf("$")));
        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(content.length))));
        assertFalse(channel.writeInbound(byteBufOf("\r\n")));
        assertFalse(channel.writeInbound(byteBufOf(buf1)));
<a name="6"></a>        assertFalse(channel.writeInbound(byteBufOf(buf2)));
        assertTrue</b></font>(channel.writeInbound(byteBufOf("\r\n")));
        FullBulkStringRedisMessage msg = <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>channel.readInbound();
        assertThat(bytesOf(msg.content()), is(content));
        ReferenceCountUtil.release(msg);
    }
    @Test
    public void shouldDecodeEmptyBulkString() {
        byte[] content = bytesOf("")</b></font>;
<a name="7"></a>        assertFalse(channel.writeInbound(byteBufOf("$")));
        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(content.length))));
        assertFalse(channel.writeInbound(byteBufOf("\r\n")));
        assertFalse(channel.writeInbound(<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>byteBufOf(content)));
        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
        FullBulkStringRedisMessage msg = channel.readInbound();
        assertThat(bytesOf(msg.content()), is(content));
        ReferenceCountUtil.release</b></font>(msg);
    }
    @Test
    public void shouldDecodeNullBulkString() {
        assertFalse(channel.writeInbound(byteBufOf("$")));
        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(-1))));
        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
        assertTrue(channel.writeInbound(byteBufOf("$")));
        assertTrue(channel.writeInbound(byteBufOf(Integer.toString(-1))));
        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
        FullBulkStringRedisMessage msg1 = channel.readInbound();
        assertThat(msg1.isNull(), is(true));
        ReferenceCountUtil.release(msg1);
        FullBulkStringRedisMessage msg2 = channel.readInbound();
        assertThat(msg2.isNull(), is(true));
        ReferenceCountUtil.release(msg2);
        FullBulkStringRedisMessage msg3 = channel.readInbound();
        assertThat(msg3, is(nullValue()));
    }
    @Test
    public void shouldDecodeSimpleArray() throws Exception {
        assertFalse(channel.writeInbound(byteBufOf("*3\r\n")));
        assertFalse(channel.writeInbound(byteBufOf(":1234\r\n")));
        assertFalse(channel.writeInbound(byteBufOf("+sim")));
        assertFalse(channel.writeInbound(byteBufOf("ple\r\n-err")));
        assertTrue(channel.writeInbound(byteBufOf("or\r\n")));
<a name="0"></a>        ArrayRedisMessage msg = channel.readInbound();
        List&lt;RedisMessage&gt; children = msg.children();
        assertThat(msg.children().size(), is(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>equalTo(3)));
        assertThat(children.get(0), instanceOf(IntegerRedisMessage.class));
        assertThat(((IntegerRedisMessage) children.get(0)).value(), is(1234L));
        assertThat(children.get(1), instanceOf(SimpleStringRedisMessage.class));
        assertThat(((SimpleStringRedisMessage) children.get(1)).content(), is("simple"));
        assertThat(children.get(2), instanceOf(ErrorRedisMessage.class));
        assertThat(((ErrorRedisMessage) children.get(2)).content(), is("error"));
        ReferenceCountUtil.release(msg);
    }
    @Test
    public void shouldDecodeNestedArray() throws Exception {
        ByteBuf buf = Unpooled.buffer()</b></font>;
        buf.writeBytes(byteBufOf("*2\r\n"));
        buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
        buf.writeBytes(byteBufOf("*2\r\n+Foo\r\n-Bar\r\n"));
        assertTrue(channel.writeInbound(buf));
        ArrayRedisMessage msg = channel.readInbound();
        List&lt;RedisMessage&gt; children = msg.children();
        assertThat(msg.children().size(), is(2));
        ArrayRedisMessage intArray = (ArrayRedisMessage) children.get(0);
        ArrayRedisMessage strArray = (ArrayRedisMessage) children.get(1);
<a name="1"></a>        assertThat(intArray.children().size(), is(3));
        assertThat(((IntegerRedisMessage) intArray.children().get(0)).value(), is(1L));
        assertThat(((IntegerRedisMessage) intArray.children().get(1)).value(), is(2L));
        <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assertThat(((IntegerRedisMessage) intArray.children().get(2)).value(), is(3L));
        assertThat(strArray.children().size(), is(2));
        assertThat(((SimpleStringRedisMessage) strArray.children().get(0)).content(), is("Foo"));
        assertThat(((ErrorRedisMessage) strArray.children().get(1)).content(), is("Bar"));
        ReferenceCountUtil.release(msg);
    }
    @Test
    public void shouldErrorOnDoubleReleaseArrayReferenceCounted() {
        ByteBuf buf = Unpooled.buffer</b></font>();
        buf.writeBytes(byteBufOf("*2\r\n"));
        buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
        buf.writeBytes(byteBufOf("*2\r\n+Foo\r\n-Bar\r\n"));
        assertTrue(channel.writeInbound(buf));
        final ArrayRedisMessage msg = channel.readInbound();
        ReferenceCountUtil.release(msg);
<a name="9"></a>        assertThrows(IllegalReferenceCountException.class, new Executable() {
            @Override
            public void execute() {
                <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ReferenceCountUtil.release(msg);
            }
        });
    }
    @Test
    public void shouldErrorOnReleaseArrayChildReferenceCounted() {
        ByteBuf buf = Unpooled.buffer()</b></font>;
        buf.writeBytes(byteBufOf("*2\r\n"));
        buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
        buf.writeBytes(byteBufOf("$3\r\nFoo\r\n"));
        assertTrue(channel.writeInbound(buf));
        ArrayRedisMessage msg = channel.readInbound();
        final List&lt;RedisMessage&gt; children = msg.children();
        ReferenceCountUtil.release(msg);
<a name="11"></a>        assertThrows(IllegalReferenceCountException.class, new Executable() {
            @Override
            public void execute() {
                ReferenceCountUtil.release(<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>children.get(1));
            }
        });
    }
    @Test
    public void shouldErrorOnReleasecontentOfArrayChildReferenceCounted() throws Exception {</b></font>
        ByteBuf buf = Unpooled.buffer();
        buf.writeBytes(byteBufOf("*2\r\n"));
        buf.writeBytes(byteBufOf("$3\r\nFoo\r\n$3\r\nBar\r\n"));
        assertTrue(channel.writeInbound(buf));
        ArrayRedisMessage msg = channel.readInbound();
        List&lt;RedisMessage&gt; children = msg.children();
        final ByteBuf childBuf = ((FullBulkStringRedisMessage) children.get(0)).content();
        ReferenceCountUtil.release(msg);
<a name="8"></a>        assertThrows(IllegalReferenceCountException.class, new Executable() {
            @Override
            public void execute() {
                <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>ReferenceCountUtil.release(childBuf);
            }
        });
    }
    @Test
    public void testPredefinedMessagesNotEqual() {
        assertNotEquals</b></font>(FullBulkStringRedisMessage.EMPTY_INSTANCE, FullBulkStringRedisMessage.NULL_INSTANCE);
        assertNotEquals(FullBulkStringRedisMessage.NULL_INSTANCE, FullBulkStringRedisMessage.EMPTY_INSTANCE);
    }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>PendingWriteQueueTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright 2014 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
<a name="2"></a> * License for the specific language governing permissions and limitations
 * under the License.
 */
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>package io.netty.channel;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.util.CharsetUtil;
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
publi</b></font>c class PendingWriteQueueTest {
    @Test
    public void testRemoveAndWrite() {
        assertWrite(new TestHandler() {
            @Override
            public void flush(ChannelHandlerContext ctx) throws Exception {
                assertFalse(ctx.channel().isWritable(), "Should not be writable anymore");
                ChannelFuture future = queue.removeAndWrite();
                future.addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture future) {
                        assertQueueEmpty(queue);
                    }
                });
<a name="10"></a>                super.flush(ctx);
            }
        }, 1);
    <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
    @Test
    public void testRemoveAndWriteAll() {
        assertWrite(new TestHandler() {
            @</b></font>Override
            public void flush(ChannelHandlerContext ctx) throws Exception {
                assertFalse(ctx.channel().isWritable(), "Should not be writable anymore");
                ChannelFuture future = queue.removeAndWriteAll();
                future.addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture future) {
<a name="8"></a>                        assertQueueEmpty(queue);
                    }
                });
                <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.flush(ctx);
            }
        }, 3);
    }
    @Test
    public void testRemoveAndFail() {
        assertWriteFails</b></font>(new TestHandler() {
<a name="11"></a>            @Override
            public void flush(ChannelHandlerContext ctx) throws Exception {
                queue.removeAndFail(new TestException());
                <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.flush(ctx);
            }
        }, 1);
    }
    @Test
    public void testRemoveAndFailAll() {</b></font>
        assertWriteFails(new TestHandler() {
<a name="9"></a>            @Override
            public void flush(ChannelHandlerContext ctx) throws Exception {
                queue.removeAndFailAll(new TestException());
                <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.flush(ctx);
            }
        }, 3);
    }
    @Test
    public void shouldFireChannelWritabilityChangedAfterRemoval() {
        final AtomicReference&lt;ChannelHandlerContext&gt; ctxRef = new AtomicReference&lt;ChannelHandlerContext&gt;()</b></font>;
        final AtomicReference&lt;PendingWriteQueue&gt; queueRef = new AtomicReference&lt;PendingWriteQueue&gt;();
        final ByteBuf msg = Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII);
        final EmbeddedChannel channel = new EmbeddedChannel(new ChannelInboundHandlerAdapter() {
            @Override
            public void handlerAdded(ChannelHandlerContext ctx) {
                ctxRef.set(ctx);
                queueRef.set(new PendingWriteQueue(ctx));
            }
            @Override
            public void channelWritabilityChanged(ChannelHandlerContext ctx) {
                final PendingWriteQueue queue = queueRef.get();
                final ByteBuf msg = (ByteBuf) queue.current();
                if (msg == null) {
                    return;
                }
                assertThat(msg.refCnt(), is(1));
                //
                queue.remove();
                assertThat(msg.refCnt(), is(0));
<a name="7"></a>            }
        });
        <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>channel.config().setWriteBufferLowWaterMark(1);
        channel.config().setWriteBufferHighWaterMark(3);
        final PendingWriteQueue queue = queueRef.get();
        queue.add(msg, channel.newPromise());
        channel.finish();
        assertThat(msg.refCnt</b></font>(), is(0));
    }
    private static void assertWrite(ChannelHandler handler, int count) {
        final ByteBuf buffer = Unpooled.copiedBuffer("Test", CharsetUtil.US_ASCII);
        final EmbeddedChannel channel = new EmbeddedChannel(handler);
        channel.config().setWriteBufferLowWaterMark(1);
        channel.config().setWriteBufferHighWaterMark(3);
        ByteBuf[] buffers = new ByteBuf[count];
        for (int i = 0; i &lt; buffers.length; i++) {
            buffers[i] = buffer.retainedDuplicate();
        }
        assertTrue(channel.writeOutbound(buffers));
        assertTrue(channel.finish());
        channel.closeFuture().syncUninterruptibly();
        for (int i = 0; i &lt; buffers.length; i++) {
            assertBuffer(channel, buffer);
        }
        buffer.release();
        assertNull(channel.readOutbound());
    }
    private static void assertBuffer(EmbeddedChannel channel, ByteBuf buffer) {
        ByteBuf written = channel.readOutbound();
        assertEquals(buffer, written);
<a name="5"></a>        written.release();
    }
    private static void assertQueueEmpty(PendingWriteQueue queue) <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
        assertTrue(queue.isEmpty());
        assertEquals(0, queue.size());
        assertEquals(0, queue.bytes());
        assertNull(queue.current());
        assertNull(queue.removeAndWrite());
        assertNull(queue.removeAndWriteAll</b></font>());
    }
    private static void assertWriteFails(ChannelHandler handler, int count) {
        final ByteBuf buffer = Unpooled.copiedBuffer("Test", CharsetUtil.US_ASCII);
        final EmbeddedChannel channel = new EmbeddedChannel(handler);
        ByteBuf[] buffers = new ByteBuf[count];
        for (int i = 0; i &lt; buffers.length; i++) {
            buffers[i] = buffer.retainedDuplicate();
        }
        try {
            assertFalse(channel.writeOutbound(buffers));
            fail();
        } catch (Exception e) {
            assertTrue(e instanceof TestException);
        }
        assertFalse(channel.finish());
        channel.closeFuture().syncUninterruptibly();
        buffer.release();
        assertNull(channel.readOutbound());
    }
    private static EmbeddedChannel newChannel() {
        return new EmbeddedChannel(new ChannelHandlerAdapter() { });
    }
    @Test
    public void testRemoveAndFailAllReentrantFailAll() {
        EmbeddedChannel channel = newChannel();
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
        ChannelPromise promise = channel.newPromise();
        promise.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                queue.removeAndFailAll(new IllegalStateException());
            }
        });
        queue.add(1L, promise);
        ChannelPromise promise2 = channel.newPromise();
        queue.add(2L, promise2);
<a name="6"></a>        queue.removeAndFailAll(new Exception());
        assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(promise2.isDone());
        assertFalse(promise2.isSuccess());
        assertFalse(channel.finish());
    }
    @Test
    public void testRemoveAndWriteAllReentrantWrite() {
        EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {</b></font>
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                ctx.writeAndFlush(msg, promise);
            }
        }, new ChannelOutboundHandlerAdapter());
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().lastContext());
        ChannelPromise promise = channel.newPromise();
        final ChannelPromise promise3 = channel.newPromise();
        promise.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                queue.add(3L, promise3);
<a name="0"></a>            }
        });
        queue.add(1L, promise);
        ChannelPromise promise2 = <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>channel.newPromise();
        queue.add(2L, promise2);
        queue.removeAndWriteAll();
        assertTrue(promise.isDone());
        assertTrue(promise.isSuccess());
        assertTrue(promise2.isDone());
        assertTrue(promise2.isSuccess());
        assertTrue(promise3.isDone());
        assertTrue(promise3.isSuccess());
        assertTrue(channel.finish());
        assertEquals(1L, (Long) channel.readOutbound());
        assertEquals(2L, (Long) channel.readOutbound());
        assertEquals(3L, (Long) channel.readOutbound());
    }
    @Test
    public void testRemoveAndWriteAllWithVoidPromise() {
        EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {</b></font>
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                ctx.writeAndFlush(msg, promise);
            }
        }, new ChannelOutboundHandlerAdapter());
<a name="4"></a>
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().lastContext());
        ChannelPromise promise = <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>channel.newPromise();
        queue.add(1L, promise);
        queue.add(2L, channel.voidPromise());
        queue.removeAndWriteAll();
        assertTrue(channel.finish());
        assertTrue(promise.isDone());
        assertTrue(promise.isSuccess());
        assertEquals(1L, (Long) channel.readOutbound());
        assertEquals(2L, (Long) channel.readOutbound());
    }</b></font>
    @Test
    public void testRemoveAndFailAllReentrantWrite() {
        final List&lt;Integer&gt; failOrder = Collections.synchronizedList(new ArrayList&lt;Integer&gt;());
        EmbeddedChannel channel = newChannel();
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
        ChannelPromise promise = channel.newPromise();
        final ChannelPromise promise3 = channel.newPromise();
        promise3.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                failOrder.add(3);
            }
        });
        promise.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                failOrder.add(1);
                queue.add(3L, promise3);
            }
        });
        queue.add(1L, promise);
        ChannelPromise promise2 = channel.newPromise();
        promise2.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                failOrder.add(2);
            }
<a name="1"></a>        });
        queue.add(2L, promise2);
        queue.removeAndFailAll(new Exception());
        <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertTrue(promise.isDone());
        assertFalse(promise.isSuccess());
        assertTrue(promise2.isDone());
        assertFalse(promise2.isSuccess());
        assertTrue(promise3.isDone());
        assertFalse(promise3.isSuccess());
        assertFalse(channel.finish());
        assertEquals(1, (int) failOrder.get(0));
        assertEquals(2, (int) failOrder.get(1));
        assertEquals(3, (int) failOrder.get(2));
    }
    @Test
    public void testRemoveAndWriteAllReentrance() {
        EmbeddedChannel channel = newChannel</b></font>();
        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
        ChannelPromise promise = channel.newPromise();
        promise.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                queue.removeAndWriteAll();
            }
<a name="3"></a>        });
        queue.add(1L, promise);
        <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ChannelPromise promise2 = channel.newPromise();
        queue.add(2L, promise2);
        queue.removeAndWriteAll();
        channel.flush();
        assertTrue(promise.isSuccess());
        assertTrue(promise2.isSuccess());
        assertTrue(channel.finish());
        assertEquals(1L, (Long) channel.readOutbound());
        assertEquals(2L, (Long) channel.readOutbound());
        assertNull(channel.readOutbound());
        assertNull(channel.readInbound</b></font>());
    }
    @Test
    public void testCloseChannelOnCreation() {
        EmbeddedChannel channel = newChannel();
        ChannelHandlerContext context = channel.pipeline().firstContext();
        channel.close().syncUninterruptibly();
        final PendingWriteQueue queue = new PendingWriteQueue(context);
        IllegalStateException ex = new IllegalStateException();
        ChannelPromise promise = channel.newPromise();
        queue.add(1L, promise);
        queue.removeAndFailAll(ex);
        assertSame(ex, promise.cause());
    }
    private static class TestHandler extends ChannelDuplexHandler {
        protected PendingWriteQueue queue;
        private int expectedSize;
<a name="13"></a>
        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
            <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>super.channelActive(ctx);
            assertQueueEmpty(queue);
            assertTrue(ctx.channel().isWritable(), "Should be writable");
        }
<a name="12"></a>        @</b></font>Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            queue.add(msg, promise);
            assertFalse(<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>queue.isEmpty());
            assertEquals(++expectedSize, queue.size());
            assertNotNull(queue.current());
        }
        @</b></font>Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            queue = new PendingWriteQueue(ctx);
        }
    }
    private static final class TestException extends Exception {
        private static final long serialVersionUID = -9018570103039458401L;
    }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
