<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ForwardingListenableFuture.java & TreeBasedTableTest.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ForwardingListenableFuture.java & TreeBasedTableTest.java
      </h3>
      <h1 align="center">
        2.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ForwardingListenableFuture.java (20.0%)<TH>TreeBasedTableTest.java (1.3554217%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1857925-0.html#0',2,'match1857925-1.html#0',3)" NAME="0">(60-66)<TD><A HREF="javascript:ZweiFrames('match1857925-0.html#0',2,'match1857925-1.html#0',3)" NAME="0">(99-105)</A><TD ALIGN=center><FONT COLOR="#ff0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ForwardingListenableFuture.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2009 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.common.util.concurrent;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import java.util.concurrent.Executor;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * A {@link ListenableFuture} which forwards all its method calls to another future. Subclasses
 * should override one or more methods to modify the behavior of the backing future as desired per
 * the &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;decorator pattern&lt;/a&gt;.
 *
 * &lt;p&gt;Most subclasses can just use {@link SimpleForwardingListenableFuture}.
 *
 * @author Shardul Deo
 * @since 4.0
 */
@GwtCompatible
@ElementTypesAreNonnullByDefault
public abstract class ForwardingListenableFuture&lt;V extends @Nullable Object&gt;
    extends ForwardingFuture&lt;V&gt; implements ListenableFuture&lt;V&gt; {

  /** Constructor for use by subclasses. */
  protected ForwardingListenableFuture() {}

  @Override
  protected abstract ListenableFuture&lt;? extends V&gt; delegate();

  @Override
  public void addListener(Runnable listener, Executor exec) {
    delegate().addListener(listener, exec);
  }

  // TODO(cpovirk): Use standard Javadoc form for SimpleForwarding* class and constructor
  /**
   * A simplified version of {@link ForwardingListenableFuture} where subclasses can pass in an
   * already constructed {@link ListenableFuture} as the delegate.
   *
   * @since 9.0
   */
  public abstract static class SimpleForwardingListenableFuture&lt;V extends @Nullable Object&gt;
      extends ForwardingListenableFuture&lt;V&gt; {
<A NAME="0"></A>    private final ListenableFuture&lt;V&gt; delegate;

    protected SimpleForwardingListenableFuture(ListenableFuture&lt;V&gt; delegate) {
      this.delegate = <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1857925-1.html#0',3,'match1857925-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Preconditions.checkNotNull(delegate);
    }

    @Override
    protected final ListenableFuture&lt;V&gt; delegate() {
      return delegate;
    }</B></FONT>
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeBasedTableTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (C) 2008 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import static com.google.common.truth.Truth.assertThat;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.collect.testing.SortedMapInterfaceTest;
import com.google.common.collect.testing.SortedMapTestSuiteBuilder;
import com.google.common.collect.testing.TestStringSortedMapGenerator;
import com.google.common.collect.testing.features.CollectionFeature;
import com.google.common.collect.testing.features.CollectionSize;
import com.google.common.collect.testing.features.MapFeature;
import com.google.common.testing.SerializableTester;
import java.util.Collections;
import java.util.Comparator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedMap;
import junit.framework.Test;
import junit.framework.TestSuite;

/**
 * Test cases for {@link TreeBasedTable}.
 *
 * @author Jared Levy
 * @author Louis Wasserman
 */
@GwtCompatible(emulated = true)
public class TreeBasedTableTest extends AbstractTableTest {
  @GwtIncompatible // suite
  public static Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTestSuite(TreeBasedTableTest.class);
    suite.addTestSuite(TreeRowTest.class);
    suite.addTest(
        SortedMapTestSuiteBuilder.using(
                new TestStringSortedMapGenerator() {
                  @Override
                  protected SortedMap&lt;String, String&gt; create(Entry&lt;String, String&gt;[] entries) {
                    TreeBasedTable&lt;String, String, String&gt; table = TreeBasedTable.create();
                    table.put(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
                    table.put(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;);
                    table.put(&quot;a&quot;, &quot;a&quot;, &quot;d&quot;);
                    for (Entry&lt;String, String&gt; entry : entries) {
                      table.put(&quot;b&quot;, entry.getKey(), entry.getValue());
                    }
                    return table.row(&quot;b&quot;);
                  }
                })
            .withFeatures(
                MapFeature.GENERAL_PURPOSE,
                CollectionFeature.SUPPORTS_ITERATOR_REMOVE,
                CollectionSize.ANY)
            .named(&quot;RowMapTestSuite&quot;)
            .createTestSuite());
    return suite;
  }

  public static class TreeRowTest extends SortedMapInterfaceTest&lt;String, String&gt; {
    public TreeRowTest() {
      super(false, false, true, true, true);
    }

    @Override
    protected SortedMap&lt;String, String&gt; makeEmptyMap() {
      TreeBasedTable&lt;String, String, String&gt; table = TreeBasedTable.create();
      table.put(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
      table.put(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;);
      table.put(&quot;a&quot;, &quot;a&quot;, &quot;d&quot;);
      return table.row(&quot;b&quot;);
    }

    @Override
    protected SortedMap&lt;String, String&gt; makePopulatedMap() {
      TreeBasedTable&lt;String, String, String&gt; table = TreeBasedTable.create();
      table.put(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
      table.put(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;);
      table.put(&quot;b&quot;, &quot;b&quot;, &quot;x&quot;);
<A NAME="0"></A>      table.put(&quot;b&quot;, &quot;c&quot;, &quot;y&quot;);
      table.put(&quot;b&quot;, &quot;x&quot;, &quot;n&quot;);
      table.put(&quot;a&quot;, &quot;a&quot;, &quot;d&quot;);
      return <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1857925-0.html#0',2,'match1857925-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>table.row(&quot;b&quot;);
    }

    @Override
    protected String getKeyNotInPopulatedMap() {
      return &quot;q&quot;;
    }</B></FONT>

    @Override
    protected String getValueNotInPopulatedMap() {
      return &quot;p&quot;;
    }

    public void testClearSubMapOfRowMap() {
      TreeBasedTable&lt;String, String, String&gt; table = TreeBasedTable.create();
      table.put(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
      table.put(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;);
      table.put(&quot;b&quot;, &quot;b&quot;, &quot;x&quot;);
      table.put(&quot;b&quot;, &quot;c&quot;, &quot;y&quot;);
      table.put(&quot;b&quot;, &quot;x&quot;, &quot;n&quot;);
      table.put(&quot;a&quot;, &quot;a&quot;, &quot;d&quot;);
      table.row(&quot;b&quot;).subMap(&quot;c&quot;, &quot;x&quot;).clear();
      assertEquals(table.row(&quot;b&quot;), ImmutableMap.of(&quot;b&quot;, &quot;x&quot;, &quot;x&quot;, &quot;n&quot;));
      table.row(&quot;b&quot;).subMap(&quot;b&quot;, &quot;y&quot;).clear();
      assertEquals(table.row(&quot;b&quot;), ImmutableMap.of());
      assertFalse(table.backingMap.containsKey(&quot;b&quot;));
    }
  }

  private TreeBasedTable&lt;String, Integer, Character&gt; sortedTable;

  protected TreeBasedTable&lt;String, Integer, Character&gt; create(
      Comparator&lt;? super String&gt; rowComparator,
      Comparator&lt;? super Integer&gt; columnComparator,
      Object... data) {
    TreeBasedTable&lt;String, Integer, Character&gt; table =
        TreeBasedTable.create(rowComparator, columnComparator);
    table.put(&quot;foo&quot;, 4, 'a');
    table.put(&quot;cat&quot;, 1, 'b');
    table.clear();
    populate(table, data);
    return table;
  }

  @Override
  protected TreeBasedTable&lt;String, Integer, Character&gt; create(Object... data) {
    TreeBasedTable&lt;String, Integer, Character&gt; table = TreeBasedTable.create();
    table.put(&quot;foo&quot;, 4, 'a');
    table.put(&quot;cat&quot;, 1, 'b');
    table.clear();
    populate(table, data);
    return table;
  }

  public void testCreateExplicitComparators() {
    table = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    table.put(&quot;foo&quot;, 3, 'a');
    table.put(&quot;foo&quot;, 12, 'b');
    table.put(&quot;bar&quot;, 5, 'c');
    table.put(&quot;cat&quot;, 8, 'd');
    assertThat(table.rowKeySet()).containsExactly(&quot;foo&quot;, &quot;cat&quot;, &quot;bar&quot;).inOrder();
    assertThat(table.row(&quot;foo&quot;).keySet()).containsExactly(12, 3).inOrder();
  }

  public void testCreateCopy() {
    TreeBasedTable&lt;String, Integer, Character&gt; original =
        TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    original.put(&quot;foo&quot;, 3, 'a');
    original.put(&quot;foo&quot;, 12, 'b');
    original.put(&quot;bar&quot;, 5, 'c');
    original.put(&quot;cat&quot;, 8, 'd');
    table = TreeBasedTable.create(original);
    assertThat(table.rowKeySet()).containsExactly(&quot;foo&quot;, &quot;cat&quot;, &quot;bar&quot;).inOrder();
    assertThat(table.row(&quot;foo&quot;).keySet()).containsExactly(12, 3).inOrder();
    assertEquals(original, table);
  }

  @GwtIncompatible // SerializableTester
  public void testSerialization() {
    table = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    SerializableTester.reserializeAndAssert(table);
  }

  public void testToString_ordered() {
    table = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    assertEquals(&quot;{bar={1=b}, foo={1=a, 3=c}}&quot;, table.toString());
    assertEquals(&quot;{bar={1=b}, foo={1=a, 3=c}}&quot;, table.rowMap().toString());
  }

  public void testCellSetToString_ordered() {
    table = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    assertEquals(&quot;[(bar,1)=b, (foo,1)=a, (foo,3)=c]&quot;, table.cellSet().toString());
  }

  public void testRowKeySetToString_ordered() {
    table = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    assertEquals(&quot;[bar, foo]&quot;, table.rowKeySet().toString());
  }

  public void testValuesToString_ordered() {
    table = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    assertEquals(&quot;[b, a, c]&quot;, table.values().toString());
  }

  public void testRowComparator() {
    sortedTable = TreeBasedTable.create();
    assertSame(Ordering.natural(), sortedTable.rowComparator());

    sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    assertSame(Collections.reverseOrder(), sortedTable.rowComparator());
  }

  public void testColumnComparator() {
    sortedTable = TreeBasedTable.create();
    sortedTable.put(&quot;&quot;, 42, 'x');
    assertSame(Ordering.natural(), sortedTable.columnComparator());
    assertSame(
        Ordering.natural(),
        ((SortedMap&lt;Integer, Character&gt;) sortedTable.rowMap().values().iterator().next())
            .comparator());

    sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    sortedTable.put(&quot;&quot;, 42, 'x');
    assertSame(Ordering.usingToString(), sortedTable.columnComparator());
    assertSame(
        Ordering.usingToString(),
        ((SortedMap&lt;Integer, Character&gt;) sortedTable.rowMap().values().iterator().next())
            .comparator());
  }

  public void testRowKeySetComparator() {
    sortedTable = TreeBasedTable.create();
    assertSame(Ordering.natural(), sortedTable.rowKeySet().comparator());

    sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    assertSame(Collections.reverseOrder(), sortedTable.rowKeySet().comparator());
  }

  public void testRowKeySetFirst() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    assertSame(&quot;bar&quot;, sortedTable.rowKeySet().first());
  }

  public void testRowKeySetLast() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    assertSame(&quot;foo&quot;, sortedTable.rowKeySet().last());
  }

  public void testRowKeySetHeadSet() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    Set&lt;String&gt; set = sortedTable.rowKeySet().headSet(&quot;cat&quot;);
    assertEquals(Collections.singleton(&quot;bar&quot;), set);
    set.clear();
    assertTrue(set.isEmpty());
    assertEquals(Collections.singleton(&quot;foo&quot;), sortedTable.rowKeySet());
  }

  public void testRowKeySetTailSet() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    Set&lt;String&gt; set = sortedTable.rowKeySet().tailSet(&quot;cat&quot;);
    assertEquals(Collections.singleton(&quot;foo&quot;), set);
    set.clear();
    assertTrue(set.isEmpty());
    assertEquals(Collections.singleton(&quot;bar&quot;), sortedTable.rowKeySet());
  }

  public void testRowKeySetSubSet() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c', &quot;dog&quot;, 2, 'd');
    Set&lt;String&gt; set = sortedTable.rowKeySet().subSet(&quot;cat&quot;, &quot;egg&quot;);
    assertEquals(Collections.singleton(&quot;dog&quot;), set);
    set.clear();
    assertTrue(set.isEmpty());
    assertEquals(ImmutableSet.of(&quot;bar&quot;, &quot;foo&quot;), sortedTable.rowKeySet());
  }

  public void testRowMapComparator() {
    sortedTable = TreeBasedTable.create();
    assertSame(Ordering.natural(), sortedTable.rowMap().comparator());

    sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    assertSame(Collections.reverseOrder(), sortedTable.rowMap().comparator());
  }

  public void testRowMapFirstKey() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    assertSame(&quot;bar&quot;, sortedTable.rowMap().firstKey());
  }

  public void testRowMapLastKey() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    assertSame(&quot;foo&quot;, sortedTable.rowMap().lastKey());
  }

  public void testRowKeyMapHeadMap() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    Map&lt;String, Map&lt;Integer, Character&gt;&gt; map = sortedTable.rowMap().headMap(&quot;cat&quot;);
    assertEquals(1, map.size());
    assertEquals(ImmutableMap.of(1, 'b'), map.get(&quot;bar&quot;));
    map.clear();
    assertTrue(map.isEmpty());
    assertEquals(Collections.singleton(&quot;foo&quot;), sortedTable.rowKeySet());
  }

  public void testRowKeyMapTailMap() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    Map&lt;String, Map&lt;Integer, Character&gt;&gt; map = sortedTable.rowMap().tailMap(&quot;cat&quot;);
    assertEquals(1, map.size());
    assertEquals(ImmutableMap.of(1, 'a', 3, 'c'), map.get(&quot;foo&quot;));
    map.clear();
    assertTrue(map.isEmpty());
    assertEquals(Collections.singleton(&quot;bar&quot;), sortedTable.rowKeySet());
  }

  public void testRowKeyMapSubMap() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c', &quot;dog&quot;, 2, 'd');
    Map&lt;String, Map&lt;Integer, Character&gt;&gt; map = sortedTable.rowMap().subMap(&quot;cat&quot;, &quot;egg&quot;);
    assertEquals(ImmutableMap.of(2, 'd'), map.get(&quot;dog&quot;));
    map.clear();
    assertTrue(map.isEmpty());
    assertEquals(ImmutableSet.of(&quot;bar&quot;, &quot;foo&quot;), sortedTable.rowKeySet());
  }

  public void testRowMapValuesAreSorted() {
    sortedTable = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c', &quot;dog&quot;, 2, 'd');
    assertTrue(sortedTable.rowMap().get(&quot;foo&quot;) instanceof SortedMap);
  }

  public void testColumnKeySet_isSorted() {
    table =
        create(
            &quot;a&quot;, 2, 'X', &quot;a&quot;, 2, 'X', &quot;b&quot;, 3, 'X', &quot;b&quot;, 2, 'X', &quot;c&quot;, 10, 'X', &quot;c&quot;, 10, 'X', &quot;c&quot;, 20,
            'X', &quot;d&quot;, 15, 'X', &quot;d&quot;, 20, 'X', &quot;d&quot;, 1, 'X', &quot;e&quot;, 5, 'X');
    assertEquals(&quot;[1, 2, 3, 5, 10, 15, 20]&quot;, table.columnKeySet().toString());
  }

  public void testColumnKeySet_isSortedWithRealComparator() {
    table =
        create(
            String.CASE_INSENSITIVE_ORDER,
            Ordering.natural().reverse(),
            &quot;a&quot;,
            2,
            'X',
            &quot;a&quot;,
            2,
            'X',
            &quot;b&quot;,
            3,
            'X',
            &quot;b&quot;,
            2,
            'X',
            &quot;c&quot;,
            10,
            'X',
            &quot;c&quot;,
            10,
            'X',
            &quot;c&quot;,
            20,
            'X',
            &quot;d&quot;,
            15,
            'X',
            &quot;d&quot;,
            20,
            'X',
            &quot;d&quot;,
            1,
            'X',
            &quot;e&quot;,
            5,
            'X');
    assertEquals(&quot;[20, 15, 10, 5, 3, 2, 1]&quot;, table.columnKeySet().toString());
  }

  public void testColumnKeySet_empty() {
    table = create();
    assertEquals(&quot;[]&quot;, table.columnKeySet().toString());
  }

  public void testColumnKeySet_oneRow() {
    table = create(&quot;a&quot;, 2, 'X', &quot;a&quot;, 1, 'X');
    assertEquals(&quot;[1, 2]&quot;, table.columnKeySet().toString());
  }

  public void testColumnKeySet_oneColumn() {
    table = create(&quot;a&quot;, 1, 'X', &quot;b&quot;, 1, 'X');
    assertEquals(&quot;[1]&quot;, table.columnKeySet().toString());
  }

  public void testColumnKeySet_oneEntry() {
    table = create(&quot;a&quot;, 1, 'X');
    assertEquals(&quot;[1]&quot;, table.columnKeySet().toString());
  }

  public void testRowEntrySetContains() {
    table =
        sortedTable =
            create(
                &quot;a&quot;, 2, 'X', &quot;a&quot;, 2, 'X', &quot;b&quot;, 3, 'X', &quot;b&quot;, 2, 'X', &quot;c&quot;, 10, 'X', &quot;c&quot;, 10, 'X', &quot;c&quot;,
                20, 'X', &quot;d&quot;, 15, 'X', &quot;d&quot;, 20, 'X', &quot;d&quot;, 1, 'X', &quot;e&quot;, 5, 'X');
    SortedMap&lt;Integer, Character&gt; row = sortedTable.row(&quot;c&quot;);
    Set&lt;Entry&lt;Integer, Character&gt;&gt; entrySet = row.entrySet();
    assertTrue(entrySet.contains(Maps.immutableEntry(10, 'X')));
    assertTrue(entrySet.contains(Maps.immutableEntry(20, 'X')));
    assertFalse(entrySet.contains(Maps.immutableEntry(15, 'X')));
    entrySet = row.tailMap(15).entrySet();
    assertFalse(entrySet.contains(Maps.immutableEntry(10, 'X')));
    assertTrue(entrySet.contains(Maps.immutableEntry(20, 'X')));
    assertFalse(entrySet.contains(Maps.immutableEntry(15, 'X')));
  }

  public void testRowEntrySetRemove() {
    table =
        sortedTable =
            create(
                &quot;a&quot;, 2, 'X', &quot;a&quot;, 2, 'X', &quot;b&quot;, 3, 'X', &quot;b&quot;, 2, 'X', &quot;c&quot;, 10, 'X', &quot;c&quot;, 10, 'X', &quot;c&quot;,
                20, 'X', &quot;d&quot;, 15, 'X', &quot;d&quot;, 20, 'X', &quot;d&quot;, 1, 'X', &quot;e&quot;, 5, 'X');
    SortedMap&lt;Integer, Character&gt; row = sortedTable.row(&quot;c&quot;);
    Set&lt;Entry&lt;Integer, Character&gt;&gt; entrySet = row.tailMap(15).entrySet();
    assertFalse(entrySet.remove(Maps.immutableEntry(10, 'X')));
    assertTrue(entrySet.remove(Maps.immutableEntry(20, 'X')));
    assertFalse(entrySet.remove(Maps.immutableEntry(15, 'X')));
    entrySet = row.entrySet();
    assertTrue(entrySet.remove(Maps.immutableEntry(10, 'X')));
    assertFalse(entrySet.remove(Maps.immutableEntry(20, 'X')));
    assertFalse(entrySet.remove(Maps.immutableEntry(15, 'X')));
  }

  public void testRowSize() {
    table =
        sortedTable =
            create(
                &quot;a&quot;, 2, 'X', &quot;a&quot;, 2, 'X', &quot;b&quot;, 3, 'X', &quot;b&quot;, 2, 'X', &quot;c&quot;, 10, 'X', &quot;c&quot;, 10, 'X', &quot;c&quot;,
                20, 'X', &quot;d&quot;, 15, 'X', &quot;d&quot;, 20, 'X', &quot;d&quot;, 1, 'X', &quot;e&quot;, 5, 'X');
    SortedMap&lt;Integer, Character&gt; row = sortedTable.row(&quot;c&quot;);
    assertEquals(2, row.size());
    assertEquals(1, row.tailMap(15).size());
  }

  public void testSubRowClearAndPut() {
    table = create(&quot;foo&quot;, 1, 'a', &quot;bar&quot;, 1, 'b', &quot;foo&quot;, 3, 'c');
    SortedMap&lt;Integer, Character&gt; row = (SortedMap&lt;Integer, Character&gt;) table.row(&quot;foo&quot;);
    SortedMap&lt;Integer, Character&gt; subRow = row.tailMap(2);
    assertEquals(ImmutableMap.of(1, 'a', 3, 'c'), row);
    assertEquals(ImmutableMap.of(3, 'c'), subRow);
    table.remove(&quot;foo&quot;, 3);
    assertEquals(ImmutableMap.of(1, 'a'), row);
    assertEquals(ImmutableMap.of(), subRow);
    table.remove(&quot;foo&quot;, 1);
    assertEquals(ImmutableMap.of(), row);
    assertEquals(ImmutableMap.of(), subRow);
    table.put(&quot;foo&quot;, 2, 'b');
    assertEquals(ImmutableMap.of(2, 'b'), row);
    assertEquals(ImmutableMap.of(2, 'b'), subRow);
    row.clear();
    assertEquals(ImmutableMap.of(), row);
    assertEquals(ImmutableMap.of(), subRow);
    table.put(&quot;foo&quot;, 5, 'x');
    assertEquals(ImmutableMap.of(5, 'x'), row);
    assertEquals(ImmutableMap.of(5, 'x'), subRow);
  }
}
</PRE>
</div>
  </div>
</body>
</html>
