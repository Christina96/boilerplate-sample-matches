<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ForwardingListenableFuture.java &amp; TreeBasedTableTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ForwardingListenableFuture.java &amp; TreeBasedTableTest.java
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ForwardingListenableFuture.java (20.0%)<th>TreeBasedTableTest.java (1.3554217%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(60-66)<td><a href="#" name="0">(99-105)</a><td align="center"><font color="#ff0000">9</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ForwardingListenableFuture.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.util.concurrent;
2 import com.google.common.annotations.GwtCompatible;
3 import com.google.common.base.Preconditions;
4 import java.util.concurrent.Executor;
5 import org.checkerframework.checker.nullness.qual.Nullable;
6 @GwtCompatible
7 @ElementTypesAreNonnullByDefault
8 public abstract class ForwardingListenableFuture&lt;V extends @Nullable Object&gt;
9     extends ForwardingFuture&lt;V&gt; implements ListenableFuture&lt;V&gt; {
10   protected ForwardingListenableFuture() {}
11   @Override
12   protected abstract ListenableFuture&lt;? extends V&gt; delegate();
13   @Override
14   public void addListener(Runnable listener, Executor exec) {
15     delegate().addListener(listener, exec);
16   }
17   public abstract static class SimpleForwardingListenableFuture&lt;V extends @Nullable Object&gt;
18       extends ForwardingListenableFuture&lt;V&gt; {
19 <a name="0"></a>    private final ListenableFuture&lt;V&gt; delegate;
20     protected SimpleForwardingListenableFuture(ListenableFuture&lt;V&gt; delegate) {
21       this.delegate = <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Preconditions.checkNotNull(delegate);
22     }
23     @Override
24     protected final ListenableFuture&lt;V&gt; delegate() {
25       return delegate;
26     }</b></font>
27   }
28 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeBasedTableTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package com.google.common.collect;
2 import static com.google.common.truth.Truth.assertThat;
3 import com.google.common.annotations.GwtCompatible;
4 import com.google.common.annotations.GwtIncompatible;
5 import com.google.common.collect.testing.SortedMapInterfaceTest;
6 import com.google.common.collect.testing.SortedMapTestSuiteBuilder;
7 import com.google.common.collect.testing.TestStringSortedMapGenerator;
8 import com.google.common.collect.testing.features.CollectionFeature;
9 import com.google.common.collect.testing.features.CollectionSize;
10 import com.google.common.collect.testing.features.MapFeature;
11 import com.google.common.testing.SerializableTester;
12 import java.util.Collections;
13 import java.util.Comparator;
14 import java.util.Map;
15 import java.util.Map.Entry;
16 import java.util.Set;
17 import java.util.SortedMap;
18 import junit.framework.Test;
19 import junit.framework.TestSuite;
20 @GwtCompatible(emulated = true)
21 public class TreeBasedTableTest extends AbstractTableTest {
22   @GwtIncompatible   public static Test suite() {
23     TestSuite suite = new TestSuite();
24     suite.addTestSuite(TreeBasedTableTest.class);
25     suite.addTestSuite(TreeRowTest.class);
26     suite.addTest(
27         SortedMapTestSuiteBuilder.using(
28                 new TestStringSortedMapGenerator() {
29                   @Override
30                   protected SortedMap&lt;String, String&gt; create(Entry&lt;String, String&gt;[] entries) {
31                     TreeBasedTable&lt;String, String, String&gt; table = TreeBasedTable.create();
32                     table.put("a", "b", "c");
33                     table.put("c", "b", "a");
34                     table.put("a", "a", "d");
35                     for (Entry&lt;String, String&gt; entry : entries) {
36                       table.put("b", entry.getKey(), entry.getValue());
37                     }
38                     return table.row("b");
39                   }
40                 })
41             .withFeatures(
42                 MapFeature.GENERAL_PURPOSE,
43                 CollectionFeature.SUPPORTS_ITERATOR_REMOVE,
44                 CollectionSize.ANY)
45             .named("RowMapTestSuite")
46             .createTestSuite());
47     return suite;
48   }
49   public static class TreeRowTest extends SortedMapInterfaceTest&lt;String, String&gt; {
50     public TreeRowTest() {
51       super(false, false, true, true, true);
52     }
53     @Override
54     protected SortedMap&lt;String, String&gt; makeEmptyMap() {
55       TreeBasedTable&lt;String, String, String&gt; table = TreeBasedTable.create();
56       table.put("a", "b", "c");
57       table.put("c", "b", "a");
58       table.put("a", "a", "d");
59       return table.row("b");
60     }
61     @Override
62     protected SortedMap&lt;String, String&gt; makePopulatedMap() {
63       TreeBasedTable&lt;String, String, String&gt; table = TreeBasedTable.create();
64       table.put("a", "b", "c");
65       table.put("c", "b", "a");
66       table.put("b", "b", "x");
67 <a name="0"></a>      table.put("b", "c", "y");
68       table.put("b", "x", "n");
69       table.put("a", "a", "d");
70       return <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>table.row("b");
71     }
72     @Override
73     protected String getKeyNotInPopulatedMap() {
74       return "q";
75     }</b></font>
76     @Override
77     protected String getValueNotInPopulatedMap() {
78       return "p";
79     }
80     public void testClearSubMapOfRowMap() {
81       TreeBasedTable&lt;String, String, String&gt; table = TreeBasedTable.create();
82       table.put("a", "b", "c");
83       table.put("c", "b", "a");
84       table.put("b", "b", "x");
85       table.put("b", "c", "y");
86       table.put("b", "x", "n");
87       table.put("a", "a", "d");
88       table.row("b").subMap("c", "x").clear();
89       assertEquals(table.row("b"), ImmutableMap.of("b", "x", "x", "n"));
90       table.row("b").subMap("b", "y").clear();
91       assertEquals(table.row("b"), ImmutableMap.of());
92       assertFalse(table.backingMap.containsKey("b"));
93     }
94   }
95   private TreeBasedTable&lt;String, Integer, Character&gt; sortedTable;
96   protected TreeBasedTable&lt;String, Integer, Character&gt; create(
97       Comparator&lt;? super String&gt; rowComparator,
98       Comparator&lt;? super Integer&gt; columnComparator,
99       Object... data) {
100     TreeBasedTable&lt;String, Integer, Character&gt; table =
101         TreeBasedTable.create(rowComparator, columnComparator);
102     table.put("foo", 4, 'a');
103     table.put("cat", 1, 'b');
104     table.clear();
105     populate(table, data);
106     return table;
107   }
108   @Override
109   protected TreeBasedTable&lt;String, Integer, Character&gt; create(Object... data) {
110     TreeBasedTable&lt;String, Integer, Character&gt; table = TreeBasedTable.create();
111     table.put("foo", 4, 'a');
112     table.put("cat", 1, 'b');
113     table.clear();
114     populate(table, data);
115     return table;
116   }
117   public void testCreateExplicitComparators() {
118     table = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
119     table.put("foo", 3, 'a');
120     table.put("foo", 12, 'b');
121     table.put("bar", 5, 'c');
122     table.put("cat", 8, 'd');
123     assertThat(table.rowKeySet()).containsExactly("foo", "cat", "bar").inOrder();
124     assertThat(table.row("foo").keySet()).containsExactly(12, 3).inOrder();
125   }
126   public void testCreateCopy() {
127     TreeBasedTable&lt;String, Integer, Character&gt; original =
128         TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
129     original.put("foo", 3, 'a');
130     original.put("foo", 12, 'b');
131     original.put("bar", 5, 'c');
132     original.put("cat", 8, 'd');
133     table = TreeBasedTable.create(original);
134     assertThat(table.rowKeySet()).containsExactly("foo", "cat", "bar").inOrder();
135     assertThat(table.row("foo").keySet()).containsExactly(12, 3).inOrder();
136     assertEquals(original, table);
137   }
138   @GwtIncompatible   public void testSerialization() {
139     table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
140     SerializableTester.reserializeAndAssert(table);
141   }
142   public void testToString_ordered() {
143     table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
144     assertEquals("{bar={1=b}, foo={1=a, 3=c}}", table.toString());
145     assertEquals("{bar={1=b}, foo={1=a, 3=c}}", table.rowMap().toString());
146   }
147   public void testCellSetToString_ordered() {
148     table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
149     assertEquals("[(bar,1)=b, (foo,1)=a, (foo,3)=c]", table.cellSet().toString());
150   }
151   public void testRowKeySetToString_ordered() {
152     table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
153     assertEquals("[bar, foo]", table.rowKeySet().toString());
154   }
155   public void testValuesToString_ordered() {
156     table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
157     assertEquals("[b, a, c]", table.values().toString());
158   }
159   public void testRowComparator() {
160     sortedTable = TreeBasedTable.create();
161     assertSame(Ordering.natural(), sortedTable.rowComparator());
162     sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
163     assertSame(Collections.reverseOrder(), sortedTable.rowComparator());
164   }
165   public void testColumnComparator() {
166     sortedTable = TreeBasedTable.create();
167     sortedTable.put("", 42, 'x');
168     assertSame(Ordering.natural(), sortedTable.columnComparator());
169     assertSame(
170         Ordering.natural(),
171         ((SortedMap&lt;Integer, Character&gt;) sortedTable.rowMap().values().iterator().next())
172             .comparator());
173     sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
174     sortedTable.put("", 42, 'x');
175     assertSame(Ordering.usingToString(), sortedTable.columnComparator());
176     assertSame(
177         Ordering.usingToString(),
178         ((SortedMap&lt;Integer, Character&gt;) sortedTable.rowMap().values().iterator().next())
179             .comparator());
180   }
181   public void testRowKeySetComparator() {
182     sortedTable = TreeBasedTable.create();
183     assertSame(Ordering.natural(), sortedTable.rowKeySet().comparator());
184     sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
185     assertSame(Collections.reverseOrder(), sortedTable.rowKeySet().comparator());
186   }
187   public void testRowKeySetFirst() {
188     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
189     assertSame("bar", sortedTable.rowKeySet().first());
190   }
191   public void testRowKeySetLast() {
192     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
193     assertSame("foo", sortedTable.rowKeySet().last());
194   }
195   public void testRowKeySetHeadSet() {
196     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
197     Set&lt;String&gt; set = sortedTable.rowKeySet().headSet("cat");
198     assertEquals(Collections.singleton("bar"), set);
199     set.clear();
200     assertTrue(set.isEmpty());
201     assertEquals(Collections.singleton("foo"), sortedTable.rowKeySet());
202   }
203   public void testRowKeySetTailSet() {
204     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
205     Set&lt;String&gt; set = sortedTable.rowKeySet().tailSet("cat");
206     assertEquals(Collections.singleton("foo"), set);
207     set.clear();
208     assertTrue(set.isEmpty());
209     assertEquals(Collections.singleton("bar"), sortedTable.rowKeySet());
210   }
211   public void testRowKeySetSubSet() {
212     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c', "dog", 2, 'd');
213     Set&lt;String&gt; set = sortedTable.rowKeySet().subSet("cat", "egg");
214     assertEquals(Collections.singleton("dog"), set);
215     set.clear();
216     assertTrue(set.isEmpty());
217     assertEquals(ImmutableSet.of("bar", "foo"), sortedTable.rowKeySet());
218   }
219   public void testRowMapComparator() {
220     sortedTable = TreeBasedTable.create();
221     assertSame(Ordering.natural(), sortedTable.rowMap().comparator());
222     sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
223     assertSame(Collections.reverseOrder(), sortedTable.rowMap().comparator());
224   }
225   public void testRowMapFirstKey() {
226     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
227     assertSame("bar", sortedTable.rowMap().firstKey());
228   }
229   public void testRowMapLastKey() {
230     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
231     assertSame("foo", sortedTable.rowMap().lastKey());
232   }
233   public void testRowKeyMapHeadMap() {
234     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
235     Map&lt;String, Map&lt;Integer, Character&gt;&gt; map = sortedTable.rowMap().headMap("cat");
236     assertEquals(1, map.size());
237     assertEquals(ImmutableMap.of(1, 'b'), map.get("bar"));
238     map.clear();
239     assertTrue(map.isEmpty());
240     assertEquals(Collections.singleton("foo"), sortedTable.rowKeySet());
241   }
242   public void testRowKeyMapTailMap() {
243     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
244     Map&lt;String, Map&lt;Integer, Character&gt;&gt; map = sortedTable.rowMap().tailMap("cat");
245     assertEquals(1, map.size());
246     assertEquals(ImmutableMap.of(1, 'a', 3, 'c'), map.get("foo"));
247     map.clear();
248     assertTrue(map.isEmpty());
249     assertEquals(Collections.singleton("bar"), sortedTable.rowKeySet());
250   }
251   public void testRowKeyMapSubMap() {
252     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c', "dog", 2, 'd');
253     Map&lt;String, Map&lt;Integer, Character&gt;&gt; map = sortedTable.rowMap().subMap("cat", "egg");
254     assertEquals(ImmutableMap.of(2, 'd'), map.get("dog"));
255     map.clear();
256     assertTrue(map.isEmpty());
257     assertEquals(ImmutableSet.of("bar", "foo"), sortedTable.rowKeySet());
258   }
259   public void testRowMapValuesAreSorted() {
260     sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c', "dog", 2, 'd');
261     assertTrue(sortedTable.rowMap().get("foo") instanceof SortedMap);
262   }
263   public void testColumnKeySet_isSorted() {
264     table =
265         create(
266             "a", 2, 'X', "a", 2, 'X', "b", 3, 'X', "b", 2, 'X', "c", 10, 'X', "c", 10, 'X', "c", 20,
267             'X', "d", 15, 'X', "d", 20, 'X', "d", 1, 'X', "e", 5, 'X');
268     assertEquals("[1, 2, 3, 5, 10, 15, 20]", table.columnKeySet().toString());
269   }
270   public void testColumnKeySet_isSortedWithRealComparator() {
271     table =
272         create(
273             String.CASE_INSENSITIVE_ORDER,
274             Ordering.natural().reverse(),
275             "a",
276             2,
277             'X',
278             "a",
279             2,
280             'X',
281             "b",
282             3,
283             'X',
284             "b",
285             2,
286             'X',
287             "c",
288             10,
289             'X',
290             "c",
291             10,
292             'X',
293             "c",
294             20,
295             'X',
296             "d",
297             15,
298             'X',
299             "d",
300             20,
301             'X',
302             "d",
303             1,
304             'X',
305             "e",
306             5,
307             'X');
308     assertEquals("[20, 15, 10, 5, 3, 2, 1]", table.columnKeySet().toString());
309   }
310   public void testColumnKeySet_empty() {
311     table = create();
312     assertEquals("[]", table.columnKeySet().toString());
313   }
314   public void testColumnKeySet_oneRow() {
315     table = create("a", 2, 'X', "a", 1, 'X');
316     assertEquals("[1, 2]", table.columnKeySet().toString());
317   }
318   public void testColumnKeySet_oneColumn() {
319     table = create("a", 1, 'X', "b", 1, 'X');
320     assertEquals("[1]", table.columnKeySet().toString());
321   }
322   public void testColumnKeySet_oneEntry() {
323     table = create("a", 1, 'X');
324     assertEquals("[1]", table.columnKeySet().toString());
325   }
326   public void testRowEntrySetContains() {
327     table =
328         sortedTable =
329             create(
330                 "a", 2, 'X', "a", 2, 'X', "b", 3, 'X', "b", 2, 'X', "c", 10, 'X', "c", 10, 'X', "c",
331                 20, 'X', "d", 15, 'X', "d", 20, 'X', "d", 1, 'X', "e", 5, 'X');
332     SortedMap&lt;Integer, Character&gt; row = sortedTable.row("c");
333     Set&lt;Entry&lt;Integer, Character&gt;&gt; entrySet = row.entrySet();
334     assertTrue(entrySet.contains(Maps.immutableEntry(10, 'X')));
335     assertTrue(entrySet.contains(Maps.immutableEntry(20, 'X')));
336     assertFalse(entrySet.contains(Maps.immutableEntry(15, 'X')));
337     entrySet = row.tailMap(15).entrySet();
338     assertFalse(entrySet.contains(Maps.immutableEntry(10, 'X')));
339     assertTrue(entrySet.contains(Maps.immutableEntry(20, 'X')));
340     assertFalse(entrySet.contains(Maps.immutableEntry(15, 'X')));
341   }
342   public void testRowEntrySetRemove() {
343     table =
344         sortedTable =
345             create(
346                 "a", 2, 'X', "a", 2, 'X', "b", 3, 'X', "b", 2, 'X', "c", 10, 'X', "c", 10, 'X', "c",
347                 20, 'X', "d", 15, 'X', "d", 20, 'X', "d", 1, 'X', "e", 5, 'X');
348     SortedMap&lt;Integer, Character&gt; row = sortedTable.row("c");
349     Set&lt;Entry&lt;Integer, Character&gt;&gt; entrySet = row.tailMap(15).entrySet();
350     assertFalse(entrySet.remove(Maps.immutableEntry(10, 'X')));
351     assertTrue(entrySet.remove(Maps.immutableEntry(20, 'X')));
352     assertFalse(entrySet.remove(Maps.immutableEntry(15, 'X')));
353     entrySet = row.entrySet();
354     assertTrue(entrySet.remove(Maps.immutableEntry(10, 'X')));
355     assertFalse(entrySet.remove(Maps.immutableEntry(20, 'X')));
356     assertFalse(entrySet.remove(Maps.immutableEntry(15, 'X')));
357   }
358   public void testRowSize() {
359     table =
360         sortedTable =
361             create(
362                 "a", 2, 'X', "a", 2, 'X', "b", 3, 'X', "b", 2, 'X', "c", 10, 'X', "c", 10, 'X', "c",
363                 20, 'X', "d", 15, 'X', "d", 20, 'X', "d", 1, 'X', "e", 5, 'X');
364     SortedMap&lt;Integer, Character&gt; row = sortedTable.row("c");
365     assertEquals(2, row.size());
366     assertEquals(1, row.tailMap(15).size());
367   }
368   public void testSubRowClearAndPut() {
369     table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
370     SortedMap&lt;Integer, Character&gt; row = (SortedMap&lt;Integer, Character&gt;) table.row("foo");
371     SortedMap&lt;Integer, Character&gt; subRow = row.tailMap(2);
372     assertEquals(ImmutableMap.of(1, 'a', 3, 'c'), row);
373     assertEquals(ImmutableMap.of(3, 'c'), subRow);
374     table.remove("foo", 3);
375     assertEquals(ImmutableMap.of(1, 'a'), row);
376     assertEquals(ImmutableMap.of(), subRow);
377     table.remove("foo", 1);
378     assertEquals(ImmutableMap.of(), row);
379     assertEquals(ImmutableMap.of(), subRow);
380     table.put("foo", 2, 'b');
381     assertEquals(ImmutableMap.of(2, 'b'), row);
382     assertEquals(ImmutableMap.of(2, 'b'), subRow);
383     row.clear();
384     assertEquals(ImmutableMap.of(), row);
385     assertEquals(ImmutableMap.of(), subRow);
386     table.put("foo", 5, 'x');
387     assertEquals(ImmutableMap.of(5, 'x'), row);
388     assertEquals(ImmutableMap.of(5, 'x'), subRow);
389   }
390 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
