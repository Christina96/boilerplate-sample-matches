
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.030181086519115%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ServerListLoabBalancerTest.java</h3>
            <pre><code>1  package com.netflix.loadbalancer;
2  import static org.junit.Assert.*;
3  import java.util.Arrays;
4  import java.util.HashSet;
5  import java.util.List;
6  import java.util.Set;
7  import org.apache.commons.configuration.Configuration;
8  import org.junit.BeforeClass;
9  import org.junit.Test;
10  import com.netflix.client.ClientFactory;
11  import com.netflix.client.config.IClientConfig;
12  import com.netflix.config.ConfigurationManager;
13  import com.netflix.loadbalancer.DynamicServerListLoadBalancer;
14  import com.netflix.loadbalancer.Server;
15  public class ServerListLoabBalancerTest {
16  	static Server[] servers = {new Server("abc", 80), new Server("xyz", 90), new Server("www.netflix.com", 80)};
17  	static List<Server> serverList = Arrays.asList(servers);
18  	public static class FixedServerList extends AbstractServerList<Server> {
19  		@Override
20  		public void initWithNiwsConfig(IClientConfig clientConfig) {
<span onclick='openModal()' class='match'>21  		}
22  		@Override
23  		public List<Server> getInitialListOfServers() {
24  			return serverList;
25  		}
26  		@Override
27  		public List<Server> getUpdatedListOfServers() {
28  			return serverList;
29  		}
30  	}
31  	static DynamicServerListLoadBalancer<Server> lb;
</span>32  	@BeforeClass
33  	public static void init() {
34  		Configuration config = ConfigurationManager.getConfigInstance();
35  		config.setProperty("ServerListLoabBalancerTest.ribbon.NFLoadBalancerClassName", 
36  				com.netflix.loadbalancer.DynamicServerListLoadBalancer.class.getName());
37  		config.setProperty("ServerListLoabBalancerTest.ribbon.NIWSServerListClassName", FixedServerList.class.getName());
38  		lb = (DynamicServerListLoadBalancer<Server>) ClientFactory.getNamedLoadBalancer("ServerListLoabBalancerTest");
39  	}
40      @Test
41      public void testChooseServer() {
42      	assertNotNull(lb);
43      	Set<Server> result = new HashSet<Server>();
44      	for (int i = 0; i < 100; i++) {
45      		Server s = lb.chooseServer(null);
46      		result.add(s);
47      	}
48      	Set<Server> expected = new HashSet<Server>();
49      	expected.addAll(serverList);
50      	assertEquals(expected, result);
51      }
52  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-Commands.java</h3>
            <pre><code>1  package net.md_5.bungee.protocol.packet;
2  import com.google.common.base.Preconditions;
3  import com.mojang.brigadier.Command;
4  import com.mojang.brigadier.StringReader;
5  import com.mojang.brigadier.arguments.ArgumentType;
6  import com.mojang.brigadier.arguments.DoubleArgumentType;
7  import com.mojang.brigadier.arguments.FloatArgumentType;
8  import com.mojang.brigadier.arguments.IntegerArgumentType;
9  import com.mojang.brigadier.arguments.LongArgumentType;
10  import com.mojang.brigadier.arguments.StringArgumentType;
11  import com.mojang.brigadier.builder.ArgumentBuilder;
12  import com.mojang.brigadier.builder.LiteralArgumentBuilder;
13  import com.mojang.brigadier.builder.RequiredArgumentBuilder;
14  import com.mojang.brigadier.context.CommandContext;
15  import com.mojang.brigadier.exceptions.CommandSyntaxException;
16  import com.mojang.brigadier.suggestion.SuggestionProvider;
17  import com.mojang.brigadier.suggestion.Suggestions;
18  import com.mojang.brigadier.suggestion.SuggestionsBuilder;
19  import com.mojang.brigadier.tree.ArgumentCommandNode;
20  import com.mojang.brigadier.tree.CommandNode;
21  import com.mojang.brigadier.tree.LiteralCommandNode;
22  import com.mojang.brigadier.tree.RootCommandNode;
23  import io.netty.buffer.ByteBuf;
24  import java.util.ArrayDeque;
25  import java.util.Collection;
26  import java.util.Deque;
27  import java.util.HashMap;
28  import java.util.Iterator;
29  import java.util.LinkedHashMap;
30  import java.util.Map;
31  import java.util.concurrent.CompletableFuture;
32  import lombok.AllArgsConstructor;
33  import lombok.Data;
34  import lombok.EqualsAndHashCode;
35  import lombok.NoArgsConstructor;
36  import net.md_5.bungee.protocol.AbstractPacketHandler;
37  import net.md_5.bungee.protocol.DefinedPacket;
38  import net.md_5.bungee.protocol.ProtocolConstants;
39  @Data
40  @NoArgsConstructor
41  @AllArgsConstructor
42  @EqualsAndHashCode(callSuper = false)
43  public class Commands extends DefinedPacket
44  {
45      private static final int FLAG_TYPE = 0x3;
46      private static final int FLAG_EXECUTABLE = 0x4;
47      private static final int FLAG_REDIRECT = 0x8;
48      private static final int FLAG_SUGGESTIONS = 0x10;
49      private static final int NODE_ROOT = 0;
50      private static final int NODE_LITERAL = 1;
51      private static final int NODE_ARGUMENT = 2;
52      private RootCommandNode root;
53      @Override
54      public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
55      {
56          int nodeCount = readVarInt( buf );
57          NetworkNode[] nodes = new NetworkNode[ nodeCount ];
58          Deque<NetworkNode> nodeQueue = new ArrayDeque<>( nodes.length );
59          for ( int i = 0; i < nodeCount; i++ )
60          {
61              byte flags = buf.readByte();
62              int[] children = readVarIntArray( buf );
63              int redirectNode = ( ( flags & FLAG_REDIRECT ) != 0 ) ? readVarInt( buf ) : 0;
64              ArgumentBuilder argumentBuilder;
65              switch ( flags & FLAG_TYPE )
66              {
67                  case NODE_ROOT:
68                      argumentBuilder = null;
69                      break;
70                  case NODE_LITERAL:
71                      argumentBuilder = LiteralArgumentBuilder.literal( readString( buf ) );
72                      break;
73                  case NODE_ARGUMENT:
74                      String name = readString( buf );
75                      argumentBuilder = RequiredArgumentBuilder.argument( name, ArgumentRegistry.read( buf, protocolVersion ) );
76                      if ( ( flags & FLAG_SUGGESTIONS ) != 0 )
77                      {
78                          String suggster = readString( buf );
79                          ( (RequiredArgumentBuilder) argumentBuilder ).suggests( SuggestionRegistry.getProvider( suggster ) );
80                      }
81                      break;
82                  default:
83                      throw new IllegalArgumentException( "Unhandled node type " + flags );
84              }
85              NetworkNode node = new NetworkNode( argumentBuilder, flags, redirectNode, children );
86              nodes[i] = node;
87              nodeQueue.add( node );
88          }
89          boolean mustCycle;
90          do
91          {
92              if ( nodeQueue.isEmpty() )
93              {
94                  int rootIndex = readVarInt( buf );
95                  root = (RootCommandNode<?>) nodes[rootIndex].command;
96                  return;
97              }
98              mustCycle = false;
99              for ( Iterator<NetworkNode> iter = nodeQueue.iterator(); iter.hasNext(); )
100              {
101                  NetworkNode node = iter.next();
102                  if ( node.buildSelf( nodes ) )
103                  {
104                      iter.remove();
105                      mustCycle = true;
106                  }
107              }
108          } while ( mustCycle );
109          throw new IllegalStateException( "Did not finish building root node" );
110      }
111      @Override
112      public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
113      {
114          Map<CommandNode, Integer> indexMap = new LinkedHashMap<>();
115          Deque<CommandNode> nodeQueue = new ArrayDeque<>();
116          nodeQueue.add( root );
117          while ( !nodeQueue.isEmpty() )
118          {
119              CommandNode command = nodeQueue.pollFirst();
120              if ( !indexMap.containsKey( command ) )
121              {
122                  int currentIndex = indexMap.size();
123                  indexMap.put( command, currentIndex );
124                  nodeQueue.addAll( command.getChildren() );
125                  if ( command.getRedirect() != null )
126                  {
127                      nodeQueue.add( command.getRedirect() );
128                  }
129              }
130          }
131          writeVarInt( indexMap.size(), buf );
132          int currentIndex = 0;
133          for ( Map.Entry<CommandNode, Integer> entry : indexMap.entrySet() )
134          {
135              Preconditions.checkState( entry.getValue() == currentIndex++, "Iteration out of order!" );
136              CommandNode node = entry.getKey();
137              byte flags = 0;
138              if ( node.getRedirect() != null )
139              {
140                  flags |= FLAG_REDIRECT;
141              }
142              if ( node.getCommand() != null )
143              {
144                  flags |= FLAG_EXECUTABLE;
145              }
146              if ( node instanceof RootCommandNode )
147              {
148                  flags |= NODE_ROOT;
149              } else if ( node instanceof LiteralCommandNode )
150              {
151                  flags |= NODE_LITERAL;
152              } else if ( node instanceof ArgumentCommandNode )
153              {
154                  flags |= NODE_ARGUMENT;
155                  if ( ( (ArgumentCommandNode) node ).getCustomSuggestions() != null )
156                  {
157                      flags |= FLAG_SUGGESTIONS;
158                  }
159              } else
160              {
161                  throw new IllegalArgumentException( "Unhandled node type " + node );
162              }
163              buf.writeByte( flags );
164              writeVarInt( node.getChildren().size(), buf );
165              for ( CommandNode child : (Collection<CommandNode>) node.getChildren() )
166              {
167                  writeVarInt( indexMap.get( child ), buf );
168              }
169              if ( node.getRedirect() != null )
170              {
171                  writeVarInt( indexMap.get( node.getRedirect() ), buf );
172              }
173              if ( node instanceof LiteralCommandNode )
174              {
175                  writeString( ( (LiteralCommandNode) node ).getLiteral(), buf );
176              } else if ( node instanceof ArgumentCommandNode )
177              {
178                  ArgumentCommandNode argumentNode = (ArgumentCommandNode) node;
179                  writeString( argumentNode.getName(), buf );
180                  ArgumentRegistry.write( argumentNode.getType(), buf, protocolVersion );
181                  if ( argumentNode.getCustomSuggestions() != null )
182                  {
183                      writeString( SuggestionRegistry.getKey( argumentNode.getCustomSuggestions() ), buf );
184                  }
185              }
186          }
187          int rootIndex = indexMap.get( root );
188          Preconditions.checkState( rootIndex == 0, "How did root not land up at index 0?!?" );
189          writeVarInt( rootIndex, buf );
190      }
191      @Override
192      public void handle(AbstractPacketHandler handler) throws Exception
193      {
194          handler.handle( this );
195      }
196      @Data
197      private static class NetworkNode
198      {
199          private final ArgumentBuilder argumentBuilder;
200          private final byte flags;
201          private final int redirectNode;
202          private final int[] children;
203          private CommandNode command;
204          private boolean buildSelf(NetworkNode[] otherNodes)
205          {
206              if ( command == null )
207              {
208                  if ( argumentBuilder == null )
209                  {
210                      command = new RootCommandNode();
211                  } else
212                  {
213                      if ( ( flags & FLAG_REDIRECT ) != 0 )
214                      {
215                          if ( otherNodes[redirectNode].command == null )
216                          {
217                              return false;
218                          }
219                          argumentBuilder.redirect( otherNodes[redirectNode].command );
220                      }
221                      if ( ( flags & FLAG_EXECUTABLE ) != 0 )
222                      {
223                          argumentBuilder.executes( new Command()
224                          {
225                              @Override
226                              public int run(CommandContext context) throws CommandSyntaxException
227                              {
228                                  return 0;
229                              }
230                          } );
231                      }
232                      command = argumentBuilder.build();
233                  }
234              }
235              for ( int childIndex : children )
236              {
237                  if ( otherNodes[childIndex].command == null )
238                  {
239                      return false;
240                  }
241              }
242              for ( int childIndex : children )
243              {
244                  CommandNode<?> child = otherNodes[childIndex].command;
245                  Preconditions.checkArgument( !( child instanceof RootCommandNode ), "Cannot have RootCommandNode as child" );
246                  command.addChild( child );
247              }
248              return true;
249          }
250      }
251      @Data
252      private static class ArgumentRegistry
253      {
254          private static final Map<String, ArgumentSerializer> PROVIDERS = new HashMap<>();
255          private static final ArgumentSerializer[] IDS_1_19;
256          private static final ArgumentSerializer[] IDS_1_19_3;
257          private static final ArgumentSerializer[] IDS_1_19_4;
258          private static final Map<Class<?>, ProperArgumentSerializer<?>> PROPER_PROVIDERS = new HashMap<>();
259          private static final ArgumentSerializer<Void> VOID = new ArgumentSerializer<Void>()
260          {
261              @Override
262              protected Void read(ByteBuf buf)
263              {
264                  return null;
265              }
266              @Override
267              protected void write(ByteBuf buf, Void t)
268              {
269              }
270          };
271          private static final ArgumentSerializer<Boolean> BOOLEAN = new ArgumentSerializer<Boolean>()
272          {
273              @Override
274              protected Boolean read(ByteBuf buf)
275              {
276                  return buf.readBoolean();
277              }
278              @Override
279              protected void write(ByteBuf buf, Boolean t)
280              {
281                  buf.writeBoolean( t );
282              }
283          };
284          private static final ArgumentSerializer<Byte> BYTE = new ArgumentSerializer<Byte>()
285          {
286              @Override
287              protected Byte read(ByteBuf buf)
288              {
289                  return buf.readByte();
290              }
291              @Override
292              protected void write(ByteBuf buf, Byte t)
293              {
294                  buf.writeByte( t );
295              }
296          };
297          private static final ArgumentSerializer<FloatArgumentType> FLOAT_RANGE = new ArgumentSerializer<FloatArgumentType>()
298          {
299              @Override
300              protected FloatArgumentType read(ByteBuf buf)
301              {
302                  byte flags = buf.readByte();
303                  float min = ( flags & 0x1 ) != 0 ? buf.readFloat() : -Float.MAX_VALUE;
304                  float max = ( flags & 0x2 ) != 0 ? buf.readFloat() : Float.MAX_VALUE;
305                  return FloatArgumentType.floatArg( min, max );
306              }
307              @Override
308              protected void write(ByteBuf buf, FloatArgumentType t)
309              {
310                  boolean hasMin = t.getMinimum() != -Float.MAX_VALUE;
311                  boolean hasMax = t.getMaximum() != Float.MAX_VALUE;
312                  buf.writeByte( binaryFlag( hasMin, hasMax ) );
313                  if ( hasMin )
314                  {
315                      buf.writeFloat( t.getMinimum() );
316                  }
317                  if ( hasMax )
318                  {
319                      buf.writeFloat( t.getMaximum() );
320                  }
321              }
322          };
323          private static final ArgumentSerializer<DoubleArgumentType> DOUBLE_RANGE = new ArgumentSerializer<DoubleArgumentType>()
324          {
325              @Override
326              protected DoubleArgumentType read(ByteBuf buf)
327              {
328                  byte flags = buf.readByte();
329                  double min = ( flags & 0x1 ) != 0 ? buf.readDouble() : -Double.MAX_VALUE;
330                  double max = ( flags & 0x2 ) != 0 ? buf.readDouble() : Double.MAX_VALUE;
331                  return DoubleArgumentType.doubleArg( min, max );
332              }
333              @Override
334              protected void write(ByteBuf buf, DoubleArgumentType t)
335              {
336                  boolean hasMin = t.getMinimum() != -Double.MAX_VALUE;
337                  boolean hasMax = t.getMaximum() != Double.MAX_VALUE;
338                  buf.writeByte( binaryFlag( hasMin, hasMax ) );
339                  if ( hasMin )
340                  {
341                      buf.writeDouble( t.getMinimum() );
342                  }
343                  if ( hasMax )
344                  {
345                      buf.writeDouble( t.getMaximum() );
346                  }
347              }
348          };
349          private static final ArgumentSerializer<IntegerArgumentType> INTEGER_RANGE = new ArgumentSerializer<IntegerArgumentType>()
350          {
351              @Override
352              protected IntegerArgumentType read(ByteBuf buf)
353              {
354                  byte flags = buf.readByte();
355                  int min = ( flags & 0x1 ) != 0 ? buf.readInt() : Integer.MIN_VALUE;
356                  int max = ( flags & 0x2 ) != 0 ? buf.readInt() : Integer.MAX_VALUE;
357                  return IntegerArgumentType.integer( min, max );
358              }
359              @Override
360              protected void write(ByteBuf buf, IntegerArgumentType t)
361              {
362                  boolean hasMin = t.getMinimum() != Integer.MIN_VALUE;
363                  boolean hasMax = t.getMaximum() != Integer.MAX_VALUE;
364                  buf.writeByte( binaryFlag( hasMin, hasMax ) );
365                  if ( hasMin )
366                  {
367                      buf.writeInt( t.getMinimum() );
368                  }
369                  if ( hasMax )
370                  {
371                      buf.writeInt( t.getMaximum() );
372                  }
373              }
374          };
375          private static final ArgumentSerializer<Integer> INTEGER = new ArgumentSerializer<Integer>()
376          {
377              @Override
378              protected Integer read(ByteBuf buf)
379              {
380                  return buf.readInt();
381              }
382              @Override
383              protected void write(ByteBuf buf, Integer t)
384              {
385                  buf.writeInt( t );
386              }
387          };
388          private static final ArgumentSerializer<LongArgumentType> LONG_RANGE = new ArgumentSerializer<LongArgumentType>()
389          {
390              @Override
391              protected LongArgumentType read(ByteBuf buf)
392              {
393                  byte flags = buf.readByte();
394                  long min = ( flags & 0x1 ) != 0 ? buf.readLong() : Long.MIN_VALUE;
395                  long max = ( flags & 0x2 ) != 0 ? buf.readLong() : Long.MAX_VALUE;
396                  return LongArgumentType.longArg( min, max );
397              }
398              @Override
399              protected void write(ByteBuf buf, LongArgumentType t)
400              {
401                  boolean hasMin = t.getMinimum() != Long.MIN_VALUE;
402                  boolean hasMax = t.getMaximum() != Long.MAX_VALUE;
403                  buf.writeByte( binaryFlag( hasMin, hasMax ) );
404                  if ( hasMin )
405                  {
406                      buf.writeLong( t.getMinimum() );
407                  }
408                  if ( hasMax )
409                  {
410                      buf.writeLong( t.getMaximum() );
411                  }
412              }
413          };
414          private static final ProperArgumentSerializer<StringArgumentType> STRING = new ProperArgumentSerializer<StringArgumentType>()
415          {
416              @Override
417              protected StringArgumentType read(ByteBuf buf)
418              {
419                  int val = readVarInt( buf );
420                  switch ( val )
421                  {
422                      case 0:
423                          return StringArgumentType.word();
424                      case 1:
425                          return StringArgumentType.string();
426                      case 2:
427                          return StringArgumentType.greedyString();
428                      default:
429                          throw new IllegalArgumentException( "Unknown string type " + val );
430                  }
431              }
432              @Override
433              protected void write(ByteBuf buf, StringArgumentType t)
434              {
435                  writeVarInt( t.getType().ordinal(), buf );
<span onclick='openModal()' class='match'>436              }
437              @Override
438              protected int getIntKey()
439              {
440                  return 5;
441              }
442              @Override
443              protected String getKey()
444              {
445                  return "brigadier:string";
446              }
447          };
448          private static final ArgumentSerializer<String> RAW_STRING = new ArgumentSerializer<String>()
</span>449          {
450              @Override
451              protected String read(ByteBuf buf)
452              {
453                  return DefinedPacket.readString( buf );
454              }
455              @Override
456              protected void write(ByteBuf buf, String t)
457              {
458                  DefinedPacket.writeString( t, buf );
459              }
460          };
461          static
462          {
463              register( "brigadier:bool", VOID );
464              register( "brigadier:float", FLOAT_RANGE );
465              register( "brigadier:double", DOUBLE_RANGE );
466              register( "brigadier:integer", INTEGER_RANGE );
467              register( "brigadier:long", LONG_RANGE );
468              register( "brigadier:string", STRING );
469              PROPER_PROVIDERS.put( StringArgumentType.class, STRING );
470              register( "minecraft:entity", BYTE );
471              register( "minecraft:game_profile", VOID );
472              register( "minecraft:block_pos", VOID );
473              register( "minecraft:column_pos", VOID );
474              register( "minecraft:vec3", VOID );
475              register( "minecraft:vec2", VOID );
476              register( "minecraft:block_state", VOID );
477              register( "minecraft:block_predicate", VOID );
478              register( "minecraft:item_stack", VOID );
479              register( "minecraft:item_predicate", VOID );
480              register( "minecraft:color", VOID );
481              register( "minecraft:component", VOID );
482              register( "minecraft:message", VOID );
483              register( "minecraft:nbt_compound_tag", VOID ); 
484              register( "minecraft:nbt_tag", VOID ); 
485              register( "minecraft:nbt_path", VOID );
486              register( "minecraft:objective", VOID );
487              register( "minecraft:objective_criteria", VOID );
488              register( "minecraft:operation", VOID );
489              register( "minecraft:particle", VOID );
490              register( "minecraft:angle", VOID ); 
491              register( "minecraft:rotation", VOID );
492              register( "minecraft:scoreboard_slot", VOID );
493              register( "minecraft:score_holder", BYTE );
494              register( "minecraft:swizzle", VOID );
495              register( "minecraft:team", VOID );
496              register( "minecraft:item_slot", VOID );
497              register( "minecraft:resource_location", VOID );
498              register( "minecraft:mob_effect", VOID );
499              register( "minecraft:function", VOID );
500              register( "minecraft:entity_anchor", VOID );
501              register( "minecraft:int_range", VOID );
502              register( "minecraft:float_range", VOID );
503              register( "minecraft:item_enchantment", VOID );
504              register( "minecraft:entity_summon", VOID );
505              register( "minecraft:dimension", VOID );
506              register( "minecraft:time", VOID ); 
507              register( "minecraft:resource_or_tag", RAW_STRING ); 
508              register( "minecraft:resource", RAW_STRING ); 
509              register( "minecraft:uuid", VOID ); 
510              register( "minecraft:nbt", VOID ); 
511              IDS_1_19 = new ArgumentSerializer[]
512              {
513                  get( "brigadier:bool", VOID ),
514                  get( "brigadier:float", FLOAT_RANGE ),
515                  get( "brigadier:double", DOUBLE_RANGE ),
516                  get( "brigadier:integer", INTEGER_RANGE ),
517                  get( "brigadier:long", LONG_RANGE ),
518                  get( "brigadier:string", STRING ),
519                  get( "minecraft:entity", BYTE ),
520                  get( "minecraft:game_profile", VOID ),
521                  get( "minecraft:block_pos", VOID ),
522                  get( "minecraft:column_pos", VOID ),
523                  get( "minecraft:vec3", VOID ),
524                  get( "minecraft:vec2", VOID ),
525                  get( "minecraft:block_state", VOID ),
526                  get( "minecraft:block_predicate", VOID ),
527                  get( "minecraft:item_stack", VOID ),
528                  get( "minecraft:item_predicate", VOID ),
529                  get( "minecraft:color", VOID ),
530                  get( "minecraft:component", VOID ),
531                  get( "minecraft:message", VOID ),
532                  get( "minecraft:nbt_compound_tag", VOID ),
533                  get( "minecraft:nbt_tag", VOID ),
534                  get( "minecraft:nbt_path", VOID ),
535                  get( "minecraft:objective", VOID ),
536                  get( "minecraft:objective_criteria", VOID ),
537                  get( "minecraft:operation", VOID ),
538                  get( "minecraft:particle", VOID ),
539                  get( "minecraft:angle", VOID ),
540                  get( "minecraft:rotation", VOID ),
541                  get( "minecraft:scoreboard_slot", VOID ),
542                  get( "minecraft:score_holder", BYTE ),
543                  get( "minecraft:swizzle", VOID ),
544                  get( "minecraft:team", VOID ),
545                  get( "minecraft:item_slot", VOID ),
546                  get( "minecraft:resource_location", VOID ),
547                  get( "minecraft:mob_effect", VOID ),
548                  get( "minecraft:function", VOID ),
549                  get( "minecraft:entity_anchor", VOID ),
550                  get( "minecraft:int_range", VOID ),
551                  get( "minecraft:float_range", VOID ),
552                  get( "minecraft:item_enchantment", VOID ),
553                  get( "minecraft:entity_summon", VOID ),
554                  get( "minecraft:dimension", VOID ),
555                  get( "minecraft:time", VOID ),
556                  get( "minecraft:resource_or_tag", RAW_STRING ),
557                  get( "minecraft:resource", RAW_STRING ),
558                  get( "minecraft:template_mirror", VOID ),
559                  get( "minecraft:template_rotation", VOID ),
560                  get( "minecraft:uuid", VOID ),
561              };
562              IDS_1_19_3 = new ArgumentSerializer[]
563              {
564                  get( "brigadier:bool", VOID ),
565                  get( "brigadier:float", FLOAT_RANGE ),
566                  get( "brigadier:double", DOUBLE_RANGE ),
567                  get( "brigadier:integer", INTEGER_RANGE ),
568                  get( "brigadier:long", LONG_RANGE ),
569                  get( "brigadier:string", STRING ),
570                  get( "minecraft:entity", BYTE ),
571                  get( "minecraft:game_profile", VOID ),
572                  get( "minecraft:block_pos", VOID ),
573                  get( "minecraft:column_pos", VOID ),
574                  get( "minecraft:vec3", VOID ),
575                  get( "minecraft:vec2", VOID ),
576                  get( "minecraft:block_state", VOID ),
577                  get( "minecraft:block_predicate", VOID ),
578                  get( "minecraft:item_stack", VOID ),
579                  get( "minecraft:item_predicate", VOID ),
580                  get( "minecraft:color", VOID ),
581                  get( "minecraft:component", VOID ),
582                  get( "minecraft:message", VOID ),
583                  get( "minecraft:nbt_compound_tag", VOID ),
584                  get( "minecraft:nbt_tag", VOID ),
585                  get( "minecraft:nbt_path", VOID ),
586                  get( "minecraft:objective", VOID ),
587                  get( "minecraft:objective_criteria", VOID ),
588                  get( "minecraft:operation", VOID ),
589                  get( "minecraft:particle", VOID ),
590                  get( "minecraft:angle", VOID ),
591                  get( "minecraft:rotation", VOID ),
592                  get( "minecraft:scoreboard_slot", VOID ),
593                  get( "minecraft:score_holder", BYTE ),
594                  get( "minecraft:swizzle", VOID ),
595                  get( "minecraft:team", VOID ),
596                  get( "minecraft:item_slot", VOID ),
597                  get( "minecraft:resource_location", VOID ),
598                  get( "minecraft:function", VOID ),
599                  get( "minecraft:entity_anchor", VOID ),
600                  get( "minecraft:int_range", VOID ),
601                  get( "minecraft:float_range", VOID ),
602                  get( "minecraft:dimension", VOID ),
603                  get( "minecraft:gamemode", VOID ),
604                  get( "minecraft:time", VOID ),
605                  get( "minecraft:resource_or_tag", RAW_STRING ),
606                  get( "minecraft:resource_or_tag_key", RAW_STRING ),
607                  get( "minecraft:resource", RAW_STRING ),
608                  get( "minecraft:resource_key", RAW_STRING ),
609                  get( "minecraft:template_mirror", VOID ),
610                  get( "minecraft:template_rotation", VOID ),
611                  get( "minecraft:uuid", VOID )
612              };
613              IDS_1_19_4 = new ArgumentSerializer[]
614              {
615                  get( "brigadier:bool", VOID ),
616                  get( "brigadier:float", FLOAT_RANGE ),
617                  get( "brigadier:double", DOUBLE_RANGE ),
618                  get( "brigadier:integer", INTEGER_RANGE ),
619                  get( "brigadier:long", LONG_RANGE ),
620                  get( "brigadier:string", STRING ),
621                  get( "minecraft:entity", BYTE ),
622                  get( "minecraft:game_profile", VOID ),
623                  get( "minecraft:block_pos", VOID ),
624                  get( "minecraft:column_pos", VOID ),
625                  get( "minecraft:vec3", VOID ),
626                  get( "minecraft:vec2", VOID ),
627                  get( "minecraft:block_state", VOID ),
628                  get( "minecraft:block_predicate", VOID ),
629                  get( "minecraft:item_stack", VOID ),
630                  get( "minecraft:item_predicate", VOID ),
631                  get( "minecraft:color", VOID ),
632                  get( "minecraft:component", VOID ),
633                  get( "minecraft:message", VOID ),
634                  get( "minecraft:nbt_compound_tag", VOID ),
635                  get( "minecraft:nbt_tag", VOID ),
636                  get( "minecraft:nbt_path", VOID ),
637                  get( "minecraft:objective", VOID ),
638                  get( "minecraft:objective_criteria", VOID ),
639                  get( "minecraft:operation", VOID ),
640                  get( "minecraft:particle", VOID ),
641                  get( "minecraft:angle", VOID ),
642                  get( "minecraft:rotation", VOID ),
643                  get( "minecraft:scoreboard_slot", VOID ),
644                  get( "minecraft:score_holder", BYTE ),
645                  get( "minecraft:swizzle", VOID ),
646                  get( "minecraft:team", VOID ),
647                  get( "minecraft:item_slot", VOID ),
648                  get( "minecraft:resource_location", VOID ),
649                  get( "minecraft:function", VOID ),
650                  get( "minecraft:entity_anchor", VOID ),
651                  get( "minecraft:int_range", VOID ),
652                  get( "minecraft:float_range", VOID ),
653                  get( "minecraft:dimension", VOID ),
654                  get( "minecraft:gamemode", VOID ),
655                  get( "minecraft:time", INTEGER ),
656                  get( "minecraft:resource_or_tag", RAW_STRING ),
657                  get( "minecraft:resource_or_tag_key", RAW_STRING ),
658                  get( "minecraft:resource", RAW_STRING ),
659                  get( "minecraft:resource_key", RAW_STRING ),
660                  get( "minecraft:template_mirror", VOID ),
661                  get( "minecraft:template_rotation", VOID ),
662                  get( "minecraft:uuid", VOID ),
663                  get( "minecraft:heightmap", VOID )
664              };
665          }
666          private static void register(String name, ArgumentSerializer serializer)
667          {
668              PROVIDERS.put( name, serializer );
669          }
670          private static ArgumentSerializer get(String name, ArgumentSerializer serializer)
671          {
672              return serializer;
673          }
674          private static ArgumentType<?> read(ByteBuf buf, int protocolVersion)
675          {
676              Object key;
677              ArgumentSerializer reader;
678              if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_19 )
679              {
680                  key = readVarInt( buf );
681                  if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_19_4 )
682                  {
683                      reader = IDS_1_19_4[(Integer) key];
684                  } else if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_19_3 )
685                  {
686                      reader = IDS_1_19_3[(Integer) key];
687                  } else
688                  {
689                      reader = IDS_1_19[(Integer) key];
690                  }
691              } else
692              {
693                  key = readString( buf );
694                  reader = PROVIDERS.get( (String) key );
695              }
696              Preconditions.checkArgument( reader != null, "No provider for argument " + key );
697              Object val = reader.read( buf );
698              return val != null && PROPER_PROVIDERS.containsKey( val.getClass() ) ? (ArgumentType<?>) val : new DummyType( key, reader, val );
699          }
700          private static void write(ArgumentType<?> arg, ByteBuf buf, int protocolVersion)
701          {
702              ProperArgumentSerializer proper = PROPER_PROVIDERS.get( arg.getClass() );
703              if ( proper != null )
704              {
705                  if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_19 )
706                  {
707                      writeVarInt( proper.getIntKey(), buf );
708                  } else
709                  {
710                      writeString( proper.getKey(), buf );
711                  }
712                  proper.write( buf, arg );
713              } else
714              {
715                  Preconditions.checkArgument( arg instanceof DummyType, "Non dummy arg " + arg.getClass() );
716                  DummyType dummy = (DummyType) arg;
717                  if ( dummy.key instanceof Integer )
718                  {
719                      writeVarInt( (Integer) dummy.key, buf );
720                  } else
721                  {
722                      writeString( (String) dummy.key, buf );
723                  }
724                  dummy.serializer.write( buf, dummy.value );
725              }
726          }
727          @Data
728          private static class DummyType<T> implements ArgumentType<T>
729          {
730              private final Object key;
731              private final ArgumentSerializer<T> serializer;
732              private final T value;
733              @Override
734              public T parse(StringReader reader) throws CommandSyntaxException
735              {
736                  throw new UnsupportedOperationException( "Not supported." );
737              }
738          }
739          private abstract static class ArgumentSerializer<T>
740          {
741              protected abstract T read(ByteBuf buf);
742              protected abstract void write(ByteBuf buf, T t);
743          }
744          private abstract static class ProperArgumentSerializer<T> extends ArgumentSerializer<T>
745          {
746              protected abstract int getIntKey();
747              protected abstract String getKey();
748          }
749      }
750      @Data
751      public static class SuggestionRegistry
752      {
753          public static final SuggestionProvider ASK_SERVER = new DummyProvider( "minecraft:ask_server" );
754          private static final Map<String, SuggestionProvider<DummyProvider>> PROVIDERS = new HashMap<>();
755          static
756          {
757              PROVIDERS.put( "minecraft:ask_server", ASK_SERVER );
758              registerDummy( "minecraft:all_recipes" );
759              registerDummy( "minecraft:available_sounds" );
760              registerDummy( "minecraft:available_biomes" );
761              registerDummy( "minecraft:summonable_entities" );
762          }
763          private static void registerDummy(String name)
764          {
765              PROVIDERS.put( name, new DummyProvider( name ) );
766          }
767          private static SuggestionProvider<DummyProvider> getProvider(String key)
768          {
769              SuggestionProvider<DummyProvider> provider = PROVIDERS.get( key );
770              Preconditions.checkArgument( provider != null, "Unknown completion provider " + key );
771              return provider;
772          }
773          private static String getKey(SuggestionProvider<DummyProvider> provider)
774          {
775              Preconditions.checkArgument( provider instanceof DummyProvider, "Non dummy provider " + provider );
776              return ( (DummyProvider) provider ).key;
777          }
778          @Data
779          private static final class DummyProvider implements SuggestionProvider<DummyProvider>
780          {
781              private final String key;
782              @Override
783              public CompletableFuture<Suggestions> getSuggestions(CommandContext<DummyProvider> context, SuggestionsBuilder builder) throws CommandSyntaxException
784              {
785                  return builder.buildFuture();
786              }
787          }
788      }
789      private static byte binaryFlag(boolean first, boolean second)
790      {
791          byte ret = 0;
792          if ( first )
793          {
794              ret = (byte) ( ret | 0x1 );
795          }
796          if ( second )
797          {
798              ret = (byte) ( ret | 0x2 );
799          }
800          return ret;
801      }
802  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-ServerListLoabBalancerTest.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-Commands.java</div>
                </div>
                <div class="column column_space"><pre><code>21  		}
22  		@Override
23  		public List<Server> getInitialListOfServers() {
24  			return serverList;
25  		}
26  		@Override
27  		public List<Server> getUpdatedListOfServers() {
28  			return serverList;
29  		}
30  	}
31  	static DynamicServerListLoadBalancer<Server> lb;
</pre></code></div>
                <div class="column column_space"><pre><code>436              }
437              @Override
438              protected int getIntKey()
439              {
440                  return 5;
441              }
442              @Override
443              protected String getKey()
444              {
445                  return "brigadier:string";
446              }
447          };
448          private static final ArgumentSerializer<String> RAW_STRING = new ArgumentSerializer<String>()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    