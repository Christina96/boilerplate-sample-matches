<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for SocketSslSessionReuseTest.java &amp; CloseNotifyTest.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for SocketSslSessionReuseTest.java &amp; CloseNotifyTest.java
      </h3>
<h1 align="center">
        22.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>SocketSslSessionReuseTest.java (22.839506%)<th>CloseNotifyTest.java (21.764706%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-61)<td><a href="#" name="0">(18-53)</a><td align="center"><font color="#ff0000">32</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(139-144)<td><a href="#" name="1">(138-142)</a><td align="center"><font color="#670000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(95-100)<td><a href="#" name="2">(146-152)</a><td align="center"><font color="#570000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(132-135)<td><a href="#" name="3">(88-93)</a><td align="center"><font color="#470000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(89-92)<td><a href="#" name="4">(161-166)</a><td align="center"><font color="#470000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>SocketSslSessionReuseTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright 2015 The Netty Project
3  *
4  * The Netty Project licenses this file to you under the Apache License,
5  * version 2.0 (the "License"); you may not use this file except in compliance
6  * with the License. You may obtain a copy of the License at:
7  *
8  *   https://www.apache.org/licenses/LICENSE-2.0
9  *
10  * Unless required by applicable law or agreed to in writing, software
11  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
12  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
13  * License for the specific language governing permissions and limitations
14  * under the License.
15  */
16 package io.netty.testsuite.transport.socket;
17 import io.netty.bootstrap.Bootstrap;
18 import io.netty.bootstrap.ServerBootstrap;
19 import io.netty.buffer.ByteBuf;
20 <a name="0"></a>import io.netty.buffer.ByteBufUtil;
21 import io.netty.buffer.Unpooled;
22 import io.netty.channel.Channel;
23 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.netty.channel.ChannelHandlerContext;
24 import io.netty.channel.ChannelHandler.Sharable;
25 import io.netty.channel.ChannelInitializer;
26 import io.netty.channel.SimpleChannelInboundHandler;
27 import io.netty.channel.socket.SocketChannel;
28 import io.netty.handler.ssl.JdkSslClientContext;
29 import io.netty.handler.ssl.JdkSslServerContext;
30 import io.netty.handler.ssl.SslContext;
31 import io.netty.handler.ssl.SslHandler;
32 import io.netty.handler.ssl.util.SelfSignedCertificate;
33 import io.netty.util.internal.logging.InternalLogger;
34 import io.netty.util.internal.logging.InternalLoggerFactory;
35 import org.junit.jupiter.api.TestInfo;
36 import org.junit.jupiter.api.Timeout;
37 import org.junit.jupiter.params.ParameterizedTest;
38 import org.junit.jupiter.params.provider.MethodSource;
39 import javax.net.ssl.SSLEngine;
40 import javax.net.ssl.SSLSessionContext;
41 import java.io.File;
42 import java.io.IOException;
43 import java.net.InetSocketAddress;
44 import java.security.cert.CertificateException;
45 import java.util.Collection;
46 import java.util.Collections;
47 import java.util.Enumeration;
48 import java.util.HashSet;
49 import java.util.Set;
50 import java.util.concurrent.TimeUnit;
51 import java.util.concurrent.atomic.AtomicReference;
52 import static org.junit.jupiter.api.Assertions.assertEquals;
53 public class SocketSslSessionReuseTest extends AbstractSocketTest {
54     private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocketSslSessionReuseTest.class)</b></font>;
55     private static final File CERT_FILE;
56     private static final File KEY_FILE;
57     static {
58         SelfSignedCertificate ssc;
59         try {
60             ssc = new SelfSignedCertificate();
61         } catch (CertificateException e) {
62             throw new Error(e);
63         }
64         CERT_FILE = ssc.certificate();
65         KEY_FILE = ssc.privateKey();
66     }
67     public static Collection&lt;Object[]&gt; data() throws Exception {
68         return Collections.singletonList(new Object[] {
69             new JdkSslServerContext(CERT_FILE, KEY_FILE),
70             new JdkSslClientContext(CERT_FILE)
71         });
72     }
73     @ParameterizedTest(name = "{index}: serverEngine = {0}, clientEngine = {1}")
74     @MethodSource("data")
75 <a name="4"></a>    @Timeout(value = 30000, unit = TimeUnit.MILLISECONDS)
76     public void testSslSessionReuse(final SslContext serverCtx, final SslContext clientCtx, TestInfo testInfo)
77             throws Throwable {
78         <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>run(testInfo, new Runner&lt;ServerBootstrap, Bootstrap&gt;() {
79             @Override
80             public void run(ServerBootstrap serverBootstrap, Bootstrap bootstrap) throws Throwable {
81 <a name="2"></a>                testSslSessionReuse</b></font>(sb, cb, serverCtx, clientCtx);
82             }
83         });
84     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
85     public void testSslSessionReuse(ServerBootstrap sb, Bootstrap cb,
86                                     final SslContext serverCtx, final SslContext clientCtx) throws Throwable {
87         final ReadAndDiscardHandler sh = new ReadAndDiscardHandler(true, true);
88         final ReadAndDiscardHandler ch = new ReadAndDiscardHandler(false, true)</b></font>;
89         final String[] protocols = { "TLSv1", "TLSv1.1", "TLSv1.2" };
90         sb.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
91             @Override
92             protected void initChannel(SocketChannel sch) throws Exception {
93                 SSLEngine engine = serverCtx.newEngine(sch.alloc());
94                 engine.setUseClientMode(false);
95                 engine.setEnabledProtocols(protocols);
96                 sch.pipeline().addLast(new SslHandler(engine));
97                 sch.pipeline().addLast(sh);
98             }
99         });
100         final Channel sc = sb.bind().sync().channel();
101         cb.handler(new ChannelInitializer&lt;SocketChannel&gt;() {
102             @Override
103             protected void initChannel(SocketChannel sch) throws Exception {
104                 InetSocketAddress serverAddr = (InetSocketAddress) sc.localAddress();
105                 SSLEngine engine = clientCtx.newEngine(sch.alloc(), serverAddr.getHostString(), serverAddr.getPort());
106                 engine.setUseClientMode(true);
107                 engine.setEnabledProtocols(protocols);
108                 sch.pipeline().addLast(new SslHandler(engine));
109                 sch.pipeline().addLast(ch);
110             }
111         });
112 <a name="3"></a>        try {
113             SSLSessionContext clientSessionCtx = clientCtx.sessionContext();
114             ByteBuf msg = Unpooled.wrappedBuffer(new byte[] { 0xa, 0xb, 0xc, 0xd }, 0, 4);
115             Channel cc = <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>cb.connect(sc.localAddress()).sync().channel();
116             cc.writeAndFlush(msg).sync();
117             cc.closeFuture().sync();
118             rethrowHandlerExceptions</b></font>(sh, ch);
119 <a name="1"></a>            Set&lt;String&gt; sessions = sessionIdSet(clientSessionCtx.getIds());
120             msg = Unpooled.wrappedBuffer(new byte[] { 0xa, 0xb, 0xc, 0xd }, 0, 4);
121             cc = <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>cb.connect(sc.localAddress()).sync().channel();
122             cc.writeAndFlush(msg).sync();
123             cc.closeFuture().sync();
124             assertEquals(sessions, sessionIdSet(clientSessionCtx.getIds()), "Expected no new sessions");
125             rethrowHandlerExceptions(sh, ch);
126         }</b></font> finally {
127             sc.close().awaitUninterruptibly();
128         }
129     }
130     private static void rethrowHandlerExceptions(ReadAndDiscardHandler sh, ReadAndDiscardHandler ch) throws Throwable {
131         if (sh.exception.get() != null &amp;&amp; !(sh.exception.get() instanceof IOException)) {
132             throw sh.exception.get();
133         }
134         if (ch.exception.get() != null &amp;&amp; !(ch.exception.get() instanceof IOException)) {
135             throw ch.exception.get();
136         }
137         if (sh.exception.get() != null) {
138             throw sh.exception.get();
139         }
140         if (ch.exception.get() != null) {
141             throw ch.exception.get();
142         }
143     }
144     private static Set&lt;String&gt; sessionIdSet(Enumeration&lt;byte[]&gt; sessionIds) {
145         Set&lt;String&gt; idSet = new HashSet&lt;String&gt;();
146         byte[] id;
147         while (sessionIds.hasMoreElements()) {
148             id = sessionIds.nextElement();
149             idSet.add(ByteBufUtil.hexDump(Unpooled.wrappedBuffer(id)));
150         }
151         return idSet;
152     }
153     @Sharable
154     private static class ReadAndDiscardHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {
155         final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();
156         private final boolean server;
157         private final boolean autoRead;
158         ReadAndDiscardHandler(boolean server, boolean autoRead) {
159             this.server = server;
160             this.autoRead = autoRead;
161         }
162         @Override
163         public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
164             byte[] actual = new byte[in.readableBytes()];
165             in.readBytes(actual);
166             ctx.close();
167         }
168         @Override
169         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
170             try {
171                 ctx.flush();
172             } finally {
173                 if (!autoRead) {
174                     ctx.read();
175                 }
176             }
177         }
178         @Override
179         public void exceptionCaught(ChannelHandlerContext ctx,
180                 Throwable cause) throws Exception {
181             if (logger.isWarnEnabled()) {
182                 logger.warn(
183                         "Unexpected exception from the " +
184                         (server? "server" : "client") + " side", cause);
185             }
186             exception.compareAndSet(null, cause);
187             ctx.close();
188         }
189     }
190 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CloseNotifyTest.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright 2021 The Netty Project
3  *
4  * The Netty Project licenses this file to you under the Apache License,
5  * version 2.0 (the "License"); you may not use this file except in compliance
6  * with the License. You may obtain a copy of the License at:
7  *
8  *   https://www.apache.org/licenses/LICENSE-2.0
9  *
10  * Unless required by applicable law or agreed to in writing, software
11  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
12  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
13  * License for the specific language governing permissions and limitations
14  * under the License.
15 <a name="0"></a> */
16 package io.netty.handler.ssl;
17 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import io.netty.buffer.ByteBuf;
18 import io.netty.buffer.UnpooledByteBufAllocator;
19 import io.netty.channel.ChannelHandlerContext;
20 import io.netty.channel.SimpleChannelInboundHandler;
21 import io.netty.channel.embedded.EmbeddedChannel;
22 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
23 import io.netty.handler.ssl.util.SelfSignedCertificate;
24 import org.junit.jupiter.api.Timeout;
25 import org.junit.jupiter.params.ParameterizedTest;
26 import org.junit.jupiter.params.provider.MethodSource;
27 import java.util.Collection;
28 import java.util.Queue;
29 import java.util.concurrent.BlockingQueue;
30 import java.util.concurrent.LinkedBlockingQueue;
31 import java.util.concurrent.TimeUnit;
32 import javax.annotation.Nullable;
33 import javax.net.ssl.SSLSession;
34 import static io.netty.buffer.ByteBufUtil.writeAscii;
35 import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
36 import static io.netty.handler.codec.ByteToMessageDecoder.MERGE_CUMULATOR;
37 import static java.nio.charset.StandardCharsets.US_ASCII;
38 import static java.util.Arrays.asList;
39 import static org.hamcrest.MatcherAssert.assertThat;
40 import static org.hamcrest.Matchers.empty;
41 import static org.hamcrest.Matchers.equalTo;
42 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
43 import static org.hamcrest.Matchers.instanceOf;
44 import static org.hamcrest.Matchers.is;
45 import static org.hamcrest.Matchers.notNullValue;
46 import static org.junit.jupiter.api.Assumptions.assumeTrue;
47 public class CloseNotifyTest {
48     private static final UnpooledByteBufAllocator ALLOC = UnpooledByteBufAllocator.DEFAULT</b></font>;
49     private static final Object INACTIVE = new Object() {
50         @Override
51         public String toString() {
52             return "INACTIVE";
53         }
54     };
55     static Collection&lt;Object[]&gt; data() {
56         return asList(new Object[][] {
57                 { SslProvider.JDK, SslProtocols.TLS_v1_2 },
58                 { SslProvider.JDK, SslProtocols.TLS_v1_3 },
59                 { SslProvider.OPENSSL, SslProtocols.TLS_v1_2 },
60                 { SslProvider.OPENSSL, SslProtocols.TLS_v1_3 },
61         });
62     }
63     @ParameterizedTest(name = "{index}: provider={0}, protocol={1}")
64     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
65     @MethodSource("data")
66     public void eventsOrder(SslProvider provider, String protocol) throws Exception {
67         assumeTrue(provider != SslProvider.OPENSSL || OpenSsl.isAvailable(), "OpenSSL is not available");
68         if (SslProtocols.TLS_v1_3.equals(protocol)) {
69             assumeTrue(SslProvider.isTlsv13Supported(provider));
70         }
71         BlockingQueue&lt;Object&gt; clientEventQueue = new LinkedBlockingQueue&lt;Object&gt;();
72         BlockingQueue&lt;Object&gt; serverEventQueue = new LinkedBlockingQueue&lt;Object&gt;();
73         EmbeddedChannel clientChannel = initChannel(provider, protocol, true, clientEventQueue);
74         EmbeddedChannel serverChannel = initChannel(provider, protocol, false, serverEventQueue);
75 <a name="3"></a>
76         try {
77             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>forwardData(clientChannel, serverChannel);
78             forwardData(serverChannel, clientChannel);
79             forwardData(clientChannel, serverChannel);
80             forwardData(serverChannel, clientChannel);
81             assertThat(clientEventQueue.poll(), instanceOf(SslHandshakeCompletionEvent.class));
82             assertThat(serverEventQueue.poll</b></font>(), instanceOf(SslHandshakeCompletionEvent.class));
83             assertThat(handshakenProtocol(clientChannel), equalTo(protocol));
84             clientChannel.writeOutbound(writeAscii(ALLOC, "request_msg"));
85             forwardData(clientChannel, serverChannel);
86             assertThat(serverEventQueue.poll(), equalTo((Object) "request_msg"));
87             serverChannel.writeOutbound(writeAscii(ALLOC, "response_msg"));
88             assertThat(serverChannel.finish(), is(true));
89             assertThat(serverEventQueue.poll(), instanceOf(SslCloseCompletionEvent.class));
90             assertThat(clientEventQueue, empty());
91             forwardAllWithCloseNotify(serverChannel, clientChannel);
92             assertThat(clientEventQueue.poll(), equalTo((Object) "response_msg"));
93             assertThat(clientEventQueue.poll(), instanceOf(SslCloseCompletionEvent.class));
94             if (!jdkTls13(provider, protocol)) {
95                 assertCloseNotify((ByteBuf) clientChannel.readOutbound());
96             }
97         } finally {
98             try {
99                 clientChannel.finish();
100             } finally {
101                 serverChannel.finish();
102             }
103         }
104         if (jdkTls13(provider, protocol)) {
105             assertCloseNotify((ByteBuf) clientChannel.readOutbound());
106         } else {
107             discardEmptyOutboundBuffers(clientChannel);
108         }
109         assertThat(clientEventQueue.poll(), is(INACTIVE));
110         assertThat(clientEventQueue, empty());
111 <a name="1"></a>        assertThat(serverEventQueue.poll(), is(INACTIVE));
112         assertThat(serverEventQueue, empty());
113         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assertThat(clientChannel.releaseInbound(), is(false));
114         assertThat(clientChannel.releaseOutbound(), is(false));
115         assertThat(serverChannel.releaseInbound(), is(false));
116         assertThat(serverChannel.releaseOutbound(), is(false));
117     }</b></font>
118 <a name="2"></a>
119     private static boolean jdkTls13(SslProvider provider, String protocol) {
120         return provider == SslProvider.JDK &amp;&amp; SslProtocols.TLS_v1_3.equals(protocol);
121     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
122     private static EmbeddedChannel initChannel(SslProvider provider, String protocol, final boolean useClientMode,
123             final BlockingQueue&lt;Object&gt; eventQueue) throws Exception {
124         SelfSignedCertificate ssc = new SelfSignedCertificate();
125         final SslContext sslContext = (useClientMode</b></font>
126                 ? SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE)
127                 : SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()))
128                  .sslProvider(provider)
129                  .protocols(protocol)
130                 .build();
131 <a name="4"></a>        return new EmbeddedChannel(
132                 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>sslContext.newHandler(ALLOC),
133                 new SimpleChannelInboundHandler&lt;ByteBuf&gt;() {
134                     @Override
135                     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {
136                         eventQueue.add</b></font>(msg.toString(US_ASCII));
137                     }
138                     @Override
139                     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
140                         eventQueue.add(evt);
141                     }
142                     @Override
143                     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
144                         eventQueue.add(INACTIVE);
145                         super.channelInactive(ctx);
146                     }
147                 }
148         );
149     }
150     private static void forwardData(EmbeddedChannel from, EmbeddedChannel to) {
151         ByteBuf in;
152         while ((in = from.readOutbound()) != null) {
153             to.writeInbound(in);
154         }
155     }
156     private static void forwardAllWithCloseNotify(EmbeddedChannel from, EmbeddedChannel to) {
157         ByteBuf cumulation = EMPTY_BUFFER;
158         ByteBuf in, closeNotify = null;
159         while ((in = from.readOutbound()) != null) {
160             if (closeNotify != null) {
161                 closeNotify.release();
162             }
163             closeNotify = in.duplicate();
164             cumulation = MERGE_CUMULATOR.cumulate(ALLOC, cumulation, in.retain());
165         }
166         assertCloseNotify(closeNotify);
167         to.writeInbound(cumulation);
168     }
169     private static String handshakenProtocol(EmbeddedChannel channel) {
170         SslHandler sslHandler = channel.pipeline().get(SslHandler.class);
171         SSLSession session = sslHandler.engine().getSession();
172         return session.getProtocol();
173     }
174     private static void discardEmptyOutboundBuffers(EmbeddedChannel channel) {
175         Queue&lt;Object&gt; outbound = channel.outboundMessages();
176         while (outbound.peek() instanceof ByteBuf) {
177             ByteBuf buf = (ByteBuf) outbound.peek();
178             if (!buf.isReadable()) {
179                 buf.release();
180                 outbound.poll();
181             } else {
182                 break;
183             }
184         }
185     }
186     static void assertCloseNotify(@Nullable ByteBuf closeNotify) {
187         assertThat(closeNotify, notNullValue());
188         try {
189             assertThat("Doesn't match expected length of close_notify alert",
190                     closeNotify.readableBytes(), greaterThanOrEqualTo(7));
191         } finally {
192             closeNotify.release();
193         }
194     }
195 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
