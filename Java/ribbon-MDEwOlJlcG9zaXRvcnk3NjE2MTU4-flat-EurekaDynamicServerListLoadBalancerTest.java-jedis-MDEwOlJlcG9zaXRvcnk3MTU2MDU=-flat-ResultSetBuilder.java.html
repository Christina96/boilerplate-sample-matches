
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.922551252847381%, Tokens: 15</h2>
        <div class="column">
            <h3>ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-EurekaDynamicServerListLoadBalancerTest.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.netflix.loadbalancer;
2  import com.netflix.appinfo.InstanceInfo;
3  import com.netflix.client.config.CommonClientConfigKey;
4  import com.netflix.client.config.DefaultClientConfigImpl;
5  import com.netflix.discovery.CacheRefreshedEvent;
6  import com.netflix.discovery.DefaultEurekaClientConfig;
7  import com.netflix.discovery.DiscoveryClient;
8  import com.netflix.discovery.EurekaClient;
9  import com.netflix.discovery.EurekaEventListener;
10  import com.netflix.discovery.util.InstanceInfoGenerator;
11  import com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList;
12  import com.netflix.niws.loadbalancer.DiscoveryEnabledServer;
13  import com.netflix.niws.loadbalancer.EurekaNotificationServerListUpdater;
14  import org.easymock.Capture;
15  import org.easymock.EasyMock;
</span>16  import org.junit.Assert;
17  import org.junit.Before;
18  import org.junit.Test;
19  import org.junit.runner.RunWith;
20  import org.powermock.api.easymock.PowerMock;
21  import org.powermock.core.classloader.annotations.PowerMockIgnore;
22  import org.powermock.core.classloader.annotations.PrepareForTest;
23  import org.powermock.modules.junit4.PowerMockRunner;
24  import javax.inject.Provider;
25  import java.util.List;
26  import java.util.concurrent.TimeUnit;
27  @RunWith(PowerMockRunner.class)
28  @PrepareForTest(DiscoveryClient.class)
29  @PowerMockIgnore("javax.management.*")
30  public class EurekaDynamicServerListLoadBalancerTest {
31      private final List<InstanceInfo> servers = InstanceInfoGenerator.newBuilder(10, 1).build().toInstanceList();
32      private final int initialServerListSize = 4;
33      private final int secondServerListSize = servers.size() - initialServerListSize;
34      private final String vipAddress = servers.get(0).getVIPAddress();
35      private DefaultClientConfigImpl config;
36      private EurekaClient eurekaClientMock;
37      private Provider<EurekaClient> eurekaClientProvider;
38      @Before
39      public void setUp() {
40          PowerMock.mockStatic(DiscoveryClient.class);
41          EasyMock
42                  .expect(DiscoveryClient.getZone(EasyMock.isA(InstanceInfo.class)))
43                  .andReturn("zone")
44                  .anyTimes();
45          eurekaClientMock = setUpEurekaClientMock(servers);
46          eurekaClientProvider = new Provider<EurekaClient>() {
47              @Override
48              public EurekaClient get() {
49                  return eurekaClientMock;
50              }
51          };
52          config = DefaultClientConfigImpl.getClientConfigWithDefaultValues();
53          config.set(CommonClientConfigKey.DeploymentContextBasedVipAddresses, vipAddress);
54          config.set(CommonClientConfigKey.ServerListUpdaterClassName, EurekaNotificationServerListUpdater.class.getName());
55      }
56      @Test
57      public void testLoadBalancerHappyCase() throws Exception {
58          Assert.assertNotEquals("the two test server list counts should be different",
59                  secondServerListSize, initialServerListSize);
60          DynamicServerListLoadBalancer<DiscoveryEnabledServer> lb = null;
61          try {
62              Capture<EurekaEventListener> eventListenerCapture = new Capture<EurekaEventListener>();
63              eurekaClientMock.registerEventListener(EasyMock.capture(eventListenerCapture));
64              PowerMock.replay(DiscoveryClient.class);
65              PowerMock.replay(eurekaClientMock);
66              lb = new DynamicServerListLoadBalancer<DiscoveryEnabledServer>(
67                      config,
68                      new AvailabilityFilteringRule(),
69                      new DummyPing(),
70                      new DiscoveryEnabledNIWSServerList(vipAddress, eurekaClientProvider),
71                      new ZoneAffinityServerListFilter<DiscoveryEnabledServer>(),
72                      new EurekaNotificationServerListUpdater(eurekaClientProvider)
73              );
74              Assert.assertEquals(initialServerListSize, lb.getServerCount(false));
75              eventListenerCapture.getValue().onEvent(new CacheRefreshedEvent());
76              Assert.assertTrue(verifyFinalServerListCount(secondServerListSize, lb));
77          } finally {
78              if (lb != null) {
79                  lb.shutdown();
80                  PowerMock.verify(eurekaClientMock);
81                  PowerMock.verify(DiscoveryClient.class);
82              }
83          }
84      }
85      @Test
86      public void testShutdownMultiple() {
87          try {
88              eurekaClientMock.registerEventListener(EasyMock.anyObject(EurekaEventListener.class));
89              EasyMock.expectLastCall().anyTimes();
90              PowerMock.replay(DiscoveryClient.class);
91              PowerMock.replay(eurekaClientMock);
92              DynamicServerListLoadBalancer<DiscoveryEnabledServer> lb1 = new DynamicServerListLoadBalancer<DiscoveryEnabledServer>(
93                      config,
94                      new AvailabilityFilteringRule(),
95                      new DummyPing(),
96                      new DiscoveryEnabledNIWSServerList(vipAddress, eurekaClientProvider),
97                      new ZoneAffinityServerListFilter<DiscoveryEnabledServer>(),
98                      new EurekaNotificationServerListUpdater(eurekaClientProvider)
99              );
100              DynamicServerListLoadBalancer<DiscoveryEnabledServer> lb2 = new DynamicServerListLoadBalancer<DiscoveryEnabledServer>(
101                      config,
102                      new AvailabilityFilteringRule(),
103                      new DummyPing(),
104                      new DiscoveryEnabledNIWSServerList(vipAddress, eurekaClientProvider),
105                      new ZoneAffinityServerListFilter<DiscoveryEnabledServer>(),
106                      new EurekaNotificationServerListUpdater(eurekaClientProvider)
107              );
108              DynamicServerListLoadBalancer<DiscoveryEnabledServer> lb3 = new DynamicServerListLoadBalancer<DiscoveryEnabledServer>(
109                      config,
110                      new AvailabilityFilteringRule(),
111                      new DummyPing(),
112                      new DiscoveryEnabledNIWSServerList(vipAddress, eurekaClientProvider),
113                      new ZoneAffinityServerListFilter<DiscoveryEnabledServer>(),
114                      new EurekaNotificationServerListUpdater(eurekaClientProvider)
115              );
116              lb3.shutdown();
117              lb1.shutdown();
118              lb2.shutdown();
119          } finally {
120              PowerMock.verify(eurekaClientMock);
121              PowerMock.verify(DiscoveryClient.class);
122          }
123      }
124      private boolean verifyFinalServerListCount(int finalCount, DynamicServerListLoadBalancer lb) throws Exception {
125          long stepSize = TimeUnit.MILLISECONDS.convert(50l, TimeUnit.MILLISECONDS);
126          long maxTime = TimeUnit.MILLISECONDS.convert(2l, TimeUnit.SECONDS);
127          for (int i = 0; i < maxTime; i += stepSize) {
128              if (finalCount == lb.getServerCount(false)) {
129                  return true;
130              } else {
131                  Thread.sleep(stepSize);
132              }
133          }
134          return false;
135      }
136      private EurekaClient setUpEurekaClientMock(List<InstanceInfo> servers) {
137          final EurekaClient eurekaClientMock = PowerMock.createMock(EurekaClient.class);
138          EasyMock.expect(eurekaClientMock.getEurekaClientConfig()).andReturn(new DefaultEurekaClientConfig()).anyTimes();
139          EasyMock
140                  .expect(eurekaClientMock.getInstancesByVipAddress(EasyMock.anyString(), EasyMock.anyBoolean(), EasyMock.anyString()))
141                  .andReturn(servers.subList(0, initialServerListSize)).times(1)
142                  .andReturn(servers.subList(initialServerListSize, servers.size())).anyTimes();
143          EasyMock
144                  .expectLastCall();
145          EasyMock
146                  .expect(eurekaClientMock.unregisterEventListener(EasyMock.isA(EurekaEventListener.class)))
147                  .andReturn(true).anyTimes();
148          return eurekaClientMock;
149      }
150  }
</code></pre>
        </div>
        <div class="column">
            <h3>jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ResultSetBuilder.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package redis.clients.jedis.graph;
2  import static java.util.Collections.emptyList;
3  import java.util.ArrayList;
4  import java.util.HashMap;
5  import java.util.Iterator;
6  import java.util.List;
7  import java.util.Map;
8  import java.util.Objects;
9  import java.util.stream.Collectors;
10  import redis.clients.jedis.Builder;
11  import redis.clients.jedis.BuilderFactory;
12  import redis.clients.jedis.exceptions.JedisDataException;
13  import redis.clients.jedis.exceptions.JedisException;
14  import redis.clients.jedis.graph.entities.*;
15  import redis.clients.jedis.util.SafeEncoder;
</span>16  class ResultSetBuilder extends Builder<ResultSet> {
17    private final GraphCache graphCache;
18    ResultSetBuilder(GraphCache cache) {
19      this.graphCache = cache;
20    }
21    @Override
22    public ResultSet build(Object data) {
23      List<Object> rawResponse = (List<Object>) data;
24      if (rawResponse.get(rawResponse.size() - 1) instanceof JedisDataException) {
25        throw (JedisDataException) rawResponse.get(rawResponse.size() - 1);
26      }
27      final Object headerObject;
28      final Object recordsObject;
29      final Object statisticsObject;
30      if (rawResponse.size() == 1) {
31        headerObject = emptyList();
32        recordsObject = emptyList();
33        statisticsObject = rawResponse.get(0);
34      } else if (rawResponse.size() == 3) {
35        headerObject = rawResponse.get(0);
36        recordsObject = rawResponse.get(1);
37        statisticsObject = rawResponse.get(2);
38      } else {
39        throw new JedisException("Unrecognized graph response format.");
40      }
41      HeaderImpl header = parseHeader(headerObject);
42      List<Record> records = parseRecords(header, recordsObject);
43      StatisticsImpl statistics = parseStatistics(statisticsObject);
44      return new ResultSetImpl(header, records, statistics);
45    }
46    private class ResultSetImpl implements ResultSet {
47      private final Header header;
48      private final List<Record> results;
49      private final Statistics statistics;
50      private ResultSetImpl(Header header, List<Record> results, Statistics statistics) {
51        this.header = header;
52        this.results = results;
53        this.statistics = statistics;
54      }
55      @Override
56      public Header getHeader() {
57        return header;
58      }
59      @Override
60      public Statistics getStatistics() {
61        return statistics;
62      }
63      @Override
64      public int size() {
65        return results.size();
66      }
67      @Override
68      public boolean equals(Object o) {
69        if (this == o) {
70          return true;
71        }
72        if (!(o instanceof ResultSetImpl)) {
73          return false;
74        }
75        ResultSetImpl resultSet = (ResultSetImpl) o;
76        return Objects.equals(getHeader(), resultSet.getHeader())
77            && Objects.equals(getStatistics(), resultSet.getStatistics())
78            && Objects.equals(results, resultSet.results);
79      }
80      @Override
81      public int hashCode() {
82        return Objects.hash(getHeader(), getStatistics(), results);
83      }
84      @Override
85      public String toString() {
86        final StringBuilder sb = new StringBuilder("ResultSetImpl{");
87        sb.append("header=").append(header);
88        sb.append(", statistics=").append(statistics);
89        sb.append(", results=").append(results);
90        sb.append('}');
91        return sb.toString();
92      }
93      @Override
94      public Iterator<Record> iterator() {
95        return results.iterator();
96      }
97    }
98    @SuppressWarnings("unchecked")
99    private List<Record> parseRecords(Header header, Object data) {
100      List<List<Object>> rawResultSet = (List<List<Object>>) data;
101      if (rawResultSet == null || rawResultSet.isEmpty()) {
102        return new ArrayList<>(0);
103      }
104      List<Record> results = new ArrayList<>(rawResultSet.size());
105      for (List<Object> row : rawResultSet) {
106        List<Object> parsedRow = new ArrayList<>(row.size());
107        for (int i = 0; i < row.size(); i++) {
108          List<Object> obj = (List<Object>) row.get(i);
109          ResultSet.ColumnType objType = header.getSchemaTypes().get(i);
110          switch (objType) {
111            case NODE:
112              parsedRow.add(deserializeNode(obj));
113              break;
114            case RELATION:
115              parsedRow.add(deserializeEdge(obj));
116              break;
117            case SCALAR:
118              parsedRow.add(deserializeScalar(obj));
119              break;
120            default:
121              parsedRow.add(null);
122              break;
123          }
124        }
125        Record record = new RecordImpl(header.getSchemaNames(), parsedRow);
126        results.add(record);
127      }
128      return results;
129    }
130    @SuppressWarnings("unchecked")
131    private Node deserializeNode(List<Object> rawNodeData) {
132      List<Long> labelsIndices = (List<Long>) rawNodeData.get(1);
133      List<List<Object>> rawProperties = (List<List<Object>>) rawNodeData.get(2);
134      Node node = new Node(labelsIndices.size(), rawProperties.size());
135      deserializeGraphEntityId(node, (Long) rawNodeData.get(0));
136      for (Long labelIndex : labelsIndices) {
137        String label = graphCache.getLabel(labelIndex.intValue());
138        node.addLabel(label);
139      }
140      deserializeGraphEntityProperties(node, rawProperties);
141      return node;
142    }
143    private void deserializeGraphEntityId(GraphEntity graphEntity, long id) {
144      graphEntity.setId(id);
145    }
146    @SuppressWarnings("unchecked")
147    private Edge deserializeEdge(List<Object> rawEdgeData) {
148      List<List<Object>> rawProperties = (List<List<Object>>) rawEdgeData.get(4);
149      Edge edge = new Edge(rawProperties.size());
150      deserializeGraphEntityId(edge, (Long) rawEdgeData.get(0));
151      String relationshipType = graphCache.getRelationshipType(((Long) rawEdgeData.get(1)).intValue());
152      edge.setRelationshipType(relationshipType);
153      edge.setSource((long) rawEdgeData.get(2));
154      edge.setDestination((long) rawEdgeData.get(3));
155      deserializeGraphEntityProperties(edge, rawProperties);
156      return edge;
157    }
158    private void deserializeGraphEntityProperties(GraphEntity entity, List<List<Object>> rawProperties) {
159      for (List<Object> rawProperty : rawProperties) {
160        String name = graphCache.getPropertyName(((Long) rawProperty.get(0)).intValue());
161        List<Object> propertyScalar = rawProperty.subList(1, rawProperty.size());
162        entity.addProperty(name, deserializeScalar(propertyScalar));
163      }
164    }
165    @SuppressWarnings("unchecked")
166    private Object deserializeScalar(List<Object> rawScalarData) {
167      ScalarType type = getValueTypeFromObject(rawScalarData.get(0));
168      Object obj = rawScalarData.get(1);
169      switch (type) {
170        case NULL:
171          return null;
172        case BOOLEAN:
173          return Boolean.parseBoolean(SafeEncoder.encode((byte[]) obj));
174        case DOUBLE:
175          return BuilderFactory.DOUBLE.build(obj);
176        case INTEGER:
177          return (Long) obj;
178        case STRING:
179          return SafeEncoder.encode((byte[]) obj);
180        case ARRAY:
181          return deserializeArray(obj);
182        case NODE:
183          return deserializeNode((List<Object>) obj);
184        case EDGE:
185          return deserializeEdge((List<Object>) obj);
186        case PATH:
187          return deserializePath(obj);
188        case MAP:
189          return deserializeMap(obj);
190        case POINT:
191          return deserializePoint(obj);
192        case UNKNOWN:
193        default:
194          return obj;
195      }
196    }
197    private Object deserializePoint(Object rawScalarData) {
198      return new Point(BuilderFactory.DOUBLE_LIST.build(rawScalarData));
199    }
200    @SuppressWarnings("unchecked")
201    private Map<String, Object> deserializeMap(Object rawScalarData) {
202      List<Object> keyTypeValueEntries = (List<Object>) rawScalarData;
203      int size = keyTypeValueEntries.size();
204      Map<String, Object> map = new HashMap<>(size >> 1); 
205      for (int i = 0; i < size; i += 2) {
206        String key = SafeEncoder.encode((byte[]) keyTypeValueEntries.get(i));
207        Object value = deserializeScalar((List<Object>) keyTypeValueEntries.get(i + 1));
208        map.put(key, value);
209      }
210      return map;
211    }
212    @SuppressWarnings("unchecked")
213    private Path deserializePath(Object rawScalarData) {
214      List<List<Object>> array = (List<List<Object>>) rawScalarData;
215      List<Node> nodes = (List<Node>) deserializeScalar(array.get(0));
216      List<Edge> edges = (List<Edge>) deserializeScalar(array.get(1));
217      return new Path(nodes, edges);
218    }
219    @SuppressWarnings("unchecked")
220    private List<Object> deserializeArray(Object rawScalarData) {
221      List<List<Object>> array = (List<List<Object>>) rawScalarData;
222      List<Object> res = new ArrayList<>(array.size());
223      for (List<Object> arrayValue : array) {
224        res.add(deserializeScalar(arrayValue));
225      }
226      return res;
227    }
228    private ScalarType getValueTypeFromObject(Object rawScalarType) {
229      return getScalarType(((Long) rawScalarType).intValue());
230    }
231    private static enum ScalarType {
232      UNKNOWN,
233      NULL,
234      STRING,
235      INTEGER, 
236      BOOLEAN,
237      DOUBLE,
238      ARRAY,
239      EDGE,
240      NODE,
241      PATH,
242      MAP,
243      POINT;
244    }
245    private static final ScalarType[] SCALAR_TYPES = ScalarType.values();
246    private static ScalarType getScalarType(int index) {
247      try {
248        return SCALAR_TYPES[index];
249      } catch (IndexOutOfBoundsException e) {
250        throw new JedisException("Unrecognized response type");
251      }
252    }
253    private class RecordImpl implements Record {
254      private final List<String> header;
255      private final List<Object> values;
256      public RecordImpl(List<String> header, List<Object> values) {
257        this.header = header;
258        this.values = values;
259      }
260      @Override
261      public <T> T getValue(int index) {
262        return (T) this.values.get(index);
263      }
264      @Override
265      public <T> T getValue(String key) {
266        return getValue(this.header.indexOf(key));
267      }
268      @Override
269      public String getString(int index) {
270        return this.values.get(index).toString();
271      }
272      @Override
273      public String getString(String key) {
274        return getString(this.header.indexOf(key));
275      }
276      @Override
277      public List<String> keys() {
278        return header;
279      }
280      @Override
281      public List<Object> values() {
282        return this.values;
283      }
284      @Override
285      public boolean containsKey(String key) {
286        return this.header.contains(key);
287      }
288      @Override
289      public int size() {
290        return this.header.size();
291      }
292      @Override
293      public boolean equals(Object o) {
294        if (this == o) {
295          return true;
296        }
297        if (!(o instanceof RecordImpl)) {
298          return false;
299        }
300        RecordImpl record = (RecordImpl) o;
301        return Objects.equals(header, record.header)
302            && Objects.equals(values, record.values);
303      }
304      @Override
305      public int hashCode() {
306        return Objects.hash(header, values);
307      }
308      @Override
309      public String toString() {
310        final StringBuilder sb = new StringBuilder("Record{");
311        sb.append("values=").append(values);
312        sb.append('}');
313        return sb.toString();
314      }
315    }
316    private static final ResultSet.ColumnType[] COLUMN_TYPES = ResultSet.ColumnType.values();
317    private class HeaderImpl implements Header {
318      private final List<ResultSet.ColumnType> schemaTypes;
319      private final List<String> schemaNames;
320      private HeaderImpl() {
321        this.schemaTypes = emptyList();
322        this.schemaNames = emptyList();
323      }
324      private HeaderImpl(List<ResultSet.ColumnType> schemaTypes, List<String> schemaNames) {
325        this.schemaTypes = schemaTypes;
326        this.schemaNames = schemaNames;
327      }
328      @Override
329      public List<String> getSchemaNames() {
330        return schemaNames;
331      }
332      @Override
333      public List<ResultSet.ColumnType> getSchemaTypes() {
334        return schemaTypes;
335      }
336      @Override
337      public boolean equals(Object o) {
338        if (this == o) {
339          return true;
340        }
341        if (!(o instanceof HeaderImpl)) {
342          return false;
343        }
344        HeaderImpl header = (HeaderImpl) o;
345        return Objects.equals(getSchemaTypes(), header.getSchemaTypes())
346            && Objects.equals(getSchemaNames(), header.getSchemaNames());
347      }
348      @Override
349      public int hashCode() {
350        return Objects.hash(getSchemaTypes(), getSchemaNames());
351      }
352      @Override
353      public String toString() {
354        final StringBuilder sb = new StringBuilder("HeaderImpl{");
355        sb.append("schemaTypes=").append(schemaTypes);
356        sb.append(", schemaNames=").append(schemaNames);
357        sb.append('}');
358        return sb.toString();
359      }
360    }
361    private HeaderImpl parseHeader(Object data) {
362      if (data == null) {
363        return new HeaderImpl();
364      }
365      List<List<Object>> list = (List<List<Object>>) data;
366      List<ResultSet.ColumnType> types = new ArrayList<>(list.size());
367      List<String> texts = new ArrayList<>(list.size());
368      for (List<Object> tuple : list) {
369        types.add(COLUMN_TYPES[((Long) tuple.get(0)).intValue()]);
370        texts.add(SafeEncoder.encode((byte[]) tuple.get(1)));
371      }
372      return new HeaderImpl(types, texts);
373    }
374    private class StatisticsImpl implements Statistics {
375      private final Map<String, String> statistics;
376      private StatisticsImpl(Map<String, String> statistics) {
377        this.statistics = statistics;
378      }
379      public String getStringValue(String label) {
380        return statistics.get(label);
381      }
382      private int getIntValue(String label) {
383        String value = getStringValue(label);
384        return value == null ? 0 : Integer.parseInt(value);
385      }
386      @Override
387      public int nodesCreated() {
388        return getIntValue("Nodes created");
389      }
390      @Override
391      public int nodesDeleted() {
392        return getIntValue("Nodes deleted");
393      }
394      @Override
395      public int indicesCreated() {
396        return getIntValue("Indices created");
397      }
398      @Override
399      public int indicesDeleted() {
400        return getIntValue("Indices deleted");
401      }
402      @Override
403      public int labelsAdded() {
404        return getIntValue("Labels added");
405      }
406      @Override
407      public int relationshipsDeleted() {
408        return getIntValue("Relationships deleted");
409      }
410      @Override
411      public int relationshipsCreated() {
412        return getIntValue("Relationships created");
413      }
414      @Override
415      public int propertiesSet() {
416        return getIntValue("Properties set");
417      }
418      @Override
419      public boolean cachedExecution() {
420        return "1".equals(getStringValue("Cached execution"));
421      }
422      @Override
423      public String queryIntervalExecutionTime() {
424        return getStringValue("Query internal execution time");
425      }
426      @Override
427      public boolean equals(Object o) {
428        if (this == o) {
429          return true;
430        }
431        if (!(o instanceof StatisticsImpl)) {
432          return false;
433        }
434        StatisticsImpl that = (StatisticsImpl) o;
435        return Objects.equals(statistics, that.statistics);
436      }
437      @Override
438      public int hashCode() {
439        return Objects.hash(statistics);
440      }
441      @Override
442      public String toString() {
443        final StringBuilder sb = new StringBuilder("Statistics{");
444        sb.append(statistics);
445        sb.append('}');
446        return sb.toString();
447      }
448    }
449    private StatisticsImpl parseStatistics(Object data) {
450      Map<String, String> map = ((List<byte[]>) data).stream()
451          .map(SafeEncoder::encode).map(s -> s.split(": "))
452          .collect(Collectors.toMap(sa -> sa[0], sa -> sa[1]));
453      return new StatisticsImpl(map);
454    }
455  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ribbon-MDEwOlJlcG9zaXRvcnk3NjE2MTU4-flat-EurekaDynamicServerListLoadBalancerTest.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from jedis-MDEwOlJlcG9zaXRvcnk3MTU2MDU=-flat-ResultSetBuilder.java</div>
                <div class="column column_space"><pre><code>1  package com.netflix.loadbalancer;
2  import com.netflix.appinfo.InstanceInfo;
3  import com.netflix.client.config.CommonClientConfigKey;
4  import com.netflix.client.config.DefaultClientConfigImpl;
5  import com.netflix.discovery.CacheRefreshedEvent;
6  import com.netflix.discovery.DefaultEurekaClientConfig;
7  import com.netflix.discovery.DiscoveryClient;
8  import com.netflix.discovery.EurekaClient;
9  import com.netflix.discovery.EurekaEventListener;
10  import com.netflix.discovery.util.InstanceInfoGenerator;
11  import com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList;
12  import com.netflix.niws.loadbalancer.DiscoveryEnabledServer;
13  import com.netflix.niws.loadbalancer.EurekaNotificationServerListUpdater;
14  import org.easymock.Capture;
15  import org.easymock.EasyMock;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package redis.clients.jedis.graph;
2  import static java.util.Collections.emptyList;
3  import java.util.ArrayList;
4  import java.util.HashMap;
5  import java.util.Iterator;
6  import java.util.List;
7  import java.util.Map;
8  import java.util.Objects;
9  import java.util.stream.Collectors;
10  import redis.clients.jedis.Builder;
11  import redis.clients.jedis.BuilderFactory;
12  import redis.clients.jedis.exceptions.JedisDataException;
13  import redis.clients.jedis.exceptions.JedisException;
14  import redis.clients.jedis.graph.entities.*;
15  import redis.clients.jedis.util.SafeEncoder;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    