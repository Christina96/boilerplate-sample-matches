
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.442176870748299%, Tokens: 12</h2>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-SerializeTest.java</h3>
            <pre><code>1  package com.weibo.api.motan.benchmark;
2  import java.io.Serializable;
3  import java.util.Map;
4  import com.weibo.api.motan.codec.Serialization;
5  import com.weibo.api.motan.serialize.FastJsonSerialization;
6  import com.weibo.api.motan.serialize.Hessian2Serialization;
7  public class SerializeTest {
8      private static final int loop = 10000;
9      public static void main(String[] args) throws Exception {
10          Hessian2Serialization hession = new Hessian2Serialization();
11          FastJsonSerialization fastjson = new FastJsonSerialization();
12          SerializeObject object = new SerializeObject();
13          object.setHello("hello world");
14          object.setAge(1000000L);
15          object.setArr(new int[20]);
16          object.setArr2(new int[2][20]);
17          for (int i = 0; i < loop; i++) {
18              hession.serialize(object);
19              fastjson.serialize(object);
20          }
21          byte[] fastjsonBytes = fastjson.serialize(object);
22          byte[] hessionBytes = hession.serialize(object);
23          for (int i = 0; i < loop; i++) {
24              hession.deserialize(hessionBytes, object.getClass());
25              fastjson.deserialize(fastjsonBytes, object.getClass());
26          }
27          costtime(hession, object);
<span onclick='openModal()' class='match'>28          costtime(fastjson, object);
29          System.out.println("~~~~~~~~~~~~~~~~~~~~\n");
30          System.out.println("Hessian2Serialization serialize size: " + hessionBytes.length);
31          costtime(hession, object);
32          System.out.println("FastJsonSerialization serialize size: " + fastjsonBytes.length);
33          costtime(fastjson, object);
34      }
35      public static void costtime(Serialization serialization, Object object) throws Exception {
36          long start = System.nanoTime();
</span>37          for (int i = 0; i < loop; i++) {
38              serialization.serialize(object);
39          }
40          long cost = System.nanoTime() - start;
41          System.out.println(serialization.getClass().getSimpleName() + " serialize costtime: " + cost / loop + "ns");
42          byte[] bytes = serialization.serialize(object);
43          start = System.nanoTime();
44          for (int i = 0; i < loop; i++) {
45              serialization.deserialize(bytes, object.getClass());
46          }
47          cost = System.nanoTime() - start;
48          System.out.println(serialization.getClass().getSimpleName() + " deserialize costtime: " + cost / loop + "ns");
49      }
50  }
51  class SerializeObject implements Serializable {
52      private static final long serialVersionUID = 2366873906296131107L;
53      private long age;
54      private String hello;
55      private int[] arr;
56      private int[][] arr2;
57      private Map<String, Object> obj;
58      public SerializeObject() {}
59      public void setAge(long age) {
60          this.age = age;
61      }
62      public void setHello(String hello) {
63          this.hello = hello;
64      }
65      public void setArr(int[] arr) {
66          this.arr = arr;
67      }
68      public void setArr2(int[][] arr2) {
69          this.arr2 = arr2;
70      }
71      public long getAge() {
72          return age;
73      }
74      public String getHello() {
75          return hello;
76      }
77      public int[] getArr() {
78          return arr;
79      }
80      public int[][] getArr2() {
81          return arr2;
82      }
83      public Map<String, Object> getObj() {
84          return obj;
85      }
86      public void setObj(Map<String, Object> obj) {
87          this.obj = obj;
88      }
89  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyChannelHandler_10.java</h3>
            <pre><code>1  package com.weibo.api.motan.transport.netty4;
2  import com.weibo.api.motan.codec.Codec;
3  import com.weibo.api.motan.common.MotanConstants;
4  import com.weibo.api.motan.common.URLParamType;
5  import com.weibo.api.motan.core.extension.ExtensionLoader;
6  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
7  import com.weibo.api.motan.exception.MotanFrameworkException;
8  import com.weibo.api.motan.exception.MotanServiceException;
9  import com.weibo.api.motan.protocol.rpc.RpcProtocolVersion;
10  import com.weibo.api.motan.rpc.DefaultResponse;
11  import com.weibo.api.motan.rpc.Request;
12  import com.weibo.api.motan.rpc.Response;
13  import com.weibo.api.motan.rpc.RpcContext;
14  import com.weibo.api.motan.transport.Channel;
15  import com.weibo.api.motan.transport.MessageHandler;
16  import com.weibo.api.motan.util.LoggerUtil;
17  import com.weibo.api.motan.util.MotanFrameworkUtil;
18  import com.weibo.api.motan.util.NetUtils;
19  import io.netty.channel.ChannelDuplexHandler;
20  import io.netty.channel.ChannelFuture;
21  import io.netty.channel.ChannelFutureListener;
22  import io.netty.channel.ChannelHandlerContext;
23  import java.net.InetSocketAddress;
24  import java.net.SocketAddress;
25  import java.util.concurrent.RejectedExecutionException;
26  import java.util.concurrent.ThreadPoolExecutor;
27  public class NettyChannelHandler extends ChannelDuplexHandler {
28      private ThreadPoolExecutor threadPoolExecutor;
29      private MessageHandler messageHandler;
30      private Channel channel;
31      private Codec codec;
32      public NettyChannelHandler(Channel channel, MessageHandler messageHandler) {
33          this.channel = channel;
34          this.messageHandler = messageHandler;
35          codec = ExtensionLoader.getExtensionLoader(Codec.class).getExtension(channel.getUrl().getParameter(URLParamType.codec.getName(), URLParamType.codec.getValue()));
36      }
37      public NettyChannelHandler(Channel channel, MessageHandler messageHandler,
38                                 ThreadPoolExecutor threadPoolExecutor) {
39          this.channel = channel;
40          this.messageHandler = messageHandler;
41          this.threadPoolExecutor = threadPoolExecutor;
<span onclick='openModal()' class='match'>42          codec = ExtensionLoader.getExtensionLoader(Codec.class).getExtension(channel.getUrl().getParameter(URLParamType.codec.getName(), URLParamType.codec.getValue()));
43      }
44      private String getRemoteIp(ChannelHandlerContext ctx) {
45          String ip = "";
46          SocketAddress remote = ctx.channel().remoteAddress();
</span>47          if (remote != null) {
48              try {
49                  ip = ((InetSocketAddress) remote).getAddress().getHostAddress();
50              } catch (Exception e) {
51                  LoggerUtil.warn("get remoteIp error! default will use. msg:{}, remote:{}", e.getMessage(), remote.toString());
52              }
53          }
54          return ip;
55      }
56      @Override
57      public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
58          if (msg instanceof NettyMessage) {
59              if (threadPoolExecutor != null) {
60                  try {
61                      threadPoolExecutor.execute(() -> processMessage(ctx, ((NettyMessage) msg)));
62                  } catch (RejectedExecutionException rejectException) {
63                      if (((NettyMessage) msg).isRequest()) {
64                          rejectMessage(ctx, (NettyMessage) msg);
65                      } else {
66                          LoggerUtil.warn("process thread pool is full, run in io thread, active={} poolSize={} corePoolSize={} maxPoolSize={} taskCount={} requestId={}",
67                                  threadPoolExecutor.getActiveCount(), threadPoolExecutor.getPoolSize(), threadPoolExecutor.getCorePoolSize(),
68                                  threadPoolExecutor.getMaximumPoolSize(), threadPoolExecutor.getTaskCount(), ((NettyMessage) msg).getRequestId());
69                          processMessage(ctx, (NettyMessage) msg);
70                      }
71                  }
72              } else {
73                  processMessage(ctx, (NettyMessage) msg);
74              }
75          } else {
76              LoggerUtil.error("NettyChannelHandler messageReceived type not support: class=" + msg.getClass());
77              throw new MotanFrameworkException("NettyChannelHandler messageReceived type not support: class=" + msg.getClass());
78          }
79      }
80      private void rejectMessage(ChannelHandlerContext ctx, NettyMessage msg) {
81          if (msg.isRequest()) {
82              sendResponse(ctx, MotanFrameworkUtil.buildErrorResponse(msg.getRequestId(), msg.getVersion().getVersion(), new MotanServiceException("process thread pool is full, reject by server: " + ctx.channel().localAddress(), MotanErrorMsgConstant.SERVICE_REJECT, false)));
83              LoggerUtil.error("process thread pool is full, reject, active={} poolSize={} corePoolSize={} maxPoolSize={} taskCount={} requestId={}",
84                      threadPoolExecutor.getActiveCount(), threadPoolExecutor.getPoolSize(), threadPoolExecutor.getCorePoolSize(),
85                      threadPoolExecutor.getMaximumPoolSize(), threadPoolExecutor.getTaskCount(), msg.getRequestId());
86              if (channel instanceof NettyServer) {
87                  ((NettyServer) channel).getRejectCounter().incrementAndGet();
88              }
89          }
90      }
91      private void processMessage(ChannelHandlerContext ctx, NettyMessage msg) {
92          long startTime = System.currentTimeMillis();
93          String remoteIp = getRemoteIp(ctx);
94          Object result;
95          try {
96              result = codec.decode(channel, remoteIp, msg.getData());
97          } catch (Exception e) {
98              LoggerUtil.error("NettyDecoder decode fail! requestId" + msg.getRequestId() + ", size:" + msg.getData().length + ", ip:" + remoteIp + ", e:" + e.getMessage());
99              Response response = MotanFrameworkUtil.buildErrorResponse(msg.getRequestId(), msg.getVersion().getVersion(), e);
100              if (msg.isRequest()) {
101                  sendResponse(ctx, response);
102              } else {
103                  processResponse(response);
104              }
105              return;
106          }
107          long length = msg.getData().length;
108          if (RpcProtocolVersion.VERSION_1 == msg.getVersion() || RpcProtocolVersion.VERSION_1_Compress == msg.getVersion()) {
109              length += RpcProtocolVersion.VERSION_1.getHeaderLength();
110          }
111          if (result instanceof Request) {
112              Request request = (Request) result;
113              MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_SRECEIVE, msg.getStartTime());
114              MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_SEXECUTOR_START, startTime);
115              MotanFrameworkUtil.logEvent(request, MotanConstants.TRACE_SDECODE);
116              request.setAttachment(MotanConstants.CONTENT_LENGTH, String.valueOf(length));
117              processRequest(ctx, request);
118          } else if (result instanceof Response) {
119              Response response = (Response) result;
120              MotanFrameworkUtil.logEvent(response, MotanConstants.TRACE_CRECEIVE, msg.getStartTime());
121              MotanFrameworkUtil.logEvent(response, MotanConstants.TRACE_CDECODE);
122              response.setAttachment(MotanConstants.CONTENT_LENGTH, String.valueOf(length));
123              processResponse(result);
124          }
125      }
126      private void processRequest(final ChannelHandlerContext ctx, final Request request) {
127          request.setAttachment(URLParamType.host.getName(), NetUtils.getHostName(ctx.channel().remoteAddress()));
128          final long processStartTime = System.currentTimeMillis();
129          try {
130              RpcContext.init(request);
131              Object result;
132              try {
133                  result = messageHandler.handle(channel, request);
134              } catch (Exception e) {
135                  LoggerUtil.error("NettyChannelHandler processRequest fail! request:" + MotanFrameworkUtil.toString(request), e);
136                  result = MotanFrameworkUtil.buildErrorResponse(request, new MotanServiceException("process request fail. errMsg:" + e.getMessage()));
137              }
138              if (result instanceof Response) {
139                  MotanFrameworkUtil.logEvent((Response) result, MotanConstants.TRACE_PROCESS);
140              }
141              final DefaultResponse response;
142              if (result instanceof DefaultResponse) {
143                  response = (DefaultResponse) result;
144              } else {
145                  response = new DefaultResponse(result);
146              }
147              response.setRpcProtocolVersion(request.getRpcProtocolVersion());
148              response.setRequestId(request.getRequestId());
149              response.setProcessTime(System.currentTimeMillis() - processStartTime);
150              ChannelFuture channelFuture = sendResponse(ctx, response);
151              if (channelFuture != null) {
152                  channelFuture.addListener((ChannelFutureListener) future -> {
153                      MotanFrameworkUtil.logEvent(response, MotanConstants.TRACE_SSEND, System.currentTimeMillis());
154                      response.onFinish();
155                  });
156              } else { 
157                  response.onFinish();
158              }
159          } finally {
160              RpcContext.destroy();
161          }
162      }
163      private ChannelFuture sendResponse(ChannelHandlerContext ctx, Response response) {
164          byte[] msg = CodecUtil.encodeObjectToBytes(channel, codec, response);
165          response.setAttachment(MotanConstants.CONTENT_LENGTH, String.valueOf(msg.length));
166          if (ctx.channel().isActive()) {
167              return ctx.channel().writeAndFlush(msg);
168          }
169          return null;
170      }
171      private void processResponse(Object msg) {
172          messageHandler.handle(channel, msg);
173      }
174      @Override
175      public void channelActive(ChannelHandlerContext ctx) throws Exception {
176          LoggerUtil.info("NettyChannelHandler channelActive: remote={} local={}", ctx.channel().remoteAddress(), ctx.channel().localAddress());
177          ctx.fireChannelActive();
178      }
179      @Override
180      public void channelInactive(ChannelHandlerContext ctx) throws Exception {
181          LoggerUtil.info("NettyChannelHandler channelInactive: remote={} local={}", ctx.channel().remoteAddress(), ctx.channel().localAddress());
182          ctx.fireChannelInactive();
183      }
184      @Override
185      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
186          LoggerUtil.error("NettyChannelHandler exceptionCaught: remote={} local={} event={}", ctx.channel().remoteAddress(), ctx.channel().localAddress(), cause.getMessage(), cause);
187          ctx.channel().close();
188      }
189  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-SerializeTest.java</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-NettyChannelHandler_10.java</div>
                <div class="column column_space"><pre><code>28          costtime(fastjson, object);
29          System.out.println("~~~~~~~~~~~~~~~~~~~~\n");
30          System.out.println("Hessian2Serialization serialize size: " + hessionBytes.length);
31          costtime(hession, object);
32          System.out.println("FastJsonSerialization serialize size: " + fastjsonBytes.length);
33          costtime(fastjson, object);
34      }
35      public static void costtime(Serialization serialization, Object object) throws Exception {
36          long start = System.nanoTime();
</pre></code></div>
                <div class="column column_space"><pre><code>42          codec = ExtensionLoader.getExtensionLoader(Codec.class).getExtension(channel.getUrl().getParameter(URLParamType.codec.getName(), URLParamType.codec.getValue()));
43      }
44      private String getRemoteIp(ChannelHandlerContext ctx) {
45          String ip = "";
46          SocketAddress remote = ctx.channel().remoteAddress();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    