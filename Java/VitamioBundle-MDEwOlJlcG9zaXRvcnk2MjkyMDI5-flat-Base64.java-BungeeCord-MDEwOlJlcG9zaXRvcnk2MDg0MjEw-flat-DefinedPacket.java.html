
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Base64.java</h3>
            <pre><code>1  package io.vov.vitamio.utils;
2  import java.io.UnsupportedEncodingException;
3  public class Base64 {
4      public static final int DEFAULT = 0;
5      public static final int NO_PADDING = 1;
6      public static final int NO_WRAP = 2;
7      public static final int CRLF = 4;
8      public static final int URL_SAFE = 8;
9      public static final int NO_CLOSE = 16;
10       static abstract class Coder {
11          public byte[] output;
12          public int op;
13          public abstract boolean process(byte[] input, int offset, int len, boolean finish);
14          public abstract int maxOutputSize(int len);
15      }
<span onclick='openModal()' class='match'>16      public static byte[] decode(String str, int flags) {
17          return decode(str.getBytes(), flags);
</span>18      }
19      public static byte[] decode(byte[] input, int flags) {
20          return decode(input, 0, input.length, flags);
21      }
22      public static byte[] decode(byte[] input, int offset, int len, int flags) {
23          Decoder decoder = new Decoder(flags, new byte[len*3/4]);
24          if (!decoder.process(input, offset, len, true)) {
25              throw new IllegalArgumentException("bad base-64");
26          }
27          if (decoder.op == decoder.output.length) {
28              return decoder.output;
29          }
30          byte[] temp = new byte[decoder.op];
31          System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
32          return temp;
33      }
34       static class Decoder extends Coder {
35          private static final int DECODE[] = {
36              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
37              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
38              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
39              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
40              -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
41              15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
42              -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
43              41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
44              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
45              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
46              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
47              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
48              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
49              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
50              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
51              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
52          };
53          private static final int DECODE_WEBSAFE[] = {
54              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
55              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
56              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
57              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
58              -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
59              15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
60              -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
61              41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
62              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
63              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
64              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
65              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
66              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
67              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
68              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
69              -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
70          };
71          private static final int SKIP = -1;
72          private static final int EQUALS = -2;
73          private int state;   
74          private int value;
75          final private int[] alphabet;
76          public Decoder(int flags, byte[] output) {
77              this.output = output;
78              alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
79              state = 0;
80              value = 0;
81          }
82          public int maxOutputSize(int len) {
83              return len * 3/4 + 10;
84          }
85          public boolean process(byte[] input, int offset, int len, boolean finish) {
86              if (this.state == 6) return false;
87              int p = offset;
88              len += offset;
89              int state = this.state;
90              int value = this.value;
91              int op = 0;
92              final byte[] output = this.output;
93              final int[] alphabet = this.alphabet;
94              while (p < len) {
95                  if (state == 0) {
96                      while (p+4 <= len &&
97                             (value = ((alphabet[input[p] & 0xff] << 18) |
98                                       (alphabet[input[p+1] & 0xff] << 12) |
99                                       (alphabet[input[p+2] & 0xff] << 6) |
100                                       (alphabet[input[p+3] & 0xff]))) >= 0) {
101                          output[op+2] = (byte) value;
102                          output[op+1] = (byte) (value >> 8);
103                          output[op] = (byte) (value >> 16);
104                          op += 3;
105                          p += 4;
106                      }
107                      if (p >= len) break;
108                  }
109                  int d = alphabet[input[p++] & 0xff];
110                  switch (state) {
111                  case 0:
112                      if (d >= 0) {
113                          value = d;
114                          ++state;
115                      } else if (d != SKIP) {
116                          this.state = 6;
117                          return false;
118                      }
119                      break;
120                  case 1:
121                      if (d >= 0) {
122                          value = (value << 6) | d;
123                          ++state;
124                      } else if (d != SKIP) {
125                          this.state = 6;
126                          return false;
127                      }
128                      break;
129                  case 2:
130                      if (d >= 0) {
131                          value = (value << 6) | d;
132                          ++state;
133                      } else if (d == EQUALS) {
134                          output[op++] = (byte) (value >> 4);
135                          state = 4;
136                      } else if (d != SKIP) {
137                          this.state = 6;
138                          return false;
139                      }
140                      break;
141                  case 3:
142                      if (d >= 0) {
143                          value = (value << 6) | d;
144                          output[op+2] = (byte) value;
145                          output[op+1] = (byte) (value >> 8);
146                          output[op] = (byte) (value >> 16);
147                          op += 3;
148                          state = 0;
149                      } else if (d == EQUALS) {
150                          output[op+1] = (byte) (value >> 2);
151                          output[op] = (byte) (value >> 10);
152                          op += 2;
153                          state = 5;
154                      } else if (d != SKIP) {
155                          this.state = 6;
156                          return false;
157                      }
158                      break;
159                  case 4:
160                      if (d == EQUALS) {
161                          ++state;
162                      } else if (d != SKIP) {
163                          this.state = 6;
164                          return false;
165                      }
166                      break;
167                  case 5:
168                      if (d != SKIP) {
169                          this.state = 6;
170                          return false;
171                      }
172                      break;
173                  }
174              }
175              if (!finish) {
176                  this.state = state;
177                  this.value = value;
178                  this.op = op;
179                  return true;
180              }
181              switch (state) {
182              case 0:
183                  break;
184              case 1:
185                  this.state = 6;
186                  return false;
187              case 2:
188                  output[op++] = (byte) (value >> 4);
189                  break;
190              case 3:
191                  output[op++] = (byte) (value >> 10);
192                  output[op++] = (byte) (value >> 2);
193                  break;
194              case 4:
195                  this.state = 6;
196                  return false;
197              case 5:
198                  break;
199              }
200              this.state = state;
201              this.op = op;
202              return true;
203          }
204      }
205      public static String encodeToString(byte[] input, int flags) {
206          try {
207              return new String(encode(input, flags), "US-ASCII");
208          } catch (UnsupportedEncodingException e) {
209              throw new AssertionError(e);
210          }
211      }
212      public static String encodeToString(byte[] input, int offset, int len, int flags) {
213          try {
214              return new String(encode(input, offset, len, flags), "US-ASCII");
215          } catch (UnsupportedEncodingException e) {
216              throw new AssertionError(e);
217          }
218      }
219      public static byte[] encode(byte[] input, int flags) {
220          return encode(input, 0, input.length, flags);
221      }
222      public static byte[] encode(byte[] input, int offset, int len, int flags) {
223          Encoder encoder = new Encoder(flags, null);
224          int output_len = len / 3 * 4;
225          if (encoder.do_padding) {
226              if (len % 3 > 0) {
227                  output_len += 4;
228              }
229          } else {
230              switch (len % 3) {
231                  case 0: break;
232                  case 1: output_len += 2; break;
233                  case 2: output_len += 3; break;
234              }
235          }
236          if (encoder.do_newline && len > 0) {
237              output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
238                  (encoder.do_cr ? 2 : 1);
239          }
240          encoder.output = new byte[output_len];
241          encoder.process(input, offset, len, true);
242          assert encoder.op == output_len;
243          return encoder.output;
244      }
245       static class Encoder extends Coder {
246          public static final int LINE_GROUPS = 19;
247          private static final byte ENCODE[] = {
248              'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
249              'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
250              'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
251              'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
252          };
253          private static final byte ENCODE_WEBSAFE[] = {
254              'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
255              'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
256              'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
257              'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
258          };
259          final private byte[] tail;
260           int tailLen;
261          private int count;
262          final public boolean do_padding;
263          final public boolean do_newline;
264          final public boolean do_cr;
265          final private byte[] alphabet;
266          public Encoder(int flags, byte[] output) {
267              this.output = output;
268              do_padding = (flags & NO_PADDING) == 0;
269              do_newline = (flags & NO_WRAP) == 0;
270              do_cr = (flags & CRLF) != 0;
271              alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
272              tail = new byte[2];
273              tailLen = 0;
274              count = do_newline ? LINE_GROUPS : -1;
275          }
276          public int maxOutputSize(int len) {
277              return len * 8/5 + 10;
278          }
279          public boolean process(byte[] input, int offset, int len, boolean finish) {
280              final byte[] alphabet = this.alphabet;
281              final byte[] output = this.output;
282              int op = 0;
283              int count = this.count;
284              int p = offset;
285              len += offset;
286              int v = -1;
287              switch (tailLen) {
288                  case 0:
289                      break;
290                  case 1:
291                      if (p+2 <= len) {
292                          v = ((tail[0] & 0xff) << 16) |
293                              ((input[p++] & 0xff) << 8) |
294                              (input[p++] & 0xff);
295                          tailLen = 0;
296                      };
297                      break;
298                  case 2:
299                      if (p+1 <= len) {
300                          v = ((tail[0] & 0xff) << 16) |
301                              ((tail[1] & 0xff) << 8) |
302                              (input[p++] & 0xff);
303                          tailLen = 0;
304                      }
305                      break;
306              }
307              if (v != -1) {
308                  output[op++] = alphabet[(v >> 18) & 0x3f];
309                  output[op++] = alphabet[(v >> 12) & 0x3f];
310                  output[op++] = alphabet[(v >> 6) & 0x3f];
311                  output[op++] = alphabet[v & 0x3f];
312                  if (--count == 0) {
313                      if (do_cr) output[op++] = '\r';
314                      output[op++] = '\n';
315                      count = LINE_GROUPS;
316                  }
317              }
318              while (p+3 <= len) {
319                  v = ((input[p] & 0xff) << 16) |
320                      ((input[p+1] & 0xff) << 8) |
321                      (input[p+2] & 0xff);
322                  output[op] = alphabet[(v >> 18) & 0x3f];
323                  output[op+1] = alphabet[(v >> 12) & 0x3f];
324                  output[op+2] = alphabet[(v >> 6) & 0x3f];
325                  output[op+3] = alphabet[v & 0x3f];
326                  p += 3;
327                  op += 4;
328                  if (--count == 0) {
329                      if (do_cr) output[op++] = '\r';
330                      output[op++] = '\n';
331                      count = LINE_GROUPS;
332                  }
333              }
334              if (finish) {
335                  if (p-tailLen == len-1) {
336                      int t = 0;
337                      v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
338                      tailLen -= t;
339                      output[op++] = alphabet[(v >> 6) & 0x3f];
340                      output[op++] = alphabet[v & 0x3f];
341                      if (do_padding) {
342                          output[op++] = '=';
343                          output[op++] = '=';
344                      }
345                      if (do_newline) {
346                          if (do_cr) output[op++] = '\r';
347                          output[op++] = '\n';
348                      }
349                  } else if (p-tailLen == len-2) {
350                      int t = 0;
351                      v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
352                          (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
353                      tailLen -= t;
354                      output[op++] = alphabet[(v >> 12) & 0x3f];
355                      output[op++] = alphabet[(v >> 6) & 0x3f];
356                      output[op++] = alphabet[v & 0x3f];
357                      if (do_padding) {
358                          output[op++] = '=';
359                      }
360                      if (do_newline) {
361                          if (do_cr) output[op++] = '\r';
362                          output[op++] = '\n';
363                      }
364                  } else if (do_newline && op > 0 && count != LINE_GROUPS) {
365                      if (do_cr) output[op++] = '\r';
366                      output[op++] = '\n';
367                  }
368                  assert tailLen == 0;
369                  assert p == len;
370              } else {
371                  if (p == len-1) {
372                      tail[tailLen++] = input[p];
373                  } else if (p == len-2) {
374                      tail[tailLen++] = input[p];
375                      tail[tailLen++] = input[p+1];
376                  }
377              }
378              this.op = op;
379              this.count = count;
380              return true;
381          }
382      }
383      private Base64() { }   
384  }
</code></pre>
        </div>
        <div class="column">
            <h3>BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DefinedPacket.java</h3>
            <pre><code>1  package net.md_5.bungee.protocol;
2  import com.google.common.base.Charsets;
3  import com.google.common.base.Preconditions;
4  import io.netty.buffer.ByteBuf;
5  import io.netty.buffer.ByteBufInputStream;
6  import io.netty.buffer.ByteBufOutputStream;
7  import java.io.DataInputStream;
8  import java.io.DataOutputStream;
9  import java.io.IOException;
10  import java.util.ArrayList;
11  import java.util.Arrays;
12  import java.util.BitSet;
13  import java.util.EnumSet;
14  import java.util.List;
15  import java.util.UUID;
16  import lombok.RequiredArgsConstructor;
17  import se.llbit.nbt.NamedTag;
18  import se.llbit.nbt.Tag;
19  @RequiredArgsConstructor
20  public abstract class DefinedPacket
21  {
22      public static void writeString(String s, ByteBuf buf)
23      {
24          writeString( s, buf, Short.MAX_VALUE );
25      }
26      public static void writeString(String s, ByteBuf buf, int maxLength)
27      {
28          if ( s.length() > maxLength )
29          {
30              throw new OverflowPacketException( "Cannot send string longer than " + maxLength + " (got " + s.length() + " characters)" );
31          }
32          byte[] b = s.getBytes( Charsets.UTF_8 );
33          if ( b.length > maxLength * 3 )
34          {
35              throw new OverflowPacketException( "Cannot send string longer than " + ( maxLength * 3 ) + " (got " + b.length + " bytes)" );
36          }
37          writeVarInt( b.length, buf );
38          buf.writeBytes( b );
39      }
40      public static String readString(ByteBuf buf)
41      {
42          return readString( buf, Short.MAX_VALUE );
43      }
44      public static String readString(ByteBuf buf, int maxLen)
45      {
46          int len = readVarInt( buf );
47          if ( len > maxLen * 3 )
48          {
49              throw new OverflowPacketException( "Cannot receive string longer than " + maxLen * 3 + " (got " + len + " bytes)" );
50          }
51          String s = buf.toString( buf.readerIndex(), len, Charsets.UTF_8 );
52          buf.readerIndex( buf.readerIndex() + len );
53          if ( s.length() > maxLen )
54          {
55              throw new OverflowPacketException( "Cannot receive string longer than " + maxLen + " (got " + s.length() + " characters)" );
56          }
57          return s;
58      }
59      public static void writeArray(byte[] b, ByteBuf buf)
60      {
61          if ( b.length > Short.MAX_VALUE )
62          {
63              throw new OverflowPacketException( "Cannot send byte array longer than Short.MAX_VALUE (got " + b.length + " bytes)" );
64          }
65          writeVarInt( b.length, buf );
66          buf.writeBytes( b );
67      }
68      public static byte[] toArray(ByteBuf buf)
69      {
70          byte[] ret = new byte[ buf.readableBytes() ];
71          buf.readBytes( ret );
72          return ret;
73      }
74      public static byte[] readArray(ByteBuf buf)
75      {
76          return readArray( buf, buf.readableBytes() );
77      }
<span onclick='openModal()' class='match'>78      public static byte[] readArray(ByteBuf buf, int limit)
79      {
80          int len = readVarInt( buf );
</span>81          if ( len > limit )
82          {
83              throw new OverflowPacketException( "Cannot receive byte array longer than " + limit + " (got " + len + " bytes)" );
84          }
85          byte[] ret = new byte[ len ];
86          buf.readBytes( ret );
87          return ret;
88      }
89      public static int[] readVarIntArray(ByteBuf buf)
90      {
91          int len = readVarInt( buf );
92          int[] ret = new int[ len ];
93          for ( int i = 0; i < len; i++ )
94          {
95              ret[i] = readVarInt( buf );
96          }
97          return ret;
98      }
99      public static void writeStringArray(List<String> s, ByteBuf buf)
100      {
101          writeVarInt( s.size(), buf );
102          for ( String str : s )
103          {
104              writeString( str, buf );
105          }
106      }
107      public static List<String> readStringArray(ByteBuf buf)
108      {
109          int len = readVarInt( buf );
110          List<String> ret = new ArrayList<>( len );
111          for ( int i = 0; i < len; i++ )
112          {
113              ret.add( readString( buf ) );
114          }
115          return ret;
116      }
117      public static int readVarInt(ByteBuf input)
118      {
119          return readVarInt( input, 5 );
120      }
121      public static int readVarInt(ByteBuf input, int maxBytes)
122      {
123          int out = 0;
124          int bytes = 0;
125          byte in;
126          while ( true )
127          {
128              in = input.readByte();
129              out |= ( in & 0x7F ) << ( bytes++ * 7 );
130              if ( bytes > maxBytes )
131              {
132                  throw new RuntimeException( "VarInt too big" );
133              }
134              if ( ( in & 0x80 ) != 0x80 )
135              {
136                  break;
137              }
138          }
139          return out;
140      }
141      public static void writeVarInt(int value, ByteBuf output)
142      {
143          int part;
144          while ( true )
145          {
146              part = value & 0x7F;
147              value >>>= 7;
148              if ( value != 0 )
149              {
150                  part |= 0x80;
151              }
152              output.writeByte( part );
153              if ( value == 0 )
154              {
155                  break;
156              }
157          }
158      }
159      public static int readVarShort(ByteBuf buf)
160      {
161          int low = buf.readUnsignedShort();
162          int high = 0;
163          if ( ( low & 0x8000 ) != 0 )
164          {
165              low = low & 0x7FFF;
166              high = buf.readUnsignedByte();
167          }
168          return ( ( high & 0xFF ) << 15 ) | low;
169      }
170      public static void writeVarShort(ByteBuf buf, int toWrite)
171      {
172          int low = toWrite & 0x7FFF;
173          int high = ( toWrite & 0x7F8000 ) >> 15;
174          if ( high != 0 )
175          {
176              low = low | 0x8000;
177          }
178          buf.writeShort( low );
179          if ( high != 0 )
180          {
181              buf.writeByte( high );
182          }
183      }
184      public static void writeUUID(UUID value, ByteBuf output)
185      {
186          output.writeLong( value.getMostSignificantBits() );
187          output.writeLong( value.getLeastSignificantBits() );
188      }
189      public static UUID readUUID(ByteBuf input)
190      {
191          return new UUID( input.readLong(), input.readLong() );
192      }
193      public static void writeProperties(Property[] properties, ByteBuf buf)
194      {
195          if ( properties == null )
196          {
197              writeVarInt( 0, buf );
198              return;
199          }
200          writeVarInt( properties.length, buf );
201          for ( Property prop : properties )
202          {
203              writeString( prop.getName(), buf );
204              writeString( prop.getValue(), buf );
205              if ( prop.getSignature() != null )
206              {
207                  buf.writeBoolean( true );
208                  writeString( prop.getSignature(), buf );
209              } else
210              {
211                  buf.writeBoolean( false );
212              }
213          }
214      }
215      public static Property[] readProperties(ByteBuf buf)
216      {
217          Property[] properties = new Property[ DefinedPacket.readVarInt( buf ) ];
218          for ( int j = 0; j < properties.length; j++ )
219          {
220              String name = readString( buf );
221              String value = readString( buf );
222              if ( buf.readBoolean() )
223              {
224                  properties[j] = new Property( name, value, DefinedPacket.readString( buf ) );
225              } else
226              {
227                  properties[j] = new Property( name, value );
228              }
229          }
230          return properties;
231      }
232      public static void writePublicKey(PlayerPublicKey publicKey, ByteBuf buf)
233      {
234          if ( publicKey != null )
235          {
236              buf.writeBoolean( true );
237              buf.writeLong( publicKey.getExpiry() );
238              writeArray( publicKey.getKey(), buf );
239              writeArray( publicKey.getSignature(), buf );
240          } else
241          {
242              buf.writeBoolean( false );
243          }
244      }
245      public static PlayerPublicKey readPublicKey(ByteBuf buf)
246      {
247          if ( buf.readBoolean() )
248          {
249              return new PlayerPublicKey( buf.readLong(), readArray( buf, 512 ), readArray( buf, 4096 ) );
250          }
251          return null;
252      }
253      public static Tag readTag(ByteBuf input)
254      {
255          Tag tag = NamedTag.read( new DataInputStream( new ByteBufInputStream( input ) ) );
256          Preconditions.checkArgument( !tag.isError(), "Error reading tag: %s", tag.error() );
257          return tag;
258      }
259      public static void writeTag(Tag tag, ByteBuf output)
260      {
261          try
262          {
263              tag.write( new DataOutputStream( new ByteBufOutputStream( output ) ) );
264          } catch ( IOException ex )
265          {
266              throw new RuntimeException( "Exception writing tag", ex );
267          }
268      }
269      public static <E extends Enum<E>> void writeEnumSet(EnumSet<E> enumset, Class<E> oclass, ByteBuf buf)
270      {
271          E[] enums = oclass.getEnumConstants();
272          BitSet bits = new BitSet( enums.length );
273          for ( int i = 0; i < enums.length; ++i )
274          {
275              bits.set( i, enumset.contains( enums[i] ) );
276          }
277          writeFixedBitSet( bits, enums.length, buf );
278      }
279      public static <E extends Enum<E>> EnumSet<E> readEnumSet(Class<E> oclass, ByteBuf buf)
280      {
281          E[] enums = oclass.getEnumConstants();
282          BitSet bits = readFixedBitSet( enums.length, buf );
283          EnumSet<E> set = EnumSet.noneOf( oclass );
284          for ( int i = 0; i < enums.length; ++i )
285          {
286              if ( bits.get( i ) )
287              {
288                  set.add( enums[i] );
289              }
290          }
291          return set;
292      }
293      public static BitSet readFixedBitSet(int i, ByteBuf buf)
294      {
295          byte[] bits = new byte[ ( i + 8 ) >> 3 ];
296          buf.readBytes( bits );
297          return BitSet.valueOf( bits );
298      }
299      public static void writeFixedBitSet(BitSet bits, int size, ByteBuf buf)
300      {
301          if ( bits.length() > size )
302          {
303              throw new OverflowPacketException( "BitSet too large (expected " + size + " got " + bits.size() + ")" );
304          }
305          buf.writeBytes( Arrays.copyOf( bits.toByteArray(), ( size + 8 ) >> 3 ) );
306      }
307      public void read(ByteBuf buf)
308      {
309          throw new UnsupportedOperationException( "Packet must implement read method" );
310      }
311      public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
312      {
313          read( buf );
314      }
315      public void write(ByteBuf buf)
316      {
317          throw new UnsupportedOperationException( "Packet must implement write method" );
318      }
319      public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
320      {
321          write( buf );
322      }
323      public abstract void handle(AbstractPacketHandler handler) throws Exception;
324      @Override
325      public abstract boolean equals(Object obj);
326      @Override
327      public abstract int hashCode();
328      @Override
329      public abstract String toString();
330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from VitamioBundle-MDEwOlJlcG9zaXRvcnk2MjkyMDI5-flat-Base64.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from BungeeCord-MDEwOlJlcG9zaXRvcnk2MDg0MjEw-flat-DefinedPacket.java</div>
                </div>
                <div class="column column_space"><pre><code>16      public static byte[] decode(String str, int flags) {
17          return decode(str.getBytes(), flags);
</pre></code></div>
                <div class="column column_space"><pre><code>78      public static byte[] readArray(ByteBuf buf, int limit)
79      {
80          int len = readVarInt( buf );
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    