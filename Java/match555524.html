<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for GlobalEventExecutor.java &amp; ReadOnlyHttp2Headers.java</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for GlobalEventExecutor.java &amp; ReadOnlyHttp2Headers.java
      </h3>
<h1 align="center">
        7.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>GlobalEventExecutor.java (20.192308%)<th>ReadOnlyHttp2Headers.java (4.5619116%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(164-178)<td><a href="#" name="0">(864-878)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(18-41)<td><a href="#" name="1">(20-47)</a><td align="center"><font color="#e20000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(148-156)<td><a href="#" name="2">(483-491)</a><td align="center"><font color="#9b0000">11</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(157-163)<td><a href="#" name="3">(684-690)</a><td align="center"><font color="#7f0000">9</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(142-147)<td><a href="#" name="4">(472-477)</a><td align="center"><font color="#7f0000">9</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>GlobalEventExecutor.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.util.concurrent;
2 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import io.netty.util.internal.ObjectUtil;
3 import io.netty.util.internal.ThreadExecutorMap;
4 import io.netty.util.internal.logging.InternalLogger;
5 import io.netty.util.internal.logging.InternalLoggerFactory;
6 import java.security.AccessController;
7 import java.security.PrivilegedAction;
8 import java.util.Queue;
9 import java.util.concurrent.BlockingQueue;
10 import java.util.concurrent.Executors;
11 import java.util.concurrent.LinkedBlockingQueue;
12 import java.util.concurrent.RejectedExecutionException;
13 import java.util.concurrent.ThreadFactory;
14 import java.util.concurrent.TimeUnit;
15 import java.util.concurrent.atomic.AtomicBoolean;
16 public final class GlobalEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
17     private static final InternalLogger logger = InternalLoggerFactory.getInstance(GlobalEventExecutor.class)</b></font>;
18     private static final long SCHEDULE_QUIET_PERIOD_INTERVAL = TimeUnit.SECONDS.toNanos(1);
19     public static final GlobalEventExecutor INSTANCE = new GlobalEventExecutor();
20     final BlockingQueue&lt;Runnable&gt; taskQueue = new LinkedBlockingQueue&lt;Runnable&gt;();
21     final ScheduledFutureTask&lt;Void&gt; quietPeriodTask = new ScheduledFutureTask&lt;Void&gt;(
22             this, Executors.&lt;Void&gt;callable(new Runnable() {
23         @Override
24         public void run() {
25         }
26     }, null), ScheduledFutureTask.deadlineNanos(SCHEDULE_QUIET_PERIOD_INTERVAL), -SCHEDULE_QUIET_PERIOD_INTERVAL);
27     final ThreadFactory threadFactory;
28     private final TaskRunner taskRunner = new TaskRunner();
29     private final AtomicBoolean started = new AtomicBoolean();
30     volatile Thread thread;
31     private final Future&lt;?&gt; terminationFuture = new FailedFuture&lt;Object&gt;(this, new UnsupportedOperationException());
32     private GlobalEventExecutor() {
33         scheduledTaskQueue().add(quietPeriodTask);
34         threadFactory = ThreadExecutorMap.apply(new DefaultThreadFactory(
35                 DefaultThreadFactory.toPoolName(getClass()), false, Thread.NORM_PRIORITY, null), this);
36     }
37     Runnable takeTask() {
38         BlockingQueue&lt;Runnable&gt; taskQueue = this.taskQueue;
39         for (;;) {
40             ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();
41             if (scheduledTask == null) {
42                 Runnable task = null;
43                 try {
44                     task = taskQueue.take();
45                 } catch (InterruptedException e) {
46                 }
47                 return task;
48             } else {
49                 long delayNanos = scheduledTask.delayNanos();
50                 Runnable task = null;
51                 if (delayNanos &gt; 0) {
52                     try {
53                         task = taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);
54                     } catch (InterruptedException e) {
55                         return null;
56                     }
57                 }
58                 if (task == null) {
59                     fetchFromScheduledTaskQueue();
60                     task = taskQueue.poll();
61                 }
62                 if (task != null) {
63                     return task;
64                 }
65             }
66         }
67     }
68     private void fetchFromScheduledTaskQueue() {
69         long nanoTime = AbstractScheduledEventExecutor.nanoTime();
70         Runnable scheduledTask = pollScheduledTask(nanoTime);
71         while (scheduledTask != null) {
72             taskQueue.add(scheduledTask);
73             scheduledTask = pollScheduledTask(nanoTime);
74         }
75     }
76     public int pendingTasks() {
77         return taskQueue.size();
78     }
79     private void addTask(Runnable task) {
80         taskQueue.add(ObjectUtil.checkNotNull(task, "task"));
81 <a name="4"></a>    }
82     @Override
83     public boolean inEventLoop(<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Thread thread) {
84         return thread == this.thread;
85     }
86 <a name="2"></a>
87     @Override
88     public Future&lt;?&gt; shutdownGracefully(long quietPeriod, long timeout</b></font>, TimeUnit unit) {
89         return <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>terminationFuture();
90     }
91     @Override
92     public Future&lt;?&gt; terminationFuture() {
93         return terminationFuture;
94 <a name="3"></a>    }
95     @</b></font>Override
96     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>@Deprecated
97     public void shutdown() {
98         throw new UnsupportedOperationException();
99     }
100 <a name="0"></a>
101     @Override
102     public boolean isShuttingDown() {</b></font>
103         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return false;
104     }
105     @Override
106     public boolean isShutdown() {
107         return false;
108     }
109     @Override
110     public boolean isTerminated() {
111         return false;
112     }
113     @Override
114     public boolean awaitTermination(long timeout</b></font>, TimeUnit unit) {
115         return false;
116     }
117     public boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
118         ObjectUtil.checkNotNull(unit, "unit");
119         final Thread thread = this.thread;
120         if (thread == null) {
121             throw new IllegalStateException("thread was not started");
122         }
123         thread.join(unit.toMillis(timeout));
124         return !thread.isAlive();
125     }
126     @Override
127     public void execute(Runnable task) {
128         addTask(ObjectUtil.checkNotNull(task, "task"));
129         if (!inEventLoop()) {
130             startThread();
131         }
132     }
133     private void startThread() {
134         if (started.compareAndSet(false, true)) {
135             final Thread t = threadFactory.newThread(taskRunner);
136             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
137                 @Override
138                 public Void run() {
139                     t.setContextClassLoader(null);
140                     return null;
141                 }
142             });
143             thread = t;
144             t.start();
145         }
146     }
147     final class TaskRunner implements Runnable {
148         @Override
149         public void run() {
150             for (;;) {
151                 Runnable task = takeTask();
152                 if (task != null) {
153                     try {
154                         task.run();
155                     } catch (Throwable t) {
156                         logger.warn("Unexpected exception from the global event executor: ", t);
157                     }
158                     if (task != quietPeriodTask) {
159                         continue;
160                     }
161                 }
162                 Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = GlobalEventExecutor.this.scheduledTaskQueue;
163                 if (taskQueue.isEmpty() &amp;&amp; (scheduledTaskQueue == null || scheduledTaskQueue.size() == 1)) {
164                     boolean stopped = started.compareAndSet(true, false);
165                     assert stopped;
166                     if (taskQueue.isEmpty()) {
167                         break;
168                     }
169                     if (!started.compareAndSet(false, true)) {
170                         break;
171                     }
172                 }
173             }
174         }
175     }
176 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ReadOnlyHttp2Headers.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 package io.netty.handler.codec.http2;
2 <a name="1"></a>
3 import io.netty.handler.codec.Headers;
4 import io.netty.util.AsciiString;
5 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import io.netty.util.HashingStrategy;
6 import java.util.ArrayList;
7 import java.util.Collections;
8 import java.util.Iterator;
9 import java.util.LinkedHashSet;
10 import java.util.List;
11 import java.util.Map;
12 import java.util.NoSuchElementException;
13 import java.util.Set;
14 import static io.netty.handler.codec.CharSequenceValueConverter.*;
15 import static io.netty.handler.codec.http2.DefaultHttp2Headers.*;
16 import static io.netty.util.AsciiString.*;
17 import static io.netty.util.internal.EmptyArrays.*;
18 import static io.netty.util.internal.ObjectUtil.checkNotNullArrayParam;
19 public final class ReadOnlyHttp2Headers implements Http2Headers {
20     private static final byte PSEUDO_HEADER_TOKEN = (byte) ':</b></font>';
21     private final AsciiString[] pseudoHeaders;
22     private final AsciiString[] otherHeaders;
23     public static ReadOnlyHttp2Headers trailers(boolean validateHeaders, AsciiString... otherHeaders) {
24         return new ReadOnlyHttp2Headers(validateHeaders, EMPTY_ASCII_STRINGS, otherHeaders);
25     }
26     public static ReadOnlyHttp2Headers clientHeaders(boolean validateHeaders,
27                                                      AsciiString method, AsciiString path,
28                                                      AsciiString scheme, AsciiString authority,
29                                                      AsciiString... otherHeaders) {
30         return new ReadOnlyHttp2Headers(validateHeaders,
31                 new AsciiString[] {
32                   PseudoHeaderName.METHOD.value(), method, PseudoHeaderName.PATH.value(), path,
33                   PseudoHeaderName.SCHEME.value(), scheme, PseudoHeaderName.AUTHORITY.value(), authority
34                 },
35                 otherHeaders);
36     }
37     public static ReadOnlyHttp2Headers serverHeaders(boolean validateHeaders,
38                                                      AsciiString status,
39                                                      AsciiString... otherHeaders) {
40         return new ReadOnlyHttp2Headers(validateHeaders,
41                                         new AsciiString[] { PseudoHeaderName.STATUS.value(), status },
42                                         otherHeaders);
43     }
44     private ReadOnlyHttp2Headers(boolean validateHeaders, AsciiString[] pseudoHeaders, AsciiString... otherHeaders) {
45         assert (pseudoHeaders.length &amp; 1) == 0;         if ((otherHeaders.length &amp; 1) != 0) {
46             throw newInvalidArraySizeException();
47         }
48         if (validateHeaders) {
49             validateHeaders(pseudoHeaders, otherHeaders);
50         }
51         this.pseudoHeaders = pseudoHeaders;
52         this.otherHeaders = otherHeaders;
53     }
54     private static IllegalArgumentException newInvalidArraySizeException() {
55         return new IllegalArgumentException("pseudoHeaders and otherHeaders must be arrays of [name, value] pairs");
56     }
57     private static void validateHeaders(AsciiString[] pseudoHeaders, AsciiString... otherHeaders) {
58         for (int i = 1; i &lt; pseudoHeaders.length; i += 2) {
59             checkNotNullArrayParam(pseudoHeaders[i], i, "pseudoHeaders");
60         }
61         boolean seenNonPseudoHeader = false;
62         final int otherHeadersEnd = otherHeaders.length - 1;
63         for (int i = 0; i &lt; otherHeadersEnd; i += 2) {
64             AsciiString name = otherHeaders[i];
65             HTTP2_NAME_VALIDATOR.validateName(name);
66             if (!seenNonPseudoHeader &amp;&amp; !name.isEmpty() &amp;&amp; name.byteAt(0) != PSEUDO_HEADER_TOKEN) {
67                 seenNonPseudoHeader = true;
68             } else if (seenNonPseudoHeader &amp;&amp; !name.isEmpty() &amp;&amp; name.byteAt(0) == PSEUDO_HEADER_TOKEN) {
69                 throw new IllegalArgumentException(
70                      "otherHeaders name at index " + i + " is a pseudo header that appears after non-pseudo headers.");
71             }
72             checkNotNullArrayParam(otherHeaders[i + 1], i + 1, "otherHeaders");
73         }
74     }
75     private AsciiString get0(CharSequence name) {
76         final int nameHash = AsciiString.hashCode(name);
77         final int pseudoHeadersEnd = pseudoHeaders.length - 1;
78         for (int i = 0; i &lt; pseudoHeadersEnd; i += 2) {
79             AsciiString roName = pseudoHeaders[i];
80             if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
81                 return pseudoHeaders[i + 1];
82             }
83         }
84         final int otherHeadersEnd = otherHeaders.length - 1;
85         for (int i = 0; i &lt; otherHeadersEnd; i += 2) {
86             AsciiString roName = otherHeaders[i];
87             if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
88                 return otherHeaders[i + 1];
89             }
90         }
91         return null;
92     }
93     @Override
94     public CharSequence get(CharSequence name) {
95         return get0(name);
96     }
97     @Override
98     public CharSequence get(CharSequence name, CharSequence defaultValue) {
99         CharSequence value = get(name);
100         return value != null ? value : defaultValue;
101     }
102     @Override
103     public CharSequence getAndRemove(CharSequence name) {
104         throw new UnsupportedOperationException("read only");
105     }
106     @Override
107     public CharSequence getAndRemove(CharSequence name, CharSequence defaultValue) {
108         throw new UnsupportedOperationException("read only");
109     }
110     @Override
111     public List&lt;CharSequence&gt; getAll(CharSequence name) {
112         final int nameHash = AsciiString.hashCode(name);
113         List&lt;CharSequence&gt; values = new ArrayList&lt;CharSequence&gt;();
114         final int pseudoHeadersEnd = pseudoHeaders.length - 1;
115         for (int i = 0; i &lt; pseudoHeadersEnd; i += 2) {
116             AsciiString roName = pseudoHeaders[i];
117             if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
118                 values.add(pseudoHeaders[i + 1]);
119             }
120         }
121         final int otherHeadersEnd = otherHeaders.length - 1;
122         for (int i = 0; i &lt; otherHeadersEnd; i += 2) {
123             AsciiString roName = otherHeaders[i];
124             if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
125                 values.add(otherHeaders[i + 1]);
126             }
127         }
128         return values;
129     }
130     @Override
131     public List&lt;CharSequence&gt; getAllAndRemove(CharSequence name) {
132         throw new UnsupportedOperationException("read only");
133     }
134     @Override
135     public Boolean getBoolean(CharSequence name) {
136         AsciiString value = get0(name);
137         return value != null ? INSTANCE.convertToBoolean(value) : null;
138     }
139     @Override
140     public boolean getBoolean(CharSequence name, boolean defaultValue) {
141         Boolean value = getBoolean(name);
142         return value != null ? value : defaultValue;
143     }
144     @Override
145     public Byte getByte(CharSequence name) {
146         AsciiString value = get0(name);
147         return value != null ? INSTANCE.convertToByte(value) : null;
148     }
149     @Override
150     public byte getByte(CharSequence name, byte defaultValue) {
151         Byte value = getByte(name);
152         return value != null ? value : defaultValue;
153     }
154     @Override
155     public Character getChar(CharSequence name) {
156         AsciiString value = get0(name);
157         return value != null ? INSTANCE.convertToChar(value) : null;
158     }
159     @Override
160     public char getChar(CharSequence name, char defaultValue) {
161         Character value = getChar(name);
162         return value != null ? value : defaultValue;
163     }
164     @Override
165     public Short getShort(CharSequence name) {
166         AsciiString value = get0(name);
167         return value != null ? INSTANCE.convertToShort(value) : null;
168     }
169     @Override
170     public short getShort(CharSequence name, short defaultValue) {
171         Short value = getShort(name);
172         return value != null ? value : defaultValue;
173     }
174     @Override
175     public Integer getInt(CharSequence name) {
176         AsciiString value = get0(name);
177         return value != null ? INSTANCE.convertToInt(value) : null;
178     }
179     @Override
180     public int getInt(CharSequence name, int defaultValue) {
181         Integer value = getInt(name);
182         return value != null ? value : defaultValue;
183     }
184     @Override
185     public Long getLong(CharSequence name) {
186         AsciiString value = get0(name);
187         return value != null ? INSTANCE.convertToLong(value) : null;
188     }
189     @Override
190     public long getLong(CharSequence name, long defaultValue) {
191         Long value = getLong(name);
192         return value != null ? value : defaultValue;
193     }
194     @Override
195     public Float getFloat(CharSequence name) {
196         AsciiString value = get0(name);
197         return value != null ? INSTANCE.convertToFloat(value) : null;
198     }
199     @Override
200     public float getFloat(CharSequence name, float defaultValue) {
201         Float value = getFloat(name);
202         return value != null ? value : defaultValue;
203     }
204     @Override
205     public Double getDouble(CharSequence name) {
206         AsciiString value = get0(name);
207         return value != null ? INSTANCE.convertToDouble(value) : null;
208     }
209     @Override
210     public double getDouble(CharSequence name, double defaultValue) {
211         Double value = getDouble(name);
212         return value != null ? value : defaultValue;
213     }
214     @Override
215     public Long getTimeMillis(CharSequence name) {
216         AsciiString value = get0(name);
217         return value != null ? INSTANCE.convertToTimeMillis(value) : null;
218     }
219     @Override
220     public long getTimeMillis(CharSequence name, long defaultValue) {
221         Long value = getTimeMillis(name);
222         return value != null ? value : defaultValue;
223     }
224     @Override
225     public Boolean getBooleanAndRemove(CharSequence name) {
226         throw new UnsupportedOperationException("read only");
227     }
228     @Override
229     public boolean getBooleanAndRemove(CharSequence name, boolean defaultValue) {
230         throw new UnsupportedOperationException("read only");
231     }
232     @Override
233     public Byte getByteAndRemove(CharSequence name) {
234         throw new UnsupportedOperationException("read only");
235     }
236     @Override
237     public byte getByteAndRemove(CharSequence name, byte defaultValue) {
238         throw new UnsupportedOperationException("read only");
239     }
240     @Override
241     public Character getCharAndRemove(CharSequence name) {
242         throw new UnsupportedOperationException("read only");
243     }
244     @Override
245     public char getCharAndRemove(CharSequence name, char defaultValue) {
246         throw new UnsupportedOperationException("read only");
247     }
248     @Override
249     public Short getShortAndRemove(CharSequence name) {
250         throw new UnsupportedOperationException("read only");
251     }
252     @Override
253     public short getShortAndRemove(CharSequence name, short defaultValue) {
254         throw new UnsupportedOperationException("read only");
255     }
256     @Override
257     public Integer getIntAndRemove(CharSequence name) {
258         throw new UnsupportedOperationException("read only");
259     }
260     @Override
261     public int getIntAndRemove(CharSequence name, int defaultValue) {
262         throw new UnsupportedOperationException("read only");
263     }
264     @Override
265     public Long getLongAndRemove(CharSequence name) {
266         throw new UnsupportedOperationException("read only");
267     }
268     @Override
269     public long getLongAndRemove(CharSequence name, long defaultValue) {
270         throw new UnsupportedOperationException("read only");
271     }
272     @Override
273     public Float getFloatAndRemove(CharSequence name) {
274         throw new UnsupportedOperationException("read only");
275     }
276     @Override
277     public float getFloatAndRemove(CharSequence name, float defaultValue) {
278         throw new UnsupportedOperationException("read only");
279     }
280     @Override
281     public Double getDoubleAndRemove(CharSequence name) {
282         throw new UnsupportedOperationException("read only");
283     }
284     @Override
285     public double getDoubleAndRemove(CharSequence name, double defaultValue) {
286         throw new UnsupportedOperationException("read only");
287     }
288     @Override
289     public Long getTimeMillisAndRemove(CharSequence name) {
290         throw new UnsupportedOperationException("read only");
291     }
292     @Override
293     public long getTimeMillisAndRemove(CharSequence name, long defaultValue) {
294         throw new UnsupportedOperationException("read only");
295     }
296     @Override
297     public boolean contains(CharSequence name) {
298         return get(name) != null;
299     }
300     @Override
301     public boolean contains(CharSequence name, CharSequence value) {
302         return contains(name, value, false);
303     }
304     @Override
305     public boolean containsObject(CharSequence name, Object value) {
306         if (value instanceof CharSequence) {
307             return contains(name, (CharSequence) value);
308         }
309         return contains(name, value.toString());
310     }
311     @Override
312     public boolean containsBoolean(CharSequence name, boolean value) {
313         return contains(name, String.valueOf(value));
314     }
315     @Override
316     public boolean containsByte(CharSequence name, byte value) {
317         return contains(name, String.valueOf(value));
318     }
319     @Override
320     public boolean containsChar(CharSequence name, char value) {
321         return contains(name, String.valueOf(value));
322     }
323     @Override
324     public boolean containsShort(CharSequence name, short value) {
325         return contains(name, String.valueOf(value));
326     }
327     @Override
328     public boolean containsInt(CharSequence name, int value) {
329         return contains(name, String.valueOf(value));
330     }
331     @Override
332     public boolean containsLong(CharSequence name, long value) {
333         return contains(name, String.valueOf(value));
334 <a name="4"></a>    }
335     @Override
336     public boolean containsFloat(CharSequence name, <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>float value) {
337         return false;
338     }
339     @Override
340     public boolean containsDouble(CharSequence name, double value</b></font>) {
341         return contains(name, String.valueOf(value));
342     }
343 <a name="2"></a>
344     @Override
345     public boolean containsTimeMillis(CharSequence name, long value) {
346         return contains(name, <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>String.valueOf(value));
347     }
348     @Override
349     public int size() {
350         return pseudoHeaders.length + otherHeaders.length &gt;&gt;&gt; 1;
351     }
352     @</b></font>Override
353     public boolean isEmpty() {
354         return pseudoHeaders.length == 0 &amp;&amp; otherHeaders.length == 0;
355     }
356     @Override
357     public Set&lt;CharSequence&gt; names() {
358         if (isEmpty()) {
359             return Collections.emptySet();
360         }
361         Set&lt;CharSequence&gt; names = new LinkedHashSet&lt;CharSequence&gt;(size());
362         final int pseudoHeadersEnd = pseudoHeaders.length - 1;
363         for (int i = 0; i &lt; pseudoHeadersEnd; i += 2) {
364             names.add(pseudoHeaders[i]);
365         }
366         final int otherHeadersEnd = otherHeaders.length - 1;
367         for (int i = 0; i &lt; otherHeadersEnd; i += 2) {
368             names.add(otherHeaders[i]);
369         }
370         return names;
371     }
372     @Override
373     public Http2Headers add(CharSequence name, CharSequence value) {
374         throw new UnsupportedOperationException("read only");
375     }
376     @Override
377     public Http2Headers add(CharSequence name, Iterable&lt;? extends CharSequence&gt; values) {
378         throw new UnsupportedOperationException("read only");
379     }
380     @Override
381     public Http2Headers add(CharSequence name, CharSequence... values) {
382         throw new UnsupportedOperationException("read only");
383     }
384     @Override
385     public Http2Headers addObject(CharSequence name, Object value) {
386         throw new UnsupportedOperationException("read only");
387     }
388     @Override
389     public Http2Headers addObject(CharSequence name, Iterable&lt;?&gt; values) {
390         throw new UnsupportedOperationException("read only");
391     }
392     @Override
393     public Http2Headers addObject(CharSequence name, Object... values) {
394         throw new UnsupportedOperationException("read only");
395     }
396     @Override
397     public Http2Headers addBoolean(CharSequence name, boolean value) {
398         throw new UnsupportedOperationException("read only");
399     }
400     @Override
401     public Http2Headers addByte(CharSequence name, byte value) {
402         throw new UnsupportedOperationException("read only");
403     }
404     @Override
405     public Http2Headers addChar(CharSequence name, char value) {
406         throw new UnsupportedOperationException("read only");
407     }
408     @Override
409     public Http2Headers addShort(CharSequence name, short value) {
410         throw new UnsupportedOperationException("read only");
411     }
412     @Override
413     public Http2Headers addInt(CharSequence name, int value) {
414         throw new UnsupportedOperationException("read only");
415     }
416     @Override
417     public Http2Headers addLong(CharSequence name, long value) {
418         throw new UnsupportedOperationException("read only");
419     }
420     @Override
421     public Http2Headers addFloat(CharSequence name, float value) {
422         throw new UnsupportedOperationException("read only");
423     }
424     @Override
425     public Http2Headers addDouble(CharSequence name, double value) {
426         throw new UnsupportedOperationException("read only");
427     }
428     @Override
429     public Http2Headers addTimeMillis(CharSequence name, long value) {
430         throw new UnsupportedOperationException("read only");
431     }
432     @Override
433     public Http2Headers add(Headers&lt;? extends CharSequence, ? extends CharSequence, ?&gt; headers) {
434         throw new UnsupportedOperationException("read only");
435     }
436     @Override
437     public Http2Headers set(CharSequence name, CharSequence value) {
438         throw new UnsupportedOperationException("read only");
439     }
440     @Override
441     public Http2Headers set(CharSequence name, Iterable&lt;? extends CharSequence&gt; values) {
442         throw new UnsupportedOperationException("read only");
443     }
444     @Override
445     public Http2Headers set(CharSequence name, CharSequence... values) {
446         throw new UnsupportedOperationException("read only");
447     }
448     @Override
449     public Http2Headers setObject(CharSequence name, Object value) {
450         throw new UnsupportedOperationException("read only");
451     }
452     @Override
453     public Http2Headers setObject(CharSequence name, Iterable&lt;?&gt; values) {
454         throw new UnsupportedOperationException("read only");
455     }
456     @Override
457     public Http2Headers setObject(CharSequence name, Object... values) {
458         throw new UnsupportedOperationException("read only");
459     }
460     @Override
461     public Http2Headers setBoolean(CharSequence name, boolean value) {
462         throw new UnsupportedOperationException("read only");
463     }
464     @Override
465     public Http2Headers setByte(CharSequence name, byte value) {
466         throw new UnsupportedOperationException("read only");
467     }
468     @Override
469     public Http2Headers setChar(CharSequence name, char value) {
470         throw new UnsupportedOperationException("read only");
471     }
472     @Override
473     public Http2Headers setShort(CharSequence name, short value) {
474         throw new UnsupportedOperationException("read only");
475     }
476     @Override
477     public Http2Headers setInt(CharSequence name, int value) {
478         throw new UnsupportedOperationException("read only");
479     }
480     @Override
481     public Http2Headers setLong(CharSequence name, long value) {
482         throw new UnsupportedOperationException("read only");
483     }
484     @Override
485     public Http2Headers setFloat(CharSequence name, float value) {
486         throw new UnsupportedOperationException("read only");
487     }
488     @Override
489     public Http2Headers setDouble(CharSequence name, double value) {
490         throw new UnsupportedOperationException("read only");
491     }
492     @Override
493     public Http2Headers setTimeMillis(CharSequence name, long value) {
494         throw new UnsupportedOperationException("read only");
495     }
496     @Override
497     public Http2Headers set(Headers&lt;? extends CharSequence, ? extends CharSequence, ?&gt; headers) {
498         throw new UnsupportedOperationException("read only");
499     }
500     @Override
501     public Http2Headers setAll(Headers&lt;? extends CharSequence, ? extends CharSequence, ?&gt; headers) {
502         throw new UnsupportedOperationException("read only");
503     }
504     @Override
505     public boolean remove(CharSequence name) {
506 <a name="3"></a>        throw new UnsupportedOperationException("read only");
507     }
508     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>@Override
509     public Http2Headers clear() {
510         throw new UnsupportedOperationException("read only");
511     }
512     @Override
513     public Iterator&lt;Map.Entry&lt;CharSequence, CharSequence&gt;&gt; iterator() {</b></font>
514         return new ReadOnlyIterator();
515     }
516     @Override
517     public Iterator&lt;CharSequence&gt; valueIterator(CharSequence name) {
518         return new ReadOnlyValueIterator(name);
519     }
520     @Override
521     public Http2Headers method(CharSequence value) {
522         throw new UnsupportedOperationException("read only");
523     }
524     @Override
525     public Http2Headers scheme(CharSequence value) {
526         throw new UnsupportedOperationException("read only");
527     }
528     @Override
529     public Http2Headers authority(CharSequence value) {
530         throw new UnsupportedOperationException("read only");
531     }
532     @Override
533     public Http2Headers path(CharSequence value) {
534         throw new UnsupportedOperationException("read only");
535     }
536     @Override
537     public Http2Headers status(CharSequence value) {
538         throw new UnsupportedOperationException("read only");
539     }
540     @Override
541     public CharSequence method() {
542         return get(PseudoHeaderName.METHOD.value());
543     }
544     @Override
545     public CharSequence scheme() {
546         return get(PseudoHeaderName.SCHEME.value());
547     }
548     @Override
549     public CharSequence authority() {
550         return get(PseudoHeaderName.AUTHORITY.value());
551     }
552     @Override
553     public CharSequence path() {
554         return get(PseudoHeaderName.PATH.value());
555     }
556     @Override
557     public CharSequence status() {
558         return get(PseudoHeaderName.STATUS.value());
559     }
560     @Override
561     public boolean contains(CharSequence name, CharSequence value, boolean caseInsensitive) {
562         final int nameHash = AsciiString.hashCode(name);
563         final HashingStrategy&lt;CharSequence&gt; strategy =
564                 caseInsensitive ? CASE_INSENSITIVE_HASHER : CASE_SENSITIVE_HASHER;
565         final int valueHash = strategy.hashCode(value);
566         return contains(name, nameHash, value, valueHash, strategy, otherHeaders)
567                 || contains(name, nameHash, value, valueHash, strategy, pseudoHeaders);
568     }
569     private static boolean contains(CharSequence name, int nameHash, CharSequence value, int valueHash,
570                                     HashingStrategy&lt;CharSequence&gt; hashingStrategy, AsciiString[] headers) {
571         final int headersEnd = headers.length - 1;
572         for (int i = 0; i &lt; headersEnd; i += 2) {
573             AsciiString roName = headers[i];
574             AsciiString roValue = headers[i + 1];
575             if (roName.hashCode() == nameHash &amp;&amp; roValue.hashCode() == valueHash &amp;&amp;
576                 roName.contentEqualsIgnoreCase(name) &amp;&amp; hashingStrategy.equals(roValue, value)) {
577                 return true;
578             }
579         }
580         return false;
581     }
582     @Override
583     public String toString() {
584         StringBuilder builder = new StringBuilder(getClass().getSimpleName()).append('[');
585         String separator = "";
586         for (Map.Entry&lt;CharSequence, CharSequence&gt; entry : this) {
587             builder.append(separator);
588             builder.append(entry.getKey()).append(": ").append(entry.getValue());
589             separator = ", ";
590         }
591         return builder.append(']').toString();
592     }
593     private final class ReadOnlyValueIterator implements Iterator&lt;CharSequence&gt; {
594         private int i;
595         private final int nameHash;
596         private final CharSequence name;
597         private AsciiString[] current = pseudoHeaders.length != 0 ? pseudoHeaders : otherHeaders;
598         private AsciiString next;
599         ReadOnlyValueIterator(CharSequence name) {
600             nameHash = AsciiString.hashCode(name);
601             this.name = name;
602             calculateNext();
603         }
604         @Override
605         public boolean hasNext() {
606             return next != null;
607         }
608         @Override
609         public CharSequence next() {
610             if (!hasNext()) {
611                 throw new NoSuchElementException();
612             }
613             CharSequence current = next;
614             calculateNext();
615             return current;
616         }
617         @Override
618         public void remove() {
619             throw new UnsupportedOperationException("read only");
620         }
621         private void calculateNext() {
622             for (; i &lt; current.length; i += 2) {
623                 AsciiString roName = current[i];
624                 if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
625                     if (i + 1 &lt; current.length) {
626                         next = current[i + 1];
627                         i += 2;
628                     }
629                     return;
630                 }
631             }
632             if (current == pseudoHeaders) {
633                 i = 0;
634                 current = otherHeaders;
635                 calculateNext();
636             } else {
637                 next = null;
638             }
639         }
640     }
641     private final class ReadOnlyIterator implements Map.Entry&lt;CharSequence, CharSequence&gt;,
642                                                     Iterator&lt;Map.Entry&lt;CharSequence, CharSequence&gt;&gt; {
643         private int i;
644         private AsciiString[] current = pseudoHeaders.length != 0 ? pseudoHeaders : otherHeaders;
645         private AsciiString key;
646         private AsciiString value;
647         @Override
648         public boolean hasNext() {
649             return i != current.length;
650         }
651         @Override
652         public Map.Entry&lt;CharSequence, CharSequence&gt; next() {
653             if (!hasNext()) {
654                 throw new NoSuchElementException();
655             }
656             key = current[i];
657             value = current[i + 1];
658             i += 2;
659             if (i == current.length &amp;&amp; current == pseudoHeaders) {
660 <a name="0"></a>                current = otherHeaders;
661                 i = 0;
662             }
663             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return this;
664         }
665         @Override
666         public CharSequence getKey() {
667             return key;
668         }
669         @Override
670         public CharSequence getValue() {
671             return value;
672         }
673         @Override
674         public CharSequence setValue(CharSequence value</b></font>) {
675             throw new UnsupportedOperationException("read only");
676         }
677         @Override
678         public void remove() {
679             throw new UnsupportedOperationException("read only");
680         }
681         @Override
682         public String toString() {
683             return key.toString() + '=' + value.toString();
684         }
685     }
686 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
