<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for GlobalEventExecutor.java & ReadOnlyHttp2Headers.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for GlobalEventExecutor.java & ReadOnlyHttp2Headers.java
      </h3>
      <h1 align="center">
        7.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>GlobalEventExecutor.java (20.192308%)<TH>ReadOnlyHttp2Headers.java (4.5619116%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match555524-0.html#0',2,'match555524-1.html#0',3)" NAME="0">(164-178)<TD><A HREF="javascript:ZweiFrames('match555524-0.html#0',2,'match555524-1.html#0',3)" NAME="0">(864-878)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match555524-0.html#1',2,'match555524-1.html#1',3)" NAME="1">(18-41)<TD><A HREF="javascript:ZweiFrames('match555524-0.html#1',2,'match555524-1.html#1',3)" NAME="1">(20-47)</A><TD ALIGN=center><FONT COLOR="#e20000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match555524-0.html#2',2,'match555524-1.html#2',3)" NAME="2">(148-156)<TD><A HREF="javascript:ZweiFrames('match555524-0.html#2',2,'match555524-1.html#2',3)" NAME="2">(483-491)</A><TD ALIGN=center><FONT COLOR="#9b0000">11</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match555524-0.html#3',2,'match555524-1.html#3',3)" NAME="3">(157-163)<TD><A HREF="javascript:ZweiFrames('match555524-0.html#3',2,'match555524-1.html#3',3)" NAME="3">(684-690)</A><TD ALIGN=center><FONT COLOR="#7f0000">9</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match555524-0.html#4',2,'match555524-1.html#4',3)" NAME="4">(142-147)<TD><A HREF="javascript:ZweiFrames('match555524-0.html#4',2,'match555524-1.html#4',3)" NAME="4">(472-477)</A><TD ALIGN=center><FONT COLOR="#7f0000">9</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>GlobalEventExecutor.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
<A NAME="1"></A> */
package io.netty.util.concurrent;

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match555524-1.html#1',3,'match555524-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.ThreadExecutorMap;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Queue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Single-thread singleton {@link EventExecutor}.  It starts the thread automatically and stops it when there is no
 * task pending in the task queue for 1 second.  Please note it is not scalable to schedule large number of tasks to
 * this executor; use a dedicated executor.
 */
public final class GlobalEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {

    private static final InternalLogger logger = InternalLoggerFactory.getInstance(GlobalEventExecutor.class)</B></FONT>;

    private static final long SCHEDULE_QUIET_PERIOD_INTERVAL = TimeUnit.SECONDS.toNanos(1);

    public static final GlobalEventExecutor INSTANCE = new GlobalEventExecutor();

    final BlockingQueue&lt;Runnable&gt; taskQueue = new LinkedBlockingQueue&lt;Runnable&gt;();
    final ScheduledFutureTask&lt;Void&gt; quietPeriodTask = new ScheduledFutureTask&lt;Void&gt;(
            this, Executors.&lt;Void&gt;callable(new Runnable() {
        @Override
        public void run() {
            // NOOP
        }
    }, null), ScheduledFutureTask.deadlineNanos(SCHEDULE_QUIET_PERIOD_INTERVAL), -SCHEDULE_QUIET_PERIOD_INTERVAL);

    // because the GlobalEventExecutor is a singleton, tasks submitted to it can come from arbitrary threads and this
    // can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory must not
    // be sticky about its thread group
    // visible for testing
    final ThreadFactory threadFactory;
    private final TaskRunner taskRunner = new TaskRunner();
    private final AtomicBoolean started = new AtomicBoolean();
    volatile Thread thread;

    private final Future&lt;?&gt; terminationFuture = new FailedFuture&lt;Object&gt;(this, new UnsupportedOperationException());

    private GlobalEventExecutor() {
        scheduledTaskQueue().add(quietPeriodTask);
        threadFactory = ThreadExecutorMap.apply(new DefaultThreadFactory(
                DefaultThreadFactory.toPoolName(getClass()), false, Thread.NORM_PRIORITY, null), this);
    }

    /**
     * Take the next {@link Runnable} from the task queue and so will block if no task is currently present.
     *
     * @return {@code null} if the executor thread has been interrupted or waken up.
     */
    Runnable takeTask() {
        BlockingQueue&lt;Runnable&gt; taskQueue = this.taskQueue;
        for (;;) {
            ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();
            if (scheduledTask == null) {
                Runnable task = null;
                try {
                    task = taskQueue.take();
                } catch (InterruptedException e) {
                    // Ignore
                }
                return task;
            } else {
                long delayNanos = scheduledTask.delayNanos();
                Runnable task = null;
                if (delayNanos &gt; 0) {
                    try {
                        task = taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);
                    } catch (InterruptedException e) {
                        // Waken up.
                        return null;
                    }
                }
                if (task == null) {
                    // We need to fetch the scheduled tasks now as otherwise there may be a chance that
                    // scheduled tasks are never executed if there is always one task in the taskQueue.
                    // This is for example true for the read task of OIO Transport
                    // See https://github.com/netty/netty/issues/1614
                    fetchFromScheduledTaskQueue();
                    task = taskQueue.poll();
                }

                if (task != null) {
                    return task;
                }
            }
        }
    }

    private void fetchFromScheduledTaskQueue() {
        long nanoTime = AbstractScheduledEventExecutor.nanoTime();
        Runnable scheduledTask = pollScheduledTask(nanoTime);
        while (scheduledTask != null) {
            taskQueue.add(scheduledTask);
            scheduledTask = pollScheduledTask(nanoTime);
        }
    }

    /**
     * Return the number of tasks that are pending for processing.
     */
    public int pendingTasks() {
        return taskQueue.size();
    }

    /**
     * Add a task to the task queue, or throws a {@link RejectedExecutionException} if this instance was shutdown
     * before.
     */
    private void addTask(Runnable task) {
        taskQueue.add(ObjectUtil.checkNotNull(task, &quot;task&quot;));
<A NAME="4"></A>    }

    @Override
    public boolean inEventLoop(<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match555524-1.html#4',3,'match555524-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Thread thread) {
        return thread == this.thread;
    }
<A NAME="2"></A>
    @Override
    public Future&lt;?&gt; shutdownGracefully(long quietPeriod, long timeout</B></FONT>, TimeUnit unit) {
        return <FONT color="#980517"><A HREF="javascript:ZweiFrames('match555524-1.html#2',3,'match555524-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>terminationFuture();
    }

    @Override
    public Future&lt;?&gt; terminationFuture() {
        return terminationFuture;
<A NAME="3"></A>    }

    @</B></FONT>Override
    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match555524-1.html#3',3,'match555524-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>@Deprecated
    public void shutdown() {
        throw new UnsupportedOperationException();
    }
<A NAME="0"></A>
    @Override
    public boolean isShuttingDown() {</B></FONT>
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match555524-1.html#0',3,'match555524-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return false;
    }

    @Override
    public boolean isShutdown() {
        return false;
    }

    @Override
    public boolean isTerminated() {
        return false;
    }

    @Override
    public boolean awaitTermination(long timeout</B></FONT>, TimeUnit unit) {
        return false;
    }

    /**
     * Waits until the worker thread of this executor has no tasks left in its task queue and terminates itself.
     * Because a new worker thread will be started again when a new task is submitted, this operation is only useful
     * when you want to ensure that the worker thread is terminated &lt;strong&gt;after&lt;/strong&gt; your application is shut
     * down and there's no chance of submitting a new task afterwards.
     *
     * @return {@code true} if and only if the worker thread has been terminated
     */
    public boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
        ObjectUtil.checkNotNull(unit, &quot;unit&quot;);

        final Thread thread = this.thread;
        if (thread == null) {
            throw new IllegalStateException(&quot;thread was not started&quot;);
        }
        thread.join(unit.toMillis(timeout));
        return !thread.isAlive();
    }

    @Override
    public void execute(Runnable task) {
        addTask(ObjectUtil.checkNotNull(task, &quot;task&quot;));
        if (!inEventLoop()) {
            startThread();
        }
    }

    private void startThread() {
        if (started.compareAndSet(false, true)) {
            final Thread t = threadFactory.newThread(taskRunner);
            // Set to null to ensure we not create classloader leaks by holds a strong reference to the inherited
            // classloader.
            // See:
            // - https://github.com/netty/netty/issues/7290
            // - https://bugs.openjdk.java.net/browse/JDK-7008595
            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                @Override
                public Void run() {
                    t.setContextClassLoader(null);
                    return null;
                }
            });

            // Set the thread before starting it as otherwise inEventLoop() may return false and so produce
            // an assert error.
            // See https://github.com/netty/netty/issues/4357
            thread = t;
            t.start();
        }
    }

    final class TaskRunner implements Runnable {
        @Override
        public void run() {
            for (;;) {
                Runnable task = takeTask();
                if (task != null) {
                    try {
                        task.run();
                    } catch (Throwable t) {
                        logger.warn(&quot;Unexpected exception from the global event executor: &quot;, t);
                    }

                    if (task != quietPeriodTask) {
                        continue;
                    }
                }

                Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = GlobalEventExecutor.this.scheduledTaskQueue;
                // Terminate if there is no task in the queue (except the noop task).
                if (taskQueue.isEmpty() &amp;&amp; (scheduledTaskQueue == null || scheduledTaskQueue.size() == 1)) {
                    // Mark the current thread as stopped.
                    // The following CAS must always success and must be uncontended,
                    // because only one thread should be running at the same time.
                    boolean stopped = started.compareAndSet(true, false);
                    assert stopped;

                    // Check if there are pending entries added by execute() or schedule*() while we do CAS above.
                    // Do not check scheduledTaskQueue because it is not thread-safe and can only be mutated from a
                    // TaskRunner actively running tasks.
                    if (taskQueue.isEmpty()) {
                        // A) No new task was added and thus there's nothing to handle
                        //    -&gt; safe to terminate because there's nothing left to do
                        // B) A new thread started and handled all the new tasks.
                        //    -&gt; safe to terminate the new thread will take care the rest
                        break;
                    }

                    // There are pending tasks added again.
                    if (!started.compareAndSet(false, true)) {
                        // startThread() started a new thread and set 'started' to true.
                        // -&gt; terminate this thread so that the new thread reads from taskQueue exclusively.
                        break;
                    }

                    // New tasks were added, but this worker was faster to set 'started' to true.
                    // i.e. a new worker thread was not started by startThread().
                    // -&gt; keep this thread alive to handle the newly added entries.
                }
            }
        }
    }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ReadOnlyHttp2Headers.java</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright 2016 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.handler.codec.http2;
<A NAME="1"></A>
import io.netty.handler.codec.Headers;
import io.netty.util.AsciiString;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match555524-0.html#1',2,'match555524-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import io.netty.util.HashingStrategy;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import static io.netty.handler.codec.CharSequenceValueConverter.*;
import static io.netty.handler.codec.http2.DefaultHttp2Headers.*;
import static io.netty.util.AsciiString.*;
import static io.netty.util.internal.EmptyArrays.*;
import static io.netty.util.internal.ObjectUtil.checkNotNullArrayParam;

/**
 * A variant of {@link Http2Headers} which only supports read-only methods.
 * &lt;p&gt;
 * Any array passed to this class may be used directly in the underlying data structures of this class. If these
 * arrays may be modified it is the caller's responsibility to supply this class with a copy of the array.
 * &lt;p&gt;
 * This may be a good alternative to {@link DefaultHttp2Headers} if your have a fixed set of headers which will not
 * change.
 */
public final class ReadOnlyHttp2Headers implements Http2Headers {
    private static final byte PSEUDO_HEADER_TOKEN = (byte) ':</B></FONT>';
    private final AsciiString[] pseudoHeaders;
    private final AsciiString[] otherHeaders;

    /**
     * Used to create read only object designed to represent trailers.
     * &lt;p&gt;
     * If this is used for a purpose other than trailers you may violate the header serialization ordering defined by
     * &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.1.2.1&quot;&gt;RFC 7540, 8.1.2.1&lt;/a&gt;.
     * @param validateHeaders {@code true} will run validation on each header name/value pair to ensure protocol
     *                        compliance.
     * @param otherHeaders A an array of key:value pairs. Must not contain any
     *                     &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.1.2.1&quot;&gt;pseudo headers&lt;/a&gt;
     *                     or {@code null} names/values.
     *                     A copy will &lt;strong&gt;NOT&lt;/strong&gt; be made of this array. If the contents of this array
     *                     may be modified externally you are responsible for passing in a copy.
     * @return A read only representation of the headers.
     */
    public static ReadOnlyHttp2Headers trailers(boolean validateHeaders, AsciiString... otherHeaders) {
        return new ReadOnlyHttp2Headers(validateHeaders, EMPTY_ASCII_STRINGS, otherHeaders);
    }

    /**
     * Create a new read only representation of headers used by clients.
     * @param validateHeaders {@code true} will run validation on each header name/value pair to ensure protocol
     *                        compliance.
     * @param method The value for {@link PseudoHeaderName#METHOD}.
     * @param path The value for {@link PseudoHeaderName#PATH}.
     * @param scheme The value for {@link PseudoHeaderName#SCHEME}.
     * @param authority The value for {@link PseudoHeaderName#AUTHORITY}.
     * @param otherHeaders A an array of key:value pairs. Must not contain any
     *                     &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.1.2.1&quot;&gt;pseudo headers&lt;/a&gt;
     *                     or {@code null} names/values.
     *                     A copy will &lt;strong&gt;NOT&lt;/strong&gt; be made of this array. If the contents of this array
     *                     may be modified externally you are responsible for passing in a copy.
     * @return a new read only representation of headers used by clients.
     */
    public static ReadOnlyHttp2Headers clientHeaders(boolean validateHeaders,
                                                     AsciiString method, AsciiString path,
                                                     AsciiString scheme, AsciiString authority,
                                                     AsciiString... otherHeaders) {
        return new ReadOnlyHttp2Headers(validateHeaders,
                new AsciiString[] {
                  PseudoHeaderName.METHOD.value(), method, PseudoHeaderName.PATH.value(), path,
                  PseudoHeaderName.SCHEME.value(), scheme, PseudoHeaderName.AUTHORITY.value(), authority
                },
                otherHeaders);
    }

    /**
     * Create a new read only representation of headers used by servers.
     * @param validateHeaders {@code true} will run validation on each header name/value pair to ensure protocol
     *                        compliance.
     * @param status The value for {@link PseudoHeaderName#STATUS}.
     * @param otherHeaders A an array of key:value pairs. Must not contain any
     *                     &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.1.2.1&quot;&gt;pseudo headers&lt;/a&gt;
     *                     or {@code null} names/values.
     *                     A copy will &lt;strong&gt;NOT&lt;/strong&gt; be made of this array. If the contents of this array
     *                     may be modified externally you are responsible for passing in a copy.
     * @return a new read only representation of headers used by servers.
     */
    public static ReadOnlyHttp2Headers serverHeaders(boolean validateHeaders,
                                                     AsciiString status,
                                                     AsciiString... otherHeaders) {
        return new ReadOnlyHttp2Headers(validateHeaders,
                                        new AsciiString[] { PseudoHeaderName.STATUS.value(), status },
                                        otherHeaders);
    }

    private ReadOnlyHttp2Headers(boolean validateHeaders, AsciiString[] pseudoHeaders, AsciiString... otherHeaders) {
        assert (pseudoHeaders.length &amp; 1) == 0; // pseudoHeaders are only set internally so assert should be enough.
        if ((otherHeaders.length &amp; 1) != 0) {
            throw newInvalidArraySizeException();
        }
        if (validateHeaders) {
            validateHeaders(pseudoHeaders, otherHeaders);
        }
        this.pseudoHeaders = pseudoHeaders;
        this.otherHeaders = otherHeaders;
    }

    private static IllegalArgumentException newInvalidArraySizeException() {
        return new IllegalArgumentException(&quot;pseudoHeaders and otherHeaders must be arrays of [name, value] pairs&quot;);
    }

    private static void validateHeaders(AsciiString[] pseudoHeaders, AsciiString... otherHeaders) {
        // We are only validating values... so start at 1 and go until end.
        for (int i = 1; i &lt; pseudoHeaders.length; i += 2) {
            // pseudoHeaders names are only set internally so they are assumed to be valid.
            checkNotNullArrayParam(pseudoHeaders[i], i, &quot;pseudoHeaders&quot;);
        }

        boolean seenNonPseudoHeader = false;
        final int otherHeadersEnd = otherHeaders.length - 1;
        for (int i = 0; i &lt; otherHeadersEnd; i += 2) {
            AsciiString name = otherHeaders[i];
            HTTP2_NAME_VALIDATOR.validateName(name);
            if (!seenNonPseudoHeader &amp;&amp; !name.isEmpty() &amp;&amp; name.byteAt(0) != PSEUDO_HEADER_TOKEN) {
                seenNonPseudoHeader = true;
            } else if (seenNonPseudoHeader &amp;&amp; !name.isEmpty() &amp;&amp; name.byteAt(0) == PSEUDO_HEADER_TOKEN) {
                throw new IllegalArgumentException(
                     &quot;otherHeaders name at index &quot; + i + &quot; is a pseudo header that appears after non-pseudo headers.&quot;);
            }
            checkNotNullArrayParam(otherHeaders[i + 1], i + 1, &quot;otherHeaders&quot;);
        }
    }

    private AsciiString get0(CharSequence name) {
        final int nameHash = AsciiString.hashCode(name);

        final int pseudoHeadersEnd = pseudoHeaders.length - 1;
        for (int i = 0; i &lt; pseudoHeadersEnd; i += 2) {
            AsciiString roName = pseudoHeaders[i];
            if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
                return pseudoHeaders[i + 1];
            }
        }

        final int otherHeadersEnd = otherHeaders.length - 1;
        for (int i = 0; i &lt; otherHeadersEnd; i += 2) {
            AsciiString roName = otherHeaders[i];
            if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
                return otherHeaders[i + 1];
            }
        }
        return null;
    }

    @Override
    public CharSequence get(CharSequence name) {
        return get0(name);
    }

    @Override
    public CharSequence get(CharSequence name, CharSequence defaultValue) {
        CharSequence value = get(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public CharSequence getAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public CharSequence getAndRemove(CharSequence name, CharSequence defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public List&lt;CharSequence&gt; getAll(CharSequence name) {
        final int nameHash = AsciiString.hashCode(name);
        List&lt;CharSequence&gt; values = new ArrayList&lt;CharSequence&gt;();

        final int pseudoHeadersEnd = pseudoHeaders.length - 1;
        for (int i = 0; i &lt; pseudoHeadersEnd; i += 2) {
            AsciiString roName = pseudoHeaders[i];
            if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
                values.add(pseudoHeaders[i + 1]);
            }
        }

        final int otherHeadersEnd = otherHeaders.length - 1;
        for (int i = 0; i &lt; otherHeadersEnd; i += 2) {
            AsciiString roName = otherHeaders[i];
            if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
                values.add(otherHeaders[i + 1]);
            }
        }

        return values;
    }

    @Override
    public List&lt;CharSequence&gt; getAllAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Boolean getBoolean(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToBoolean(value) : null;
    }

    @Override
    public boolean getBoolean(CharSequence name, boolean defaultValue) {
        Boolean value = getBoolean(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Byte getByte(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToByte(value) : null;
    }

    @Override
    public byte getByte(CharSequence name, byte defaultValue) {
        Byte value = getByte(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Character getChar(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToChar(value) : null;
    }

    @Override
    public char getChar(CharSequence name, char defaultValue) {
        Character value = getChar(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Short getShort(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToShort(value) : null;
    }

    @Override
    public short getShort(CharSequence name, short defaultValue) {
        Short value = getShort(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Integer getInt(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToInt(value) : null;
    }

    @Override
    public int getInt(CharSequence name, int defaultValue) {
        Integer value = getInt(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Long getLong(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToLong(value) : null;
    }

    @Override
    public long getLong(CharSequence name, long defaultValue) {
        Long value = getLong(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Float getFloat(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToFloat(value) : null;
    }

    @Override
    public float getFloat(CharSequence name, float defaultValue) {
        Float value = getFloat(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Double getDouble(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToDouble(value) : null;
    }

    @Override
    public double getDouble(CharSequence name, double defaultValue) {
        Double value = getDouble(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Long getTimeMillis(CharSequence name) {
        AsciiString value = get0(name);
        return value != null ? INSTANCE.convertToTimeMillis(value) : null;
    }

    @Override
    public long getTimeMillis(CharSequence name, long defaultValue) {
        Long value = getTimeMillis(name);
        return value != null ? value : defaultValue;
    }

    @Override
    public Boolean getBooleanAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public boolean getBooleanAndRemove(CharSequence name, boolean defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Byte getByteAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public byte getByteAndRemove(CharSequence name, byte defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Character getCharAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public char getCharAndRemove(CharSequence name, char defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Short getShortAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public short getShortAndRemove(CharSequence name, short defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Integer getIntAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public int getIntAndRemove(CharSequence name, int defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Long getLongAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public long getLongAndRemove(CharSequence name, long defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Float getFloatAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public float getFloatAndRemove(CharSequence name, float defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Double getDoubleAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public double getDoubleAndRemove(CharSequence name, double defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Long getTimeMillisAndRemove(CharSequence name) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public long getTimeMillisAndRemove(CharSequence name, long defaultValue) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public boolean contains(CharSequence name) {
        return get(name) != null;
    }

    @Override
    public boolean contains(CharSequence name, CharSequence value) {
        return contains(name, value, false);
    }

    @Override
    public boolean containsObject(CharSequence name, Object value) {
        if (value instanceof CharSequence) {
            return contains(name, (CharSequence) value);
        }
        return contains(name, value.toString());
    }

    @Override
    public boolean containsBoolean(CharSequence name, boolean value) {
        return contains(name, String.valueOf(value));
    }

    @Override
    public boolean containsByte(CharSequence name, byte value) {
        return contains(name, String.valueOf(value));
    }

    @Override
    public boolean containsChar(CharSequence name, char value) {
        return contains(name, String.valueOf(value));
    }

    @Override
    public boolean containsShort(CharSequence name, short value) {
        return contains(name, String.valueOf(value));
    }

    @Override
    public boolean containsInt(CharSequence name, int value) {
        return contains(name, String.valueOf(value));
    }

    @Override
    public boolean containsLong(CharSequence name, long value) {
        return contains(name, String.valueOf(value));
<A NAME="4"></A>    }

    @Override
    public boolean containsFloat(CharSequence name, <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match555524-0.html#4',2,'match555524-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>float value) {
        return false;
    }

    @Override
    public boolean containsDouble(CharSequence name, double value</B></FONT>) {
        return contains(name, String.valueOf(value));
    }
<A NAME="2"></A>
    @Override
    public boolean containsTimeMillis(CharSequence name, long value) {
        return contains(name, <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match555524-0.html#2',2,'match555524-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>String.valueOf(value));
    }

    @Override
    public int size() {
        return pseudoHeaders.length + otherHeaders.length &gt;&gt;&gt; 1;
    }

    @</B></FONT>Override
    public boolean isEmpty() {
        return pseudoHeaders.length == 0 &amp;&amp; otherHeaders.length == 0;
    }

    @Override
    public Set&lt;CharSequence&gt; names() {
        if (isEmpty()) {
            return Collections.emptySet();
        }
        Set&lt;CharSequence&gt; names = new LinkedHashSet&lt;CharSequence&gt;(size());
        final int pseudoHeadersEnd = pseudoHeaders.length - 1;
        for (int i = 0; i &lt; pseudoHeadersEnd; i += 2) {
            names.add(pseudoHeaders[i]);
        }

        final int otherHeadersEnd = otherHeaders.length - 1;
        for (int i = 0; i &lt; otherHeadersEnd; i += 2) {
            names.add(otherHeaders[i]);
        }
        return names;
    }

    @Override
    public Http2Headers add(CharSequence name, CharSequence value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers add(CharSequence name, Iterable&lt;? extends CharSequence&gt; values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers add(CharSequence name, CharSequence... values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addObject(CharSequence name, Object value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addObject(CharSequence name, Iterable&lt;?&gt; values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addObject(CharSequence name, Object... values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addBoolean(CharSequence name, boolean value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addByte(CharSequence name, byte value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addChar(CharSequence name, char value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addShort(CharSequence name, short value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addInt(CharSequence name, int value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addLong(CharSequence name, long value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addFloat(CharSequence name, float value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addDouble(CharSequence name, double value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers addTimeMillis(CharSequence name, long value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers add(Headers&lt;? extends CharSequence, ? extends CharSequence, ?&gt; headers) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers set(CharSequence name, CharSequence value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers set(CharSequence name, Iterable&lt;? extends CharSequence&gt; values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers set(CharSequence name, CharSequence... values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setObject(CharSequence name, Object value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setObject(CharSequence name, Iterable&lt;?&gt; values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setObject(CharSequence name, Object... values) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setBoolean(CharSequence name, boolean value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setByte(CharSequence name, byte value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setChar(CharSequence name, char value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setShort(CharSequence name, short value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setInt(CharSequence name, int value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setLong(CharSequence name, long value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setFloat(CharSequence name, float value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setDouble(CharSequence name, double value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setTimeMillis(CharSequence name, long value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers set(Headers&lt;? extends CharSequence, ? extends CharSequence, ?&gt; headers) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers setAll(Headers&lt;? extends CharSequence, ? extends CharSequence, ?&gt; headers) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public boolean remove(CharSequence name) {
<A NAME="3"></A>        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match555524-0.html#3',2,'match555524-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    public Http2Headers clear() {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Iterator&lt;Map.Entry&lt;CharSequence, CharSequence&gt;&gt; iterator() {</B></FONT>
        return new ReadOnlyIterator();
    }

    @Override
    public Iterator&lt;CharSequence&gt; valueIterator(CharSequence name) {
        return new ReadOnlyValueIterator(name);
    }

    @Override
    public Http2Headers method(CharSequence value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers scheme(CharSequence value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers authority(CharSequence value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers path(CharSequence value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public Http2Headers status(CharSequence value) {
        throw new UnsupportedOperationException(&quot;read only&quot;);
    }

    @Override
    public CharSequence method() {
        return get(PseudoHeaderName.METHOD.value());
    }

    @Override
    public CharSequence scheme() {
        return get(PseudoHeaderName.SCHEME.value());
    }

    @Override
    public CharSequence authority() {
        return get(PseudoHeaderName.AUTHORITY.value());
    }

    @Override
    public CharSequence path() {
        return get(PseudoHeaderName.PATH.value());
    }

    @Override
    public CharSequence status() {
        return get(PseudoHeaderName.STATUS.value());
    }

    @Override
    public boolean contains(CharSequence name, CharSequence value, boolean caseInsensitive) {
        final int nameHash = AsciiString.hashCode(name);
        final HashingStrategy&lt;CharSequence&gt; strategy =
                caseInsensitive ? CASE_INSENSITIVE_HASHER : CASE_SENSITIVE_HASHER;
        final int valueHash = strategy.hashCode(value);

        return contains(name, nameHash, value, valueHash, strategy, otherHeaders)
                || contains(name, nameHash, value, valueHash, strategy, pseudoHeaders);
    }

    private static boolean contains(CharSequence name, int nameHash, CharSequence value, int valueHash,
                                    HashingStrategy&lt;CharSequence&gt; hashingStrategy, AsciiString[] headers) {
        final int headersEnd = headers.length - 1;
        for (int i = 0; i &lt; headersEnd; i += 2) {
            AsciiString roName = headers[i];
            AsciiString roValue = headers[i + 1];
            if (roName.hashCode() == nameHash &amp;&amp; roValue.hashCode() == valueHash &amp;&amp;
                roName.contentEqualsIgnoreCase(name) &amp;&amp; hashingStrategy.equals(roValue, value)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(getClass().getSimpleName()).append('[');
        String separator = &quot;&quot;;
        for (Map.Entry&lt;CharSequence, CharSequence&gt; entry : this) {
            builder.append(separator);
            builder.append(entry.getKey()).append(&quot;: &quot;).append(entry.getValue());
            separator = &quot;, &quot;;
        }
        return builder.append(']').toString();
    }

    private final class ReadOnlyValueIterator implements Iterator&lt;CharSequence&gt; {
        private int i;
        private final int nameHash;
        private final CharSequence name;
        private AsciiString[] current = pseudoHeaders.length != 0 ? pseudoHeaders : otherHeaders;
        private AsciiString next;

        ReadOnlyValueIterator(CharSequence name) {
            nameHash = AsciiString.hashCode(name);
            this.name = name;
            calculateNext();
        }

        @Override
        public boolean hasNext() {
            return next != null;
        }

        @Override
        public CharSequence next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            CharSequence current = next;
            calculateNext();
            return current;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException(&quot;read only&quot;);
        }

        private void calculateNext() {
            for (; i &lt; current.length; i += 2) {
                AsciiString roName = current[i];
                if (roName.hashCode() == nameHash &amp;&amp; roName.contentEqualsIgnoreCase(name)) {
                    if (i + 1 &lt; current.length) {
                        next = current[i + 1];
                        i += 2;
                    }
                    return;
                }
            }
            if (current == pseudoHeaders) {
                i = 0;
                current = otherHeaders;
                calculateNext();
            } else {
                next = null;
            }
        }
    }

    private final class ReadOnlyIterator implements Map.Entry&lt;CharSequence, CharSequence&gt;,
                                                    Iterator&lt;Map.Entry&lt;CharSequence, CharSequence&gt;&gt; {
        private int i;
        private AsciiString[] current = pseudoHeaders.length != 0 ? pseudoHeaders : otherHeaders;
        private AsciiString key;
        private AsciiString value;

        @Override
        public boolean hasNext() {
            return i != current.length;
        }

        @Override
        public Map.Entry&lt;CharSequence, CharSequence&gt; next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            key = current[i];
            value = current[i + 1];
            i += 2;
            if (i == current.length &amp;&amp; current == pseudoHeaders) {
<A NAME="0"></A>                current = otherHeaders;
                i = 0;
            }
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match555524-0.html#0',2,'match555524-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return this;
        }

        @Override
        public CharSequence getKey() {
            return key;
        }

        @Override
        public CharSequence getValue() {
            return value;
        }

        @Override
        public CharSequence setValue(CharSequence value</B></FONT>) {
            throw new UnsupportedOperationException(&quot;read only&quot;);
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException(&quot;read only&quot;);
        }

        @Override
        public String toString() {
            return key.toString() + '=' + value.toString();
        }
    }
}
</PRE>
</div>
  </div>
</body>
</html>
