
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.981566820276496%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>segmentfault-lessons-MDEwOlJlcG9zaXRvcnk5MzE1NzM4MQ==-flat-RepositoryAnnotationProcessor.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.segementfalut.deep.in.java.annotation.processing;
2  import javax.annotation.processing.*;
3  import javax.lang.model.SourceVersion;
4  import javax.lang.model.element.Element;
5  import javax.lang.model.element.ElementKind;
6  import javax.lang.model.element.Modifier;
7  import javax.lang.model.element.TypeElement;
8  import javax.lang.model.type.DeclaredType;
9  import javax.lang.model.type.TypeMirror;
10  import javax.lang.model.util.Types;
11  import javax.tools.FileObject;
12  import javax.tools.StandardLocation;
13  import java.io.IOException;
14  import java.io.Writer;
15  import java.sql.Wrapper;
16  import java.util.*;
</span>17  @SupportedAnnotationTypes(RepositoryAnnotationProcessor.REPOSITORY_ANNOTATION_CLASS_NAME)
18  @SupportedSourceVersion(SourceVersion.RELEASE_8)
19  public class RepositoryAnnotationProcessor extends AbstractProcessor {
20      public static final String REPOSITORY_ANNOTATION_CLASS_NAME = "com.segementfalut.deep.in.java.reflection.Repository";
21      private static final String CRUD_REPOSITORY_INTERFACE_CLASS_NAME = "com.segementfalut.deep.in.java.reflection.CrudRepository";
22      private Map<String, String> crudRepositoryParameterizedTypesMapping = new HashMap<>();
23      @Override
24      public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
25          roundEnv.getRootElements()
26                  .stream()
27                  .filter(this::isRepositoryAnnotationPresent) 
28                  .forEach(this::processRepositoryAnnotatedElement);     
29          if (roundEnv.processingOver()) {
30              try {
31                  generateCrudRepositoryParameterizedTypesMetadata();
32              } catch (IOException e) {
33                  throw new RuntimeException(e);
34              }
35          }
36          return false;
37      }
38      private void generateCrudRepositoryParameterizedTypesMetadata() throws IOException {
39          Filer filer = processingEnv.getFiler();
40          String resourceName = "META-INF/crud-repos-mappings.properties";
41          FileObject fileObject = filer.createResource(StandardLocation.CLASS_OUTPUT, "", resourceName);
42          try (Writer writer = fileObject.openWriter()) {
43              Properties properties = new Properties();
44              properties.putAll(crudRepositoryParameterizedTypesMapping);
45              properties.store(writer, "Generated by RepositoryAnnotationProcessor");
46          }
47      }
48      private void processRepositoryAnnotatedElement(Element element) {
49          if (!isConcreteClass(element) || !isCrudRepositoryType(element)) {
50              return;
51          }
52          System.out.println("CrudRepository 实现类为 ：" + element.toString());
53          TypeMirror crudRepositoryGenericInterfaceType = getGenericInterfaceType(element, CRUD_REPOSITORY_INTERFACE_CLASS_NAME);
54          System.out.println("CrudRepository 实现泛型接口定义为 ：" + crudRepositoryGenericInterfaceType.toString());
55          DeclaredType declaredType = DeclaredType.class.cast(crudRepositoryGenericInterfaceType);
56          List<? extends TypeMirror> parameterizedTypes = declaredType.getTypeArguments();
57          TypeMirror firstArgumentType = parameterizedTypes.get(0);
58          System.out.println("CrudRepository 实现接口的首个泛型参数为 ：" + firstArgumentType.toString());
59          crudRepositoryParameterizedTypesMapping.put(crudRepositoryGenericInterfaceType.toString(), firstArgumentType.toString());
60      }
61      private boolean isConcreteClass(Element element) {
62          return !element.getModifiers().contains(Modifier.ABSTRACT);
63      }
64      private boolean isCrudRepositoryType(Element element) {
65          return getGenericInterfaceType(element, CRUD_REPOSITORY_INTERFACE_CLASS_NAME) != null;
66      }
67      private TypeMirror getGenericInterfaceType(Element element, String interfaceTypeName) {
68          ElementKind kind = element.getKind();
69          if (kind.isClass() && element instanceof TypeElement) {
70              TypeElement typeElement = (TypeElement) element;
71              return typeElement.getInterfaces().stream() 
72                      .filter(interfaceType -> typeEquals(interfaceType, interfaceTypeName))
73                      .findFirst() 
74                      .orElse(null);
75          }
76          return null;
77      }
78      private boolean typeEquals(TypeMirror type, String typeName) {
79          Types types = processingEnv.getTypeUtils();
80          TypeMirror erasedType = types.erasure(type); 
81          return Objects.equals(typeName, erasedType.toString());
82      }
83      private boolean isRepositoryAnnotationPresent(Element element) {
84          return isAnnotationPresent(element, REPOSITORY_ANNOTATION_CLASS_NAME);
85      }
86      private boolean isAnnotationPresent(Element element, String annotationClassName) {
87          return element.getAnnotationMirrors() 
88                  .stream()
89                  .filter(annotation -> Objects.equals(annotationClassName, annotation.getAnnotationType().toString()))
90                  .count() > 0;
91      }
92  }
</code></pre>
        </div>
        <div class="column">
            <h3>motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-RefererConfig.java</h3>
            <pre><code><span onclick='openModal()' class='match'>1  package com.weibo.api.motan.config;
2  import com.weibo.api.motan.cluster.Cluster;
3  import com.weibo.api.motan.cluster.support.ClusterSupport;
4  import com.weibo.api.motan.common.MotanConstants;
5  import com.weibo.api.motan.common.URLParamType;
6  import com.weibo.api.motan.config.annotation.ConfigDesc;
7  import com.weibo.api.motan.config.handler.ConfigHandler;
8  import com.weibo.api.motan.core.extension.ExtensionLoader;
9  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
10  import com.weibo.api.motan.exception.MotanFrameworkException;
11  import com.weibo.api.motan.proxy.ProxyFactory;
12  import com.weibo.api.motan.registry.RegistryService;
13  import com.weibo.api.motan.rpc.URL;
14  import com.weibo.api.motan.util.CollectionUtil;
15  import com.weibo.api.motan.util.LoggerUtil;
16  import com.weibo.api.motan.util.NetUtils;
</span>17  import com.weibo.api.motan.util.UrlUtils;
18  import org.apache.commons.lang3.StringUtils;
19  import java.util.*;
20  import java.util.concurrent.atomic.AtomicBoolean;
21  public class RefererConfig<T> extends AbstractRefererConfig {
22      private static final long serialVersionUID = -2299754608229467887L;
23      private Class<T> interfaceClass;
24      private String serviceInterface;
25      public String getServiceInterface() {
26          return serviceInterface;
27      }
28      public void setServiceInterface(String serviceInterface) {
29          this.serviceInterface = serviceInterface;
30      }
31      protected List<MethodConfig> methods;
32      private String directUrl;
33      private AtomicBoolean initialized = new AtomicBoolean(false);
34      private T ref;
35      private BasicRefererInterfaceConfig basicReferer;
36      private List<ClusterSupport<T>> clusterSupports;
37      public List<MethodConfig> getMethods() {
38          return methods;
39      }
40      public void setMethods(List<MethodConfig> methods) {
41          this.methods = methods;
42      }
43      public void setMethods(MethodConfig methods) {
44          this.methods = Collections.singletonList(methods);
45      }
46      public boolean hasMethods() {
47          return this.methods != null && !this.methods.isEmpty();
48      }
49      public T getRef() {
50          if (ref == null) {
51              initRef();
52          }
53          return ref;
54      }
55      @SuppressWarnings({"unchecked", "rawtypes"})
56      public synchronized void initRef() {
57          if (initialized.get()) {
58              return;
59          }
60          try {
61              interfaceClass = (Class) Class.forName(interfaceClass.getName(), true, Thread.currentThread().getContextClassLoader());
62          } catch (ClassNotFoundException e) {
63              throw new MotanFrameworkException("RefererConfig initRef Error: Class not found " + interfaceClass.getName(), e,
64                      MotanErrorMsgConstant.FRAMEWORK_INIT_ERROR);
65          }
66          checkInterfaceAndMethods(interfaceClass, methods);
67          if (meshClient != null) { 
68              initMeshClientRef();
69          } else { 
70              initClusterRef();
71          }
72          initialized.set(true);
73      }
74      private void initClusterRef() {
75          if (CollectionUtil.isEmpty(protocols)) {
76              throw new MotanFrameworkException(String.format("%s RefererConfig is malformed, for protocol not set correctly!",
77                      interfaceClass.getName()));
78          }
79          clusterSupports = new ArrayList<>(protocols.size());
80          List<Cluster<T>> clusters = new ArrayList<>(protocols.size());
81          String proxy = null;
82          ConfigHandler configHandler = ExtensionLoader.getExtensionLoader(ConfigHandler.class).getExtension(MotanConstants.DEFAULT_VALUE);
83          loadRegistryUrls();
84          String localIp = getLocalHostAddress();
85          for (ProtocolConfig protocol : protocols) {
86              Map<String, String> params = new HashMap<>();
87              params.put(URLParamType.nodeType.getName(), MotanConstants.NODE_TYPE_REFERER);
88              params.put(URLParamType.version.getName(), URLParamType.version.getValue());
89              params.put(URLParamType.refreshTimestamp.getName(), String.valueOf(System.currentTimeMillis()));
90              collectConfigParams(params, protocol, basicReferer, extConfig, this);
91              collectMethodConfigParams(params, this.getMethods());
92              String path = StringUtils.isBlank(serviceInterface) ? interfaceClass.getName() : serviceInterface;
93              URL refUrl = new URL(protocol.getName(), localIp, MotanConstants.DEFAULT_INT_VALUE, path, params);
94              ClusterSupport<T> clusterSupport = createClusterSupport(refUrl, configHandler);
95              clusterSupports.add(clusterSupport);
96              clusters.add(clusterSupport.getCluster());
97              if (proxy == null) {
98                  proxy = getProxyType(refUrl);
99              }
100          }
101          ref = configHandler.refer(interfaceClass, clusters, proxy);
102      }
103      private void initMeshClientRef() {
104          Map<String, String> params = new HashMap<>();
105          params.put(URLParamType.nodeType.getName(), MotanConstants.NODE_TYPE_REFERER);
106          collectConfigParams(params, basicReferer, extConfig, this);
107          String path = StringUtils.isBlank(serviceInterface) ? interfaceClass.getName() : serviceInterface;
108          URL refUrl = new URL(MotanConstants.PROTOCOL_MOTAN2, getLocalHostAddress(), MotanConstants.DEFAULT_INT_VALUE, path, params);
109          ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(getProxyType(refUrl));
110          ref = proxyFactory.getProxy(interfaceClass, refUrl, meshClient);
111          LoggerUtil.info("init mesh client referer finish. url:" + refUrl.toFullStr());
112      }
113      private String getProxyType(URL refUrl) {
114          String defaultProxy = StringUtils.isBlank(serviceInterface) ? URLParamType.proxy.getValue() : MotanConstants.PROXY_COMMON;
115          return refUrl.getParameter(URLParamType.proxy.getName(), defaultProxy);
116      }
117      private ClusterSupport<T> createClusterSupport(URL refUrl, ConfigHandler configHandler) {
118          LoggerUtil.info("create cluster for refer url :" + refUrl.toFullStr());
119          List<URL> regUrls = new ArrayList<>();
120          if (StringUtils.isNotBlank(directUrl) || MotanConstants.PROTOCOL_INJVM.equals(refUrl.getProtocol())) {
121              URL regUrl =
122                      new URL(MotanConstants.REGISTRY_PROTOCOL_LOCAL, NetUtils.LOCALHOST, MotanConstants.DEFAULT_INT_VALUE,
123                              RegistryService.class.getName());
124              if (StringUtils.isNotBlank(directUrl)) {
125                  List<URL> directUrls = new ArrayList<>();
126                  String[] dus = MotanConstants.COMMA_SPLIT_PATTERN.split(directUrl);
127                  for (String du : dus) {
128                      if (du.contains(":")) {
129                          String[] hostPort = du.split(":");
130                          URL durl = refUrl.createCopy();
131                          durl.setHost(hostPort[0].trim());
132                          durl.setPort(Integer.parseInt(hostPort[1].trim()));
133                          durl.addParameter(URLParamType.nodeType.getName(), MotanConstants.NODE_TYPE_SERVICE);
134                          directUrls.add(durl);
135                      }
136                  }
137                  String directUrlsString = UrlUtils.urlsToString(directUrls);
138                  if (StringUtils.isNotBlank(directUrlsString)) {
139                      regUrl.addParameter(URLParamType.directUrl.getName(), directUrlsString);
140                  } else {
141                      LoggerUtil.warn("parse directUrl string is empty. directUrl:" + directUrl);
142                  }
143              }
144              regUrls.add(regUrl);
145          } else { 
146              if (registryUrls == null || registryUrls.isEmpty()) {
147                  throw new IllegalStateException(
148                          String.format(
149                                  "No registry to reference %s on the consumer %s , please config <motan:registry address=\"...\" /> in your spring config.",
150                                  interfaceClass, NetUtils.LOCALHOST));
151              }
152              for (URL url : registryUrls) {
153                  regUrls.add(url.createCopy());
154              }
155          }
156          return configHandler.buildClusterSupport(interfaceClass, regUrls, refUrl);
157      }
158      public synchronized void destroy() {
159          if (clusterSupports != null) {
160              for (ClusterSupport<T> clusterSupport : clusterSupports) {
161                  clusterSupport.destroy();
162              }
163          }
164          ref = null;
165          initialized.set(false);
166      }
167      public void setInterface(Class<T> interfaceClass) {
168          if (interfaceClass != null && !interfaceClass.isInterface()) {
169              throw new IllegalStateException("The interface class " + interfaceClass + " is not a interface!");
170          }
171          this.interfaceClass = interfaceClass;
172      }
173      public Class<?> getInterface() {
174          return interfaceClass;
175      }
176      public String getDirectUrl() {
177          return directUrl;
178      }
179      public void setDirectUrl(String directUrl) {
180          this.directUrl = directUrl;
181      }
182      @ConfigDesc(excluded = true)
183      public BasicRefererInterfaceConfig getBasicReferer() {
184          return basicReferer;
185      }
186      public void setBasicReferer(BasicRefererInterfaceConfig basicReferer) {
187          this.basicReferer = basicReferer;
188      }
189      public List<ClusterSupport<T>> getClusterSupports() {
190          return clusterSupports;
191      }
192      public AtomicBoolean getInitialized() {
193          return initialized;
194      }
195  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from segmentfault-lessons-MDEwOlJlcG9zaXRvcnk5MzE1NzM4MQ==-flat-RepositoryAnnotationProcessor.java</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from motan-MDEwOlJlcG9zaXRvcnk1NjY3OTUyMQ==-flat-RefererConfig.java</div>
                </div>
                <div class="column column_space"><pre><code>1  package com.segementfalut.deep.in.java.annotation.processing;
2  import javax.annotation.processing.*;
3  import javax.lang.model.SourceVersion;
4  import javax.lang.model.element.Element;
5  import javax.lang.model.element.ElementKind;
6  import javax.lang.model.element.Modifier;
7  import javax.lang.model.element.TypeElement;
8  import javax.lang.model.type.DeclaredType;
9  import javax.lang.model.type.TypeMirror;
10  import javax.lang.model.util.Types;
11  import javax.tools.FileObject;
12  import javax.tools.StandardLocation;
13  import java.io.IOException;
14  import java.io.Writer;
15  import java.sql.Wrapper;
16  import java.util.*;
</pre></code></div>
                <div class="column column_space"><pre><code>1  package com.weibo.api.motan.config;
2  import com.weibo.api.motan.cluster.Cluster;
3  import com.weibo.api.motan.cluster.support.ClusterSupport;
4  import com.weibo.api.motan.common.MotanConstants;
5  import com.weibo.api.motan.common.URLParamType;
6  import com.weibo.api.motan.config.annotation.ConfigDesc;
7  import com.weibo.api.motan.config.handler.ConfigHandler;
8  import com.weibo.api.motan.core.extension.ExtensionLoader;
9  import com.weibo.api.motan.exception.MotanErrorMsgConstant;
10  import com.weibo.api.motan.exception.MotanFrameworkException;
11  import com.weibo.api.motan.proxy.ProxyFactory;
12  import com.weibo.api.motan.registry.RegistryService;
13  import com.weibo.api.motan.rpc.URL;
14  import com.weibo.api.motan.util.CollectionUtil;
15  import com.weibo.api.motan.util.LoggerUtil;
16  import com.weibo.api.motan.util.NetUtils;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    