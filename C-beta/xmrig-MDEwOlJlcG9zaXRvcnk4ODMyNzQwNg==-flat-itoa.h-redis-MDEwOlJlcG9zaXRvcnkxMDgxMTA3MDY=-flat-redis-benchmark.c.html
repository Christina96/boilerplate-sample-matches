
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.830856334041047%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-itoa.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_ITOA_
2  #define RAPIDJSON_ITOA_
3  #include "../rapidjson.h"
4  RAPIDJSON_NAMESPACE_BEGIN
5  namespace internal {
6  inline const char* GetDigitsLut() {
7      static const char cDigitsLut[200] = {
8          '0','0','0','1','0','2','0','3','0','4','0','5','0','6','0','7','0','8','0','9',
9          '1','0','1','1','1','2','1','3','1','4','1','5','1','6','1','7','1','8','1','9',
10          '2','0','2','1','2','2','2','3','2','4','2','5','2','6','2','7','2','8','2','9',
11          '3','0','3','1','3','2','3','3','3','4','3','5','3','6','3','7','3','8','3','9',
12          '4','0','4','1','4','2','4','3','4','4','4','5','4','6','4','7','4','8','4','9',
13          '5','0','5','1','5','2','5','3','5','4','5','5','5','6','5','7','5','8','5','9',
14          '6','0','6','1','6','2','6','3','6','4','6','5','6','6','6','7','6','8','6','9',
15          '7','0','7','1','7','2','7','3','7','4','7','5','7','6','7','7','7','8','7','9',
16          '8','0','8','1','8','2','8','3','8','4','8','5','8','6','8','7','8','8','8','9',
17          '9','0','9','1','9','2','9','3','9','4','9','5','9','6','9','7','9','8','9','9'
18      };
19      return cDigitsLut;
20  }
<span onclick='openModal()' class='match'>21  inline char* u32toa(uint32_t value, char* buffer) {
22      RAPIDJSON_ASSERT(buffer != 0);
23      const char* cDigitsLut = GetDigitsLut();
24      if (value < 10000) {
25          const uint32_t d1 = (value / 100) << 1;
</span>26          const uint32_t d2 = (value % 100) << 1;
27          if (value >= 1000)
28              *buffer++ = cDigitsLut[d1];
29          if (value >= 100)
30              *buffer++ = cDigitsLut[d1 + 1];
31          if (value >= 10)
32              *buffer++ = cDigitsLut[d2];
33          *buffer++ = cDigitsLut[d2 + 1];
34      }
35      else if (value < 100000000) {
36          const uint32_t b = value / 10000;
37          const uint32_t c = value % 10000;
38          const uint32_t d1 = (b / 100) << 1;
39          const uint32_t d2 = (b % 100) << 1;
40          const uint32_t d3 = (c / 100) << 1;
41          const uint32_t d4 = (c % 100) << 1;
42          if (value >= 10000000)
43              *buffer++ = cDigitsLut[d1];
44          if (value >= 1000000)
45              *buffer++ = cDigitsLut[d1 + 1];
46          if (value >= 100000)
47              *buffer++ = cDigitsLut[d2];
48          *buffer++ = cDigitsLut[d2 + 1];
49          *buffer++ = cDigitsLut[d3];
50          *buffer++ = cDigitsLut[d3 + 1];
51          *buffer++ = cDigitsLut[d4];
52          *buffer++ = cDigitsLut[d4 + 1];
53      }
54      else {
55          const uint32_t a = value / 100000000; 
56          value %= 100000000;
57          if (a >= 10) {
58              const unsigned i = a << 1;
59              *buffer++ = cDigitsLut[i];
60              *buffer++ = cDigitsLut[i + 1];
61          }
62          else
63              *buffer++ = static_cast<char>('0' + static_cast<char>(a));
64          const uint32_t b = value / 10000; 
65          const uint32_t c = value % 10000; 
66          const uint32_t d1 = (b / 100) << 1;
67          const uint32_t d2 = (b % 100) << 1;
68          const uint32_t d3 = (c / 100) << 1;
69          const uint32_t d4 = (c % 100) << 1;
70          *buffer++ = cDigitsLut[d1];
71          *buffer++ = cDigitsLut[d1 + 1];
72          *buffer++ = cDigitsLut[d2];
73          *buffer++ = cDigitsLut[d2 + 1];
74          *buffer++ = cDigitsLut[d3];
75          *buffer++ = cDigitsLut[d3 + 1];
76          *buffer++ = cDigitsLut[d4];
77          *buffer++ = cDigitsLut[d4 + 1];
78      }
79      return buffer;
80  }
81  inline char* i32toa(int32_t value, char* buffer) {
82      RAPIDJSON_ASSERT(buffer != 0);
83      uint32_t u = static_cast<uint32_t>(value);
84      if (value < 0) {
85          *buffer++ = '-';
86          u = ~u + 1;
87      }
88      return u32toa(u, buffer);
89  }
90  inline char* u64toa(uint64_t value, char* buffer) {
91      RAPIDJSON_ASSERT(buffer != 0);
92      const char* cDigitsLut = GetDigitsLut();
93      const uint64_t  kTen8 = 100000000;
94      const uint64_t  kTen9 = kTen8 * 10;
95      const uint64_t kTen10 = kTen8 * 100;
96      const uint64_t kTen11 = kTen8 * 1000;
97      const uint64_t kTen12 = kTen8 * 10000;
98      const uint64_t kTen13 = kTen8 * 100000;
99      const uint64_t kTen14 = kTen8 * 1000000;
100      const uint64_t kTen15 = kTen8 * 10000000;
101      const uint64_t kTen16 = kTen8 * kTen8;
102      if (value < kTen8) {
103          uint32_t v = static_cast<uint32_t>(value);
104          if (v < 10000) {
105              const uint32_t d1 = (v / 100) << 1;
106              const uint32_t d2 = (v % 100) << 1;
107              if (v >= 1000)
108                  *buffer++ = cDigitsLut[d1];
109              if (v >= 100)
110                  *buffer++ = cDigitsLut[d1 + 1];
111              if (v >= 10)
112                  *buffer++ = cDigitsLut[d2];
113              *buffer++ = cDigitsLut[d2 + 1];
114          }
115          else {
116              const uint32_t b = v / 10000;
117              const uint32_t c = v % 10000;
118              const uint32_t d1 = (b / 100) << 1;
119              const uint32_t d2 = (b % 100) << 1;
120              const uint32_t d3 = (c / 100) << 1;
121              const uint32_t d4 = (c % 100) << 1;
122              if (value >= 10000000)
123                  *buffer++ = cDigitsLut[d1];
124              if (value >= 1000000)
125                  *buffer++ = cDigitsLut[d1 + 1];
126              if (value >= 100000)
127                  *buffer++ = cDigitsLut[d2];
128              *buffer++ = cDigitsLut[d2 + 1];
129              *buffer++ = cDigitsLut[d3];
130              *buffer++ = cDigitsLut[d3 + 1];
131              *buffer++ = cDigitsLut[d4];
132              *buffer++ = cDigitsLut[d4 + 1];
133          }
134      }
135      else if (value < kTen16) {
136          const uint32_t v0 = static_cast<uint32_t>(value / kTen8);
137          const uint32_t v1 = static_cast<uint32_t>(value % kTen8);
138          const uint32_t b0 = v0 / 10000;
139          const uint32_t c0 = v0 % 10000;
140          const uint32_t d1 = (b0 / 100) << 1;
141          const uint32_t d2 = (b0 % 100) << 1;
142          const uint32_t d3 = (c0 / 100) << 1;
143          const uint32_t d4 = (c0 % 100) << 1;
144          const uint32_t b1 = v1 / 10000;
145          const uint32_t c1 = v1 % 10000;
146          const uint32_t d5 = (b1 / 100) << 1;
147          const uint32_t d6 = (b1 % 100) << 1;
148          const uint32_t d7 = (c1 / 100) << 1;
149          const uint32_t d8 = (c1 % 100) << 1;
150          if (value >= kTen15)
151              *buffer++ = cDigitsLut[d1];
152          if (value >= kTen14)
153              *buffer++ = cDigitsLut[d1 + 1];
154          if (value >= kTen13)
155              *buffer++ = cDigitsLut[d2];
156          if (value >= kTen12)
157              *buffer++ = cDigitsLut[d2 + 1];
158          if (value >= kTen11)
159              *buffer++ = cDigitsLut[d3];
160          if (value >= kTen10)
161              *buffer++ = cDigitsLut[d3 + 1];
162          if (value >= kTen9)
163              *buffer++ = cDigitsLut[d4];
164          *buffer++ = cDigitsLut[d4 + 1];
165          *buffer++ = cDigitsLut[d5];
166          *buffer++ = cDigitsLut[d5 + 1];
167          *buffer++ = cDigitsLut[d6];
168          *buffer++ = cDigitsLut[d6 + 1];
169          *buffer++ = cDigitsLut[d7];
170          *buffer++ = cDigitsLut[d7 + 1];
171          *buffer++ = cDigitsLut[d8];
172          *buffer++ = cDigitsLut[d8 + 1];
173      }
174      else {
175          const uint32_t a = static_cast<uint32_t>(value / kTen16); 
176          value %= kTen16;
177          if (a < 10)
178              *buffer++ = static_cast<char>('0' + static_cast<char>(a));
179          else if (a < 100) {
180              const uint32_t i = a << 1;
181              *buffer++ = cDigitsLut[i];
182              *buffer++ = cDigitsLut[i + 1];
183          }
184          else if (a < 1000) {
185              *buffer++ = static_cast<char>('0' + static_cast<char>(a / 100));
186              const uint32_t i = (a % 100) << 1;
187              *buffer++ = cDigitsLut[i];
188              *buffer++ = cDigitsLut[i + 1];
189          }
190          else {
191              const uint32_t i = (a / 100) << 1;
192              const uint32_t j = (a % 100) << 1;
193              *buffer++ = cDigitsLut[i];
194              *buffer++ = cDigitsLut[i + 1];
195              *buffer++ = cDigitsLut[j];
196              *buffer++ = cDigitsLut[j + 1];
197          }
198          const uint32_t v0 = static_cast<uint32_t>(value / kTen8);
199          const uint32_t v1 = static_cast<uint32_t>(value % kTen8);
200          const uint32_t b0 = v0 / 10000;
201          const uint32_t c0 = v0 % 10000;
202          const uint32_t d1 = (b0 / 100) << 1;
203          const uint32_t d2 = (b0 % 100) << 1;
204          const uint32_t d3 = (c0 / 100) << 1;
205          const uint32_t d4 = (c0 % 100) << 1;
206          const uint32_t b1 = v1 / 10000;
207          const uint32_t c1 = v1 % 10000;
208          const uint32_t d5 = (b1 / 100) << 1;
209          const uint32_t d6 = (b1 % 100) << 1;
210          const uint32_t d7 = (c1 / 100) << 1;
211          const uint32_t d8 = (c1 % 100) << 1;
212          *buffer++ = cDigitsLut[d1];
213          *buffer++ = cDigitsLut[d1 + 1];
214          *buffer++ = cDigitsLut[d2];
215          *buffer++ = cDigitsLut[d2 + 1];
216          *buffer++ = cDigitsLut[d3];
217          *buffer++ = cDigitsLut[d3 + 1];
218          *buffer++ = cDigitsLut[d4];
219          *buffer++ = cDigitsLut[d4 + 1];
220          *buffer++ = cDigitsLut[d5];
221          *buffer++ = cDigitsLut[d5 + 1];
222          *buffer++ = cDigitsLut[d6];
223          *buffer++ = cDigitsLut[d6 + 1];
224          *buffer++ = cDigitsLut[d7];
225          *buffer++ = cDigitsLut[d7 + 1];
226          *buffer++ = cDigitsLut[d8];
227          *buffer++ = cDigitsLut[d8 + 1];
228      }
229      return buffer;
230  }
231  inline char* i64toa(int64_t value, char* buffer) {
232      RAPIDJSON_ASSERT(buffer != 0);
233      uint64_t u = static_cast<uint64_t>(value);
234      if (value < 0) {
235          *buffer++ = '-';
236          u = ~u + 1;
237      }
238      return u64toa(u, buffer);
239  }
240  } 
241  RAPIDJSON_NAMESPACE_END
242  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-benchmark.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/win32fixes.h"
4  #include "Win32_Interop/win32_wsiocp2.h"
5  #include "Win32_Interop/Win32_Signal_Process.h"
6  #include "Win32_Interop/Win32_Time.h"
7  #include "Win32_Interop/Win32_Error.h"
8  #include "Win32_Interop/win32fixes.h"
9  #include "Win32_Interop/Win32_PThread.h"
10  #endif
11  #include "fmacros.h"
12  #include <stdio.h>
13  #include <string.h>
14  #include <stdlib.h>
15  POSIX_ONLY(#include <unistd.h>)
16  #include <errno.h>
17  #include <time.h>
18  POSIX_ONLY(#include <sys/time.h>)
19  #include <signal.h>
20  #include <assert.h>
21  #include <sds.h> &bsol;* Use hiredis sds. */
22  #include "ae.h"
23  #include "hiredis.h"
24  #ifdef _WIN32
25  #include "win32_hiredis.h"
26  #endif
27  #include "adlist.h"
28  #include "zmalloc.h"
29  #define UNUSED(V) ((void) V)
30  #define RANDPTR_INITIAL_SIZE 8
31  static struct config {
32      aeEventLoop *el;
33      const char *hostip;
34      int hostport;
35      const char *hostsocket;
36      int numclients;
37      int liveclients;
38      int requests;
39      int requests_issued;
40      int requests_finished;
41      int keysize;
42      int datasize;
43      int randomkeys;
44      int randomkeys_keyspacelen;
45      int keepalive;
46      int pipeline;
47      int showerrors;
48      PORT_LONGLONG start;
49      PORT_LONGLONG totlatency;
50      PORT_LONGLONG *latency;
51      const char *title;
52      list *clients;
53      int quiet;
54      int csv;
55      int loop;
56      int idlemode;
57      int dbnum;
58      sds dbnumstr;
59      char *tests;
60      char *auth;
61  } config;
62  typedef struct _client {
63      redisContext *context;
64      sds obuf;
65      char **randptr;         &bsol;* Pointers to :rand: strings inside the command buf */
66      size_t randlen;         &bsol;* Number of pointers in client->randptr */
67      size_t randfree;        &bsol;* Number of unused pointers in client->randptr */
68      size_t written;         &bsol;* Bytes of 'obuf' already written */
69      PORT_LONGLONG start;        &bsol;* Start time of a request */
70      PORT_LONGLONG latency;      &bsol;* Request latency */
71      int pending;            &bsol;* Number of pending requests (replies to consume) */
72      int prefix_pending;     &bsol;* If non-zero, number of pending prefix commands. Commands
73                                 such as auth and select are prefixed to the pipeline of
74                                 benchmark commands and discarded after the first send. */
75      int prefixlen;          &bsol;* Size in bytes of the pending prefix commands */
76  } *client;
77  #ifdef _WIN32
78  extern pthread_mutex_t used_memory_mutex;
79  #endif
80  static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask);
81  static void createMissingClients(client c);
82  static PORT_LONGLONG ustime(void) {
83  #ifdef _WIN32
84      return GetHighResRelativeTime(1000000);
85  #else
86      struct timeval tv;
87      long long ust;
88      gettimeofday(&tv, NULL);
89      ust = ((long)tv.tv_sec)*1000000;
90      ust += tv.tv_usec;
91      return ust;
92  #endif
93  }
94  static PORT_LONGLONG mstime(void) {
95  #ifdef _WIN32
96      return GetHighResRelativeTime(1000);
97  #else
98      struct timeval tv;
99      long long mst;
100      gettimeofday(&tv, NULL);
101      mst = ((long long)tv.tv_sec)*1000;
102      mst += tv.tv_usec/1000;
103      return mst;
104  #endif
105  }
106  static void freeClient(client c) {
107      listNode *ln;
108      aeDeleteFileEvent(config.el,(int)c->context->fd,AE_WRITABLE);               WIN_PORT_FIX &bsol;* cast (int) */
109      aeDeleteFileEvent(config.el,(int)c->context->fd,AE_READABLE);               WIN_PORT_FIX &bsol;* cast (int) */
110      redisFree(c->context);
111      sdsfree(c->obuf);
112      zfree(c->randptr);
113      zfree(c);
114      config.liveclients--;
115      ln = listSearchKey(config.clients,c);
116      assert(ln != NULL);
117      listDelNode(config.clients,ln);
118  }
119  static void freeAllClients(void) {
120      listNode *ln = config.clients->head, *next;
121      while(ln) {
122          next = ln->next;
123          freeClient(ln->value);
124          ln = next;
125      }
126  }
127  static void resetClient(client c) {
128      aeDeleteFileEvent(config.el,(int)c->context->fd,AE_WRITABLE);               WIN_PORT_FIX &bsol;* cast (int) */
129      aeDeleteFileEvent(config.el,(int)c->context->fd,AE_READABLE);               WIN_PORT_FIX &bsol;* cast (int) */
130      aeCreateFileEvent(config.el,(int)c->context->fd,AE_WRITABLE,writeHandler,c);WIN_PORT_FIX &bsol;* cast (int) */
131      c->written = 0;
132      c->pending = config.pipeline;
133  }
134  static void randomizeClientKey(client c) {
135      size_t i;
136      for (i = 0; i < c->randlen; i++) {
137          char *p = c->randptr[i]+11;
138          size_t r = random() % config.randomkeys_keyspacelen;
139          size_t j;
140          for (j = 0; j < 12; j++) {
141              *p = '0'+r%10;
142              r/=10;
143              p--;
144          }
145      }
146  }
147  static void clientDone(client c) {
148      if (config.requests_finished == config.requests) {
149          freeClient(c);
150          aeStop(config.el);
151          return;
152      }
153      if (config.keepalive) {
154          resetClient(c);
155      } else {
156          config.liveclients--;
157          createMissingClients(c);
158          config.liveclients++;
159          freeClient(c);
160      }
161  }
162  static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
163      client c = privdata;
164      void *reply = NULL;
165  #ifdef _WIN32
166      ssize_t nread;
167      char buf[1024*16];
168  #endif
169      UNUSED(el);
170      UNUSED(fd);
171      UNUSED(mask);
172      if (c->latency < 0) c->latency = ustime()-(c->start);
173  #ifdef _WIN32
174      nread = read(c->context->fd,buf,sizeof(buf));
175      if (nread == -1) {
176          if ((errno == ENOENT) || (errno == WSAEWOULDBLOCK)) {
177              errno = EAGAIN;
178              WSIOCP_QueueNextRead((int) c->context->fd);
179              return;
180          } else {
181              fprintf(stderr,"Error: %s\n",c->context->errstr);
182              exit(1);
183          }
184      } else if (redisBufferReadDone(c->context, buf, nread) != REDIS_OK) {
185  #else
186      if (redisBufferRead(c->context) != REDIS_OK) {
187  #endif
188          fprintf(stderr,"Error: %s\n",c->context->errstr);
189          exit(1);
190      } else {
191          WIN32_ONLY(WSIOCP_QueueNextRead((int) c->context->fd);)
192          while(c->pending) {
193              if (redisGetReply(c->context,&reply) != REDIS_OK) {
194                  fprintf(stderr,"Error: %s\n",c->context->errstr);
195                  exit(1);
196              }
197              if (reply != NULL) {
198                  if (reply == (void*)REDIS_REPLY_ERROR) {
199                      fprintf(stderr,"Unexpected error reply, exiting...\n");
200                      exit(1);
201                  }
202                  if (config.showerrors) {
203                      static time_t lasterr_time = 0;
204                      time_t now = time(NULL);
205                      redisReply *r = reply;
206                      if (r->type == REDIS_REPLY_ERROR && lasterr_time != now) {
207                          lasterr_time = now;
208                          printf("Error from server: %s\n", r->str);
209                      }
210                  }
211                  freeReplyObject(reply);
212                  if (c->prefix_pending > 0) {
213                      c->prefix_pending--;
214                      c->pending--;
215                      if (c->prefixlen > 0) {
216                          size_t j;
217                          sdsrange(c->obuf, c->prefixlen, -1);
218                          for (j = 0; j < c->randlen; j++)
219                              c->randptr[j] -= c->prefixlen;
220                          c->prefixlen = 0;
221                      }
222                      continue;
223                  }
224                  if (config.requests_finished < config.requests)
225                      config.latency[config.requests_finished++] = c->latency;
226                  c->pending--;
227                  if (c->pending == 0) {
228                      clientDone(c);
229                      break;
230                  }
231              } else {
232                  break;
233              }
234          }
235      }
236  }
237  #ifdef _WIN32
238  static void writeHandlerDone(aeEventLoop *el, int fd, void *privdata, int nwritten) {
239      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
240      client c = (client) req->client;
241      c->written += nwritten;
242      if (sdslen(c->obuf) == c->written) {
243          aeDeleteFileEvent(config.el, (int) c->context->fd, AE_WRITABLE);
244          aeCreateFileEvent(config.el, (int) c->context->fd, AE_READABLE, readHandler, c);
245      }
246  }
247  #endif
248  static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
249      client c = privdata;
250      UNUSED(el);
251      UNUSED(fd);
252      UNUSED(mask);
253      if (c->written == 0) {
254          if (config.requests_issued++ >= config.requests) {
255              freeClient(c);
256              return;
257          }
258          if (config.randomkeys) randomizeClientKey(c);
259          c->start = ustime();
260          c->latency = -1;
261      }
262      if (sdslen(c->obuf) > c->written) {
263          void *ptr = c->obuf+c->written;
264  #ifdef _WIN32
265          int result = WSIOCP_SocketSend(c->context->fd,
266                                         (char*) ptr,
267                                         (int) (sdslen(c->obuf) - c->written),
268                                         el,
269                                         c,
270                                         NULL,
271                                         writeHandlerDone);
272          if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
273              if (errno != EPIPE)
274                  fprintf(stderr, "Writing to socket %s\n", wsa_strerror(errno));
275              freeClient(c);
276              return;
277          }
278  #else
279          ssize_t nwritten = write(c->context->fd,ptr,sdslen(c->obuf)-c->written);
280          if (nwritten == -1) {
281              if (errno != EPIPE)
282                  fprintf(stderr, "Writing to socket: %s\n", strerror(errno));
283              freeClient(c);
284              return;
285          }
286          c->written += nwritten;
287          if (sdslen(c->obuf) == c->written) {
288              aeDeleteFileEvent(config.el,c->context->fd,AE_WRITABLE);
289              aeCreateFileEvent(config.el,c->context->fd,AE_READABLE,readHandler,c);
290          }
291  #endif
292      }
293  }
<span onclick='openModal()' class='match'>294  static client createClient(char *cmd, size_t len, client from) {
295      int j;
296      client c = zmalloc(sizeof(struct _client));
297      if (config.hostsocket == NULL) {
298  #ifdef _WIN32
299          SOCKADDR_STORAGE ss;
300          c->context = redisPreConnectNonBlock(config.hostip,config.hostport, &ss);
</span>301          if (WSIOCP_SocketConnect(c->context->fd, &ss) != 0) {
302              c->context->err = errno;
303              strerror_r(errno,c->context->errstr,sizeof(c->context->errstr));
304          }
305  #else
306          c->context = redisConnectNonBlock(config.hostip,config.hostport);
307  #endif
308      } else {
309          c->context = redisConnectUnixNonBlock(config.hostsocket);
310      }
311      if (c->context->err) {
312          fprintf(stderr,"Could not connect to Redis at ");
313          if (config.hostsocket == NULL)
314              fprintf(stderr,"%s:%d: %s\n",config.hostip,config.hostport,c->context->errstr);
315          else
316              fprintf(stderr,"%s: %s\n",config.hostsocket,c->context->errstr);
317          exit(1);
318      }
319      c->context->reader->maxbuf = 0;
320      c->obuf = sdsempty();
321      c->prefix_pending = 0;
322      if (config.auth) {
323          char *buf = NULL;
324          int len = redisFormatCommand(&buf, "AUTH %s", config.auth);
325          c->obuf = sdscatlen(c->obuf, buf, len);
326          free(buf);
327          c->prefix_pending++;
328      }
329      if (config.dbnum != 0) {
330          c->obuf = sdscatprintf(c->obuf,"*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n",
331              (int)sdslen(config.dbnumstr),config.dbnumstr);
332          c->prefix_pending++;
333      }
334      c->prefixlen = (int)sdslen(c->obuf);                                        WIN_PORT_FIX &bsol;* cast (int) */
335      if (from) {
336          c->obuf = sdscatlen(c->obuf,
337              from->obuf+from->prefixlen,
338              sdslen(from->obuf)-from->prefixlen);
339      } else {
340          for (j = 0; j < config.pipeline; j++)
341              c->obuf = sdscatlen(c->obuf,cmd,len);
342      }
343      c->written = 0;
344      c->pending = config.pipeline+c->prefix_pending;
345      c->randptr = NULL;
346      c->randlen = 0;
347      if (config.randomkeys) {
348          if (from) {
349              c->randlen = from->randlen;
350              c->randfree = 0;
351              c->randptr = zmalloc(sizeof(char*)*c->randlen);
352              for (j = 0; j < (int)c->randlen; j++) {
353                  c->randptr[j] = c->obuf + (from->randptr[j]-from->obuf);
354                  c->randptr[j] += c->prefixlen - from->prefixlen;
355              }
356          } else {
357              char *p = c->obuf;
358              c->randlen = 0;
359              c->randfree = RANDPTR_INITIAL_SIZE;
360              c->randptr = zmalloc(sizeof(char*)*c->randfree);
361              while ((p = strstr(p,"__rand_int__")) != NULL) {
362                  if (c->randfree == 0) {
363                      c->randptr = zrealloc(c->randptr,sizeof(char*)*c->randlen*2);
364                      c->randfree += c->randlen;
365                  }
366                  c->randptr[c->randlen++] = p;
367                  c->randfree--;
368                  p += 12; &bsol;* 12 is strlen("__rand_int__). */
369              }
370          }
371      }
372      if (config.idlemode == 0)
373          aeCreateFileEvent(config.el,c->context->fd,AE_WRITABLE,writeHandler,c);
374      listAddNodeTail(config.clients,c);
375      config.liveclients++;
376      return c;
377  }
378  static void createMissingClients(client c) {
379      int n = 0;
380      while(config.liveclients < config.numclients) {
381          createClient(NULL,0,c);
382          if (++n > 64) {
383              usleep(50000);
384              n = 0;
385          }
386      }
387  }
388  static int compareLatency(const void *a, const void *b) {
389      return (int)((*(PORT_LONGLONG*)a)-(*(PORT_LONGLONG*)b));                    WIN_PORT_FIX &bsol;* cast (int) */
390  }
391  static void showLatencyReport(void) {
392      int i, curlat = 0;
393      float perc, reqpersec;
394      reqpersec = (float)config.requests_finished/((float)config.totlatency/1000);
395      if (!config.quiet && !config.csv) {
396          printf("====== %s ======\n", config.title);
397          printf("  %d requests completed in %.2f seconds\n", config.requests_finished,
398              (float)config.totlatency/1000);
399          printf("  %d parallel clients\n", config.numclients);
400          printf("  %d bytes payload\n", config.datasize);
401          printf("  keep alive: %d\n", config.keepalive);
402          printf("\n");
403          qsort(config.latency,config.requests,sizeof(PORT_LONGLONG),compareLatency);
404          for (i = 0; i < config.requests; i++) {
405              if (config.latency[i]/1000 != curlat || i == (config.requests-1)) {
406                  curlat = (int)config.latency[i]/1000;                           WIN_PORT_FIX &bsol;* cast (int) */
407                  perc = ((float)(i+1)*100)/config.requests;
408                  printf("%.2f%% <= %d milliseconds\n", perc, curlat);
409              }
410          }
411          printf("%.2f requests per second\n\n", reqpersec);
412      } else if (config.csv) {
413          printf("\"%s\",\"%.2f\"\n", config.title, reqpersec);
414      } else {
415          printf("%s: %.2f requests per second\n", config.title, reqpersec);
416      }
417  }
418  static void benchmark(char *title, char *cmd, int len) {
419      client c;
420      config.title = title;
421      config.requests_issued = 0;
422      config.requests_finished = 0;
423      c = createClient(cmd,len,NULL);
424      createMissingClients(c);
425      config.start = mstime();
426      aeMain(config.el);
427      config.totlatency = mstime()-config.start;
428      showLatencyReport();
429      freeAllClients();
430  }
431  int parseOptions(int argc, const char **argv) {
432      int i;
433      int lastarg;
434      int exit_status = 1;
435      for (i = 1; i < argc; i++) {
436          lastarg = (i == (argc-1));
437          if (!strcmp(argv[i],"-c")) {
438              if (lastarg) goto invalid;
439              config.numclients = atoi(argv[++i]);
440          } else if (!strcmp(argv[i],"-n")) {
441              if (lastarg) goto invalid;
442              config.requests = atoi(argv[++i]);
443          } else if (!strcmp(argv[i],"-k")) {
444              if (lastarg) goto invalid;
445              config.keepalive = atoi(argv[++i]);
446          } else if (!strcmp(argv[i],"-h")) {
447              if (lastarg) goto invalid;
448              config.hostip = strdup(argv[++i]);
449          } else if (!strcmp(argv[i],"-p")) {
450              if (lastarg) goto invalid;
451              config.hostport = atoi(argv[++i]);
452          } else if (!strcmp(argv[i],"-s")) {
453              if (lastarg) goto invalid;
454              config.hostsocket = strdup(argv[++i]);
455          } else if (!strcmp(argv[i],"-a") ) {
456              if (lastarg) goto invalid;
457              config.auth = strdup(argv[++i]);
458          } else if (!strcmp(argv[i],"-d")) {
459              if (lastarg) goto invalid;
460              config.datasize = atoi(argv[++i]);
461              if (config.datasize < 1) config.datasize=1;
462              if (config.datasize > 1024*1024*1024) config.datasize = 1024*1024*1024;
463          } else if (!strcmp(argv[i],"-P")) {
464              if (lastarg) goto invalid;
465              config.pipeline = atoi(argv[++i]);
466              if (config.pipeline <= 0) config.pipeline=1;
467          } else if (!strcmp(argv[i],"-r")) {
468              if (lastarg) goto invalid;
469              config.randomkeys = 1;
470              config.randomkeys_keyspacelen = atoi(argv[++i]);
471              if (config.randomkeys_keyspacelen < 0)
472                  config.randomkeys_keyspacelen = 0;
473          } else if (!strcmp(argv[i],"-q")) {
474              config.quiet = 1;
475          } else if (!strcmp(argv[i],"--csv")) {
476              config.csv = 1;
477          } else if (!strcmp(argv[i],"-l")) {
478              config.loop = 1;
479          } else if (!strcmp(argv[i],"-I")) {
480              config.idlemode = 1;
481          } else if (!strcmp(argv[i],"-e")) {
482              config.showerrors = 1;
483          } else if (!strcmp(argv[i],"-t")) {
484              if (lastarg) goto invalid;
485              config.tests = sdsnew(",");
486              config.tests = sdscat(config.tests,(char*)argv[++i]);
487              config.tests = sdscat(config.tests,",");
488              sdstolower(config.tests);
489          } else if (!strcmp(argv[i],"--dbnum")) {
490              if (lastarg) goto invalid;
491              config.dbnum = atoi(argv[++i]);
492              config.dbnumstr = sdsfromlonglong(config.dbnum);
493          } else if (!strcmp(argv[i],"--help")) {
494              exit_status = 0;
495              goto usage;
496          } else {
497              if (argv[i][0] == '-') goto invalid;
498              return i;
499          }
500      }
501      return i;
502  invalid:
503      printf("Invalid option \"%s\" or option argument missing\n\n",argv[i]);
504  usage:
505      printf(
506  "Usage: redis-benchmark [-h <host>] [-p <port>] [-c <clients>] [-n <requests>] [-k <boolean>]\n\n"
507  " -h <hostname>      Server hostname (default 127.0.0.1)\n"
508  " -p <port>          Server port (default 6379)\n"
509  " -s <socket>        Server socket (overrides host and port)\n"
510  " -a <password>      Password for Redis Auth\n"
511  " -c <clients>       Number of parallel connections (default 50)\n"
512  " -n <requests>      Total number of requests (default 100000)\n"
513  " -d <size>          Data size of SET/GET value in bytes (default 3)\n"
514  " --dbnum <db>       SELECT the specified db number (default 0)\n"
515  " -k <boolean>       1=keep alive 0=reconnect (default 1)\n"
516  " -r <keyspacelen>   Use random keys for SET/GET/INCR, random values for SADD\n"
517  "  Using this option the benchmark will expand the string __rand_int__\n"
518  "  inside an argument with a 12 digits number in the specified range\n"
519  "  from 0 to keyspacelen-1. The substitution changes every time a command\n"
520  "  is executed. Default tests use this to hit random keys in the\n"
521  "  specified range.\n"
522  " -P <numreq>        Pipeline <numreq> requests. Default 1 (no pipeline).\n"
523  " -e                 If server replies with errors, show them on stdout.\n"
524  "                    (no more than 1 error per second is displayed)\n"
525  " -q                 Quiet. Just show query/sec values\n"
526  " --csv              Output in CSV format\n"
527  " -l                 Loop. Run the tests forever\n"
528  " -t <tests>         Only run the comma separated list of tests. The test\n"
529  "                    names are the same as the ones produced as output.\n"
530  " -I                 Idle mode. Just open N idle connections and wait.\n\n"
531  "Examples:\n\n"
532  " Run the benchmark with the default configuration against 127.0.0.1:6379:\n"
533  "   $ redis-benchmark\n\n"
534  " Use 20 parallel clients, for a total of 100k requests, against 192.168.1.1:\n"
535  "   $ redis-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20\n\n"
536  " Fill 127.0.0.1:6379 with about 1 million keys only using the SET test:\n"
537  "   $ redis-benchmark -t set -n 1000000 -r 100000000\n\n"
538  " Benchmark 127.0.0.1:6379 for a few commands producing CSV output:\n"
539  "   $ redis-benchmark -t ping,set,get -n 100000 --csv\n\n"
540  " Benchmark a specific command line:\n"
541  "   $ redis-benchmark -r 10000 -n 10000 eval 'return redis.call(\"ping\")' 0\n\n"
542  " Fill a list with 10000 random elements:\n"
543  "   $ redis-benchmark -r 10000 -n 10000 lpush mylist __rand_int__\n\n"
544  " On user specified command lines __rand_int__ is replaced with a random integer\n"
545  " with a range of values selected by the -r option.\n"
546      );
547      exit(exit_status);
548  }
549  int showThroughput(struct aeEventLoop *eventLoop, PORT_LONGLONG id, void *clientData) {
550      UNUSED(eventLoop);
551      UNUSED(id);
552      UNUSED(clientData);
553      if (config.liveclients == 0 && config.requests_finished != config.requests) {
554          fprintf(stderr,"All clients disconnected... aborting.\n");
555          exit(1);
556      }
557      if (config.csv) return 250;
558      if (config.idlemode == 1) {
559          printf("clients: %d\r", config.liveclients);
560          fflush(stdout);
561  	return 250;
562      }
563      float dt = (float)((float)(mstime()-config.start)/1000.0);              WIN_PORT_FIX &bsol;* cast (float) */
564      float rps = (float)config.requests_finished/dt;
565      printf("%s: %.2f\r", config.title, rps);
566      fflush(stdout);
567      return 250; &bsol;* every 250ms */
568  }
569  int test_is_selected(char *name) {
570      char buf[256];
571      int l = (int)strlen(name);                                                  WIN_PORT_FIX &bsol;* cast (int) */
572      if (config.tests == NULL) return 1;
573      buf[0] = ',';
574      memcpy(buf+1,name,l);
575      buf[l+1] = ',';
576      buf[l+2] = '\0';
577      return strstr(config.tests,buf) != NULL;
578  }
579  int main(int argc, const char **argv) {
580      int i;
581      char *data, *cmd;
582      int len;
583      client c;
584  #ifdef _WIN32
585      InitTimeFunctions();
586      pthread_mutex_init(&used_memory_mutex, NULL);
587  #endif
588      srandom((unsigned int)time(NULL));                                          WIN_PORT_FIX &bsol;* cast (unsigned int) */
589      signal(SIGHUP, SIG_IGN);
590      signal(SIGPIPE, SIG_IGN);
591      config.numclients = 50;
592      config.requests = 100000;
593      config.liveclients = 0;
594      config.el = aeCreateEventLoop(1024*10);
595      aeCreateTimeEvent(config.el,1,showThroughput,NULL,NULL);
596      config.keepalive = 1;
597      config.datasize = 3;
598      config.pipeline = 1;
599      config.showerrors = 0;
600      config.randomkeys = 0;
601      config.randomkeys_keyspacelen = 0;
602      config.quiet = 0;
603      config.csv = 0;
604      config.loop = 0;
605      config.idlemode = 0;
606      config.latency = NULL;
607      config.clients = listCreate();
608      config.hostip = "127.0.0.1";
609      config.hostport = 6379;
610      config.hostsocket = NULL;
611      config.tests = NULL;
612      config.dbnum = 0;
613      config.auth = NULL;
614      i = parseOptions(argc,argv);
615      argc -= i;
616      argv += i;
617      config.latency = zmalloc(sizeof(PORT_LONGLONG)*config.requests);
618      if (config.keepalive == 0) {
619          printf("WARNING: keepalive disabled, you probably need 'echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse' for Linux and 'sudo sysctl -w net.inet.tcp.msl=1000' for Mac OS X in order to use a lot of clients/requests\n");
620      }
621      if (config.idlemode) {
622          printf("Creating %d idle connections and waiting forever (Ctrl+C when done)\n", config.numclients);
623          c = createClient("",0,NULL); &bsol;* will never receive a reply */
624          createMissingClients(c);
625          aeMain(config.el);
626      }
627      if (argc) {
628          sds title = sdsnew(argv[0]);
629          for (i = 1; i < argc; i++) {
630              title = sdscatlen(title, " ", 1);
631              title = sdscatlen(title, (char*)argv[i], strlen(argv[i]));
632          }
633          do {
634              len = redisFormatCommandArgv(&cmd,argc,argv,NULL);
635              benchmark(title,cmd,len);
636              free(cmd);
637          } while(config.loop);
638          return 0;
639      }
640      data = zmalloc(config.datasize+1);
641      do {
642          memset(data,'x',config.datasize);
643          data[config.datasize] = '\0';
644          if (test_is_selected("ping_inline") || test_is_selected("ping"))
645              benchmark("PING_INLINE","PING\r\n",6);
646          if (test_is_selected("ping_mbulk") || test_is_selected("ping")) {
647              len = redisFormatCommand(&cmd,"PING");
648              benchmark("PING_BULK",cmd,len);
649              free(cmd);
650          }
651          if (test_is_selected("set")) {
652              len = redisFormatCommand(&cmd,"SET key:__rand_int__ %s",data);
653              benchmark("SET",cmd,len);
654              free(cmd);
655          }
656          if (test_is_selected("get")) {
657              len = redisFormatCommand(&cmd,"GET key:__rand_int__");
658              benchmark("GET",cmd,len);
659              free(cmd);
660          }
661          if (test_is_selected("incr")) {
662              len = redisFormatCommand(&cmd,"INCR counter:__rand_int__");
663              benchmark("INCR",cmd,len);
664              free(cmd);
665          }
666          if (test_is_selected("lpush")) {
667              len = redisFormatCommand(&cmd,"LPUSH mylist %s",data);
668              benchmark("LPUSH",cmd,len);
669              free(cmd);
670          }
671          if (test_is_selected("rpush")) {
672              len = redisFormatCommand(&cmd,"RPUSH mylist %s",data);
673              benchmark("RPUSH",cmd,len);
674              free(cmd);
675          }
676          if (test_is_selected("lpop")) {
677              len = redisFormatCommand(&cmd,"LPOP mylist");
678              benchmark("LPOP",cmd,len);
679              free(cmd);
680          }
681          if (test_is_selected("rpop")) {
682              len = redisFormatCommand(&cmd,"RPOP mylist");
683              benchmark("RPOP",cmd,len);
684              free(cmd);
685          }
686          if (test_is_selected("sadd")) {
687              len = redisFormatCommand(&cmd,
688                  "SADD myset element:__rand_int__");
689              benchmark("SADD",cmd,len);
690              free(cmd);
691          }
692          if (test_is_selected("hset")) {
693              len = redisFormatCommand(&cmd,
694                  "HSET myset:__rand_int__ element:__rand_int__ %s",data);
695              benchmark("HSET",cmd,len);
696              free(cmd);
697          }
698          if (test_is_selected("spop")) {
699              len = redisFormatCommand(&cmd,"SPOP myset");
700              benchmark("SPOP",cmd,len);
701              free(cmd);
702          }
703          if (test_is_selected("lrange") ||
704              test_is_selected("lrange_100") ||
705              test_is_selected("lrange_300") ||
706              test_is_selected("lrange_500") ||
707              test_is_selected("lrange_600"))
708          {
709              len = redisFormatCommand(&cmd,"LPUSH mylist %s",data);
710              benchmark("LPUSH (needed to benchmark LRANGE)",cmd,len);
711              free(cmd);
712          }
713          if (test_is_selected("lrange") || test_is_selected("lrange_100")) {
714              len = redisFormatCommand(&cmd,"LRANGE mylist 0 99");
715              benchmark("LRANGE_100 (first 100 elements)",cmd,len);
716              free(cmd);
717          }
718          if (test_is_selected("lrange") || test_is_selected("lrange_300")) {
719              len = redisFormatCommand(&cmd,"LRANGE mylist 0 299");
720              benchmark("LRANGE_300 (first 300 elements)",cmd,len);
721              free(cmd);
722          }
723          if (test_is_selected("lrange") || test_is_selected("lrange_500")) {
724              len = redisFormatCommand(&cmd,"LRANGE mylist 0 449");
725              benchmark("LRANGE_500 (first 450 elements)",cmd,len);
726              free(cmd);
727          }
728          if (test_is_selected("lrange") || test_is_selected("lrange_600")) {
729              len = redisFormatCommand(&cmd,"LRANGE mylist 0 599");
730              benchmark("LRANGE_600 (first 600 elements)",cmd,len);
731              free(cmd);
732          }
733          if (test_is_selected("mset")) {
734              const char *argv[21];
735              argv[0] = "MSET";
736              for (i = 1; i < 21; i += 2) {
737                  argv[i] = "key:__rand_int__";
738                  argv[i+1] = data;
739              }
740              len = redisFormatCommandArgv(&cmd,21,argv,NULL);
741              benchmark("MSET (10 keys)",cmd,len);
742              free(cmd);
743          }
744          if (!config.csv) printf("\n");
745      } while(config.loop);
746      return 0;
747  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-itoa.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-benchmark.c</div>
                </div>
                <div class="column column_space"><pre><code>21  inline char* u32toa(uint32_t value, char* buffer) {
22      RAPIDJSON_ASSERT(buffer != 0);
23      const char* cDigitsLut = GetDigitsLut();
24      if (value < 10000) {
25          const uint32_t d1 = (value / 100) << 1;
</pre></code></div>
                <div class="column column_space"><pre><code>294  static client createClient(char *cmd, size_t len, client from) {
295      int j;
296      client c = zmalloc(sizeof(struct _client));
297      if (config.hostsocket == NULL) {
298  #ifdef _WIN32
299          SOCKADDR_STORAGE ss;
300          c->context = redisPreConnectNonBlock(config.hostip,config.hostport, &ss);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    