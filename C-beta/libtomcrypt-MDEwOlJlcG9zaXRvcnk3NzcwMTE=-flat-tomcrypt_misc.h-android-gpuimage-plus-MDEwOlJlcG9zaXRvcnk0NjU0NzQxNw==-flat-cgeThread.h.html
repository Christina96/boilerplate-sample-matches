
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 24.0%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</h3>
            <pre><code>1  #ifdef LTC_BASE64
2  int base64_encode(const unsigned char *in,  unsigned long inlen,
3                                   char *out, unsigned long *outlen);
4  int base64_decode(const char *in,  unsigned long inlen,
5                          unsigned char *out, unsigned long *outlen);
6  int base64_strict_decode(const char *in,  unsigned long inlen,
7                          unsigned char *out, unsigned long *outlen);
8  int base64_sane_decode(const char *in,  unsigned long inlen,
9                          unsigned char *out, unsigned long *outlen);
10  #endif
11  #ifdef LTC_BASE64_URL
12  int base64url_encode(const unsigned char *in,  unsigned long inlen,
13                                      char *out, unsigned long *outlen);
14  int base64url_strict_encode(const unsigned char *in,  unsigned long inlen,
15                                             char *out, unsigned long *outlen);
16  int base64url_decode(const char *in,  unsigned long inlen,
17                          unsigned char *out, unsigned long *outlen);
18  int base64url_strict_decode(const char *in,  unsigned long inlen,
19                          unsigned char *out, unsigned long *outlen);
20  int base64url_sane_decode(const char *in,  unsigned long inlen,
21                          unsigned char *out, unsigned long *outlen);
22  #endif
23  #ifdef LTC_BASE32
24  typedef enum {
25     BASE32_RFC4648   = 0,
26     BASE32_BASE32HEX = 1,
27     BASE32_ZBASE32   = 2,
28     BASE32_CROCKFORD = 3
29  } base32_alphabet;
<span onclick='openModal()' class='match'>30  int base32_encode(const unsigned char *in,  unsigned long inlen,
31                                   char *out, unsigned long *outlen,
32                          base32_alphabet id);
33  int base32_decode(const          char *in,  unsigned long inlen,
34                          unsigned char *out, unsigned long *outlen,
35                          base32_alphabet id);
36  #endif
37  #ifdef LTC_BASE16
38  int base16_encode(const unsigned char *in,  unsigned long  inlen,
39                                   char *out, unsigned long *outlen,
40                          unsigned int   options);
</span>41  int base16_decode(const          char *in,  unsigned long  inlen,
42                          unsigned char *out, unsigned long *outlen);
43  #endif
44  #ifdef LTC_BCRYPT
45  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
46                           const unsigned char *salt,   unsigned long salt_len,
47                                 unsigned int  rounds,            int hash_idx,
48                                 unsigned char *out,    unsigned long *outlen);
49  #endif
50  #ifdef LTC_HKDF
51  int hkdf_test(void);
52  int hkdf_extract(int hash_idx,
53                   const unsigned char *salt, unsigned long saltlen,
54                   const unsigned char *in,   unsigned long inlen,
55                         unsigned char *out,  unsigned long *outlen);
56  int hkdf_expand(int hash_idx,
57                  const unsigned char *info, unsigned long infolen,
58                  const unsigned char *in,   unsigned long inlen,
59                        unsigned char *out,  unsigned long outlen);
60  int hkdf(int hash_idx,
61           const unsigned char *salt, unsigned long saltlen,
62           const unsigned char *info, unsigned long infolen,
63           const unsigned char *in,   unsigned long inlen,
64                 unsigned char *out,  unsigned long outlen);
65  #endif  &bsol;* LTC_HKDF */
66  int mem_neq(const void *a, const void *b, size_t len);
67  void zeromem(volatile void *out, size_t outlen);
68  void burn_stack(unsigned long len);
69  const char *error_to_string(int err);
70  extern const char *crypt_build_settings;
71  int crypt_fsa(void *mp, ...) LTC_NULL_TERMINATED;
72  int crypt_get_constant(const char* namein, int *valueout);
73  int crypt_list_all_constants(char *names_list, unsigned int *names_list_size);
74  int crypt_get_size(const char* namein, unsigned int *sizeout);
75  int crypt_list_all_sizes(char *names_list, unsigned int *names_list_size);
76  #ifdef LTM_DESC
77  LTC_DEPRECATED(crypt_mp_init) void init_LTM(void);
78  #endif
79  #ifdef TFM_DESC
80  LTC_DEPRECATED(crypt_mp_init) void init_TFM(void);
81  #endif
82  #ifdef GMP_DESC
83  LTC_DEPRECATED(crypt_mp_init) void init_GMP(void);
84  #endif
85  int crypt_mp_init(const char* mpi);
86  #ifdef LTC_ADLER32
87  typedef struct adler32_state_s
88  {
89     unsigned short s[2];
90  } adler32_state;
91  void adler32_init(adler32_state *ctx);
92  void adler32_update(adler32_state *ctx, const unsigned char *input, unsigned long length);
93  void adler32_finish(const adler32_state *ctx, void *hash, unsigned long size);
94  int adler32_test(void);
95  #endif
96  #ifdef LTC_CRC32
97  typedef struct crc32_state_s
98  {
99     ulong32 crc;
100  } crc32_state;
101  void crc32_init(crc32_state *ctx);
102  void crc32_update(crc32_state *ctx, const unsigned char *input, unsigned long length);
103  void crc32_finish(const crc32_state *ctx, void *hash, unsigned long size);
104  int crc32_test(void);
105  #endif
106  #ifdef LTC_PADDING
107  enum padding_type {
108     LTC_PAD_PKCS7        = 0x0000U,
109  #ifdef LTC_RNG_GET_BYTES
110     LTC_PAD_ISO_10126    = 0x1000U,
111  #endif
112     LTC_PAD_ANSI_X923    = 0x2000U,
113     LTC_PAD_SSH          = 0x3000U,
114     LTC_PAD_ONE_AND_ZERO = 0x8000U,
115     LTC_PAD_ZERO         = 0x9000U,
116     LTC_PAD_ZERO_ALWAYS  = 0xA000U,
117  };
118  int padding_pad(unsigned char *data, unsigned long length, unsigned long* padded_length, unsigned long mode);
119  int padding_depad(const unsigned char *data, unsigned long *length, unsigned long mode);
120  #endif  &bsol;* LTC_PADDING */
121  #ifdef LTC_SSH
122  typedef enum ssh_data_type_ {
123     LTC_SSHDATA_EOL,
124     LTC_SSHDATA_BYTE,
125     LTC_SSHDATA_BOOLEAN,
126     LTC_SSHDATA_UINT32,
127     LTC_SSHDATA_UINT64,
128     LTC_SSHDATA_STRING,
129     LTC_SSHDATA_MPINT,
130     LTC_SSHDATA_NAMELIST,
131  } ssh_data_type;
132  int ssh_encode_sequence_multi(unsigned char *out, unsigned long *outlen, ...) LTC_NULL_TERMINATED;
133  int ssh_decode_sequence_multi(const unsigned char *in, unsigned long *inlen, ...) LTC_NULL_TERMINATED;
134  #endif &bsol;* LTC_SSH */
135  int compare_testvector(const void* is, const unsigned long is_len, const void* should, const unsigned long should_len, const char* what, int which);
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeThread.h</h3>
            <pre><code>1  &bsol;*
2   * cgeThread.h
3   *
4   *  Created on: 2015-3-17
5   *      Author: Wang Yang
6   *        Mail: admin@wysaid.org
7   */
8  #ifndef _CGE_THREAD_H_
9  #define _CGE_THREAD_H_
10  #include <condition_variable>
11  #include <list>
12  #include <memory>
13  #include <mutex>
14  #include <thread>
15  namespace CGE
16  {
17  template <class Type>
18  class CGESyncReadWriteQueue
19  {
20  public:
21      void putData4Write(const Type& data)
22      {
23          m_writeMutex.lock();
24          m_list4Write.push(data);
25          m_writeMutex.unlock();
26      }
27      void putData4Read(const Type& data)
28      {
29          m_readMutex.lock();
30          m_list4Read.push(data);
31          m_readMutex.unlock();
32      }
33      bool hasData4Write()
34      {
35          m_list4Write.lock();
36          bool canWrite = !m_list4Write.empty();
37          m_list4Write.unlock();
38          return canWrite;
39      }
40      bool hasData4Read()
41      {
42          m_list4Read.lock();
43          bool canRead = !m_list4Read.empty();
44          m_list4Read.unlock();
45          return canRead;
46      }
47      Type getData4Write()
48      {
49          std::unique_lock<std::mutex> lock(m_writeMutex);
50          if (m_list4Write.empty())
51              return Type();
52          Type data = m_list4Write.front();
53          m_list4Write.pop();
54          return data;
55      }
56      Type getData4Read()
57      {
58          std::unique_lock<std::mutex> lock(m_readMutex);
59          if (m_list4Read.empty())
60              return Type();
61          Type data = m_list4Read.front();
62          m_list4Read.pop();
63          return data;
64      }
65      std::list<Type>& list4Read()
66      {
67          return m_list4Read;
68      }
69      std::list<Type>& list4Write()
70      {
71          return m_list4Write;
72      }
73  private:
74      std::list<Type> m_list4Read;
75      std::list<Type> m_list4Write;
76      std::mutex m_readMutex;
77      std::mutex m_writeMutex;
78  };
79  class CGEThreadPreemptive
80  {
81  public:
82      CGEThreadPreemptive();
83      ~CGEThreadPreemptive();
84      inline bool isActive() const { return m_runningStatus; }
85      inline bool isRunning() const { return m_thread != nullptr; }
86      void run();
87      void quit();
88      void join(); 
89  protected:
90      virtual void runTask() = 0; 
91      void _run();
92  public:
93      std::mutex& getMutex() { return m_mutex; }
94      std::thread* getThread() { return m_thread; }
95      std::condition_variable& getCondition() { return m_condition; }
96  protected:
97      std::thread* m_thread;
98      std::mutex m_mutex;
99      std::condition_variable m_condition;
100      bool m_taskRestart, m_threadOver;
101      bool m_runningStatus;
102  };
103  class CGEThreadPool
104  {
105  private:
106      class Worker;
107  public:
108      class Work;
<span onclick='openModal()' class='match'>109      CGEThreadPool(std::list<std::unique_ptr<Worker>>::size_type maxThreadNum = 1);
110      ~CGEThreadPool();
111      bool isActive(); 
112      bool isBusy();   
113      void wait4Active(long ms = 0);
114      void wait4Busy(long ms = 0);
115      void terminate();
116      void quit(); 
117      void join(); 
</span>118      std::list<Work>::size_type totalWorks() { return m_workList.size(); }
119      std::list<std::unique_ptr<Worker>>::size_type totalWorkers() { return m_workerList.size(); }
120      void run(const Work& work);
121      static CGEThreadPool* globalThreadPool;
122      static void setGlobalThreadNum(size_t maxThreadNum);
123      static void runOnGlobalPool(const Work& work);
124      static void clearGlobalPool();
125  private:
126      std::list<Work> m_workList;
127      std::list<std::unique_ptr<Worker>> m_workerList;
128      std::condition_variable m_condition;
129      std::mutex m_threadMutex, m_poolMutex;
130      std::list<std::unique_ptr<Worker>>::size_type m_maxWorkerSize;
131      bool m_threadOver, m_threadJoining;
132  };
133  class CGEThreadPool::Work
134  {
135  public:
136      Work() :
137          func(nullptr), arg(NULL) {}
138      Work(const std::function<void(void*)>& _func, void* _arg = NULL) :
139          func(_func), arg(_arg) {}
140      void run()
141      {
142          if (func != nullptr) func(arg);
143      }
144  private:
145      std::function<void(void*)> func;
146      void* arg;
147  };
148  class CGEThreadPool::Worker
149  {
150  public:
151      Worker(CGEThreadPool& pool);
152      Worker(Worker& worker);
153      Worker(Worker&& worker);
154      ~Worker();
155      inline bool isActive() const { return m_runningStatus; }
156      inline bool isRunning() const { return m_thread != nullptr; }
157      void shouldLeave() { m_shouldLeave = true; }
158      void run();
159      void terminate();
160      void waitForQuit();
161      void join();
162  protected:
163      void _run();
164  private:
165      std::thread* m_thread;
166      CGEThreadPool& m_pool;
167      bool m_runningStatus, m_shouldLeave;
168  };
169  } 
170  #define CGE_THREAD_WORK CGE::CGEThreadPool::Work
171  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeThread.h</div>
                </div>
                <div class="column column_space"><pre><code>30  int base32_encode(const unsigned char *in,  unsigned long inlen,
31                                   char *out, unsigned long *outlen,
32                          base32_alphabet id);
33  int base32_decode(const          char *in,  unsigned long inlen,
34                          unsigned char *out, unsigned long *outlen,
35                          base32_alphabet id);
36  #endif
37  #ifdef LTC_BASE16
38  int base16_encode(const unsigned char *in,  unsigned long  inlen,
39                                   char *out, unsigned long *outlen,
40                          unsigned int   options);
</pre></code></div>
                <div class="column column_space"><pre><code>109      CGEThreadPool(std::list<std::unique_ptr<Worker>>::size_type maxThreadNum = 1);
110      ~CGEThreadPool();
111      bool isActive(); 
112      bool isBusy();   
113      void wait4Active(long ms = 0);
114      void wait4Busy(long ms = 0);
115      void terminate();
116      void quit(); 
117      void join(); 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    