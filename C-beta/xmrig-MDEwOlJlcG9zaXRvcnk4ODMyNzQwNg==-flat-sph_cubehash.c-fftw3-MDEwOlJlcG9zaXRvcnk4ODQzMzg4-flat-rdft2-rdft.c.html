
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.67654986522911%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_cubehash.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include <limits.h>
4  #include "sph_cubehash.h"
5  #ifdef __cplusplus
6  extern "C"{
7  #endif
8  #if SPH_SMALL_FOOTPRINT && !defined SPH_SMALL_FOOTPRINT_CUBEHASH
9  #define SPH_SMALL_FOOTPRINT_CUBEHASH   1
10  #endif
11  #if SPH_SMALL_FOOTPRINT_CUBEHASH
12  #if !defined SPH_CUBEHASH_UNROLL
13  #define SPH_CUBEHASH_UNROLL   4
14  #endif
15  #if !defined SPH_CUBEHASH_NOCOPY
16  #define SPH_CUBEHASH_NOCOPY   1
17  #endif
18  #else
19  #if !defined SPH_CUBEHASH_UNROLL
20  #define SPH_CUBEHASH_UNROLL   0
21  #endif
22  #if !defined SPH_CUBEHASH_NOCOPY
23  #define SPH_CUBEHASH_NOCOPY   0
24  #endif
25  #endif
26  #ifdef _MSC_VER
27  #pragma warning (disable: 4146)
28  #endif
29  static const sph_u32 IV224[] = {
<span onclick='openModal()' class='match'>30  	SPH_C32(0xB0FC8217), SPH_C32(0x1BEE1A90), SPH_C32(0x829E1A22),
31  	SPH_C32(0x6362C342), SPH_C32(0x24D91C30), SPH_C32(0x03A7AA24),
32  	SPH_C32(0xA63721C8), SPH_C32(0x85B0E2EF), SPH_C32(0xF35D13F3),
33  	SPH_C32(0x41DA807D), SPH_C32(0x21A70CA6), SPH_C32(0x1F4E9774),
</span>34  	SPH_C32(0xB3E1C932), SPH_C32(0xEB0A79A8), SPH_C32(0xCDDAAA66),
35  	SPH_C32(0xE2F6ECAA), SPH_C32(0x0A713362), SPH_C32(0xAA3080E0),
36  	SPH_C32(0xD8F23A32), SPH_C32(0xCEF15E28), SPH_C32(0xDB086314),
37  	SPH_C32(0x7F709DF7), SPH_C32(0xACD228A4), SPH_C32(0x704D6ECE),
38  	SPH_C32(0xAA3EC95F), SPH_C32(0xE387C214), SPH_C32(0x3A6445FF),
39  	SPH_C32(0x9CAB81C3), SPH_C32(0xC73D4B98), SPH_C32(0xD277AEBE),
40  	SPH_C32(0xFD20151C), SPH_C32(0x00CB573E)
41  };
42  static const sph_u32 IV256[] = {
43  	SPH_C32(0xEA2BD4B4), SPH_C32(0xCCD6F29F), SPH_C32(0x63117E71),
44  	SPH_C32(0x35481EAE), SPH_C32(0x22512D5B), SPH_C32(0xE5D94E63),
45  	SPH_C32(0x7E624131), SPH_C32(0xF4CC12BE), SPH_C32(0xC2D0B696),
46  	SPH_C32(0x42AF2070), SPH_C32(0xD0720C35), SPH_C32(0x3361DA8C),
47  	SPH_C32(0x28CCECA4), SPH_C32(0x8EF8AD83), SPH_C32(0x4680AC00),
48  	SPH_C32(0x40E5FBAB), SPH_C32(0xD89041C3), SPH_C32(0x6107FBD5),
49  	SPH_C32(0x6C859D41), SPH_C32(0xF0B26679), SPH_C32(0x09392549),
50  	SPH_C32(0x5FA25603), SPH_C32(0x65C892FD), SPH_C32(0x93CB6285),
51  	SPH_C32(0x2AF2B5AE), SPH_C32(0x9E4B4E60), SPH_C32(0x774ABFDD),
52  	SPH_C32(0x85254725), SPH_C32(0x15815AEB), SPH_C32(0x4AB6AAD6),
53  	SPH_C32(0x9CDAF8AF), SPH_C32(0xD6032C0A)
54  };
55  static const sph_u32 IV384[] = {
56  	SPH_C32(0xE623087E), SPH_C32(0x04C00C87), SPH_C32(0x5EF46453),
57  	SPH_C32(0x69524B13), SPH_C32(0x1A05C7A9), SPH_C32(0x3528DF88),
58  	SPH_C32(0x6BDD01B5), SPH_C32(0x5057B792), SPH_C32(0x6AA7A922),
59  	SPH_C32(0x649C7EEE), SPH_C32(0xF426309F), SPH_C32(0xCB629052),
60  	SPH_C32(0xFC8E20ED), SPH_C32(0xB3482BAB), SPH_C32(0xF89E5E7E),
61  	SPH_C32(0xD83D4DE4), SPH_C32(0x44BFC10D), SPH_C32(0x5FC1E63D),
62  	SPH_C32(0x2104E6CB), SPH_C32(0x17958F7F), SPH_C32(0xDBEAEF70),
63  	SPH_C32(0xB4B97E1E), SPH_C32(0x32C195F6), SPH_C32(0x6184A8E4),
64  	SPH_C32(0x796C2543), SPH_C32(0x23DE176D), SPH_C32(0xD33BBAEC),
65  	SPH_C32(0x0C12E5D2), SPH_C32(0x4EB95A7B), SPH_C32(0x2D18BA01),
66  	SPH_C32(0x04EE475F), SPH_C32(0x1FC5F22E)
67  };
68  static const sph_u32 IV512[] = {
69  	SPH_C32(0x2AEA2A61), SPH_C32(0x50F494D4), SPH_C32(0x2D538B8B),
70  	SPH_C32(0x4167D83E), SPH_C32(0x3FEE2313), SPH_C32(0xC701CF8C),
71  	SPH_C32(0xCC39968E), SPH_C32(0x50AC5695), SPH_C32(0x4D42C787),
72  	SPH_C32(0xA647A8B3), SPH_C32(0x97CF0BEF), SPH_C32(0x825B4537),
73  	SPH_C32(0xEEF864D2), SPH_C32(0xF22090C4), SPH_C32(0xD0E5CD33),
74  	SPH_C32(0xA23911AE), SPH_C32(0xFCD398D9), SPH_C32(0x148FE485),
75  	SPH_C32(0x1B017BEF), SPH_C32(0xB6444532), SPH_C32(0x6A536159),
76  	SPH_C32(0x2FF5781C), SPH_C32(0x91FA7934), SPH_C32(0x0DBADEA9),
77  	SPH_C32(0xD65C8A2B), SPH_C32(0xA5A70E75), SPH_C32(0xB1C62456),
78  	SPH_C32(0xBC796576), SPH_C32(0x1921C8F7), SPH_C32(0xE7989AF1),
79  	SPH_C32(0x7795D246), SPH_C32(0xD43E3B44)
80  };
81  #define T32      SPH_T32
82  #define ROTL32   SPH_ROTL32
83  #if SPH_CUBEHASH_NOCOPY
84  #define DECL_STATE
85  #define READ_STATE(cc)
86  #define WRITE_STATE(cc)
87  #define x0   ((sc)->state[ 0])
88  #define x1   ((sc)->state[ 1])
89  #define x2   ((sc)->state[ 2])
90  #define x3   ((sc)->state[ 3])
91  #define x4   ((sc)->state[ 4])
92  #define x5   ((sc)->state[ 5])
93  #define x6   ((sc)->state[ 6])
94  #define x7   ((sc)->state[ 7])
95  #define x8   ((sc)->state[ 8])
96  #define x9   ((sc)->state[ 9])
97  #define xa   ((sc)->state[10])
98  #define xb   ((sc)->state[11])
99  #define xc   ((sc)->state[12])
100  #define xd   ((sc)->state[13])
101  #define xe   ((sc)->state[14])
102  #define xf   ((sc)->state[15])
103  #define xg   ((sc)->state[16])
104  #define xh   ((sc)->state[17])
105  #define xi   ((sc)->state[18])
106  #define xj   ((sc)->state[19])
107  #define xk   ((sc)->state[20])
108  #define xl   ((sc)->state[21])
109  #define xm   ((sc)->state[22])
110  #define xn   ((sc)->state[23])
111  #define xo   ((sc)->state[24])
112  #define xp   ((sc)->state[25])
113  #define xq   ((sc)->state[26])
114  #define xr   ((sc)->state[27])
115  #define xs   ((sc)->state[28])
116  #define xt   ((sc)->state[29])
117  #define xu   ((sc)->state[30])
118  #define xv   ((sc)->state[31])
119  #else
120  #define DECL_STATE \
121  	sph_u32 x0, x1, x2, x3, x4, x5, x6, x7; \
122  	sph_u32 x8, x9, xa, xb, xc, xd, xe, xf; \
123  	sph_u32 xg, xh, xi, xj, xk, xl, xm, xn; \
124  	sph_u32 xo, xp, xq, xr, xs, xt, xu, xv;
125  #define READ_STATE(cc)   do { \
126  		x0 = (cc)->state[ 0]; \
127  		x1 = (cc)->state[ 1]; \
128  		x2 = (cc)->state[ 2]; \
129  		x3 = (cc)->state[ 3]; \
130  		x4 = (cc)->state[ 4]; \
131  		x5 = (cc)->state[ 5]; \
132  		x6 = (cc)->state[ 6]; \
133  		x7 = (cc)->state[ 7]; \
134  		x8 = (cc)->state[ 8]; \
135  		x9 = (cc)->state[ 9]; \
136  		xa = (cc)->state[10]; \
137  		xb = (cc)->state[11]; \
138  		xc = (cc)->state[12]; \
139  		xd = (cc)->state[13]; \
140  		xe = (cc)->state[14]; \
141  		xf = (cc)->state[15]; \
142  		xg = (cc)->state[16]; \
143  		xh = (cc)->state[17]; \
144  		xi = (cc)->state[18]; \
145  		xj = (cc)->state[19]; \
146  		xk = (cc)->state[20]; \
147  		xl = (cc)->state[21]; \
148  		xm = (cc)->state[22]; \
149  		xn = (cc)->state[23]; \
150  		xo = (cc)->state[24]; \
151  		xp = (cc)->state[25]; \
152  		xq = (cc)->state[26]; \
153  		xr = (cc)->state[27]; \
154  		xs = (cc)->state[28]; \
155  		xt = (cc)->state[29]; \
156  		xu = (cc)->state[30]; \
157  		xv = (cc)->state[31]; \
158  	} while (0)
159  #define WRITE_STATE(cc)   do { \
160  		(cc)->state[ 0] = x0; \
161  		(cc)->state[ 1] = x1; \
162  		(cc)->state[ 2] = x2; \
163  		(cc)->state[ 3] = x3; \
164  		(cc)->state[ 4] = x4; \
165  		(cc)->state[ 5] = x5; \
166  		(cc)->state[ 6] = x6; \
167  		(cc)->state[ 7] = x7; \
168  		(cc)->state[ 8] = x8; \
169  		(cc)->state[ 9] = x9; \
170  		(cc)->state[10] = xa; \
171  		(cc)->state[11] = xb; \
172  		(cc)->state[12] = xc; \
173  		(cc)->state[13] = xd; \
174  		(cc)->state[14] = xe; \
175  		(cc)->state[15] = xf; \
176  		(cc)->state[16] = xg; \
177  		(cc)->state[17] = xh; \
178  		(cc)->state[18] = xi; \
179  		(cc)->state[19] = xj; \
180  		(cc)->state[20] = xk; \
181  		(cc)->state[21] = xl; \
182  		(cc)->state[22] = xm; \
183  		(cc)->state[23] = xn; \
184  		(cc)->state[24] = xo; \
185  		(cc)->state[25] = xp; \
186  		(cc)->state[26] = xq; \
187  		(cc)->state[27] = xr; \
188  		(cc)->state[28] = xs; \
189  		(cc)->state[29] = xt; \
190  		(cc)->state[30] = xu; \
191  		(cc)->state[31] = xv; \
192  	} while (0)
193  #endif
194  #define INPUT_BLOCK   do { \
195  		x0 ^= sph_dec32le_aligned(buf +  0); \
196  		x1 ^= sph_dec32le_aligned(buf +  4); \
197  		x2 ^= sph_dec32le_aligned(buf +  8); \
198  		x3 ^= sph_dec32le_aligned(buf + 12); \
199  		x4 ^= sph_dec32le_aligned(buf + 16); \
200  		x5 ^= sph_dec32le_aligned(buf + 20); \
201  		x6 ^= sph_dec32le_aligned(buf + 24); \
202  		x7 ^= sph_dec32le_aligned(buf + 28); \
203  	} while (0)
204  #define ROUND_EVEN   do { \
205  		xg = T32(x0 + xg); \
206  		x0 = ROTL32(x0, 7); \
207  		xh = T32(x1 + xh); \
208  		x1 = ROTL32(x1, 7); \
209  		xi = T32(x2 + xi); \
210  		x2 = ROTL32(x2, 7); \
211  		xj = T32(x3 + xj); \
212  		x3 = ROTL32(x3, 7); \
213  		xk = T32(x4 + xk); \
214  		x4 = ROTL32(x4, 7); \
215  		xl = T32(x5 + xl); \
216  		x5 = ROTL32(x5, 7); \
217  		xm = T32(x6 + xm); \
218  		x6 = ROTL32(x6, 7); \
219  		xn = T32(x7 + xn); \
220  		x7 = ROTL32(x7, 7); \
221  		xo = T32(x8 + xo); \
222  		x8 = ROTL32(x8, 7); \
223  		xp = T32(x9 + xp); \
224  		x9 = ROTL32(x9, 7); \
225  		xq = T32(xa + xq); \
226  		xa = ROTL32(xa, 7); \
227  		xr = T32(xb + xr); \
228  		xb = ROTL32(xb, 7); \
229  		xs = T32(xc + xs); \
230  		xc = ROTL32(xc, 7); \
231  		xt = T32(xd + xt); \
232  		xd = ROTL32(xd, 7); \
233  		xu = T32(xe + xu); \
234  		xe = ROTL32(xe, 7); \
235  		xv = T32(xf + xv); \
236  		xf = ROTL32(xf, 7); \
237  		x8 ^= xg; \
238  		x9 ^= xh; \
239  		xa ^= xi; \
240  		xb ^= xj; \
241  		xc ^= xk; \
242  		xd ^= xl; \
243  		xe ^= xm; \
244  		xf ^= xn; \
245  		x0 ^= xo; \
246  		x1 ^= xp; \
247  		x2 ^= xq; \
248  		x3 ^= xr; \
249  		x4 ^= xs; \
250  		x5 ^= xt; \
251  		x6 ^= xu; \
252  		x7 ^= xv; \
253  		xi = T32(x8 + xi); \
254  		x8 = ROTL32(x8, 11); \
255  		xj = T32(x9 + xj); \
256  		x9 = ROTL32(x9, 11); \
257  		xg = T32(xa + xg); \
258  		xa = ROTL32(xa, 11); \
259  		xh = T32(xb + xh); \
260  		xb = ROTL32(xb, 11); \
261  		xm = T32(xc + xm); \
262  		xc = ROTL32(xc, 11); \
263  		xn = T32(xd + xn); \
264  		xd = ROTL32(xd, 11); \
265  		xk = T32(xe + xk); \
266  		xe = ROTL32(xe, 11); \
267  		xl = T32(xf + xl); \
268  		xf = ROTL32(xf, 11); \
269  		xq = T32(x0 + xq); \
270  		x0 = ROTL32(x0, 11); \
271  		xr = T32(x1 + xr); \
272  		x1 = ROTL32(x1, 11); \
273  		xo = T32(x2 + xo); \
274  		x2 = ROTL32(x2, 11); \
275  		xp = T32(x3 + xp); \
276  		x3 = ROTL32(x3, 11); \
277  		xu = T32(x4 + xu); \
278  		x4 = ROTL32(x4, 11); \
279  		xv = T32(x5 + xv); \
280  		x5 = ROTL32(x5, 11); \
281  		xs = T32(x6 + xs); \
282  		x6 = ROTL32(x6, 11); \
283  		xt = T32(x7 + xt); \
284  		x7 = ROTL32(x7, 11); \
285  		xc ^= xi; \
286  		xd ^= xj; \
287  		xe ^= xg; \
288  		xf ^= xh; \
289  		x8 ^= xm; \
290  		x9 ^= xn; \
291  		xa ^= xk; \
292  		xb ^= xl; \
293  		x4 ^= xq; \
294  		x5 ^= xr; \
295  		x6 ^= xo; \
296  		x7 ^= xp; \
297  		x0 ^= xu; \
298  		x1 ^= xv; \
299  		x2 ^= xs; \
300  		x3 ^= xt; \
301  	} while (0)
302  #define ROUND_ODD   do { \
303  		xj = T32(xc + xj); \
304  		xc = ROTL32(xc, 7); \
305  		xi = T32(xd + xi); \
306  		xd = ROTL32(xd, 7); \
307  		xh = T32(xe + xh); \
308  		xe = ROTL32(xe, 7); \
309  		xg = T32(xf + xg); \
310  		xf = ROTL32(xf, 7); \
311  		xn = T32(x8 + xn); \
312  		x8 = ROTL32(x8, 7); \
313  		xm = T32(x9 + xm); \
314  		x9 = ROTL32(x9, 7); \
315  		xl = T32(xa + xl); \
316  		xa = ROTL32(xa, 7); \
317  		xk = T32(xb + xk); \
318  		xb = ROTL32(xb, 7); \
319  		xr = T32(x4 + xr); \
320  		x4 = ROTL32(x4, 7); \
321  		xq = T32(x5 + xq); \
322  		x5 = ROTL32(x5, 7); \
323  		xp = T32(x6 + xp); \
324  		x6 = ROTL32(x6, 7); \
325  		xo = T32(x7 + xo); \
326  		x7 = ROTL32(x7, 7); \
327  		xv = T32(x0 + xv); \
328  		x0 = ROTL32(x0, 7); \
329  		xu = T32(x1 + xu); \
330  		x1 = ROTL32(x1, 7); \
331  		xt = T32(x2 + xt); \
332  		x2 = ROTL32(x2, 7); \
333  		xs = T32(x3 + xs); \
334  		x3 = ROTL32(x3, 7); \
335  		x4 ^= xj; \
336  		x5 ^= xi; \
337  		x6 ^= xh; \
338  		x7 ^= xg; \
339  		x0 ^= xn; \
340  		x1 ^= xm; \
341  		x2 ^= xl; \
342  		x3 ^= xk; \
343  		xc ^= xr; \
344  		xd ^= xq; \
345  		xe ^= xp; \
346  		xf ^= xo; \
347  		x8 ^= xv; \
348  		x9 ^= xu; \
349  		xa ^= xt; \
350  		xb ^= xs; \
351  		xh = T32(x4 + xh); \
352  		x4 = ROTL32(x4, 11); \
353  		xg = T32(x5 + xg); \
354  		x5 = ROTL32(x5, 11); \
355  		xj = T32(x6 + xj); \
356  		x6 = ROTL32(x6, 11); \
357  		xi = T32(x7 + xi); \
358  		x7 = ROTL32(x7, 11); \
359  		xl = T32(x0 + xl); \
360  		x0 = ROTL32(x0, 11); \
361  		xk = T32(x1 + xk); \
362  		x1 = ROTL32(x1, 11); \
363  		xn = T32(x2 + xn); \
364  		x2 = ROTL32(x2, 11); \
365  		xm = T32(x3 + xm); \
366  		x3 = ROTL32(x3, 11); \
367  		xp = T32(xc + xp); \
368  		xc = ROTL32(xc, 11); \
369  		xo = T32(xd + xo); \
370  		xd = ROTL32(xd, 11); \
371  		xr = T32(xe + xr); \
372  		xe = ROTL32(xe, 11); \
373  		xq = T32(xf + xq); \
374  		xf = ROTL32(xf, 11); \
375  		xt = T32(x8 + xt); \
376  		x8 = ROTL32(x8, 11); \
377  		xs = T32(x9 + xs); \
378  		x9 = ROTL32(x9, 11); \
379  		xv = T32(xa + xv); \
380  		xa = ROTL32(xa, 11); \
381  		xu = T32(xb + xu); \
382  		xb = ROTL32(xb, 11); \
383  		x0 ^= xh; \
384  		x1 ^= xg; \
385  		x2 ^= xj; \
386  		x3 ^= xi; \
387  		x4 ^= xl; \
388  		x5 ^= xk; \
389  		x6 ^= xn; \
390  		x7 ^= xm; \
391  		x8 ^= xp; \
392  		x9 ^= xo; \
393  		xa ^= xr; \
394  		xb ^= xq; \
395  		xc ^= xt; \
396  		xd ^= xs; \
397  		xe ^= xv; \
398  		xf ^= xu; \
399  	} while (0)
400  #if SPH_CUBEHASH_UNROLL == 2
401  #define SIXTEEN_ROUNDS   do { \
402  		int j; \
403  		for (j = 0; j < 8; j ++) { \
404  			ROUND_EVEN; \
405  			ROUND_ODD; \
406  		} \
407  	} while (0)
408  #elif SPH_CUBEHASH_UNROLL == 4
409  #define SIXTEEN_ROUNDS   do { \
410  		int j; \
411  		for (j = 0; j < 4; j ++) { \
412  			ROUND_EVEN; \
413  			ROUND_ODD; \
414  			ROUND_EVEN; \
415  			ROUND_ODD; \
416  		} \
417  	} while (0)
418  #elif SPH_CUBEHASH_UNROLL == 8
419  #define SIXTEEN_ROUNDS   do { \
420  		int j; \
421  		for (j = 0; j < 2; j ++) { \
422  			ROUND_EVEN; \
423  			ROUND_ODD; \
424  			ROUND_EVEN; \
425  			ROUND_ODD; \
426  			ROUND_EVEN; \
427  			ROUND_ODD; \
428  			ROUND_EVEN; \
429  			ROUND_ODD; \
430  		} \
431  	} while (0)
432  #else
433  #define SIXTEEN_ROUNDS   do { \
434  		ROUND_EVEN; \
435  		ROUND_ODD; \
436  		ROUND_EVEN; \
437  		ROUND_ODD; \
438  		ROUND_EVEN; \
439  		ROUND_ODD; \
440  		ROUND_EVEN; \
441  		ROUND_ODD; \
442  		ROUND_EVEN; \
443  		ROUND_ODD; \
444  		ROUND_EVEN; \
445  		ROUND_ODD; \
446  		ROUND_EVEN; \
447  		ROUND_ODD; \
448  		ROUND_EVEN; \
449  		ROUND_ODD; \
450  	} while (0)
451  #endif
452  static void
453  cubehash_init(sph_cubehash_context *sc, const sph_u32 *iv)
454  {
455  	memcpy(sc->state, iv, sizeof sc->state);
456  	sc->ptr = 0;
457  }
458  static void
459  cubehash_core(sph_cubehash_context *sc, const void *data, size_t len)
460  {
461  	unsigned char *buf;
462  	size_t ptr;
463  	DECL_STATE
464  	buf = sc->buf;
465  	ptr = sc->ptr;
466  	if (len < (sizeof sc->buf) - ptr) {
467  		memcpy(buf + ptr, data, len);
468  		ptr += len;
469  		sc->ptr = ptr;
470  		return;
471  	}
472  	READ_STATE(sc);
473  	while (len > 0) {
474  		size_t clen;
475  		clen = (sizeof sc->buf) - ptr;
476  		if (clen > len)
477  			clen = len;
478  		memcpy(buf + ptr, data, clen);
479  		ptr += clen;
480  		data = (const unsigned char *)data + clen;
481  		len -= clen;
482  		if (ptr == sizeof sc->buf) {
483  			INPUT_BLOCK;
484  			SIXTEEN_ROUNDS;
485  			ptr = 0;
486  		}
487  	}
488  	WRITE_STATE(sc);
489  	sc->ptr = ptr;
490  }
491  static void
492  cubehash_close(sph_cubehash_context *sc, unsigned ub, unsigned n,
493  	void *dst, size_t out_size_w32)
494  {
495  	unsigned char *buf, *out;
496  	size_t ptr;
497  	unsigned z;
498  	int i;
499  	DECL_STATE
500  	buf = sc->buf;
501  	ptr = sc->ptr;
502  	z = 0x80 >> n;
503  	buf[ptr ++] = ((ub & -z) | z) & 0xFF;
504  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
505  	READ_STATE(sc);
506  	INPUT_BLOCK;
507  	for (i = 0; i < 11; i ++) {
508  		SIXTEEN_ROUNDS;
509  		if (i == 0)
510  			xv ^= SPH_C32(1);
511  	}
512  	WRITE_STATE(sc);
513  	out = dst;
514  	for (z = 0; z < out_size_w32; z ++)
515  		sph_enc32le(out + (z << 2), sc->state[z]);
516  }
517  void
518  sph_cubehash224_init(void *cc)
519  {
520  	cubehash_init(cc, IV224);
521  }
522  void
523  sph_cubehash224(void *cc, const void *data, size_t len)
524  {
525  	cubehash_core(cc, data, len);
526  }
527  void
528  sph_cubehash224_close(void *cc, void *dst)
529  {
530  	sph_cubehash224_addbits_and_close(cc, 0, 0, dst);
531  }
532  void
533  sph_cubehash224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
534  {
535  	cubehash_close(cc, ub, n, dst, 7);
536  	sph_cubehash224_init(cc);
537  }
538  void
539  sph_cubehash256_init(void *cc)
540  {
541  	cubehash_init(cc, IV256);
542  }
543  void
544  sph_cubehash256(void *cc, const void *data, size_t len)
545  {
546  	cubehash_core(cc, data, len);
547  }
548  void
549  sph_cubehash256_close(void *cc, void *dst)
550  {
551  	sph_cubehash256_addbits_and_close(cc, 0, 0, dst);
552  }
553  void
554  sph_cubehash256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
555  {
556  	cubehash_close(cc, ub, n, dst, 8);
557  	sph_cubehash256_init(cc);
558  }
559  void
560  sph_cubehash384_init(void *cc)
561  {
562  	cubehash_init(cc, IV384);
563  }
564  void
565  sph_cubehash384(void *cc, const void *data, size_t len)
566  {
567  	cubehash_core(cc, data, len);
568  }
569  void
570  sph_cubehash384_close(void *cc, void *dst)
571  {
572  	sph_cubehash384_addbits_and_close(cc, 0, 0, dst);
573  }
574  void
575  sph_cubehash384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
576  {
577  	cubehash_close(cc, ub, n, dst, 12);
578  	sph_cubehash384_init(cc);
579  }
580  void
581  sph_cubehash512_init(void *cc)
582  {
583  	cubehash_init(cc, IV512);
584  }
585  void
586  sph_cubehash512(void *cc, const void *data, size_t len)
587  {
588  	cubehash_core(cc, data, len);
589  }
590  void
591  sph_cubehash512_close(void *cc, void *dst)
592  {
593  	sph_cubehash512_addbits_and_close(cc, 0, 0, dst);
594  }
595  void
596  sph_cubehash512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
597  {
598  	cubehash_close(cc, ub, n, dst, 16);
599  	sph_cubehash512_init(cc);
600  }
601  #ifdef __cplusplus
602  }
603  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft2 super;
7       plan *cld, *cldrest;
8       INT n, vl, nbuf, bufdist;
9       INT cs, ivs, ovs;
10  } P;
11  static void hc2c(INT n, R *r, R *rio, R *iio, INT os)
12  {
13       INT i;
14       rio[0] = r[0];
15       iio[0] = 0;
16       for (i = 1; i + i < n; ++i) {
17  	  rio[i * os] = r[i];
18  	  iio[i * os] = r[n - i];
19       }
20       if (i + i == n) {	&bsol;* store the Nyquist frequency */
21  	  rio[i * os] = r[i];
22  	  iio[i * os] = K(0.0);
23       }
24  }
25  static void c2hc(INT n, R *rio, R *iio, INT is, R *r)
26  {
27       INT i;
28       r[0] = rio[0];
29       for (i = 1; i + i < n; ++i) {
30  	  r[i] = rio[i * is];
31  	  r[n - i] = iio[i * is];
32       }
33       if (i + i == n)		&bsol;* store the Nyquist frequency */
34  	  r[i] = rio[i * is];
35  }
36  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
37  {
38       const P *ego = (const P *) ego_;
39       plan_rdft *cld = (plan_rdft *) ego->cld;
40       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
41       INT n = ego->n;
42       INT ivs = ego->ivs, ovs = ego->ovs, os = ego->cs;
43       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
44       plan_rdft2 *cldrest;
45       for (i = nbuf; i <= vl; i += nbuf) {
46            cld->apply((plan *) cld, r0, bufs);
47  	  r0 += ivs * nbuf; r1 += ivs * nbuf;
48  	  for (j = 0; j < nbuf; ++j, cr += ovs, ci += ovs)
49  	       hc2c(n, bufs + j*bufdist, cr, ci, os);
50       }
51       X(ifree)(bufs);
52       cldrest = (plan_rdft2 *) ego->cldrest;
53       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
54  }
55  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
56  {
57       const P *ego = (const P *) ego_;
58       plan_rdft *cld = (plan_rdft *) ego->cld;
59       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
60       INT n = ego->n;
61       INT ivs = ego->ivs, ovs = ego->ovs, is = ego->cs;
62       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
63       plan_rdft2 *cldrest;
64       for (i = nbuf; i <= vl; i += nbuf) {
65  	  for (j = 0; j < nbuf; ++j, cr += ivs, ci += ivs)
66  	       c2hc(n, cr, ci, is, bufs + j*bufdist);
67            cld->apply((plan *) cld, bufs, r0);
68  	  r0 += ovs * nbuf; r1 += ovs * nbuf;
69       }
70       X(ifree)(bufs);
71       cldrest = (plan_rdft2 *) ego->cldrest;
72       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
73  }
74  static void awake(plan *ego_, enum wakefulness wakefulness)
75  {
76       P *ego = (P *) ego_;
77       X(plan_awake)(ego->cld, wakefulness);
78       X(plan_awake)(ego->cldrest, wakefulness);
79  }
80  static void destroy(plan *ego_)
81  {
82       P *ego = (P *) ego_;
83       X(plan_destroy_internal)(ego->cldrest);
84       X(plan_destroy_internal)(ego->cld);
85  }
86  static void print(const plan *ego_, printer *p)
87  {
88       const P *ego = (const P *) ego_;
89       p->print(p, "(rdft2-rdft-%s-%D%v/%D-%D%(%p%)%(%p%))",
90  	      ego->super.apply == apply_r2hc ? "r2hc" : "hc2r",
91                ego->n, ego->nbuf,
92                ego->vl, ego->bufdist % ego->n,
93                ego->cld, ego->cldrest);
94  }
95  static INT min_nbuf(const problem_rdft2 *p, INT n, INT vl)
96  {
97       INT is, os, ivs, ovs;
98       if (p->r0 != p->cr)
99  	  return 1;
100       if (X(rdft2_inplace_strides(p, RNK_MINFTY)))
101  	  return 1;
102       A(p->vecsz->rnk == 1); &bsol;*  rank 0 and MINFTY are inplace */
103       X(rdft2_strides)(p->kind, p->sz->dims, &is, &os);
104       X(rdft2_strides)(p->kind, p->vecsz->dims, &ivs, &ovs);
<span onclick='openModal()' class='match'>105       if (n * X(iabs)(is) <= X(iabs)(ivs)
106  	 && (n/2 + 1) * X(iabs)(os) <= X(iabs)(ovs)
107  	 && ( ((p->cr - p->ci) <= X(iabs)(os)) || 
108  	      ((p->ci - p->cr) <= X(iabs)(os)) )
</span>109  	 && ivs > 0 && ovs > 0) {
110  	  INT vsmin = X(imin)(ivs, ovs);
111  	  INT vsmax = X(imax)(ivs, ovs);
112  	  return(((vsmax - vsmin) * vl + vsmin - 1) / vsmin);
113       }
114       return vl; &bsol;* punt: just buffer the whole vector */
115  }
116  static int applicable0(const problem *p_, const S *ego, const planner *plnr)
117  {
118       const problem_rdft2 *p = (const problem_rdft2 *) p_;
119       UNUSED(ego);
120       return(1
121  	    && p->vecsz->rnk <= 1
122  	    && p->sz->rnk == 1
123  	    && (p->kind == R2HC || p->kind == HC2R)
124  	    && (2 * (p->r1 - p->r0) ==
125  		(((p->kind == R2HC) ? p->sz->dims[0].is : p->sz->dims[0].os)))
126  	    && !(X(toobig)(p->sz->dims[0].n) && CONSERVE_MEMORYP(plnr))
127  	  );
128  }
129  static int applicable(const problem *p_, const S *ego, const planner *plnr)
130  {
131       const problem_rdft2 *p;
132       if (NO_BUFFERINGP(plnr)) return 0;
133       if (!applicable0(p_, ego, plnr)) return 0;
134       p = (const problem_rdft2 *) p_;
135       if (NO_UGLYP(plnr)) {
136  	  if (p->r0 != p->cr) return 0;
137  	  if (X(toobig)(p->sz->dims[0].n)) return 0;
138       }
139       return 1;
140  }
141  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
142  {
143       const S *ego = (const S *) ego_;
144       P *pln;
145       plan *cld = (plan *) 0;
146       plan *cldrest = (plan *) 0;
147       const problem_rdft2 *p = (const problem_rdft2 *) p_;
148       R *bufs = (R *) 0;
149       INT nbuf = 0, bufdist, n, vl;
150       INT ivs, ovs, rs, id, od;
151       static const plan_adt padt = {
152  	  X(rdft2_solve), awake, print, destroy
153       };
154       if (!applicable(p_, ego, plnr))
155            goto nada;
156       n = p->sz->dims[0].n;
157       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
158       nbuf = X(imax)(X(nbuf)(n, vl, 0), min_nbuf(p, n, vl));
159       bufdist = X(bufdist)(n, vl);
160       A(nbuf > 0);
161       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
162       id = ivs * (nbuf * (vl / nbuf));
163       od = ovs * (nbuf * (vl / nbuf));
164       if (p->kind == R2HC) {
165  	  cld = X(mkplan_f_d)(
166  	       plnr,
167  	       X(mkproblem_rdft_d)(
168  		    X(mktensor_1d)(n, p->sz->dims[0].is/2, 1),
169  		    X(mktensor_1d)(nbuf, ivs, bufdist),
170  		    TAINT(p->r0, ivs * nbuf), bufs, &p->kind),
171  	       0, 0, (p->r0 == p->cr) ? NO_DESTROY_INPUT : 0);
172  	  if (!cld) goto nada;
173  	  X(ifree)(bufs); bufs = 0;
174  	  cldrest = X(mkplan_d)(plnr, 
175  				X(mkproblem_rdft2_d)(
176  				     X(tensor_copy)(p->sz),
177  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
178  				     p->r0 + id, p->r1 + id, 
179  				     p->cr + od, p->ci + od,
180  				     p->kind));
181  	  if (!cldrest) goto nada;
182  	  pln = MKPLAN_RDFT2(P, &padt, apply_r2hc);
183       } else {
184  	  A(p->kind == HC2R);
185  	  cld = X(mkplan_f_d)(
186  	       plnr,
187  	       X(mkproblem_rdft_d)(
188  		    X(mktensor_1d)(n, 1, p->sz->dims[0].os/2),
189  		    X(mktensor_1d)(nbuf, bufdist, ovs),
190  		    bufs, TAINT(p->r0, ovs * nbuf), &p->kind),
191  	       0, 0, NO_DESTROY_INPUT); &bsol;* always ok to destroy bufs */
192  	  if (!cld) goto nada;
193  	  X(ifree)(bufs); bufs = 0;
194  	  cldrest = X(mkplan_d)(plnr, 
195  				X(mkproblem_rdft2_d)(
196  				     X(tensor_copy)(p->sz),
197  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
198  				     p->r0 + od, p->r1 + od, 
199  				     p->cr + id, p->ci + id,
200  				     p->kind));
201  	  if (!cldrest) goto nada;
202  	  pln = MKPLAN_RDFT2(P, &padt, apply_hc2r);
203       }
204       pln->cld = cld;
205       pln->cldrest = cldrest;
206       pln->n = n;
207       pln->vl = vl;
208       pln->ivs = ivs;
209       pln->ovs = ovs;
210       X(rdft2_strides)(p->kind, &p->sz->dims[0], &rs, &pln->cs);
211       pln->nbuf = nbuf;
212       pln->bufdist = bufdist;
213       X(ops_madd)(vl / nbuf, &cld->ops, &cldrest->ops,
214  		 &pln->super.super.ops);
215       pln->super.super.ops.other += (p->kind == R2HC ? (n + 2) : n) * vl;
216       return &(pln->super.super);
217   nada:
218       X(ifree0)(bufs);
219       X(plan_destroy_internal)(cldrest);
220       X(plan_destroy_internal)(cld);
221       return (plan *) 0;
222  }
223  static solver *mksolver(void)
224  {
225       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
226       S *slv = MKSOLVER(S, &sadt);
227       return &(slv->super);
228  }
229  void X(rdft2_rdft_register)(planner *p)
230  {
231       REGISTER_SOLVER(p, mksolver());
232  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_cubehash.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</div>
                </div>
                <div class="column column_space"><pre><code>30  	SPH_C32(0xB0FC8217), SPH_C32(0x1BEE1A90), SPH_C32(0x829E1A22),
31  	SPH_C32(0x6362C342), SPH_C32(0x24D91C30), SPH_C32(0x03A7AA24),
32  	SPH_C32(0xA63721C8), SPH_C32(0x85B0E2EF), SPH_C32(0xF35D13F3),
33  	SPH_C32(0x41DA807D), SPH_C32(0x21A70CA6), SPH_C32(0x1F4E9774),
</pre></code></div>
                <div class="column column_space"><pre><code>105       if (n * X(iabs)(is) <= X(iabs)(ivs)
106  	 && (n/2 + 1) * X(iabs)(os) <= X(iabs)(ovs)
107  	 && ( ((p->cr - p->ci) <= X(iabs)(os)) || 
108  	      ((p->ci - p->cr) <= X(iabs)(os)) )
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    