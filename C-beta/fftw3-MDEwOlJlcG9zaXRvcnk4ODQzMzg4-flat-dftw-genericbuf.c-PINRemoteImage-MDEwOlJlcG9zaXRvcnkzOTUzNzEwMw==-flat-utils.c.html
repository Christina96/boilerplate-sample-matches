
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.08955223880597%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-genericbuf.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef struct {
3       ct_solver super;
4       INT batchsz;
5  } S;
6  typedef struct {
7       plan_dftw super;
8       INT r, rs, m, ms, v, vs, mb, me;
9       INT batchsz;
10       plan *cld;
11       triggen *t;
12       const S *slv;
13  } P;
14  #define BATCHDIST(r) ((r) + 16)
15  static void bytwiddle(const P *ego, INT mb, INT me, R *buf, R *rio, R *iio)
16  {
17       INT j, k;
18       INT r = ego->r, rs = ego->rs, ms = ego->ms;
19       triggen *t = ego->t;
20       for (j = 0; j < r; ++j) {
21  	  for (k = mb; k < me; ++k)
22  	       t->rotate(t, j * k,
23  			 rio[j * rs + k * ms],
24  			 iio[j * rs + k * ms],
25  			 &buf[j * 2 + 2 * BATCHDIST(r) * (k - mb) + 0]);
26       }
27  }
28  static int applicable0(const S *ego,
29  		       INT r, INT irs, INT ors,
30  		       INT m, INT v,
31  		       INT mcount)
32  {
33       return (1
34  	     && v == 1
35  	     && irs == ors
36  	     && mcount >= ego->batchsz
37  	     && mcount % ego->batchsz == 0
38  	     && r >= 64 
39  	     && m >= r
40  	  );
41  }
42  static int applicable(const S *ego,
43  		      INT r, INT irs, INT ors,
44  		      INT m, INT v,
45  		      INT mcount,
46  		      const planner *plnr)
47  {
48       if (!applicable0(ego, r, irs, ors, m, v, mcount))
49  	  return 0;
50       if (NO_UGLYP(plnr) && m * r < 65536)
51  	  return 0;
52       return 1;
53  }
54  static void dobatch(const P *ego, INT mb, INT me, R *buf, R *rio, R *iio)
55  {
56       plan_dft *cld;
57       INT ms = ego->ms;
58       bytwiddle(ego, mb, me, buf, rio, iio);
59       cld = (plan_dft *) ego->cld;
60       cld->apply(ego->cld, buf, buf + 1, buf, buf + 1);
61       X(cpy2d_pair_co)(buf, buf + 1,
62  		      rio + ms * mb, iio + ms * mb,
63  		      me-mb, 2 * BATCHDIST(ego->r), ms,
64  		      ego->r, 2, ego->rs);
65  }
66  static void apply(const plan *ego_, R *rio, R *iio)
67  {
68       const P *ego = (const P *) ego_;
69       R *buf = (R *) MALLOC(sizeof(R) * 2 * BATCHDIST(ego->r) * ego->batchsz,
70  			   BUFFERS);
71       INT m;
72       for (m = ego->mb; m < ego->me; m += ego->batchsz)
73  	  dobatch(ego, m, m + ego->batchsz, buf, rio, iio);
74       A(m == ego->me);
75       X(ifree)(buf);
76  }
77  static void awake(plan *ego_, enum wakefulness wakefulness)
78  {
79       P *ego = (P *) ego_;
80       X(plan_awake)(ego->cld, wakefulness);
81       switch (wakefulness) {
82  	 case SLEEPY:
83  	      X(triggen_destroy)(ego->t); ego->t = 0;
84  	      break;
85  	 default:
86  	      ego->t = X(mktriggen)(AWAKE_SQRTN_TABLE, ego->r * ego->m);
87  	      break;
88       }
89  }
90  static void destroy(plan *ego_)
91  {
92       P *ego = (P *) ego_;
93       X(plan_destroy_internal)(ego->cld);
94  }
95  static void print(const plan *ego_, printer *p)
96  {
<span onclick='openModal()' class='match'>97       const P *ego = (const P *) ego_;
98       p->print(p, "(dftw-genericbuf/%D-%D-%D%(%p%))",
99  	      ego->batchsz, ego->r, ego->m, ego->cld);
100  }
101  static plan *mkcldw(const ct_solver *ego_,
102  		    INT r, INT irs, INT ors,
103  		    INT m, INT ms,
</span>104  		    INT v, INT ivs, INT ovs,
105  		    INT mstart, INT mcount,
106  		    R *rio, R *iio,
107  		    planner *plnr)
108  {
109       const S *ego = (const S *)ego_;
110       P *pln;
111       plan *cld = 0;
112       R *buf;
113       static const plan_adt padt = {
114  	  0, awake, print, destroy
115       };
116       UNUSED(ivs); UNUSED(ovs); UNUSED(rio); UNUSED(iio);
117       A(mstart >= 0 && mstart + mcount <= m);
118       if (!applicable(ego, r, irs, ors, m, v, mcount, plnr))
119            return (plan *)0;
120       buf = (R *) MALLOC(sizeof(R) * 2 * BATCHDIST(r) * ego->batchsz, BUFFERS);
121       cld = X(mkplan_d)(plnr,
122  			X(mkproblem_dft_d)(
123  			     X(mktensor_1d)(r, 2, 2),
124  			     X(mktensor_1d)(ego->batchsz,
125  					    2 * BATCHDIST(r),
126  					    2 * BATCHDIST(r)),
127  			     buf, buf + 1, buf, buf + 1
128  			     )
129  			);
130       X(ifree)(buf);
131       if (!cld) goto nada;
132       pln = MKPLAN_DFTW(P, &padt, apply);
133       pln->slv = ego;
134       pln->cld = cld;
135       pln->r = r;
136       pln->m = m;
137       pln->ms = ms;
138       pln->rs = irs;
139       pln->batchsz = ego->batchsz;
140       pln->mb = mstart;
141       pln->me = mstart + mcount;
142       {
143  	  double n0 = (r - 1) * (mcount - 1);
144  	  pln->super.super.ops = cld->ops;
145  	  pln->super.super.ops.mul += 8 * n0;
146  	  pln->super.super.ops.add += 4 * n0;
147  	  pln->super.super.ops.other += 8 * n0;
148       }
149       return &(pln->super.super);
150   nada:
151       X(plan_destroy_internal)(cld);
152       return (plan *) 0;
153  }
154  static void regsolver(planner *plnr, INT r, INT batchsz)
155  {
156       S *slv = (S *)X(mksolver_ct)(sizeof(S), r, DECDIT, mkcldw, 0);
157       slv->batchsz = batchsz;
158       REGISTER_SOLVER(plnr, &(slv->super.super));
159       if (X(mksolver_ct_hook)) {
160  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), r, DECDIT, mkcldw, 0);
161  	  slv->batchsz = batchsz;
162  	  REGISTER_SOLVER(plnr, &(slv->super.super));
163       }
164  }
165  void X(ct_genericbuf_register)(planner *p)
166  {
167       static const INT radices[] = { -1, -2, -4, -8, -16, -32, -64 };
168       static const INT batchsizes[] = { 4, 8, 16, 32, 64 };
169       unsigned i, j;
170       for (i = 0; i < sizeof(radices) / sizeof(radices[0]); ++i)
171  	  for (j = 0; j < sizeof(batchsizes) / sizeof(batchsizes[0]); ++j)
172  	       regsolver(p, radices[i], batchsizes[j]);
173  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-utils.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>  
3  #include "src/webp/decode.h"
4  #include "src/webp/encode.h"
5  #include "src/webp/format_constants.h"  
6  #include "src/utils/color_cache_utils.h"
7  #include "src/utils/utils.h"
8  #if defined(PRINT_MEM_INFO)
9  #include <stdio.h>
10  static int num_malloc_calls = 0;
11  static int num_calloc_calls = 0;
12  static int num_free_calls = 0;
13  static int countdown_to_fail = 0;     
14  typedef struct MemBlock MemBlock;
15  struct MemBlock {
16    void* ptr_;
17    size_t size_;
18    MemBlock* next_;
19  };
20  static MemBlock* all_blocks = NULL;
21  static size_t total_mem = 0;
22  static size_t total_mem_allocated = 0;
23  static size_t high_water_mark = 0;
24  static size_t mem_limit = 0;
25  static int exit_registered = 0;
26  static void PrintMemInfo(void) {
27    fprintf(stderr, "\nMEMORY INFO:\n");
28    fprintf(stderr, "num calls to: malloc = %4d\n", num_malloc_calls);
29    fprintf(stderr, "              calloc = %4d\n", num_calloc_calls);
30    fprintf(stderr, "              free   = %4d\n", num_free_calls);
31    fprintf(stderr, "total_mem: %u\n", (uint32_t)total_mem);
32    fprintf(stderr, "total_mem allocated: %u\n", (uint32_t)total_mem_allocated);
33    fprintf(stderr, "high-water mark: %u\n", (uint32_t)high_water_mark);
34    while (all_blocks != NULL) {
35      MemBlock* b = all_blocks;
36      all_blocks = b->next_;
37      free(b);
38    }
39  }
40  static void Increment(int* const v) {
41    if (!exit_registered) {
42  #if defined(MALLOC_FAIL_AT)
43      {
44        const char* const malloc_fail_at_str = getenv("MALLOC_FAIL_AT");
45        if (malloc_fail_at_str != NULL) {
46          countdown_to_fail = atoi(malloc_fail_at_str);
47        }
48      }
49  #endif
50  #if defined(MALLOC_LIMIT)
51      {
52        const char* const malloc_limit_str = getenv("MALLOC_LIMIT");
53        if (malloc_limit_str != NULL) {
54          mem_limit = atoi(malloc_limit_str);
55        }
56      }
57  #endif
58      (void)countdown_to_fail;
59      (void)mem_limit;
60      atexit(PrintMemInfo);
61      exit_registered = 1;
62    }
63    ++*v;
64  }
65  static void AddMem(void* ptr, size_t size) {
66    if (ptr != NULL) {
67      MemBlock* const b = (MemBlock*)malloc(sizeof(*b));
68      if (b == NULL) abort();
69      b->next_ = all_blocks;
70      all_blocks = b;
71      b->ptr_ = ptr;
72      b->size_ = size;
73      total_mem += size;
74      total_mem_allocated += size;
75  #if defined(PRINT_MEM_TRAFFIC)
76  #if defined(MALLOC_FAIL_AT)
77      fprintf(stderr, "fail-count: %5d [mem=%u]\n",
78              num_malloc_calls + num_calloc_calls, (uint32_t)total_mem);
79  #else
80      fprintf(stderr, "Mem: %u (+%u)\n", (uint32_t)total_mem, (uint32_t)size);
81  #endif
82  #endif
83      if (total_mem > high_water_mark) high_water_mark = total_mem;
84    }
85  }
86  static void SubMem(void* ptr) {
87    if (ptr != NULL) {
88      MemBlock** b = &all_blocks;
89      while (*b != NULL && (*b)->ptr_ != ptr) b = &(*b)->next_;
90      if (*b == NULL) {
91        fprintf(stderr, "Invalid pointer free! (%p)\n", ptr);
92        abort();
93      }
94      {
95        MemBlock* const block = *b;
96        *b = block->next_;
97        total_mem -= block->size_;
98  #if defined(PRINT_MEM_TRAFFIC)
99        fprintf(stderr, "Mem: %u (-%u)\n",
100                (uint32_t)total_mem, (uint32_t)block->size_);
101  #endif
102        free(block);
103      }
104    }
105  }
106  #else
107  #define Increment(v) do {} while (0)
108  #define AddMem(p, s) do {} while (0)
109  #define SubMem(p)    do {} while (0)
110  #endif
111  static int CheckSizeArgumentsOverflow(uint64_t nmemb, size_t size) {
112    const uint64_t total_size = nmemb * size;
113    if (nmemb == 0) return 1;
114    if ((uint64_t)size > WEBP_MAX_ALLOCABLE_MEMORY / nmemb) return 0;
115    if (total_size != (size_t)total_size) return 0;
116  #if defined(PRINT_MEM_INFO) && defined(MALLOC_FAIL_AT)
117    if (countdown_to_fail > 0 && --countdown_to_fail == 0) {
118      return 0;    
119    }
120  #endif
121  #if defined(MALLOC_LIMIT)
122    if (mem_limit > 0) {
123      const uint64_t new_total_mem = (uint64_t)total_mem + total_size;
124      if (new_total_mem != (size_t)new_total_mem ||
125          new_total_mem > mem_limit) {
126        return 0;   
127      }
128    }
129  #endif
130    return 1;
131  }
132  void* WebPSafeMalloc(uint64_t nmemb, size_t size) {
133    void* ptr;
134    Increment(&num_malloc_calls);
135    if (!CheckSizeArgumentsOverflow(nmemb, size)) return NULL;
136    assert(nmemb * size > 0);
137    ptr = malloc((size_t)(nmemb * size));
138    AddMem(ptr, (size_t)(nmemb * size));
139    return ptr;
140  }
141  void* WebPSafeCalloc(uint64_t nmemb, size_t size) {
142    void* ptr;
143    Increment(&num_calloc_calls);
144    if (!CheckSizeArgumentsOverflow(nmemb, size)) return NULL;
145    assert(nmemb * size > 0);
146    ptr = calloc((size_t)nmemb, size);
147    AddMem(ptr, (size_t)(nmemb * size));
148    return ptr;
149  }
150  void WebPSafeFree(void* const ptr) {
151    if (ptr != NULL) {
152      Increment(&num_free_calls);
153      SubMem(ptr);
154    }
155    free(ptr);
156  }
157  void* WebPMalloc(size_t size) {
158    return WebPSafeMalloc(1, size);
159  }
<span onclick='openModal()' class='match'>160  void WebPFree(void* ptr) {
161    WebPSafeFree(ptr);
162  }
163  void WebPCopyPlane(const uint8_t* src, int src_stride,
164                     uint8_t* dst, int dst_stride, int width, int height) {
</span>165    assert(src != NULL && dst != NULL);
166    assert(src_stride >= width && dst_stride >= width);
167    while (height-- > 0) {
168      memcpy(dst, src, width);
169      src += src_stride;
170      dst += dst_stride;
171    }
172  }
173  void WebPCopyPixels(const WebPPicture* const src, WebPPicture* const dst) {
174    assert(src != NULL && dst != NULL);
175    assert(src->width == dst->width && src->height == dst->height);
176    assert(src->use_argb && dst->use_argb);
177    WebPCopyPlane((uint8_t*)src->argb, 4 * src->argb_stride, (uint8_t*)dst->argb,
178                  4 * dst->argb_stride, 4 * src->width, src->height);
179  }
180  #define COLOR_HASH_SIZE         (MAX_PALETTE_SIZE * 4)
181  #define COLOR_HASH_RIGHT_SHIFT  22  
182  int WebPGetColorPalette(const WebPPicture* const pic, uint32_t* const palette) {
183    int i;
184    int x, y;
185    int num_colors = 0;
186    uint8_t in_use[COLOR_HASH_SIZE] = { 0 };
187    uint32_t colors[COLOR_HASH_SIZE];
188    const uint32_t* argb = pic->argb;
189    const int width = pic->width;
190    const int height = pic->height;
191    uint32_t last_pix = ~argb[0];   
192    assert(pic != NULL);
193    assert(pic->use_argb);
194    for (y = 0; y < height; ++y) {
195      for (x = 0; x < width; ++x) {
196        int key;
197        if (argb[x] == last_pix) {
198          continue;
199        }
200        last_pix = argb[x];
201        key = VP8LHashPix(last_pix, COLOR_HASH_RIGHT_SHIFT);
202        while (1) {
203          if (!in_use[key]) {
204            colors[key] = last_pix;
205            in_use[key] = 1;
206            ++num_colors;
207            if (num_colors > MAX_PALETTE_SIZE) {
208              return MAX_PALETTE_SIZE + 1;  
209            }
210            break;
211          } else if (colors[key] == last_pix) {
212            break;  
213          } else {
214            ++key;
215            key &= (COLOR_HASH_SIZE - 1);  
216          }
217        }
218      }
219      argb += pic->argb_stride;
220    }
221    if (palette != NULL) {  
222      num_colors = 0;
223      for (i = 0; i < COLOR_HASH_SIZE; ++i) {
224        if (in_use[i]) {
225          palette[num_colors] = colors[i];
226          ++num_colors;
227        }
228      }
229    }
230    return num_colors;
231  }
232  #undef COLOR_HASH_SIZE
233  #undef COLOR_HASH_RIGHT_SHIFT
234  #if defined(WEBP_NEED_LOG_TABLE_8BIT)
235  const uint8_t WebPLogTable8bit[256] = {   
236    0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
237    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
238    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
239    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
240    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
241    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
242    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
243    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
244    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
245    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
246    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
247    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
248    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
249    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
250    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
251    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
252  };
253  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-genericbuf.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-utils.c</div>
                </div>
                <div class="column column_space"><pre><code>97       const P *ego = (const P *) ego_;
98       p->print(p, "(dftw-genericbuf/%D-%D-%D%(%p%))",
99  	      ego->batchsz, ego->r, ego->m, ego->cld);
100  }
101  static plan *mkcldw(const ct_solver *ego_,
102  		    INT r, INT irs, INT ors,
103  		    INT m, INT ms,
</pre></code></div>
                <div class="column column_space"><pre><code>160  void WebPFree(void* ptr) {
161    WebPSafeFree(ptr);
162  }
163  void WebPCopyPlane(const uint8_t* src, int src_stride,
164                     uint8_t* dst, int dst_stride, int width, int height) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    