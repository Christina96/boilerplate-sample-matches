
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.128205128205128%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-bpf.h</h3>
            <pre><code>1  #if !defined(_NET_BPF_H_) && !defined(_NET_BPF_H_INCLUDED) && !defined(_BPF_H_) && !defined(_H_BPF) && !defined(lib_pcap_bpf_h)
2  #define lib_pcap_bpf_h
3  #include <pcap/funcattrs.h>
4  #include <pcap/dlt.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  #define BPF_RELEASE 199606
9  #ifdef MSDOS &bsol;* must be 32-bit */
10  typedef long          bpf_int32;
11  typedef unsigned long bpf_u_int32;
12  #else
13  typedef	int bpf_int32;
14  typedef	u_int bpf_u_int32;
15  #endif
16  #ifndef __NetBSD__
17  #define BPF_ALIGNMENT sizeof(bpf_int32)
18  #else
19  #define BPF_ALIGNMENT sizeof(long)
20  #endif
21  #define BPF_WORDALIGN(x) (((x)+(BPF_ALIGNMENT-1))&~(BPF_ALIGNMENT-1))
22  struct bpf_program {
23  	u_int bf_len;
24  	struct bpf_insn *bf_insns;
25  };
26  #define BPF_CLASS(code) ((code) & 0x07)
27  #define		BPF_LD		0x00
28  #define		BPF_LDX		0x01
29  #define		BPF_ST		0x02
30  #define		BPF_STX		0x03
31  #define		BPF_ALU		0x04
32  #define		BPF_JMP		0x05
33  #define		BPF_RET		0x06
34  #define		BPF_MISC	0x07
35  #define BPF_SIZE(code)	((code) & 0x18)
36  #define		BPF_W		0x00
37  #define		BPF_H		0x08
38  #define		BPF_B		0x10
39  #define BPF_MODE(code)	((code) & 0xe0)
40  #define		BPF_IMM	0x00
41  #define		BPF_ABS		0x20
42  #define		BPF_IND		0x40
43  #define		BPF_MEM		0x60
44  #define		BPF_LEN		0x80
45  #define		BPF_MSH		0xa0
46  #define BPF_OP(code)	((code) & 0xf0)
47  #define		BPF_ADD		0x00
48  #define		BPF_SUB		0x10
49  #define		BPF_MUL		0x20
50  #define		BPF_DIV		0x30
51  #define		BPF_OR		0x40
52  #define		BPF_AND		0x50
53  #define		BPF_LSH		0x60
54  #define		BPF_RSH		0x70
55  #define		BPF_NEG		0x80
56  #define		BPF_MOD		0x90
57  #define		BPF_XOR		0xa0
58  #define		BPF_JA		0x00
59  #define		BPF_JEQ		0x10
60  #define		BPF_JGT		0x20
61  #define		BPF_JGE		0x30
62  #define		BPF_JSET	0x40
63  #define BPF_SRC(code)	((code) & 0x08)
64  #define		BPF_K		0x00
65  #define		BPF_X		0x08
66  #define BPF_RVAL(code)	((code) & 0x18)
67  #define		BPF_A		0x10
68  #define BPF_MISCOP(code) ((code) & 0xf8)
69  #define		BPF_TAX		0x00
70  #define		BPF_TXA		0x80
71  struct bpf_insn {
72  	u_short	code;
73  	u_char	jt;
74  	u_char	jf;
75  	bpf_u_int32 k;
76  };
77  #ifdef BPF_STMT
78  #undef BPF_STMT
79  #endif
80  #define BPF_STMT(code, k) { (u_short)(code), 0, 0, k }
81  #ifdef BPF_JUMP
82  #undef BPF_JUMP
83  #endif
84  #define BPF_JUMP(code, k, jt, jf) { (u_short)(code), jt, jf, k }
85  PCAP_AVAILABLE_0_4
<span onclick='openModal()' class='match'>86  PCAP_API u_int	bpf_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
87  PCAP_AVAILABLE_0_6
88  PCAP_API int	bpf_validate(const struct bpf_insn *f, int len);
89  PCAP_AVAILABLE_0_4
90  PCAP_API char	*bpf_image(const struct bpf_insn *, int);
</span>91  PCAP_AVAILABLE_0_6
92  PCAP_API void	bpf_dump(const struct bpf_program *, int);
93  #define BPF_MEMWORDS 16
94  #ifdef __cplusplus
95  }
96  #endif
97  #endif &bsol;* !defined(_NET_BPF_H_) && !defined(_BPF_H_) && !defined(_H_BPF) && !defined(lib_pcap_bpf_h) */
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2-rdft2.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  #include "dft/dft.h"
3  typedef struct {
4       solver super;
5       int spltrnk;
6       const int *buddies;
7       size_t nbuddies;
8  } S;
9  typedef struct {
10       plan_dft super;
11       plan *cldr, *cldc;
12       const S *solver;
13  } P;
14  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
15  {
16       const P *ego = (const P *) ego_;
17       {
18  	  plan_rdft2 *cldr = (plan_rdft2 *) ego->cldr;
19  	  cldr->apply((plan *) cldr, r0, r1, cr, ci);
20       }
21       {
22  	  plan_dft *cldc = (plan_dft *) ego->cldc;
23  	  cldc->apply((plan *) cldc, cr, ci, cr, ci);
24       }
25  }
26  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
27  {
28       const P *ego = (const P *) ego_;
29       {
30  	  plan_dft *cldc = (plan_dft *) ego->cldc;
31  	  cldc->apply((plan *) cldc, ci, cr, ci, cr);
32       }
33       {
34  	  plan_rdft2 *cldr = (plan_rdft2 *) ego->cldr;
35  	  cldr->apply((plan *) cldr, r0, r1, cr, ci);
36       }
37  }
38  static void awake(plan *ego_, enum wakefulness wakefulness)
39  {
40       P *ego = (P *) ego_;
41       X(plan_awake)(ego->cldr, wakefulness);
42       X(plan_awake)(ego->cldc, wakefulness);
43  }
44  static void destroy(plan *ego_)
45  {
46       P *ego = (P *) ego_;
47       X(plan_destroy_internal)(ego->cldr);
48       X(plan_destroy_internal)(ego->cldc);
49  }
50  static void print(const plan *ego_, printer *p)
51  {
52       const P *ego = (const P *) ego_;
53       const S *s = ego->solver;
54       p->print(p, "(rdft2-rank>=2/%d%(%p%)%(%p%))", 
55  	      s->spltrnk, ego->cldr, ego->cldc);
56  }
57  static int picksplit(const S *ego, const tensor *sz, int *rp)
58  {
59       A(sz->rnk > 1); &bsol;* cannot split rnk <= 1 */
60       if (!X(pickdim)(ego->spltrnk, ego->buddies, ego->nbuddies, sz, 1, rp))
61            return 0;
62       *rp += 1; &bsol;* convert from dim. index to rank */
63       if (*rp >= sz->rnk) &bsol;* split must reduce rank */
64            return 0;
65       return 1;
66  }
67  static int applicable0(const solver *ego_, const problem *p_, int *rp,
68  		       const planner *plnr)
69  {
70       const problem_rdft2 *p = (const problem_rdft2 *) p_;
71       const S *ego = (const S *)ego_;
72       return (1
73  	     && FINITE_RNK(p->sz->rnk) && FINITE_RNK(p->vecsz->rnk)
74  	     && (p->kind == R2HC || p->kind == HC2R)
75  	     && p->sz->rnk >= 2
76  	     && picksplit(ego, p->sz, rp)
77  	     && (0
78  		 || (p->r0 != p->cr && 
79  		     (p->kind == R2HC || !NO_DESTROY_INPUTP(plnr)))
80  		 || (p->r0 == p->cr))
81  	  );
82  }
83  static int applicable(const solver *ego_, const problem *p_, 
84  		      const planner *plnr, int *rp)
85  {
86       const S *ego = (const S *)ego_;
87       if (!applicable0(ego_, p_, rp, plnr)) return 0;
88       if (NO_RANK_SPLITSP(plnr) && (ego->spltrnk != ego->buddies[0]))
89            return 0;
90       if (NO_UGLYP(plnr)) {
91  	  const problem_rdft2 *p = (const problem_rdft2 *) p_;
92  	  if (p->vecsz->rnk > 0 &&
93  	      X(tensor_min_stride)(p->vecsz) 
94  	      > X(rdft2_tensor_max_index)(p->sz, p->kind))
95  	       return 0;
96       }
97       return 1;
98  }
99  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
100  {
101       const S *ego = (const S *) ego_;
102       const problem_rdft2 *p;
103       P *pln;
104       plan *cldr = 0, *cldc = 0;
105       tensor *sz1, *sz2, *vecszi, *sz2i;
106       int spltrnk;
107       inplace_kind k;
108       problem *cldp;
109       static const plan_adt padt = {
110  	  X(rdft2_solve), awake, print, destroy
111       };
112       if (!applicable(ego_, p_, plnr, &spltrnk))
113            return (plan *) 0;
114       p = (const problem_rdft2 *) p_;
115       X(tensor_split)(p->sz, &sz1, spltrnk, &sz2);
116       k = p->kind == R2HC ? INPLACE_OS : INPLACE_IS;
117       vecszi = X(tensor_copy_inplace)(p->vecsz, k);
118       sz2i = X(tensor_copy_inplace)(sz2, k);
119       sz2i->dims[sz2i->rnk - 1].n = sz2i->dims[sz2i->rnk - 1].n/2 + 1;
120       cldr = X(mkplan_d)(plnr, 
121  		       X(mkproblem_rdft2_d)(X(tensor_copy)(sz2),
122  					    X(tensor_append)(p->vecsz, sz1),
123  					    p->r0, p->r1,
124  					    p->cr, p->ci, p->kind));
125       if (!cldr) goto nada;
126       if (p->kind == R2HC)
127  	  cldp = X(mkproblem_dft_d)(X(tensor_copy_inplace)(sz1, k),
128  				    X(tensor_append)(vecszi, sz2i),
129  				    p->cr, p->ci, p->cr, p->ci);
<span onclick='openModal()' class='match'>130       else &bsol;* HC2R must swap re/im parts to get IDFT */
130       else &bsol;* HC2R must swap re/im parts to get IDFT */
</span>131  	  cldp = X(mkproblem_dft_d)(X(tensor_copy_inplace)(sz1, k),
132  				    X(tensor_append)(vecszi, sz2i),
133  				    p->ci, p->cr, p->ci, p->cr);
134       cldc = X(mkplan_d)(plnr, cldp);
135       if (!cldc) goto nada;
136       pln = MKPLAN_RDFT2(P, &padt, p->kind == R2HC ? apply_r2hc : apply_hc2r);
137       pln->cldr = cldr;
138       pln->cldc = cldc;
139       pln->solver = ego;
140       X(ops_add)(&cldr->ops, &cldc->ops, &pln->super.super.ops);
141       X(tensor_destroy4)(sz2i, vecszi, sz2, sz1);
142       return &(pln->super.super);
143   nada:
144       X(plan_destroy_internal)(cldr);
145       X(plan_destroy_internal)(cldc);
146       X(tensor_destroy4)(sz2i, vecszi, sz2, sz1);
147       return (plan *) 0;
148  }
149  static solver *mksolver(int spltrnk, const int *buddies, size_t nbuddies)
150  {
151       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
152       S *slv = MKSOLVER(S, &sadt);
153       slv->spltrnk = spltrnk;
154       slv->buddies = buddies;
155       slv->nbuddies = nbuddies;
156       return &(slv->super);
157  }
158  void X(rdft2_rank_geq2_register)(planner *p)
159  {
160       static const int buddies[] = { 1, 0, -2 };
161       size_t i;
162       for (i = 0; i < NELEM(buddies); ++i)
163            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
164  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-bpf.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2-rdft2.c</div>
                </div>
                <div class="column column_space"><pre><code>86  PCAP_API u_int	bpf_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
87  PCAP_AVAILABLE_0_6
88  PCAP_API int	bpf_validate(const struct bpf_insn *f, int len);
89  PCAP_AVAILABLE_0_4
90  PCAP_API char	*bpf_image(const struct bpf_insn *, int);
</pre></code></div>
                <div class="column column_space"><pre><code>130       else &bsol;* HC2R must swap re/im parts to get IDFT */
130       else &bsol;* HC2R must swap re/im parts to get IDFT */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    