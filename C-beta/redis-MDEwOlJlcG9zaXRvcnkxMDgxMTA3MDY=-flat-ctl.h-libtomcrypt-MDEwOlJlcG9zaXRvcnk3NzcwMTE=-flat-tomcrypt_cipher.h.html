
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.698630136986301%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ctl.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_CTL_H
2  #define JEMALLOC_INTERNAL_CTL_H
3  #include "jemalloc/internal/jemalloc_internal_types.h"
4  #include "jemalloc/internal/malloc_io.h"
5  #include "jemalloc/internal/mutex_prof.h"
6  #include "jemalloc/internal/ql.h"
7  #include "jemalloc/internal/sc.h"
8  #include "jemalloc/internal/stats.h"
9  #define CTL_MAX_DEPTH	7
10  typedef struct ctl_node_s {
11  	bool named;
12  } ctl_node_t;
13  typedef struct ctl_named_node_s {
14  	ctl_node_t node;
15  	const char *name;
16  	size_t nchildren;
17  	const ctl_node_t *children;
18  	int (*ctl)(tsd_t *, const size_t *, size_t, void *, size_t *, void *,
19  	    size_t);
20  } ctl_named_node_t;
21  typedef struct ctl_indexed_node_s {
22  	struct ctl_node_s node;
23  	const ctl_named_node_t *(*index)(tsdn_t *, const size_t *, size_t,
24  	    size_t);
25  } ctl_indexed_node_t;
26  typedef struct ctl_arena_stats_s {
27  	arena_stats_t astats;
28  	size_t allocated_small;
29  	uint64_t nmalloc_small;
30  	uint64_t ndalloc_small;
31  	uint64_t nrequests_small;
32  	uint64_t nfills_small;
<span onclick='openModal()' class='match'>33  	uint64_t nflushes_small;
34  	bin_stats_t bstats[SC_NBINS];
35  	arena_stats_large_t lstats[SC_NSIZES - SC_NBINS];
36  	arena_stats_extents_t estats[SC_NPSIZES];
37  } ctl_arena_stats_t;
38  typedef struct ctl_stats_s {
39  	size_t allocated;
40  	size_t active;
41  	size_t metadata;
42  	size_t metadata_thp;
</span>43  	size_t resident;
44  	size_t mapped;
45  	size_t retained;
46  	background_thread_stats_t background_thread;
47  	mutex_prof_data_t mutex_prof_data[mutex_prof_num_global_mutexes];
48  } ctl_stats_t;
49  typedef struct ctl_arena_s ctl_arena_t;
50  struct ctl_arena_s {
51  	unsigned arena_ind;
52  	bool initialized;
53  	ql_elm(ctl_arena_t) destroyed_link;
54  	unsigned nthreads;
55  	const char *dss;
56  	ssize_t dirty_decay_ms;
57  	ssize_t muzzy_decay_ms;
58  	size_t pactive;
59  	size_t pdirty;
60  	size_t pmuzzy;
61  	ctl_arena_stats_t *astats;
62  };
63  typedef struct ctl_arenas_s {
64  	uint64_t epoch;
65  	unsigned narenas;
66  	ql_head(ctl_arena_t) destroyed;
67  	ctl_arena_t *arenas[2 + MALLOCX_ARENA_LIMIT];
68  } ctl_arenas_t;
69  int ctl_byname(tsd_t *tsd, const char *name, void *oldp, size_t *oldlenp,
70      void *newp, size_t newlen);
71  int ctl_nametomib(tsd_t *tsd, const char *name, size_t *mibp, size_t *miblenp);
72  int ctl_bymib(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
73      size_t *oldlenp, void *newp, size_t newlen);
74  bool ctl_boot(void);
75  void ctl_prefork(tsdn_t *tsdn);
76  void ctl_postfork_parent(tsdn_t *tsdn);
77  void ctl_postfork_child(tsdn_t *tsdn);
78  #define xmallctl(name, oldp, oldlenp, newp, newlen) do {		\
79  	if (je_mallctl(name, oldp, oldlenp, newp, newlen)		\
80  	    != 0) {							\
81  		malloc_printf(						\
82  		    "<jemalloc>: Failure in xmallctl(\"%s\", ...)\n",	\
83  		    name);						\
84  		abort();						\
85  	}								\
86  } while (0)
87  #define xmallctlnametomib(name, mibp, miblenp) do {			\
88  	if (je_mallctlnametomib(name, mibp, miblenp) != 0) {		\
89  		malloc_printf("<jemalloc>: Failure in "			\
90  		    "xmallctlnametomib(\"%s\", ...)\n", name);		\
91  		abort();						\
92  	}								\
93  } while (0)
94  #define xmallctlbymib(mib, miblen, oldp, oldlenp, newp, newlen) do {	\
95  	if (je_mallctlbymib(mib, miblen, oldp, oldlenp, newp,		\
96  	    newlen) != 0) {						\
97  		malloc_write(						\
98  		    "<jemalloc>: Failure in xmallctlbymib()\n");	\
99  		abort();						\
100  	}								\
101  } while (0)
102  #endif &bsol;* JEMALLOC_INTERNAL_CTL_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_cipher.h</h3>
            <pre><code>1  #ifdef LTC_BLOWFISH
2  struct blowfish_key {
3     ulong32 S[4][256];
4     ulong32 K[18];
5  };
6  #endif
7  #ifdef LTC_RC5
8  struct rc5_key {
9     int rounds;
10     ulong32 K[50];
11  };
12  #endif
13  #ifdef LTC_RC6
14  struct rc6_key {
15     ulong32 K[44];
16  };
17  #endif
18  #ifdef LTC_SAFERP
19  struct saferp_key {
20     unsigned char K[33][16];
21     long rounds;
22  };
23  #endif
24  #ifdef LTC_RIJNDAEL
25  struct rijndael_key {
26     ulong32 eK[60], dK[60];
27     int Nr;
28  };
29  #endif
30  #ifdef LTC_KSEED
31  struct kseed_key {
32      ulong32 K[32], dK[32];
33  };
34  #endif
35  #ifdef LTC_KASUMI
36  struct kasumi_key {
37      ulong32 KLi1[8], KLi2[8],
38              KOi1[8], KOi2[8], KOi3[8],
39              KIi1[8], KIi2[8], KIi3[8];
40  };
41  #endif
42  #ifdef LTC_XTEA
43  struct xtea_key {
44     unsigned long A[32], B[32];
45  };
46  #endif
47  #ifdef LTC_TWOFISH
48  #ifndef LTC_TWOFISH_SMALL
49     struct twofish_key {
50        ulong32 S[4][256], K[40];
51     };
52  #else
53     struct twofish_key {
54        ulong32 K[40];
55        unsigned char S[32], start;
56     };
57  #endif
58  #endif
59  #ifdef LTC_SAFER
60  #define LTC_SAFER_K64_DEFAULT_NOF_ROUNDS     6
61  #define LTC_SAFER_K128_DEFAULT_NOF_ROUNDS   10
62  #define LTC_SAFER_SK64_DEFAULT_NOF_ROUNDS    8
63  #define LTC_SAFER_SK128_DEFAULT_NOF_ROUNDS  10
64  #define LTC_SAFER_MAX_NOF_ROUNDS            13
65  #define LTC_SAFER_BLOCK_LEN                  8
66  #define LTC_SAFER_KEY_LEN     (1 + LTC_SAFER_BLOCK_LEN * (1 + 2 * LTC_SAFER_MAX_NOF_ROUNDS))
67  typedef unsigned char safer_block_t[LTC_SAFER_BLOCK_LEN];
68  typedef unsigned char safer_key_t[LTC_SAFER_KEY_LEN];
69  struct safer_key { safer_key_t key; };
70  #endif
71  #ifdef LTC_RC2
72  struct rc2_key { unsigned xkey[64]; };
73  #endif
74  #ifdef LTC_DES
75  struct des_key {
76      ulong32 ek[32], dk[32];
77  };
78  struct des3_key {
79      ulong32 ek[3][32], dk[3][32];
80  };
81  #endif
82  #ifdef LTC_CAST5
83  struct cast5_key {
84      ulong32 K[32], keylen;
85  };
86  #endif
87  #ifdef LTC_NOEKEON
88  struct noekeon_key {
89      ulong32 K[4], dK[4];
90  };
91  #endif
92  #ifdef LTC_SKIPJACK
93  struct skipjack_key {
94      unsigned char key[10];
95  };
96  #endif
97  #ifdef LTC_KHAZAD
98  struct khazad_key {
99     ulong64 roundKeyEnc[8 + 1];
100     ulong64 roundKeyDec[8 + 1];
101  };
102  #endif
103  #ifdef LTC_ANUBIS
104  struct anubis_key {
105     int keyBits;
106     int R;
107     ulong32 roundKeyEnc[18 + 1][4];
108     ulong32 roundKeyDec[18 + 1][4];
109  };
110  #endif
111  #ifdef LTC_MULTI2
112  struct multi2_key {
113      int N;
114      ulong32 uk[8];
115  };
116  #endif
117  #ifdef LTC_CAMELLIA
118  struct camellia_key {
119      int R;
120      ulong64 kw[4], k[24], kl[6];
121  };
122  #endif
123  #ifdef LTC_IDEA
124  #define LTC_IDEA_ROUNDS 8
125  #define LTC_IDEA_KEYLEN 6*LTC_IDEA_ROUNDS+4
126  struct idea_key {
127     unsigned short int ek[LTC_IDEA_KEYLEN]; &bsol;* enc key */
128     unsigned short int dk[LTC_IDEA_KEYLEN]; &bsol;* dec key */
129  };
130  #endif
131  #ifdef LTC_SERPENT
132  struct serpent_key {
133     ulong32 k[33*4];
134  };
135  #endif
136  #ifdef LTC_TEA
137  struct tea_key {
138     ulong32 k[4];
139  };
140  #endif
141  typedef union Symmetric_key {
142  #ifdef LTC_DES
143     struct des_key des;
144     struct des3_key des3;
145  #endif
146  #ifdef LTC_RC2
147     struct rc2_key rc2;
148  #endif
149  #ifdef LTC_SAFER
150     struct safer_key safer;
151  #endif
152  #ifdef LTC_TWOFISH
153     struct twofish_key  twofish;
154  #endif
155  #ifdef LTC_BLOWFISH
156     struct blowfish_key blowfish;
157  #endif
158  #ifdef LTC_RC5
159     struct rc5_key      rc5;
160  #endif
161  #ifdef LTC_RC6
162     struct rc6_key      rc6;
163  #endif
164  #ifdef LTC_SAFERP
165     struct saferp_key   saferp;
166  #endif
167  #ifdef LTC_RIJNDAEL
168     struct rijndael_key rijndael;
169  #endif
170  #ifdef LTC_XTEA
171     struct xtea_key     xtea;
172  #endif
173  #ifdef LTC_CAST5
174     struct cast5_key    cast5;
175  #endif
176  #ifdef LTC_NOEKEON
177     struct noekeon_key  noekeon;
178  #endif
179  #ifdef LTC_SKIPJACK
180     struct skipjack_key skipjack;
181  #endif
182  #ifdef LTC_KHAZAD
183     struct khazad_key   khazad;
184  #endif
185  #ifdef LTC_ANUBIS
186     struct anubis_key   anubis;
187  #endif
188  #ifdef LTC_KSEED
189     struct kseed_key    kseed;
190  #endif
191  #ifdef LTC_KASUMI
192     struct kasumi_key   kasumi;
193  #endif
194  #ifdef LTC_MULTI2
195     struct multi2_key   multi2;
196  #endif
197  #ifdef LTC_CAMELLIA
198     struct camellia_key camellia;
199  #endif
200  #ifdef LTC_IDEA
201     struct idea_key     idea;
202  #endif
203  #ifdef LTC_SERPENT
204     struct serpent_key  serpent;
205  #endif
206  #ifdef LTC_TEA
207     struct tea_key      tea;
208  #endif
209     void   *data;
210  } symmetric_key;
211  #ifdef LTC_ECB_MODE
212  typedef struct {
213     int                 cipher,
214                         blocklen;
215     symmetric_key       key;
216  } symmetric_ECB;
217  #endif
218  #ifdef LTC_CFB_MODE
219  typedef struct {
<span onclick='openModal()' class='match'>220     int                 cipher,
221                         blocklen,
222                         padlen;
223     unsigned char       IV[MAXBLOCKSIZE],
224                         pad[MAXBLOCKSIZE];
225     symmetric_key       key;
226  } symmetric_CFB;
227  #endif
228  #ifdef LTC_OFB_MODE
229  typedef struct {
230     int                 cipher,
231                         blocklen,
232                         padlen;
233     unsigned char       IV[MAXBLOCKSIZE];
234     symmetric_key       key;
</span>235  } symmetric_OFB;
236  #endif
237  #ifdef LTC_CBC_MODE
238  typedef struct {
239     int                 cipher,
240                         blocklen;
241     unsigned char       IV[MAXBLOCKSIZE];
242     symmetric_key       key;
243  } symmetric_CBC;
244  #endif
245  #ifdef LTC_CTR_MODE
246  typedef struct {
247     int                 cipher,
248                         blocklen,
249                         padlen,
250                         mode,
251                         ctrlen;
252     unsigned char       ctr[MAXBLOCKSIZE];
253     unsigned char       pad[MAXBLOCKSIZE] LTC_ALIGN(16);
254     symmetric_key       key;
255  } symmetric_CTR;
256  #endif
257  #ifdef LTC_LRW_MODE
258  typedef struct {
259      int               cipher;
260      unsigned char     IV[16],
261                        tweak[16],
262                        pad[16];
263      symmetric_key     key;
264  #ifdef LTC_LRW_TABLES
265      unsigned char     PC[16][256][16];
266  #endif
267  } symmetric_LRW;
268  #endif
269  #ifdef LTC_F8_MODE
270  typedef struct {
271     int                 cipher,
272                         blocklen,
273                         padlen;
274     unsigned char       IV[MAXBLOCKSIZE],
275                         MIV[MAXBLOCKSIZE];
276     ulong32             blockcnt;
277     symmetric_key       key;
278  } symmetric_F8;
279  #endif
280  extern struct ltc_cipher_descriptor {
281     const char *name;
282     unsigned char ID;
283     int  min_key_length,
284          max_key_length,
285          block_length,
286          default_rounds;
287     int  (*setup)(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
288     int (*ecb_encrypt)(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
289     int (*ecb_decrypt)(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
290     int (*test)(void);
291     void (*done)(symmetric_key *skey);
292     int  (*keysize)(int *keysize);
293     int (*accel_ecb_encrypt)(const unsigned char *pt, unsigned char *ct, unsigned long blocks, symmetric_key *skey);
294     int (*accel_ecb_decrypt)(const unsigned char *ct, unsigned char *pt, unsigned long blocks, symmetric_key *skey);
295     int (*accel_cbc_encrypt)(const unsigned char *pt, unsigned char *ct, unsigned long blocks, unsigned char *IV, symmetric_key *skey);
296     int (*accel_cbc_decrypt)(const unsigned char *ct, unsigned char *pt, unsigned long blocks, unsigned char *IV, symmetric_key *skey);
297     int (*accel_ctr_encrypt)(const unsigned char *pt, unsigned char *ct, unsigned long blocks, unsigned char *IV, int mode, symmetric_key *skey);
298     int (*accel_lrw_encrypt)(const unsigned char *pt, unsigned char *ct, unsigned long blocks, unsigned char *IV, const unsigned char *tweak, symmetric_key *skey);
299     int (*accel_lrw_decrypt)(const unsigned char *ct, unsigned char *pt, unsigned long blocks, unsigned char *IV, const unsigned char *tweak, symmetric_key *skey);
300     int (*accel_ccm_memory)(
301         const unsigned char *key,    unsigned long keylen,
302         symmetric_key       *uskey,
303         const unsigned char *nonce,  unsigned long noncelen,
304         const unsigned char *header, unsigned long headerlen,
305               unsigned char *pt,     unsigned long ptlen,
306               unsigned char *ct,
307               unsigned char *tag,    unsigned long *taglen,
308                         int  direction);
309     int (*accel_gcm_memory)(
310         const unsigned char *key,    unsigned long keylen,
311         const unsigned char *IV,     unsigned long IVlen,
312         const unsigned char *adata,  unsigned long adatalen,
313               unsigned char *pt,     unsigned long ptlen,
314               unsigned char *ct,
315               unsigned char *tag,    unsigned long *taglen,
316                         int direction);
317     int (*omac_memory)(
318         const unsigned char *key, unsigned long keylen,
319         const unsigned char *in,  unsigned long inlen,
320               unsigned char *out, unsigned long *outlen);
321     int (*xcbc_memory)(
322         const unsigned char *key, unsigned long keylen,
323         const unsigned char *in,  unsigned long inlen,
324               unsigned char *out, unsigned long *outlen);
325     int (*f9_memory)(
326         const unsigned char *key, unsigned long keylen,
327         const unsigned char *in,  unsigned long inlen,
328               unsigned char *out, unsigned long *outlen);
329      int (*accel_xts_encrypt)(const unsigned char *pt, unsigned char *ct,
330          unsigned long blocks, unsigned char *tweak,
331          const symmetric_key *skey1, const symmetric_key *skey2);
332       int (*accel_xts_decrypt)(const unsigned char *ct, unsigned char *pt,
333           unsigned long blocks, unsigned char *tweak,
334           const symmetric_key *skey1, const symmetric_key *skey2);
335  } cipher_descriptor[];
336  #ifdef LTC_BLOWFISH
337  int blowfish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
338  int blowfish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
339  int blowfish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
340  int blowfish_test(void);
341  void blowfish_done(symmetric_key *skey);
342  int blowfish_keysize(int *keysize);
343  extern const struct ltc_cipher_descriptor blowfish_desc;
344  #endif
345  #ifdef LTC_RC5
346  int rc5_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
347  int rc5_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
348  int rc5_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
349  int rc5_test(void);
350  void rc5_done(symmetric_key *skey);
351  int rc5_keysize(int *keysize);
352  extern const struct ltc_cipher_descriptor rc5_desc;
353  #endif
354  #ifdef LTC_RC6
355  int rc6_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
356  int rc6_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
357  int rc6_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
358  int rc6_test(void);
359  void rc6_done(symmetric_key *skey);
360  int rc6_keysize(int *keysize);
361  extern const struct ltc_cipher_descriptor rc6_desc;
362  #endif
363  #ifdef LTC_RC2
364  int rc2_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
365  int rc2_setup_ex(const unsigned char *key, int keylen, int bits, int num_rounds, symmetric_key *skey);
366  int rc2_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
367  int rc2_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
368  int rc2_test(void);
369  void rc2_done(symmetric_key *skey);
370  int rc2_keysize(int *keysize);
371  extern const struct ltc_cipher_descriptor rc2_desc;
372  #endif
373  #ifdef LTC_SAFERP
374  int saferp_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
375  int saferp_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
376  int saferp_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
377  int saferp_test(void);
378  void saferp_done(symmetric_key *skey);
379  int saferp_keysize(int *keysize);
380  extern const struct ltc_cipher_descriptor saferp_desc;
381  #endif
382  #ifdef LTC_SAFER
383  int safer_k64_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
384  int safer_sk64_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
385  int safer_k128_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
386  int safer_sk128_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
387  int safer_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
388  int safer_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
389  int safer_k64_test(void);
390  int safer_sk64_test(void);
391  int safer_sk128_test(void);
392  void safer_done(symmetric_key *skey);
393  int safer_64_keysize(int *keysize);
394  int safer_128_keysize(int *keysize);
395  extern const struct ltc_cipher_descriptor safer_k64_desc, safer_k128_desc, safer_sk64_desc, safer_sk128_desc;
396  #endif
397  #ifdef LTC_RIJNDAEL
398  #define aes_setup           rijndael_setup
399  #define aes_ecb_encrypt     rijndael_ecb_encrypt
400  #define aes_ecb_decrypt     rijndael_ecb_decrypt
401  #define aes_test            rijndael_test
402  #define aes_done            rijndael_done
403  #define aes_keysize         rijndael_keysize
404  #define aes_enc_setup           rijndael_enc_setup
405  #define aes_enc_ecb_encrypt     rijndael_enc_ecb_encrypt
406  #define aes_enc_keysize         rijndael_enc_keysize
407  int rijndael_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
408  int rijndael_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
409  int rijndael_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
410  int rijndael_test(void);
411  void rijndael_done(symmetric_key *skey);
412  int rijndael_keysize(int *keysize);
413  int rijndael_enc_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
414  int rijndael_enc_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
415  void rijndael_enc_done(symmetric_key *skey);
416  int rijndael_enc_keysize(int *keysize);
417  extern const struct ltc_cipher_descriptor rijndael_desc, aes_desc;
418  extern const struct ltc_cipher_descriptor rijndael_enc_desc, aes_enc_desc;
419  #endif
420  #ifdef LTC_XTEA
421  int xtea_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
422  int xtea_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
423  int xtea_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
424  int xtea_test(void);
425  void xtea_done(symmetric_key *skey);
426  int xtea_keysize(int *keysize);
427  extern const struct ltc_cipher_descriptor xtea_desc;
428  #endif
429  #ifdef LTC_TWOFISH
430  int twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
431  int twofish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
432  int twofish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
433  int twofish_test(void);
434  void twofish_done(symmetric_key *skey);
435  int twofish_keysize(int *keysize);
436  extern const struct ltc_cipher_descriptor twofish_desc;
437  #endif
438  #ifdef LTC_DES
439  int des_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
440  int des_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
441  int des_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
442  int des_test(void);
443  void des_done(symmetric_key *skey);
444  int des_keysize(int *keysize);
445  int des3_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
446  int des3_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
447  int des3_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
448  int des3_test(void);
449  void des3_done(symmetric_key *skey);
450  int des3_keysize(int *keysize);
451  extern const struct ltc_cipher_descriptor des_desc, des3_desc;
452  #endif
453  #ifdef LTC_CAST5
454  int cast5_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
455  int cast5_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
456  int cast5_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
457  int cast5_test(void);
458  void cast5_done(symmetric_key *skey);
459  int cast5_keysize(int *keysize);
460  extern const struct ltc_cipher_descriptor cast5_desc;
461  #endif
462  #ifdef LTC_NOEKEON
463  int noekeon_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
464  int noekeon_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
465  int noekeon_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
466  int noekeon_test(void);
467  void noekeon_done(symmetric_key *skey);
468  int noekeon_keysize(int *keysize);
469  extern const struct ltc_cipher_descriptor noekeon_desc;
470  #endif
471  #ifdef LTC_SKIPJACK
472  int skipjack_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
473  int skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
474  int skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
475  int skipjack_test(void);
476  void skipjack_done(symmetric_key *skey);
477  int skipjack_keysize(int *keysize);
478  extern const struct ltc_cipher_descriptor skipjack_desc;
479  #endif
480  #ifdef LTC_KHAZAD
481  int khazad_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
482  int khazad_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
483  int khazad_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
484  int khazad_test(void);
485  void khazad_done(symmetric_key *skey);
486  int khazad_keysize(int *keysize);
487  extern const struct ltc_cipher_descriptor khazad_desc;
488  #endif
489  #ifdef LTC_ANUBIS
490  int anubis_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
491  int anubis_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
492  int anubis_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
493  int anubis_test(void);
494  void anubis_done(symmetric_key *skey);
495  int anubis_keysize(int *keysize);
496  extern const struct ltc_cipher_descriptor anubis_desc;
497  #endif
498  #ifdef LTC_KSEED
499  int kseed_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
500  int kseed_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
501  int kseed_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
502  int kseed_test(void);
503  void kseed_done(symmetric_key *skey);
504  int kseed_keysize(int *keysize);
505  extern const struct ltc_cipher_descriptor kseed_desc;
506  #endif
507  #ifdef LTC_KASUMI
508  int kasumi_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
509  int kasumi_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
510  int kasumi_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
511  int kasumi_test(void);
512  void kasumi_done(symmetric_key *skey);
513  int kasumi_keysize(int *keysize);
514  extern const struct ltc_cipher_descriptor kasumi_desc;
515  #endif
516  #ifdef LTC_MULTI2
517  int multi2_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
518  int multi2_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
519  int multi2_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
520  int multi2_test(void);
521  void multi2_done(symmetric_key *skey);
522  int multi2_keysize(int *keysize);
523  extern const struct ltc_cipher_descriptor multi2_desc;
524  #endif
525  #ifdef LTC_CAMELLIA
526  int camellia_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
527  int camellia_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
528  int camellia_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
529  int camellia_test(void);
530  void camellia_done(symmetric_key *skey);
531  int camellia_keysize(int *keysize);
532  extern const struct ltc_cipher_descriptor camellia_desc;
533  #endif
534  #ifdef LTC_IDEA
535  int idea_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
536  int idea_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
537  int idea_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
538  int idea_test(void);
539  void idea_done(symmetric_key *skey);
540  int idea_keysize(int *keysize);
541  extern const struct ltc_cipher_descriptor idea_desc;
542  #endif
543  #ifdef LTC_SERPENT
544  int serpent_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
545  int serpent_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
546  int serpent_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
547  int serpent_test(void);
548  void serpent_done(symmetric_key *skey);
549  int serpent_keysize(int *keysize);
550  extern const struct ltc_cipher_descriptor serpent_desc;
551  #endif
552  #ifdef LTC_TEA
553  int tea_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
554  int tea_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey);
555  int tea_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey);
556  int tea_test(void);
557  void tea_done(symmetric_key *skey);
558  int tea_keysize(int *keysize);
559  extern const struct ltc_cipher_descriptor tea_desc;
560  #endif
561  #ifdef LTC_ECB_MODE
562  int ecb_start(int cipher, const unsigned char *key,
563                int keylen, int num_rounds, symmetric_ECB *ecb);
564  int ecb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_ECB *ecb);
565  int ecb_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_ECB *ecb);
566  int ecb_done(symmetric_ECB *ecb);
567  #endif
568  #ifdef LTC_CFB_MODE
569  int cfb_start(int cipher, const unsigned char *IV, const unsigned char *key,
570                int keylen, int num_rounds, symmetric_CFB *cfb);
571  int cfb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CFB *cfb);
572  int cfb_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_CFB *cfb);
573  int cfb_getiv(unsigned char *IV, unsigned long *len, const symmetric_CFB *cfb);
574  int cfb_setiv(const unsigned char *IV, unsigned long len, symmetric_CFB *cfb);
575  int cfb_done(symmetric_CFB *cfb);
576  #endif
577  #ifdef LTC_OFB_MODE
578  int ofb_start(int cipher, const unsigned char *IV, const unsigned char *key,
579                int keylen, int num_rounds, symmetric_OFB *ofb);
580  int ofb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_OFB *ofb);
581  int ofb_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_OFB *ofb);
582  int ofb_getiv(unsigned char *IV, unsigned long *len, const symmetric_OFB *ofb);
583  int ofb_setiv(const unsigned char *IV, unsigned long len, symmetric_OFB *ofb);
584  int ofb_done(symmetric_OFB *ofb);
585  #endif
586  #ifdef LTC_CBC_MODE
587  int cbc_start(int cipher, const unsigned char *IV, const unsigned char *key,
588                 int keylen, int num_rounds, symmetric_CBC *cbc);
589  int cbc_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CBC *cbc);
590  int cbc_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_CBC *cbc);
591  int cbc_getiv(unsigned char *IV, unsigned long *len, const symmetric_CBC *cbc);
592  int cbc_setiv(const unsigned char *IV, unsigned long len, symmetric_CBC *cbc);
593  int cbc_done(symmetric_CBC *cbc);
594  #endif
595  #ifdef LTC_CTR_MODE
596  #define CTR_COUNTER_LITTLE_ENDIAN    0x0000
597  #define CTR_COUNTER_BIG_ENDIAN       0x1000
598  #define LTC_CTR_RFC3686              0x2000
599  int ctr_start(               int   cipher,
600                const unsigned char *IV,
601                const unsigned char *key,       int keylen,
602                               int  num_rounds, int ctr_mode,
603                     symmetric_CTR *ctr);
604  int ctr_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CTR *ctr);
605  int ctr_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_CTR *ctr);
606  int ctr_getiv(unsigned char *IV, unsigned long *len, const symmetric_CTR *ctr);
607  int ctr_setiv(const unsigned char *IV, unsigned long len, symmetric_CTR *ctr);
608  int ctr_done(symmetric_CTR *ctr);
609  int ctr_test(void);
610  #endif
611  #ifdef LTC_LRW_MODE
612  #define LRW_ENCRYPT LTC_ENCRYPT
613  #define LRW_DECRYPT LTC_DECRYPT
614  int lrw_start(               int   cipher,
615                const unsigned char *IV,
616                const unsigned char *key,       int keylen,
617                const unsigned char *tweak,
618                               int  num_rounds,
619                     symmetric_LRW *lrw);
620  int lrw_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_LRW *lrw);
621  int lrw_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_LRW *lrw);
622  int lrw_getiv(unsigned char *IV, unsigned long *len, const symmetric_LRW *lrw);
623  int lrw_setiv(const unsigned char *IV, unsigned long len, symmetric_LRW *lrw);
624  int lrw_done(symmetric_LRW *lrw);
625  int lrw_test(void);
626  int lrw_process(const unsigned char *pt, unsigned char *ct, unsigned long len, int mode, symmetric_LRW *lrw);
627  #endif
628  #ifdef LTC_F8_MODE
629  int f8_start(                int  cipher, const unsigned char *IV,
630               const unsigned char *key,                    int  keylen,
631               const unsigned char *salt_key,               int  skeylen,
632                               int  num_rounds,   symmetric_F8  *f8);
633  int f8_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_F8 *f8);
634  int f8_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_F8 *f8);
635  int f8_getiv(unsigned char *IV, unsigned long *len, const symmetric_F8 *f8);
636  int f8_setiv(const unsigned char *IV, unsigned long len, symmetric_F8 *f8);
637  int f8_done(symmetric_F8 *f8);
638  int f8_test_mode(void);
639  #endif
640  #ifdef LTC_XTS_MODE
641  typedef struct {
642     symmetric_key  key1, key2;
643     int            cipher;
644  } symmetric_xts;
645  int xts_start(                int  cipher,
646                const unsigned char *key1,
647                const unsigned char *key2,
648                      unsigned long  keylen,
649                                int  num_rounds,
650                      symmetric_xts *xts);
651  int xts_encrypt(
652     const unsigned char *pt, unsigned long ptlen,
653           unsigned char *ct,
654           unsigned char *tweak,
655     const symmetric_xts *xts);
656  int xts_decrypt(
657     const unsigned char *ct, unsigned long ptlen,
658           unsigned char *pt,
659           unsigned char *tweak,
660     const symmetric_xts *xts);
661  void xts_done(symmetric_xts *xts);
662  int  xts_test(void);
663  void xts_mult_x(unsigned char *I);
664  #endif
665  int find_cipher(const char *name);
666  int find_cipher_any(const char *name, int blocklen, int keylen);
667  int find_cipher_id(unsigned char ID);
668  int register_cipher(const struct ltc_cipher_descriptor *cipher);
669  int unregister_cipher(const struct ltc_cipher_descriptor *cipher);
670  int register_all_ciphers(void);
671  int cipher_is_valid(int idx);
672  LTC_MUTEX_PROTO(ltc_cipher_mutex)
673  #ifdef LTC_CHACHA
674  typedef struct {
675     ulong32 input[16];
676     unsigned char kstream[64];
677     unsigned long ksleft;
678     unsigned long ivlen;
679     int rounds;
680  } chacha_state;
681  int chacha_setup(chacha_state *st, const unsigned char *key, unsigned long keylen, int rounds);
682  int chacha_ivctr32(chacha_state *st, const unsigned char *iv, unsigned long ivlen, ulong32 counter);
683  int chacha_ivctr64(chacha_state *st, const unsigned char *iv, unsigned long ivlen, ulong64 counter);
684  int chacha_crypt(chacha_state *st, const unsigned char *in, unsigned long inlen, unsigned char *out);
685  int chacha_keystream(chacha_state *st, unsigned char *out, unsigned long outlen);
686  int chacha_done(chacha_state *st);
687  int chacha_test(void);
688  int chacha_memory(const unsigned char *key,    unsigned long keylen,  unsigned long rounds,
689                    const unsigned char *iv,     unsigned long ivlen,   ulong64 counter,
690                    const unsigned char *datain, unsigned long datalen, unsigned char *dataout);
691  #endif &bsol;* LTC_CHACHA */
692  #ifdef LTC_SALSA20
693  typedef struct {
694     ulong32 input[16];
695     unsigned char kstream[64];
696     unsigned long ksleft;
697     unsigned long ivlen;
698     int rounds;
699  } salsa20_state;
700  int salsa20_setup(salsa20_state *st, const unsigned char *key, unsigned long keylen, int rounds);
701  int salsa20_ivctr64(salsa20_state *st, const unsigned char *iv, unsigned long ivlen, ulong64 counter);
702  int salsa20_crypt(salsa20_state *st, const unsigned char *in, unsigned long inlen, unsigned char *out);
703  int salsa20_keystream(salsa20_state *st, unsigned char *out, unsigned long outlen);
704  int salsa20_done(salsa20_state *st);
705  int salsa20_test(void);
706  int salsa20_memory(const unsigned char *key,    unsigned long keylen,  unsigned long rounds,
707                     const unsigned char *iv,     unsigned long ivlen,   ulong64 counter,
708                     const unsigned char *datain, unsigned long datalen, unsigned char *dataout);
709  #endif &bsol;* LTC_SALSA20 */
710  #ifdef LTC_XSALSA20
711  int xsalsa20_setup(salsa20_state *st, const unsigned char *key,   unsigned long keylen,
712                                        const unsigned char *nonce, unsigned long noncelen,
713                                        int rounds);
714  int xsalsa20_test(void);
715  int xsalsa20_memory(const unsigned char *key,    unsigned long keylen,   unsigned long rounds,
716                      const unsigned char *nonce,  unsigned long noncelen,
717                      const unsigned char *datain, unsigned long datalen,  unsigned char *dataout);
718  #endif &bsol;* LTC_XSALSA20 */
719  #ifdef LTC_SOSEMANUK
720  typedef struct {
721      ulong32 kc[100];    &bsol;* key_context */
722      ulong32 s00, s01, s02, s03, s04, s05, s06, s07, s08, s09;
723      ulong32 r1, r2;
724      unsigned char buf[80];
725      unsigned ptr;
726  } sosemanuk_state;
727  int sosemanuk_setup(sosemanuk_state *st, const unsigned char *key, unsigned long keylen);
728  int sosemanuk_setiv(sosemanuk_state *st, const unsigned char *iv, unsigned long ivlen);
729  int sosemanuk_crypt(sosemanuk_state *st, const unsigned char *in, unsigned long inlen, unsigned char *out);
730  int sosemanuk_keystream(sosemanuk_state *st, unsigned char *out, unsigned long outlen);
731  int sosemanuk_done(sosemanuk_state *st);
732  int sosemanuk_test(void);
733  int sosemanuk_memory(const unsigned char *key,    unsigned long keylen,
734                       const unsigned char *iv,     unsigned long ivlen,
735                       const unsigned char *datain, unsigned long datalen,
736                       unsigned char *dataout);
737  #endif &bsol;* LTC_SOSEMANUK */
738  #ifdef LTC_RABBIT
739  typedef struct {
740     ulong32 x[8];
741     ulong32 c[8];
742     ulong32 carry;
743  } rabbit_ctx;
744  typedef struct {
745     rabbit_ctx master_ctx;
746     rabbit_ctx work_ctx;
747     unsigned char block[16];     &bsol;* last keystream block containing unused bytes */
748     ulong32       unused;        &bsol;* count fm right */
749  } rabbit_state;
750  int rabbit_setup(rabbit_state* st, const unsigned char *key, unsigned long keylen);
751  int rabbit_setiv(rabbit_state* st, const unsigned char *iv, unsigned long ivlen);
752  int rabbit_crypt(rabbit_state* st, const unsigned char *in, unsigned long inlen, unsigned char *out);
753  int rabbit_keystream(rabbit_state* st, unsigned char *out, unsigned long outlen);
754  int rabbit_done(rabbit_state *st);
755  int rabbit_test(void);
756  int rabbit_memory(const unsigned char *key,    unsigned long keylen,
757                    const unsigned char *iv,     unsigned long ivlen,
758                    const unsigned char *datain, unsigned long datalen,
759                    unsigned char *dataout);
760  #endif &bsol;* LTC_RABBIT */
761  #ifdef LTC_RC4_STREAM
762  typedef struct {
763     unsigned int x, y;
764     unsigned char buf[256];
765  } rc4_state;
766  int rc4_stream_setup(rc4_state *st, const unsigned char *key, unsigned long keylen);
767  int rc4_stream_crypt(rc4_state *st, const unsigned char *in, unsigned long inlen, unsigned char *out);
768  int rc4_stream_keystream(rc4_state *st, unsigned char *out, unsigned long outlen);
769  int rc4_stream_done(rc4_state *st);
770  int rc4_stream_test(void);
771  int rc4_stream_memory(const unsigned char *key,    unsigned long keylen,
772                        const unsigned char *datain, unsigned long datalen,
773                        unsigned char *dataout);
774  #endif &bsol;* LTC_RC4_STREAM */
775  #ifdef LTC_SOBER128_STREAM
776  typedef struct {
777     ulong32 R[17],       &bsol;* Working storage for the shift register */
778             initR[17],   &bsol;* saved register contents */
779             konst,       &bsol;* key dependent constant */
780             sbuf;        &bsol;* partial word encryption buffer */
781     int     nbuf;        &bsol;* number of part-word stream bits buffered */
782  } sober128_state;
783  int sober128_stream_setup(sober128_state *st, const unsigned char *key, unsigned long keylen);
784  int sober128_stream_setiv(sober128_state *st, const unsigned char *iv, unsigned long ivlen);
785  int sober128_stream_crypt(sober128_state *st, const unsigned char *in, unsigned long inlen, unsigned char *out);
786  int sober128_stream_keystream(sober128_state *st, unsigned char *out, unsigned long outlen);
787  int sober128_stream_done(sober128_state *st);
788  int sober128_stream_test(void);
789  int sober128_stream_memory(const unsigned char *key,    unsigned long keylen,
790                             const unsigned char *iv,     unsigned long ivlen,
791                             const unsigned char *datain, unsigned long datalen,
792                             unsigned char *dataout);
793  #endif &bsol;* LTC_SOBER128_STREAM */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ctl.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_cipher.h</div>
                </div>
                <div class="column column_space"><pre><code>33  	uint64_t nflushes_small;
34  	bin_stats_t bstats[SC_NBINS];
35  	arena_stats_large_t lstats[SC_NSIZES - SC_NBINS];
36  	arena_stats_extents_t estats[SC_NPSIZES];
37  } ctl_arena_stats_t;
38  typedef struct ctl_stats_s {
39  	size_t allocated;
40  	size_t active;
41  	size_t metadata;
42  	size_t metadata_thp;
</pre></code></div>
                <div class="column column_space"><pre><code>220     int                 cipher,
221                         blocklen,
222                         padlen;
223     unsigned char       IV[MAXBLOCKSIZE],
224                         pad[MAXBLOCKSIZE];
225     symmetric_key       key;
226  } symmetric_CFB;
227  #endif
228  #ifdef LTC_OFB_MODE
229  typedef struct {
230     int                 cipher,
231                         blocklen,
232                         padlen;
233     unsigned char       IV[MAXBLOCKSIZE];
234     symmetric_key       key;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    