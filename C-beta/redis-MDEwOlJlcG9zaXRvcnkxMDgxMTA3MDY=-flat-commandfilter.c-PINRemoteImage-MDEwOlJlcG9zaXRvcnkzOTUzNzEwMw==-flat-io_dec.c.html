
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.450704225352112%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-commandfilter.c</h3>
            <pre><code>1  #define REDISMODULE_EXPERIMENTAL_API
2  #include "redismodule.h"
3  #include <string.h>
4  static RedisModuleString *log_key_name;
5  static const char log_command_name[] = "commandfilter.log";
6  static const char ping_command_name[] = "commandfilter.ping";
7  static const char unregister_command_name[] = "commandfilter.unregister";
8  static int in_log_command = 0;
9  static RedisModuleCommandFilter *filter = NULL;
10  int CommandFilter_UnregisterCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
11  {
12      (void) argc;
13      (void) argv;
14      RedisModule_ReplyWithLongLong(ctx,
15              RedisModule_UnregisterCommandFilter(ctx, filter));
<span onclick='openModal()' class='match'>16      return REDISMODULE_OK;
17  }
18  int CommandFilter_PingCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
19  {
20      (void) argc;
21      (void) argv;
22      RedisModuleCallReply *reply = RedisModule_Call(ctx, "ping", "c", "@log");
</span>23      if (reply) {
24          RedisModule_ReplyWithCallReply(ctx, reply);
25          RedisModule_FreeCallReply(reply);
26      } else {
27          RedisModule_ReplyWithSimpleString(ctx, "Unknown command or invalid arguments");
28      }
29      return REDISMODULE_OK;
30  }
31  int CommandFilter_LogCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
32  {
33      RedisModuleString *s = RedisModule_CreateString(ctx, "", 0);
34      int i;
35      for (i = 1; i < argc; i++) {
36          size_t arglen;
37          const char *arg = RedisModule_StringPtrLen(argv[i], &arglen);
38          if (i > 1) RedisModule_StringAppendBuffer(ctx, s, " ", 1);
39          RedisModule_StringAppendBuffer(ctx, s, arg, arglen);
40      }
41      RedisModuleKey *log = RedisModule_OpenKey(ctx, log_key_name, REDISMODULE_WRITE|REDISMODULE_READ);
42      RedisModule_ListPush(log, REDISMODULE_LIST_HEAD, s);
43      RedisModule_CloseKey(log);
44      RedisModule_FreeString(ctx, s);
45      in_log_command = 1;
46      size_t cmdlen;
47      const char *cmdname = RedisModule_StringPtrLen(argv[1], &cmdlen);
48      RedisModuleCallReply *reply = RedisModule_Call(ctx, cmdname, "v", &argv[2], argc - 2);
49      if (reply) {
50          RedisModule_ReplyWithCallReply(ctx, reply);
51          RedisModule_FreeCallReply(reply);
52      } else {
53          RedisModule_ReplyWithSimpleString(ctx, "Unknown command or invalid arguments");
54      }
55      in_log_command = 0;
56      return REDISMODULE_OK;
57  }
58  void CommandFilter_CommandFilter(RedisModuleCommandFilterCtx *filter)
59  {
60      if (in_log_command) return;  &bsol;* don't process our own RM_Call() from CommandFilter_LogCommand() */
61      int log = 0;
62      int pos = 0;
63      while (pos < RedisModule_CommandFilterArgsCount(filter)) {
64          const RedisModuleString *arg = RedisModule_CommandFilterArgGet(filter, pos);
65          size_t arg_len;
66          const char *arg_str = RedisModule_StringPtrLen(arg, &arg_len);
67          if (arg_len == 6 && !memcmp(arg_str, "@delme", 6)) {
68              RedisModule_CommandFilterArgDelete(filter, pos);
69              continue;
70          } 
71          if (arg_len == 10 && !memcmp(arg_str, "@replaceme", 10)) {
72              RedisModule_CommandFilterArgReplace(filter, pos,
73                      RedisModule_CreateString(NULL, "--replaced--", 12));
74          } else if (arg_len == 13 && !memcmp(arg_str, "@insertbefore", 13)) {
75              RedisModule_CommandFilterArgInsert(filter, pos,
76                      RedisModule_CreateString(NULL, "--inserted-before--", 19));
77              pos++;
78          } else if (arg_len == 12 && !memcmp(arg_str, "@insertafter", 12)) {
79              RedisModule_CommandFilterArgInsert(filter, pos + 1,
80                      RedisModule_CreateString(NULL, "--inserted-after--", 18));
81              pos++;
82          } else if (arg_len == 4 && !memcmp(arg_str, "@log", 4)) {
83              log = 1;
84          }
85          pos++;
86      }
87      if (log) RedisModule_CommandFilterArgInsert(filter, 0,
88              RedisModule_CreateString(NULL, log_command_name, sizeof(log_command_name)-1));
89  }
90  int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
91      if (RedisModule_Init(ctx,"commandfilter",1,REDISMODULE_APIVER_1)
92              == REDISMODULE_ERR) return REDISMODULE_ERR;
93      if (argc != 2) {
94          RedisModule_Log(ctx, "warning", "Log key name not specified");
95          return REDISMODULE_ERR;
96      }
97      long long noself = 0;
98      log_key_name = RedisModule_CreateStringFromString(ctx, argv[0]);
99      RedisModule_StringToLongLong(argv[1], &noself);
100      if (RedisModule_CreateCommand(ctx,log_command_name,
101                  CommandFilter_LogCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
102              return REDISMODULE_ERR;
103      if (RedisModule_CreateCommand(ctx,ping_command_name,
104                  CommandFilter_PingCommand,"deny-oom",1,1,1) == REDISMODULE_ERR)
105              return REDISMODULE_ERR;
106      if (RedisModule_CreateCommand(ctx,unregister_command_name,
107                  CommandFilter_UnregisterCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
108              return REDISMODULE_ERR;
109      if ((filter = RedisModule_RegisterCommandFilter(ctx, CommandFilter_CommandFilter, 
110                      noself ? REDISMODULE_CMDFILTER_NOSELF : 0))
111              == NULL) return REDISMODULE_ERR;
112      return REDISMODULE_OK;
113  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-io_dec.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include "src/dec/vp8i_dec.h"
4  #include "src/dec/webpi_dec.h"
5  #include "src/dsp/dsp.h"
6  #include "src/dsp/yuv.h"
7  #include "src/utils/utils.h"
8  static int EmitYUV(const VP8Io* const io, WebPDecParams* const p) {
9    WebPDecBuffer* output = p->output;
10    const WebPYUVABuffer* const buf = &output->u.YUVA;
11    uint8_t* const y_dst = buf->y + io->mb_y * buf->y_stride;
12    uint8_t* const u_dst = buf->u + (io->mb_y >> 1) * buf->u_stride;
13    uint8_t* const v_dst = buf->v + (io->mb_y >> 1) * buf->v_stride;
14    const int mb_w = io->mb_w;
15    const int mb_h = io->mb_h;
16    const int uv_w = (mb_w + 1) / 2;
17    const int uv_h = (mb_h + 1) / 2;
18    int j;
19    for (j = 0; j < mb_h; ++j) {
20      memcpy(y_dst + j * buf->y_stride, io->y + j * io->y_stride, mb_w);
21    }
22    for (j = 0; j < uv_h; ++j) {
23      memcpy(u_dst + j * buf->u_stride, io->u + j * io->uv_stride, uv_w);
24      memcpy(v_dst + j * buf->v_stride, io->v + j * io->uv_stride, uv_w);
25    }
26    return io->mb_h;
27  }
28  static int EmitSampledRGB(const VP8Io* const io, WebPDecParams* const p) {
29    WebPDecBuffer* const output = p->output;
30    WebPRGBABuffer* const buf = &output->u.RGBA;
31    uint8_t* const dst = buf->rgba + io->mb_y * buf->stride;
32    WebPSamplerProcessPlane(io->y, io->y_stride,
33                            io->u, io->v, io->uv_stride,
34                            dst, buf->stride, io->mb_w, io->mb_h,
35                            WebPSamplers[output->colorspace]);
36    return io->mb_h;
37  }
38  #ifdef FANCY_UPSAMPLING
39  static int EmitFancyRGB(const VP8Io* const io, WebPDecParams* const p) {
40    int num_lines_out = io->mb_h;   
41    const WebPRGBABuffer* const buf = &p->output->u.RGBA;
42    uint8_t* dst = buf->rgba + io->mb_y * buf->stride;
43    WebPUpsampleLinePairFunc upsample = WebPUpsamplers[p->output->colorspace];
44    const uint8_t* cur_y = io->y;
45    const uint8_t* cur_u = io->u;
46    const uint8_t* cur_v = io->v;
47    const uint8_t* top_u = p->tmp_u;
48    const uint8_t* top_v = p->tmp_v;
49    int y = io->mb_y;
50    const int y_end = io->mb_y + io->mb_h;
51    const int mb_w = io->mb_w;
52    const int uv_w = (mb_w + 1) / 2;
53    if (y == 0) {
54      upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, mb_w);
55    } else {
56      upsample(p->tmp_y, cur_y, top_u, top_v, cur_u, cur_v,
57               dst - buf->stride, dst, mb_w);
58      ++num_lines_out;
59    }
60    for (; y + 2 < y_end; y += 2) {
61      top_u = cur_u;
62      top_v = cur_v;
63      cur_u += io->uv_stride;
64      cur_v += io->uv_stride;
65      dst += 2 * buf->stride;
66      cur_y += 2 * io->y_stride;
67      upsample(cur_y - io->y_stride, cur_y,
68               top_u, top_v, cur_u, cur_v,
69               dst - buf->stride, dst, mb_w);
70    }
71    cur_y += io->y_stride;
72    if (io->crop_top + y_end < io->crop_bottom) {
73      memcpy(p->tmp_y, cur_y, mb_w * sizeof(*p->tmp_y));
74      memcpy(p->tmp_u, cur_u, uv_w * sizeof(*p->tmp_u));
75      memcpy(p->tmp_v, cur_v, uv_w * sizeof(*p->tmp_v));
76      num_lines_out--;
77    } else {
78      if (!(y_end & 1)) {
79        upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v,
80                 dst + buf->stride, NULL, mb_w);
81      }
82    }
83    return num_lines_out;
84  }
85  #endif    &bsol;* FANCY_UPSAMPLING */
86  static void FillAlphaPlane(uint8_t* dst, int w, int h, int stride) {
87    int j;
88    for (j = 0; j < h; ++j) {
89      memset(dst, 0xff, w * sizeof(*dst));
90      dst += stride;
91    }
92  }
93  static int EmitAlphaYUV(const VP8Io* const io, WebPDecParams* const p,
94                          int expected_num_lines_out) {
95    const uint8_t* alpha = io->a;
96    const WebPYUVABuffer* const buf = &p->output->u.YUVA;
97    const int mb_w = io->mb_w;
98    const int mb_h = io->mb_h;
99    uint8_t* dst = buf->a + io->mb_y * buf->a_stride;
100    int j;
101    (void)expected_num_lines_out;
102    assert(expected_num_lines_out == mb_h);
103    if (alpha != NULL) {
104      for (j = 0; j < mb_h; ++j) {
105        memcpy(dst, alpha, mb_w * sizeof(*dst));
106        alpha += io->width;
107        dst += buf->a_stride;
108      }
109    } else if (buf->a != NULL) {
110      FillAlphaPlane(dst, mb_w, mb_h, buf->a_stride);
111    }
112    return 0;
113  }
114  static int GetAlphaSourceRow(const VP8Io* const io,
115                               const uint8_t** alpha, int* const num_rows) {
116    int start_y = io->mb_y;
117    *num_rows = io->mb_h;
118    if (io->fancy_upsampling) {
119      if (start_y == 0) {
120        --*num_rows;
121      } else {
122        --start_y;
123        *alpha -= io->width;
124      }
125      if (io->crop_top + io->mb_y + io->mb_h == io->crop_bottom) {
126        *num_rows = io->crop_bottom - io->crop_top - start_y;
127      }
128    }
<span onclick='openModal()' class='match'>129    return start_y;
130  }
131  static int EmitAlphaRGB(const VP8Io* const io, WebPDecParams* const p,
132                          int expected_num_lines_out) {
133    const uint8_t* alpha = io->a;
</span>134    if (alpha != NULL) {
135      const int mb_w = io->mb_w;
136      const WEBP_CSP_MODE colorspace = p->output->colorspace;
137      const int alpha_first =
138          (colorspace == MODE_ARGB || colorspace == MODE_Argb);
139      const WebPRGBABuffer* const buf = &p->output->u.RGBA;
140      int num_rows;
141      const int start_y = GetAlphaSourceRow(io, &alpha, &num_rows);
142      uint8_t* const base_rgba = buf->rgba + start_y * buf->stride;
143      uint8_t* const dst = base_rgba + (alpha_first ? 0 : 3);
144      const int has_alpha = WebPDispatchAlpha(alpha, io->width, mb_w,
145                                              num_rows, dst, buf->stride);
146      (void)expected_num_lines_out;
147      assert(expected_num_lines_out == num_rows);
148      if (has_alpha && WebPIsPremultipliedMode(colorspace)) {
149        WebPApplyAlphaMultiply(base_rgba, alpha_first,
150                               mb_w, num_rows, buf->stride);
151      }
152    }
153    return 0;
154  }
155  static int EmitAlphaRGBA4444(const VP8Io* const io, WebPDecParams* const p,
156                               int expected_num_lines_out) {
157    const uint8_t* alpha = io->a;
158    if (alpha != NULL) {
159      const int mb_w = io->mb_w;
160      const WEBP_CSP_MODE colorspace = p->output->colorspace;
161      const WebPRGBABuffer* const buf = &p->output->u.RGBA;
162      int num_rows;
163      const int start_y = GetAlphaSourceRow(io, &alpha, &num_rows);
164      uint8_t* const base_rgba = buf->rgba + start_y * buf->stride;
165  #if (WEBP_SWAP_16BIT_CSP == 1)
166      uint8_t* alpha_dst = base_rgba;
167  #else
168      uint8_t* alpha_dst = base_rgba + 1;
169  #endif
170      uint32_t alpha_mask = 0x0f;
171      int i, j;
172      for (j = 0; j < num_rows; ++j) {
173        for (i = 0; i < mb_w; ++i) {
174          const uint32_t alpha_value = alpha[i] >> 4;
175          alpha_dst[2 * i] = (alpha_dst[2 * i] & 0xf0) | alpha_value;
176          alpha_mask &= alpha_value;
177        }
178        alpha += io->width;
179        alpha_dst += buf->stride;
180      }
181      (void)expected_num_lines_out;
182      assert(expected_num_lines_out == num_rows);
183      if (alpha_mask != 0x0f && WebPIsPremultipliedMode(colorspace)) {
184        WebPApplyAlphaMultiply4444(base_rgba, mb_w, num_rows, buf->stride);
185      }
186    }
187    return 0;
188  }
189  #if !defined(WEBP_REDUCE_SIZE)
190  static int Rescale(const uint8_t* src, int src_stride,
191                     int new_lines, WebPRescaler* const wrk) {
192    int num_lines_out = 0;
193    while (new_lines > 0) {    
194      const int lines_in = WebPRescalerImport(wrk, new_lines, src, src_stride);
195      src += lines_in * src_stride;
196      new_lines -= lines_in;
197      num_lines_out += WebPRescalerExport(wrk);    
198    }
199    return num_lines_out;
200  }
201  static int EmitRescaledYUV(const VP8Io* const io, WebPDecParams* const p) {
202    const int mb_h = io->mb_h;
203    const int uv_mb_h = (mb_h + 1) >> 1;
204    WebPRescaler* const scaler = p->scaler_y;
205    int num_lines_out = 0;
206    if (WebPIsAlphaMode(p->output->colorspace) && io->a != NULL) {
207      WebPMultRows((uint8_t*)io->y, io->y_stride,
208                   io->a, io->width, io->mb_w, mb_h, 0);
209    }
210    num_lines_out = Rescale(io->y, io->y_stride, mb_h, scaler);
211    Rescale(io->u, io->uv_stride, uv_mb_h, p->scaler_u);
212    Rescale(io->v, io->uv_stride, uv_mb_h, p->scaler_v);
213    return num_lines_out;
214  }
215  static int EmitRescaledAlphaYUV(const VP8Io* const io, WebPDecParams* const p,
216                                  int expected_num_lines_out) {
217    const WebPYUVABuffer* const buf = &p->output->u.YUVA;
218    uint8_t* const dst_a = buf->a + p->last_y * buf->a_stride;
219    if (io->a != NULL) {
220      uint8_t* const dst_y = buf->y + p->last_y * buf->y_stride;
221      const int num_lines_out = Rescale(io->a, io->width, io->mb_h, p->scaler_a);
222      assert(expected_num_lines_out == num_lines_out);
223      if (num_lines_out > 0) {   
224        WebPMultRows(dst_y, buf->y_stride, dst_a, buf->a_stride,
225                     p->scaler_a->dst_width, num_lines_out, 1);
226      }
227    } else if (buf->a != NULL) {
228      assert(p->last_y + expected_num_lines_out <= io->scaled_height);
229      FillAlphaPlane(dst_a, io->scaled_width, expected_num_lines_out,
230                     buf->a_stride);
231    }
232    return 0;
233  }
234  static int InitYUVRescaler(const VP8Io* const io, WebPDecParams* const p) {
235    const int has_alpha = WebPIsAlphaMode(p->output->colorspace);
236    const WebPYUVABuffer* const buf = &p->output->u.YUVA;
237    const int out_width  = io->scaled_width;
238    const int out_height = io->scaled_height;
239    const int uv_out_width  = (out_width + 1) >> 1;
240    const int uv_out_height = (out_height + 1) >> 1;
241    const int uv_in_width  = (io->mb_w + 1) >> 1;
242    const int uv_in_height = (io->mb_h + 1) >> 1;
243    const size_t work_size = 2 * out_width;   
244    const size_t uv_work_size = 2 * uv_out_width;  
245    size_t tmp_size, rescaler_size;
246    rescaler_t* work;
247    WebPRescaler* scalers;
248    const int num_rescalers = has_alpha ? 4 : 3;
249    tmp_size = (work_size + 2 * uv_work_size) * sizeof(*work);
250    if (has_alpha) {
251      tmp_size += work_size * sizeof(*work);
252    }
253    rescaler_size = num_rescalers * sizeof(*p->scaler_y) + WEBP_ALIGN_CST;
254    p->memory = WebPSafeMalloc(1ULL, tmp_size + rescaler_size);
255    if (p->memory == NULL) {
256      return 0;   
257    }
258    work = (rescaler_t*)p->memory;
259    scalers = (WebPRescaler*)WEBP_ALIGN((const uint8_t*)work + tmp_size);
260    p->scaler_y = &scalers[0];
261    p->scaler_u = &scalers[1];
262    p->scaler_v = &scalers[2];
263    p->scaler_a = has_alpha ? &scalers[3] : NULL;
264    WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h,
265                     buf->y, out_width, out_height, buf->y_stride, 1,
266                     work);
267    WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height,
268                     buf->u, uv_out_width, uv_out_height, buf->u_stride, 1,
269                     work + work_size);
270    WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height,
271                     buf->v, uv_out_width, uv_out_height, buf->v_stride, 1,
272                     work + work_size + uv_work_size);
273    p->emit = EmitRescaledYUV;
274    if (has_alpha) {
275      WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h,
276                       buf->a, out_width, out_height, buf->a_stride, 1,
277                       work + work_size + 2 * uv_work_size);
278      p->emit_alpha = EmitRescaledAlphaYUV;
279      WebPInitAlphaProcessing();
280    }
281    return 1;
282  }
283  static int ExportRGB(WebPDecParams* const p, int y_pos) {
284    const WebPYUV444Converter convert =
285        WebPYUV444Converters[p->output->colorspace];
286    const WebPRGBABuffer* const buf = &p->output->u.RGBA;
287    uint8_t* dst = buf->rgba + y_pos * buf->stride;
288    int num_lines_out = 0;
289    while (WebPRescalerHasPendingOutput(p->scaler_y) &&
290           WebPRescalerHasPendingOutput(p->scaler_u)) {
291      assert(y_pos + num_lines_out < p->output->height);
292      assert(p->scaler_u->y_accum == p->scaler_v->y_accum);
293      WebPRescalerExportRow(p->scaler_y);
294      WebPRescalerExportRow(p->scaler_u);
295      WebPRescalerExportRow(p->scaler_v);
296      convert(p->scaler_y->dst, p->scaler_u->dst, p->scaler_v->dst,
297              dst, p->scaler_y->dst_width);
298      dst += buf->stride;
299      ++num_lines_out;
300    }
301    return num_lines_out;
302  }
303  static int EmitRescaledRGB(const VP8Io* const io, WebPDecParams* const p) {
304    const int mb_h = io->mb_h;
305    const int uv_mb_h = (mb_h + 1) >> 1;
306    int j = 0, uv_j = 0;
307    int num_lines_out = 0;
308    while (j < mb_h) {
309      const int y_lines_in =
310          WebPRescalerImport(p->scaler_y, mb_h - j,
311                             io->y + j * io->y_stride, io->y_stride);
312      j += y_lines_in;
313      if (WebPRescaleNeededLines(p->scaler_u, uv_mb_h - uv_j)) {
314        const int u_lines_in =
315            WebPRescalerImport(p->scaler_u, uv_mb_h - uv_j,
316                               io->u + uv_j * io->uv_stride, io->uv_stride);
317        const int v_lines_in =
318            WebPRescalerImport(p->scaler_v, uv_mb_h - uv_j,
319                               io->v + uv_j * io->uv_stride, io->uv_stride);
320        (void)v_lines_in;   
321        assert(u_lines_in == v_lines_in);
322        uv_j += u_lines_in;
323      }
324      num_lines_out += ExportRGB(p, p->last_y + num_lines_out);
325    }
326    return num_lines_out;
327  }
328  static int ExportAlpha(WebPDecParams* const p, int y_pos, int max_lines_out) {
329    const WebPRGBABuffer* const buf = &p->output->u.RGBA;
330    uint8_t* const base_rgba = buf->rgba + y_pos * buf->stride;
331    const WEBP_CSP_MODE colorspace = p->output->colorspace;
332    const int alpha_first =
333        (colorspace == MODE_ARGB || colorspace == MODE_Argb);
334    uint8_t* dst = base_rgba + (alpha_first ? 0 : 3);
335    int num_lines_out = 0;
336    const int is_premult_alpha = WebPIsPremultipliedMode(colorspace);
337    uint32_t non_opaque = 0;
338    const int width = p->scaler_a->dst_width;
339    while (WebPRescalerHasPendingOutput(p->scaler_a) &&
340           num_lines_out < max_lines_out) {
341      assert(y_pos + num_lines_out < p->output->height);
342      WebPRescalerExportRow(p->scaler_a);
343      non_opaque |= WebPDispatchAlpha(p->scaler_a->dst, 0, width, 1, dst, 0);
344      dst += buf->stride;
345      ++num_lines_out;
346    }
347    if (is_premult_alpha && non_opaque) {
348      WebPApplyAlphaMultiply(base_rgba, alpha_first,
349                             width, num_lines_out, buf->stride);
350    }
351    return num_lines_out;
352  }
353  static int ExportAlphaRGBA4444(WebPDecParams* const p, int y_pos,
354                                 int max_lines_out) {
355    const WebPRGBABuffer* const buf = &p->output->u.RGBA;
356    uint8_t* const base_rgba = buf->rgba + y_pos * buf->stride;
357  #if (WEBP_SWAP_16BIT_CSP == 1)
358    uint8_t* alpha_dst = base_rgba;
359  #else
360    uint8_t* alpha_dst = base_rgba + 1;
361  #endif
362    int num_lines_out = 0;
363    const WEBP_CSP_MODE colorspace = p->output->colorspace;
364    const int width = p->scaler_a->dst_width;
365    const int is_premult_alpha = WebPIsPremultipliedMode(colorspace);
366    uint32_t alpha_mask = 0x0f;
367    while (WebPRescalerHasPendingOutput(p->scaler_a) &&
368           num_lines_out < max_lines_out) {
369      int i;
370      assert(y_pos + num_lines_out < p->output->height);
371      WebPRescalerExportRow(p->scaler_a);
372      for (i = 0; i < width; ++i) {
373        const uint32_t alpha_value = p->scaler_a->dst[i] >> 4;
374        alpha_dst[2 * i] = (alpha_dst[2 * i] & 0xf0) | alpha_value;
375        alpha_mask &= alpha_value;
376      }
377      alpha_dst += buf->stride;
378      ++num_lines_out;
379    }
380    if (is_premult_alpha && alpha_mask != 0x0f) {
381      WebPApplyAlphaMultiply4444(base_rgba, width, num_lines_out, buf->stride);
382    }
383    return num_lines_out;
384  }
385  static int EmitRescaledAlphaRGB(const VP8Io* const io, WebPDecParams* const p,
386                                  int expected_num_out_lines) {
387    if (io->a != NULL) {
388      WebPRescaler* const scaler = p->scaler_a;
389      int lines_left = expected_num_out_lines;
390      const int y_end = p->last_y + lines_left;
391      while (lines_left > 0) {
392        const int row_offset = scaler->src_y - io->mb_y;
393        WebPRescalerImport(scaler, io->mb_h + io->mb_y - scaler->src_y,
394                           io->a + row_offset * io->width, io->width);
395        lines_left -= p->emit_alpha_row(p, y_end - lines_left, lines_left);
396      }
397    }
398    return 0;
399  }
400  static int InitRGBRescaler(const VP8Io* const io, WebPDecParams* const p) {
401    const int has_alpha = WebPIsAlphaMode(p->output->colorspace);
402    const int out_width  = io->scaled_width;
403    const int out_height = io->scaled_height;
404    const int uv_in_width  = (io->mb_w + 1) >> 1;
405    const int uv_in_height = (io->mb_h + 1) >> 1;
406    const size_t work_size = 2 * out_width;   
407    rescaler_t* work;  
408    uint8_t* tmp;   
409    size_t tmp_size1, tmp_size2, total_size, rescaler_size;
410    WebPRescaler* scalers;
411    const int num_rescalers = has_alpha ? 4 : 3;
412    tmp_size1 = 3 * work_size;
413    tmp_size2 = 3 * out_width;
414    if (has_alpha) {
415      tmp_size1 += work_size;
416      tmp_size2 += out_width;
417    }
418    total_size = tmp_size1 * sizeof(*work) + tmp_size2 * sizeof(*tmp);
419    rescaler_size = num_rescalers * sizeof(*p->scaler_y) + WEBP_ALIGN_CST;
420    p->memory = WebPSafeMalloc(1ULL, total_size + rescaler_size);
421    if (p->memory == NULL) {
422      return 0;   
423    }
424    work = (rescaler_t*)p->memory;
425    tmp = (uint8_t*)(work + tmp_size1);
426    scalers = (WebPRescaler*)WEBP_ALIGN((const uint8_t*)work + total_size);
427    p->scaler_y = &scalers[0];
428    p->scaler_u = &scalers[1];
429    p->scaler_v = &scalers[2];
430    p->scaler_a = has_alpha ? &scalers[3] : NULL;
431    WebPRescalerInit(p->scaler_y, io->mb_w, io->mb_h,
432                     tmp + 0 * out_width, out_width, out_height, 0, 1,
433                     work + 0 * work_size);
434    WebPRescalerInit(p->scaler_u, uv_in_width, uv_in_height,
435                     tmp + 1 * out_width, out_width, out_height, 0, 1,
436                     work + 1 * work_size);
437    WebPRescalerInit(p->scaler_v, uv_in_width, uv_in_height,
438                     tmp + 2 * out_width, out_width, out_height, 0, 1,
439                     work + 2 * work_size);
440    p->emit = EmitRescaledRGB;
441    WebPInitYUV444Converters();
442    if (has_alpha) {
443      WebPRescalerInit(p->scaler_a, io->mb_w, io->mb_h,
444                       tmp + 3 * out_width, out_width, out_height, 0, 1,
445                       work + 3 * work_size);
446      p->emit_alpha = EmitRescaledAlphaRGB;
447      if (p->output->colorspace == MODE_RGBA_4444 ||
448          p->output->colorspace == MODE_rgbA_4444) {
449        p->emit_alpha_row = ExportAlphaRGBA4444;
450      } else {
451        p->emit_alpha_row = ExportAlpha;
452      }
453      WebPInitAlphaProcessing();
454    }
455    return 1;
456  }
457  #endif  
458  static int CustomSetup(VP8Io* io) {
459    WebPDecParams* const p = (WebPDecParams*)io->opaque;
460    const WEBP_CSP_MODE colorspace = p->output->colorspace;
461    const int is_rgb = WebPIsRGBMode(colorspace);
462    const int is_alpha = WebPIsAlphaMode(colorspace);
463    p->memory = NULL;
464    p->emit = NULL;
465    p->emit_alpha = NULL;
466    p->emit_alpha_row = NULL;
467    if (!WebPIoInitFromOptions(p->options, io, is_alpha ? MODE_YUV : MODE_YUVA)) {
468      return 0;
469    }
470    if (is_alpha && WebPIsPremultipliedMode(colorspace)) {
471      WebPInitUpsamplers();
472    }
473    if (io->use_scaling) {
474  #if !defined(WEBP_REDUCE_SIZE)
475      const int ok = is_rgb ? InitRGBRescaler(io, p) : InitYUVRescaler(io, p);
476      if (!ok) {
477        return 0;    
478      }
479  #else
480      return 0;   
481  #endif
482    } else {
483      if (is_rgb) {
484        WebPInitSamplers();
485        p->emit = EmitSampledRGB;   
486        if (io->fancy_upsampling) {
487  #ifdef FANCY_UPSAMPLING
488          const int uv_width = (io->mb_w + 1) >> 1;
489          p->memory = WebPSafeMalloc(1ULL, (size_t)(io->mb_w + 2 * uv_width));
490          if (p->memory == NULL) {
491            return 0;   
492          }
493          p->tmp_y = (uint8_t*)p->memory;
494          p->tmp_u = p->tmp_y + io->mb_w;
495          p->tmp_v = p->tmp_u + uv_width;
496          p->emit = EmitFancyRGB;
497          WebPInitUpsamplers();
498  #endif
499        }
500      } else {
501        p->emit = EmitYUV;
502      }
503      if (is_alpha) {  
504        p->emit_alpha =
505            (colorspace == MODE_RGBA_4444 || colorspace == MODE_rgbA_4444) ?
506                EmitAlphaRGBA4444
507            : is_rgb ? EmitAlphaRGB
508            : EmitAlphaYUV;
509        if (is_rgb) {
510          WebPInitAlphaProcessing();
511        }
512      }
513    }
514    return 1;
515  }
516  static int CustomPut(const VP8Io* io) {
517    WebPDecParams* const p = (WebPDecParams*)io->opaque;
518    const int mb_w = io->mb_w;
519    const int mb_h = io->mb_h;
520    int num_lines_out;
521    assert(!(io->mb_y & 1));
522    if (mb_w <= 0 || mb_h <= 0) {
523      return 0;
524    }
525    num_lines_out = p->emit(io, p);
526    if (p->emit_alpha != NULL) {
527      p->emit_alpha(io, p, num_lines_out);
528    }
529    p->last_y += num_lines_out;
530    return 1;
531  }
532  static void CustomTeardown(const VP8Io* io) {
533    WebPDecParams* const p = (WebPDecParams*)io->opaque;
534    WebPSafeFree(p->memory);
535    p->memory = NULL;
536  }
537  void WebPInitCustomIo(WebPDecParams* const params, VP8Io* const io) {
538    io->put      = CustomPut;
539    io->setup    = CustomSetup;
540    io->teardown = CustomTeardown;
541    io->opaque   = params;
542  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-commandfilter.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-io_dec.c</div>
                </div>
                <div class="column column_space"><pre><code>16      return REDISMODULE_OK;
17  }
18  int CommandFilter_PingCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
19  {
20      (void) argc;
21      (void) argv;
22      RedisModuleCallReply *reply = RedisModule_Call(ctx, "ping", "c", "@log");
</pre></code></div>
                <div class="column column_space"><pre><code>129    return start_y;
130  }
131  static int EmitAlphaRGB(const VP8Io* const io, WebPDecParams* const p,
132                          int expected_num_lines_out) {
133    const uint8_t* alpha = io->a;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    