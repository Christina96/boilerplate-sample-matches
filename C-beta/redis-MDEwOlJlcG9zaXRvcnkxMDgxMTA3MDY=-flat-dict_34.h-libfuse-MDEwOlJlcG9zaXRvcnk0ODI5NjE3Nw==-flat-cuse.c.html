
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.545454545454546%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-dict_34.h</h3>
            <pre><code>1  #include <stdint.h>
2  #ifdef _WIN32
3  #include "Win32_Interop/win32_types.h"
4  #endif
5  #ifndef __DICT_H
6  #define __DICT_H
7  #define DICT_OK 0
8  #define DICT_ERR 1
9  #define DICT_NOTUSED(V) ((void) V)
10  typedef struct dictEntry {
11      void *key;
12      union {
13          void *val;
14          uint64_t u64;
15          int64_t s64;
16          double d;
17      } v;
18      struct dictEntry *next;
19  } dictEntry;
20  typedef struct dictType {
<span onclick='openModal()' class='match'>21      uint64_t (*hashFunction)(const void *key);
22      void *(*keyDup)(void *privdata, const void *key);
23      void *(*valDup)(void *privdata, const void *obj);
</span>24      int (*keyCompare)(void *privdata, const void *key1, const void *key2);
25      void (*keyDestructor)(void *privdata, void *key);
26      void (*valDestructor)(void *privdata, void *obj);
27  } dictType;
28  typedef struct dictht {
29      dictEntry **table;
30      PORT_ULONG size;
31      PORT_ULONG sizemask;
32      PORT_ULONG used;
33  } dictht;
34  typedef struct dict {
35      dictType *type;
36      void *privdata;
37      dictht ht[2];
38      PORT_LONG rehashidx; &bsol;* rehashing not in progress if rehashidx == -1 */
39      PORT_ULONG iterators; &bsol;* number of iterators currently running */
40  } dict;
41  typedef struct dictIterator {
42      dict *d;
43      PORT_LONG index;
44      int table, safe;
45      dictEntry *entry, *nextEntry;
46      PORT_LONGLONG fingerprint;
47  } dictIterator;
48  typedef void (dictScanFunction)(void *privdata, const dictEntry *de);
49  typedef void (dictScanBucketFunction)(void *privdata, dictEntry **bucketref);
50  #define DICT_HT_INITIAL_SIZE     4
51  #define dictFreeVal(d, entry) \
52      if ((d)->type->valDestructor) \
53          (d)->type->valDestructor((d)->privdata, (entry)->v.val)
54  #define dictSetVal(d, entry, _val_) do { \
55      if ((d)->type->valDup) \
56          (entry)->v.val = (d)->type->valDup((d)->privdata, _val_); \
57      else \
58          (entry)->v.val = (_val_); \
59  } while(0)
60  #define dictSetSignedIntegerVal(entry, _val_) \
61      do { (entry)->v.s64 = _val_; } while(0)
62  #define dictSetUnsignedIntegerVal(entry, _val_) \
63      do { (entry)->v.u64 = _val_; } while(0)
64  #define dictSetDoubleVal(entry, _val_) \
65      do { (entry)->v.d = _val_; } while(0)
66  #define dictFreeKey(d, entry) \
67      if ((d)->type->keyDestructor) \
68          (d)->type->keyDestructor((d)->privdata, (entry)->key)
69  #define dictSetKey(d, entry, _key_) do { \
70      if ((d)->type->keyDup) \
71          (entry)->key = (d)->type->keyDup((d)->privdata, _key_); \
72      else \
73          (entry)->key = (_key_); \
74  } while(0)
75  #define dictCompareKeys(d, key1, key2) \
76      (((d)->type->keyCompare) ? \
77          (d)->type->keyCompare((d)->privdata, key1, key2) : \
78          (key1) == (key2))
79  #define dictHashKey(d, key) (d)->type->hashFunction(key)
80  #define dictGetKey(he) ((he)->key)
81  #define dictGetVal(he) ((he)->v.val)
82  #define dictGetSignedIntegerVal(he) ((he)->v.s64)
83  #define dictGetUnsignedIntegerVal(he) ((he)->v.u64)
84  #define dictGetDoubleVal(he) ((he)->v.d)
85  #define dictSlots(d) ((d)->ht[0].size+(d)->ht[1].size)
86  #define dictSize(d) ((d)->ht[0].used+(d)->ht[1].used)
87  #define dictIsRehashing(d) ((d)->rehashidx != -1)
88  dict *dictCreate(dictType *type, void *privDataPtr);
89  int dictExpand(dict *d, PORT_ULONG size);
90  int dictAdd(dict *d, void *key, void *val);
91  dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing);
92  dictEntry *dictAddOrFind(dict *d, void *key);
93  int dictReplace(dict *d, void *key, void *val);
94  int dictDelete(dict *d, const void *key);
95  dictEntry *dictUnlink(dict *ht, const void *key);
96  void dictFreeUnlinkedEntry(dict *d, dictEntry *he);
97  void dictRelease(dict *d);
98  dictEntry * dictFind(dict *d, const void *key);
99  void *dictFetchValue(dict *d, const void *key);
100  int dictResize(dict *d);
101  dictIterator *dictGetIterator(dict *d);
102  dictIterator *dictGetSafeIterator(dict *d);
103  dictEntry *dictNext(dictIterator *iter);
104  void dictReleaseIterator(dictIterator *iter);
105  dictEntry *dictGetRandomKey(dict *d);
106  unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);
107  void dictGetStats(char *buf, size_t bufsize, dict *d);
108  uint64_t dictGenHashFunction(const void *key, int len);
109  uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len);
110  void dictEmpty(dict *d, void(callback)(void*));
111  void dictEnableResize(void);
112  void dictDisableResize(void);
113  int dictRehash(dict *d, int n);
114  int dictRehashMilliseconds(dict *d, int ms);
115  void dictSetHashFunctionSeed(uint8_t *seed);
116  uint8_t *dictGetHashFunctionSeed(void);
117  PORT_ULONG dictScan(dict *d, PORT_ULONG v, dictScanFunction *fn, dictScanBucketFunction *bucketfn, void *privdata);
118  uint64_t dictGetHash(dict *d, const void *key);
119  dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t hash);
120  extern dictType dictTypeHeapStringCopyKey;
121  extern dictType dictTypeHeapStrings;
122  extern dictType dictTypeHeapStringCopyKeyValue;
123  #endif &bsol;* __DICT_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-cuse.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 31
2  #include <cuse_lowlevel.h>
3  #include <fuse_opt.h>
4  #include <stddef.h>
5  #include <stdio.h>
6  #include <stdlib.h>
7  #include <string.h>
8  #include <unistd.h>
9  #include <errno.h>
10  #include "ioctl.h"
11  static void *cusexmp_buf;
12  static size_t cusexmp_size;
13  static const char *usage =
14  "usage: cusexmp [options]\n"
15  "\n"
16  "options:\n"
17  "    --help|-h             print this help message\n"
18  "    --maj=MAJ|-M MAJ      device major number\n"
19  "    --min=MIN|-m MIN      device minor number\n"
20  "    --name=NAME|-n NAME   device name (mandatory)\n"
21  "    -d   -o debug         enable debug output (implies -f)\n"
22  "    -f                    foreground operation\n"
23  "    -s                    disable multi-threaded operation\n"
24  "\n";
25  static int cusexmp_resize(size_t new_size)
26  {
27  	void *new_buf;
28  	if (new_size == cusexmp_size)
29  		return 0;
30  	new_buf = realloc(cusexmp_buf, new_size);
31  	if (!new_buf && new_size)
32  		return -ENOMEM;
33  	if (new_size > cusexmp_size)
34  		memset(new_buf + cusexmp_size, 0, new_size - cusexmp_size);
35  	cusexmp_buf = new_buf;
36  	cusexmp_size = new_size;
37  	return 0;
38  }
39  static int cusexmp_expand(size_t new_size)
40  {
41  	if (new_size > cusexmp_size)
42  		return cusexmp_resize(new_size);
43  	return 0;
44  }
45  static void cusexmp_open(fuse_req_t req, struct fuse_file_info *fi)
46  {
47  	fuse_reply_open(req, fi);
48  }
49  static void cusexmp_read(fuse_req_t req, size_t size, off_t off,
50  			 struct fuse_file_info *fi)
51  {
52  	(void)fi;
53  	if (off >= cusexmp_size)
54  		off = cusexmp_size;
55  	if (size > cusexmp_size - off)
56  		size = cusexmp_size - off;
57  	fuse_reply_buf(req, cusexmp_buf + off, size);
58  }
59  static void cusexmp_write(fuse_req_t req, const char *buf, size_t size,
60  			  off_t off, struct fuse_file_info *fi)
61  {
62  	(void)fi;
63  	if (cusexmp_expand(off + size)) {
64  		fuse_reply_err(req, ENOMEM);
65  		return;
66  	}
67  	memcpy(cusexmp_buf + off, buf, size);
68  	fuse_reply_write(req, size);
69  }
70  static void fioc_do_rw(fuse_req_t req, void *addr, const void *in_buf,
71  		       size_t in_bufsz, size_t out_bufsz, int is_read)
72  {
73  	const struct fioc_rw_arg *arg;
74  	struct iovec in_iov[2], out_iov[3], iov[3];
75  	size_t cur_size;
76  	in_iov[0].iov_base = addr;
77  	in_iov[0].iov_len = sizeof(*arg);
78  	if (!in_bufsz) {
79  		fuse_reply_ioctl_retry(req, in_iov, 1, NULL, 0);
80  		return;
81  	}
82  	arg = in_buf;
83  	in_buf += sizeof(*arg);
84  	in_bufsz -= sizeof(*arg);
85  	out_iov[0].iov_base =
86  		addr + offsetof(struct fioc_rw_arg, prev_size);
87  	out_iov[0].iov_len = sizeof(arg->prev_size);
88  	out_iov[1].iov_base =
89  		addr + offsetof(struct fioc_rw_arg, new_size);
90  	out_iov[1].iov_len = sizeof(arg->new_size);
91  	if (is_read) {
92  		out_iov[2].iov_base = arg->buf;
93  		out_iov[2].iov_len = arg->size;
94  		if (!out_bufsz) {
95  			fuse_reply_ioctl_retry(req, in_iov, 1, out_iov, 3);
96  			return;
97  		}
98  	} else {
99  		in_iov[1].iov_base = arg->buf;
100  		in_iov[1].iov_len = arg->size;
101  		if (arg->size && !in_bufsz) {
102  			fuse_reply_ioctl_retry(req, in_iov, 2, out_iov, 2);
103  			return;
104  		}
105  	}
106  	cur_size = cusexmp_size;
107  	iov[0].iov_base = &cur_size;
108  	iov[0].iov_len = sizeof(cur_size);
109  	iov[1].iov_base = &cusexmp_size;
110  	iov[1].iov_len = sizeof(cusexmp_size);
111  	if (is_read) {
112  		size_t off = arg->offset;
113  		size_t size = arg->size;
114  		if (off >= cusexmp_size)
115  			off = cusexmp_size;
116  		if (size > cusexmp_size - off)
117  			size = cusexmp_size - off;
118  		iov[2].iov_base = cusexmp_buf + off;
119  		iov[2].iov_len = size;
120  		fuse_reply_ioctl_iov(req, size, iov, 3);
121  	} else {
122  		if (cusexmp_expand(arg->offset + in_bufsz)) {
123  			fuse_reply_err(req, ENOMEM);
124  			return;
125  		}
126  		memcpy(cusexmp_buf + arg->offset, in_buf, in_bufsz);
127  		fuse_reply_ioctl_iov(req, in_bufsz, iov, 2);
128  	}
129  }
<span onclick='openModal()' class='match'>130  static void cusexmp_ioctl(fuse_req_t req, int cmd, void *arg,
131  			  struct fuse_file_info *fi, unsigned flags,
132  			  const void *in_buf, size_t in_bufsz, size_t out_bufsz)
133  {
134  	int is_read = 0;
</span>135  	(void)fi;
136  	if (flags & FUSE_IOCTL_COMPAT) {
137  		fuse_reply_err(req, ENOSYS);
138  		return;
139  	}
140  	switch (cmd) {
141  	case FIOC_GET_SIZE:
142  		if (!out_bufsz) {
143  			struct iovec iov = { arg, sizeof(size_t) };
144  			fuse_reply_ioctl_retry(req, NULL, 0, &iov, 1);
145  		} else
146  			fuse_reply_ioctl(req, 0, &cusexmp_size,
147  					 sizeof(cusexmp_size));
148  		break;
149  	case FIOC_SET_SIZE:
150  		if (!in_bufsz) {
151  			struct iovec iov = { arg, sizeof(size_t) };
152  			fuse_reply_ioctl_retry(req, &iov, 1, NULL, 0);
153  		} else {
154  			cusexmp_resize(*(size_t *)in_buf);
155  			fuse_reply_ioctl(req, 0, NULL, 0);
156  		}
157  		break;
158  	case FIOC_READ:
159  		is_read = 1;
160  	case FIOC_WRITE:
161  		fioc_do_rw(req, arg, in_buf, in_bufsz, out_bufsz, is_read);
162  		break;
163  	default:
164  		fuse_reply_err(req, EINVAL);
165  	}
166  }
167  struct cusexmp_param {
168  	unsigned		major;
169  	unsigned		minor;
170  	char			*dev_name;
171  	int			is_help;
172  };
173  #define CUSEXMP_OPT(t, p) { t, offsetof(struct cusexmp_param, p), 1 }
174  static const struct fuse_opt cusexmp_opts[] = {
175  	CUSEXMP_OPT("-M %u",		major),
176  	CUSEXMP_OPT("--maj=%u",		major),
177  	CUSEXMP_OPT("-m %u",		minor),
178  	CUSEXMP_OPT("--min=%u",		minor),
179  	CUSEXMP_OPT("-n %s",		dev_name),
180  	CUSEXMP_OPT("--name=%s",	dev_name),
181  	FUSE_OPT_KEY("-h",		0),
182  	FUSE_OPT_KEY("--help",		0),
183  	FUSE_OPT_END
184  };
185  static int cusexmp_process_arg(void *data, const char *arg, int key,
186  			       struct fuse_args *outargs)
187  {
188  	struct cusexmp_param *param = data;
189  	(void)outargs;
190  	(void)arg;
191  	switch (key) {
192  	case 0:
193  		param->is_help = 1;
194  		fprintf(stderr, "%s", usage);
195  		return fuse_opt_add_arg(outargs, "-ho");
196  	default:
197  		return 1;
198  	}
199  }
200  static const struct cuse_lowlevel_ops cusexmp_clop = {
201  	.open		= cusexmp_open,
202  	.read		= cusexmp_read,
203  	.write		= cusexmp_write,
204  	.ioctl		= cusexmp_ioctl,
205  };
206  int main(int argc, char **argv)
207  {
208  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
209  	struct cusexmp_param param = { 0, 0, NULL, 0 };
210  	char dev_name[128] = "DEVNAME=";
211  	const char *dev_info_argv[] = { dev_name };
212  	struct cuse_info ci;
213  	int ret = 1;
214  	if (fuse_opt_parse(&args, &param, cusexmp_opts, cusexmp_process_arg)) {
215  		printf("failed to parse option\n");
216  		free(param.dev_name);
217  		goto out;
218  	}
219  	if (!param.is_help) {
220  		if (!param.dev_name) {
221  			fprintf(stderr, "Error: device name missing\n");
222  			goto out;
223  		}
224  		strncat(dev_name, param.dev_name, sizeof(dev_name) - sizeof("DEVNAME="));
225  		free(param.dev_name);
226  	}
227  	memset(&ci, 0, sizeof(ci));
228  	ci.dev_major = param.major;
229  	ci.dev_minor = param.minor;
230  	ci.dev_info_argc = 1;
231  	ci.dev_info_argv = dev_info_argv;
232  	ci.flags = CUSE_UNRESTRICTED_IOCTL;
233  	ret = cuse_lowlevel_main(args.argc, args.argv, &ci, &cusexmp_clop, NULL);
234  out:
235  	fuse_opt_free_args(&args);
236  	return ret;
237  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-dict_34.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-cuse.c</div>
                </div>
                <div class="column column_space"><pre><code>21      uint64_t (*hashFunction)(const void *key);
22      void *(*keyDup)(void *privdata, const void *key);
23      void *(*valDup)(void *privdata, const void *obj);
</pre></code></div>
                <div class="column column_space"><pre><code>130  static void cusexmp_ioctl(fuse_req_t req, int cmd, void *arg,
131  			  struct fuse_file_info *fi, unsigned flags,
132  			  const void *in_buf, size_t in_bufsz, size_t out_bufsz)
133  {
134  	int is_read = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    