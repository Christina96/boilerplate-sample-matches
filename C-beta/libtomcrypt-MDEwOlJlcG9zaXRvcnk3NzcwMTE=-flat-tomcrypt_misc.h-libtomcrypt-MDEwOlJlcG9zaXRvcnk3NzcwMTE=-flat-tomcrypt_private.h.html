
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 59.62264150943396%, Tokens: 36, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</h3>
            <pre><code>1  #ifdef LTC_BASE64
<span onclick='openModal()' class='match'>2  int base64_encode(const unsigned char *in,  unsigned long inlen,
3                                   char *out, unsigned long *outlen);
4  int base64_decode(const char *in,  unsigned long inlen,
5                          unsigned char *out, unsigned long *outlen);
6  int base64_strict_decode(const char *in,  unsigned long inlen,
7                          unsigned char *out, unsigned long *outlen);
8  int base64_sane_decode(const char *in,  unsigned long inlen,
9                          unsigned char *out, unsigned long *outlen);
10  #endif
11  #ifdef LTC_BASE64_URL
12  int base64url_encode(const unsigned char *in,  unsigned long inlen,
13                                      char *out, unsigned long *outlen);
14  int base64url_strict_encode(const unsigned char *in,  unsigned long inlen,
15                                             char *out, unsigned long *outlen);
16  int base64url_decode(const char *in,  unsigned long inlen,
17                          unsigned char *out, unsigned long *outlen);
18  int base64url_strict_decode(const char *in,  unsigned long inlen,
19                          unsigned char *out, unsigned long *outlen);
20  int base64url_sane_decode(const char *in,  unsigned long inlen,
21                          unsigned char *out, unsigned long *outlen);
</span>22  #endif
23  #ifdef LTC_BASE32
24  typedef enum {
25     BASE32_RFC4648   = 0,
26     BASE32_BASE32HEX = 1,
27     BASE32_ZBASE32   = 2,
28     BASE32_CROCKFORD = 3
29  } base32_alphabet;
30  int base32_encode(const unsigned char *in,  unsigned long inlen,
31                                   char *out, unsigned long *outlen,
32                          base32_alphabet id);
33  int base32_decode(const          char *in,  unsigned long inlen,
34                          unsigned char *out, unsigned long *outlen,
35                          base32_alphabet id);
36  #endif
37  #ifdef LTC_BASE16
38  int base16_encode(const unsigned char *in,  unsigned long  inlen,
39                                   char *out, unsigned long *outlen,
40                          unsigned int   options);
41  int base16_decode(const          char *in,  unsigned long  inlen,
42                          unsigned char *out, unsigned long *outlen);
43  #endif
44  #ifdef LTC_BCRYPT
45  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
46                           const unsigned char *salt,   unsigned long salt_len,
47                                 unsigned int  rounds,            int hash_idx,
48                                 unsigned char *out,    unsigned long *outlen);
49  #endif
50  #ifdef LTC_HKDF
51  int hkdf_test(void);
52  int hkdf_extract(int hash_idx,
53                   const unsigned char *salt, unsigned long saltlen,
54                   const unsigned char *in,   unsigned long inlen,
55                         unsigned char *out,  unsigned long *outlen);
56  int hkdf_expand(int hash_idx,
57                  const unsigned char *info, unsigned long infolen,
58                  const unsigned char *in,   unsigned long inlen,
59                        unsigned char *out,  unsigned long outlen);
60  int hkdf(int hash_idx,
61           const unsigned char *salt, unsigned long saltlen,
62           const unsigned char *info, unsigned long infolen,
63           const unsigned char *in,   unsigned long inlen,
64                 unsigned char *out,  unsigned long outlen);
65  #endif  &bsol;* LTC_HKDF */
66  int mem_neq(const void *a, const void *b, size_t len);
67  void zeromem(volatile void *out, size_t outlen);
68  void burn_stack(unsigned long len);
69  const char *error_to_string(int err);
70  extern const char *crypt_build_settings;
71  int crypt_fsa(void *mp, ...) LTC_NULL_TERMINATED;
72  int crypt_get_constant(const char* namein, int *valueout);
73  int crypt_list_all_constants(char *names_list, unsigned int *names_list_size);
74  int crypt_get_size(const char* namein, unsigned int *sizeout);
75  int crypt_list_all_sizes(char *names_list, unsigned int *names_list_size);
76  #ifdef LTM_DESC
77  LTC_DEPRECATED(crypt_mp_init) void init_LTM(void);
78  #endif
79  #ifdef TFM_DESC
80  LTC_DEPRECATED(crypt_mp_init) void init_TFM(void);
81  #endif
82  #ifdef GMP_DESC
83  LTC_DEPRECATED(crypt_mp_init) void init_GMP(void);
84  #endif
85  int crypt_mp_init(const char* mpi);
86  #ifdef LTC_ADLER32
87  typedef struct adler32_state_s
88  {
89     unsigned short s[2];
90  } adler32_state;
91  void adler32_init(adler32_state *ctx);
92  void adler32_update(adler32_state *ctx, const unsigned char *input, unsigned long length);
93  void adler32_finish(const adler32_state *ctx, void *hash, unsigned long size);
94  int adler32_test(void);
95  #endif
96  #ifdef LTC_CRC32
97  typedef struct crc32_state_s
98  {
99     ulong32 crc;
100  } crc32_state;
101  void crc32_init(crc32_state *ctx);
102  void crc32_update(crc32_state *ctx, const unsigned char *input, unsigned long length);
103  void crc32_finish(const crc32_state *ctx, void *hash, unsigned long size);
104  int crc32_test(void);
105  #endif
106  #ifdef LTC_PADDING
107  enum padding_type {
108     LTC_PAD_PKCS7        = 0x0000U,
109  #ifdef LTC_RNG_GET_BYTES
110     LTC_PAD_ISO_10126    = 0x1000U,
111  #endif
112     LTC_PAD_ANSI_X923    = 0x2000U,
113     LTC_PAD_SSH          = 0x3000U,
114     LTC_PAD_ONE_AND_ZERO = 0x8000U,
115     LTC_PAD_ZERO         = 0x9000U,
116     LTC_PAD_ZERO_ALWAYS  = 0xA000U,
117  };
118  int padding_pad(unsigned char *data, unsigned long length, unsigned long* padded_length, unsigned long mode);
119  int padding_depad(const unsigned char *data, unsigned long *length, unsigned long mode);
120  #endif  &bsol;* LTC_PADDING */
121  #ifdef LTC_SSH
122  typedef enum ssh_data_type_ {
123     LTC_SSHDATA_EOL,
124     LTC_SSHDATA_BYTE,
125     LTC_SSHDATA_BOOLEAN,
126     LTC_SSHDATA_UINT32,
127     LTC_SSHDATA_UINT64,
128     LTC_SSHDATA_STRING,
129     LTC_SSHDATA_MPINT,
130     LTC_SSHDATA_NAMELIST,
131  } ssh_data_type;
132  int ssh_encode_sequence_multi(unsigned char *out, unsigned long *outlen, ...) LTC_NULL_TERMINATED;
133  int ssh_decode_sequence_multi(const unsigned char *in, unsigned long *inlen, ...) LTC_NULL_TERMINATED;
134  #endif &bsol;* LTC_SSH */
135  int compare_testvector(const void* is, const unsigned long is_len, const void* should, const unsigned long should_len, const char* what, int which);
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_private.h</h3>
            <pre><code>1  #include "tomcrypt.h"
2  #define LTC_PAD_MASK       (0xF000U)
3  #ifndef LTC_NULL
4     #define LTC_NULL ((void *)0)
5  #endif
6  enum ltc_oid_id {
7     LTC_OID_RSA,
8     LTC_OID_DSA,
9     LTC_OID_EC,
10     LTC_OID_EC_PRIMEF,
11     LTC_OID_X25519,
12     LTC_OID_ED25519,
13  };
14  typedef struct {
15    int size;
16    const char *name, *base, *prime;
17  } ltc_dh_set_type;
18  typedef int (*fn_kdf_t)(const unsigned char *password, unsigned long password_len,
19                                const unsigned char *salt,     unsigned long salt_len,
20                                int iteration_count,  int hash_idx,
21                                unsigned char *out,   unsigned long *outlen);
22  typedef struct {
23     fn_kdf_t kdf;
24     const char* h;
25     const char* c;
26     unsigned long keylen;
27     unsigned long blocklen;
28  } pbes_properties;
29  typedef struct
30  {
31     pbes_properties type;
32     const void *pwd;
33     unsigned long pwdlen;
34     ltc_asn1_list *enc_data;
35     ltc_asn1_list *salt;
36     ltc_asn1_list *iv;
37     unsigned long iterations;
38     unsigned long key_bits;
39  } pbes_arg;
40  void blowfish_enc(ulong32 *data, unsigned long blocks, const symmetric_key *skey);
41  int blowfish_expand(const unsigned char *key, int keylen,
42                      const unsigned char *data, int datalen,
43                      symmetric_key *skey);
44  int blowfish_setup_with_data(const unsigned char *key, int keylen,
45                               const unsigned char *data, int datalen,
46                               symmetric_key *skey);
47  #define HASH_PROCESS(func_name, compress_name, state_var, block_size)                       \
48  int func_name (hash_state * md, const unsigned char *in, unsigned long inlen)               \
49  {                                                                                           \
50      unsigned long n;                                                                        \
51      int           err;                                                                      \
52      LTC_ARGCHK(md != NULL);                                                                 \
53      LTC_ARGCHK(in != NULL);                                                                 \
54      if (md-> state_var .curlen > sizeof(md-> state_var .buf)) {                             \
55         return CRYPT_INVALID_ARG;                                                            \
56      }                                                                                       \
57      if (((md-> state_var .length + inlen * 8) < md-> state_var .length)                     \
58            || ((inlen * 8) < inlen)) {                                                       \
59        return CRYPT_HASH_OVERFLOW;                                                           \
60      }                                                                                       \
61      while (inlen > 0) {                                                                     \
62          if (md-> state_var .curlen == 0 && inlen >= block_size) {                           \
63             if ((err = compress_name (md, in)) != CRYPT_OK) {                                \
64                return err;                                                                   \
65             }                                                                                \
66             md-> state_var .length += block_size * 8;                                        \
67             in             += block_size;                                                    \
68             inlen          -= block_size;                                                    \
69          } else {                                                                            \
70             n = MIN(inlen, (block_size - md-> state_var .curlen));                           \
71             XMEMCPY(md-> state_var .buf + md-> state_var.curlen, in, (size_t)n);             \
72             md-> state_var .curlen += n;                                                     \
73             in             += n;                                                             \
74             inlen          -= n;                                                             \
75             if (md-> state_var .curlen == block_size) {                                      \
76                if ((err = compress_name (md, md-> state_var .buf)) != CRYPT_OK) {            \
77                   return err;                                                                \
78                }                                                                             \
79                md-> state_var .length += 8*block_size;                                       \
80                md-> state_var .curlen = 0;                                                   \
81             }                                                                                \
82         }                                                                                    \
83      }                                                                                       \
84      return CRYPT_OK;                                                                        \
85  }
86  int ocb3_int_ntz(unsigned long x);
87  void ocb3_int_xor_blocks(unsigned char *out, const unsigned char *block_a, const unsigned char *block_b, unsigned long block_len);
88  #if !defined(DESC_DEF_ONLY)
89  #define MP_DIGIT_BIT                 ltc_mp.bits_per_digit
90  #define mp_init(a)                   ltc_mp.init(a)
91  #define mp_init_multi                ltc_init_multi
92  #define mp_clear(a)                  ltc_mp.deinit(a)
93  #define mp_clear_multi               ltc_deinit_multi
94  #define mp_cleanup_multi             ltc_cleanup_multi
95  #define mp_init_copy(a, b)           ltc_mp.init_copy(a, b)
96  #define mp_neg(a, b)                 ltc_mp.neg(a, b)
97  #define mp_copy(a, b)                ltc_mp.copy(a, b)
98  #define mp_set(a, b)                 ltc_mp.set_int(a, b)
99  #define mp_set_int(a, b)             ltc_mp.set_int(a, b)
100  #define mp_get_int(a)                ltc_mp.get_int(a)
101  #define mp_get_digit(a, n)           ltc_mp.get_digit(a, n)
102  #define mp_get_digit_count(a)        ltc_mp.get_digit_count(a)
103  #define mp_cmp(a, b)                 ltc_mp.compare(a, b)
104  #define mp_cmp_d(a, b)               ltc_mp.compare_d(a, b)
105  #define mp_count_bits(a)             ltc_mp.count_bits(a)
106  #define mp_cnt_lsb(a)                ltc_mp.count_lsb_bits(a)
107  #define mp_2expt(a, b)               ltc_mp.twoexpt(a, b)
108  #define mp_read_radix(a, b, c)       ltc_mp.read_radix(a, b, c)
109  #define mp_toradix(a, b, c)          ltc_mp.write_radix(a, b, c)
110  #define mp_unsigned_bin_size(a)      ltc_mp.unsigned_size(a)
111  #define mp_to_unsigned_bin(a, b)     ltc_mp.unsigned_write(a, b)
112  #define mp_read_unsigned_bin(a, b, c) ltc_mp.unsigned_read(a, b, c)
113  #define mp_add(a, b, c)              ltc_mp.add(a, b, c)
114  #define mp_add_d(a, b, c)            ltc_mp.addi(a, b, c)
115  #define mp_sub(a, b, c)              ltc_mp.sub(a, b, c)
116  #define mp_sub_d(a, b, c)            ltc_mp.subi(a, b, c)
117  #define mp_mul(a, b, c)              ltc_mp.mul(a, b, c)
118  #define mp_mul_d(a, b, c)            ltc_mp.muli(a, b, c)
119  #define mp_sqr(a, b)                 ltc_mp.sqr(a, b)
120  #define mp_sqrtmod_prime(a, b, c)    ltc_mp.sqrtmod_prime(a, b, c)
121  #define mp_div(a, b, c, d)           ltc_mp.mpdiv(a, b, c, d)
122  #define mp_div_2(a, b)               ltc_mp.div_2(a, b)
123  #define mp_mod(a, b, c)              ltc_mp.mpdiv(a, b, NULL, c)
124  #define mp_mod_d(a, b, c)            ltc_mp.modi(a, b, c)
125  #define mp_gcd(a, b, c)              ltc_mp.gcd(a, b, c)
126  #define mp_lcm(a, b, c)              ltc_mp.lcm(a, b, c)
127  #define mp_addmod(a, b, c, d)        ltc_mp.addmod(a, b, c, d)
128  #define mp_submod(a, b, c, d)        ltc_mp.submod(a, b, c, d)
129  #define mp_mulmod(a, b, c, d)        ltc_mp.mulmod(a, b, c, d)
130  #define mp_sqrmod(a, b, c)           ltc_mp.sqrmod(a, b, c)
131  #define mp_invmod(a, b, c)           ltc_mp.invmod(a, b, c)
132  #define mp_montgomery_setup(a, b)    ltc_mp.montgomery_setup(a, b)
133  #define mp_montgomery_normalization(a, b) ltc_mp.montgomery_normalization(a, b)
134  #define mp_montgomery_reduce(a, b, c)   ltc_mp.montgomery_reduce(a, b, c)
135  #define mp_montgomery_free(a)        ltc_mp.montgomery_deinit(a)
136  #define mp_exptmod(a,b,c,d)          ltc_mp.exptmod(a,b,c,d)
137  #define mp_prime_is_prime(a, b, c)   ltc_mp.isprime(a, b, c)
138  #define mp_iszero(a)                 (mp_cmp_d(a, 0) == LTC_MP_EQ ? LTC_MP_YES : LTC_MP_NO)
139  #define mp_isodd(a)                  (mp_get_digit_count(a) > 0 ? (mp_get_digit(a, 0) & 1 ? LTC_MP_YES : LTC_MP_NO) : LTC_MP_NO)
140  #define mp_exch(a, b)                do { void *ABC__tmp = a; a = b; b = ABC__tmp; } while(0)
141  #define mp_tohex(a, b)               mp_toradix(a, b, 16)
142  #define mp_rand(a, b)                ltc_mp.rand(a, b)
143  #endif
144  typedef enum {
145     BASE64_PEM_CRLF = 1,
146     BASE64_PEM_SSH = 2,
147  } base64_pem_flags;
148  int base64_encode_pem(const unsigned char *in,  unsigned long inlen,
149                                       char *out, unsigned long *outlen,
150                              unsigned int  flags);
151  void copy_or_zeromem(const unsigned char* src, unsigned char* dest, unsigned long len, int coz);
152  int pbes_decrypt(const pbes_arg  *arg, unsigned char *dec_data, unsigned long *dec_size);
153  int pbes1_extract(const ltc_asn1_list *s, pbes_arg *res);
154  int pbes2_extract(const ltc_asn1_list *s, pbes_arg *res);
155  int rand_bn_bits(void *N, int bits, prng_state *prng, int wprng);
156  int rand_bn_upto(void *N, void *limit, prng_state *prng, int wprng);
157  int pk_get_oid(enum ltc_oid_id id, const char **st);
158  int pk_oid_str_to_num(const char *OID, unsigned long *oid, unsigned long *oidlen);
159  int pk_oid_num_to_str(const unsigned long *oid, unsigned long oidlen, char *OID, unsigned long *outlen);
160  #ifdef LTC_MRSA
161  int rsa_init(rsa_key *key);
162  void rsa_shrink_key(rsa_key *key);
163  int rsa_make_key_bn_e(prng_state *prng, int wprng, int size, void *e,
164                        rsa_key *key); &bsol;* used by op-tee */
165  int rsa_import_pkcs1(const unsigned char *in, unsigned long inlen, rsa_key *key);
166  #endif &bsol;* LTC_MRSA */
167  #ifdef LTC_MDH
168  extern const ltc_dh_set_type ltc_dh_sets[];
169  int dh_check_pubkey(const dh_key *key);
170  #endif &bsol;* LTC_MDH */
171  #ifdef LTC_MECC
172  int ecc_set_curve_from_mpis(void *a, void *b, void *prime, void *order, void *gx, void *gy, unsigned long cofactor, ecc_key *key);
173  int ecc_copy_curve(const ecc_key *srckey, ecc_key *key);
174  int ecc_set_curve_by_size(int size, ecc_key *key);
175  int ecc_import_subject_public_key_info(const unsigned char *in, unsigned long inlen, ecc_key *key);
176  #ifdef LTC_SSH
177  int ecc_ssh_ecdsa_encode_name(char *buffer, unsigned long *buflen, const ecc_key *key);
178  #endif
179  ecc_point *ltc_ecc_new_point(void);
180  void       ltc_ecc_del_point(ecc_point *p);
181  int        ltc_ecc_set_point_xyz(ltc_mp_digit x, ltc_mp_digit y, ltc_mp_digit z, ecc_point *p);
182  int        ltc_ecc_copy_point(const ecc_point *src, ecc_point *dst);
<span onclick='openModal()' class='match'>183  int        ltc_ecc_is_point(const ltc_ecc_dp *dp, void *x, void *y);
184  int        ltc_ecc_is_point_at_infinity(const ecc_point *P, void *modulus, int *retval);
185  int        ltc_ecc_import_point(const unsigned char *in, unsigned long inlen, void *prime, void *a, void *b, void *x, void *y);
186  int        ltc_ecc_export_point(unsigned char *out, unsigned long *outlen, void *x, void *y, unsigned long size, int compressed);
187  int        ltc_ecc_verify_key(const ecc_key *key);
188  #if !defined(LTC_MECC_ACCEL) || defined(LTM_DESC) || defined(GMP_DESC)
189  int ltc_ecc_projective_dbl_point(const ecc_point *P, ecc_point *R, void *ma, void *modulus, void *mp);
190  int ltc_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *mp);
191  #endif
192  #if defined(LTC_MECC_FP)
193  int ltc_ecc_fp_mulmod(void *k, ecc_point *G, ecc_point *R, void *a, void *modulus, int map);
194  int ltc_ecc_fp_save_state(unsigned char **out, unsigned long *outlen);
</span>195  int ltc_ecc_fp_restore_state(unsigned char *in, unsigned long inlen);
196  void ltc_ecc_fp_free(void);
197  int ltc_ecc_fp_add_point(ecc_point *g, void *modulus, int lock);
198  void ltc_ecc_fp_tablelock(int lock);
199  #endif
200  int ltc_ecc_mulmod(void *k, const ecc_point *G, ecc_point *R, void *a, void *modulus, int map);
201  #ifdef LTC_ECC_SHAMIR
202  int ltc_ecc_mul2add(const ecc_point *A, void *kA,
203                      const ecc_point *B, void *kB,
204                            ecc_point *C,
205                                 void *ma,
206                                 void *modulus);
207  #ifdef LTC_MECC_FP
208  int ltc_ecc_fp_mul2add(const ecc_point *A, void *kA,
209                         const ecc_point *B, void *kB,
210                               ecc_point *C,
211                                    void *ma,
212                                    void *modulus);
213  #endif
214  #endif
215  int ltc_ecc_map(ecc_point *P, void *modulus, void *mp);
216  #endif &bsol;* LTC_MECC */
217  #ifdef LTC_MDSA
218  int dsa_int_validate_xy(const dsa_key *key, int *stat);
219  int dsa_int_validate_pqg(const dsa_key *key, int *stat);
220  int dsa_int_validate_primes(const dsa_key *key, int *stat);
221  #endif &bsol;* LTC_MDSA */
222  #ifdef LTC_CURVE25519
223  int tweetnacl_crypto_sign(
224    unsigned char *sm,unsigned long long *smlen,
225    const unsigned char *m,unsigned long long mlen,
226    const unsigned char *sk,const unsigned char *pk,
227    const unsigned char *ctx,unsigned long long cs);
228  int tweetnacl_crypto_sign_open(
229    int *stat,
230    unsigned char *m,unsigned long long *mlen,
231    const unsigned char *sm,unsigned long long smlen,
232    const unsigned char *ctx, unsigned long long cs,
233    const unsigned char *pk);
234  int tweetnacl_crypto_sign_keypair(prng_state *prng, int wprng, unsigned char *pk,unsigned char *sk);
235  int tweetnacl_crypto_sk_to_pk(unsigned char *pk, const unsigned char *sk);
236  int tweetnacl_crypto_scalarmult(unsigned char *q, const unsigned char *n, const unsigned char *p);
237  int tweetnacl_crypto_scalarmult_base(unsigned char *q,const unsigned char *n);
238  int tweetnacl_crypto_ph(unsigned char *out, const unsigned char *msg, unsigned long long msglen);
239  typedef int (*sk_to_pk)(unsigned char *pk ,const unsigned char *sk);
240  int ec25519_import_pkcs8(const unsigned char *in, unsigned long inlen,
241                         const void *pwd, unsigned long pwdlen,
242                         enum ltc_oid_id id, sk_to_pk fp,
243                         curve25519_key *key);
244  int ec25519_export(       unsigned char *out, unsigned long *outlen,
245                                      int  which,
246                     const curve25519_key *key);
247  int ec25519_crypto_ctx(      unsigned char *out, unsigned long *outlen,
248                               unsigned char flag,
249                         const unsigned char *ctx, unsigned long  ctxlen);
250  #endif &bsol;* LTC_CURVE25519 */
251  #ifdef LTC_DER
252  #define LTC_ASN1_IS_TYPE(e, t) (((e) != NULL) && ((e)->type == (t)))
253  int der_decode_custom_type_ex(const unsigned char *in, unsigned long  inlen,
254                             ltc_asn1_list *root,
255                             ltc_asn1_list *list,     unsigned long  outlen, unsigned int flags);
256  int der_encode_asn1_identifier(const ltc_asn1_list *id, unsigned char *out, unsigned long *outlen);
257  int der_decode_asn1_identifier(const unsigned char *in, unsigned long *inlen, ltc_asn1_list *id);
258  int der_length_asn1_identifier(const ltc_asn1_list *id, unsigned long *idlen);
259  int der_encode_asn1_length(unsigned long len, unsigned char* out, unsigned long* outlen);
260  int der_decode_asn1_length(const unsigned char *in, unsigned long *inlen, unsigned long *outlen);
261  int der_length_asn1_length(unsigned long len, unsigned long *outlen);
262  int der_length_sequence_ex(const ltc_asn1_list *list, unsigned long inlen,
263                             unsigned long *outlen, unsigned long *payloadlen);
264  extern const ltc_asn1_type  der_asn1_tag_to_type_map[];
265  extern const unsigned long  der_asn1_tag_to_type_map_sz;
266  extern const int der_asn1_type_to_identifier_map[];
267  extern const unsigned long der_asn1_type_to_identifier_map_sz;
268  int der_decode_sequence_multi_ex(const unsigned char *in, unsigned long inlen, unsigned int flags, ...)
269                                   LTC_NULL_TERMINATED;
270  int der_teletex_char_encode(int c);
271  int der_teletex_value_decode(int v);
272  int der_utf8_valid_char(const wchar_t c);
273  typedef int (*public_key_decode_cb)(const unsigned char *in, unsigned long inlen, void *ctx);
274  int x509_decode_public_key_from_certificate(const unsigned char *in, unsigned long inlen,
275                                              enum ltc_oid_id algorithm, ltc_asn1_type param_type,
276                                              ltc_asn1_list* parameters, unsigned long *parameters_len,
277                                              public_key_decode_cb callback, void *ctx);
278  int x509_encode_subject_public_key_info(unsigned char *out, unsigned long *outlen,
279          unsigned int algorithm, const void* public_key, unsigned long public_key_len,
280          ltc_asn1_type parameters_type, ltc_asn1_list* parameters, unsigned long parameters_len);
281  int x509_decode_subject_public_key_info(const unsigned char *in, unsigned long inlen,
282          unsigned int algorithm, void* public_key, unsigned long* public_key_len,
283          ltc_asn1_type parameters_type, ltc_asn1_list* parameters, unsigned long *parameters_len);
284  int pk_oid_cmp_with_ulong(const char *o1, const unsigned long *o2, unsigned long o2size);
285  int pk_oid_cmp_with_asn1(const char *o1, const ltc_asn1_list *o2);
286  #endif &bsol;* LTC_DER */
287  #ifdef LTC_PKCS_8
288  int pkcs8_decode_flexi(const unsigned char  *in,  unsigned long inlen,
289                                      const void  *pwd, unsigned long pwdlen,
290                                   ltc_asn1_list **decoded_list);
291  #endif  &bsol;* LTC_PKCS_8 */
292  #ifdef LTC_PKCS_12
293  int pkcs12_utf8_to_utf16(const unsigned char *in,  unsigned long  inlen,
294                                 unsigned char *out, unsigned long *outlen);
295  int pkcs12_kdf(               int   hash_id,
296                 const unsigned char *pw,         unsigned long pwlen,
297                 const unsigned char *salt,       unsigned long saltlen,
298                       unsigned int   iterations, unsigned char purpose,
299                       unsigned char *out,        unsigned long outlen);
300  #endif  &bsol;* LTC_PKCS_12 */
301  #define LTC_PRNG_EXPORT(which) \
302  int which ## _export(unsigned char *out, unsigned long *outlen, prng_state *prng)      \
303  {                                                                                      \
304     unsigned long len = which ## _desc.export_size;                                     \
305                                                                                         \
306     LTC_ARGCHK(prng   != NULL);                                                         \
307     LTC_ARGCHK(out    != NULL);                                                         \
308     LTC_ARGCHK(outlen != NULL);                                                         \
309                                                                                         \
310     if (*outlen < len) {                                                                \
311        *outlen = len;                                                                   \
312        return CRYPT_BUFFER_OVERFLOW;                                                    \
313     }                                                                                   \
314                                                                                         \
315     if (which ## _read(out, len, prng) != len) {                                        \
316        return CRYPT_ERROR_READPRNG;                                                     \
317     }                                                                                   \
318                                                                                         \
319     *outlen = len;                                                                      \
320     return CRYPT_OK;                                                                    \
321  }
322  #ifdef _MSC_VER
323     #define LTC_BYTE(x, n) ((unsigned char)((x) >> (8 * (n))))
324  #else
325     #define LTC_BYTE(x, n) (((x) >> (8 * (n))) & 255)
326  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_private.h</div>
                </div>
                <div class="column column_space"><pre><code>2  int base64_encode(const unsigned char *in,  unsigned long inlen,
3                                   char *out, unsigned long *outlen);
4  int base64_decode(const char *in,  unsigned long inlen,
5                          unsigned char *out, unsigned long *outlen);
6  int base64_strict_decode(const char *in,  unsigned long inlen,
7                          unsigned char *out, unsigned long *outlen);
8  int base64_sane_decode(const char *in,  unsigned long inlen,
9                          unsigned char *out, unsigned long *outlen);
10  #endif
11  #ifdef LTC_BASE64_URL
12  int base64url_encode(const unsigned char *in,  unsigned long inlen,
13                                      char *out, unsigned long *outlen);
14  int base64url_strict_encode(const unsigned char *in,  unsigned long inlen,
15                                             char *out, unsigned long *outlen);
16  int base64url_decode(const char *in,  unsigned long inlen,
17                          unsigned char *out, unsigned long *outlen);
18  int base64url_strict_decode(const char *in,  unsigned long inlen,
19                          unsigned char *out, unsigned long *outlen);
20  int base64url_sane_decode(const char *in,  unsigned long inlen,
21                          unsigned char *out, unsigned long *outlen);
</pre></code></div>
                <div class="column column_space"><pre><code>183  int        ltc_ecc_is_point(const ltc_ecc_dp *dp, void *x, void *y);
184  int        ltc_ecc_is_point_at_infinity(const ecc_point *P, void *modulus, int *retval);
185  int        ltc_ecc_import_point(const unsigned char *in, unsigned long inlen, void *prime, void *a, void *b, void *x, void *y);
186  int        ltc_ecc_export_point(unsigned char *out, unsigned long *outlen, void *x, void *y, unsigned long size, int compressed);
187  int        ltc_ecc_verify_key(const ecc_key *key);
188  #if !defined(LTC_MECC_ACCEL) || defined(LTM_DESC) || defined(GMP_DESC)
189  int ltc_ecc_projective_dbl_point(const ecc_point *P, ecc_point *R, void *ma, void *modulus, void *mp);
190  int ltc_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *mp);
191  #endif
192  #if defined(LTC_MECC_FP)
193  int ltc_ecc_fp_mulmod(void *k, ecc_point *G, ecc_point *R, void *a, void *modulus, int map);
194  int ltc_ecc_fp_save_state(unsigned char **out, unsigned long *outlen);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    