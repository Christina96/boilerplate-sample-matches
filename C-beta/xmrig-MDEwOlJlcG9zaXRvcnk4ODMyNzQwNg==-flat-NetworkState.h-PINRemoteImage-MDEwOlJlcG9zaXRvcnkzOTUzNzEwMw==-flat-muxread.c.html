
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.013927576601671%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-NetworkState.h</h3>
            <pre><code>1  #ifndef XMRIG_NETWORKSTATE_H
2  #define XMRIG_NETWORKSTATE_H
3  #include "base/crypto/Algorithm.h"
4  #include "base/net/stratum/strategies/StrategyProxy.h"
5  #include "base/tools/String.h"
6  #include <array>
7  #include <string>
8  #include <vector>
9  namespace xmrig {
10  class NetworkState : public StrategyProxy
11  {
12  public:
13      NetworkState(IStrategyListener *listener);
14      inline const Algorithm &algorithm() const   { return m_algorithm; }
15      inline uint64_t accepted() const            { return m_accepted; }
16      inline uint64_t rejected() const            { return m_rejected; }
17  #   ifdef XMRIG_FEATURE_API
18      rapidjson::Value getConnection(rapidjson::Document &doc, int version) const;
19      rapidjson::Value getResults(rapidjson::Document &doc, int version) const;
20  #   endif
21      void printConnection() const;
22      void printResults() const;
23      static const char *scaleDiff(uint64_t &diff);
24      static std::string humanDiff(uint64_t diff);
25  protected:
26      void onActive(IStrategy *strategy, IClient *client) override;
27      void onJob(IStrategy *strategy, IClient *client, const Job &job, const rapidjson::Value &params) override;
28      void onPause(IStrategy *strategy) override;
29      void onResultAccepted(IStrategy *strategy, IClient *client, const SubmitResult &result, const char *error) override;
30  private:
31      uint32_t latency() const;
32      uint64_t avgTime() const;
33      uint64_t connectionTime() const;
34      void add(const SubmitResult &result, const char *error);
35      void stop();
36      Algorithm m_algorithm;
37      bool m_active               = false;
38      char m_pool[256]{};
39      std::array<uint64_t, 10> m_topDiff { { } };
<span onclick='openModal()' class='match'>40      std::vector<uint16_t> m_latency;
41      String m_fingerprint;
42      String m_ip;
43      String m_tls;
44      uint64_t m_accepted         = 0;
45      uint64_t m_connectionTime   = 0;
46      uint64_t m_diff             = 0;
</span>47      uint64_t m_failures         = 0;
48      uint64_t m_hashes           = 0;
49      uint64_t m_rejected         = 0;
50  };
51  } &bsol;* namespace xmrig */
52  #endif &bsol;* XMRIG_NETWORKSTATE_H */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-muxread.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/mux/muxi.h"
3  #include "src/utils/utils.h"
4  #define SWITCH_ID_LIST(INDEX, LIST)                                           \
5    if (idx == (INDEX)) {                                                       \
6      const WebPChunk* const chunk = ChunkSearchList((LIST), nth,               \
7                                                     kChunks[(INDEX)].tag);     \
8      if (chunk) {                                                              \
9        *data = chunk->data_;                                                   \
10        return WEBP_MUX_OK;                                                     \
11      } else {                                                                  \
12        return WEBP_MUX_NOT_FOUND;                                              \
13      }                                                                         \
14    }
15  static WebPMuxError MuxGet(const WebPMux* const mux, CHUNK_INDEX idx,
16                             uint32_t nth, WebPData* const data) {
17    assert(mux != NULL);
18    assert(!IsWPI(kChunks[idx].id));
19    WebPDataInit(data);
20    SWITCH_ID_LIST(IDX_VP8X, mux->vp8x_);
21    SWITCH_ID_LIST(IDX_ICCP, mux->iccp_);
22    SWITCH_ID_LIST(IDX_ANIM, mux->anim_);
23    SWITCH_ID_LIST(IDX_EXIF, mux->exif_);
24    SWITCH_ID_LIST(IDX_XMP, mux->xmp_);
25    assert(idx != IDX_UNKNOWN);
26    return WEBP_MUX_NOT_FOUND;
27  }
28  #undef SWITCH_ID_LIST
29  static WebPMuxError ChunkVerifyAndAssign(WebPChunk* chunk,
30                                           const uint8_t* data, size_t data_size,
31                                           size_t riff_size, int copy_data) {
32    uint32_t chunk_size;
33    WebPData chunk_data;
34    if (data_size < CHUNK_HEADER_SIZE) return WEBP_MUX_NOT_ENOUGH_DATA;
35    chunk_size = GetLE32(data + TAG_SIZE);
36    if (chunk_size > MAX_CHUNK_PAYLOAD) return WEBP_MUX_BAD_DATA;
37    {
38      const size_t chunk_disk_size = SizeWithPadding(chunk_size);
39      if (chunk_disk_size > riff_size) return WEBP_MUX_BAD_DATA;
40      if (chunk_disk_size > data_size) return WEBP_MUX_NOT_ENOUGH_DATA;
41    }
42    chunk_data.bytes = data + CHUNK_HEADER_SIZE;
43    chunk_data.size = chunk_size;
44    return ChunkAssignData(chunk, &chunk_data, copy_data, GetLE32(data + 0));
45  }
46  int MuxImageFinalize(WebPMuxImage* const wpi) {
47    const WebPChunk* const img = wpi->img_;
48    const WebPData* const image = &img->data_;
49    const int is_lossless = (img->tag_ == kChunks[IDX_VP8L].tag);
50    int w, h;
51    int vp8l_has_alpha = 0;
52    const int ok = is_lossless ?
53        VP8LGetInfo(image->bytes, image->size, &w, &h, &vp8l_has_alpha) :
54        VP8GetInfo(image->bytes, image->size, image->size, &w, &h);
55    assert(img != NULL);
56    if (ok) {
57      if (is_lossless && (wpi->alpha_ != NULL)) {
58        ChunkDelete(wpi->alpha_);
59        wpi->alpha_ = NULL;
60      }
61      wpi->width_ = w;
62      wpi->height_ = h;
63      wpi->has_alpha_ = vp8l_has_alpha || (wpi->alpha_ != NULL);
64    }
65    return ok;
66  }
67  static int MuxImageParse(const WebPChunk* const chunk, int copy_data,
68                           WebPMuxImage* const wpi) {
69    const uint8_t* bytes = chunk->data_.bytes;
70    size_t size = chunk->data_.size;
71    const uint8_t* const last = (bytes == NULL) ? NULL : bytes + size;
72    WebPChunk subchunk;
73    size_t subchunk_size;
74    WebPChunk** unknown_chunk_list = &wpi->unknown_;
75    ChunkInit(&subchunk);
76    assert(chunk->tag_ == kChunks[IDX_ANMF].tag);
77    assert(!wpi->is_partial_);
78    {
79      const size_t hdr_size = ANMF_CHUNK_SIZE;
80      const WebPData temp = { bytes, hdr_size };
81      if (size < hdr_size) goto Fail;
82      ChunkAssignData(&subchunk, &temp, copy_data, chunk->tag_);
83    }
84    ChunkSetHead(&subchunk, &wpi->header_);
85    wpi->is_partial_ = 1;  
86    subchunk_size = ChunkDiskSize(&subchunk) - CHUNK_HEADER_SIZE;
87    bytes += subchunk_size;
88    size -= subchunk_size;
89    while (bytes != last) {
90      ChunkInit(&subchunk);
91      if (ChunkVerifyAndAssign(&subchunk, bytes, size, size,
92                               copy_data) != WEBP_MUX_OK) {
93        goto Fail;
94      }
95      switch (ChunkGetIdFromTag(subchunk.tag_)) {
96        case WEBP_CHUNK_ALPHA:
97          if (wpi->alpha_ != NULL) goto Fail;  
98          if (ChunkSetHead(&subchunk, &wpi->alpha_) != WEBP_MUX_OK) goto Fail;
99          wpi->is_partial_ = 1;  
100          break;
101        case WEBP_CHUNK_IMAGE:
102          if (wpi->img_ != NULL) goto Fail;  
103          if (ChunkSetHead(&subchunk, &wpi->img_) != WEBP_MUX_OK) goto Fail;
104          if (!MuxImageFinalize(wpi)) goto Fail;
105          wpi->is_partial_ = 0;  
106          break;
107        case WEBP_CHUNK_UNKNOWN:
108          if (wpi->is_partial_) {
109            goto Fail;  
110          }
111          if (ChunkAppend(&subchunk, &unknown_chunk_list) != WEBP_MUX_OK) {
112            goto Fail;
113          }
114          break;
115        default:
116          goto Fail;
117          break;
118      }
119      subchunk_size = ChunkDiskSize(&subchunk);
120      bytes += subchunk_size;
121      size -= subchunk_size;
122    }
123    if (wpi->is_partial_) goto Fail;
124    return 1;
125   Fail:
126    ChunkRelease(&subchunk);
127    return 0;
128  }
<span onclick='openModal()' class='match'>129  WebPMux* WebPMuxCreateInternal(const WebPData* bitstream, int copy_data,
130                                 int version) {
131    size_t riff_size;
132    uint32_t tag;
133    const uint8_t* end;
134    WebPMux* mux = NULL;
135    WebPMuxImage* wpi = NULL;
136    const uint8_t* data;
</span>137    size_t size;
138    WebPChunk chunk;
139    WebPChunk** chunk_list_ends[WEBP_CHUNK_NIL + 1] = { NULL };
140    ChunkInit(&chunk);
141    if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_MUX_ABI_VERSION)) {
142      return NULL;  
143    }
144    if (bitstream == NULL) return NULL;
145    data = bitstream->bytes;
146    size = bitstream->size;
147    if (data == NULL) return NULL;
148    if (size < RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE) return NULL;
149    if (GetLE32(data + 0) != MKFOURCC('R', 'I', 'F', 'F') ||
150        GetLE32(data + CHUNK_HEADER_SIZE) != MKFOURCC('W', 'E', 'B', 'P')) {
151      return NULL;
152    }
153    mux = WebPMuxNew();
154    if (mux == NULL) return NULL;
155    tag = GetLE32(data + RIFF_HEADER_SIZE);
156    if (tag != kChunks[IDX_VP8].tag &&
157        tag != kChunks[IDX_VP8L].tag &&
158        tag != kChunks[IDX_VP8X].tag) {
159      goto Err;  
160    }
161    riff_size = GetLE32(data + TAG_SIZE);
162    if (riff_size > MAX_CHUNK_PAYLOAD) goto Err;
163    riff_size = SizeWithPadding(riff_size);
164    if (riff_size < CHUNK_HEADER_SIZE) goto Err;
165    if (riff_size > size) goto Err;
166    if (size > riff_size + CHUNK_HEADER_SIZE) {
167      size = riff_size + CHUNK_HEADER_SIZE;
168    }
169    end = data + size;
170    data += RIFF_HEADER_SIZE;
171    size -= RIFF_HEADER_SIZE;
172    wpi = (WebPMuxImage*)WebPSafeMalloc(1ULL, sizeof(*wpi));
173    if (wpi == NULL) goto Err;
174    MuxImageInit(wpi);
175    while (data != end) {
176      size_t data_size;
177      WebPChunkId id;
178      if (ChunkVerifyAndAssign(&chunk, data, size, riff_size,
179                               copy_data) != WEBP_MUX_OK) {
180        goto Err;
181      }
182      data_size = ChunkDiskSize(&chunk);
183      id = ChunkGetIdFromTag(chunk.tag_);
184      switch (id) {
185        case WEBP_CHUNK_ALPHA:
186          if (wpi->alpha_ != NULL) goto Err;  
187          if (ChunkSetHead(&chunk, &wpi->alpha_) != WEBP_MUX_OK) goto Err;
188          wpi->is_partial_ = 1;  
189          break;
190        case WEBP_CHUNK_IMAGE:
191          if (ChunkSetHead(&chunk, &wpi->img_) != WEBP_MUX_OK) goto Err;
192          if (!MuxImageFinalize(wpi)) goto Err;
193          wpi->is_partial_ = 0;  
194   PushImage:
195          if (MuxImagePush(wpi, &mux->images_) != WEBP_MUX_OK) goto Err;
196          MuxImageInit(wpi);  
197          break;
198        case WEBP_CHUNK_ANMF:
199          if (wpi->is_partial_) goto Err;  
200          if (!MuxImageParse(&chunk, copy_data, wpi)) goto Err;
201          ChunkRelease(&chunk);
202          goto PushImage;
203          break;
204        default:  
205          if (wpi->is_partial_) goto Err;  
206          if (chunk_list_ends[id] == NULL) {
207            chunk_list_ends[id] =
208                MuxGetChunkListFromId(mux, id);  
209          }
210          if (ChunkAppend(&chunk, &chunk_list_ends[id]) != WEBP_MUX_OK) goto Err;
211          if (id == WEBP_CHUNK_VP8X) {  
212            if (data_size < CHUNK_HEADER_SIZE + VP8X_CHUNK_SIZE) goto Err;
213            mux->canvas_width_ = GetLE24(data + 12) + 1;
214            mux->canvas_height_ = GetLE24(data + 15) + 1;
215          }
216          break;
217      }
218      data += data_size;
219      size -= data_size;
220      ChunkInit(&chunk);
221    }
222    if (wpi->is_partial_) goto Err;
223    if (MuxValidate(mux) != WEBP_MUX_OK) goto Err;
224    MuxImageDelete(wpi);
225    return mux;  
226   Err:  
227    ChunkRelease(&chunk);
228    MuxImageDelete(wpi);
229    WebPMuxDelete(mux);
230    return NULL;
231  }
232  static WebPMuxError ValidateForSingleImage(const WebPMux* const mux) {
233    const int num_images = MuxImageCount(mux->images_, WEBP_CHUNK_IMAGE);
234    const int num_frames = MuxImageCount(mux->images_, WEBP_CHUNK_ANMF);
235    if (num_images == 0) {
236      return WEBP_MUX_NOT_FOUND;
237    } else if (num_images == 1 && num_frames == 0) {
238      return WEBP_MUX_OK;
239    } else {
240      return WEBP_MUX_INVALID_ARGUMENT;
241    }
242  }
243  static WebPMuxError MuxGetCanvasInfo(const WebPMux* const mux,
244                                       int* width, int* height, uint32_t* flags) {
245    int w, h;
246    uint32_t f = 0;
247    WebPData data;
248    assert(mux != NULL);
249    if (MuxGet(mux, IDX_VP8X, 1, &data) == WEBP_MUX_OK) {
250      if (data.size < VP8X_CHUNK_SIZE) return WEBP_MUX_BAD_DATA;
251      f = GetLE32(data.bytes + 0);
252      w = GetLE24(data.bytes + 4) + 1;
253      h = GetLE24(data.bytes + 7) + 1;
254    } else {
255      const WebPMuxImage* const wpi = mux->images_;
256      w = mux->canvas_width_;
257      h = mux->canvas_height_;
258      if (w == 0 && h == 0 && ValidateForSingleImage(mux) == WEBP_MUX_OK) {
259        assert(wpi != NULL);
260        w = wpi->width_;
261        h = wpi->height_;
262      }
263      if (wpi != NULL) {
264        if (wpi->has_alpha_) f |= ALPHA_FLAG;
265      }
266    }
267    if (w * (uint64_t)h >= MAX_IMAGE_AREA) return WEBP_MUX_BAD_DATA;
268    if (width != NULL) *width = w;
269    if (height != NULL) *height = h;
270    if (flags != NULL) *flags = f;
271    return WEBP_MUX_OK;
272  }
273  WebPMuxError WebPMuxGetCanvasSize(const WebPMux* mux, int* width, int* height) {
274    if (mux == NULL || width == NULL || height == NULL) {
275      return WEBP_MUX_INVALID_ARGUMENT;
276    }
277    return MuxGetCanvasInfo(mux, width, height, NULL);
278  }
279  WebPMuxError WebPMuxGetFeatures(const WebPMux* mux, uint32_t* flags) {
280    if (mux == NULL || flags == NULL) return WEBP_MUX_INVALID_ARGUMENT;
281    return MuxGetCanvasInfo(mux, NULL, NULL, flags);
282  }
283  static uint8_t* EmitVP8XChunk(uint8_t* const dst, int width,
284                                int height, uint32_t flags) {
285    const size_t vp8x_size = CHUNK_HEADER_SIZE + VP8X_CHUNK_SIZE;
286    assert(width >= 1 && height >= 1);
287    assert(width <= MAX_CANVAS_SIZE && height <= MAX_CANVAS_SIZE);
288    assert(width * (uint64_t)height < MAX_IMAGE_AREA);
289    PutLE32(dst, MKFOURCC('V', 'P', '8', 'X'));
290    PutLE32(dst + TAG_SIZE, VP8X_CHUNK_SIZE);
291    PutLE32(dst + CHUNK_HEADER_SIZE, flags);
292    PutLE24(dst + CHUNK_HEADER_SIZE + 4, width - 1);
293    PutLE24(dst + CHUNK_HEADER_SIZE + 7, height - 1);
294    return dst + vp8x_size;
295  }
296  static WebPMuxError SynthesizeBitstream(const WebPMuxImage* const wpi,
297                                          WebPData* const bitstream) {
298    uint8_t* dst;
299    const int need_vp8x = (wpi->alpha_ != NULL);
300    const size_t vp8x_size = need_vp8x ? CHUNK_HEADER_SIZE + VP8X_CHUNK_SIZE : 0;
301    const size_t alpha_size = need_vp8x ? ChunkDiskSize(wpi->alpha_) : 0;
302    const size_t size = RIFF_HEADER_SIZE + vp8x_size + alpha_size +
303                        ChunkDiskSize(wpi->img_);
304    uint8_t* const data = (uint8_t*)WebPSafeMalloc(1ULL, size);
305    if (data == NULL) return WEBP_MUX_MEMORY_ERROR;
306    assert(wpi->alpha_ == NULL || wpi->alpha_->next_ == NULL);
307    assert(wpi->img_ != NULL && wpi->img_->next_ == NULL);
308    dst = MuxEmitRiffHeader(data, size);
309    if (need_vp8x) {
310      dst = EmitVP8XChunk(dst, wpi->width_, wpi->height_, ALPHA_FLAG);  
311      dst = ChunkListEmit(wpi->alpha_, dst);       
312    }
313    dst = ChunkListEmit(wpi->img_, dst);
314    assert(dst == data + size);
315    bitstream->bytes = data;
316    bitstream->size = size;
317    return WEBP_MUX_OK;
318  }
319  WebPMuxError WebPMuxGetChunk(const WebPMux* mux, const char fourcc[4],
320                               WebPData* chunk_data) {
321    CHUNK_INDEX idx;
322    if (mux == NULL || fourcc == NULL || chunk_data == NULL) {
323      return WEBP_MUX_INVALID_ARGUMENT;
324    }
325    idx = ChunkGetIndexFromFourCC(fourcc);
326    if (IsWPI(kChunks[idx].id)) {     
327      return WEBP_MUX_INVALID_ARGUMENT;
328    } else if (idx != IDX_UNKNOWN) {  
329      return MuxGet(mux, idx, 1, chunk_data);
330    } else {                          
331      const WebPChunk* const chunk =
332          ChunkSearchList(mux->unknown_, 1, ChunkGetTagFromFourCC(fourcc));
333      if (chunk == NULL) return WEBP_MUX_NOT_FOUND;
334      *chunk_data = chunk->data_;
335      return WEBP_MUX_OK;
336    }
337  }
338  static WebPMuxError MuxGetImageInternal(const WebPMuxImage* const wpi,
339                                          WebPMuxFrameInfo* const info) {
340    info->x_offset = 0;
341    info->y_offset = 0;
342    info->duration = 1;
343    info->dispose_method = WEBP_MUX_DISPOSE_NONE;
344    info->blend_method = WEBP_MUX_BLEND;
345    info->id = ChunkGetIdFromTag(wpi->img_->tag_);
346    return SynthesizeBitstream(wpi, &info->bitstream);
347  }
348  static WebPMuxError MuxGetFrameInternal(const WebPMuxImage* const wpi,
349                                          WebPMuxFrameInfo* const frame) {
350    const int is_frame = (wpi->header_->tag_ == kChunks[IDX_ANMF].tag);
351    const WebPData* frame_data;
352    if (!is_frame) return WEBP_MUX_INVALID_ARGUMENT;
353    assert(wpi->header_ != NULL);  
354    frame_data = &wpi->header_->data_;
355    if (frame_data->size < kChunks[IDX_ANMF].size) return WEBP_MUX_BAD_DATA;
356    frame->x_offset = 2 * GetLE24(frame_data->bytes + 0);
357    frame->y_offset = 2 * GetLE24(frame_data->bytes + 3);
358    {
359      const uint8_t bits = frame_data->bytes[15];
360      frame->duration = GetLE24(frame_data->bytes + 12);
361      frame->dispose_method =
362          (bits & 1) ? WEBP_MUX_DISPOSE_BACKGROUND : WEBP_MUX_DISPOSE_NONE;
363      frame->blend_method = (bits & 2) ? WEBP_MUX_NO_BLEND : WEBP_MUX_BLEND;
364    }
365    frame->id = ChunkGetIdFromTag(wpi->header_->tag_);
366    return SynthesizeBitstream(wpi, &frame->bitstream);
367  }
368  WebPMuxError WebPMuxGetFrame(
369      const WebPMux* mux, uint32_t nth, WebPMuxFrameInfo* frame) {
370    WebPMuxError err;
371    WebPMuxImage* wpi;
372    if (mux == NULL || frame == NULL) {
373      return WEBP_MUX_INVALID_ARGUMENT;
374    }
375    err = MuxImageGetNth((const WebPMuxImage**)&mux->images_, nth, &wpi);
376    if (err != WEBP_MUX_OK) return err;
377    if (wpi->header_ == NULL) {
378      return MuxGetImageInternal(wpi, frame);
379    } else {
380      return MuxGetFrameInternal(wpi, frame);
381    }
382  }
383  WebPMuxError WebPMuxGetAnimationParams(const WebPMux* mux,
384                                         WebPMuxAnimParams* params) {
385    WebPData anim;
386    WebPMuxError err;
387    if (mux == NULL || params == NULL) return WEBP_MUX_INVALID_ARGUMENT;
388    err = MuxGet(mux, IDX_ANIM, 1, &anim);
389    if (err != WEBP_MUX_OK) return err;
390    if (anim.size < kChunks[WEBP_CHUNK_ANIM].size) return WEBP_MUX_BAD_DATA;
391    params->bgcolor = GetLE32(anim.bytes);
392    params->loop_count = GetLE16(anim.bytes + 4);
393    return WEBP_MUX_OK;
394  }
395  static CHUNK_INDEX ChunkGetIndexFromId(WebPChunkId id) {
396    int i;
397    for (i = 0; kChunks[i].id != WEBP_CHUNK_NIL; ++i) {
398      if (id == kChunks[i].id) return (CHUNK_INDEX)i;
399    }
400    return IDX_NIL;
401  }
402  static int CountChunks(const WebPChunk* const chunk_list, uint32_t tag) {
403    int count = 0;
404    const WebPChunk* current;
405    for (current = chunk_list; current != NULL; current = current->next_) {
406      if (tag == NIL_TAG || current->tag_ == tag) {
407        count++;  
408      }
409    }
410    return count;
411  }
412  WebPMuxError WebPMuxNumChunks(const WebPMux* mux,
413                                WebPChunkId id, int* num_elements) {
414    if (mux == NULL || num_elements == NULL) {
415      return WEBP_MUX_INVALID_ARGUMENT;
416    }
417    if (IsWPI(id)) {
418      *num_elements = MuxImageCount(mux->images_, id);
419    } else {
420      WebPChunk* const* chunk_list = MuxGetChunkListFromId(mux, id);
421      const CHUNK_INDEX idx = ChunkGetIndexFromId(id);
422      *num_elements = CountChunks(*chunk_list, kChunks[idx].tag);
423    }
424    return WEBP_MUX_OK;
425  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-NetworkState.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-muxread.c</div>
                </div>
                <div class="column column_space"><pre><code>40      std::vector<uint16_t> m_latency;
41      String m_fingerprint;
42      String m_ip;
43      String m_tls;
44      uint64_t m_accepted         = 0;
45      uint64_t m_connectionTime   = 0;
46      uint64_t m_diff             = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>129  WebPMux* WebPMuxCreateInternal(const WebPData* bitstream, int copy_data,
130                                 int version) {
131    size_t riff_size;
132    uint32_t tag;
133    const uint8_t* end;
134    WebPMux* mux = NULL;
135    WebPMuxImage* wpi = NULL;
136    const uint8_t* data;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    