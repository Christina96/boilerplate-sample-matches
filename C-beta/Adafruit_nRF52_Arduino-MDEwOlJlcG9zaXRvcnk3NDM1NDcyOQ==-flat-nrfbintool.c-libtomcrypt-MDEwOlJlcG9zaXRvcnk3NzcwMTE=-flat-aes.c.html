
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.434316353887399%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfbintool.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdint.h>
3  #include <stdbool.h>
4  #include <stdlib.h>
5  #include <string.h>
6  #include <assert.h>
7  #define SIGNATURE_EXTENSION "_signature.bin"
8  #define DFU_INIT_EXTENSION  "_init.dat"
9  typedef enum
10  {
11      BANK_VALID_APP   = 0x01,
12      BANK_VALID_SD    = 0xA5,
13      BANK_VALID_BOOT  = 0xAA,
14      BANK_ERASED      = 0xFE,
15      BANK_INVALID_APP = 0xFF,
16  } bootloader_bank_code_t;
17  typedef struct
18  {
19      uint32_t bank_0;          &bsol;**< Variable to store if bank 0 contains a valid application. */
20      uint32_t bank_0_crc;      &bsol;**< If bank is valid, this field will contain a valid CRC of the total image. */
21      uint32_t bank_1;          &bsol;**< Variable to store if bank 1 has been erased/prepared for new image. Bank 1 is only used in Banked Update scenario. */
22      uint32_t bank_0_size;     &bsol;**< Size of active image in bank0 if present, otherwise 0. */
23      uint32_t sd_image_size;   &bsol;**< Size of SoftDevice image in bank0 if bank_0 code is BANK_VALID_SD. */
24      uint32_t bl_image_size;   &bsol;**< Size of Bootloader image in bank0 if bank_0 code is BANK_VALID_SD. */
25      uint32_t app_image_size;  &bsol;**< Size of Application image in bank0 if bank_0 code is BANK_VALID_SD. */
26      uint32_t sd_image_start;  &bsol;**< Location in flash where SoftDevice image is stored for SoftDevice update. */
27  } bootloader_settings_t;
28  uint16_t crc16(uint8_t const *buffer, size_t len)
29  {
30    uint16_t crc = 0xffff;
31    int i;
32    for (i = 0; i < len; i++)
33    {
34      crc  = (uint8_t)(crc >> 8) | (crc << 8);
35      crc ^= buffer[i];
36      crc ^= (unsigned char)(crc & 0xff) >> 4;
37      crc ^= (crc << 8) << 4;
38      crc ^= ((crc & 0xff) << 4) << 1;
39    }
40  	return crc;
41  }
42  uint32_t get_filesize(char* filename)
43  {
44    uint32_t filesize;
45    FILE* fin = fopen(filename, "rb");
46    assert(fin != NULL);
47    fseek(fin, 0, SEEK_END);
48    filesize = ftell(fin);
49    fseek(fin, 0, SEEK_SET);
50    fclose(fin);
51    return filesize;
52  }
53  uint16_t crc16_of_file(char *filename)
54  {
55    uint32_t filesize = get_filesize(filename);
56    assert(filesize > 0);
57    FILE* fin = fopen(filename, "rb");
58    assert(fin != NULL);
59    uint8_t* buf = (uint8_t*) malloc(filesize);
60    (void) fread(buf, 1, filesize, fin);
<span onclick='openModal()' class='match'>61    uint16_t crc = crc16(buf, filesize);
62    free(buf);
63    fclose(fin);
64    return crc;
65  }
66  void create_app_signature(char *filename)
67  {
68    bootloader_settings_t signature =
</span>69    {
70        .bank_0      = BANK_VALID_APP,
71        .bank_0_crc  = crc16_of_file(filename),
72        .bank_1      = BANK_ERASED,
73        .bank_0_size = get_filesize(filename)
74    } ;
75    char output_name[256] = { 0 };
76    memcpy(output_name, filename, strlen(filename) - 4); 
77    strcat(output_name, SIGNATURE_EXTENSION);
78    FILE* fout = fopen(output_name, "wb");
79    assert(fout != NULL );
80    fwrite(&signature, 1, sizeof(signature), fout);
81    fclose(fout);
82  }
83  #define U32_FROM_U16(high, low)     ((uint32_t) (((high) << 16) | (low)))
84  #define DFU_SOFTDEVICE_ANY                  ((uint16_t)0xFFFE)
85  void create_app_dfu_init_packet(char* filename)
86  {
87    typedef struct
88    {
89      uint16_t device_type;    &bsol;**< Device type (2 bytes), for example Heart Rate. This number must be defined by the customer before production. It can be located in UICR or FICR. */
90      uint16_t device_rev;     &bsol;**< Device revision (2 bytes), for example major revision 1, minor revision 0. This number must be defined by the customer before production. It can be located in UICR or FICR. */
91      uint32_t app_version;    &bsol;**< Application version for the image software. This field allows for additional checking, for example ensuring that a downgrade is not allowed. */
92      uint16_t softdevice_len; &bsol;**< Number of different SoftDevice revisions compatible with this application. The list of SoftDevice firmware IDs is defined in @ref softdevice. */
93      uint16_t softdevice[1];  &bsol;**< Variable length array of SoftDevices compatible with this application. The length of the array is specified in the length field. SoftDevice firmware id 0xFFFE indicates any SoftDevice. */
94      uint16_t app_crc16;
95    } dfu_init_packet_t;
96    dfu_init_packet_t init_packet =
97    {
98        .device_type    = 0xffff,
99        .device_rev     = 0xffff,
100        .app_version    = U32_FROM_U16(0, 0),
101        .softdevice_len = 1,
102        .softdevice     = { DFU_SOFTDEVICE_ANY  },
103        .app_crc16      = crc16_of_file(filename)
104    };
105    char output_name[256] = { 0 };
106    memcpy(output_name, filename, strlen(filename) - 4); 
107    strcat(output_name, DFU_INIT_EXTENSION);
108    FILE* fout = fopen(output_name, "wb");
109    assert(fout != NULL );
110    fwrite(&init_packet, 1, sizeof(init_packet), fout);
111    fclose(fout);
112  }
113  int main(int argc, char *argv[])
114  {
115    if (argc != 2)
116    {
117      printf("%s <filename>", argv[0]);
118      return 0;
119    }
120    char *filename = argv[1];
121    create_app_signature(filename);
122    create_app_dfu_init_packet(filename);
123    return 0;
124  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-aes.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIJNDAEL
3  #ifndef ENCRYPT_ONLY
4  #define SETUP    rijndael_setup
5  #define ECB_ENC  rijndael_ecb_encrypt
6  #define ECB_DEC  rijndael_ecb_decrypt
7  #define ECB_DONE rijndael_done
8  #define ECB_TEST rijndael_test
9  #define ECB_KS   rijndael_keysize
10  const struct ltc_cipher_descriptor rijndael_desc =
11  {
12      "rijndael",
13      6,
14      16, 32, 16, 10,
15      SETUP, ECB_ENC, ECB_DEC, ECB_TEST, ECB_DONE, ECB_KS,
16      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
17  };
18  const struct ltc_cipher_descriptor aes_desc =
19  {
20      "aes",
21      6,
22      16, 32, 16, 10,
23      SETUP, ECB_ENC, ECB_DEC, ECB_TEST, ECB_DONE, ECB_KS,
24      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
25  };
26  #else
27  #define SETUP    rijndael_enc_setup
28  #define ECB_ENC  rijndael_enc_ecb_encrypt
29  #define ECB_KS   rijndael_enc_keysize
30  #define ECB_DONE rijndael_enc_done
31  const struct ltc_cipher_descriptor rijndael_enc_desc =
32  {
33      "rijndael",
34      6,
35      16, 32, 16, 10,
36      SETUP, ECB_ENC, NULL, NULL, ECB_DONE, ECB_KS,
37      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
38  };
39  const struct ltc_cipher_descriptor aes_enc_desc =
40  {
41      "aes",
42      6,
43      16, 32, 16, 10,
44      SETUP, ECB_ENC, NULL, NULL, ECB_DONE, ECB_KS,
45      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
46  };
47  #endif
48  #define LTC_AES_TAB_C
49  #include "aes_tab.c"
50  static ulong32 setup_mix(ulong32 temp)
51  {
52     return (Te4_3[LTC_BYTE(temp, 2)]) ^
53            (Te4_2[LTC_BYTE(temp, 1)]) ^
54            (Te4_1[LTC_BYTE(temp, 0)]) ^
55            (Te4_0[LTC_BYTE(temp, 3)]);
56  }
57  #ifndef ENCRYPT_ONLY
58  #ifdef LTC_SMALL_CODE
59  static ulong32 setup_mix2(ulong32 temp)
60  {
61     return Td0(255 & Te4[LTC_BYTE(temp, 3)]) ^
62            Td1(255 & Te4[LTC_BYTE(temp, 2)]) ^
63            Td2(255 & Te4[LTC_BYTE(temp, 1)]) ^
64            Td3(255 & Te4[LTC_BYTE(temp, 0)]);
65  }
66  #endif
67  #endif
68  int SETUP(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
69  {
70      int i;
71      ulong32 temp, *rk;
72  #ifndef ENCRYPT_ONLY
73      ulong32 *rrk;
74  #endif
75      LTC_ARGCHK(key  != NULL);
76      LTC_ARGCHK(skey != NULL);
77      if (keylen != 16 && keylen != 24 && keylen != 32) {
78         return CRYPT_INVALID_KEYSIZE;
79      }
80      if (num_rounds != 0 && num_rounds != (10 + ((keylen/8)-2)*2)) {
81         return CRYPT_INVALID_ROUNDS;
82      }
83      skey->rijndael.Nr = 10 + ((keylen/8)-2)*2;
84      i                 = 0;
85      rk                = skey->rijndael.eK;
86      LOAD32H(rk[0], key     );
87      LOAD32H(rk[1], key +  4);
88      LOAD32H(rk[2], key +  8);
89      LOAD32H(rk[3], key + 12);
90      if (keylen == 16) {
91          for (;;) {
92              temp  = rk[3];
93              rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
94              rk[5] = rk[1] ^ rk[4];
95              rk[6] = rk[2] ^ rk[5];
96              rk[7] = rk[3] ^ rk[6];
97              if (++i == 10) {
98                 break;
99              }
100              rk += 4;
101          }
102      } else if (keylen == 24) {
103          LOAD32H(rk[4], key + 16);
104          LOAD32H(rk[5], key + 20);
105          for (;;) {
106          #ifdef _MSC_VER
107              temp = skey->rijndael.eK[rk - skey->rijndael.eK + 5];
108          #else
109              temp = rk[5];
110          #endif
111              rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
112              rk[ 7] = rk[ 1] ^ rk[ 6];
113              rk[ 8] = rk[ 2] ^ rk[ 7];
114              rk[ 9] = rk[ 3] ^ rk[ 8];
115              if (++i == 8) {
116                  break;
117              }
118              rk[10] = rk[ 4] ^ rk[ 9];
119              rk[11] = rk[ 5] ^ rk[10];
120              rk += 6;
121          }
122      } else if (keylen == 32) {
123          LOAD32H(rk[4], key + 16);
124          LOAD32H(rk[5], key + 20);
125          LOAD32H(rk[6], key + 24);
126          LOAD32H(rk[7], key + 28);
127          for (;;) {
128          #ifdef _MSC_VER
129              temp = skey->rijndael.eK[rk - skey->rijndael.eK + 7];
130          #else
131              temp = rk[7];
132          #endif
133              rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
134              rk[ 9] = rk[ 1] ^ rk[ 8];
135              rk[10] = rk[ 2] ^ rk[ 9];
136              rk[11] = rk[ 3] ^ rk[10];
137              if (++i == 7) {
138                  break;
139              }
140              temp = rk[11];
141              rk[12] = rk[ 4] ^ setup_mix(RORc(temp, 8));
142              rk[13] = rk[ 5] ^ rk[12];
143              rk[14] = rk[ 6] ^ rk[13];
144              rk[15] = rk[ 7] ^ rk[14];
145              rk += 8;
146          }
147      } else {
148         return CRYPT_ERROR;
149      }
150  #ifndef ENCRYPT_ONLY
151      rk   = skey->rijndael.dK;
152      rrk  = skey->rijndael.eK + (28 + keylen) - 4;
153      *rk++ = *rrk++;
154      *rk++ = *rrk++;
155      *rk++ = *rrk++;
156      *rk   = *rrk;
157      rk -= 3; rrk -= 3;
158      for (i = 1; i < skey->rijndael.Nr; i++) {
159          rrk -= 4;
160          rk  += 4;
161      #ifdef LTC_SMALL_CODE
162          temp = rrk[0];
163          rk[0] = setup_mix2(temp);
164          temp = rrk[1];
165          rk[1] = setup_mix2(temp);
166          temp = rrk[2];
167          rk[2] = setup_mix2(temp);
168          temp = rrk[3];
169          rk[3] = setup_mix2(temp);
170       #else
171          temp = rrk[0];
172          rk[0] =
173              Tks0[LTC_BYTE(temp, 3)] ^
174              Tks1[LTC_BYTE(temp, 2)] ^
175              Tks2[LTC_BYTE(temp, 1)] ^
176              Tks3[LTC_BYTE(temp, 0)];
177          temp = rrk[1];
178          rk[1] =
179              Tks0[LTC_BYTE(temp, 3)] ^
180              Tks1[LTC_BYTE(temp, 2)] ^
181              Tks2[LTC_BYTE(temp, 1)] ^
182              Tks3[LTC_BYTE(temp, 0)];
183          temp = rrk[2];
184          rk[2] =
185              Tks0[LTC_BYTE(temp, 3)] ^
186              Tks1[LTC_BYTE(temp, 2)] ^
187              Tks2[LTC_BYTE(temp, 1)] ^
188              Tks3[LTC_BYTE(temp, 0)];
189          temp = rrk[3];
190          rk[3] =
191              Tks0[LTC_BYTE(temp, 3)] ^
192              Tks1[LTC_BYTE(temp, 2)] ^
193              Tks2[LTC_BYTE(temp, 1)] ^
194              Tks3[LTC_BYTE(temp, 0)];
195        #endif
196      }
197      rrk -= 4;
198      rk  += 4;
199      *rk++ = *rrk++;
200      *rk++ = *rrk++;
201      *rk++ = *rrk++;
202      *rk   = *rrk;
203  #endif &bsol;* ENCRYPT_ONLY */
204      return CRYPT_OK;
205  }
206  #ifdef LTC_CLEAN_STACK
207  static int s_rijndael_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
208  #else
209  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
210  #endif
211  {
212      ulong32 s0, s1, s2, s3, t0, t1, t2, t3;
213      const ulong32 *rk;
214      int Nr, r;
215      LTC_ARGCHK(pt != NULL);
216      LTC_ARGCHK(ct != NULL);
217      LTC_ARGCHK(skey != NULL);
218      Nr = skey->rijndael.Nr;
219      if (Nr < 2 || Nr > 16)
220          return CRYPT_INVALID_ROUNDS;
221      rk = skey->rijndael.eK;
222      LOAD32H(s0, pt      ); s0 ^= rk[0];
223      LOAD32H(s1, pt  +  4); s1 ^= rk[1];
224      LOAD32H(s2, pt  +  8); s2 ^= rk[2];
225      LOAD32H(s3, pt  + 12); s3 ^= rk[3];
226  #ifdef LTC_SMALL_CODE
227      for (r = 0; ; r++) {
228          rk += 4;
229          t0 =
230              Te0(LTC_BYTE(s0, 3)) ^
231              Te1(LTC_BYTE(s1, 2)) ^
232              Te2(LTC_BYTE(s2, 1)) ^
233              Te3(LTC_BYTE(s3, 0)) ^
234              rk[0];
235          t1 =
236              Te0(LTC_BYTE(s1, 3)) ^
237              Te1(LTC_BYTE(s2, 2)) ^
238              Te2(LTC_BYTE(s3, 1)) ^
239              Te3(LTC_BYTE(s0, 0)) ^
240              rk[1];
241          t2 =
242              Te0(LTC_BYTE(s2, 3)) ^
243              Te1(LTC_BYTE(s3, 2)) ^
244              Te2(LTC_BYTE(s0, 1)) ^
245              Te3(LTC_BYTE(s1, 0)) ^
246              rk[2];
247          t3 =
248              Te0(LTC_BYTE(s3, 3)) ^
249              Te1(LTC_BYTE(s0, 2)) ^
250              Te2(LTC_BYTE(s1, 1)) ^
251              Te3(LTC_BYTE(s2, 0)) ^
252              rk[3];
253          if (r == Nr-2) {
254             break;
255          }
256          s0 = t0; s1 = t1; s2 = t2; s3 = t3;
257      }
258      rk += 4;
259  #else
260      r = Nr >> 1;
261      for (;;) {
262          t0 =
263              Te0(LTC_BYTE(s0, 3)) ^
264              Te1(LTC_BYTE(s1, 2)) ^
265              Te2(LTC_BYTE(s2, 1)) ^
266              Te3(LTC_BYTE(s3, 0)) ^
267              rk[4];
268          t1 =
269              Te0(LTC_BYTE(s1, 3)) ^
270              Te1(LTC_BYTE(s2, 2)) ^
271              Te2(LTC_BYTE(s3, 1)) ^
272              Te3(LTC_BYTE(s0, 0)) ^
273              rk[5];
274          t2 =
275              Te0(LTC_BYTE(s2, 3)) ^
276              Te1(LTC_BYTE(s3, 2)) ^
277              Te2(LTC_BYTE(s0, 1)) ^
278              Te3(LTC_BYTE(s1, 0)) ^
279              rk[6];
280          t3 =
281              Te0(LTC_BYTE(s3, 3)) ^
282              Te1(LTC_BYTE(s0, 2)) ^
283              Te2(LTC_BYTE(s1, 1)) ^
284              Te3(LTC_BYTE(s2, 0)) ^
285              rk[7];
286          rk += 8;
287          if (--r == 0) {
288              break;
289          }
290          s0 =
291              Te0(LTC_BYTE(t0, 3)) ^
292              Te1(LTC_BYTE(t1, 2)) ^
293              Te2(LTC_BYTE(t2, 1)) ^
294              Te3(LTC_BYTE(t3, 0)) ^
295              rk[0];
296          s1 =
297              Te0(LTC_BYTE(t1, 3)) ^
298              Te1(LTC_BYTE(t2, 2)) ^
299              Te2(LTC_BYTE(t3, 1)) ^
300              Te3(LTC_BYTE(t0, 0)) ^
301              rk[1];
302          s2 =
303              Te0(LTC_BYTE(t2, 3)) ^
304              Te1(LTC_BYTE(t3, 2)) ^
305              Te2(LTC_BYTE(t0, 1)) ^
306              Te3(LTC_BYTE(t1, 0)) ^
307              rk[2];
308          s3 =
309              Te0(LTC_BYTE(t3, 3)) ^
310              Te1(LTC_BYTE(t0, 2)) ^
311              Te2(LTC_BYTE(t1, 1)) ^
312              Te3(LTC_BYTE(t2, 0)) ^
313              rk[3];
314      }
315  #endif
316      s0 =
317          (Te4_3[LTC_BYTE(t0, 3)]) ^
318          (Te4_2[LTC_BYTE(t1, 2)]) ^
319          (Te4_1[LTC_BYTE(t2, 1)]) ^
320          (Te4_0[LTC_BYTE(t3, 0)]) ^
321          rk[0];
322      STORE32H(s0, ct);
323      s1 =
324          (Te4_3[LTC_BYTE(t1, 3)]) ^
325          (Te4_2[LTC_BYTE(t2, 2)]) ^
326          (Te4_1[LTC_BYTE(t3, 1)]) ^
327          (Te4_0[LTC_BYTE(t0, 0)]) ^
328          rk[1];
329      STORE32H(s1, ct+4);
330      s2 =
331          (Te4_3[LTC_BYTE(t2, 3)]) ^
332          (Te4_2[LTC_BYTE(t3, 2)]) ^
333          (Te4_1[LTC_BYTE(t0, 1)]) ^
334          (Te4_0[LTC_BYTE(t1, 0)]) ^
335          rk[2];
336      STORE32H(s2, ct+8);
337      s3 =
338          (Te4_3[LTC_BYTE(t3, 3)]) ^
<span onclick='openModal()' class='match'>339          (Te4_2[LTC_BYTE(t0, 2)]) ^
340          (Te4_1[LTC_BYTE(t1, 1)]) ^
341          (Te4_0[LTC_BYTE(t2, 0)]) ^
342          rk[3];
343      STORE32H(s3, ct+12);
344      return CRYPT_OK;
345  }
346  #ifdef LTC_CLEAN_STACK
347  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
</span>348  {
349     int err = s_rijndael_ecb_encrypt(pt, ct, skey);
350     burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
351     return err;
352  }
353  #endif
354  #ifndef ENCRYPT_ONLY
355  #ifdef LTC_CLEAN_STACK
356  static int s_rijndael_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
357  #else
358  int ECB_DEC(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
359  #endif
360  {
361      ulong32 s0, s1, s2, s3, t0, t1, t2, t3;
362      const ulong32 *rk;
363      int Nr, r;
364      LTC_ARGCHK(pt != NULL);
365      LTC_ARGCHK(ct != NULL);
366      LTC_ARGCHK(skey != NULL);
367      Nr = skey->rijndael.Nr;
368      if (Nr < 2 || Nr > 16)
369          return CRYPT_INVALID_ROUNDS;
370      rk = skey->rijndael.dK;
371      LOAD32H(s0, ct      ); s0 ^= rk[0];
372      LOAD32H(s1, ct  +  4); s1 ^= rk[1];
373      LOAD32H(s2, ct  +  8); s2 ^= rk[2];
374      LOAD32H(s3, ct  + 12); s3 ^= rk[3];
375  #ifdef LTC_SMALL_CODE
376      for (r = 0; ; r++) {
377          rk += 4;
378          t0 =
379              Td0(LTC_BYTE(s0, 3)) ^
380              Td1(LTC_BYTE(s3, 2)) ^
381              Td2(LTC_BYTE(s2, 1)) ^
382              Td3(LTC_BYTE(s1, 0)) ^
383              rk[0];
384          t1 =
385              Td0(LTC_BYTE(s1, 3)) ^
386              Td1(LTC_BYTE(s0, 2)) ^
387              Td2(LTC_BYTE(s3, 1)) ^
388              Td3(LTC_BYTE(s2, 0)) ^
389              rk[1];
390          t2 =
391              Td0(LTC_BYTE(s2, 3)) ^
392              Td1(LTC_BYTE(s1, 2)) ^
393              Td2(LTC_BYTE(s0, 1)) ^
394              Td3(LTC_BYTE(s3, 0)) ^
395              rk[2];
396          t3 =
397              Td0(LTC_BYTE(s3, 3)) ^
398              Td1(LTC_BYTE(s2, 2)) ^
399              Td2(LTC_BYTE(s1, 1)) ^
400              Td3(LTC_BYTE(s0, 0)) ^
401              rk[3];
402          if (r == Nr-2) {
403             break;
404          }
405          s0 = t0; s1 = t1; s2 = t2; s3 = t3;
406      }
407      rk += 4;
408  #else
409      r = Nr >> 1;
410      for (;;) {
411          t0 =
412              Td0(LTC_BYTE(s0, 3)) ^
413              Td1(LTC_BYTE(s3, 2)) ^
414              Td2(LTC_BYTE(s2, 1)) ^
415              Td3(LTC_BYTE(s1, 0)) ^
416              rk[4];
417          t1 =
418              Td0(LTC_BYTE(s1, 3)) ^
419              Td1(LTC_BYTE(s0, 2)) ^
420              Td2(LTC_BYTE(s3, 1)) ^
421              Td3(LTC_BYTE(s2, 0)) ^
422              rk[5];
423          t2 =
424              Td0(LTC_BYTE(s2, 3)) ^
425              Td1(LTC_BYTE(s1, 2)) ^
426              Td2(LTC_BYTE(s0, 1)) ^
427              Td3(LTC_BYTE(s3, 0)) ^
428              rk[6];
429          t3 =
430              Td0(LTC_BYTE(s3, 3)) ^
431              Td1(LTC_BYTE(s2, 2)) ^
432              Td2(LTC_BYTE(s1, 1)) ^
433              Td3(LTC_BYTE(s0, 0)) ^
434              rk[7];
435          rk += 8;
436          if (--r == 0) {
437              break;
438          }
439          s0 =
440              Td0(LTC_BYTE(t0, 3)) ^
441              Td1(LTC_BYTE(t3, 2)) ^
442              Td2(LTC_BYTE(t2, 1)) ^
443              Td3(LTC_BYTE(t1, 0)) ^
444              rk[0];
445          s1 =
446              Td0(LTC_BYTE(t1, 3)) ^
447              Td1(LTC_BYTE(t0, 2)) ^
448              Td2(LTC_BYTE(t3, 1)) ^
449              Td3(LTC_BYTE(t2, 0)) ^
450              rk[1];
451          s2 =
452              Td0(LTC_BYTE(t2, 3)) ^
453              Td1(LTC_BYTE(t1, 2)) ^
454              Td2(LTC_BYTE(t0, 1)) ^
455              Td3(LTC_BYTE(t3, 0)) ^
456              rk[2];
457          s3 =
458              Td0(LTC_BYTE(t3, 3)) ^
459              Td1(LTC_BYTE(t2, 2)) ^
460              Td2(LTC_BYTE(t1, 1)) ^
461              Td3(LTC_BYTE(t0, 0)) ^
462              rk[3];
463      }
464  #endif
465      s0 =
466          (Td4[LTC_BYTE(t0, 3)] & 0xff000000) ^
467          (Td4[LTC_BYTE(t3, 2)] & 0x00ff0000) ^
468          (Td4[LTC_BYTE(t2, 1)] & 0x0000ff00) ^
469          (Td4[LTC_BYTE(t1, 0)] & 0x000000ff) ^
470          rk[0];
471      STORE32H(s0, pt);
472      s1 =
473          (Td4[LTC_BYTE(t1, 3)] & 0xff000000) ^
474          (Td4[LTC_BYTE(t0, 2)] & 0x00ff0000) ^
475          (Td4[LTC_BYTE(t3, 1)] & 0x0000ff00) ^
476          (Td4[LTC_BYTE(t2, 0)] & 0x000000ff) ^
477          rk[1];
478      STORE32H(s1, pt+4);
479      s2 =
480          (Td4[LTC_BYTE(t2, 3)] & 0xff000000) ^
481          (Td4[LTC_BYTE(t1, 2)] & 0x00ff0000) ^
482          (Td4[LTC_BYTE(t0, 1)] & 0x0000ff00) ^
483          (Td4[LTC_BYTE(t3, 0)] & 0x000000ff) ^
484          rk[2];
485      STORE32H(s2, pt+8);
486      s3 =
487          (Td4[LTC_BYTE(t3, 3)] & 0xff000000) ^
488          (Td4[LTC_BYTE(t2, 2)] & 0x00ff0000) ^
489          (Td4[LTC_BYTE(t1, 1)] & 0x0000ff00) ^
490          (Td4[LTC_BYTE(t0, 0)] & 0x000000ff) ^
491          rk[3];
492      STORE32H(s3, pt+12);
493      return CRYPT_OK;
494  }
495  #ifdef LTC_CLEAN_STACK
496  int ECB_DEC(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
497  {
498     int err = s_rijndael_ecb_decrypt(ct, pt, skey);
499     burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
500     return err;
501  }
502  #endif
503  int ECB_TEST(void)
504  {
505   #ifndef LTC_TEST
506      return CRYPT_NOP;
507   #else
508   int err;
509   static const struct {
510       int keylen;
511       unsigned char key[32], pt[16], ct[16];
512   } tests[] = {
513      { 16,
514        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
515          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
516        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
517          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
518        { 0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
519          0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a }
520      }, {
521        24,
522        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
523          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
524          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 },
525        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
526          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
527        { 0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0,
528          0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91 }
529      }, {
530        32,
531        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
532          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
533          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
534          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
535        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
536          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
537        { 0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
538          0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89 }
539      }
540   };
541    symmetric_key key;
542    unsigned char tmp[2][16];
543    int i, y;
544    for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
545      zeromem(&key, sizeof(key));
546      if ((err = rijndael_setup(tests[i].key, tests[i].keylen, 0, &key)) != CRYPT_OK) {
547         return err;
548      }
549      rijndael_ecb_encrypt(tests[i].pt, tmp[0], &key);
550      rijndael_ecb_decrypt(tmp[0], tmp[1], &key);
551      if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "AES Encrypt", i) ||
552            compare_testvector(tmp[1], 16, tests[i].pt, 16, "AES Decrypt", i)) {
553          return CRYPT_FAIL_TESTVECTOR;
554      }
555      for (y = 0; y < 16; y++) tmp[0][y] = 0;
556      for (y = 0; y < 1000; y++) rijndael_ecb_encrypt(tmp[0], tmp[0], &key);
557      for (y = 0; y < 1000; y++) rijndael_ecb_decrypt(tmp[0], tmp[0], &key);
558      for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
559    }
560    return CRYPT_OK;
561   #endif
562  }
563  #endif &bsol;* ENCRYPT_ONLY */
564  void ECB_DONE(symmetric_key *skey)
565  {
566    LTC_UNUSED_PARAM(skey);
567  }
568  int ECB_KS(int *keysize)
569  {
570     LTC_ARGCHK(keysize != NULL);
571     if (*keysize < 16) {
572        return CRYPT_INVALID_KEYSIZE;
573     }
574     if (*keysize < 24) {
575        *keysize = 16;
576        return CRYPT_OK;
577     }
578     if (*keysize < 32) {
579        *keysize = 24;
580        return CRYPT_OK;
581     }
582     *keysize = 32;
583     return CRYPT_OK;
584  }
585  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfbintool.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-aes.c</div>
                </div>
                <div class="column column_space"><pre><code>61    uint16_t crc = crc16(buf, filesize);
62    free(buf);
63    fclose(fin);
64    return crc;
65  }
66  void create_app_signature(char *filename)
67  {
68    bootloader_settings_t signature =
</pre></code></div>
                <div class="column column_space"><pre><code>339          (Te4_2[LTC_BYTE(t0, 2)]) ^
340          (Te4_1[LTC_BYTE(t1, 1)]) ^
341          (Te4_0[LTC_BYTE(t2, 0)]) ^
342          rk[3];
343      STORE32H(s3, ct+12);
344      return CRYPT_OK;
345  }
346  #ifdef LTC_CLEAN_STACK
347  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    