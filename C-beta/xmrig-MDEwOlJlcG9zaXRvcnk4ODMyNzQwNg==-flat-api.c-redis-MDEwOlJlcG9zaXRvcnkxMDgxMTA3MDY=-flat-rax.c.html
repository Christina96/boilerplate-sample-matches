
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.454720616570328%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-api.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <stdio.h>
3  #include <string.h>
4  #include "llhttp.h"
5  #define CALLBACK_MAYBE(PARSER, NAME, ...)                                     \
6    do {                                                                        \
7      const llhttp_settings_t* settings;                                        \
8      settings = (const llhttp_settings_t*) (PARSER)->settings;                 \
9      if (settings == NULL || settings->NAME == NULL) {                         \
10        err = 0;                                                                \
11        break;                                                                  \
12      }                                                                         \
13      err = settings->NAME(__VA_ARGS__);                                        \
14    } while (0)
15  void llhttp_init(llhttp_t* parser, llhttp_type_t type,
16                   const llhttp_settings_t* settings) {
17    llhttp__internal_init(parser);
18    parser->type = type;
19    parser->settings = (void*) settings;
20  }
21  #if defined(__wasm__)
22  extern int wasm_on_message_begin(llhttp_t * p);
23  extern int wasm_on_url(llhttp_t* p, const char* at, size_t length);
24  extern int wasm_on_status(llhttp_t* p, const char* at, size_t length);
25  extern int wasm_on_header_field(llhttp_t* p, const char* at, size_t length);
26  extern int wasm_on_header_value(llhttp_t* p, const char* at, size_t length);
27  extern int wasm_on_headers_complete(llhttp_t * p);
28  extern int wasm_on_body(llhttp_t* p, const char* at, size_t length);
29  extern int wasm_on_message_complete(llhttp_t * p);
30  const llhttp_settings_t wasm_settings = {
31    wasm_on_message_begin,
32    wasm_on_url,
33    wasm_on_status,
34    wasm_on_header_field,
35    wasm_on_header_value,
36    wasm_on_headers_complete,
37    wasm_on_body,
38    wasm_on_message_complete,
39    NULL,
40    NULL,
41  };
42  llhttp_t* llhttp_alloc(llhttp_type_t type) {
43    llhttp_t* parser = malloc(sizeof(llhttp_t));
44    llhttp_init(parser, type, &wasm_settings);
45    return parser;
46  }
47  void llhttp_free(llhttp_t* parser) {
48    free(parser);
49  }
50  uint8_t llhttp_get_type(llhttp_t* parser) {
51    return parser->type;
52  }
53  uint8_t llhttp_get_http_major(llhttp_t* parser) {
54    return parser->http_major;
55  }
56  uint8_t llhttp_get_http_minor(llhttp_t* parser) {
57    return parser->http_minor;
58  }
59  uint8_t llhttp_get_method(llhttp_t* parser) {
60    return parser->method;
61  }
62  int llhttp_get_status_code(llhttp_t* parser) {
63    return parser->status_code;
64  }
65  uint8_t llhttp_get_upgrade(llhttp_t* parser) {
66    return parser->upgrade;
67  }
68  #endif  
69  void llhttp_reset(llhttp_t* parser) {
70    llhttp_type_t type = parser->type;
71    const llhttp_settings_t* settings = parser->settings;
72    void* data = parser->data;
73    uint8_t lenient_flags = parser->lenient_flags;
74    llhttp__internal_init(parser);
<span onclick='openModal()' class='match'>75    parser->type = type;
76    parser->settings = (void*) settings;
77    parser->data = data;
78    parser->lenient_flags = lenient_flags;
79  }
80  llhttp_errno_t llhttp_execute(llhttp_t* parser, const char* data, size_t len) {
</span>81    return llhttp__internal_execute(parser, data, data + len);
82  }
83  void llhttp_settings_init(llhttp_settings_t* settings) {
84    memset(settings, 0, sizeof(*settings));
85  }
86  llhttp_errno_t llhttp_finish(llhttp_t* parser) {
87    int err;
88    if (parser->error != 0) {
89      return 0;
90    }
91    switch (parser->finish) {
92      case HTTP_FINISH_SAFE_WITH_CB:
93        CALLBACK_MAYBE(parser, on_message_complete, parser);
94        if (err != HPE_OK) return err;
95      case HTTP_FINISH_SAFE:
96        return HPE_OK;
97      case HTTP_FINISH_UNSAFE:
98        parser->reason = "Invalid EOF state";
99        return HPE_INVALID_EOF_STATE;
100      default:
101        abort();
102    }
103  }
104  void llhttp_pause(llhttp_t* parser) {
105    if (parser->error != HPE_OK) {
106      return;
107    }
108    parser->error = HPE_PAUSED;
109    parser->reason = "Paused";
110  }
111  void llhttp_resume(llhttp_t* parser) {
112    if (parser->error != HPE_PAUSED) {
113      return;
114    }
115    parser->error = 0;
116  }
117  void llhttp_resume_after_upgrade(llhttp_t* parser) {
118    if (parser->error != HPE_PAUSED_UPGRADE) {
119      return;
120    }
121    parser->error = 0;
122  }
123  llhttp_errno_t llhttp_get_errno(const llhttp_t* parser) {
124    return parser->error;
125  }
126  const char* llhttp_get_error_reason(const llhttp_t* parser) {
127    return parser->reason;
128  }
129  void llhttp_set_error_reason(llhttp_t* parser, const char* reason) {
130    parser->reason = reason;
131  }
132  const char* llhttp_get_error_pos(const llhttp_t* parser) {
133    return parser->error_pos;
134  }
135  const char* llhttp_errno_name(llhttp_errno_t err) {
136  #define HTTP_ERRNO_GEN(CODE, NAME, _) case HPE_##NAME: return "HPE_" #NAME;
137    switch (err) {
138      HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)
139      default: abort();
140    }
141  #undef HTTP_ERRNO_GEN
142  }
143  const char* llhttp_method_name(llhttp_method_t method) {
144  #define HTTP_METHOD_GEN(NUM, NAME, STRING) case HTTP_##NAME: return #STRING;
145    switch (method) {
146      HTTP_METHOD_MAP(HTTP_METHOD_GEN)
147      default: abort();
148    }
149  #undef HTTP_METHOD_GEN
150  }
151  void llhttp_set_lenient_headers(llhttp_t* parser, int enabled) {
152    if (enabled) {
153      parser->lenient_flags |= LENIENT_HEADERS;
154    } else {
155      parser->lenient_flags &= ~LENIENT_HEADERS;
156    }
157  }
158  void llhttp_set_lenient_chunked_length(llhttp_t* parser, int enabled) {
159    if (enabled) {
160      parser->lenient_flags |= LENIENT_CHUNKED_LENGTH;
161    } else {
162      parser->lenient_flags &= ~LENIENT_CHUNKED_LENGTH;
163    }
164  }
165  void llhttp_set_lenient_keep_alive(llhttp_t* parser, int enabled) {
166    if (enabled) {
167      parser->lenient_flags |= LENIENT_KEEP_ALIVE;
168    } else {
169      parser->lenient_flags &= ~LENIENT_KEEP_ALIVE;
170    }
171  }
172  int llhttp__on_message_begin(llhttp_t* s, const char* p, const char* endp) {
173    int err;
174    CALLBACK_MAYBE(s, on_message_begin, s);
175    return err;
176  }
177  int llhttp__on_url(llhttp_t* s, const char* p, const char* endp) {
178    int err;
179    CALLBACK_MAYBE(s, on_url, s, p, endp - p);
180    return err;
181  }
182  int llhttp__on_url_complete(llhttp_t* s, const char* p, const char* endp) {
183    int err;
184    CALLBACK_MAYBE(s, on_url_complete, s);
185    return err;
186  }
187  int llhttp__on_status(llhttp_t* s, const char* p, const char* endp) {
188    int err;
189    CALLBACK_MAYBE(s, on_status, s, p, endp - p);
190    return err;
191  }
192  int llhttp__on_status_complete(llhttp_t* s, const char* p, const char* endp) {
193    int err;
194    CALLBACK_MAYBE(s, on_status_complete, s);
195    return err;
196  }
197  int llhttp__on_header_field(llhttp_t* s, const char* p, const char* endp) {
198    int err;
199    CALLBACK_MAYBE(s, on_header_field, s, p, endp - p);
200    return err;
201  }
202  int llhttp__on_header_field_complete(llhttp_t* s, const char* p, const char* endp) {
203    int err;
204    CALLBACK_MAYBE(s, on_header_field_complete, s);
205    return err;
206  }
207  int llhttp__on_header_value(llhttp_t* s, const char* p, const char* endp) {
208    int err;
209    CALLBACK_MAYBE(s, on_header_value, s, p, endp - p);
210    return err;
211  }
212  int llhttp__on_header_value_complete(llhttp_t* s, const char* p, const char* endp) {
213    int err;
214    CALLBACK_MAYBE(s, on_header_value_complete, s);
215    return err;
216  }
217  int llhttp__on_headers_complete(llhttp_t* s, const char* p, const char* endp) {
218    int err;
219    CALLBACK_MAYBE(s, on_headers_complete, s);
220    return err;
221  }
222  int llhttp__on_message_complete(llhttp_t* s, const char* p, const char* endp) {
223    int err;
224    CALLBACK_MAYBE(s, on_message_complete, s);
225    return err;
226  }
227  int llhttp__on_body(llhttp_t* s, const char* p, const char* endp) {
228    int err;
229    CALLBACK_MAYBE(s, on_body, s, p, endp - p);
230    return err;
231  }
232  int llhttp__on_chunk_header(llhttp_t* s, const char* p, const char* endp) {
233    int err;
234    CALLBACK_MAYBE(s, on_chunk_header, s);
235    return err;
236  }
237  int llhttp__on_chunk_complete(llhttp_t* s, const char* p, const char* endp) {
238    int err;
239    CALLBACK_MAYBE(s, on_chunk_complete, s);
240    return err;
241  }
242  void llhttp__debug(llhttp_t* s, const char* p, const char* endp,
243                     const char* msg) {
244    if (p == endp) {
245      fprintf(stderr, "p=%p type=%d flags=%02x next=null debug=%s\n", s, s->type,
246              s->flags, msg);
247    } else {
248      fprintf(stderr, "p=%p type=%d flags=%02x next=%02x   debug=%s\n", s,
249              s->type, s->flags, *p, msg);
250    }
251  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rax.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <assert.h>
4  #include <stdio.h>
5  #include <errno.h>
6  #include <math.h>
7  #include "rax.h"
8  #ifndef RAX_MALLOC_INCLUDE
9  #define RAX_MALLOC_INCLUDE "rax_malloc.h"
10  #endif
11  #include RAX_MALLOC_INCLUDE
12  void *raxNotFound = (void*)"rax-not-found-pointer";
13  void raxDebugShowNode(const char *msg, raxNode *n);
14  #ifdef RAX_DEBUG_MSG
15  #define debugf(...)                                                            \
16      if (raxDebugMsg) {                                                         \
17          printf("%s:%s:%d:\t", __FILE__, __FUNCTION__, __LINE__);               \
18          printf(__VA_ARGS__);                                                   \
19          fflush(stdout);                                                        \
20      }
21  #define debugnode(msg,n) raxDebugShowNode(msg,n)
22  #else
23  #define debugf(...)
24  #define debugnode(msg,n)
25  #endif
26  static int raxDebugMsg = 1;
27  void raxSetDebugMsg(int onoff) {
28      raxDebugMsg = onoff;
29  }
30  static inline void raxStackInit(raxStack *ts) {
31      ts->stack = ts->static_items;
32      ts->items = 0;
33      ts->maxitems = RAX_STACK_STATIC_ITEMS;
34      ts->oom = 0;
35  }
36  static inline int raxStackPush(raxStack *ts, void *ptr) {
37      if (ts->items == ts->maxitems) {
38          if (ts->stack == ts->static_items) {
39              ts->stack = rax_malloc(sizeof(void*)*ts->maxitems*2);
40              if (ts->stack == NULL) {
41                  ts->stack = ts->static_items;
42                  ts->oom = 1;
43                  errno = ENOMEM;
44                  return 0;
45              }
46              memcpy(ts->stack,ts->static_items,sizeof(void*)*ts->maxitems);
47          } else {
48              void **newalloc = rax_realloc(ts->stack,sizeof(void*)*ts->maxitems*2);
49              if (newalloc == NULL) {
50                  ts->oom = 1;
51                  errno = ENOMEM;
52                  return 0;
53              }
54              ts->stack = newalloc;
55          }
56          ts->maxitems *= 2;
57      }
58      ts->stack[ts->items] = ptr;
59      ts->items++;
60      return 1;
61  }
62  static inline void *raxStackPop(raxStack *ts) {
63      if (ts->items == 0) return NULL;
64      ts->items--;
65      return ts->stack[ts->items];
66  }
67  static inline void *raxStackPeek(raxStack *ts) {
68      if (ts->items == 0) return NULL;
69      return ts->stack[ts->items-1];
70  }
71  static inline void raxStackFree(raxStack *ts) {
72      if (ts->stack != ts->static_items) rax_free(ts->stack);
73  }
74  #define raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) & (sizeof(void*)-1))
75  #define raxNodeLastChildPtr(n) ((raxNode**) ( \
76      ((char*)(n)) + \
77      raxNodeCurrentLength(n) - \
78      sizeof(raxNode*) - \
79      (((n)->iskey && !(n)->isnull) ? sizeof(void*) : 0) \
80  ))
81  #define raxNodeFirstChildPtr(n) ((raxNode**) ( \
82      (n)->data + \
83      (n)->size + \
84      raxPadding((n)->size)))
85  #define raxNodeCurrentLength(n) ( \
86      sizeof(raxNode)+(n)->size+ \
87      raxPadding((n)->size)+ \
88      ((n)->iscompr ? sizeof(raxNode*) : sizeof(raxNode*)*(n)->size)+ \
89      (((n)->iskey && !(n)->isnull)*sizeof(void*)) \
90  )
91  raxNode *raxNewNode(size_t children, int datafield) {
92      size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+
93                        sizeof(raxNode*)*children;
94      if (datafield) nodesize += sizeof(void*);
95      raxNode *node = rax_malloc(nodesize);
96      if (node == NULL) return NULL;
97      node->iskey = 0;
98      node->isnull = 0;
99      node->iscompr = 0;
100      node->size = children;
101      return node;
102  }
103  rax *raxNew(void) {
104      rax *rax = rax_malloc(sizeof(*rax));
105      if (rax == NULL) return NULL;
106      rax->numele = 0;
107      rax->numnodes = 1;
108      rax->head = raxNewNode(0,0);
109      if (rax->head == NULL) {
110          rax_free(rax);
111          return NULL;
112      } else {
113          return rax;
114      }
115  }
116  raxNode *raxReallocForData(raxNode *n, void *data) {
117      if (data == NULL) return n; &bsol;* No reallocation needed, setting isnull=1 */
118      size_t curlen = raxNodeCurrentLength(n);
119      return rax_realloc(n,curlen+sizeof(void*));
120  }
121  void raxSetData(raxNode *n, void *data) {
122      n->iskey = 1;
123      if (data != NULL) {
124          n->isnull = 0;
125          void **ndata = (void**)
126              ((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
127          memcpy(ndata,&data,sizeof(data));
128      } else {
129          n->isnull = 1;
130      }
131  }
132  void *raxGetData(raxNode *n) {
133      if (n->isnull) return NULL;
134      void **ndata =(void**)((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
135      void *data;
136      memcpy(&data,ndata,sizeof(data));
137      return data;
138  }
139  raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode ***parentlink) {
140      assert(n->iscompr == 0);
141      size_t curlen = raxNodeCurrentLength(n);
142      n->size++;
143      size_t newlen = raxNodeCurrentLength(n);
144      n->size--; &bsol;* For now restore the orignal size. We'll update it only on
145                    success at the end. */
146      raxNode *child = raxNewNode(0,0);
147      if (child == NULL) return NULL;
148      raxNode *newn = rax_realloc(n,newlen);
149      if (newn == NULL) {
150          rax_free(child);
151          return NULL;
152      }
153      n = newn;
154      int pos;
155      for (pos = 0; pos < n->size; pos++) {
156          if (n->data[pos] > c) break;
157      }
158      unsigned char *src, *dst;
159      if (n->iskey && !n->isnull) {
160          src = ((unsigned char*)n+curlen-sizeof(void*));
161          dst = ((unsigned char*)n+newlen-sizeof(void*));
162          memmove(dst,src,sizeof(void*));
163      }
164      size_t shift = newlen - curlen - sizeof(void*);
165      src = n->data+n->size+
166            raxPadding(n->size)+
167            sizeof(raxNode*)*pos;
168      memmove(src+shift+sizeof(raxNode*),src,sizeof(raxNode*)*(n->size-pos));
169      if (shift) {
170          src = (unsigned char*) raxNodeFirstChildPtr(n);
171          memmove(src+shift,src,sizeof(raxNode*)*pos);
172      }
173      src = n->data+pos;
174      memmove(src+1,src,n->size-pos);
175      n->data[pos] = c;
176      n->size++;
177      src = (unsigned char*) raxNodeFirstChildPtr(n);
178      raxNode **childfield = (raxNode**)(src+sizeof(raxNode*)*pos);
179      memcpy(childfield,&child,sizeof(child));
180      *childptr = child;
181      *parentlink = childfield;
182      return n;
183  }
184  raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **child) {
185      assert(n->size == 0 && n->iscompr == 0);
186      void *data = NULL; &bsol;* Initialized only to avoid warnings. */
187      size_t newsize;
188      debugf("Compress node: %.*s\n", (int)len,s);
189      *child = raxNewNode(0,0);
190      if (*child == NULL) return NULL;
191      newsize = sizeof(raxNode)+len+raxPadding(len)+sizeof(raxNode*);
192      if (n->iskey) {
193          data = raxGetData(n); &bsol;* To restore it later. */
194          if (!n->isnull) newsize += sizeof(void*);
195      }
196      raxNode *newn = rax_realloc(n,newsize);
197      if (newn == NULL) {
198          rax_free(*child);
199          return NULL;
200      }
201      n = newn;
202      n->iscompr = 1;
203      n->size = len;
204      memcpy(n->data,s,len);
205      if (n->iskey) raxSetData(n,data);
206      raxNode **childfield = raxNodeLastChildPtr(n);
207      memcpy(childfield,child,sizeof(*child));
208      return n;
209  }
210  static inline size_t raxLowWalk(rax *rax, unsigned char *s, size_t len, raxNode **stopnode, raxNode ***plink, int *splitpos, raxStack *ts) {
211      raxNode *h = rax->head;
212      raxNode **parentlink = &rax->head;
213      size_t i = 0; &bsol;* Position in the string. */
214      size_t j = 0; &bsol;* Position in the node children (or bytes if compressed).*/
215      while(h->size && i < len) {
216          debugnode("Lookup current node",h);
217          unsigned char *v = h->data;
218          if (h->iscompr) {
219              for (j = 0; j < h->size && i < len; j++, i++) {
220                  if (v[j] != s[i]) break;
221              }
222              if (j != h->size) break;
223          } else {
224              for (j = 0; j < h->size; j++) {
225                  if (v[j] == s[i]) break;
226              }
227              if (j == h->size) break;
228              i++;
229          }
230          if (ts) raxStackPush(ts,h); &bsol;* Save stack of parent nodes. */
231          raxNode **children = raxNodeFirstChildPtr(h);
232          if (h->iscompr) j = 0; &bsol;* Compressed node only child is at index 0. */
233          memcpy(&h,children+j,sizeof(h));
234          parentlink = children+j;
235          j = 0; &bsol;* If the new node is compressed and we do not
236                    iterate again (since i == l) set the split
237                    position to 0 to signal this node represents
238                    the searched key. */
239      }
240      debugnode("Lookup stop node is",h);
241      if (stopnode) *stopnode = h;
242      if (plink) *plink = parentlink;
243      if (splitpos && h->iscompr) *splitpos = j;
244      return i;
245  }
246  int raxGenericInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old, int overwrite) {
247      size_t i;
248      int j = 0; &bsol;* Split position. If raxLowWalk() stops in a compressed
249                    node, the index 'j' represents the char we stopped within the
250                    compressed node, that is, the position where to split the
251                    node for insertion. */
252      raxNode *h, **parentlink;
253      debugf("### Insert %.*s with value %p\n", (int)len, s, data);
254      i = raxLowWalk(rax,s,len,&h,&parentlink,&j,NULL);
255      if (i == len && (!h->iscompr || j == 0 &bsol;* not in the middle if j is 0 */)) {
256          debugf("### Insert: node representing key exists\n");
257          if (!h->iskey || (h->isnull && overwrite)) {
258              h = raxReallocForData(h,data);
259              if (h) memcpy(parentlink,&h,sizeof(h));
260          }
261          if (h == NULL) {
262              errno = ENOMEM;
263              return 0;
264          }
265          if (h->iskey) {
266              if (old) *old = raxGetData(h);
267              if (overwrite) raxSetData(h,data);
268              errno = 0;
269              return 0; &bsol;* Element already exists. */
270          }
271          raxSetData(h,data);
272          rax->numele++;
273          return 1; &bsol;* Element inserted. */
274      }
275      if (h->iscompr && i != len) {
276          debugf("ALGO 1: Stopped at compressed node %.*s (%p)\n",
277              h->size, h->data, (void*)h);
278          debugf("Still to insert: %.*s\n", (int)(len-i), s+i);
279          debugf("Splitting at %d: '%c'\n", j, ((char*)h->data)[j]);
280          debugf("Other (key) letter is '%c'\n", s[i]);
281          raxNode **childfield = raxNodeLastChildPtr(h);
282          raxNode *next;
283          memcpy(&next,childfield,sizeof(next));
284          debugf("Next is %p\n", (void*)next);
285          debugf("iskey %d\n", h->iskey);
286          if (h->iskey) {
287              debugf("key value is %p\n", raxGetData(h));
288          }
289          size_t trimmedlen = j;
290          size_t postfixlen = h->size - j - 1;
291          int split_node_is_key = !trimmedlen && h->iskey && !h->isnull;
292          size_t nodesize;
293          raxNode *splitnode = raxNewNode(1, split_node_is_key);
294          raxNode *trimmed = NULL;
295          raxNode *postfix = NULL;
296          if (trimmedlen) {
297              nodesize = sizeof(raxNode)+trimmedlen+raxPadding(trimmedlen)+
298                         sizeof(raxNode*);
299              if (h->iskey && !h->isnull) nodesize += sizeof(void*);
300              trimmed = rax_malloc(nodesize);
301          }
302          if (postfixlen) {
303              nodesize = sizeof(raxNode)+postfixlen+raxPadding(postfixlen)+
304                         sizeof(raxNode*);
305              postfix = rax_malloc(nodesize);
306          }
307          if (splitnode == NULL ||
308              (trimmedlen && trimmed == NULL) ||
309              (postfixlen && postfix == NULL))
310          {
311              rax_free(splitnode);
312              rax_free(trimmed);
313              rax_free(postfix);
314              errno = ENOMEM;
315              return 0;
316          }
317          splitnode->data[0] = h->data[j];
318          if (j == 0) {
319              if (h->iskey) {
320                  void *ndata = raxGetData(h);
321                  raxSetData(splitnode,ndata);
322              }
323              memcpy(parentlink,&splitnode,sizeof(splitnode));
324          } else {
325              trimmed->size = j;
326              memcpy(trimmed->data,h->data,j);
327              trimmed->iscompr = j > 1 ? 1 : 0;
328              trimmed->iskey = h->iskey;
329              trimmed->isnull = h->isnull;
330              if (h->iskey && !h->isnull) {
331                  void *ndata = raxGetData(h);
332                  raxSetData(trimmed,ndata);
333              }
334              raxNode **cp = raxNodeLastChildPtr(trimmed);
335              memcpy(cp,&splitnode,sizeof(splitnode));
336              memcpy(parentlink,&trimmed,sizeof(trimmed));
337              parentlink = cp; &bsol;* Set parentlink to splitnode parent. */
338              rax->numnodes++;
339          }
340          if (postfixlen) {
341              postfix->iskey = 0;
342              postfix->isnull = 0;
343              postfix->size = postfixlen;
344              postfix->iscompr = postfixlen > 1;
345              memcpy(postfix->data,h->data+j+1,postfixlen);
346              raxNode **cp = raxNodeLastChildPtr(postfix);
347              memcpy(cp,&next,sizeof(next));
348              rax->numnodes++;
349          } else {
350              postfix = next;
351          }
352          raxNode **splitchild = raxNodeLastChildPtr(splitnode);
353          memcpy(splitchild,&postfix,sizeof(postfix));
354          rax_free(h);
355          h = splitnode;
356      } else if (h->iscompr && i == len) {
357          debugf("ALGO 2: Stopped at compressed node %.*s (%p) j = %d\n",
358              h->size, h->data, (void*)h, j);
359          size_t postfixlen = h->size - j;
360          size_t nodesize = sizeof(raxNode)+postfixlen+raxPadding(postfixlen)+
361                            sizeof(raxNode*);
362          if (data != NULL) nodesize += sizeof(void*);
363          raxNode *postfix = rax_malloc(nodesize);
364          nodesize = sizeof(raxNode)+j+raxPadding(j)+sizeof(raxNode*);
365          if (h->iskey && !h->isnull) nodesize += sizeof(void*);
366          raxNode *trimmed = rax_malloc(nodesize);
367          if (postfix == NULL || trimmed == NULL) {
368              rax_free(postfix);
369              rax_free(trimmed);
370              errno = ENOMEM;
371              return 0;
372          }
373          raxNode **childfield = raxNodeLastChildPtr(h);
374          raxNode *next;
375          memcpy(&next,childfield,sizeof(next));
376          postfix->size = postfixlen;
377          postfix->iscompr = postfixlen > 1;
378          postfix->iskey = 1;
379          postfix->isnull = 0;
380          memcpy(postfix->data,h->data+j,postfixlen);
381          raxSetData(postfix,data);
382          raxNode **cp = raxNodeLastChildPtr(postfix);
383          memcpy(cp,&next,sizeof(next));
384          rax->numnodes++;
385          trimmed->size = j;
386          trimmed->iscompr = j > 1;
387          trimmed->iskey = 0;
388          trimmed->isnull = 0;
389          memcpy(trimmed->data,h->data,j);
390          memcpy(parentlink,&trimmed,sizeof(trimmed));
391          if (h->iskey) {
392              void *aux = raxGetData(h);
393              raxSetData(trimmed,aux);
394          }
395          cp = raxNodeLastChildPtr(trimmed);
396          memcpy(cp,&postfix,sizeof(postfix));
397          rax->numele++;
398          rax_free(h);
399          return 1; &bsol;* Key inserted. */
400      }
401      while(i < len) {
402          raxNode *child;
403          if (h->size == 0 && len-i > 1) {
404              debugf("Inserting compressed node\n");
405              size_t comprsize = len-i;
406              if (comprsize > RAX_NODE_MAX_SIZE)
407                  comprsize = RAX_NODE_MAX_SIZE;
408              raxNode *newh = raxCompressNode(h,s+i,comprsize,&child);
409              if (newh == NULL) goto oom;
410              h = newh;
411              memcpy(parentlink,&h,sizeof(h));
412              parentlink = raxNodeLastChildPtr(h);
413              i += comprsize;
414          } else {
415              debugf("Inserting normal node\n");
416              raxNode **new_parentlink;
417              raxNode *newh = raxAddChild(h,s[i],&child,&new_parentlink);
418              if (newh == NULL) goto oom;
419              h = newh;
420              memcpy(parentlink,&h,sizeof(h));
421              parentlink = new_parentlink;
422              i++;
423          }
424          rax->numnodes++;
425          h = child;
426      }
427      raxNode *newh = raxReallocForData(h,data);
428      if (newh == NULL) goto oom;
429      h = newh;
430      if (!h->iskey) rax->numele++;
431      raxSetData(h,data);
432      memcpy(parentlink,&h,sizeof(h));
433      return 1; &bsol;* Element inserted. */
434  oom:
435      if (h->size == 0) {
436          h->isnull = 1;
437          h->iskey = 1;
438          rax->numele++; &bsol;* Compensate the next remove. */
439          assert(raxRemove(rax,s,i,NULL) != 0);
440      }
441      errno = ENOMEM;
442      return 0;
443  }
444  int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
445      return raxGenericInsert(rax,s,len,data,old,1);
446  }
447  int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
448      return raxGenericInsert(rax,s,len,data,old,0);
449  }
450  void *raxFind(rax *rax, unsigned char *s, size_t len) {
451      raxNode *h;
452      debugf("### Lookup: %.*s\n", (int)len, s);
453      int splitpos = 0;
454      size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,NULL);
455      if (i != len || (h->iscompr && splitpos != 0) || !h->iskey)
456          return raxNotFound;
457      return raxGetData(h);
458  }
459  raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {
460      raxNode **cp = raxNodeFirstChildPtr(parent);
461      raxNode *c;
462      while(1) {
463          memcpy(&c,cp,sizeof(c));
464          if (c == child) break;
465          cp++;
466      }
467      return cp;
468  }
469  raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
470      debugnode("raxRemoveChild before", parent);
471      if (parent->iscompr) {
472          void *data = NULL;
473          if (parent->iskey) data = raxGetData(parent);
474          parent->isnull = 0;
475          parent->iscompr = 0;
476          parent->size = 0;
477          if (parent->iskey) raxSetData(parent,data);
478          debugnode("raxRemoveChild after", parent);
479          return parent;
480      }
481      raxNode **cp = raxNodeFirstChildPtr(parent);
482      raxNode **c = cp;
483      unsigned char *e = parent->data;
484      while(1) {
485          raxNode *aux;
486          memcpy(&aux,c,sizeof(aux));
487          if (aux == child) break;
488          c++;
489          e++;
490      }
491      int taillen = parent->size - (e - parent->data) - 1;
492      debugf("raxRemoveChild tail len: %d\n", taillen);
493      memmove(e,e+1,taillen);
494      size_t shift = ((parent->size+4) % sizeof(void*)) == 1 ? sizeof(void*) : 0;
495      if (shift)
496          memmove(((char*)cp)-shift,cp,(parent->size-taillen-1)*sizeof(raxNode**));
497      size_t valuelen = (parent->iskey && !parent->isnull) ? sizeof(void*) : 0;
498      memmove(((char*)c)-shift,c+1,taillen*sizeof(raxNode**)+valuelen);
499      parent->size--;
500      raxNode *newnode = rax_realloc(parent,raxNodeCurrentLength(parent));
501      if (newnode) {
502          debugnode("raxRemoveChild after", newnode);
503      }
504      return newnode ? newnode : parent;
505  }
506  int raxRemove(rax *rax, unsigned char *s, size_t len, void **old) {
507      raxNode *h;
508      raxStack ts;
509      debugf("### Delete: %.*s\n", (int)len, s);
510      raxStackInit(&ts);
511      int splitpos = 0;
512      size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,&ts);
513      if (i != len || (h->iscompr && splitpos != 0) || !h->iskey) {
514          raxStackFree(&ts);
515          return 0;
516      }
517      if (old) *old = raxGetData(h);
518      h->iskey = 0;
519      rax->numele--;
520      int trycompress = 0; &bsol;* Will be set to 1 if we should try to optimize the
521                              tree resulting from the deletion. */
522      if (h->size == 0) {
523          debugf("Key deleted in node without children. Cleanup needed.\n");
524          raxNode *child = NULL;
525          while(h != rax->head) {
526              child = h;
527              debugf("Freeing child %p [%.*s] key:%d\n", (void*)child,
528                  (int)child->size, (char*)child->data, child->iskey);
529              rax_free(child);
530              rax->numnodes--;
531              h = raxStackPop(&ts);
532              if (h->iskey || (!h->iscompr && h->size != 1)) break;
533          }
534          if (child) {
535              debugf("Unlinking child %p from parent %p\n",
536                  (void*)child, (void*)h);
537              raxNode *new = raxRemoveChild(h,child);
538              if (new != h) {
539                  raxNode *parent = raxStackPeek(&ts);
540                  raxNode **parentlink;
541                  if (parent == NULL) {
542                      parentlink = &rax->head;
543                  } else {
544                      parentlink = raxFindParentLink(parent,h);
545                  }
546                  memcpy(parentlink,&new,sizeof(new));
547              }
548              if (new->size == 1 && new->iskey == 0) {
549                  trycompress = 1;
550                  h = new;
551              }
552          }
553      } else if (h->size == 1) {
554          trycompress = 1;
555      }
556      if (trycompress && ts.oom) trycompress = 0;
557      if (trycompress) {
558          debugf("After removing %.*s:\n", (int)len, s);
559          debugnode("Compression may be needed",h);
560          debugf("Seek start node\n");
561          raxNode *parent;
562          while(1) {
563              parent = raxStackPop(&ts);
564              if (!parent || parent->iskey ||
565                  (!parent->iscompr && parent->size != 1)) break;
566              h = parent;
567              debugnode("Going up to",h);
568          }
569          raxNode *start = h; &bsol;* Compression starting node. */
570          size_t comprsize = h->size;
571          int nodes = 1;
572          while(h->size != 0) {
573              raxNode **cp = raxNodeLastChildPtr(h);
574              memcpy(&h,cp,sizeof(h));
575              if (h->iskey || (!h->iscompr && h->size != 1)) break;
576              if (comprsize + h->size > RAX_NODE_MAX_SIZE) break;
577              nodes++;
578              comprsize += h->size;
579          }
580          if (nodes > 1) {
581              size_t nodesize =
582                  sizeof(raxNode)+comprsize+raxPadding(comprsize)+sizeof(raxNode*);
583              raxNode *new = rax_malloc(nodesize);
584              if (new == NULL) {
585                  raxStackFree(&ts);
586                  return 1;
587              }
588              new->iskey = 0;
589              new->isnull = 0;
590              new->iscompr = 1;
591              new->size = comprsize;
592              rax->numnodes++;
593              comprsize = 0;
594              h = start;
595              while(h->size != 0) {
596                  memcpy(new->data+comprsize,h->data,h->size);
597                  comprsize += h->size;
598                  raxNode **cp = raxNodeLastChildPtr(h);
599                  raxNode *tofree = h;
600                  memcpy(&h,cp,sizeof(h));
601                  rax_free(tofree); rax->numnodes--;
602                  if (h->iskey || (!h->iscompr && h->size != 1)) break;
603              }
604              debugnode("New node",new);
605              raxNode **cp = raxNodeLastChildPtr(new);
606              memcpy(cp,&h,sizeof(h));
607              if (parent) {
608                  raxNode **parentlink = raxFindParentLink(parent,start);
609                  memcpy(parentlink,&new,sizeof(new));
610              } else {
611                  rax->head = new;
612              }
613              debugf("Compressed %d nodes, %d total bytes\n",
614                  nodes, (int)comprsize);
615          }
616      }
617      raxStackFree(&ts);
618      return 1;
619  }
620  void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {
621      debugnode("free traversing",n);
622      int numchildren = n->iscompr ? 1 : n->size;
623      raxNode **cp = raxNodeLastChildPtr(n);
624      while(numchildren--) {
625          raxNode *child;
626          memcpy(&child,cp,sizeof(child));
627          raxRecursiveFree(rax,child,free_callback);
628          cp--;
629      }
630      debugnode("free depth-first",n);
631      if (free_callback && n->iskey && !n->isnull)
632          free_callback(raxGetData(n));
633      rax_free(n);
634      rax->numnodes--;
635  }
636  void raxFreeWithCallback(rax *rax, void (*free_callback)(void*)) {
637      raxRecursiveFree(rax,rax->head,free_callback);
638      assert(rax->numnodes == 0);
639      rax_free(rax);
640  }
641  void raxFree(rax *rax) {
642      raxFreeWithCallback(rax,NULL);
643  }
644  void raxStart(raxIterator *it, rax *rt) {
645      it->flags = RAX_ITER_EOF; &bsol;* No crash if the iterator is not seeked. */
646      it->rt = rt;
647      it->key_len = 0;
<span onclick='openModal()' class='match'>648      it->key = it->key_static_string;
649      it->key_max = RAX_ITER_STATIC_LEN;
650      it->data = NULL;
651      it->node_cb = NULL;
652      raxStackInit(&it->stack);
653  }
654  int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
</span>655      if (it->key_max < it->key_len+len) {
656          unsigned char *old = (it->key == it->key_static_string) ? NULL :
657                                                                    it->key;
658          size_t new_max = (it->key_len+len)*2;
659          it->key = rax_realloc(old,new_max);
660          if (it->key == NULL) {
661              it->key = (!old) ? it->key_static_string : old;
662              errno = ENOMEM;
663              return 0;
664          }
665          if (old == NULL) memcpy(it->key,it->key_static_string,it->key_len);
666          it->key_max = new_max;
667      }
668      memmove(it->key+it->key_len,s,len);
669      it->key_len += len;
670      return 1;
671  }
672  void raxIteratorDelChars(raxIterator *it, size_t count) {
673      it->key_len -= count;
674  }
675  int raxIteratorNextStep(raxIterator *it, int noup) {
676      if (it->flags & RAX_ITER_EOF) {
677          return 1;
678      } else if (it->flags & RAX_ITER_JUST_SEEKED) {
679          it->flags &= ~RAX_ITER_JUST_SEEKED;
680          return 1;
681      }
682      size_t orig_key_len = it->key_len;
683      size_t orig_stack_items = it->stack.items;
684      raxNode *orig_node = it->node;
685      while(1) {
686          int children = it->node->iscompr ? 1 : it->node->size;
687          if (!noup && children) {
688              debugf("GO DEEPER\n");
689              if (!raxStackPush(&it->stack,it->node)) return 0;
690              raxNode **cp = raxNodeFirstChildPtr(it->node);
691              if (!raxIteratorAddChars(it,it->node->data,
692                  it->node->iscompr ? it->node->size : 1)) return 0;
693              memcpy(&it->node,cp,sizeof(it->node));
694              if (it->node_cb && it->node_cb(&it->node))
695                  memcpy(cp,&it->node,sizeof(it->node));
696              if (it->node->iskey) {
697                  it->data = raxGetData(it->node);
698                  return 1;
699              }
700          } else {
701              while(1) {
702                  int old_noup = noup;
703                  if (!noup && it->node == it->rt->head) {
704                      it->flags |= RAX_ITER_EOF;
705                      it->stack.items = orig_stack_items;
706                      it->key_len = orig_key_len;
707                      it->node = orig_node;
708                      return 1;
709                  }
710                  unsigned char prevchild = it->key[it->key_len-1];
711                  if (!noup) {
712                      it->node = raxStackPop(&it->stack);
713                  } else {
714                      noup = 0;
715                  }
716                  int todel = it->node->iscompr ? it->node->size : 1;
717                  raxIteratorDelChars(it,todel);
718                  if (!it->node->iscompr && it->node->size > (old_noup ? 0 : 1)) {
719                      raxNode **cp = raxNodeFirstChildPtr(it->node);
720                      int i = 0;
721                      while (i < it->node->size) {
722                          debugf("SCAN NEXT %c\n", it->node->data[i]);
723                          if (it->node->data[i] > prevchild) break;
724                          i++;
725                          cp++;
726                      }
727                      if (i != it->node->size) {
728                          debugf("SCAN found a new node\n");
729                          raxIteratorAddChars(it,it->node->data+i,1);
730                          if (!raxStackPush(&it->stack,it->node)) return 0;
731                          memcpy(&it->node,cp,sizeof(it->node));
732                          if (it->node_cb && it->node_cb(&it->node))
733                              memcpy(cp,&it->node,sizeof(it->node));
734                          if (it->node->iskey) {
735                              it->data = raxGetData(it->node);
736                              return 1;
737                          }
738                          break;
739                      }
740                  }
741              }
742          }
743      }
744  }
745  int raxSeekGreatest(raxIterator *it) {
746      while(it->node->size) {
747          if (it->node->iscompr) {
748              if (!raxIteratorAddChars(it,it->node->data,
749                  it->node->size)) return 0;
750          } else {
751              if (!raxIteratorAddChars(it,it->node->data+it->node->size-1,1))
752                  return 0;
753          }
754          raxNode **cp = raxNodeLastChildPtr(it->node);
755          if (!raxStackPush(&it->stack,it->node)) return 0;
756          memcpy(&it->node,cp,sizeof(it->node));
757      }
758      return 1;
759  }
760  int raxIteratorPrevStep(raxIterator *it, int noup) {
761      if (it->flags & RAX_ITER_EOF) {
762          return 1;
763      } else if (it->flags & RAX_ITER_JUST_SEEKED) {
764          it->flags &= ~RAX_ITER_JUST_SEEKED;
765          return 1;
766      }
767      size_t orig_key_len = it->key_len;
768      size_t orig_stack_items = it->stack.items;
769      raxNode *orig_node = it->node;
770      while(1) {
771          int old_noup = noup;
772          if (!noup && it->node == it->rt->head) {
773              it->flags |= RAX_ITER_EOF;
774              it->stack.items = orig_stack_items;
775              it->key_len = orig_key_len;
776              it->node = orig_node;
777              return 1;
778          }
779          unsigned char prevchild = it->key[it->key_len-1];
780          if (!noup) {
781              it->node = raxStackPop(&it->stack);
782          } else {
783              noup = 0;
784          }
785          int todel = it->node->iscompr ? it->node->size : 1;
786          raxIteratorDelChars(it,todel);
787          if (!it->node->iscompr && it->node->size > (old_noup ? 0 : 1)) {
788              raxNode **cp = raxNodeLastChildPtr(it->node);
789              int i = it->node->size-1;
790              while (i >= 0) {
791                  debugf("SCAN PREV %c\n", it->node->data[i]);
792                  if (it->node->data[i] < prevchild) break;
793                  i--;
794                  cp--;
795              }
796              if (i != -1) {
797                  debugf("SCAN found a new node\n");
798                  if (!raxIteratorAddChars(it,it->node->data+i,1)) return 0;
799                  if (!raxStackPush(&it->stack,it->node)) return 0;
800                  memcpy(&it->node,cp,sizeof(it->node));
801                  if (!raxSeekGreatest(it)) return 0;
802              }
803          }
804          if (it->node->iskey) {
805              it->data = raxGetData(it->node);
806              return 1;
807          }
808      }
809  }
810  int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len) {
811      int eq = 0, lt = 0, gt = 0, first = 0, last = 0;
812      it->stack.items = 0; &bsol;* Just resetting. Intialized by raxStart(). */
813      it->flags |= RAX_ITER_JUST_SEEKED;
814      it->flags &= ~RAX_ITER_EOF;
815      it->key_len = 0;
816      it->node = NULL;
817      if (op[0] == '>') {
818          gt = 1;
819          if (op[1] == '=') eq = 1;
820      } else if (op[0] == '<') {
821          lt = 1;
822          if (op[1] == '=') eq = 1;
823      } else if (op[0] == '=') {
824          eq = 1;
825      } else if (op[0] == '^') {
826          first = 1;
827      } else if (op[0] == '$') {
828          last = 1;
829      } else {
830          errno = 0;
831          return 0; &bsol;* Error. */
832      }
833      if (it->rt->numele == 0) {
834          it->flags |= RAX_ITER_EOF;
835          return 1;
836      }
837      if (first) {
838          return raxSeek(it,">=",NULL,0);
839      }
840      if (last) {
841          it->node = it->rt->head;
842          if (!raxSeekGreatest(it)) return 0;
843          assert(it->node->iskey);
844          it->data = raxGetData(it->node);
845          return 1;
846      }
847      int splitpos = 0;
848      size_t i = raxLowWalk(it->rt,ele,len,&it->node,NULL,&splitpos,&it->stack);
849      if (it->stack.oom) return 0;
850      if (eq && i == len && (!it->node->iscompr || splitpos == 0) &&
851          it->node->iskey)
852      {
853          if (!raxIteratorAddChars(it,ele,len)) return 0; &bsol;* OOM. */
854          it->data = raxGetData(it->node);
855      } else if (lt || gt) {
856          if (!raxStackPush(&it->stack,it->node)) return 0;
857          for (size_t j = 1; j < it->stack.items; j++) {
858              raxNode *parent = it->stack.stack[j-1];
859              raxNode *child = it->stack.stack[j];
860              if (parent->iscompr) {
861                  if (!raxIteratorAddChars(it,parent->data,parent->size))
862                      return 0;
863              } else {
864                  raxNode **cp = raxNodeFirstChildPtr(parent);
865                  unsigned char *p = parent->data;
866                  while(1) {
867                      raxNode *aux;
868                      memcpy(&aux,cp,sizeof(aux));
869                      if (aux == child) break;
870                      cp++;
871                      p++;
872                  }
873                  if (!raxIteratorAddChars(it,p,1)) return 0;
874              }
875          }
876          raxStackPop(&it->stack);
877          debugf("After initial seek: i=%d len=%d key=%.*s\n",
878              (int)i, (int)len, (int)it->key_len, it->key);
879          if (i != len && !it->node->iscompr) {
880              if (!raxIteratorAddChars(it,ele+i,1)) return 0;
881              debugf("Seek normal node on mismatch: %.*s\n",
882                  (int)it->key_len, (char*)it->key);
883              it->flags &= ~RAX_ITER_JUST_SEEKED;
884              if (lt && !raxIteratorPrevStep(it,1)) return 0;
885              if (gt && !raxIteratorNextStep(it,1)) return 0;
886              it->flags |= RAX_ITER_JUST_SEEKED; &bsol;* Ignore next call. */
887          } else if (i != len && it->node->iscompr) {
888              debugf("Compressed mismatch: %.*s\n",
889                  (int)it->key_len, (char*)it->key);
890              int nodechar = it->node->data[splitpos];
891              int keychar = ele[i];
892              it->flags &= ~RAX_ITER_JUST_SEEKED;
893              if (gt) {
894                  if (nodechar > keychar) {
895                      if (!raxIteratorNextStep(it,0)) return 0;
896                  } else {
897                      if (!raxIteratorAddChars(it,it->node->data,it->node->size))
898                          return 0;
899                      if (!raxIteratorNextStep(it,1)) return 0;
900                  }
901              }
902              if (lt) {
903                  if (nodechar < keychar) {
904                      if (!raxSeekGreatest(it)) return 0;
905                      it->data = raxGetData(it->node);
906                  } else {
907                      if (!raxIteratorAddChars(it,it->node->data,it->node->size))
908                          return 0;
909                      if (!raxIteratorPrevStep(it,1)) return 0;
910                  }
911              }
912              it->flags |= RAX_ITER_JUST_SEEKED; &bsol;* Ignore next call. */
913          } else {
914              debugf("No mismatch: %.*s\n",
915                  (int)it->key_len, (char*)it->key);
916              it->flags &= ~RAX_ITER_JUST_SEEKED;
917              if (it->node->iscompr && it->node->iskey && splitpos && lt) {
918              } else {
919                  if (gt && !raxIteratorNextStep(it,0)) return 0;
920                  if (lt && !raxIteratorPrevStep(it,0)) return 0;
921              }
922              it->flags |= RAX_ITER_JUST_SEEKED; &bsol;* Ignore next call. */
923          }
924      } else {
925          it->flags |= RAX_ITER_EOF;
926          return 1;
927      }
928      return 1;
929  }
930  int raxNext(raxIterator *it) {
931      if (!raxIteratorNextStep(it,0)) {
932          errno = ENOMEM;
933          return 0;
934      }
935      if (it->flags & RAX_ITER_EOF) {
936          errno = 0;
937          return 0;
938      }
939      return 1;
940  }
941  int raxPrev(raxIterator *it) {
942      if (!raxIteratorPrevStep(it,0)) {
943          errno = ENOMEM;
944          return 0;
945      }
946      if (it->flags & RAX_ITER_EOF) {
947          errno = 0;
948          return 0;
949      }
950      return 1;
951  }
952  int raxRandomWalk(raxIterator *it, size_t steps) {
953      if (it->rt->numele == 0) {
954          it->flags |= RAX_ITER_EOF;
955          return 0;
956      }
957      if (steps == 0) {
958          size_t fle = floor(log(it->rt->numele));
959          fle *= 2;
960          steps = 1 + rand() % fle;
961      }
962      raxNode *n = it->node;
963      while(steps > 0 || !n->iskey) {
964          int numchildren = n->iscompr ? 1 : n->size;
965          int r = rand() % (numchildren+(n != it->rt->head));
966          if (r == numchildren) {
967              n = raxStackPop(&it->stack);
968              int todel = n->iscompr ? n->size : 1;
969              raxIteratorDelChars(it,todel);
970          } else {
971              if (n->iscompr) {
972                  if (!raxIteratorAddChars(it,n->data,n->size)) return 0;
973              } else {
974                  if (!raxIteratorAddChars(it,n->data+r,1)) return 0;
975              }
976              raxNode **cp = raxNodeFirstChildPtr(n)+r;
977              if (!raxStackPush(&it->stack,n)) return 0;
978              memcpy(&n,cp,sizeof(n));
979          }
980          if (n->iskey) steps--;
981      }
982      it->node = n;
983      return 1;
984  }
985  int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key_len) {
986      int eq = 0, lt = 0, gt = 0;
987      if (op[0] == '=' || op[1] == '=') eq = 1;
988      if (op[0] == '>') gt = 1;
989      else if (op[0] == '<') lt = 1;
990      else if (op[1] != '=') return 0; &bsol;* Syntax error. */
991      size_t minlen = key_len < iter->key_len ? key_len : iter->key_len;
992      int cmp = memcmp(iter->key,key,minlen);
993      if (lt == 0 && gt == 0) return cmp == 0 && key_len == iter->key_len;
994      if (cmp == 0) {
995          if (eq && key_len == iter->key_len) return 1;
996          else if (lt) return iter->key_len < key_len;
997          else if (gt) return iter->key_len > key_len;
998      } if (cmp > 0) {
999          return gt ? 1 : 0;
1000      } else &bsol;* (cmp < 0) */ {
1001          return lt ? 1 : 0;
1002      }
1003  }
1004  void raxStop(raxIterator *it) {
1005      if (it->key != it->key_static_string) rax_free(it->key);
1006      raxStackFree(&it->stack);
1007  }
1008  int raxEOF(raxIterator *it) {
1009      return it->flags & RAX_ITER_EOF;
1010  }
1011  uint64_t raxSize(rax *rax) {
1012      return rax->numele;
1013  }
1014  void raxRecursiveShow(int level, int lpad, raxNode *n) {
1015      char s = n->iscompr ? '"' : '[';
1016      char e = n->iscompr ? '"' : ']';
1017      int numchars = printf("%c%.*s%c", s, n->size, n->data, e);
1018      if (n->iskey) {
1019          numchars += printf("=%p",raxGetData(n));
1020      }
1021      int numchildren = n->iscompr ? 1 : n->size;
1022      if (level) {
1023          lpad += (numchildren > 1) ? 7 : 4;
1024          if (numchildren == 1) lpad += numchars;
1025      }
1026      raxNode **cp = raxNodeFirstChildPtr(n);
1027      for (int i = 0; i < numchildren; i++) {
1028          char *branch = " `-(%c) ";
1029          if (numchildren > 1) {
1030              printf("\n");
1031              for (int j = 0; j < lpad; j++) putchar(' ');
1032              printf(branch,n->data[i]);
1033          } else {
1034              printf(" -> ");
1035          }
1036          raxNode *child;
1037          memcpy(&child,cp,sizeof(child));
1038          raxRecursiveShow(level+1,lpad,child);
1039          cp++;
1040      }
1041  }
1042  void raxShow(rax *rax) {
1043      raxRecursiveShow(0,0,rax->head);
1044      putchar('\n');
1045  }
1046  void raxDebugShowNode(const char *msg, raxNode *n) {
1047      if (raxDebugMsg == 0) return;
1048      printf("%s: %p [%.*s] key:%d size:%d children:",
1049          msg, (void*)n, (int)n->size, (char*)n->data, n->iskey, n->size);
1050      int numcld = n->iscompr ? 1 : n->size;
1051      raxNode **cldptr = raxNodeLastChildPtr(n) - (numcld-1);
1052      while(numcld--) {
1053          raxNode *child;
1054          memcpy(&child,cldptr,sizeof(child));
1055          cldptr++;
1056          printf("%p ", (void*)child);
1057      }
1058      printf("\n");
1059      fflush(stdout);
1060  }
1061  PORT_ULONG raxTouch(raxNode *n) {
1062      debugf("Touching %p\n", (void*)n);
1063      PORT_ULONG sum = 0;
1064      if (n->iskey) {
1065          sum += (PORT_ULONG)raxGetData(n);
1066      }
1067      int numchildren = n->iscompr ? 1 : n->size;
1068      raxNode **cp = raxNodeFirstChildPtr(n);
1069      int count = 0;
1070      for (int i = 0; i < numchildren; i++) {
1071          if (numchildren > 1) {
1072              sum += (PORT_LONG)n->data[i];
1073          }
1074          raxNode *child;
1075          memcpy(&child,cp,sizeof(child));
1076          if (child == (void*)0x65d1760) count++;
1077          if (count > 1) exit(1);
1078          sum += raxTouch(child);
1079          cp++;
1080      }
1081      return sum;
1082  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-api.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rax.c</div>
                </div>
                <div class="column column_space"><pre><code>75    parser->type = type;
76    parser->settings = (void*) settings;
77    parser->data = data;
78    parser->lenient_flags = lenient_flags;
79  }
80  llhttp_errno_t llhttp_execute(llhttp_t* parser, const char* data, size_t len) {
</pre></code></div>
                <div class="column column_space"><pre><code>648      it->key = it->key_static_string;
649      it->key_max = RAX_ITER_STATIC_LEN;
650      it->data = NULL;
651      it->node_cb = NULL;
652      raxStackInit(&it->stack);
653  }
654  int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    