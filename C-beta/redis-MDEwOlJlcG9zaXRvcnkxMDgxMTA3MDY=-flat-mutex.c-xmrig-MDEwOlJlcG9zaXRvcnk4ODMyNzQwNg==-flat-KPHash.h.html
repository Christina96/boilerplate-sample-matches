
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 68.29268292682927%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mutex.c</h3>
            <pre><code>1  #define JEMALLOC_MUTEX_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/assert.h"
5  #include "jemalloc/internal/malloc_io.h"
6  #include "jemalloc/internal/spin.h"
7  #ifndef _CRT_SPINCOUNT
8  #define _CRT_SPINCOUNT 4000
9  #endif
10  #ifdef JEMALLOC_LAZY_LOCK
<span onclick='openModal()' class='match'>11  bool isthreaded = false;
12  #endif
13  #ifdef JEMALLOC_MUTEX_INIT_CB
14  static bool		postpone_init = true;
15  static malloc_mutex_t	*postponed_mutexes = NULL;
16  #endif
17  #if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)
18  JEMALLOC_EXPORT int
19  pthread_create(pthread_t *__restrict thread,
20      const pthread_attr_t *__restrict attr, void *(*start_routine)(void *),
21      void *__restrict arg) {
22  	return pthread_create_wrapper(thread, attr, start_routine, arg);
</span>23  }
24  #endif
25  #ifdef JEMALLOC_MUTEX_INIT_CB
26  JEMALLOC_EXPORT int	_pthread_mutex_init_calloc_cb(pthread_mutex_t *mutex,
27      void *(calloc_cb)(size_t, size_t));
28  #endif
29  void
30  malloc_mutex_lock_slow(malloc_mutex_t *mutex) {
31  	mutex_prof_data_t *data = &mutex->prof_data;
32  	nstime_t before = NSTIME_ZERO_INITIALIZER;
33  	if (ncpus == 1) {
34  		goto label_spin_done;
35  	}
36  	int cnt = 0, max_cnt = MALLOC_MUTEX_MAX_SPIN;
37  	do {
38  		spin_cpu_spinwait();
39  		if (!atomic_load_b(&mutex->locked, ATOMIC_RELAXED)
40                      && !malloc_mutex_trylock_final(mutex)) {
41  			data->n_spin_acquired++;
42  			return;
43  		}
44  	} while (cnt++ < max_cnt);
45  	if (!config_stats) {
46  		malloc_mutex_lock_final(mutex);
47  		return;
48  	}
49  label_spin_done:
50  	nstime_update(&before);
51  	nstime_t after;
52  	nstime_copy(&after, &before);
53  	uint32_t n_thds = atomic_fetch_add_u32(&data->n_waiting_thds, 1,
54  	    ATOMIC_RELAXED) + 1;
55  	if (!malloc_mutex_trylock_final(mutex)) {
56  		atomic_fetch_sub_u32(&data->n_waiting_thds, 1, ATOMIC_RELAXED);
57  		data->n_spin_acquired++;
58  		return;
59  	}
60  	malloc_mutex_lock_final(mutex);
61  	atomic_fetch_sub_u32(&data->n_waiting_thds, 1, ATOMIC_RELAXED);
62  	nstime_update(&after);
63  	nstime_t delta;
64  	nstime_copy(&delta, &after);
65  	nstime_subtract(&delta, &before);
66  	data->n_wait_times++;
67  	nstime_add(&data->tot_wait_time, &delta);
68  	if (nstime_compare(&data->max_wait_time, &delta) < 0) {
69  		nstime_copy(&data->max_wait_time, &delta);
70  	}
71  	if (n_thds > data->max_n_thds) {
72  		data->max_n_thds = n_thds;
73  	}
74  }
75  static void
76  mutex_prof_data_init(mutex_prof_data_t *data) {
77  	memset(data, 0, sizeof(mutex_prof_data_t));
78  	nstime_init(&data->max_wait_time, 0);
79  	nstime_init(&data->tot_wait_time, 0);
80  	data->prev_owner = NULL;
81  }
82  void
83  malloc_mutex_prof_data_reset(tsdn_t *tsdn, malloc_mutex_t *mutex) {
84  	malloc_mutex_assert_owner(tsdn, mutex);
85  	mutex_prof_data_init(&mutex->prof_data);
86  }
87  static int
88  mutex_addr_comp(const witness_t *witness1, void *mutex1,
89      const witness_t *witness2, void *mutex2) {
90  	assert(mutex1 != NULL);
91  	assert(mutex2 != NULL);
92  	uintptr_t mu1int = (uintptr_t)mutex1;
93  	uintptr_t mu2int = (uintptr_t)mutex2;
94  	if (mu1int < mu2int) {
95  		return -1;
96  	} else if (mu1int == mu2int) {
97  		return 0;
98  	} else {
99  		return 1;
100  	}
101  }
102  bool
103  malloc_mutex_init(malloc_mutex_t *mutex, const char *name,
104      witness_rank_t rank, malloc_mutex_lock_order_t lock_order) {
105  	mutex_prof_data_init(&mutex->prof_data);
106  #ifdef _WIN32
107  #  if _WIN32_WINNT >= 0x0600
108  	InitializeSRWLock(&mutex->lock);
109  #  else
110  	if (!InitializeCriticalSectionAndSpinCount(&mutex->lock,
111  	    _CRT_SPINCOUNT)) {
112  		return true;
113  	}
114  #  endif
115  #elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
116         mutex->lock = OS_UNFAIR_LOCK_INIT;
117  #elif (defined(JEMALLOC_MUTEX_INIT_CB))
118  	if (postpone_init) {
119  		mutex->postponed_next = postponed_mutexes;
120  		postponed_mutexes = mutex;
121  	} else {
122  		if (_pthread_mutex_init_calloc_cb(&mutex->lock,
123  		    bootstrap_calloc) != 0) {
124  			return true;
125  		}
126  	}
127  #else
128  	pthread_mutexattr_t attr;
129  	if (pthread_mutexattr_init(&attr) != 0) {
130  		return true;
131  	}
132  	pthread_mutexattr_settype(&attr, MALLOC_MUTEX_TYPE);
133  	if (pthread_mutex_init(&mutex->lock, &attr) != 0) {
134  		pthread_mutexattr_destroy(&attr);
135  		return true;
136  	}
137  	pthread_mutexattr_destroy(&attr);
138  #endif
139  	if (config_debug) {
140  		mutex->lock_order = lock_order;
141  		if (lock_order == malloc_mutex_address_ordered) {
142  			witness_init(&mutex->witness, name, rank,
143  			    mutex_addr_comp, mutex);
144  		} else {
145  			witness_init(&mutex->witness, name, rank, NULL, NULL);
146  		}
147  	}
148  	return false;
149  }
150  void
151  malloc_mutex_prefork(tsdn_t *tsdn, malloc_mutex_t *mutex) {
152  	malloc_mutex_lock(tsdn, mutex);
153  }
154  void
155  malloc_mutex_postfork_parent(tsdn_t *tsdn, malloc_mutex_t *mutex) {
156  	malloc_mutex_unlock(tsdn, mutex);
157  }
158  void
159  malloc_mutex_postfork_child(tsdn_t *tsdn, malloc_mutex_t *mutex) {
160  #ifdef JEMALLOC_MUTEX_INIT_CB
161  	malloc_mutex_unlock(tsdn, mutex);
162  #else
163  	if (malloc_mutex_init(mutex, mutex->witness.name,
164  	    mutex->witness.rank, mutex->lock_order)) {
165  		malloc_printf("<jemalloc>: Error re-initializing mutex in "
166  		    "child\n");
167  		if (opt_abort) {
168  			abort();
169  		}
170  	}
171  #endif
172  }
173  bool
174  malloc_mutex_boot(void) {
175  #ifdef JEMALLOC_MUTEX_INIT_CB
176  	postpone_init = false;
177  	while (postponed_mutexes != NULL) {
178  		if (_pthread_mutex_init_calloc_cb(&postponed_mutexes->lock,
179  		    bootstrap_calloc) != 0) {
180  			return true;
181  		}
182  		postponed_mutexes = postponed_mutexes->postponed_next;
183  	}
184  #endif
185  	return false;
186  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-KPHash.h</h3>
            <pre><code>1  #ifndef XMRIG_KP_HASH_H
2  #define XMRIG_KP_HASH_H
3  #include <cstdint>
4  namespace xmrig
5  {
6  class KPCache;
7  class KPHash
8  {
9  public:
10      static constexpr uint32_t EPOCH_LENGTH  = 7500;
11      static constexpr uint32_t PERIOD_LENGTH = 3;
12      static constexpr int CNT_CACHE          = 11;
<span onclick='openModal()' class='match'>13      static constexpr int CNT_MATH           = 18;
14      static constexpr uint32_t REGS          = 32;
15      static constexpr uint32_t LANES         = 16;
16      static void calculate(const KPCache& light_cache, uint32_t block_height, const uint8_t (&header_hash)[32], uint64_t nonce, uint32_t (&output)[8], uint32_t (&mix_hash)[8]);
</span>17  };
18  } 
19  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mutex.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-KPHash.h</div>
                </div>
                <div class="column column_space"><pre><code>11  bool isthreaded = false;
12  #endif
13  #ifdef JEMALLOC_MUTEX_INIT_CB
14  static bool		postpone_init = true;
15  static malloc_mutex_t	*postponed_mutexes = NULL;
16  #endif
17  #if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)
18  JEMALLOC_EXPORT int
19  pthread_create(pthread_t *__restrict thread,
20      const pthread_attr_t *__restrict attr, void *(*start_routine)(void *),
21      void *__restrict arg) {
22  	return pthread_create_wrapper(thread, attr, start_routine, arg);
</pre></code></div>
                <div class="column column_space"><pre><code>13      static constexpr int CNT_MATH           = 18;
14      static constexpr uint32_t REGS          = 32;
15      static constexpr uint32_t LANES         = 16;
16      static void calculate(const KPCache& light_cache, uint32_t block_height, const uint8_t (&header_hash)[32], uint64_t nonce, uint32_t (&output)[8], uint32_t (&mix_hash)[8]);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    