
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.99307958477509%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeGLFunctions.h</h3>
            <pre><code>1  &bsol;*
2   * cgeGLFunctions.h
3   *
4   *  Created on: 2013-12-5
5   *      Author: Wang Yang
6   *        Mail: admin@wysaid.org
7   */
8  #ifndef _CGEGLFUNCTIONS_H_
9  #define _CGEGLFUNCTIONS_H_
10  #include "cgeCommonDefine.h"
11  #include <cassert>
12  #if defined(_CGE_DISABLE_GLOBALCONTEXT_) && _CGE_DISABLE_GLOBALCONTEXT_
13  #define CGE_ENABLE_GLOBAL_GLCONTEXT(...)
14  #define CGE_DISABLE_GLOBAL_GLCONTEXT(...)
15  #else
16  #define CGE_ENABLE_GLOBAL_GLCONTEXT(...) cgeEnableGlobalGLContext()
17  #define CGE_DISABLE_GLOBAL_GLCONTEXT(...) cgeDisableGlobalGLContext()
18  #endif
19  namespace CGE
20  {
21  #if !(defined(_CGE_DISABLE_GLOBALCONTEXT_) && _CGE_DISABLE_GLOBALCONTEXT_)
22  typedef bool (*CGEEnableGLContextFunction)(void*);
23  typedef bool (*CGEDisableGLContextFunction)(void*);
24  void cgeSetGLContextEnableFunction(CGEEnableGLContextFunction func, void* param);
25  void cgeSetGLContextDisableFunction(CGEDisableGLContextFunction func, void* param);
26  void* cgeGetGLEnableParam();
27  void* cgeGetGLDisableParam();
28  void cgeStopGlobalGLEnableFunction();
29  void cgeRestoreGlobalGLEnableFunction();
30  void cgeEnableGlobalGLContext();
31  void cgeDisableGlobalGLContext();
32  #endif
33  typedef void* (*CGEBufferLoadFun)(const char* sourceName, void** bufferData, GLint* w, GLint* h, CGEBufferFormat* fmt, void* arg);
34  typedef bool (*CGEBufferUnloadFun)(void* arg1, void* arg2);
35  typedef GLuint (*CGETextureLoadFun)(const char* sourceName, GLint* w, GLint* h, void* arg);
36  void cgeSetCommonLoadFunction(CGEBufferLoadFun fun, void* arg);
37  void cgeSetCommonUnloadFunction(CGEBufferUnloadFun fun, void* arg);
38  void* cgeLoadResourceCommon(const char* sourceName, void** bufferData, GLint* w, GLint* h, GLenum* format, GLenum* type);
39  CGEBufferLoadFun cgeGetCommonLoadFunc();
40  void* cgeGetCommonLoadArg();
41  bool cgeUnloadResourceCommon(void* bufferArg);
42  CGEBufferUnloadFun cgeGetCommonUnloadFunc();
43  void* cgeGetCommonUnloadArg();
44  char* cgeGetScaledBufferInSize(const void* buffer, int& w, int& h, int channel, int maxSizeX, int maxSizeY);
45  char* cgeGetScaledBufferOutofSize(const void* buffer, int& w, int& h, int channel, int minSizeX, int minSizeY);
46  inline GLint cgeGetMaxTextureSize()
47  {
48      GLint n;
49      glGetIntegerv(GL_MAX_TEXTURE_SIZE, &n);
50      return n - 1;
51  }
52  class FrameBuffer
53  {
54  public:
55      FrameBuffer() { glGenFramebuffers(1, &m_framebuffer); }
56      ~FrameBuffer() { glDeleteFramebuffers(1, &m_framebuffer); }
57      inline void bind() const { glBindFramebuffer(GL_FRAMEBUFFER, m_framebuffer); }
58      inline void bindTexture2D(GLuint texID, GLsizei w, GLsizei h, GLenum attachment = GL_COLOR_ATTACHMENT0) const
59      {
60          bindTexture2D(texID, 0, 0, w, h, attachment);
61      }
62      inline void bindTexture2D(GLuint texID, GLenum attachment = GL_COLOR_ATTACHMENT0) const
63      {
64          bind();
65          glFramebufferTexture2D(GL_FRAMEBUFFER, attachment, GL_TEXTURE_2D, texID, 0);
66          CGE_LOG_CODE(
67              GLenum code = glCheckFramebufferStatus(GL_FRAMEBUFFER);
68              if (code != GL_FRAMEBUFFER_COMPLETE) {
69                  CGE_LOG_ERROR("CGE::FrameBuffer::bindTexture2D - Frame buffer is not valid: %x\n", code);
70              })
71      }
72      inline void bindTexture2D(GLuint texID, GLsizei x, GLsizei y, GLsizei w, GLsizei h, GLenum attachment = GL_COLOR_ATTACHMENT0) const
73      {
74          bindTexture2D(texID, attachment);
75          glViewport(x, y, w, h);
76      }
77      inline GLuint fbo() { return m_framebuffer; }
78  protected:
79      GLuint m_framebuffer;
80  };
81  struct CGESizei
82  {
83      CGESizei() :
84          width(0), height(0) {}
85      CGESizei(int w, int h) :
86          width(w), height(h) {}
87      void set(int w, int h)
88      {
89          width = w;
90          height = h;
91      }
92      bool operator==(const CGESizei& other) const
93      {
94          return width == other.width && height == other.height;
95      }
96      bool operator!=(const CGESizei& other) const
97      {
98          return width != other.width || height != other.height;
99      }
100      GLint width;
101      GLint height;
102  };
103  struct CGESizef
104  {
105      CGESizef() :
106          width(0.0f), height(0.0f) {}
107      CGESizef(float w, float h) :
108          width(w), height(h) {}
109      void set(float w, float h)
110      {
111          width = w;
112          height = h;
113      }
114      GLfloat width;
115      GLfloat height;
116  };
117  struct TextureInfo
118  {
119      GLuint name{};
120      int width{}, height{};
121  };
122  class TextureObject
123  {
124  public:
125      virtual ~TextureObject();
126      explicit TextureObject(GLuint texture = 0, const CGESizei& size = CGESizei());
127      explicit TextureObject(const TextureObject&) = delete;
128      TextureObject(TextureObject&&) noexcept;
129      explicit TextureObject(TextureInfo&& t) :
130          m_texture(t.name), m_size(t.width, t.height) { t.name = 0; }
131      GLuint texture() const { return m_texture; }
132      GLint width() const { return m_size.width; }
133      GLint height() const { return m_size.height; }
134      CGESizei size() const { return m_size; }
135      void cleanup(bool deleteTexture = true);
136      bool resize(int w, int h, const void* buffer = nullptr, GLenum format = GL_RGBA);
137      inline bool updateTextureData(int w, int h, const void* buffer = nullptr, GLenum format = GL_RGBA)
138      {
139          return resize(w, h, buffer, format);
140      }
141      TextureObject& operator=(TextureObject&& t) noexcept;
142      TextureObject& operator=(TextureInfo&& t);
143  protected:
144      GLuint m_texture = 0;
145      CGESizei m_size;
146  };
147  class FrameBufferWithTexture : protected FrameBuffer, public TextureObject
148  {
149  public:
150      using FrameBuffer::FrameBuffer;
151      ~FrameBufferWithTexture() override;
152      GLuint renderbuffer() const { return m_renderBuffer; }
<span onclick='openModal()' class='match'>153      void bindTexture2D(GLsizei w, GLsizei h, const void* buffer = nullptr);
154      void attachDepthBuffer();
155      bool checkStatus();
156      using FrameBuffer::bind;
157      using FrameBuffer::fbo;
158  private:
159      using TextureObject::resize;
160      GLuint m_renderBuffer = 0;
</span>161  };
162  struct CGELuminance
163  {
164      enum
165      {
166          CalcPrecision = 16
167      };
168      enum
169      {
170          Weight = (1 << CalcPrecision)
171      };
172      enum
173      {
174          RWeight = int(0.299 * Weight),
175          GWeight = int(0.587 * Weight),
176          BWeight = int(0.114 * Weight)
177      };
178      static inline int RGB888(int r, int g, int b)
179      {
180          return (r * RWeight + g * GWeight + b * BWeight) >> CalcPrecision;
181      }
182      static inline int RGB565(unsigned short color)
183      {
184          const int r = (color & 31) << 3;
185          const int g = ((color >> 5) & 63) << 2;
186          const int b = ((color >> 11) & 31) << 3;
187          return RGB888(r, g, b);
188      }
189  };
190  } 
191  #include <ctime>
192  #include <memory>
193  #include <vector>
194  #include "cgeShaderFunctions.h"
195  #include "cgeImageFilter.h"
196  #include "cgeImageHandler.h"
197  #endif &bsol;* _CGEGLFUNCTIONS_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_mips32.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MIPS32)
3  #include "src/dsp/mips_macro.h"
4  #include "src/enc/vp8i_enc.h"
5  #include "src/enc/cost_enc.h"
6  static const int kC1 = 20091 + (1 << 16);
7  static const int kC2 = 35468;
8  #define VERTICAL_PASS(A, B, C, D, TEMP4, TEMP0, TEMP1, TEMP2, TEMP3)        \
9    "lh      %[temp16],      " #A "(%[temp20])                 \n\t"          \
10    "lh      %[temp18],      " #B "(%[temp20])                 \n\t"          \
11    "lh      %[temp17],      " #C "(%[temp20])                 \n\t"          \
12    "lh      %[temp19],      " #D "(%[temp20])                 \n\t"          \
13    "addu    %[" #TEMP4 "],    %[temp16],      %[temp18]       \n\t"          \
14    "subu    %[temp16],      %[temp16],      %[temp18]         \n\t"          \
15    "mul     %[" #TEMP0 "],    %[temp17],      %[kC2]          \n\t"          \
16    "mul     %[temp18],      %[temp19],      %[kC1]            \n\t"          \
17    "mul     %[temp17],      %[temp17],      %[kC1]            \n\t"          \
18    "mul     %[temp19],      %[temp19],      %[kC2]            \n\t"          \
19    "sra     %[" #TEMP0 "],    %[" #TEMP0 "],    16            \n\n"          \
20    "sra     %[temp18],      %[temp18],      16                \n\n"          \
21    "sra     %[temp17],      %[temp17],      16                \n\n"          \
22    "sra     %[temp19],      %[temp19],      16                \n\n"          \
23    "subu    %[" #TEMP2 "],    %[" #TEMP0 "],    %[temp18]     \n\t"          \
24    "addu    %[" #TEMP3 "],    %[temp17],      %[temp19]       \n\t"          \
25    "addu    %[" #TEMP0 "],    %[" #TEMP4 "],    %[" #TEMP3 "] \n\t"          \
26    "addu    %[" #TEMP1 "],    %[temp16],      %[" #TEMP2 "]   \n\t"          \
27    "subu    %[" #TEMP2 "],    %[temp16],      %[" #TEMP2 "]   \n\t"          \
28    "subu    %[" #TEMP3 "],    %[" #TEMP4 "],    %[" #TEMP3 "] \n\t"
29  #define HORIZONTAL_PASS(A, TEMP0, TEMP4, TEMP8, TEMP12)                       \
30    "addiu   %[" #TEMP0 "],    %[" #TEMP0 "],    4               \n\t"          \
31    "addu    %[temp16],      %[" #TEMP0 "],    %[" #TEMP8 "]     \n\t"          \
32    "subu    %[temp17],      %[" #TEMP0 "],    %[" #TEMP8 "]     \n\t"          \
33    "mul     %[" #TEMP0 "],    %[" #TEMP4 "],    %[kC2]          \n\t"          \
34    "mul     %[" #TEMP8 "],    %[" #TEMP12 "],   %[kC1]          \n\t"          \
35    "mul     %[" #TEMP4 "],    %[" #TEMP4 "],    %[kC1]          \n\t"          \
36    "mul     %[" #TEMP12 "],   %[" #TEMP12 "],   %[kC2]          \n\t"          \
37    "sra     %[" #TEMP0 "],    %[" #TEMP0 "],    16              \n\t"          \
38    "sra     %[" #TEMP8 "],    %[" #TEMP8 "],    16              \n\t"          \
39    "sra     %[" #TEMP4 "],    %[" #TEMP4 "],    16              \n\t"          \
40    "sra     %[" #TEMP12 "],   %[" #TEMP12 "],   16              \n\t"          \
41    "subu    %[temp18],      %[" #TEMP0 "],    %[" #TEMP8 "]     \n\t"          \
42    "addu    %[temp19],      %[" #TEMP4 "],    %[" #TEMP12 "]    \n\t"          \
43    "addu    %[" #TEMP0 "],    %[temp16],      %[temp19]         \n\t"          \
44    "addu    %[" #TEMP4 "],    %[temp17],      %[temp18]         \n\t"          \
45    "subu    %[" #TEMP8 "],    %[temp17],      %[temp18]         \n\t"          \
46    "subu    %[" #TEMP12 "],   %[temp16],      %[temp19]         \n\t"          \
47    "lw      %[temp20],      0(%[args])                          \n\t"          \
48    "sra     %[" #TEMP0 "],    %[" #TEMP0 "],    3               \n\t"          \
49    "sra     %[" #TEMP4 "],    %[" #TEMP4 "],    3               \n\t"          \
50    "sra     %[" #TEMP8 "],    %[" #TEMP8 "],    3               \n\t"          \
51    "sra     %[" #TEMP12 "],   %[" #TEMP12 "],   3               \n\t"          \
52    "lbu     %[temp16],      0+" XSTR(BPS) "*" #A "(%[temp20])   \n\t"          \
53    "lbu     %[temp17],      1+" XSTR(BPS) "*" #A "(%[temp20])   \n\t"          \
54    "lbu     %[temp18],      2+" XSTR(BPS) "*" #A "(%[temp20])   \n\t"          \
55    "lbu     %[temp19],      3+" XSTR(BPS) "*" #A "(%[temp20])   \n\t"          \
56    "addu    %[" #TEMP0 "],    %[temp16],      %[" #TEMP0 "]     \n\t"          \
57    "addu    %[" #TEMP4 "],    %[temp17],      %[" #TEMP4 "]     \n\t"          \
58    "addu    %[" #TEMP8 "],    %[temp18],      %[" #TEMP8 "]     \n\t"          \
59    "addu    %[" #TEMP12 "],   %[temp19],      %[" #TEMP12 "]    \n\t"          \
60    "slt     %[temp16],      %[" #TEMP0 "],    $zero             \n\t"          \
61    "slt     %[temp17],      %[" #TEMP4 "],    $zero             \n\t"          \
62    "slt     %[temp18],      %[" #TEMP8 "],    $zero             \n\t"          \
63    "slt     %[temp19],      %[" #TEMP12 "],   $zero             \n\t"          \
64    "movn    %[" #TEMP0 "],    $zero,          %[temp16]         \n\t"          \
65    "movn    %[" #TEMP4 "],    $zero,          %[temp17]         \n\t"          \
66    "movn    %[" #TEMP8 "],    $zero,          %[temp18]         \n\t"          \
67    "movn    %[" #TEMP12 "],   $zero,          %[temp19]         \n\t"          \
68    "addiu   %[temp20],      $zero,          255                 \n\t"          \
69    "slt     %[temp16],      %[" #TEMP0 "],    %[temp20]         \n\t"          \
70    "slt     %[temp17],      %[" #TEMP4 "],    %[temp20]         \n\t"          \
71    "slt     %[temp18],      %[" #TEMP8 "],    %[temp20]         \n\t"          \
72    "slt     %[temp19],      %[" #TEMP12 "],   %[temp20]         \n\t"          \
73    "movz    %[" #TEMP0 "],    %[temp20],      %[temp16]         \n\t"          \
74    "movz    %[" #TEMP4 "],    %[temp20],      %[temp17]         \n\t"          \
75    "lw      %[temp16],      8(%[args])                          \n\t"          \
76    "movz    %[" #TEMP8 "],    %[temp20],      %[temp18]         \n\t"          \
77    "movz    %[" #TEMP12 "],   %[temp20],      %[temp19]         \n\t"          \
78    "sb      %[" #TEMP0 "],    0+" XSTR(BPS) "*" #A "(%[temp16]) \n\t"          \
79    "sb      %[" #TEMP4 "],    1+" XSTR(BPS) "*" #A "(%[temp16]) \n\t"          \
80    "sb      %[" #TEMP8 "],    2+" XSTR(BPS) "*" #A "(%[temp16]) \n\t"          \
81    "sb      %[" #TEMP12 "],   3+" XSTR(BPS) "*" #A "(%[temp16]) \n\t"
<span onclick='openModal()' class='match'>82  static WEBP_INLINE void ITransformOne_MIPS32(const uint8_t* ref,
83                                               const int16_t* in,
84                                               uint8_t* dst) {
85    int temp0, temp1, temp2, temp3, temp4, temp5, temp6;
86    int temp7, temp8, temp9, temp10, temp11, temp12, temp13;
87    int temp14, temp15, temp16, temp17, temp18, temp19, temp20;
88    const int* args[3] = {(const int*)ref, (const int*)in, (const int*)dst};
</span>89    __asm__ volatile(
90      "lw      %[temp20],      4(%[args])                      \n\t"
91      VERTICAL_PASS(0, 16,  8, 24, temp4,  temp0,  temp1,  temp2,  temp3)
92      VERTICAL_PASS(2, 18, 10, 26, temp8,  temp4,  temp5,  temp6,  temp7)
93      VERTICAL_PASS(4, 20, 12, 28, temp12, temp8,  temp9,  temp10, temp11)
94      VERTICAL_PASS(6, 22, 14, 30, temp20, temp12, temp13, temp14, temp15)
95      HORIZONTAL_PASS(0, temp0, temp4, temp8,  temp12)
96      HORIZONTAL_PASS(1, temp1, temp5, temp9,  temp13)
97      HORIZONTAL_PASS(2, temp2, temp6, temp10, temp14)
98      HORIZONTAL_PASS(3, temp3, temp7, temp11, temp15)
99      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
100        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
101        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
102        [temp9]"=&r"(temp9), [temp10]"=&r"(temp10), [temp11]"=&r"(temp11),
103        [temp12]"=&r"(temp12), [temp13]"=&r"(temp13), [temp14]"=&r"(temp14),
104        [temp15]"=&r"(temp15), [temp16]"=&r"(temp16), [temp17]"=&r"(temp17),
105        [temp18]"=&r"(temp18), [temp19]"=&r"(temp19), [temp20]"=&r"(temp20)
106      : [args]"r"(args), [kC1]"r"(kC1), [kC2]"r"(kC2)
107      : "memory", "hi", "lo"
108    );
109  }
110  static void ITransform_MIPS32(const uint8_t* ref, const int16_t* in,
111                                uint8_t* dst, int do_two) {
112    ITransformOne_MIPS32(ref, in, dst);
113    if (do_two) {
114      ITransformOne_MIPS32(ref + 4, in + 16, dst + 4);
115    }
116  }
117  #undef VERTICAL_PASS
118  #undef HORIZONTAL_PASS
119  #define QUANTIZE_ONE(J, K, N)                                               \
120    "lh           %[temp0],       " #J "(%[ppin])                     \n\t"   \
121    "lhu          %[temp1],       " #J "(%[ppsharpen])                \n\t"   \
122    "lw           %[temp2],       " #K "(%[ppzthresh])                \n\t"   \
123    "sra          %[sign],        %[temp0],           15              \n\t"   \
124    "xor          %[coeff],       %[temp0],           %[sign]         \n\t"   \
125    "subu         %[coeff],       %[coeff],           %[sign]         \n\t"   \
126    "addu         %[coeff],       %[coeff],           %[temp1]        \n\t"   \
127    "slt          %[temp4],       %[temp2],           %[coeff]        \n\t"   \
128    "addiu        %[temp5],       $zero,              0               \n\t"   \
129    "addiu        %[level],       $zero,              0               \n\t"   \
130    "beqz         %[temp4],       2f                                  \n\t"   \
131    "lhu          %[temp1],       " #J "(%[ppiq])                     \n\t"   \
132    "lw           %[temp2],       " #K "(%[ppbias])                   \n\t"   \
133    "lhu          %[temp3],       " #J "(%[ppq])                      \n\t"   \
134    "mul          %[level],       %[coeff],           %[temp1]        \n\t"   \
135    "addu         %[level],       %[level],           %[temp2]        \n\t"   \
136    "sra          %[level],       %[level],           17              \n\t"   \
137    "slt          %[temp4],       %[max_level],       %[level]        \n\t"   \
138    "movn         %[level],       %[max_level],       %[temp4]        \n\t"   \
139    "xor          %[level],       %[level],           %[sign]         \n\t"   \
140    "subu         %[level],       %[level],           %[sign]         \n\t"   \
141    "mul          %[temp5],       %[level],           %[temp3]        \n\t"   \
142  "2:                                                                 \n\t"   \
143    "sh           %[temp5],       " #J "(%[ppin])                     \n\t"   \
144    "sh           %[level],       " #N "(%[pout])                     \n\t"
145  static int QuantizeBlock_MIPS32(int16_t in[16], int16_t out[16],
146                                  const VP8Matrix* const mtx) {
147    int temp0, temp1, temp2, temp3, temp4, temp5;
148    int sign, coeff, level, i;
149    int max_level = MAX_LEVEL;
150    int16_t* ppin             = &in[0];
151    int16_t* pout             = &out[0];
152    const uint16_t* ppsharpen = &mtx->sharpen_[0];
153    const uint32_t* ppzthresh = &mtx->zthresh_[0];
154    const uint16_t* ppq       = &mtx->q_[0];
155    const uint16_t* ppiq      = &mtx->iq_[0];
156    const uint32_t* ppbias    = &mtx->bias_[0];
157    __asm__ volatile(
158      QUANTIZE_ONE( 0,  0,  0)
159      QUANTIZE_ONE( 2,  4,  2)
160      QUANTIZE_ONE( 8, 16,  4)
161      QUANTIZE_ONE(16, 32,  6)
162      QUANTIZE_ONE(10, 20,  8)
163      QUANTIZE_ONE( 4,  8, 10)
164      QUANTIZE_ONE( 6, 12, 12)
165      QUANTIZE_ONE(12, 24, 14)
166      QUANTIZE_ONE(18, 36, 16)
167      QUANTIZE_ONE(24, 48, 18)
168      QUANTIZE_ONE(26, 52, 20)
169      QUANTIZE_ONE(20, 40, 22)
170      QUANTIZE_ONE(14, 28, 24)
171      QUANTIZE_ONE(22, 44, 26)
172      QUANTIZE_ONE(28, 56, 28)
173      QUANTIZE_ONE(30, 60, 30)
174      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
175        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3),
176        [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
177        [sign]"=&r"(sign), [coeff]"=&r"(coeff),
178        [level]"=&r"(level)
179      : [pout]"r"(pout), [ppin]"r"(ppin),
180        [ppiq]"r"(ppiq), [max_level]"r"(max_level),
181        [ppbias]"r"(ppbias), [ppzthresh]"r"(ppzthresh),
182        [ppsharpen]"r"(ppsharpen), [ppq]"r"(ppq)
183      : "memory", "hi", "lo"
184    );
185    for (i = 15; i >= 0; i--) {
186      if (out[i]) return 1;
187    }
188    return 0;
189  }
190  static int Quantize2Blocks_MIPS32(int16_t in[32], int16_t out[32],
191                                    const VP8Matrix* const mtx) {
192    int nz;
193    nz  = QuantizeBlock_MIPS32(in + 0 * 16, out + 0 * 16, mtx) << 0;
194    nz |= QuantizeBlock_MIPS32(in + 1 * 16, out + 1 * 16, mtx) << 1;
195    return nz;
196  }
197  #undef QUANTIZE_ONE
198  #define HORIZONTAL_PASS(A, E, F, G, H, E1, F1, G1, H1)                  \
199    "lbu    %[temp0],  0+" XSTR(BPS) "*" #A "(%[a])  \n\t"                \
200    "lbu    %[temp1],  1+" XSTR(BPS) "*" #A "(%[a])  \n\t"                \
201    "lbu    %[temp2],  2+" XSTR(BPS) "*" #A "(%[a])  \n\t"                \
202    "lbu    %[temp3],  3+" XSTR(BPS) "*" #A "(%[a])  \n\t"                \
203    "lbu    %[temp4],  0+" XSTR(BPS) "*" #A "(%[b])  \n\t"                \
204    "lbu    %[temp5],  1+" XSTR(BPS) "*" #A "(%[b])  \n\t"                \
205    "lbu    %[temp6],  2+" XSTR(BPS) "*" #A "(%[b])  \n\t"                \
206    "lbu    %[temp7],  3+" XSTR(BPS) "*" #A "(%[b])  \n\t"                \
207    "addu   %[temp8],  %[temp0],    %[temp2]         \n\t"                \
208    "subu   %[temp0],  %[temp0],    %[temp2]         \n\t"                \
209    "addu   %[temp2],  %[temp1],    %[temp3]         \n\t"                \
210    "subu   %[temp1],  %[temp1],    %[temp3]         \n\t"                \
211    "addu   %[temp3],  %[temp4],    %[temp6]         \n\t"                \
212    "subu   %[temp4],  %[temp4],    %[temp6]         \n\t"                \
213    "addu   %[temp6],  %[temp5],    %[temp7]         \n\t"                \
214    "subu   %[temp5],  %[temp5],    %[temp7]         \n\t"                \
215    "addu   %[temp7],  %[temp8],    %[temp2]         \n\t"                \
216    "subu   %[temp2],  %[temp8],    %[temp2]         \n\t"                \
217    "addu   %[temp8],  %[temp0],    %[temp1]         \n\t"                \
218    "subu   %[temp0],  %[temp0],    %[temp1]         \n\t"                \
219    "addu   %[temp1],  %[temp3],    %[temp6]         \n\t"                \
220    "subu   %[temp3],  %[temp3],    %[temp6]         \n\t"                \
221    "addu   %[temp6],  %[temp4],    %[temp5]         \n\t"                \
222    "subu   %[temp4],  %[temp4],    %[temp5]         \n\t"                \
223    "sw     %[temp7],  " #E "(%[tmp])                \n\t"                \
224    "sw     %[temp2],  " #H "(%[tmp])                \n\t"                \
225    "sw     %[temp8],  " #F "(%[tmp])                \n\t"                \
226    "sw     %[temp0],  " #G "(%[tmp])                \n\t"                \
227    "sw     %[temp1],  " #E1 "(%[tmp])               \n\t"                \
228    "sw     %[temp3],  " #H1 "(%[tmp])               \n\t"                \
229    "sw     %[temp6],  " #F1 "(%[tmp])               \n\t"                \
230    "sw     %[temp4],  " #G1 "(%[tmp])               \n\t"
231  #define VERTICAL_PASS(A, B, C, D, A1, B1, C1, D1, E, F, G, H)     \
232    "lw     %[temp0],  " #A1 "(%[tmp])         \n\t"                \
233    "lw     %[temp1],  " #C1 "(%[tmp])         \n\t"                \
234    "lw     %[temp2],  " #B1 "(%[tmp])         \n\t"                \
235    "lw     %[temp3],  " #D1 "(%[tmp])         \n\t"                \
236    "addu   %[temp8],  %[temp0],    %[temp1]   \n\t"                \
237    "subu   %[temp0],  %[temp0],    %[temp1]   \n\t"                \
238    "addu   %[temp1],  %[temp2],    %[temp3]   \n\t"                \
239    "subu   %[temp2],  %[temp2],    %[temp3]   \n\t"                \
240    "addu   %[temp3],  %[temp8],    %[temp1]   \n\t"                \
241    "subu   %[temp8],  %[temp8],    %[temp1]   \n\t"                \
242    "addu   %[temp1],  %[temp0],    %[temp2]   \n\t"                \
243    "subu   %[temp0],  %[temp0],    %[temp2]   \n\t"                \
244    "sra    %[temp4],  %[temp3],    31         \n\t"                \
245    "sra    %[temp5],  %[temp1],    31         \n\t"                \
246    "sra    %[temp6],  %[temp0],    31         \n\t"                \
247    "sra    %[temp7],  %[temp8],    31         \n\t"                \
248    "xor    %[temp3],  %[temp3],    %[temp4]   \n\t"                \
249    "xor    %[temp1],  %[temp1],    %[temp5]   \n\t"                \
250    "xor    %[temp0],  %[temp0],    %[temp6]   \n\t"                \
251    "xor    %[temp8],  %[temp8],    %[temp7]   \n\t"                \
252    "subu   %[temp3],  %[temp3],    %[temp4]   \n\t"                \
253    "subu   %[temp1],  %[temp1],    %[temp5]   \n\t"                \
254    "subu   %[temp0],  %[temp0],    %[temp6]   \n\t"                \
255    "subu   %[temp8],  %[temp8],    %[temp7]   \n\t"                \
256    "lhu    %[temp4],  " #E "(%[w])            \n\t"                \
257    "lhu    %[temp5],  " #F "(%[w])            \n\t"                \
258    "lhu    %[temp6],  " #G "(%[w])            \n\t"                \
259    "lhu    %[temp7],  " #H "(%[w])            \n\t"                \
260    "madd   %[temp4],  %[temp3]                \n\t"                \
261    "madd   %[temp5],  %[temp1]                \n\t"                \
262    "madd   %[temp6],  %[temp0]                \n\t"                \
263    "madd   %[temp7],  %[temp8]                \n\t"                \
264    "lw     %[temp0],  " #A "(%[tmp])          \n\t"                \
265    "lw     %[temp1],  " #C "(%[tmp])          \n\t"                \
266    "lw     %[temp2],  " #B "(%[tmp])          \n\t"                \
267    "lw     %[temp3],  " #D "(%[tmp])          \n\t"                \
268    "addu   %[temp8],  %[temp0],    %[temp1]   \n\t"                \
269    "subu   %[temp0],  %[temp0],    %[temp1]   \n\t"                \
270    "addu   %[temp1],  %[temp2],    %[temp3]   \n\t"                \
271    "subu   %[temp2],  %[temp2],    %[temp3]   \n\t"                \
272    "addu   %[temp3],  %[temp8],    %[temp1]   \n\t"                \
273    "subu   %[temp1],  %[temp8],    %[temp1]   \n\t"                \
274    "addu   %[temp8],  %[temp0],    %[temp2]   \n\t"                \
275    "subu   %[temp0],  %[temp0],    %[temp2]   \n\t"                \
276    "sra    %[temp2],  %[temp3],    31         \n\t"                \
277    "xor    %[temp3],  %[temp3],    %[temp2]   \n\t"                \
278    "subu   %[temp3],  %[temp3],    %[temp2]   \n\t"                \
279    "msub   %[temp4],  %[temp3]                \n\t"                \
280    "sra    %[temp2],  %[temp8],    31         \n\t"                \
281    "sra    %[temp3],  %[temp0],    31         \n\t"                \
282    "sra    %[temp4],  %[temp1],    31         \n\t"                \
283    "xor    %[temp8],  %[temp8],    %[temp2]   \n\t"                \
284    "xor    %[temp0],  %[temp0],    %[temp3]   \n\t"                \
285    "xor    %[temp1],  %[temp1],    %[temp4]   \n\t"                \
286    "subu   %[temp8],  %[temp8],    %[temp2]   \n\t"                \
287    "subu   %[temp0],  %[temp0],    %[temp3]   \n\t"                \
288    "subu   %[temp1],  %[temp1],    %[temp4]   \n\t"                \
289    "msub   %[temp5],  %[temp8]                \n\t"                \
290    "msub   %[temp6],  %[temp0]                \n\t"                \
291    "msub   %[temp7],  %[temp1]                \n\t"
292  static int Disto4x4_MIPS32(const uint8_t* const a, const uint8_t* const b,
293                             const uint16_t* const w) {
294    int tmp[32];
295    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
296    __asm__ volatile(
297      HORIZONTAL_PASS(0,   0,  4,  8, 12,    64,  68,  72,  76)
298      HORIZONTAL_PASS(1,  16, 20, 24, 28,    80,  84,  88,  92)
299      HORIZONTAL_PASS(2,  32, 36, 40, 44,    96, 100, 104, 108)
300      HORIZONTAL_PASS(3,  48, 52, 56, 60,   112, 116, 120, 124)
301      "mthi   $zero                             \n\t"
302      "mtlo   $zero                             \n\t"
303      VERTICAL_PASS( 0, 16, 32, 48,     64, 80,  96, 112,   0,  8, 16, 24)
304      VERTICAL_PASS( 4, 20, 36, 52,     68, 84, 100, 116,   2, 10, 18, 26)
305      VERTICAL_PASS( 8, 24, 40, 56,     72, 88, 104, 120,   4, 12, 20, 28)
306      VERTICAL_PASS(12, 28, 44, 60,     76, 92, 108, 124,   6, 14, 22, 30)
307      "mflo   %[temp0]                          \n\t"
308      "sra    %[temp1],  %[temp0],  31          \n\t"
309      "xor    %[temp0],  %[temp0],  %[temp1]    \n\t"
310      "subu   %[temp0],  %[temp0],  %[temp1]    \n\t"
311      "sra    %[temp0],  %[temp0],  5           \n\t"
312      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
313        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
314        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8)
315      : [a]"r"(a), [b]"r"(b), [w]"r"(w), [tmp]"r"(tmp)
316      : "memory", "hi", "lo"
317    );
318    return temp0;
319  }
320  #undef VERTICAL_PASS
321  #undef HORIZONTAL_PASS
322  static int Disto16x16_MIPS32(const uint8_t* const a, const uint8_t* const b,
323                               const uint16_t* const w) {
324    int D = 0;
325    int x, y;
326    for (y = 0; y < 16 * BPS; y += 4 * BPS) {
327      for (x = 0; x < 16; x += 4) {
328        D += Disto4x4_MIPS32(a + x + y, b + x + y, w);
329      }
330    }
331    return D;
332  }
333  #define HORIZONTAL_PASS(A, TEMP0, TEMP1, TEMP2, TEMP3)                  \
334    "lw     %[" #TEMP1 "],  0(%[args])                           \n\t"    \
335    "lw     %[" #TEMP2 "],  4(%[args])                           \n\t"    \
336    "lbu    %[temp16],    0+" XSTR(BPS) "*" #A "(%[" #TEMP1 "])  \n\t"    \
337    "lbu    %[temp17],    0+" XSTR(BPS) "*" #A "(%[" #TEMP2 "])  \n\t"    \
338    "lbu    %[temp18],    1+" XSTR(BPS) "*" #A "(%[" #TEMP1 "])  \n\t"    \
339    "lbu    %[temp19],    1+" XSTR(BPS) "*" #A "(%[" #TEMP2 "])  \n\t"    \
340    "subu   %[temp20],    %[temp16],    %[temp17]                \n\t"    \
341    "lbu    %[temp16],    2+" XSTR(BPS) "*" #A "(%[" #TEMP1 "])  \n\t"    \
342    "lbu    %[temp17],    2+" XSTR(BPS) "*" #A "(%[" #TEMP2 "])  \n\t"    \
343    "subu   %[" #TEMP0 "],  %[temp18],    %[temp19]              \n\t"    \
344    "lbu    %[temp18],    3+" XSTR(BPS) "*" #A "(%[" #TEMP1 "])  \n\t"    \
345    "lbu    %[temp19],    3+" XSTR(BPS) "*" #A "(%[" #TEMP2 "])  \n\t"    \
346    "subu   %[" #TEMP1 "],  %[temp16],    %[temp17]              \n\t"    \
347    "subu   %[" #TEMP2 "],  %[temp18],    %[temp19]              \n\t"    \
348    "addu   %[" #TEMP3 "],  %[temp20],    %[" #TEMP2 "]          \n\t"    \
349    "subu   %[" #TEMP2 "],  %[temp20],    %[" #TEMP2 "]          \n\t"    \
350    "addu   %[temp20],    %[" #TEMP0 "],  %[" #TEMP1 "]          \n\t"    \
351    "subu   %[" #TEMP0 "],  %[" #TEMP0 "],  %[" #TEMP1 "]        \n\t"    \
352    "mul    %[temp16],    %[" #TEMP2 "],  %[c5352]               \n\t"    \
353    "mul    %[temp17],    %[" #TEMP2 "],  %[c2217]               \n\t"    \
354    "mul    %[temp18],    %[" #TEMP0 "],  %[c5352]               \n\t"    \
355    "mul    %[temp19],    %[" #TEMP0 "],  %[c2217]               \n\t"    \
356    "addu   %[" #TEMP1 "],  %[" #TEMP3 "],  %[temp20]            \n\t"    \
357    "subu   %[temp20],    %[" #TEMP3 "],  %[temp20]              \n\t"    \
358    "sll    %[" #TEMP0 "],  %[" #TEMP1 "],  3                    \n\t"    \
359    "sll    %[" #TEMP2 "],  %[temp20],    3                      \n\t"    \
360    "addiu  %[temp16],    %[temp16],    1812                     \n\t"    \
361    "addiu  %[temp17],    %[temp17],    937                      \n\t"    \
362    "addu   %[temp16],    %[temp16],    %[temp19]                \n\t"    \
363    "subu   %[temp17],    %[temp17],    %[temp18]                \n\t"    \
364    "sra    %[" #TEMP1 "],  %[temp16],    9                      \n\t"    \
365    "sra    %[" #TEMP3 "],  %[temp17],    9                      \n\t"
366  #define VERTICAL_PASS(A, B, C, D, TEMP0, TEMP4, TEMP8, TEMP12)    \
367    "addu   %[temp16],    %[" #TEMP0 "],  %[" #TEMP12 "]   \n\t"    \
368    "subu   %[temp19],    %[" #TEMP0 "],  %[" #TEMP12 "]   \n\t"    \
369    "addu   %[temp17],    %[" #TEMP4 "],  %[" #TEMP8 "]    \n\t"    \
370    "subu   %[temp18],    %[" #TEMP4 "],  %[" #TEMP8 "]    \n\t"    \
371    "mul    %[" #TEMP8 "],  %[temp19],    %[c2217]         \n\t"    \
372    "mul    %[" #TEMP12 "], %[temp18],    %[c2217]         \n\t"    \
373    "mul    %[" #TEMP4 "],  %[temp19],    %[c5352]         \n\t"    \
374    "mul    %[temp18],    %[temp18],    %[c5352]           \n\t"    \
375    "addiu  %[temp16],    %[temp16],    7                  \n\t"    \
376    "addu   %[" #TEMP0 "],  %[temp16],    %[temp17]        \n\t"    \
377    "sra    %[" #TEMP0 "],  %[" #TEMP0 "],  4              \n\t"    \
378    "addu   %[" #TEMP12 "], %[" #TEMP12 "], %[" #TEMP4 "]  \n\t"    \
379    "subu   %[" #TEMP4 "],  %[temp16],    %[temp17]        \n\t"    \
380    "sra    %[" #TEMP4 "],  %[" #TEMP4 "],  4              \n\t"    \
381    "addiu  %[" #TEMP8 "],  %[" #TEMP8 "],  30000          \n\t"    \
382    "addiu  %[" #TEMP12 "], %[" #TEMP12 "], 12000          \n\t"    \
383    "addiu  %[" #TEMP8 "],  %[" #TEMP8 "],  21000          \n\t"    \
384    "subu   %[" #TEMP8 "],  %[" #TEMP8 "],  %[temp18]      \n\t"    \
385    "sra    %[" #TEMP12 "], %[" #TEMP12 "], 16             \n\t"    \
386    "sra    %[" #TEMP8 "],  %[" #TEMP8 "],  16             \n\t"    \
387    "addiu  %[temp16],    %[" #TEMP12 "], 1                \n\t"    \
388    "movn   %[" #TEMP12 "], %[temp16],    %[temp19]        \n\t"    \
389    "sh     %[" #TEMP0 "],  " #A "(%[temp20])              \n\t"    \
390    "sh     %[" #TEMP4 "],  " #C "(%[temp20])              \n\t"    \
391    "sh     %[" #TEMP8 "],  " #D "(%[temp20])              \n\t"    \
392    "sh     %[" #TEMP12 "], " #B "(%[temp20])              \n\t"
393  static void FTransform_MIPS32(const uint8_t* src, const uint8_t* ref,
394                                int16_t* out) {
395    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
396    int temp9, temp10, temp11, temp12, temp13, temp14, temp15, temp16;
397    int temp17, temp18, temp19, temp20;
398    const int c2217 = 2217;
399    const int c5352 = 5352;
400    const int* const args[3] =
401        { (const int*)src, (const int*)ref, (const int*)out };
402    __asm__ volatile(
403      HORIZONTAL_PASS(0, temp0,  temp1,  temp2,  temp3)
404      HORIZONTAL_PASS(1, temp4,  temp5,  temp6,  temp7)
405      HORIZONTAL_PASS(2, temp8,  temp9,  temp10, temp11)
406      HORIZONTAL_PASS(3, temp12, temp13, temp14, temp15)
407      "lw   %[temp20],    8(%[args])                     \n\t"
408      VERTICAL_PASS(0,  8, 16, 24, temp0, temp4, temp8,  temp12)
409      VERTICAL_PASS(2, 10, 18, 26, temp1, temp5, temp9,  temp13)
410      VERTICAL_PASS(4, 12, 20, 28, temp2, temp6, temp10, temp14)
411      VERTICAL_PASS(6, 14, 22, 30, temp3, temp7, temp11, temp15)
412      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
413        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
414        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
415        [temp9]"=&r"(temp9), [temp10]"=&r"(temp10), [temp11]"=&r"(temp11),
416        [temp12]"=&r"(temp12), [temp13]"=&r"(temp13), [temp14]"=&r"(temp14),
417        [temp15]"=&r"(temp15), [temp16]"=&r"(temp16), [temp17]"=&r"(temp17),
418        [temp18]"=&r"(temp18), [temp19]"=&r"(temp19), [temp20]"=&r"(temp20)
419      : [args]"r"(args), [c2217]"r"(c2217), [c5352]"r"(c5352)
420      : "memory", "hi", "lo"
421    );
422  }
423  #undef VERTICAL_PASS
424  #undef HORIZONTAL_PASS
425  #if !defined(WORK_AROUND_GCC)
426  #define GET_SSE_INNER(A, B, C, D)                               \
427    "lbu     %[temp0],    " #A "(%[a])                 \n\t"      \
428    "lbu     %[temp1],    " #A "(%[b])                 \n\t"      \
429    "lbu     %[temp2],    " #B "(%[a])                 \n\t"      \
430    "lbu     %[temp3],    " #B "(%[b])                 \n\t"      \
431    "lbu     %[temp4],    " #C "(%[a])                 \n\t"      \
432    "lbu     %[temp5],    " #C "(%[b])                 \n\t"      \
433    "lbu     %[temp6],    " #D "(%[a])                 \n\t"      \
434    "lbu     %[temp7],    " #D "(%[b])                 \n\t"      \
435    "subu    %[temp0],    %[temp0],     %[temp1]       \n\t"      \
436    "subu    %[temp2],    %[temp2],     %[temp3]       \n\t"      \
437    "subu    %[temp4],    %[temp4],     %[temp5]       \n\t"      \
438    "subu    %[temp6],    %[temp6],     %[temp7]       \n\t"      \
439    "madd    %[temp0],    %[temp0]                     \n\t"      \
440    "madd    %[temp2],    %[temp2]                     \n\t"      \
441    "madd    %[temp4],    %[temp4]                     \n\t"      \
442    "madd    %[temp6],    %[temp6]                     \n\t"
443  #define GET_SSE(A, B, C, D)               \
444    GET_SSE_INNER(A, A + 1, A + 2, A + 3)   \
445    GET_SSE_INNER(B, B + 1, B + 2, B + 3)   \
446    GET_SSE_INNER(C, C + 1, C + 2, C + 3)   \
447    GET_SSE_INNER(D, D + 1, D + 2, D + 3)
448  static int SSE16x16_MIPS32(const uint8_t* a, const uint8_t* b) {
449    int count;
450    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
451    __asm__ volatile(
452       "mult   $zero,    $zero                            \n\t"
453       GET_SSE( 0 * BPS, 4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS)
454       GET_SSE( 1 * BPS, 4 +  1 * BPS, 8 +  1 * BPS, 12 +  1 * BPS)
455       GET_SSE( 2 * BPS, 4 +  2 * BPS, 8 +  2 * BPS, 12 +  2 * BPS)
456       GET_SSE( 3 * BPS, 4 +  3 * BPS, 8 +  3 * BPS, 12 +  3 * BPS)
457       GET_SSE( 4 * BPS, 4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS)
458       GET_SSE( 5 * BPS, 4 +  5 * BPS, 8 +  5 * BPS, 12 +  5 * BPS)
459       GET_SSE( 6 * BPS, 4 +  6 * BPS, 8 +  6 * BPS, 12 +  6 * BPS)
460       GET_SSE( 7 * BPS, 4 +  7 * BPS, 8 +  7 * BPS, 12 +  7 * BPS)
461       GET_SSE( 8 * BPS, 4 +  8 * BPS, 8 +  8 * BPS, 12 +  8 * BPS)
462       GET_SSE( 9 * BPS, 4 +  9 * BPS, 8 +  9 * BPS, 12 +  9 * BPS)
463       GET_SSE(10 * BPS, 4 + 10 * BPS, 8 + 10 * BPS, 12 + 10 * BPS)
464       GET_SSE(11 * BPS, 4 + 11 * BPS, 8 + 11 * BPS, 12 + 11 * BPS)
465       GET_SSE(12 * BPS, 4 + 12 * BPS, 8 + 12 * BPS, 12 + 12 * BPS)
466       GET_SSE(13 * BPS, 4 + 13 * BPS, 8 + 13 * BPS, 12 + 13 * BPS)
467       GET_SSE(14 * BPS, 4 + 14 * BPS, 8 + 14 * BPS, 12 + 14 * BPS)
468       GET_SSE(15 * BPS, 4 + 15 * BPS, 8 + 15 * BPS, 12 + 15 * BPS)
469      "mflo    %[count]                                   \n\t"
470      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
471        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
472        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [count]"=&r"(count)
473      : [a]"r"(a), [b]"r"(b)
474      : "memory", "hi", "lo"
475    );
476    return count;
477  }
478  static int SSE16x8_MIPS32(const uint8_t* a, const uint8_t* b) {
479    int count;
480    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
481    __asm__ volatile(
482       "mult   $zero,    $zero                            \n\t"
483       GET_SSE( 0 * BPS, 4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS)
484       GET_SSE( 1 * BPS, 4 +  1 * BPS, 8 +  1 * BPS, 12 +  1 * BPS)
485       GET_SSE( 2 * BPS, 4 +  2 * BPS, 8 +  2 * BPS, 12 +  2 * BPS)
486       GET_SSE( 3 * BPS, 4 +  3 * BPS, 8 +  3 * BPS, 12 +  3 * BPS)
487       GET_SSE( 4 * BPS, 4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS)
488       GET_SSE( 5 * BPS, 4 +  5 * BPS, 8 +  5 * BPS, 12 +  5 * BPS)
489       GET_SSE( 6 * BPS, 4 +  6 * BPS, 8 +  6 * BPS, 12 +  6 * BPS)
490       GET_SSE( 7 * BPS, 4 +  7 * BPS, 8 +  7 * BPS, 12 +  7 * BPS)
491      "mflo    %[count]                                   \n\t"
492      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
493        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
494        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [count]"=&r"(count)
495      : [a]"r"(a), [b]"r"(b)
496      : "memory", "hi", "lo"
497    );
498    return count;
499  }
500  static int SSE8x8_MIPS32(const uint8_t* a, const uint8_t* b) {
501    int count;
502    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
503    __asm__ volatile(
504       "mult   $zero,    $zero                            \n\t"
505       GET_SSE(0 * BPS, 4 + 0 * BPS, 1 * BPS, 4 + 1 * BPS)
506       GET_SSE(2 * BPS, 4 + 2 * BPS, 3 * BPS, 4 + 3 * BPS)
507       GET_SSE(4 * BPS, 4 + 4 * BPS, 5 * BPS, 4 + 5 * BPS)
508       GET_SSE(6 * BPS, 4 + 6 * BPS, 7 * BPS, 4 + 7 * BPS)
509      "mflo    %[count]                                   \n\t"
510      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
511        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
512        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [count]"=&r"(count)
513      : [a]"r"(a), [b]"r"(b)
514      : "memory", "hi", "lo"
515    );
516    return count;
517  }
518  static int SSE4x4_MIPS32(const uint8_t* a, const uint8_t* b) {
519    int count;
520    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
521    __asm__ volatile(
522       "mult   $zero,    $zero                            \n\t"
523       GET_SSE(0 * BPS, 1 * BPS, 2 * BPS, 3 * BPS)
524      "mflo    %[count]                                   \n\t"
525      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
526        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
527        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [count]"=&r"(count)
528      : [a]"r"(a), [b]"r"(b)
529      : "memory", "hi", "lo"
530    );
531    return count;
532  }
533  #undef GET_SSE
534  #undef GET_SSE_INNER
535  #endif  
536  extern void VP8EncDspInitMIPS32(void);
537  WEBP_TSAN_IGNORE_FUNCTION void VP8EncDspInitMIPS32(void) {
538    VP8ITransform = ITransform_MIPS32;
539    VP8FTransform = FTransform_MIPS32;
540    VP8EncQuantizeBlock = QuantizeBlock_MIPS32;
541    VP8EncQuantize2Blocks = Quantize2Blocks_MIPS32;
542    VP8TDisto4x4 = Disto4x4_MIPS32;
543    VP8TDisto16x16 = Disto16x16_MIPS32;
544  #if !defined(WORK_AROUND_GCC)
545    VP8SSE16x16 = SSE16x16_MIPS32;
546    VP8SSE8x8 = SSE8x8_MIPS32;
547    VP8SSE16x8 = SSE16x8_MIPS32;
548    VP8SSE4x4 = SSE4x4_MIPS32;
549  #endif
550  }
551  #else  
552  WEBP_DSP_INIT_STUB(VP8EncDspInitMIPS32)
553  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeGLFunctions.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_mips32.c</div>
                </div>
                <div class="column column_space"><pre><code>153      void bindTexture2D(GLsizei w, GLsizei h, const void* buffer = nullptr);
154      void attachDepthBuffer();
155      bool checkStatus();
156      using FrameBuffer::bind;
157      using FrameBuffer::fbo;
158  private:
159      using TextureObject::resize;
160      GLuint m_renderBuffer = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>82  static WEBP_INLINE void ITransformOne_MIPS32(const uint8_t* ref,
83                                               const int16_t* in,
84                                               uint8_t* dst) {
85    int temp0, temp1, temp2, temp3, temp4, temp5, temp6;
86    int temp7, temp8, temp9, temp10, temp11, temp12, temp13;
87    int temp14, temp15, temp16, temp17, temp18, temp19, temp20;
88    const int* args[3] = {(const int*)ref, (const int*)in, (const int*)dst};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    