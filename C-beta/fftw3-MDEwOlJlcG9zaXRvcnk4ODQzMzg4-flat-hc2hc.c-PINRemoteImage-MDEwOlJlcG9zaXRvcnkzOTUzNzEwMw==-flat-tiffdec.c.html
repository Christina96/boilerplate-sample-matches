
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.7165991902834%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-hc2hc.c</h3>
            <pre><code>1  #include "rdft/hc2hc.h"
2  hc2hc_solver *(*X(mksolver_hc2hc_hook))(size_t, INT, hc2hc_mkinferior) = 0;
3  typedef struct {
4       plan_rdft super;
5       plan *cld;
6       plan *cldw;
7       INT r;
8  } P;
9  static void apply_dit(const plan *ego_, R *I, R *O)
10  {
11       const P *ego = (const P *) ego_;
12       plan_rdft *cld;
13       plan_hc2hc *cldw;
14       cld = (plan_rdft *) ego->cld;
15       cld->apply(ego->cld, I, O);
16       cldw = (plan_hc2hc *) ego->cldw;
17       cldw->apply(ego->cldw, O);
18  }
19  static void apply_dif(const plan *ego_, R *I, R *O)
20  {
21       const P *ego = (const P *) ego_;
22       plan_rdft *cld;
23       plan_hc2hc *cldw;
24       cldw = (plan_hc2hc *) ego->cldw;
25       cldw->apply(ego->cldw, I);
26       cld = (plan_rdft *) ego->cld;
27       cld->apply(ego->cld, I, O);
28  }
29  static void awake(plan *ego_, enum wakefulness wakefulness)
30  {
31       P *ego = (P *) ego_;
32       X(plan_awake)(ego->cld, wakefulness);
33       X(plan_awake)(ego->cldw, wakefulness);
34  }
35  static void destroy(plan *ego_)
36  {
37       P *ego = (P *) ego_;
38       X(plan_destroy_internal)(ego->cldw);
39       X(plan_destroy_internal)(ego->cld);
40  }
41  static void print(const plan *ego_, printer *p)
42  {
43       const P *ego = (const P *) ego_;
44       p->print(p, "(rdft-ct-%s/%D%(%p%)%(%p%))",
45  	      ego->super.apply == apply_dit ? "dit" : "dif",
46  	      ego->r, ego->cldw, ego->cld);
47  }
48  static int applicable0(const hc2hc_solver *ego, const problem *p_, planner *plnr)
49  {
50       const problem_rdft *p = (const problem_rdft *) p_;
51       INT r;
52       return (1
53  	     && p->sz->rnk == 1
54  	     && p->vecsz->rnk <= 1 
55  	     && (&bsol;* either the problem is R2HC, which is solved by DIT */
56  		  (p->kind[0] == R2HC)
57  		  ||
58  		  (p->kind[0] == HC2R && 
59  		   (p->I == p->O || !NO_DESTROY_INPUTP(plnr))))
60  	     && ((r = X(choose_radix)(ego->r, p->sz->dims[0].n)) > 0)
61  	     && p->sz->dims[0].n > r);
62  }
63  int X(hc2hc_applicable)(const hc2hc_solver *ego, const problem *p_, planner *plnr)
64  {
65       const problem_rdft *p;
66       if (!applicable0(ego, p_, plnr))
67            return 0;
68       p = (const problem_rdft *) p_;
69       return (0
70  	     || p->vecsz->rnk == 0
71  	     || !NO_VRECURSEP(plnr)
72  	  );
73  }
74  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
75  {
76       const hc2hc_solver *ego = (const hc2hc_solver *) ego_;
77       const problem_rdft *p;
78       P *pln = 0;
79       plan *cld = 0, *cldw = 0;
80       INT n, r, m, v, ivs, ovs;
81       iodim *d;
82       static const plan_adt padt = {
83  	  X(rdft_solve), awake, print, destroy
84       };
85       if (NO_NONTHREADEDP(plnr) || !X(hc2hc_applicable)(ego, p_, plnr))
86            return (plan *) 0;
87       p = (const problem_rdft *) p_;
88       d = p->sz->dims;
89       n = d[0].n;
90       r = X(choose_radix)(ego->r, n);
91       m = n / r;
92       X(tensor_tornk1)(p->vecsz, &v, &ivs, &ovs);
93       switch (p->kind[0]) {
94  	 case R2HC:
95  	      cldw = ego->mkcldw(ego, 
96  				 R2HC, r, m, d[0].os, v, ovs, 0, (m+2)/2, 
97  				 p->O, plnr);
98  	      if (!cldw) goto nada;
99  	      cld = X(mkplan_d)(plnr, 
100  				X(mkproblem_rdft_d)(
101  				     X(mktensor_1d)(m, r * d[0].is, d[0].os),
102  				     X(mktensor_2d)(r, d[0].is, m * d[0].os,
103  						    v, ivs, ovs),
104  				     p->I, p->O, p->kind)
105  		   );
106  	      if (!cld) goto nada;
107  	      pln = MKPLAN_RDFT(P, &padt, apply_dit);
108  	      break;
109  	 case HC2R:
110  	      cldw = ego->mkcldw(ego,
111  				 HC2R, r, m, d[0].is, v, ivs, 0, (m+2)/2, 
112  				 p->I, plnr);
113  	      if (!cldw) goto nada;
114  	      cld = X(mkplan_d)(plnr, 
115  				X(mkproblem_rdft_d)(
116  				     X(mktensor_1d)(m, d[0].is, r * d[0].os),
117  				     X(mktensor_2d)(r, m * d[0].is, d[0].os,
118  						    v, ivs, ovs),
119  				     p->I, p->O, p->kind)
120  		   );
121  	      if (!cld) goto nada;
122  	      pln = MKPLAN_RDFT(P, &padt, apply_dif);
123  	      break;
124  	 default: 
125  	      A(0);
126       }
127       pln->cld = cld;
128       pln->cldw = cldw;
129       pln->r = r;
130       X(ops_add)(&cld->ops, &cldw->ops, &pln->super.super.ops);
131       pln->super.super.could_prune_now_p = cldw->could_prune_now_p;
132       return &(pln->super.super);
133   nada:
134       X(plan_destroy_internal)(cldw);
135       X(plan_destroy_internal)(cld);
<span onclick='openModal()' class='match'>136       return (plan *) 0;
137  }
138  hc2hc_solver *X(mksolver_hc2hc)(size_t size, INT r, hc2hc_mkinferior mkcldw)
139  {
140       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
</span>141       hc2hc_solver *slv = (hc2hc_solver *)X(mksolver)(size, &sadt);
142       slv->r = r;
143       slv->mkcldw = mkcldw;
144       return slv;
145  }
146  plan *X(mkplan_hc2hc)(size_t size, const plan_adt *adt, hc2hcapply apply)
147  {
148       plan_hc2hc *ego;
149       ego = (plan_hc2hc *) X(mkplan)(size, adt);
150       ego->apply = apply;
151       return &(ego->super);
152  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-tiffdec.c</h3>
            <pre><code>1  #include "./tiffdec.h"
2  #ifdef HAVE_CONFIG_H
3  #include "webp/config.h"
4  #endif
5  #include <limits.h>
6  #include <stdio.h>
7  #include <string.h>
8  #ifdef WEBP_HAVE_TIFF
9  #include <tiffio.h>
10  #include "webp/encode.h"
11  #include "./imageio_util.h"
12  #include "./metadata.h"
13  static const struct {
14    ttag_t tag;
15    size_t storage_offset;
16  } kTIFFMetadataMap[] = {
17    { TIFFTAG_ICCPROFILE, METADATA_OFFSET(iccp) },
18    { TIFFTAG_XMLPACKET,  METADATA_OFFSET(xmp) },
19    { 0, 0 },
20  };
21  static int ExtractMetadataFromTIFF(TIFF* const tif, Metadata* const metadata) {
22    int i;
23    toff_t exif_ifd_offset;
24    for (i = 0; kTIFFMetadataMap[i].tag != 0; ++i) {
25      MetadataPayload* const payload =
26          (MetadataPayload*)((uint8_t*)metadata +
27                             kTIFFMetadataMap[i].storage_offset);
28      void* tag_data;
29      uint32 tag_data_len;
30      if (TIFFGetField(tif, kTIFFMetadataMap[i].tag, &tag_data_len, &tag_data) &&
31          !MetadataCopy((const char*)tag_data, tag_data_len, payload)) {
32        return 0;
33      }
34    }
35    if (TIFFGetField(tif, TIFFTAG_EXIFIFD, &exif_ifd_offset)) {
36      fprintf(stderr, "Warning: EXIF extraction from TIFF is unsupported.\n");
37    }
38    return 1;
39  }
40  typedef struct {
41    const uint8_t* data;
42    toff_t size;
43    toff_t pos;
44  } MyData;
45  static int MyClose(thandle_t opaque) {
46    (void)opaque;
47    return 0;
48  }
49  static toff_t MySize(thandle_t opaque) {
50    const MyData* const my_data = (MyData*)opaque;
51    return my_data->size;
52  }
53  static toff_t MySeek(thandle_t opaque, toff_t offset, int whence) {
54    MyData* const my_data = (MyData*)opaque;
55    offset += (whence == SEEK_CUR) ? my_data->pos
56            : (whence == SEEK_SET) ? 0
57            : my_data->size;
58    if (offset > my_data->size) return (toff_t)-1;
59    my_data->pos = offset;
60    return offset;
61  }
62  static int MyMapFile(thandle_t opaque, void** base, toff_t* size) {
63    (void)opaque;
64    (void)base;
65    (void)size;
66    return 0;
67  }
68  static void MyUnmapFile(thandle_t opaque, void* base, toff_t size) {
69    (void)opaque;
70    (void)base;
71    (void)size;
72  }
73  static tsize_t MyRead(thandle_t opaque, void* dst, tsize_t size) {
74    MyData* const my_data = (MyData*)opaque;
75    if (my_data->pos + size > my_data->size) {
76      size = (tsize_t)(my_data->size - my_data->pos);
77    }
78    if (size > 0) {
79      memcpy(dst, my_data->data + my_data->pos, size);
80      my_data->pos += size;
81    }
82    return size;
83  }
84  #define MFIX 24    
85  #define HALF ((1u << MFIX) >> 1)
86  static uint32_t Unmult(uint8_t x, uint32_t mult) {
87    const uint32_t v = (x * mult + HALF) >> MFIX;
88    return (v > 255u) ? 255u : v;
89  }
90  static WEBP_INLINE uint32_t GetScale(uint32_t a) {
91    return (255u << MFIX) / a;
92  }
93  #undef MFIX
94  #undef HALF
95  static void MultARGBRow(uint8_t* ptr, int width) {
96    int x;
97    for (x = 0; x < width; ++x, ptr += 4) {
98      const uint32_t alpha = ptr[3];
99      if (alpha < 255) {
100        if (alpha == 0) {   
101          ptr[0] = ptr[1] = ptr[2] = 0;
102        } else {
103          const uint32_t scale = GetScale(alpha);
104          ptr[0] = Unmult(ptr[0], scale);
105          ptr[1] = Unmult(ptr[1], scale);
106          ptr[2] = Unmult(ptr[2], scale);
107        }
108      }
109    }
110  }
111  int ReadTIFF(const uint8_t* const data, size_t data_size,
112               WebPPicture* const pic, int keep_alpha,
113               Metadata* const metadata) {
114    MyData my_data = { data, (toff_t)data_size, 0 };
115    TIFF* tif;
116    uint32_t image_width, image_height, tile_width, tile_height;
117    uint16_t samples_per_px = 0;
118    uint16_t extra_samples = 0;
119    uint16_t* extra_samples_ptr = NULL;
120    uint32_t* raster;
121    int64_t alloc_size;
122    int ok = 0;
123    tdir_t dircount;
124    if (data == NULL || data_size == 0 || data_size > INT_MAX || pic == NULL) {
125      return 0;
126    }
127    tif = TIFFClientOpen("Memory", "r", &my_data,
128                         MyRead, MyRead, MySeek, MyClose,
129                         MySize, MyMapFile, MyUnmapFile);
130    if (tif == NULL) {
131      fprintf(stderr, "Error! Cannot parse TIFF file\n");
132      return 0;
133    }
134    dircount = TIFFNumberOfDirectories(tif);
135    if (dircount > 1) {
136      fprintf(stderr, "Warning: multi-directory TIFF files are not supported.\n"
137                      "Only the first will be used, %d will be ignored.\n",
138                      dircount - 1);
139    }
140    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samples_per_px)) {
141      fprintf(stderr, "Error! Cannot retrieve TIFF samples-per-pixel info.\n");
142      goto End;
143    }
144    if (samples_per_px < 3 || samples_per_px > 4) goto End;  
145    if (!(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &image_width) &&
146          TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &image_height))) {
147      fprintf(stderr, "Error! Cannot retrieve TIFF image dimensions.\n");
148      goto End;
149    }
150    if (!ImgIoUtilCheckSizeArgumentsOverflow((uint64_t)image_width * image_height,
151                                             sizeof(*raster))) {
152      goto End;
153    }
154    if ((TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width) &&
155         tile_width > 32 && tile_width / 2 > image_width) ||
156        (TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height) &&
157         tile_height > 32 && tile_height / 2 > image_height)) {
158      fprintf(stderr, "Error! TIFF tile dimensions are too big.\n");
159      goto End;
160    }
161    if (samples_per_px > 3 && !TIFFGetField(tif, TIFFTAG_EXTRASAMPLES,
162                                            &extra_samples, &extra_samples_ptr)) {
163      fprintf(stderr, "Error! Cannot retrieve TIFF ExtraSamples info.\n");
164      goto End;
165    }
166    alloc_size =
167        (int64_t)((uint64_t)image_width * image_height * sizeof(*raster));
168    if (alloc_size < 0 || alloc_size != (tsize_t)alloc_size) goto End;
169    raster = (uint32*)_TIFFmalloc((tsize_t)alloc_size);
170    if (raster != NULL) {
171      if (TIFFReadRGBAImageOriented(tif, image_width, image_height, raster,
172                                    ORIENTATION_TOPLEFT, 1)) {
173        const int stride = image_width * sizeof(*raster);
174        pic->width = image_width;
175        pic->height = image_height;
176  #ifdef WORDS_BIGENDIAN
177        TIFFSwabArrayOfLong(raster, image_width * image_height);
178  #endif
179        if (extra_samples == 1 && extra_samples_ptr != NULL &&
180            extra_samples_ptr[0] == EXTRASAMPLE_ASSOCALPHA) {
181          uint32_t y;
182          uint8_t* tmp = (uint8_t*)raster;
183          for (y = 0; y < image_height; ++y) {
184            MultARGBRow(tmp, image_width);
185            tmp += stride;
186          }
187        }
188        ok = keep_alpha
189           ? WebPPictureImportRGBA(pic, (const uint8_t*)raster, stride)
190           : WebPPictureImportRGBX(pic, (const uint8_t*)raster, stride);
191      }
192      _TIFFfree(raster);
193    } else {
194      fprintf(stderr, "Error allocating TIFF RGBA memory!\n");
195    }
196    if (ok) {
197      if (metadata != NULL) {
198        ok = ExtractMetadataFromTIFF(tif, metadata);
199        if (!ok) {
200          fprintf(stderr, "Error extracting TIFF metadata!\n");
201          MetadataFree(metadata);
202          WebPPictureFree(pic);
203        }
204      }
205    }
206   End:
207    TIFFClose(tif);
<span onclick='openModal()' class='match'>208    return ok;
209  }
210  #else  
211  int ReadTIFF(const uint8_t* const data, size_t data_size,
212               struct WebPPicture* const pic, int keep_alpha,
213               struct Metadata* const metadata) {
</span>214    (void)data;
215    (void)data_size;
216    (void)pic;
217    (void)keep_alpha;
218    (void)metadata;
219    fprintf(stderr, "TIFF support not compiled. Please install the libtiff "
220            "development package before building.\n");
221    return 0;
222  }
223  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-hc2hc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-tiffdec.c</div>
                </div>
                <div class="column column_space"><pre><code>136       return (plan *) 0;
137  }
138  hc2hc_solver *X(mksolver_hc2hc)(size_t size, INT r, hc2hc_mkinferior mkcldw)
139  {
140       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
</pre></code></div>
                <div class="column column_space"><pre><code>208    return ok;
209  }
210  #else  
211  int ReadTIFF(const uint8_t* const data, size_t data_size,
212               struct WebPPicture* const pic, int keep_alpha,
213               struct Metadata* const metadata) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    