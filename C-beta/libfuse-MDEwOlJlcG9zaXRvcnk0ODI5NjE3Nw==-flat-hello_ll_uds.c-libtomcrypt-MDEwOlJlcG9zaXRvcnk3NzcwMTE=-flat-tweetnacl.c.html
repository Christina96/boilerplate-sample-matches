
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.395929694727105%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-hello_ll_uds.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 34
2  #ifndef _GNU_SOURCE
3  #define _GNU_SOURCE
4  #endif
5  #include <fuse_lowlevel.h>
6  #include <fuse_kernel.h>
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include <errno.h>
11  #include <fcntl.h>
12  #include <unistd.h>
13  #include <assert.h>
14  #include <sys/socket.h>
15  #include <sys/un.h>
16  static const char *hello_str = "Hello World!\n";
17  static const char *hello_name = "hello";
18  static int hello_stat(fuse_ino_t ino, struct stat *stbuf)
19  {
20  	stbuf->st_ino = ino;
21  	switch (ino) {
22  	case 1:
23  		stbuf->st_mode = S_IFDIR | 0755;
24  		stbuf->st_nlink = 2;
25  		break;
26  	case 2:
27  		stbuf->st_mode = S_IFREG | 0444;
28  		stbuf->st_nlink = 1;
29  		stbuf->st_size = strlen(hello_str);
30  		break;
31  	default:
32  		return -1;
33  	}
34  	return 0;
35  }
36  static void hello_ll_getattr(fuse_req_t req, fuse_ino_t ino,
37  			     struct fuse_file_info *fi)
38  {
39  	struct stat stbuf;
40  	(void) fi;
41  	memset(&stbuf, 0, sizeof(stbuf));
42  	if (hello_stat(ino, &stbuf) == -1)
43  		fuse_reply_err(req, ENOENT);
44  	else
45  		fuse_reply_attr(req, &stbuf, 1.0);
46  }
47  static void hello_ll_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)
48  {
49  	struct fuse_entry_param e;
50  	if (parent != 1 || strcmp(name, hello_name) != 0)
51  		fuse_reply_err(req, ENOENT);
52  	else {
53  		memset(&e, 0, sizeof(e));
54  		e.ino = 2;
55  		e.attr_timeout = 1.0;
56  		e.entry_timeout = 1.0;
57  		hello_stat(e.ino, &e.attr);
58  		fuse_reply_entry(req, &e);
59  	}
60  }
61  struct dirbuf {
62  	char *p;
63  	size_t size;
64  };
65  static void dirbuf_add(fuse_req_t req, struct dirbuf *b, const char *name,
66  		       fuse_ino_t ino)
67  {
68  	struct stat stbuf;
69  	size_t oldsize = b->size;
70  	b->size += fuse_add_direntry(req, NULL, 0, name, NULL, 0);
71  	b->p = (char *) realloc(b->p, b->size);
72  	memset(&stbuf, 0, sizeof(stbuf));
73  	stbuf.st_ino = ino;
74  	fuse_add_direntry(req, b->p + oldsize, b->size - oldsize, name, &stbuf,
75  			  b->size);
76  }
77  #define min(x, y) ((x) < (y) ? (x) : (y))
78  static int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,
79  			     off_t off, size_t maxsize)
80  {
81  	if (off < bufsize)
82  		return fuse_reply_buf(req, buf + off,
83  				      min(bufsize - off, maxsize));
84  	else
85  		return fuse_reply_buf(req, NULL, 0);
86  }
87  static void hello_ll_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
88  			     off_t off, struct fuse_file_info *fi)
89  {
90  	(void) fi;
91  	if (ino != 1)
92  		fuse_reply_err(req, ENOTDIR);
93  	else {
94  		struct dirbuf b;
95  		memset(&b, 0, sizeof(b));
96  		dirbuf_add(req, &b, ".", 1);
97  		dirbuf_add(req, &b, "..", 1);
98  		dirbuf_add(req, &b, hello_name, 2);
99  		reply_buf_limited(req, b.p, b.size, off, size);
100  		free(b.p);
101  	}
102  }
103  static void hello_ll_open(fuse_req_t req, fuse_ino_t ino,
104  			  struct fuse_file_info *fi)
105  {
106  	if (ino != 2)
107  		fuse_reply_err(req, EISDIR);
108  	else if ((fi->flags & O_ACCMODE) != O_RDONLY)
109  		fuse_reply_err(req, EACCES);
110  	else
111  		fuse_reply_open(req, fi);
112  }
<span onclick='openModal()' class='match'>113  static void hello_ll_read(fuse_req_t req, fuse_ino_t ino, size_t size,
114  			  off_t off, struct fuse_file_info *fi)
115  {
116  	(void) fi;
117  	assert(ino == 2);
118  	reply_buf_limited(req, hello_str, strlen(hello_str), off, size);
</span>119  }
120  static const struct fuse_lowlevel_ops hello_ll_oper = {
121  	.lookup		= hello_ll_lookup,
122  	.getattr	= hello_ll_getattr,
123  	.readdir	= hello_ll_readdir,
124  	.open		= hello_ll_open,
125  	.read		= hello_ll_read,
126  };
127  static int create_socket(const char *socket_path) {
128  	struct sockaddr_un addr;
129  	if (strnlen(socket_path, sizeof(addr.sun_path)) >=
130  		sizeof(addr.sun_path)) {
131  		printf("Socket path may not be longer than %lu characters\n",
132  			 sizeof(addr.sun_path) - 1);
133  		return -1;
134  	}
135  	if (remove(socket_path) == -1 && errno != ENOENT) {
136  		printf("Could not delete previous socket file entry at %s. Error: "
137  			 "%s\n", socket_path, strerror(errno));
138  		return -1;
139  	}
140  	memset(&addr, 0, sizeof(struct sockaddr_un));
141  	strcpy(addr.sun_path, socket_path);
142  	int sfd = socket(AF_UNIX, SOCK_STREAM, 0);
143  	if (sfd == -1) {
144  		printf("Could not create socket. Error: %s\n", strerror(errno));
145  		return -1;
146  	}
147  	addr.sun_family = AF_UNIX;
148  	if (bind(sfd, (struct sockaddr *) &addr,
149  		   sizeof(struct sockaddr_un)) == -1) {
150  		printf("Could not bind socket. Error: %s\n", strerror(errno));
151  		return -1;
152  	}
153  	if (listen(sfd, 1) == -1)
154  		return -1;
155  	printf("Awaiting connection on socket at %s...\n", socket_path);
156  	int cfd = accept(sfd, NULL, NULL);
157  	if (cfd == -1) {
158  		printf("Could not accept connection. Error: %s\n",
159  			 strerror(errno));
160  		return -1;
161  	} else {
162  		printf("Accepted connection!\n");
163  	}
164  	return cfd;
165  }
166  static ssize_t stream_writev(int fd, struct iovec *iov, int count,
167                               void *userdata) {
168  	(void)userdata;
169  	ssize_t written = 0;
170  	int cur = 0;
171  	for (;;) {
172  		written = writev(fd, iov+cur, count-cur);
173  		if (written < 0)
174  			return written;
175  		while (cur < count && written >= iov[cur].iov_len)
176  			written -= iov[cur++].iov_len;
177  		if (cur == count)
178  			break;
179  		iov[cur].iov_base = (char *)iov[cur].iov_base + written;
180  		iov[cur].iov_len -= written;
181  	}
182  	return written;
183  }
184  static ssize_t readall(int fd, void *buf, size_t len) {
185  	size_t count = 0;
186  	while (count < len) {
187  		int i = read(fd, (char *)buf + count, len - count);
188  		if (!i)
189  			break;
190  		if (i < 0)
191  			return i;
192  		count += i;
193  	}
194  	return count;
195  }
196  static ssize_t stream_read(int fd, void *buf, size_t buf_len, void *userdata) {
197      (void)userdata;
198  	int res = readall(fd, buf, sizeof(struct fuse_in_header));
199  	if (res == -1)
200      	return res;
201      uint32_t packet_len = ((struct fuse_in_header *)buf)->len;
202      if (packet_len > buf_len)
203      	return -1;
204      int prev_res = res;
205      res = readall(fd, (char *)buf + sizeof(struct fuse_in_header),
206                    packet_len - sizeof(struct fuse_in_header));
207      return  (res == -1) ? res : (res + prev_res);
208  }
209  static ssize_t stream_splice_send(int fdin, off_t *offin, int fdout,
210  					    off_t *offout, size_t len,
211                                    unsigned int flags, void *userdata) {
212  	(void)userdata;
213  	size_t count = 0;
214  	while (count < len) {
215  		int i = splice(fdin, offin, fdout, offout, len - count, flags);
216  		if (i < 1)
217  			return i;
218  		count += i;
219  	}
220  	return count;
221  }
222  static void fuse_cmdline_help_uds(void)
223  {
224  	printf("    -h   --help            print help\n"
225  	       "    -V   --version         print version\n"
226  	       "    -d   -o debug          enable debug output (implies -f)\n");
227  }
228  int main(int argc, char *argv[])
229  {
230  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
231  	struct fuse_session *se;
232  	struct fuse_cmdline_opts opts;
233  	const struct fuse_custom_io io = {
234  		.writev = stream_writev,
235  		.read = stream_read,
236  		.splice_receive = NULL,
237  		.splice_send = stream_splice_send,
238  	};
239  	int cfd = -1;
240  	int ret = -1;
241  	if (fuse_parse_cmdline(&args, &opts) != 0)
242  		return 1;
243  	if (opts.show_help) {
244  		printf("usage: %s [options]\n\n", argv[0]);
245  		fuse_cmdline_help_uds();
246  		fuse_lowlevel_help();
247  		ret = 0;
248  		goto err_out1;
249  	} else if (opts.show_version) {
250  		printf("FUSE library version %s\n", fuse_pkgversion());
251  		fuse_lowlevel_version();
252  		ret = 0;
253  		goto err_out1;
254  	}
255  	se = fuse_session_new(&args, &hello_ll_oper,
256  			      sizeof(hello_ll_oper), NULL);
257  	if (se == NULL)
258  	    goto err_out1;
259  	if (fuse_set_signal_handlers(se) != 0)
260  	    goto err_out2;
261  	cfd = create_socket("/tmp/libfuse-hello-ll.sock");
262  	if (cfd == -1)
263  		goto err_out3;
264  	if (fuse_session_custom_io(se, &io, cfd) != 0)
265  		goto err_out3;
266  	ret = fuse_session_loop(se);
267  err_out3:
268  	fuse_remove_signal_handlers(se);
269  err_out2:
270  	fuse_session_destroy(se);
271  err_out1:
272  	free(opts.mountpoint);
273  	fuse_opt_free_args(&args);
274  	return ret ? 1 : 0;
275  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tweetnacl.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #define FOR(i,n) for (i = 0;i < n;++i)
3  #define sv static void
4  typedef unsigned char u8;
5  typedef ulong32 u32;
6  typedef ulong64 u64;
7  typedef long64 i64;
8  typedef i64 gf[16];
9  static const u8
10    nine[32] = {9};
11  static const gf
12    gf0,
13    gf1 = {1},
14    gf121665 = {0xDB41,1},
15    D = {0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203},
16    D2 = {0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406},
17    X = {0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169},
18    Y = {0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666},
19    I = {0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83};
20  static int vn(const u8 *x,const u8 *y,int n)
21  {
22    int i;
23    u32 d = 0;
24    FOR(i,n) d |= x[i]^y[i];
25    return (1 & ((d - 1) >> 8)) - 1;
26  }
27  static int tweetnacl_crypto_verify_32(const u8 *x,const u8 *y)
28  {
29    return vn(x,y,32);
30  }
31  sv set25519(gf r, const gf a)
32  {
33    int i;
34    FOR(i,16) r[i]=a[i];
35  }
36  sv car25519(gf o)
37  {
38    int i;
39    i64 c;
40    FOR(i,16) {
41      o[i]+=(1LL<<16);
42      c=o[i]>>16;
43      o[(i+1)*(i<15)]+=c-1+37*(c-1)*(i==15);
44      o[i]-=c<<16;
45    }
46  }
47  sv sel25519(gf p,gf q,int b)
48  {
49    i64 t,i,c=~(b-1);
50    FOR(i,16) {
51      t= c&(p[i]^q[i]);
52      p[i]^=t;
53      q[i]^=t;
54    }
55  }
56  sv pack25519(u8 *o,const gf n)
57  {
58    int i,j,b;
59    gf m,t;
60    FOR(i,16) t[i]=n[i];
61    car25519(t);
62    car25519(t);
63    car25519(t);
64    FOR(j,2) {
65      m[0]=t[0]-0xffed;
66      for(i=1;i<15;i++) {
67        m[i]=t[i]-0xffff-((m[i-1]>>16)&1);
68        m[i-1]&=0xffff;
69      }
70      m[15]=t[15]-0x7fff-((m[14]>>16)&1);
71      b=(m[15]>>16)&1;
72      m[14]&=0xffff;
73      sel25519(t,m,1-b);
74    }
75    FOR(i,16) {
76      o[2*i]=t[i]&0xff;
77      o[2*i+1]=t[i]>>8;
78    }
79  }
80  static int neq25519(const gf a, const gf b)
81  {
82    u8 c[32],d[32];
83    pack25519(c,a);
84    pack25519(d,b);
85    return tweetnacl_crypto_verify_32(c,d);
86  }
87  static u8 par25519(const gf a)
88  {
89    u8 d[32];
90    pack25519(d,a);
91    return d[0]&1;
92  }
93  sv unpack25519(gf o, const u8 *n)
94  {
95    int i;
96    FOR(i,16) o[i]=n[2*i]+((i64)n[2*i+1]<<8);
97    o[15]&=0x7fff;
98  }
99  sv A(gf o,const gf a,const gf b)
100  {
101    int i;
102    FOR(i,16) o[i]=a[i]+b[i];
103  }
104  sv Z(gf o,const gf a,const gf b)
105  {
106    int i;
107    FOR(i,16) o[i]=a[i]-b[i];
108  }
109  sv M(gf o,const gf a,const gf b)
110  {
111    i64 i,j,t[31];
112    FOR(i,31) t[i]=0;
113    FOR(i,16) FOR(j,16) t[i+j]+=a[i]*b[j];
114    FOR(i,15) t[i]+=38*t[i+16];
115    FOR(i,16) o[i]=t[i];
116    car25519(o);
117    car25519(o);
118  }
119  sv S(gf o,const gf a)
120  {
121    M(o,a,a);
122  }
123  sv inv25519(gf o,const gf i)
124  {
125    gf c;
126    int a;
127    FOR(a,16) c[a]=i[a];
128    for(a=253;a>=0;a--) {
129      S(c,c);
130      if(a!=2&&a!=4) M(c,c,i);
131    }
132    FOR(a,16) o[a]=c[a];
133  }
134  sv pow2523(gf o,const gf i)
135  {
136    gf c;
137    int a;
138    FOR(a,16) c[a]=i[a];
139    for(a=250;a>=0;a--) {
140      S(c,c);
141      if(a!=1) M(c,c,i);
142    }
143    FOR(a,16) o[a]=c[a];
144  }
145  int tweetnacl_crypto_scalarmult(u8 *q,const u8 *n,const u8 *p)
146  {
147    u8 z[32];
148    i64 x[80],r,i;
149    gf a,b,c,d,e,f;
150    FOR(i,31) z[i]=n[i];
151    z[31]=(n[31]&127)|64;
152    z[0]&=248;
153    unpack25519(x,p);
154    FOR(i,16) {
155      b[i]=x[i];
156      d[i]=a[i]=c[i]=0;
157    }
158    a[0]=d[0]=1;
159    for(i=254;i>=0;--i) {
160      r=(z[i>>3]>>(i&7))&1;
161      sel25519(a,b,r);
162      sel25519(c,d,r);
163      A(e,a,c);
164      Z(a,a,c);
165      A(c,b,d);
166      Z(b,b,d);
167      S(d,e);
168      S(f,a);
169      M(a,c,a);
170      M(c,b,e);
171      A(e,a,c);
172      Z(a,a,c);
173      S(b,a);
174      Z(c,d,f);
175      M(a,c,gf121665);
176      A(a,a,d);
177      M(c,c,a);
178      M(a,d,f);
179      M(d,b,x);
180      S(b,e);
181      sel25519(a,b,r);
182      sel25519(c,d,r);
183    }
184    FOR(i,16) {
185      x[i+16]=a[i];
186      x[i+32]=c[i];
187      x[i+48]=b[i];
188      x[i+64]=d[i];
189    }
190    inv25519(x+32,x+32);
191    M(x+16,x+16,x+32);
192    pack25519(q,x+16);
193    return 0;
194  }
195  int tweetnacl_crypto_scalarmult_base(u8 *q,const u8 *n)
196  {
197    return tweetnacl_crypto_scalarmult(q,n,nine);
198  }
199  static LTC_INLINE int tweetnacl_crypto_hash_ctx(u8 *out,const u8 *m,u64 n,const u8 *ctx,u32 cs)
200  {
201    unsigned long len = 64;
202    int hash_idx = find_hash("sha512");
203    if (n > ULONG_MAX) return CRYPT_OVERFLOW;
204    if(cs == 0)
205      return hash_memory(hash_idx, m, n, out, &len);
206    return hash_memory_multi(hash_idx, out, &len, ctx, cs, m, n, LTC_NULL);
207  }
208  static LTC_INLINE int tweetnacl_crypto_hash(u8 *out,const u8 *m,u64 n)
209  {
210    return tweetnacl_crypto_hash_ctx(out, m, n, NULL, 0);
211  }
212  sv add(gf p[4],gf q[4])
213  {
214    gf a,b,c,d,t,e,f,g,h;
215    Z(a, p[1], p[0]);
216    Z(t, q[1], q[0]);
217    M(a, a, t);
218    A(b, p[0], p[1]);
219    A(t, q[0], q[1]);
220    M(b, b, t);
221    M(c, p[3], q[3]);
222    M(c, c, D2);
223    M(d, p[2], q[2]);
224    A(d, d, d);
225    Z(e, b, a);
226    Z(f, d, c);
227    A(g, d, c);
228    A(h, b, a);
229    M(p[0], e, f);
230    M(p[1], h, g);
231    M(p[2], g, f);
232    M(p[3], e, h);
233  }
234  sv cswap(gf p[4],gf q[4],u8 b)
235  {
236    int i;
237    FOR(i,4)
238      sel25519(p[i],q[i],b);
239  }
240  sv pack(u8 *r,gf p[4])
241  {
242    gf tx, ty, zi;
243    inv25519(zi, p[2]);
244    M(tx, p[0], zi);
245    M(ty, p[1], zi);
246    pack25519(r, ty);
247    r[31] ^= par25519(tx) << 7;
248  }
249  sv scalarmult(gf p[4],gf q[4],const u8 *s)
250  {
251    int i;
252    set25519(p[0],gf0);
253    set25519(p[1],gf1);
254    set25519(p[2],gf1);
255    set25519(p[3],gf0);
256    for (i = 255;i >= 0;--i) {
257      u8 b = (s[i/8]>>(i&7))&1;
258      cswap(p,q,b);
259      add(q,p);
260      add(p,p);
261      cswap(p,q,b);
262    }
263  }
264  sv scalarbase(gf p[4],const u8 *s)
265  {
266    gf q[4];
267    set25519(q[0],X);
268    set25519(q[1],Y);
269    set25519(q[2],gf1);
270    M(q[3],X,Y);
271    scalarmult(p,q,s);
272  }
273  int tweetnacl_crypto_sk_to_pk(u8 *pk, const u8 *sk)
274  {
275    u8 d[64];
276    gf p[4];
277    tweetnacl_crypto_hash(d, sk, 32);
278    d[0] &= 248;
279    d[31] &= 127;
280    d[31] |= 64;
281    scalarbase(p,d);
282    pack(pk,p);
283    return 0;
284  }
285  int tweetnacl_crypto_sign_keypair(prng_state *prng, int wprng, u8 *pk, u8 *sk)
286  {
287    int err;
288    if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
289       return err;
290    }
291    if (prng_descriptor[wprng].read(sk,32, prng) != 32) {
292       return CRYPT_ERROR_READPRNG;
293    }
294    if ((err = tweetnacl_crypto_sk_to_pk(pk, sk)) != CRYPT_OK) {
295       return err;
296    }
297    return CRYPT_OK;
298  }
299  static const u64 L[32] = {0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10};
300  sv modL(u8 *r,i64 x[64])
301  {
302    i64 carry,i,j;
303    for (i = 63;i >= 32;--i) {
304      carry = 0;
305      for (j = i - 32;j < i - 12;++j) {
306        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
307        carry = (x[j] + 128) >> 8;
308        x[j] -= carry << 8;
309      }
310      x[j] += carry;
311      x[i] = 0;
312    }
313    carry = 0;
314    FOR(j,32) {
315      x[j] += carry - (x[31] >> 4) * L[j];
316      carry = x[j] >> 8;
317      x[j] &= 255;
318    }
319    FOR(j,32) x[j] -= carry * L[j];
320    FOR(i,32) {
321      x[i+1] += x[i] >> 8;
322      r[i] = x[i] & 255;
323    }
324  }
325  sv reduce(u8 *r)
326  {
327    i64 x[64],i;
328    FOR(i,64) x[i] = (u64) r[i];
329    FOR(i,64) r[i] = 0;
330    modL(r,x);
331  }
332  int tweetnacl_crypto_sign(u8 *sm,u64 *smlen,const u8 *m,u64 mlen,const u8 *sk,const u8 *pk, const u8 *ctx, u64 cs)
333  {
334    u8 d[64],h[64],r[64];
335    i64 i,j,x[64];
336    gf p[4];
337    tweetnacl_crypto_hash(d, sk, 32);
338    d[0] &= 248;
339    d[31] &= 127;
340    d[31] |= 64;
341    *smlen = mlen+64;
342    FOR(i,(i64)mlen) sm[64 + i] = m[i];
343    FOR(i,32) sm[32 + i] = d[32 + i];
344    tweetnacl_crypto_hash_ctx(r, sm+32, mlen+32,ctx,cs);
345    reduce(r);
346    scalarbase(p,r);
347    pack(sm,p);
348    FOR(i,32) sm[i+32] = pk[i];
349    tweetnacl_crypto_hash_ctx(h,sm,mlen + 64,ctx,cs);
350    reduce(h);
351    FOR(i,64) x[i] = 0;
352    FOR(i,32) x[i] = (u64) r[i];
353    FOR(i,32) FOR(j,32) x[i+j] += h[i] * (u64) d[j];
354    modL(sm + 32,x);
355    return 0;
356  }
357  static int unpackneg(gf r[4],const u8 p[32])
358  {
359    gf t, chk, num, den, den2, den4, den6;
360    set25519(r[2],gf1);
361    unpack25519(r[1],p);
362    S(num,r[1]);
363    M(den,num,D);
364    Z(num,num,r[2]);
365    A(den,r[2],den);
366    S(den2,den);
367    S(den4,den2);
368    M(den6,den4,den2);
369    M(t,den6,num);
370    M(t,t,den);
371    pow2523(t,t);
372    M(t,t,num);
373    M(t,t,den);
374    M(t,t,den);
375    M(r[0],t,den);
376    S(chk,r[0]);
377    M(chk,chk,den);
378    if (neq25519(chk, num)) M(r[0],r[0],I);
379    S(chk,r[0]);
380    M(chk,chk,den);
381    if (neq25519(chk, num)) return -1;
382    if (par25519(r[0]) == (p[31]>>7)) Z(r[0],gf0,r[0]);
383    M(r[3],r[0],r[1]);
384    return 0;
385  }
386  int tweetnacl_crypto_sign_open(int *stat, u8 *m,u64 *mlen,const u8 *sm,u64 smlen,const u8 *ctx,u64 cs,const u8 *pk)
387  {
388    u64 i;
389    u8 s[32],t[32],h[64];
390    gf p[4],q[4];
391    *stat = 0;
392    if (*mlen < smlen) return CRYPT_BUFFER_OVERFLOW;
393    *mlen = -1;
394    if (smlen < 64) return CRYPT_INVALID_ARG;
395    if (unpackneg(q,pk)) return CRYPT_ERROR;
<span onclick='openModal()' class='match'>396    XMEMMOVE(m,sm,smlen);
397    XMEMMOVE(s,m + 32,32);
398    XMEMMOVE(m + 32,pk,32);
399    tweetnacl_crypto_hash_ctx(h,m,smlen,ctx,cs);
</span>400    reduce(h);
401    scalarmult(p,q,h);
402    scalarbase(q,s);
403    add(p,q);
404    pack(t,p);
405    smlen -= 64;
406    if (tweetnacl_crypto_verify_32(sm, t)) {
407      FOR(i,smlen) m[i] = 0;
408      zeromem(m, smlen);
409      return CRYPT_OK;
410    }
411    *stat = 1;
412    XMEMMOVE(m,m + 64,smlen);
413    *mlen = smlen;
414    return CRYPT_OK;
415  }
416  int tweetnacl_crypto_ph(u8 *out,const u8 *msg,u64 msglen)
417  {
418    return tweetnacl_crypto_hash(out, msg, msglen);
419  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-hello_ll_uds.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tweetnacl.c</div>
                </div>
                <div class="column column_space"><pre><code>113  static void hello_ll_read(fuse_req_t req, fuse_ino_t ino, size_t size,
114  			  off_t off, struct fuse_file_info *fi)
115  {
116  	(void) fi;
117  	assert(ino == 2);
118  	reply_buf_limited(req, hello_str, strlen(hello_str), off, size);
</pre></code></div>
                <div class="column column_space"><pre><code>396    XMEMMOVE(m,sm,smlen);
397    XMEMMOVE(s,m + 32,32);
398    XMEMMOVE(m + 32,pk,32);
399    tweetnacl_crypto_hash_ctx(h,m,smlen,ctx,cs);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    