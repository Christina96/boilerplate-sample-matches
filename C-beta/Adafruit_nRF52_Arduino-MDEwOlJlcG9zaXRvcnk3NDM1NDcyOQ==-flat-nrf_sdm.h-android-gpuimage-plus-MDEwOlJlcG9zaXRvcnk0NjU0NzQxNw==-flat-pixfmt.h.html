
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 38.62068965517241%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_sdm.h</h3>
            <pre><code>1  #ifndef NRF_SDM_H__
2  #define NRF_SDM_H__
3  #include <stdint.h>
4  #include "nrf.h"
5  #include "nrf_svc.h"
6  #include "nrf_error.h"
7  #include "nrf_error_sdm.h"
8  #include "nrf_soc.h"
9  #ifdef __cplusplus
10  extern "C" {
11  #endif
12  #ifdef NRFSOC_DOXYGEN
13  #define MBR_SIZE 0
14  #warning test
15  #endif
16  #define SD_MAJOR_VERSION  (6)
17  #define SD_MINOR_VERSION  (1)
18  #define SD_BUGFIX_VERSION (1)
19  #define SD_VARIANT_ID 140
20  #define SD_VERSION (SD_MAJOR_VERSION * 1000000 + SD_MINOR_VERSION * 1000 + SD_BUGFIX_VERSION)
21  #define SDM_SVC_BASE 0x10
22  #define SD_UNIQUE_STR_SIZE 20
23  #define SDM_INFO_FIELD_INVALID (0)
24  #define SOFTDEVICE_INFO_STRUCT_OFFSET (0x2000)
25  #define SOFTDEVICE_INFO_STRUCT_ADDRESS (SOFTDEVICE_INFO_STRUCT_OFFSET + MBR_SIZE)
26  #define SD_INFO_STRUCT_SIZE_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET)
27  #define SD_SIZE_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x08)
28  #define SD_FWID_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x0C)
29  #define SD_ID_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x10)
30  #define SD_VERSION_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x14)
31  #define SD_UNIQUE_STR_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x18)
32  #define SD_INFO_STRUCT_SIZE_GET(baseaddr) (*((uint8_t *) ((baseaddr) + SD_INFO_STRUCT_SIZE_OFFSET)))
33  #define SD_SIZE_GET(baseaddr) (*((uint32_t *) ((baseaddr) + SD_SIZE_OFFSET)))
34  #define SD_FLASH_SIZE 0x25000
35  #define SD_FWID_GET(baseaddr) (*((uint16_t *) ((baseaddr) + SD_FWID_OFFSET)))
36  #define SD_ID_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_ID_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET)) \
37          ? (*((uint32_t *) ((baseaddr) + SD_ID_OFFSET))) : SDM_INFO_FIELD_INVALID)
38  #define SD_VERSION_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_VERSION_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET)) \
39          ? (*((uint32_t *) ((baseaddr) + SD_VERSION_OFFSET))) : SDM_INFO_FIELD_INVALID)
40  #define SD_UNIQUE_STR_ADDR_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_UNIQUE_STR_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET)) \
41          ? (((uint8_t *) ((baseaddr) + SD_UNIQUE_STR_OFFSET))) : SDM_INFO_FIELD_INVALID)
42  #define NRF_FAULT_ID_SD_RANGE_START     0x00000000            &bsol;**< SoftDevice ID range start. */
43  #define NRF_FAULT_ID_APP_RANGE_START    0x00001000            &bsol;**< Application ID range start. */
44  #define NRF_FAULT_ID_SD_ASSERT    (NRF_FAULT_ID_SD_RANGE_START  + 1)          &bsol;**< SoftDevice assertion. The info parameter is reserved for future used. */
45  #define NRF_FAULT_ID_APP_MEMACC   (NRF_FAULT_ID_APP_RANGE_START + 1)          &bsol;**< Application invalid memory access. The info parameter will contain 0x00000000,
46                                                                                     in case of SoftDevice RAM access violation. In case of SoftDevice peripheral
47                                                                                     register violation the info parameter will contain the sub-region number of
48                                                                                     PREGION[0], on whose address range the disallowed write access caused the
49                                                                                     memory access fault. */
50  enum NRF_SD_SVCS
51  {
52    SD_SOFTDEVICE_ENABLE = SDM_SVC_BASE, &bsol;**< ::sd_softdevice_enable */
53    SD_SOFTDEVICE_DISABLE,               &bsol;**< ::sd_softdevice_disable */
54    SD_SOFTDEVICE_IS_ENABLED,            &bsol;**< ::sd_softdevice_is_enabled */
55    SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET, &bsol;**< ::sd_softdevice_vector_table_base_set */
56    SVC_SDM_LAST                         &bsol;**< Placeholder for last SDM SVC */
57  };
58  #define NRF_CLOCK_LF_ACCURACY_250_PPM (0) &bsol;**< Default: 250 ppm */
59  #define NRF_CLOCK_LF_ACCURACY_500_PPM (1) &bsol;**< 500 ppm */
60  #define NRF_CLOCK_LF_ACCURACY_150_PPM (2) &bsol;**< 150 ppm */
61  #define NRF_CLOCK_LF_ACCURACY_100_PPM (3) &bsol;**< 100 ppm */
62  #define NRF_CLOCK_LF_ACCURACY_75_PPM  (4) &bsol;**< 75 ppm */
63  #define NRF_CLOCK_LF_ACCURACY_50_PPM  (5) &bsol;**< 50 ppm */
64  #define NRF_CLOCK_LF_ACCURACY_30_PPM  (6) &bsol;**< 30 ppm */
65  #define NRF_CLOCK_LF_ACCURACY_20_PPM  (7) &bsol;**< 20 ppm */
66  #define NRF_CLOCK_LF_ACCURACY_10_PPM  (8) &bsol;**< 10 ppm */
67  #define NRF_CLOCK_LF_ACCURACY_5_PPM   (9) &bsol;**<  5 ppm */
68  #define NRF_CLOCK_LF_ACCURACY_2_PPM  (10) &bsol;**<  2 ppm */
69  #define NRF_CLOCK_LF_ACCURACY_1_PPM  (11) &bsol;**<  1 ppm */
70  #define NRF_CLOCK_LF_SRC_RC      (0)                        &bsol;**< LFCLK RC oscillator. */
71  #define NRF_CLOCK_LF_SRC_XTAL    (1)                        &bsol;**< LFCLK crystal oscillator. */
72  #define NRF_CLOCK_LF_SRC_SYNTH   (2)                        &bsol;**< LFCLK Synthesized from HFCLK. */
73  typedef struct
74  {
75    uint8_t source;         &bsol;**< LF oscillator clock source, see @ref NRF_CLOCK_LF_SRC. */
76    uint8_t rc_ctiv;        &bsol;**< Only for ::NRF_CLOCK_LF_SRC_RC: Calibration timer interval in 1/4 second
77                                 units (nRF52: 1-32).
78                                 @note To avoid excessive clock drift, 0.5 degrees Celsius is the
79                                       maximum temperature change allowed in one calibration timer
80                                       interval. The interval should be selected to ensure this.
81                                    @note Must be 0 if source is not ::NRF_CLOCK_LF_SRC_RC.  */
82    uint8_t rc_temp_ctiv;   &bsol;**<  Only for ::NRF_CLOCK_LF_SRC_RC: How often (in number of calibration
83                                  intervals) the RC oscillator shall be calibrated if the temperature
84                                  hasn't changed.
85                                       0: Always calibrate even if the temperature hasn't changed.
86                                       1: Only calibrate if the temperature has changed (legacy - nRF51 only).
87                                       2-33: Check the temperature and only calibrate if it has changed,
88                                             however calibration will take place every rc_temp_ctiv
89                                             intervals in any case.
90                                  @note Must be 0 if source is not ::NRF_CLOCK_LF_SRC_RC.
91                                  @note For nRF52, the application must ensure calibration at least once
92                                        every 8 seconds to ensure +/-500 ppm clock stability. The
93                                        recommended configuration for ::NRF_CLOCK_LF_SRC_RC on nRF52 is
94                                        rc_ctiv=16 and rc_temp_ctiv=2. This will ensure calibration at
95                                        least once every 8 seconds and for temperature changes of 0.5
96                                        degrees Celsius every 4 seconds. See the Product Specification
<span onclick='openModal()' class='match'>97                                        for the nRF52 device being used for more information.*/
98    uint8_t accuracy;       &bsol;**< External clock accuracy used in the LL to compute timing
99                                 windows, see @ref NRF_CLOCK_LF_ACCURACY.*/
</span>100  } nrf_clock_lf_cfg_t;
101  typedef void (*nrf_fault_handler_t)(uint32_t id, uint32_t pc, uint32_t info);
102  SVCALL(SD_SOFTDEVICE_ENABLE, uint32_t, sd_softdevice_enable(nrf_clock_lf_cfg_t const * p_clock_lf_cfg, nrf_fault_handler_t fault_handler));
103  SVCALL(SD_SOFTDEVICE_DISABLE, uint32_t, sd_softdevice_disable(void));
104  SVCALL(SD_SOFTDEVICE_IS_ENABLED, uint32_t, sd_softdevice_is_enabled(uint8_t * p_softdevice_enabled));
105  SVCALL(SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET, uint32_t, sd_softdevice_vector_table_base_set(uint32_t address));
106  #ifdef __cplusplus
107  }
108  #endif
109  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-pixfmt.h</h3>
            <pre><code>1  #ifndef AVUTIL_PIXFMT_H
2  #define AVUTIL_PIXFMT_H
3  #include "libavutil/avconfig.h"
4  #include "version.h"
5  #define AVPALETTE_SIZE 1024
6  #define AVPALETTE_COUNT 256
7  enum AVPixelFormat {
8      AV_PIX_FMT_NONE = -1,
9      AV_PIX_FMT_YUV420P,   
10      AV_PIX_FMT_YUYV422,   
11      AV_PIX_FMT_RGB24,     
12      AV_PIX_FMT_BGR24,     
13      AV_PIX_FMT_YUV422P,   
14      AV_PIX_FMT_YUV444P,   
15      AV_PIX_FMT_YUV410P,   
16      AV_PIX_FMT_YUV411P,   
17      AV_PIX_FMT_GRAY8,     
18      AV_PIX_FMT_MONOWHITE, 
19      AV_PIX_FMT_MONOBLACK, 
20      AV_PIX_FMT_PAL8,      
21      AV_PIX_FMT_YUVJ420P,  
22      AV_PIX_FMT_YUVJ422P,  
23      AV_PIX_FMT_YUVJ444P,  
24  #if FF_API_XVMC
25      AV_PIX_FMT_XVMC_MPEG2_MC,
26      AV_PIX_FMT_XVMC_MPEG2_IDCT,
27      AV_PIX_FMT_XVMC = AV_PIX_FMT_XVMC_MPEG2_IDCT,
28  #endif &bsol;* FF_API_XVMC */
29      AV_PIX_FMT_UYVY422,   
30      AV_PIX_FMT_UYYVYY411, 
31      AV_PIX_FMT_BGR8,      
32      AV_PIX_FMT_BGR4,      
33      AV_PIX_FMT_BGR4_BYTE, 
34      AV_PIX_FMT_RGB8,      
35      AV_PIX_FMT_RGB4,      
36      AV_PIX_FMT_RGB4_BYTE, 
37      AV_PIX_FMT_NV12,      
38      AV_PIX_FMT_NV21,      
39      AV_PIX_FMT_ARGB,      
40      AV_PIX_FMT_RGBA,      
41      AV_PIX_FMT_ABGR,      
42      AV_PIX_FMT_BGRA,      
43      AV_PIX_FMT_GRAY16BE,  
44      AV_PIX_FMT_GRAY16LE,  
45      AV_PIX_FMT_YUV440P,   
46      AV_PIX_FMT_YUVJ440P,  
47      AV_PIX_FMT_YUVA420P,  
48  #if FF_API_VDPAU
49      AV_PIX_FMT_VDPAU_H264,
50      AV_PIX_FMT_VDPAU_MPEG1,
51      AV_PIX_FMT_VDPAU_MPEG2,
52      AV_PIX_FMT_VDPAU_WMV3,
53      AV_PIX_FMT_VDPAU_VC1, 
54  #endif
55      AV_PIX_FMT_RGB48BE,   
56      AV_PIX_FMT_RGB48LE,   
57      AV_PIX_FMT_RGB565BE,  
58      AV_PIX_FMT_RGB565LE,  
59      AV_PIX_FMT_RGB555BE,  
60      AV_PIX_FMT_RGB555LE,  
61      AV_PIX_FMT_BGR565BE,  
62      AV_PIX_FMT_BGR565LE,  
63      AV_PIX_FMT_BGR555BE,  
64      AV_PIX_FMT_BGR555LE,  
65  #if FF_API_VAAPI
66      AV_PIX_FMT_VAAPI_MOCO, 
67      AV_PIX_FMT_VAAPI_IDCT, 
68      AV_PIX_FMT_VAAPI_VLD,  
69      AV_PIX_FMT_VAAPI = AV_PIX_FMT_VAAPI_VLD,
70  #else
71      AV_PIX_FMT_VAAPI,
72  #endif
73      AV_PIX_FMT_YUV420P16LE,  
74      AV_PIX_FMT_YUV420P16BE,  
75      AV_PIX_FMT_YUV422P16LE,  
76      AV_PIX_FMT_YUV422P16BE,  
<span onclick='openModal()' class='match'>77      AV_PIX_FMT_YUV444P16LE,  
78      AV_PIX_FMT_YUV444P16BE,  
79  #if FF_API_VDPAU
80      AV_PIX_FMT_VDPAU_MPEG4,  
81  #endif
82      AV_PIX_FMT_DXVA2_VLD,    
83      AV_PIX_FMT_RGB444LE,  
84      AV_PIX_FMT_RGB444BE,  
85      AV_PIX_FMT_BGR444LE,  
86      AV_PIX_FMT_BGR444BE,  
87      AV_PIX_FMT_YA8,       
88      AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8, 
89      AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8, 
90      AV_PIX_FMT_BGR48BE,   
91      AV_PIX_FMT_BGR48LE,   
</span>92      AV_PIX_FMT_YUV420P9BE, 
93      AV_PIX_FMT_YUV420P9LE, 
94      AV_PIX_FMT_YUV420P10BE,
95      AV_PIX_FMT_YUV420P10LE,
96      AV_PIX_FMT_YUV422P10BE,
97      AV_PIX_FMT_YUV422P10LE,
98      AV_PIX_FMT_YUV444P9BE, 
99      AV_PIX_FMT_YUV444P9LE, 
100      AV_PIX_FMT_YUV444P10BE,
101      AV_PIX_FMT_YUV444P10LE,
102      AV_PIX_FMT_YUV422P9BE, 
103      AV_PIX_FMT_YUV422P9LE, 
104      AV_PIX_FMT_VDA_VLD,    
105      AV_PIX_FMT_GBRP,      
106      AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP, 
107      AV_PIX_FMT_GBRP9BE,   
108      AV_PIX_FMT_GBRP9LE,   
109      AV_PIX_FMT_GBRP10BE,  
110      AV_PIX_FMT_GBRP10LE,  
111      AV_PIX_FMT_GBRP16BE,  
112      AV_PIX_FMT_GBRP16LE,  
113      AV_PIX_FMT_YUVA422P,  
114      AV_PIX_FMT_YUVA444P,  
115      AV_PIX_FMT_YUVA420P9BE,  
116      AV_PIX_FMT_YUVA420P9LE,  
117      AV_PIX_FMT_YUVA422P9BE,  
118      AV_PIX_FMT_YUVA422P9LE,  
119      AV_PIX_FMT_YUVA444P9BE,  
120      AV_PIX_FMT_YUVA444P9LE,  
121      AV_PIX_FMT_YUVA420P10BE, 
122      AV_PIX_FMT_YUVA420P10LE, 
123      AV_PIX_FMT_YUVA422P10BE, 
124      AV_PIX_FMT_YUVA422P10LE, 
125      AV_PIX_FMT_YUVA444P10BE, 
126      AV_PIX_FMT_YUVA444P10LE, 
127      AV_PIX_FMT_YUVA420P16BE, 
128      AV_PIX_FMT_YUVA420P16LE, 
129      AV_PIX_FMT_YUVA422P16BE, 
130      AV_PIX_FMT_YUVA422P16LE, 
131      AV_PIX_FMT_YUVA444P16BE, 
132      AV_PIX_FMT_YUVA444P16LE, 
133      AV_PIX_FMT_VDPAU,     
134      AV_PIX_FMT_XYZ12LE,      
135      AV_PIX_FMT_XYZ12BE,      
136      AV_PIX_FMT_NV16,         
137      AV_PIX_FMT_NV20LE,       
138      AV_PIX_FMT_NV20BE,       
139      AV_PIX_FMT_RGBA64BE,     
140      AV_PIX_FMT_RGBA64LE,     
141      AV_PIX_FMT_BGRA64BE,     
142      AV_PIX_FMT_BGRA64LE,     
143      AV_PIX_FMT_YVYU422,   
144      AV_PIX_FMT_VDA,          
145      AV_PIX_FMT_YA16BE,       
146      AV_PIX_FMT_YA16LE,       
147      AV_PIX_FMT_GBRAP,        
148      AV_PIX_FMT_GBRAP16BE,    
149      AV_PIX_FMT_GBRAP16LE,    
150      AV_PIX_FMT_QSV,
151      AV_PIX_FMT_MMAL,
152      AV_PIX_FMT_D3D11VA_VLD,  
153      AV_PIX_FMT_CUDA,
154      AV_PIX_FMT_0RGB=0x123+4,
155      AV_PIX_FMT_RGB0,        
156      AV_PIX_FMT_0BGR,        
157      AV_PIX_FMT_BGR0,        
158      AV_PIX_FMT_YUV420P12BE, 
159      AV_PIX_FMT_YUV420P12LE, 
160      AV_PIX_FMT_YUV420P14BE, 
161      AV_PIX_FMT_YUV420P14LE, 
162      AV_PIX_FMT_YUV422P12BE, 
163      AV_PIX_FMT_YUV422P12LE, 
164      AV_PIX_FMT_YUV422P14BE, 
165      AV_PIX_FMT_YUV422P14LE, 
166      AV_PIX_FMT_YUV444P12BE, 
167      AV_PIX_FMT_YUV444P12LE, 
168      AV_PIX_FMT_YUV444P14BE, 
169      AV_PIX_FMT_YUV444P14LE, 
170      AV_PIX_FMT_GBRP12BE,    
171      AV_PIX_FMT_GBRP12LE,    
172      AV_PIX_FMT_GBRP14BE,    
173      AV_PIX_FMT_GBRP14LE,    
174      AV_PIX_FMT_YUVJ411P,    
175      AV_PIX_FMT_BAYER_BGGR8,    
176      AV_PIX_FMT_BAYER_RGGB8,    
177      AV_PIX_FMT_BAYER_GBRG8,    
178      AV_PIX_FMT_BAYER_GRBG8,    
179      AV_PIX_FMT_BAYER_BGGR16LE, 
180      AV_PIX_FMT_BAYER_BGGR16BE, 
181      AV_PIX_FMT_BAYER_RGGB16LE, 
182      AV_PIX_FMT_BAYER_RGGB16BE, 
183      AV_PIX_FMT_BAYER_GBRG16LE, 
184      AV_PIX_FMT_BAYER_GBRG16BE, 
185      AV_PIX_FMT_BAYER_GRBG16LE, 
186      AV_PIX_FMT_BAYER_GRBG16BE, 
187  #if !FF_API_XVMC
188      AV_PIX_FMT_XVMC,
189  #endif &bsol;* !FF_API_XVMC */
190      AV_PIX_FMT_YUV440P10LE, 
191      AV_PIX_FMT_YUV440P10BE, 
192      AV_PIX_FMT_YUV440P12LE, 
193      AV_PIX_FMT_YUV440P12BE, 
194      AV_PIX_FMT_AYUV64LE,    
195      AV_PIX_FMT_AYUV64BE,    
196      AV_PIX_FMT_VIDEOTOOLBOX, 
197      AV_PIX_FMT_P010LE, 
198      AV_PIX_FMT_P010BE, 
199      AV_PIX_FMT_GBRAP12BE,  
200      AV_PIX_FMT_GBRAP12LE,  
201      AV_PIX_FMT_GBRAP10BE,  
202      AV_PIX_FMT_GBRAP10LE,  
203      AV_PIX_FMT_MEDIACODEC, 
204      AV_PIX_FMT_GRAY12BE,   
205      AV_PIX_FMT_GRAY12LE,   
206      AV_PIX_FMT_GRAY10BE,   
207      AV_PIX_FMT_GRAY10LE,   
208      AV_PIX_FMT_P016LE, 
209      AV_PIX_FMT_P016BE, 
210      AV_PIX_FMT_D3D11,
211      AV_PIX_FMT_GRAY9BE,   
212      AV_PIX_FMT_GRAY9LE,   
213      AV_PIX_FMT_GBRPF32BE,  
214      AV_PIX_FMT_GBRPF32LE,  
215      AV_PIX_FMT_GBRAPF32BE, 
216      AV_PIX_FMT_GBRAPF32LE, 
217      AV_PIX_FMT_DRM_PRIME,
218      AV_PIX_FMT_NB         
219  };
220  #if AV_HAVE_BIGENDIAN
221  #   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##be
222  #else
223  #   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##le
224  #endif
225  #define AV_PIX_FMT_RGB32   AV_PIX_FMT_NE(ARGB, BGRA)
226  #define AV_PIX_FMT_RGB32_1 AV_PIX_FMT_NE(RGBA, ABGR)
227  #define AV_PIX_FMT_BGR32   AV_PIX_FMT_NE(ABGR, RGBA)
228  #define AV_PIX_FMT_BGR32_1 AV_PIX_FMT_NE(BGRA, ARGB)
229  #define AV_PIX_FMT_0RGB32  AV_PIX_FMT_NE(0RGB, BGR0)
230  #define AV_PIX_FMT_0BGR32  AV_PIX_FMT_NE(0BGR, RGB0)
231  #define AV_PIX_FMT_GRAY9  AV_PIX_FMT_NE(GRAY9BE,  GRAY9LE)
232  #define AV_PIX_FMT_GRAY10 AV_PIX_FMT_NE(GRAY10BE, GRAY10LE)
233  #define AV_PIX_FMT_GRAY12 AV_PIX_FMT_NE(GRAY12BE, GRAY12LE)
234  #define AV_PIX_FMT_GRAY16 AV_PIX_FMT_NE(GRAY16BE, GRAY16LE)
235  #define AV_PIX_FMT_YA16   AV_PIX_FMT_NE(YA16BE,   YA16LE)
236  #define AV_PIX_FMT_RGB48  AV_PIX_FMT_NE(RGB48BE,  RGB48LE)
237  #define AV_PIX_FMT_RGB565 AV_PIX_FMT_NE(RGB565BE, RGB565LE)
238  #define AV_PIX_FMT_RGB555 AV_PIX_FMT_NE(RGB555BE, RGB555LE)
239  #define AV_PIX_FMT_RGB444 AV_PIX_FMT_NE(RGB444BE, RGB444LE)
240  #define AV_PIX_FMT_RGBA64 AV_PIX_FMT_NE(RGBA64BE, RGBA64LE)
241  #define AV_PIX_FMT_BGR48  AV_PIX_FMT_NE(BGR48BE,  BGR48LE)
242  #define AV_PIX_FMT_BGR565 AV_PIX_FMT_NE(BGR565BE, BGR565LE)
243  #define AV_PIX_FMT_BGR555 AV_PIX_FMT_NE(BGR555BE, BGR555LE)
244  #define AV_PIX_FMT_BGR444 AV_PIX_FMT_NE(BGR444BE, BGR444LE)
245  #define AV_PIX_FMT_BGRA64 AV_PIX_FMT_NE(BGRA64BE, BGRA64LE)
246  #define AV_PIX_FMT_YUV420P9  AV_PIX_FMT_NE(YUV420P9BE , YUV420P9LE)
247  #define AV_PIX_FMT_YUV422P9  AV_PIX_FMT_NE(YUV422P9BE , YUV422P9LE)
248  #define AV_PIX_FMT_YUV444P9  AV_PIX_FMT_NE(YUV444P9BE , YUV444P9LE)
249  #define AV_PIX_FMT_YUV420P10 AV_PIX_FMT_NE(YUV420P10BE, YUV420P10LE)
250  #define AV_PIX_FMT_YUV422P10 AV_PIX_FMT_NE(YUV422P10BE, YUV422P10LE)
251  #define AV_PIX_FMT_YUV440P10 AV_PIX_FMT_NE(YUV440P10BE, YUV440P10LE)
252  #define AV_PIX_FMT_YUV444P10 AV_PIX_FMT_NE(YUV444P10BE, YUV444P10LE)
253  #define AV_PIX_FMT_YUV420P12 AV_PIX_FMT_NE(YUV420P12BE, YUV420P12LE)
254  #define AV_PIX_FMT_YUV422P12 AV_PIX_FMT_NE(YUV422P12BE, YUV422P12LE)
255  #define AV_PIX_FMT_YUV440P12 AV_PIX_FMT_NE(YUV440P12BE, YUV440P12LE)
256  #define AV_PIX_FMT_YUV444P12 AV_PIX_FMT_NE(YUV444P12BE, YUV444P12LE)
257  #define AV_PIX_FMT_YUV420P14 AV_PIX_FMT_NE(YUV420P14BE, YUV420P14LE)
258  #define AV_PIX_FMT_YUV422P14 AV_PIX_FMT_NE(YUV422P14BE, YUV422P14LE)
259  #define AV_PIX_FMT_YUV444P14 AV_PIX_FMT_NE(YUV444P14BE, YUV444P14LE)
260  #define AV_PIX_FMT_YUV420P16 AV_PIX_FMT_NE(YUV420P16BE, YUV420P16LE)
261  #define AV_PIX_FMT_YUV422P16 AV_PIX_FMT_NE(YUV422P16BE, YUV422P16LE)
262  #define AV_PIX_FMT_YUV444P16 AV_PIX_FMT_NE(YUV444P16BE, YUV444P16LE)
263  #define AV_PIX_FMT_GBRP9     AV_PIX_FMT_NE(GBRP9BE ,    GBRP9LE)
264  #define AV_PIX_FMT_GBRP10    AV_PIX_FMT_NE(GBRP10BE,    GBRP10LE)
265  #define AV_PIX_FMT_GBRP12    AV_PIX_FMT_NE(GBRP12BE,    GBRP12LE)
266  #define AV_PIX_FMT_GBRP14    AV_PIX_FMT_NE(GBRP14BE,    GBRP14LE)
267  #define AV_PIX_FMT_GBRP16    AV_PIX_FMT_NE(GBRP16BE,    GBRP16LE)
268  #define AV_PIX_FMT_GBRAP10   AV_PIX_FMT_NE(GBRAP10BE,   GBRAP10LE)
269  #define AV_PIX_FMT_GBRAP12   AV_PIX_FMT_NE(GBRAP12BE,   GBRAP12LE)
270  #define AV_PIX_FMT_GBRAP16   AV_PIX_FMT_NE(GBRAP16BE,   GBRAP16LE)
271  #define AV_PIX_FMT_BAYER_BGGR16 AV_PIX_FMT_NE(BAYER_BGGR16BE,    BAYER_BGGR16LE)
272  #define AV_PIX_FMT_BAYER_RGGB16 AV_PIX_FMT_NE(BAYER_RGGB16BE,    BAYER_RGGB16LE)
273  #define AV_PIX_FMT_BAYER_GBRG16 AV_PIX_FMT_NE(BAYER_GBRG16BE,    BAYER_GBRG16LE)
274  #define AV_PIX_FMT_BAYER_GRBG16 AV_PIX_FMT_NE(BAYER_GRBG16BE,    BAYER_GRBG16LE)
275  #define AV_PIX_FMT_GBRPF32    AV_PIX_FMT_NE(GBRPF32BE,  GBRPF32LE)
276  #define AV_PIX_FMT_GBRAPF32   AV_PIX_FMT_NE(GBRAPF32BE, GBRAPF32LE)
277  #define AV_PIX_FMT_YUVA420P9  AV_PIX_FMT_NE(YUVA420P9BE , YUVA420P9LE)
278  #define AV_PIX_FMT_YUVA422P9  AV_PIX_FMT_NE(YUVA422P9BE , YUVA422P9LE)
279  #define AV_PIX_FMT_YUVA444P9  AV_PIX_FMT_NE(YUVA444P9BE , YUVA444P9LE)
280  #define AV_PIX_FMT_YUVA420P10 AV_PIX_FMT_NE(YUVA420P10BE, YUVA420P10LE)
281  #define AV_PIX_FMT_YUVA422P10 AV_PIX_FMT_NE(YUVA422P10BE, YUVA422P10LE)
282  #define AV_PIX_FMT_YUVA444P10 AV_PIX_FMT_NE(YUVA444P10BE, YUVA444P10LE)
283  #define AV_PIX_FMT_YUVA420P16 AV_PIX_FMT_NE(YUVA420P16BE, YUVA420P16LE)
284  #define AV_PIX_FMT_YUVA422P16 AV_PIX_FMT_NE(YUVA422P16BE, YUVA422P16LE)
285  #define AV_PIX_FMT_YUVA444P16 AV_PIX_FMT_NE(YUVA444P16BE, YUVA444P16LE)
286  #define AV_PIX_FMT_XYZ12      AV_PIX_FMT_NE(XYZ12BE, XYZ12LE)
287  #define AV_PIX_FMT_NV20       AV_PIX_FMT_NE(NV20BE,  NV20LE)
288  #define AV_PIX_FMT_AYUV64     AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)
289  #define AV_PIX_FMT_P010       AV_PIX_FMT_NE(P010BE,  P010LE)
290  #define AV_PIX_FMT_P016       AV_PIX_FMT_NE(P016BE,  P016LE)
291  enum AVColorPrimaries {
292      AVCOL_PRI_RESERVED0   = 0,
293      AVCOL_PRI_BT709       = 1,  
294      AVCOL_PRI_UNSPECIFIED = 2,
295      AVCOL_PRI_RESERVED    = 3,
296      AVCOL_PRI_BT470M      = 4,  
297      AVCOL_PRI_BT470BG     = 5,  
298      AVCOL_PRI_SMPTE170M   = 6,  
299      AVCOL_PRI_SMPTE240M   = 7,  
300      AVCOL_PRI_FILM        = 8,  
301      AVCOL_PRI_BT2020      = 9,  
302      AVCOL_PRI_SMPTE428    = 10, 
303      AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,
304      AVCOL_PRI_SMPTE431    = 11, 
305      AVCOL_PRI_SMPTE432    = 12, 
306      AVCOL_PRI_JEDEC_P22   = 22, 
307      AVCOL_PRI_NB                
308  };
309  enum AVColorTransferCharacteristic {
310      AVCOL_TRC_RESERVED0    = 0,
311      AVCOL_TRC_BT709        = 1,  
312      AVCOL_TRC_UNSPECIFIED  = 2,
313      AVCOL_TRC_RESERVED     = 3,
314      AVCOL_TRC_GAMMA22      = 4,  
315      AVCOL_TRC_GAMMA28      = 5,  
316      AVCOL_TRC_SMPTE170M    = 6,  
317      AVCOL_TRC_SMPTE240M    = 7,
318      AVCOL_TRC_LINEAR       = 8,  
319      AVCOL_TRC_LOG          = 9,  
320      AVCOL_TRC_LOG_SQRT     = 10, 
321      AVCOL_TRC_IEC61966_2_4 = 11, 
322      AVCOL_TRC_BT1361_ECG   = 12, 
323      AVCOL_TRC_IEC61966_2_1 = 13, 
324      AVCOL_TRC_BT2020_10    = 14, 
325      AVCOL_TRC_BT2020_12    = 15, 
326      AVCOL_TRC_SMPTE2084    = 16, 
327      AVCOL_TRC_SMPTEST2084  = AVCOL_TRC_SMPTE2084,
328      AVCOL_TRC_SMPTE428     = 17, 
329      AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428,
330      AVCOL_TRC_ARIB_STD_B67 = 18, 
331      AVCOL_TRC_NB                 
332  };
333  enum AVColorSpace {
334      AVCOL_SPC_RGB         = 0,  
335      AVCOL_SPC_BT709       = 1,  
336      AVCOL_SPC_UNSPECIFIED = 2,
337      AVCOL_SPC_RESERVED    = 3,
338      AVCOL_SPC_FCC         = 4,  
339      AVCOL_SPC_BT470BG     = 5,  
340      AVCOL_SPC_SMPTE170M   = 6,  
341      AVCOL_SPC_SMPTE240M   = 7,  
342      AVCOL_SPC_YCGCO       = 8,  
343      AVCOL_SPC_YCOCG       = AVCOL_SPC_YCGCO,
344      AVCOL_SPC_BT2020_NCL  = 9,  
345      AVCOL_SPC_BT2020_CL   = 10, 
346      AVCOL_SPC_SMPTE2085   = 11, 
347      AVCOL_SPC_CHROMA_DERIVED_NCL = 12, 
348      AVCOL_SPC_CHROMA_DERIVED_CL = 13, 
349      AVCOL_SPC_ICTCP       = 14, 
350      AVCOL_SPC_NB                
351  };
352  enum AVColorRange {
353      AVCOL_RANGE_UNSPECIFIED = 0,
354      AVCOL_RANGE_MPEG        = 1, 
355      AVCOL_RANGE_JPEG        = 2, 
356      AVCOL_RANGE_NB               
357  };
358  enum AVChromaLocation {
359      AVCHROMA_LOC_UNSPECIFIED = 0,
360      AVCHROMA_LOC_LEFT        = 1, 
361      AVCHROMA_LOC_CENTER      = 2, 
362      AVCHROMA_LOC_TOPLEFT     = 3, 
363      AVCHROMA_LOC_TOP         = 4,
364      AVCHROMA_LOC_BOTTOMLEFT  = 5,
365      AVCHROMA_LOC_BOTTOM      = 6,
366      AVCHROMA_LOC_NB               
367  };
368  #endif &bsol;* AVUTIL_PIXFMT_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_sdm.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-pixfmt.h</div>
                </div>
                <div class="column column_space"><pre><code>97                                        for the nRF52 device being used for more information.*/
98    uint8_t accuracy;       &bsol;**< External clock accuracy used in the LL to compute timing
99                                 windows, see @ref NRF_CLOCK_LF_ACCURACY.*/
</pre></code></div>
                <div class="column column_space"><pre><code>77      AV_PIX_FMT_YUV444P16LE,  
78      AV_PIX_FMT_YUV444P16BE,  
79  #if FF_API_VDPAU
80      AV_PIX_FMT_VDPAU_MPEG4,  
81  #endif
82      AV_PIX_FMT_DXVA2_VLD,    
83      AV_PIX_FMT_RGB444LE,  
84      AV_PIX_FMT_RGB444BE,  
85      AV_PIX_FMT_BGR444LE,  
86      AV_PIX_FMT_BGR444BE,  
87      AV_PIX_FMT_YA8,       
88      AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8, 
89      AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8, 
90      AV_PIX_FMT_BGR48BE,   
91      AV_PIX_FMT_BGR48LE,   
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    