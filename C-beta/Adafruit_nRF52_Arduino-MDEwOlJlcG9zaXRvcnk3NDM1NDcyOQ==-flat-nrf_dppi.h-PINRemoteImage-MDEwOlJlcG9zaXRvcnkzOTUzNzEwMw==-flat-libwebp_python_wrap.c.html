
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.4074074074074066%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_dppi.h</h3>
            <pre><code>1  #ifndef NRF_DPPI_H__
2  #define NRF_DPPI_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_DPPI_CHANNEL_GROUP0 = 0, &bsol;**< Channel group 0. */
10      NRF_DPPI_CHANNEL_GROUP1 = 1, &bsol;**< Channel group 1. */
11      NRF_DPPI_CHANNEL_GROUP2 = 2, &bsol;**< Channel group 2. */
12      NRF_DPPI_CHANNEL_GROUP3 = 3, &bsol;**< Channel group 3. */
13      NRF_DPPI_CHANNEL_GROUP4 = 4, &bsol;**< Channel group 4. */
14      NRF_DPPI_CHANNEL_GROUP5 = 5  &bsol;**< Channel group 5. */
15  } nrf_dppi_channel_group_t;
16  typedef enum
17  {
18      NRF_DPPI_TASK_CHG0_EN  = offsetof(NRF_DPPIC_Type, TASKS_CHG[0].EN),  &bsol;**< Enable channel group 0. */
19      NRF_DPPI_TASK_CHG0_DIS = offsetof(NRF_DPPIC_Type, TASKS_CHG[0].DIS), &bsol;**< Disable channel group 0. */
20      NRF_DPPI_TASK_CHG1_EN  = offsetof(NRF_DPPIC_Type, TASKS_CHG[1].EN),  &bsol;**< Enable channel group 1. */
21      NRF_DPPI_TASK_CHG1_DIS = offsetof(NRF_DPPIC_Type, TASKS_CHG[1].DIS), &bsol;**< Disable channel group 1. */
22      NRF_DPPI_TASK_CHG2_EN  = offsetof(NRF_DPPIC_Type, TASKS_CHG[2].EN),  &bsol;**< Enable channel group 2. */
23      NRF_DPPI_TASK_CHG2_DIS = offsetof(NRF_DPPIC_Type, TASKS_CHG[2].DIS), &bsol;**< Disable channel group 2. */
24      NRF_DPPI_TASK_CHG3_EN  = offsetof(NRF_DPPIC_Type, TASKS_CHG[3].EN),  &bsol;**< Enable channel group 3. */
25      NRF_DPPI_TASK_CHG3_DIS = offsetof(NRF_DPPIC_Type, TASKS_CHG[3].DIS), &bsol;**< Disable channel group 3. */
26      NRF_DPPI_TASK_CHG4_EN  = offsetof(NRF_DPPIC_Type, TASKS_CHG[4].EN),  &bsol;**< Enable channel group 4. */
27      NRF_DPPI_TASK_CHG4_DIS = offsetof(NRF_DPPIC_Type, TASKS_CHG[4].DIS), &bsol;**< Disable channel group 4. */
28      NRF_DPPI_TASK_CHG5_EN  = offsetof(NRF_DPPIC_Type, TASKS_CHG[5].EN),  &bsol;**< Enable channel group 5. */
29      NRF_DPPI_TASK_CHG5_DIS = offsetof(NRF_DPPIC_Type, TASKS_CHG[5].DIS)  &bsol;**< Disable channel group 5. */
30  } nrf_dppi_task_t;
31  NRF_STATIC_INLINE void nrf_dppi_task_trigger(NRF_DPPIC_Type * p_reg, nrf_dppi_task_t dppi_task);
32  NRF_STATIC_INLINE uint32_t nrf_dppi_task_address_get(NRF_DPPIC_Type const * p_reg,
33                                                       nrf_dppi_task_t        task);
34  NRF_STATIC_INLINE bool nrf_dppi_channel_check(NRF_DPPIC_Type const * p_reg, uint8_t channel);
35  NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask);
36  NRF_STATIC_INLINE void nrf_dppi_channels_disable(NRF_DPPIC_Type * p_reg, uint32_t mask);
37  NRF_STATIC_INLINE void nrf_dppi_channels_disable_all(NRF_DPPIC_Type * p_reg);
38  NRF_STATIC_INLINE void nrf_dppi_subscribe_set(NRF_DPPIC_Type * p_reg,
39                                                nrf_dppi_task_t  task,
40                                                uint8_t          channel);
41  NRF_STATIC_INLINE void nrf_dppi_subscribe_clear(NRF_DPPIC_Type * p_reg, nrf_dppi_task_t task);
42  NRF_STATIC_INLINE void nrf_dppi_channels_include_in_group(NRF_DPPIC_Type *         p_reg,
43                                                            uint32_t                 channel_mask,
44                                                            nrf_dppi_channel_group_t channel_group);
45  NRF_STATIC_INLINE void nrf_dppi_channels_remove_from_group(NRF_DPPIC_Type *         p_reg,
46                                                             uint32_t                 channel_mask,
47                                                             nrf_dppi_channel_group_t channel_group);
48  NRF_STATIC_INLINE void nrf_dppi_group_clear(NRF_DPPIC_Type *         p_reg,
49                                              nrf_dppi_channel_group_t group);
50  NRF_STATIC_INLINE void nrf_dppi_group_enable(NRF_DPPIC_Type *         p_reg,
51                                               nrf_dppi_channel_group_t group);
52  NRF_STATIC_INLINE void nrf_dppi_group_disable(NRF_DPPIC_Type *         p_reg,
53                                                nrf_dppi_channel_group_t group);
54  NRF_STATIC_INLINE nrf_dppi_task_t nrf_dppi_group_enable_task_get(uint8_t index);
55  NRF_STATIC_INLINE nrf_dppi_task_t nrf_dppi_group_disable_task_get(uint8_t index);
56  #ifndef NRF_DECLARE_ONLY
57  NRF_STATIC_INLINE void nrf_dppi_task_trigger(NRF_DPPIC_Type * p_reg, nrf_dppi_task_t dppi_task)
58  {
59      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) dppi_task)) = 1;
60  }
61  NRF_STATIC_INLINE uint32_t nrf_dppi_task_address_get(NRF_DPPIC_Type const * p_reg,
62                                                       nrf_dppi_task_t        task)
63  {
64      return (uint32_t) ((uint8_t *) p_reg + (uint32_t ) task);
65  }
66  NRF_STATIC_INLINE bool nrf_dppi_channel_check(NRF_DPPIC_Type const * p_reg, uint8_t channel)
67  {
68      NRFX_ASSERT(channel < DPPI_CH_NUM);
69      return ((p_reg->CHEN & (DPPIC_CHEN_CH0_Enabled << (DPPIC_CHEN_CH0_Pos + channel))) != 0);
70  }
71  NRF_STATIC_INLINE void nrf_dppi_channels_disable_all(NRF_DPPIC_Type * p_reg)
72  {
73      p_reg->CHENCLR = 0xFFFFFFFFuL;
74  }
75  NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
76  {
77      p_reg->CHENSET = mask;
78  }
79  NRF_STATIC_INLINE void nrf_dppi_channels_disable(NRF_DPPIC_Type * p_reg, uint32_t mask)
80  {
81      p_reg->CHENCLR = mask;
82  }
83  NRF_STATIC_INLINE void nrf_dppi_subscribe_set(NRF_DPPIC_Type * p_reg,
84                                                nrf_dppi_task_t  task,
85                                                uint8_t          channel)
86  {
87      NRFX_ASSERT(channel < DPPI_CH_NUM);
88      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
89              ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
90  }
91  NRF_STATIC_INLINE void nrf_dppi_subscribe_clear(NRF_DPPIC_Type * p_reg, nrf_dppi_task_t task)
92  {
93      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
94  }
95  NRF_STATIC_INLINE void nrf_dppi_channels_include_in_group(NRF_DPPIC_Type *         p_reg,
96                                                            uint32_t                 channel_mask,
97                                                            nrf_dppi_channel_group_t channel_group)
98  {
99      p_reg->CHG[(uint32_t) channel_group] =
100          p_reg->CHG[(uint32_t) channel_group] | (channel_mask);
101  }
102  NRF_STATIC_INLINE void nrf_dppi_channels_remove_from_group(NRF_DPPIC_Type *         p_reg,
103                                                             uint32_t                 channel_mask,
104                                                             nrf_dppi_channel_group_t channel_group)
105  {
106      p_reg->CHG[(uint32_t) channel_group] =
107          p_reg->CHG[(uint32_t) channel_group] & ~(channel_mask);
108  }
109  NRF_STATIC_INLINE void nrf_dppi_group_clear(NRF_DPPIC_Type *         p_reg,
110                                              nrf_dppi_channel_group_t group)
111  {
112      p_reg->CHG[(uint32_t) group] = 0;
113  }
114  NRF_STATIC_INLINE void nrf_dppi_group_enable(NRF_DPPIC_Type * p_reg, nrf_dppi_channel_group_t group)
115  {
116      p_reg->TASKS_CHG[(uint32_t) group].EN = 1;
117  }
118  NRF_STATIC_INLINE void nrf_dppi_group_disable(NRF_DPPIC_Type *         p_reg,
119                                                nrf_dppi_channel_group_t group)
120  {
121      p_reg->TASKS_CHG[(uint32_t) group].DIS = 1;
<span onclick='openModal()' class='match'>122  }
123  NRF_STATIC_INLINE nrf_dppi_task_t nrf_dppi_group_enable_task_get(uint8_t index)
124  {
125      NRFX_ASSERT(index < DPPI_GROUP_NUM);
126      return (nrf_dppi_task_t)NRFX_OFFSETOF(NRF_DPPIC_Type, TASKS_CHG[index].EN);
127  }
128  NRF_STATIC_INLINE nrf_dppi_task_t nrf_dppi_group_disable_task_get(uint8_t index)
129  {
130      NRFX_ASSERT(index < DPPI_GROUP_NUM);
131      return (nrf_dppi_task_t)NRFX_OFFSETOF(NRF_DPPIC_Type, TASKS_CHG[index].DIS);
132  }
</span>133  #endif 
134  #ifdef __cplusplus
135  }
136  #endif
137  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_python_wrap.c</h3>
            <pre><code>1  #define SWIG_PYTHON_STRICT_BYTE_CHAR
2  #ifndef SWIGPYTHON
3  #define SWIGPYTHON
4  #endif
5  #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
6  #ifndef SWIGTEMPLATEDISAMBIGUATOR
7  # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
8  #  define SWIGTEMPLATEDISAMBIGUATOR template
9  # elif defined(__HP_aCC)
10  #  define SWIGTEMPLATEDISAMBIGUATOR template
11  # else
12  #  define SWIGTEMPLATEDISAMBIGUATOR
13  # endif
14  #endif
15  #ifndef SWIGINLINE
16  # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
17  #   define SWIGINLINE inline
18  # else
19  #   define SWIGINLINE
20  # endif
21  #endif
22  #ifndef SWIGUNUSED
23  # if defined(__GNUC__)
24  #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
25  #     define SWIGUNUSED __attribute__ ((__unused__))
26  #   else
27  #     define SWIGUNUSED
28  #   endif
29  # elif defined(__ICC)
30  #   define SWIGUNUSED __attribute__ ((__unused__))
31  # else
32  #   define SWIGUNUSED
33  # endif
34  #endif
35  #ifndef SWIG_MSC_UNSUPPRESS_4505
36  # if defined(_MSC_VER)
37  #   pragma warning(disable : 4505) &bsol;* unreferenced local function has been removed */
38  # endif
39  #endif
40  #ifndef SWIGUNUSEDPARM
41  # ifdef __cplusplus
42  #   define SWIGUNUSEDPARM(p)
43  # else
44  #   define SWIGUNUSEDPARM(p) p SWIGUNUSED
45  # endif
46  #endif
47  #ifndef SWIGINTERN
48  # define SWIGINTERN static SWIGUNUSED
49  #endif
50  #ifndef SWIGINTERNINLINE
51  # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
52  #endif
53  #if defined(__GNUC__)
54  #  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
55  #    ifndef GCC_HASCLASSVISIBILITY
56  #      define GCC_HASCLASSVISIBILITY
57  #    endif
58  #  endif
59  #endif
60  #ifndef SWIGEXPORT
61  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
62  #   if defined(STATIC_LINKED)
63  #     define SWIGEXPORT
64  #   else
65  #     define SWIGEXPORT __declspec(dllexport)
66  #   endif
67  # else
68  #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
69  #     define SWIGEXPORT __attribute__ ((visibility("default")))
70  #   else
71  #     define SWIGEXPORT
72  #   endif
73  # endif
74  #endif
75  #ifndef SWIGSTDCALL
76  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
77  #   define SWIGSTDCALL __stdcall
78  # else
79  #   define SWIGSTDCALL
80  # endif
81  #endif
82  #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
83  # define _CRT_SECURE_NO_DEPRECATE
84  #endif
85  #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
86  # define _SCL_SECURE_NO_DEPRECATE
87  #endif
88  #if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
89  # define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
90  #endif
91  #ifdef __INTEL_COMPILER
92  # pragma warning disable 592
93  #endif
94  #if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
95  # undef _DEBUG
96  # include <Python.h>
97  # define _DEBUG
98  #else
99  # include <Python.h>
100  #endif
101  #define SWIG_RUNTIME_VERSION "4"
102  #ifdef SWIG_TYPE_TABLE
103  # define SWIG_QUOTE_STRING(x) #x
104  # define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
105  # define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
106  #else
107  # define SWIG_TYPE_TABLE_NAME
108  #endif
109  #ifndef SWIGRUNTIME
110  # define SWIGRUNTIME SWIGINTERN
111  #endif
112  #ifndef SWIGRUNTIMEINLINE
113  # define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
114  #endif
115  #ifndef SWIG_BUFFER_SIZE
116  # define SWIG_BUFFER_SIZE 1024
117  #endif
118  #define SWIG_POINTER_DISOWN        0x1
119  #define SWIG_CAST_NEW_MEMORY       0x2
120  #define SWIG_POINTER_OWN           0x1
121  #define SWIG_OK                    (0)
122  #define SWIG_ERROR                 (-1)
123  #define SWIG_IsOK(r)               (r >= 0)
124  #define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)
125  #define SWIG_CASTRANKLIMIT         (1 << 8)
126  #define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
127  #define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
128  #define SWIG_BADOBJ                (SWIG_ERROR)
129  #define SWIG_OLDOBJ                (SWIG_OK)
130  #define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
131  #define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
132  #define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
133  #define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
134  #define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
135  #define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
136  #define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
137  #define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
138  #if defined(SWIG_CASTRANK_MODE)
139  #  ifndef SWIG_TypeRank
140  #    define SWIG_TypeRank             unsigned long
141  #  endif
142  #  ifndef SWIG_MAXCASTRANK            &bsol;* Default cast allowed */
143  #    define SWIG_MAXCASTRANK          (2)
144  #  endif
145  #  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
146  #  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
147  SWIGINTERNINLINE int SWIG_AddCast(int r) {
148    return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
149  }
150  SWIGINTERNINLINE int SWIG_CheckState(int r) {
151    return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
152  }
153  #else &bsol;* no cast-rank mode */
154  #  define SWIG_AddCast(r) (r)
155  #  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
156  #endif
157  #include <string.h>
158  #ifdef __cplusplus
159  extern "C" {
160  #endif
161  typedef void *(*swig_converter_func)(void *, int *);
162  typedef struct swig_type_info *(*swig_dycast_func)(void **);
163  typedef struct swig_type_info {
164    const char             *name;                 &bsol;* mangled name of this type */
165    const char             *str;                  &bsol;* human readable name of this type */
166    swig_dycast_func        dcast;                &bsol;* dynamic cast function down a hierarchy */
167    struct swig_cast_info  *cast;                 &bsol;* linked list of types that can cast into this type */
168    void                   *clientdata;           &bsol;* language specific type data */
169    int                    owndata;               &bsol;* flag if the structure owns the clientdata */
170  } swig_type_info;
171  typedef struct swig_cast_info {
172    swig_type_info         *type;                 &bsol;* pointer to type that is equivalent to this type */
173    swig_converter_func     converter;            &bsol;* function to cast the void pointers */
174    struct swig_cast_info  *next;                 &bsol;* pointer to next cast in linked list */
175    struct swig_cast_info  *prev;                 &bsol;* pointer to the previous cast */
176  } swig_cast_info;
177  typedef struct swig_module_info {
178    swig_type_info         **types;               &bsol;* Array of pointers to swig_type_info structures that are in this module */
179    size_t                 size;                  &bsol;* Number of types in this module */
180    struct swig_module_info *next;                &bsol;* Pointer to next element in circularly linked list */
181    swig_type_info         **type_initial;        &bsol;* Array of initially generated type structures */
182    swig_cast_info         **cast_initial;        &bsol;* Array of initially generated casting structures */
183    void                    *clientdata;          &bsol;* Language specific module data */
184  } swig_module_info;
185  SWIGRUNTIME int
186  SWIG_TypeNameComp(const char *f1, const char *l1,
187                    const char *f2, const char *l2) {
188    for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
189      while ((*f1 == ' ') && (f1 != l1)) ++f1;
190      while ((*f2 == ' ') && (f2 != l2)) ++f2;
191      if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
192    }
193    return (int)((l1 - f1) - (l2 - f2));
194  }
195  SWIGRUNTIME int
196  SWIG_TypeCmp(const char *nb, const char *tb) {
197    int equiv = 1;
198    const char* te = tb + strlen(tb);
199    const char* ne = nb;
200    while (equiv != 0 && *ne) {
201      for (nb = ne; *ne; ++ne) {
202        if (*ne == '|') break;
203      }
204      equiv = SWIG_TypeNameComp(nb, ne, tb, te);
205      if (*ne) ++ne;
206    }
207    return equiv;
208  }
209  SWIGRUNTIME int
210  SWIG_TypeEquiv(const char *nb, const char *tb) {
211    return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
212  }
213  SWIGRUNTIME swig_cast_info *
214  SWIG_TypeCheck(const char *c, swig_type_info *ty) {
215    if (ty) {
216      swig_cast_info *iter = ty->cast;
217      while (iter) {
218        if (strcmp(iter->type->name, c) == 0) {
219          if (iter == ty->cast)
220            return iter;
221          iter->prev->next = iter->next;
222          if (iter->next)
223            iter->next->prev = iter->prev;
224          iter->next = ty->cast;
225          iter->prev = 0;
226          if (ty->cast) ty->cast->prev = iter;
227          ty->cast = iter;
228          return iter;
229        }
230        iter = iter->next;
231      }
232    }
233    return 0;
234  }
235  SWIGRUNTIME swig_cast_info *
236  SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
237    if (ty) {
238      swig_cast_info *iter = ty->cast;
239      while (iter) {
240        if (iter->type == from) {
241          if (iter == ty->cast)
242            return iter;
243          iter->prev->next = iter->next;
244          if (iter->next)
245            iter->next->prev = iter->prev;
246          iter->next = ty->cast;
247          iter->prev = 0;
248          if (ty->cast) ty->cast->prev = iter;
249          ty->cast = iter;
250          return iter;
251        }
252        iter = iter->next;
253      }
254    }
255    return 0;
256  }
257  SWIGRUNTIMEINLINE void *
258  SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
259    return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
260  }
261  SWIGRUNTIME swig_type_info *
262  SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
263    swig_type_info *lastty = ty;
264    if (!ty || !ty->dcast) return ty;
265    while (ty && (ty->dcast)) {
266      ty = (*ty->dcast)(ptr);
267      if (ty) lastty = ty;
268    }
269    return lastty;
270  }
271  SWIGRUNTIMEINLINE const char *
272  SWIG_TypeName(const swig_type_info *ty) {
273    return ty->name;
274  }
275  SWIGRUNTIME const char *
276  SWIG_TypePrettyName(const swig_type_info *type) {
277    if (!type) return NULL;
278    if (type->str != NULL) {
279      const char *last_name = type->str;
280      const char *s;
281      for (s = type->str; *s; s++)
282        if (*s == '|') last_name = s+1;
283      return last_name;
284    }
285    else
286      return type->name;
287  }
288  SWIGRUNTIME void
289  SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
290    swig_cast_info *cast = ti->cast;
291    ti->clientdata = clientdata;
292    while (cast) {
293      if (!cast->converter) {
294        swig_type_info *tc = cast->type;
295        if (!tc->clientdata) {
296          SWIG_TypeClientData(tc, clientdata);
297        }
298      }
299      cast = cast->next;
300    }
301  }
302  SWIGRUNTIME void
303  SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
304    SWIG_TypeClientData(ti, clientdata);
305    ti->owndata = 1;
306  }
307  SWIGRUNTIME swig_type_info *
308  SWIG_MangledTypeQueryModule(swig_module_info *start,
309                              swig_module_info *end,
310                              const char *name) {
311    swig_module_info *iter = start;
312    do {
313      if (iter->size) {
314        size_t l = 0;
315        size_t r = iter->size - 1;
316        do {
317          size_t i = (l + r) >> 1;
318          const char *iname = iter->types[i]->name;
319          if (iname) {
320            int compare = strcmp(name, iname);
321            if (compare == 0) {
322              return iter->types[i];
323            } else if (compare < 0) {
324              if (i) {
325                r = i - 1;
326              } else {
327                break;
328              }
329            } else if (compare > 0) {
330              l = i + 1;
331            }
332          } else {
333            break; &bsol;* should never happen */
334          }
335        } while (l <= r);
336      }
337      iter = iter->next;
338    } while (iter != end);
339    return 0;
340  }
341  SWIGRUNTIME swig_type_info *
342  SWIG_TypeQueryModule(swig_module_info *start,
343                       swig_module_info *end,
344                       const char *name) {
345    swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
346    if (ret) {
347      return ret;
348    } else {
349      swig_module_info *iter = start;
350      do {
351        size_t i = 0;
352        for (; i < iter->size; ++i) {
353          if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
354            return iter->types[i];
355        }
356        iter = iter->next;
357      } while (iter != end);
358    }
359    return 0;
360  }
361  SWIGRUNTIME char *
362  SWIG_PackData(char *c, void *ptr, size_t sz) {
363    static const char hex[17] = "0123456789abcdef";
364    const unsigned char *u = (unsigned char *) ptr;
365    const unsigned char *eu =  u + sz;
366    for (; u != eu; ++u) {
367      unsigned char uu = *u;
368      *(c++) = hex[(uu & 0xf0) >> 4];
369      *(c++) = hex[uu & 0xf];
370    }
371    return c;
372  }
373  SWIGRUNTIME const char *
374  SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
375    unsigned char *u = (unsigned char *) ptr;
376    const unsigned char *eu = u + sz;
377    for (; u != eu; ++u) {
378      char d = *(c++);
379      unsigned char uu;
380      if ((d >= '0') && (d <= '9'))
381        uu = (unsigned char)((d - '0') << 4);
382      else if ((d >= 'a') && (d <= 'f'))
383        uu = (unsigned char)((d - ('a'-10)) << 4);
384      else
385        return (char *) 0;
386      d = *(c++);
387      if ((d >= '0') && (d <= '9'))
388        uu |= (unsigned char)(d - '0');
389      else if ((d >= 'a') && (d <= 'f'))
390        uu |= (unsigned char)(d - ('a'-10));
391      else
392        return (char *) 0;
393      *u = uu;
394    }
395    return c;
396  }
397  SWIGRUNTIME char *
398  SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
399    char *r = buff;
400    if ((2*sizeof(void *) + 2) > bsz) return 0;
401    *(r++) = '_';
402    r = SWIG_PackData(r,&ptr,sizeof(void *));
403    if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
404    strcpy(r,name);
405    return buff;
406  }
407  SWIGRUNTIME const char *
408  SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
409    if (*c != '_') {
410      if (strcmp(c,"NULL") == 0) {
411        *ptr = (void *) 0;
412        return name;
413      } else {
414        return 0;
415      }
416    }
417    return SWIG_UnpackData(++c,ptr,sizeof(void *));
418  }
419  SWIGRUNTIME char *
420  SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
421    char *r = buff;
422    size_t lname = (name ? strlen(name) : 0);
423    if ((2*sz + 2 + lname) > bsz) return 0;
424    *(r++) = '_';
425    r = SWIG_PackData(r,ptr,sz);
426    if (lname) {
427      strncpy(r,name,lname+1);
428    } else {
429      *r = 0;
430    }
431    return buff;
432  }
433  SWIGRUNTIME const char *
434  SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
435    if (*c != '_') {
436      if (strcmp(c,"NULL") == 0) {
437        memset(ptr,0,sz);
438        return name;
439      } else {
440        return 0;
441      }
442    }
443    return SWIG_UnpackData(++c,ptr,sz);
444  }
445  #ifdef __cplusplus
446  }
447  #endif
448  #define  SWIG_UnknownError         -1
449  #define  SWIG_IOError              -2
450  #define  SWIG_RuntimeError         -3
451  #define  SWIG_IndexError           -4
452  #define  SWIG_TypeError            -5
453  #define  SWIG_DivisionByZero       -6
454  #define  SWIG_OverflowError        -7
455  #define  SWIG_SyntaxError          -8
456  #define  SWIG_ValueError           -9
457  #define  SWIG_SystemError          -10
458  #define  SWIG_AttributeError       -11
459  #define  SWIG_MemoryError          -12
460  #define  SWIG_NullReferenceError   -13
461  #if PY_VERSION_HEX >= 0x03000000
462  #define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
463  #define PyInt_Check(x) PyLong_Check(x)
464  #define PyInt_AsLong(x) PyLong_AsLong(x)
465  #define PyInt_FromLong(x) PyLong_FromLong(x)
466  #define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
467  #define PyString_Check(name) PyBytes_Check(name)
468  #define PyString_FromString(x) PyUnicode_FromString(x)
469  #define PyString_FromStringAndSize(x, y) PyBytes_FromStringAndSize(x, y)
470  #define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
471  #define PyString_AsString(str) PyBytes_AsString(str)
472  #define PyString_Size(str) PyBytes_Size(str)
473  #define PyString_InternFromString(key) PyUnicode_InternFromString(key)
474  #define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
475  #define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
476  #define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
477  #endif
478  #ifndef Py_TYPE
479  #  define Py_TYPE(op) ((op)->ob_type)
480  #endif
481  #if PY_VERSION_HEX >= 0x03000000
482  #  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
483  #else
484  #  define SWIG_Python_str_FromFormat PyString_FromFormat
485  #endif
486  SWIGINTERN char*
487  SWIG_Python_str_AsChar(PyObject *str)
488  {
489  #if PY_VERSION_HEX >= 0x03000000
490    char *cstr;
491    char *newstr;
492    Py_ssize_t len;
493    str = PyUnicode_AsUTF8String(str);
494    PyBytes_AsStringAndSize(str, &cstr, &len);
495    newstr = (char *) malloc(len+1);
496    memcpy(newstr, cstr, len+1);
497    Py_XDECREF(str);
498    return newstr;
499  #else
500    return PyString_AsString(str);
501  #endif
502  }
503  #if PY_VERSION_HEX >= 0x03000000
504  #  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
505  #else
506  #  define SWIG_Python_str_DelForPy3(x)
507  #endif
508  SWIGINTERN PyObject*
509  SWIG_Python_str_FromChar(const char *c)
510  {
511  #if PY_VERSION_HEX >= 0x03000000
512    return PyUnicode_FromString(c);
513  #else
514    return PyString_FromString(c);
515  #endif
516  }
517  #if PY_VERSION_HEX < 0x02020000
518  # if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
519  #  define PyOS_snprintf _snprintf
520  # else
521  #  define PyOS_snprintf snprintf
522  # endif
523  #endif
524  #if PY_VERSION_HEX < 0x02020000
525  #ifndef SWIG_PYBUFFER_SIZE
526  # define SWIG_PYBUFFER_SIZE 1024
527  #endif
528  static PyObject *
529  PyString_FromFormat(const char *fmt, ...) {
530    va_list ap;
531    char buf[SWIG_PYBUFFER_SIZE * 2];
532    int res;
533    va_start(ap, fmt);
534    res = vsnprintf(buf, sizeof(buf), fmt, ap);
535    va_end(ap);
536    return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
537  }
538  #endif
539  #ifndef PyObject_DEL
540  # define PyObject_DEL PyObject_Del
541  #endif
542  #if PY_VERSION_HEX < 0x02020000
543  # ifndef PyExc_StopIteration
544  #  define PyExc_StopIteration PyExc_RuntimeError
545  # endif
546  # ifndef PyObject_GenericGetAttr
547  #  define PyObject_GenericGetAttr 0
548  # endif
549  #endif
550  #if PY_VERSION_HEX < 0x02010000
551  # ifndef Py_NotImplemented
552  #  define Py_NotImplemented PyExc_RuntimeError
553  # endif
554  #endif
555  #if PY_VERSION_HEX < 0x02010000
556  # ifndef PyString_AsStringAndSize
557  #  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
558  # endif
559  #endif
560  #if PY_VERSION_HEX < 0x02000000
561  # ifndef PySequence_Size
562  #  define PySequence_Size PySequence_Length
563  # endif
564  #endif
565  #if PY_VERSION_HEX < 0x02030000
566  static
567  PyObject *PyBool_FromLong(long ok)
568  {
569    PyObject *result = ok ? Py_True : Py_False;
570    Py_INCREF(result);
571    return result;
572  }
573  #endif
574  #if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
575  typedef int Py_ssize_t;
576  # define PY_SSIZE_T_MAX INT_MAX
577  # define PY_SSIZE_T_MIN INT_MIN
578  typedef inquiry lenfunc;
579  typedef intargfunc ssizeargfunc;
580  typedef intintargfunc ssizessizeargfunc;
581  typedef intobjargproc ssizeobjargproc;
582  typedef intintobjargproc ssizessizeobjargproc;
583  typedef getreadbufferproc readbufferproc;
584  typedef getwritebufferproc writebufferproc;
585  typedef getsegcountproc segcountproc;
586  typedef getcharbufferproc charbufferproc;
587  static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
588  {
589    long result = 0;
590    PyObject *i = PyNumber_Int(x);
591    if (i) {
592      result = PyInt_AsLong(i);
593      Py_DECREF(i);
594    }
595    return result;
596  }
597  #endif
598  #if PY_VERSION_HEX < 0x02050000
599  #define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
600  #endif
601  #if PY_VERSION_HEX < 0x02040000
602  #define Py_VISIT(op)                            \
603    do {                                          \
604      if (op) {                                   \
605        int vret = visit((op), arg);              \
606        if (vret)                                 \
607          return vret;                            \
608      }                                           \
609    } while (0)
610  #endif
611  #if PY_VERSION_HEX < 0x02030000
612  typedef struct {
613    PyTypeObject type;
614    PyNumberMethods as_number;
615    PyMappingMethods as_mapping;
616    PySequenceMethods as_sequence;
617    PyBufferProcs as_buffer;
618    PyObject *name, *slots;
619  } PyHeapTypeObject;
620  #endif
621  #if PY_VERSION_HEX < 0x02030000
622  typedef destructor freefunc;
623  #endif
624  #if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
625       (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
626       (PY_MAJOR_VERSION > 3))
627  # define SWIGPY_USE_CAPSULE
628  # define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
629  #endif
630  #if PY_VERSION_HEX < 0x03020000
631  #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
632  #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
633  #define Py_hash_t long
634  #endif
635  SWIGRUNTIME PyObject*
636  SWIG_Python_ErrorType(int code) {
637    PyObject* type = 0;
638    switch(code) {
639    case SWIG_MemoryError:
640      type = PyExc_MemoryError;
641      break;
642    case SWIG_IOError:
643      type = PyExc_IOError;
644      break;
645    case SWIG_RuntimeError:
646      type = PyExc_RuntimeError;
647      break;
648    case SWIG_IndexError:
649      type = PyExc_IndexError;
650      break;
651    case SWIG_TypeError:
652      type = PyExc_TypeError;
653      break;
654    case SWIG_DivisionByZero:
655      type = PyExc_ZeroDivisionError;
656      break;
657    case SWIG_OverflowError:
658      type = PyExc_OverflowError;
659      break;
660    case SWIG_SyntaxError:
661      type = PyExc_SyntaxError;
662      break;
663    case SWIG_ValueError:
664      type = PyExc_ValueError;
665      break;
666    case SWIG_SystemError:
667      type = PyExc_SystemError;
668      break;
669    case SWIG_AttributeError:
670      type = PyExc_AttributeError;
671      break;
672    default:
673      type = PyExc_RuntimeError;
674    }
675    return type;
676  }
677  SWIGRUNTIME void
678  SWIG_Python_AddErrorMsg(const char* mesg)
679  {
680    PyObject *type = 0;
681    PyObject *value = 0;
682    PyObject *traceback = 0;
683    if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
684    if (value) {
685      char *tmp;
686      PyObject *old_str = PyObject_Str(value);
687      PyErr_Clear();
688      Py_XINCREF(type);
689      PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
690      SWIG_Python_str_DelForPy3(tmp);
691      Py_DECREF(old_str);
692      Py_DECREF(value);
693    } else {
694      PyErr_SetString(PyExc_RuntimeError, mesg);
695    }
696  }
697  #if defined(SWIG_PYTHON_NO_THREADS)
698  #  if defined(SWIG_PYTHON_THREADS)
699  #    undef SWIG_PYTHON_THREADS
700  #  endif
701  #endif
702  #if defined(SWIG_PYTHON_THREADS) &bsol;* Threading support is enabled */
703  #  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
704  #    if (PY_VERSION_HEX >= 0x02030000) &bsol;* For 2.3 or later, use the PyGILState calls */
705  #      define SWIG_PYTHON_USE_GIL
706  #    endif
707  #  endif
708  #  if defined(SWIG_PYTHON_USE_GIL) &bsol;* Use PyGILState threads calls */
709  #    ifndef SWIG_PYTHON_INITIALIZE_THREADS
710  #     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads()
711  #    endif
712  #    ifdef __cplusplus &bsol;* C++ code */
713         class SWIG_Python_Thread_Block {
714           bool status;
715           PyGILState_STATE state;
716         public:
717           void end() { if (status) { PyGILState_Release(state); status = false;} }
718           SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
719           ~SWIG_Python_Thread_Block() { end(); }
720         };
721         class SWIG_Python_Thread_Allow {
722           bool status;
723           PyThreadState *save;
724         public:
725           void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
726           SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
727           ~SWIG_Python_Thread_Allow() { end(); }
728         };
729  #      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
730  #      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
731  #      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
732  #      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
733  #    else &bsol;* C code */
734  #      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
735  #      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
736  #      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
737  #      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
738  #    endif
739  #  else &bsol;* Old thread way, not implemented, user must provide it */
740  #    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
741  #      define SWIG_PYTHON_INITIALIZE_THREADS
742  #    endif
743  #    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
744  #      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
745  #    endif
746  #    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
747  #      define SWIG_PYTHON_THREAD_END_BLOCK
748  #    endif
749  #    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
750  #      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
751  #    endif
752  #    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
753  #      define SWIG_PYTHON_THREAD_END_ALLOW
754  #    endif
755  #  endif
756  #else &bsol;* No thread support */
757  #  define SWIG_PYTHON_INITIALIZE_THREADS
758  #  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
759  #  define SWIG_PYTHON_THREAD_END_BLOCK
760  #  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
761  #  define SWIG_PYTHON_THREAD_END_ALLOW
762  #endif
763  #ifdef __cplusplus
764  extern "C" {
765  #endif
766  #define SWIG_PY_POINTER 4
767  #define SWIG_PY_BINARY  5
768  typedef struct swig_const_info {
769    int type;
770    char *name;
771    long lvalue;
772    double dvalue;
773    void   *pvalue;
774    swig_type_info **ptype;
775  } swig_const_info;
776  #if PY_VERSION_HEX >= 0x03000000
777  SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
778  {
779    return PyInstanceMethod_New(func);
780  }
781  #else
782  SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
783  {
784    return NULL;
785  }
786  #endif
787  #ifdef __cplusplus
788  }
789  #endif
790  #define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
791  #define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
792  #define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
793  #ifdef SWIGPYTHON_BUILTIN
794  #define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
795  #else
796  #define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
797  #endif
798  #define SWIG_InternalNewPointerObj(ptr, type, flags)    SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
799  #define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty)
800  #define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
801  #define swig_owntype                                    int
802  #define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
803  #define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
804  #define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
805  #define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
806  #define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
807  #define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)
808  #define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
809  #define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
810  #define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
811  #define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
812  #define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)
813  #define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj
814  #define SWIG_SetErrorMsg                                SWIG_Python_SetErrorMsg
815  #define SWIG_ErrorType(code)                            SWIG_Python_ErrorType(code)
816  #define SWIG_Error(code, msg)                           SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg)
817  #define SWIG_fail                                       goto fail
818  SWIGINTERN void
819  SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
820    SWIG_PYTHON_THREAD_BEGIN_BLOCK;
821    PyErr_SetObject(errtype, obj);
822    Py_DECREF(obj);
823    SWIG_PYTHON_THREAD_END_BLOCK;
824  }
825  SWIGINTERN void
826  SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
827    SWIG_PYTHON_THREAD_BEGIN_BLOCK;
828    PyErr_SetString(errtype, msg);
829    SWIG_PYTHON_THREAD_END_BLOCK;
830  }
831  #define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)
832  #if defined(SWIGPYTHON_BUILTIN)
833  SWIGINTERN void
834  SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
835    PyObject *s = PyString_InternFromString(key);
836    PyList_Append(seq, s);
837    Py_DECREF(s);
838  }
839  SWIGINTERN void
840  SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {
841  #if PY_VERSION_HEX < 0x02030000
842    PyDict_SetItemString(d, (char *)name, obj);
843  #else
844    PyDict_SetItemString(d, name, obj);
845  #endif
846    Py_DECREF(obj);
847    if (public_interface)
848      SwigPyBuiltin_AddPublicSymbol(public_interface, name);
849  }
850  #else
851  SWIGINTERN void
852  SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {
853  #if PY_VERSION_HEX < 0x02030000
854    PyDict_SetItemString(d, (char *)name, obj);
855  #else
856    PyDict_SetItemString(d, name, obj);
857  #endif
858    Py_DECREF(obj);
859  }
860  #endif
861  SWIGINTERN PyObject*
862  SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
863  #if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
864    if (!result) {
865      result = obj;
866    } else if (result == Py_None) {
867      Py_DECREF(result);
868      result = obj;
869    } else {
870      if (!PyList_Check(result)) {
871        PyObject *o2 = result;
872        result = PyList_New(1);
873        PyList_SetItem(result, 0, o2);
874      }
875      PyList_Append(result,obj);
876      Py_DECREF(obj);
877    }
878    return result;
879  #else
880    PyObject*   o2;
881    PyObject*   o3;
882    if (!result) {
883      result = obj;
884    } else if (result == Py_None) {
885      Py_DECREF(result);
886      result = obj;
887    } else {
888      if (!PyTuple_Check(result)) {
889        o2 = result;
890        result = PyTuple_New(1);
891        PyTuple_SET_ITEM(result, 0, o2);
892      }
893      o3 = PyTuple_New(1);
894      PyTuple_SET_ITEM(o3, 0, obj);
895      o2 = result;
896      result = PySequence_Concat(o2, o3);
897      Py_DECREF(o2);
898      Py_DECREF(o3);
899    }
900    return result;
901  #endif
902  }
903  SWIGINTERN Py_ssize_t
904  SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
905  {
906    if (!args) {
907      if (!min && !max) {
908        return 1;
909      } else {
910        PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none",
911                     name, (min == max ? "" : "at least "), (int)min);
912        return 0;
913      }
914    }
915    if (!PyTuple_Check(args)) {
916      if (min <= 1 && max >= 1) {
917        Py_ssize_t i;
918        objs[0] = args;
919        for (i = 1; i < max; ++i) {
920          objs[i] = 0;
921        }
922        return 2;
923      }
924      PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
925      return 0;
926    } else {
927      Py_ssize_t l = PyTuple_GET_SIZE(args);
928      if (l < min) {
929        PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d",
930                     name, (min == max ? "" : "at least "), (int)min, (int)l);
931        return 0;
932      } else if (l > max) {
933        PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d",
934                     name, (min == max ? "" : "at most "), (int)max, (int)l);
935        return 0;
936      } else {
937        Py_ssize_t i;
938        for (i = 0; i < l; ++i) {
939          objs[i] = PyTuple_GET_ITEM(args, i);
940        }
941        for (; l < max; ++l) {
942          objs[l] = 0;
943        }
944        return i + 1;
945      }
946    }
947  }
948  #if PY_VERSION_HEX >= 0x02020000
949  #define SWIG_Python_CallFunctor(functor, obj)           PyObject_CallFunctionObjArgs(functor, obj, NULL);
950  #else
951  #define SWIG_Python_CallFunctor(functor, obj)           PyObject_CallFunction(functor, "O", obj);
952  #endif
953  #ifdef __cplusplus
954  #define SWIG_STATIC_POINTER(var)  var
955  #else
956  #define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
957  #endif
958  #define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
959  #define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
960  #define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)
961  #define SWIG_BUILTIN_TP_INIT        (SWIG_POINTER_OWN << 2)
962  #define SWIG_BUILTIN_INIT           (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)
963  #ifdef __cplusplus
964  extern "C" {
965  #endif
966  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
967  #  ifndef SWIG_PYTHON_NO_BUILD_NONE
968  #    ifndef SWIG_PYTHON_BUILD_NONE
969  #      define SWIG_PYTHON_BUILD_NONE
970  #    endif
971  #  endif
972  #endif
973  #ifdef SWIG_PYTHON_BUILD_NONE
974  #  ifdef Py_None
975  #   undef Py_None
976  #   define Py_None SWIG_Py_None()
977  #  endif
978  SWIGRUNTIMEINLINE PyObject *
979  _SWIG_Py_None(void)
980  {
981    PyObject *none = Py_BuildValue((char*)"");
982    Py_DECREF(none);
983    return none;
984  }
985  SWIGRUNTIME PyObject *
986  SWIG_Py_None(void)
987  {
988    static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
989    return none;
990  }
991  #endif
992  SWIGRUNTIMEINLINE PyObject *
993  SWIG_Py_Void(void)
994  {
995    PyObject *none = Py_None;
996    Py_INCREF(none);
997    return none;
998  }
999  typedef struct {
1000    PyObject *klass;
1001    PyObject *newraw;
1002    PyObject *newargs;
1003    PyObject *destroy;
1004    int delargs;
1005    int implicitconv;
1006    PyTypeObject *pytype;
1007  } SwigPyClientData;
1008  SWIGRUNTIMEINLINE int
1009  SWIG_Python_CheckImplicit(swig_type_info *ty)
1010  {
1011    SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
1012    return data ? data->implicitconv : 0;
1013  }
1014  SWIGRUNTIMEINLINE PyObject *
1015  SWIG_Python_ExceptionType(swig_type_info *desc) {
1016    SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
1017    PyObject *klass = data ? data->klass : 0;
1018    return (klass ? klass : PyExc_RuntimeError);
1019  }
1020  SWIGRUNTIME SwigPyClientData *
1021  SwigPyClientData_New(PyObject* obj)
1022  {
1023    if (!obj) {
1024      return 0;
1025    } else {
1026      SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
1027      data->klass = obj;
1028      Py_INCREF(data->klass);
1029      if (PyClass_Check(obj)) {
1030        data->newraw = 0;
1031        data->newargs = obj;
1032        Py_INCREF(obj);
1033      } else {
1034  #if (PY_VERSION_HEX < 0x02020000)
1035        data->newraw = 0;
1036  #else
1037        data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
1038  #endif
1039        if (data->newraw) {
1040          Py_INCREF(data->newraw);
1041          data->newargs = PyTuple_New(1);
1042          PyTuple_SetItem(data->newargs, 0, obj);
1043        } else {
1044          data->newargs = obj;
1045        }
1046        Py_INCREF(data->newargs);
1047      }
1048      data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
1049      if (PyErr_Occurred()) {
1050        PyErr_Clear();
1051        data->destroy = 0;
1052      }
1053      if (data->destroy) {
1054        int flags;
1055        Py_INCREF(data->destroy);
1056        flags = PyCFunction_GET_FLAGS(data->destroy);
1057  #ifdef METH_O
1058        data->delargs = !(flags & (METH_O));
1059  #else
1060        data->delargs = 0;
1061  #endif
1062      } else {
1063        data->delargs = 0;
1064      }
1065      data->implicitconv = 0;
1066      data->pytype = 0;
1067      return data;
1068    }
1069  }
1070  SWIGRUNTIME void
1071  SwigPyClientData_Del(SwigPyClientData *data) {
1072    Py_XDECREF(data->newraw);
1073    Py_XDECREF(data->newargs);
1074    Py_XDECREF(data->destroy);
1075  }
1076  typedef struct {
1077    PyObject_HEAD
1078    void *ptr;
1079    swig_type_info *ty;
1080    int own;
1081    PyObject *next;
1082  #ifdef SWIGPYTHON_BUILTIN
1083    PyObject *dict;
1084  #endif
1085  } SwigPyObject;
1086  #ifdef SWIGPYTHON_BUILTIN
1087  SWIGRUNTIME PyObject *
1088  SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
1089  {
1090    SwigPyObject *sobj = (SwigPyObject *)v;
1091    if (!sobj->dict)
1092      sobj->dict = PyDict_New();
1093    Py_INCREF(sobj->dict);
1094    return sobj->dict;
1095  }
1096  #endif
1097  SWIGRUNTIME PyObject *
1098  SwigPyObject_long(SwigPyObject *v)
1099  {
1100    return PyLong_FromVoidPtr(v->ptr);
1101  }
1102  SWIGRUNTIME PyObject *
1103  SwigPyObject_format(const char* fmt, SwigPyObject *v)
1104  {
1105    PyObject *res = NULL;
1106    PyObject *args = PyTuple_New(1);
1107    if (args) {
1108      if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
1109        PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
1110        if (ofmt) {
1111  #if PY_VERSION_HEX >= 0x03000000
1112          res = PyUnicode_Format(ofmt,args);
1113  #else
1114          res = PyString_Format(ofmt,args);
1115  #endif
1116          Py_DECREF(ofmt);
1117        }
1118        Py_DECREF(args);
1119      }
1120    }
1121    return res;
<span onclick='openModal()' class='match'>1122  }
1123  SWIGRUNTIME PyObject *
1124  SwigPyObject_oct(SwigPyObject *v)
1125  {
1126    return SwigPyObject_format("%o",v);
1127  }
1128  SWIGRUNTIME PyObject *
1129  SwigPyObject_hex(SwigPyObject *v)
1130  {
1131    return SwigPyObject_format("%x",v);
1132  }
</span>1133  SWIGRUNTIME PyObject *
1134  #ifdef METH_NOARGS
1135  SwigPyObject_repr(SwigPyObject *v)
1136  #else
1137  SwigPyObject_repr(SwigPyObject *v, PyObject *args)
1138  #endif
1139  {
1140    const char *name = SWIG_TypePrettyName(v->ty);
1141    PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
1142    if (v->next) {
1143  # ifdef METH_NOARGS
1144      PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
1145  # else
1146      PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
1147  # endif
1148  # if PY_VERSION_HEX >= 0x03000000
1149      PyObject *joined = PyUnicode_Concat(repr, nrep);
1150      Py_DecRef(repr);
1151      Py_DecRef(nrep);
1152      repr = joined;
1153  # else
1154      PyString_ConcatAndDel(&repr,nrep);
1155  # endif
1156    }
1157    return repr;
1158  }
1159  SWIGRUNTIME PyObject *
1160  SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
1161  {
1162    return SwigPyObject_repr((SwigPyObject*)v);
1163  }
1164  SWIGRUNTIME int
1165  SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
1166  {
1167    void *i = v->ptr;
1168    void *j = w->ptr;
1169    return (i < j) ? -1 : ((i > j) ? 1 : 0);
1170  }
1171  SWIGRUNTIME PyObject*
1172  SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
1173  {
1174    PyObject* res;
1175    if( op != Py_EQ && op != Py_NE ) {
1176      Py_INCREF(Py_NotImplemented);
1177      return Py_NotImplemented;
1178    }
1179    res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
1180    return res;
1181  }
1182  SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);
1183  #ifdef SWIGPYTHON_BUILTIN
1184  static swig_type_info *SwigPyObject_stype = 0;
1185  SWIGRUNTIME PyTypeObject*
1186  SwigPyObject_type(void) {
1187      SwigPyClientData *cd;
1188      assert(SwigPyObject_stype);
1189      cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
1190      assert(cd);
1191      assert(cd->pytype);
1192      return cd->pytype;
1193  }
1194  #else
1195  SWIGRUNTIME PyTypeObject*
1196  SwigPyObject_type(void) {
1197    static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
1198    return type;
1199  }
1200  #endif
1201  SWIGRUNTIMEINLINE int
1202  SwigPyObject_Check(PyObject *op) {
1203  #ifdef SWIGPYTHON_BUILTIN
1204    PyTypeObject *target_tp = SwigPyObject_type();
1205    if (PyType_IsSubtype(op->ob_type, target_tp))
1206      return 1;
1207    return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
1208  #else
1209    return (Py_TYPE(op) == SwigPyObject_type())
1210      || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
1211  #endif
1212  }
1213  SWIGRUNTIME PyObject *
1214  SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
1215  SWIGRUNTIME void
1216  SwigPyObject_dealloc(PyObject *v)
1217  {
1218    SwigPyObject *sobj = (SwigPyObject *) v;
1219    PyObject *next = sobj->next;
1220    if (sobj->own == SWIG_POINTER_OWN) {
1221      swig_type_info *ty = sobj->ty;
1222      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
1223      PyObject *destroy = data ? data->destroy : 0;
1224      if (destroy) {
1225        PyObject *res;
1226        PyObject *val = NULL, *type = NULL, *tb = NULL;
1227        PyErr_Fetch(&val, &type, &tb);
1228        if (data->delargs) {
1229          PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
1230          res = SWIG_Python_CallFunctor(destroy, tmp);
1231          Py_DECREF(tmp);
1232        } else {
1233          PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
1234          PyObject *mself = PyCFunction_GET_SELF(destroy);
1235          res = ((*meth)(mself, v));
1236        }
1237        if (!res)
1238          PyErr_WriteUnraisable(destroy);
1239        PyErr_Restore(val, type, tb);
1240        Py_XDECREF(res);
1241      }
1242  #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
1243      else {
1244        const char *name = SWIG_TypePrettyName(ty);
1245        printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
1246      }
1247  #endif
1248    }
1249    Py_XDECREF(next);
1250    PyObject_DEL(v);
1251  }
1252  SWIGRUNTIME PyObject*
1253  SwigPyObject_append(PyObject* v, PyObject* next)
1254  {
1255    SwigPyObject *sobj = (SwigPyObject *) v;
1256  #ifndef METH_O
1257    PyObject *tmp = 0;
1258    if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
1259    next = tmp;
1260  #endif
1261    if (!SwigPyObject_Check(next)) {
1262      PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
1263      return NULL;
1264    }
1265    sobj->next = next;
1266    Py_INCREF(next);
1267    return SWIG_Py_Void();
1268  }
1269  SWIGRUNTIME PyObject*
1270  SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
1271  {
1272    SwigPyObject *sobj = (SwigPyObject *) v;
1273    if (sobj->next) {
1274      Py_INCREF(sobj->next);
1275      return sobj->next;
1276    } else {
1277      return SWIG_Py_Void();
1278    }
1279  }
1280  SWIGINTERN PyObject*
1281  #ifdef METH_NOARGS
1282  SwigPyObject_disown(PyObject *v)
1283  #else
1284  SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
1285  #endif
1286  {
1287    SwigPyObject *sobj = (SwigPyObject *)v;
1288    sobj->own = 0;
1289    return SWIG_Py_Void();
1290  }
1291  SWIGINTERN PyObject*
1292  #ifdef METH_NOARGS
1293  SwigPyObject_acquire(PyObject *v)
1294  #else
1295  SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
1296  #endif
1297  {
1298    SwigPyObject *sobj = (SwigPyObject *)v;
1299    sobj->own = SWIG_POINTER_OWN;
1300    return SWIG_Py_Void();
1301  }
1302  #ifdef METH_NOARGS
1303  static PyObject*
1304  SwigPyObject_disown2(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
1305  {
1306    return SwigPyObject_disown(v);
1307  }
1308  static PyObject*
1309  SwigPyObject_acquire2(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
1310  {
1311    return SwigPyObject_acquire(v);
1312  }
1313  #endif
1314  SWIGINTERN PyObject*
1315  SwigPyObject_own(PyObject *v, PyObject *args)
1316  {
1317    PyObject *val = 0;
1318  #if (PY_VERSION_HEX < 0x02020000)
1319    if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
1320  #elif (PY_VERSION_HEX < 0x02050000)
1321    if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val))
1322  #else
1323    if (!PyArg_UnpackTuple(args, "own", 0, 1, &val))
1324  #endif
1325      {
1326        return NULL;
1327      }
1328    else
1329      {
1330        SwigPyObject *sobj = (SwigPyObject *)v;
1331        PyObject *obj = PyBool_FromLong(sobj->own);
1332        if (val) {
1333  #ifdef METH_NOARGS
1334          if (PyObject_IsTrue(val)) {
1335            SwigPyObject_acquire(v);
1336          } else {
1337            SwigPyObject_disown(v);
1338          }
1339  #else
1340          if (PyObject_IsTrue(val)) {
1341            SwigPyObject_acquire(v,args);
1342          } else {
1343            SwigPyObject_disown(v,args);
1344          }
1345  #endif
1346        }
1347        return obj;
1348      }
1349  }
1350  #ifdef METH_O
1351  static PyMethodDef
1352  swigobject_methods[] = {
1353    {(char *)"disown",  (PyCFunction)SwigPyObject_disown2, METH_NOARGS,  (char *)"releases ownership of the pointer"},
1354    {(char *)"acquire", (PyCFunction)SwigPyObject_acquire2,METH_NOARGS,  (char *)"acquires ownership of the pointer"},
1355    {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
1356    {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
1357    {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
1358    {(char *)"__repr__",(PyCFunction)SwigPyObject_repr2,   METH_NOARGS,  (char *)"returns object representation"},
1359    {0, 0, 0, 0}
1360  };
1361  #else
1362  static PyMethodDef
1363  swigobject_methods[] = {
1364    {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
1365    {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"acquires ownership of the pointer"},
1366    {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
1367    {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
1368    {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
1369    {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_VARARGS,  (char *)"returns object representation"},
1370    {0, 0, 0, 0}
1371  };
1372  #endif
1373  #if PY_VERSION_HEX < 0x02020000
1374  SWIGINTERN PyObject *
1375  SwigPyObject_getattr(SwigPyObject *sobj,char *name)
1376  {
1377    return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
1378  }
1379  #endif
1380  SWIGRUNTIME PyTypeObject*
1381  SwigPyObject_TypeOnce(void) {
1382    static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
1383    static PyNumberMethods SwigPyObject_as_number = {
1384      (binaryfunc)0, &bsol;*nb_add*/
1385      (binaryfunc)0, &bsol;*nb_subtract*/
1386      (binaryfunc)0, &bsol;*nb_multiply*/
1387  #if PY_VERSION_HEX < 0x03000000
1388      (binaryfunc)0, &bsol;*nb_divide*/
1389  #endif
1390      (binaryfunc)0, &bsol;*nb_remainder*/
1391      (binaryfunc)0, &bsol;*nb_divmod*/
1392      (ternaryfunc)0,&bsol;*nb_power*/
1393      (unaryfunc)0,  &bsol;*nb_negative*/
1394      (unaryfunc)0,  &bsol;*nb_positive*/
1395      (unaryfunc)0,  &bsol;*nb_absolute*/
1396      (inquiry)0,    &bsol;*nb_nonzero*/
1397      0,             &bsol;*nb_invert*/
1398      0,             &bsol;*nb_lshift*/
1399      0,             &bsol;*nb_rshift*/
1400      0,             &bsol;*nb_and*/
1401      0,             &bsol;*nb_xor*/
1402      0,             &bsol;*nb_or*/
1403  #if PY_VERSION_HEX < 0x03000000
1404      0,   &bsol;*nb_coerce*/
1405  #endif
1406      (unaryfunc)SwigPyObject_long, &bsol;*nb_int*/
1407  #if PY_VERSION_HEX < 0x03000000
1408      (unaryfunc)SwigPyObject_long, &bsol;*nb_long*/
1409  #else
1410      0, &bsol;*nb_reserved*/
1411  #endif
1412      (unaryfunc)0,                 &bsol;*nb_float*/
1413  #if PY_VERSION_HEX < 0x03000000
1414      (unaryfunc)SwigPyObject_oct,  &bsol;*nb_oct*/
1415      (unaryfunc)SwigPyObject_hex,  &bsol;*nb_hex*/
1416  #endif
1417  #if PY_VERSION_HEX >= 0x03050000 &bsol;* 3.5 */
1418      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &bsol;* nb_inplace_add -> nb_inplace_matrix_multiply */
1419  #elif PY_VERSION_HEX >= 0x03000000 &bsol;* 3.0 */
1420      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &bsol;* nb_inplace_add -> nb_index, nb_inplace_divide removed */
1421  #elif PY_VERSION_HEX >= 0x02050000 &bsol;* 2.5.0 */
1422      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &bsol;* nb_inplace_add -> nb_index */
1423  #elif PY_VERSION_HEX >= 0x02020000 &bsol;* 2.2.0 */
1424      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &bsol;* nb_inplace_add -> nb_inplace_true_divide */
1425  #elif PY_VERSION_HEX >= 0x02000000 &bsol;* 2.0.0 */
1426      0,0,0,0,0,0,0,0,0,0,0 &bsol;* nb_inplace_add -> nb_inplace_or */
1427  #endif
1428    };
1429    static PyTypeObject swigpyobject_type;
1430    static int type_init = 0;
1431    if (!type_init) {
1432      const PyTypeObject tmp = {
1433  #if PY_VERSION_HEX >= 0x03000000
1434        PyVarObject_HEAD_INIT(NULL, 0)
1435  #else
1436        PyObject_HEAD_INIT(NULL)
1437        0,                                    &bsol;* ob_size */
1438  #endif
1439        (char *)"SwigPyObject",               &bsol;* tp_name */
1440        sizeof(SwigPyObject),                 &bsol;* tp_basicsize */
1441        0,                                    &bsol;* tp_itemsize */
1442        (destructor)SwigPyObject_dealloc,     &bsol;* tp_dealloc */
1443        0,                                    &bsol;* tp_print */
1444  #if PY_VERSION_HEX < 0x02020000
1445        (getattrfunc)SwigPyObject_getattr,    &bsol;* tp_getattr */
1446  #else
1447        (getattrfunc)0,                       &bsol;* tp_getattr */
1448  #endif
1449        (setattrfunc)0,                       &bsol;* tp_setattr */
1450  #if PY_VERSION_HEX >= 0x03000000
1451        0, &bsol;* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
1452  #else
1453        (cmpfunc)SwigPyObject_compare,        &bsol;* tp_compare */
1454  #endif
1455        (reprfunc)SwigPyObject_repr,          &bsol;* tp_repr */
1456        &SwigPyObject_as_number,              &bsol;* tp_as_number */
1457        0,                                    &bsol;* tp_as_sequence */
1458        0,                                    &bsol;* tp_as_mapping */
1459        (hashfunc)0,                          &bsol;* tp_hash */
1460        (ternaryfunc)0,                       &bsol;* tp_call */
1461        0,                                    &bsol;* tp_str */
1462        PyObject_GenericGetAttr,              &bsol;* tp_getattro */
1463        0,                                    &bsol;* tp_setattro */
1464        0,                                    &bsol;* tp_as_buffer */
1465        Py_TPFLAGS_DEFAULT,                   &bsol;* tp_flags */
1466        swigobject_doc,                       &bsol;* tp_doc */
1467        0,                                    &bsol;* tp_traverse */
1468        0,                                    &bsol;* tp_clear */
1469        (richcmpfunc)SwigPyObject_richcompare,&bsol;* tp_richcompare */
1470        0,                                    &bsol;* tp_weaklistoffset */
1471  #if PY_VERSION_HEX >= 0x02020000
1472        0,                                    &bsol;* tp_iter */
1473        0,                                    &bsol;* tp_iternext */
1474        swigobject_methods,                   &bsol;* tp_methods */
1475        0,                                    &bsol;* tp_members */
1476        0,                                    &bsol;* tp_getset */
1477        0,                                    &bsol;* tp_base */
1478        0,                                    &bsol;* tp_dict */
1479        0,                                    &bsol;* tp_descr_get */
1480        0,                                    &bsol;* tp_descr_set */
1481        0,                                    &bsol;* tp_dictoffset */
1482        0,                                    &bsol;* tp_init */
1483        0,                                    &bsol;* tp_alloc */
1484        0,                                    &bsol;* tp_new */
1485        0,                                    &bsol;* tp_free */
1486        0,                                    &bsol;* tp_is_gc */
1487        0,                                    &bsol;* tp_bases */
1488        0,                                    &bsol;* tp_mro */
1489        0,                                    &bsol;* tp_cache */
1490        0,                                    &bsol;* tp_subclasses */
1491        0,                                    &bsol;* tp_weaklist */
1492  #endif
1493  #if PY_VERSION_HEX >= 0x02030000
1494        0,                                    &bsol;* tp_del */
1495  #endif
1496  #if PY_VERSION_HEX >= 0x02060000
1497        0,                                    &bsol;* tp_version_tag */
1498  #endif
1499  #if PY_VERSION_HEX >= 0x03040000
1500        0,                                    &bsol;* tp_finalize */
1501  #endif
1502  #ifdef COUNT_ALLOCS
1503        0,                                    &bsol;* tp_allocs */
1504        0,                                    &bsol;* tp_frees */
1505        0,                                    &bsol;* tp_maxalloc */
1506  #if PY_VERSION_HEX >= 0x02050000
1507        0,                                    &bsol;* tp_prev */
1508  #endif
1509        0                                     &bsol;* tp_next */
1510  #endif
1511      };
1512      swigpyobject_type = tmp;
1513      type_init = 1;
1514  #if PY_VERSION_HEX < 0x02020000
1515      swigpyobject_type.ob_type = &PyType_Type;
1516  #else
1517      if (PyType_Ready(&swigpyobject_type) < 0)
1518        return NULL;
1519  #endif
1520    }
1521    return &swigpyobject_type;
1522  }
1523  SWIGRUNTIME PyObject *
1524  SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
1525  {
1526    SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
1527    if (sobj) {
1528      sobj->ptr  = ptr;
1529      sobj->ty   = ty;
1530      sobj->own  = own;
1531      sobj->next = 0;
1532    }
1533    return (PyObject *)sobj;
1534  }
1535  typedef struct {
1536    PyObject_HEAD
1537    void *pack;
1538    swig_type_info *ty;
1539    size_t size;
1540  } SwigPyPacked;
1541  SWIGRUNTIME int
1542  SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
1543  {
1544    char result[SWIG_BUFFER_SIZE];
1545    fputs("<Swig Packed ", fp);
1546    if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
1547      fputs("at ", fp);
1548      fputs(result, fp);
1549    }
1550    fputs(v->ty->name,fp);
1551    fputs(">", fp);
1552    return 0;
1553  }
1554  SWIGRUNTIME PyObject *
1555  SwigPyPacked_repr(SwigPyPacked *v)
1556  {
1557    char result[SWIG_BUFFER_SIZE];
1558    if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
1559      return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
1560    } else {
1561      return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
1562    }
1563  }
1564  SWIGRUNTIME PyObject *
1565  SwigPyPacked_str(SwigPyPacked *v)
1566  {
1567    char result[SWIG_BUFFER_SIZE];
1568    if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
1569      return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
1570    } else {
1571      return SWIG_Python_str_FromChar(v->ty->name);
1572    }
1573  }
1574  SWIGRUNTIME int
1575  SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
1576  {
1577    size_t i = v->size;
1578    size_t j = w->size;
1579    int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
1580    return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
1581  }
1582  SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);
1583  SWIGRUNTIME PyTypeObject*
1584  SwigPyPacked_type(void) {
1585    static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
1586    return type;
1587  }
1588  SWIGRUNTIMEINLINE int
1589  SwigPyPacked_Check(PyObject *op) {
1590    return ((op)->ob_type == SwigPyPacked_TypeOnce())
1591      || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
1592  }
1593  SWIGRUNTIME void
1594  SwigPyPacked_dealloc(PyObject *v)
1595  {
1596    if (SwigPyPacked_Check(v)) {
1597      SwigPyPacked *sobj = (SwigPyPacked *) v;
1598      free(sobj->pack);
1599    }
1600    PyObject_DEL(v);
1601  }
1602  SWIGRUNTIME PyTypeObject*
1603  SwigPyPacked_TypeOnce(void) {
1604    static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
1605    static PyTypeObject swigpypacked_type;
1606    static int type_init = 0;
1607    if (!type_init) {
1608      const PyTypeObject tmp = {
1609  #if PY_VERSION_HEX>=0x03000000
1610        PyVarObject_HEAD_INIT(NULL, 0)
1611  #else
1612        PyObject_HEAD_INIT(NULL)
1613        0,                                    &bsol;* ob_size */
1614  #endif
1615        (char *)"SwigPyPacked",               &bsol;* tp_name */
1616        sizeof(SwigPyPacked),                 &bsol;* tp_basicsize */
1617        0,                                    &bsol;* tp_itemsize */
1618        (destructor)SwigPyPacked_dealloc,     &bsol;* tp_dealloc */
1619        (printfunc)SwigPyPacked_print,        &bsol;* tp_print */
1620        (getattrfunc)0,                       &bsol;* tp_getattr */
1621        (setattrfunc)0,                       &bsol;* tp_setattr */
1622  #if PY_VERSION_HEX>=0x03000000
1623        0, &bsol;* tp_reserved in 3.0.1 */
1624  #else
1625        (cmpfunc)SwigPyPacked_compare,        &bsol;* tp_compare */
1626  #endif
1627        (reprfunc)SwigPyPacked_repr,          &bsol;* tp_repr */
1628        0,                                    &bsol;* tp_as_number */
1629        0,                                    &bsol;* tp_as_sequence */
1630        0,                                    &bsol;* tp_as_mapping */
1631        (hashfunc)0,                          &bsol;* tp_hash */
1632        (ternaryfunc)0,                       &bsol;* tp_call */
1633        (reprfunc)SwigPyPacked_str,           &bsol;* tp_str */
1634        PyObject_GenericGetAttr,              &bsol;* tp_getattro */
1635        0,                                    &bsol;* tp_setattro */
1636        0,                                    &bsol;* tp_as_buffer */
1637        Py_TPFLAGS_DEFAULT,                   &bsol;* tp_flags */
1638        swigpacked_doc,                       &bsol;* tp_doc */
1639        0,                                    &bsol;* tp_traverse */
1640        0,                                    &bsol;* tp_clear */
1641        0,                                    &bsol;* tp_richcompare */
1642        0,                                    &bsol;* tp_weaklistoffset */
1643  #if PY_VERSION_HEX >= 0x02020000
1644        0,                                    &bsol;* tp_iter */
1645        0,                                    &bsol;* tp_iternext */
1646        0,                                    &bsol;* tp_methods */
1647        0,                                    &bsol;* tp_members */
1648        0,                                    &bsol;* tp_getset */
1649        0,                                    &bsol;* tp_base */
1650        0,                                    &bsol;* tp_dict */
1651        0,                                    &bsol;* tp_descr_get */
1652        0,                                    &bsol;* tp_descr_set */
1653        0,                                    &bsol;* tp_dictoffset */
1654        0,                                    &bsol;* tp_init */
1655        0,                                    &bsol;* tp_alloc */
1656        0,                                    &bsol;* tp_new */
1657        0,                                    &bsol;* tp_free */
1658        0,                                    &bsol;* tp_is_gc */
1659        0,                                    &bsol;* tp_bases */
1660        0,                                    &bsol;* tp_mro */
1661        0,                                    &bsol;* tp_cache */
1662        0,                                    &bsol;* tp_subclasses */
1663        0,                                    &bsol;* tp_weaklist */
1664  #endif
1665  #if PY_VERSION_HEX >= 0x02030000
1666        0,                                    &bsol;* tp_del */
1667  #endif
1668  #if PY_VERSION_HEX >= 0x02060000
1669        0,                                    &bsol;* tp_version_tag */
1670  #endif
1671  #if PY_VERSION_HEX >= 0x03040000
1672        0,                                    &bsol;* tp_finalize */
1673  #endif
1674  #ifdef COUNT_ALLOCS
1675        0,                                    &bsol;* tp_allocs */
1676        0,                                    &bsol;* tp_frees */
1677        0,                                    &bsol;* tp_maxalloc */
1678  #if PY_VERSION_HEX >= 0x02050000
1679        0,                                    &bsol;* tp_prev */
1680  #endif
1681        0                                     &bsol;* tp_next */
1682  #endif
1683      };
1684      swigpypacked_type = tmp;
1685      type_init = 1;
1686  #if PY_VERSION_HEX < 0x02020000
1687      swigpypacked_type.ob_type = &PyType_Type;
1688  #else
1689      if (PyType_Ready(&swigpypacked_type) < 0)
1690        return NULL;
1691  #endif
1692    }
1693    return &swigpypacked_type;
1694  }
1695  SWIGRUNTIME PyObject *
1696  SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
1697  {
1698    SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
1699    if (sobj) {
1700      void *pack = malloc(size);
1701      if (pack) {
1702        memcpy(pack, ptr, size);
1703        sobj->pack = pack;
1704        sobj->ty   = ty;
1705        sobj->size = size;
1706      } else {
1707        PyObject_DEL((PyObject *) sobj);
1708        sobj = 0;
1709      }
1710    }
1711    return (PyObject *) sobj;
1712  }
1713  SWIGRUNTIME swig_type_info *
1714  SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
1715  {
1716    if (SwigPyPacked_Check(obj)) {
1717      SwigPyPacked *sobj = (SwigPyPacked *)obj;
1718      if (sobj->size != size) return 0;
1719      memcpy(ptr, sobj->pack, size);
1720      return sobj->ty;
1721    } else {
1722      return 0;
1723    }
1724  }
1725  SWIGRUNTIMEINLINE PyObject *
1726  _SWIG_This(void)
1727  {
1728      return SWIG_Python_str_FromChar("this");
1729  }
1730  static PyObject *swig_this = NULL;
1731  SWIGRUNTIME PyObject *
1732  SWIG_This(void)
1733  {
1734    if (swig_this == NULL)
1735      swig_this = _SWIG_This();
1736    return swig_this;
1737  }
1738  #if PY_VERSION_HEX>=0x03000000
1739  #define SWIG_PYTHON_SLOW_GETSET_THIS
1740  #endif
1741  SWIGRUNTIME SwigPyObject *
1742  SWIG_Python_GetSwigThis(PyObject *pyobj)
1743  {
1744    PyObject *obj;
1745    if (SwigPyObject_Check(pyobj))
1746      return (SwigPyObject *) pyobj;
1747  #ifdef SWIGPYTHON_BUILTIN
1748    (void)obj;
1749  # ifdef PyWeakref_CheckProxy
1750    if (PyWeakref_CheckProxy(pyobj)) {
1751      pyobj = PyWeakref_GET_OBJECT(pyobj);
1752      if (pyobj && SwigPyObject_Check(pyobj))
1753        return (SwigPyObject*) pyobj;
1754    }
1755  # endif
1756    return NULL;
1757  #else
1758    obj = 0;
1759  #if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
1760    if (PyInstance_Check(pyobj)) {
1761      obj = _PyInstance_Lookup(pyobj, SWIG_This());
1762    } else {
1763      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
1764      if (dictptr != NULL) {
1765        PyObject *dict = *dictptr;
1766        obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
1767      } else {
1768  #ifdef PyWeakref_CheckProxy
1769        if (PyWeakref_CheckProxy(pyobj)) {
1770          PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
1771          return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
1772        }
1773  #endif
1774        obj = PyObject_GetAttr(pyobj,SWIG_This());
1775        if (obj) {
1776          Py_DECREF(obj);
1777        } else {
1778          if (PyErr_Occurred()) PyErr_Clear();
1779          return 0;
1780        }
1781      }
1782    }
1783  #else
1784    obj = PyObject_GetAttr(pyobj,SWIG_This());
1785    if (obj) {
1786      Py_DECREF(obj);
1787    } else {
1788      if (PyErr_Occurred()) PyErr_Clear();
1789      return 0;
1790    }
1791  #endif
1792    if (obj && !SwigPyObject_Check(obj)) {
1793      return SWIG_Python_GetSwigThis(obj);
1794    }
1795    return (SwigPyObject *)obj;
1796  #endif
1797  }
1798  SWIGRUNTIME int
1799  SWIG_Python_AcquirePtr(PyObject *obj, int own) {
1800    if (own == SWIG_POINTER_OWN) {
1801      SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
1802      if (sobj) {
1803        int oldown = sobj->own;
1804        sobj->own = own;
1805        return oldown;
1806      }
1807    }
1808    return 0;
1809  }
1810  SWIGRUNTIME int
1811  SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
1812    int res;
1813    SwigPyObject *sobj;
1814    int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;
1815    if (!obj)
1816      return SWIG_ERROR;
1817    if (obj == Py_None && !implicit_conv) {
1818      if (ptr)
1819        *ptr = 0;
1820      return SWIG_OK;
1821    }
1822    res = SWIG_ERROR;
1823    sobj = SWIG_Python_GetSwigThis(obj);
1824    if (own)
1825      *own = 0;
1826    while (sobj) {
1827      void *vptr = sobj->ptr;
1828      if (ty) {
1829        swig_type_info *to = sobj->ty;
1830        if (to == ty) {
1831          if (ptr) *ptr = vptr;
1832          break;
1833        } else {
1834          swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
1835          if (!tc) {
1836            sobj = (SwigPyObject *)sobj->next;
1837          } else {
1838            if (ptr) {
1839              int newmemory = 0;
1840              *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
1841              if (newmemory == SWIG_CAST_NEW_MEMORY) {
1842                assert(own); &bsol;* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
1843                if (own)
1844                  *own = *own | SWIG_CAST_NEW_MEMORY;
1845              }
1846            }
1847            break;
1848          }
1849        }
1850      } else {
1851        if (ptr) *ptr = vptr;
1852        break;
1853      }
1854    }
1855    if (sobj) {
1856      if (own)
1857        *own = *own | sobj->own;
1858      if (flags & SWIG_POINTER_DISOWN) {
1859        sobj->own = 0;
1860      }
1861      res = SWIG_OK;
1862    } else {
1863      if (implicit_conv) {
1864        SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
1865        if (data && !data->implicitconv) {
1866          PyObject *klass = data->klass;
1867          if (klass) {
1868            PyObject *impconv;
1869            data->implicitconv = 1; &bsol;* avoid recursion and call 'explicit' constructors*/
1870            impconv = SWIG_Python_CallFunctor(klass, obj);
1871            data->implicitconv = 0;
1872            if (PyErr_Occurred()) {
1873              PyErr_Clear();
1874              impconv = 0;
1875            }
1876            if (impconv) {
1877              SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
1878              if (iobj) {
1879                void *vptr;
1880                res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
1881                if (SWIG_IsOK(res)) {
1882                  if (ptr) {
1883                    *ptr = vptr;
1884                    iobj->own = 0;
1885                    res = SWIG_AddCast(res);
1886                    res = SWIG_AddNewMask(res);
1887                  } else {
1888                    res = SWIG_AddCast(res);
1889                  }
1890                }
1891              }
1892              Py_DECREF(impconv);
1893            }
1894          }
1895        }
1896      }
1897      if (!SWIG_IsOK(res) && obj == Py_None) {
1898        if (ptr)
1899          *ptr = 0;
1900        if (PyErr_Occurred())
1901          PyErr_Clear();
1902        res = SWIG_OK;
1903      }
1904    }
1905    return res;
1906  }
1907  SWIGRUNTIME int
1908  SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
1909    if (!PyCFunction_Check(obj)) {
1910      return SWIG_ConvertPtr(obj, ptr, ty, 0);
1911    } else {
1912      void *vptr = 0;
1913      const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
1914      const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
1915      if (desc)
1916        desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
1917      if (!desc)
1918        return SWIG_ERROR;
1919      if (ty) {
1920        swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
1921        if (tc) {
1922          int newmemory = 0;
1923          *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
1924          assert(!newmemory); &bsol;* newmemory handling not yet implemented */
1925        } else {
1926          return SWIG_ERROR;
1927        }
1928      } else {
1929        *ptr = vptr;
1930      }
1931      return SWIG_OK;
1932    }
1933  }
1934  SWIGRUNTIME int
1935  SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
1936    swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
1937    if (!to) return SWIG_ERROR;
1938    if (ty) {
1939      if (to != ty) {
1940        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
1941        if (!tc) return SWIG_ERROR;
1942      }
1943    }
1944    return SWIG_OK;
1945  }
1946  SWIGRUNTIME PyObject*
1947  SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
1948  {
1949  #if (PY_VERSION_HEX >= 0x02020000)
1950    PyObject *inst = 0;
1951    PyObject *newraw = data->newraw;
1952    if (newraw) {
1953      inst = PyObject_Call(newraw, data->newargs, NULL);
1954      if (inst) {
1955  #if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
1956        PyObject **dictptr = _PyObject_GetDictPtr(inst);
1957        if (dictptr != NULL) {
1958          PyObject *dict = *dictptr;
1959          if (dict == NULL) {
1960            dict = PyDict_New();
1961            *dictptr = dict;
1962            PyDict_SetItem(dict, SWIG_This(), swig_this);
1963          }
1964        }
1965  #else
1966        PyObject *key = SWIG_This();
1967        PyObject_SetAttr(inst, key, swig_this);
1968  #endif
1969      }
1970    } else {
1971  #if PY_VERSION_HEX >= 0x03000000
1972      inst = ((PyTypeObject*) data->newargs)->tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
1973      if (inst) {
1974        PyObject_SetAttr(inst, SWIG_This(), swig_this);
1975        Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
1976      }
1977  #else
1978      PyObject *dict = PyDict_New();
1979      if (dict) {
1980        PyDict_SetItem(dict, SWIG_This(), swig_this);
1981        inst = PyInstance_NewRaw(data->newargs, dict);
1982        Py_DECREF(dict);
1983      }
1984  #endif
1985    }
1986    return inst;
1987  #else
1988  #if (PY_VERSION_HEX >= 0x02010000)
1989    PyObject *inst = 0;
1990    PyObject *dict = PyDict_New();
1991    if (dict) {
1992      PyDict_SetItem(dict, SWIG_This(), swig_this);
1993      inst = PyInstance_NewRaw(data->newargs, dict);
1994      Py_DECREF(dict);
1995    }
1996    return (PyObject *) inst;
1997  #else
1998    PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
1999    if (inst == NULL) {
2000      return NULL;
2001    }
2002    inst->in_class = (PyClassObject *)data->newargs;
2003    Py_INCREF(inst->in_class);
2004    inst->in_dict = PyDict_New();
2005    if (inst->in_dict == NULL) {
2006      Py_DECREF(inst);
2007      return NULL;
2008    }
2009  #ifdef Py_TPFLAGS_HAVE_WEAKREFS
2010    inst->in_weakreflist = NULL;
2011  #endif
2012  #ifdef Py_TPFLAGS_GC
2013    PyObject_GC_Init(inst);
2014  #endif
2015    PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
2016    return (PyObject *) inst;
2017  #endif
2018  #endif
2019  }
2020  SWIGRUNTIME void
2021  SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
2022  {
2023   PyObject *dict;
2024  #if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
2025   PyObject **dictptr = _PyObject_GetDictPtr(inst);
2026   if (dictptr != NULL) {
2027     dict = *dictptr;
2028     if (dict == NULL) {
2029       dict = PyDict_New();
2030       *dictptr = dict;
2031     }
2032     PyDict_SetItem(dict, SWIG_This(), swig_this);
2033     return;
2034   }
2035  #endif
2036   dict = PyObject_GetAttrString(inst, (char*)"__dict__");
2037   PyDict_SetItem(dict, SWIG_This(), swig_this);
2038   Py_DECREF(dict);
2039  }
2040  SWIGINTERN PyObject *
2041  SWIG_Python_InitShadowInstance(PyObject *args) {
2042    PyObject *obj[2];
2043    if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
2044      return NULL;
2045    } else {
2046      SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
2047      if (sthis) {
2048        SwigPyObject_append((PyObject*) sthis, obj[1]);
2049      } else {
2050        SWIG_Python_SetSwigThis(obj[0], obj[1]);
2051      }
2052      return SWIG_Py_Void();
2053    }
2054  }
2055  SWIGRUNTIME PyObject *
2056  SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
2057    SwigPyClientData *clientdata;
2058    PyObject * robj;
2059    int own;
2060    if (!ptr)
2061      return SWIG_Py_Void();
2062    clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
2063    own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
2064    if (clientdata && clientdata->pytype) {
2065      SwigPyObject *newobj;
2066      if (flags & SWIG_BUILTIN_TP_INIT) {
2067        newobj = (SwigPyObject*) self;
2068        if (newobj->ptr) {
2069          PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
2070          while (newobj->next)
2071            newobj = (SwigPyObject *) newobj->next;
2072          newobj->next = next_self;
2073          newobj = (SwigPyObject *)next_self;
2074  #ifdef SWIGPYTHON_BUILTIN
2075          newobj->dict = 0;
2076  #endif
2077        }
2078      } else {
2079        newobj = PyObject_New(SwigPyObject, clientdata->pytype);
2080  #ifdef SWIGPYTHON_BUILTIN
2081        newobj->dict = 0;
2082  #endif
2083      }
2084      if (newobj) {
2085        newobj->ptr = ptr;
2086        newobj->ty = type;
2087        newobj->own = own;
2088        newobj->next = 0;
2089        return (PyObject*) newobj;
2090      }
2091      return SWIG_Py_Void();
2092    }
2093    assert(!(flags & SWIG_BUILTIN_TP_INIT));
2094    robj = SwigPyObject_New(ptr, type, own);
2095    if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
2096      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
2097      Py_DECREF(robj);
2098      robj = inst;
2099    }
2100    return robj;
2101  }
2102  SWIGRUNTIMEINLINE PyObject *
2103  SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
2104    return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
2105  }
2106  #ifdef SWIG_LINK_RUNTIME
2107  void *SWIG_ReturnGlobalTypeList(void *);
2108  #endif
2109  SWIGRUNTIME swig_module_info *
2110  SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
2111    static void *type_pointer = (void *)0;
2112    if (!type_pointer) {
2113  #ifdef SWIG_LINK_RUNTIME
2114      type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
2115  #else
2116  # ifdef SWIGPY_USE_CAPSULE
2117      type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
2118  # else
2119      type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
2120                                      (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
2121  # endif
2122      if (PyErr_Occurred()) {
2123        PyErr_Clear();
2124        type_pointer = (void *)0;
2125      }
2126  #endif
2127    }
2128    return (swig_module_info *) type_pointer;
2129  }
2130  #if PY_MAJOR_VERSION < 2
2131  SWIGINTERN int
2132  PyModule_AddObject(PyObject *m, char *name, PyObject *o)
2133  {
2134    PyObject *dict;
2135    if (!PyModule_Check(m)) {
2136      PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs module as first arg");
2137      return SWIG_ERROR;
2138    }
2139    if (!o) {
2140      PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs non-NULL value");
2141      return SWIG_ERROR;
2142    }
2143    dict = PyModule_GetDict(m);
2144    if (dict == NULL) {
2145      PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
2146                   PyModule_GetName(m));
2147      return SWIG_ERROR;
2148    }
2149    if (PyDict_SetItemString(dict, name, o))
2150      return SWIG_ERROR;
2151    Py_DECREF(o);
2152    return SWIG_OK;
2153  }
2154  #endif
2155  SWIGRUNTIME void
2156  #ifdef SWIGPY_USE_CAPSULE
2157  SWIG_Python_DestroyModule(PyObject *obj)
2158  #else
2159  SWIG_Python_DestroyModule(void *vptr)
2160  #endif
2161  {
2162  #ifdef SWIGPY_USE_CAPSULE
2163    swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
2164  #else
2165    swig_module_info *swig_module = (swig_module_info *) vptr;
2166  #endif
2167    swig_type_info **types = swig_module->types;
2168    size_t i;
2169    for (i =0; i < swig_module->size; ++i) {
2170      swig_type_info *ty = types[i];
2171      if (ty->owndata) {
2172        SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
2173        if (data) SwigPyClientData_Del(data);
2174      }
2175    }
2176    Py_DECREF(SWIG_This());
2177    swig_this = NULL;
2178  }
2179  SWIGRUNTIME void
2180  SWIG_Python_SetModule(swig_module_info *swig_module) {
2181  #if PY_VERSION_HEX >= 0x03000000
2182    PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
2183  #else
2184    static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; &bsol;* Sentinel */
2185    PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
2186  #endif
2187  #ifdef SWIGPY_USE_CAPSULE
2188    PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
2189    if (pointer && module) {
2190      PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
2191    } else {
2192      Py_XDECREF(pointer);
2193    }
2194  #else
2195    PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
2196    if (pointer && module) {
2197      PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
2198    } else {
2199      Py_XDECREF(pointer);
2200    }
2201  #endif
2202  }
2203  SWIGRUNTIME PyObject *
2204  SWIG_Python_TypeCache(void) {
2205    static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
2206    return cache;
2207  }
2208  SWIGRUNTIME swig_type_info *
2209  SWIG_Python_TypeQuery(const char *type)
2210  {
2211    PyObject *cache = SWIG_Python_TypeCache();
2212    PyObject *key = SWIG_Python_str_FromChar(type);
2213    PyObject *obj = PyDict_GetItem(cache, key);
2214    swig_type_info *descriptor;
2215    if (obj) {
2216  #ifdef SWIGPY_USE_CAPSULE
2217      descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
2218  #else
2219      descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
2220  #endif
2221    } else {
2222      swig_module_info *swig_module = SWIG_GetModule(0);
2223      descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
2224      if (descriptor) {
2225  #ifdef SWIGPY_USE_CAPSULE
2226        obj = PyCapsule_New((void*) descriptor, NULL, NULL);
2227  #else
2228        obj = PyCObject_FromVoidPtr(descriptor, NULL);
2229  #endif
2230        PyDict_SetItem(cache, key, obj);
2231        Py_DECREF(obj);
2232      }
2233    }
2234    Py_DECREF(key);
2235    return descriptor;
2236  }
2237  #define SWIG_POINTER_EXCEPTION  0
2238  #define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
2239  #define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
2240  SWIGRUNTIME int
2241  SWIG_Python_AddErrMesg(const char* mesg, int infront)
2242  {
2243    if (PyErr_Occurred()) {
2244      PyObject *type = 0;
2245      PyObject *value = 0;
2246      PyObject *traceback = 0;
2247      PyErr_Fetch(&type, &value, &traceback);
2248      if (value) {
2249        char *tmp;
2250        PyObject *old_str = PyObject_Str(value);
2251        Py_XINCREF(type);
2252        PyErr_Clear();
2253        if (infront) {
2254          PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
2255        } else {
2256          PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
2257        }
2258        SWIG_Python_str_DelForPy3(tmp);
2259        Py_DECREF(old_str);
2260      }
2261      return 1;
2262    } else {
2263      return 0;
2264    }
2265  }
2266  SWIGRUNTIME int
2267  SWIG_Python_ArgFail(int argnum)
2268  {
2269    if (PyErr_Occurred()) {
2270      char mesg[256];
2271      PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
2272      return SWIG_Python_AddErrMesg(mesg, 1);
2273    } else {
2274      return 0;
2275    }
2276  }
2277  SWIGRUNTIMEINLINE const char *
2278  SwigPyObject_GetDesc(PyObject *self)
2279  {
2280    SwigPyObject *v = (SwigPyObject *)self;
2281    swig_type_info *ty = v ? v->ty : 0;
2282    return ty ? ty->str : "";
2283  }
2284  SWIGRUNTIME void
2285  SWIG_Python_TypeError(const char *type, PyObject *obj)
2286  {
2287    if (type) {
2288  #if defined(SWIG_COBJECT_TYPES)
2289      if (obj && SwigPyObject_Check(obj)) {
2290        const char *otype = (const char *) SwigPyObject_GetDesc(obj);
2291        if (otype) {
2292          PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
2293                       type, otype);
2294          return;
2295        }
2296      } else
2297  #endif
2298      {
2299        const char *otype = (obj ? obj->ob_type->tp_name : 0);
2300        if (otype) {
2301          PyObject *str = PyObject_Str(obj);
2302          const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
2303          if (cstr) {
2304            PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
2305                         type, otype, cstr);
2306            SWIG_Python_str_DelForPy3(cstr);
2307          } else {
2308            PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
2309                         type, otype);
2310          }
2311          Py_XDECREF(str);
2312          return;
2313        }
2314      }
2315      PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
2316    } else {
2317      PyErr_Format(PyExc_TypeError, "unexpected type is received");
2318    }
2319  }
2320  SWIGRUNTIME void *
2321  SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
2322    void *result;
2323    if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
2324      PyErr_Clear();
2325  #if SWIG_POINTER_EXCEPTION
2326      if (flags) {
2327        SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
2328        SWIG_Python_ArgFail(argnum);
2329      }
2330  #endif
2331    }
2332    return result;
2333  }
2334  #ifdef SWIGPYTHON_BUILTIN
2335  SWIGRUNTIME int
2336  SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
2337    PyTypeObject *tp = obj->ob_type;
2338    PyObject *descr;
2339    PyObject *encoded_name;
2340    descrsetfunc f;
2341    int res = -1;
2342  # ifdef Py_USING_UNICODE
2343    if (PyString_Check(name)) {
2344      name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
2345      if (!name)
2346        return -1;
2347    } else if (!PyUnicode_Check(name))
2348  # else
2349    if (!PyString_Check(name))
2350  # endif
2351    {
2352      PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
2353      return -1;
2354    } else {
2355      Py_INCREF(name);
2356    }
2357    if (!tp->tp_dict) {
2358      if (PyType_Ready(tp) < 0)
2359        goto done;
2360    }
2361    descr = _PyType_Lookup(tp, name);
2362    f = NULL;
2363    if (descr != NULL)
2364      f = descr->ob_type->tp_descr_set;
2365    if (!f) {
2366      if (PyString_Check(name)) {
2367        encoded_name = name;
2368        Py_INCREF(name);
2369      } else {
2370        encoded_name = PyUnicode_AsUTF8String(name);
2371      }
2372      PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
2373      Py_DECREF(encoded_name);
2374    } else {
2375      res = f(descr, obj, value);
2376    }
2377    done:
2378    Py_DECREF(name);
2379    return res;
2380  }
2381  #endif
2382  #ifdef __cplusplus
2383  }
2384  #endif
2385  #define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0)
2386  #define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else
2387    #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0)
2388  #define SWIGTYPE_p_char swig_types[0]
2389  #define SWIGTYPE_p_int swig_types[1]
2390  #define SWIGTYPE_p_uint8_t swig_types[2]
2391  static swig_type_info *swig_types[4];
2392  static swig_module_info swig_module = {swig_types, 3, 0, 0, 0, 0};
2393  #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
2394  #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
2395  #if (PY_VERSION_HEX <= 0x02000000)
2396  # if !defined(SWIG_PYTHON_CLASSIC)
2397  #  error "This python version requires swig to be run with the '-classic' option"
2398  # endif
2399  #endif
2400  #if PY_VERSION_HEX >= 0x03000000
2401  #  define SWIG_init    PyInit__libwebp
2402  #else
2403  #  define SWIG_init    init_libwebp
2404  #endif
2405  #define SWIG_name    "_libwebp"
2406  #define SWIGVERSION 0x030012
2407  #define SWIG_VERSION SWIGVERSION
2408  #define SWIG_as_voidptr(a) (void *)((const void *)(a))
2409  #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a))
2410  SWIGINTERNINLINE PyObject*
2411    SWIG_From_int  (int value)
2412  {
2413    return PyInt_FromLong((long) value);
2414  }
2415  SWIGINTERN swig_type_info*
2416  SWIG_pchar_descriptor(void)
2417  {
2418    static int init = 0;
2419    static swig_type_info* info = 0;
2420    if (!init) {
2421      info = SWIG_TypeQuery("_p_char");
2422      init = 1;
2423    }
2424    return info;
2425  }
2426  SWIGINTERN int
2427  SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
2428  {
2429  #if PY_VERSION_HEX>=0x03000000
2430  #if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
2431    if (PyBytes_Check(obj))
2432  #else
2433    if (PyUnicode_Check(obj))
2434  #endif
2435  #else
2436    if (PyString_Check(obj))
2437  #endif
2438    {
2439      char *cstr; Py_ssize_t len;
2440  #if PY_VERSION_HEX>=0x03000000
2441  #if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
2442      if (!alloc && cptr) {
2443          return SWIG_RuntimeError;
2444      }
2445      obj = PyUnicode_AsUTF8String(obj);
2446      if(alloc) *alloc = SWIG_NEWOBJ;
2447  #endif
2448      PyBytes_AsStringAndSize(obj, &cstr, &len);
2449  #else
2450      PyString_AsStringAndSize(obj, &cstr, &len);
2451  #endif
2452      if (cptr) {
2453        if (alloc) {
2454  #if defined(SWIG_PYTHON_SAFE_CSTRINGS)
2455          if (*alloc != SWIG_OLDOBJ)
2456  #else
2457          if (*alloc == SWIG_NEWOBJ)
2458  #endif
2459          {
2460            *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
2461            *alloc = SWIG_NEWOBJ;
2462          } else {
2463            *cptr = cstr;
2464            *alloc = SWIG_OLDOBJ;
2465          }
2466        } else {
2467  #if PY_VERSION_HEX>=0x03000000
2468  #if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
2469          *cptr = PyBytes_AsString(obj);
2470  #else
2471          assert(0); &bsol;* Should never reach here with Unicode strings in Python 3 */
2472  #endif
2473  #else
2474          *cptr = SWIG_Python_str_AsChar(obj);
2475  #endif
2476        }
2477      }
2478      if (psize) *psize = len + 1;
2479  #if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
2480      Py_XDECREF(obj);
2481  #endif
2482      return SWIG_OK;
2483    } else {
2484  #if defined(SWIG_PYTHON_2_UNICODE)
2485  #if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
2486  #error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
2487  #endif
2488  #if PY_VERSION_HEX<0x03000000
2489      if (PyUnicode_Check(obj)) {
2490        char *cstr; Py_ssize_t len;
2491        if (!alloc && cptr) {
2492          return SWIG_RuntimeError;
2493        }
2494        obj = PyUnicode_AsUTF8String(obj);
2495        if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
2496          if (cptr) {
2497            if (alloc) *alloc = SWIG_NEWOBJ;
2498            *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
2499          }
2500          if (psize) *psize = len + 1;
2501          Py_XDECREF(obj);
2502          return SWIG_OK;
2503        } else {
2504          Py_XDECREF(obj);
2505        }
2506      }
2507  #endif
2508  #endif
2509      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
2510      if (pchar_descriptor) {
2511        void* vptr = 0;
2512        if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
2513          if (cptr) *cptr = (char *) vptr;
2514          if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
2515          if (alloc) *alloc = SWIG_OLDOBJ;
2516          return SWIG_OK;
2517        }
2518      }
2519    }
2520    return SWIG_TypeError;
2521  }
2522  SWIGINTERN int
2523  SWIG_AsVal_double (PyObject *obj, double *val)
2524  {
2525    int res = SWIG_TypeError;
2526    if (PyFloat_Check(obj)) {
2527      if (val) *val = PyFloat_AsDouble(obj);
2528      return SWIG_OK;
2529  #if PY_VERSION_HEX < 0x03000000
2530    } else if (PyInt_Check(obj)) {
2531      if (val) *val = (double) PyInt_AsLong(obj);
2532      return SWIG_OK;
2533  #endif
2534    } else if (PyLong_Check(obj)) {
2535      double v = PyLong_AsDouble(obj);
2536      if (!PyErr_Occurred()) {
2537        if (val) *val = v;
2538        return SWIG_OK;
2539      } else {
2540        PyErr_Clear();
2541      }
2542    }
2543  #ifdef SWIG_PYTHON_CAST_MODE
2544    {
2545      int dispatch = 0;
2546      double d = PyFloat_AsDouble(obj);
2547      if (!PyErr_Occurred()) {
2548        if (val) *val = d;
2549        return SWIG_AddCast(SWIG_OK);
2550      } else {
2551        PyErr_Clear();
2552      }
2553      if (!dispatch) {
2554        long v = PyLong_AsLong(obj);
2555        if (!PyErr_Occurred()) {
2556          if (val) *val = v;
2557          return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
2558        } else {
2559          PyErr_Clear();
2560        }
2561      }
2562    }
2563  #endif
2564    return res;
2565  }
2566  #include <float.h>
2567  #include <math.h>
2568  SWIGINTERNINLINE int
2569  SWIG_CanCastAsInteger(double *d, double min, double max) {
2570    double x = *d;
2571    if ((min <= x && x <= max)) {
2572     double fx = floor(x);
2573     double cx = ceil(x);
2574     double rd =  ((x - fx) < 0.5) ? fx : cx; &bsol;* simple rint */
2575     if ((errno == EDOM) || (errno == ERANGE)) {
2576       errno = 0;
2577     } else {
2578       double summ, reps, diff;
2579       if (rd < x) {
2580         diff = x - rd;
2581       } else if (rd > x) {
2582         diff = rd - x;
2583       } else {
2584         return 1;
2585       }
2586       summ = rd + x;
2587       reps = diff/summ;
2588       if (reps < 8*DBL_EPSILON) {
2589         *d = rd;
2590         return 1;
2591       }
2592     }
2593    }
2594    return 0;
2595  }
2596  SWIGINTERN int
2597  SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val)
2598  {
2599  #if PY_VERSION_HEX < 0x03000000
2600    if (PyInt_Check(obj)) {
2601      long v = PyInt_AsLong(obj);
2602      if (v >= 0) {
2603        if (val) *val = v;
2604        return SWIG_OK;
2605      } else {
2606        return SWIG_OverflowError;
2607      }
2608    } else
2609  #endif
2610    if (PyLong_Check(obj)) {
2611      unsigned long v = PyLong_AsUnsignedLong(obj);
2612      if (!PyErr_Occurred()) {
2613        if (val) *val = v;
2614        return SWIG_OK;
2615      } else {
2616        PyErr_Clear();
2617        return SWIG_OverflowError;
2618      }
2619    }
2620  #ifdef SWIG_PYTHON_CAST_MODE
2621    {
2622      int dispatch = 0;
2623      unsigned long v = PyLong_AsUnsignedLong(obj);
2624      if (!PyErr_Occurred()) {
2625        if (val) *val = v;
2626        return SWIG_AddCast(SWIG_OK);
2627      } else {
2628        PyErr_Clear();
2629      }
2630      if (!dispatch) {
2631        double d;
2632        int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
2633        if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
2634          if (val) *val = (unsigned long)(d);
2635          return res;
2636        }
2637      }
2638    }
2639  #endif
2640    return SWIG_TypeError;
2641  }
2642  #include <limits.h>
2643  #if !defined(SWIG_NO_LLONG_MAX)
2644  # if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
2645  #   define LLONG_MAX __LONG_LONG_MAX__
2646  #   define LLONG_MIN (-LLONG_MAX - 1LL)
2647  #   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
2648  # endif
2649  #endif
2650  #if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
2651  #  define SWIG_LONG_LONG_AVAILABLE
2652  #endif
2653  #ifdef SWIG_LONG_LONG_AVAILABLE
2654  SWIGINTERN int
2655  SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
2656  {
2657    int res = SWIG_TypeError;
2658    if (PyLong_Check(obj)) {
2659      unsigned long long v = PyLong_AsUnsignedLongLong(obj);
2660      if (!PyErr_Occurred()) {
2661        if (val) *val = v;
2662        return SWIG_OK;
2663      } else {
2664        PyErr_Clear();
2665        res = SWIG_OverflowError;
2666      }
2667    } else {
2668      unsigned long v;
2669      res = SWIG_AsVal_unsigned_SS_long (obj,&v);
2670      if (SWIG_IsOK(res)) {
2671        if (val) *val = v;
2672        return res;
2673      }
2674    }
2675  #ifdef SWIG_PYTHON_CAST_MODE
2676    {
2677      const double mant_max = 1LL << DBL_MANT_DIG;
2678      double d;
2679      res = SWIG_AsVal_double (obj,&d);
2680      if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
2681        return SWIG_OverflowError;
2682      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
2683        if (val) *val = (unsigned long long)(d);
2684        return SWIG_AddCast(res);
2685      }
2686      res = SWIG_TypeError;
2687    }
2688  #endif
2689    return res;
2690  }
2691  #endif
2692  SWIGINTERNINLINE int
2693  SWIG_AsVal_size_t (PyObject * obj, size_t *val)
2694  {
2695    int res = SWIG_TypeError;
2696  #ifdef SWIG_LONG_LONG_AVAILABLE
2697    if (sizeof(size_t) <= sizeof(unsigned long)) {
2698  #endif
2699      unsigned long v;
2700      res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
2701      if (SWIG_IsOK(res) && val) *val = (size_t)(v);
2702  #ifdef SWIG_LONG_LONG_AVAILABLE
2703    } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
2704      unsigned long long v;
2705      res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
2706      if (SWIG_IsOK(res) && val) *val = (size_t)(v);
2707    }
2708  #endif
2709    return res;
2710  }
2711  #include "webp/decode.h"
2712  #include "webp/encode.h"
2713  static size_t ReturnedBufferSize(
2714      const char* function, int* width, int* height) {
2715    static const struct sizemap {
2716      const char* function;
2717      int size_multiplier;
2718    } size_map[] = {
2719  #ifdef SWIGJAVA
2720      { "Java_com_google_webp_libwebpJNI_WebPDecodeRGB",  3 },
2721      { "Java_com_google_webp_libwebpJNI_WebPDecodeRGBA", 4 },
2722      { "Java_com_google_webp_libwebpJNI_WebPDecodeARGB", 4 },
2723      { "Java_com_google_webp_libwebpJNI_WebPDecodeBGR",  3 },
2724      { "Java_com_google_webp_libwebpJNI_WebPDecodeBGRA", 4 },
2725      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGB",  1 },
2726      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeBGR",  1 },
2727      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGBA", 1 },
2728      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeBGRA", 1 },
2729      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessRGB",  1 },
2730      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessBGR",  1 },
2731      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessRGBA", 1 },
2732      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessBGRA", 1 },
2733  #endif
2734  #ifdef SWIGPYTHON
2735      { "WebPDecodeRGB",  3 },
2736      { "WebPDecodeRGBA", 4 },
2737      { "WebPDecodeARGB", 4 },
2738      { "WebPDecodeBGR",  3 },
2739      { "WebPDecodeBGRA", 4 },
2740      { "wrap_WebPEncodeRGB",  1 },
2741      { "wrap_WebPEncodeBGR",  1 },
2742      { "wrap_WebPEncodeRGBA", 1 },
2743      { "wrap_WebPEncodeBGRA", 1 },
2744      { "wrap_WebPEncodeLosslessRGB",  1 },
2745      { "wrap_WebPEncodeLosslessBGR",  1 },
2746      { "wrap_WebPEncodeLosslessRGBA", 1 },
2747      { "wrap_WebPEncodeLosslessBGRA", 1 },
2748  #endif
2749      { NULL, 0 }
2750    };
2751    const struct sizemap* p;
2752    size_t size = 0;
2753    for (p = size_map; p->function; ++p) {
2754      if (!strcmp(function, p->function)) {
2755        size = *width * *height * p->size_multiplier;
2756        break;
2757      }
2758    }
2759    return size;
2760  }
2761  typedef size_t (*WebPEncodeFunction)(const uint8_t* rgb,
2762                                       int width, int height, int stride,
2763                                       float quality_factor, uint8_t** output);
2764  typedef size_t (*WebPEncodeLosslessFunction)(const uint8_t* rgb,
2765                                               int width, int height, int stride,
2766                                               uint8_t** output);
2767  static uint8_t* EncodeLossy(const uint8_t* rgb,
2768                              int width, int height, int stride,
2769                              float quality_factor,
2770                              WebPEncodeFunction encfn,
2771                              int* output_size, int* unused) {
2772    uint8_t* output = NULL;
2773    const size_t image_size =
2774        encfn(rgb, width, height, stride, quality_factor, &output);
2775    *output_size = image_size;
2776    *unused = 1;
2777    return image_size ? output : NULL;
2778  }
2779  static uint8_t* EncodeLossless(const uint8_t* rgb,
2780                                 int width, int height, int stride,
2781                                 WebPEncodeLosslessFunction encfn,
2782                                 int* output_size, int* unused) {
2783    uint8_t* output = NULL;
2784    const size_t image_size = encfn(rgb, width, height, stride, &output);
2785    *output_size = image_size;
2786    *unused = 1;
2787    return image_size ? output : NULL;
2788  }
2789  #define LOSSY_WRAPPER(FUNC)                                             \
2790    static uint8_t* wrap_##FUNC(                                          \
2791        const uint8_t* rgb, int* unused1, int* unused2, int* output_size, \
2792        int width, int height, int stride, float quality_factor) {        \
2793      return EncodeLossy(rgb, width, height, stride, quality_factor,      \
2794                         FUNC, output_size, unused2);                     \
2795    }                                                                     \
2796  
2797  LOSSY_WRAPPER(WebPEncodeRGB)
2798  LOSSY_WRAPPER(WebPEncodeBGR)
2799  LOSSY_WRAPPER(WebPEncodeRGBA)
2800  LOSSY_WRAPPER(WebPEncodeBGRA)
2801  #undef LOSSY_WRAPPER
2802  #define LOSSLESS_WRAPPER(FUNC)                                          \
2803    static uint8_t* wrap_##FUNC(                                          \
2804        const uint8_t* rgb, int* unused1, int* unused2, int* output_size, \
2805        int width, int height, int stride) {                              \
2806      return EncodeLossless(rgb, width, height, stride,                   \
2807                            FUNC, output_size, unused2);                  \
2808    }                                                                     \
2809  
2810  LOSSLESS_WRAPPER(WebPEncodeLosslessRGB)
2811  LOSSLESS_WRAPPER(WebPEncodeLosslessBGR)
2812  LOSSLESS_WRAPPER(WebPEncodeLosslessRGBA)
2813  LOSSLESS_WRAPPER(WebPEncodeLosslessBGRA)
2814  #undef LOSSLESS_WRAPPER
2815  SWIGINTERN int
2816  SWIG_AsVal_long (PyObject *obj, long* val)
2817  {
2818  #if PY_VERSION_HEX < 0x03000000
2819    if (PyInt_Check(obj)) {
2820      if (val) *val = PyInt_AsLong(obj);
2821      return SWIG_OK;
2822    } else
2823  #endif
2824    if (PyLong_Check(obj)) {
2825      long v = PyLong_AsLong(obj);
2826      if (!PyErr_Occurred()) {
2827        if (val) *val = v;
2828        return SWIG_OK;
2829      } else {
2830        PyErr_Clear();
2831        return SWIG_OverflowError;
2832      }
2833    }
2834  #ifdef SWIG_PYTHON_CAST_MODE
2835    {
2836      int dispatch = 0;
2837      long v = PyInt_AsLong(obj);
2838      if (!PyErr_Occurred()) {
2839        if (val) *val = v;
2840        return SWIG_AddCast(SWIG_OK);
2841      } else {
2842        PyErr_Clear();
2843      }
2844      if (!dispatch) {
2845        double d;
2846        int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
2847        if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
2848          if (val) *val = (long)(d);
2849          return res;
2850        }
2851      }
2852    }
2853  #endif
2854    return SWIG_TypeError;
2855  }
2856  SWIGINTERN int
2857  SWIG_AsVal_int (PyObject * obj, int *val)
2858  {
2859    long v;
2860    int res = SWIG_AsVal_long (obj, &v);
2861    if (SWIG_IsOK(res)) {
2862      if ((v < INT_MIN || v > INT_MAX)) {
2863        return SWIG_OverflowError;
2864      } else {
2865        if (val) *val = (int)(v);
2866      }
2867    }
2868    return res;
2869  }
2870  #ifndef SWIG_isfinite
2871  # if defined(isfinite)
2872  #  define SWIG_isfinite(X) (isfinite(X))
2873  # elif defined __cplusplus && __cplusplus >= 201103L
2874  namespace std { }
2875  extern "C++" template<typename T>
2876  inline int SWIG_isfinite_func(T x) {
2877    using namespace std;
2878    return isfinite(x);
2879  }
2880  #  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
2881  # elif defined(_MSC_VER)
2882  #  define SWIG_isfinite(X) (_finite(X))
2883  # elif defined(__sun) && defined(__SVR4)
2884  #  include <ieeefp.h>
2885  #  define SWIG_isfinite(X) (finite(X))
2886  # endif
2887  #endif
2888  #ifdef SWIG_isfinite
2889  # define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
2890  #else
2891  # define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
2892  #endif
2893  SWIGINTERN int
2894  SWIG_AsVal_float (PyObject * obj, float *val)
2895  {
2896    double v;
2897    int res = SWIG_AsVal_double (obj, &v);
2898    if (SWIG_IsOK(res)) {
2899      if (SWIG_Float_Overflow_Check(v)) {
2900        return SWIG_OverflowError;
2901      } else {
2902        if (val) *val = (float)(v);
2903      }
2904    }
2905    return res;
2906  }
2907  #ifdef __cplusplus
2908  extern "C" {
2909  #endif
2910  SWIGINTERN PyObject *_wrap_WebPGetDecoderVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
2911    PyObject *resultobj = 0;
2912    int result;
2913    if (!PyArg_ParseTuple(args,(char *)":WebPGetDecoderVersion")) SWIG_fail;
2914    result = (int)WebPGetDecoderVersion();
2915    resultobj = SWIG_From_int((int)(result));
2916    return resultobj;
2917  fail:
2918    return NULL;
2919  }
2920  SWIGINTERN PyObject *_wrap_WebPGetInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
2921    PyObject *resultobj = 0;
2922    uint8_t *arg1 = (uint8_t *) 0 ;
2923    size_t arg2 ;
2924    int *arg3 = (int *) 0 ;
2925    int *arg4 = (int *) 0 ;
2926    int res1 ;
2927    char *buf1 = 0 ;
2928    size_t size1 = 0 ;
2929    int alloc1 = 0 ;
2930    int temp3 ;
2931    int res3 = SWIG_TMPOBJ ;
2932    int temp4 ;
2933    int res4 = SWIG_TMPOBJ ;
2934    PyObject * obj0 = 0 ;
2935    int result;
2936    arg3 = &temp3;
2937    arg4 = &temp4;
2938    if (!PyArg_ParseTuple(args,(char *)"O:WebPGetInfo",&obj0)) SWIG_fail;
2939    res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, &size1, &alloc1);
2940    if (!SWIG_IsOK(res1)) {
2941      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WebPGetInfo" "', argument " "1"" of type '" "uint8_t const *""'");
2942    }
2943    arg1 = (uint8_t *)(buf1);
2944    arg2 = (size_t)(size1 - 1);
2945    result = (int)WebPGetInfo((uint8_t const *)arg1,arg2,arg3,arg4);
2946    resultobj = SWIG_From_int((int)(result));
2947    if (SWIG_IsTmpObj(res3)) {
2948      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
2949    } else {
2950      int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
2951      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
2952    }
2953    if (SWIG_IsTmpObj(res4)) {
2954      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
2955    } else {
2956      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
2957      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
2958    }
2959    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
2960    return resultobj;
2961  fail:
2962    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
2963    return NULL;
2964  }
2965  SWIGINTERN PyObject *_wrap_WebPDecodeRGB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
2966    PyObject *resultobj = 0;
2967    uint8_t *arg1 = (uint8_t *) 0 ;
2968    size_t arg2 ;
2969    int *arg3 = (int *) 0 ;
2970    int *arg4 = (int *) 0 ;
2971    int res1 ;
2972    char *buf1 = 0 ;
2973    size_t size1 = 0 ;
2974    int alloc1 = 0 ;
2975    int temp3 ;
2976    int res3 = SWIG_TMPOBJ ;
2977    int temp4 ;
2978    int res4 = SWIG_TMPOBJ ;
2979    PyObject * obj0 = 0 ;
2980    uint8_t *result = 0 ;
2981    arg3 = &temp3;
2982    arg4 = &temp4;
2983    if (!PyArg_ParseTuple(args,(char *)"O:WebPDecodeRGB",&obj0)) SWIG_fail;
2984    res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, &size1, &alloc1);
2985    if (!SWIG_IsOK(res1)) {
2986      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WebPDecodeRGB" "', argument " "1"" of type '" "uint8_t const *""'");
2987    }
2988    arg1 = (uint8_t *)(buf1);
2989    arg2 = (size_t)(size1 - 1);
2990    result = (uint8_t *)WebPDecodeRGB((uint8_t const *)arg1,arg2,arg3,arg4);
2991    {
2992      resultobj = PyString_FromStringAndSize(
2993        (const char*)result,
2994        (result == NULL) ? 0 : ReturnedBufferSize("WebPDecodeRGB", arg3, arg4));
2995    }
2996    if (SWIG_IsTmpObj(res3)) {
2997      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
2998    } else {
2999      int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3000      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
3001    }
3002    if (SWIG_IsTmpObj(res4)) {
3003      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3004    } else {
3005      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3006      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3007    }
3008    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3009    free(result);
3010    return resultobj;
3011  fail:
3012    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3013    return NULL;
3014  }
3015  SWIGINTERN PyObject *_wrap_WebPDecodeRGBA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3016    PyObject *resultobj = 0;
3017    uint8_t *arg1 = (uint8_t *) 0 ;
3018    size_t arg2 ;
3019    int *arg3 = (int *) 0 ;
3020    int *arg4 = (int *) 0 ;
3021    int res1 ;
3022    char *buf1 = 0 ;
3023    size_t size1 = 0 ;
3024    int alloc1 = 0 ;
3025    int temp3 ;
3026    int res3 = SWIG_TMPOBJ ;
3027    int temp4 ;
3028    int res4 = SWIG_TMPOBJ ;
3029    PyObject * obj0 = 0 ;
3030    uint8_t *result = 0 ;
3031    arg3 = &temp3;
3032    arg4 = &temp4;
3033    if (!PyArg_ParseTuple(args,(char *)"O:WebPDecodeRGBA",&obj0)) SWIG_fail;
3034    res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, &size1, &alloc1);
3035    if (!SWIG_IsOK(res1)) {
3036      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WebPDecodeRGBA" "', argument " "1"" of type '" "uint8_t const *""'");
3037    }
3038    arg1 = (uint8_t *)(buf1);
3039    arg2 = (size_t)(size1 - 1);
3040    result = (uint8_t *)WebPDecodeRGBA((uint8_t const *)arg1,arg2,arg3,arg4);
3041    {
3042      resultobj = PyString_FromStringAndSize(
3043        (const char*)result,
3044        (result == NULL) ? 0 : ReturnedBufferSize("WebPDecodeRGBA", arg3, arg4));
3045    }
3046    if (SWIG_IsTmpObj(res3)) {
3047      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
3048    } else {
3049      int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3050      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
3051    }
3052    if (SWIG_IsTmpObj(res4)) {
3053      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3054    } else {
3055      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3056      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3057    }
3058    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3059    free(result);
3060    return resultobj;
3061  fail:
3062    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3063    return NULL;
3064  }
3065  SWIGINTERN PyObject *_wrap_WebPDecodeARGB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3066    PyObject *resultobj = 0;
3067    uint8_t *arg1 = (uint8_t *) 0 ;
3068    size_t arg2 ;
3069    int *arg3 = (int *) 0 ;
3070    int *arg4 = (int *) 0 ;
3071    int res1 ;
3072    char *buf1 = 0 ;
3073    size_t size1 = 0 ;
3074    int alloc1 = 0 ;
3075    int temp3 ;
3076    int res3 = SWIG_TMPOBJ ;
3077    int temp4 ;
3078    int res4 = SWIG_TMPOBJ ;
3079    PyObject * obj0 = 0 ;
3080    uint8_t *result = 0 ;
3081    arg3 = &temp3;
3082    arg4 = &temp4;
3083    if (!PyArg_ParseTuple(args,(char *)"O:WebPDecodeARGB",&obj0)) SWIG_fail;
3084    res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, &size1, &alloc1);
3085    if (!SWIG_IsOK(res1)) {
3086      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WebPDecodeARGB" "', argument " "1"" of type '" "uint8_t const *""'");
3087    }
3088    arg1 = (uint8_t *)(buf1);
3089    arg2 = (size_t)(size1 - 1);
3090    result = (uint8_t *)WebPDecodeARGB((uint8_t const *)arg1,arg2,arg3,arg4);
3091    {
3092      resultobj = PyString_FromStringAndSize(
3093        (const char*)result,
3094        (result == NULL) ? 0 : ReturnedBufferSize("WebPDecodeARGB", arg3, arg4));
3095    }
3096    if (SWIG_IsTmpObj(res3)) {
3097      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
3098    } else {
3099      int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3100      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
3101    }
3102    if (SWIG_IsTmpObj(res4)) {
3103      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3104    } else {
3105      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3106      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3107    }
3108    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3109    free(result);
3110    return resultobj;
3111  fail:
3112    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3113    return NULL;
3114  }
3115  SWIGINTERN PyObject *_wrap_WebPDecodeBGR(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3116    PyObject *resultobj = 0;
3117    uint8_t *arg1 = (uint8_t *) 0 ;
3118    size_t arg2 ;
3119    int *arg3 = (int *) 0 ;
3120    int *arg4 = (int *) 0 ;
3121    int res1 ;
3122    char *buf1 = 0 ;
3123    size_t size1 = 0 ;
3124    int alloc1 = 0 ;
3125    int temp3 ;
3126    int res3 = SWIG_TMPOBJ ;
3127    int temp4 ;
3128    int res4 = SWIG_TMPOBJ ;
3129    PyObject * obj0 = 0 ;
3130    uint8_t *result = 0 ;
3131    arg3 = &temp3;
3132    arg4 = &temp4;
3133    if (!PyArg_ParseTuple(args,(char *)"O:WebPDecodeBGR",&obj0)) SWIG_fail;
3134    res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, &size1, &alloc1);
3135    if (!SWIG_IsOK(res1)) {
3136      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WebPDecodeBGR" "', argument " "1"" of type '" "uint8_t const *""'");
3137    }
3138    arg1 = (uint8_t *)(buf1);
3139    arg2 = (size_t)(size1 - 1);
3140    result = (uint8_t *)WebPDecodeBGR((uint8_t const *)arg1,arg2,arg3,arg4);
3141    {
3142      resultobj = PyString_FromStringAndSize(
3143        (const char*)result,
3144        (result == NULL) ? 0 : ReturnedBufferSize("WebPDecodeBGR", arg3, arg4));
3145    }
3146    if (SWIG_IsTmpObj(res3)) {
3147      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
3148    } else {
3149      int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3150      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
3151    }
3152    if (SWIG_IsTmpObj(res4)) {
3153      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3154    } else {
3155      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3156      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3157    }
3158    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3159    free(result);
3160    return resultobj;
3161  fail:
3162    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3163    return NULL;
3164  }
3165  SWIGINTERN PyObject *_wrap_WebPDecodeBGRA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3166    PyObject *resultobj = 0;
3167    uint8_t *arg1 = (uint8_t *) 0 ;
3168    size_t arg2 ;
3169    int *arg3 = (int *) 0 ;
3170    int *arg4 = (int *) 0 ;
3171    int res1 ;
3172    char *buf1 = 0 ;
3173    size_t size1 = 0 ;
3174    int alloc1 = 0 ;
3175    int temp3 ;
3176    int res3 = SWIG_TMPOBJ ;
3177    int temp4 ;
3178    int res4 = SWIG_TMPOBJ ;
3179    PyObject * obj0 = 0 ;
3180    uint8_t *result = 0 ;
3181    arg3 = &temp3;
3182    arg4 = &temp4;
3183    if (!PyArg_ParseTuple(args,(char *)"O:WebPDecodeBGRA",&obj0)) SWIG_fail;
3184    res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, &size1, &alloc1);
3185    if (!SWIG_IsOK(res1)) {
3186      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WebPDecodeBGRA" "', argument " "1"" of type '" "uint8_t const *""'");
3187    }
3188    arg1 = (uint8_t *)(buf1);
3189    arg2 = (size_t)(size1 - 1);
3190    result = (uint8_t *)WebPDecodeBGRA((uint8_t const *)arg1,arg2,arg3,arg4);
3191    {
3192      resultobj = PyString_FromStringAndSize(
3193        (const char*)result,
3194        (result == NULL) ? 0 : ReturnedBufferSize("WebPDecodeBGRA", arg3, arg4));
3195    }
3196    if (SWIG_IsTmpObj(res3)) {
3197      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
3198    } else {
3199      int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3200      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
3201    }
3202    if (SWIG_IsTmpObj(res4)) {
3203      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3204    } else {
3205      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3206      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3207    }
3208    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3209    free(result);
3210    return resultobj;
3211  fail:
3212    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
3213    return NULL;
3214  }
3215  SWIGINTERN PyObject *_wrap_WebPGetEncoderVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3216    PyObject *resultobj = 0;
3217    int result;
3218    if (!PyArg_ParseTuple(args,(char *)":WebPGetEncoderVersion")) SWIG_fail;
3219    result = (int)WebPGetEncoderVersion();
3220    resultobj = SWIG_From_int((int)(result));
3221    return resultobj;
3222  fail:
3223    return NULL;
3224  }
3225  SWIGINTERN PyObject *_wrap_wrap_WebPEncodeRGB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3226    PyObject *resultobj = 0;
3227    uint8_t *arg1 = (uint8_t *) 0 ;
3228    int *arg2 = (int *) 0 ;
3229    int *arg3 = (int *) 0 ;
3230    int *arg4 = (int *) 0 ;
3231    int arg5 ;
3232    int arg6 ;
3233    int arg7 ;
3234    float arg8 ;
3235    Py_buffer rgb_buffer1 ;
3236    int temp2 ;
3237    int res2 = 0 ;
3238    int temp3 ;
3239    int res3 = 0 ;
3240    int temp4 ;
3241    int res4 = SWIG_TMPOBJ ;
3242    int val5 ;
3243    int ecode5 = 0 ;
3244    int val6 ;
3245    int ecode6 = 0 ;
3246    int val7 ;
3247    int ecode7 = 0 ;
3248    float val8 ;
3249    int ecode8 = 0 ;
3250    PyObject * obj0 = 0 ;
3251    PyObject * obj1 = 0 ;
3252    PyObject * obj2 = 0 ;
3253    PyObject * obj3 = 0 ;
3254    PyObject * obj4 = 0 ;
3255    PyObject * obj5 = 0 ;
3256    PyObject * obj6 = 0 ;
3257    uint8_t *result = 0 ;
3258    arg4 = &temp4;
3259    if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:wrap_WebPEncodeRGB",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
3260    {
3261      if (!PyObject_CheckBuffer(obj0)) {
3262        SWIG_exception_fail(SWIG_TypeError,
3263          "in method 'wrap_WebPEncodeRGB', argument 1"
3264          " does not support the buffer interface");
3265      }
3266      if (PyObject_GetBuffer(obj0, &rgb_buffer1, PyBUF_SIMPLE)) {
3267        SWIG_exception_fail(SWIG_RuntimeError,
3268          "in method 'wrap_WebPEncodeRGB', unable to get buffer view");
3269      }
3270      arg1 = (uint8_t *)rgb_buffer1.buf;
3271    }
3272    if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_int,0))))) {
3273      int val;
3274      int ecode = SWIG_AsVal_int(obj1, &val);
3275      if (!SWIG_IsOK(ecode)) {
3276        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeRGB" "', argument " "2"" of type '" "int""'");
3277      }
3278      temp2 = (int)(val);
3279      arg2 = &temp2;
3280      res2 = SWIG_AddTmpMask(ecode);
3281    }
3282    if (!(SWIG_IsOK((res3 = SWIG_ConvertPtr(obj2,SWIG_as_voidptrptr(&arg3),SWIGTYPE_p_int,0))))) {
3283      int val;
3284      int ecode = SWIG_AsVal_int(obj2, &val);
3285      if (!SWIG_IsOK(ecode)) {
3286        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeRGB" "', argument " "3"" of type '" "int""'");
3287      }
3288      temp3 = (int)(val);
3289      arg3 = &temp3;
3290      res3 = SWIG_AddTmpMask(ecode);
3291    }
3292    ecode5 = SWIG_AsVal_int(obj3, &val5);
3293    if (!SWIG_IsOK(ecode5)) {
3294      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "wrap_WebPEncodeRGB" "', argument " "5"" of type '" "int""'");
3295    }
3296    arg5 = (int)(val5);
3297    ecode6 = SWIG_AsVal_int(obj4, &val6);
3298    if (!SWIG_IsOK(ecode6)) {
3299      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "wrap_WebPEncodeRGB" "', argument " "6"" of type '" "int""'");
3300    }
3301    arg6 = (int)(val6);
3302    ecode7 = SWIG_AsVal_int(obj5, &val7);
3303    if (!SWIG_IsOK(ecode7)) {
3304      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "wrap_WebPEncodeRGB" "', argument " "7"" of type '" "int""'");
3305    }
3306    arg7 = (int)(val7);
3307    ecode8 = SWIG_AsVal_float(obj6, &val8);
3308    if (!SWIG_IsOK(ecode8)) {
3309      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "wrap_WebPEncodeRGB" "', argument " "8"" of type '" "float""'");
3310    }
3311    arg8 = (float)(val8);
3312    result = (uint8_t *)wrap_WebPEncodeRGB((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
3313    {
3314      resultobj = PyString_FromStringAndSize(
3315        (const char*)result,
3316        (result == NULL) ? 0 : ReturnedBufferSize("wrap_WebPEncodeRGB", arg3, arg4));
3317    }
3318    if (SWIG_IsTmpObj(res4)) {
3319      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3320    } else {
3321      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3322      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3323    }
3324    {
3325      PyBuffer_Release(&rgb_buffer1);
3326    }
3327    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3328    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3329    free(result);
3330    return resultobj;
3331  fail:
3332    {
3333      PyBuffer_Release(&rgb_buffer1);
3334    }
3335    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3336    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3337    return NULL;
3338  }
3339  SWIGINTERN PyObject *_wrap_wrap_WebPEncodeBGR(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3340    PyObject *resultobj = 0;
3341    uint8_t *arg1 = (uint8_t *) 0 ;
3342    int *arg2 = (int *) 0 ;
3343    int *arg3 = (int *) 0 ;
3344    int *arg4 = (int *) 0 ;
3345    int arg5 ;
3346    int arg6 ;
3347    int arg7 ;
3348    float arg8 ;
3349    Py_buffer rgb_buffer1 ;
3350    int temp2 ;
3351    int res2 = 0 ;
3352    int temp3 ;
3353    int res3 = 0 ;
3354    int temp4 ;
3355    int res4 = SWIG_TMPOBJ ;
3356    int val5 ;
3357    int ecode5 = 0 ;
3358    int val6 ;
3359    int ecode6 = 0 ;
3360    int val7 ;
3361    int ecode7 = 0 ;
3362    float val8 ;
3363    int ecode8 = 0 ;
3364    PyObject * obj0 = 0 ;
3365    PyObject * obj1 = 0 ;
3366    PyObject * obj2 = 0 ;
3367    PyObject * obj3 = 0 ;
3368    PyObject * obj4 = 0 ;
3369    PyObject * obj5 = 0 ;
3370    PyObject * obj6 = 0 ;
3371    uint8_t *result = 0 ;
3372    arg4 = &temp4;
3373    if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:wrap_WebPEncodeBGR",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
3374    {
3375      if (!PyObject_CheckBuffer(obj0)) {
3376        SWIG_exception_fail(SWIG_TypeError,
3377          "in method 'wrap_WebPEncodeBGR', argument 1"
3378          " does not support the buffer interface");
3379      }
3380      if (PyObject_GetBuffer(obj0, &rgb_buffer1, PyBUF_SIMPLE)) {
3381        SWIG_exception_fail(SWIG_RuntimeError,
3382          "in method 'wrap_WebPEncodeBGR', unable to get buffer view");
3383      }
3384      arg1 = (uint8_t *)rgb_buffer1.buf;
3385    }
3386    if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_int,0))))) {
3387      int val;
3388      int ecode = SWIG_AsVal_int(obj1, &val);
3389      if (!SWIG_IsOK(ecode)) {
3390        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeBGR" "', argument " "2"" of type '" "int""'");
3391      }
3392      temp2 = (int)(val);
3393      arg2 = &temp2;
3394      res2 = SWIG_AddTmpMask(ecode);
3395    }
3396    if (!(SWIG_IsOK((res3 = SWIG_ConvertPtr(obj2,SWIG_as_voidptrptr(&arg3),SWIGTYPE_p_int,0))))) {
3397      int val;
3398      int ecode = SWIG_AsVal_int(obj2, &val);
3399      if (!SWIG_IsOK(ecode)) {
3400        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeBGR" "', argument " "3"" of type '" "int""'");
3401      }
3402      temp3 = (int)(val);
3403      arg3 = &temp3;
3404      res3 = SWIG_AddTmpMask(ecode);
3405    }
3406    ecode5 = SWIG_AsVal_int(obj3, &val5);
3407    if (!SWIG_IsOK(ecode5)) {
3408      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "wrap_WebPEncodeBGR" "', argument " "5"" of type '" "int""'");
3409    }
3410    arg5 = (int)(val5);
3411    ecode6 = SWIG_AsVal_int(obj4, &val6);
3412    if (!SWIG_IsOK(ecode6)) {
3413      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "wrap_WebPEncodeBGR" "', argument " "6"" of type '" "int""'");
3414    }
3415    arg6 = (int)(val6);
3416    ecode7 = SWIG_AsVal_int(obj5, &val7);
3417    if (!SWIG_IsOK(ecode7)) {
3418      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "wrap_WebPEncodeBGR" "', argument " "7"" of type '" "int""'");
3419    }
3420    arg7 = (int)(val7);
3421    ecode8 = SWIG_AsVal_float(obj6, &val8);
3422    if (!SWIG_IsOK(ecode8)) {
3423      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "wrap_WebPEncodeBGR" "', argument " "8"" of type '" "float""'");
3424    }
3425    arg8 = (float)(val8);
3426    result = (uint8_t *)wrap_WebPEncodeBGR((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
3427    {
3428      resultobj = PyString_FromStringAndSize(
3429        (const char*)result,
3430        (result == NULL) ? 0 : ReturnedBufferSize("wrap_WebPEncodeBGR", arg3, arg4));
3431    }
3432    if (SWIG_IsTmpObj(res4)) {
3433      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3434    } else {
3435      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3436      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3437    }
3438    {
3439      PyBuffer_Release(&rgb_buffer1);
3440    }
3441    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3442    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3443    free(result);
3444    return resultobj;
3445  fail:
3446    {
3447      PyBuffer_Release(&rgb_buffer1);
3448    }
3449    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3450    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3451    return NULL;
3452  }
3453  SWIGINTERN PyObject *_wrap_wrap_WebPEncodeRGBA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3454    PyObject *resultobj = 0;
3455    uint8_t *arg1 = (uint8_t *) 0 ;
3456    int *arg2 = (int *) 0 ;
3457    int *arg3 = (int *) 0 ;
3458    int *arg4 = (int *) 0 ;
3459    int arg5 ;
3460    int arg6 ;
3461    int arg7 ;
3462    float arg8 ;
3463    Py_buffer rgb_buffer1 ;
3464    int temp2 ;
3465    int res2 = 0 ;
3466    int temp3 ;
3467    int res3 = 0 ;
3468    int temp4 ;
3469    int res4 = SWIG_TMPOBJ ;
3470    int val5 ;
3471    int ecode5 = 0 ;
3472    int val6 ;
3473    int ecode6 = 0 ;
3474    int val7 ;
3475    int ecode7 = 0 ;
3476    float val8 ;
3477    int ecode8 = 0 ;
3478    PyObject * obj0 = 0 ;
3479    PyObject * obj1 = 0 ;
3480    PyObject * obj2 = 0 ;
3481    PyObject * obj3 = 0 ;
3482    PyObject * obj4 = 0 ;
3483    PyObject * obj5 = 0 ;
3484    PyObject * obj6 = 0 ;
3485    uint8_t *result = 0 ;
3486    arg4 = &temp4;
3487    if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:wrap_WebPEncodeRGBA",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
3488    {
3489      if (!PyObject_CheckBuffer(obj0)) {
3490        SWIG_exception_fail(SWIG_TypeError,
3491          "in method 'wrap_WebPEncodeRGBA', argument 1"
3492          " does not support the buffer interface");
3493      }
3494      if (PyObject_GetBuffer(obj0, &rgb_buffer1, PyBUF_SIMPLE)) {
3495        SWIG_exception_fail(SWIG_RuntimeError,
3496          "in method 'wrap_WebPEncodeRGBA', unable to get buffer view");
3497      }
3498      arg1 = (uint8_t *)rgb_buffer1.buf;
3499    }
3500    if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_int,0))))) {
3501      int val;
3502      int ecode = SWIG_AsVal_int(obj1, &val);
3503      if (!SWIG_IsOK(ecode)) {
3504        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeRGBA" "', argument " "2"" of type '" "int""'");
3505      }
3506      temp2 = (int)(val);
3507      arg2 = &temp2;
3508      res2 = SWIG_AddTmpMask(ecode);
3509    }
3510    if (!(SWIG_IsOK((res3 = SWIG_ConvertPtr(obj2,SWIG_as_voidptrptr(&arg3),SWIGTYPE_p_int,0))))) {
3511      int val;
3512      int ecode = SWIG_AsVal_int(obj2, &val);
3513      if (!SWIG_IsOK(ecode)) {
3514        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeRGBA" "', argument " "3"" of type '" "int""'");
3515      }
3516      temp3 = (int)(val);
3517      arg3 = &temp3;
3518      res3 = SWIG_AddTmpMask(ecode);
3519    }
3520    ecode5 = SWIG_AsVal_int(obj3, &val5);
3521    if (!SWIG_IsOK(ecode5)) {
3522      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "wrap_WebPEncodeRGBA" "', argument " "5"" of type '" "int""'");
3523    }
3524    arg5 = (int)(val5);
3525    ecode6 = SWIG_AsVal_int(obj4, &val6);
3526    if (!SWIG_IsOK(ecode6)) {
3527      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "wrap_WebPEncodeRGBA" "', argument " "6"" of type '" "int""'");
3528    }
3529    arg6 = (int)(val6);
3530    ecode7 = SWIG_AsVal_int(obj5, &val7);
3531    if (!SWIG_IsOK(ecode7)) {
3532      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "wrap_WebPEncodeRGBA" "', argument " "7"" of type '" "int""'");
3533    }
3534    arg7 = (int)(val7);
3535    ecode8 = SWIG_AsVal_float(obj6, &val8);
3536    if (!SWIG_IsOK(ecode8)) {
3537      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "wrap_WebPEncodeRGBA" "', argument " "8"" of type '" "float""'");
3538    }
3539    arg8 = (float)(val8);
3540    result = (uint8_t *)wrap_WebPEncodeRGBA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
3541    {
3542      resultobj = PyString_FromStringAndSize(
3543        (const char*)result,
3544        (result == NULL) ? 0 : ReturnedBufferSize("wrap_WebPEncodeRGBA", arg3, arg4));
3545    }
3546    if (SWIG_IsTmpObj(res4)) {
3547      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3548    } else {
3549      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3550      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3551    }
3552    {
3553      PyBuffer_Release(&rgb_buffer1);
3554    }
3555    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3556    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3557    free(result);
3558    return resultobj;
3559  fail:
3560    {
3561      PyBuffer_Release(&rgb_buffer1);
3562    }
3563    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3564    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3565    return NULL;
3566  }
3567  SWIGINTERN PyObject *_wrap_wrap_WebPEncodeBGRA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3568    PyObject *resultobj = 0;
3569    uint8_t *arg1 = (uint8_t *) 0 ;
3570    int *arg2 = (int *) 0 ;
3571    int *arg3 = (int *) 0 ;
3572    int *arg4 = (int *) 0 ;
3573    int arg5 ;
3574    int arg6 ;
3575    int arg7 ;
3576    float arg8 ;
3577    Py_buffer rgb_buffer1 ;
3578    int temp2 ;
3579    int res2 = 0 ;
3580    int temp3 ;
3581    int res3 = 0 ;
3582    int temp4 ;
3583    int res4 = SWIG_TMPOBJ ;
3584    int val5 ;
3585    int ecode5 = 0 ;
3586    int val6 ;
3587    int ecode6 = 0 ;
3588    int val7 ;
3589    int ecode7 = 0 ;
3590    float val8 ;
3591    int ecode8 = 0 ;
3592    PyObject * obj0 = 0 ;
3593    PyObject * obj1 = 0 ;
3594    PyObject * obj2 = 0 ;
3595    PyObject * obj3 = 0 ;
3596    PyObject * obj4 = 0 ;
3597    PyObject * obj5 = 0 ;
3598    PyObject * obj6 = 0 ;
3599    uint8_t *result = 0 ;
3600    arg4 = &temp4;
3601    if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:wrap_WebPEncodeBGRA",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
3602    {
3603      if (!PyObject_CheckBuffer(obj0)) {
3604        SWIG_exception_fail(SWIG_TypeError,
3605          "in method 'wrap_WebPEncodeBGRA', argument 1"
3606          " does not support the buffer interface");
3607      }
3608      if (PyObject_GetBuffer(obj0, &rgb_buffer1, PyBUF_SIMPLE)) {
3609        SWIG_exception_fail(SWIG_RuntimeError,
3610          "in method 'wrap_WebPEncodeBGRA', unable to get buffer view");
3611      }
3612      arg1 = (uint8_t *)rgb_buffer1.buf;
3613    }
3614    if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_int,0))))) {
3615      int val;
3616      int ecode = SWIG_AsVal_int(obj1, &val);
3617      if (!SWIG_IsOK(ecode)) {
3618        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeBGRA" "', argument " "2"" of type '" "int""'");
3619      }
3620      temp2 = (int)(val);
3621      arg2 = &temp2;
3622      res2 = SWIG_AddTmpMask(ecode);
3623    }
3624    if (!(SWIG_IsOK((res3 = SWIG_ConvertPtr(obj2,SWIG_as_voidptrptr(&arg3),SWIGTYPE_p_int,0))))) {
3625      int val;
3626      int ecode = SWIG_AsVal_int(obj2, &val);
3627      if (!SWIG_IsOK(ecode)) {
3628        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeBGRA" "', argument " "3"" of type '" "int""'");
3629      }
3630      temp3 = (int)(val);
3631      arg3 = &temp3;
3632      res3 = SWIG_AddTmpMask(ecode);
3633    }
3634    ecode5 = SWIG_AsVal_int(obj3, &val5);
3635    if (!SWIG_IsOK(ecode5)) {
3636      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "wrap_WebPEncodeBGRA" "', argument " "5"" of type '" "int""'");
3637    }
3638    arg5 = (int)(val5);
3639    ecode6 = SWIG_AsVal_int(obj4, &val6);
3640    if (!SWIG_IsOK(ecode6)) {
3641      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "wrap_WebPEncodeBGRA" "', argument " "6"" of type '" "int""'");
3642    }
3643    arg6 = (int)(val6);
3644    ecode7 = SWIG_AsVal_int(obj5, &val7);
3645    if (!SWIG_IsOK(ecode7)) {
3646      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "wrap_WebPEncodeBGRA" "', argument " "7"" of type '" "int""'");
3647    }
3648    arg7 = (int)(val7);
3649    ecode8 = SWIG_AsVal_float(obj6, &val8);
3650    if (!SWIG_IsOK(ecode8)) {
3651      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "wrap_WebPEncodeBGRA" "', argument " "8"" of type '" "float""'");
3652    }
3653    arg8 = (float)(val8);
3654    result = (uint8_t *)wrap_WebPEncodeBGRA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
3655    {
3656      resultobj = PyString_FromStringAndSize(
3657        (const char*)result,
3658        (result == NULL) ? 0 : ReturnedBufferSize("wrap_WebPEncodeBGRA", arg3, arg4));
3659    }
3660    if (SWIG_IsTmpObj(res4)) {
3661      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3662    } else {
3663      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3664      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3665    }
3666    {
3667      PyBuffer_Release(&rgb_buffer1);
3668    }
3669    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3670    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3671    free(result);
3672    return resultobj;
3673  fail:
3674    {
3675      PyBuffer_Release(&rgb_buffer1);
3676    }
3677    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3678    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3679    return NULL;
3680  }
3681  SWIGINTERN PyObject *_wrap_wrap_WebPEncodeLosslessRGB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3682    PyObject *resultobj = 0;
3683    uint8_t *arg1 = (uint8_t *) 0 ;
3684    int *arg2 = (int *) 0 ;
3685    int *arg3 = (int *) 0 ;
3686    int *arg4 = (int *) 0 ;
3687    int arg5 ;
3688    int arg6 ;
3689    int arg7 ;
3690    Py_buffer rgb_buffer1 ;
3691    int temp2 ;
3692    int res2 = 0 ;
3693    int temp3 ;
3694    int res3 = 0 ;
3695    int temp4 ;
3696    int res4 = SWIG_TMPOBJ ;
3697    int val5 ;
3698    int ecode5 = 0 ;
3699    int val6 ;
3700    int ecode6 = 0 ;
3701    int val7 ;
3702    int ecode7 = 0 ;
3703    PyObject * obj0 = 0 ;
3704    PyObject * obj1 = 0 ;
3705    PyObject * obj2 = 0 ;
3706    PyObject * obj3 = 0 ;
3707    PyObject * obj4 = 0 ;
3708    PyObject * obj5 = 0 ;
3709    uint8_t *result = 0 ;
3710    arg4 = &temp4;
3711    if (!PyArg_ParseTuple(args,(char *)"OOOOOO:wrap_WebPEncodeLosslessRGB",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
3712    {
3713      if (!PyObject_CheckBuffer(obj0)) {
3714        SWIG_exception_fail(SWIG_TypeError,
3715          "in method 'wrap_WebPEncodeLosslessRGB', argument 1"
3716          " does not support the buffer interface");
3717      }
3718      if (PyObject_GetBuffer(obj0, &rgb_buffer1, PyBUF_SIMPLE)) {
3719        SWIG_exception_fail(SWIG_RuntimeError,
3720          "in method 'wrap_WebPEncodeLosslessRGB', unable to get buffer view");
3721      }
3722      arg1 = (uint8_t *)rgb_buffer1.buf;
3723    }
3724    if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_int,0))))) {
3725      int val;
3726      int ecode = SWIG_AsVal_int(obj1, &val);
3727      if (!SWIG_IsOK(ecode)) {
3728        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeLosslessRGB" "', argument " "2"" of type '" "int""'");
3729      }
3730      temp2 = (int)(val);
3731      arg2 = &temp2;
3732      res2 = SWIG_AddTmpMask(ecode);
3733    }
3734    if (!(SWIG_IsOK((res3 = SWIG_ConvertPtr(obj2,SWIG_as_voidptrptr(&arg3),SWIGTYPE_p_int,0))))) {
3735      int val;
3736      int ecode = SWIG_AsVal_int(obj2, &val);
3737      if (!SWIG_IsOK(ecode)) {
3738        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeLosslessRGB" "', argument " "3"" of type '" "int""'");
3739      }
3740      temp3 = (int)(val);
3741      arg3 = &temp3;
3742      res3 = SWIG_AddTmpMask(ecode);
3743    }
3744    ecode5 = SWIG_AsVal_int(obj3, &val5);
3745    if (!SWIG_IsOK(ecode5)) {
3746      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "wrap_WebPEncodeLosslessRGB" "', argument " "5"" of type '" "int""'");
3747    }
3748    arg5 = (int)(val5);
3749    ecode6 = SWIG_AsVal_int(obj4, &val6);
3750    if (!SWIG_IsOK(ecode6)) {
3751      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "wrap_WebPEncodeLosslessRGB" "', argument " "6"" of type '" "int""'");
3752    }
3753    arg6 = (int)(val6);
3754    ecode7 = SWIG_AsVal_int(obj5, &val7);
3755    if (!SWIG_IsOK(ecode7)) {
3756      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "wrap_WebPEncodeLosslessRGB" "', argument " "7"" of type '" "int""'");
3757    }
3758    arg7 = (int)(val7);
3759    result = (uint8_t *)wrap_WebPEncodeLosslessRGB((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
3760    {
3761      resultobj = PyString_FromStringAndSize(
3762        (const char*)result,
3763        (result == NULL) ? 0 : ReturnedBufferSize("wrap_WebPEncodeLosslessRGB", arg3, arg4));
3764    }
3765    if (SWIG_IsTmpObj(res4)) {
3766      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3767    } else {
3768      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3769      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3770    }
3771    {
3772      PyBuffer_Release(&rgb_buffer1);
3773    }
3774    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3775    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3776    free(result);
3777    return resultobj;
3778  fail:
3779    {
3780      PyBuffer_Release(&rgb_buffer1);
3781    }
3782    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3783    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3784    return NULL;
3785  }
3786  SWIGINTERN PyObject *_wrap_wrap_WebPEncodeLosslessBGR(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3787    PyObject *resultobj = 0;
3788    uint8_t *arg1 = (uint8_t *) 0 ;
3789    int *arg2 = (int *) 0 ;
3790    int *arg3 = (int *) 0 ;
3791    int *arg4 = (int *) 0 ;
3792    int arg5 ;
3793    int arg6 ;
3794    int arg7 ;
3795    Py_buffer rgb_buffer1 ;
3796    int temp2 ;
3797    int res2 = 0 ;
3798    int temp3 ;
3799    int res3 = 0 ;
3800    int temp4 ;
3801    int res4 = SWIG_TMPOBJ ;
3802    int val5 ;
3803    int ecode5 = 0 ;
3804    int val6 ;
3805    int ecode6 = 0 ;
3806    int val7 ;
3807    int ecode7 = 0 ;
3808    PyObject * obj0 = 0 ;
3809    PyObject * obj1 = 0 ;
3810    PyObject * obj2 = 0 ;
3811    PyObject * obj3 = 0 ;
3812    PyObject * obj4 = 0 ;
3813    PyObject * obj5 = 0 ;
3814    uint8_t *result = 0 ;
3815    arg4 = &temp4;
3816    if (!PyArg_ParseTuple(args,(char *)"OOOOOO:wrap_WebPEncodeLosslessBGR",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
3817    {
3818      if (!PyObject_CheckBuffer(obj0)) {
3819        SWIG_exception_fail(SWIG_TypeError,
3820          "in method 'wrap_WebPEncodeLosslessBGR', argument 1"
3821          " does not support the buffer interface");
3822      }
3823      if (PyObject_GetBuffer(obj0, &rgb_buffer1, PyBUF_SIMPLE)) {
3824        SWIG_exception_fail(SWIG_RuntimeError,
3825          "in method 'wrap_WebPEncodeLosslessBGR', unable to get buffer view");
3826      }
3827      arg1 = (uint8_t *)rgb_buffer1.buf;
3828    }
3829    if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_int,0))))) {
3830      int val;
3831      int ecode = SWIG_AsVal_int(obj1, &val);
3832      if (!SWIG_IsOK(ecode)) {
3833        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeLosslessBGR" "', argument " "2"" of type '" "int""'");
3834      }
3835      temp2 = (int)(val);
3836      arg2 = &temp2;
3837      res2 = SWIG_AddTmpMask(ecode);
3838    }
3839    if (!(SWIG_IsOK((res3 = SWIG_ConvertPtr(obj2,SWIG_as_voidptrptr(&arg3),SWIGTYPE_p_int,0))))) {
3840      int val;
3841      int ecode = SWIG_AsVal_int(obj2, &val);
3842      if (!SWIG_IsOK(ecode)) {
3843        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeLosslessBGR" "', argument " "3"" of type '" "int""'");
3844      }
3845      temp3 = (int)(val);
3846      arg3 = &temp3;
3847      res3 = SWIG_AddTmpMask(ecode);
3848    }
3849    ecode5 = SWIG_AsVal_int(obj3, &val5);
3850    if (!SWIG_IsOK(ecode5)) {
3851      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "wrap_WebPEncodeLosslessBGR" "', argument " "5"" of type '" "int""'");
3852    }
3853    arg5 = (int)(val5);
3854    ecode6 = SWIG_AsVal_int(obj4, &val6);
3855    if (!SWIG_IsOK(ecode6)) {
3856      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "wrap_WebPEncodeLosslessBGR" "', argument " "6"" of type '" "int""'");
3857    }
3858    arg6 = (int)(val6);
3859    ecode7 = SWIG_AsVal_int(obj5, &val7);
3860    if (!SWIG_IsOK(ecode7)) {
3861      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "wrap_WebPEncodeLosslessBGR" "', argument " "7"" of type '" "int""'");
3862    }
3863    arg7 = (int)(val7);
3864    result = (uint8_t *)wrap_WebPEncodeLosslessBGR((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
3865    {
3866      resultobj = PyString_FromStringAndSize(
3867        (const char*)result,
3868        (result == NULL) ? 0 : ReturnedBufferSize("wrap_WebPEncodeLosslessBGR", arg3, arg4));
3869    }
3870    if (SWIG_IsTmpObj(res4)) {
3871      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3872    } else {
3873      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3874      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3875    }
3876    {
3877      PyBuffer_Release(&rgb_buffer1);
3878    }
3879    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3880    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3881    free(result);
3882    return resultobj;
3883  fail:
3884    {
3885      PyBuffer_Release(&rgb_buffer1);
3886    }
3887    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3888    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3889    return NULL;
3890  }
3891  SWIGINTERN PyObject *_wrap_wrap_WebPEncodeLosslessRGBA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3892    PyObject *resultobj = 0;
3893    uint8_t *arg1 = (uint8_t *) 0 ;
3894    int *arg2 = (int *) 0 ;
3895    int *arg3 = (int *) 0 ;
3896    int *arg4 = (int *) 0 ;
3897    int arg5 ;
3898    int arg6 ;
3899    int arg7 ;
3900    Py_buffer rgb_buffer1 ;
3901    int temp2 ;
3902    int res2 = 0 ;
3903    int temp3 ;
3904    int res3 = 0 ;
3905    int temp4 ;
3906    int res4 = SWIG_TMPOBJ ;
3907    int val5 ;
3908    int ecode5 = 0 ;
3909    int val6 ;
3910    int ecode6 = 0 ;
3911    int val7 ;
3912    int ecode7 = 0 ;
3913    PyObject * obj0 = 0 ;
3914    PyObject * obj1 = 0 ;
3915    PyObject * obj2 = 0 ;
3916    PyObject * obj3 = 0 ;
3917    PyObject * obj4 = 0 ;
3918    PyObject * obj5 = 0 ;
3919    uint8_t *result = 0 ;
3920    arg4 = &temp4;
3921    if (!PyArg_ParseTuple(args,(char *)"OOOOOO:wrap_WebPEncodeLosslessRGBA",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
3922    {
3923      if (!PyObject_CheckBuffer(obj0)) {
3924        SWIG_exception_fail(SWIG_TypeError,
3925          "in method 'wrap_WebPEncodeLosslessRGBA', argument 1"
3926          " does not support the buffer interface");
3927      }
3928      if (PyObject_GetBuffer(obj0, &rgb_buffer1, PyBUF_SIMPLE)) {
3929        SWIG_exception_fail(SWIG_RuntimeError,
3930          "in method 'wrap_WebPEncodeLosslessRGBA', unable to get buffer view");
3931      }
3932      arg1 = (uint8_t *)rgb_buffer1.buf;
3933    }
3934    if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_int,0))))) {
3935      int val;
3936      int ecode = SWIG_AsVal_int(obj1, &val);
3937      if (!SWIG_IsOK(ecode)) {
3938        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeLosslessRGBA" "', argument " "2"" of type '" "int""'");
3939      }
3940      temp2 = (int)(val);
3941      arg2 = &temp2;
3942      res2 = SWIG_AddTmpMask(ecode);
3943    }
3944    if (!(SWIG_IsOK((res3 = SWIG_ConvertPtr(obj2,SWIG_as_voidptrptr(&arg3),SWIGTYPE_p_int,0))))) {
3945      int val;
3946      int ecode = SWIG_AsVal_int(obj2, &val);
3947      if (!SWIG_IsOK(ecode)) {
3948        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeLosslessRGBA" "', argument " "3"" of type '" "int""'");
3949      }
3950      temp3 = (int)(val);
3951      arg3 = &temp3;
3952      res3 = SWIG_AddTmpMask(ecode);
3953    }
3954    ecode5 = SWIG_AsVal_int(obj3, &val5);
3955    if (!SWIG_IsOK(ecode5)) {
3956      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "wrap_WebPEncodeLosslessRGBA" "', argument " "5"" of type '" "int""'");
3957    }
3958    arg5 = (int)(val5);
3959    ecode6 = SWIG_AsVal_int(obj4, &val6);
3960    if (!SWIG_IsOK(ecode6)) {
3961      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "wrap_WebPEncodeLosslessRGBA" "', argument " "6"" of type '" "int""'");
3962    }
3963    arg6 = (int)(val6);
3964    ecode7 = SWIG_AsVal_int(obj5, &val7);
3965    if (!SWIG_IsOK(ecode7)) {
3966      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "wrap_WebPEncodeLosslessRGBA" "', argument " "7"" of type '" "int""'");
3967    }
3968    arg7 = (int)(val7);
3969    result = (uint8_t *)wrap_WebPEncodeLosslessRGBA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
3970    {
3971      resultobj = PyString_FromStringAndSize(
3972        (const char*)result,
3973        (result == NULL) ? 0 : ReturnedBufferSize("wrap_WebPEncodeLosslessRGBA", arg3, arg4));
3974    }
3975    if (SWIG_IsTmpObj(res4)) {
3976      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
3977    } else {
3978      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
3979      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
3980    }
3981    {
3982      PyBuffer_Release(&rgb_buffer1);
3983    }
3984    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3985    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3986    free(result);
3987    return resultobj;
3988  fail:
3989    {
3990      PyBuffer_Release(&rgb_buffer1);
3991    }
3992    if (SWIG_IsNewObj(res2)) free((char*)arg2);
3993    if (SWIG_IsNewObj(res3)) free((char*)arg3);
3994    return NULL;
3995  }
3996  SWIGINTERN PyObject *_wrap_wrap_WebPEncodeLosslessBGRA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
3997    PyObject *resultobj = 0;
3998    uint8_t *arg1 = (uint8_t *) 0 ;
3999    int *arg2 = (int *) 0 ;
4000    int *arg3 = (int *) 0 ;
4001    int *arg4 = (int *) 0 ;
4002    int arg5 ;
4003    int arg6 ;
4004    int arg7 ;
4005    Py_buffer rgb_buffer1 ;
4006    int temp2 ;
4007    int res2 = 0 ;
4008    int temp3 ;
4009    int res3 = 0 ;
4010    int temp4 ;
4011    int res4 = SWIG_TMPOBJ ;
4012    int val5 ;
4013    int ecode5 = 0 ;
4014    int val6 ;
4015    int ecode6 = 0 ;
4016    int val7 ;
4017    int ecode7 = 0 ;
4018    PyObject * obj0 = 0 ;
4019    PyObject * obj1 = 0 ;
4020    PyObject * obj2 = 0 ;
4021    PyObject * obj3 = 0 ;
4022    PyObject * obj4 = 0 ;
4023    PyObject * obj5 = 0 ;
4024    uint8_t *result = 0 ;
4025    arg4 = &temp4;
4026    if (!PyArg_ParseTuple(args,(char *)"OOOOOO:wrap_WebPEncodeLosslessBGRA",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
4027    {
4028      if (!PyObject_CheckBuffer(obj0)) {
4029        SWIG_exception_fail(SWIG_TypeError,
4030          "in method 'wrap_WebPEncodeLosslessBGRA', argument 1"
4031          " does not support the buffer interface");
4032      }
4033      if (PyObject_GetBuffer(obj0, &rgb_buffer1, PyBUF_SIMPLE)) {
4034        SWIG_exception_fail(SWIG_RuntimeError,
4035          "in method 'wrap_WebPEncodeLosslessBGRA', unable to get buffer view");
4036      }
4037      arg1 = (uint8_t *)rgb_buffer1.buf;
4038    }
4039    if (!(SWIG_IsOK((res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2),SWIGTYPE_p_int,0))))) {
4040      int val;
4041      int ecode = SWIG_AsVal_int(obj1, &val);
4042      if (!SWIG_IsOK(ecode)) {
4043        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeLosslessBGRA" "', argument " "2"" of type '" "int""'");
4044      }
4045      temp2 = (int)(val);
4046      arg2 = &temp2;
4047      res2 = SWIG_AddTmpMask(ecode);
4048    }
4049    if (!(SWIG_IsOK((res3 = SWIG_ConvertPtr(obj2,SWIG_as_voidptrptr(&arg3),SWIGTYPE_p_int,0))))) {
4050      int val;
4051      int ecode = SWIG_AsVal_int(obj2, &val);
4052      if (!SWIG_IsOK(ecode)) {
4053        SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "wrap_WebPEncodeLosslessBGRA" "', argument " "3"" of type '" "int""'");
4054      }
4055      temp3 = (int)(val);
4056      arg3 = &temp3;
4057      res3 = SWIG_AddTmpMask(ecode);
4058    }
4059    ecode5 = SWIG_AsVal_int(obj3, &val5);
4060    if (!SWIG_IsOK(ecode5)) {
4061      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "wrap_WebPEncodeLosslessBGRA" "', argument " "5"" of type '" "int""'");
4062    }
4063    arg5 = (int)(val5);
4064    ecode6 = SWIG_AsVal_int(obj4, &val6);
4065    if (!SWIG_IsOK(ecode6)) {
4066      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "wrap_WebPEncodeLosslessBGRA" "', argument " "6"" of type '" "int""'");
4067    }
4068    arg6 = (int)(val6);
4069    ecode7 = SWIG_AsVal_int(obj5, &val7);
4070    if (!SWIG_IsOK(ecode7)) {
4071      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "wrap_WebPEncodeLosslessBGRA" "', argument " "7"" of type '" "int""'");
4072    }
4073    arg7 = (int)(val7);
4074    result = (uint8_t *)wrap_WebPEncodeLosslessBGRA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
4075    {
4076      resultobj = PyString_FromStringAndSize(
4077        (const char*)result,
4078        (result == NULL) ? 0 : ReturnedBufferSize("wrap_WebPEncodeLosslessBGRA", arg3, arg4));
4079    }
4080    if (SWIG_IsTmpObj(res4)) {
4081      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
4082    } else {
4083      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
4084      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
4085    }
4086    {
4087      PyBuffer_Release(&rgb_buffer1);
4088    }
4089    if (SWIG_IsNewObj(res2)) free((char*)arg2);
4090    if (SWIG_IsNewObj(res3)) free((char*)arg3);
4091    free(result);
4092    return resultobj;
4093  fail:
4094    {
4095      PyBuffer_Release(&rgb_buffer1);
4096    }
4097    if (SWIG_IsNewObj(res2)) free((char*)arg2);
4098    if (SWIG_IsNewObj(res3)) free((char*)arg3);
4099    return NULL;
4100  }
4101  static PyMethodDef SwigMethods[] = {
4102           { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
4103           { "WebPGetDecoderVersion", _wrap_WebPGetDecoderVersion, METH_VARARGS, (char *)"WebPGetDecoderVersion() -> int"},
4104           { "WebPGetInfo", _wrap_WebPGetInfo, METH_VARARGS, (char *)"WebPGetInfo(uint8_t data) -> (width, height)"},
4105           { "WebPDecodeRGB", _wrap_WebPDecodeRGB, METH_VARARGS, (char *)"WebPDecodeRGB(uint8_t data) -> (rgb, width, height)"},
4106           { "WebPDecodeRGBA", _wrap_WebPDecodeRGBA, METH_VARARGS, (char *)"WebPDecodeRGBA(uint8_t data) -> (rgb, width, height)"},
4107           { "WebPDecodeARGB", _wrap_WebPDecodeARGB, METH_VARARGS, (char *)"WebPDecodeARGB(uint8_t data) -> (rgb, width, height)"},
4108           { "WebPDecodeBGR", _wrap_WebPDecodeBGR, METH_VARARGS, (char *)"WebPDecodeBGR(uint8_t data) -> (rgb, width, height)"},
4109           { "WebPDecodeBGRA", _wrap_WebPDecodeBGRA, METH_VARARGS, (char *)"WebPDecodeBGRA(uint8_t data) -> (rgb, width, height)"},
4110           { "WebPGetEncoderVersion", _wrap_WebPGetEncoderVersion, METH_VARARGS, (char *)"WebPGetEncoderVersion() -> int"},
4111           { "wrap_WebPEncodeRGB", _wrap_wrap_WebPEncodeRGB, METH_VARARGS, (char *)"private, do not call directly."},
4112           { "wrap_WebPEncodeBGR", _wrap_wrap_WebPEncodeBGR, METH_VARARGS, (char *)"private, do not call directly."},
4113           { "wrap_WebPEncodeRGBA", _wrap_wrap_WebPEncodeRGBA, METH_VARARGS, (char *)"private, do not call directly."},
4114           { "wrap_WebPEncodeBGRA", _wrap_wrap_WebPEncodeBGRA, METH_VARARGS, (char *)"private, do not call directly."},
4115           { "wrap_WebPEncodeLosslessRGB", _wrap_wrap_WebPEncodeLosslessRGB, METH_VARARGS, (char *)"private, do not call directly."},
4116           { "wrap_WebPEncodeLosslessBGR", _wrap_wrap_WebPEncodeLosslessBGR, METH_VARARGS, (char *)"private, do not call directly."},
4117           { "wrap_WebPEncodeLosslessRGBA", _wrap_wrap_WebPEncodeLosslessRGBA, METH_VARARGS, (char *)"private, do not call directly."},
4118           { "wrap_WebPEncodeLosslessBGRA", _wrap_wrap_WebPEncodeLosslessBGRA, METH_VARARGS, (char *)"private, do not call directly."},
4119           { NULL, NULL, 0, NULL }
4120  };
4121  static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
4122  static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
4123  static swig_type_info _swigt__p_uint8_t = {"_p_uint8_t", "uint8_t *", 0, 0, (void*)0, 0};
4124  static swig_type_info *swig_type_initial[] = {
4125    &_swigt__p_char,
4126    &_swigt__p_int,
4127    &_swigt__p_uint8_t,
4128  };
4129  static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
4130  static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
4131  static swig_cast_info _swigc__p_uint8_t[] = {  {&_swigt__p_uint8_t, 0, 0, 0},{0, 0, 0, 0}};
4132  static swig_cast_info *swig_cast_initial[] = {
4133    _swigc__p_char,
4134    _swigc__p_int,
4135    _swigc__p_uint8_t,
4136  };
4137  static swig_const_info swig_const_table[] = {
4138  {0, 0, 0, 0.0, 0, 0}};
4139  #ifdef __cplusplus
4140  }
4141  #endif
4142  #ifdef __cplusplus
4143  extern "C" {
4144  #if 0
4145  } &bsol;* c-mode */
4146  #endif
4147  #endif
4148  #if 0
4149  #define SWIGRUNTIME_DEBUG
4150  #endif
4151  SWIGRUNTIME void
4152  SWIG_InitializeModule(void *clientdata) {
4153    size_t i;
4154    swig_module_info *module_head, *iter;
4155    int init;
4156    if (swig_module.next==0) {
4157      swig_module.type_initial = swig_type_initial;
4158      swig_module.cast_initial = swig_cast_initial;
4159      swig_module.next = &swig_module;
4160      init = 1;
4161    } else {
4162      init = 0;
4163    }
4164    module_head = SWIG_GetModule(clientdata);
4165    if (!module_head) {
4166      SWIG_SetModule(clientdata, &swig_module);
4167    } else {
4168      iter=module_head;
4169      do {
4170        if (iter==&swig_module) {
4171          return;
4172        }
4173        iter=iter->next;
4174      } while (iter!= module_head);
4175      swig_module.next = module_head->next;
4176      module_head->next = &swig_module;
4177    }
4178    if (init == 0) return;
4179  #ifdef SWIGRUNTIME_DEBUG
4180    printf("SWIG_InitializeModule: size %d\n", swig_module.size);
4181  #endif
4182    for (i = 0; i < swig_module.size; ++i) {
4183      swig_type_info *type = 0;
4184      swig_type_info *ret;
4185      swig_cast_info *cast;
4186  #ifdef SWIGRUNTIME_DEBUG
4187      printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
4188  #endif
4189      if (swig_module.next != &swig_module) {
4190        type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
4191      }
4192      if (type) {
4193  #ifdef SWIGRUNTIME_DEBUG
4194        printf("SWIG_InitializeModule: found type %s\n", type->name);
4195  #endif
4196        if (swig_module.type_initial[i]->clientdata) {
4197          type->clientdata = swig_module.type_initial[i]->clientdata;
4198  #ifdef SWIGRUNTIME_DEBUG
4199          printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
4200  #endif
4201        }
4202      } else {
4203        type = swig_module.type_initial[i];
4204      }
4205      cast = swig_module.cast_initial[i];
4206      while (cast->type) {
4207        ret = 0;
4208  #ifdef SWIGRUNTIME_DEBUG
4209        printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
4210  #endif
4211        if (swig_module.next != &swig_module) {
4212          ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
4213  #ifdef SWIGRUNTIME_DEBUG
4214          if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
4215  #endif
4216        }
4217        if (ret) {
4218          if (type == swig_module.type_initial[i]) {
4219  #ifdef SWIGRUNTIME_DEBUG
4220            printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
4221  #endif
4222            cast->type = ret;
4223            ret = 0;
4224          } else {
4225            swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
4226  #ifdef SWIGRUNTIME_DEBUG
4227            if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
4228  #endif
4229            if (!ocast) ret = 0;
4230          }
4231        }
4232        if (!ret) {
4233  #ifdef SWIGRUNTIME_DEBUG
4234          printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
4235  #endif
4236          if (type->cast) {
4237            type->cast->prev = cast;
4238            cast->next = type->cast;
4239          }
4240          type->cast = cast;
4241        }
4242        cast++;
4243      }
4244      swig_module.types[i] = type;
4245    }
4246    swig_module.types[i] = 0;
4247  #ifdef SWIGRUNTIME_DEBUG
4248    printf("**** SWIG_InitializeModule: Cast List ******\n");
4249    for (i = 0; i < swig_module.size; ++i) {
4250      int j = 0;
4251      swig_cast_info *cast = swig_module.cast_initial[i];
4252      printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
4253      while (cast->type) {
4254        printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
4255        cast++;
4256        ++j;
4257      }
4258      printf("---- Total casts: %d\n",j);
4259    }
4260    printf("**** SWIG_InitializeModule: Cast List ******\n");
4261  #endif
4262  }
4263  SWIGRUNTIME void
4264  SWIG_PropagateClientData(void) {
4265    size_t i;
4266    swig_cast_info *equiv;
4267    static int init_run = 0;
4268    if (init_run) return;
4269    init_run = 1;
4270    for (i = 0; i < swig_module.size; i++) {
4271      if (swig_module.types[i]->clientdata) {
4272        equiv = swig_module.types[i]->cast;
4273        while (equiv) {
4274          if (!equiv->converter) {
4275            if (equiv->type && !equiv->type->clientdata)
4276            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
4277          }
4278          equiv = equiv->next;
4279        }
4280      }
4281    }
4282  }
4283  #ifdef __cplusplus
4284  #if 0
4285  {
4286  #endif
4287  }
4288  #endif
4289  #ifdef __cplusplus
4290  extern "C" {
4291  #endif
4292  #define SWIG_newvarlink()                             SWIG_Python_newvarlink()
4293  #define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
4294  #define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
4295    typedef struct swig_globalvar {
4296      char       *name;                  &bsol;* Name of global variable */
4297      PyObject *(*get_attr)(void);       &bsol;* Return the current value */
4298      int       (*set_attr)(PyObject *); &bsol;* Set the value */
4299      struct swig_globalvar *next;
4300    } swig_globalvar;
4301    typedef struct swig_varlinkobject {
4302      PyObject_HEAD
4303      swig_globalvar *vars;
4304    } swig_varlinkobject;
4305    SWIGINTERN PyObject *
4306    swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
4307  #if PY_VERSION_HEX >= 0x03000000
4308      return PyUnicode_InternFromString("<Swig global variables>");
4309  #else
4310      return PyString_FromString("<Swig global variables>");
4311  #endif
4312    }
4313    SWIGINTERN PyObject *
4314    swig_varlink_str(swig_varlinkobject *v) {
4315  #if PY_VERSION_HEX >= 0x03000000
4316      PyObject *str = PyUnicode_InternFromString("(");
4317      PyObject *tail;
4318      PyObject *joined;
4319      swig_globalvar *var;
4320      for (var = v->vars; var; var=var->next) {
4321        tail = PyUnicode_FromString(var->name);
4322        joined = PyUnicode_Concat(str, tail);
4323        Py_DecRef(str);
4324        Py_DecRef(tail);
4325        str = joined;
4326        if (var->next) {
4327          tail = PyUnicode_InternFromString(", ");
4328          joined = PyUnicode_Concat(str, tail);
4329          Py_DecRef(str);
4330          Py_DecRef(tail);
4331          str = joined;
4332        }
4333      }
4334      tail = PyUnicode_InternFromString(")");
4335      joined = PyUnicode_Concat(str, tail);
4336      Py_DecRef(str);
4337      Py_DecRef(tail);
4338      str = joined;
4339  #else
4340      PyObject *str = PyString_FromString("(");
4341      swig_globalvar *var;
4342      for (var = v->vars; var; var=var->next) {
4343        PyString_ConcatAndDel(&str,PyString_FromString(var->name));
4344        if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
4345      }
4346      PyString_ConcatAndDel(&str,PyString_FromString(")"));
4347  #endif
4348      return str;
4349    }
4350    SWIGINTERN int
4351    swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
4352      char *tmp;
4353      PyObject *str = swig_varlink_str(v);
4354      fprintf(fp,"Swig global variables ");
4355      fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
4356      SWIG_Python_str_DelForPy3(tmp);
4357      Py_DECREF(str);
4358      return 0;
4359    }
4360    SWIGINTERN void
4361    swig_varlink_dealloc(swig_varlinkobject *v) {
4362      swig_globalvar *var = v->vars;
4363      while (var) {
4364        swig_globalvar *n = var->next;
4365        free(var->name);
4366        free(var);
4367        var = n;
4368      }
4369    }
4370    SWIGINTERN PyObject *
4371    swig_varlink_getattr(swig_varlinkobject *v, char *n) {
4372      PyObject *res = NULL;
4373      swig_globalvar *var = v->vars;
4374      while (var) {
4375        if (strcmp(var->name,n) == 0) {
4376          res = (*var->get_attr)();
4377          break;
4378        }
4379        var = var->next;
4380      }
4381      if (res == NULL && !PyErr_Occurred()) {
4382        PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
4383      }
4384      return res;
4385    }
4386    SWIGINTERN int
4387    swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
4388      int res = 1;
4389      swig_globalvar *var = v->vars;
4390      while (var) {
4391        if (strcmp(var->name,n) == 0) {
4392          res = (*var->set_attr)(p);
4393          break;
4394        }
4395        var = var->next;
4396      }
4397      if (res == 1 && !PyErr_Occurred()) {
4398        PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
4399      }
4400      return res;
4401    }
4402    SWIGINTERN PyTypeObject*
4403    swig_varlink_type(void) {
4404      static char varlink__doc__[] = "Swig var link object";
4405      static PyTypeObject varlink_type;
4406      static int type_init = 0;
4407      if (!type_init) {
4408        const PyTypeObject tmp = {
4409  #if PY_VERSION_HEX >= 0x03000000
4410          PyVarObject_HEAD_INIT(NULL, 0)
4411  #else
4412          PyObject_HEAD_INIT(NULL)
4413          0,                                  &bsol;* ob_size */
4414  #endif
4415          (char *)"swigvarlink",              &bsol;* tp_name */
4416          sizeof(swig_varlinkobject),         &bsol;* tp_basicsize */
4417          0,                                  &bsol;* tp_itemsize */
4418          (destructor) swig_varlink_dealloc,  &bsol;* tp_dealloc */
4419          (printfunc) swig_varlink_print,     &bsol;* tp_print */
4420          (getattrfunc) swig_varlink_getattr, &bsol;* tp_getattr */
4421          (setattrfunc) swig_varlink_setattr, &bsol;* tp_setattr */
4422          0,                                  &bsol;* tp_compare */
4423          (reprfunc) swig_varlink_repr,       &bsol;* tp_repr */
4424          0,                                  &bsol;* tp_as_number */
4425          0,                                  &bsol;* tp_as_sequence */
4426          0,                                  &bsol;* tp_as_mapping */
4427          0,                                  &bsol;* tp_hash */
4428          0,                                  &bsol;* tp_call */
4429          (reprfunc) swig_varlink_str,        &bsol;* tp_str */
4430          0,                                  &bsol;* tp_getattro */
4431          0,                                  &bsol;* tp_setattro */
4432          0,                                  &bsol;* tp_as_buffer */
4433          0,                                  &bsol;* tp_flags */
4434          varlink__doc__,                     &bsol;* tp_doc */
4435          0,                                  &bsol;* tp_traverse */
4436          0,                                  &bsol;* tp_clear */
4437          0,                                  &bsol;* tp_richcompare */
4438          0,                                  &bsol;* tp_weaklistoffset */
4439  #if PY_VERSION_HEX >= 0x02020000
4440          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, &bsol;* tp_iter -> tp_weaklist */
4441  #endif
4442  #if PY_VERSION_HEX >= 0x02030000
4443          0,                                  &bsol;* tp_del */
4444  #endif
4445  #if PY_VERSION_HEX >= 0x02060000
4446          0,                                  &bsol;* tp_version_tag */
4447  #endif
4448  #if PY_VERSION_HEX >= 0x03040000
4449          0,                                  &bsol;* tp_finalize */
4450  #endif
4451  #ifdef COUNT_ALLOCS
4452          0,                                  &bsol;* tp_allocs */
4453          0,                                  &bsol;* tp_frees */
4454          0,                                  &bsol;* tp_maxalloc */
4455  #if PY_VERSION_HEX >= 0x02050000
4456          0,                                  &bsol;* tp_prev */
4457  #endif
4458          0                                   &bsol;* tp_next */
4459  #endif
4460        };
4461        varlink_type = tmp;
4462        type_init = 1;
4463  #if PY_VERSION_HEX < 0x02020000
4464        varlink_type.ob_type = &PyType_Type;
4465  #else
4466        if (PyType_Ready(&varlink_type) < 0)
4467        return NULL;
4468  #endif
4469      }
4470      return &varlink_type;
4471    }
4472    SWIGINTERN PyObject *
4473    SWIG_Python_newvarlink(void) {
4474      swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
4475      if (result) {
4476        result->vars = 0;
4477      }
4478      return ((PyObject*) result);
4479    }
4480    SWIGINTERN void
4481    SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
4482      swig_varlinkobject *v = (swig_varlinkobject *) p;
4483      swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
4484      if (gv) {
4485        size_t size = strlen(name)+1;
4486        gv->name = (char *)malloc(size);
4487        if (gv->name) {
4488          strncpy(gv->name,name,size);
4489          gv->get_attr = get_attr;
4490          gv->set_attr = set_attr;
4491          gv->next = v->vars;
4492        }
4493      }
4494      v->vars = gv;
4495    }
4496    SWIGINTERN PyObject *
4497    SWIG_globals(void) {
4498      static PyObject *_SWIG_globals = 0;
4499      if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();
4500      return _SWIG_globals;
4501    }
4502    SWIGINTERN void
4503    SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
4504      PyObject *obj = 0;
4505      size_t i;
4506      for (i = 0; constants[i].type; ++i) {
4507        switch(constants[i].type) {
4508        case SWIG_PY_POINTER:
4509          obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
4510          break;
4511        case SWIG_PY_BINARY:
4512          obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
4513          break;
4514        default:
4515          obj = 0;
4516          break;
4517        }
4518        if (obj) {
4519          PyDict_SetItemString(d, constants[i].name, obj);
4520          Py_DECREF(obj);
4521        }
4522      }
4523    }
4524    SWIGINTERN void
4525    SWIG_Python_FixMethods(PyMethodDef *methods,
4526      swig_const_info *const_table,
4527      swig_type_info **types,
4528      swig_type_info **types_initial) {
4529      size_t i;
4530      for (i = 0; methods[i].ml_name; ++i) {
4531        const char *c = methods[i].ml_doc;
4532        if (!c) continue;
4533        c = strstr(c, "swig_ptr: ");
4534        if (c) {
4535          int j;
4536          swig_const_info *ci = 0;
4537          const char *name = c + 10;
4538          for (j = 0; const_table[j].type; ++j) {
4539            if (strncmp(const_table[j].name, name,
4540                strlen(const_table[j].name)) == 0) {
4541              ci = &(const_table[j]);
4542              break;
4543            }
4544          }
4545          if (ci) {
4546            void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
4547            if (ptr) {
4548              size_t shift = (ci->ptype) - types;
4549              swig_type_info *ty = types_initial[shift];
4550              size_t ldoc = (c - methods[i].ml_doc);
4551              size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
4552              char *ndoc = (char*)malloc(ldoc + lptr + 10);
4553              if (ndoc) {
4554                char *buff = ndoc;
4555                memcpy(buff, methods[i].ml_doc, ldoc);
4556                buff += ldoc;
4557                memcpy(buff, "swig_ptr: ", 10);
4558                buff += 10;
4559                SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
4560                methods[i].ml_doc = ndoc;
4561              }
4562            }
4563          }
4564        }
4565      }
4566    }
4567  #ifdef __cplusplus
4568  }
4569  #endif
4570  #ifdef __cplusplus
4571  extern "C"
4572  #endif
4573  SWIGEXPORT
4574  #if PY_VERSION_HEX >= 0x03000000
4575  PyObject*
4576  #else
4577  void
4578  #endif
4579  SWIG_init(void) {
4580    PyObject *m, *d, *md;
4581  #if PY_VERSION_HEX >= 0x03000000
4582    static struct PyModuleDef SWIG_module = {
4583  # if PY_VERSION_HEX >= 0x03020000
4584      PyModuleDef_HEAD_INIT,
4585  # else
4586      {
4587        PyObject_HEAD_INIT(NULL)
4588        NULL, &bsol;* m_init */
4589        0,    &bsol;* m_index */
4590        NULL, &bsol;* m_copy */
4591      },
4592  # endif
4593      (char *) SWIG_name,
4594      NULL,
4595      -1,
4596      SwigMethods,
4597      NULL,
4598      NULL,
4599      NULL,
4600      NULL
4601    };
4602  #endif
4603  #if defined(SWIGPYTHON_BUILTIN)
4604    static SwigPyClientData SwigPyObject_clientdata = {
4605      0, 0, 0, 0, 0, 0, 0
4606    };
4607    static PyGetSetDef this_getset_def = {
4608      (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
4609    };
4610    static SwigPyGetSet thisown_getset_closure = {
4611      SwigPyObject_own,
4612      SwigPyObject_own
4613    };
4614    static PyGetSetDef thisown_getset_def = {
4615      (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
4616    };
4617    PyTypeObject *builtin_pytype;
4618    int builtin_base_count;
4619    swig_type_info *builtin_basetype;
4620    PyObject *tuple;
4621    PyGetSetDescrObject *static_getset;
4622    PyTypeObject *metatype;
4623    PyTypeObject *swigpyobject;
4624    SwigPyClientData *cd;
4625    PyObject *public_interface, *public_symbol;
4626    PyObject *this_descr;
4627    PyObject *thisown_descr;
4628    PyObject *self = 0;
4629    int i;
4630    (void)builtin_pytype;
4631    (void)builtin_base_count;
4632    (void)builtin_basetype;
4633    (void)tuple;
4634    (void)static_getset;
4635    (void)self;
4636    metatype = SwigPyObjectType();
4637    assert(metatype);
4638  #endif
4639    SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
4640  #if PY_VERSION_HEX >= 0x03000000
4641    m = PyModule_Create(&SWIG_module);
4642  #else
4643    m = Py_InitModule((char *) SWIG_name, SwigMethods);
4644  #endif
4645    md = d = PyModule_GetDict(m);
4646    (void)md;
4647    SWIG_InitializeModule(0);
4648  #ifdef SWIGPYTHON_BUILTIN
4649    swigpyobject = SwigPyObject_TypeOnce();
4650    SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
4651    assert(SwigPyObject_stype);
4652    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
4653    if (!cd) {
4654      SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
4655      SwigPyObject_clientdata.pytype = swigpyobject;
4656    } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
4657      PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
4658  # if PY_VERSION_HEX >= 0x03000000
4659      return NULL;
4660  # else
4661      return;
4662  # endif
4663    }
4664    this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
4665    (void)this_descr;
4666    thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
4667    (void)thisown_descr;
4668    public_interface = PyList_New(0);
4669    public_symbol = 0;
4670    (void)public_symbol;
4671    PyDict_SetItemString(md, "__all__", public_interface);
4672    Py_DECREF(public_interface);
4673    for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
4674    SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
4675    for (i = 0; swig_const_table[i].name != 0; ++i)
4676    SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
4677  #endif
4678    SWIG_InstallConstants(d,swig_const_table);
4679  #if PY_VERSION_HEX >= 0x03000000
4680    return m;
4681  #else
4682    return;
4683  #endif
4684  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_dppi.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_python_wrap.c</div>
                </div>
                <div class="column column_space"><pre><code>122  }
123  NRF_STATIC_INLINE nrf_dppi_task_t nrf_dppi_group_enable_task_get(uint8_t index)
124  {
125      NRFX_ASSERT(index < DPPI_GROUP_NUM);
126      return (nrf_dppi_task_t)NRFX_OFFSETOF(NRF_DPPIC_Type, TASKS_CHG[index].EN);
127  }
128  NRF_STATIC_INLINE nrf_dppi_task_t nrf_dppi_group_disable_task_get(uint8_t index)
129  {
130      NRFX_ASSERT(index < DPPI_GROUP_NUM);
131      return (nrf_dppi_task_t)NRFX_OFFSETOF(NRF_DPPIC_Type, TASKS_CHG[index].DIS);
132  }
</pre></code></div>
                <div class="column column_space"><pre><code>1122  }
1123  SWIGRUNTIME PyObject *
1124  SwigPyObject_oct(SwigPyObject *v)
1125  {
1126    return SwigPyObject_format("%o",v);
1127  }
1128  SWIGRUNTIME PyObject *
1129  SwigPyObject_hex(SwigPyObject *v)
1130  {
1131    return SwigPyObject_format("%x",v);
1132  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    