
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.220088626292467%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/enc/backward_references_enc.h"
3  #include "src/enc/histogram_enc.h"
4  #include "src/dsp/lossless_common.h"
5  #include "src/utils/color_cache_utils.h"
6  #include "src/utils/utils.h"
7  #define VALUES_IN_BYTE 256
8  extern void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs);
9  extern int VP8LDistanceToPlaneCode(int xsize, int dist);
10  extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
11                                        const PixOrCopy v);
12  typedef struct {
13    double alpha_[VALUES_IN_BYTE];
14    double red_[VALUES_IN_BYTE];
15    double blue_[VALUES_IN_BYTE];
16    double distance_[NUM_DISTANCE_CODES];
17    double* literal_;
18  } CostModel;
19  static void ConvertPopulationCountTableToBitEstimates(
20      int num_symbols, const uint32_t population_counts[], double output[]) {
21    uint32_t sum = 0;
22    int nonzeros = 0;
23    int i;
24    for (i = 0; i < num_symbols; ++i) {
25      sum += population_counts[i];
26      if (population_counts[i] > 0) {
27        ++nonzeros;
28      }
29    }
30    if (nonzeros <= 1) {
31      memset(output, 0, num_symbols * sizeof(*output));
32    } else {
33      const double logsum = VP8LFastLog2(sum);
34      for (i = 0; i < num_symbols; ++i) {
35        output[i] = logsum - VP8LFastLog2(population_counts[i]);
36      }
37    }
38  }
39  static int CostModelBuild(CostModel* const m, int xsize, int cache_bits,
40                            const VP8LBackwardRefs* const refs) {
41    int ok = 0;
42    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
43    VP8LHistogram* const histo = VP8LAllocateHistogram(cache_bits);
44    if (histo == NULL) goto Error;
45    VP8LHistogramInit(histo, cache_bits, &bsol;*init_arrays=*/ 1);
46    while (VP8LRefsCursorOk(&c)) {
47      VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, VP8LDistanceToPlaneCode,
48                                      xsize);
49      VP8LRefsCursorNext(&c);
50    }
51    ConvertPopulationCountTableToBitEstimates(
52        VP8LHistogramNumCodes(histo->palette_code_bits_),
53        histo->literal_, m->literal_);
54    ConvertPopulationCountTableToBitEstimates(
55        VALUES_IN_BYTE, histo->red_, m->red_);
56    ConvertPopulationCountTableToBitEstimates(
57        VALUES_IN_BYTE, histo->blue_, m->blue_);
58    ConvertPopulationCountTableToBitEstimates(
59        VALUES_IN_BYTE, histo->alpha_, m->alpha_);
60    ConvertPopulationCountTableToBitEstimates(
61        NUM_DISTANCE_CODES, histo->distance_, m->distance_);
62    ok = 1;
63   Error:
64    VP8LFreeHistogram(histo);
65    return ok;
66  }
67  static WEBP_INLINE double GetLiteralCost(const CostModel* const m, uint32_t v) {
68    return m->alpha_[v >> 24] +
69           m->red_[(v >> 16) & 0xff] +
70           m->literal_[(v >> 8) & 0xff] +
71           m->blue_[v & 0xff];
72  }
73  static WEBP_INLINE double GetCacheCost(const CostModel* const m, uint32_t idx) {
74    const int literal_idx = VALUES_IN_BYTE + NUM_LENGTH_CODES + idx;
75    return m->literal_[literal_idx];
76  }
77  static WEBP_INLINE double GetLengthCost(const CostModel* const m,
78                                          uint32_t length) {
79    int code, extra_bits;
80    VP8LPrefixEncodeBits(length, &code, &extra_bits);
81    return m->literal_[VALUES_IN_BYTE + code] + extra_bits;
82  }
83  static WEBP_INLINE double GetDistanceCost(const CostModel* const m,
84                                            uint32_t distance) {
85    int code, extra_bits;
86    VP8LPrefixEncodeBits(distance, &code, &extra_bits);
87    return m->distance_[code] + extra_bits;
88  }
89  static WEBP_INLINE void AddSingleLiteralWithCostModel(
90      const uint32_t* const argb, VP8LColorCache* const hashers,
91      const CostModel* const cost_model, int idx, int use_color_cache,
92      float prev_cost, float* const cost, uint16_t* const dist_array) {
93    double cost_val = prev_cost;
94    const uint32_t color = argb[idx];
95    const int ix = use_color_cache ? VP8LColorCacheContains(hashers, color) : -1;
96    if (ix >= 0) {
97      const double mul0 = 0.68;
98      cost_val += GetCacheCost(cost_model, ix) * mul0;
99    } else {
100      const double mul1 = 0.82;
101      if (use_color_cache) VP8LColorCacheInsert(hashers, color);
102      cost_val += GetLiteralCost(cost_model, color) * mul1;
103    }
104    if (cost[idx] > cost_val) {
105      cost[idx] = (float)cost_val;
106      dist_array[idx] = 1;  
107    }
108  }
109  #define COST_CACHE_INTERVAL_SIZE_MAX 500
110  typedef struct CostInterval CostInterval;
111  struct CostInterval {
112    float cost_;
113    int start_;
114    int end_;
115    int index_;
116    CostInterval* previous_;
117    CostInterval* next_;
118  };
119  typedef struct {
120    double cost_;
121    int start_;
122    int end_;       
123  } CostCacheInterval;
124  #define COST_MANAGER_MAX_FREE_LIST 10
125  typedef struct {
126    CostInterval* head_;
127    int count_;  
128    CostCacheInterval* cache_intervals_;
129    size_t cache_intervals_size_;
130    double cost_cache_[MAX_LENGTH];  
131    float* costs_;
132    uint16_t* dist_array_;
133    CostInterval intervals_[COST_MANAGER_MAX_FREE_LIST];
134    CostInterval* free_intervals_;
135    CostInterval* recycled_intervals_;
136  } CostManager;
137  static void CostIntervalAddToFreeList(CostManager* const manager,
138                                        CostInterval* const interval) {
139    interval->next_ = manager->free_intervals_;
140    manager->free_intervals_ = interval;
141  }
142  static int CostIntervalIsInFreeList(const CostManager* const manager,
143                                      const CostInterval* const interval) {
144    return (interval >= &manager->intervals_[0] &&
145            interval <= &manager->intervals_[COST_MANAGER_MAX_FREE_LIST - 1]);
146  }
147  static void CostManagerInitFreeList(CostManager* const manager) {
148    int i;
149    manager->free_intervals_ = NULL;
150    for (i = 0; i < COST_MANAGER_MAX_FREE_LIST; ++i) {
151      CostIntervalAddToFreeList(manager, &manager->intervals_[i]);
152    }
153  }
154  static void DeleteIntervalList(CostManager* const manager,
155                                 const CostInterval* interval) {
156    while (interval != NULL) {
157      const CostInterval* const next = interval->next_;
158      if (!CostIntervalIsInFreeList(manager, interval)) {
159        WebPSafeFree((void*)interval);
160      }  
161      interval = next;
162    }
163  }
164  static void CostManagerClear(CostManager* const manager) {
165    if (manager == NULL) return;
166    WebPSafeFree(manager->costs_);
167    WebPSafeFree(manager->cache_intervals_);
168    DeleteIntervalList(manager, manager->head_);
169    manager->head_ = NULL;
170    DeleteIntervalList(manager, manager->recycled_intervals_);
171    manager->recycled_intervals_ = NULL;
172    memset(manager, 0, sizeof(*manager));
173    CostManagerInitFreeList(manager);
174  }
175  static int CostManagerInit(CostManager* const manager,
176                             uint16_t* const dist_array, int pix_count,
177                             const CostModel* const cost_model) {
178    int i;
179    const int cost_cache_size = (pix_count > MAX_LENGTH) ? MAX_LENGTH : pix_count;
180    manager->costs_ = NULL;
181    manager->cache_intervals_ = NULL;
182    manager->head_ = NULL;
183    manager->recycled_intervals_ = NULL;
184    manager->count_ = 0;
185    manager->dist_array_ = dist_array;
186    CostManagerInitFreeList(manager);
187    manager->cache_intervals_size_ = 1;
188    manager->cost_cache_[0] = GetLengthCost(cost_model, 0);
189    for (i = 1; i < cost_cache_size; ++i) {
190      manager->cost_cache_[i] = GetLengthCost(cost_model, i);
191      if (manager->cost_cache_[i] != manager->cost_cache_[i - 1]) {
192        ++manager->cache_intervals_size_;
193      }
194    }
195    assert(manager->cache_intervals_size_ <= MAX_LENGTH);
196    manager->cache_intervals_ = (CostCacheInterval*)WebPSafeMalloc(
197        manager->cache_intervals_size_, sizeof(*manager->cache_intervals_));
198    if (manager->cache_intervals_ == NULL) {
199      CostManagerClear(manager);
200      return 0;
201    }
202    {
203      CostCacheInterval* cur = manager->cache_intervals_;
204      cur->start_ = 0;
205      cur->end_ = 1;
206      cur->cost_ = manager->cost_cache_[0];
207      for (i = 1; i < cost_cache_size; ++i) {
208        const double cost_val = manager->cost_cache_[i];
209        if (cost_val != cur->cost_) {
210          ++cur;
211          cur->start_ = i;
212          cur->cost_ = cost_val;
213        }
214        cur->end_ = i + 1;
215      }
216    }
217    manager->costs_ = (float*)WebPSafeMalloc(pix_count, sizeof(*manager->costs_));
218    if (manager->costs_ == NULL) {
219      CostManagerClear(manager);
220      return 0;
221    }
222    for (i = 0; i < pix_count; ++i) manager->costs_[i] = 1e38f;
223    return 1;
224  }
225  static WEBP_INLINE void UpdateCost(CostManager* const manager, int i,
226                                     int position, float cost) {
227    const int k = i - position;
228    assert(k >= 0 && k < MAX_LENGTH);
229    if (manager->costs_[i] > cost) {
230      manager->costs_[i] = cost;
231      manager->dist_array_[i] = k + 1;
232    }
233  }
234  static WEBP_INLINE void UpdateCostPerInterval(CostManager* const manager,
235                                                int start, int end, int position,
236                                                float cost) {
237    int i;
238    for (i = start; i < end; ++i) UpdateCost(manager, i, position, cost);
239  }
240  static WEBP_INLINE void ConnectIntervals(CostManager* const manager,
241                                           CostInterval* const prev,
242                                           CostInterval* const next) {
243    if (prev != NULL) {
244      prev->next_ = next;
245    } else {
246      manager->head_ = next;
247    }
248    if (next != NULL) next->previous_ = prev;
249  }
250  static WEBP_INLINE void PopInterval(CostManager* const manager,
251                                      CostInterval* const interval) {
252    if (interval == NULL) return;
253    ConnectIntervals(manager, interval->previous_, interval->next_);
254    if (CostIntervalIsInFreeList(manager, interval)) {
255      CostIntervalAddToFreeList(manager, interval);
256    } else {  
257      interval->next_ = manager->recycled_intervals_;
258      manager->recycled_intervals_ = interval;
259    }
260    --manager->count_;
261    assert(manager->count_ >= 0);
262  }
263  static WEBP_INLINE void UpdateCostAtIndex(CostManager* const manager, int i,
264                                            int do_clean_intervals) {
265    CostInterval* current = manager->head_;
266    while (current != NULL && current->start_ <= i) {
267      CostInterval* const next = current->next_;
268      if (current->end_ <= i) {
269        if (do_clean_intervals) {
270          PopInterval(manager, current);
271        }
272      } else {
273        UpdateCost(manager, i, current->index_, current->cost_);
274      }
275      current = next;
276    }
277  }
278  static WEBP_INLINE void PositionOrphanInterval(CostManager* const manager,
279                                                 CostInterval* const current,
280                                                 CostInterval* previous) {
281    assert(current != NULL);
282    if (previous == NULL) previous = manager->head_;
283    while (previous != NULL && current->start_ < previous->start_) {
284      previous = previous->previous_;
285    }
286    while (previous != NULL && previous->next_ != NULL &&
287           previous->next_->start_ < current->start_) {
288      previous = previous->next_;
289    }
290    if (previous != NULL) {
291      ConnectIntervals(manager, current, previous->next_);
292    } else {
293      ConnectIntervals(manager, current, manager->head_);
294    }
<span onclick='openModal()' class='match'>295    ConnectIntervals(manager, previous, current);
296  }
297  static WEBP_INLINE void InsertInterval(CostManager* const manager,
298                                         CostInterval* const interval_in,
299                                         float cost, int position, int start,
</span>300                                         int end) {
301    CostInterval* interval_new;
302    if (start >= end) return;
303    if (manager->count_ >= COST_CACHE_INTERVAL_SIZE_MAX) {
304      UpdateCostPerInterval(manager, start, end, position, cost);
305      return;
306    }
307    if (manager->free_intervals_ != NULL) {
308      interval_new = manager->free_intervals_;
309      manager->free_intervals_ = interval_new->next_;
310    } else if (manager->recycled_intervals_ != NULL) {
311      interval_new = manager->recycled_intervals_;
312      manager->recycled_intervals_ = interval_new->next_;
313    } else {  
314      interval_new = (CostInterval*)WebPSafeMalloc(1, sizeof(*interval_new));
315      if (interval_new == NULL) {
316        UpdateCostPerInterval(manager, start, end, position, cost);
317        return;
318      }
319    }
320    interval_new->cost_ = cost;
321    interval_new->index_ = position;
322    interval_new->start_ = start;
323    interval_new->end_ = end;
324    PositionOrphanInterval(manager, interval_new, interval_in);
325    ++manager->count_;
326  }
327  static WEBP_INLINE void PushInterval(CostManager* const manager,
328                                       double distance_cost, int position,
329                                       int len) {
330    size_t i;
331    CostInterval* interval = manager->head_;
332    CostInterval* interval_next;
333    const CostCacheInterval* const cost_cache_intervals =
334        manager->cache_intervals_;
335    const int kSkipDistance = 10;
336    if (len < kSkipDistance) {
337      int j;
338      for (j = position; j < position + len; ++j) {
339        const int k = j - position;
340        float cost_tmp;
341        assert(k >= 0 && k < MAX_LENGTH);
342        cost_tmp = (float)(distance_cost + manager->cost_cache_[k]);
343        if (manager->costs_[j] > cost_tmp) {
344          manager->costs_[j] = cost_tmp;
345          manager->dist_array_[j] = k + 1;
346        }
347      }
348      return;
349    }
350    for (i = 0; i < manager->cache_intervals_size_ &&
351                cost_cache_intervals[i].start_ < len;
352         ++i) {
353      int start = position + cost_cache_intervals[i].start_;
354      const int end = position + (cost_cache_intervals[i].end_ > len
355                                   ? len
356                                   : cost_cache_intervals[i].end_);
357      const float cost = (float)(distance_cost + cost_cache_intervals[i].cost_);
358      for (; interval != NULL && interval->start_ < end;
359           interval = interval_next) {
360        interval_next = interval->next_;
361        if (start >= interval->end_) continue;
362        if (cost >= interval->cost_) {
363          const int start_new = interval->end_;
364          InsertInterval(manager, interval, cost, position, start,
365                         interval->start_);
366          start = start_new;
367          if (start >= end) break;
368          continue;
369        }
370        if (start <= interval->start_) {
371          if (interval->end_ <= end) {
372            PopInterval(manager, interval);
373          } else {
374            interval->start_ = end;
375            break;
376          }
377        } else {
378          if (end < interval->end_) {
379            const int end_original = interval->end_;
380            interval->end_ = start;
381            InsertInterval(manager, interval, interval->cost_, interval->index_,
382                           end, end_original);
383            interval = interval->next_;
384            break;
385          } else {
386            interval->end_ = start;
387          }
388        }
389      }
390      InsertInterval(manager, interval, cost, position, start, end);
391    }
392  }
393  static int BackwardReferencesHashChainDistanceOnly(
394      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
395      const VP8LHashChain* const hash_chain, const VP8LBackwardRefs* const refs,
396      uint16_t* const dist_array) {
397    int i;
398    int ok = 0;
399    int cc_init = 0;
400    const int pix_count = xsize * ysize;
401    const int use_color_cache = (cache_bits > 0);
402    const size_t literal_array_size =
403        sizeof(double) * (NUM_LITERAL_CODES + NUM_LENGTH_CODES +
404                          ((cache_bits > 0) ? (1 << cache_bits) : 0));
405    const size_t cost_model_size = sizeof(CostModel) + literal_array_size;
406    CostModel* const cost_model =
407        (CostModel*)WebPSafeCalloc(1ULL, cost_model_size);
408    VP8LColorCache hashers;
409    CostManager* cost_manager =
410        (CostManager*)WebPSafeMalloc(1ULL, sizeof(*cost_manager));
411    int offset_prev = -1, len_prev = -1;
412    double offset_cost = -1;
413    int first_offset_is_constant = -1;  
414    int reach = 0;
415    if (cost_model == NULL || cost_manager == NULL) goto Error;
416    cost_model->literal_ = (double*)(cost_model + 1);
417    if (use_color_cache) {
418      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
419      if (!cc_init) goto Error;
420    }
421    if (!CostModelBuild(cost_model, xsize, cache_bits, refs)) {
422      goto Error;
423    }
424    if (!CostManagerInit(cost_manager, dist_array, pix_count, cost_model)) {
425      goto Error;
426    }
427    dist_array[0] = 0;
428    AddSingleLiteralWithCostModel(argb, &hashers, cost_model, 0, use_color_cache,
429                                  0.f, cost_manager->costs_, dist_array);
430    for (i = 1; i < pix_count; ++i) {
431      const float prev_cost = cost_manager->costs_[i - 1];
432      int offset, len;
433      VP8LHashChainFindCopy(hash_chain, i, &offset, &len);
434      AddSingleLiteralWithCostModel(argb, &hashers, cost_model, i,
435                                    use_color_cache, prev_cost,
436                                    cost_manager->costs_, dist_array);
437      if (len >= 2) {
438        if (offset != offset_prev) {
439          const int code = VP8LDistanceToPlaneCode(xsize, offset);
440          offset_cost = GetDistanceCost(cost_model, code);
441          first_offset_is_constant = 1;
442          PushInterval(cost_manager, prev_cost + offset_cost, i, len);
443        } else {
444          assert(offset_cost >= 0);
445          assert(len_prev >= 0);
446          assert(first_offset_is_constant == 0 || first_offset_is_constant == 1);
447          if (first_offset_is_constant) {
448            reach = i - 1 + len_prev - 1;
449            first_offset_is_constant = 0;
450          }
451          if (i + len - 1 > reach) {
452            int offset_j, len_j = 0;
453            int j;
454            assert(len == MAX_LENGTH || len == pix_count - i);
455            for (j = i; j <= reach; ++j) {
456              VP8LHashChainFindCopy(hash_chain, j + 1, &offset_j, &len_j);
457              if (offset_j != offset) {
458                VP8LHashChainFindCopy(hash_chain, j, &offset_j, &len_j);
459                break;
460              }
461            }
462            UpdateCostAtIndex(cost_manager, j - 1, 0);
463            UpdateCostAtIndex(cost_manager, j, 0);
464            PushInterval(cost_manager, cost_manager->costs_[j - 1] + offset_cost,
465                         j, len_j);
466            reach = j + len_j - 1;
467          }
468        }
469      }
470      UpdateCostAtIndex(cost_manager, i, 1);
471      offset_prev = offset;
472      len_prev = len;
473    }
474    ok = !refs->error_;
475  Error:
476    if (cc_init) VP8LColorCacheClear(&hashers);
477    CostManagerClear(cost_manager);
478    WebPSafeFree(cost_model);
479    WebPSafeFree(cost_manager);
480    return ok;
481  }
482  static void TraceBackwards(uint16_t* const dist_array,
483                             int dist_array_size,
484                             uint16_t** const chosen_path,
485                             int* const chosen_path_size) {
486    uint16_t* path = dist_array + dist_array_size;
487    uint16_t* cur = dist_array + dist_array_size - 1;
488    while (cur >= dist_array) {
489      const int k = *cur;
490      --path;
491      *path = k;
492      cur -= k;
493    }
494    *chosen_path = path;
495    *chosen_path_size = (int)(dist_array + dist_array_size - path);
496  }
497  static int BackwardReferencesHashChainFollowChosenPath(
498      const uint32_t* const argb, int cache_bits,
499      const uint16_t* const chosen_path, int chosen_path_size,
500      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs) {
501    const int use_color_cache = (cache_bits > 0);
502    int ix;
503    int i = 0;
504    int ok = 0;
505    int cc_init = 0;
506    VP8LColorCache hashers;
507    if (use_color_cache) {
508      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
509      if (!cc_init) goto Error;
510    }
511    VP8LClearBackwardRefs(refs);
512    for (ix = 0; ix < chosen_path_size; ++ix) {
513      const int len = chosen_path[ix];
514      if (len != 1) {
515        int k;
516        const int offset = VP8LHashChainFindOffset(hash_chain, i);
517        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(offset, len));
518        if (use_color_cache) {
519          for (k = 0; k < len; ++k) {
520            VP8LColorCacheInsert(&hashers, argb[i + k]);
521          }
522        }
523        i += len;
524      } else {
525        PixOrCopy v;
526        const int idx =
527            use_color_cache ? VP8LColorCacheContains(&hashers, argb[i]) : -1;
528        if (idx >= 0) {
529          v = PixOrCopyCreateCacheIdx(idx);
530        } else {
531          if (use_color_cache) VP8LColorCacheInsert(&hashers, argb[i]);
532          v = PixOrCopyCreateLiteral(argb[i]);
533        }
534        VP8LBackwardRefsCursorAdd(refs, v);
535        ++i;
536      }
537    }
538    ok = !refs->error_;
539   Error:
540    if (cc_init) VP8LColorCacheClear(&hashers);
541    return ok;
542  }
543  extern int VP8LBackwardReferencesTraceBackwards(
544      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
545      const VP8LHashChain* const hash_chain,
546      const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
547  int VP8LBackwardReferencesTraceBackwards(int xsize, int ysize,
548                                           const uint32_t* const argb,
549                                           int cache_bits,
550                                           const VP8LHashChain* const hash_chain,
551                                           const VP8LBackwardRefs* const refs_src,
552                                           VP8LBackwardRefs* const refs_dst) {
553    int ok = 0;
554    const int dist_array_size = xsize * ysize;
555    uint16_t* chosen_path = NULL;
556    int chosen_path_size = 0;
557    uint16_t* dist_array =
558        (uint16_t*)WebPSafeMalloc(dist_array_size, sizeof(*dist_array));
559    if (dist_array == NULL) goto Error;
560    if (!BackwardReferencesHashChainDistanceOnly(
561            xsize, ysize, argb, cache_bits, hash_chain, refs_src, dist_array)) {
562      goto Error;
563    }
564    TraceBackwards(dist_array, dist_array_size, &chosen_path, &chosen_path_size);
565    if (!BackwardReferencesHashChainFollowChosenPath(
566            argb, cache_bits, chosen_path, chosen_path_size, hash_chain,
567            refs_dst)) {
568      goto Error;
569    }
570    ok = 1;
571   Error:
572    WebPSafeFree(dist_array);
573    return ok;
574  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_zset.c</h3>
            <pre><code>1  #include "server.h"
2  #include <math.h>
3  #ifdef _WIN32
4  #define bzero(b,len) (memset((b), '\0', (len)), (void) 0)
5  #endif
6  int zslLexValueGteMin(sds value, zlexrangespec *spec);
7  int zslLexValueLteMax(sds value, zlexrangespec *spec);
8  zskiplistNode *zslCreateNode(int level, double score, sds ele) {
9      zskiplistNode *zn =
10          zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
11      zn->score = score;
12      zn->ele = ele;
13      return zn;
14  }
15  zskiplist *zslCreate(void) {
16      int j;
17      zskiplist *zsl;
18      zsl = zmalloc(sizeof(*zsl));
19      zsl->level = 1;
20      zsl->length = 0;
21      zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
22      for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {
23          zsl->header->level[j].forward = NULL;
24          zsl->header->level[j].span = 0;
25      }
26      zsl->header->backward = NULL;
27      zsl->tail = NULL;
28      return zsl;
29  }
30  void zslFreeNode(zskiplistNode *node) {
31      sdsfree(node->ele);
32      zfree(node);
33  }
34  void zslFree(zskiplist *zsl) {
35      zskiplistNode *node = zsl->header->level[0].forward, *next;
36      zfree(zsl->header);
37      while(node) {
38          next = node->level[0].forward;
39          zslFreeNode(node);
40          node = next;
41      }
42      zfree(zsl);
43  }
44  int zslRandomLevel(void) {
45      int level = 1;
46      while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
47          level += 1;
48      return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
49  }
50  zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
51      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
52      unsigned int rank[ZSKIPLIST_MAXLEVEL];
53      int i, level;
54      serverAssert(!isnan(score));
55      x = zsl->header;
56      for (i = zsl->level-1; i >= 0; i--) {
57          rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
58          while (x->level[i].forward &&
59                  (x->level[i].forward->score < score ||
60                      (x->level[i].forward->score == score &&
61                      sdscmp(x->level[i].forward->ele,ele) < 0)))
62          {
63              rank[i] += x->level[i].span;
64              x = x->level[i].forward;
65          }
66          update[i] = x;
67      }
68      level = zslRandomLevel();
69      if (level > zsl->level) {
70          for (i = zsl->level; i < level; i++) {
71              rank[i] = 0;
72              update[i] = zsl->header;
73              update[i]->level[i].span = zsl->length;
74          }
75          zsl->level = level;
76      }
77      x = zslCreateNode(level,score,ele);
78      for (i = 0; i < level; i++) {
79          x->level[i].forward = update[i]->level[i].forward;
80          update[i]->level[i].forward = x;
81          x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
82          update[i]->level[i].span = (rank[0] - rank[i]) + 1;
83      }
84      for (i = level; i < zsl->level; i++) {
85          update[i]->level[i].span++;
86      }
87      x->backward = (update[0] == zsl->header) ? NULL : update[0];
88      if (x->level[0].forward)
89          x->level[0].forward->backward = x;
90      else
91          zsl->tail = x;
92      zsl->length++;
93      return x;
94  }
95  void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
96      int i;
97      for (i = 0; i < zsl->level; i++) {
98          if (update[i]->level[i].forward == x) {
99              update[i]->level[i].span += x->level[i].span - 1;
100              update[i]->level[i].forward = x->level[i].forward;
101          } else {
102              update[i]->level[i].span -= 1;
103          }
104      }
105      if (x->level[0].forward) {
106          x->level[0].forward->backward = x->backward;
107      } else {
108          zsl->tail = x->backward;
109      }
110      while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
111          zsl->level--;
112      zsl->length--;
113  }
114  int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
115      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
116      int i;
117      x = zsl->header;
118      for (i = zsl->level-1; i >= 0; i--) {
119          while (x->level[i].forward &&
120                  (x->level[i].forward->score < score ||
121                      (x->level[i].forward->score == score &&
122                       sdscmp(x->level[i].forward->ele,ele) < 0)))
123          {
124              x = x->level[i].forward;
125          }
126          update[i] = x;
127      }
128      x = x->level[0].forward;
129      if (x && score == x->score && sdscmp(x->ele,ele) == 0) {
130          zslDeleteNode(zsl, x, update);
131          if (!node)
132              zslFreeNode(x);
133          else
134              *node = x;
135          return 1;
136      }
137      return 0; &bsol;* not found */
138  }
139  zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {
140      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
141      int i;
142      x = zsl->header;
143      for (i = zsl->level-1; i >= 0; i--) {
144          while (x->level[i].forward &&
145                  (x->level[i].forward->score < curscore ||
146                      (x->level[i].forward->score == curscore &&
147                       sdscmp(x->level[i].forward->ele,ele) < 0)))
148          {
149              x = x->level[i].forward;
150          }
151          update[i] = x;
152      }
153      x = x->level[0].forward;
154      serverAssert(x && curscore == x->score && sdscmp(x->ele,ele) == 0);
155      if ((x->backward == NULL || x->backward->score < newscore) &&
156          (x->level[0].forward == NULL || x->level[0].forward->score > newscore))
157      {
158          x->score = newscore;
159          return x;
160      }
161      zslDeleteNode(zsl, x, update);
162      zskiplistNode *newnode = zslInsert(zsl,newscore,x->ele);
163      x->ele = NULL;
164      zslFreeNode(x);
165      return newnode;
166  }
167  int zslValueGteMin(double value, zrangespec *spec) {
168      return spec->minex ? (value > spec->min) : (value >= spec->min);
169  }
170  int zslValueLteMax(double value, zrangespec *spec) {
171      return spec->maxex ? (value < spec->max) : (value <= spec->max);
172  }
173  int zslIsInRange(zskiplist *zsl, zrangespec *range) {
174      zskiplistNode *x;
175      if (range->min > range->max ||
176              (range->min == range->max && (range->minex || range->maxex)))
177          return 0;
178      x = zsl->tail;
179      if (x == NULL || !zslValueGteMin(x->score,range))
180          return 0;
181      x = zsl->header->level[0].forward;
182      if (x == NULL || !zslValueLteMax(x->score,range))
183          return 0;
184      return 1;
185  }
186  zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
187      zskiplistNode *x;
188      int i;
189      if (!zslIsInRange(zsl,range)) return NULL;
190      x = zsl->header;
191      for (i = zsl->level-1; i >= 0; i--) {
192          while (x->level[i].forward &&
193              !zslValueGteMin(x->level[i].forward->score,range))
194                  x = x->level[i].forward;
195      }
196      x = x->level[0].forward;
197      serverAssert(x != NULL);
198      if (!zslValueLteMax(x->score,range)) return NULL;
199      return x;
200  }
201  zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
202      zskiplistNode *x;
203      int i;
204      if (!zslIsInRange(zsl,range)) return NULL;
205      x = zsl->header;
206      for (i = zsl->level-1; i >= 0; i--) {
207          while (x->level[i].forward &&
208              zslValueLteMax(x->level[i].forward->score,range))
209                  x = x->level[i].forward;
210      }
211      serverAssert(x != NULL);
212      if (!zslValueGteMin(x->score,range)) return NULL;
213      return x;
214  }
215  PORT_ULONG zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
216      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
217      PORT_ULONG removed = 0;
218      int i;
219      x = zsl->header;
220      for (i = zsl->level-1; i >= 0; i--) {
221          while (x->level[i].forward && (range->minex ?
222              x->level[i].forward->score <= range->min :
223              x->level[i].forward->score < range->min))
224                  x = x->level[i].forward;
225          update[i] = x;
226      }
227      x = x->level[0].forward;
228      while (x &&
229             (range->maxex ? x->score < range->max : x->score <= range->max))
230      {
231          zskiplistNode *next = x->level[0].forward;
232          zslDeleteNode(zsl,x,update);
233          dictDelete(dict,x->ele);
234          zslFreeNode(x); &bsol;* Here is where x->ele is actually released. */
235          removed++;
236          x = next;
237      }
238      return removed;
239  }
240  PORT_ULONG zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {
241      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
242      PORT_ULONG removed = 0;
243      int i;
244      x = zsl->header;
245      for (i = zsl->level-1; i >= 0; i--) {
246          while (x->level[i].forward &&
247              !zslLexValueGteMin(x->level[i].forward->ele,range))
248                  x = x->level[i].forward;
249          update[i] = x;
250      }
251      x = x->level[0].forward;
252      while (x && zslLexValueLteMax(x->ele,range)) {
253          zskiplistNode *next = x->level[0].forward;
254          zslDeleteNode(zsl,x,update);
255          dictDelete(dict,x->ele);
256          zslFreeNode(x); &bsol;* Here is where x->ele is actually released. */
257          removed++;
258          x = next;
259      }
260      return removed;
261  }
262  PORT_ULONG zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
263      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
264      PORT_ULONG traversed = 0, removed = 0;
265      int i;
266      x = zsl->header;
267      for (i = zsl->level-1; i >= 0; i--) {
268          while (x->level[i].forward && (traversed + x->level[i].span) < start) {
269              traversed += x->level[i].span;
270              x = x->level[i].forward;
271          }
272          update[i] = x;
273      }
274      traversed++;
275      x = x->level[0].forward;
276      while (x && traversed <= end) {
277          zskiplistNode *next = x->level[0].forward;
278          zslDeleteNode(zsl,x,update);
279          dictDelete(dict,x->ele);
280          zslFreeNode(x);
281          removed++;
282          traversed++;
283          x = next;
284      }
285      return removed;
286  }
287  PORT_ULONG zslGetRank(zskiplist *zsl, double score, sds ele) {
288      zskiplistNode *x;
289      PORT_ULONG rank = 0;
290      int i;
291      x = zsl->header;
292      for (i = zsl->level-1; i >= 0; i--) {
293          while (x->level[i].forward &&
294              (x->level[i].forward->score < score ||
295                  (x->level[i].forward->score == score &&
296                  sdscmp(x->level[i].forward->ele,ele) <= 0))) {
297              rank += x->level[i].span;
298              x = x->level[i].forward;
299          }
300          if (x->ele && sdscmp(x->ele,ele) == 0) {
301              return rank;
302          }
303      }
304      return 0;
305  }
306  zskiplistNode* zslGetElementByRank(zskiplist *zsl, PORT_ULONG rank) {
307      zskiplistNode *x;
308      PORT_ULONG traversed = 0;
309      int i;
310      x = zsl->header;
311      for (i = zsl->level-1; i >= 0; i--) {
312          while (x->level[i].forward && (traversed + x->level[i].span) <= rank)
313          {
314              traversed += x->level[i].span;
315              x = x->level[i].forward;
316          }
317          if (traversed == rank) {
318              return x;
319          }
320      }
321      return NULL;
322  }
323  static int zslParseRange(robj *min, robj *max, zrangespec *spec) {
324      char *eptr;
325      spec->minex = spec->maxex = 0;
326      if (min->encoding == OBJ_ENCODING_INT) {
327          spec->min = (PORT_LONG)min->ptr;
328      } else {
329          if (((char*)min->ptr)[0] == '(') {
330              spec->min = strtod((char*)min->ptr+1,&eptr);
331              if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
332              spec->minex = 1;
333          } else {
334              spec->min = strtod((char*)min->ptr,&eptr);
335              if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
336          }
337      }
338      if (max->encoding == OBJ_ENCODING_INT) {
339          spec->max = (PORT_LONG)max->ptr;
340      } else {
341          if (((char*)max->ptr)[0] == '(') {
342              spec->max = strtod((char*)max->ptr+1,&eptr);
343              if (eptr[0] != '\0' || isnan(spec->max)) return C_ERR;
344              spec->maxex = 1;
345          } else {
346              spec->max = strtod((char*)max->ptr,&eptr);
347              if (eptr[0] != '\0' || isnan(spec->max)) return C_ERR;
348          }
349      }
350      return C_OK;
351  }
352  int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
353      char *c = item->ptr;
354      switch(c[0]) {
355      case '+':
356          if (c[1] != '\0') return C_ERR;
357          *ex = 1;
358          *dest = shared.maxstring;
359          return C_OK;
360      case '-':
361          if (c[1] != '\0') return C_ERR;
362          *ex = 1;
363          *dest = shared.minstring;
364          return C_OK;
365      case '(':
366          *ex = 1;
367          *dest = sdsnewlen(c+1,sdslen(c)-1);
368          return C_OK;
369      case '[':
370          *ex = 0;
371          *dest = sdsnewlen(c+1,sdslen(c)-1);
372          return C_OK;
373      default:
374          return C_ERR;
375      }
376  }
377  void zslFreeLexRange(zlexrangespec *spec) {
378      if (spec->min != shared.minstring &&
379          spec->min != shared.maxstring) sdsfree(spec->min);
380      if (spec->max != shared.minstring &&
381          spec->max != shared.maxstring) sdsfree(spec->max);
382  }
383  int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
384      if (min->encoding == OBJ_ENCODING_INT ||
385          max->encoding == OBJ_ENCODING_INT) return C_ERR;
386      spec->min = spec->max = NULL;
387      if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||
388          zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {
389          zslFreeLexRange(spec);
390          return C_ERR;
391      } else {
392          return C_OK;
393      }
394  }
395  int sdscmplex(sds a, sds b) {
396      if (a == b) return 0;
397      if (a == shared.minstring || b == shared.maxstring) return -1;
398      if (a == shared.maxstring || b == shared.minstring) return 1;
399      return sdscmp(a,b);
400  }
401  int zslLexValueGteMin(sds value, zlexrangespec *spec) {
402      return spec->minex ?
403          (sdscmplex(value,spec->min) > 0) :
404          (sdscmplex(value,spec->min) >= 0);
405  }
406  int zslLexValueLteMax(sds value, zlexrangespec *spec) {
407      return spec->maxex ?
408          (sdscmplex(value,spec->max) < 0) :
409          (sdscmplex(value,spec->max) <= 0);
410  }
411  int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
412      zskiplistNode *x;
413      int cmp = sdscmplex(range->min,range->max);
414      if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
415          return 0;
416      x = zsl->tail;
417      if (x == NULL || !zslLexValueGteMin(x->ele,range))
418          return 0;
419      x = zsl->header->level[0].forward;
420      if (x == NULL || !zslLexValueLteMax(x->ele,range))
421          return 0;
422      return 1;
423  }
424  zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
425      zskiplistNode *x;
426      int i;
427      if (!zslIsInLexRange(zsl,range)) return NULL;
428      x = zsl->header;
429      for (i = zsl->level-1; i >= 0; i--) {
430          while (x->level[i].forward &&
431              !zslLexValueGteMin(x->level[i].forward->ele,range))
432                  x = x->level[i].forward;
433      }
434      x = x->level[0].forward;
435      serverAssert(x != NULL);
436      if (!zslLexValueLteMax(x->ele,range)) return NULL;
437      return x;
438  }
439  zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
440      zskiplistNode *x;
441      int i;
442      if (!zslIsInLexRange(zsl,range)) return NULL;
443      x = zsl->header;
444      for (i = zsl->level-1; i >= 0; i--) {
445          while (x->level[i].forward &&
446              zslLexValueLteMax(x->level[i].forward->ele,range))
447                  x = x->level[i].forward;
448      }
449      serverAssert(x != NULL);
450      if (!zslLexValueGteMin(x->ele,range)) return NULL;
451      return x;
452  }
453  double zzlGetScore(unsigned char *sptr) {
454      unsigned char *vstr;
455      unsigned int vlen;
456      PORT_LONGLONG vlong;
457      char buf[128];
458      double score;
459      serverAssert(sptr != NULL);
460      serverAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
461      if (vstr) {
462          memcpy(buf,vstr,vlen);
463          buf[vlen] = '\0';
464          score = strtod(buf,NULL);
465      } else {
466          score = (double)vlong;                                                  WIN_PORT_FIX &bsol;* cast (double) */
467      }
468      return score;
469  }
470  sds ziplistGetObject(unsigned char *sptr) {
471      unsigned char *vstr;
472      unsigned int vlen;
473      PORT_LONGLONG vlong;
474      serverAssert(sptr != NULL);
475      serverAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
476      if (vstr) {
477          return sdsnewlen((char*)vstr,vlen);
478      } else {
479          return sdsfromlonglong(vlong);
480      }
481  }
482  int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
483      unsigned char *vstr;
484      unsigned int vlen;
485      PORT_LONGLONG vlong;
486      unsigned char vbuf[32];
487      int minlen, cmp;
488      serverAssert(ziplistGet(eptr,&vstr,&vlen,&vlong));
489      if (vstr == NULL) {
490          vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);
491          vstr = vbuf;
492      }
493      minlen = (vlen < clen) ? vlen : clen;
494      cmp = memcmp(vstr,cstr,minlen);
495      if (cmp == 0) return vlen-clen;
496      return cmp;
497  }
498  unsigned int zzlLength(unsigned char *zl) {
499      return ziplistLen(zl)/2;
500  }
501  void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
502      unsigned char *l_eptr, *l_sptr;                                             WIN_PORT_FIX &bsol;* compiler error: _sptr -> l_sptr */
503      serverAssert(*eptr != NULL && *sptr != NULL);
504      l_eptr = ziplistNext(zl, *sptr);
505      if (l_eptr != NULL) {
506          l_sptr = ziplistNext(zl, l_eptr);
507          serverAssert(l_sptr != NULL);
508      } else {
509          l_sptr = NULL;
510      }
511      *eptr = l_eptr;
512      *sptr = l_sptr;
513  }
514  void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
515      unsigned char *l_eptr, *l_sptr;                                             WIN_PORT_FIX &bsol;* compiler error: _sptr -> l_sptr */
516      serverAssert(*eptr != NULL && *sptr != NULL);
517      l_sptr = ziplistPrev(zl, *eptr);
518      if (l_sptr != NULL) {
519          l_eptr = ziplistPrev(zl, l_sptr);
520          serverAssert(l_eptr != NULL);
521      } else {
522          l_eptr = NULL;
523      }
524      *eptr = l_eptr;
525      *sptr = l_sptr;
526  }
527  int zzlIsInRange(unsigned char *zl, zrangespec *range) {
528      unsigned char *p;
529      double score;
530      if (range->min > range->max ||
531              (range->min == range->max && (range->minex || range->maxex)))
532          return 0;
533      p = ziplistIndex(zl,-1); &bsol;* Last score. */
534      if (p == NULL) return 0; &bsol;* Empty sorted set */
535      score = zzlGetScore(p);
536      if (!zslValueGteMin(score,range))
537          return 0;
538      p = ziplistIndex(zl,1); &bsol;* First score. */
539      serverAssert(p != NULL);
540      score = zzlGetScore(p);
541      if (!zslValueLteMax(score,range))
542          return 0;
543      return 1;
544  }
545  unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
546      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
547      double score;
548      if (!zzlIsInRange(zl,range)) return NULL;
549      while (eptr != NULL) {
550          sptr = ziplistNext(zl,eptr);
551          serverAssert(sptr != NULL);
552          score = zzlGetScore(sptr);
553          if (zslValueGteMin(score,range)) {
554              if (zslValueLteMax(score,range))
555                  return eptr;
556              return NULL;
557          }
558          eptr = ziplistNext(zl,sptr);
559      }
560      return NULL;
561  }
562  unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
563      unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
564      double score;
565      if (!zzlIsInRange(zl,range)) return NULL;
566      while (eptr != NULL) {
567          sptr = ziplistNext(zl,eptr);
568          serverAssert(sptr != NULL);
569          score = zzlGetScore(sptr);
570          if (zslValueLteMax(score,range)) {
571              if (zslValueGteMin(score,range))
572                  return eptr;
573              return NULL;
574          }
575          sptr = ziplistPrev(zl,eptr);
576          if (sptr != NULL)
577              serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
578          else
579              eptr = NULL;
580      }
581      return NULL;
582  }
583  int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
584      sds value = ziplistGetObject(p);
585      int res = zslLexValueGteMin(value,spec);
586      sdsfree(value);
587      return res;
588  }
589  int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
590      sds value = ziplistGetObject(p);
591      int res = zslLexValueLteMax(value,spec);
592      sdsfree(value);
593      return res;
594  }
595  int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
596      unsigned char *p;
597      int cmp = sdscmplex(range->min,range->max);
598      if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
599          return 0;
600      p = ziplistIndex(zl,-2); &bsol;* Last element. */
601      if (p == NULL) return 0;
602      if (!zzlLexValueGteMin(p,range))
603          return 0;
604      p = ziplistIndex(zl,0); &bsol;* First element. */
605      serverAssert(p != NULL);
606      if (!zzlLexValueLteMax(p,range))
607          return 0;
608      return 1;
609  }
610  unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
611      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
612      if (!zzlIsInLexRange(zl,range)) return NULL;
613      while (eptr != NULL) {
614          if (zzlLexValueGteMin(eptr,range)) {
615              if (zzlLexValueLteMax(eptr,range))
616                  return eptr;
617              return NULL;
618          }
619          sptr = ziplistNext(zl,eptr); &bsol;* This element score. Skip it. */
620          serverAssert(sptr != NULL);
621          eptr = ziplistNext(zl,sptr); &bsol;* Next element. */
622      }
623      return NULL;
624  }
625  unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
626      unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
627      if (!zzlIsInLexRange(zl,range)) return NULL;
628      while (eptr != NULL) {
629          if (zzlLexValueLteMax(eptr,range)) {
630              if (zzlLexValueGteMin(eptr,range))
631                  return eptr;
632              return NULL;
633          }
634          sptr = ziplistPrev(zl,eptr);
635          if (sptr != NULL)
636              serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
637          else
638              eptr = NULL;
639      }
640      return NULL;
641  }
642  unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
643      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
644      while (eptr != NULL) {
645          sptr = ziplistNext(zl,eptr);
646          serverAssert(sptr != NULL);
647          if (ziplistCompare(eptr,(unsigned char*)ele,(unsigned int)sdslen(ele))) {     WIN_PORT_FIX &bsol;* unsigned int */
648              if (score != NULL) *score = zzlGetScore(sptr);
649              return eptr;
650          }
651          eptr = ziplistNext(zl,sptr);
652      }
653      return NULL;
654  }
655  unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
656      unsigned char *p = eptr;
657      zl = ziplistDelete(zl,&p);
658      zl = ziplistDelete(zl,&p);
659      return zl;
660  }
661  unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
662      unsigned char *sptr;
663      char scorebuf[128];
664      int scorelen;
665      size_t offset;
666      scorelen = d2string(scorebuf,sizeof(scorebuf),score);
667      if (eptr == NULL) {
668          zl = ziplistPush(zl,(unsigned char*)ele,(unsigned int)sdslen(ele),ZIPLIST_TAIL); WIN_PORT_FIX &bsol;* unsigned int */
669          zl = ziplistPush(zl,(unsigned char*)scorebuf,scorelen,ZIPLIST_TAIL);
670      } else {
671          offset = eptr-zl;
672          zl = ziplistInsert(zl,eptr,(unsigned char*)ele,(unsigned int)sdslen(ele));    WIN_PORT_FIX &bsol;* unsigned int */
673          eptr = zl+offset;
674          serverAssert((sptr = ziplistNext(zl,eptr)) != NULL);
675          zl = ziplistInsert(zl,sptr,(unsigned char*)scorebuf,scorelen);
676      }
677      return zl;
678  }
679  unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
680      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
681      double s;
682      while (eptr != NULL) {
683          sptr = ziplistNext(zl,eptr);
684          serverAssert(sptr != NULL);
685          s = zzlGetScore(sptr);
686          if (s > score) {
687              zl = zzlInsertAt(zl,eptr,ele,score);
688              break;
689          } else if (s == score) {
690              if (zzlCompareElements(eptr,(unsigned char*)ele,(unsigned int)sdslen(ele)) > 0) { WIN_PORT_FIX &bsol;* unsigned int */
691                  zl = zzlInsertAt(zl,eptr,ele,score);
692                  break;
693              }
694          }
695          eptr = ziplistNext(zl,sptr);
696      }
697      if (eptr == NULL)
698          zl = zzlInsertAt(zl,NULL,ele,score);
699      return zl;
700  }
701  unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, PORT_ULONG *deleted) {
702      unsigned char *eptr, *sptr;
703      double score;
704      PORT_ULONG num = 0;
705      if (deleted != NULL) *deleted = 0;
706      eptr = zzlFirstInRange(zl,range);
707      if (eptr == NULL) return zl;
708      while ((sptr = ziplistNext(zl,eptr)) != NULL) {
709          score = zzlGetScore(sptr);
710          if (zslValueLteMax(score,range)) {
711              zl = ziplistDelete(zl,&eptr);
712              zl = ziplistDelete(zl,&eptr);
713              num++;
714          } else {
715              break;
716          }
717      }
718      if (deleted != NULL) *deleted = num;
719      return zl;
720  }
721  unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, PORT_ULONG *deleted) {
722      unsigned char *eptr, *sptr;
723      PORT_ULONG num = 0;
724      if (deleted != NULL) *deleted = 0;
725      eptr = zzlFirstInLexRange(zl,range);
726      if (eptr == NULL) return zl;
727      while ((sptr = ziplistNext(zl,eptr)) != NULL) {
728          if (zzlLexValueLteMax(eptr,range)) {
729              zl = ziplistDelete(zl,&eptr);
730              zl = ziplistDelete(zl,&eptr);
731              num++;
732          } else {
733              break;
734          }
735      }
736      if (deleted != NULL) *deleted = num;
737      return zl;
738  }
739  unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, PORT_ULONG *deleted) {
740      unsigned int num = (end-start)+1;
741      if (deleted) *deleted = num;
742      zl = ziplistDeleteRange(zl,2*(start-1),2*num);
743      return zl;
744  }
745  PORT_ULONG zsetLength(const robj *zobj) {
746      PORT_ULONG length = 0;
747      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
748          length = zzlLength(zobj->ptr);
749      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
750          length = (PORT_ULONG) ((const zset*)zobj->ptr)->zsl->length;                         WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
751      } else {
752          serverPanic("Unknown sorted set encoding");
753      }
754      return length;
755  }
756  void zsetConvert(robj *zobj, int encoding) {
757      zset *zs;
758      zskiplistNode *node, *next;
759      sds ele;
760      double score;
761      if (zobj->encoding == encoding) return;
762      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
763          unsigned char *zl = zobj->ptr;
764          unsigned char *eptr, *sptr;
765          unsigned char *vstr;
766          unsigned int vlen;
767          PORT_LONGLONG vlong;
768          if (encoding != OBJ_ENCODING_SKIPLIST)
769              serverPanic("Unknown target encoding");
770          zs = zmalloc(sizeof(*zs));
771          zs->dict = dictCreate(&zsetDictType,NULL);
772          zs->zsl = zslCreate();
773          eptr = ziplistIndex(zl,0);
774          serverAssertWithInfo(NULL,zobj,eptr != NULL);
775          sptr = ziplistNext(zl,eptr);
776          serverAssertWithInfo(NULL,zobj,sptr != NULL);
777          while (eptr != NULL) {
778              score = zzlGetScore(sptr);
779              serverAssertWithInfo(NULL,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
780              if (vstr == NULL)
781                  ele = sdsfromlonglong(vlong);
782              else
783                  ele = sdsnewlen((char*)vstr,vlen);
784              node = zslInsert(zs->zsl,score,ele);
785              serverAssert(dictAdd(zs->dict,ele,&node->score) == DICT_OK);
786              zzlNext(zl,&eptr,&sptr);
787          }
788          zfree(zobj->ptr);
789          zobj->ptr = zs;
790          zobj->encoding = OBJ_ENCODING_SKIPLIST;
791      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
792          unsigned char *zl = ziplistNew();
793          if (encoding != OBJ_ENCODING_ZIPLIST)
794              serverPanic("Unknown target encoding");
795          zs = zobj->ptr;
796          dictRelease(zs->dict);
797          node = zs->zsl->header->level[0].forward;
798          zfree(zs->zsl->header);
799          zfree(zs->zsl);
800          while (node) {
801              zl = zzlInsertAt(zl,NULL,node->ele,node->score);
802              next = node->level[0].forward;
803              zslFreeNode(node);
804              node = next;
805          }
806          zfree(zs);
807          zobj->ptr = zl;
808          zobj->encoding = OBJ_ENCODING_ZIPLIST;
809      } else {
810          serverPanic("Unknown sorted set encoding");
811      }
812  }
813  void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {
814      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;
815      zset *zset = zobj->ptr;
816      if (zset->zsl->length <= server.zset_max_ziplist_entries &&
817          maxelelen <= server.zset_max_ziplist_value)
818              zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);
819  }
820  int zsetScore(robj *zobj, sds member, double *score) {
821      if (!zobj || !member) return C_ERR;
822      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
823          if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;
824      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
825          zset *zs = zobj->ptr;
826          dictEntry *de = dictFind(zs->dict, member);
827          if (de == NULL) return C_ERR;
828          *score = *(double*)dictGetVal(de);
829      } else {
830          serverPanic("Unknown sorted set encoding");
831      }
832      return C_OK;
833  }
834  int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore) {
835      int incr = (*flags & ZADD_INCR) != 0;
836      int nx = (*flags & ZADD_NX) != 0;
837      int xx = (*flags & ZADD_XX) != 0;
838      *flags = 0; &bsol;* We'll return our response flags. */
839      double curscore;
840      if (isnan(score)) {
841          *flags = ZADD_NAN;
842          return 0;
843      }
844      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
845          unsigned char *eptr;
846          if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
847              if (nx) {
848                  *flags |= ZADD_NOP;
849                  return 1;
850              }
851              if (incr) {
852                  score += curscore;
853                  if (isnan(score)) {
854                      *flags |= ZADD_NAN;
855                      return 0;
856                  }
857                  if (newscore) *newscore = score;
858              }
859              if (score != curscore) {
860                  zobj->ptr = zzlDelete(zobj->ptr,eptr);
861                  zobj->ptr = zzlInsert(zobj->ptr,ele,score);
862                  *flags |= ZADD_UPDATED;
863              }
864              return 1;
865          } else if (!xx) {
866              zobj->ptr = zzlInsert(zobj->ptr,ele,score);
867              if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries ||
868                  sdslen(ele) > server.zset_max_ziplist_value)
869                  zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
870              if (newscore) *newscore = score;
871              *flags |= ZADD_ADDED;
872              return 1;
873          } else {
874              *flags |= ZADD_NOP;
875              return 1;
876          }
877      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
878          zset *zs = zobj->ptr;
879          zskiplistNode *znode;
880          dictEntry *de;
881          de = dictFind(zs->dict,ele);
882          if (de != NULL) {
883              if (nx) {
884                  *flags |= ZADD_NOP;
885                  return 1;
886              }
887              curscore = *(double*)dictGetVal(de);
888              if (incr) {
889                  score += curscore;
890                  if (isnan(score)) {
891                      *flags |= ZADD_NAN;
892                      return 0;
893                  }
894                  if (newscore) *newscore = score;
895              }
896              if (score != curscore) {
897                  znode = zslUpdateScore(zs->zsl,curscore,ele,score);
898                  dictGetVal(de) = &znode->score; &bsol;* Update score ptr. */
899                  *flags |= ZADD_UPDATED;
900              }
901              return 1;
902          } else if (!xx) {
903              ele = sdsdup(ele);
904              znode = zslInsert(zs->zsl,score,ele);
905              serverAssert(dictAdd(zs->dict,ele,&znode->score) == DICT_OK);
906              *flags |= ZADD_ADDED;
907              if (newscore) *newscore = score;
908              return 1;
909          } else {
910              *flags |= ZADD_NOP;
911              return 1;
912          }
913      } else {
914          serverPanic("Unknown sorted set encoding");
915      }
916      return 0; &bsol;* Never reached. */
917  }
918  int zsetDel(robj *zobj, sds ele) {
919      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
920          unsigned char *eptr;
921          if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {
922              zobj->ptr = zzlDelete(zobj->ptr,eptr);
923              return 1;
924          }
925      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
926          zset *zs = zobj->ptr;
927          dictEntry *de;
928          double score;
929          de = dictUnlink(zs->dict,ele);
930          if (de != NULL) {
931              score = *(double*)dictGetVal(de);
932              dictFreeUnlinkedEntry(zs->dict,de);
933              int retval = zslDelete(zs->zsl,score,ele,NULL);
934              serverAssert(retval);
935              if (htNeedsResize(zs->dict)) dictResize(zs->dict);
936              return 1;
937          }
938      } else {
939          serverPanic("Unknown sorted set encoding");
940      }
<span onclick='openModal()' class='match'>941      return 0; &bsol;* No such element found. */
942  }
943  PORT_LONG zsetRank(robj *zobj, sds ele, int reverse) {
944      PORT_ULONG llen;
945      PORT_ULONG rank;
</span>946      llen = zsetLength(zobj);
947      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
948          unsigned char *zl = zobj->ptr;
949          unsigned char *eptr, *sptr;
950          eptr = ziplistIndex(zl,0);
951          serverAssert(eptr != NULL);
952          sptr = ziplistNext(zl,eptr);
953          serverAssert(sptr != NULL);
954          rank = 1;
955          while(eptr != NULL) {
956              if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele)))
957                  break;
958              rank++;
959              zzlNext(zl,&eptr,&sptr);
960          }
961          if (eptr != NULL) {
962              if (reverse)
963                  return llen-rank;
964              else
965                  return rank-1;
966          } else {
967              return -1;
968          }
969      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
970          zset *zs = zobj->ptr;
971          zskiplist *zsl = zs->zsl;
972          dictEntry *de;
973          double score;
974          de = dictFind(zs->dict,ele);
975          if (de != NULL) {
976              score = *(double*)dictGetVal(de);
977              rank = zslGetRank(zsl,score,ele);
978              serverAssert(rank != 0);
979              if (reverse)
980                  return llen-rank;
981              else
982                  return rank-1;
983          } else {
984              return -1;
985          }
986      } else {
987          serverPanic("Unknown sorted set encoding");
988      }
989  }
990  void zaddGenericCommand(client *c, int flags) {
991      static char *nanerr = "resulting score is not a number (NaN)";
992      robj *key = c->argv[1];
993      robj *zobj;
994      sds ele;
995      double score = 0, *scores = NULL;
996      int j, elements;
997      int scoreidx = 0;
998      int added = 0;      &bsol;* Number of new elements added. */
999      int updated = 0;    &bsol;* Number of elements with updated score. */
1000      int processed = 0;  &bsol;* Number of elements processed, may remain zero with
1001                             options like XX. */
1002      scoreidx = 2;
1003      while(scoreidx < c->argc) {
1004          char *opt = c->argv[scoreidx]->ptr;
1005          if (!strcasecmp(opt,"nx")) flags |= ZADD_NX;
1006          else if (!strcasecmp(opt,"xx")) flags |= ZADD_XX;
1007          else if (!strcasecmp(opt,"ch")) flags |= ZADD_CH;
1008          else if (!strcasecmp(opt,"incr")) flags |= ZADD_INCR;
1009          else break;
1010          scoreidx++;
1011      }
1012      int incr = (flags & ZADD_INCR) != 0;
1013      int nx = (flags & ZADD_NX) != 0;
1014      int xx = (flags & ZADD_XX) != 0;
1015      int ch = (flags & ZADD_CH) != 0;
1016      elements = c->argc-scoreidx;
1017      if (elements % 2 || !elements) {
1018          addReply(c,shared.syntaxerr);
1019          return;
1020      }
1021      elements /= 2; &bsol;* Now this holds the number of score-element pairs. */
1022      if (nx && xx) {
1023          addReplyError(c,
1024              "XX and NX options at the same time are not compatible");
1025          return;
1026      }
1027      if (incr && elements > 1) {
1028          addReplyError(c,
1029              "INCR option supports a single increment-element pair");
1030          return;
1031      }
1032      scores = zmalloc(sizeof(double)*elements);
1033      for (j = 0; j < elements; j++) {
1034          if (getDoubleFromObjectOrReply(c,c->argv[scoreidx+j*2],&scores[j],NULL)
1035              != C_OK) goto cleanup;
1036      }
1037      zobj = lookupKeyWrite(c->db,key);
1038      if (zobj == NULL) {
1039          if (xx) goto reply_to_client; &bsol;* No key + XX option: nothing to do. */
1040          if (server.zset_max_ziplist_entries == 0 ||
1041              server.zset_max_ziplist_value < sdslen(c->argv[scoreidx+1]->ptr))
1042          {
1043              zobj = createZsetObject();
1044          } else {
1045              zobj = createZsetZiplistObject();
1046          }
1047          dbAdd(c->db,key,zobj);
1048      } else {
1049          if (zobj->type != OBJ_ZSET) {
1050              addReply(c,shared.wrongtypeerr);
1051              goto cleanup;
1052          }
1053      }
1054      for (j = 0; j < elements; j++) {
1055          double newscore;
1056          score = scores[j];
1057          int retflags = flags;
1058          ele = c->argv[scoreidx+1+j*2]->ptr;
1059          int retval = zsetAdd(zobj, score, ele, &retflags, &newscore);
1060          if (retval == 0) {
1061              addReplyError(c,nanerr);
1062              goto cleanup;
1063          }
1064          if (retflags & ZADD_ADDED) added++;
1065          if (retflags & ZADD_UPDATED) updated++;
1066          if (!(retflags & ZADD_NOP)) processed++;
1067          score = newscore;
1068      }
1069      server.dirty += (added+updated);
1070  reply_to_client:
1071      if (incr) { &bsol;* ZINCRBY or INCR option. */
1072          if (processed)
1073              addReplyDouble(c,score);
1074          else
1075              addReply(c,shared.nullbulk);
1076      } else { &bsol;* ZADD. */
1077          addReplyLongLong(c,ch ? added+updated : added);
1078      }
1079  cleanup:
1080      zfree(scores);
1081      if (added || updated) {
1082          signalModifiedKey(c->db,key);
1083          notifyKeyspaceEvent(NOTIFY_ZSET,
1084              incr ? "zincr" : "zadd", key, c->db->id);
1085      }
1086  }
1087  void zaddCommand(client *c) {
1088      zaddGenericCommand(c,ZADD_NONE);
1089  }
1090  void zincrbyCommand(client *c) {
1091      zaddGenericCommand(c,ZADD_INCR);
1092  }
1093  void zremCommand(client *c) {
1094      robj *key = c->argv[1];
1095      robj *zobj;
1096      int deleted = 0, keyremoved = 0, j;
1097      if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
1098          checkType(c,zobj,OBJ_ZSET)) return;
1099      for (j = 2; j < c->argc; j++) {
1100          if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;
1101          if (zsetLength(zobj) == 0) {
1102              dbDelete(c->db,key);
1103              keyremoved = 1;
1104              break;
1105          }
1106      }
1107      if (deleted) {
1108          notifyKeyspaceEvent(NOTIFY_ZSET,"zrem",key,c->db->id);
1109          if (keyremoved)
1110              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
1111          signalModifiedKey(c->db,key);
1112          server.dirty += deleted;
1113      }
1114      addReplyLongLong(c,deleted);
1115  }
1116  #define ZRANGE_RANK 0
1117  #define ZRANGE_SCORE 1
1118  #define ZRANGE_LEX 2
1119  void zremrangeGenericCommand(client *c, int rangetype) {
1120      robj *key = c->argv[1];
1121      robj *zobj;
1122      int keyremoved = 0;
1123      PORT_ULONG deleted = 0;
1124      zrangespec range;
1125      zlexrangespec lexrange;
1126      PORT_LONG start, end, llen;
1127      if (rangetype == ZRANGE_RANK) {
1128          if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) ||
1129              (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK))
1130              return;
1131      } else if (rangetype == ZRANGE_SCORE) {
1132          if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
1133              addReplyError(c,"min or max is not a float");
1134              return;
1135          }
1136      } else if (rangetype == ZRANGE_LEX) {
1137          if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != C_OK) {
1138              addReplyError(c,"min or max not valid string range item");
1139              return;
1140          }
1141      }
1142      if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
1143          checkType(c,zobj,OBJ_ZSET)) goto cleanup;
1144      if (rangetype == ZRANGE_RANK) {
1145          llen = zsetLength(zobj);
1146          if (start < 0) start = llen+start;
1147          if (end < 0) end = llen+end;
1148          if (start < 0) start = 0;
1149          if (start > end || start >= llen) {
1150              addReply(c,shared.czero);
1151              goto cleanup;
1152          }
1153          if (end >= llen) end = llen-1;
1154      }
1155      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1156          switch(rangetype) {
1157          case ZRANGE_RANK:
1158              zobj->ptr = zzlDeleteRangeByRank(zobj->ptr,(int)start+1,(int)end+1,&deleted);   WIN_PORT_FIX &bsol;* cast (int), cast (int) */
1159              break;
1160          case ZRANGE_SCORE:
1161              zobj->ptr = zzlDeleteRangeByScore(zobj->ptr,&range,&deleted);
1162              break;
1163          case ZRANGE_LEX:
1164              zobj->ptr = zzlDeleteRangeByLex(zobj->ptr,&lexrange,&deleted);
1165              break;
1166          }
1167          if (zzlLength(zobj->ptr) == 0) {
1168              dbDelete(c->db,key);
1169              keyremoved = 1;
1170          }
1171      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
1172          zset *zs = zobj->ptr;
1173          switch(rangetype) {
1174          case ZRANGE_RANK:
1175              deleted = zslDeleteRangeByRank(zs->zsl,(int)start+1,(int)end+1,zs->dict);   WIN_PORT_FIX &bsol;* cast (int), cast (int) */
1176              break;
1177          case ZRANGE_SCORE:
1178              deleted = zslDeleteRangeByScore(zs->zsl,&range,zs->dict);
1179              break;
1180          case ZRANGE_LEX:
1181              deleted = zslDeleteRangeByLex(zs->zsl,&lexrange,zs->dict);
1182              break;
1183          }
1184          if (htNeedsResize(zs->dict)) dictResize(zs->dict);
1185          if (dictSize(zs->dict) == 0) {
1186              dbDelete(c->db,key);
1187              keyremoved = 1;
1188          }
1189      } else {
1190          serverPanic("Unknown sorted set encoding");
1191      }
1192      if (deleted) {
1193          char *event[3] = {"zremrangebyrank","zremrangebyscore","zremrangebylex"};
1194          signalModifiedKey(c->db,key);
1195          notifyKeyspaceEvent(NOTIFY_ZSET,event[rangetype],key,c->db->id);
1196          if (keyremoved)
1197              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
1198      }
1199      server.dirty += deleted;
1200      addReplyLongLong(c,deleted);
1201  cleanup:
1202      if (rangetype == ZRANGE_LEX) zslFreeLexRange(&lexrange);
1203  }
1204  void zremrangebyrankCommand(client *c) {
1205      zremrangeGenericCommand(c,ZRANGE_RANK);
1206  }
1207  void zremrangebyscoreCommand(client *c) {
1208      zremrangeGenericCommand(c,ZRANGE_SCORE);
1209  }
1210  void zremrangebylexCommand(client *c) {
1211      zremrangeGenericCommand(c,ZRANGE_LEX);
1212  }
1213  typedef struct {
1214      robj *subject;
1215      int type; &bsol;* Set, sorted set */
1216      int encoding;
1217      double weight;
1218      union {
1219          union _iterset {
1220              struct {
1221                  intset *is;
1222                  int ii;
1223              } is;
1224              struct {
1225                  dict *dict;
1226                  dictIterator *di;
1227                  dictEntry *de;
1228              } ht;
1229          } set;
1230          union _iterzset {
1231              struct {
1232                  unsigned char *zl;
1233                  unsigned char *eptr, *sptr;
1234              } zl;
1235              struct {
1236                  zset *zs;
1237                  zskiplistNode *node;
1238              } sl;
1239          } zset;
1240      } iter;
1241  } zsetopsrc;
1242  #define OPVAL_DIRTY_SDS 1
1243  #define OPVAL_DIRTY_LL 2
1244  #define OPVAL_VALID_LL 4
1245  typedef struct {
1246      int flags;
1247      unsigned char _buf[32]; &bsol;* Private buffer. */
1248      sds ele;
1249      unsigned char *estr;
1250      unsigned int elen;
1251      PORT_LONGLONG ell;
1252      double score;
1253  } zsetopval;
1254  typedef union _iterset iterset;
1255  typedef union _iterzset iterzset;
1256  void zuiInitIterator(zsetopsrc *op) {
1257      if (op->subject == NULL)
1258          return;
1259      if (op->type == OBJ_SET) {
1260          iterset *it = &op->iter.set;
1261          if (op->encoding == OBJ_ENCODING_INTSET) {
1262              it->is.is = op->subject->ptr;
1263              it->is.ii = 0;
1264          } else if (op->encoding == OBJ_ENCODING_HT) {
1265              it->ht.dict = op->subject->ptr;
1266              it->ht.di = dictGetIterator(op->subject->ptr);
1267              it->ht.de = dictNext(it->ht.di);
1268          } else {
1269              serverPanic("Unknown set encoding");
1270          }
1271      } else if (op->type == OBJ_ZSET) {
1272          iterzset *it = &op->iter.zset;
1273          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1274              it->zl.zl = op->subject->ptr;
1275              it->zl.eptr = ziplistIndex(it->zl.zl,0);
1276              if (it->zl.eptr != NULL) {
1277                  it->zl.sptr = ziplistNext(it->zl.zl,it->zl.eptr);
1278                  serverAssert(it->zl.sptr != NULL);
1279              }
1280          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1281              it->sl.zs = op->subject->ptr;
1282              it->sl.node = it->sl.zs->zsl->header->level[0].forward;
1283          } else {
1284              serverPanic("Unknown sorted set encoding");
1285          }
1286      } else {
1287          serverPanic("Unsupported type");
1288      }
1289  }
1290  void zuiClearIterator(zsetopsrc *op) {
1291      if (op->subject == NULL)
1292          return;
1293      if (op->type == OBJ_SET) {
1294          iterset *it = &op->iter.set;
1295          if (op->encoding == OBJ_ENCODING_INTSET) {
1296              UNUSED(it); &bsol;* skip */
1297          } else if (op->encoding == OBJ_ENCODING_HT) {
1298              dictReleaseIterator(it->ht.di);
1299          } else {
1300              serverPanic("Unknown set encoding");
1301          }
1302      } else if (op->type == OBJ_ZSET) {
1303          iterzset *it = &op->iter.zset;
1304          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1305              UNUSED(it); &bsol;* skip */
1306          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1307              UNUSED(it); &bsol;* skip */
1308          } else {
1309              serverPanic("Unknown sorted set encoding");
1310          }
1311      } else {
1312          serverPanic("Unsupported type");
1313      }
1314  }
1315  PORT_ULONG zuiLength(zsetopsrc *op) {
1316      if (op->subject == NULL)
1317          return 0;
1318      if (op->type == OBJ_SET) {
1319          if (op->encoding == OBJ_ENCODING_INTSET) {
1320              return intsetLen(op->subject->ptr);
1321          } else if (op->encoding == OBJ_ENCODING_HT) {
1322              dict *ht = op->subject->ptr;
1323              return dictSize(ht);
1324          } else {
1325              serverPanic("Unknown set encoding");
1326          }
1327      } else if (op->type == OBJ_ZSET) {
1328          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1329              return zzlLength(op->subject->ptr);
1330          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1331              zset *zs = op->subject->ptr;
1332              return zs->zsl->length;
1333          } else {
1334              serverPanic("Unknown sorted set encoding");
1335          }
1336      } else {
1337          serverPanic("Unsupported type");
1338      }
1339  }
1340  int zuiNext(zsetopsrc *op, zsetopval *val) {
1341      if (op->subject == NULL)
1342          return 0;
1343      if (val->flags & OPVAL_DIRTY_SDS)
1344          sdsfree(val->ele);
1345      memset(val,0,sizeof(zsetopval));
1346      if (op->type == OBJ_SET) {
1347          iterset *it = &op->iter.set;
1348          if (op->encoding == OBJ_ENCODING_INTSET) {
1349              int64_t ell;
1350              if (!intsetGet(it->is.is,it->is.ii,&ell))
1351                  return 0;
1352              val->ell = ell;
1353              val->score = 1.0;
1354              it->is.ii++;
1355          } else if (op->encoding == OBJ_ENCODING_HT) {
1356              if (it->ht.de == NULL)
1357                  return 0;
1358              val->ele = dictGetKey(it->ht.de);
1359              val->score = 1.0;
1360              it->ht.de = dictNext(it->ht.di);
1361          } else {
1362              serverPanic("Unknown set encoding");
1363          }
1364      } else if (op->type == OBJ_ZSET) {
1365          iterzset *it = &op->iter.zset;
1366          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1367              if (it->zl.eptr == NULL || it->zl.sptr == NULL)
1368                  return 0;
1369              serverAssert(ziplistGet(it->zl.eptr,&val->estr,&val->elen,&val->ell));
1370              val->score = zzlGetScore(it->zl.sptr);
1371              zzlNext(it->zl.zl,&it->zl.eptr,&it->zl.sptr);
1372          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1373              if (it->sl.node == NULL)
1374                  return 0;
1375              val->ele = it->sl.node->ele;
1376              val->score = it->sl.node->score;
1377              it->sl.node = it->sl.node->level[0].forward;
1378          } else {
1379              serverPanic("Unknown sorted set encoding");
1380          }
1381      } else {
1382          serverPanic("Unsupported type");
1383      }
1384      return 1;
1385  }
1386  int zuiLongLongFromValue(zsetopval *val) {
1387      if (!(val->flags & OPVAL_DIRTY_LL)) {
1388          val->flags |= OPVAL_DIRTY_LL;
1389          if (val->ele != NULL) {
1390              if (string2ll(val->ele,sdslen(val->ele),&val->ell))
1391                  val->flags |= OPVAL_VALID_LL;
1392          } else if (val->estr != NULL) {
1393              if (string2ll((char*)val->estr,val->elen,&val->ell))
1394                  val->flags |= OPVAL_VALID_LL;
1395          } else {
1396              val->flags |= OPVAL_VALID_LL;
1397          }
1398      }
1399      return val->flags & OPVAL_VALID_LL;
1400  }
1401  sds zuiSdsFromValue(zsetopval *val) {
1402      if (val->ele == NULL) {
1403          if (val->estr != NULL) {
1404              val->ele = sdsnewlen((char*)val->estr,val->elen);
1405          } else {
1406              val->ele = sdsfromlonglong(val->ell);
1407          }
1408          val->flags |= OPVAL_DIRTY_SDS;
1409      }
1410      return val->ele;
1411  }
1412  sds zuiNewSdsFromValue(zsetopval *val) {
1413      if (val->flags & OPVAL_DIRTY_SDS) {
1414          sds ele = val->ele;
1415          val->flags &= ~OPVAL_DIRTY_SDS;
1416          val->ele = NULL;
1417          return ele;
1418      } else if (val->ele) {
1419          return sdsdup(val->ele);
1420      } else if (val->estr) {
1421          return sdsnewlen((char*)val->estr,val->elen);
1422      } else {
1423          return sdsfromlonglong(val->ell);
1424      }
1425  }
1426  int zuiBufferFromValue(zsetopval *val) {
1427      if (val->estr == NULL) {
1428          if (val->ele != NULL) {
1429              val->elen = sdslen(val->ele);
1430              val->estr = (unsigned char*)val->ele;
1431          } else {
1432              val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);
1433              val->estr = val->_buf;
1434          }
1435      }
1436      return 1;
1437  }
1438  int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
1439      if (op->subject == NULL)
1440          return 0;
1441      if (op->type == OBJ_SET) {
1442          if (op->encoding == OBJ_ENCODING_INTSET) {
1443              if (zuiLongLongFromValue(val) &&
1444                  intsetFind(op->subject->ptr,val->ell))
1445              {
1446                  *score = 1.0;
1447                  return 1;
1448              } else {
1449                  return 0;
1450              }
1451          } else if (op->encoding == OBJ_ENCODING_HT) {
1452              dict *ht = op->subject->ptr;
1453              zuiSdsFromValue(val);
1454              if (dictFind(ht,val->ele) != NULL) {
1455                  *score = 1.0;
1456                  return 1;
1457              } else {
1458                  return 0;
1459              }
1460          } else {
1461              serverPanic("Unknown set encoding");
1462          }
1463      } else if (op->type == OBJ_ZSET) {
1464          zuiSdsFromValue(val);
1465          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1466              if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {
1467                  return 1;
1468              } else {
1469                  return 0;
1470              }
1471          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1472              zset *zs = op->subject->ptr;
1473              dictEntry *de;
1474              if ((de = dictFind(zs->dict,val->ele)) != NULL) {
1475                  *score = *(double*)dictGetVal(de);
1476                  return 1;
1477              } else {
1478                  return 0;
1479              }
1480          } else {
1481              serverPanic("Unknown sorted set encoding");
1482          }
1483      } else {
1484          serverPanic("Unsupported type");
1485      }
1486  }
1487  int zuiCompareByCardinality(const void *s1, const void *s2) {
1488      PORT_ULONG first = zuiLength((zsetopsrc*)s1);
1489      PORT_ULONG second = zuiLength((zsetopsrc*)s2);
1490      if (first > second) return 1;
1491      if (first < second) return -1;
1492      return 0;
1493  }
1494  #define REDIS_AGGR_SUM 1
1495  #define REDIS_AGGR_MIN 2
1496  #define REDIS_AGGR_MAX 3
1497  #define zunionInterDictValue(_e) (dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))
1498  inline static void zunionInterAggregate(double *target, double val, int aggregate) {
1499      if (aggregate == REDIS_AGGR_SUM) {
1500          *target = *target + val;
1501          if (isnan(*target)) *target = 0.0;
1502      } else if (aggregate == REDIS_AGGR_MIN) {
1503          *target = val < *target ? val : *target;
1504      } else if (aggregate == REDIS_AGGR_MAX) {
1505          *target = val > *target ? val : *target;
1506      } else {
1507          serverPanic("Unknown ZUNION/INTER aggregate type");
1508      }
1509  }
1510  uint64_t dictSdsHash(const void *key);
1511  int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
1512  dictType setAccumulatorDictType = {
1513      dictSdsHash,               &bsol;* hash function */
1514      NULL,                      &bsol;* key dup */
1515      NULL,                      &bsol;* val dup */
1516      dictSdsKeyCompare,         &bsol;* key compare */
1517      NULL,                      &bsol;* key destructor */
1518      NULL                       &bsol;* val destructor */
1519  };
1520  void zunionInterGenericCommand(client *c, robj *dstkey, int op) {
1521      int i, j;
1522      PORT_LONG setnum;
1523      int aggregate = REDIS_AGGR_SUM;
1524      zsetopsrc *src;
1525      zsetopval zval;
1526      sds tmp;
1527      size_t maxelelen = 0;
1528      robj *dstobj;
1529      zset *dstzset;
1530      zskiplistNode *znode;
1531      int touched = 0;
1532      if ((getLongFromObjectOrReply(c, c->argv[2], &setnum, NULL) != C_OK))
1533          return;
1534      if (setnum < 1) {
1535          addReplyError(c,
1536              "at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE");
1537          return;
1538      }
1539      if (setnum > c->argc-3) {
1540          addReply(c,shared.syntaxerr);
1541          return;
1542      }
1543      src = zcalloc(sizeof(zsetopsrc) * setnum);
1544      for (i = 0, j = 3; i < setnum; i++, j++) {
1545          robj *obj = lookupKeyWrite(c->db,c->argv[j]);
1546          if (obj != NULL) {
1547              if (obj->type != OBJ_ZSET && obj->type != OBJ_SET) {
1548                  zfree(src);
1549                  addReply(c,shared.wrongtypeerr);
1550                  return;
1551              }
1552              src[i].subject = obj;
1553              src[i].type = obj->type;
1554              src[i].encoding = obj->encoding;
1555          } else {
1556              src[i].subject = NULL;
1557          }
1558          src[i].weight = 1.0;
1559      }
1560      if (j < c->argc) {
1561          int remaining = c->argc - j;
1562          while (remaining) {
1563              if (remaining >= (setnum + 1) &&
1564                  !strcasecmp(c->argv[j]->ptr,"weights"))
1565              {
1566                  j++; remaining--;
1567                  for (i = 0; i < setnum; i++, j++, remaining--) {
1568                      if (getDoubleFromObjectOrReply(c,c->argv[j],&src[i].weight,
1569                              "weight value is not a float") != C_OK)
1570                      {
1571                          zfree(src);
1572                          return;
1573                      }
1574                  }
1575              } else if (remaining >= 2 &&
1576                         !strcasecmp(c->argv[j]->ptr,"aggregate"))
1577              {
1578                  j++; remaining--;
1579                  if (!strcasecmp(c->argv[j]->ptr,"sum")) {
1580                      aggregate = REDIS_AGGR_SUM;
1581                  } else if (!strcasecmp(c->argv[j]->ptr,"min")) {
1582                      aggregate = REDIS_AGGR_MIN;
1583                  } else if (!strcasecmp(c->argv[j]->ptr,"max")) {
1584                      aggregate = REDIS_AGGR_MAX;
1585                  } else {
1586                      zfree(src);
1587                      addReply(c,shared.syntaxerr);
1588                      return;
1589                  }
1590                  j++; remaining--;
1591              } else {
1592                  zfree(src);
1593                  addReply(c,shared.syntaxerr);
1594                  return;
1595              }
1596          }
1597      }
1598      qsort(src,setnum,sizeof(zsetopsrc),zuiCompareByCardinality);
1599      dstobj = createZsetObject();
1600      dstzset = dstobj->ptr;
1601      memset(&zval, 0, sizeof(zval));
1602      if (op == SET_OP_INTER) {
1603          if (zuiLength(&src[0]) > 0) {
1604              zuiInitIterator(&src[0]);
1605              while (zuiNext(&src[0],&zval)) {
1606                  double score, value;
1607                  score = src[0].weight * zval.score;
1608                  if (isnan(score)) score = 0;
1609                  for (j = 1; j < setnum; j++) {
1610                      if (src[j].subject == src[0].subject) {
1611                          value = zval.score*src[j].weight;
1612                          zunionInterAggregate(&score,value,aggregate);
1613                      } else if (zuiFind(&src[j],&zval,&value)) {
1614                          value *= src[j].weight;
1615                          zunionInterAggregate(&score,value,aggregate);
1616                      } else {
1617                          break;
1618                      }
1619                  }
1620                  if (j == setnum) {
1621                      tmp = zuiNewSdsFromValue(&zval);
1622                      znode = zslInsert(dstzset->zsl,score,tmp);
1623                      dictAdd(dstzset->dict,tmp,&znode->score);
1624                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);
1625                  }
1626              }
1627              zuiClearIterator(&src[0]);
1628          }
1629      } else if (op == SET_OP_UNION) {
1630          dict *accumulator = dictCreate(&setAccumulatorDictType,NULL);
1631          dictIterator *di;
1632          dictEntry *de, *existing;
1633          double score;
1634          if (setnum) {
1635              dictExpand(accumulator,zuiLength(&src[setnum-1]));
1636          }
1637          for (i = 0; i < setnum; i++) {
1638              if (zuiLength(&src[i]) == 0) continue;
1639              zuiInitIterator(&src[i]);
1640              while (zuiNext(&src[i],&zval)) {
1641                  score = src[i].weight * zval.score;
1642                  if (isnan(score)) score = 0;
1643                  de = dictAddRaw(accumulator,zuiSdsFromValue(&zval),&existing);
1644                  if (!existing) {
1645                      tmp = zuiNewSdsFromValue(&zval);
1646                       if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);
1647                      dictSetKey(accumulator, de, tmp);
1648                      dictSetDoubleVal(de,score);
1649                  } else {
1650                      zunionInterAggregate(&existing->v.d,score,aggregate);
1651                  }
1652              }
1653              zuiClearIterator(&src[i]);
1654          }
1655          di = dictGetIterator(accumulator);
1656          dictExpand(dstzset->dict,dictSize(accumulator));
1657          while((de = dictNext(di)) != NULL) {
1658              sds ele = dictGetKey(de);
1659              score = dictGetDoubleVal(de);
1660              znode = zslInsert(dstzset->zsl,score,ele);
1661              dictAdd(dstzset->dict,ele,&znode->score);
1662          }
1663          dictReleaseIterator(di);
1664          dictRelease(accumulator);
1665      } else {
1666          serverPanic("Unknown operator");
1667      }
1668      if (dbDelete(c->db,dstkey))
1669          touched = 1;
1670      if (dstzset->zsl->length) {
1671          zsetConvertToZiplistIfNeeded(dstobj,maxelelen);
1672          dbAdd(c->db,dstkey,dstobj);
1673          addReplyLongLong(c,zsetLength(dstobj));
1674          signalModifiedKey(c->db,dstkey);
1675          notifyKeyspaceEvent(NOTIFY_ZSET,
1676              (op == SET_OP_UNION) ? "zunionstore" : "zinterstore",
1677              dstkey,c->db->id);
1678          server.dirty++;
1679      } else {
1680          decrRefCount(dstobj);
1681          addReply(c,shared.czero);
1682          if (touched) {
1683              signalModifiedKey(c->db,dstkey);
1684              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",dstkey,c->db->id);
1685              server.dirty++;
1686          }
1687      }
1688      zfree(src);
1689  }
1690  void zunionstoreCommand(client *c) {
1691      zunionInterGenericCommand(c,c->argv[1], SET_OP_UNION);
1692  }
1693  void zinterstoreCommand(client *c) {
1694      zunionInterGenericCommand(c,c->argv[1], SET_OP_INTER);
1695  }
1696  void zrangeGenericCommand(client *c, int reverse) {
1697      robj *key = c->argv[1];
1698      robj *zobj;
1699      int withscores = 0;
1700      PORT_LONG start;
1701      PORT_LONG end;
1702      PORT_LONG llen;
1703      PORT_LONG rangelen;
1704      if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
1705          (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
1706      if (c->argc == 5 && !strcasecmp(c->argv[4]->ptr,"withscores")) {
1707          withscores = 1;
1708      } else if (c->argc >= 5) {
1709          addReply(c,shared.syntaxerr);
1710          return;
1711      }
1712      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL
1713           || checkType(c,zobj,OBJ_ZSET)) return;
1714      llen = zsetLength(zobj);
1715      if (start < 0) start = llen+start;
1716      if (end < 0) end = llen+end;
1717      if (start < 0) start = 0;
1718      if (start > end || start >= llen) {
1719          addReply(c,shared.emptymultibulk);
1720          return;
1721      }
1722      if (end >= llen) end = llen-1;
1723      rangelen = (int)(end-start)+1;                                              WIN_PORT_FIX &bsol;* cast (int) */
1724      addReplyMultiBulkLen(c, withscores ? (rangelen*2) : rangelen);
1725      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1726          unsigned char *zl = zobj->ptr;
1727          unsigned char *eptr, *sptr;
1728          unsigned char *vstr;
1729          unsigned int vlen;
1730          PORT_LONGLONG vlong;
1731          if (reverse)
1732              eptr = ziplistIndex(zl,(int)(-2-(2*start)));                        WIN_PORT_FIX &bsol;* cast (int) */
1733          else
1734              eptr = ziplistIndex(zl,(int)(2*start));                             WIN_PORT_FIX &bsol;* cast (int) */
1735          serverAssertWithInfo(c,zobj,eptr != NULL);
1736          sptr = ziplistNext(zl,eptr);
1737          while (rangelen--) {
1738              serverAssertWithInfo(c,zobj,eptr != NULL && sptr != NULL);
1739              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
1740              if (vstr == NULL)
1741                  addReplyBulkLongLong(c,vlong);
1742              else
1743                  addReplyBulkCBuffer(c,vstr,vlen);
1744              if (withscores)
1745                  addReplyDouble(c,zzlGetScore(sptr));
1746              if (reverse)
1747                  zzlPrev(zl,&eptr,&sptr);
1748              else
1749                  zzlNext(zl,&eptr,&sptr);
1750          }
1751      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
1752          zset *zs = zobj->ptr;
1753          zskiplist *zsl = zs->zsl;
1754          zskiplistNode *ln;
1755          sds ele;
1756          if (reverse) {
1757              ln = zsl->tail;
1758              if (start > 0)
1759                  ln = zslGetElementByRank(zsl,llen-start);
1760          } else {
1761              ln = zsl->header->level[0].forward;
1762              if (start > 0)
1763                  ln = zslGetElementByRank(zsl,start+1);
1764          }
1765          while(rangelen--) {
1766              serverAssertWithInfo(c,zobj,ln != NULL);
1767              ele = ln->ele;
1768              addReplyBulkCBuffer(c,ele,sdslen(ele));
1769              if (withscores)
1770                  addReplyDouble(c,ln->score);
1771              ln = reverse ? ln->backward : ln->level[0].forward;
1772          }
1773      } else {
1774          serverPanic("Unknown sorted set encoding");
1775      }
1776  }
1777  void zrangeCommand(client *c) {
1778      zrangeGenericCommand(c,0);
1779  }
1780  void zrevrangeCommand(client *c) {
1781      zrangeGenericCommand(c,1);
1782  }
1783  void genericZrangebyscoreCommand(client *c, int reverse) {
1784      zrangespec range;
1785      robj *key = c->argv[1];
1786      robj *zobj;
1787      PORT_LONG offset = 0, limit = -1;
1788      int withscores = 0;
1789      PORT_ULONG rangelen = 0;
1790      void *replylen = NULL;
1791      int minidx, maxidx;
1792      if (reverse) {
1793          maxidx = 2; minidx = 3;
1794      } else {
1795          minidx = 2; maxidx = 3;
1796      }
1797      if (zslParseRange(c->argv[minidx],c->argv[maxidx],&range) != C_OK) {
1798          addReplyError(c,"min or max is not a float");
1799          return;
1800      }
1801      if (c->argc > 4) {
1802          int remaining = c->argc - 4;
1803          int pos = 4;
1804          while (remaining) {
1805              if (remaining >= 1 && !strcasecmp(c->argv[pos]->ptr,"withscores")) {
1806                  pos++; remaining--;
1807                  withscores = 1;
1808              } else if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,"limit")) {
1809                  if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL)
1810                          != C_OK) ||
1811                      (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL)
1812                          != C_OK))
1813                  {
1814                      return;
1815                  }
1816                  pos += 3; remaining -= 3;
1817              } else {
1818                  addReply(c,shared.syntaxerr);
1819                  return;
1820              }
1821          }
1822      }
1823      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
1824          checkType(c,zobj,OBJ_ZSET)) return;
1825      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1826          unsigned char *zl = zobj->ptr;
1827          unsigned char *eptr, *sptr;
1828          unsigned char *vstr;
1829          unsigned int vlen;
1830          PORT_LONGLONG vlong;
1831          double score;
1832          if (reverse) {
1833              eptr = zzlLastInRange(zl,&range);
1834          } else {
1835              eptr = zzlFirstInRange(zl,&range);
1836          }
1837          if (eptr == NULL) {
1838              addReply(c, shared.emptymultibulk);
1839              return;
1840          }
1841          serverAssertWithInfo(c,zobj,eptr != NULL);
1842          sptr = ziplistNext(zl,eptr);
1843          replylen = addDeferredMultiBulkLength(c);
1844          while (eptr && offset--) {
1845              if (reverse) {
1846                  zzlPrev(zl,&eptr,&sptr);
1847              } else {
1848                  zzlNext(zl,&eptr,&sptr);
1849              }
1850          }
1851          while (eptr && limit--) {
1852              score = zzlGetScore(sptr);
1853              if (reverse) {
1854                  if (!zslValueGteMin(score,&range)) break;
1855              } else {
1856                  if (!zslValueLteMax(score,&range)) break;
1857              }
1858              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
1859              rangelen++;
1860              if (vstr == NULL) {
1861                  addReplyBulkLongLong(c,vlong);
1862              } else {
1863                  addReplyBulkCBuffer(c,vstr,vlen);
1864              }
1865              if (withscores) {
1866                  addReplyDouble(c,score);
1867              }
1868              if (reverse) {
1869                  zzlPrev(zl,&eptr,&sptr);
1870              } else {
1871                  zzlNext(zl,&eptr,&sptr);
1872              }
1873          }
1874      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
1875          zset *zs = zobj->ptr;
1876          zskiplist *zsl = zs->zsl;
1877          zskiplistNode *ln;
1878          if (reverse) {
1879              ln = zslLastInRange(zsl,&range);
1880          } else {
1881              ln = zslFirstInRange(zsl,&range);
1882          }
1883          if (ln == NULL) {
1884              addReply(c, shared.emptymultibulk);
1885              return;
1886          }
1887          replylen = addDeferredMultiBulkLength(c);
1888          while (ln && offset--) {
1889              if (reverse) {
1890                  ln = ln->backward;
1891              } else {
1892                  ln = ln->level[0].forward;
1893              }
1894          }
1895          while (ln && limit--) {
1896              if (reverse) {
1897                  if (!zslValueGteMin(ln->score,&range)) break;
1898              } else {
1899                  if (!zslValueLteMax(ln->score,&range)) break;
1900              }
1901              rangelen++;
1902              addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));
1903              if (withscores) {
1904                  addReplyDouble(c,ln->score);
1905              }
1906              if (reverse) {
1907                  ln = ln->backward;
1908              } else {
1909                  ln = ln->level[0].forward;
1910              }
1911          }
1912      } else {
1913          serverPanic("Unknown sorted set encoding");
1914      }
1915      if (withscores) {
1916          rangelen *= 2;
1917      }
1918      setDeferredMultiBulkLength(c, replylen, rangelen);
1919  }
1920  void zrangebyscoreCommand(client *c) {
1921      genericZrangebyscoreCommand(c,0);
1922  }
1923  void zrevrangebyscoreCommand(client *c) {
1924      genericZrangebyscoreCommand(c,1);
1925  }
1926  void zcountCommand(client *c) {
1927      robj *key = c->argv[1];
1928      robj *zobj;
1929      zrangespec range;
1930      PORT_ULONG count = 0;
1931      if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
1932          addReplyError(c,"min or max is not a float");
1933          return;
1934      }
1935      if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
1936          checkType(c, zobj, OBJ_ZSET)) return;
1937      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1938          unsigned char *zl = zobj->ptr;
1939          unsigned char *eptr, *sptr;
1940          double score;
1941          eptr = zzlFirstInRange(zl,&range);
1942          if (eptr == NULL) {
1943              addReply(c, shared.czero);
1944              return;
1945          }
1946          sptr = ziplistNext(zl,eptr);
1947          score = zzlGetScore(sptr);
1948          serverAssertWithInfo(c,zobj,zslValueLteMax(score,&range));
1949          while (eptr) {
1950              score = zzlGetScore(sptr);
1951              if (!zslValueLteMax(score,&range)) {
1952                  break;
1953              } else {
1954                  count++;
1955                  zzlNext(zl,&eptr,&sptr);
1956              }
1957          }
1958      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
1959          zset *zs = zobj->ptr;
1960          zskiplist *zsl = zs->zsl;
1961          zskiplistNode *zn;
1962          PORT_ULONG rank;
1963          zn = zslFirstInRange(zsl, &range);
1964          if (zn != NULL) {
1965              rank = zslGetRank(zsl, zn->score, zn->ele);
1966              count = (int)(zsl->length - (rank - 1));                            WIN_PORT_FIX &bsol;* cast (int) */
1967              zn = zslLastInRange(zsl, &range);
1968              if (zn != NULL) {
1969                  rank = zslGetRank(zsl, zn->score, zn->ele);
1970                  count -= (int)(zsl->length - rank);                             WIN_PORT_FIX &bsol;* cast (int) */
1971              }
1972          }
1973      } else {
1974          serverPanic("Unknown sorted set encoding");
1975      }
1976      addReplyLongLong(c, count);
1977  }
1978  void zlexcountCommand(client *c) {
1979      robj *key = c->argv[1];
1980      robj *zobj;
1981      zlexrangespec range;
1982      PORT_ULONG count = 0;
1983      if (zslParseLexRange(c->argv[2],c->argv[3],&range) != C_OK) {
1984          addReplyError(c,"min or max not valid string range item");
1985          return;
1986      }
1987      if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
1988          checkType(c, zobj, OBJ_ZSET))
1989      {
1990          zslFreeLexRange(&range);
1991          return;
1992      }
1993      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1994          unsigned char *zl = zobj->ptr;
1995          unsigned char *eptr, *sptr;
1996          eptr = zzlFirstInLexRange(zl,&range);
1997          if (eptr == NULL) {
1998              zslFreeLexRange(&range);
1999              addReply(c, shared.czero);
2000              return;
2001          }
2002          sptr = ziplistNext(zl,eptr);
2003          serverAssertWithInfo(c,zobj,zzlLexValueLteMax(eptr,&range));
2004          while (eptr) {
2005              if (!zzlLexValueLteMax(eptr,&range)) {
2006                  break;
2007              } else {
2008                  count++;
2009                  zzlNext(zl,&eptr,&sptr);
2010              }
2011          }
2012      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
2013          zset *zs = zobj->ptr;
2014          zskiplist *zsl = zs->zsl;
2015          zskiplistNode *zn;
2016          PORT_ULONG rank;
2017          zn = zslFirstInLexRange(zsl, &range);
2018          if (zn != NULL) {
2019              rank = zslGetRank(zsl, zn->score, zn->ele);
2020              count = (int)(zsl->length - (rank - 1));                            WIN_PORT_FIX &bsol;* cast (int) */
2021              zn = zslLastInLexRange(zsl, &range);
2022              if (zn != NULL) {
2023                  rank = zslGetRank(zsl, zn->score, zn->ele);
2024                  count -= (int)(zsl->length - rank);                             WIN_PORT_FIX &bsol;* cast (int) */
2025              }
2026          }
2027      } else {
2028          serverPanic("Unknown sorted set encoding");
2029      }
2030      zslFreeLexRange(&range);
2031      addReplyLongLong(c, count);
2032  }
2033  void genericZrangebylexCommand(client *c, int reverse) {
2034      zlexrangespec range;
2035      robj *key = c->argv[1];
2036      robj *zobj;
2037      PORT_LONG offset = 0, limit = -1;
2038      PORT_ULONG rangelen = 0;
2039      void *replylen = NULL;
2040      int minidx, maxidx;
2041      if (reverse) {
2042          maxidx = 2; minidx = 3;
2043      } else {
2044          minidx = 2; maxidx = 3;
2045      }
2046      if (zslParseLexRange(c->argv[minidx],c->argv[maxidx],&range) != C_OK) {
2047          addReplyError(c,"min or max not valid string range item");
2048          return;
2049      }
2050      if (c->argc > 4) {
2051          int remaining = c->argc - 4;
2052          int pos = 4;
2053          while (remaining) {
2054              if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,"limit")) {
2055                  if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != C_OK) ||
2056                      (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL) != C_OK)) {
2057                      zslFreeLexRange(&range);
2058                      return;
2059                  }
2060                  pos += 3; remaining -= 3;
2061              } else {
2062                  zslFreeLexRange(&range);
2063                  addReply(c,shared.syntaxerr);
2064                  return;
2065              }
2066          }
2067      }
2068      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
2069          checkType(c,zobj,OBJ_ZSET))
2070      {
2071          zslFreeLexRange(&range);
2072          return;
2073      }
2074      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
2075          unsigned char *zl = zobj->ptr;
2076          unsigned char *eptr, *sptr;
2077          unsigned char *vstr;
2078          unsigned int vlen;
2079          PORT_LONGLONG vlong;
2080          if (reverse) {
2081              eptr = zzlLastInLexRange(zl,&range);
2082          } else {
2083              eptr = zzlFirstInLexRange(zl,&range);
2084          }
2085          if (eptr == NULL) {
2086              addReply(c, shared.emptymultibulk);
2087              zslFreeLexRange(&range);
2088              return;
2089          }
2090          serverAssertWithInfo(c,zobj,eptr != NULL);
2091          sptr = ziplistNext(zl,eptr);
2092          replylen = addDeferredMultiBulkLength(c);
2093          while (eptr && offset--) {
2094              if (reverse) {
2095                  zzlPrev(zl,&eptr,&sptr);
2096              } else {
2097                  zzlNext(zl,&eptr,&sptr);
2098              }
2099          }
2100          while (eptr && limit--) {
2101              if (reverse) {
2102                  if (!zzlLexValueGteMin(eptr,&range)) break;
2103              } else {
2104                  if (!zzlLexValueLteMax(eptr,&range)) break;
2105              }
2106              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
2107              rangelen++;
2108              if (vstr == NULL) {
2109                  addReplyBulkLongLong(c,vlong);
2110              } else {
2111                  addReplyBulkCBuffer(c,vstr,vlen);
2112              }
2113              if (reverse) {
2114                  zzlPrev(zl,&eptr,&sptr);
2115              } else {
2116                  zzlNext(zl,&eptr,&sptr);
2117              }
2118          }
2119      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
2120          zset *zs = zobj->ptr;
2121          zskiplist *zsl = zs->zsl;
2122          zskiplistNode *ln;
2123          if (reverse) {
2124              ln = zslLastInLexRange(zsl,&range);
2125          } else {
2126              ln = zslFirstInLexRange(zsl,&range);
2127          }
2128          if (ln == NULL) {
2129              addReply(c, shared.emptymultibulk);
2130              zslFreeLexRange(&range);
2131              return;
2132          }
2133          replylen = addDeferredMultiBulkLength(c);
2134          while (ln && offset--) {
2135              if (reverse) {
2136                  ln = ln->backward;
2137              } else {
2138                  ln = ln->level[0].forward;
2139              }
2140          }
2141          while (ln && limit--) {
2142              if (reverse) {
2143                  if (!zslLexValueGteMin(ln->ele,&range)) break;
2144              } else {
2145                  if (!zslLexValueLteMax(ln->ele,&range)) break;
2146              }
2147              rangelen++;
2148              addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));
2149              if (reverse) {
2150                  ln = ln->backward;
2151              } else {
2152                  ln = ln->level[0].forward;
2153              }
2154          }
2155      } else {
2156          serverPanic("Unknown sorted set encoding");
2157      }
2158      zslFreeLexRange(&range);
2159      setDeferredMultiBulkLength(c, replylen, rangelen);
2160  }
2161  void zrangebylexCommand(client *c) {
2162      genericZrangebylexCommand(c,0);
2163  }
2164  void zrevrangebylexCommand(client *c) {
2165      genericZrangebylexCommand(c,1);
2166  }
2167  void zcardCommand(client *c) {
2168      robj *key = c->argv[1];
2169      robj *zobj;
2170      if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
2171          checkType(c,zobj,OBJ_ZSET)) return;
2172      addReplyLongLong(c,zsetLength(zobj));
2173  }
2174  void zscoreCommand(client *c) {
2175      robj *key = c->argv[1];
2176      robj *zobj;
2177      double score;
2178      if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
2179          checkType(c,zobj,OBJ_ZSET)) return;
2180      if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {
2181          addReply(c,shared.nullbulk);
2182      } else {
2183          addReplyDouble(c,score);
2184      }
2185  }
2186  void zrankGenericCommand(client *c, int reverse) {
2187      robj *key = c->argv[1];
2188      robj *ele = c->argv[2];
2189      robj *zobj;
2190      PORT_LONG rank;
2191      if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
2192          checkType(c,zobj,OBJ_ZSET)) return;
2193      serverAssertWithInfo(c,ele,sdsEncodedObject(ele));
2194      rank = zsetRank(zobj,ele->ptr,reverse);
2195      if (rank >= 0) {
2196          addReplyLongLong(c,rank);
2197      } else {
2198          addReply(c,shared.nullbulk);
2199      }
2200  }
2201  void zrankCommand(client *c) {
2202      zrankGenericCommand(c, 0);
2203  }
2204  void zrevrankCommand(client *c) {
2205      zrankGenericCommand(c, 1);
2206  }
2207  void zscanCommand(client *c) {
2208      robj *o;
2209      PORT_ULONG cursor;
2210      if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
2211      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
2212          checkType(c,o,OBJ_ZSET)) return;
2213      scanGenericCommand(c,o,cursor);
2214  }
2215  void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg) {
2216      int idx;
2217      robj *key = NULL;
2218      robj *zobj = NULL;
2219      sds ele;
2220      double score;
2221      PORT_LONG count = 1;
2222      if (countarg) {
2223          if (getLongFromObjectOrReply(c,countarg,&count,NULL) != C_OK)
2224              return;
2225          if (count <= 0) {
2226              addReply(c,shared.emptymultibulk);
2227              return;
2228          }
2229      }
2230      idx = 0;
2231      while (idx < keyc) {
2232          key = keyv[idx++];
2233          zobj = lookupKeyWrite(c->db,key);
2234          if (!zobj) continue;
2235          if (checkType(c,zobj,OBJ_ZSET)) return;
2236          break;
2237      }
2238      if (!zobj) {
2239          addReply(c,shared.emptymultibulk);
2240          return;
2241      }
2242      void *arraylen_ptr = addDeferredMultiBulkLength(c);
2243      PORT_LONG arraylen = 0;
2244      if (emitkey) addReplyBulk(c,key);
2245      do {
2246          if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
2247              unsigned char *zl = zobj->ptr;
2248              unsigned char *eptr, *sptr;
2249              unsigned char *vstr;
2250              unsigned int vlen;
2251              PORT_LONGLONG vlong;
2252              eptr = ziplistIndex(zl,where == ZSET_MAX ? -2 : 0);
2253              serverAssertWithInfo(c,zobj,eptr != NULL);
2254              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
2255              if (vstr == NULL)
2256                  ele = sdsfromlonglong(vlong);
2257              else
2258                  ele = sdsnewlen(vstr,vlen);
2259              sptr = ziplistNext(zl,eptr);
2260              serverAssertWithInfo(c,zobj,sptr != NULL);
2261              score = zzlGetScore(sptr);
2262          } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
2263              zset *zs = zobj->ptr;
2264              zskiplist *zsl = zs->zsl;
2265              zskiplistNode *zln;
2266              zln = (where == ZSET_MAX ? zsl->tail :
2267                                         zsl->header->level[0].forward);
2268              serverAssertWithInfo(c,zobj,zln != NULL);
2269              ele = sdsdup(zln->ele);
2270              score = zln->score;
2271          } else {
2272              serverPanic("Unknown sorted set encoding");
2273          }
2274          serverAssertWithInfo(c,zobj,zsetDel(zobj,ele));
2275          server.dirty++;
2276          if (arraylen == 0) { &bsol;* Do this only for the first iteration. */
2277              char *events[2] = {"zpopmin","zpopmax"};
2278              notifyKeyspaceEvent(NOTIFY_ZSET,events[where],key,c->db->id);
2279              signalModifiedKey(c->db,key);
2280          }
2281          addReplyBulkCBuffer(c,ele,sdslen(ele));
2282          addReplyDouble(c,score);
2283          sdsfree(ele);
2284          arraylen += 2;
2285          if (zsetLength(zobj) == 0) {
2286              dbDelete(c->db,key);
2287              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
2288              break;
2289          }
2290      } while(--count);
2291      setDeferredMultiBulkLength(c,arraylen_ptr,arraylen + (emitkey != 0));
2292  }
2293  void zpopminCommand(client *c) {
2294      if (c->argc > 3) {
2295          addReply(c,shared.syntaxerr);
2296          return;
2297      }
2298      genericZpopCommand(c,&c->argv[1],1,ZSET_MIN,0,
2299          c->argc == 3 ? c->argv[2] : NULL);
2300  }
2301  void zpopmaxCommand(client *c) {
2302      if (c->argc > 3) {
2303          addReply(c,shared.syntaxerr);
2304          return;
2305      }
2306      genericZpopCommand(c,&c->argv[1],1,ZSET_MAX,0,
2307          c->argc == 3 ? c->argv[2] : NULL);
2308  }
2309  void blockingGenericZpopCommand(client *c, int where) {
2310      robj *o;
2311      mstime_t timeout;
2312      int j;
2313      if (getTimeoutFromObjectOrReply(c,c->argv[c->argc-1],&timeout,UNIT_SECONDS)
2314          != C_OK) return;
2315      for (j = 1; j < c->argc-1; j++) {
2316          o = lookupKeyWrite(c->db,c->argv[j]);
2317          if (o != NULL) {
2318              if (o->type != OBJ_ZSET) {
2319                  addReply(c,shared.wrongtypeerr);
2320                  return;
2321              } else {
2322                  if (zsetLength(o) != 0) {
2323                      genericZpopCommand(c,&c->argv[j],1,where,1,NULL);
2324                      rewriteClientCommandVector(c,2,
2325                          where == ZSET_MAX ? shared.zpopmax : shared.zpopmin,
2326                          c->argv[j]);
2327                      return;
2328                  }
2329              }
2330          }
2331      }
2332      if (c->flags & CLIENT_MULTI) {
2333          addReply(c,shared.nullmultibulk);
2334          return;
2335      }
2336      blockForKeys(c,BLOCKED_ZSET,c->argv + 1,c->argc - 2,timeout,NULL,NULL);
2337  }
2338  void bzpopminCommand(client *c) {
2339      blockingGenericZpopCommand(c,ZSET_MIN);
2340  }
2341  void bzpopmaxCommand(client *c) {
2342      blockingGenericZpopCommand(c,ZSET_MAX);
2343  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_zset.c</div>
                </div>
                <div class="column column_space"><pre><code>295    ConnectIntervals(manager, previous, current);
296  }
297  static WEBP_INLINE void InsertInterval(CostManager* const manager,
298                                         CostInterval* const interval_in,
299                                         float cost, int position, int start,
</pre></code></div>
                <div class="column column_space"><pre><code>941      return 0; &bsol;* No such element found. */
942  }
943  PORT_LONG zsetRank(robj *zobj, sds ele, int reverse) {
944      PORT_ULONG llen;
945      PORT_ULONG rank;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    