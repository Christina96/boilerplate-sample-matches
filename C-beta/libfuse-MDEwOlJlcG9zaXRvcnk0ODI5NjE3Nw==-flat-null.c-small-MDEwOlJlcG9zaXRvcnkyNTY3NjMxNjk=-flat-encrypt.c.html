
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.030576789437109%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-null.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 31
2  #include <fuse.h>
3  #include <fuse_lowlevel.h>
4  #include <stdio.h>
5  #include <stdlib.h>
6  #include <string.h>
7  #include <unistd.h>
8  #include <time.h>
9  #include <errno.h>
<span onclick='openModal()' class='match'>10  static int null_getattr(const char *path, struct stat *stbuf,
11  			struct fuse_file_info *fi)
12  {
13  	(void) fi;
14  	if(strcmp(path, "/") != 0)
15  		return -ENOENT;
16  	stbuf->st_mode = S_IFREG | 0644;
17  	stbuf->st_nlink = 1;
18  	stbuf->st_uid = getuid();
</span>19  	stbuf->st_gid = getgid();
20  	stbuf->st_size = (1ULL << 32); &bsol;* 4G */
21  	stbuf->st_blocks = 0;
22  	stbuf->st_atime = stbuf->st_mtime = stbuf->st_ctime = time(NULL);
23  	return 0;
24  }
25  static int null_truncate(const char *path, off_t size,
26  			 struct fuse_file_info *fi)
27  {
28  	(void) size;
29  	(void) fi;
30  	if(strcmp(path, "/") != 0)
31  		return -ENOENT;
32  	return 0;
33  }
34  static int null_open(const char *path, struct fuse_file_info *fi)
35  {
36  	(void) fi;
37  	if(strcmp(path, "/") != 0)
38  		return -ENOENT;
39  	return 0;
40  }
41  static int null_read(const char *path, char *buf, size_t size,
42  		     off_t offset, struct fuse_file_info *fi)
43  {
44  	(void) buf;
45  	(void) offset;
46  	(void) fi;
47  	if(strcmp(path, "/") != 0)
48  		return -ENOENT;
49  	if (offset >= (1ULL << 32))
50  		return 0;
51  	memset(buf, 0, size);
52  	return size;
53  }
54  static int null_write(const char *path, const char *buf, size_t size,
55  		      off_t offset, struct fuse_file_info *fi)
56  {
57  	(void) buf;
58  	(void) offset;
59  	(void) fi;
60  	if(strcmp(path, "/") != 0)
61  		return -ENOENT;
62  	return size;
63  }
64  static const struct fuse_operations null_oper = {
65  	.getattr	= null_getattr,
66  	.truncate	= null_truncate,
67  	.open		= null_open,
68  	.read		= null_read,
69  	.write		= null_write,
70  };
71  int main(int argc, char *argv[])
72  {
73  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
74  	struct fuse_cmdline_opts opts;
75  	struct stat stbuf;
76  	if (fuse_parse_cmdline(&args, &opts) != 0)
77  		return 1;
78  	fuse_opt_free_args(&args);
79  	if (!opts.mountpoint) {
80  		fprintf(stderr, "missing mountpoint parameter\n");
81  		return 1;
82  	}
83  	if (stat(opts.mountpoint, &stbuf) == -1) {
84  		fprintf(stderr ,"failed to access mountpoint %s: %s\n",
85  			opts.mountpoint, strerror(errno));
86  		free(opts.mountpoint);
87  		return 1;
88  	}
89  	free(opts.mountpoint);
90  	if (!S_ISREG(stbuf.st_mode)) {
91  		fprintf(stderr, "mountpoint is not a regular file\n");
92  		return 1;
93  	}
94  	return fuse_main(argc, argv, &null_oper, NULL);
95  }
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-encrypt.c</h3>
            <pre><code>1  #include <stdint.h>
2  #ifdef HAVE_CONFIG_H
3  #include "config.h"
4  #endif
5  #if defined(USE_CRYPTO_OPENSSL)
6  #include <openssl/md5.h>
7  #include <openssl/rand.h>
8  #include <openssl/hmac.h>
9  #include <openssl/aes.h>
10  #elif defined(USE_CRYPTO_POLARSSL)
11  #include <polarssl/md5.h>
12  #include <polarssl/sha1.h>
13  #include <polarssl/aes.h>
14  #include <polarssl/entropy.h>
15  #include <polarssl/ctr_drbg.h>
16  #include <polarssl/version.h>
17  #define CIPHER_UNSUPPORTED "unsupported"
18  #include <time.h>
19  #ifdef _WIN32
20  #include <windows.h>
21  #include <wincrypt.h>
22  #else
23  #include <stdio.h>
24  #endif
25  #elif defined(USE_CRYPTO_MBEDTLS)
26  #include <mbedtls/md5.h>
27  #include <mbedtls/entropy.h>
28  #include <mbedtls/ctr_drbg.h>
29  #include <mbedtls/version.h>
30  #include <mbedtls/aes.h>
31  #define CIPHER_UNSUPPORTED "unsupported"
32  #include <time.h>
33  #ifdef _WIN32
34  #include <windows.h>
35  #include <wincrypt.h>
36  #else
37  #include <stdio.h>
38  #endif
39  #endif
40  #include <sodium.h>
41  #ifndef __MINGW32__
42  #include <arpa/inet.h>
43  #endif
44  #include "cache.h"
45  #include "encrypt.h"
46  #include "utils.h"
47  #define OFFSET_ROL(p, o) ((uint64_t)(*(p + o)) << (8 * o))
48  static uint8_t *enc_table;
49  static uint8_t *dec_table;
50  static uint8_t enc_key[MAX_KEY_LENGTH];
51  static int enc_key_len;
52  static int enc_iv_len;
53  static int enc_method;
54  static struct cache *iv_cache;
55  #ifdef DEBUG
56  static void
57  dump(char *tag, char *text, int len)
58  {
59      int i;
60      printf("%s: ", tag);
61      for (i = 0; i < len; i++)
62          printf("0x%02x ", (uint8_t)text[i]);
63      printf("\n");
64  }
65  #endif
66  static const char *supported_ciphers[CIPHER_NUM] = {
67      "table",
68      "rc4",
69      "rc4-md5-6",
70      "rc4-md5",
71      "aes-128-cfb",
72      "aes-192-cfb",
73      "aes-256-cfb",
74      "aes-128-ctr",
75      "aes-192-ctr",
76      "aes-256-ctr",
77      "bf-cfb",
78      "camellia-128-cfb",
79      "camellia-192-cfb",
80      "camellia-256-cfb",
81      "cast5-cfb",
82      "des-cfb",
83      "idea-cfb",
84      "rc2-cfb",
85      "seed-cfb",
86      "salsa20",
87      "chacha20",
88      "chacha20-ietf"
89  };
90  #ifdef USE_CRYPTO_POLARSSL
91  static const char *supported_ciphers_polarssl[CIPHER_NUM] = {
92      "table",
93      "ARC4-128",
94      "ARC4-128",
95      "ARC4-128",
96      "AES-128-CFB128",
97      "AES-192-CFB128",
98      "AES-256-CFB128",
99      "AES-128-CTR",
100      "AES-192-CTR",
101      "AES-256-CTR",
102      "BLOWFISH-CFB64",
103      "CAMELLIA-128-CFB128",
104      "CAMELLIA-192-CFB128",
105      "CAMELLIA-256-CFB128",
106      CIPHER_UNSUPPORTED,
107      CIPHER_UNSUPPORTED,
108      CIPHER_UNSUPPORTED,
109      CIPHER_UNSUPPORTED,
110      CIPHER_UNSUPPORTED,
111      "salsa20",
112      "chacha20",
113      "chacha20-ietf"
114  };
115  #endif
116  #ifdef USE_CRYPTO_MBEDTLS
117  static const char *supported_ciphers_mbedtls[CIPHER_NUM] = {
118      "table",
119      "ARC4-128",
120      "ARC4-128",
121      "ARC4-128",
122      "AES-128-CFB128",
123      "AES-192-CFB128",
124      "AES-256-CFB128",
125      "AES-128-CTR",
126      "AES-192-CTR",
127      "AES-256-CTR",
128      "BLOWFISH-CFB64",
129      "CAMELLIA-128-CFB128",
130      "CAMELLIA-192-CFB128",
131      "CAMELLIA-256-CFB128",
132      CIPHER_UNSUPPORTED,
133      CIPHER_UNSUPPORTED,
134      CIPHER_UNSUPPORTED,
135      CIPHER_UNSUPPORTED,
136      CIPHER_UNSUPPORTED,
137      "salsa20",
138      "chacha20",
139      "chacha20-ietf"
140  };
141  #endif
142  #ifdef USE_CRYPTO_APPLECC
143  static const CCAlgorithm supported_ciphers_applecc[CIPHER_NUM] = {
144      kCCAlgorithmInvalid,
145      kCCAlgorithmRC4,
146      kCCAlgorithmRC4,
147      kCCAlgorithmRC4,
148      kCCAlgorithmAES,
149      kCCAlgorithmAES,
150      kCCAlgorithmAES,
151      kCCAlgorithmAES,
152      kCCAlgorithmAES,
153      kCCAlgorithmAES,
154      kCCAlgorithmBlowfish,
155      kCCAlgorithmInvalid,
156      kCCAlgorithmInvalid,
157      kCCAlgorithmInvalid,
158      kCCAlgorithmCAST,
159      kCCAlgorithmDES,
160      kCCAlgorithmInvalid,
161      kCCAlgorithmRC2,
162      kCCAlgorithmInvalid,
163      kCCAlgorithmInvalid,
164      kCCAlgorithmInvalid,
165      kCCAlgorithmInvalid
166  };
167  static const CCMode supported_modes_applecc[CIPHER_NUM] = {
168      kCCAlgorithmInvalid,
169      kCCAlgorithmInvalid,
170      kCCModeRC4,
171      kCCModeRC4,
172      kCCModeCFB,
173      kCCModeCFB,
174      kCCModeCFB,
175      kCCModeCTR,
176      kCCModeCTR,
177      kCCModeCTR,
178      kCCModeCFB,
179      kCCAlgorithmInvalid,
180      kCCAlgorithmInvalid,
181      kCCAlgorithmInvalid,
182      kCCModeCFB,
183      kCCModeCFB,
184      kCCModeCFB,
185      kCCModeCFB,
186      kCCAlgorithmInvalid,
187      kCCAlgorithmInvalid,
188      kCCAlgorithmInvalid,
189      kCCAlgorithmInvalid
190  };
191  #endif
192  static const int supported_ciphers_iv_size[CIPHER_NUM] = {
193      0,  0,  6, 16, 16, 16, 16, 16, 16, 16,  8, 16, 16, 16,  8,  8,  8,  8, 16,  8,  8, 12
194  };
195  static const int supported_ciphers_key_size[CIPHER_NUM] = {
196      0, 16, 16, 16, 16, 24, 32, 16, 24, 32, 16, 16, 24, 32, 16,  8, 16, 16, 16, 32, 32, 32
197  };
198  static int
199  safe_memcmp(const void *s1, const void *s2, size_t n)
200  {
201      const unsigned char *_s1 = (const unsigned char *)s1;
202      const unsigned char *_s2 = (const unsigned char *)s2;
203      int ret                  = 0;
204      size_t i;
205      for (i = 0; i < n; i++)
206          ret |= _s1[i] ^ _s2[i];
207      return !!ret;
208  }
209  int
210  balloc(buffer_t *ptr, size_t capacity)
211  {
212      sodium_memzero(ptr, sizeof(buffer_t));
213      ptr->array    = ss_malloc(capacity);
214      ptr->capacity = capacity;
215      return capacity;
216  }
217  int
218  brealloc(buffer_t *ptr, size_t len, size_t capacity)
219  {
220      if (ptr == NULL)
221          return -1;
222      size_t real_capacity = max(len, capacity);
223      if (ptr->capacity < real_capacity) {
224          ptr->array    = ss_realloc(ptr->array, real_capacity);
225          ptr->capacity = real_capacity;
226      }
227      return real_capacity;
228  }
229  void
230  bfree(buffer_t *ptr)
231  {
232      if (ptr == NULL)
233          return;
234      ptr->idx      = 0;
235      ptr->len      = 0;
236      ptr->capacity = 0;
237      if (ptr->array != NULL) {
238          ss_free(ptr->array);
239      }
240  }
241  static int
242  crypto_stream_xor_ic(uint8_t *c, const uint8_t *m, uint64_t mlen,
243                       const uint8_t *n, uint64_t ic, const uint8_t *k,
244                       int method)
245  {
246      switch (method) {
247      case SALSA20:
248          return crypto_stream_salsa20_xor_ic(c, m, mlen, n, ic, k);
249      case CHACHA20:
250          return crypto_stream_chacha20_xor_ic(c, m, mlen, n, ic, k);
251      case CHACHA20IETF:
252          return crypto_stream_chacha20_ietf_xor_ic(c, m, mlen, n, (uint32_t)ic, k);
253      }
254      return 0;
255  }
256  static int
257  random_compare(const void *_x, const void *_y, uint32_t i,
258                 uint64_t a)
259  {
260      uint8_t x = *((uint8_t *)_x);
261      uint8_t y = *((uint8_t *)_y);
262      return a % (x + i) - a % (y + i);
263  }
264  static void
265  merge(uint8_t *left, int llength, uint8_t *right,
266        int rlength, uint32_t salt, uint64_t key)
267  {
268      uint8_t *ltmp = (uint8_t *)malloc(llength * sizeof(uint8_t));
269      uint8_t *rtmp = (uint8_t *)malloc(rlength * sizeof(uint8_t));
270      uint8_t *ll = ltmp;
271      uint8_t *rr = rtmp;
272      uint8_t *result = left;
273      memcpy(ltmp, left, llength * sizeof(uint8_t));
274      memcpy(rtmp, right, rlength * sizeof(uint8_t));
275      while (llength > 0 && rlength > 0) {
276          if (random_compare(ll, rr, salt, key) <= 0) {
277              *result = *ll;
278              ++ll;
279              --llength;
280          } else {
281              *result = *rr;
282              ++rr;
283              --rlength;
284          }
285          ++result;
286      }
287      if (llength > 0) {
288          while (llength > 0) {
289              *result = *ll;
290              ++result;
291              ++ll;
292              --llength;
293          }
294      } else {
295          while (rlength > 0) {
296              *result = *rr;
297              ++result;
298              ++rr;
299              --rlength;
300          }
301      }
302      ss_free(ltmp);
303      ss_free(rtmp);
304  }
305  static void
306  merge_sort(uint8_t array[], int length,
307             uint32_t salt, uint64_t key)
308  {
309      uint8_t middle;
310      uint8_t *left, *right;
311      int llength;
312      if (length <= 1) {
313          return;
314      }
315      middle = length / 2;
316      llength = length - middle;
317      left  = array;
318      right = array + llength;
319      merge_sort(left, llength, salt, key);
320      merge_sort(right, middle, salt, key);
321      merge(left, llength, right, middle, salt, key);
322  }
323  int
324  enc_get_iv_len()
325  {
326      return enc_iv_len;
327  }
328  uint8_t* enc_get_key()
329  {
330      return enc_key;
331  }
332  int enc_get_key_len()
333  {
334      return enc_key_len;
335  }
336  unsigned char *enc_md5(const unsigned char *d, size_t n, unsigned char *md)
337  {
338  #if defined(USE_CRYPTO_OPENSSL)
339      return MD5(d, n, md);
340  #elif defined(USE_CRYPTO_POLARSSL)
341      static unsigned char m[16];
342      if (md == NULL) {
343          md = m;
344      }
345      md5(d, n, md);
346      return md;
347  #elif defined(USE_CRYPTO_MBEDTLS)
348      static unsigned char m[16];
349      if (md == NULL) {
350          md = m;
351      }
352      mbedtls_md5(d, n, md);
353      return md;
354  #endif
355  }
356  void
357  enc_table_init(const char *pass)
358  {
359      uint32_t i;
360      uint64_t key = 0;
361      uint8_t *digest;
362      enc_table = ss_malloc(256);
363      dec_table = ss_malloc(256);
364      digest = enc_md5((const uint8_t *)pass, strlen(pass), NULL);
365      for (i = 0; i < 8; i++)
366          key += OFFSET_ROL(digest, i);
367      for (i = 0; i < 256; ++i)
368          enc_table[i] = i;
369      for (i = 1; i < 1024; ++i)
370          merge_sort(enc_table, 256, i, key);
371      for (i = 0; i < 256; ++i)
372          dec_table[enc_table[i]] = i;
373  }
374  int
375  cipher_iv_size(const cipher_t *cipher)
376  {
377  #if defined(USE_CRYPTO_OPENSSL)
378      if (cipher->info == NULL)
379          return cipher->iv_len;
380      else
381          return EVP_CIPHER_iv_length(cipher->info);
382  #elif defined(USE_CRYPTO_POLARSSL) || defined(USE_CRYPTO_MBEDTLS)
383      if (cipher == NULL) {
384          return 0;
385      }
386      return cipher->info->iv_size;
387  #endif
388  }
389  int
390  cipher_key_size(const cipher_t *cipher)
391  {
392  #if defined(USE_CRYPTO_OPENSSL)
393      if (cipher->info == NULL)
394          return cipher->key_len;
395      else
396          return EVP_CIPHER_key_length(cipher->info);
397  #elif defined(USE_CRYPTO_POLARSSL)
398      if (cipher == NULL) {
399          return 0;
400      }
401      if (cipher->info->base != NULL && POLARSSL_CIPHER_ID_BLOWFISH ==
402          cipher->info->base->cipher) {
403          return 128 / 8;
404      }
405      return cipher->info->key_length / 8;
406  #elif defined(USE_CRYPTO_MBEDTLS)
407      if (cipher == NULL) {
408          return 0;
409      }
410      return cipher->info->key_bitlen / 8;
411  #endif
412  }
413  void
414  bytes_to_key_with_size(const char *pass, size_t len, uint8_t *md, size_t md_size)
415  {
416      uint8_t result[128];
417      enc_md5((const unsigned char *)pass, len, result);
418      memcpy(md, result, 16);
419      int i = 16;
420      for (; i < md_size; i += 16) {
421          memcpy(result + 16, pass, len);
422          enc_md5(result, 16 + len, result);
423          memcpy(md + i, result, 16);
424      }
425  }
426  int
427  bytes_to_key(const cipher_t *cipher, const digest_type_t *md,
428               const uint8_t *pass, uint8_t *key)
429  {
430      size_t datal;
431      datal = strlen((const char *)pass);
432  #if defined(USE_CRYPTO_OPENSSL)
433      MD5_CTX c;
434      unsigned char md_buf[MAX_MD_SIZE];
435      int nkey;
436      int addmd;
437      unsigned int i, j, mds;
438      mds  = 16;
439      nkey = cipher_key_size(cipher);
440      if (pass == NULL)
441          return nkey;
442      memset(&c, 0, sizeof(MD5_CTX));
443      for (j = 0, addmd = 0; j < nkey; addmd++) {
444          MD5_Init(&c);
445          if (addmd) {
446              MD5_Update(&c, md_buf, mds);
447          }
448          MD5_Update(&c, pass, datal);
449          MD5_Final(md_buf, &c);
450          for (i = 0; i < mds; i++, j++) {
451              if (j >= nkey)
452                  break;
453              key[j] = md_buf[i];
454          }
455      }
456      return nkey;
457  #elif defined(USE_CRYPTO_POLARSSL)
458      md_context_t c;
459      unsigned char md_buf[MAX_MD_SIZE];
460      int nkey;
461      int addmd;
462      unsigned int i, j, mds;
463      nkey = cipher_key_size(cipher);
464      mds  = md_get_size(md);
465      memset(&c, 0, sizeof(md_context_t));
466      if (pass == NULL)
467          return nkey;
468      if (md_init_ctx(&c, md))
469          return 0;
470      for (j = 0, addmd = 0; j < nkey; addmd++) {
471          md_starts(&c);
472          if (addmd) {
473              md_update(&c, md_buf, mds);
474          }
475          md_update(&c, pass, datal);
476          md_finish(&c, md_buf);
477          for (i = 0; i < mds; i++, j++) {
478              if (j >= nkey)
479                  break;
480              key[j] = md_buf[i];
481          }
482      }
483      md_free_ctx(&c);
484      return nkey;
485  #elif defined(USE_CRYPTO_MBEDTLS)
486      mbedtls_md_context_t c;
487      unsigned char md_buf[MAX_MD_SIZE];
488      int nkey;
489      int addmd;
490      unsigned int i, j, mds;
491      nkey = cipher_key_size(cipher);
492      mds  = mbedtls_md_get_size(md);
493      memset(&c, 0, sizeof(mbedtls_md_context_t));
494      if (pass == NULL)
495          return nkey;
496      if (mbedtls_md_setup(&c, md, 1))
497          return 0;
498      for (j = 0, addmd = 0; j < nkey; addmd++) {
499          mbedtls_md_starts(&c);
500          if (addmd) {
501              mbedtls_md_update(&c, md_buf, mds);
502          }
503          mbedtls_md_update(&c, pass, datal);
504          mbedtls_md_finish(&c, &(md_buf[0]));
505          for (i = 0; i < mds; i++, j++) {
506              if (j >= nkey)
507                  break;
508              key[j] = md_buf[i];
509          }
510      }
511      mbedtls_md_free(&c);
512      return nkey;
513  #endif
514  }
515  int
516  rand_bytes(uint8_t *output, int len)
517  {
518      randombytes_buf(output, len);
519      return 0;
520  }
521  const cipher_kt_t *
522  get_cipher_type(int method)
523  {
524      if (method <= TABLE || method >= CIPHER_NUM) {
525          LOGE("get_cipher_type(): Illegal method");
526          return NULL;
527      }
528      if (method == RC4_MD5 || method == RC4_MD5_6) {
529          method = RC4;
530      }
531      if (method >= SALSA20) {
532          return NULL;
533      }
534      const char *ciphername = supported_ciphers[method];
535  #if defined(USE_CRYPTO_OPENSSL)
536      return EVP_get_cipherbyname(ciphername);
537  #elif defined(USE_CRYPTO_POLARSSL)
538      const char *polarname = supported_ciphers_polarssl[method];
539      if (strcmp(polarname, CIPHER_UNSUPPORTED) == 0) {
540          LOGE("Cipher %s currently is not supported by PolarSSL library",
541               ciphername);
542          return NULL;
543      }
544      return cipher_info_from_string(polarname);
545  #elif defined(USE_CRYPTO_MBEDTLS)
546      const char *mbedtlsname = supported_ciphers_mbedtls[method];
547      if (strcmp(mbedtlsname, CIPHER_UNSUPPORTED) == 0) {
548          LOGE("Cipher %s currently is not supported by mbed TLS library",
549               ciphername);
550          return NULL;
551      }
552      return mbedtls_cipher_info_from_string(mbedtlsname);
553  #endif
554  }
555  const digest_type_t *
556  get_digest_type(const char *digest)
557  {
558      if (digest == NULL) {
559          LOGE("get_digest_type(): Digest name is null");
560          return NULL;
561      }
562  #if defined(USE_CRYPTO_OPENSSL)
563      return EVP_get_digestbyname(digest);
564  #elif defined(USE_CRYPTO_POLARSSL)
565      return md_info_from_string(digest);
566  #elif defined(USE_CRYPTO_MBEDTLS)
567      return mbedtls_md_info_from_string(digest);
568  #endif
569  }
570  void
571  cipher_context_init(cipher_ctx_t *ctx, int method, int enc)
572  {
573      if (method <= TABLE || method >= CIPHER_NUM) {
574          LOGE("cipher_context_init(): Illegal method");
575          return;
576      }
577      if (method >= SALSA20) {
578          enc_iv_len = supported_ciphers_iv_size[method];
579          return;
580      }
581      const char *ciphername = supported_ciphers[method];
582  #if defined(USE_CRYPTO_APPLECC)
583      cipher_cc_t *cc = &ctx->cc;
584      cc->cryptor = NULL;
585      cc->cipher  = supported_ciphers_applecc[method];
586      if (cc->cipher == kCCAlgorithmInvalid) {
587          cc->valid = kCCContextInvalid;
588      } else {
589          cc->valid = kCCContextValid;
590          if (cc->cipher == kCCAlgorithmRC4) {
591              cc->mode    = supported_modes_applecc[method];
592              cc->padding = ccNoPadding;
593          } else {
594              cc->mode = supported_modes_applecc[method];
595              if (cc->mode == kCCModeCTR) {
596                  cc->padding = ccNoPadding;
597              } else {
598                  cc->padding = ccPKCS7Padding;
599              }
600          }
601          return;
602      }
603  #endif
604      const cipher_kt_t *cipher = get_cipher_type(method);
605  #if defined(USE_CRYPTO_OPENSSL)
606      ctx->evp = EVP_CIPHER_CTX_new();
607      cipher_evp_t *evp = ctx->evp;
608      if (cipher == NULL) {
609          LOGE("Cipher %s not found in OpenSSL library", ciphername);
610          FATAL("Cannot initialize cipher");
611      }
612      if (!EVP_CipherInit_ex(evp, cipher, NULL, NULL, NULL, enc)) {
613          LOGE("Cannot initialize cipher %s", ciphername);
614          exit(EXIT_FAILURE);
615      }
616      if (!EVP_CIPHER_CTX_set_key_length(evp, enc_key_len)) {
617          EVP_CIPHER_CTX_cleanup(evp);
618          LOGE("Invalid key length: %d", enc_key_len);
619          exit(EXIT_FAILURE);
620      }
621      if (method > RC4_MD5) {
622          EVP_CIPHER_CTX_set_padding(evp, 1);
623      }
624  #elif defined(USE_CRYPTO_POLARSSL)
625      ctx->evp = (cipher_evp_t *)ss_malloc(sizeof(cipher_evp_t));
626      cipher_evp_t *evp = ctx->evp;
627      if (cipher == NULL) {
628          LOGE("Cipher %s not found in PolarSSL library", ciphername);
629          FATAL("Cannot initialize PolarSSL cipher");
630      }
631      if (cipher_init_ctx(evp, cipher) != 0) {
632          FATAL("Cannot initialize PolarSSL cipher context");
633      }
634  #elif defined(USE_CRYPTO_MBEDTLS)
635      ctx->evp = (cipher_evp_t *)ss_malloc(sizeof(cipher_evp_t));
636      cipher_evp_t *evp = ctx->evp;
637      if (cipher == NULL) {
638          LOGE("Cipher %s not found in mbed TLS library", ciphername);
639          FATAL("Cannot initialize mbed TLS cipher");
640      }
641      mbedtls_cipher_init(evp);
642      if (mbedtls_cipher_setup(evp, cipher) != 0) {
643          FATAL("Cannot initialize mbed TLS cipher context");
644      }
645  #endif
646  }
647  void
648  cipher_context_set_iv(cipher_ctx_t *ctx, uint8_t *iv, size_t iv_len,
649                        int enc)
650  {
651      const unsigned char *true_key;
652      if (iv == NULL) {
653          LOGE("cipher_context_set_iv(): IV is null");
654          return;
655      }
656      if (!enc) {
657          memcpy(ctx->iv, iv, iv_len);
658      }
659      if (enc_method >= SALSA20) {
660          return;
661      }
662      if (enc_method == RC4_MD5 || enc_method == RC4_MD5_6) {
663          unsigned char key_iv[32];
664          memcpy(key_iv, enc_key, 16);
665          memcpy(key_iv + 16, iv, iv_len);
666          true_key = enc_md5(key_iv, 16 + iv_len, NULL);
667          iv_len   = 0;
668      } else {
669          true_key = enc_key;
670      }
671  #ifdef USE_CRYPTO_APPLECC
672      cipher_cc_t *cc = &ctx->cc;
673      if (cc->valid == kCCContextValid) {
674          memcpy(cc->iv, iv, iv_len);
675          memcpy(cc->key, true_key, enc_key_len);
676          cc->iv_len  = iv_len;
677          cc->key_len = enc_key_len;
678          cc->encrypt = enc ? kCCEncrypt : kCCDecrypt;
679          if (cc->cryptor != NULL) {
680              CCCryptorRelease(cc->cryptor);
681              cc->cryptor = NULL;
682          }
683          CCCryptorStatus ret;
684          ret = CCCryptorCreateWithMode(
685              cc->encrypt,
686              cc->mode,
687              cc->cipher,
688              cc->padding,
689              cc->iv, cc->key, cc->key_len,
690              NULL, 0, 0, kCCModeOptionCTR_BE,
691              &cc->cryptor);
692          if (ret != kCCSuccess) {
693              if (cc->cryptor != NULL) {
694                  CCCryptorRelease(cc->cryptor);
695                  cc->cryptor = NULL;
696              }
697              FATAL("Cannot set CommonCrypto key and IV");
698          }
699          return;
700      }
701  #endif
702      cipher_evp_t *evp = ctx->evp;
703      if (evp == NULL) {
704          LOGE("cipher_context_set_iv(): Cipher context is null");
705          return;
706      }
707  #if defined(USE_CRYPTO_OPENSSL)
708      if (!EVP_CipherInit_ex(evp, NULL, NULL, true_key, iv, enc)) {
709          EVP_CIPHER_CTX_cleanup(evp);
710          FATAL("Cannot set key and IV");
711      }
712  #elif defined(USE_CRYPTO_POLARSSL)
713      if (cipher_setkey(evp, true_key, enc_key_len * 8, enc) != 0) {
714          cipher_free_ctx(evp);
715          FATAL("Cannot set PolarSSL cipher key");
716      }
717  #if POLARSSL_VERSION_NUMBER >= 0x01030000
718      if (cipher_set_iv(evp, iv, iv_len) != 0) {
719          cipher_free_ctx(evp);
720          FATAL("Cannot set PolarSSL cipher IV");
721      }
722      if (cipher_reset(evp) != 0) {
723          cipher_free_ctx(evp);
724          FATAL("Cannot finalize PolarSSL cipher context");
725      }
726  #else
727      if (cipher_reset(evp, iv) != 0) {
728          cipher_free_ctx(evp);
729          FATAL("Cannot set PolarSSL cipher IV");
730      }
731  #endif
732  #elif defined(USE_CRYPTO_MBEDTLS)
733      if (mbedtls_cipher_setkey(evp, true_key, enc_key_len * 8, enc) != 0) {
734          mbedtls_cipher_free(evp);
735          FATAL("Cannot set mbed TLS cipher key");
736      }
737      if (mbedtls_cipher_set_iv(evp, iv, iv_len) != 0) {
738          mbedtls_cipher_free(evp);
739          FATAL("Cannot set mbed TLS cipher IV");
740      }
741      if (mbedtls_cipher_reset(evp) != 0) {
742          mbedtls_cipher_free(evp);
743          FATAL("Cannot finalize mbed TLS cipher context");
744      }
745  #endif
746  #ifdef DEBUG
747      dump("IV", (char *)iv, iv_len);
748  #endif
749  }
750  void
751  cipher_context_release(cipher_ctx_t *ctx)
752  {
753      if (enc_method >= SALSA20) {
754          return;
755      }
756  #ifdef USE_CRYPTO_APPLECC
757      cipher_cc_t *cc = &ctx->cc;
758      if (cc->cryptor != NULL) {
759          CCCryptorRelease(cc->cryptor);
760          cc->cryptor = NULL;
761      }
762      if (cc->valid == kCCContextValid) {
763          return;
764      }
765  #endif
766  #if defined(USE_CRYPTO_OPENSSL)
767      EVP_CIPHER_CTX_free(ctx->evp);
768  #elif defined(USE_CRYPTO_POLARSSL)
769      cipher_free_ctx(ctx->evp);
770      ss_free(ctx->evp);
771  #elif defined(USE_CRYPTO_MBEDTLS)
772      mbedtls_cipher_free(ctx->evp);
773      ss_free(ctx->evp);
774  #endif
775  }
776  static int
777  cipher_context_update(cipher_ctx_t *ctx, uint8_t *output, size_t *olen,
778                        const uint8_t *input, size_t ilen)
779  {
780  #ifdef USE_CRYPTO_APPLECC
781      cipher_cc_t *cc = &ctx->cc;
782      if (cc->valid == kCCContextValid) {
783          CCCryptorStatus ret;
784          ret = CCCryptorUpdate(cc->cryptor, input, ilen, output,
785                                ilen, olen);
786          return (ret == kCCSuccess) ? 1 : 0;
787      }
788  #endif
789      cipher_evp_t *evp = ctx->evp;
790  #if defined(USE_CRYPTO_OPENSSL)
791      int err = 0, tlen = *olen;
792      err = EVP_CipherUpdate(evp, (uint8_t *)output, &tlen,
793                             (const uint8_t *)input, ilen);
794      *olen = tlen;
795      return err;
796  #elif defined(USE_CRYPTO_POLARSSL)
797      return !cipher_update(evp, (const uint8_t *)input, ilen,
798                            (uint8_t *)output, olen);
799  #elif defined(USE_CRYPTO_MBEDTLS)
800      return !mbedtls_cipher_update(evp, (const uint8_t *)input, ilen,
801                                    (uint8_t *)output, olen);
802  #endif
803  }
804  int ss_md5_hmac(char *auth, char *msg, int msg_len, uint8_t *iv)
805  {
806      uint8_t hash[MD5_BYTES];
807      uint8_t auth_key[MAX_IV_LENGTH + MAX_KEY_LENGTH];
808      memcpy(auth_key, iv, enc_iv_len);
809      memcpy(auth_key + enc_iv_len, enc_key, enc_key_len);
810  #if defined(USE_CRYPTO_OPENSSL)
811      HMAC(EVP_md5(), auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash, NULL);
812  #elif defined(USE_CRYPTO_MBEDTLS)
813      mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_MD5), auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
814  #else
815      md5_hmac(auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
816  #endif
817      memcpy(auth, hash, MD5_BYTES);
818      return 0;
819  }
820  int ss_md5_hmac_with_key(char *auth, char *msg, int msg_len, uint8_t *auth_key, int key_len)
821  {
822      uint8_t hash[MD5_BYTES];
823  #if defined(USE_CRYPTO_OPENSSL)
824      HMAC(EVP_md5(), auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash, NULL);
825  #elif defined(USE_CRYPTO_MBEDTLS)
826      mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_MD5), auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
827  #else
828      md5_hmac(auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
829  #endif
830      memcpy(auth, hash, MD5_BYTES);
831      return 0;
832  }
833  int ss_md5_hash_func(char *auth, char *msg, int msg_len)
834  {
835      uint8_t hash[MD5_BYTES];
836  #if defined(USE_CRYPTO_OPENSSL)
837      MD5((uint8_t *)msg, msg_len, (uint8_t *)hash);
838  #elif defined(USE_CRYPTO_MBEDTLS)
839      mbedtls_md(mbedtls_md_info_from_type(MBEDTLS_MD_MD5), (uint8_t *)msg, msg_len, (uint8_t *)hash);
840  #else
841      md5((uint8_t *)msg, msg_len, (uint8_t *)hash);
842  #endif
843      memcpy(auth, hash, MD5_BYTES);
844      return 0;
845  }
846  int ss_sha1_hmac(char *auth, char *msg, int msg_len, uint8_t *iv)
847  {
848      uint8_t hash[SHA1_BYTES];
849      uint8_t auth_key[MAX_IV_LENGTH + MAX_KEY_LENGTH];
850      memcpy(auth_key, iv, enc_iv_len);
851      memcpy(auth_key + enc_iv_len, enc_key, enc_key_len);
852  #if defined(USE_CRYPTO_OPENSSL)
853      HMAC(EVP_sha1(), auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash, NULL);
854  #elif defined(USE_CRYPTO_MBEDTLS)
855      mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
856  #else
857      sha1_hmac(auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
858  #endif
859      memcpy(auth, hash, SHA1_BYTES);
860      return 0;
861  }
862  int ss_sha1_hmac_with_key(char *auth, char *msg, int msg_len, uint8_t *auth_key, int key_len)
863  {
864      uint8_t hash[SHA1_BYTES];
865  #if defined(USE_CRYPTO_OPENSSL)
866      HMAC(EVP_sha1(), auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash, NULL);
867  #elif defined(USE_CRYPTO_MBEDTLS)
868      mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
869  #else
870      sha1_hmac(auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
871  #endif
872      memcpy(auth, hash, SHA1_BYTES);
873      return 0;
874  }
875  int ss_sha1_hash_func(char *auth, char *msg, int msg_len)
876  {
877      uint8_t hash[SHA1_BYTES];
878  #if defined(USE_CRYPTO_OPENSSL)
879      SHA1((uint8_t *)msg, msg_len, (uint8_t *)hash);
880  #elif defined(USE_CRYPTO_MBEDTLS)
881      mbedtls_md(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), (uint8_t *)msg, msg_len, (uint8_t *)hash);
882  #else
883      sha1((uint8_t *)msg, msg_len, (uint8_t *)hash);
884  #endif
885      memcpy(auth, hash, SHA1_BYTES);
886      return 0;
887  }
888  int ss_aes_128_cbc(char *encrypt, char *out_data, char *key)
889  {
890      unsigned char iv[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
891  #if defined(USE_CRYPTO_OPENSSL)
892      AES_KEY aes;
893      AES_set_encrypt_key((unsigned char*)key, 128, &aes);
894      AES_cbc_encrypt((const unsigned char *)encrypt, (unsigned char *)out_data, 16, &aes, iv, AES_ENCRYPT);
895  #elif defined(USE_CRYPTO_MBEDTLS)
896      mbedtls_aes_context aes;
897      unsigned char output[16];
898      mbedtls_aes_setkey_enc( &aes, (unsigned char *)key, 128 );
899      mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );
900      memcpy(out_data, output, 16);
901  #else
902      aes_context aes;
903      unsigned char output[16];
904      aes_setkey_enc( &aes, (unsigned char *)key, 128 );
905      aes_crypt_cbc( &aes, AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );
906      memcpy(out_data, output, 16);
907  #endif
908      return 0;
909  }
910  int ss_onetimeauth(buffer_t *buf, uint8_t *iv, size_t capacity)
911  {
912      uint8_t hash[ONETIMEAUTH_BYTES * 2];
913      uint8_t auth_key[MAX_IV_LENGTH + MAX_KEY_LENGTH];
914      memcpy(auth_key, iv, enc_iv_len);
915      memcpy(auth_key + enc_iv_len, enc_key, enc_key_len);
916      brealloc(buf, ONETIMEAUTH_BYTES + buf->len, capacity);
917  #if defined(USE_CRYPTO_OPENSSL)
918      HMAC(EVP_sha1(), auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, buf->len, (uint8_t *)hash, NULL);
919  #elif defined(USE_CRYPTO_MBEDTLS)
920      mbedtls_md_hmac(mbedtls_md_info_from_type(
921                          MBEDTLS_MD_SHA1), auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, buf->len,
922                      (uint8_t *)hash);
923  #else
924      sha1_hmac(auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, buf->len, (uint8_t *)hash);
925  #endif
926      memcpy(buf->array + buf->len, hash, ONETIMEAUTH_BYTES);
927      buf->len += ONETIMEAUTH_BYTES;
928      return 0;
929  }
930  int
931  ss_onetimeauth_verify(buffer_t *buf, uint8_t *iv)
932  {
933      uint8_t hash[ONETIMEAUTH_BYTES * 2];
934      uint8_t auth_key[MAX_IV_LENGTH + MAX_KEY_LENGTH];
935      memcpy(auth_key, iv, enc_iv_len);
936      memcpy(auth_key + enc_iv_len, enc_key, enc_key_len);
937      size_t len = buf->len - ONETIMEAUTH_BYTES;
938  #if defined(USE_CRYPTO_OPENSSL)
939      HMAC(EVP_sha1(), auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, len, hash, NULL);
940  #elif defined(USE_CRYPTO_MBEDTLS)
941      mbedtls_md_hmac(mbedtls_md_info_from_type(
942                          MBEDTLS_MD_SHA1), auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, len, hash);
943  #else
944      sha1_hmac(auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, len, hash);
945  #endif
946      return safe_memcmp(buf->array + len, hash, ONETIMEAUTH_BYTES);
947  }
948  int
949  ss_encrypt_all(buffer_t *plain, int method, int auth, size_t capacity)
950  {
951      if (method > TABLE) {
952          cipher_ctx_t evp;
953          cipher_context_init(&evp, method, 1);
954          size_t iv_len = enc_iv_len;
955          int err       = 1;
956          static buffer_t tmp = { 0, 0, 0, NULL };
957          brealloc(&tmp, iv_len + plain->len, capacity);
958          buffer_t *cipher = &tmp;
959          cipher->len = plain->len;
960          uint8_t iv[MAX_IV_LENGTH];
961          rand_bytes(iv, iv_len);
962          cipher_context_set_iv(&evp, iv, iv_len, 1);
963          memcpy(cipher->array, iv, iv_len);
964          if (auth) {
965              ss_onetimeauth(plain, iv, capacity);
966              cipher->len = plain->len;
967          }
968          if (method >= SALSA20) {
969              crypto_stream_xor_ic((uint8_t *)(cipher->array + iv_len),
970                                   (const uint8_t *)plain->array, (uint64_t)(plain->len),
971                                   (const uint8_t *)iv,
972                                   0, enc_key, method);
973          } else {
974              err = cipher_context_update(&evp, (uint8_t *)(cipher->array + iv_len),
975                                          &cipher->len, (const uint8_t *)plain->array,
976                                          plain->len);
977          }
978          if (!err) {
979              bfree(plain);
980              cipher_context_release(&evp);
981              return -1;
982          }
983  #ifdef DEBUG
984          dump("PLAIN", plain->array, plain->len);
985          dump("CIPHER", cipher->array + iv_len, cipher->len);
986  #endif
987          cipher_context_release(&evp);
988          brealloc(plain, iv_len + cipher->len, capacity);
989          memcpy(plain->array, cipher->array, iv_len + cipher->len);
990          plain->len = iv_len + cipher->len;
991          return 0;
992      } else {
993          char *begin = plain->array;
994          char *ptr   = plain->array;
995          while (ptr < begin + plain->len) {
996              *ptr = (char)enc_table[(uint8_t)*ptr];
997              ptr++;
998          }
999          return 0;
1000      }
1001  }
1002  int
1003  ss_encrypt(buffer_t *plain, enc_ctx_t *ctx, size_t capacity)
1004  {
1005      if (ctx != NULL) {
1006          static buffer_t tmp = { 0, 0, 0, NULL };
1007          int err       = 1;
1008          size_t iv_len = 0;
1009          if (!ctx->init) {
1010              iv_len = enc_iv_len;
1011          }
1012          brealloc(&tmp, iv_len + plain->len, capacity);
1013          buffer_t *cipher = &tmp;
1014          cipher->len = plain->len;
1015          if (!ctx->init) {
1016              cipher_context_set_iv(&ctx->evp, ctx->evp.iv, iv_len, 1);
1017              memcpy(cipher->array, ctx->evp.iv, iv_len);
1018              ctx->counter = 0;
1019              ctx->init    = 1;
1020          }
1021          if (enc_method >= SALSA20) {
1022              int padding = ctx->counter % SODIUM_BLOCK_SIZE;
1023              brealloc(cipher, iv_len + (padding + cipher->len) * 2, capacity);
1024              if (padding) {
1025                  brealloc(plain, plain->len + padding, capacity);
1026                  memmove(plain->array + padding, plain->array, plain->len);
1027                  sodium_memzero(plain->array, padding);
1028              }
1029              crypto_stream_xor_ic((uint8_t *)(cipher->array + iv_len),
1030                                   (const uint8_t *)plain->array,
1031                                   (uint64_t)(plain->len + padding),
1032                                   (const uint8_t *)ctx->evp.iv,
1033                                   ctx->counter / SODIUM_BLOCK_SIZE, enc_key,
1034                                   enc_method);
1035              ctx->counter += plain->len;
1036              if (padding) {
1037                  memmove(cipher->array + iv_len,
1038                          cipher->array + iv_len + padding, cipher->len);
1039              }
1040          } else {
1041              err =
1042                  cipher_context_update(&ctx->evp,
1043                                        (uint8_t *)(cipher->array + iv_len),
1044                                        &cipher->len, (const uint8_t *)plain->array,
1045                                        plain->len);
1046              if (!err) {
1047                  return -1;
1048              }
1049          }
1050  #ifdef DEBUG
1051          dump("PLAIN", plain->array, plain->len);
1052          dump("CIPHER", cipher->array + iv_len, cipher->len);
1053  #endif
1054          brealloc(plain, iv_len + cipher->len, capacity);
1055          memcpy(plain->array, cipher->array, iv_len + cipher->len);
1056          plain->len = iv_len + cipher->len;
1057          return 0;
1058      } else {
1059          char *begin = plain->array;
1060          char *ptr   = plain->array;
1061          while (ptr < begin + plain->len) {
1062              *ptr = (char)enc_table[(uint8_t)*ptr];
1063              ptr++;
1064          }
1065          return 0;
1066      }
1067  }
1068  int
1069  ss_decrypt_all(buffer_t *cipher, int method, int auth, size_t capacity)
1070  {
1071      if (method > TABLE) {
1072          size_t iv_len = enc_iv_len;
1073          int ret       = 1;
1074          if (cipher->len <= iv_len) {
1075              return -1;
1076          }
1077          cipher_ctx_t evp;
1078          cipher_context_init(&evp, method, 0);
1079          static buffer_t tmp = { 0, 0, 0, NULL };
1080          brealloc(&tmp, cipher->len, capacity);
1081          buffer_t *plain = &tmp;
1082          plain->len = cipher->len - iv_len;
1083          uint8_t iv[MAX_IV_LENGTH];
1084          memcpy(iv, cipher->array, iv_len);
1085          cipher_context_set_iv(&evp, iv, iv_len, 0);
1086          if (method >= SALSA20) {
1087              crypto_stream_xor_ic((uint8_t *)plain->array,
1088                                   (const uint8_t *)(cipher->array + iv_len),
1089                                   (uint64_t)(cipher->len - iv_len),
1090                                   (const uint8_t *)iv, 0, enc_key, method);
1091          } else {
1092              ret = cipher_context_update(&evp, (uint8_t *)plain->array, &plain->len,
1093                                          (const uint8_t *)(cipher->array + iv_len),
1094                                          cipher->len - iv_len);
1095          }
1096          if (auth || (plain->array[0] & ONETIMEAUTH_FLAG)) {
1097              if (plain->len > ONETIMEAUTH_BYTES) {
1098                  ret = !ss_onetimeauth_verify(plain, iv);
1099                  if (ret) {
1100                      plain->len -= ONETIMEAUTH_BYTES;
1101                  }
1102              } else {
1103                  ret = 0;
1104              }
1105          }
1106          if (!ret) {
1107              bfree(cipher);
1108              cipher_context_release(&evp);
1109              return -1;
1110          }
1111  #ifdef DEBUG
1112          dump("PLAIN", plain->array, plain->len);
1113          dump("CIPHER", cipher->array + iv_len, cipher->len - iv_len);
1114  #endif
1115          cipher_context_release(&evp);
1116          brealloc(cipher, plain->len, capacity);
1117          memcpy(cipher->array, plain->array, plain->len);
1118          cipher->len = plain->len;
1119          return 0;
1120      } else {
1121          char *begin = cipher->array;
1122          char *ptr   = cipher->array;
1123          while (ptr < begin + cipher->len) {
1124              *ptr = (char)dec_table[(uint8_t)*ptr];
1125              ptr++;
1126          }
1127          return 0;
1128      }
1129  }
1130  int
1131  ss_decrypt(buffer_t *cipher, enc_ctx_t *ctx, size_t capacity)
1132  {
1133      if (ctx != NULL) {
1134          static buffer_t tmp = { 0, 0, 0, NULL };
1135          size_t iv_len = 0;
1136          int err       = 1;
1137          brealloc(&tmp, cipher->len, capacity);
1138          buffer_t *plain = &tmp;
1139          plain->len = cipher->len;
1140          if (!ctx->init) {
1141              uint8_t iv[MAX_IV_LENGTH];
1142              iv_len      = enc_iv_len;
1143              plain->len -= iv_len;
1144              memcpy(iv, cipher->array, iv_len);
1145              cipher_context_set_iv(&ctx->evp, iv, iv_len, 0);
1146              ctx->counter = 0;
1147              ctx->init    = 1;
1148              if (enc_method > RC4) {
1149                  if (cache_key_exist(iv_cache, (char *)iv, iv_len)) {
1150                      bfree(cipher);
1151                      return -1;
1152                  } else {
1153                      cache_insert(iv_cache, (char *)iv, iv_len, NULL);
1154                  }
1155              }
1156          }
1157          if (enc_method >= SALSA20) {
1158              int padding = ctx->counter % SODIUM_BLOCK_SIZE;
1159              brealloc(plain, (plain->len + padding) * 2, capacity);
1160              if (padding) {
1161                  brealloc(cipher, cipher->len + padding, capacity);
1162                  memmove(cipher->array + iv_len + padding, cipher->array + iv_len,
1163                          cipher->len - iv_len);
1164                  sodium_memzero(cipher->array + iv_len, padding);
1165              }
1166              crypto_stream_xor_ic((uint8_t *)plain->array,
1167                                   (const uint8_t *)(cipher->array + iv_len),
1168                                   (uint64_t)(cipher->len - iv_len + padding),
1169                                   (const uint8_t *)ctx->evp.iv,
1170                                   ctx->counter / SODIUM_BLOCK_SIZE, enc_key,
1171                                   enc_method);
1172              ctx->counter += cipher->len - iv_len;
1173              if (padding) {
1174                  memmove(plain->array, plain->array + padding, plain->len);
1175              }
1176          } else {
1177              err = cipher_context_update(&ctx->evp, (uint8_t *)plain->array, &plain->len,
1178                                          (const uint8_t *)(cipher->array + iv_len),
1179                                          cipher->len - iv_len);
1180          }
1181          if (!err) {
1182              bfree(cipher);
1183              return -1;
1184          }
1185  #ifdef DEBUG
1186          dump("PLAIN", plain->array, plain->len);
1187          dump("CIPHER", cipher->array + iv_len, cipher->len - iv_len);
1188  #endif
1189          brealloc(cipher, plain->len, capacity);
1190          memcpy(cipher->array, plain->array, plain->len);
1191          cipher->len = plain->len;
1192          return 0;
1193      } else {
1194          char *begin = cipher->array;
1195          char *ptr   = cipher->array;
1196          while (ptr < begin + cipher->len) {
1197              *ptr = (char)dec_table[(uint8_t)*ptr];
1198              ptr++;
1199          }
1200          return 0;
1201      }
1202  }
1203  void
1204  enc_ctx_init(int method, enc_ctx_t *ctx, int enc)
1205  {
1206      sodium_memzero(ctx, sizeof(enc_ctx_t));
1207      cipher_context_init(&ctx->evp, method, enc);
1208      if (enc) {
1209          rand_bytes(ctx->evp.iv, enc_iv_len);
1210      }
1211  }
1212  void
1213  enc_key_init(int method, const char *pass)
1214  {
1215      if (method <= TABLE || method >= CIPHER_NUM) {
1216          LOGE("enc_key_init(): Illegal method");
1217          return;
1218      }
1219      cache_create(&iv_cache, 256, NULL);
1220  #if defined(USE_CRYPTO_OPENSSL)
1221      OpenSSL_add_all_algorithms();
1222  #else
1223      cipher_kt_t cipher_info;
1224  #endif
1225      cipher_t cipher;
1226      memset(&cipher, 0, sizeof(cipher_t));
1227      if (sodium_init() == -1) {
1228          FATAL("Failed to initialize sodium");
1229      }
1230      if (method == SALSA20 || method == CHACHA20 || method == CHACHA20IETF) {
1231  #if defined(USE_CRYPTO_OPENSSL)
1232          cipher.info    = NULL;
1233          cipher.key_len = supported_ciphers_key_size[method];
1234          cipher.iv_len  = supported_ciphers_iv_size[method];
1235  #endif
1236  #if defined(USE_CRYPTO_POLARSSL)
1237          cipher.info             = &cipher_info;
1238          cipher.info->base       = NULL;
1239          cipher.info->key_length = supported_ciphers_key_size[method] * 8;
1240          cipher.info->iv_size    = supported_ciphers_iv_size[method];
1241  #endif
1242  #if defined(USE_CRYPTO_MBEDTLS)
1243          cipher.info             = &cipher_info;
1244          cipher.info->base       = NULL;
1245          cipher.info->key_bitlen = supported_ciphers_key_size[method] * 8;
1246          cipher.info->iv_size    = supported_ciphers_iv_size[method];
1247  #endif
1248      } else {
1249          cipher.info = (cipher_kt_t *)get_cipher_type(method);
1250      }
1251      if (cipher.info == NULL && cipher.key_len == 0) {
1252          do {
1253  #if defined(USE_CRYPTO_POLARSSL) && defined(USE_CRYPTO_APPLECC)
1254              if (supported_ciphers_applecc[method] != kCCAlgorithmInvalid) {
1255                  cipher_info.base       = NULL;
1256                  cipher_info.key_length = supported_ciphers_key_size[method] * 8;
1257                  cipher_info.iv_size    = supported_ciphers_iv_size[method];
1258                  cipher.info            = (cipher_kt_t *)&cipher_info;
1259                  break;
1260              }
1261  #endif
1262  #if defined(USE_CRYPTO_MBEDTLS) && defined(USE_CRYPTO_APPLECC)
1263              if (supported_ciphers_applecc[method] != kCCAlgorithmInvalid) {
1264                  cipher_info.base       = NULL;
1265                  cipher_info.key_bitlen = supported_ciphers_key_size[method] * 8;
1266                  cipher_info.iv_size    = supported_ciphers_iv_size[method];
1267                  cipher.info            = (cipher_kt_t *)&cipher_info;
1268                  break;
1269              }
1270  #endif
1271              LOGE("Cipher %s not found in crypto library", supported_ciphers[method]);
1272              FATAL("Cannot initialize cipher");
1273          } while (0);
1274      }
1275      const digest_type_t *md = get_digest_type("MD5");
1276      if (md == NULL) {
1277          FATAL("MD5 Digest not found in crypto library");
1278      }
1279      enc_key_len = bytes_to_key(&cipher, md, (const uint8_t *)pass, enc_key);
1280      if (enc_key_len == 0) {
1281          FATAL("Cannot generate key and IV");
1282      }
1283      if (method == RC4_MD5 || method == RC4_MD5_6) {
1284          enc_iv_len = supported_ciphers_iv_size[method];
1285      } else {
1286          enc_iv_len = cipher_iv_size(&cipher);
1287      }
1288      enc_method = method;
1289  }
1290  int
1291  enc_init(const char *pass, const char *method)
1292  {
1293      int m = TABLE;
1294      if (method != NULL) {
1295          for (m = TABLE; m < CIPHER_NUM; m++)
1296              if (strcmp(method, supported_ciphers[m]) == 0) {
1297                  break;
1298              }
1299          if (m >= CIPHER_NUM) {
1300              LOGE("Invalid cipher name: %s, use rc4-md5 instead", method);
1301              m = RC4_MD5;
1302          }
1303      }
1304      if (m == TABLE) {
1305          enc_table_init(pass);
1306      } else {
1307          enc_key_init(m, pass);
1308      }
1309      return m;
1310  }
1311  int
1312  ss_check_hash(buffer_t *buf, chunk_t *chunk, enc_ctx_t *ctx, size_t capacity)
1313  {
1314      int i, j, k;
1315      ssize_t blen  = buf->len;
1316      uint32_t cidx = chunk->idx;
1317      brealloc(chunk->buf, chunk->len + blen, capacity);
1318      brealloc(buf, chunk->len + blen, capacity);
1319      for (i = 0, j = 0, k = 0; i < blen; i++) {
1320          chunk->buf->array[cidx++] = buf->array[k++];
1321          if (cidx == CLEN_BYTES) {
1322              uint16_t clen = ntohs(*((uint16_t *)chunk->buf->array));
1323              brealloc(chunk->buf, clen + AUTH_BYTES, capacity);
1324              chunk->len = clen;
1325          }
1326          if (cidx == chunk->len + AUTH_BYTES) {
1327              uint8_t hash[ONETIMEAUTH_BYTES * 2];
1328              uint8_t key[MAX_IV_LENGTH + sizeof(uint32_t)];
1329              uint32_t c = htonl(chunk->counter);
1330              memcpy(key, ctx->evp.iv, enc_iv_len);
1331              memcpy(key + enc_iv_len, &c, sizeof(uint32_t));
1332  #if defined(USE_CRYPTO_OPENSSL)
1333              HMAC(EVP_sha1(), key, enc_iv_len + sizeof(uint32_t),
1334                   (uint8_t *)chunk->buf->array + AUTH_BYTES, chunk->len, hash, NULL);
1335  #elif defined(USE_CRYPTO_MBEDTLS)
1336              mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), key, enc_iv_len + sizeof(uint32_t),
<span onclick='openModal()' class='match'>1337                              (uint8_t *)chunk->buf->array + AUTH_BYTES, chunk->len, hash);
1338  #else
1339              sha1_hmac(key, enc_iv_len + sizeof(uint32_t),
1340                        (uint8_t *)chunk->buf->array + AUTH_BYTES, chunk->len, hash);
1341  #endif
1342              if (safe_memcmp(hash, chunk->buf->array + CLEN_BYTES, ONETIMEAUTH_BYTES) != 0) {
1343                  return 0;
1344              }
1345              memmove(buf->array + j + chunk->len, buf->array + k, blen - i - 1);
1346              memcpy(buf->array + j, chunk->buf->array + AUTH_BYTES, chunk->len);
1347              j   += chunk->len;
1348              k    = j;
1349              cidx = 0;
</span>1350              chunk->counter++;
1351          }
1352      }
1353      buf->len   = j;
1354      chunk->idx = cidx;
1355      return 1;
1356  }
1357  int
1358  ss_gen_hash(buffer_t *buf, uint32_t *counter, enc_ctx_t *ctx, size_t capacity)
1359  {
1360      ssize_t blen       = buf->len;
1361      uint16_t chunk_len = htons((uint16_t)blen);
1362      uint8_t hash[ONETIMEAUTH_BYTES * 2];
1363      uint8_t key[MAX_IV_LENGTH + sizeof(uint32_t)];
1364      uint32_t c = htonl(*counter);
1365      brealloc(buf, AUTH_BYTES + blen, capacity);
1366      memcpy(key, ctx->evp.iv, enc_iv_len);
1367      memcpy(key + enc_iv_len, &c, sizeof(uint32_t));
1368  #if defined(USE_CRYPTO_OPENSSL)
1369      HMAC(EVP_sha1(), key, enc_iv_len + sizeof(uint32_t), (uint8_t *)buf->array, blen, hash, NULL);
1370  #elif defined(USE_CRYPTO_MBEDTLS)
1371      mbedtls_md_hmac(mbedtls_md_info_from_type(
1372                          MBEDTLS_MD_SHA1), key, enc_iv_len + sizeof(uint32_t), (uint8_t *)buf->array, blen, hash);
1373  #else
1374      sha1_hmac(key, enc_iv_len + sizeof(uint32_t), (uint8_t *)buf->array, blen, hash);
1375  #endif
1376      memmove(buf->array + AUTH_BYTES, buf->array, blen);
1377      memcpy(buf->array + CLEN_BYTES, hash, ONETIMEAUTH_BYTES);
1378      memcpy(buf->array, &chunk_len, CLEN_BYTES);
1379      *counter = *counter + 1;
1380      buf->len = blen + AUTH_BYTES;
1381      return 0;
1382  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-null.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-encrypt.c</div>
                </div>
                <div class="column column_space"><pre><code>10  static int null_getattr(const char *path, struct stat *stbuf,
11  			struct fuse_file_info *fi)
12  {
13  	(void) fi;
14  	if(strcmp(path, "/") != 0)
15  		return -ENOENT;
16  	stbuf->st_mode = S_IFREG | 0644;
17  	stbuf->st_nlink = 1;
18  	stbuf->st_uid = getuid();
</pre></code></div>
                <div class="column column_space"><pre><code>1337                              (uint8_t *)chunk->buf->array + AUTH_BYTES, chunk->len, hash);
1338  #else
1339              sha1_hmac(key, enc_iv_len + sizeof(uint32_t),
1340                        (uint8_t *)chunk->buf->array + AUTH_BYTES, chunk->len, hash);
1341  #endif
1342              if (safe_memcmp(hash, chunk->buf->array + CLEN_BYTES, ONETIMEAUTH_BYTES) != 0) {
1343                  return 0;
1344              }
1345              memmove(buf->array + j + chunk->len, buf->array + k, blen - i - 1);
1346              memcpy(buf->array + j, chunk->buf->array + AUTH_BYTES, chunk->len);
1347              j   += chunk->len;
1348              k    = j;
1349              cidx = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    