
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.221932114882506%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-argb_mips_dsp_r2.c</h3>
            <pre><code>1  #include "./dsp.h"
2  #if defined(WEBP_USE_MIPS_DSP_R2)
3  static void PackARGB(const uint8_t* a, const uint8_t* r, const uint8_t* g,
4                       const uint8_t* b, int len, uint32_t* out) {
5    int temp0, temp1, temp2, temp3, offset;
6    const int rest = len & 1;
7    const uint32_t* const loop_end = out + len - rest;
8    const int step = 4;
9    __asm__ volatile (
10      "xor          %[offset],   %[offset], %[offset]    \n\t"
11      "beq          %[loop_end], %[out],    0f           \n\t"
12    "2:                                                  \n\t"
13      "lbux         %[temp0],    %[offset](%[a])         \n\t"
14      "lbux         %[temp1],    %[offset](%[r])         \n\t"
15      "lbux         %[temp2],    %[offset](%[g])         \n\t"
16      "lbux         %[temp3],    %[offset](%[b])         \n\t"
17      "ins          %[temp1],    %[temp0],  16,     16   \n\t"
18      "ins          %[temp3],    %[temp2],  16,     16   \n\t"
19      "addiu        %[out],      %[out],    4            \n\t"
20      "precr.qb.ph  %[temp0],    %[temp1],  %[temp3]     \n\t"
21      "sw           %[temp0],    -4(%[out])              \n\t"
22      "addu         %[offset],   %[offset], %[step]      \n\t"
23      "bne          %[loop_end], %[out],    2b           \n\t"
24    "0:                                                  \n\t"
25      "beq          %[rest],     $zero,     1f           \n\t"
26      "lbux         %[temp0],    %[offset](%[a])         \n\t"
27      "lbux         %[temp1],    %[offset](%[r])         \n\t"
28      "lbux         %[temp2],    %[offset](%[g])         \n\t"
29      "lbux         %[temp3],    %[offset](%[b])         \n\t"
30      "ins          %[temp1],    %[temp0],  16,     16   \n\t"
31      "ins          %[temp3],    %[temp2],  16,     16   \n\t"
32      "precr.qb.ph  %[temp0],    %[temp1],  %[temp3]     \n\t"
33      "sw           %[temp0],    0(%[out])               \n\t"
34    "1:                                                  \n\t"
35      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
36        [temp3]"=&r"(temp3), [offset]"=&r"(offset), [out]"+&r"(out)
37      : [a]"r"(a), [r]"r"(r), [g]"r"(g), [b]"r"(b), [step]"r"(step),
38        [loop_end]"r"(loop_end), [rest]"r"(rest)
39      : "memory"
40    );
41  }
<span onclick='openModal()' class='match'>42  static void PackRGB(const uint8_t* r, const uint8_t* g, const uint8_t* b,
43                      int len, int step, uint32_t* out) {
44    int temp0, temp1, temp2, offset;
45    const int rest = len & 1;
46    const int a = 0xff;
47    const uint32_t* const loop_end = out + len - rest;
</span>48    __asm__ volatile (
49      "xor          %[offset],   %[offset], %[offset]    \n\t"
50      "beq          %[loop_end], %[out],    0f           \n\t"
51    "2:                                                  \n\t"
52      "lbux         %[temp0],    %[offset](%[r])         \n\t"
53      "lbux         %[temp1],    %[offset](%[g])         \n\t"
54      "lbux         %[temp2],    %[offset](%[b])         \n\t"
55      "ins          %[temp0],    %[a],      16,     16   \n\t"
56      "ins          %[temp2],    %[temp1],  16,     16   \n\t"
57      "addiu        %[out],      %[out],    4            \n\t"
58      "precr.qb.ph  %[temp0],    %[temp0],  %[temp2]     \n\t"
59      "sw           %[temp0],    -4(%[out])              \n\t"
60      "addu         %[offset],   %[offset], %[step]      \n\t"
61      "bne          %[loop_end], %[out],    2b           \n\t"
62    "0:                                                  \n\t"
63      "beq          %[rest],     $zero,     1f           \n\t"
64      "lbux         %[temp0],    %[offset](%[r])         \n\t"
65      "lbux         %[temp1],    %[offset](%[g])         \n\t"
66      "lbux         %[temp2],    %[offset](%[b])         \n\t"
67      "ins          %[temp0],    %[a],      16,     16   \n\t"
68      "ins          %[temp2],    %[temp1],  16,     16   \n\t"
69      "precr.qb.ph  %[temp0],    %[temp0],  %[temp2]     \n\t"
70      "sw           %[temp0],    0(%[out])               \n\t"
71    "1:                                                  \n\t"
72      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
73        [offset]"=&r"(offset), [out]"+&r"(out)
74      : [a]"r"(a), [r]"r"(r), [g]"r"(g), [b]"r"(b), [step]"r"(step),
75        [loop_end]"r"(loop_end), [rest]"r"(rest)
76      : "memory"
77    );
78  }
79  extern void VP8EncDspARGBInitMIPSdspR2(void);
80  WEBP_TSAN_IGNORE_FUNCTION void VP8EncDspARGBInitMIPSdspR2(void) {
81    VP8PackARGB = PackARGB;
82    VP8PackRGB = PackRGB;
83  }
84  #else  
85  WEBP_DSP_INIT_STUB(VP8EncDspARGBInitMIPSdspR2)
86  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-tls1.2_ticket.c</h3>
            <pre><code>1  #include "tls1.2_ticket.h"
2  #include "list.c"
3  typedef struct tls12_ticket_auth_global_data {
4      uint8_t local_client_id[32];
5      List client_data;
6      time_t startup_time;
7  }tls12_ticket_auth_global_data;
8  typedef struct tls12_ticket_auth_local_data {
9      int handshake_status;
10      char *send_buffer;
11      int send_buffer_size;
12      char *recv_buffer;
13      int recv_buffer_size;
14  }tls12_ticket_auth_local_data;
15  void tls12_ticket_auth_local_data_init(tls12_ticket_auth_local_data* local) {
16      local->handshake_status = 0;
17      local->send_buffer = malloc(0);
18      local->send_buffer_size = 0;
19      local->recv_buffer = malloc(0);
20      local->recv_buffer_size = 0;
21  }
22  void * tls12_ticket_auth_init_data() {
23      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)malloc(sizeof(tls12_ticket_auth_global_data));
24      rand_bytes(global->local_client_id, 32);
25      global->client_data = list_init(22);
26      global->startup_time = time(NULL);
27      return global;
28  }
29  obfs * tls12_ticket_auth_new_obfs() {
30      obfs * self = new_obfs();
31      self->l_data = malloc(sizeof(tls12_ticket_auth_local_data));
32      tls12_ticket_auth_local_data_init((tls12_ticket_auth_local_data*)self->l_data);
33      return self;
34  }
35  void tls12_ticket_auth_dispose(obfs *self) {
36      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
37      if (local->send_buffer != NULL) {
38          free(local->send_buffer);
39          local->send_buffer = NULL;
40      }
41      if (local->recv_buffer != NULL) {
42          free(local->recv_buffer);
43          local->recv_buffer = NULL;
44      }
45      free(local);
46      dispose_obfs(self);
47  }
48  int tls12_ticket_pack_auth_data(tls12_ticket_auth_global_data *global, server_info *server, char *outdata) {
49      int out_size = 32;
50      time_t t = time(NULL);
51      outdata[0] = t >> 24;
52      outdata[1] = t >> 16;
53      outdata[2] = t >> 8;
54      outdata[3] = t;
55      rand_bytes((uint8_t*)outdata + 4, 18);
56      uint8_t *key = (uint8_t*)malloc(server->key_len + 32);
57      char hash[ONETIMEAUTH_BYTES * 2];
58      memcpy(key, server->key, server->key_len);
59      memcpy(key + server->key_len, global->local_client_id, 32);
60      ss_sha1_hmac_with_key(hash, outdata, out_size - OBFS_HMAC_SHA1_LEN, key, server->key_len + 32);
61      free(key);
62      memcpy(outdata + out_size - OBFS_HMAC_SHA1_LEN, hash, OBFS_HMAC_SHA1_LEN);
63      return out_size;
64  }
65  void tls12_ticket_auth_pack_data(char *encryptdata, int datalength, int start, int len, char *out_buffer, int outlength) {
66      out_buffer[outlength] = 0x17;
67      out_buffer[outlength + 1] = 0x3;
68      out_buffer[outlength + 2] = 0x3;
69      out_buffer[outlength + 3] = len >> 8;
70      out_buffer[outlength + 4] = len;
71      memcpy(out_buffer + outlength + 5, encryptdata + start, len);
72  }
73  int tls12_ticket_auth_client_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
74      char *encryptdata = *pencryptdata;
75      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
76      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
77      char * out_buffer = NULL;
78      if (local->handshake_status == 8) {
79          if (datalength < 1024) {
80              if (*capacity < datalength + 5) {
81                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + 5) * 2);
82                  encryptdata = *pencryptdata;
83              }
84              memmove(encryptdata + 5, encryptdata, datalength);
85              encryptdata[0] = 0x17;
86              encryptdata[1] = 0x3;
87              encryptdata[2] = 0x3;
88              encryptdata[3] = datalength >> 8;
89              encryptdata[4] = datalength;
90              return datalength + 5;
91          } else {
92              out_buffer = (char*)malloc(datalength + 2048);
93              int start = 0;
94              int outlength = 0;
95              int len;
96              while (datalength - start > 2048) {
97                  len = xorshift128plus() % 4096 + 100;
98                  if (len > datalength - start)
99                      len = datalength - start;
100                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
101                  outlength += len + 5;
102                  start += len;
103              }
104              if (datalength - start > 0) {
105                  len = datalength - start;
106                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
107                  outlength += len + 5;
108              }
109              if (*capacity < outlength) {
110                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
111                  encryptdata = *pencryptdata;
112              }
113              memcpy(encryptdata, out_buffer, outlength);
114              free(out_buffer);
115              return outlength;
116          }
117      }
118      local->send_buffer = (char*)realloc(local->send_buffer, local->send_buffer_size + datalength + 5);
119      memcpy(local->send_buffer + local->send_buffer_size + 5, encryptdata, datalength);
120      local->send_buffer[local->send_buffer_size] = 0x17;
121      local->send_buffer[local->send_buffer_size + 1] = 0x3;
122      local->send_buffer[local->send_buffer_size + 2] = 0x3;
123      local->send_buffer[local->send_buffer_size + 3] = datalength >> 8;
124      local->send_buffer[local->send_buffer_size + 4] = datalength;
125      local->send_buffer_size += datalength + 5;
126      if (local->handshake_status == 0) {
127  #define CSTR_DECL(name, len, str) const char* name = str; const int len = sizeof(str) - 1;
128          CSTR_DECL(tls_data0, tls_data0_len, "\x00\x1c\xc0\x2b\xc0\x2f\xcc\xa9\xcc\xa8\xcc\x14\xcc\x13\xc0\x0a\xc0\x14\xc0\x09\xc0\x13\x00\x9c\x00\x35\x00\x2f\x00\x0a\x01\x00"
129                  );
130          CSTR_DECL(tls_data1, tls_data1_len, "\xff\x01\x00\x01\x00"
131                  );
132          CSTR_DECL(tls_data2, tls_data2_len, "\x00\x17\x00\x00\x00\x23\x00\xd0");
133          CSTR_DECL(tls_data3, tls_data3_len, "\x00\x0d\x00\x16\x00\x14\x06\x01\x06\x03\x05\x01\x05\x03\x04\x01\x04\x03\x03\x01\x03\x03\x02\x01\x02\x03\x00\x05\x00\x05\x01\x00\x00\x00\x00\x00\x12\x00\x00\x75\x50\x00\x00\x00\x0b\x00\x02\x01\x00\x00\x0a\x00\x06\x00\x04\x00\x17\x00\x18"
134                  );
135          uint8_t tls_data[2048];
136          int tls_data_len = 0;
137          memcpy(tls_data, tls_data1, tls_data1_len);
138          tls_data_len += tls_data1_len;
139          char hosts[1024];
140          char * phost[128];
141          int host_num = 0;
142          int pos;
143          char sni[256] = {0};
144          if (self->server.param && strlen(self->server.param) == 0)
145              self->server.param = NULL;
146          strncpy(hosts, self->server.param ? self->server.param : self->server.host, sizeof hosts);
147          phost[host_num++] = hosts;
148          for (pos = 0; hosts[pos]; ++pos) {
149              if (hosts[pos] == ',') {
150                  phost[host_num++] = &hosts[pos + 1];
151              }
152          }
153          host_num = xorshift128plus() % host_num;
154          sprintf(sni, "%s", phost[host_num]);
155          int sni_len = strlen(sni);
156          if (sni_len > 0 && sni[sni_len - 1] >= '0' && sni[sni_len - 1] <= '9')
157              sni_len = 0;
158          tls_data[tls_data_len] = '\0';
159          tls_data[tls_data_len + 1] = '\0';
160          tls_data[tls_data_len + 2] = (sni_len + 5) >> 8;
161          tls_data[tls_data_len + 3] = (sni_len + 5);
162          tls_data[tls_data_len + 4] = (sni_len + 3) >> 8;
163          tls_data[tls_data_len + 5] = (sni_len + 3);
164          tls_data[tls_data_len + 6] = '\0';
165          tls_data[tls_data_len + 7] = sni_len >> 8;
166          tls_data[tls_data_len + 8] = sni_len;
167          memcpy(tls_data + tls_data_len + 9, sni, sni_len);
168          tls_data_len += 9 + sni_len;
169          memcpy(tls_data + tls_data_len, tls_data2, tls_data2_len);
170          tls_data_len += tls_data2_len;
171          rand_bytes(tls_data + tls_data_len, 208);
172          tls_data_len += 208;
173          memcpy(tls_data + tls_data_len, tls_data3, tls_data3_len);
174          tls_data_len += tls_data3_len;
175          datalength = 11 + 32 + 1 + 32 + tls_data0_len + 2 + tls_data_len;
176          out_buffer = (char*)malloc(datalength);
177          char *pdata = out_buffer + datalength - tls_data_len;
178          int len = tls_data_len;
179          memcpy(pdata, tls_data, tls_data_len);
180          pdata[-1] = tls_data_len;
181          pdata[-2] = tls_data_len >> 8;
182          pdata -= 2; len += 2;
183          memcpy(pdata - tls_data0_len, tls_data0, tls_data0_len);
184          pdata -= tls_data0_len; len += tls_data0_len;
185          memcpy(pdata - 32, global->local_client_id, 32);
186          pdata -= 32; len += 32;
187          pdata[-1] = 0x20;
188          pdata -= 1; len += 1;
189          tls12_ticket_pack_auth_data(global, &self->server, pdata - 32);
190          pdata -= 32; len += 32;
191          pdata[-1] = 0x3;
192          pdata[-2] = 0x3; 
193          pdata -= 2; len += 2;
194          pdata[-1] = len;
195          pdata[-2] = len >> 8;
196          pdata[-3] = 0;
197          pdata[-4] = 1;
198          pdata -= 4; len += 4;
199          pdata[-1] = len;
200          pdata[-2] = len >> 8;
201          pdata -= 2; len += 2;
202          pdata[-1] = 0x1;
203          pdata[-2] = 0x3; 
204          pdata -= 2; len += 2;
205          pdata[-1] = 0x16; 
206          pdata -= 1; len += 1;
207          local->handshake_status = 1;
208      } else if (datalength == 0) {
209          datalength = local->send_buffer_size + 43;
210          out_buffer = (char*)malloc(datalength);
211          char *pdata = out_buffer;
212          memcpy(pdata, "\x14\x03\x03\x00\x01\x01", 6);
213          pdata += 6;
214          memcpy(pdata, "\x16\x03\x03\x00\x20", 5);
215          pdata += 5;
216          rand_bytes((uint8_t*)pdata, 22);
217          pdata += 22;
218          uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
219          char hash[ONETIMEAUTH_BYTES * 2];
220          memcpy(key, self->server.key, self->server.key_len);
221          memcpy(key + self->server.key_len, global->local_client_id, 32);
222          ss_sha1_hmac_with_key(hash, out_buffer, pdata - out_buffer, key, self->server.key_len + 32);
223          free(key);
224          memcpy(pdata, hash, OBFS_HMAC_SHA1_LEN);
225          pdata += OBFS_HMAC_SHA1_LEN;
226          memcpy(pdata, local->send_buffer, local->send_buffer_size);
227          free(local->send_buffer);
228          local->send_buffer = NULL;
229          local->handshake_status = 8;
230      } else {
231          return 0;
232      }
233      if (*capacity < datalength) {
234          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = datalength * 2);
235          encryptdata = *pencryptdata;
236      }
237      memmove(encryptdata, out_buffer, datalength);
238      free(out_buffer);
239      return datalength;
240  }
241  int tls12_ticket_auth_server_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
242      char *encryptdata = *pencryptdata;
243      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
244      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
245      char * out_buffer = NULL;
246      if (local->handshake_status == 8) {
247          if (datalength < 1024) {
248              if (*capacity < datalength + 5) {
249                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + 5) * 2);
250                  encryptdata = *pencryptdata;
251              }
252              memmove(encryptdata + 5, encryptdata, datalength);
253              encryptdata[0] = 0x17;
254              encryptdata[1] = 0x3;
255              encryptdata[2] = 0x3;
256              encryptdata[3] = datalength >> 8;
257              encryptdata[4] = datalength;
258              return datalength + 5;
259          } else {
260              out_buffer = (char*)malloc(datalength + 2048);
261              int start = 0;
262              int outlength = 0;
263              int len;
264              while (datalength - start > 2048) {
265                  len = xorshift128plus() % 4096 + 100;
266                  if (len > datalength - start)
267                      len = datalength - start;
268                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
269                  outlength += len + 5;
270                  start += len;
271              }
272              if (datalength - start > 0) {
273                  len = datalength - start;
274                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
275                  outlength += len + 5;
276              }
277              if (*capacity < outlength) {
278                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
279                  encryptdata = *pencryptdata;
280              }
281              memcpy(encryptdata, out_buffer, outlength);
282              free(out_buffer);
283              return outlength;
284          }
285      }
286      local->handshake_status = 3;
287      out_buffer = (char*)malloc(43 + 86);
288      int data_len = 0;
289      char *p_data = out_buffer + 86;
290      memcpy(p_data - 10, "\xc0\x2f\x00\x00\x05\xff\x01\x00\x01\x00", 10);
291      p_data -= 10;data_len += 10;
292      memcpy(p_data - 32, global->local_client_id, 32);
293      p_data -= 32;data_len += 32;
294      p_data[-1] = 0x20;
295      p_data -= 1;data_len += 1;
296      tls12_ticket_pack_auth_data(global, &self->server, p_data - 32);
297      p_data -= 32;data_len += 32;
298      p_data[-1] = 0x3;
299      p_data[-2] = 0x3; 
300      p_data -= 2;data_len += 2;
301      p_data[-1] = data_len;
302      p_data[-2] = data_len >> 8;
303      p_data[-3] = 0x00;
304      p_data[-4] = 0x02;
305      p_data -= 4; data_len += 4;
306      p_data[-1] = data_len;
307      p_data[-2] = data_len >> 8;
308      p_data[-3] = 0x03;
309      p_data[-4] = 0x03;
310      p_data[-5] = 0x16;
311      p_data -= 5; data_len += 5;
312      memcpy(out_buffer, p_data, data_len);
313      char *pdata = out_buffer + 86;
314      memcpy(pdata, "\x14\x03\x03\x00\x01\x01", 6);
315      pdata += 6;
316      memcpy(pdata, "\x16\x03\x03\x00\x20", 5);
317      pdata += 5;
318      rand_bytes((uint8_t*)pdata, 22);
319      pdata += 22;
320      uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
321      char hash[ONETIMEAUTH_BYTES * 2];
322      memcpy(key, self->server.key, self->server.key_len);
323      memcpy(key + self->server.key_len, global->local_client_id, 32);
324      ss_sha1_hmac_with_key(hash, out_buffer, 43 + 86, key, self->server.key_len + 32);
325      free(key);
326      memcpy(pdata, hash, OBFS_HMAC_SHA1_LEN);
327      memmove(encryptdata, out_buffer, 43 + 86);
328      free(out_buffer);
329      return 43 + 86;
330  }
331  int tls12_ticket_auth_client_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
332      char *encryptdata = *pencryptdata;
333      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
334      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
335      *needsendback = 0;
336      if (local->handshake_status == 8) {
337          local->recv_buffer_size += datalength;
338          local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size);
339          memcpy(local->recv_buffer + local->recv_buffer_size - datalength, encryptdata, datalength);
340          datalength = 0;
341          while (local->recv_buffer_size > 5) {
342              if (local->recv_buffer[0] != 0x17)
343                  return -1;
344              int size = ((int)(unsigned char)local->recv_buffer[3] << 8) + (unsigned char)local->recv_buffer[4];
345              if (size + 5 > local->recv_buffer_size)
346                  break;
347              if (*capacity < datalength + size) {
348                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + size) * 2);
349                  encryptdata = *pencryptdata;
350              }
351              memcpy(encryptdata + datalength, local->recv_buffer + 5, size);
352              datalength += size;
353              local->recv_buffer_size -= 5 + size;
354              memmove(local->recv_buffer, local->recv_buffer + 5 + size, local->recv_buffer_size);
355          }
356          return datalength;
357      }
358      if (datalength < 11 + 32 + 1 + 32) {
359          return -1;
360      }
361      uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
362      char hash[ONETIMEAUTH_BYTES * 2];
363      memcpy(key, self->server.key, self->server.key_len);
364      memcpy(key + self->server.key_len, global->local_client_id, 32);
365      ss_sha1_hmac_with_key(hash, encryptdata + 11, 22, key, self->server.key_len + 32);
366      free(key);
367      if (memcmp(encryptdata + 33, hash, OBFS_HMAC_SHA1_LEN)) {
368          return -1;
369      }
370      *needsendback = 1;
371      return 0;
372  }
<span onclick='openModal()' class='match'>373  int tls12_ticket_auth_server_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
374      char *encryptdata = *pencryptdata;
375      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
</span>376      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
377      *needsendback = 0;
378      if (local->handshake_status == 8) {
379          if(datalength != 0)
380          {
381              local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size + datalength);
382              memmove(local->recv_buffer + local->recv_buffer_size, encryptdata, datalength);
383              local->recv_buffer_size += datalength;
384          }
385          datalength = 0;
386          while (local->recv_buffer_size > 5) {
387              if (local->recv_buffer[0] != 0x17 || local->recv_buffer[1] != 0x03 || local->recv_buffer[2] != 0x03)
388              {
389                  LOGE("server_decode data error, wrong tls version 3");
390                  return -1;
391              }
392              int size = ((int)(unsigned char)local->recv_buffer[3] << 8) + (unsigned char)local->recv_buffer[4];
393              if (size + 5 > local->recv_buffer_size)
394                  break;
395              if (*capacity < local->recv_buffer_size + size) {
396                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (local->recv_buffer_size + size) * 2);
397                  encryptdata = *pencryptdata;
398              }
399              memcpy(encryptdata + datalength, local->recv_buffer + 5, size);
400              datalength += size;
401              local->recv_buffer_size -= 5 + size;
402              memmove(local->recv_buffer, local->recv_buffer + 5 + size, local->recv_buffer_size);
403          }
404          return datalength;
405      }
406      if (local->handshake_status == 3) {
407          char *verify = encryptdata;
408          if(datalength < 43)
409          {
410              LOGE("server_decode data error, too short:%d", (int)datalength);
411              return -1;
412          }
413          if(encryptdata[0] != 0x14 || encryptdata[1] != 0x03 || encryptdata[2] != 0x03 || encryptdata[3] != 0x00 || encryptdata[4] != 0x01 || encryptdata[5] != 0x01)
414          {
415              LOGE("server_decode data error, wrong tls version");
416              return -1;
417          }
418          encryptdata += 6;
419          if(encryptdata[0] != 0x16 || encryptdata[1] != 0x03 || encryptdata[2] != 0x03 || encryptdata[3] != 0x00 || encryptdata[4] != 0x20)
420          {
421              LOGE("server_decode data error, wrong tls version 2");
422              return -1;
423          }
424          uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
425          char hash[ONETIMEAUTH_BYTES * 2];
426          memcpy(key, self->server.key, self->server.key_len);
427          memcpy(key + self->server.key_len, global->local_client_id, 32);
428          ss_sha1_hmac_with_key(hash, verify, 33, key, self->server.key_len + 32);
429          free(key);
430          if (memcmp(verify + 33, hash, OBFS_HMAC_SHA1_LEN) != 0) {
431              LOGE("server_decode data error, hash Mismatch %d",(int)memcmp(verify + 33, hash, OBFS_HMAC_SHA1_LEN));
432              return -1;
433          }
434          local->recv_buffer_size = datalength - 43;
435          local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size);
436          memmove(local->recv_buffer, encryptdata + 37, datalength - 43);
437          local->handshake_status = 8;
438          return tls12_ticket_auth_server_decode(self, pencryptdata, 0, capacity, needsendback);
439      }
440      local->handshake_status = 2;
441      if(encryptdata[0] != 0x16 || encryptdata[1] != 0x03 || encryptdata[2] != 0x01)
442      {
443          return -1;
444      }
445      encryptdata += 3;
446      {
447          int size = ((int)(unsigned char)encryptdata[0] << 8) + (unsigned char)encryptdata[1];
448          if(size != datalength - 5)
449          {
450              LOGE("tls_auth wrong tls head size");
451              return -1;
452          }
453      }
454      encryptdata += 2;
455      if(encryptdata[0] != 0x01 || encryptdata[1] != 0x00)
456      {
457          LOGE("tls_auth not client hello message");
458          return -1;
459      }
460      encryptdata += 2;
461      {
462          int size = ((int)(unsigned char)encryptdata[0] << 8) + (unsigned char)encryptdata[1];
463          if(size != datalength - 9)
464          {
465              LOGE("tls_auth wrong message size");
466              return -1;
467          }
468      }
469      encryptdata += 2;
470      if(encryptdata[0] != 0x03 || encryptdata[1] != 0x03)
471      {
472          LOGE("tls_auth wrong tls version");
473          return -1;
474      }
475      encryptdata += 2;
476      char *verifyid = encryptdata;
477      encryptdata += 32;
478      int sessionid_len = encryptdata[0];
479      if(sessionid_len < 32)
480      {
481          LOGE("tls_auth wrong sessionid_len");
482          return -1;
483      }
484      char *sessionid = encryptdata + 1;
485      memcpy(global->local_client_id , sessionid, sessionid_len);
486      uint8_t *key = (uint8_t*)malloc(self->server.key_len + sessionid_len);
487      char hash[ONETIMEAUTH_BYTES * 2];
488      memcpy(key, self->server.key, self->server.key_len);
489      memcpy(key + self->server.key_len, global->local_client_id, sessionid_len);
490      ss_sha1_hmac_with_key(hash, verifyid, 22, key, self->server.key_len + sessionid_len);
491      free(key);
492      encryptdata += (sessionid_len + 1);
493      long utc_time = ((int)(unsigned char)verifyid[0] << 24) + ((int)(unsigned char)verifyid[1] << 16) + ((int)(unsigned char)verifyid[2] << 8) + (unsigned char)verifyid[3];
494      time_t t = time(NULL);
495      if (self->server.param && strlen(self->server.param) == 0)
496      {
497          self->server.param = NULL;
498      }
499      int max_time_dif = 0;
500      int time_dif = utc_time - t;
501      if(self->server.param)
502      {
503          max_time_dif = atoi(self->server.param);
504      }
505      if(max_time_dif > 0 && (time_dif < -max_time_dif || time_dif > max_time_dif || utc_time - global->startup_time < -max_time_dif / 2))
506      {
507          LOGE("tls_auth wrong time");
508          return -1;
509      }
510      if (memcmp(verifyid + 22, hash, OBFS_HMAC_SHA1_LEN)) {
511          LOGE("tls_auth wrong sha1");
512          return -1;
513      }
514      int search_result = global->client_data->have_same_cmp(global->client_data, verifyid);
515      if(search_result != 0)
516      {
517          LOGE("replay attack detect!");
518          return -1;
519      }
520      global->client_data->add_back(global->client_data, verifyid);
521      encryptdata += 48;
522      *needsendback = 1;
523      return 0;
524  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-argb_mips_dsp_r2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-tls1.2_ticket.c</div>
                </div>
                <div class="column column_space"><pre><code>42  static void PackRGB(const uint8_t* r, const uint8_t* g, const uint8_t* b,
43                      int len, int step, uint32_t* out) {
44    int temp0, temp1, temp2, offset;
45    const int rest = len & 1;
46    const int a = 0xff;
47    const uint32_t* const loop_end = out + len - rest;
</pre></code></div>
                <div class="column column_space"><pre><code>373  int tls12_ticket_auth_server_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
374      char *encryptdata = *pencryptdata;
375      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    