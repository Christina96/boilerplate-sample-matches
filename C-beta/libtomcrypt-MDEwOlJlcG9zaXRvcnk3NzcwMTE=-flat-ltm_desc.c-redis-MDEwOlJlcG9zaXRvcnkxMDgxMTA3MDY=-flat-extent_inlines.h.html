
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.13443640124095%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltm_desc.c</h3>
            <pre><code>1  #define DESC_DEF_ONLY
2  #include "tomcrypt_private.h"
3  #ifdef LTM_DESC
4  #include <tommath.h>
5  #if !defined(PRIVATE_MP_WARRAY) && !defined(BN_MP_PRIME_IS_PRIME_C)
6  #include <stdbool.h>
7  #endif
8  static const struct {
9      mp_err mpi_code;
10      int ltc_code;
11  } mpi_to_ltc_codes[] = {
12     { MP_OKAY ,  CRYPT_OK},
13     { MP_MEM  ,  CRYPT_MEM},
14     { MP_VAL  ,  CRYPT_INVALID_ARG},
15  #if defined(MP_BUF) || defined(MP_USE_ENUMS)
16     { MP_ITER ,  CRYPT_INVALID_PACKET},
17     { MP_BUF  ,  CRYPT_BUFFER_OVERFLOW},
18  #endif
19  };
20  static int mpi_to_ltc_error(mp_err err)
21  {
22     size_t x;
23     for (x = 0; x < sizeof(mpi_to_ltc_codes)/sizeof(mpi_to_ltc_codes[0]); x++) {
24         if (err == mpi_to_ltc_codes[x].mpi_code) {
25            return mpi_to_ltc_codes[x].ltc_code;
26         }
27     }
28     return CRYPT_ERROR;
29  }
30  static int init_mpi(void **a)
31  {
32     LTC_ARGCHK(a != NULL);
33     *a = XCALLOC(1, sizeof(mp_int));
34     if (*a == NULL) {
35        return CRYPT_MEM;
36     } else {
37        return CRYPT_OK;
38     }
39  }
40  static int init(void **a)
41  {
42     int err;
43     LTC_ARGCHK(a != NULL);
44     if ((err = init_mpi(a)) != CRYPT_OK) {
45        return err;
46     }
47     if ((err = mpi_to_ltc_error(mp_init(*a))) != CRYPT_OK) {
48        XFREE(*a);
49     }
50     return err;
51  }
52  static void deinit(void *a)
53  {
54     LTC_ARGCHKVD(a != NULL);
55     mp_clear(a);
56     XFREE(a);
57  }
58  static int neg(void *a, void *b)
59  {
60     LTC_ARGCHK(a != NULL);
61     LTC_ARGCHK(b != NULL);
62     return mpi_to_ltc_error(mp_neg(a, b));
63  }
64  static int copy(void *a, void *b)
65  {
66     LTC_ARGCHK(a != NULL);
67     LTC_ARGCHK(b != NULL);
68     return mpi_to_ltc_error(mp_copy(a, b));
69  }
70  static int init_copy(void **a, void *b)
71  {
72     int err;
73     LTC_ARGCHK(a  != NULL);
74     LTC_ARGCHK(b  != NULL);
75     if ((err = init_mpi(a)) != CRYPT_OK) return err;
76     return mpi_to_ltc_error(mp_init_copy(*a, b));
77  }
78  static int set_int(void *a, ltc_mp_digit b)
79  {
80     LTC_ARGCHK(a != NULL);
81  #ifdef BN_MP_SET_INT_C
82     return mpi_to_ltc_error(mp_set_int(a, b));
83  #else
84     mp_set_u32(a, b);
85     return CRYPT_OK;
86  #endif
87  }
88  static unsigned long get_int(void *a)
89  {
90     LTC_ARGCHK(a != NULL);
91  #ifdef BN_MP_GET_INT_C
92     return mp_get_int(a);
93  #else
94     return mp_get_ul(a);
95  #endif
96  }
97  static ltc_mp_digit get_digit(void *a, int n)
98  {
99     mp_int *A;
100     LTC_ARGCHK(a != NULL);
101     A = a;
102     return (n >= A->used || n < 0) ? 0 : A->dp[n];
103  }
104  static int get_digit_count(void *a)
105  {
106     mp_int *A;
107     LTC_ARGCHK(a != NULL);
108     A = a;
109     return A->used;
110  }
111  static int compare(void *a, void *b)
112  {
113     LTC_ARGCHK(a != NULL);
114     LTC_ARGCHK(b != NULL);
115     switch (mp_cmp(a, b)) {
116        case MP_LT: return LTC_MP_LT;
117        case MP_EQ: return LTC_MP_EQ;
118        case MP_GT: return LTC_MP_GT;
119        default:    return 0;
120     }
121  }
122  static int compare_d(void *a, ltc_mp_digit b)
123  {
124     LTC_ARGCHK(a != NULL);
125     switch (mp_cmp_d(a, b)) {
126        case MP_LT: return LTC_MP_LT;
127        case MP_EQ: return LTC_MP_EQ;
128        case MP_GT: return LTC_MP_GT;
129        default:    return 0;
130     }
131  }
132  static int count_bits(void *a)
133  {
134     LTC_ARGCHK(a != NULL);
135     return mp_count_bits(a);
136  }
137  static int count_lsb_bits(void *a)
138  {
139     LTC_ARGCHK(a != NULL);
140     return mp_cnt_lsb(a);
141  }
142  static int twoexpt(void *a, int n)
143  {
144     LTC_ARGCHK(a != NULL);
145     return mpi_to_ltc_error(mp_2expt(a, n));
146  }
147  static int read_radix(void *a, const char *b, int radix)
148  {
149     LTC_ARGCHK(a != NULL);
150     LTC_ARGCHK(b != NULL);
151     return mpi_to_ltc_error(mp_read_radix(a, b, radix));
152  }
153  static int write_radix(void *a, char *b, int radix)
154  {
155     LTC_ARGCHK(a != NULL);
156     LTC_ARGCHK(b != NULL);
157  #ifdef BN_MP_TORADIX_C
158     return mpi_to_ltc_error(mp_toradix(a, b, radix));
159  #else
160     return mpi_to_ltc_error(mp_to_radix(a, b, SIZE_MAX, NULL, radix));
161  #endif
162  }
163  static unsigned long unsigned_size(void *a)
164  {
165     LTC_ARGCHK(a != NULL);
166  #ifdef BN_MP_UNSIGNED_BIN_SIZE_C
167     return mp_unsigned_bin_size(a);
168  #else
169     return (unsigned long)mp_ubin_size(a);
170  #endif
171  }
172  static int unsigned_write(void *a, unsigned char *b)
173  {
174     LTC_ARGCHK(a != NULL);
175     LTC_ARGCHK(b != NULL);
176  #ifdef BN_MP_TO_UNSIGNED_BIN_C
177     return mpi_to_ltc_error(mp_to_unsigned_bin(a, b));
178  #else
179     return mpi_to_ltc_error(mp_to_ubin(a, b, SIZE_MAX, NULL));
180  #endif
181  }
182  static int unsigned_read(void *a, unsigned char *b, unsigned long len)
183  {
184     LTC_ARGCHK(a != NULL);
185     LTC_ARGCHK(b != NULL);
186  #ifdef BN_MP_READ_UNSIGNED_BIN_C
187     return mpi_to_ltc_error(mp_read_unsigned_bin(a, b, len));
188  #else
189     return mpi_to_ltc_error(mp_from_ubin(a, b, (size_t)len));
190  #endif
191  }
192  static int add(void *a, void *b, void *c)
193  {
194     LTC_ARGCHK(a != NULL);
195     LTC_ARGCHK(b != NULL);
196     LTC_ARGCHK(c != NULL);
197     return mpi_to_ltc_error(mp_add(a, b, c));
198  }
199  static int addi(void *a, ltc_mp_digit b, void *c)
200  {
201     LTC_ARGCHK(a != NULL);
202     LTC_ARGCHK(c != NULL);
203     return mpi_to_ltc_error(mp_add_d(a, b, c));
204  }
205  static int sub(void *a, void *b, void *c)
206  {
207     LTC_ARGCHK(a != NULL);
208     LTC_ARGCHK(b != NULL);
209     LTC_ARGCHK(c != NULL);
210     return mpi_to_ltc_error(mp_sub(a, b, c));
211  }
212  static int subi(void *a, ltc_mp_digit b, void *c)
213  {
214     LTC_ARGCHK(a != NULL);
215     LTC_ARGCHK(c != NULL);
216     return mpi_to_ltc_error(mp_sub_d(a, b, c));
217  }
218  static int mul(void *a, void *b, void *c)
219  {
220     LTC_ARGCHK(a != NULL);
221     LTC_ARGCHK(b != NULL);
222     LTC_ARGCHK(c != NULL);
223     return mpi_to_ltc_error(mp_mul(a, b, c));
224  }
225  static int muli(void *a, ltc_mp_digit b, void *c)
226  {
227     LTC_ARGCHK(a != NULL);
228     LTC_ARGCHK(c != NULL);
229     return mpi_to_ltc_error(mp_mul_d(a, b, c));
230  }
231  static int sqr(void *a, void *b)
232  {
233     LTC_ARGCHK(a != NULL);
234     LTC_ARGCHK(b != NULL);
235     return mpi_to_ltc_error(mp_sqr(a, b));
236  }
237  static int sqrtmod_prime(void *a, void *b, void *c)
238  {
239     LTC_ARGCHK(a != NULL);
240     LTC_ARGCHK(b != NULL);
241     LTC_ARGCHK(c != NULL);
242     return mpi_to_ltc_error(mp_sqrtmod_prime(a, b, c));
243  }
244  static int divide(void *a, void *b, void *c, void *d)
245  {
246     LTC_ARGCHK(a != NULL);
247     LTC_ARGCHK(b != NULL);
248     return mpi_to_ltc_error(mp_div(a, b, c, d));
249  }
250  static int div_2(void *a, void *b)
251  {
252     LTC_ARGCHK(a != NULL);
253     LTC_ARGCHK(b != NULL);
254     return mpi_to_ltc_error(mp_div_2(a, b));
255  }
256  static int modi(void *a, ltc_mp_digit b, ltc_mp_digit *c)
257  {
258     mp_digit tmp;
259     int      err;
260     LTC_ARGCHK(a != NULL);
261     LTC_ARGCHK(c != NULL);
262     if ((err = mpi_to_ltc_error(mp_mod_d(a, b, &tmp))) != CRYPT_OK) {
263        return err;
264     }
265     *c = tmp;
266     return CRYPT_OK;
267  }
268  static int gcd(void *a, void *b, void *c)
269  {
270     LTC_ARGCHK(a != NULL);
271     LTC_ARGCHK(b != NULL);
272     LTC_ARGCHK(c != NULL);
273     return mpi_to_ltc_error(mp_gcd(a, b, c));
274  }
275  static int lcm(void *a, void *b, void *c)
276  {
277     LTC_ARGCHK(a != NULL);
278     LTC_ARGCHK(b != NULL);
279     LTC_ARGCHK(c != NULL);
280     return mpi_to_ltc_error(mp_lcm(a, b, c));
281  }
282  static int addmod(void *a, void *b, void *c, void *d)
283  {
284     LTC_ARGCHK(a != NULL);
285     LTC_ARGCHK(b != NULL);
286     LTC_ARGCHK(c != NULL);
287     LTC_ARGCHK(d != NULL);
288     return mpi_to_ltc_error(mp_addmod(a,b,c,d));
289  }
290  static int submod(void *a, void *b, void *c, void *d)
291  {
292     LTC_ARGCHK(a != NULL);
293     LTC_ARGCHK(b != NULL);
294     LTC_ARGCHK(c != NULL);
295     LTC_ARGCHK(d != NULL);
296     return mpi_to_ltc_error(mp_submod(a,b,c,d));
297  }
298  static int mulmod(void *a, void *b, void *c, void *d)
299  {
300     LTC_ARGCHK(a != NULL);
301     LTC_ARGCHK(b != NULL);
302     LTC_ARGCHK(c != NULL);
303     LTC_ARGCHK(d != NULL);
304     return mpi_to_ltc_error(mp_mulmod(a,b,c,d));
305  }
306  static int sqrmod(void *a, void *b, void *c)
307  {
308     LTC_ARGCHK(a != NULL);
309     LTC_ARGCHK(b != NULL);
310     LTC_ARGCHK(c != NULL);
311     return mpi_to_ltc_error(mp_sqrmod(a,b,c));
312  }
313  static int invmod(void *a, void *b, void *c)
314  {
315     LTC_ARGCHK(a != NULL);
316     LTC_ARGCHK(b != NULL);
317     LTC_ARGCHK(c != NULL);
318     return mpi_to_ltc_error(mp_invmod(a, b, c));
<span onclick='openModal()' class='match'>319  }
320  static int montgomery_setup(void *a, void **b)
321  {
322     int err;
323     LTC_ARGCHK(a != NULL);
324     LTC_ARGCHK(b != NULL);
325     *b = XCALLOC(1, sizeof(mp_digit));
326     if (*b == NULL) {
327        return CRYPT_MEM;
328     }
</span>329     if ((err = mpi_to_ltc_error(mp_montgomery_setup(a, (mp_digit *)*b))) != CRYPT_OK) {
330        XFREE(*b);
331     }
332     return err;
333  }
334  static int montgomery_normalization(void *a, void *b)
335  {
336     LTC_ARGCHK(a != NULL);
337     LTC_ARGCHK(b != NULL);
338     return mpi_to_ltc_error(mp_montgomery_calc_normalization(a, b));
339  }
340  static int montgomery_reduce(void *a, void *b, void *c)
341  {
342     LTC_ARGCHK(a != NULL);
343     LTC_ARGCHK(b != NULL);
344     LTC_ARGCHK(c != NULL);
345     return mpi_to_ltc_error(mp_montgomery_reduce(a, b, *((mp_digit *)c)));
346  }
347  static void montgomery_deinit(void *a)
348  {
349     XFREE(a);
350  }
351  static int exptmod(void *a, void *b, void *c, void *d)
352  {
353     LTC_ARGCHK(a != NULL);
354     LTC_ARGCHK(b != NULL);
355     LTC_ARGCHK(c != NULL);
356     LTC_ARGCHK(d != NULL);
357     return mpi_to_ltc_error(mp_exptmod(a,b,c,d));
358  }
359  static int isprime(void *a, int b, int *c)
360  {
361     int err;
362  #if defined(PRIVATE_MP_WARRAY) || defined(BN_MP_PRIME_IS_PRIME_C)
363     int res;
364  #else
365     bool res;
366  #endif
367     LTC_ARGCHK(a != NULL);
368     LTC_ARGCHK(c != NULL);
369     b = mp_prime_rabin_miller_trials(mp_count_bits(a));
370     err = mpi_to_ltc_error(mp_prime_is_prime(a, b, &res));
371     *c = res ? LTC_MP_YES : LTC_MP_NO;
372     return err;
373  }
374  static int set_rand(void *a, int size)
375  {
376     LTC_ARGCHK(a != NULL);
377     return mpi_to_ltc_error(mp_rand(a, size));
378  }
379  #ifndef MP_DIGIT_BIT
380  #define MP_DIGIT_BIT DIGIT_BIT
381  #endif
382  const ltc_math_descriptor ltm_desc = {
383     "LibTomMath",
384     (int)MP_DIGIT_BIT,
385     &init,
386     &init_copy,
387     &deinit,
388     &neg,
389     &copy,
390     &set_int,
391     &get_int,
392     &get_digit,
393     &get_digit_count,
394     &compare,
395     &compare_d,
396     &count_bits,
397     &count_lsb_bits,
398     &twoexpt,
399     &read_radix,
400     &write_radix,
401     &unsigned_size,
402     &unsigned_write,
403     &unsigned_read,
404     &add,
405     &addi,
406     &sub,
407     &subi,
408     &mul,
409     &muli,
410     &sqr,
411     &sqrtmod_prime,
412     &divide,
413     &div_2,
414     &modi,
415     &gcd,
416     &lcm,
417     &mulmod,
418     &sqrmod,
419     &invmod,
420     &montgomery_setup,
421     &montgomery_normalization,
422     &montgomery_reduce,
423     &montgomery_deinit,
424     &exptmod,
425     &isprime,
426  #ifdef LTC_MECC
427  #ifdef LTC_MECC_FP
428     &ltc_ecc_fp_mulmod,
429  #else
430     &ltc_ecc_mulmod,
431  #endif
432     &ltc_ecc_projective_add_point,
433     &ltc_ecc_projective_dbl_point,
434     &ltc_ecc_map,
435  #ifdef LTC_ECC_SHAMIR
436  #ifdef LTC_MECC_FP
437     &ltc_ecc_fp_mul2add,
438  #else
439     &ltc_ecc_mul2add,
440  #endif &bsol;* LTC_MECC_FP */
441  #else
442     NULL,
443  #endif &bsol;* LTC_ECC_SHAMIR */
444  #else
445     NULL, NULL, NULL, NULL, NULL,
446  #endif &bsol;* LTC_MECC */
447  #ifdef LTC_MRSA
448     &rsa_make_key,
449     &rsa_exptmod,
450  #else
451     NULL, NULL,
452  #endif
453     &addmod,
454     &submod,
455     &set_rand,
456  };
457  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent_inlines.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_EXTENT_INLINES_H
2  #define JEMALLOC_INTERNAL_EXTENT_INLINES_H
3  #include "jemalloc/internal/mutex.h"
4  #include "jemalloc/internal/mutex_pool.h"
5  #include "jemalloc/internal/pages.h"
6  #include "jemalloc/internal/prng.h"
7  #include "jemalloc/internal/ql.h"
8  #include "jemalloc/internal/sc.h"
9  #include "jemalloc/internal/sz.h"
10  static inline void
11  extent_lock(tsdn_t *tsdn, extent_t *extent) {
12  	assert(extent != NULL);
13  	mutex_pool_lock(tsdn, &extent_mutex_pool, (uintptr_t)extent);
14  }
15  static inline void
16  extent_unlock(tsdn_t *tsdn, extent_t *extent) {
17  	assert(extent != NULL);
18  	mutex_pool_unlock(tsdn, &extent_mutex_pool, (uintptr_t)extent);
19  }
20  static inline void
21  extent_lock2(tsdn_t *tsdn, extent_t *extent1, extent_t *extent2) {
22  	assert(extent1 != NULL && extent2 != NULL);
23  	mutex_pool_lock2(tsdn, &extent_mutex_pool, (uintptr_t)extent1,
24  	    (uintptr_t)extent2);
25  }
26  static inline void
27  extent_unlock2(tsdn_t *tsdn, extent_t *extent1, extent_t *extent2) {
28  	assert(extent1 != NULL && extent2 != NULL);
29  	mutex_pool_unlock2(tsdn, &extent_mutex_pool, (uintptr_t)extent1,
30  	    (uintptr_t)extent2);
31  }
32  static inline unsigned
33  extent_arena_ind_get(const extent_t *extent) {
34  	unsigned arena_ind = (unsigned)((extent->e_bits &
35  	    EXTENT_BITS_ARENA_MASK) >> EXTENT_BITS_ARENA_SHIFT);
36  	assert(arena_ind < MALLOCX_ARENA_LIMIT);
37  	return arena_ind;
38  }
39  static inline arena_t *
40  extent_arena_get(const extent_t *extent) {
41  	unsigned arena_ind = extent_arena_ind_get(extent);
42  	return (arena_t *)atomic_load_p(&arenas[arena_ind], ATOMIC_ACQUIRE);
43  }
44  static inline szind_t
45  extent_szind_get_maybe_invalid(const extent_t *extent) {
46  	szind_t szind = (szind_t)((extent->e_bits & EXTENT_BITS_SZIND_MASK) >>
47  	    EXTENT_BITS_SZIND_SHIFT);
48  	assert(szind <= SC_NSIZES);
49  	return szind;
50  }
51  static inline szind_t
52  extent_szind_get(const extent_t *extent) {
53  	szind_t szind = extent_szind_get_maybe_invalid(extent);
54  	assert(szind < SC_NSIZES); &bsol;* Never call when "invalid". */
55  	return szind;
56  }
57  static inline size_t
58  extent_usize_get(const extent_t *extent) {
59  	return sz_index2size(extent_szind_get(extent));
60  }
61  static inline unsigned
62  extent_binshard_get(const extent_t *extent) {
63  	unsigned binshard = (unsigned)((extent->e_bits &
64  	    EXTENT_BITS_BINSHARD_MASK) >> EXTENT_BITS_BINSHARD_SHIFT);
65  	assert(binshard < bin_infos[extent_szind_get(extent)].n_shards);
66  	return binshard;
67  }
68  static inline size_t
69  extent_sn_get(const extent_t *extent) {
70  	return (size_t)((extent->e_bits & EXTENT_BITS_SN_MASK) >>
71  	    EXTENT_BITS_SN_SHIFT);
72  }
73  static inline extent_state_t
74  extent_state_get(const extent_t *extent) {
75  	return (extent_state_t)((extent->e_bits & EXTENT_BITS_STATE_MASK) >>
76  	    EXTENT_BITS_STATE_SHIFT);
77  }
78  static inline bool
79  extent_zeroed_get(const extent_t *extent) {
80  	return (bool)((extent->e_bits & EXTENT_BITS_ZEROED_MASK) >>
81  	    EXTENT_BITS_ZEROED_SHIFT);
82  }
83  static inline bool
84  extent_committed_get(const extent_t *extent) {
85  	return (bool)((extent->e_bits & EXTENT_BITS_COMMITTED_MASK) >>
86  	    EXTENT_BITS_COMMITTED_SHIFT);
87  }
88  static inline bool
89  extent_dumpable_get(const extent_t *extent) {
90  	return (bool)((extent->e_bits & EXTENT_BITS_DUMPABLE_MASK) >>
91  	    EXTENT_BITS_DUMPABLE_SHIFT);
92  }
93  static inline bool
94  extent_slab_get(const extent_t *extent) {
95  	return (bool)((extent->e_bits & EXTENT_BITS_SLAB_MASK) >>
96  	    EXTENT_BITS_SLAB_SHIFT);
97  }
98  static inline unsigned
99  extent_nfree_get(const extent_t *extent) {
100  	assert(extent_slab_get(extent));
101  	return (unsigned)((extent->e_bits & EXTENT_BITS_NFREE_MASK) >>
102  	    EXTENT_BITS_NFREE_SHIFT);
103  }
104  static inline void *
105  extent_base_get(const extent_t *extent) {
106  	assert(extent->e_addr == PAGE_ADDR2BASE(extent->e_addr) ||
107  	    !extent_slab_get(extent));
108  	return PAGE_ADDR2BASE(extent->e_addr);
109  }
110  static inline void *
111  extent_addr_get(const extent_t *extent) {
112  	assert(extent->e_addr == PAGE_ADDR2BASE(extent->e_addr) ||
113  	    !extent_slab_get(extent));
114  	return extent->e_addr;
115  }
116  static inline size_t
117  extent_size_get(const extent_t *extent) {
118  	return (extent->e_size_esn & EXTENT_SIZE_MASK);
119  }
120  static inline size_t
121  extent_esn_get(const extent_t *extent) {
122  	return (extent->e_size_esn & EXTENT_ESN_MASK);
123  }
124  static inline size_t
125  extent_bsize_get(const extent_t *extent) {
126  	return extent->e_bsize;
127  }
128  static inline void *
129  extent_before_get(const extent_t *extent) {
130  	return (void *)((uintptr_t)extent_base_get(extent) - PAGE);
131  }
132  static inline void *
133  extent_last_get(const extent_t *extent) {
134  	return (void *)((uintptr_t)extent_base_get(extent) +
135  	    extent_size_get(extent) - PAGE);
136  }
137  static inline void *
138  extent_past_get(const extent_t *extent) {
139  	return (void *)((uintptr_t)extent_base_get(extent) +
140  	    extent_size_get(extent));
141  }
142  static inline arena_slab_data_t *
143  extent_slab_data_get(extent_t *extent) {
144  	assert(extent_slab_get(extent));
145  	return &extent->e_slab_data;
146  }
147  static inline const arena_slab_data_t *
148  extent_slab_data_get_const(const extent_t *extent) {
149  	assert(extent_slab_get(extent));
150  	return &extent->e_slab_data;
151  }
152  static inline prof_tctx_t *
153  extent_prof_tctx_get(const extent_t *extent) {
154  	return (prof_tctx_t *)atomic_load_p(&extent->e_prof_tctx,
155  	    ATOMIC_ACQUIRE);
156  }
157  static inline nstime_t
158  extent_prof_alloc_time_get(const extent_t *extent) {
159  	return extent->e_alloc_time;
160  }
161  static inline void
162  extent_arena_set(extent_t *extent, arena_t *arena) {
163  	unsigned arena_ind = (arena != NULL) ? arena_ind_get(arena) : ((1U <<
164  	    MALLOCX_ARENA_BITS) - 1);
165  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_ARENA_MASK) |
166  	    ((uint64_t)arena_ind << EXTENT_BITS_ARENA_SHIFT);
167  }
168  static inline void
169  extent_binshard_set(extent_t *extent, unsigned binshard) {
170  	assert(binshard < bin_infos[extent_szind_get(extent)].n_shards);
171  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_BINSHARD_MASK) |
172  	    ((uint64_t)binshard << EXTENT_BITS_BINSHARD_SHIFT);
173  }
174  static inline void
175  extent_addr_set(extent_t *extent, void *addr) {
176  	extent->e_addr = addr;
177  }
178  static inline void
179  extent_addr_randomize(tsdn_t *tsdn, extent_t *extent, size_t alignment) {
180  	assert(extent_base_get(extent) == extent_addr_get(extent));
181  	if (alignment < PAGE) {
182  		unsigned lg_range = LG_PAGE -
183  		    lg_floor(CACHELINE_CEILING(alignment));
184  		size_t r;
185  		if (!tsdn_null(tsdn)) {
186  			tsd_t *tsd = tsdn_tsd(tsdn);
187  			r = (size_t)prng_lg_range_u64(
188  			    tsd_offset_statep_get(tsd), lg_range);
189  		} else {
190  			r = prng_lg_range_zu(
191  			    &extent_arena_get(extent)->offset_state,
192  			    lg_range, true);
193  		}
194  		uintptr_t random_offset = ((uintptr_t)r) << (LG_PAGE -
195  		    lg_range);
196  		extent->e_addr = (void *)((uintptr_t)extent->e_addr +
197  		    random_offset);
198  		assert(ALIGNMENT_ADDR2BASE(extent->e_addr, alignment) ==
199  		    extent->e_addr);
200  	}
201  }
202  static inline void
203  extent_size_set(extent_t *extent, size_t size) {
204  	assert((size & ~EXTENT_SIZE_MASK) == 0);
205  	extent->e_size_esn = size | (extent->e_size_esn & ~EXTENT_SIZE_MASK);
206  }
207  static inline void
208  extent_esn_set(extent_t *extent, size_t esn) {
209  	extent->e_size_esn = (extent->e_size_esn & ~EXTENT_ESN_MASK) | (esn &
210  	    EXTENT_ESN_MASK);
211  }
212  static inline void
213  extent_bsize_set(extent_t *extent, size_t bsize) {
214  	extent->e_bsize = bsize;
215  }
216  static inline void
217  extent_szind_set(extent_t *extent, szind_t szind) {
218  	assert(szind <= SC_NSIZES); &bsol;* SC_NSIZES means "invalid". */
219  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_SZIND_MASK) |
220  	    ((uint64_t)szind << EXTENT_BITS_SZIND_SHIFT);
221  }
222  static inline void
223  extent_nfree_set(extent_t *extent, unsigned nfree) {
224  	assert(extent_slab_get(extent));
225  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_NFREE_MASK) |
226  	    ((uint64_t)nfree << EXTENT_BITS_NFREE_SHIFT);
227  }
228  static inline void
229  extent_nfree_binshard_set(extent_t *extent, unsigned nfree, unsigned binshard) {
230  	assert(binshard < bin_infos[extent_szind_get(extent)].n_shards);
231  	extent->e_bits = (extent->e_bits &
232  	    (~EXTENT_BITS_NFREE_MASK & ~EXTENT_BITS_BINSHARD_MASK)) |
233  	    ((uint64_t)binshard << EXTENT_BITS_BINSHARD_SHIFT) |
234  	    ((uint64_t)nfree << EXTENT_BITS_NFREE_SHIFT);
235  }
236  static inline void
237  extent_nfree_inc(extent_t *extent) {
238  	assert(extent_slab_get(extent));
239  	extent->e_bits += ((uint64_t)1U << EXTENT_BITS_NFREE_SHIFT);
240  }
241  static inline void
242  extent_nfree_dec(extent_t *extent) {
243  	assert(extent_slab_get(extent));
244  	extent->e_bits -= ((uint64_t)1U << EXTENT_BITS_NFREE_SHIFT);
245  }
246  static inline void
247  extent_nfree_sub(extent_t *extent, uint64_t n) {
248  	assert(extent_slab_get(extent));
249  	extent->e_bits -= (n << EXTENT_BITS_NFREE_SHIFT);
250  }
251  static inline void
252  extent_sn_set(extent_t *extent, size_t sn) {
253  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_SN_MASK) |
254  	    ((uint64_t)sn << EXTENT_BITS_SN_SHIFT);
255  }
256  static inline void
257  extent_state_set(extent_t *extent, extent_state_t state) {
258  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_STATE_MASK) |
259  	    ((uint64_t)state << EXTENT_BITS_STATE_SHIFT);
260  }
261  static inline void
262  extent_zeroed_set(extent_t *extent, bool zeroed) {
263  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_ZEROED_MASK) |
264  	    ((uint64_t)zeroed << EXTENT_BITS_ZEROED_SHIFT);
265  }
266  static inline void
267  extent_committed_set(extent_t *extent, bool committed) {
268  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_COMMITTED_MASK) |
269  	    ((uint64_t)committed << EXTENT_BITS_COMMITTED_SHIFT);
270  }
271  static inline void
272  extent_dumpable_set(extent_t *extent, bool dumpable) {
273  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_DUMPABLE_MASK) |
274  	    ((uint64_t)dumpable << EXTENT_BITS_DUMPABLE_SHIFT);
275  }
276  static inline void
277  extent_slab_set(extent_t *extent, bool slab) {
278  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_SLAB_MASK) |
279  	    ((uint64_t)slab << EXTENT_BITS_SLAB_SHIFT);
280  }
281  static inline void
282  extent_prof_tctx_set(extent_t *extent, prof_tctx_t *tctx) {
283  	atomic_store_p(&extent->e_prof_tctx, tctx, ATOMIC_RELEASE);
284  }
285  static inline void
286  extent_prof_alloc_time_set(extent_t *extent, nstime_t t) {
287  	nstime_copy(&extent->e_alloc_time, &t);
288  }
289  static inline bool
290  extent_is_head_get(extent_t *extent) {
291  	if (maps_coalesce) {
292  		not_reached();
293  	}
294  	return (bool)((extent->e_bits & EXTENT_BITS_IS_HEAD_MASK) >>
295  	    EXTENT_BITS_IS_HEAD_SHIFT);
296  }
297  static inline void
298  extent_is_head_set(extent_t *extent, bool is_head) {
299  	if (maps_coalesce) {
300  		not_reached();
301  	}
302  	extent->e_bits = (extent->e_bits & ~EXTENT_BITS_IS_HEAD_MASK) |
303  	    ((uint64_t)is_head << EXTENT_BITS_IS_HEAD_SHIFT);
304  }
305  static inline void
306  extent_init(extent_t *extent, arena_t *arena, void *addr, size_t size,
307      bool slab, szind_t szind, size_t sn, extent_state_t state, bool zeroed,
308      bool committed, bool dumpable, extent_head_state_t is_head) {
309  	assert(addr == PAGE_ADDR2BASE(addr) || !slab);
310  	extent_arena_set(extent, arena);
311  	extent_addr_set(extent, addr);
312  	extent_size_set(extent, size);
313  	extent_slab_set(extent, slab);
314  	extent_szind_set(extent, szind);
315  	extent_sn_set(extent, sn);
316  	extent_state_set(extent, state);
317  	extent_zeroed_set(extent, zeroed);
318  	extent_committed_set(extent, committed);
319  	extent_dumpable_set(extent, dumpable);
320  	ql_elm_new(extent, ql_link);
321  	if (!maps_coalesce) {
322  		extent_is_head_set(extent, (is_head == EXTENT_IS_HEAD) ? true :
323  		    false);
324  	}
325  	if (config_prof) {
326  		extent_prof_tctx_set(extent, NULL);
327  	}
328  }
329  static inline void
330  extent_binit(extent_t *extent, void *addr, size_t bsize, size_t sn) {
331  	extent_arena_set(extent, NULL);
332  	extent_addr_set(extent, addr);
333  	extent_bsize_set(extent, bsize);
334  	extent_slab_set(extent, false);
335  	extent_szind_set(extent, SC_NSIZES);
336  	extent_sn_set(extent, sn);
337  	extent_state_set(extent, extent_state_active);
338  	extent_zeroed_set(extent, true);
339  	extent_committed_set(extent, true);
340  	extent_dumpable_set(extent, true);
341  }
342  static inline void
343  extent_list_init(extent_list_t *list) {
344  	ql_new(list);
345  }
346  static inline extent_t *
347  extent_list_first(const extent_list_t *list) {
348  	return ql_first(list);
349  }
350  static inline extent_t *
351  extent_list_last(const extent_list_t *list) {
352  	return ql_last(list, ql_link);
353  }
354  static inline void
355  extent_list_append(extent_list_t *list, extent_t *extent) {
356  	ql_tail_insert(list, extent, ql_link);
357  }
358  static inline void
359  extent_list_prepend(extent_list_t *list, extent_t *extent) {
360  	ql_head_insert(list, extent, ql_link);
361  }
362  static inline void
363  extent_list_replace(extent_list_t *list, extent_t *to_remove,
364      extent_t *to_insert) {
365  	ql_after_insert(to_remove, to_insert, ql_link);
366  	ql_remove(list, to_remove, ql_link);
367  }
368  static inline void
369  extent_list_remove(extent_list_t *list, extent_t *extent) {
370  	ql_remove(list, extent, ql_link);
371  }
372  static inline int
373  extent_sn_comp(const extent_t *a, const extent_t *b) {
374  	size_t a_sn = extent_sn_get(a);
375  	size_t b_sn = extent_sn_get(b);
376  	return (a_sn > b_sn) - (a_sn < b_sn);
377  }
378  static inline int
379  extent_esn_comp(const extent_t *a, const extent_t *b) {
380  	size_t a_esn = extent_esn_get(a);
381  	size_t b_esn = extent_esn_get(b);
382  	return (a_esn > b_esn) - (a_esn < b_esn);
383  }
384  static inline int
385  extent_ad_comp(const extent_t *a, const extent_t *b) {
386  	uintptr_t a_addr = (uintptr_t)extent_addr_get(a);
387  	uintptr_t b_addr = (uintptr_t)extent_addr_get(b);
388  	return (a_addr > b_addr) - (a_addr < b_addr);
389  }
390  static inline int
391  extent_ead_comp(const extent_t *a, const extent_t *b) {
392  	uintptr_t a_eaddr = (uintptr_t)a;
393  	uintptr_t b_eaddr = (uintptr_t)b;
394  	return (a_eaddr > b_eaddr) - (a_eaddr < b_eaddr);
<span onclick='openModal()' class='match'>395  }
396  static inline int
397  extent_snad_comp(const extent_t *a, const extent_t *b) {
398  	int ret;
399  	ret = extent_sn_comp(a, b);
400  	if (ret != 0) {
401  		return ret;
402  	}
</span>403  	ret = extent_ad_comp(a, b);
404  	return ret;
405  }
406  static inline int
407  extent_esnead_comp(const extent_t *a, const extent_t *b) {
408  	int ret;
409  	ret = extent_esn_comp(a, b);
410  	if (ret != 0) {
411  		return ret;
412  	}
413  	ret = extent_ead_comp(a, b);
414  	return ret;
415  }
416  #endif &bsol;* JEMALLOC_INTERNAL_EXTENT_INLINES_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltm_desc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent_inlines.h</div>
                </div>
                <div class="column column_space"><pre><code>319  }
320  static int montgomery_setup(void *a, void **b)
321  {
322     int err;
323     LTC_ARGCHK(a != NULL);
324     LTC_ARGCHK(b != NULL);
325     *b = XCALLOC(1, sizeof(mp_digit));
326     if (*b == NULL) {
327        return CRYPT_MEM;
328     }
</pre></code></div>
                <div class="column column_space"><pre><code>395  }
396  static inline int
397  extent_snad_comp(const extent_t *a, const extent_t *b) {
398  	int ret;
399  	ret = extent_sn_comp(a, b);
400  	if (ret != 0) {
401  		return ret;
402  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    