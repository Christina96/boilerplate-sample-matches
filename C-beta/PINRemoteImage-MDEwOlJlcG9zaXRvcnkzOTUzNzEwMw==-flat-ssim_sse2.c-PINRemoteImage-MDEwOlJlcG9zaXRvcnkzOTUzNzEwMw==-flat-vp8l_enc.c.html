
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.122448979591836%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-ssim_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #include <assert.h>
4  #include <emmintrin.h>
5  #include "src/dsp/common_sse2.h"
6  #if !defined(WEBP_DISABLE_STATS)
7  static WEBP_INLINE void SubtractAndSquare_SSE2(const __m128i a, const __m128i b,
8                                                 __m128i* const sum) {
9    const __m128i a_b = _mm_subs_epu8(a, b);
10    const __m128i b_a = _mm_subs_epu8(b, a);
11    const __m128i abs_a_b = _mm_or_si128(a_b, b_a);
12    const __m128i zero = _mm_setzero_si128();
13    const __m128i C0 = _mm_unpacklo_epi8(abs_a_b, zero);
14    const __m128i C1 = _mm_unpackhi_epi8(abs_a_b, zero);
15    const __m128i sum1 = _mm_madd_epi16(C0, C0);
16    const __m128i sum2 = _mm_madd_epi16(C1, C1);
17    *sum = _mm_add_epi32(sum1, sum2);
18  }
19  static uint32_t AccumulateSSE_SSE2(const uint8_t* src1,
20                                     const uint8_t* src2, int len) {
21    int i = 0;
22    uint32_t sse2 = 0;
23    if (len >= 16) {
24      const int limit = len - 32;
25      int32_t tmp[4];
26      __m128i sum1;
27      __m128i sum = _mm_setzero_si128();
28      __m128i a0 = _mm_loadu_si128((const __m128i*)&src1[i]);
29      __m128i b0 = _mm_loadu_si128((const __m128i*)&src2[i]);
30      i += 16;
31      while (i <= limit) {
32        const __m128i a1 = _mm_loadu_si128((const __m128i*)&src1[i]);
33        const __m128i b1 = _mm_loadu_si128((const __m128i*)&src2[i]);
34        __m128i sum2;
35        i += 16;
36        SubtractAndSquare_SSE2(a0, b0, &sum1);
37        sum = _mm_add_epi32(sum, sum1);
38        a0 = _mm_loadu_si128((const __m128i*)&src1[i]);
39        b0 = _mm_loadu_si128((const __m128i*)&src2[i]);
40        i += 16;
41        SubtractAndSquare_SSE2(a1, b1, &sum2);
42        sum = _mm_add_epi32(sum, sum2);
43      }
44      SubtractAndSquare_SSE2(a0, b0, &sum1);
45      sum = _mm_add_epi32(sum, sum1);
46      _mm_storeu_si128((__m128i*)tmp, sum);
47      sse2 += (tmp[3] + tmp[2] + tmp[1] + tmp[0]);
48    }
49    for (; i < len; ++i) {
50      const int32_t diff = src1[i] - src2[i];
51      sse2 += diff * diff;
52    }
53    return sse2;
54  }
55  #endif  
56  #if !defined(WEBP_REDUCE_SIZE)
57  static uint32_t HorizontalAdd16b_SSE2(const __m128i* const m) {
58    uint16_t tmp[8];
59    const __m128i a = _mm_srli_si128(*m, 8);
60    const __m128i b = _mm_add_epi16(*m, a);
61    _mm_storeu_si128((__m128i*)tmp, b);
62    return (uint32_t)tmp[3] + tmp[2] + tmp[1] + tmp[0];
63  }
64  static uint32_t HorizontalAdd32b_SSE2(const __m128i* const m) {
65    const __m128i a = _mm_srli_si128(*m, 8);
66    const __m128i b = _mm_add_epi32(*m, a);
67    const __m128i c = _mm_add_epi32(b, _mm_srli_si128(b, 4));
68    return (uint32_t)_mm_cvtsi128_si32(c);
69  }
70  static const uint16_t kWeight[] = { 1, 2, 3, 4, 3, 2, 1, 0 };
71  #define ACCUMULATE_ROW(WEIGHT) do {                         \
72                            \
73    const __m128i Wy = _mm_set1_epi16((WEIGHT));              \
74    const __m128i W = _mm_mullo_epi16(Wx, Wy);                \
75           \
76    const __m128i a0 = _mm_loadl_epi64((const __m128i*)src1); \
77    const __m128i b0 = _mm_loadl_epi64((const __m128i*)src2); \
78                   \
79    const __m128i a1 = _mm_unpacklo_epi8(a0, zero);           \
80    const __m128i b1 = _mm_unpacklo_epi8(b0, zero);           \
81    const __m128i wa1 = _mm_mullo_epi16(a1, W);               \
82    const __m128i wb1 = _mm_mullo_epi16(b1, W);               \
83                                              \
84    xm  = _mm_add_epi16(xm, wa1);                             \
85    ym  = _mm_add_epi16(ym, wb1);                             \
86    xxm = _mm_add_epi32(xxm, _mm_madd_epi16(a1, wa1));        \
87    xym = _mm_add_epi32(xym, _mm_madd_epi16(a1, wb1));        \
88    yym = _mm_add_epi32(yym, _mm_madd_epi16(b1, wb1));        \
89    src1 += stride1;                                          \
90    src2 += stride2;                                          \
91  } while (0)
<span onclick='openModal()' class='match'>92  static double SSIMGet_SSE2(const uint8_t* src1, int stride1,
93                             const uint8_t* src2, int stride2) {
94    VP8DistoStats stats;
95    const __m128i zero = _mm_setzero_si128();
</span>96    __m128i xm = zero, ym = zero;                
97    __m128i xxm = zero, yym = zero, xym = zero;  
98    const __m128i Wx = _mm_loadu_si128((const __m128i*)kWeight);
99    assert(2 * VP8_SSIM_KERNEL + 1 == 7);
100    ACCUMULATE_ROW(1);
101    ACCUMULATE_ROW(2);
102    ACCUMULATE_ROW(3);
103    ACCUMULATE_ROW(4);
104    ACCUMULATE_ROW(3);
105    ACCUMULATE_ROW(2);
106    ACCUMULATE_ROW(1);
107    stats.xm  = HorizontalAdd16b_SSE2(&xm);
108    stats.ym  = HorizontalAdd16b_SSE2(&ym);
109    stats.xxm = HorizontalAdd32b_SSE2(&xxm);
110    stats.xym = HorizontalAdd32b_SSE2(&xym);
111    stats.yym = HorizontalAdd32b_SSE2(&yym);
112    return VP8SSIMFromStats(&stats);
113  }
114  #endif  
115  extern void VP8SSIMDspInitSSE2(void);
116  WEBP_TSAN_IGNORE_FUNCTION void VP8SSIMDspInitSSE2(void) {
117  #if !defined(WEBP_DISABLE_STATS)
118    VP8AccumulateSSE = AccumulateSSE_SSE2;
119  #endif
120  #if !defined(WEBP_REDUCE_SIZE)
121    VP8SSIMGet = SSIMGet_SSE2;
122  #endif
123  }
124  #else  
125  WEBP_DSP_INIT_STUB(VP8SSIMDspInitSSE2)
126  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include "src/enc/backward_references_enc.h"
4  #include "src/enc/histogram_enc.h"
5  #include "src/enc/vp8i_enc.h"
6  #include "src/enc/vp8li_enc.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  #include "src/utils/bit_writer_utils.h"
10  #include "src/utils/huffman_encode_utils.h"
11  #include "src/utils/utils.h"
12  #include "src/webp/format_constants.h"
13  #define MAX_HUFF_IMAGE_SIZE       2600
14  static int PaletteCompareColorsForQsort(const void* p1, const void* p2) {
15    const uint32_t a = WebPMemToUint32((uint8_t*)p1);
16    const uint32_t b = WebPMemToUint32((uint8_t*)p2);
17    assert(a != b);
18    return (a < b) ? -1 : 1;
19  }
20  static WEBP_INLINE uint32_t PaletteComponentDistance(uint32_t v) {
21    return (v <= 128) ? v : (256 - v);
22  }
23  static WEBP_INLINE uint32_t PaletteColorDistance(uint32_t col1, uint32_t col2) {
24    const uint32_t diff = VP8LSubPixels(col1, col2);
25    const int kMoreWeightForRGBThanForAlpha = 9;
26    uint32_t score;
27    score =  PaletteComponentDistance((diff >>  0) & 0xff);
28    score += PaletteComponentDistance((diff >>  8) & 0xff);
29    score += PaletteComponentDistance((diff >> 16) & 0xff);
30    score *= kMoreWeightForRGBThanForAlpha;
31    score += PaletteComponentDistance((diff >> 24) & 0xff);
32    return score;
33  }
34  static WEBP_INLINE void SwapColor(uint32_t* const col1, uint32_t* const col2) {
35    const uint32_t tmp = *col1;
36    *col1 = *col2;
37    *col2 = tmp;
38  }
39  static void GreedyMinimizeDeltas(uint32_t palette[], int num_colors) {
40    uint32_t predict = 0x00000000;
41    int i, k;
42    for (i = 0; i < num_colors; ++i) {
43      int best_ix = i;
44      uint32_t best_score = ~0U;
45      for (k = i; k < num_colors; ++k) {
46        const uint32_t cur_score = PaletteColorDistance(palette[k], predict);
47        if (best_score > cur_score) {
48          best_score = cur_score;
49          best_ix = k;
50        }
51      }
52      SwapColor(&palette[best_ix], &palette[i]);
53      predict = palette[i];
54    }
55  }
56  static int PaletteHasNonMonotonousDeltas(uint32_t palette[], int num_colors) {
57    uint32_t predict = 0x000000;
58    int i;
59    uint8_t sign_found = 0x00;
60    for (i = 0; i < num_colors; ++i) {
61      const uint32_t diff = VP8LSubPixels(palette[i], predict);
62      const uint8_t rd = (diff >> 16) & 0xff;
63      const uint8_t gd = (diff >>  8) & 0xff;
64      const uint8_t bd = (diff >>  0) & 0xff;
65      if (rd != 0x00) {
66        sign_found |= (rd < 0x80) ? 1 : 2;
67      }
68      if (gd != 0x00) {
69        sign_found |= (gd < 0x80) ? 8 : 16;
70      }
71      if (bd != 0x00) {
72        sign_found |= (bd < 0x80) ? 64 : 128;
73      }
74      predict = palette[i];
75    }
76    return (sign_found & (sign_found << 1)) != 0;  
77  }
78  static int AnalyzeAndCreatePalette(const WebPPicture* const pic,
79                                     int low_effort,
80                                     uint32_t palette[MAX_PALETTE_SIZE],
81                                     int* const palette_size) {
82    const int num_colors = WebPGetColorPalette(pic, palette);
83    if (num_colors > MAX_PALETTE_SIZE) {
84      *palette_size = 0;
85      return 0;
86    }
87    *palette_size = num_colors;
88    qsort(palette, num_colors, sizeof(*palette), PaletteCompareColorsForQsort);
89    if (!low_effort && PaletteHasNonMonotonousDeltas(palette, num_colors)) {
90      GreedyMinimizeDeltas(palette, num_colors);
91    }
92    return 1;
93  }
94  typedef enum {
95    kDirect = 0,
96    kSpatial = 1,
97    kSubGreen = 2,
98    kSpatialSubGreen = 3,
99    kPalette = 4,
100    kNumEntropyIx = 5
101  } EntropyIx;
102  typedef enum {
103    kHistoAlpha = 0,
104    kHistoAlphaPred,
105    kHistoGreen,
106    kHistoGreenPred,
107    kHistoRed,
108    kHistoRedPred,
109    kHistoBlue,
110    kHistoBluePred,
111    kHistoRedSubGreen,
112    kHistoRedPredSubGreen,
113    kHistoBlueSubGreen,
114    kHistoBluePredSubGreen,
115    kHistoPalette,
116    kHistoTotal  
117  } HistoIx;
118  static void AddSingleSubGreen(int p, uint32_t* const r, uint32_t* const b) {
119    const int green = p >> 8;  
120    ++r[((p >> 16) - green) & 0xff];
121    ++b[((p >>  0) - green) & 0xff];
122  }
123  static void AddSingle(uint32_t p,
124                        uint32_t* const a, uint32_t* const r,
125                        uint32_t* const g, uint32_t* const b) {
126    ++a[(p >> 24) & 0xff];
127    ++r[(p >> 16) & 0xff];
128    ++g[(p >>  8) & 0xff];
129    ++b[(p >>  0) & 0xff];
130  }
131  static WEBP_INLINE uint32_t HashPix(uint32_t pix) {
132    return ((((uint64_t)pix + (pix >> 19)) * 0x39c5fba7ull) & 0xffffffffu) >> 24;
133  }
134  static int AnalyzeEntropy(const uint32_t* argb,
135                            int width, int height, int argb_stride,
136                            int use_palette,
137                            int palette_size, int transform_bits,
138                            EntropyIx* const min_entropy_ix,
139                            int* const red_and_blue_always_zero) {
140    uint32_t* histo;
141    if (use_palette && palette_size <= 16) {
142      *min_entropy_ix = kPalette;
143      *red_and_blue_always_zero = 1;
144      return 1;
145    }
146    histo = (uint32_t*)WebPSafeCalloc(kHistoTotal, sizeof(*histo) * 256);
147    if (histo != NULL) {
148      int i, x, y;
149      const uint32_t* prev_row = NULL;
150      const uint32_t* curr_row = argb;
151      uint32_t pix_prev = argb[0];  
152      for (y = 0; y < height; ++y) {
153        for (x = 0; x < width; ++x) {
154          const uint32_t pix = curr_row[x];
155          const uint32_t pix_diff = VP8LSubPixels(pix, pix_prev);
156          pix_prev = pix;
157          if ((pix_diff == 0) || (prev_row != NULL && pix == prev_row[x])) {
158            continue;
159          }
160          AddSingle(pix,
161                    &histo[kHistoAlpha * 256],
162                    &histo[kHistoRed * 256],
163                    &histo[kHistoGreen * 256],
164                    &histo[kHistoBlue * 256]);
165          AddSingle(pix_diff,
166                    &histo[kHistoAlphaPred * 256],
167                    &histo[kHistoRedPred * 256],
168                    &histo[kHistoGreenPred * 256],
169                    &histo[kHistoBluePred * 256]);
170          AddSingleSubGreen(pix,
171                            &histo[kHistoRedSubGreen * 256],
172                            &histo[kHistoBlueSubGreen * 256]);
173          AddSingleSubGreen(pix_diff,
174                            &histo[kHistoRedPredSubGreen * 256],
175                            &histo[kHistoBluePredSubGreen * 256]);
176          {
177            const uint32_t hash = HashPix(pix);
178            ++histo[kHistoPalette * 256 + hash];
179          }
180        }
181        prev_row = curr_row;
182        curr_row += argb_stride;
183      }
184      {
185        double entropy_comp[kHistoTotal];
186        double entropy[kNumEntropyIx];
187        int k;
188        int last_mode_to_analyze = use_palette ? kPalette : kSpatialSubGreen;
189        int j;
190        ++histo[kHistoRedPredSubGreen * 256];
191        ++histo[kHistoBluePredSubGreen * 256];
192        ++histo[kHistoRedPred * 256];
193        ++histo[kHistoGreenPred * 256];
194        ++histo[kHistoBluePred * 256];
195        ++histo[kHistoAlphaPred * 256];
196        for (j = 0; j < kHistoTotal; ++j) {
197          entropy_comp[j] = VP8LBitsEntropy(&histo[j * 256], 256);
198        }
199        entropy[kDirect] = entropy_comp[kHistoAlpha] +
200            entropy_comp[kHistoRed] +
201            entropy_comp[kHistoGreen] +
202            entropy_comp[kHistoBlue];
203        entropy[kSpatial] = entropy_comp[kHistoAlphaPred] +
204            entropy_comp[kHistoRedPred] +
205            entropy_comp[kHistoGreenPred] +
206            entropy_comp[kHistoBluePred];
207        entropy[kSubGreen] = entropy_comp[kHistoAlpha] +
208            entropy_comp[kHistoRedSubGreen] +
209            entropy_comp[kHistoGreen] +
210            entropy_comp[kHistoBlueSubGreen];
211        entropy[kSpatialSubGreen] = entropy_comp[kHistoAlphaPred] +
212            entropy_comp[kHistoRedPredSubGreen] +
213            entropy_comp[kHistoGreenPred] +
214            entropy_comp[kHistoBluePredSubGreen];
215        entropy[kPalette] = entropy_comp[kHistoPalette];
216        entropy[kSpatial] += VP8LSubSampleSize(width, transform_bits) *
217                             VP8LSubSampleSize(height, transform_bits) *
218                             VP8LFastLog2(14);
219        entropy[kSpatialSubGreen] += VP8LSubSampleSize(width, transform_bits) *
220                                     VP8LSubSampleSize(height, transform_bits) *
221                                     VP8LFastLog2(24);
222        entropy[kPalette] += palette_size * 8;
223        *min_entropy_ix = kDirect;
224        for (k = kDirect + 1; k <= last_mode_to_analyze; ++k) {
225          if (entropy[*min_entropy_ix] > entropy[k]) {
226            *min_entropy_ix = (EntropyIx)k;
227          }
228        }
229        assert((int)*min_entropy_ix <= last_mode_to_analyze);
230        *red_and_blue_always_zero = 1;
231        {
232          static const uint8_t kHistoPairs[5][2] = {
233            { kHistoRed, kHistoBlue },
234            { kHistoRedPred, kHistoBluePred },
235            { kHistoRedSubGreen, kHistoBlueSubGreen },
236            { kHistoRedPredSubGreen, kHistoBluePredSubGreen },
237            { kHistoRed, kHistoBlue }
238          };
239          const uint32_t* const red_histo =
240              &histo[256 * kHistoPairs[*min_entropy_ix][0]];
241          const uint32_t* const blue_histo =
242              &histo[256 * kHistoPairs[*min_entropy_ix][1]];
243          for (i = 1; i < 256; ++i) {
244            if ((red_histo[i] | blue_histo[i]) != 0) {
245              *red_and_blue_always_zero = 0;
246              break;
247            }
248          }
249        }
250      }
251      WebPSafeFree(histo);
252      return 1;
253    } else {
254      return 0;
255    }
256  }
257  static int GetHistoBits(int method, int use_palette, int width, int height) {
258    int histo_bits = (use_palette ? 9 : 7) - method;
259    while (1) {
260      const int huff_image_size = VP8LSubSampleSize(width, histo_bits) *
261                                  VP8LSubSampleSize(height, histo_bits);
262      if (huff_image_size <= MAX_HUFF_IMAGE_SIZE) break;
263      ++histo_bits;
264    }
265    return (histo_bits < MIN_HUFFMAN_BITS) ? MIN_HUFFMAN_BITS :
266           (histo_bits > MAX_HUFFMAN_BITS) ? MAX_HUFFMAN_BITS : histo_bits;
267  }
268  static int GetTransformBits(int method, int histo_bits) {
269    const int max_transform_bits = (method < 4) ? 6 : (method > 4) ? 4 : 5;
270    const int res =
271        (histo_bits > max_transform_bits) ? max_transform_bits : histo_bits;
272    assert(res <= MAX_TRANSFORM_BITS);
273    return res;
274  }
275  #define CRUNCH_CONFIGS_LZ77_MAX 2
276  typedef struct {
277    int entropy_idx_;
278    int lz77s_types_to_try_[CRUNCH_CONFIGS_LZ77_MAX];
279    int lz77s_types_to_try_size_;
280  } CrunchConfig;
281  #define CRUNCH_CONFIGS_MAX kNumEntropyIx
282  static int EncoderAnalyze(VP8LEncoder* const enc,
283                            CrunchConfig crunch_configs[CRUNCH_CONFIGS_MAX],
284                            int* const crunch_configs_size,
285                            int* const red_and_blue_always_zero) {
286    const WebPPicture* const pic = enc->pic_;
287    const int width = pic->width;
288    const int height = pic->height;
289    const WebPConfig* const config = enc->config_;
290    const int method = config->method;
291    const int low_effort = (config->method == 0);
292    int i;
293    int use_palette;
294    int n_lz77s;
295    assert(pic != NULL && pic->argb != NULL);
296    use_palette =
297        AnalyzeAndCreatePalette(pic, low_effort,
298                                enc->palette_, &enc->palette_size_);
299    enc->histo_bits_ = GetHistoBits(method, use_palette,
300                                    pic->width, pic->height);
301    enc->transform_bits_ = GetTransformBits(method, enc->histo_bits_);
302    if (low_effort) {
303      crunch_configs[0].entropy_idx_ = use_palette ? kPalette : kSpatialSubGreen;
304      n_lz77s = 1;
305      *crunch_configs_size = 1;
306    } else {
307      EntropyIx min_entropy_ix;
308      n_lz77s = (enc->palette_size_ > 0 && enc->palette_size_ <= 16) ? 2 : 1;
309      if (!AnalyzeEntropy(pic->argb, width, height, pic->argb_stride, use_palette,
310                          enc->palette_size_, enc->transform_bits_,
311                          &min_entropy_ix, red_and_blue_always_zero)) {
312        return 0;
313      }
314      if (method == 6 && config->quality == 100) {
315        *crunch_configs_size = 0;
316        for (i = 0; i < kNumEntropyIx; ++i) {
317          if (i != kPalette || use_palette) {
318            assert(*crunch_configs_size < CRUNCH_CONFIGS_MAX);
319            crunch_configs[(*crunch_configs_size)++].entropy_idx_ = i;
320          }
321        }
322      } else {
323        *crunch_configs_size = 1;
324        crunch_configs[0].entropy_idx_ = min_entropy_ix;
325      }
326    }
327    assert(n_lz77s <= CRUNCH_CONFIGS_LZ77_MAX);
328    for (i = 0; i < *crunch_configs_size; ++i) {
329      int j;
330      for (j = 0; j < n_lz77s; ++j) {
331        crunch_configs[i].lz77s_types_to_try_[j] =
332            (j == 0) ? kLZ77Standard | kLZ77RLE : kLZ77Box;
333      }
334      crunch_configs[i].lz77s_types_to_try_size_ = n_lz77s;
335    }
336    return 1;
337  }
338  static int EncoderInit(VP8LEncoder* const enc) {
339    const WebPPicture* const pic = enc->pic_;
340    const int width = pic->width;
341    const int height = pic->height;
342    const int pix_cnt = width * height;
343    const int refs_block_size = (pix_cnt - 1) / MAX_REFS_BLOCK_PER_IMAGE + 1;
344    int i;
345    if (!VP8LHashChainInit(&enc->hash_chain_, pix_cnt)) return 0;
346    for (i = 0; i < 3; ++i) VP8LBackwardRefsInit(&enc->refs_[i], refs_block_size);
347    return 1;
348  }
349  static int GetHuffBitLengthsAndCodes(
350      const VP8LHistogramSet* const histogram_image,
351      HuffmanTreeCode* const huffman_codes) {
352    int i, k;
353    int ok = 0;
354    uint64_t total_length_size = 0;
355    uint8_t* mem_buf = NULL;
356    const int histogram_image_size = histogram_image->size;
357    int max_num_symbols = 0;
358    uint8_t* buf_rle = NULL;
359    HuffmanTree* huff_tree = NULL;
360    for (i = 0; i < histogram_image_size; ++i) {
361      const VP8LHistogram* const histo = histogram_image->histograms[i];
362      HuffmanTreeCode* const codes = &huffman_codes[5 * i];
363      assert(histo != NULL);
364      for (k = 0; k < 5; ++k) {
365        const int num_symbols =
366            (k == 0) ? VP8LHistogramNumCodes(histo->palette_code_bits_) :
367            (k == 4) ? NUM_DISTANCE_CODES : 256;
368        codes[k].num_symbols = num_symbols;
369        total_length_size += num_symbols;
370      }
371    }
372    {
373      uint16_t* codes;
374      uint8_t* lengths;
375      mem_buf = (uint8_t*)WebPSafeCalloc(total_length_size,
376                                         sizeof(*lengths) + sizeof(*codes));
377      if (mem_buf == NULL) goto End;
378      codes = (uint16_t*)mem_buf;
379      lengths = (uint8_t*)&codes[total_length_size];
380      for (i = 0; i < 5 * histogram_image_size; ++i) {
381        const int bit_length = huffman_codes[i].num_symbols;
382        huffman_codes[i].codes = codes;
383        huffman_codes[i].code_lengths = lengths;
384        codes += bit_length;
385        lengths += bit_length;
386        if (max_num_symbols < bit_length) {
387          max_num_symbols = bit_length;
388        }
389      }
390    }
391    buf_rle = (uint8_t*)WebPSafeMalloc(1ULL, max_num_symbols);
392    huff_tree = (HuffmanTree*)WebPSafeMalloc(3ULL * max_num_symbols,
393                                             sizeof(*huff_tree));
394    if (buf_rle == NULL || huff_tree == NULL) goto End;
395    for (i = 0; i < histogram_image_size; ++i) {
396      HuffmanTreeCode* const codes = &huffman_codes[5 * i];
397      VP8LHistogram* const histo = histogram_image->histograms[i];
398      VP8LCreateHuffmanTree(histo->literal_, 15, buf_rle, huff_tree, codes + 0);
399      VP8LCreateHuffmanTree(histo->red_, 15, buf_rle, huff_tree, codes + 1);
400      VP8LCreateHuffmanTree(histo->blue_, 15, buf_rle, huff_tree, codes + 2);
401      VP8LCreateHuffmanTree(histo->alpha_, 15, buf_rle, huff_tree, codes + 3);
402      VP8LCreateHuffmanTree(histo->distance_, 15, buf_rle, huff_tree, codes + 4);
403    }
404    ok = 1;
405   End:
406    WebPSafeFree(huff_tree);
407    WebPSafeFree(buf_rle);
408    if (!ok) {
409      WebPSafeFree(mem_buf);
410      memset(huffman_codes, 0, 5 * histogram_image_size * sizeof(*huffman_codes));
411    }
412    return ok;
413  }
414  static void StoreHuffmanTreeOfHuffmanTreeToBitMask(
415      VP8LBitWriter* const bw, const uint8_t* code_length_bitdepth) {
416    static const uint8_t kStorageOrder[CODE_LENGTH_CODES] = {
417      17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
418    };
419    int i;
420    int codes_to_store = CODE_LENGTH_CODES;
421    for (; codes_to_store > 4; --codes_to_store) {
422      if (code_length_bitdepth[kStorageOrder[codes_to_store - 1]] != 0) {
423        break;
424      }
425    }
426    VP8LPutBits(bw, codes_to_store - 4, 4);
427    for (i = 0; i < codes_to_store; ++i) {
428      VP8LPutBits(bw, code_length_bitdepth[kStorageOrder[i]], 3);
429    }
430  }
431  static void ClearHuffmanTreeIfOnlyOneSymbol(
432      HuffmanTreeCode* const huffman_code) {
433    int k;
434    int count = 0;
435    for (k = 0; k < huffman_code->num_symbols; ++k) {
436      if (huffman_code->code_lengths[k] != 0) {
437        ++count;
438        if (count > 1) return;
439      }
440    }
441    for (k = 0; k < huffman_code->num_symbols; ++k) {
442      huffman_code->code_lengths[k] = 0;
443      huffman_code->codes[k] = 0;
444    }
445  }
446  static void StoreHuffmanTreeToBitMask(
447      VP8LBitWriter* const bw,
448      const HuffmanTreeToken* const tokens, const int num_tokens,
449      const HuffmanTreeCode* const huffman_code) {
450    int i;
451    for (i = 0; i < num_tokens; ++i) {
452      const int ix = tokens[i].code;
453      const int extra_bits = tokens[i].extra_bits;
454      VP8LPutBits(bw, huffman_code->codes[ix], huffman_code->code_lengths[ix]);
455      switch (ix) {
456        case 16:
457          VP8LPutBits(bw, extra_bits, 2);
458          break;
459        case 17:
460          VP8LPutBits(bw, extra_bits, 3);
461          break;
462        case 18:
463          VP8LPutBits(bw, extra_bits, 7);
464          break;
465      }
466    }
467  }
468  static void StoreFullHuffmanCode(VP8LBitWriter* const bw,
469                                   HuffmanTree* const huff_tree,
470                                   HuffmanTreeToken* const tokens,
471                                   const HuffmanTreeCode* const tree) {
472    uint8_t code_length_bitdepth[CODE_LENGTH_CODES] = { 0 };
473    uint16_t code_length_bitdepth_symbols[CODE_LENGTH_CODES] = { 0 };
474    const int max_tokens = tree->num_symbols;
475    int num_tokens;
476    HuffmanTreeCode huffman_code;
477    huffman_code.num_symbols = CODE_LENGTH_CODES;
478    huffman_code.code_lengths = code_length_bitdepth;
479    huffman_code.codes = code_length_bitdepth_symbols;
480    VP8LPutBits(bw, 0, 1);
481    num_tokens = VP8LCreateCompressedHuffmanTree(tree, tokens, max_tokens);
482    {
483      uint32_t histogram[CODE_LENGTH_CODES] = { 0 };
484      uint8_t buf_rle[CODE_LENGTH_CODES] = { 0 };
485      int i;
486      for (i = 0; i < num_tokens; ++i) {
487        ++histogram[tokens[i].code];
488      }
489      VP8LCreateHuffmanTree(histogram, 7, buf_rle, huff_tree, &huffman_code);
490    }
491    StoreHuffmanTreeOfHuffmanTreeToBitMask(bw, code_length_bitdepth);
492    ClearHuffmanTreeIfOnlyOneSymbol(&huffman_code);
493    {
494      int trailing_zero_bits = 0;
495      int trimmed_length = num_tokens;
496      int write_trimmed_length;
497      int length;
498      int i = num_tokens;
499      while (i-- > 0) {
500        const int ix = tokens[i].code;
501        if (ix == 0 || ix == 17 || ix == 18) {
502          --trimmed_length;   
503          trailing_zero_bits += code_length_bitdepth[ix];
504          if (ix == 17) {
505            trailing_zero_bits += 3;
506          } else if (ix == 18) {
507            trailing_zero_bits += 7;
508          }
509        } else {
510          break;
511        }
512      }
513      write_trimmed_length = (trimmed_length > 1 && trailing_zero_bits > 12);
514      length = write_trimmed_length ? trimmed_length : num_tokens;
515      VP8LPutBits(bw, write_trimmed_length, 1);
516      if (write_trimmed_length) {
517        if (trimmed_length == 2) {
518          VP8LPutBits(bw, 0, 3 + 2);     
519        } else {
520          const int nbits = BitsLog2Floor(trimmed_length - 2);
521          const int nbitpairs = nbits / 2 + 1;
522          assert(trimmed_length > 2);
523          assert(nbitpairs - 1 < 8);
524          VP8LPutBits(bw, nbitpairs - 1, 3);
525          VP8LPutBits(bw, trimmed_length - 2, nbitpairs * 2);
526        }
527      }
528      StoreHuffmanTreeToBitMask(bw, tokens, length, &huffman_code);
529    }
530  }
<span onclick='openModal()' class='match'>531  static void StoreHuffmanCode(VP8LBitWriter* const bw,
532                               HuffmanTree* const huff_tree,
533                               HuffmanTreeToken* const tokens,
534                               const HuffmanTreeCode* const huffman_code) {
535    int i;
536    int count = 0;
</span>537    int symbols[2] = { 0, 0 };
538    const int kMaxBits = 8;
539    const int kMaxSymbol = 1 << kMaxBits;
540    for (i = 0; i < huffman_code->num_symbols && count < 3; ++i) {
541      if (huffman_code->code_lengths[i] != 0) {
542        if (count < 2) symbols[count] = i;
543        ++count;
544      }
545    }
546    if (count == 0) {   
547      VP8LPutBits(bw, 0x01, 4);
548    } else if (count <= 2 && symbols[0] < kMaxSymbol && symbols[1] < kMaxSymbol) {
549      VP8LPutBits(bw, 1, 1);  
550      VP8LPutBits(bw, count - 1, 1);
551      if (symbols[0] <= 1) {
552        VP8LPutBits(bw, 0, 1);  
553        VP8LPutBits(bw, symbols[0], 1);
554      } else {
555        VP8LPutBits(bw, 1, 1);
556        VP8LPutBits(bw, symbols[0], 8);
557      }
558      if (count == 2) {
559        VP8LPutBits(bw, symbols[1], 8);
560      }
561    } else {
562      StoreFullHuffmanCode(bw, huff_tree, tokens, huffman_code);
563    }
564  }
565  static WEBP_INLINE void WriteHuffmanCode(VP8LBitWriter* const bw,
566                               const HuffmanTreeCode* const code,
567                               int code_index) {
568    const int depth = code->code_lengths[code_index];
569    const int symbol = code->codes[code_index];
570    VP8LPutBits(bw, symbol, depth);
571  }
572  static WEBP_INLINE void WriteHuffmanCodeWithExtraBits(
573      VP8LBitWriter* const bw,
574      const HuffmanTreeCode* const code,
575      int code_index,
576      int bits,
577      int n_bits) {
578    const int depth = code->code_lengths[code_index];
579    const int symbol = code->codes[code_index];
580    VP8LPutBits(bw, (bits << depth) | symbol, depth + n_bits);
581  }
582  static WebPEncodingError StoreImageToBitMask(
583      VP8LBitWriter* const bw, int width, int histo_bits,
584      const VP8LBackwardRefs* const refs,
585      const uint16_t* histogram_symbols,
586      const HuffmanTreeCode* const huffman_codes) {
587    const int histo_xsize = histo_bits ? VP8LSubSampleSize(width, histo_bits) : 1;
588    const int tile_mask = (histo_bits == 0) ? 0 : -(1 << histo_bits);
589    int x = 0;
590    int y = 0;
591    int tile_x = x & tile_mask;
592    int tile_y = y & tile_mask;
593    int histogram_ix = histogram_symbols[0];
594    const HuffmanTreeCode* codes = huffman_codes + 5 * histogram_ix;
595    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
596    while (VP8LRefsCursorOk(&c)) {
597      const PixOrCopy* const v = c.cur_pos;
598      if ((tile_x != (x & tile_mask)) || (tile_y != (y & tile_mask))) {
599        tile_x = x & tile_mask;
600        tile_y = y & tile_mask;
601        histogram_ix = histogram_symbols[(y >> histo_bits) * histo_xsize +
602                                         (x >> histo_bits)];
603        codes = huffman_codes + 5 * histogram_ix;
604      }
605      if (PixOrCopyIsLiteral(v)) {
606        static const uint8_t order[] = { 1, 2, 0, 3 };
607        int k;
608        for (k = 0; k < 4; ++k) {
609          const int code = PixOrCopyLiteral(v, order[k]);
610          WriteHuffmanCode(bw, codes + k, code);
611        }
612      } else if (PixOrCopyIsCacheIdx(v)) {
613        const int code = PixOrCopyCacheIdx(v);
614        const int literal_ix = 256 + NUM_LENGTH_CODES + code;
615        WriteHuffmanCode(bw, codes, literal_ix);
616      } else {
617        int bits, n_bits;
618        int code;
619        const int distance = PixOrCopyDistance(v);
620        VP8LPrefixEncode(v->len, &code, &n_bits, &bits);
621        WriteHuffmanCodeWithExtraBits(bw, codes, 256 + code, bits, n_bits);
622        VP8LPrefixEncode(distance, &code, &n_bits, &bits);
623        WriteHuffmanCode(bw, codes + 4, code);
624        VP8LPutBits(bw, bits, n_bits);
625      }
626      x += PixOrCopyLength(v);
627      while (x >= width) {
628        x -= width;
629        ++y;
630      }
631      VP8LRefsCursorNext(&c);
632    }
633    return bw->error_ ? VP8_ENC_ERROR_OUT_OF_MEMORY : VP8_ENC_OK;
634  }
635  static WebPEncodingError EncodeImageNoHuffman(VP8LBitWriter* const bw,
636                                                const uint32_t* const argb,
637                                                VP8LHashChain* const hash_chain,
638                                                VP8LBackwardRefs* const refs_tmp1,
639                                                VP8LBackwardRefs* const refs_tmp2,
640                                                int width, int height,
641                                                int quality, int low_effort) {
642    int i;
643    int max_tokens = 0;
644    WebPEncodingError err = VP8_ENC_OK;
645    VP8LBackwardRefs* refs;
646    HuffmanTreeToken* tokens = NULL;
647    HuffmanTreeCode huffman_codes[5] = { { 0, NULL, NULL } };
648    const uint16_t histogram_symbols[1] = { 0 };    
649    int cache_bits = 0;
650    VP8LHistogramSet* histogram_image = NULL;
651    HuffmanTree* const huff_tree = (HuffmanTree*)WebPSafeMalloc(
652          3ULL * CODE_LENGTH_CODES, sizeof(*huff_tree));
653    if (huff_tree == NULL) {
654      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
655      goto Error;
656    }
657    if (!VP8LHashChainFill(hash_chain, quality, argb, width, height,
658                           low_effort)) {
659      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
660      goto Error;
661    }
662    refs = VP8LGetBackwardReferences(width, height, argb, quality, 0,
663                                     kLZ77Standard | kLZ77RLE, &cache_bits,
664                                     hash_chain, refs_tmp1, refs_tmp2);
665    if (refs == NULL) {
666      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
667      goto Error;
668    }
669    histogram_image = VP8LAllocateHistogramSet(1, cache_bits);
670    if (histogram_image == NULL) {
671      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
672      goto Error;
673    }
674    VP8LHistogramSetClear(histogram_image);
675    VP8LHistogramStoreRefs(refs, histogram_image->histograms[0]);
676    assert(histogram_image->size == 1);
677    if (!GetHuffBitLengthsAndCodes(histogram_image, huffman_codes)) {
678      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
679      goto Error;
680    }
681    VP8LPutBits(bw, 0, 1);
682    for (i = 0; i < 5; ++i) {
683      HuffmanTreeCode* const codes = &huffman_codes[i];
684      if (max_tokens < codes->num_symbols) {
685        max_tokens = codes->num_symbols;
686      }
687    }
688    tokens = (HuffmanTreeToken*)WebPSafeMalloc(max_tokens, sizeof(*tokens));
689    if (tokens == NULL) {
690      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
691      goto Error;
692    }
693    for (i = 0; i < 5; ++i) {
694      HuffmanTreeCode* const codes = &huffman_codes[i];
695      StoreHuffmanCode(bw, huff_tree, tokens, codes);
696      ClearHuffmanTreeIfOnlyOneSymbol(codes);
697    }
698    err = StoreImageToBitMask(bw, width, 0, refs, histogram_symbols,
699                              huffman_codes);
700   Error:
701    WebPSafeFree(tokens);
702    WebPSafeFree(huff_tree);
703    VP8LFreeHistogramSet(histogram_image);
704    WebPSafeFree(huffman_codes[0].codes);
705    return err;
706  }
707  static WebPEncodingError EncodeImageInternal(
708      VP8LBitWriter* const bw, const uint32_t* const argb,
709      VP8LHashChain* const hash_chain, VP8LBackwardRefs refs_array[3], int width,
710      int height, int quality, int low_effort, int use_cache,
711      const CrunchConfig* const config, int* cache_bits, int histogram_bits,
712      size_t init_byte_position, int* const hdr_size, int* const data_size) {
713    WebPEncodingError err = VP8_ENC_OK;
714    const uint32_t histogram_image_xysize =
715        VP8LSubSampleSize(width, histogram_bits) *
716        VP8LSubSampleSize(height, histogram_bits);
717    VP8LHistogramSet* histogram_image = NULL;
718    VP8LHistogram* tmp_histo = NULL;
719    int histogram_image_size = 0;
720    size_t bit_array_size = 0;
721    HuffmanTree* const huff_tree = (HuffmanTree*)WebPSafeMalloc(
722        3ULL * CODE_LENGTH_CODES, sizeof(*huff_tree));
723    HuffmanTreeToken* tokens = NULL;
724    HuffmanTreeCode* huffman_codes = NULL;
725    VP8LBackwardRefs* refs_best;
726    VP8LBackwardRefs* refs_tmp;
727    uint16_t* const histogram_symbols =
728        (uint16_t*)WebPSafeMalloc(histogram_image_xysize,
729                                  sizeof(*histogram_symbols));
730    int lz77s_idx;
731    VP8LBitWriter bw_init = *bw, bw_best;
732    int hdr_size_tmp;
733    assert(histogram_bits >= MIN_HUFFMAN_BITS);
734    assert(histogram_bits <= MAX_HUFFMAN_BITS);
735    assert(hdr_size != NULL);
736    assert(data_size != NULL);
737    if (histogram_symbols == NULL) {
738      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
739      goto Error;
740    }
741    if (use_cache) {
742      if (*cache_bits == 0) *cache_bits = MAX_COLOR_CACHE_BITS;
743    } else {
744      *cache_bits = 0;
745    }
746    if (huff_tree == NULL ||
747        !VP8LHashChainFill(hash_chain, quality, argb, width, height,
748                           low_effort) ||
749        !VP8LBitWriterInit(&bw_best, 0) ||
750        (config->lz77s_types_to_try_size_ > 1 &&
751         !VP8LBitWriterClone(bw, &bw_best))) {
752      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
753      goto Error;
754    }
755    for (lz77s_idx = 0; lz77s_idx < config->lz77s_types_to_try_size_;
756         ++lz77s_idx) {
757      refs_best = VP8LGetBackwardReferences(
758          width, height, argb, quality, low_effort,
759          config->lz77s_types_to_try_[lz77s_idx], cache_bits, hash_chain,
760          &refs_array[0], &refs_array[1]);
761      if (refs_best == NULL) {
762        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
763        goto Error;
764      }
765      refs_tmp = &refs_array[refs_best == &refs_array[0] ? 1 : 0];
766      histogram_image =
767          VP8LAllocateHistogramSet(histogram_image_xysize, *cache_bits);
768      tmp_histo = VP8LAllocateHistogram(*cache_bits);
769      if (histogram_image == NULL || tmp_histo == NULL) {
770        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
771        goto Error;
772      }
773      if (!VP8LGetHistoImageSymbols(width, height, refs_best, quality, low_effort,
774                                    histogram_bits, *cache_bits, histogram_image,
775                                    tmp_histo, histogram_symbols)) {
776        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
777        goto Error;
778      }
779      histogram_image_size = histogram_image->size;
780      bit_array_size = 5 * histogram_image_size;
781      huffman_codes = (HuffmanTreeCode*)WebPSafeCalloc(bit_array_size,
782                                                       sizeof(*huffman_codes));
783      if (huffman_codes == NULL ||
784          !GetHuffBitLengthsAndCodes(histogram_image, huffman_codes)) {
785        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
786        goto Error;
787      }
788      VP8LFreeHistogramSet(histogram_image);
789      histogram_image = NULL;
790      VP8LFreeHistogram(tmp_histo);
791      tmp_histo = NULL;
792      if (*cache_bits > 0) {
793        VP8LPutBits(bw, 1, 1);
794        VP8LPutBits(bw, *cache_bits, 4);
795      } else {
796        VP8LPutBits(bw, 0, 1);
797      }
798      {
799        const int write_histogram_image = (histogram_image_size > 1);
800        VP8LPutBits(bw, write_histogram_image, 1);
801        if (write_histogram_image) {
802          uint32_t* const histogram_argb =
803              (uint32_t*)WebPSafeMalloc(histogram_image_xysize,
804                                        sizeof(*histogram_argb));
805          int max_index = 0;
806          uint32_t i;
807          if (histogram_argb == NULL) {
808            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
809            goto Error;
810          }
811          for (i = 0; i < histogram_image_xysize; ++i) {
812            const int symbol_index = histogram_symbols[i] & 0xffff;
813            histogram_argb[i] = (symbol_index << 8);
814            if (symbol_index >= max_index) {
815              max_index = symbol_index + 1;
816            }
817          }
818          histogram_image_size = max_index;
819          VP8LPutBits(bw, histogram_bits - 2, 3);
820          err = EncodeImageNoHuffman(
821              bw, histogram_argb, hash_chain, refs_tmp, &refs_array[2],
822              VP8LSubSampleSize(width, histogram_bits),
823              VP8LSubSampleSize(height, histogram_bits), quality, low_effort);
824          WebPSafeFree(histogram_argb);
825          if (err != VP8_ENC_OK) goto Error;
826        }
827      }
828      {
829        int i;
830        int max_tokens = 0;
831        for (i = 0; i < 5 * histogram_image_size; ++i) {
832          HuffmanTreeCode* const codes = &huffman_codes[i];
833          if (max_tokens < codes->num_symbols) {
834            max_tokens = codes->num_symbols;
835          }
836        }
837        tokens = (HuffmanTreeToken*)WebPSafeMalloc(max_tokens, sizeof(*tokens));
838        if (tokens == NULL) {
839          err = VP8_ENC_ERROR_OUT_OF_MEMORY;
840          goto Error;
841        }
842        for (i = 0; i < 5 * histogram_image_size; ++i) {
843          HuffmanTreeCode* const codes = &huffman_codes[i];
844          StoreHuffmanCode(bw, huff_tree, tokens, codes);
845          ClearHuffmanTreeIfOnlyOneSymbol(codes);
846        }
847      }
848      hdr_size_tmp = (int)(VP8LBitWriterNumBytes(bw) - init_byte_position);
849      err = StoreImageToBitMask(bw, width, histogram_bits, refs_best,
850                                histogram_symbols, huffman_codes);
851      if (lz77s_idx == 0 ||
852          VP8LBitWriterNumBytes(bw) < VP8LBitWriterNumBytes(&bw_best)) {
853        *hdr_size = hdr_size_tmp;
854        *data_size =
855            (int)(VP8LBitWriterNumBytes(bw) - init_byte_position - *hdr_size);
856        VP8LBitWriterSwap(bw, &bw_best);
857      }
858      if (config->lz77s_types_to_try_size_ > 1) VP8LBitWriterReset(&bw_init, bw);
859      WebPSafeFree(tokens);
860      tokens = NULL;
861      if (huffman_codes != NULL) {
862        WebPSafeFree(huffman_codes->codes);
863        WebPSafeFree(huffman_codes);
864        huffman_codes = NULL;
865      }
866    }
867    VP8LBitWriterSwap(bw, &bw_best);
868   Error:
869    WebPSafeFree(tokens);
870    WebPSafeFree(huff_tree);
871    VP8LFreeHistogramSet(histogram_image);
872    VP8LFreeHistogram(tmp_histo);
873    if (huffman_codes != NULL) {
874      WebPSafeFree(huffman_codes->codes);
875      WebPSafeFree(huffman_codes);
876    }
877    WebPSafeFree(histogram_symbols);
878    VP8LBitWriterWipeOut(&bw_best);
879    return err;
880  }
881  static void ApplySubtractGreen(VP8LEncoder* const enc, int width, int height,
882                                 VP8LBitWriter* const bw) {
883    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
884    VP8LPutBits(bw, SUBTRACT_GREEN, 2);
885    VP8LSubtractGreenFromBlueAndRed(enc->argb_, width * height);
886  }
887  static WebPEncodingError ApplyPredictFilter(const VP8LEncoder* const enc,
888                                              int width, int height,
889                                              int quality, int low_effort,
890                                              int used_subtract_green,
891                                              VP8LBitWriter* const bw) {
892    const int pred_bits = enc->transform_bits_;
893    const int transform_width = VP8LSubSampleSize(width, pred_bits);
894    const int transform_height = VP8LSubSampleSize(height, pred_bits);
895    const int near_lossless_strength = enc->use_palette_ ? 100
896                                     : enc->config_->near_lossless;
897    VP8LResidualImage(width, height, pred_bits, low_effort, enc->argb_,
898                      enc->argb_scratch_, enc->transform_data_,
899                      near_lossless_strength, enc->config_->exact,
900                      used_subtract_green);
901    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
902    VP8LPutBits(bw, PREDICTOR_TRANSFORM, 2);
903    assert(pred_bits >= 2);
904    VP8LPutBits(bw, pred_bits - 2, 3);
905    return EncodeImageNoHuffman(
906        bw, enc->transform_data_, (VP8LHashChain*)&enc->hash_chain_,
907        (VP8LBackwardRefs*)&enc->refs_[0],  
908        (VP8LBackwardRefs*)&enc->refs_[1], transform_width, transform_height,
909        quality, low_effort);
910  }
911  static WebPEncodingError ApplyCrossColorFilter(const VP8LEncoder* const enc,
912                                                 int width, int height,
913                                                 int quality, int low_effort,
914                                                 VP8LBitWriter* const bw) {
915    const int ccolor_transform_bits = enc->transform_bits_;
916    const int transform_width = VP8LSubSampleSize(width, ccolor_transform_bits);
917    const int transform_height = VP8LSubSampleSize(height, ccolor_transform_bits);
918    VP8LColorSpaceTransform(width, height, ccolor_transform_bits, quality,
919                            enc->argb_, enc->transform_data_);
920    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
921    VP8LPutBits(bw, CROSS_COLOR_TRANSFORM, 2);
922    assert(ccolor_transform_bits >= 2);
923    VP8LPutBits(bw, ccolor_transform_bits - 2, 3);
924    return EncodeImageNoHuffman(
925        bw, enc->transform_data_, (VP8LHashChain*)&enc->hash_chain_,
926        (VP8LBackwardRefs*)&enc->refs_[0],  
927        (VP8LBackwardRefs*)&enc->refs_[1], transform_width, transform_height,
928        quality, low_effort);
929  }
930  static WebPEncodingError WriteRiffHeader(const WebPPicture* const pic,
931                                           size_t riff_size, size_t vp8l_size) {
932    uint8_t riff[RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE + VP8L_SIGNATURE_SIZE] = {
933      'R', 'I', 'F', 'F', 0, 0, 0, 0, 'W', 'E', 'B', 'P',
934      'V', 'P', '8', 'L', 0, 0, 0, 0, VP8L_MAGIC_BYTE,
935    };
936    PutLE32(riff + TAG_SIZE, (uint32_t)riff_size);
937    PutLE32(riff + RIFF_HEADER_SIZE + TAG_SIZE, (uint32_t)vp8l_size);
938    if (!pic->writer(riff, sizeof(riff), pic)) {
939      return VP8_ENC_ERROR_BAD_WRITE;
940    }
941    return VP8_ENC_OK;
942  }
943  static int WriteImageSize(const WebPPicture* const pic,
944                            VP8LBitWriter* const bw) {
945    const int width = pic->width - 1;
946    const int height = pic->height - 1;
947    assert(width < WEBP_MAX_DIMENSION && height < WEBP_MAX_DIMENSION);
948    VP8LPutBits(bw, width, VP8L_IMAGE_SIZE_BITS);
949    VP8LPutBits(bw, height, VP8L_IMAGE_SIZE_BITS);
950    return !bw->error_;
951  }
952  static int WriteRealAlphaAndVersion(VP8LBitWriter* const bw, int has_alpha) {
953    VP8LPutBits(bw, has_alpha, 1);
954    VP8LPutBits(bw, VP8L_VERSION, VP8L_VERSION_BITS);
955    return !bw->error_;
956  }
957  static WebPEncodingError WriteImage(const WebPPicture* const pic,
958                                      VP8LBitWriter* const bw,
959                                      size_t* const coded_size) {
960    WebPEncodingError err = VP8_ENC_OK;
961    const uint8_t* const webpll_data = VP8LBitWriterFinish(bw);
962    const size_t webpll_size = VP8LBitWriterNumBytes(bw);
963    const size_t vp8l_size = VP8L_SIGNATURE_SIZE + webpll_size;
964    const size_t pad = vp8l_size & 1;
965    const size_t riff_size = TAG_SIZE + CHUNK_HEADER_SIZE + vp8l_size + pad;
966    err = WriteRiffHeader(pic, riff_size, vp8l_size);
967    if (err != VP8_ENC_OK) goto Error;
968    if (!pic->writer(webpll_data, webpll_size, pic)) {
969      err = VP8_ENC_ERROR_BAD_WRITE;
970      goto Error;
971    }
972    if (pad) {
973      const uint8_t pad_byte[1] = { 0 };
974      if (!pic->writer(pad_byte, 1, pic)) {
975        err = VP8_ENC_ERROR_BAD_WRITE;
976        goto Error;
977      }
978    }
979    *coded_size = CHUNK_HEADER_SIZE + riff_size;
980    return VP8_ENC_OK;
981   Error:
982    return err;
983  }
984  static void ClearTransformBuffer(VP8LEncoder* const enc) {
985    WebPSafeFree(enc->transform_mem_);
986    enc->transform_mem_ = NULL;
987    enc->transform_mem_size_ = 0;
988  }
989  static WebPEncodingError AllocateTransformBuffer(VP8LEncoder* const enc,
990                                                   int width, int height) {
991    WebPEncodingError err = VP8_ENC_OK;
992    const uint64_t image_size = width * height;
993    const uint64_t argb_scratch_size =
994        enc->use_predict_
995            ? (width + 1) * 2 +
996              (width * 2 + sizeof(uint32_t) - 1) / sizeof(uint32_t)
997            : 0;
998    const uint64_t transform_data_size =
999        (enc->use_predict_ || enc->use_cross_color_)
1000            ? VP8LSubSampleSize(width, enc->transform_bits_) *
1001                  VP8LSubSampleSize(height, enc->transform_bits_)
1002            : 0;
1003    const uint64_t max_alignment_in_words =
1004        (WEBP_ALIGN_CST + sizeof(uint32_t) - 1) / sizeof(uint32_t);
1005    const uint64_t mem_size =
1006        image_size + max_alignment_in_words +
1007        argb_scratch_size + max_alignment_in_words +
1008        transform_data_size;
1009    uint32_t* mem = enc->transform_mem_;
1010    if (mem == NULL || mem_size > enc->transform_mem_size_) {
1011      ClearTransformBuffer(enc);
1012      mem = (uint32_t*)WebPSafeMalloc(mem_size, sizeof(*mem));
1013      if (mem == NULL) {
1014        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1015        goto Error;
1016      }
1017      enc->transform_mem_ = mem;
1018      enc->transform_mem_size_ = (size_t)mem_size;
1019      enc->argb_content_ = kEncoderNone;
1020    }
1021    enc->argb_ = mem;
1022    mem = (uint32_t*)WEBP_ALIGN(mem + image_size);
1023    enc->argb_scratch_ = mem;
1024    mem = (uint32_t*)WEBP_ALIGN(mem + argb_scratch_size);
1025    enc->transform_data_ = mem;
1026    enc->current_width_ = width;
1027   Error:
1028    return err;
1029  }
1030  static WebPEncodingError MakeInputImageCopy(VP8LEncoder* const enc) {
1031    WebPEncodingError err = VP8_ENC_OK;
1032    const WebPPicture* const picture = enc->pic_;
1033    const int width = picture->width;
1034    const int height = picture->height;
1035    err = AllocateTransformBuffer(enc, width, height);
1036    if (err != VP8_ENC_OK) return err;
1037    if (enc->argb_content_ == kEncoderARGB) return VP8_ENC_OK;
1038    {
1039      uint32_t* dst = enc->argb_;
1040      const uint32_t* src = picture->argb;
1041      int y;
1042      for (y = 0; y < height; ++y) {
1043        memcpy(dst, src, width * sizeof(*dst));
1044        dst += width;
1045        src += picture->argb_stride;
1046      }
1047    }
1048    enc->argb_content_ = kEncoderARGB;
1049    assert(enc->current_width_ == width);
1050    return VP8_ENC_OK;
1051  }
1052  static WEBP_INLINE int SearchColorNoIdx(const uint32_t sorted[], uint32_t color,
1053                                          int hi) {
1054    int low = 0;
1055    if (sorted[low] == color) return low;  
1056    while (1) {
1057      const int mid = (low + hi) >> 1;
1058      if (sorted[mid] == color) {
1059        return mid;
1060      } else if (sorted[mid] < color) {
1061        low = mid;
1062      } else {
1063        hi = mid;
1064      }
1065    }
1066  }
1067  #define APPLY_PALETTE_GREEDY_MAX 4
1068  static WEBP_INLINE uint32_t SearchColorGreedy(const uint32_t palette[],
1069                                                int palette_size,
1070                                                uint32_t color) {
1071    (void)palette_size;
1072    assert(palette_size < APPLY_PALETTE_GREEDY_MAX);
1073    assert(3 == APPLY_PALETTE_GREEDY_MAX - 1);
1074    if (color == palette[0]) return 0;
1075    if (color == palette[1]) return 1;
1076    if (color == palette[2]) return 2;
1077    return 3;
1078  }
1079  static WEBP_INLINE uint32_t ApplyPaletteHash0(uint32_t color) {
1080    return (color >> 8) & 0xff;
1081  }
1082  #define PALETTE_INV_SIZE_BITS 11
1083  #define PALETTE_INV_SIZE (1 << PALETTE_INV_SIZE_BITS)
1084  static WEBP_INLINE uint32_t ApplyPaletteHash1(uint32_t color) {
1085    return ((uint32_t)((color & 0x00ffffffu) * 4222244071ull)) >>
1086           (32 - PALETTE_INV_SIZE_BITS);
1087  }
1088  static WEBP_INLINE uint32_t ApplyPaletteHash2(uint32_t color) {
1089    return ((uint32_t)((color & 0x00ffffffu) * ((1ull << 31) - 1))) >>
1090           (32 - PALETTE_INV_SIZE_BITS);
1091  }
1092  static void PrepareMapToPalette(const uint32_t palette[], int num_colors,
1093                                  uint32_t sorted[], uint32_t idx_map[]) {
1094    int i;
1095    memcpy(sorted, palette, num_colors * sizeof(*sorted));
1096    qsort(sorted, num_colors, sizeof(*sorted), PaletteCompareColorsForQsort);
1097    for (i = 0; i < num_colors; ++i) {
1098      idx_map[SearchColorNoIdx(sorted, palette[i], num_colors)] = i;
1099    }
1100  }
1101  #define APPLY_PALETTE_FOR(COLOR_INDEX) do {         \
1102    uint32_t prev_pix = palette[0];                   \
1103    uint32_t prev_idx = 0;                            \
1104    for (y = 0; y < height; ++y) {                    \
1105      for (x = 0; x < width; ++x) {                   \
1106        const uint32_t pix = src[x];                  \
1107        if (pix != prev_pix) {                        \
1108          prev_idx = COLOR_INDEX;                     \
1109          prev_pix = pix;                             \
1110        }                                             \
1111        tmp_row[x] = prev_idx;                        \
1112      }                                               \
1113      VP8LBundleColorMap(tmp_row, width, xbits, dst); \
1114      src += src_stride;                              \
1115      dst += dst_stride;                              \
1116    }                                                 \
1117  } while (0)
1118  static WebPEncodingError ApplyPalette(const uint32_t* src, uint32_t src_stride,
1119                                        uint32_t* dst, uint32_t dst_stride,
1120                                        const uint32_t* palette, int palette_size,
1121                                        int width, int height, int xbits) {
1122    uint8_t* const tmp_row = (uint8_t*)WebPSafeMalloc(width, sizeof(*tmp_row));
1123    int x, y;
1124    if (tmp_row == NULL) return VP8_ENC_ERROR_OUT_OF_MEMORY;
1125    if (palette_size < APPLY_PALETTE_GREEDY_MAX) {
1126      APPLY_PALETTE_FOR(SearchColorGreedy(palette, palette_size, pix));
1127    } else {
1128      int i, j;
1129      uint16_t buffer[PALETTE_INV_SIZE];
1130      uint32_t (*const hash_functions[])(uint32_t) = {
1131          ApplyPaletteHash0, ApplyPaletteHash1, ApplyPaletteHash2
1132      };
1133      for (i = 0; i < 3; ++i) {
1134        int use_LUT = 1;
1135        memset(buffer, 0xff, sizeof(buffer));
1136        for (j = 0; j < palette_size; ++j) {
1137          const uint32_t ind = hash_functions[i](palette[j]);
1138          if (buffer[ind] != 0xffffu) {
1139            use_LUT = 0;
1140            break;
1141          } else {
1142            buffer[ind] = j;
1143          }
1144        }
1145        if (use_LUT) break;
1146      }
1147      if (i == 0) {
1148        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash0(pix)]);
1149      } else if (i == 1) {
1150        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash1(pix)]);
1151      } else if (i == 2) {
1152        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash2(pix)]);
1153      } else {
1154        uint32_t idx_map[MAX_PALETTE_SIZE];
1155        uint32_t palette_sorted[MAX_PALETTE_SIZE];
1156        PrepareMapToPalette(palette, palette_size, palette_sorted, idx_map);
1157        APPLY_PALETTE_FOR(
1158            idx_map[SearchColorNoIdx(palette_sorted, pix, palette_size)]);
1159      }
1160    }
1161    WebPSafeFree(tmp_row);
1162    return VP8_ENC_OK;
1163  }
1164  #undef APPLY_PALETTE_FOR
1165  #undef PALETTE_INV_SIZE_BITS
1166  #undef PALETTE_INV_SIZE
1167  #undef APPLY_PALETTE_GREEDY_MAX
1168  static WebPEncodingError MapImageFromPalette(VP8LEncoder* const enc,
1169                                               int in_place) {
1170    WebPEncodingError err = VP8_ENC_OK;
1171    const WebPPicture* const pic = enc->pic_;
1172    const int width = pic->width;
1173    const int height = pic->height;
1174    const uint32_t* const palette = enc->palette_;
1175    const uint32_t* src = in_place ? enc->argb_ : pic->argb;
1176    const int src_stride = in_place ? enc->current_width_ : pic->argb_stride;
1177    const int palette_size = enc->palette_size_;
1178    int xbits;
1179    if (palette_size <= 4) {
1180      xbits = (palette_size <= 2) ? 3 : 2;
1181    } else {
1182      xbits = (palette_size <= 16) ? 1 : 0;
1183    }
1184    err = AllocateTransformBuffer(enc, VP8LSubSampleSize(width, xbits), height);
1185    if (err != VP8_ENC_OK) return err;
1186    err = ApplyPalette(src, src_stride,
1187                       enc->argb_, enc->current_width_,
1188                       palette, palette_size, width, height, xbits);
1189    enc->argb_content_ = kEncoderPalette;
1190    return err;
1191  }
1192  static WebPEncodingError EncodePalette(VP8LBitWriter* const bw, int low_effort,
1193                                         VP8LEncoder* const enc) {
1194    int i;
1195    uint32_t tmp_palette[MAX_PALETTE_SIZE];
1196    const int palette_size = enc->palette_size_;
1197    const uint32_t* const palette = enc->palette_;
1198    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
1199    VP8LPutBits(bw, COLOR_INDEXING_TRANSFORM, 2);
1200    assert(palette_size >= 1 && palette_size <= MAX_PALETTE_SIZE);
1201    VP8LPutBits(bw, palette_size - 1, 8);
1202    for (i = palette_size - 1; i >= 1; --i) {
1203      tmp_palette[i] = VP8LSubPixels(palette[i], palette[i - 1]);
1204    }
1205    tmp_palette[0] = palette[0];
1206    return EncodeImageNoHuffman(bw, tmp_palette, &enc->hash_chain_,
1207                                &enc->refs_[0], &enc->refs_[1], palette_size, 1,
1208                                20 &bsol;* quality */, low_effort);
1209  }
1210  static VP8LEncoder* VP8LEncoderNew(const WebPConfig* const config,
1211                                     const WebPPicture* const picture) {
1212    VP8LEncoder* const enc = (VP8LEncoder*)WebPSafeCalloc(1ULL, sizeof(*enc));
1213    if (enc == NULL) {
1214      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
1215      return NULL;
1216    }
1217    enc->config_ = config;
1218    enc->pic_ = picture;
1219    enc->argb_content_ = kEncoderNone;
1220    VP8LEncDspInit();
1221    return enc;
1222  }
1223  static void VP8LEncoderDelete(VP8LEncoder* enc) {
1224    if (enc != NULL) {
1225      int i;
1226      VP8LHashChainClear(&enc->hash_chain_);
1227      for (i = 0; i < 3; ++i) VP8LBackwardRefsClear(&enc->refs_[i]);
1228      ClearTransformBuffer(enc);
1229      WebPSafeFree(enc);
1230    }
1231  }
1232  typedef struct {
1233    const WebPConfig* config_;
1234    const WebPPicture* picture_;
1235    VP8LBitWriter* bw_;
1236    VP8LEncoder* enc_;
1237    int use_cache_;
1238    CrunchConfig crunch_configs_[CRUNCH_CONFIGS_MAX];
1239    int num_crunch_configs_;
1240    int red_and_blue_always_zero_;
1241    WebPEncodingError err_;
1242    WebPAuxStats* stats_;
1243  } StreamEncodeContext;
1244  static int EncodeStreamHook(void* input, void* data2) {
1245    StreamEncodeContext* const params = (StreamEncodeContext*)input;
1246    const WebPConfig* const config = params->config_;
1247    const WebPPicture* const picture = params->picture_;
1248    VP8LBitWriter* const bw = params->bw_;
1249    VP8LEncoder* const enc = params->enc_;
1250    const int use_cache = params->use_cache_;
1251    const CrunchConfig* const crunch_configs = params->crunch_configs_;
1252    const int num_crunch_configs = params->num_crunch_configs_;
1253    const int red_and_blue_always_zero = params->red_and_blue_always_zero_;
1254  #if !defined(WEBP_DISABLE_STATS)
1255    WebPAuxStats* const stats = params->stats_;
1256  #endif
1257    WebPEncodingError err = VP8_ENC_OK;
1258    const int quality = (int)config->quality;
1259    const int low_effort = (config->method == 0);
1260  #if (WEBP_NEAR_LOSSLESS == 1)
1261    const int width = picture->width;
1262  #endif
1263    const int height = picture->height;
1264    const size_t byte_position = VP8LBitWriterNumBytes(bw);
1265  #if (WEBP_NEAR_LOSSLESS == 1)
1266    int use_near_lossless = 0;
1267  #endif
1268    int hdr_size = 0;
1269    int data_size = 0;
1270    int use_delta_palette = 0;
1271    int idx;
1272    size_t best_size = 0;
1273    VP8LBitWriter bw_init = *bw, bw_best;
1274    (void)data2;
1275    if (!VP8LBitWriterInit(&bw_best, 0) ||
1276        (num_crunch_configs > 1 && !VP8LBitWriterClone(bw, &bw_best))) {
1277      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1278      goto Error;
1279    }
1280    for (idx = 0; idx < num_crunch_configs; ++idx) {
1281      const int entropy_idx = crunch_configs[idx].entropy_idx_;
1282      enc->use_palette_ = (entropy_idx == kPalette);
1283      enc->use_subtract_green_ =
1284          (entropy_idx == kSubGreen) || (entropy_idx == kSpatialSubGreen);
1285      enc->use_predict_ =
1286          (entropy_idx == kSpatial) || (entropy_idx == kSpatialSubGreen);
1287      if (low_effort) {
1288        enc->use_cross_color_ = 0;
1289      } else {
1290        enc->use_cross_color_ = red_and_blue_always_zero ? 0 : enc->use_predict_;
1291      }
1292      enc->cache_bits_ = 0;
1293      VP8LBackwardRefsClear(&enc->refs_[0]);
1294      VP8LBackwardRefsClear(&enc->refs_[1]);
1295  #if (WEBP_NEAR_LOSSLESS == 1)
1296      use_near_lossless = (config->near_lossless < 100) && !enc->use_palette_ &&
1297                          !enc->use_predict_;
1298      if (use_near_lossless) {
1299        err = AllocateTransformBuffer(enc, width, height);
1300        if (err != VP8_ENC_OK) goto Error;
1301        if ((enc->argb_content_ != kEncoderNearLossless) &&
1302            !VP8ApplyNearLossless(picture, config->near_lossless, enc->argb_)) {
1303          err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1304          goto Error;
1305        }
1306        enc->argb_content_ = kEncoderNearLossless;
1307      } else {
1308        enc->argb_content_ = kEncoderNone;
1309      }
1310  #else
1311      enc->argb_content_ = kEncoderNone;
1312  #endif
1313      if (enc->use_palette_) {
1314        err = EncodePalette(bw, low_effort, enc);
1315        if (err != VP8_ENC_OK) goto Error;
1316        err = MapImageFromPalette(enc, use_delta_palette);
1317        if (err != VP8_ENC_OK) goto Error;
1318        if (use_cache && enc->palette_size_ < (1 << MAX_COLOR_CACHE_BITS)) {
1319          enc->cache_bits_ = BitsLog2Floor(enc->palette_size_) + 1;
1320        }
1321      }
1322      if (!use_delta_palette) {
1323        if (enc->argb_content_ != kEncoderNearLossless &&
1324            enc->argb_content_ != kEncoderPalette) {
1325          err = MakeInputImageCopy(enc);
1326          if (err != VP8_ENC_OK) goto Error;
1327        }
1328        if (enc->use_subtract_green_) {
1329          ApplySubtractGreen(enc, enc->current_width_, height, bw);
1330        }
1331        if (enc->use_predict_) {
1332          err = ApplyPredictFilter(enc, enc->current_width_, height, quality,
1333                                   low_effort, enc->use_subtract_green_, bw);
1334          if (err != VP8_ENC_OK) goto Error;
1335        }
1336        if (enc->use_cross_color_) {
1337          err = ApplyCrossColorFilter(enc, enc->current_width_, height, quality,
1338                                      low_effort, bw);
1339          if (err != VP8_ENC_OK) goto Error;
1340        }
1341      }
1342      VP8LPutBits(bw, !TRANSFORM_PRESENT, 1);  
1343      err = EncodeImageInternal(bw, enc->argb_, &enc->hash_chain_, enc->refs_,
1344                                enc->current_width_, height, quality, low_effort,
1345                                use_cache, &crunch_configs[idx],
1346                                &enc->cache_bits_, enc->histo_bits_,
1347                                byte_position, &hdr_size, &data_size);
1348      if (err != VP8_ENC_OK) goto Error;
1349      if (idx == 0 || VP8LBitWriterNumBytes(bw) < best_size) {
1350        best_size = VP8LBitWriterNumBytes(bw);
1351        VP8LBitWriterSwap(bw, &bw_best);
1352  #if !defined(WEBP_DISABLE_STATS)
1353        if (stats != NULL) {
1354          stats->lossless_features = 0;
1355          if (enc->use_predict_) stats->lossless_features |= 1;
1356          if (enc->use_cross_color_) stats->lossless_features |= 2;
1357          if (enc->use_subtract_green_) stats->lossless_features |= 4;
1358          if (enc->use_palette_) stats->lossless_features |= 8;
1359          stats->histogram_bits = enc->histo_bits_;
1360          stats->transform_bits = enc->transform_bits_;
1361          stats->cache_bits = enc->cache_bits_;
1362          stats->palette_size = enc->palette_size_;
1363          stats->lossless_size = (int)(best_size - byte_position);
1364          stats->lossless_hdr_size = hdr_size;
1365          stats->lossless_data_size = data_size;
1366        }
1367  #endif
1368      }
1369      if (num_crunch_configs > 1) VP8LBitWriterReset(&bw_init, bw);
1370    }
1371    VP8LBitWriterSwap(&bw_best, bw);
1372  Error:
1373    VP8LBitWriterWipeOut(&bw_best);
1374    params->err_ = err;
1375    return (err == VP8_ENC_OK);
1376  }
1377  WebPEncodingError VP8LEncodeStream(const WebPConfig* const config,
1378                                     const WebPPicture* const picture,
1379                                     VP8LBitWriter* const bw_main,
1380                                     int use_cache) {
1381    WebPEncodingError err = VP8_ENC_OK;
1382    VP8LEncoder* const enc_main = VP8LEncoderNew(config, picture);
1383    VP8LEncoder* enc_side = NULL;
1384    CrunchConfig crunch_configs[CRUNCH_CONFIGS_MAX];
1385    int num_crunch_configs_main, num_crunch_configs_side = 0;
1386    int idx;
1387    int red_and_blue_always_zero = 0;
1388    WebPWorker worker_main, worker_side;
1389    StreamEncodeContext params_main, params_side;
1390    WebPAuxStats stats_side;
1391    VP8LBitWriter bw_side;
1392    const WebPWorkerInterface* const worker_interface = WebPGetWorkerInterface();
1393    int ok_main;
1394    if (enc_main == NULL ||
1395        !EncoderAnalyze(enc_main, crunch_configs, &num_crunch_configs_main,
1396                        &red_and_blue_always_zero) ||
1397        !EncoderInit(enc_main) || !VP8LBitWriterInit(&bw_side, 0)) {
1398      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1399      goto Error;
1400    }
1401    if (config->thread_level > 0) {
1402      num_crunch_configs_side = num_crunch_configs_main / 2;
1403      for (idx = 0; idx < num_crunch_configs_side; ++idx) {
1404        params_side.crunch_configs_[idx] =
1405            crunch_configs[num_crunch_configs_main - num_crunch_configs_side +
1406                           idx];
1407      }
1408      params_side.num_crunch_configs_ = num_crunch_configs_side;
1409    }
1410    num_crunch_configs_main -= num_crunch_configs_side;
1411    for (idx = 0; idx < num_crunch_configs_main; ++idx) {
1412      params_main.crunch_configs_[idx] = crunch_configs[idx];
1413    }
1414    params_main.num_crunch_configs_ = num_crunch_configs_main;
1415    {
1416      const int params_size = (num_crunch_configs_side > 0) ? 2 : 1;
1417      for (idx = 0; idx < params_size; ++idx) {
1418        WebPWorker* const worker = (idx == 0) ? &worker_main : &worker_side;
1419        StreamEncodeContext* const param =
1420            (idx == 0) ? &params_main : &params_side;
1421        param->config_ = config;
1422        param->picture_ = picture;
1423        param->use_cache_ = use_cache;
1424        param->red_and_blue_always_zero_ = red_and_blue_always_zero;
1425        if (idx == 0) {
1426          param->stats_ = picture->stats;
1427          param->bw_ = bw_main;
1428          param->enc_ = enc_main;
1429        } else {
1430          param->stats_ = (picture->stats == NULL) ? NULL : &stats_side;
1431          if (!VP8LBitWriterClone(bw_main, &bw_side)) {
1432            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1433            goto Error;
1434          }
1435          param->bw_ = &bw_side;
1436          enc_side = VP8LEncoderNew(config, picture);
1437          if (enc_side == NULL || !EncoderInit(enc_side)) {
1438            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1439            goto Error;
1440          }
1441          enc_side->histo_bits_ = enc_main->histo_bits_;
1442          enc_side->transform_bits_ = enc_main->transform_bits_;
1443          enc_side->palette_size_ = enc_main->palette_size_;
1444          memcpy(enc_side->palette_, enc_main->palette_,
1445                 sizeof(enc_main->palette_));
1446          param->enc_ = enc_side;
1447        }
1448        worker_interface->Init(worker);
1449        worker->data1 = param;
1450        worker->data2 = NULL;
1451        worker->hook = EncodeStreamHook;
1452      }
1453    }
1454    if (num_crunch_configs_side != 0) {
1455      if (!worker_interface->Reset(&worker_side)) {
1456        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1457        goto Error;
1458      }
1459  #if !defined(WEBP_DISABLE_STATS)
1460      if (picture->stats != NULL) {
1461        memcpy(&stats_side, picture->stats, sizeof(stats_side));
1462      }
1463  #endif
1464      params_side.err_ = VP8_ENC_OK;
1465      worker_interface->Launch(&worker_side);
1466    }
1467    worker_interface->Execute(&worker_main);
1468    ok_main = worker_interface->Sync(&worker_main);
1469    worker_interface->End(&worker_main);
1470    if (num_crunch_configs_side != 0) {
1471      const int ok_side = worker_interface->Sync(&worker_side);
1472      worker_interface->End(&worker_side);
1473      if (!ok_main || !ok_side) {
1474        err = ok_main ? params_side.err_ : params_main.err_;
1475        goto Error;
1476      }
1477      if (VP8LBitWriterNumBytes(&bw_side) < VP8LBitWriterNumBytes(bw_main)) {
1478        VP8LBitWriterSwap(bw_main, &bw_side);
1479  #if !defined(WEBP_DISABLE_STATS)
1480        if (picture->stats != NULL) {
1481          memcpy(picture->stats, &stats_side, sizeof(*picture->stats));
1482        }
1483  #endif
1484      }
1485    } else {
1486      if (!ok_main) {
1487        err = params_main.err_;
1488        goto Error;
1489      }
1490    }
1491  Error:
1492    VP8LBitWriterWipeOut(&bw_side);
1493    VP8LEncoderDelete(enc_main);
1494    VP8LEncoderDelete(enc_side);
1495    return err;
1496  }
1497  #undef CRUNCH_CONFIGS_MAX
1498  #undef CRUNCH_CONFIGS_LZ77_MAX
1499  int VP8LEncodeImage(const WebPConfig* const config,
1500                      const WebPPicture* const picture) {
1501    int width, height;
1502    int has_alpha;
1503    size_t coded_size;
1504    int percent = 0;
1505    int initial_size;
1506    WebPEncodingError err = VP8_ENC_OK;
1507    VP8LBitWriter bw;
1508    if (picture == NULL) return 0;
1509    if (config == NULL || picture->argb == NULL) {
1510      err = VP8_ENC_ERROR_NULL_PARAMETER;
1511      WebPEncodingSetError(picture, err);
1512      return 0;
1513    }
1514    width = picture->width;
1515    height = picture->height;
1516    initial_size = (config->image_hint == WEBP_HINT_GRAPH) ?
1517        width * height : width * height * 2;
1518    if (!VP8LBitWriterInit(&bw, initial_size)) {
1519      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1520      goto Error;
1521    }
1522    if (!WebPReportProgress(picture, 1, &percent)) {
1523   UserAbort:
1524      err = VP8_ENC_ERROR_USER_ABORT;
1525      goto Error;
1526    }
1527    if (picture->stats != NULL) {
1528      WebPAuxStats* const stats = picture->stats;
1529      memset(stats, 0, sizeof(*stats));
1530      stats->PSNR[0] = 99.f;
1531      stats->PSNR[1] = 99.f;
1532      stats->PSNR[2] = 99.f;
1533      stats->PSNR[3] = 99.f;
1534      stats->PSNR[4] = 99.f;
1535    }
1536    if (!WriteImageSize(picture, &bw)) {
1537      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1538      goto Error;
1539    }
1540    has_alpha = WebPPictureHasTransparency(picture);
1541    if (!WriteRealAlphaAndVersion(&bw, has_alpha)) {
1542      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1543      goto Error;
1544    }
1545    if (!WebPReportProgress(picture, 5, &percent)) goto UserAbort;
1546    err = VP8LEncodeStream(config, picture, &bw, 1 &bsol;*use_cache*/);
1547    if (err != VP8_ENC_OK) goto Error;
1548    if (!WebPReportProgress(picture, 90, &percent)) goto UserAbort;
1549    err = WriteImage(picture, &bw, &coded_size);
1550    if (err != VP8_ENC_OK) goto Error;
1551    if (!WebPReportProgress(picture, 100, &percent)) goto UserAbort;
1552  #if !defined(WEBP_DISABLE_STATS)
1553    if (picture->stats != NULL) {
1554      picture->stats->coded_size += (int)coded_size;
1555      picture->stats->lossless_size = (int)coded_size;
1556    }
1557  #endif
1558    if (picture->extra_info != NULL) {
1559      const int mb_w = (width + 15) >> 4;
1560      const int mb_h = (height + 15) >> 4;
1561      memset(picture->extra_info, 0, mb_w * mb_h * sizeof(*picture->extra_info));
1562    }
1563   Error:
1564    if (bw.error_) err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1565    VP8LBitWriterWipeOut(&bw);
1566    if (err != VP8_ENC_OK) {
1567      WebPEncodingSetError(picture, err);
1568      return 0;
1569    }
1570    return 1;
1571  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-ssim_sse2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>92  static double SSIMGet_SSE2(const uint8_t* src1, int stride1,
93                             const uint8_t* src2, int stride2) {
94    VP8DistoStats stats;
95    const __m128i zero = _mm_setzero_si128();
</pre></code></div>
                <div class="column column_space"><pre><code>531  static void StoreHuffmanCode(VP8LBitWriter* const bw,
532                               HuffmanTree* const huff_tree,
533                               HuffmanTreeToken* const tokens,
534                               const HuffmanTreeCode* const huffman_code) {
535    int i;
536    int count = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    