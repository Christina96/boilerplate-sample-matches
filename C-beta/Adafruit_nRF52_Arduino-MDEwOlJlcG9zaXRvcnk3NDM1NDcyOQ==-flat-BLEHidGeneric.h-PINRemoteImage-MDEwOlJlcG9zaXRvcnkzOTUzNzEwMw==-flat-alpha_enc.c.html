
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.258911819887429%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-BLEHidGeneric.h</h3>
            <pre><code>1  #ifndef BLEHIDGENERIC_H_
2  #define BLEHIDGENERIC_H_
3  #include "bluefruit_common.h"
4  #include "BLECharacteristic.h"
5  #include "BLEService.h"
6  #include <Adafruit_TinyUSB.h>
7  #include "class/hid/hid.h"
8  extern const uint8_t hid_ascii_to_keycode[128][2];
9  extern const uint8_t hid_keycode_to_ascii[128][2];
10  class BLEHidGeneric : public BLEService
11  {
12    public:
<span onclick='openModal()' class='match'>13      BLEHidGeneric(uint8_t num_input, uint8_t num_output = 0, uint8_t num_feature = 0);
14      void enableKeyboard(bool enable);
15      void enableMouse(bool enable);
</span>16      void setHidInfo(uint16_t bcd, uint8_t country, uint8_t flags);
17      void setReportLen(uint16_t input_len[], uint16_t output_len[] = NULL, uint16_t feature_len[] = NULL);
18      void setReportMap(const uint8_t* report_map, size_t len);
19      void setOutputReportCallback(uint8_t reportID, BLECharacteristic::write_cb_t fp);
20      virtual err_t begin(void);
21      bool isBootMode(void) { return !_report_mode; }
22      bool inputReport(uint8_t reportID, void const* data, int len);
23      bool bootKeyboardReport(void const* data, int len);
24      bool bootMouseReport(void const* data, int len);
25      bool inputReport(uint16_t conn_hdl, uint8_t reportID, void const* data, int len);
26      bool bootKeyboardReport(uint16_t conn_hdl, void const* data, int len);
27      bool bootMouseReport(uint16_t conn_hdl, void const* data, int len);
28    protected:
29      uint8_t _num_input;
30      uint8_t _num_output;
31      uint8_t _num_feature;
32      bool    _has_keyboard;
33      bool    _has_mouse;
34      bool    _report_mode;
35      uint8_t _hid_info[4];
36      const uint8_t* _report_map;
37      size_t _report_map_len;
38      uint16_t* _input_len;
39      uint16_t* _output_len;
40      uint16_t* _feature_len;
41      BLECharacteristic* _chr_protocol;
42      BLECharacteristic* _chr_inputs;
43      BLECharacteristic* _chr_outputs;
44      BLECharacteristic* _chr_features;
45      BLECharacteristic* _chr_boot_keyboard_input;
46      BLECharacteristic* _chr_boot_keyboard_output;
47      BLECharacteristic* _chr_boot_mouse_input;
48      BLECharacteristic _chr_control;
49      static void blehid_generic_protocol_mode_cb(uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len);
50  };
51  #endif &bsol;* BLEHIDGENERIC_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-alpha_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include "src/enc/vp8i_enc.h"
4  #include "src/dsp/dsp.h"
5  #include "src/utils/filters_utils.h"
6  #include "src/utils/quant_levels_utils.h"
7  #include "src/utils/utils.h"
8  #include "src/webp/format_constants.h"
9  #include "src/enc/vp8li_enc.h"
10  static int EncodeLossless(const uint8_t* const data, int width, int height,
11                            int effort_level,  
12                            int use_quality_100, VP8LBitWriter* const bw,
13                            WebPAuxStats* const stats) {
14    int ok = 0;
15    WebPConfig config;
16    WebPPicture picture;
17    WebPPictureInit(&picture);
18    picture.width = width;
19    picture.height = height;
20    picture.use_argb = 1;
21    picture.stats = stats;
22    if (!WebPPictureAlloc(&picture)) return 0;
23    WebPDispatchAlphaToGreen(data, width, picture.width, picture.height,
24                             picture.argb, picture.argb_stride);
25    WebPConfigInit(&config);
26    config.lossless = 1;
27    config.exact = 1;
28    config.method = effort_level;  
29    config.quality =
30        (use_quality_100 && effort_level == 6) ? 100 : 8.f * effort_level;
31    assert(config.quality >= 0 && config.quality <= 100.f);
32    ok = (VP8LEncodeStream(&config, &picture, bw, 0 &bsol;*use_cache*/) == VP8_ENC_OK);
33    WebPPictureFree(&picture);
34    ok = ok && !bw->error_;
35    if (!ok) {
36      VP8LBitWriterWipeOut(bw);
37      return 0;
38    }
39    return 1;
40  }
41  typedef struct {
42    size_t score;
43    VP8BitWriter bw;
44    WebPAuxStats stats;
45  } FilterTrial;
46  static int EncodeAlphaInternal(const uint8_t* const data, int width, int height,
47                                 int method, int filter, int reduce_levels,
48                                 int effort_level,  
49                                 uint8_t* const tmp_alpha,
50                                 FilterTrial* result) {
51    int ok = 0;
52    const uint8_t* alpha_src;
53    WebPFilterFunc filter_func;
54    uint8_t header;
55    const size_t data_size = width * height;
56    const uint8_t* output = NULL;
57    size_t output_size = 0;
58    VP8LBitWriter tmp_bw;
59    assert((uint64_t)data_size == (uint64_t)width * height);  
60    assert(filter >= 0 && filter < WEBP_FILTER_LAST);
61    assert(method >= ALPHA_NO_COMPRESSION);
62    assert(method <= ALPHA_LOSSLESS_COMPRESSION);
63    assert(sizeof(header) == ALPHA_HEADER_LEN);
64    filter_func = WebPFilters[filter];
65    if (filter_func != NULL) {
66      filter_func(data, width, height, width, tmp_alpha);
67      alpha_src = tmp_alpha;
68    }  else {
69      alpha_src = data;
70    }
71    if (method != ALPHA_NO_COMPRESSION) {
72      ok = VP8LBitWriterInit(&tmp_bw, data_size >> 3);
73      ok = ok && EncodeLossless(alpha_src, width, height, effort_level,
74                                !reduce_levels, &tmp_bw, &result->stats);
75      if (ok) {
76        output = VP8LBitWriterFinish(&tmp_bw);
77        output_size = VP8LBitWriterNumBytes(&tmp_bw);
78        if (output_size > data_size) {
79          method = ALPHA_NO_COMPRESSION;
80          VP8LBitWriterWipeOut(&tmp_bw);
81        }
82      } else {
83        VP8LBitWriterWipeOut(&tmp_bw);
84        return 0;
85      }
86    }
87    if (method == ALPHA_NO_COMPRESSION) {
88      output = alpha_src;
89      output_size = data_size;
90      ok = 1;
91    }
92    header = method | (filter << 2);
93    if (reduce_levels) header |= ALPHA_PREPROCESSED_LEVELS << 4;
94    VP8BitWriterInit(&result->bw, ALPHA_HEADER_LEN + output_size);
95    ok = ok && VP8BitWriterAppend(&result->bw, &header, ALPHA_HEADER_LEN);
96    ok = ok && VP8BitWriterAppend(&result->bw, output, output_size);
97    if (method != ALPHA_NO_COMPRESSION) {
98      VP8LBitWriterWipeOut(&tmp_bw);
99    }
100    ok = ok && !result->bw.error_;
101    result->score = VP8BitWriterSize(&result->bw);
102    return ok;
103  }
104  static int GetNumColors(const uint8_t* data, int width, int height,
105                          int stride) {
106    int j;
107    int colors = 0;
108    uint8_t color[256] = { 0 };
109    for (j = 0; j < height; ++j) {
110      int i;
111      const uint8_t* const p = data + j * stride;
112      for (i = 0; i < width; ++i) {
113        color[p[i]] = 1;
114      }
115    }
116    for (j = 0; j < 256; ++j) {
117      if (color[j] > 0) ++colors;
118    }
119    return colors;
120  }
121  #define FILTER_TRY_NONE (1 << WEBP_FILTER_NONE)
122  #define FILTER_TRY_ALL ((1 << WEBP_FILTER_LAST) - 1)
123  static uint32_t GetFilterMap(const uint8_t* alpha, int width, int height,
124                               int filter, int effort_level) {
125    uint32_t bit_map = 0U;
126    if (filter == WEBP_FILTER_FAST) {
127      int try_filter_none = (effort_level > 3);
128      const int kMinColorsForFilterNone = 16;
129      const int kMaxColorsForFilterNone = 192;
130      const int num_colors = GetNumColors(alpha, width, height, width);
131      filter = (num_colors <= kMinColorsForFilterNone)
132          ? WEBP_FILTER_NONE
133          : WebPEstimateBestFilter(alpha, width, height, width);
134      bit_map |= 1 << filter;
135      if (try_filter_none || num_colors > kMaxColorsForFilterNone) {
136        bit_map |= FILTER_TRY_NONE;
137      }
138    } else if (filter == WEBP_FILTER_NONE) {
139      bit_map = FILTER_TRY_NONE;
140    } else {  
141      bit_map = FILTER_TRY_ALL;
142    }
143    return bit_map;
144  }
145  static void InitFilterTrial(FilterTrial* const score) {
146    score->score = (size_t)~0U;
147    VP8BitWriterInit(&score->bw, 0);
148  }
<span onclick='openModal()' class='match'>149  static int ApplyFiltersAndEncode(const uint8_t* alpha, int width, int height,
150                                   size_t data_size, int method, int filter,
151                                   int reduce_levels, int effort_level,
152                                   uint8_t** const output,
153                                   size_t* const output_size,
154                                   WebPAuxStats* const stats) {
155    int ok = 1;
</span>156    FilterTrial best;
157    uint32_t try_map =
158        GetFilterMap(alpha, width, height, filter, effort_level);
159    InitFilterTrial(&best);
160    if (try_map != FILTER_TRY_NONE) {
161      uint8_t* filtered_alpha =  (uint8_t*)WebPSafeMalloc(1ULL, data_size);
162      if (filtered_alpha == NULL) return 0;
163      for (filter = WEBP_FILTER_NONE; ok && try_map; ++filter, try_map >>= 1) {
164        if (try_map & 1) {
165          FilterTrial trial;
166          ok = EncodeAlphaInternal(alpha, width, height, method, filter,
167                                   reduce_levels, effort_level, filtered_alpha,
168                                   &trial);
169          if (ok && trial.score < best.score) {
170            VP8BitWriterWipeOut(&best.bw);
171            best = trial;
172          } else {
173            VP8BitWriterWipeOut(&trial.bw);
174          }
175        }
176      }
177      WebPSafeFree(filtered_alpha);
178    } else {
179      ok = EncodeAlphaInternal(alpha, width, height, method, WEBP_FILTER_NONE,
180                               reduce_levels, effort_level, NULL, &best);
181    }
182    if (ok) {
183  #if !defined(WEBP_DISABLE_STATS)
184      if (stats != NULL) {
185        stats->lossless_features = best.stats.lossless_features;
186        stats->histogram_bits = best.stats.histogram_bits;
187        stats->transform_bits = best.stats.transform_bits;
188        stats->cache_bits = best.stats.cache_bits;
189        stats->palette_size = best.stats.palette_size;
190        stats->lossless_size = best.stats.lossless_size;
191        stats->lossless_hdr_size = best.stats.lossless_hdr_size;
192        stats->lossless_data_size = best.stats.lossless_data_size;
193      }
194  #else
195      (void)stats;
196  #endif
197      *output_size = VP8BitWriterSize(&best.bw);
198      *output = VP8BitWriterBuf(&best.bw);
199    } else {
200      VP8BitWriterWipeOut(&best.bw);
201    }
202    return ok;
203  }
204  static int EncodeAlpha(VP8Encoder* const enc,
205                         int quality, int method, int filter,
206                         int effort_level,
207                         uint8_t** const output, size_t* const output_size) {
208    const WebPPicture* const pic = enc->pic_;
209    const int width = pic->width;
210    const int height = pic->height;
211    uint8_t* quant_alpha = NULL;
212    const size_t data_size = width * height;
213    uint64_t sse = 0;
214    int ok = 1;
215    const int reduce_levels = (quality < 100);
216    assert((uint64_t)data_size == (uint64_t)width * height);  
217    assert(enc != NULL && pic != NULL && pic->a != NULL);
218    assert(output != NULL && output_size != NULL);
219    assert(width > 0 && height > 0);
220    assert(pic->a_stride >= width);
221    assert(filter >= WEBP_FILTER_NONE && filter <= WEBP_FILTER_FAST);
222    if (quality < 0 || quality > 100) {
223      return 0;
224    }
225    if (method < ALPHA_NO_COMPRESSION || method > ALPHA_LOSSLESS_COMPRESSION) {
226      return 0;
227    }
228    if (method == ALPHA_NO_COMPRESSION) {
229      filter = WEBP_FILTER_NONE;
230    }
231    quant_alpha = (uint8_t*)WebPSafeMalloc(1ULL, data_size);
232    if (quant_alpha == NULL) {
233      return 0;
234    }
235    WebPCopyPlane(pic->a, pic->a_stride, quant_alpha, width, width, height);
236    if (reduce_levels) {  
237      const int alpha_levels = (quality <= 70) ? (2 + quality / 5)
238                                               : (16 + (quality - 70) * 8);
239      ok = QuantizeLevels(quant_alpha, width, height, alpha_levels, &sse);
240    }
241    if (ok) {
242      VP8FiltersInit();
243      ok = ApplyFiltersAndEncode(quant_alpha, width, height, data_size, method,
244                                 filter, reduce_levels, effort_level, output,
245                                 output_size, pic->stats);
246  #if !defined(WEBP_DISABLE_STATS)
247      if (pic->stats != NULL) {  
248        pic->stats->coded_size += (int)(*output_size);
249        enc->sse_[3] = sse;
250      }
251  #endif
252    }
253    WebPSafeFree(quant_alpha);
254    return ok;
255  }
256  static int CompressAlphaJob(void* arg1, void* dummy) {
257    VP8Encoder* const enc = (VP8Encoder*)arg1;
258    const WebPConfig* config = enc->config_;
259    uint8_t* alpha_data = NULL;
260    size_t alpha_size = 0;
261    const int effort_level = config->method;  
262    const WEBP_FILTER_TYPE filter =
263        (config->alpha_filtering == 0) ? WEBP_FILTER_NONE :
264        (config->alpha_filtering == 1) ? WEBP_FILTER_FAST :
265                                         WEBP_FILTER_BEST;
266    if (!EncodeAlpha(enc, config->alpha_quality, config->alpha_compression,
267                     filter, effort_level, &alpha_data, &alpha_size)) {
268      return 0;
269    }
270    if (alpha_size != (uint32_t)alpha_size) {  
271      WebPSafeFree(alpha_data);
272      return 0;
273    }
274    enc->alpha_data_size_ = (uint32_t)alpha_size;
275    enc->alpha_data_ = alpha_data;
276    (void)dummy;
277    return 1;
278  }
279  void VP8EncInitAlpha(VP8Encoder* const enc) {
280    WebPInitAlphaProcessing();
281    enc->has_alpha_ = WebPPictureHasTransparency(enc->pic_);
282    enc->alpha_data_ = NULL;
283    enc->alpha_data_size_ = 0;
284    if (enc->thread_level_ > 0) {
285      WebPWorker* const worker = &enc->alpha_worker_;
286      WebPGetWorkerInterface()->Init(worker);
287      worker->data1 = enc;
288      worker->data2 = NULL;
289      worker->hook = CompressAlphaJob;
290    }
291  }
292  int VP8EncStartAlpha(VP8Encoder* const enc) {
293    if (enc->has_alpha_) {
294      if (enc->thread_level_ > 0) {
295        WebPWorker* const worker = &enc->alpha_worker_;
296        if (!WebPGetWorkerInterface()->Reset(worker)) {
297          return 0;
298        }
299        WebPGetWorkerInterface()->Launch(worker);
300        return 1;
301      } else {
302        return CompressAlphaJob(enc, NULL);   
303      }
304    }
305    return 1;
306  }
307  int VP8EncFinishAlpha(VP8Encoder* const enc) {
308    if (enc->has_alpha_) {
309      if (enc->thread_level_ > 0) {
310        WebPWorker* const worker = &enc->alpha_worker_;
311        if (!WebPGetWorkerInterface()->Sync(worker)) return 0;  
312      }
313    }
314    return WebPReportProgress(enc->pic_, enc->percent_ + 20, &enc->percent_);
315  }
316  int VP8EncDeleteAlpha(VP8Encoder* const enc) {
317    int ok = 1;
318    if (enc->thread_level_ > 0) {
319      WebPWorker* const worker = &enc->alpha_worker_;
320      ok = WebPGetWorkerInterface()->Sync(worker);
321      WebPGetWorkerInterface()->End(worker);
322    }
323    WebPSafeFree(enc->alpha_data_);
324    enc->alpha_data_ = NULL;
325    enc->alpha_data_size_ = 0;
326    enc->has_alpha_ = 0;
327    return ok;
328  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-BLEHidGeneric.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-alpha_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>13      BLEHidGeneric(uint8_t num_input, uint8_t num_output = 0, uint8_t num_feature = 0);
14      void enableKeyboard(bool enable);
15      void enableMouse(bool enable);
</pre></code></div>
                <div class="column column_space"><pre><code>149  static int ApplyFiltersAndEncode(const uint8_t* alpha, int width, int height,
150                                   size_t data_size, int method, int filter,
151                                   int reduce_levels, int effort_level,
152                                   uint8_t** const output,
153                                   size_t* const output_size,
154                                   WebPAuxStats* const stats) {
155    int ok = 1;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    