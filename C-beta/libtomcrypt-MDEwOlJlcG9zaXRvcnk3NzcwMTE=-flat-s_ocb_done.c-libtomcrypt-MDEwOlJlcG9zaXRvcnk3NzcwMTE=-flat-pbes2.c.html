
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.19112627986348%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-s_ocb_done.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_OCB_MODE
3  int s_ocb_done(ocb_state *ocb, const unsigned char *pt, unsigned long ptlen,
<span onclick='openModal()' class='match'>4                 unsigned char *ct, unsigned char *tag, unsigned long *taglen, int mode)
5  {
6     unsigned char *Z, *Y, *X;
7     int err, x;
8     LTC_ARGCHK(ocb    != NULL);
9     LTC_ARGCHK(pt     != NULL);
10     LTC_ARGCHK(ct     != NULL);
11     LTC_ARGCHK(tag    != NULL);
12     LTC_ARGCHK(taglen != NULL);
13     if ((err = cipher_is_valid(ocb->cipher)) != CRYPT_OK) {
14        return err;
15     }
16     if (ocb->block_len != cipher_descriptor[ocb->cipher].block_length ||
</span>17         (int)ptlen > ocb->block_len || (int)ptlen < 0) {
18        return CRYPT_INVALID_ARG;
19     }
20     Z = XMALLOC(MAXBLOCKSIZE);
21     Y = XMALLOC(MAXBLOCKSIZE);
22     X = XMALLOC(MAXBLOCKSIZE);
23     if (X == NULL || Y == NULL || Z == NULL) {
24        if (X != NULL) {
25           XFREE(X);
26        }
27        if (Y != NULL) {
28           XFREE(Y);
29        }
30        if (Z != NULL) {
31           XFREE(Z);
32        }
33        return CRYPT_MEM;
34     }
35     ocb_shift_xor(ocb, X);
36     XMEMCPY(Z, X, ocb->block_len);
37     X[ocb->block_len-1] ^= (ptlen*8)&255;
38     X[ocb->block_len-2] ^= ((ptlen*8)>>8)&255;
39     for (x = 0; x < ocb->block_len; x++) {
40         X[x] ^= ocb->Lr[x];
41     }
42     if ((err = cipher_descriptor[ocb->cipher].ecb_encrypt(X, Y, &ocb->key)) != CRYPT_OK) {
43        goto error;
44     }
45     if (mode == 1) {
46        for (x = 0; x < (int)ptlen; x++) {
47           ocb->checksum[x] ^= ct[x];
48        }
49     }
50     for (x = 0; x < (int)ptlen; x++) {
51         ct[x] = pt[x] ^ Y[x];
52     }
53     if (mode == 0) {
54        for (x = 0; x < (int)ptlen; x++) {
55            ocb->checksum[x] ^= ct[x];
56        }
57     }
58     for (x = 0; x < ocb->block_len; x++) {
59         ocb->checksum[x] ^= Y[x] ^ Z[x];
60     }
61     if ((err = cipher_descriptor[ocb->cipher].ecb_encrypt(ocb->checksum, X, &ocb->key)) != CRYPT_OK) {
62        goto error;
63     }
64     cipher_descriptor[ocb->cipher].done(&ocb->key);
65     for (x = 0; x < ocb->block_len && x < (int)*taglen; x++) {
66         tag[x] = X[x];
67     }
68     *taglen = x;
69  #ifdef LTC_CLEAN_STACK
70     zeromem(X, MAXBLOCKSIZE);
71     zeromem(Y, MAXBLOCKSIZE);
72     zeromem(Z, MAXBLOCKSIZE);
73     zeromem(ocb, sizeof(*ocb));
74  #endif
75  error:
76     XFREE(X);
77     XFREE(Y);
78     XFREE(Z);
79     return err;
80  }
81  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pbes2.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_PBES
3  static const char * const s_oid_pbes2 =  "1.2.840.113549.1.5.13";
4  static const char * const s_oid_pbkdf2 = "1.2.840.113549.1.5.12";
5  typedef struct {
6     const char *oid;
7     const char *id;
8  } oid_id_st;
9  static const oid_id_st s_hmac_oid_names[] = {
10     { "1.2.840.113549.2.7",  "sha1" },
11     { "1.2.840.113549.2.8",  "sha224" },
12     { "1.2.840.113549.2.9",  "sha256" },
13     { "1.2.840.113549.2.10", "sha384" },
14     { "1.2.840.113549.2.11", "sha512" },
15     { "1.2.840.113549.2.12", "sha512-224" },
16     { "1.2.840.113549.2.13", "sha512-256" },
17  };
18  static const pbes_properties s_pbes2_default_types[] = {
19     { pkcs_5_alg2, "sha1",   "des",   8, 0 },
20     { pkcs_5_alg2, "sha1",   "rc2",   4, 0 },
21     { pkcs_5_alg2, "sha1",   "3des", 24, 0 },
22     { pkcs_5_alg2, "sha1",   "aes",  16, 0 },
23     { pkcs_5_alg2, "sha1",   "aes",  24, 0 },
24     { pkcs_5_alg2, "sha1",   "aes",  32, 0 },
25  };
26  typedef struct {
27     const pbes_properties *data;
28     const char* oid;
29  } oid_to_pbes;
30  static const oid_to_pbes s_pbes2_list[] = {
31     { &s_pbes2_default_types[0], "1.3.14.3.2.7"            },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/1.3.14.3.2.7            desCBC */
32     { &s_pbes2_default_types[1], "1.2.840.113549.3.2"      },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/1.2.840.113549.3.2      rc2CBC */
33     { &s_pbes2_default_types[2], "1.2.840.113549.3.7"      },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/1.2.840.113549.3.7      des-EDE3-CBC */
34     { &s_pbes2_default_types[3], "2.16.840.1.101.3.4.1.2"  },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/2.16.840.1.101.3.4.1.2  aes128-CBC */
35     { &s_pbes2_default_types[4], "2.16.840.1.101.3.4.1.22" },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/2.16.840.1.101.3.4.1.22 aes192-CBC */
36     { &s_pbes2_default_types[5], "2.16.840.1.101.3.4.1.42" },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/2.16.840.1.101.3.4.1.42 aes256-CBC */
37  };
38  static int s_pbes2_from_oid(const ltc_asn1_list *cipher_oid, const ltc_asn1_list *hmac_oid, pbes_properties *res)
39  {
40     unsigned int i;
41     for (i = 0; i < sizeof(s_pbes2_list)/sizeof(s_pbes2_list[0]); ++i) {
42        if (pk_oid_cmp_with_asn1(s_pbes2_list[i].oid, cipher_oid) == CRYPT_OK) {
43           *res = *s_pbes2_list[i].data;
44           break;
45        }
46     }
47     if (res->c == NULL) return CRYPT_INVALID_CIPHER;
48     if (hmac_oid != NULL) {
49        for (i = 0; i < sizeof(s_hmac_oid_names)/sizeof(s_hmac_oid_names[0]); ++i) {
50           if (pk_oid_cmp_with_asn1(s_hmac_oid_names[i].oid, hmac_oid) == CRYPT_OK) {
51              res->h = s_hmac_oid_names[i].id;
52              return CRYPT_OK;
53           }
54        }
55        return CRYPT_INVALID_HASH;
56     }
57     return CRYPT_OK;
58  }
<span onclick='openModal()' class='match'>59  int pbes2_extract(const ltc_asn1_list *s, pbes_arg *res)
60  {
61     unsigned long klen;
62     ltc_asn1_list *lkdf, *lenc, *loptseq, *liter, *lhmac;
63     int err;
64     LTC_ARGCHK(s   != NULL);
65     LTC_ARGCHK(res != NULL);
66     if ((err = pk_oid_cmp_with_asn1(s_oid_pbes2, s)) != CRYPT_OK) return err;
67     if (!LTC_ASN1_IS_TYPE(s->next, LTC_ASN1_SEQUENCE) ||
</span>68         !LTC_ASN1_IS_TYPE(s->next->child, LTC_ASN1_SEQUENCE) ||
69         !LTC_ASN1_IS_TYPE(s->next->child->child, LTC_ASN1_OBJECT_IDENTIFIER) ||
70         !LTC_ASN1_IS_TYPE(s->next->child->child->next, LTC_ASN1_SEQUENCE) ||
71         !LTC_ASN1_IS_TYPE(s->next->child->next, LTC_ASN1_SEQUENCE) ||
72         !LTC_ASN1_IS_TYPE(s->next->child->next->child, LTC_ASN1_OBJECT_IDENTIFIER)) {
73        return CRYPT_INVALID_PACKET;
74     }
75     lkdf = s->next->child->child;
76     lenc = s->next->child->next->child;
77     if ((err = pk_oid_cmp_with_asn1(s_oid_pbkdf2, lkdf)) != CRYPT_OK) return err;
78     if (!LTC_ASN1_IS_TYPE(lkdf->next, LTC_ASN1_SEQUENCE) ||
79         !LTC_ASN1_IS_TYPE(lkdf->next->child, LTC_ASN1_OCTET_STRING) ||
80         !LTC_ASN1_IS_TYPE(lkdf->next->child->next, LTC_ASN1_INTEGER)) {
81        return CRYPT_INVALID_PACKET;
82     }
83     liter = lkdf->next->child->next;
84     loptseq = liter->next;
85     res->salt = lkdf->next->child;
86     res->iterations = mp_get_int(liter->data);
87     if(LTC_ASN1_IS_TYPE(loptseq, LTC_ASN1_INTEGER)) {
88        loptseq = loptseq->next;
89     }
90     lhmac = NULL;
91     if (LTC_ASN1_IS_TYPE(loptseq, LTC_ASN1_SEQUENCE) &&
92         LTC_ASN1_IS_TYPE(loptseq->child, LTC_ASN1_OBJECT_IDENTIFIER)) {
93        lhmac = loptseq->child;
94     }
95     if ((err = s_pbes2_from_oid(lenc, lhmac, &res->type)) != CRYPT_OK) return err;
96     if (LTC_ASN1_IS_TYPE(lenc->next, LTC_ASN1_OCTET_STRING)) {
97        res->iv = lenc->next;
98     } else if (LTC_ASN1_IS_TYPE(lenc->next, LTC_ASN1_SEQUENCE)) {
99        if (LTC_ASN1_IS_TYPE(lenc->next->child, LTC_ASN1_INTEGER) &&
100            LTC_ASN1_IS_TYPE(lenc->next->child->next, LTC_ASN1_OCTET_STRING)) {
101           klen = mp_get_int(lenc->next->child->data);
102           res->iv   = lenc->next->child->next;
103           switch (klen) {
104              case 160:
105                 res->key_bits = 40;
106                 break;
107              case 120:
108                 res->key_bits = 64;
109                 break;
110              case 58:
111                 res->key_bits = 128;
112                 break;
113              default:
114                 if (klen < 256) return CRYPT_INVALID_KEYSIZE;
115                 res->key_bits = klen;
116                 break;
117           }
118        } else if (LTC_ASN1_IS_TYPE(lenc->next->child, LTC_ASN1_OCTET_STRING)) {
119           res->iv   = lenc->next->child;
120           res->key_bits = 32;
121        } else {
122           return CRYPT_INVALID_PACKET;
123        }
124     }
125     return CRYPT_OK;
126  }
127  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-s_ocb_done.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pbes2.c</div>
                </div>
                <div class="column column_space"><pre><code>4                 unsigned char *ct, unsigned char *tag, unsigned long *taglen, int mode)
5  {
6     unsigned char *Z, *Y, *X;
7     int err, x;
8     LTC_ARGCHK(ocb    != NULL);
9     LTC_ARGCHK(pt     != NULL);
10     LTC_ARGCHK(ct     != NULL);
11     LTC_ARGCHK(tag    != NULL);
12     LTC_ARGCHK(taglen != NULL);
13     if ((err = cipher_is_valid(ocb->cipher)) != CRYPT_OK) {
14        return err;
15     }
16     if (ocb->block_len != cipher_descriptor[ocb->cipher].block_length ||
</pre></code></div>
                <div class="column column_space"><pre><code>59  int pbes2_extract(const ltc_asn1_list *s, pbes_arg *res)
60  {
61     unsigned long klen;
62     ltc_asn1_list *lkdf, *lenc, *loptseq, *liter, *lhmac;
63     int err;
64     LTC_ARGCHK(s   != NULL);
65     LTC_ARGCHK(res != NULL);
66     if ((err = pk_oid_cmp_with_asn1(s_oid_pbes2, s)) != CRYPT_OK) return err;
67     if (!LTC_ASN1_IS_TYPE(s->next, LTC_ASN1_SEQUENCE) ||
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    