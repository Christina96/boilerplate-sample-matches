
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.273504273504273%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-opentest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <pcap.h>
8  #include <stdio.h>
9  #include <stdlib.h>
10  #include <string.h>
11  #include <stdarg.h>
12  #ifdef _WIN32
13    #include "getopt.h"
14  #else
15    #include <unistd.h>
16  #endif
17  #include <errno.h>
18  #include "pcap/funcattrs.h"
19  #ifdef _WIN32
20    #include "portability.h"
21  #endif
22  #define MAXIMUM_SNAPLEN		262144
23  static char *program_name;
24  static void PCAP_NORETURN usage(void);
25  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
26  static void warning(const char *, ...) PCAP_PRINTFLIKE(1, 2);
27  int
<span onclick='openModal()' class='match'>28  main(int argc, char **argv)
29  {
30  	register int op;
31  	register char *cp, *device;
32  	int dorfmon, dopromisc, snaplen, useactivate, bufsize;
33  	char ebuf[PCAP_ERRBUF_SIZE];
34  	pcap_if_t *devlist;
35  	pcap_t *pd;
36  	int status = 0;
37  	device = NULL;
</span>38  	dorfmon = 0;
39  	dopromisc = 0;
40  	snaplen = MAXIMUM_SNAPLEN;
41  	bufsize = 0;
42  	useactivate = 0;
43  	if ((cp = strrchr(argv[0], '/')) != NULL)
44  		program_name = cp + 1;
45  	else
46  		program_name = argv[0];
47  	opterr = 0;
48  	while ((op = getopt(argc, argv, "i:Ips:aB:")) != -1) {
49  		switch (op) {
50  		case 'i':
51  			device = strdup(optarg);
52  			break;
53  		case 'I':
54  			dorfmon = 1;
55  			useactivate = 1;	&bsol;* required for rfmon */
56  			break;
57  		case 'p':
58  			dopromisc = 1;
59  			break;
60  		case 's': {
61  			char *end;
62  			long long_snaplen;
63  			long_snaplen = strtol(optarg, &end, 0);
64  			if (optarg == end || *end != '\0'
65  			    || long_snaplen < 0
66  			    || long_snaplen > MAXIMUM_SNAPLEN)
67  				error("invalid snaplen %s", optarg);
68  			else {
69  				if (snaplen == 0)
70  					snaplen = MAXIMUM_SNAPLEN;
71  				else
72  					snaplen = (int)long_snaplen;
73  			}
74  			break;
75  		}
76  		case 'B':
77  			bufsize = atoi(optarg)*1024;
78  			if (bufsize <= 0)
79  				error("invalid packet buffer size %s", optarg);
80  			useactivate = 1;	&bsol;* required for bufsize */
81  			break;
82  		case 'a':
83  			useactivate = 1;
84  			break;
85  		default:
86  			usage();
87  		}
88  	}
89  	if (device == NULL) {
90  		if (pcap_findalldevs(&devlist, ebuf) == -1)
91  			error("%s", ebuf);
92  		if (devlist == NULL)
93  			error("no interfaces available for capture");
94  		device = strdup(devlist->name);
95  		pcap_freealldevs(devlist);
96  	}
97  	if (useactivate) {
98  		pd = pcap_create(device, ebuf);
99  		if (pd == NULL)
100  			error("%s: pcap_create failed: %s", device, ebuf);
101  		status = pcap_set_snaplen(pd, snaplen);
102  		if (status != 0)
103  			error("%s: pcap_set_snaplen failed: %s",
104  			    device, pcap_statustostr(status));
105  		if (dopromisc) {
106  			status = pcap_set_promisc(pd, 1);
107  			if (status != 0)
108  				error("%s: pcap_set_promisc failed: %s",
109  				    device, pcap_statustostr(status));
110  		}
111  		if (dorfmon) {
112  			status = pcap_set_rfmon(pd, 1);
113  			if (status != 0)
114  				error("%s: pcap_set_rfmon failed: %s",
115  				    device, pcap_statustostr(status));
116  		}
117  		status = pcap_set_timeout(pd, 1000);
118  		if (status != 0)
119  			error("%s: pcap_set_timeout failed: %s",
120  			    device, pcap_statustostr(status));
121  		if (bufsize != 0) {
122  			status = pcap_set_buffer_size(pd, bufsize);
123  			if (status != 0)
124  				error("%s: pcap_set_buffer_size failed: %s",
125  				    device, pcap_statustostr(status));
126  		}
127  		status = pcap_activate(pd);
128  		if (status < 0) {
129  			error("%s: %s\n(%s)", device,
130  			    pcap_statustostr(status), pcap_geterr(pd));
131  		} else if (status > 0) {
132  			warning("%s: %s\n(%s)", device,
133  			    pcap_statustostr(status), pcap_geterr(pd));
134  		} else
135  			printf("%s opened successfully\n", device);
136  	} else {
137  		*ebuf = '\0';
138  		pd = pcap_open_live(device, 65535, 0, 1000, ebuf);
139  		if (pd == NULL)
140  			error("%s", ebuf);
141  		else if (*ebuf)
142  			warning("%s", ebuf);
143  		else
144  			printf("%s opened successfully\n", device);
145  	}
146  	free(device);
147  	pcap_close(pd);
148  	exit(status < 0 ? 1 : 0);
149  }
150  static void
151  usage(void)
152  {
153  	(void)fprintf(stderr,
154  	    "Usage: %s [ -Ipa ] [ -i interface ] [ -s snaplen ] [ -B bufsize ]\n",
155  	    program_name);
156  	exit(1);
157  }
158  static void
159  error(const char *fmt, ...)
160  {
161  	va_list ap;
162  	(void)fprintf(stderr, "%s: ", program_name);
163  	va_start(ap, fmt);
164  	(void)vfprintf(stderr, fmt, ap);
165  	va_end(ap);
166  	if (*fmt) {
167  		fmt += strlen(fmt);
168  		if (fmt[-1] != '\n')
169  			(void)fputc('\n', stderr);
170  	}
171  	exit(1);
172  }
173  static void
174  warning(const char *fmt, ...)
175  {
176  	va_list ap;
177  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
178  	va_start(ap, fmt);
179  	(void)vfprintf(stderr, fmt, ap);
180  	va_end(ap);
181  	if (*fmt) {
182  		fmt += strlen(fmt);
183  		if (fmt[-1] != '\n')
184  			(void)fputc('\n', stderr);
185  	}
186  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_verify_hash.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MECC
<span onclick='openModal()' class='match'>3  int ecc_verify_hash_ex(const unsigned char *sig,  unsigned long siglen,
4                         const unsigned char *hash, unsigned long hashlen,
5                         ecc_signature_type sigformat, int *stat, const ecc_key *key)
6  {
7     ecc_point     *mG = NULL, *mQ = NULL;
</span>8     void          *r, *s, *v, *w, *u1, *u2, *e, *p, *m, *a, *a_plus3;
9     void          *mu = NULL, *ma = NULL;
10     void          *mp = NULL;
11     int           err;
12     unsigned long pbits, pbytes, i, shift_right;
13     unsigned char ch, buf[MAXBLOCKSIZE];
14     LTC_ARGCHK(sig  != NULL);
15     LTC_ARGCHK(hash != NULL);
16     LTC_ARGCHK(stat != NULL);
17     LTC_ARGCHK(key  != NULL);
18     *stat = 0;
19     if ((err = mp_init_multi(&r, &s, &v, &w, &u1, &u2, &e, &a_plus3, LTC_NULL)) != CRYPT_OK) {
20        return err;
21     }
22     p = key->dp.order;
23     m = key->dp.prime;
24     a = key->dp.A;
25     if ((err = mp_add_d(a, 3, a_plus3)) != CRYPT_OK) {
26        goto error;
27     }
28     mG = ltc_ecc_new_point();
29     mQ = ltc_ecc_new_point();
30     if (mQ  == NULL || mG == NULL) {
31        err = CRYPT_MEM;
32        goto error;
33     }
34     if (sigformat == LTC_ECCSIG_ANSIX962) {
35        if ((err = der_decode_sequence_multi_ex(sig, siglen, LTC_DER_SEQ_SEQUENCE | LTC_DER_SEQ_STRICT,
36                                       LTC_ASN1_INTEGER, 1UL, r,
37                                       LTC_ASN1_INTEGER, 1UL, s,
38                                       LTC_ASN1_EOL, 0UL, LTC_NULL)) != CRYPT_OK)                         { goto error; }
39     }
40     else if (sigformat == LTC_ECCSIG_RFC7518) {
41        i = mp_unsigned_bin_size(key->dp.order);
42        if (siglen != (2 * i)) {
43           err = CRYPT_INVALID_PACKET;
44           goto error;
45        }
46        if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,   i)) != CRYPT_OK)                       { goto error; }
47        if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+i, i)) != CRYPT_OK)                       { goto error; }
48     }
49     else if (sigformat == LTC_ECCSIG_ETH27) {
50        if (pk_oid_cmp_with_ulong("1.3.132.0.10", key->dp.oid, key->dp.oidlen) != CRYPT_OK) {
51           err = CRYPT_ERROR; goto error;
52        }
53        if (siglen != 65) { &bsol;* Only secp256k1 curves use this format, so must be 65 bytes long */
54           err = CRYPT_INVALID_PACKET;
55           goto error;
56        }
57        if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,  32)) != CRYPT_OK)                       { goto error; }
58        if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+32, 32)) != CRYPT_OK)                     { goto error; }
59     }
60  #ifdef LTC_SSH
61     else if (sigformat == LTC_ECCSIG_RFC5656) {
62        char name[64], name2[64];
63        unsigned long namelen = sizeof(name);
64        unsigned long name2len = sizeof(name2);
65        if ((err = ssh_decode_sequence_multi(sig, &siglen,
66                                             LTC_SSHDATA_STRING, name, &namelen,
67                                             LTC_SSHDATA_MPINT,  r,
68                                             LTC_SSHDATA_MPINT,  s,
69                                             LTC_SSHDATA_EOL,    NULL)) != CRYPT_OK)                      { goto error; }
70        if ((err = ecc_ssh_ecdsa_encode_name(name2, &name2len, key)) != CRYPT_OK)                         { goto error; }
71        if ((namelen != name2len) || (XSTRCMP(name, name2) != 0)) {
72           err = CRYPT_INVALID_ARG;
73           goto error;
74        }
75     }
76  #endif
77     else {
78        err = CRYPT_ERROR;
79        goto error;
80     }
81     if (mp_cmp_d(r, 0) != LTC_MP_GT || mp_cmp_d(s, 0) != LTC_MP_GT ||
82         mp_cmp(r, p) != LTC_MP_LT || mp_cmp(s, p) != LTC_MP_LT) {
83        err = CRYPT_INVALID_PACKET;
84        goto error;
85     }
86     pbits = mp_count_bits(p);
87     pbytes = (pbits+7) >> 3;
88     if (pbits > hashlen*8) {
89        if ((err = mp_read_unsigned_bin(e, (unsigned char *)hash, hashlen)) != CRYPT_OK)                  { goto error; }
90     }
91     else if (pbits % 8 == 0) {
92        if ((err = mp_read_unsigned_bin(e, (unsigned char *)hash, pbytes)) != CRYPT_OK)                   { goto error; }
93     }
94     else {
95        shift_right = 8 - pbits % 8;
96        for (i=0, ch=0; i<pbytes; i++) {
97          buf[i] = ch;
98          ch = (hash[i] << (8-shift_right));
99          buf[i] = buf[i] ^ (hash[i] >> shift_right);
100        }
101        if ((err = mp_read_unsigned_bin(e, (unsigned char *)buf, pbytes)) != CRYPT_OK)                    { goto error; }
102     }
103     if ((err = mp_invmod(s, p, w)) != CRYPT_OK)                                                          { goto error; }
104     if ((err = mp_mulmod(e, w, p, u1)) != CRYPT_OK)                                                      { goto error; }
105     if ((err = mp_mulmod(r, w, p, u2)) != CRYPT_OK)                                                      { goto error; }
106     if ((err = ltc_ecc_copy_point(&key->dp.base, mG)) != CRYPT_OK)                                       { goto error; }
107     if ((err = ltc_ecc_copy_point(&key->pubkey, mQ)) != CRYPT_OK)                                        { goto error; }
108     if ((err = mp_montgomery_setup(m, &mp)) != CRYPT_OK)                                                 { goto error; }
109     if (mp_cmp(a_plus3, m) != LTC_MP_EQ) {
110        if ((err = mp_init_multi(&mu, &ma, LTC_NULL)) != CRYPT_OK)                                        { goto error; }
111        if ((err = mp_montgomery_normalization(mu, m)) != CRYPT_OK)                                       { goto error; }
112        if ((err = mp_mulmod(a, mu, m, ma)) != CRYPT_OK)                                                  { goto error; }
113     }
114     if (ltc_mp.ecc_mul2add == NULL) {
115        if ((err = ltc_mp.ecc_ptmul(u1, mG, mG, a, m, 0)) != CRYPT_OK)                                    { goto error; }
116        if ((err = ltc_mp.ecc_ptmul(u2, mQ, mQ, a, m, 0)) != CRYPT_OK)                                    { goto error; }
117        if ((err = ltc_mp.ecc_ptadd(mQ, mG, mG, ma, m, mp)) != CRYPT_OK)                                  { goto error; }
118        if ((err = ltc_mp.ecc_map(mG, m, mp)) != CRYPT_OK)                                                { goto error; }
119     } else {
120        if ((err = ltc_mp.ecc_mul2add(mG, u1, mQ, u2, mG, ma, m)) != CRYPT_OK)                            { goto error; }
121     }
122     if ((err = mp_mod(mG->x, p, v)) != CRYPT_OK)                                                         { goto error; }
123     if (mp_cmp(v, r) == LTC_MP_EQ) {
124        *stat = 1;
125     }
126     err = CRYPT_OK;
127  error:
128     if (mG != NULL) ltc_ecc_del_point(mG);
129     if (mQ != NULL) ltc_ecc_del_point(mQ);
130     if (mu != NULL) mp_clear(mu);
131     if (ma != NULL) mp_clear(ma);
132     mp_clear_multi(r, s, v, w, u1, u2, e, a_plus3, LTC_NULL);
133     if (mp != NULL) mp_montgomery_free(mp);
134     return err;
135  }
136  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-opentest.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_verify_hash.c</div>
                </div>
                <div class="column column_space"><pre><code>28  main(int argc, char **argv)
29  {
30  	register int op;
31  	register char *cp, *device;
32  	int dorfmon, dopromisc, snaplen, useactivate, bufsize;
33  	char ebuf[PCAP_ERRBUF_SIZE];
34  	pcap_if_t *devlist;
35  	pcap_t *pd;
36  	int status = 0;
37  	device = NULL;
</pre></code></div>
                <div class="column column_space"><pre><code>3  int ecc_verify_hash_ex(const unsigned char *sig,  unsigned long siglen,
4                         const unsigned char *hash, unsigned long hashlen,
5                         ecc_signature_type sigformat, int *stat, const ecc_key *key)
6  {
7     ecc_point     *mG = NULL, *mQ = NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    