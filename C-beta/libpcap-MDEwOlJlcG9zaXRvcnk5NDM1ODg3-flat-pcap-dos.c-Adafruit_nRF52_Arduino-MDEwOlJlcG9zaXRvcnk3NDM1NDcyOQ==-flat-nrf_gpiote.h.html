
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 41.409691629955944%, Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dos.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include <signal.h>
5  #include <float.h>
6  #include <fcntl.h>
7  #include <limits.h> &bsol;* for INT_MAX */
8  #include <io.h>
9  #if defined(USE_32BIT_DRIVERS)
10    #include "msdos/pm_drvr/pmdrvr.h"
11    #include "msdos/pm_drvr/pci.h"
12    #include "msdos/pm_drvr/bios32.h"
13    #include "msdos/pm_drvr/module.h"
14    #include "msdos/pm_drvr/3c501.h"
15    #include "msdos/pm_drvr/3c503.h"
16    #include "msdos/pm_drvr/3c509.h"
17    #include "msdos/pm_drvr/3c59x.h"
18    #include "msdos/pm_drvr/3c515.h"
19    #include "msdos/pm_drvr/3c90x.h"
20    #include "msdos/pm_drvr/3c575_cb.h"
21    #include "msdos/pm_drvr/ne.h"
22    #include "msdos/pm_drvr/wd.h"
23    #include "msdos/pm_drvr/accton.h"
24    #include "msdos/pm_drvr/cs89x0.h"
25    #include "msdos/pm_drvr/rtl8139.h"
26    #include "msdos/pm_drvr/ne2k-pci.h"
27  #endif
28  #include "pcap.h"
29  #include "pcap-dos.h"
30  #include "pcap-int.h"
31  #include "msdos/pktdrvr.h"
32  #ifdef USE_NDIS2
33  #include "msdos/ndis2.h"
34  #endif
35  #include <arpa/inet.h>
36  #include <net/if.h>
37  #include <net/if_arp.h>
38  #include <net/if_ether.h>
39  #include <net/if_packe.h>
40  #include <tcp.h>
41  #if defined(USE_32BIT_DRIVERS)
42    #define FLUSHK()       do { _printk_safe = 1; _printk_flush(); } while (0)
43    #define NDIS_NEXT_DEV  &rtl8139_dev
44    static char *rx_pool = NULL;
<span onclick='openModal()' class='match'>45    static void init_32bit (void);
46    static int  pktq_init     (struct rx_ringbuf *q, int size, int num, char *pool);
47    static int  pktq_check    (struct rx_ringbuf *q);
48    static int  pktq_inc_out  (struct rx_ringbuf *q);
49    static int  pktq_in_index (struct rx_ringbuf *q) LOCKED_FUNC;
50    static void pktq_clear    (struct rx_ringbuf *q) LOCKED_FUNC;
51    static struct rx_elem *pktq_in_elem  (struct rx_ringbuf *q) LOCKED_FUNC;
52    static struct rx_elem *pktq_out_elem (struct rx_ringbuf *q);
53  #else
54    #define FLUSHK()      ((void)0)
55    #define NDIS_NEXT_DEV  NULL
56  #endif
57  extern WORD  _pktdevclass;
58  extern BOOL  _eth_is_init;
59  extern int   _w32_dynamic_host;
60  extern int   _watt_do_exit;
61  extern int   _watt_is_init;
62  extern int   _w32__bootp_on, _w32__dhcp_on, _w32__rarp_on, _w32__do_mask_req;
63  extern void (*_w32_usr_post_init) (void);
64  extern void (*_w32_print_hook)();
65  extern void dbug_write (const char *);  &bsol;* Watt-32 lib, pcdbug.c */
66  extern int  pkt_get_mtu (void);
67  static int ref_count = 0;
</span>68  static u_long mac_count    = 0;
69  static u_long filter_count = 0;
70  static volatile BOOL exc_occured = 0;
71  static struct device *handle_to_device [20];
72  static int  pcap_activate_dos (pcap_t *p);
73  static int  pcap_read_dos (pcap_t *p, int cnt, pcap_handler callback,
74                             u_char *data);
75  static void pcap_cleanup_dos (pcap_t *p);
76  static int  pcap_stats_dos (pcap_t *p, struct pcap_stat *ps);
77  static int  pcap_sendpacket_dos (pcap_t *p, const void *buf, size_t len);
78  static int  pcap_setfilter_dos (pcap_t *p, struct bpf_program *fp);
79  static int  ndis_probe (struct device *dev);
80  static int  pkt_probe  (struct device *dev);
81  static void close_driver (void);
82  static int  init_watt32 (struct pcap *pcap, const char *dev_name, char *err_buf);
83  static int  first_init (const char *name, char *ebuf, int promisc);
84  static void watt32_recv_hook (u_char *dummy, const struct pcap_pkthdr *pcap,
85                                const u_char *buf);
86  static struct device ndis_dev = {
87                "ndis",
88                "NDIS2 LanManager",
89                0,
90                0,0,0,0,0,0,
91                NDIS_NEXT_DEV,  &bsol;* NULL or a 32-bit device */
92                ndis_probe
93              };
94  static struct device pkt_dev = {
95                "pkt",
96                "Packet-Driver",
97                0,
98                0,0,0,0,0,0,
99                &ndis_dev,
100                pkt_probe
101              };
102  static struct device *get_device (int fd)
103  {
104    if (fd <= 0 || fd >= sizeof(handle_to_device)/sizeof(handle_to_device[0]))
105       return (NULL);
106    return handle_to_device [fd-1];
107  }
108  struct pcap_dos {
109  	void (*wait_proc)(void); &bsol;* call proc while waiting */
110  	struct pcap_stat stat;
111  };
112  pcap_t *pcap_create_interface (const char *device _U_, char *ebuf)
113  {
114  	pcap_t *p;
115  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_dos);
116  	if (p == NULL)
117  		return (NULL);
118  	p->activate_op = pcap_activate_dos;
119  	return (p);
120  }
121  static int pcap_activate_dos (pcap_t *pcap)
122  {
123    if (pcap->opt.rfmon) {
124      return (PCAP_ERROR_RFMON_NOTSUP);
125    }
126    if (pcap->snapshot <= 0 || pcap->snapshot > MAXIMUM_SNAPLEN)
127      pcap->snapshot = MAXIMUM_SNAPLEN;
128    if (pcap->snapshot < ETH_MIN+8)
129        pcap->snapshot = ETH_MIN+8;
130    if (pcap->snapshot > ETH_MAX)   &bsol;* silently accept and truncate large MTUs */
131        pcap->snapshot = ETH_MAX;
132    pcap->linktype          = DLT_EN10MB;  &bsol;* !! */
133    pcap->cleanup_op        = pcap_cleanup_dos;
134    pcap->read_op           = pcap_read_dos;
135    pcap->stats_op          = pcap_stats_dos;
136    pcap->inject_op         = pcap_sendpacket_dos;
137    pcap->setfilter_op      = pcap_setfilter_dos;
138    pcap->setdirection_op   = NULL;  &bsol;* Not implemented.*/
139    pcap->fd                = ++ref_count;
140    pcap->bufsize = ETH_MAX+100;     &bsol;* add some margin */
141    pcap->buffer = calloc (pcap->bufsize, 1);
142    if (pcap->fd == 1)  &bsol;* first time we're called */
143    {
144      if (!init_watt32(pcap, pcap->opt.device, pcap->errbuf) ||
145          !first_init(pcap->opt.device, pcap->errbuf, pcap->opt.promisc))
146      {
147        return (PCAP_ERROR);
148      }
149      atexit (close_driver);
150    }
151    else if (stricmp(active_dev->name,pcap->opt.device))
152    {
153      snprintf (pcap->errbuf, PCAP_ERRBUF_SIZE,
154                     "Cannot use different devices simultaneously "
155                     "(`%s' vs. `%s')", active_dev->name, pcap->opt.device);
156      return (PCAP_ERROR);
157    }
158    handle_to_device [pcap->fd-1] = active_dev;
159    return (0);
160  }
161  static int
162  pcap_read_one (pcap_t *p, pcap_handler callback, u_char *data)
163  {
164    struct pcap_dos *pd = p->priv;
165    struct pcap_pkthdr pcap;
166    struct timeval     now, expiry = { 0,0 };
167    int    rx_len = 0;
168    if (p->opt.timeout > 0)
169    {
170      gettimeofday2 (&now, NULL);
171      expiry.tv_usec = now.tv_usec + 1000UL * p->opt.timeout;
172      expiry.tv_sec  = now.tv_sec;
173      while (expiry.tv_usec >= 1000000L)
174      {
175        expiry.tv_usec -= 1000000L;
176        expiry.tv_sec++;
177      }
178    }
179    while (!exc_occured)
180    {
181      volatile struct device *dev; &bsol;* might be reset by sig_handler */
182      dev = get_device (p->fd);
183      if (!dev)
184         break;
185      PCAP_ASSERT (dev->copy_rx_buf || dev->peek_rx_buf);
186      FLUSHK();
187      if (dev->peek_rx_buf)
188      {
189        PCAP_ASSERT (dev->release_rx_buf);
190        rx_len = (*dev->peek_rx_buf) (&p->buffer);
191      }
192      else
193      {
194        rx_len = (*dev->copy_rx_buf) (p->buffer, p->snapshot);
195      }
196      if (rx_len > 0)  &bsol;* got a packet */
197      {
198        mac_count++;
199        FLUSHK();
200        pcap.caplen = min (rx_len, p->snapshot);
201        pcap.len    = rx_len;
202        if (callback &&
203            (!p->fcode.bf_insns || pcap_filter(p->fcode.bf_insns, p->buffer, pcap.len, pcap.caplen)))
204        {
205          filter_count++;
206          gettimeofday2 (&pcap.ts, NULL);
207          (*callback) (data, &pcap, p->buffer);
208        }
209        if (dev->release_rx_buf)
210          (*dev->release_rx_buf) (p->buffer);
211        if (pcap_pkt_debug > 0)
212        {
213          if (callback == watt32_recv_hook)
214               dbug_write ("pcap_recv_hook\n");
215          else dbug_write ("pcap_read_op\n");
216        }
217        FLUSHK();
218        return (1);
219      }
220      if (p->break_loop) {
221        p->break_loop = 0;
222        return (-2);
223      }
224      if (p->opt.timeout <= 0 || (volatile int)p->fd <= 0)
225         break;
226      gettimeofday2 (&now, NULL);
227      if (timercmp(&now, &expiry, >))
228         break;
229  #ifndef DJGPP
230      kbhit();    &bsol;* a real CPU hog */
231  #endif
232      if (pd->wait_proc)
233        (*pd->wait_proc)();     &bsol;* call yield func */
234    }
235    if (rx_len < 0)            &bsol;* receive error */
236    {
237      pd->stat.ps_drop++;
238  #ifdef USE_32BIT_DRIVERS
239      if (pcap_pkt_debug > 1)
240         printk ("pkt-err %s\n", pktInfo.error);
241  #endif
242      return (-1);
243    }
244    return (0);
245  }
246  static int
247  pcap_read_dos (pcap_t *p, int cnt, pcap_handler callback, u_char *data)
248  {
249    int rc, num = 0;
250    if (PACKET_COUNT_IS_UNLIMITED(cnt))
251      cnt = INT_MAX;
252    while (num <= cnt)
253    {
254      if (p->fd <= 0)
255         return (-1);
256      rc = pcap_read_one (p, callback, data);
257      if (rc > 0)
258         num++;
259      if (rc < 0)
260         break;
261      _w32_os_yield();  &bsol;* allow SIGINT generation, yield to Win95/NT */
262    }
263    return (num);
264  }
265  static int pcap_stats_dos (pcap_t *p, struct pcap_stat *ps)
266  {
267    struct net_device_stats *stats;
268    struct pcap_dos         *pd;
269    struct device           *dev = p ? get_device(p->fd) : NULL;
270    if (!dev)
271    {
272      strcpy (p->errbuf, "illegal pcap handle");
273      return (-1);
274    }
275    if (!dev->get_stats || (stats = (*dev->get_stats)(dev)) == NULL)
276    {
277      strcpy (p->errbuf, "device statistics not available");
278      return (-1);
279    }
280    FLUSHK();
281    pd = p->priv;
282    pd->stat.ps_recv   = stats->rx_packets;
283    pd->stat.ps_drop  += stats->rx_missed_errors;
284    pd->stat.ps_ifdrop = stats->rx_dropped +  &bsol;* queue full */
285                           stats->rx_errors;    &bsol;* HW errors */
286    if (ps)
287       *ps = pd->stat;
288    return (0);
289  }
290  int pcap_stats_ex (pcap_t *p, struct pcap_stat_ex *se)
291  {
292    struct device *dev = p ? get_device (p->fd) : NULL;
293    if (!dev || !dev->get_stats)
294    {
295      pcap_strlcpy (p->errbuf, "detailed device statistics not available",
296               PCAP_ERRBUF_SIZE);
297      return (-1);
298    }
299    if (!strnicmp(dev->name,"pkt",3))
300    {
301      pcap_strlcpy (p->errbuf, "pktdrvr doesn't have detailed statistics",
302               PCAP_ERRBUF_SIZE);
303      return (-1);
304    }
305    memcpy (se, (*dev->get_stats)(dev), sizeof(*se));
306    return (0);
307  }
308  static int pcap_setfilter_dos (pcap_t *p, struct bpf_program *fp)
309  {
310    if (!p)
311       return (-1);
312    p->fcode = *fp;
313    return (0);
314  }
315  u_long pcap_mac_packets (void)
316  {
317    return (mac_count);
318  }
319  u_long pcap_filter_packets (void)
320  {
321    return (filter_count);
322  }
323  static void pcap_cleanup_dos (pcap_t *p)
324  {
325    struct pcap_dos *pd;
326    if (!exc_occured)
327    {
328      pd = p->priv;
329      if (pcap_stats(p,NULL) < 0)
330         pd->stat.ps_drop = 0;
331      if (!get_device(p->fd))
332         return;
333      handle_to_device [p->fd-1] = NULL;
334      p->fd = 0;
335      if (ref_count > 0)
336          ref_count--;
337      if (ref_count > 0)
338         return;
339    }
340    close_driver();
341  }
342  char *pcap_lookupdev (char *ebuf)
343  {
344    struct device *dev;
345  #ifdef USE_32BIT_DRIVERS
346    init_32bit();
347  #endif
348    for (dev = (struct device*)dev_base; dev; dev = dev->next)
349    {
350      PCAP_ASSERT (dev->probe);
351      if ((*dev->probe)(dev))
352      {
353        FLUSHK();
354        probed_dev = (struct device*) dev; &bsol;* remember last probed device */
355        return (char*) dev->name;
356      }
357    }
358    if (ebuf)
359       strcpy (ebuf, "No driver found");
360    return (NULL);
361  }
362  int pcap_lookupnet (const char *device, bpf_u_int32 *localnet,
363                      bpf_u_int32 *netmask, char *errbuf)
364  {
365    DWORD mask, net;
366    if (!_watt_is_init)
367    {
368      strcpy (errbuf, "pcap_open_offline() or pcap_activate() must be "
369                      "called first");
370      return (-1);
371    }
372    mask  = _w32_sin_mask;
373    net = my_ip_addr & mask;
374    if (net == 0)
375    {
376      if (IN_CLASSA(*netmask))
377         net = IN_CLASSA_NET;
378      else if (IN_CLASSB(*netmask))
379         net = IN_CLASSB_NET;
380      else if (IN_CLASSC(*netmask))
381         net = IN_CLASSC_NET;
382      else
383      {
384        snprintf (errbuf, PCAP_ERRBUF_SIZE, "inet class for 0x%lx unknown", mask);
385        return (-1);
386      }
387    }
388    *localnet = htonl (net);
389    *netmask = htonl (mask);
390    ARGSUSED (device);
391    return (0);
392  }
393  int pcap_platform_finddevs  (pcap_if_list_t *devlistp, char *errbuf)
394  {
395    struct device     *dev;
396    pcap_if_t *curdev;
397  #if 0   &bsol;* Pkt drivers should have no addresses */
398    struct sockaddr_in sa_ll_1, sa_ll_2;
399    struct sockaddr   *addr, *netmask, *broadaddr, *dstaddr;
400  #endif
401    int       ret = 0;
402    int       found = 0;
403    for (dev = (struct device*)dev_base; dev; dev = dev->next)
404    {
405      PCAP_ASSERT (dev->probe);
406      if (!(*dev->probe)(dev))
407         continue;
408      PCAP_ASSERT (dev->close);  &bsol;* set by probe routine */
409      FLUSHK();
410      (*dev->close) (dev);
411      if ((curdev = pcap_add_dev(devlistp, dev->name, 0,
412                  dev->long_name, errbuf)) == NULL)
413      {
414        ret = -1;
415        break;
416      }
417      found = 1;
418  #if 0   &bsol;* Pkt drivers should have no addresses */
419      memset (&sa_ll_1, 0, sizeof(sa_ll_1));
420      memset (&sa_ll_2, 0, sizeof(sa_ll_2));
421      sa_ll_1.sin_family = AF_INET;
422      sa_ll_2.sin_family = AF_INET;
423      addr      = (struct sockaddr*) &sa_ll_1;
424      netmask   = (struct sockaddr*) &sa_ll_1;
425      dstaddr   = (struct sockaddr*) &sa_ll_1;
426      broadaddr = (struct sockaddr*) &sa_ll_2;
427      memset (&sa_ll_2.sin_addr, 0xFF, sizeof(sa_ll_2.sin_addr));
428      if (pcap_add_addr_to_dev(curdev, addr, sizeof(*addr),
429                          netmask, sizeof(*netmask),
430                          broadaddr, sizeof(*broadaddr),
431                          dstaddr, sizeof(*dstaddr), errbuf) < 0)
432      {
433        ret = -1;
434        break;
435      }
436  #endif
437    }
438    if (ret == 0 && !found)
439       strcpy (errbuf, "No drivers found");
440    return (ret);
441  }
442  void pcap_assert (const char *what, const char *file, unsigned line)
443  {
444    FLUSHK();
445    fprintf (stderr, "%s (%u): Assertion \"%s\" failed\n",
446             file, line, what);
447    close_driver();
448    _exit (-1);
449  }
450  void pcap_set_wait (pcap_t *p, void (*yield)(void), int wait)
451  {
452    if (p)
453    {
454      struct pcap_dos *pd = p->priv;
455      pd->wait_proc  = yield;
456      p->opt.timeout = wait;
457    }
458  }
459  static struct device *
460  open_driver (const char *dev_name, char *ebuf, int promisc)
461  {
462    struct device *dev;
463    for (dev = (struct device*)dev_base; dev; dev = dev->next)
464    {
465      PCAP_ASSERT (dev->name);
466      if (strcmp (dev_name,dev->name))
467         continue;
468      if (!probed_dev)   &bsol;* user didn't call pcap_lookupdev() first */
469      {
470        PCAP_ASSERT (dev->probe);
471        if (!(*dev->probe)(dev))    &bsol;* call the xx_probe() function */
472        {
473          snprintf (ebuf, PCAP_ERRBUF_SIZE, "failed to detect device `%s'", dev_name);
474          return (NULL);
475        }
476        probed_dev = dev;  &bsol;* device is probed okay and may be used */
477      }
478      else if (dev != probed_dev)
479      {
480        goto not_probed;
481      }
482      FLUSHK();
483      if (promisc)
484           dev->flags |=  (IFF_ALLMULTI | IFF_PROMISC);
485      else dev->flags &= ~(IFF_ALLMULTI | IFF_PROMISC);
486      PCAP_ASSERT (dev->open);
487      if (!(*dev->open)(dev))
488      {
489        snprintf (ebuf, PCAP_ERRBUF_SIZE, "failed to activate device `%s'", dev_name);
490        if (pktInfo.error && !strncmp(dev->name,"pkt",3))
491        {
492          strcat (ebuf, ": ");
493          strcat (ebuf, pktInfo.error);
494        }
495        return (NULL);
496      }
497      if (promisc && dev->set_multicast_list)
498         (*dev->set_multicast_list) (dev);
499      active_dev = dev;   &bsol;* remember our active device */
500      break;
501    }
502    if (!dev)
503    {
504      snprintf (ebuf, PCAP_ERRBUF_SIZE, "device `%s' not supported", dev_name);
505      return (NULL);
506    }
507  not_probed:
508    if (!probed_dev)
509    {
510      snprintf (ebuf, PCAP_ERRBUF_SIZE, "device `%s' not probed", dev_name);
511      return (NULL);
512    }
513    return (dev);
514  }
515  static void close_driver (void)
516  {
517    struct device *dev = active_dev;
518    if (dev && dev->close)
519    {
520      (*dev->close) (dev);
521      FLUSHK();
522    }
523    active_dev = NULL;
524  #ifdef USE_32BIT_DRIVERS
525    if (rx_pool)
526    {
527      k_free (rx_pool);
528      rx_pool = NULL;
529    }
530    if (dev)
531       pcibios_exit();
532  #endif
533  }
534  #ifdef __DJGPP__
535  static void setup_signals (void (*handler)(int))
536  {
537    signal (SIGSEGV,handler);
538    signal (SIGILL, handler);
539    signal (SIGFPE, handler);
540  }
541  static void exc_handler (int sig)
542  {
543  #ifdef USE_32BIT_DRIVERS
544    if (active_dev->irq > 0)    &bsol;* excludes IRQ 0 */
545    {
546      disable_irq (active_dev->irq);
547      irq_eoi_cmd (active_dev->irq);
548      _printk_safe = 1;
549    }
550  #endif
551    switch (sig)
552    {
553      case SIGSEGV:
554           fputs ("Catching SIGSEGV.\n", stderr);
555           break;
556      case SIGILL:
557           fputs ("Catching SIGILL.\n", stderr);
558           break;
559      case SIGFPE:
560           _fpreset();
561           fputs ("Catching SIGFPE.\n", stderr);
562           break;
563      default:
564           fprintf (stderr, "Catching signal %d.\n", sig);
565    }
566    exc_occured = 1;
567    close_driver();
568  }
569  #endif  &bsol;* __DJGPP__ */
570  static int first_init (const char *name, char *ebuf, int promisc)
571  {
572    struct device *dev;
573  #ifdef USE_32BIT_DRIVERS
574    rx_pool = k_calloc (RECEIVE_BUF_SIZE, RECEIVE_QUEUE_SIZE);
575    if (!rx_pool)
576    {
577      strcpy (ebuf, "Not enough memory (Rx pool)");
578      return (0);
579    }
580  #endif
581  #ifdef __DJGPP__
582    setup_signals (exc_handler);
583  #endif
584  #ifdef USE_32BIT_DRIVERS
585    init_32bit();
586  #endif
587    dev = open_driver (name, ebuf, promisc);
588    if (!dev)
589    {
590  #ifdef USE_32BIT_DRIVERS
591      k_free (rx_pool);
592      rx_pool = NULL;
593  #endif
594  #ifdef __DJGPP__
595      setup_signals (SIG_DFL);
596  #endif
597      return (0);
598    }
599  #ifdef USE_32BIT_DRIVERS
600    if (dev->copy_rx_buf == NULL)
601    {
602      dev->get_rx_buf     = get_rxbuf;
603      dev->peek_rx_buf    = peek_rxbuf;
604      dev->release_rx_buf = release_rxbuf;
605      pktq_init (&dev->queue, RECEIVE_BUF_SIZE, RECEIVE_QUEUE_SIZE, rx_pool);
606    }
607  #endif
608    return (1);
609  }
610  #ifdef USE_32BIT_DRIVERS
611  static void init_32bit (void)
612  {
613    static int init_pci = 0;
614    if (!_printk_file)
615       _printk_init (64*1024, NULL); &bsol;* calls atexit(printk_exit) */
616    if (!init_pci)
617       (void)pci_init();             &bsol;* init BIOS32+PCI interface */
618    init_pci = 1;
619  }
620  #endif
621  static char rxbuf [ETH_MAX+100]; &bsol;* rx-buffer with some margin */
622  static WORD etype;
623  static pcap_t pcap_save;
624  static void watt32_recv_hook (u_char *dummy, const struct pcap_pkthdr *pcap,
625                                const u_char *buf)
626  {
627    struct ether_header *ep = (struct ether_header*) buf;
628    memcpy (rxbuf, buf, pcap->caplen);
629    etype = ep->ether_type;
630    ARGSUSED (dummy);
631  }
632  #if (WATTCP_VER >= 0x0224)
633  static void *pcap_recv_hook (WORD *type)
634  {
635    int len = pcap_read_dos (&pcap_save, 1, watt32_recv_hook, NULL);
636    if (len < 0)
637       return (NULL);
638    *type = etype;
639    return (void*) &rxbuf;
640  }
641  static int pcap_xmit_hook (const void *buf, unsigned len)
642  {
643    int rc = 0;
644    if (pcap_pkt_debug > 0)
645       dbug_write ("pcap_xmit_hook: ");
646    if (active_dev && active_dev->xmit)
647       if ((*active_dev->xmit) (active_dev, buf, len) > 0)
648          rc = len;
649    if (pcap_pkt_debug > 0)
650       dbug_write (rc ? "ok\n" : "fail\n");
651    return (rc);
652  }
653  #endif
654  static int pcap_sendpacket_dos (pcap_t *p, const void *buf, size_t len)
655  {
656    struct device *dev = p ? get_device(p->fd) : NULL;
657    if (!dev || !dev->xmit)
658       return (-1);
659    return (*dev->xmit) (dev, buf, len);
660  }
661  static void (*prev_post_hook) (void);
662  static void pcap_init_hook (void)
663  {
664    _w32__bootp_on = _w32__dhcp_on = _w32__rarp_on = 0;
665    _w32__do_mask_req = 0;
666    _w32_dynamic_host = 0;
667    if (prev_post_hook)
668      (*prev_post_hook)();
669  }
670  static void null_print (void) {}
671  static int init_watt32 (struct pcap *pcap, const char *dev_name, char *err_buf)
672  {
673    char *env;
674    int   rc, MTU, has_ip_addr;
675    int   using_pktdrv = 1;
676    if (_watt_is_init)
677       sock_exit();
678    env = getenv ("PCAP_TRACE");
679    if (env && atoi(env) > 0 &&
680        pcap_pkt_debug < 0)   &bsol;* if not already set */
681    {
682      dbug_init();
683      pcap_pkt_debug = atoi (env);
684    }
685    _watt_do_exit      = 0;    &bsol;* prevent sock_init() calling exit() */
686    prev_post_hook     = _w32_usr_post_init;
687    _w32_usr_post_init = pcap_init_hook;
688    _w32_print_hook    = null_print;
689    if (dev_name && strncmp(dev_name,"pkt",3))
690       using_pktdrv = FALSE;
691    rc = sock_init();
692    has_ip_addr = (rc != 8);  &bsol;* IP-address assignment failed */
693    _watt_is_init = 1;
694    if (!using_pktdrv || !has_ip_addr)  &bsol;* for now .... */
695    {
696      static const char myip[] = "192.168.0.1";
697      static const char mask[] = "255.255.255.0";
698      printf ("Just guessing, using IP %s and netmask %s\n", myip, mask);
699      my_ip_addr    = aton (myip);
700      _w32_sin_mask = aton (mask);
701    }
702    else if (rc && using_pktdrv)
703    {
704      snprintf (err_buf, PCAP_ERRBUF_SIZE, "sock_init() failed, code %d", rc);
705      return (0);
706    }
707  #if (WATTCP_VER >= 0x0224)
708    _eth_recv_hook = pcap_recv_hook;
709    _eth_xmit_hook = pcap_xmit_hook;
710  #endif
711    if (using_pktdrv)
712    {
713      _eth_release();
714    }
715    memcpy (&pcap_save, pcap, sizeof(pcap_save));
716    MTU = pkt_get_mtu();
717    pcap_save.fcode.bf_insns = NULL;
718    pcap_save.linktype       = _eth_get_hwtype (NULL, NULL);
719    pcap_save.snapshot       = MTU > 0 ? MTU : ETH_MAX; &bsol;* assume 1514 */
720    last_nameserver = 0;
721    return (1);
722  }
723  int EISA_bus = 0;  &bsol;* Where is natural place for this? */
724  static const struct config_table debug_tab[] = {
725              { "PKT.DEBUG",       ARG_ATOI,   &pcap_pkt_debug    },
726              { "PKT.VECTOR",      ARG_ATOX_W, NULL               },
727              { "NDIS.DEBUG",      ARG_ATOI,   NULL               },
728  #ifdef USE_32BIT_DRIVERS
729              { "3C503.DEBUG",     ARG_ATOI,   &ei_debug          },
730              { "3C503.IO_BASE",   ARG_ATOX_W, &el2_dev.base_addr },
731              { "3C503.MEMORY",    ARG_ATOX_W, &el2_dev.mem_start },
732              { "3C503.IRQ",       ARG_ATOI,   &el2_dev.irq       },
733              { "3C505.DEBUG",     ARG_ATOI,   NULL               },
734              { "3C505.BASE",      ARG_ATOX_W, NULL               },
735              { "3C507.DEBUG",     ARG_ATOI,   NULL               },
736              { "3C509.DEBUG",     ARG_ATOI,   &el3_debug         },
737              { "3C509.ILOOP",     ARG_ATOI,   &el3_max_loop      },
738              { "3C529.DEBUG",     ARG_ATOI,   NULL               },
739              { "3C575.DEBUG",     ARG_ATOI,   &debug_3c575       },
740              { "3C59X.DEBUG",     ARG_ATOI,   &vortex_debug      },
741              { "3C59X.IFACE0",    ARG_ATOI,   &vortex_options[0] },
742              { "3C59X.IFACE1",    ARG_ATOI,   &vortex_options[1] },
743              { "3C59X.IFACE2",    ARG_ATOI,   &vortex_options[2] },
744              { "3C59X.IFACE3",    ARG_ATOI,   &vortex_options[3] },
745              { "3C90X.DEBUG",     ARG_ATOX_W, &tc90xbc_debug     },
746              { "ACCT.DEBUG",      ARG_ATOI,   &ethpk_debug       },
747              { "CS89.DEBUG",      ARG_ATOI,   &cs89_debug        },
748              { "RTL8139.DEBUG",   ARG_ATOI,   &rtl8139_debug     },
749              { "SMC.DEBUG",       ARG_ATOI,   &ei_debug          },
750              { "PCI.DEBUG",       ARG_ATOI,   &pci_debug         },
751              { "BIOS32.DEBUG",    ARG_ATOI,   &bios32_debug      },
752              { "IRQ.DEBUG",       ARG_ATOI,   &irq_debug         },
753              { "TIMER.IRQ",       ARG_ATOI,   &timer_irq         },
754  #endif
755              { NULL }
756            };
757  int pcap_config_hook (const char *keyword, const char *value)
758  {
759    return parse_config_table (debug_tab, NULL, keyword, value);
760  }
761  struct device       *active_dev = NULL;      &bsol;* the device we have opened */
762  struct device       *probed_dev = NULL;      &bsol;* the device we have probed */
763  const struct device *dev_base   = &pkt_dev;  &bsol;* list of network devices */
764  int pcap_pkt_debug = -1;
765  static void pkt_close (struct device *dev)
766  {
767    BOOL okay = PktExitDriver();
768    if (pcap_pkt_debug > 1)
769       fprintf (stderr, "pkt_close(): %d\n", okay);
770    if (dev->priv)
771       free (dev->priv);
772    dev->priv = NULL;
773  }
774  static int pkt_open (struct device *dev)
775  {
776    PKT_RX_MODE mode;
777    if (dev->flags & IFF_PROMISC)
778         mode = PDRX_ALL_PACKETS;
779    else mode = PDRX_BROADCAST;
780    if (!PktInitDriver(mode))
781       return (0);
782    PktResetStatistics (pktInfo.handle);
783    PktQueueBusy (FALSE);
784    return (1);
785  }
786  static int pkt_xmit (struct device *dev, const void *buf, int len)
787  {
788    struct net_device_stats *stats = (struct net_device_stats*) dev->priv;
789    if (pcap_pkt_debug > 0)
790       dbug_write ("pcap_xmit\n");
791    if (!PktTransmit(buf,len))
792    {
793      stats->tx_errors++;
794      return (0);
795    }
796    return (len);
797  }
798  static void *pkt_stats (struct device *dev)
799  {
800    struct net_device_stats *stats = (struct net_device_stats*) dev->priv;
801    if (!stats || !PktSessStatistics(pktInfo.handle))
802       return (NULL);
803    stats->rx_packets       = pktStat.inPackets;
804    stats->rx_errors        = pktStat.lost;
805    stats->rx_missed_errors = PktRxDropped();
806    return (stats);
807  }
808  static int pkt_probe (struct device *dev)
809  {
810    if (!PktSearchDriver())
811       return (0);
812    dev->open           = pkt_open;
813    dev->xmit           = pkt_xmit;
814    dev->close          = pkt_close;
815    dev->get_stats      = pkt_stats;
816    dev->copy_rx_buf    = PktReceive;  &bsol;* farmem peek and copy routine */
817    dev->get_rx_buf     = NULL;
818    dev->peek_rx_buf    = NULL;
819    dev->release_rx_buf = NULL;
820    dev->priv           = calloc (sizeof(struct net_device_stats), 1);
821    if (!dev->priv)
822       return (0);
823    return (1);
824  }
825  static void ndis_close (struct device *dev)
826  {
827  #ifdef USE_NDIS2
828    NdisShutdown();
829  #endif
830    ARGSUSED (dev);
831  }
832  static int ndis_open (struct device *dev)
833  {
834    int promisc = (dev->flags & IFF_PROMISC);
835  #ifdef USE_NDIS2
836    if (!NdisInit(promisc))
837       return (0);
838    return (1);
839  #else
840    ARGSUSED (promisc);
841    return (0);
842  #endif
843  }
844  static void *ndis_stats (struct device *dev)
845  {
846    static struct net_device_stats stats;
847    ARGSUSED (dev);
848    return (&stats);
849  }
850  static int ndis_probe (struct device *dev)
851  {
852  #ifdef USE_NDIS2
853    if (!NdisOpen())
854       return (0);
855  #endif
856    dev->open           = ndis_open;
857    dev->xmit           = NULL;
858    dev->close          = ndis_close;
859    dev->get_stats      = ndis_stats;
860    dev->copy_rx_buf    = NULL;       &bsol;* to-do */
861    dev->get_rx_buf     = NULL;       &bsol;* upcall is from rmode driver */
862    dev->peek_rx_buf    = NULL;
863    dev->release_rx_buf = NULL;
864    return (0);
865  }
866  #if defined(USE_32BIT_DRIVERS)
867  struct device el2_dev LOCKED_VAR = {
868                "3c503",
869                "EtherLink II",
870                0,
871                0,0,0,0,0,0,
872                NULL,
873                el2_probe
874              };
875  struct device el3_dev LOCKED_VAR = {
876                "3c509",
877                "EtherLink III",
878                0,
879                0,0,0,0,0,0,
880                &el2_dev,
881                el3_probe
882              };
883  struct device tc515_dev LOCKED_VAR = {
884                "3c515",
885                "EtherLink PCI",
886                0,
887                0,0,0,0,0,0,
888                &el3_dev,
889                tc515_probe
890              };
891  struct device tc59_dev LOCKED_VAR = {
892                "3c59x",
893                "EtherLink PCI",
894                0,
895                0,0,0,0,0,0,
896                &tc515_dev,
897                tc59x_probe
898              };
899  struct device tc90xbc_dev LOCKED_VAR = {
900                "3c90x",
901                "EtherLink 90X",
902                0,
903                0,0,0,0,0,0,
904                &tc59_dev,
905                tc90xbc_probe
906              };
907  struct device wd_dev LOCKED_VAR = {
908                "wd",
909                "Westen Digital",
910                0,
911                0,0,0,0,0,0,
912                &tc90xbc_dev,
913                wd_probe
914              };
915  struct device ne_dev LOCKED_VAR = {
916                "ne",
917                "NEx000",
918                0,
919                0,0,0,0,0,0,
920                &wd_dev,
921                ne_probe
922              };
923  struct device acct_dev LOCKED_VAR = {
924                "acct",
925                "Accton EtherPocket",
926                0,
927                0,0,0,0,0,0,
928                &ne_dev,
929                ethpk_probe
930              };
931  struct device cs89_dev LOCKED_VAR = {
932                "cs89",
933                "Crystal Semiconductor",
934                0,
935                0,0,0,0,0,0,
936                &acct_dev,
937                cs89x0_probe
938              };
939  struct device rtl8139_dev LOCKED_VAR = {
940                "rtl8139",
941                "RealTek PCI",
942                0,
943                0,0,0,0,0,0,
944                &cs89_dev,
945                rtl8139_probe     &bsol;* dev->probe routine */
946              };
947  int peek_rxbuf (BYTE **buf)
948  {
949    struct rx_elem *tail, *head;
950    PCAP_ASSERT (pktq_check (&active_dev->queue));
951    DISABLE();
952    tail = pktq_out_elem (&active_dev->queue);
953    head = pktq_in_elem (&active_dev->queue);
954    ENABLE();
955    if (head != tail)
956    {
957      PCAP_ASSERT (tail->size < active_dev->queue.elem_size-4-2);
958      *buf = &tail->data[0];
959      return (tail->size);
960    }
961    *buf = NULL;
962    return (0);
963  }
964  int release_rxbuf (BYTE *buf)
965  {
966  #ifndef NDEBUG
967    struct rx_elem *tail = pktq_out_elem (&active_dev->queue);
968    PCAP_ASSERT (&tail->data[0] == buf);
969  #else
970    ARGSUSED (buf);
971  #endif
972    pktq_inc_out (&active_dev->queue);
973    return (1);
974  }
975  BYTE *get_rxbuf (int len)
976  {
977    int idx;
978    if (len < ETH_MIN || len > ETH_MAX)
979       return (NULL);
980    idx = pktq_in_index (&active_dev->queue);
981  #ifdef DEBUG
982    {
983      static int fan_idx LOCKED_VAR = 0;
984      writew ("-\\|/"[fan_idx++] | (15 << 8),      &bsol;* white on black colour */
985              0xB8000 + 2*79);  &bsol;* upper-right corner, 80-col colour screen */
986      fan_idx &= 3;
987    }
988  #endif
989    if (idx != active_dev->queue.out_index)
990    {
991      struct rx_elem *head = pktq_in_elem (&active_dev->queue);
992      head->size = len;
993      active_dev->queue.in_index = idx;
994      return (&head->data[0]);
995    }
996    pktq_clear (&active_dev->queue);
997    return (NULL);
998  }
999  #define PKTQ_MARKER  0xDEADBEEF
1000  static int pktq_check (struct rx_ringbuf *q)
1001  {
1002  #ifndef NDEBUG
1003    int   i;
1004    char *buf;
1005  #endif
1006    if (!q || !q->num_elem || !q->buf_start)
1007       return (0);
1008  #ifndef NDEBUG
1009    buf = q->buf_start;
1010    for (i = 0; i < q->num_elem; i++)
1011    {
1012      buf += q->elem_size;
1013      if (*(DWORD*)(buf - sizeof(DWORD)) != PKTQ_MARKER)
1014         return (0);
1015    }
1016  #endif
1017    return (1);
1018  }
1019  static int pktq_init (struct rx_ringbuf *q, int size, int num, char *pool)
1020  {
1021    int i;
1022    q->elem_size = size;
1023    q->num_elem  = num;
1024    q->buf_start = pool;
1025    q->in_index  = 0;
1026    q->out_index = 0;
1027    PCAP_ASSERT (size >= sizeof(struct rx_elem) + sizeof(DWORD));
1028    PCAP_ASSERT (num);
1029    PCAP_ASSERT (pool);
1030    for (i = 0; i < num; i++)
1031    {
1032  #if 0
1033      struct rx_elem *elem = (struct rx_elem*) pool;
1034      PCAP_ASSERT (((unsigned)(&elem->data[0]) & 3) == 0);
1035  #endif
1036      pool += size;
1037      *(DWORD*) (pool - sizeof(DWORD)) = PKTQ_MARKER;
1038    }
1039    return (1);
1040  }
1041  static int pktq_inc_out (struct rx_ringbuf *q)
1042  {
1043    q->out_index++;
1044    if (q->out_index >= q->num_elem)
1045        q->out_index = 0;
1046    return (q->out_index);
1047  }
1048  static int pktq_in_index (struct rx_ringbuf *q)
1049  {
1050    volatile int index = q->in_index + 1;
1051    if (index >= q->num_elem)
1052        index = 0;
1053    return (index);
1054  }
1055  static struct rx_elem *pktq_in_elem (struct rx_ringbuf *q)
1056  {
1057    return (struct rx_elem*) (q->buf_start + (q->elem_size * q->in_index));
1058  }
1059  static struct rx_elem *pktq_out_elem (struct rx_ringbuf *q)
1060  {
1061    return (struct rx_elem*) (q->buf_start + (q->elem_size * q->out_index));
1062  }
1063  static void pktq_clear (struct rx_ringbuf *q)
1064  {
1065    q->in_index = q->out_index;
1066  }
1067  #undef __IOPORT_H
1068  #undef __DMA_H
1069  #define extern
1070  #define __inline__
1071  #include "msdos/pm_drvr/ioport.h"
1072  #include "msdos/pm_drvr/dma.h"
1073  #endif &bsol;* USE_32BIT_DRIVERS */
1074  const char *
1075  pcap_lib_version(void)
1076  {
1077    return ("DOS-" PCAP_VERSION_STRING);
1078  }
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_gpiote.h</h3>
            <pre><code>1  #ifndef NRF_GPIOTE_H__
2  #define NRF_GPIOTE_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(GPIOTE_CONFIG_PORT_Msk) || defined(__NRFX_DOXYGEN__)
8  #define GPIOTE_CONFIG_PORT_PIN_Msk (GPIOTE_CONFIG_PORT_Msk | GPIOTE_CONFIG_PSEL_Msk)
9  #else
10  #define GPIOTE_CONFIG_PORT_PIN_Msk GPIOTE_CONFIG_PSEL_Msk
11  #endif
12  typedef enum
13  {
14    NRF_GPIOTE_POLARITY_LOTOHI = GPIOTE_CONFIG_POLARITY_LoToHi,       
15    NRF_GPIOTE_POLARITY_HITOLO = GPIOTE_CONFIG_POLARITY_HiToLo,       
16    NRF_GPIOTE_POLARITY_TOGGLE = GPIOTE_CONFIG_POLARITY_Toggle        
17  } nrf_gpiote_polarity_t;
18  typedef enum
19  {
20    NRF_GPIOTE_INITIAL_VALUE_LOW  = GPIOTE_CONFIG_OUTINIT_Low,       
21    NRF_GPIOTE_INITIAL_VALUE_HIGH = GPIOTE_CONFIG_OUTINIT_High       
22  } nrf_gpiote_outinit_t;
23  typedef enum
24  {
25      NRF_GPIOTE_TASK_OUT_0     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[0]), &bsol;**< Out task 0. */
26      NRF_GPIOTE_TASK_OUT_1     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[1]), &bsol;**< Out task 1. */
27      NRF_GPIOTE_TASK_OUT_2     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[2]), &bsol;**< Out task 2. */
28      NRF_GPIOTE_TASK_OUT_3     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[3]), &bsol;**< Out task 3. */
29  #if (GPIOTE_CH_NUM > 4) || defined(__NRFX_DOXYGEN__)
30      NRF_GPIOTE_TASK_OUT_4     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[4]), &bsol;**< Out task 4. */
31      NRF_GPIOTE_TASK_OUT_5     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[5]), &bsol;**< Out task 5. */
32      NRF_GPIOTE_TASK_OUT_6     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[6]), &bsol;**< Out task 6. */
33      NRF_GPIOTE_TASK_OUT_7     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[7]), &bsol;**< Out task 7. */
34  #endif
35  #if defined(GPIOTE_FEATURE_SET_PRESENT) || defined(__NRFX_DOXYGEN__)
36      NRF_GPIOTE_TASK_SET_0     = offsetof(NRF_GPIOTE_Type, TASKS_SET[0]), &bsol;**< Set task 0. */
37      NRF_GPIOTE_TASK_SET_1     = offsetof(NRF_GPIOTE_Type, TASKS_SET[1]), &bsol;**< Set task 1. */
38      NRF_GPIOTE_TASK_SET_2     = offsetof(NRF_GPIOTE_Type, TASKS_SET[2]), &bsol;**< Set task 2. */
39      NRF_GPIOTE_TASK_SET_3     = offsetof(NRF_GPIOTE_Type, TASKS_SET[3]), &bsol;**< Set task 3. */
40      NRF_GPIOTE_TASK_SET_4     = offsetof(NRF_GPIOTE_Type, TASKS_SET[4]), &bsol;**< Set task 4. */
41      NRF_GPIOTE_TASK_SET_5     = offsetof(NRF_GPIOTE_Type, TASKS_SET[5]), &bsol;**< Set task 5. */
42      NRF_GPIOTE_TASK_SET_6     = offsetof(NRF_GPIOTE_Type, TASKS_SET[6]), &bsol;**< Set task 6. */
43      NRF_GPIOTE_TASK_SET_7     = offsetof(NRF_GPIOTE_Type, TASKS_SET[7]), &bsol;**< Set task 7. */
44  #endif
45  #if defined(GPIOTE_FEATURE_CLR_PRESENT) || defined(__NRFX_DOXYGEN__)
46      NRF_GPIOTE_TASK_CLR_0     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[0]), &bsol;**< Clear task 0. */
47      NRF_GPIOTE_TASK_CLR_1     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[1]), &bsol;**< Clear task 1. */
48      NRF_GPIOTE_TASK_CLR_2     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[2]), &bsol;**< Clear task 2. */
49      NRF_GPIOTE_TASK_CLR_3     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[3]), &bsol;**< Clear task 3. */
50      NRF_GPIOTE_TASK_CLR_4     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[4]), &bsol;**< Clear task 4. */
51      NRF_GPIOTE_TASK_CLR_5     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[5]), &bsol;**< Clear task 5. */
52      NRF_GPIOTE_TASK_CLR_6     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[6]), &bsol;**< Clear task 6. */
53      NRF_GPIOTE_TASK_CLR_7     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[7]), &bsol;**< Clear task 7. */
54  #endif
55  } nrf_gpiote_task_t;
56  typedef enum
57  {
58      NRF_GPIOTE_EVENT_IN_0     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[0]), &bsol;**< In event 0. */
59      NRF_GPIOTE_EVENT_IN_1     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[1]), &bsol;**< In event 1. */
60      NRF_GPIOTE_EVENT_IN_2     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[2]), &bsol;**< In event 2. */
61      NRF_GPIOTE_EVENT_IN_3     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[3]), &bsol;**< In event 3. */
62  #if (GPIOTE_CH_NUM > 4) || defined(__NRFX_DOXYGEN__)
63      NRF_GPIOTE_EVENT_IN_4     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[4]), &bsol;**< In event 4. */
64      NRF_GPIOTE_EVENT_IN_5     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[5]), &bsol;**< In event 5. */
65      NRF_GPIOTE_EVENT_IN_6     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[6]), &bsol;**< In event 6. */
66      NRF_GPIOTE_EVENT_IN_7     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[7]), &bsol;**< In event 7. */
67  #endif
68      NRF_GPIOTE_EVENT_PORT     = offsetof(NRF_GPIOTE_Type, EVENTS_PORT), &bsol;**<  Port event. */
69  } nrf_gpiote_event_t;
70  typedef enum
71  {
72      NRF_GPIOTE_INT_IN0_MASK  = GPIOTE_INTENSET_IN0_Msk,  &bsol;**< GPIOTE interrupt from IN0. */
73      NRF_GPIOTE_INT_IN1_MASK  = GPIOTE_INTENSET_IN1_Msk,  &bsol;**< GPIOTE interrupt from IN1. */
74      NRF_GPIOTE_INT_IN2_MASK  = GPIOTE_INTENSET_IN2_Msk,  &bsol;**< GPIOTE interrupt from IN2. */
75      NRF_GPIOTE_INT_IN3_MASK  = GPIOTE_INTENSET_IN3_Msk,  &bsol;**< GPIOTE interrupt from IN3. */
76  #if (GPIOTE_CH_NUM > 4) || defined(__NRFX_DOXYGEN__)
77      NRF_GPIOTE_INT_IN4_MASK  = GPIOTE_INTENSET_IN4_Msk,  &bsol;**< GPIOTE interrupt from IN4. */
78      NRF_GPIOTE_INT_IN5_MASK  = GPIOTE_INTENSET_IN5_Msk,  &bsol;**< GPIOTE interrupt from IN5. */
79      NRF_GPIOTE_INT_IN6_MASK  = GPIOTE_INTENSET_IN6_Msk,  &bsol;**< GPIOTE interrupt from IN6. */
80      NRF_GPIOTE_INT_IN7_MASK  = GPIOTE_INTENSET_IN7_Msk,  &bsol;**< GPIOTE interrupt from IN7. */
81  #endif
82      NRF_GPIOTE_INT_PORT_MASK = (int)GPIOTE_INTENSET_PORT_Msk, &bsol;**< GPIOTE interrupt from PORT event. */
83  } nrf_gpiote_int_t;
84  #if (GPIOTE_CH_NUM == 4) || defined(__NRFX_DOXYGEN__)
85  #define NRF_GPIOTE_INT_IN_MASK (NRF_GPIOTE_INT_IN0_MASK | NRF_GPIOTE_INT_IN1_MASK |\
86                                  NRF_GPIOTE_INT_IN2_MASK | NRF_GPIOTE_INT_IN3_MASK)
87  #else
88  #define NRF_GPIOTE_INT_IN_MASK (NRF_GPIOTE_INT_IN0_MASK | NRF_GPIOTE_INT_IN1_MASK |\
89                                  NRF_GPIOTE_INT_IN2_MASK | NRF_GPIOTE_INT_IN3_MASK |\
90                                  NRF_GPIOTE_INT_IN4_MASK | NRF_GPIOTE_INT_IN5_MASK |\
91                                  NRF_GPIOTE_INT_IN6_MASK | NRF_GPIOTE_INT_IN7_MASK)
92  #endif
93  NRF_STATIC_INLINE void nrf_gpiote_task_trigger(NRF_GPIOTE_Type * p_reg, nrf_gpiote_task_t task);
94  NRF_STATIC_INLINE uint32_t nrf_gpiote_task_address_get(NRF_GPIOTE_Type const * p_reg,
95                                                         nrf_gpiote_task_t       task);
96  NRF_STATIC_INLINE bool nrf_gpiote_event_check(NRF_GPIOTE_Type const * p_reg,
97                                                nrf_gpiote_event_t      event);
98  NRF_STATIC_INLINE void nrf_gpiote_event_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_event_t event);
99  NRF_STATIC_INLINE uint32_t nrf_gpiote_event_address_get(NRF_GPIOTE_Type const * p_reg,
100                                                          nrf_gpiote_event_t      event);
101  NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask);
102  NRF_STATIC_INLINE void nrf_gpiote_int_disable(NRF_GPIOTE_Type * p_reg, uint32_t mask);
103  NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg,
104                                                         uint32_t                mask);
105  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
106  NRF_STATIC_INLINE void nrf_gpiote_subscribe_set(NRF_GPIOTE_Type * p_reg,
107                                                  nrf_gpiote_task_t task,
108                                                  uint8_t           channel);
109  NRF_STATIC_INLINE void nrf_gpiote_subscribe_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_task_t task);
110  NRF_STATIC_INLINE void nrf_gpiote_publish_set(NRF_GPIOTE_Type *  p_reg,
111                                                nrf_gpiote_event_t event,
<span onclick='openModal()' class='match'>112                                                uint8_t            channel);
113  NRF_STATIC_INLINE void nrf_gpiote_publish_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_event_t event);
114  #endif 
115  NRF_STATIC_INLINE void nrf_gpiote_event_enable(NRF_GPIOTE_Type * p_reg, uint32_t idx);
116  NRF_STATIC_INLINE void nrf_gpiote_event_disable(NRF_GPIOTE_Type * p_reg, uint32_t idx);
117  NRF_STATIC_INLINE void nrf_gpiote_event_configure(NRF_GPIOTE_Type *     p_reg,
118                                                    uint32_t              idx,
119                                                    uint32_t              pin,
120                                                    nrf_gpiote_polarity_t polarity);
121  NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx);
122  NRF_STATIC_INLINE nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(NRF_GPIOTE_Type const * p_reg,
123                                                                        uint32_t                idx);
124  NRF_STATIC_INLINE void nrf_gpiote_task_enable(NRF_GPIOTE_Type * p_reg, uint32_t idx);
125  NRF_STATIC_INLINE void nrf_gpiote_task_disable(NRF_GPIOTE_Type * p_reg, uint32_t idx);
126  NRF_STATIC_INLINE void nrf_gpiote_task_configure(NRF_GPIOTE_Type *     p_reg,
127                                                   uint32_t              idx,
</span>128                                                   uint32_t              pin,
129                                                   nrf_gpiote_polarity_t polarity,
130                                                   nrf_gpiote_outinit_t  init_val);
131  NRF_STATIC_INLINE void nrf_gpiote_task_force(NRF_GPIOTE_Type *    p_reg,
132                                               uint32_t             idx,
133                                               nrf_gpiote_outinit_t init_val);
134  NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx);
135  NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx);
136  NRF_STATIC_INLINE nrf_gpiote_task_t nrf_gpiote_out_task_get(uint8_t index);
137  #if defined(GPIOTE_FEATURE_SET_PRESENT) || defined(__NRFX_DOXYGEN__)
138  NRF_STATIC_INLINE nrf_gpiote_task_t nrf_gpiote_set_task_get(uint8_t index);
139  #endif
140  #if defined(GPIOTE_FEATURE_CLR_PRESENT) || defined(__NRFX_DOXYGEN__)
141  NRF_STATIC_INLINE nrf_gpiote_task_t nrf_gpiote_clr_task_get(uint8_t index);
142  #endif
143  NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index);
144  #ifndef NRF_DECLARE_ONLY
145  NRF_STATIC_INLINE void nrf_gpiote_task_trigger(NRF_GPIOTE_Type * p_reg, nrf_gpiote_task_t task)
146  {
147      *(volatile uint32_t *)((uint32_t)p_reg + task) = 0x1UL;
148  }
149  NRF_STATIC_INLINE uint32_t nrf_gpiote_task_address_get(NRF_GPIOTE_Type const * p_reg,
150                                                         nrf_gpiote_task_t       task)
151  {
152      return ((uint32_t)p_reg + task);
153  }
154  NRF_STATIC_INLINE bool nrf_gpiote_event_check(NRF_GPIOTE_Type const * p_reg,
155                                                nrf_gpiote_event_t      event)
156  {
157      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
158  }
159  NRF_STATIC_INLINE void nrf_gpiote_event_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_event_t event)
160  {
161      *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
162  #if __CORTEX_M == 0x04
163      volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
164      (void)dummy;
165  #endif
166  }
167  NRF_STATIC_INLINE uint32_t nrf_gpiote_event_address_get(NRF_GPIOTE_Type const * p_reg,
168                                                          nrf_gpiote_event_t      event)
169  {
170      return ((uint32_t)p_reg + event);
171  }
172  NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
173  {
174      p_reg->INTENSET = mask;
175  }
176  NRF_STATIC_INLINE void nrf_gpiote_int_disable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
177  {
178      p_reg->INTENCLR = mask;
179  }
180  NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
181  {
182      return p_reg->INTENSET & mask;
183  }
184  #if defined(DPPI_PRESENT)
185  NRF_STATIC_INLINE void nrf_gpiote_subscribe_set(NRF_GPIOTE_Type * p_reg,
186                                                  nrf_gpiote_task_t task,
187                                                  uint8_t           channel)
188  {
189      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
190              ((uint32_t)channel | GPIOTE_SUBSCRIBE_OUT_EN_Msk);
191  }
192  NRF_STATIC_INLINE void nrf_gpiote_subscribe_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_task_t task)
193  {
194      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
195  }
196  NRF_STATIC_INLINE void nrf_gpiote_publish_set(NRF_GPIOTE_Type *  p_reg,
197                                                nrf_gpiote_event_t event,
198                                                uint8_t            channel)
199  {
200      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
201              ((uint32_t)channel | GPIOTE_PUBLISH_IN_EN_Msk);
202  }
203  NRF_STATIC_INLINE void nrf_gpiote_publish_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_event_t event)
204  {
205      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
206  }
207  #endif 
208  NRF_STATIC_INLINE void nrf_gpiote_event_enable(NRF_GPIOTE_Type * p_reg, uint32_t idx)
209  {
210     p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
211  }
212  NRF_STATIC_INLINE void nrf_gpiote_event_disable(NRF_GPIOTE_Type * p_reg, uint32_t idx)
213  {
214     p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
215  }
216  NRF_STATIC_INLINE void nrf_gpiote_event_configure(NRF_GPIOTE_Type *     p_reg,
217                                                    uint32_t              idx,
218                                                    uint32_t              pin,
219                                                    nrf_gpiote_polarity_t polarity)
220  {
221    p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
222    p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
223                          ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
224  }
225  NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
226  {
227      return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
228  }
229  NRF_STATIC_INLINE nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(NRF_GPIOTE_Type const * p_reg,
230                                                                        uint32_t                idx)
231  {
232      return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
233                                     GPIOTE_CONFIG_POLARITY_Pos);
234  }
235  NRF_STATIC_INLINE void nrf_gpiote_task_enable(NRF_GPIOTE_Type * p_reg, uint32_t idx)
236  {
237      uint32_t final_config = p_reg->CONFIG[idx] | GPIOTE_CONFIG_MODE_Task;
238  #ifdef NRF51
239      p_reg->CONFIG[idx] = final_config |
240                           (((31) << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk);
241      __NOP();
242      __NOP();
243      __NOP();
244  #endif
245      p_reg->CONFIG[idx] = final_config;
246  }
247  NRF_STATIC_INLINE void nrf_gpiote_task_disable(NRF_GPIOTE_Type * p_reg, uint32_t idx)
248  {
249      p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Task;
250  }
251  NRF_STATIC_INLINE void nrf_gpiote_task_configure(NRF_GPIOTE_Type *     p_reg,
252                                                   uint32_t              idx,
253                                                   uint32_t              pin,
254                                                   nrf_gpiote_polarity_t polarity,
255                                                   nrf_gpiote_outinit_t  init_val)
256  {
257    p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
258                            GPIOTE_CONFIG_POLARITY_Msk |
259                            GPIOTE_CONFIG_OUTINIT_Msk);
260    p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
261                          ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
262                          ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
263  }
264  NRF_STATIC_INLINE void nrf_gpiote_task_force(NRF_GPIOTE_Type *    p_reg,
265                                               uint32_t             idx,
266                                               nrf_gpiote_outinit_t init_val)
267  {
268      p_reg->CONFIG[idx] = (p_reg->CONFIG[idx] & ~GPIOTE_CONFIG_OUTINIT_Msk) |
269                           ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
270  }
271  NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
272  {
273      p_reg->CONFIG[idx] = 0;
274  }
275  NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
276  {
277      return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
278  }
279  NRF_STATIC_INLINE nrf_gpiote_task_t nrf_gpiote_out_task_get(uint8_t index)
280  {
281      NRFX_ASSERT(index < GPIOTE_CH_NUM);
282      return (nrf_gpiote_task_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, TASKS_OUT[index]);
283  }
284  #if defined(GPIOTE_FEATURE_SET_PRESENT)
285  NRF_STATIC_INLINE nrf_gpiote_task_t nrf_gpiote_set_task_get(uint8_t index)
286  {
287      NRFX_ASSERT(index < GPIOTE_CH_NUM);
288      return (nrf_gpiote_task_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, TASKS_SET[index]);
289  }
290  #endif
291  #if defined(GPIOTE_FEATURE_CLR_PRESENT)
292  NRF_STATIC_INLINE nrf_gpiote_task_t nrf_gpiote_clr_task_get(uint8_t index)
293  {
294      NRFX_ASSERT(index < GPIOTE_CH_NUM);
295      return (nrf_gpiote_task_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, TASKS_CLR[index]);
296  }
297  #endif
298  NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
299  {
300      NRFX_ASSERT(index < GPIOTE_CH_NUM);
301      return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
302  }
303  #endif 
304  #ifdef __cplusplus
305  }
306  #endif
307  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dos.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_gpiote.h</div>
                </div>
                <div class="column column_space"><pre><code>45    static void init_32bit (void);
46    static int  pktq_init     (struct rx_ringbuf *q, int size, int num, char *pool);
47    static int  pktq_check    (struct rx_ringbuf *q);
48    static int  pktq_inc_out  (struct rx_ringbuf *q);
49    static int  pktq_in_index (struct rx_ringbuf *q) LOCKED_FUNC;
50    static void pktq_clear    (struct rx_ringbuf *q) LOCKED_FUNC;
51    static struct rx_elem *pktq_in_elem  (struct rx_ringbuf *q) LOCKED_FUNC;
52    static struct rx_elem *pktq_out_elem (struct rx_ringbuf *q);
53  #else
54    #define FLUSHK()      ((void)0)
55    #define NDIS_NEXT_DEV  NULL
56  #endif
57  extern WORD  _pktdevclass;
58  extern BOOL  _eth_is_init;
59  extern int   _w32_dynamic_host;
60  extern int   _watt_do_exit;
61  extern int   _watt_is_init;
62  extern int   _w32__bootp_on, _w32__dhcp_on, _w32__rarp_on, _w32__do_mask_req;
63  extern void (*_w32_usr_post_init) (void);
64  extern void (*_w32_print_hook)();
65  extern void dbug_write (const char *);  &bsol;* Watt-32 lib, pcdbug.c */
66  extern int  pkt_get_mtu (void);
67  static int ref_count = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>112                                                uint8_t            channel);
113  NRF_STATIC_INLINE void nrf_gpiote_publish_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_event_t event);
114  #endif 
115  NRF_STATIC_INLINE void nrf_gpiote_event_enable(NRF_GPIOTE_Type * p_reg, uint32_t idx);
116  NRF_STATIC_INLINE void nrf_gpiote_event_disable(NRF_GPIOTE_Type * p_reg, uint32_t idx);
117  NRF_STATIC_INLINE void nrf_gpiote_event_configure(NRF_GPIOTE_Type *     p_reg,
118                                                    uint32_t              idx,
119                                                    uint32_t              pin,
120                                                    nrf_gpiote_polarity_t polarity);
121  NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx);
122  NRF_STATIC_INLINE nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(NRF_GPIOTE_Type const * p_reg,
123                                                                        uint32_t                idx);
124  NRF_STATIC_INLINE void nrf_gpiote_task_enable(NRF_GPIOTE_Type * p_reg, uint32_t idx);
125  NRF_STATIC_INLINE void nrf_gpiote_task_disable(NRF_GPIOTE_Type * p_reg, uint32_t idx);
126  NRF_STATIC_INLINE void nrf_gpiote_task_configure(NRF_GPIOTE_Type *     p_reg,
127                                                   uint32_t              idx,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    