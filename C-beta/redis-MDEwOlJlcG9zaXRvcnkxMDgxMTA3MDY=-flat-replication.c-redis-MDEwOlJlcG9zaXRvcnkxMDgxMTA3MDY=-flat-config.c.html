
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.95906432748538%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-replication.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/Win32_FDAPI.h"
4  #include "Win32_Interop/Win32_ThreadControl.h"
5  #include "Win32_Interop/Win32_QFork.h"
6  #include "Win32_Interop/win32_types.h"
7  #include "Win32_Interop/Win32_Time.h"
8  #include "Win32_Interop/Win32_Error.h"
9  #endif
10  #include "server.h"
11  #include "cluster.h"
12  POSIX_ONLY(#include <sys/time.h>)
13  POSIX_ONLY(#include <unistd.h>)
14  #include <fcntl.h>
15  POSIX_ONLY(#include <sys/socket.h>)
16  #include <sys/stat.h>
17  void replicationDiscardCachedMaster(void);
18  void replicationResurrectCachedMaster(int newfd);
19  void replicationSendAck(void);
20  void putSlaveOnline(client *slave);
21  int cancelReplicationHandshake(void);
22  char *replicationGetSlaveName(client *c) {
23      static char buf[NET_PEER_ID_LEN];
24      char ip[NET_IP_STR_LEN];
25      ip[0] = '\0';
26      buf[0] = '\0';
27      if (c->slave_ip[0] != '\0' ||
28          anetPeerToString(c->fd,ip,sizeof(ip),NULL) != -1)
29      {
30          if (c->slave_ip[0] != '\0') memcpy(ip,c->slave_ip,sizeof(c->slave_ip));
31          if (c->slave_listening_port)
32              anetFormatAddr(buf,sizeof(buf),ip,c->slave_listening_port);
33          else
34              snprintf(buf,sizeof(buf),"%s:<unknown-replica-port>",ip);
35      } else {
36          snprintf(buf,sizeof(buf),"client id #%llu",
37              (PORT_ULONGLONG) c->id);
38      }
39      return buf;
40  }
41  void createReplicationBacklog(void) {
42      serverAssert(server.repl_backlog == NULL);
43      server.repl_backlog = zmalloc(server.repl_backlog_size);
44      server.repl_backlog_histlen = 0;
45      server.repl_backlog_idx = 0;
46      server.repl_backlog_off = server.master_repl_offset+1;
47  }
48  void resizeReplicationBacklog(PORT_LONGLONG newsize) {
49      if (newsize < CONFIG_REPL_BACKLOG_MIN_SIZE)
50          newsize = CONFIG_REPL_BACKLOG_MIN_SIZE;
51      if (server.repl_backlog_size == newsize) return;
52      server.repl_backlog_size = newsize;
53      if (server.repl_backlog != NULL) {
54          zfree(server.repl_backlog);
55          server.repl_backlog = zmalloc(server.repl_backlog_size);
56          server.repl_backlog_histlen = 0;
57          server.repl_backlog_idx = 0;
58          server.repl_backlog_off = server.master_repl_offset+1;
59      }
60  }
61  void freeReplicationBacklog(void) {
62      serverAssert(listLength(server.slaves) == 0);
63      zfree(server.repl_backlog);
64      server.repl_backlog = NULL;
65  }
66  void feedReplicationBacklog(void *ptr, size_t len) {
67      unsigned char *p = ptr;
68      server.master_repl_offset += len;
69      while(len) {
70          size_t thislen = server.repl_backlog_size - server.repl_backlog_idx;
71          if (thislen > len) thislen = len;
72          memcpy(server.repl_backlog+server.repl_backlog_idx,p,thislen);
73          server.repl_backlog_idx += thislen;
74          if (server.repl_backlog_idx == server.repl_backlog_size)
75              server.repl_backlog_idx = 0;
76          len -= thislen;
77          p += thislen;
78          server.repl_backlog_histlen += thislen;
79      }
80      if (server.repl_backlog_histlen > server.repl_backlog_size)
81          server.repl_backlog_histlen = server.repl_backlog_size;
82      server.repl_backlog_off = server.master_repl_offset -
83                                server.repl_backlog_histlen + 1;
84  }
85  void feedReplicationBacklogWithObject(robj *o) {
86      char llstr[LONG_STR_SIZE];
87      void *p;
88      size_t len;
89      if (o->encoding == OBJ_ENCODING_INT) {
90          len = ll2string(llstr,sizeof(llstr),(PORT_LONG)o->ptr);
91          p = llstr;
92      } else {
93          len = sdslen(o->ptr);
94          p = o->ptr;
95      }
96      feedReplicationBacklog(p,len);
97  }
98  void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
99      listNode *ln;
100      listIter li;
101      int j, len;
102      char llstr[LONG_STR_SIZE];
103      if (server.masterhost != NULL) return;
104      if (server.repl_backlog == NULL && listLength(slaves) == 0) return;
105      serverAssert(!(listLength(slaves) != 0 && server.repl_backlog == NULL));
106      if (server.slaveseldb != dictid) {
107          robj *selectcmd;
108          if (dictid >= 0 && dictid < PROTO_SHARED_SELECT_CMDS) {
109              selectcmd = shared.select[dictid];
110          } else {
111              int dictid_len;
112              dictid_len = ll2string(llstr,sizeof(llstr),dictid);
113              selectcmd = createObject(OBJ_STRING,
114                  sdscatprintf(sdsempty(),
115                  "*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n",
116                  dictid_len, llstr));
117          }
118          if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);
119          listRewind(slaves,&li);
120          while((ln = listNext(&li))) {
121              client *slave = ln->value;
122              if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
123              addReply(slave,selectcmd);
124          }
125          if (dictid < 0 || dictid >= PROTO_SHARED_SELECT_CMDS)
126              decrRefCount(selectcmd);
127      }
128      server.slaveseldb = dictid;
129      if (server.repl_backlog) {
130          char aux[LONG_STR_SIZE+3];
131          aux[0] = '*';
132          len = ll2string(aux+1,sizeof(aux)-1,argc);
133          aux[len+1] = '\r';
134          aux[len+2] = '\n';
135          feedReplicationBacklog(aux,(size_t)len+3);  WIN_PORT_FIX &bsol;* cast (size_t) */
136          for (j = 0; j < argc; j++) {
137              PORT_LONG objlen = (PORT_LONG) stringObjectLen(argv[j]);            WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
138              aux[0] = '$';
139              len = ll2string(aux+1,sizeof(aux)-1,objlen);
140              aux[len+1] = '\r';
141              aux[len+2] = '\n';
142              feedReplicationBacklog(aux,(size_t)len+3);  WIN_PORT_FIX &bsol;* cast (size_t) */
143              feedReplicationBacklogWithObject(argv[j]);
144              feedReplicationBacklog(aux+len+1,2);
145          }
146      }
147      listRewind(slaves,&li);
148      while((ln = listNext(&li))) {
149          client *slave = ln->value;
150          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
151          addReplyMultiBulkLen(slave,argc);
152          for (j = 0; j < argc; j++)
153              addReplyBulk(slave,argv[j]);
154      }
155  }
156  #include <ctype.h>
157  void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen) {
158      listNode *ln;
159      listIter li;
160      if (0) {
161          printf("%Iu:",buflen);                                        WIN_PORT_FIX &bsol;* %zu -> %Iu */
162          for (size_t j = 0; j < buflen; j++) {
163              printf("%c", isprint(buf[j]) ? buf[j] : '.');
164          }
165          printf("\n");
166      }
167      if (server.repl_backlog) feedReplicationBacklog(buf,buflen);
168      listRewind(slaves,&li);
169      while((ln = listNext(&li))) {
170          client *slave = ln->value;
171          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
172          addReplyString(slave,buf,buflen);
173      }
174  }
175  void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
176      listNode *ln;
177      listIter li;
178      int j;
179      sds cmdrepr = sdsnew("+");
180      robj *cmdobj;
181      struct timeval tv;
182      gettimeofday(&tv,NULL);
183      cmdrepr = sdscatprintf(cmdrepr,"%Id.%06Id ",(PORT_LONG)tv.tv_sec,(PORT_LONG)tv.tv_usec);           WIN_PORT_FIX &bsol;* %ld -> %Id */
184      if (c->flags & CLIENT_LUA) {
185          cmdrepr = sdscatprintf(cmdrepr,"[%d lua] ",dictid);
186      } else if (c->flags & CLIENT_UNIX_SOCKET) {
187          cmdrepr = sdscatprintf(cmdrepr,"[%d unix:%s] ",dictid,server.unixsocket);
188      } else {
189          cmdrepr = sdscatprintf(cmdrepr,"[%d %s] ",dictid,getClientPeerId(c));
190      }
191      for (j = 0; j < argc; j++) {
192          if (argv[j]->encoding == OBJ_ENCODING_INT) {
193              cmdrepr = sdscatprintf(cmdrepr, "\"%Id\"", (PORT_LONG) argv[j]->ptr);   WIN_PORT_FIX &bsol;* %ld -> %Id */
194          } else {
195              cmdrepr = sdscatrepr(cmdrepr,(char*)argv[j]->ptr,
196                          sdslen(argv[j]->ptr));
197          }
198          if (j != argc-1)
199              cmdrepr = sdscatlen(cmdrepr," ",1);
200      }
201      cmdrepr = sdscatlen(cmdrepr,"\r\n",2);
202      cmdobj = createObject(OBJ_STRING,cmdrepr);
203      listRewind(monitors,&li);
204      while((ln = listNext(&li))) {
205          client *monitor = ln->value;
206          addReply(monitor,cmdobj);
207      }
208      decrRefCount(cmdobj);
209  }
210  PORT_LONGLONG addReplyReplicationBacklog(client *c, PORT_LONGLONG offset) {
211      PORT_LONGLONG j, skip, len;
212      serverLog(LL_DEBUG, "[PSYNC] Replica request offset: %lld", offset);
213      if (server.repl_backlog_histlen == 0) {
214          serverLog(LL_DEBUG, "[PSYNC] Backlog history len is zero");
215          return 0;
216      }
217      serverLog(LL_DEBUG, "[PSYNC] Backlog size: %lld",
218               server.repl_backlog_size);
219      serverLog(LL_DEBUG, "[PSYNC] First byte: %lld",
220               server.repl_backlog_off);
221      serverLog(LL_DEBUG, "[PSYNC] History len: %lld",
222               server.repl_backlog_histlen);
223      serverLog(LL_DEBUG, "[PSYNC] Current index: %lld",
224               server.repl_backlog_idx);
225      skip = offset - server.repl_backlog_off;
226      serverLog(LL_DEBUG, "[PSYNC] Skipping: %lld", skip);
227      j = (server.repl_backlog_idx +
228          (server.repl_backlog_size-server.repl_backlog_histlen)) %
229          server.repl_backlog_size;
230      serverLog(LL_DEBUG, "[PSYNC] Index of first byte: %lld", j);
231      j = (j + skip) % server.repl_backlog_size;
232      len = server.repl_backlog_histlen - skip;
233      serverLog(LL_DEBUG, "[PSYNC] Reply total length: %lld", len);
234      while(len) {
235          PORT_LONGLONG thislen =
236              ((server.repl_backlog_size - j) < len) ?
237              (server.repl_backlog_size - j) : len;
238          serverLog(LL_DEBUG, "[PSYNC] addReply() length: %lld", thislen);
239          addReplySds(c,sdsnewlen(server.repl_backlog + j, thislen));
240          len -= thislen;
241          j = 0;
242      }
243      return server.repl_backlog_histlen - skip;
244  }
245  PORT_LONGLONG getPsyncInitialOffset(void) {
246      return server.master_repl_offset;
247  }
248  int replicationSetupSlaveForFullResync(client *slave, PORT_LONGLONG offset) {
249      char buf[128];
250      int buflen;
251      slave->psync_initial_offset = offset;
252      slave->replstate = SLAVE_STATE_WAIT_BGSAVE_END;
253      server.slaveseldb = -1;
254      if (!(slave->flags & CLIENT_PRE_PSYNC)) {
255          buflen = snprintf(buf,sizeof(buf),"+FULLRESYNC %s %lld\r\n",
256                            server.replid,offset);
257          if (write(slave->fd,buf,buflen) != buflen) {
258              freeClientAsync(slave);
259              return C_ERR;
260          }
261      }
262      return C_OK;
263  }
264  int masterTryPartialResynchronization(client *c) {
265      PORT_LONGLONG psync_offset, psync_len;
266      char *master_replid = c->argv[1]->ptr;
267      char buf[128];
268      int buflen;
269      if (getLongLongFromObjectOrReply(c,c->argv[2],&psync_offset,NULL) !=
270         C_OK) goto need_full_resync;
271      if (strcasecmp(master_replid, server.replid) &&
272          (strcasecmp(master_replid, server.replid2) ||
273           psync_offset > server.second_replid_offset))
274      {
275          if (master_replid[0] != '?') {
276              if (strcasecmp(master_replid, server.replid) &&
277                  strcasecmp(master_replid, server.replid2))
278              {
279                  serverLog(LL_NOTICE,"Partial resynchronization not accepted: "
280                      "Replication ID mismatch (Replica asked for '%s', my "
281                      "replication IDs are '%s' and '%s')",
282                      master_replid, server.replid, server.replid2);
283              } else {
284                  serverLog(LL_NOTICE,"Partial resynchronization not accepted: "
285                      "Requested offset for second ID was %lld, but I can reply "
286                      "up to %lld", psync_offset, server.second_replid_offset);
287              }
288          } else {
289              serverLog(LL_NOTICE,"Full resync requested by replica %s",
290                  replicationGetSlaveName(c));
291          }
292          goto need_full_resync;
293      }
294      if (!server.repl_backlog ||
295          psync_offset < server.repl_backlog_off ||
296          psync_offset > (server.repl_backlog_off + server.repl_backlog_histlen))
297      {
298          serverLog(LL_NOTICE,
299              "Unable to partial resync with replica %s for lack of backlog (Replica request was: %lld).", replicationGetSlaveName(c), psync_offset);
300          if (psync_offset > server.master_repl_offset) {
301              serverLog(LL_WARNING,
302                  "Warning: replica %s tried to PSYNC with an offset that is greater than the master replication offset.", replicationGetSlaveName(c));
303          }
304          goto need_full_resync;
305      }
306      c->flags |= CLIENT_SLAVE;
307      c->replstate = SLAVE_STATE_ONLINE;
308      c->repl_ack_time = server.unixtime;
309      c->repl_put_online_on_ack = 0;
310      listAddNodeTail(server.slaves,c);
311      if (c->slave_capa & SLAVE_CAPA_PSYNC2) {
312          buflen = snprintf(buf,sizeof(buf),"+CONTINUE %s\r\n", server.replid);
313      } else {
314          buflen = snprintf(buf,sizeof(buf),"+CONTINUE\r\n");
315      }
316      if (write(c->fd,buf,buflen) != buflen) {
317          freeClientAsync(c);
318          return C_OK;
319      }
320      psync_len = addReplyReplicationBacklog(c,psync_offset);
321      serverLog(LL_NOTICE,
322          "Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.",
323              replicationGetSlaveName(c),
324              psync_len, psync_offset);
325      refreshGoodSlavesCount();
326      return C_OK; &bsol;* The caller can return, no full resync needed. */
327  need_full_resync:
328      return C_ERR;
329  }
330  int startBgsaveForReplication(int mincapa) {
331      int retval;
332      int socket_target = server.repl_diskless_sync && (mincapa & SLAVE_CAPA_EOF);
333      listIter li;
334      listNode *ln;
335      serverLog(LL_NOTICE,"Starting BGSAVE for SYNC with target: %s",
336          socket_target ? "replicas sockets" : "disk");
337      rdbSaveInfo rsi, *rsiptr;
338      rsiptr = rdbPopulateSaveInfo(&rsi);
339      if (rsiptr) {
340          if (socket_target)
341              retval = rdbSaveToSlavesSockets(rsiptr);
342          else
343              retval = rdbSaveBackground(server.rdb_filename,rsiptr);
344      } else {
345          serverLog(LL_WARNING,"BGSAVE for replication: replication information not available, can't generate the RDB file right now. Try later.");
346          retval = C_ERR;
347      }
348      if (retval == C_ERR) {
349          serverLog(LL_WARNING,"BGSAVE for replication failed");
350          listRewind(server.slaves,&li);
351          while((ln = listNext(&li))) {
352              client *slave = ln->value;
353              if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
354                  slave->replstate = REPL_STATE_NONE;
355                  slave->flags &= ~CLIENT_SLAVE;
356                  listDelNode(server.slaves,ln);
357                  addReplyError(slave,
358                      "BGSAVE failed, replication can't continue");
359                  slave->flags |= CLIENT_CLOSE_AFTER_REPLY;
360              }
361          }
362          return retval;
363      }
364      if (!socket_target) {
365          listRewind(server.slaves,&li);
366          while((ln = listNext(&li))) {
367              client *slave = ln->value;
368              if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
369                      replicationSetupSlaveForFullResync(slave,
370                              getPsyncInitialOffset());
371              }
372          }
373      }
374      if (retval == C_OK) replicationScriptCacheFlush();
375      return retval;
376  }
377  void syncCommand(client *c) {
378      if (c->flags & CLIENT_SLAVE) return;
379      if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED) {
380          addReplySds(c,sdsnew("-NOMASTERLINK Can't SYNC while not connected with my master\r\n"));
381          return;
382      }
383      if (clientHasPendingReplies(c)) {
384          addReplyError(c,"SYNC and PSYNC are invalid with pending output");
385          return;
386      }
387      serverLog(LL_NOTICE,"Replica %s asks for synchronization",
388          replicationGetSlaveName(c));
389      if (!strcasecmp(c->argv[0]->ptr,"psync")) {
390          if (masterTryPartialResynchronization(c) == C_OK) {
391              server.stat_sync_partial_ok++;
392              return; &bsol;* No full resync needed, return. */
393          } else {
394              char *master_replid = c->argv[1]->ptr;
395              if (master_replid[0] != '?') server.stat_sync_partial_err++;
396          }
397      } else {
398          c->flags |= CLIENT_PRE_PSYNC;
399      }
400      server.stat_sync_full++;
401      c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
402      if (server.repl_disable_tcp_nodelay)
403          anetDisableTcpNoDelay(NULL, c->fd); &bsol;* Non critical if it fails. */
404      c->repldbfd = -1;
405      c->flags |= CLIENT_SLAVE;
406      listAddNodeTail(server.slaves,c);
407      if (listLength(server.slaves) == 1 && server.repl_backlog == NULL) {
408          changeReplicationId();
409          clearReplicationId2();
410          createReplicationBacklog();
411      }
412      if (server.rdb_child_pid != -1 &&
413          server.rdb_child_type == RDB_CHILD_TYPE_DISK)
414      {
415          client *slave;
416          listNode *ln;
417          listIter li;
418          listRewind(server.slaves,&li);
419          while((ln = listNext(&li))) {
420              slave = ln->value;
421              if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) break;
422          }
423          if (ln && ((c->slave_capa & slave->slave_capa) == slave->slave_capa)) {
424              copyClientOutputBuffer(c,slave);
425              replicationSetupSlaveForFullResync(c,slave->psync_initial_offset);
426              serverLog(LL_NOTICE,"Waiting for end of BGSAVE for SYNC");
427          } else {
428              serverLog(LL_NOTICE,"Can't attach the replica to the current BGSAVE. Waiting for next BGSAVE for SYNC");
429          }
430      } else if (server.rdb_child_pid != -1 &&
431                 server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)
432      {
433          serverLog(LL_NOTICE,"Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC");
434      } else {
435          if (server.repl_diskless_sync && (c->slave_capa & SLAVE_CAPA_EOF)) {
436              if (server.repl_diskless_sync_delay)
437                  serverLog(LL_NOTICE,"Delay next BGSAVE for diskless SYNC");
438          } else {
439              if (server.aof_child_pid == -1) {
440                  startBgsaveForReplication(c->slave_capa);
441              } else {
442                  serverLog(LL_NOTICE,
443                      "No BGSAVE in progress, but an AOF rewrite is active. "
444                      "BGSAVE for replication delayed");
445              }
446          }
447      }
448      return;
449  }
450  void replconfCommand(client *c) {
451      int j;
452      if ((c->argc % 2) == 0) {
453          addReply(c,shared.syntaxerr);
454          return;
455      }
456      for (j = 1; j < c->argc; j+=2) {
457          if (!strcasecmp(c->argv[j]->ptr,"listening-port")) {
458              PORT_LONG port;
459              if ((getLongFromObjectOrReply(c,c->argv[j+1],
460                      &port,NULL) != C_OK))
461                  return;
462              c->slave_listening_port = (int) port;                               WIN_PORT_FIX &bsol;* cast (int) */
463          } else if (!strcasecmp(c->argv[j]->ptr,"ip-address")) {
464              sds ip = c->argv[j+1]->ptr;
465              if (sdslen(ip) < sizeof(c->slave_ip)) {
466                  memcpy(c->slave_ip,ip,sdslen(ip)+1);
467              } else {
468                  addReplyErrorFormat(c,"REPLCONF ip-address provided by "
469                      "replica instance is too long: %zd bytes", sdslen(ip));
470                  return;
471              }
472          } else if (!strcasecmp(c->argv[j]->ptr,"capa")) {
473              if (!strcasecmp(c->argv[j+1]->ptr,"eof"))
474                  c->slave_capa |= SLAVE_CAPA_EOF;
475              else if (!strcasecmp(c->argv[j+1]->ptr,"psync2"))
476                  c->slave_capa |= SLAVE_CAPA_PSYNC2;
477          } else if (!strcasecmp(c->argv[j]->ptr,"ack")) {
478              PORT_LONGLONG offset;
479              if (!(c->flags & CLIENT_SLAVE)) return;
480              if ((getLongLongFromObject(c->argv[j+1], &offset) != C_OK))
481                  return;
482              if (offset > c->repl_ack_off)
483                  c->repl_ack_off = offset;
484              c->repl_ack_time = server.unixtime;
485              if (c->repl_put_online_on_ack && c->replstate == SLAVE_STATE_ONLINE)
486                  putSlaveOnline(c);
487              return;
488          } else if (!strcasecmp(c->argv[j]->ptr,"getack")) {
489              if (server.masterhost && server.master) replicationSendAck();
490              return;
491          } else {
492              addReplyErrorFormat(c,"Unrecognized REPLCONF option: %s",
493                  (char*)c->argv[j]->ptr);
494              return;
495          }
496      }
497      addReply(c,shared.ok);
498  }
499  void putSlaveOnline(client *slave) {
500      slave->replstate = SLAVE_STATE_ONLINE;
501      slave->repl_put_online_on_ack = 0;
502      slave->repl_ack_time = server.unixtime; &bsol;* Prevent false timeout. */
503      if (aeCreateFileEvent(server.el, slave->fd, AE_WRITABLE,
504          sendReplyToClient, slave) == AE_ERR) {
505          serverLog(LL_WARNING,"Unable to register writable event for replica bulk transfer: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
506          freeClient(slave);
507          return;
508      }
509      refreshGoodSlavesCount();
510      serverLog(LL_NOTICE,"Synchronization with replica %s succeeded",
511          replicationGetSlaveName(slave));
512  }
513  #ifdef _WIN32
514  void sendBulkToSlaveLenDone(aeEventLoop *el, int fd, void *privdata, int written) {
515      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
516      UNUSED(el);
517      UNUSED(fd);
518      sdsfree((sds) req->buf);
519  }
520  void sendBulkToSlaveDataDone(aeEventLoop *el, int fd, void *privdata, int nwritten) {
521      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
522      client *slave = (client *) req->client;
523      UNUSED(el);
524      UNUSED(fd);
525      zfree(req->data);
526      slave->repldboff += nwritten;
527      if (slave->repldboff == slave->repldbsize) {
528          close(slave->repldbfd);
529          DeleteFileA(slave->replFileCopy);
530          memset(slave->replFileCopy, 0, MAX_PATH);
531          slave->repldbfd = -1;
532          aeDeleteFileEvent(server.el, slave->fd, AE_WRITABLE);
533          putSlaveOnline(slave);
534      }
535  }
536  void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
537      client *slave = privdata;
538      UNUSED(el);
539      UNUSED(mask);
540      char *buf;
541      ssize_t result, buflen;
542      if (slave->repldboff == 0) {
543          sds bulkcount;
544          bulkcount = sdscatprintf(sdsempty(),"$%lld\r\n",(PORT_ULONGLONG)
545              slave->repldbsize);
546          result = WSIOCP_SocketSend(fd, bulkcount, (int) sdslen(bulkcount), el,
547                                     slave, bulkcount, sendBulkToSlaveLenDone);
548          if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
549              sdsfree(bulkcount);
550              freeClient(slave);
551              return;
552          }
553      }
554      lseek64(slave->repldbfd,slave->repldboff,SEEK_SET);
555      buf = (char *)zmalloc(PROTO_IOBUF_LEN);
556      buflen = read(slave->repldbfd,buf,PROTO_IOBUF_LEN);
557      if (buflen <= 0) {
558          serverLog(LL_WARNING,"Read error sending DB to slave: %s",
559              (buflen == 0) ? "premature EOF" : IF_WIN32(wsa_strerror(errno),strerror(errno)));
560          freeClient(slave);
561          return;
562      }
563      result = WSIOCP_SocketSend(fd, buf, (int) buflen, el, slave, buf,
564                                 sendBulkToSlaveDataDone);
565      if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
566          serverLog(LL_VERBOSE,"Write error sending DB to slave: %s",
567              IF_WIN32(wsa_strerror(errno),strerror(errno)));
568          freeClient(slave);
569          return;
570      }
<span onclick='openModal()' class='match'>571  }
572  #else
573  void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
574      client *slave = privdata;
</span>575      UNUSED(el);
576      UNUSED(mask);
577      char buf[PROTO_IOBUF_LEN];
578      ssize_t nwritten, buflen;
579      if (slave->replpreamble) {
580          nwritten = write(fd,slave->replpreamble,sdslen(slave->replpreamble));
581          if (nwritten == -1) {
582              serverLog(LL_VERBOSE,"Write error sending RDB preamble to replica: %s",
583                  strerror(errno));
584              freeClient(slave);
585              return;
586          }
587          server.stat_net_output_bytes += nwritten;
588          sdsrange(slave->replpreamble,nwritten,-1);
589          if (sdslen(slave->replpreamble) == 0) {
590              sdsfree(slave->replpreamble);
591              slave->replpreamble = NULL;
592          } else {
593              return;
594          }
595      }
596      lseek(slave->repldbfd,slave->repldboff,SEEK_SET);
597      buflen = read(slave->repldbfd,buf,PROTO_IOBUF_LEN);
598      if (buflen <= 0) {
599          serverLog(LL_WARNING,"Read error sending DB to replica: %s",
600              (buflen == 0) ? "premature EOF" : strerror(errno));
601          freeClient(slave);
602          return;
603      }
604      if ((nwritten = write(fd,buf,buflen)) == -1) {
605          if (errno != EAGAIN) {
606              serverLog(LL_WARNING,"Write error sending DB to replica: %s",
607                  strerror(errno));
608              freeClient(slave);
609          }
610          return;
611      }
612      slave->repldboff += nwritten;
613      server.stat_net_output_bytes += nwritten;
614      if (slave->repldboff == slave->repldbsize) {
615          close(slave->repldbfd);
616          slave->repldbfd = -1;
617          aeDeleteFileEvent(server.el,slave->fd,AE_WRITABLE);
618          putSlaveOnline(slave);
619      }
620  }
621  #endif
622  void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
623      listNode *ln;
624      int startbgsave = 0;
625      int mincapa = -1;
626      listIter li;
627      listRewind(server.slaves,&li);
628      while((ln = listNext(&li))) {
629          client *slave = ln->value;
630          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
631              startbgsave = 1;
632              mincapa = (mincapa == -1) ? slave->slave_capa :
633                                          (mincapa & slave->slave_capa);
634          } else if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
635              struct redis_stat buf;
636              if (type == RDB_CHILD_TYPE_SOCKET) {
637                  serverLog(LL_NOTICE,
638                      "Streamed RDB transfer with replica %s succeeded (socket). Waiting for REPLCONF ACK from slave to enable streaming",
639                          replicationGetSlaveName(slave));
640                  slave->replstate = SLAVE_STATE_ONLINE;
641                  slave->repl_put_online_on_ack = 1;
642                  slave->repl_ack_time = server.unixtime; &bsol;* Timeout otherwise. */
643              } else {
644                  if (bgsaveerr != C_OK) {
645                      freeClient(slave);
646                      serverLog(LL_WARNING,"SYNC failed. BGSAVE child returned an error");
647                      continue;
648                  }
649  #ifdef _WIN32
650                  sprintf(slave->replFileCopy,"%d_%s",  slave->fd, server.rdb_filename);
651                  if(CopyFileA( server.rdb_filename, slave->replFileCopy, FALSE) == FALSE) {
652                      freeClient(slave);
653                      serverLog(LL_WARNING,"Failed to duplicate RDB file. Failing SYNC: %d", GetLastError());
654                      continue;
655                  }
656                  if ((slave->repldbfd = open(slave->replFileCopy,O_RDONLY|_O_BINARY,0)) == -1 ||
657  #else
658                  if ((slave->repldbfd = open(server.rdb_filename,O_RDONLY)) == -1 ||
659  #endif
660                      redis_fstat(slave->repldbfd,&buf) == -1) {
661                      freeClient(slave);
662                      serverLog(LL_WARNING,"SYNC failed. Can't open/stat DB after BGSAVE: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
663                      continue;
664                  }
665                  slave->repldboff = 0;
666                  slave->repldbsize = buf.st_size;
667                  slave->replstate = SLAVE_STATE_SEND_BULK;
668                  slave->replpreamble = sdscatprintf(sdsempty(),"$%lld\r\n",
669                      (PORT_ULONGLONG) slave->repldbsize);
670                  aeDeleteFileEvent(server.el,slave->fd,AE_WRITABLE);
671                  if (aeCreateFileEvent(server.el, slave->fd, AE_WRITABLE, sendBulkToSlave, slave) == AE_ERR) {
672                      freeClient(slave);
673                      continue;
674                  }
675              }
676          }
677      }
678      if (startbgsave) startBgsaveForReplication(mincapa);
679  }
680  void changeReplicationId(void) {
681      getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
682      server.replid[CONFIG_RUN_ID_SIZE] = '\0';
683  }
684  void clearReplicationId2(void) {
685      memset(server.replid2,'0',sizeof(server.replid));
686      server.replid2[CONFIG_RUN_ID_SIZE] = '\0';
687      server.second_replid_offset = -1;
688  }
689  void shiftReplicationId(void) {
690      memcpy(server.replid2,server.replid,sizeof(server.replid));
691      server.second_replid_offset = server.master_repl_offset+1;
692      changeReplicationId();
693      serverLog(LL_WARNING,"Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s", server.replid2, server.second_replid_offset, server.replid);
694  }
695  int slaveIsInHandshakeState(void) {
696      return server.repl_state >= REPL_STATE_RECEIVE_PONG &&
697             server.repl_state <= REPL_STATE_RECEIVE_PSYNC;
698  }
699  void replicationSendNewlineToMaster(void) {
700      static time_t newline_sent;
701      if (time(NULL) != newline_sent) {
702          newline_sent = time(NULL);
703          if (write(server.repl_transfer_s,"\n",1) == -1) {
704          }
705      }
706  }
707  void replicationEmptyDbCallback(void *privdata) {
708      UNUSED(privdata);
709      replicationSendNewlineToMaster();
710  }
711  void replicationCreateMasterClient(int fd, int dbid) {
712      server.master = createClient(fd);
713      server.master->flags |= CLIENT_MASTER;
714      server.master->authenticated = 1;
715      server.master->reploff = server.master_initial_offset;
716      server.master->read_reploff = server.master->reploff;
717      memcpy(server.master->replid, server.master_replid,
718          sizeof(server.master_replid));
719      if (server.master->reploff == -1)
720          server.master->flags |= CLIENT_PRE_PSYNC;
721      if (dbid != -1) selectDb(server.master,dbid);
722  }
723  void restartAOFAfterSYNC() {
724      unsigned int tries, max_tries = 10;
725      for (tries = 0; tries < max_tries; ++tries) {
726          if (startAppendOnly() == C_OK) break;
727          serverLog(LL_WARNING,
728              "Failed enabling the AOF after successful master synchronization! "
729              "Trying it again in one second.");
730          sleep(1);
731      }
732      if (tries == max_tries) {
733          serverLog(LL_WARNING,
734              "FATAL: this replica instance finished the synchronization with "
735              "its master, but the AOF can't be turned on. Exiting now.");
736          exit(1);
737      }
738  }
739  #define REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) &bsol;* 8 MB */
740  void readSyncBulkPayload(aeEventLoop *el, int fd, void *privdata, int mask) {
741      char buf[4096];
742      ssize_t nread, readlen, nwritten;
743      off_t left;
744      UNUSED(el);
745      UNUSED(privdata);
746      UNUSED(mask);
747      static char eofmark[CONFIG_RUN_ID_SIZE];
748      static char lastbytes[CONFIG_RUN_ID_SIZE];
749      static int usemark = 0;
750      if (server.repl_transfer_size == -1) {
751          if (syncReadLine(fd,buf,1024,(PORT_LONGLONG)server.repl_syncio_timeout*1000) == -1) {  WIN_PORT_FIX &bsol;* cast (PORT_LONGLONG) */
752              serverLog(LL_WARNING,
753                  "I/O error reading bulk count from MASTER: %s",
754                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
755              goto error;
756          }
757          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
758          if (buf[0] == '-') {
759              serverLog(LL_WARNING,
760                  "MASTER aborted replication with an error: %s",
761                  buf+1);
762              goto error;
763          } else if (buf[0] == '\0') {
764              server.repl_transfer_lastio = server.unixtime;
765              return;
766          } else if (buf[0] != '$') {
767              serverLog(LL_WARNING,"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?", buf);
768              goto error;
769          }
770          if (strncmp(buf+1,"EOF:",4) == 0 && strlen(buf+5) >= CONFIG_RUN_ID_SIZE) {
771              usemark = 1;
772              memcpy(eofmark,buf+5,CONFIG_RUN_ID_SIZE);
773              memset(lastbytes,0,CONFIG_RUN_ID_SIZE);
774              server.repl_transfer_size = 0;
775              serverLog(LL_NOTICE,
776                  "MASTER <-> REPLICA sync: receiving streamed RDB from master");
777          } else {
778              usemark = 0;
779              server.repl_transfer_size = strtol(buf+1,NULL,10);
780              serverLog(LL_NOTICE,
781                  "MASTER <-> REPLICA sync: receiving %lld bytes from master",
782                  (PORT_LONGLONG) server.repl_transfer_size);
783          }
784          return;
785      }
786      if (usemark) {
787          readlen = sizeof(buf);
788      } else {
789          left = server.repl_transfer_size - server.repl_transfer_read;
790          readlen = (left < (signed)sizeof(buf)) ? left : (signed)sizeof(buf);
791      }
792      nread = read(fd,buf,readlen);
793      if (nread <= 0) {
794  #ifdef _WIN32
795          if (server.repl_transfer_size) {
796              serverLog(LL_WARNING,"I/O error %d (left %Iu) trying to sync with MASTER: %s",
797                  errno, server.repl_transfer_size,
798                  (nread == -1) ? wsa_strerror(errno) : "connection lost");
799          }
800  #else
801          serverLog(LL_WARNING,"I/O error trying to sync with MASTER: %s",
802              (nread == -1) ? strerror(errno) : "connection lost");
803  #endif
804          cancelReplicationHandshake();
805          return;
806      }
807      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
808      server.stat_net_input_bytes += nread;
809      int eof_reached = 0;
810      if (usemark) {
811          if (nread >= CONFIG_RUN_ID_SIZE) {
812              memcpy(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,CONFIG_RUN_ID_SIZE);
813          } else {
814              int rem = (int)(CONFIG_RUN_ID_SIZE-nread);                           WIN_PORT_FIX &bsol;* cast (int) */
815              memmove(lastbytes,lastbytes+nread,rem);
816              memcpy(lastbytes+rem,buf,nread);
817          }
818  #ifdef _WIN32
819          #pragma warning( suppress: 6385 ))
820  #endif
821          if (memcmp(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == 0) eof_reached = 1;
822      }
823      server.repl_transfer_lastio = server.unixtime;
824      if ((nwritten = write(server.repl_transfer_fd,buf,nread)) != nread) {
825          serverLog(LL_WARNING,"Write error or short write writing to the DB dump file needed for MASTER <-> REPLICA synchronization: %s",
826              (nwritten == -1) ? IF_WIN32(wsa_strerror(errno), strerror(errno)) : "short write");
827          goto error;
828      }
829      server.repl_transfer_read += nread;
830      if (usemark && eof_reached) {
831          if (ftruncate(server.repl_transfer_fd,
832              server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == -1)
833          {
834              serverLog(LL_WARNING,"Error truncating the RDB file received from the master for SYNC: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
835              goto error;
836          }
837      }
838      if (server.repl_transfer_read >=
839          server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)
840      {
841          off_t sync_size = server.repl_transfer_read -
842                            server.repl_transfer_last_fsync_off;
843          rdb_fsync_range(server.repl_transfer_fd,
844              server.repl_transfer_last_fsync_off, sync_size);
845          server.repl_transfer_last_fsync_off += sync_size;
846      }
847      if (!usemark) {
848          if (server.repl_transfer_read == server.repl_transfer_size)
849              eof_reached = 1;
850      }
851      if (eof_reached) {
852          int aof_is_enabled = server.aof_state != AOF_OFF;
853  #ifdef _WIN32
854          close(server.repl_transfer_fd);
855          server.repl_transfer_fd = -1;
856  #endif
857          if (server.rdb_child_pid != -1) {
858              serverLog(LL_NOTICE,
859                  "Replica is about to load the RDB file received from the "
860                  "master, but there is a pending RDB child running. "
861                  "Killing process %ld and removing its temp file to avoid "
862                  "any race",
863                      (PORT_LONG) server.rdb_child_pid);
864              IF_WIN32(AbortForkOperation(), kill(server.rdb_child_pid,SIGUSR1));
865              rdbRemoveTempFile(server.rdb_child_pid);
866          }
867          if (fsync(server.repl_transfer_fd) == -1) {
868              serverLog(LL_WARNING,
869                  "Failed trying to sync the temp DB to disk in "
870                  "MASTER <-> REPLICA synchronization: %s",
871                  strerror(errno));
872              cancelReplicationHandshake();
873              return;
874          }
875          if (rename(server.repl_transfer_tmpfile,server.rdb_filename) == -1) {
876              serverLog(LL_WARNING,"Failed trying to rename the temp DB into dump.rdb in MASTER <-> REPLICA synchronization: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
877              cancelReplicationHandshake();
878              return;
879          }
880          serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Flushing old data");
881          if(aof_is_enabled) stopAppendOnly();
882          signalFlushedDb(-1);
883          emptyDb(
884              -1,
885              server.repl_slave_lazy_flush ? EMPTYDB_ASYNC : EMPTYDB_NO_FLAGS,
886              replicationEmptyDbCallback);
887          aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);
888          serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Loading DB in memory");
889          rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
890          if (rdbLoad(server.rdb_filename,&rsi) != C_OK) {
891              serverLog(LL_WARNING,"Failed trying to load the MASTER synchronization DB from disk");
892              cancelReplicationHandshake();
893              if (aof_is_enabled) restartAOFAfterSYNC();
894              return;
895          }
896          zfree(server.repl_transfer_tmpfile);
897  #ifdef _WIN32
898          server.repl_transfer_tmpfile = NULL;
899  #else
900          close(server.repl_transfer_fd);
901  #endif
902          replicationCreateMasterClient(server.repl_transfer_s,rsi.repl_stream_db);
903          server.repl_state = REPL_STATE_CONNECTED;
904          server.repl_down_since = 0;
905          memcpy(server.replid,server.master->replid,sizeof(server.replid));
906          server.master_repl_offset = server.master->reploff;
907          clearReplicationId2();
908          if (server.repl_backlog == NULL) createReplicationBacklog();
909          serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Finished with success");
910          if (aof_is_enabled) restartAOFAfterSYNC();
911      }
912      return;
913  error:
914      cancelReplicationHandshake();
915      return;
916  }
917  #define SYNC_CMD_READ (1<<0)
918  #define SYNC_CMD_WRITE (1<<1)
919  #define SYNC_CMD_FULL (SYNC_CMD_READ|SYNC_CMD_WRITE)
920  char *sendSynchronousCommand(int flags, int fd, ...) {
921      if (flags & SYNC_CMD_WRITE) {
922          char *arg;
923          va_list ap;
924          sds cmd = sdsempty();
925          sds cmdargs = sdsempty();
926          size_t argslen = 0;
927          va_start(ap,fd);
928          while(1) {
929              arg = va_arg(ap, char*);
930              if (arg == NULL) break;
931              cmdargs = sdscatprintf(cmdargs,"$%Iu\r\n%s\r\n",strlen(arg),arg); WIN_PORT_FIX &bsol;* zu->Iu */
932              argslen++;
933          }
934          va_end(ap);
935          cmd = sdscatprintf(cmd,"*%Iu\r\n",argslen); WIN_PORT_FIX &bsol;* zu->Iu */
936          cmd = sdscatsds(cmd,cmdargs);
937          sdsfree(cmdargs);
938          if (syncWrite(fd,cmd,(ssize_t)sdslen(cmd),(PORT_LONGLONG)server.repl_syncio_timeout*1000)      WIN_PORT_FIX &bsol;* cast (ssize_t), cast (PORT_LONGLONG) */
939              == -1)
940          {
941              sdsfree(cmd);
942              return sdscatprintf(sdsempty(),"-Writing to master: %s",
943                      IF_WIN32(wsa_strerror(errno),strerror(errno)));
944          }
945          sdsfree(cmd);
946      }
947      if (flags & SYNC_CMD_READ) {
948          char buf[256];
949          if (syncReadLine(fd,buf,sizeof(buf),(PORT_LONGLONG)server.repl_syncio_timeout*1000)  WIN_PORT_FIX &bsol;* cast (PORT_LONGLONG) */
950              == -1)
951          {
952              return sdscatprintf(sdsempty(),"-Reading from master: %s",
953                      IF_WIN32(wsa_strerror(errno),strerror(errno)));
954          }
955          server.repl_transfer_lastio = server.unixtime;
956          return sdsnew(buf);
957      }
958      return NULL;
959  }
960  #define PSYNC_WRITE_ERROR 0
961  #define PSYNC_WAIT_REPLY 1
962  #define PSYNC_CONTINUE 2
963  #define PSYNC_FULLRESYNC 3
964  #define PSYNC_NOT_SUPPORTED 4
965  #define PSYNC_TRY_LATER 5
966  int slaveTryPartialResynchronization(int fd, int read_reply) {
967      char *psync_replid;
968      char psync_offset[32];
969      sds reply;
970      if (!read_reply) {
971          server.master_initial_offset = -1;
972          if (server.cached_master) {
973              psync_replid = server.cached_master->replid;
974              snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);
975              serverLog(LL_NOTICE,"Trying a partial resynchronization (request %s:%s).", psync_replid, psync_offset);
976          } else {
977              serverLog(LL_NOTICE,"Partial resynchronization not possible (no cached master)");
978              psync_replid = "?";
979              memcpy(psync_offset,"-1",3);
980          }
981          reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"PSYNC",psync_replid,psync_offset,NULL);
982          if (reply != NULL) {
983              serverLog(LL_WARNING,"Unable to send PSYNC to master: %s",reply);
984              sdsfree(reply);
985              aeDeleteFileEvent(server.el,fd,AE_READABLE);
986              return PSYNC_WRITE_ERROR;
987          }
988          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
989          return PSYNC_WAIT_REPLY;
990      }
991      reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
992      if (sdslen(reply) == 0) {
993          sdsfree(reply);
994          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
995          return PSYNC_WAIT_REPLY;
996      }
997      aeDeleteFileEvent(server.el,fd,AE_READABLE);
998      if (!strncmp(reply,"+FULLRESYNC",11)) {
999          char *replid = NULL, *offset = NULL;
1000          replid = strchr(reply,' ');
1001          if (replid) {
1002              replid++;
1003              offset = strchr(replid,' ');
1004              if (offset) offset++;
1005          }
1006          if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {
1007              serverLog(LL_WARNING,
1008                  "Master replied with wrong +FULLRESYNC syntax.");
1009              memset(server.master_replid,0,CONFIG_RUN_ID_SIZE+1);
1010          } else {
1011              memcpy(server.master_replid, replid, offset-replid-1);
1012              server.master_replid[CONFIG_RUN_ID_SIZE] = '\0';
1013              server.master_initial_offset = strtoll(offset,NULL,10);
1014              serverLog(LL_NOTICE,"Full resync from master: %s:%lld",
1015                  server.master_replid,
1016                  server.master_initial_offset);
1017          }
1018          replicationDiscardCachedMaster();
1019          sdsfree(reply);
1020          return PSYNC_FULLRESYNC;
1021      }
1022      if (!strncmp(reply,"+CONTINUE",9)) {
1023          serverLog(LL_NOTICE,
1024              "Successful partial resynchronization with master.");
1025          char *start = reply+10;
1026          char *end = reply+9;
1027          while(end[0] != '\r' && end[0] != '\n' && end[0] != '\0') end++;
1028          if (end-start == CONFIG_RUN_ID_SIZE) {
1029              char new[CONFIG_RUN_ID_SIZE+1];
1030              memcpy(new,start,CONFIG_RUN_ID_SIZE);
1031              new[CONFIG_RUN_ID_SIZE] = '\0';
1032              if (strcmp(new,server.cached_master->replid)) {
1033                  serverLog(LL_WARNING,"Master replication ID changed to %s",new);
1034                  memcpy(server.replid2,server.cached_master->replid,
1035                      sizeof(server.replid2));
1036                  server.second_replid_offset = server.master_repl_offset+1;
1037                  memcpy(server.replid,new,sizeof(server.replid));
1038                  memcpy(server.cached_master->replid,new,sizeof(server.replid));
1039                  disconnectSlaves();
1040              }
1041          }
1042          sdsfree(reply);
1043          replicationResurrectCachedMaster(fd);
1044          if (server.repl_backlog == NULL) createReplicationBacklog();
1045          return PSYNC_CONTINUE;
1046      }
1047      if (!strncmp(reply,"-NOMASTERLINK",13) ||
1048          !strncmp(reply,"-LOADING",8))
1049      {
1050          serverLog(LL_NOTICE,
1051              "Master is currently unable to PSYNC "
1052              "but should be in the future: %s", reply);
1053          sdsfree(reply);
1054          return PSYNC_TRY_LATER;
1055      }
1056      if (strncmp(reply,"-ERR",4)) {
1057          serverLog(LL_WARNING,
1058              "Unexpected reply to PSYNC from master: %s", reply);
1059      } else {
1060          serverLog(LL_NOTICE,
1061              "Master does not support PSYNC or is in "
1062              "error state (reply: %s)", reply);
1063      }
1064      sdsfree(reply);
1065      replicationDiscardCachedMaster();
1066      return PSYNC_NOT_SUPPORTED;
1067  }
1068  void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {
1069      char tmpfile[256], *err = NULL;
1070      int dfd = -1, maxtries = 5;
1071      int sockerr = 0, psync_result;
1072      socklen_t errlen = sizeof(sockerr);
1073      UNUSED(el);
1074      UNUSED(privdata);
1075      UNUSED(mask);
1076      if (server.repl_state == REPL_STATE_NONE) {
1077          close(fd);
1078          return;
1079      }
1080      if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)
1081          sockerr = errno;
1082      if (sockerr) {
1083          serverLog(LL_WARNING,"Error condition on socket for SYNC: %s",
1084              strerror(sockerr));
1085          goto error;
1086      }
1087      if (server.repl_state == REPL_STATE_CONNECTING) {
1088          serverLog(LL_NOTICE,"Non blocking connect for SYNC fired the event.");
1089          aeDeleteFileEvent(server.el,fd,AE_WRITABLE);
1090          server.repl_state = REPL_STATE_RECEIVE_PONG;
1091          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"PING",NULL);
1092          if (err) goto write_error;
1093          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1094          return;
1095      }
1096      if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
1097          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1098          if (err[0] != '+' &&
1099              strncmp(err,"-NOAUTH",7) != 0 &&
1100              strncmp(err,"-ERR operation not permitted",28) != 0)
1101          {
1102              serverLog(LL_WARNING,"Error reply to PING from master: '%s'",err);
1103              sdsfree(err);
1104              goto error;
1105          } else {
1106              serverLog(LL_NOTICE,
1107                  "Master replied to PING, replication can continue...");
1108          }
1109          sdsfree(err);
1110          server.repl_state = REPL_STATE_SEND_AUTH;
1111      }
1112      if (server.repl_state == REPL_STATE_SEND_AUTH) {
1113          if (server.masterauth) {
1114              err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"AUTH",server.masterauth,NULL);
1115              if (err) goto write_error;
1116              server.repl_state = REPL_STATE_RECEIVE_AUTH;
1117              WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1118              return;
1119          } else {
1120              server.repl_state = REPL_STATE_SEND_PORT;
1121          }
1122      }
1123      if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {
1124          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1125          if (err[0] == '-') {
1126              serverLog(LL_WARNING,"Unable to AUTH to MASTER: %s",err);
1127              sdsfree(err);
1128              goto error;
1129          }
1130          sdsfree(err);
1131          server.repl_state = REPL_STATE_SEND_PORT;
1132      }
1133      if (server.repl_state == REPL_STATE_SEND_PORT) {
1134          sds port = sdsfromlonglong(server.slave_announce_port ?
1135              server.slave_announce_port : server.port);
1136          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF",
1137                  "listening-port",port, NULL);
1138          sdsfree(port);
1139          if (err) goto write_error;
1140          sdsfree(err);
1141          server.repl_state = REPL_STATE_RECEIVE_PORT;
1142          return;
1143      }
1144      if (server.repl_state == REPL_STATE_RECEIVE_PORT) {
1145          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1146          if (err[0] == '-') {
1147              serverLog(LL_NOTICE,"(Non critical) Master does not understand "
1148                                  "REPLCONF listening-port: %s", err);
1149          }
1150          sdsfree(err);
1151          server.repl_state = REPL_STATE_SEND_IP;
1152      }
1153      if (server.repl_state == REPL_STATE_SEND_IP &&
1154          server.slave_announce_ip == NULL)
1155      {
1156              server.repl_state = REPL_STATE_SEND_CAPA;
1157      }
1158      if (server.repl_state == REPL_STATE_SEND_IP) {
1159          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF",
1160                  "ip-address",server.slave_announce_ip, NULL);
1161          if (err) goto write_error;
1162          sdsfree(err);
1163          server.repl_state = REPL_STATE_RECEIVE_IP;
1164          return;
1165      }
1166      if (server.repl_state == REPL_STATE_RECEIVE_IP) {
1167          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1168          if (err[0] == '-') {
1169              serverLog(LL_NOTICE,"(Non critical) Master does not understand "
1170                                  "REPLCONF ip-address: %s", err);
1171          }
1172          sdsfree(err);
1173          server.repl_state = REPL_STATE_SEND_CAPA;
1174      }
1175      if (server.repl_state == REPL_STATE_SEND_CAPA) {
1176          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF",
1177                  "capa","eof","capa","psync2",NULL);
1178          if (err) goto write_error;
1179          sdsfree(err);
1180          server.repl_state = REPL_STATE_RECEIVE_CAPA;
1181          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1182          return;
1183      }
1184      if (server.repl_state == REPL_STATE_RECEIVE_CAPA) {
1185          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1186          if (err[0] == '-') {
1187              serverLog(LL_NOTICE,"(Non critical) Master does not understand "
1188                                    "REPLCONF capa: %s", err);
1189          }
1190          sdsfree(err);
1191          server.repl_state = REPL_STATE_SEND_PSYNC;
1192      }
1193      if (server.repl_state == REPL_STATE_SEND_PSYNC) {
1194          if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) {
1195              err = sdsnew("Write error sending the PSYNC command.");
1196              goto write_error;
1197          }
1198          server.repl_state = REPL_STATE_RECEIVE_PSYNC;
1199          return;
1200      }
1201      if (server.repl_state != REPL_STATE_RECEIVE_PSYNC) {
1202          serverLog(LL_WARNING,"syncWithMaster(): state machine error, "
1203                               "state should be RECEIVE_PSYNC but is %d",
1204                               server.repl_state);
1205          goto error;
1206      }
1207      psync_result = slaveTryPartialResynchronization(fd,1);
1208      if (psync_result == PSYNC_WAIT_REPLY) return; &bsol;* Try again later... */
1209      if (psync_result == PSYNC_TRY_LATER) goto error;
1210      if (psync_result == PSYNC_CONTINUE) {
1211          serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Master accepted a Partial Resynchronization.");
1212          return;
1213      }
1214      disconnectSlaves(); &bsol;* Force our slaves to resync with us as well. */
1215      freeReplicationBacklog(); &bsol;* Don't allow our chained slaves to PSYNC. */
1216      if (psync_result == PSYNC_NOT_SUPPORTED) {
1217          serverLog(LL_NOTICE,"Retrying with SYNC...");
1218          if (syncWrite(fd,"SYNC\r\n",6,(PORT_LONGLONG)server.repl_syncio_timeout*1000) == -1) {  WIN_PORT_FIX &bsol;* cast (PORT_LONGLONG) */
1219              serverLog(LL_WARNING,"I/O error writing to MASTER: %s",
1220                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
1221              goto error;
1222          }
1223      }
1224      while(maxtries--) {
1225  #ifdef _WIN32
1226          snprintf(tmpfile,256,
1227              "temp-%d.%d.rdb",(int)server.unixtime,(int)getpid());
1228          dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL|O_BINARY,_S_IREAD|_S_IWRITE);
1229  #else
1230          snprintf(tmpfile,256,
1231              "temp-%d.%ld.rdb",(int)server.unixtime,(long int)getpid());
1232          dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);
1233  #endif
1234          if (dfd != -1) break;
1235          sleep(1);
1236      }
1237      if (dfd == -1) {
1238          serverLog(LL_WARNING,"Opening the temp file needed for MASTER <-> REPLICA synchronization: %s",strerror(errno));
1239          goto error;
1240      }
1241      if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL)
1242              == AE_ERR)
1243      {
1244          serverLog(LL_WARNING,
1245              "Can't create readable event for SYNC: %s (fd=%d)",
1246              IF_WIN32(wsa_strerror(errno),strerror(errno)),fd);
1247          goto error;
1248      }
1249      server.repl_state = REPL_STATE_TRANSFER;
1250      server.repl_transfer_size = -1;
1251      server.repl_transfer_read = 0;
1252      server.repl_transfer_last_fsync_off = 0;
1253      server.repl_transfer_fd = dfd;
1254      server.repl_transfer_lastio = server.unixtime;
1255      server.repl_transfer_tmpfile = zstrdup(tmpfile);
1256      return;
1257  error:
1258      aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
1259      if (dfd != -1) close(dfd);
1260      close(fd);
1261      server.repl_transfer_s = -1;
1262      server.repl_state = REPL_STATE_CONNECT;
1263      return;
1264  write_error: &bsol;* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */
1265      serverLog(LL_WARNING,"Sending command to master in replication handshake: %s", err);
1266      sdsfree(err);
1267      goto error;
1268  }
1269  int connectWithMaster(void) {
1270      int fd;
1271      fd = anetTcpNonBlockBestEffortBindConnect(NULL,
1272          server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);
1273      if (fd == -1) {
1274          serverLog(LL_WARNING,"Unable to connect to MASTER: %s",
1275              IF_WIN32(wsa_strerror(errno),strerror(errno)));
1276          return C_ERR;
1277      }
1278      if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) ==
1279              AE_ERR)
1280      {
1281          close(fd);
1282          serverLog(LL_WARNING,"Can't create readable event for SYNC");
1283          return C_ERR;
1284      }
1285      server.repl_transfer_lastio = server.unixtime;
1286      server.repl_transfer_s = fd;
1287      server.repl_state = REPL_STATE_CONNECTING;
1288      return C_OK;
1289  }
1290  void undoConnectWithMaster(void) {
1291      int fd = server.repl_transfer_s;
1292      aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
1293      close(fd);
1294      server.repl_transfer_s = -1;
1295  }
1296  void replicationAbortSyncTransfer(void) {
1297      serverAssert(server.repl_state == REPL_STATE_TRANSFER);
1298      undoConnectWithMaster();
1299      close(server.repl_transfer_fd);
1300      unlink(server.repl_transfer_tmpfile);
1301      zfree(server.repl_transfer_tmpfile);
1302  }
1303  int cancelReplicationHandshake(void) {
1304      if (server.repl_state == REPL_STATE_TRANSFER) {
1305          replicationAbortSyncTransfer();
1306          server.repl_state = REPL_STATE_CONNECT;
1307      } else if (server.repl_state == REPL_STATE_CONNECTING ||
1308                 slaveIsInHandshakeState())
1309      {
1310          undoConnectWithMaster();
1311          server.repl_state = REPL_STATE_CONNECT;
1312      } else {
1313          return 0;
1314      }
1315      return 1;
1316  }
1317  void replicationSetMaster(char *ip, int port) {
1318      int was_master = server.masterhost == NULL;
1319      sdsfree(server.masterhost);
1320      server.masterhost = sdsnew(ip);
1321      server.masterport = port;
1322      if (server.master) {
1323          freeClient(server.master);
1324      }
1325      disconnectAllBlockedClients(); &bsol;* Clients blocked in master, now slave. */
1326      disconnectSlaves();
1327      cancelReplicationHandshake();
1328      if (was_master) {
1329          replicationDiscardCachedMaster();
1330          replicationCacheMasterUsingMyself();
1331      }
1332      server.repl_state = REPL_STATE_CONNECT;
1333  }
1334  void replicationUnsetMaster(void) {
1335      if (server.masterhost == NULL) return; &bsol;* Nothing to do. */
1336      sdsfree(server.masterhost);
1337      server.masterhost = NULL;
1338      shiftReplicationId();
1339      if (server.master) freeClient(server.master);
1340      replicationDiscardCachedMaster();
1341      cancelReplicationHandshake();
1342      disconnectSlaves();
1343      server.repl_state = REPL_STATE_NONE;
1344      server.slaveseldb = -1;
1345      server.repl_no_slaves_since = server.unixtime;
1346  }
1347  void replicationHandleMasterDisconnection(void) {
1348      server.master = NULL;
1349      server.repl_state = REPL_STATE_CONNECT;
1350      server.repl_down_since = server.unixtime;
1351  }
1352  void replicaofCommand(client *c) {
1353      if (server.cluster_enabled) {
1354          addReplyError(c,"REPLICAOF not allowed in cluster mode.");
1355          return;
1356      }
1357      if (!strcasecmp(c->argv[1]->ptr,"no") &&
1358          !strcasecmp(c->argv[2]->ptr,"one")) {
1359          if (server.masterhost) {
1360              replicationUnsetMaster();
1361              sds client = catClientInfoString(sdsempty(),c);
1362              serverLog(LL_NOTICE,"MASTER MODE enabled (user request from '%s')",
1363                  client);
1364              sdsfree(client);
1365          }
1366      } else {
1367          PORT_LONG port;
1368          if (c->flags & CLIENT_SLAVE)
1369          {
1370              addReplyError(c, "Command is not valid when client is a replica.");
1371              return;
1372          }
1373          if ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != C_OK))
1374              return;
1375          if (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr)
1376              && server.masterport == port) {
1377              serverLog(LL_NOTICE,"REPLICAOF would result into synchronization with the master we are already connected with. No operation performed.");
1378              addReplySds(c,sdsnew("+OK Already connected to specified master\r\n"));
1379              return;
1380          }
1381          replicationSetMaster(c->argv[1]->ptr, (int)port);                       WIN_PORT_FIX &bsol;* cast (int) */
1382          sds client = catClientInfoString(sdsempty(),c);
1383          serverLog(LL_NOTICE,"REPLICAOF %s:%d enabled (user request from '%s')",
1384              server.masterhost, server.masterport, client);
1385          sdsfree(client);
1386      }
1387      addReply(c,shared.ok);
1388  }
1389  void roleCommand(client *c) {
1390      if (server.masterhost == NULL) {
1391          listIter li;
1392          listNode *ln;
1393          void *mbcount;
1394          int slaves = 0;
1395          addReplyMultiBulkLen(c,3);
1396          addReplyBulkCBuffer(c,"master",6);
1397          addReplyLongLong(c,server.master_repl_offset);
1398          mbcount = addDeferredMultiBulkLength(c);
1399          listRewind(server.slaves,&li);
1400          while((ln = listNext(&li))) {
1401              client *slave = ln->value;
1402              char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;
1403              if (slaveip[0] == '\0') {
1404                  if (anetPeerToString(slave->fd,ip,sizeof(ip),NULL) == -1)
1405                      continue;
1406                  slaveip = ip;
1407              }
1408              if (slave->replstate != SLAVE_STATE_ONLINE) continue;
1409              addReplyMultiBulkLen(c,3);
1410              addReplyBulkCString(c,slaveip);
1411              addReplyBulkLongLong(c,slave->slave_listening_port);
1412              addReplyBulkLongLong(c,slave->repl_ack_off);
1413              slaves++;
1414          }
1415          setDeferredMultiBulkLength(c,mbcount,slaves);
1416      } else {
1417          char *slavestate = NULL;
1418          addReplyMultiBulkLen(c,5);
1419          addReplyBulkCBuffer(c,"slave",5);
1420          addReplyBulkCString(c,server.masterhost);
1421          addReplyLongLong(c,server.masterport);
1422          if (slaveIsInHandshakeState()) {
1423              slavestate = "handshake";
1424          } else {
1425              switch(server.repl_state) {
1426              case REPL_STATE_NONE: slavestate = "none"; break;
1427              case REPL_STATE_CONNECT: slavestate = "connect"; break;
1428              case REPL_STATE_CONNECTING: slavestate = "connecting"; break;
1429              case REPL_STATE_TRANSFER: slavestate = "sync"; break;
1430              case REPL_STATE_CONNECTED: slavestate = "connected"; break;
1431              default: slavestate = "unknown"; break;
1432              }
1433          }
1434          addReplyBulkCString(c,slavestate);
1435          addReplyLongLong(c,server.master ? server.master->reploff : -1);
1436      }
1437  }
1438  void replicationSendAck(void) {
1439      client *c = server.master;
1440      if (c != NULL) {
1441          c->flags |= CLIENT_MASTER_FORCE_REPLY;
1442          addReplyMultiBulkLen(c,3);
1443          addReplyBulkCString(c,"REPLCONF");
1444          addReplyBulkCString(c,"ACK");
1445          addReplyBulkLongLong(c,c->reploff);
1446          c->flags &= ~CLIENT_MASTER_FORCE_REPLY;
1447      }
1448  }
1449  void replicationCacheMaster(client *c) {
1450      serverAssert(server.master != NULL && server.cached_master == NULL);
1451      serverLog(LL_NOTICE,"Caching the disconnected master state.");
1452      unlinkClient(c);
1453      sdsclear(server.master->querybuf);
1454      sdsclear(server.master->pending_querybuf);
1455      server.master->read_reploff = server.master->reploff;
1456      if (c->flags & CLIENT_MULTI) discardTransaction(c);
1457      listEmpty(c->reply);
1458      c->sentlen = 0;
1459      c->reply_bytes = 0;
1460      c->bufpos = 0;
1461      resetClient(c);
1462      server.cached_master = server.master;
1463      if (c->peerid) {
1464          sdsfree(c->peerid);
1465          c->peerid = NULL;
1466      }
1467      replicationHandleMasterDisconnection();
1468  }
1469  void replicationCacheMasterUsingMyself(void) {
1470      server.master_initial_offset = server.master_repl_offset;
1471      replicationCreateMasterClient(-1,-1);
1472      memcpy(server.master->replid, server.replid, sizeof(server.replid));
1473      unlinkClient(server.master);
1474      server.cached_master = server.master;
1475      server.master = NULL;
1476      serverLog(LL_NOTICE,"Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.");
1477  }
1478  void replicationDiscardCachedMaster(void) {
1479      if (server.cached_master == NULL) return;
1480      serverLog(LL_NOTICE,"Discarding previously cached master state.");
1481      server.cached_master->flags &= ~CLIENT_MASTER;
1482      freeClient(server.cached_master);
1483      server.cached_master = NULL;
1484  }
1485  void replicationResurrectCachedMaster(int newfd) {
1486      server.master = server.cached_master;
1487      server.cached_master = NULL;
1488      server.master->fd = newfd;
1489      server.master->flags &= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
1490      server.master->authenticated = 1;
1491      server.master->lastinteraction = server.unixtime;
1492      server.repl_state = REPL_STATE_CONNECTED;
1493      server.repl_down_since = 0;
1494      linkClient(server.master);
1495      if (aeCreateFileEvent(server.el, newfd, AE_READABLE,
1496                            readQueryFromClient, server.master)) {
1497          serverLog(LL_WARNING,"Error resurrecting the cached master, impossible to add the readable handler: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
1498          freeClientAsync(server.master); &bsol;* Close ASAP. */
1499      }
1500      if (clientHasPendingReplies(server.master)) {
1501          if (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,
1502                            sendReplyToClient, server.master)) {
1503              serverLog(LL_WARNING,"Error resurrecting the cached master, impossible to add the writable handler: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
1504              freeClientAsync(server.master); &bsol;* Close ASAP. */
1505          }
1506      }
1507  }
1508  void refreshGoodSlavesCount(void) {
1509      listIter li;
1510      listNode *ln;
1511      int good = 0;
1512      if (!server.repl_min_slaves_to_write ||
1513          !server.repl_min_slaves_max_lag) return;
1514      listRewind(server.slaves,&li);
1515      while((ln = listNext(&li))) {
1516          client *slave = ln->value;
1517          time_t lag = server.unixtime - slave->repl_ack_time;
1518          if (slave->replstate == SLAVE_STATE_ONLINE &&
1519              lag <= server.repl_min_slaves_max_lag) good++;
1520      }
1521      server.repl_good_slaves_count = good;
1522  }
1523  void replicationScriptCacheInit(void) {
1524      server.repl_scriptcache_size = 10000;
1525      server.repl_scriptcache_dict = dictCreate(&replScriptCacheDictType,NULL);
1526      server.repl_scriptcache_fifo = listCreate();
1527  }
1528  void replicationScriptCacheFlush(void) {
1529      dictEmpty(server.repl_scriptcache_dict,NULL);
1530      listRelease(server.repl_scriptcache_fifo);
1531      server.repl_scriptcache_fifo = listCreate();
1532  }
1533  void replicationScriptCacheAdd(sds sha1) {
1534      int retval;
1535      sds key = sdsdup(sha1);
1536      if (listLength(server.repl_scriptcache_fifo) == server.repl_scriptcache_size)
1537      {
1538          listNode *ln = listLast(server.repl_scriptcache_fifo);
1539          sds oldest = listNodeValue(ln);
1540          retval = dictDelete(server.repl_scriptcache_dict,oldest);
1541          serverAssert(retval == DICT_OK);
1542          listDelNode(server.repl_scriptcache_fifo,ln);
1543      }
1544      retval = dictAdd(server.repl_scriptcache_dict,key,NULL);
1545      listAddNodeHead(server.repl_scriptcache_fifo,key);
1546      serverAssert(retval == DICT_OK);
1547  }
1548  int replicationScriptCacheExists(sds sha1) {
1549      return dictFind(server.repl_scriptcache_dict,sha1) != NULL;
1550  }
1551  void replicationRequestAckFromSlaves(void) {
1552      server.get_ack_from_slaves = 1;
1553  }
1554  int replicationCountAcksByOffset(PORT_LONGLONG offset) {
1555      listIter li;
1556      listNode *ln;
1557      int count = 0;
1558      listRewind(server.slaves,&li);
1559      while((ln = listNext(&li))) {
1560          client *slave = ln->value;
1561          if (slave->replstate != SLAVE_STATE_ONLINE) continue;
1562          if (slave->repl_ack_off >= offset) count++;
1563      }
1564      return count;
1565  }
1566  void waitCommand(client *c) {
1567      mstime_t timeout;
1568      PORT_LONG numreplicas, ackreplicas;
1569      PORT_LONGLONG offset = c->woff;
1570      if (server.masterhost) {
1571          addReplyError(c,"WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated.");
1572          return;
1573      }
1574      if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
1575          return;
1576      if (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,UNIT_MILLISECONDS)
1577          != C_OK) return;
1578      ackreplicas = replicationCountAcksByOffset(c->woff);
1579      if (ackreplicas >= numreplicas || c->flags & CLIENT_MULTI) {
1580          addReplyLongLong(c,ackreplicas);
1581          return;
1582      }
1583      c->bpop.timeout = timeout;
1584      c->bpop.reploffset = offset;
1585      c->bpop.numreplicas = (int) numreplicas;                                    WIN_PORT_FIX &bsol;* cast (int) */
1586      listAddNodeTail(server.clients_waiting_acks,c);
1587      blockClient(c,BLOCKED_WAIT);
1588      replicationRequestAckFromSlaves();
1589  }
1590  void unblockClientWaitingReplicas(client *c) {
1591      listNode *ln = listSearchKey(server.clients_waiting_acks,c);
1592      serverAssert(ln != NULL);
1593      listDelNode(server.clients_waiting_acks,ln);
1594  }
1595  void processClientsWaitingReplicas(void) {
1596      PORT_LONGLONG last_offset = 0;
1597      int last_numreplicas = 0;
1598      listIter li;
1599      listNode *ln;
1600      listRewind(server.clients_waiting_acks,&li);
1601      while((ln = listNext(&li))) {
1602          client *c = ln->value;
1603          if (last_offset && last_offset > c->bpop.reploffset &&
1604                             last_numreplicas > c->bpop.numreplicas)
1605          {
1606              unblockClient(c);
1607              addReplyLongLong(c,last_numreplicas);
1608          } else {
1609              int numreplicas = replicationCountAcksByOffset(c->bpop.reploffset);
1610              if (numreplicas >= c->bpop.numreplicas) {
1611                  last_offset = c->bpop.reploffset;
1612                  last_numreplicas = numreplicas;
1613                  unblockClient(c);
1614                  addReplyLongLong(c,numreplicas);
1615              }
1616          }
1617      }
1618  }
1619  PORT_LONGLONG replicationGetSlaveOffset(void) {
1620      PORT_LONGLONG offset = 0;
1621      if (server.masterhost != NULL) {
1622          if (server.master) {
1623              offset = server.master->reploff;
1624          } else if (server.cached_master) {
1625              offset = server.cached_master->reploff;
1626          }
1627      }
1628      if (offset < 0) offset = 0;
1629      return offset;
1630  }
1631  void replicationCron(void) {
1632      static PORT_LONGLONG replication_cron_loops = 0;
1633      if (server.masterhost &&
1634          (server.repl_state == REPL_STATE_CONNECTING ||
1635           slaveIsInHandshakeState()) &&
1636           (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
1637      {
1638          serverLog(LL_WARNING,"Timeout connecting to the MASTER...");
1639          cancelReplicationHandshake();
1640      }
1641      if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER &&
1642          (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
1643      {
1644          serverLog(LL_WARNING,"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value.");
1645          cancelReplicationHandshake();
1646      }
1647      if (server.masterhost && server.repl_state == REPL_STATE_CONNECTED &&
1648          (time(NULL)-server.master->lastinteraction) > server.repl_timeout)
1649      {
1650          serverLog(LL_WARNING,"MASTER timeout: no data nor PING received...");
1651          freeClient(server.master);
1652      }
1653      if (server.repl_state == REPL_STATE_CONNECT) {
1654          serverLog(LL_NOTICE,"Connecting to MASTER %s:%d",
1655              server.masterhost, server.masterport);
1656          if (connectWithMaster() == C_OK) {
1657              serverLog(LL_NOTICE,"MASTER <-> REPLICA sync started");
1658          }
1659      }
1660      if (server.masterhost && server.master &&
1661          !(server.master->flags & CLIENT_PRE_PSYNC))
1662          replicationSendAck();
1663      listIter li;
1664      listNode *ln;
1665      robj *ping_argv[1];
1666      if ((replication_cron_loops % server.repl_ping_slave_period) == 0 &&
1667          listLength(server.slaves))
1668      {
1669          int manual_failover_in_progress =
1670              server.cluster_enabled &&
1671              server.cluster->mf_end &&
1672              clientsArePaused();
1673          if (!manual_failover_in_progress) {
1674              ping_argv[0] = createStringObject("PING",4);
1675              replicationFeedSlaves(server.slaves, server.slaveseldb,
1676                  ping_argv, 1);
1677              decrRefCount(ping_argv[0]);
1678          }
1679      }
1680      listRewind(server.slaves,&li);
1681      while((ln = listNext(&li))) {
1682          client *slave = ln->value;
1683          int is_presync =
1684              (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
1685              (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END &&
1686               server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));
1687          if (is_presync) {
1688  #ifdef _WIN32
1689              if (WSIOCP_SocketSend(slave->fd, "\n", 1, server.el,
1690                                    NULL, NULL, NULL) == -1) {
1691  #else
1692              if (write(slave->fd, "\n", 1) == -1) {
1693  #endif
1694              }
1695          }
1696      }
1697      if (listLength(server.slaves)) {
1698          listIter li;
1699          listNode *ln;
1700          listRewind(server.slaves,&li);
1701          while((ln = listNext(&li))) {
1702              client *slave = ln->value;
1703              if (slave->replstate != SLAVE_STATE_ONLINE) continue;
1704              if (slave->flags & CLIENT_PRE_PSYNC) continue;
1705              if ((server.unixtime - slave->repl_ack_time) > server.repl_timeout)
1706              {
1707                  serverLog(LL_WARNING, "Disconnecting timedout replica: %s",
1708                      replicationGetSlaveName(slave));
1709                  freeClient(slave);
1710              }
1711          }
1712      }
1713      if (listLength(server.slaves) == 0 && server.repl_backlog_time_limit &&
1714          server.repl_backlog && server.masterhost == NULL)
1715      {
1716          time_t idle = server.unixtime - server.repl_no_slaves_since;
1717          if (idle > server.repl_backlog_time_limit) {
1718              changeReplicationId();
1719              clearReplicationId2();
1720              freeReplicationBacklog();
1721              serverLog(LL_NOTICE,
1722                  "Replication backlog freed after %d seconds "
1723                  "without connected replicas.",
1724                  (int) server.repl_backlog_time_limit);
1725          }
1726      }
1727      if (listLength(server.slaves) == 0 &&
1728          server.aof_state == AOF_OFF &&
1729          listLength(server.repl_scriptcache_fifo) != 0)
1730      {
1731          replicationScriptCacheFlush();
1732      }
1733      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {
1734          time_t idle, max_idle = 0;
1735          int slaves_waiting = 0;
1736          int mincapa = -1;
1737          listNode *ln;
1738          listIter li;
1739          listRewind(server.slaves,&li);
1740          while((ln = listNext(&li))) {
1741              client *slave = ln->value;
1742              if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
1743                  idle = server.unixtime - slave->lastinteraction;
1744                  if (idle > max_idle) max_idle = idle;
1745                  slaves_waiting++;
1746                  mincapa = (mincapa == -1) ? slave->slave_capa :
1747                                              (mincapa & slave->slave_capa);
1748              }
1749          }
1750          if (slaves_waiting &&
1751              (!server.repl_diskless_sync ||
1752               max_idle > server.repl_diskless_sync_delay))
1753          {
1754              startBgsaveForReplication(mincapa);
1755          }
1756      }
1757      refreshGoodSlavesCount();
1758      replication_cron_loops++; &bsol;* Incremented with frequency 1 HZ. */
1759  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-config.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/win32_types.h"
3  #include "Win32_Interop/Win32_EventLog.h"
4  #include "Win32_Interop/Win32_Error.h"
5  #include <direct.h>
6  #endif
7  #include "server.h"
8  #include "cluster.h"
9  #include <fcntl.h>
10  #include <sys/stat.h>
11  typedef struct configEnum {
12      const char *name;
13      const int val;
14  } configEnum;
15  configEnum maxmemory_policy_enum[] = {
16      {"volatile-lru", MAXMEMORY_VOLATILE_LRU},
17      {"volatile-lfu", MAXMEMORY_VOLATILE_LFU},
18      {"volatile-random",MAXMEMORY_VOLATILE_RANDOM},
19      {"volatile-ttl",MAXMEMORY_VOLATILE_TTL},
20      {"allkeys-lru",MAXMEMORY_ALLKEYS_LRU},
21      {"allkeys-lfu",MAXMEMORY_ALLKEYS_LFU},
22      {"allkeys-random",MAXMEMORY_ALLKEYS_RANDOM},
23      {"noeviction",MAXMEMORY_NO_EVICTION},
24      {NULL, 0}
25  };
26  #ifndef _WIN32
27  configEnum syslog_facility_enum[] = {
28      {"user",    LOG_USER},
29      {"local0",  LOG_LOCAL0},
30      {"local1",  LOG_LOCAL1},
31      {"local2",  LOG_LOCAL2},
32      {"local3",  LOG_LOCAL3},
33      {"local4",  LOG_LOCAL4},
34      {"local5",  LOG_LOCAL5},
35      {"local6",  LOG_LOCAL6},
36      {"local7",  LOG_LOCAL7},
37      {NULL, 0}
38  };
39  #endif
40  configEnum loglevel_enum[] = {
41      {"debug", LL_DEBUG},
42      {"verbose", LL_VERBOSE},
43      {"notice", LL_NOTICE},
44      {"warning", LL_WARNING},
45      {NULL,0}
46  };
47  configEnum supervised_mode_enum[] = {
48      {"upstart", SUPERVISED_UPSTART},
49      {"systemd", SUPERVISED_SYSTEMD},
50      {"auto", SUPERVISED_AUTODETECT},
51      {"no", SUPERVISED_NONE},
52      {NULL, 0}
53  };
54  configEnum aof_fsync_enum[] = {
55      {"everysec", AOF_FSYNC_EVERYSEC},
56      {"always", AOF_FSYNC_ALWAYS},
57      {"no", AOF_FSYNC_NO},
58      {NULL, 0}
59  };
60  clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {
61      {0, 0, 0}, &bsol;* normal */
62      {1024*1024*256, 1024*1024*64, 60}, &bsol;* slave */
63      {1024*1024*32, 1024*1024*8, 60}  &bsol;* pubsub */
64  };
65  int configEnumGetValue(configEnum *ce, char *name) {
66      while(ce->name != NULL) {
67          if (!strcasecmp(ce->name,name)) return ce->val;
68          ce++;
69      }
70      return INT_MIN;
71  }
72  const char *configEnumGetName(configEnum *ce, int val) {
73      while(ce->name != NULL) {
74          if (ce->val == val) return ce->name;
75          ce++;
76      }
77      return NULL;
78  }
79  const char *configEnumGetNameOrUnknown(configEnum *ce, int val) {
80      const char *name = configEnumGetName(ce,val);
81      return name ? name : "unknown";
82  }
83  const char *evictPolicyToString(void) {
84      return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);
85  }
86  int yesnotoi(char *s) {
87      if (!strcasecmp(s,"yes")) return 1;
88      else if (!strcasecmp(s,"no")) return 0;
89      else return -1;
90  }
91  void appendServerSaveParams(time_t seconds, int changes) {
92      server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*((PORT_ULONG)server.saveparamslen+1));  WIN_PORT_FIX &bsol;* cat (PORT_ULONG) */
93      server.saveparams[server.saveparamslen].seconds = seconds;
94      server.saveparams[server.saveparamslen].changes = changes;
95      server.saveparamslen++;
96  }
97  void resetServerSaveParams(void) {
98      zfree(server.saveparams);
99      server.saveparams = NULL;
100      server.saveparamslen = 0;
101  }
102  void queueLoadModule(sds path, sds *argv, int argc) {
103      int i;
104      struct moduleLoadQueueEntry *loadmod;
105      loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));
106      loadmod->argv = zmalloc(sizeof(robj*)*argc);
107      loadmod->path = sdsnew(path);
108      loadmod->argc = argc;
109      for (i = 0; i < argc; i++) {
110          loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
111      }
112      listAddNodeTail(server.loadmodule_queue,loadmod);
113  }
114  void loadServerConfigFromString(char *config) {
115      char *err = NULL;
116      int linenum = 0, totlines, i;
117      int slaveof_linenum = 0;
118      sds *lines;
119      lines = sdssplitlen(config,(int)strlen(config),"\n",1,&totlines);           WIN_PORT_FIX &bsol;* cast (int) */
120      for (i = 0; i < totlines; i++) {
121          sds *argv;
122          int argc;
123          linenum = i+1;
124          lines[i] = sdstrim(lines[i]," \t\r\n");
125          if (lines[i][0] == '#' || lines[i][0] == '\0') continue;
126          argv = sdssplitargs(lines[i],&argc);
127          if (argv == NULL) {
128              err = "Unbalanced quotes in configuration line";
129              goto loaderr;
130          }
131          if (argc == 0) {
132              sdsfreesplitres(argv,argc);
133              continue;
134          }
135          sdstolower(argv[0]);
136          if (!strcasecmp(argv[0],"timeout") && argc == 2) {
137              server.maxidletime = atoi(argv[1]);
138              if (server.maxidletime < 0) {
139                  err = "Invalid timeout value"; goto loaderr;
140              }
141          } else if (!strcasecmp(argv[0],"tcp-keepalive") && argc == 2) {
142              server.tcpkeepalive = atoi(argv[1]);
143              if (server.tcpkeepalive < 0) {
144                  err = "Invalid tcp-keepalive value"; goto loaderr;
145              }
146          } else if (!strcasecmp(argv[0],"protected-mode") && argc == 2) {
147              if ((server.protected_mode = yesnotoi(argv[1])) == -1) {
148                  err = "argument must be 'yes' or 'no'"; goto loaderr;
149              }
150          } else if (!strcasecmp(argv[0],"port") && argc == 2) {
151              server.port = atoi(argv[1]);
152              if (server.port < 0 || server.port > 65535) {
153                  err = "Invalid port"; goto loaderr;
154              }
155          } else if (!strcasecmp(argv[0],"tcp-backlog") && argc == 2) {
156              server.tcp_backlog = atoi(argv[1]);
157              if (server.tcp_backlog < 0) {
158                  err = "Invalid backlog value"; goto loaderr;
159              }
160          } else if (!strcasecmp(argv[0],"bind") && argc >= 2) {
161              int j, addresses = argc-1;
162              if (addresses > CONFIG_BINDADDR_MAX) {
163                  err = "Too many bind addresses specified"; goto loaderr;
164              }
165              for (j = 0; j < addresses; j++)
166                  server.bindaddr[j] = zstrdup(argv[j+1]);
167              server.bindaddr_count = addresses;
168          } else if (!strcasecmp(argv[0],"unixsocket") && argc == 2) {
169              server.unixsocket = zstrdup(argv[1]);
170          } else if (!strcasecmp(argv[0],"unixsocketperm") && argc == 2) {
171              errno = 0;
172              server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);
173              if (errno || server.unixsocketperm > 0777) {
174                  err = "Invalid socket file permissions"; goto loaderr;
175              }
176          } else if (!strcasecmp(argv[0],"save")) {
177              if (argc == 3) {
178                  int seconds = atoi(argv[1]);
179                  int changes = atoi(argv[2]);
180                  if (seconds < 1 || changes < 0) {
181                      err = "Invalid save parameters"; goto loaderr;
182                  }
183                  appendServerSaveParams(seconds,changes);
184              } else if (argc == 2 && !strcasecmp(argv[1],"")) {
185                  resetServerSaveParams();
186              }
187          } else if (!strcasecmp(argv[0],"dir") && argc == 2) {
188              if (chdir(argv[1]) == -1) {
189                  serverLog(LL_WARNING,"Can't chdir to '%s': %s",
190                      argv[1], IF_WIN32(wsa_strerror(errno), strerror(errno)));
191                  exit(1);
192              }
193          } else if (!strcasecmp(argv[0],"loglevel") && argc == 2) {
194              server.verbosity = configEnumGetValue(loglevel_enum,argv[1]);
195              if (server.verbosity == INT_MIN) {
196                  err = "Invalid log level. "
197                        "Must be one of debug, verbose, notice, warning";
198                  goto loaderr;
199              }
200  #ifdef _WIN32
201              setLogVerbosityLevel(server.verbosity);
202  #endif
203          } else if (!strcasecmp(argv[0],"logfile") && argc == 2) {
204              FILE *logfp;
205              zfree(server.logfile);
206  #ifdef _WIN32
207              int length = (int)sdslen(argv[1]);
208              if ((argv[1][0] == '\''  &&  argv[1][length-1] == '\'')  ||
209                  (argv[1][0] == '\"'  &&  argv[1][length-1] == '\"')) {
210                  if (length == 2) {
211                      server.logfile = zstrdup("\0");
212                  } else {
213                      size_t l = (size_t) length - 2 + 1;
214                      char *p = zmalloc(l);
215                      memcpy(p, argv[1]+1, l);
216                      server.logfile = p;
217                  }
218              } else {
219                  server.logfile = zstrdup(argv[1]);
220              }
221  #else
222              server.logfile = zstrdup(argv[1]);
223  #endif
224              if (server.logfile[0] != '\0') {
225                  logfp = fopen(server.logfile,"a");
226                  if (logfp == NULL) {
227                      err = sdscatprintf(sdsempty(),
228                          "Can't open the log file: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
229                      goto loaderr;
230  #ifdef _WIN32
231                  } else {
232                      setLogFile(server.logfile);
233  #endif
234                  }
235                  fclose(logfp);
236              }
237          } else if (!strcasecmp(argv[0],"always-show-logo") && argc == 2) {
238              if ((server.always_show_logo = yesnotoi(argv[1])) == -1) {
239                  err = "argument must be 'yes' or 'no'"; goto loaderr;
240              }
241          } else if (!strcasecmp(argv[0],"syslog-enabled") && argc == 2) {
242              if ((server.syslog_enabled = yesnotoi(argv[1])) == -1) {
243                  err = "argument must be 'yes' or 'no'"; goto loaderr;
244              }
245  #ifdef _WIN32
246              setSyslogEnabled(server.syslog_enabled);
247  #endif
248          } else if (!strcasecmp(argv[0],"syslog-ident") && argc == 2) {
249              if (server.syslog_ident) zfree(server.syslog_ident);
250              server.syslog_ident = zstrdup(argv[1]);
251  #ifdef _WIN32
252              setSyslogIdent(server.syslog_ident);
253  #endif
254          } else if (!strcasecmp(argv[0],"syslog-facility") && argc == 2) {
255  #ifdef _WIN32
256  #else
257              server.syslog_facility =
258                  configEnumGetValue(syslog_facility_enum,argv[1]);
259              if (server.syslog_facility == INT_MIN) {
260                  err = "Invalid log facility. Must be one of USER or between LOCAL0-LOCAL7";
261                  goto loaderr;
262              }
263  #endif
264          } else if (!strcasecmp(argv[0],"databases") && argc == 2) {
265              server.dbnum = atoi(argv[1]);
266              if (server.dbnum < 1) {
267                  err = "Invalid number of databases"; goto loaderr;
268              }
269          } else if (!strcasecmp(argv[0],"include") && argc == 2) {
270              loadServerConfig(argv[1],NULL);
271          } else if (!strcasecmp(argv[0],"maxclients") && argc == 2) {
272              server.maxclients = atoi(argv[1]);
273              if (server.maxclients < 1) {
274                  err = "Invalid max clients limit"; goto loaderr;
275              }
276          } else if (!strcasecmp(argv[0],"maxmemory") && argc == 2) {
277              server.maxmemory = memtoll(argv[1],NULL);
278          } else if (!strcasecmp(argv[0],"maxmemory-policy") && argc == 2) {
279              server.maxmemory_policy =
280                  configEnumGetValue(maxmemory_policy_enum,argv[1]);
281              if (server.maxmemory_policy == INT_MIN) {
282                  err = "Invalid maxmemory policy";
283                  goto loaderr;
284              }
285          } else if (!strcasecmp(argv[0],"maxmemory-samples") && argc == 2) {
286              server.maxmemory_samples = atoi(argv[1]);
287              if (server.maxmemory_samples <= 0) {
288                  err = "maxmemory-samples must be 1 or greater";
289                  goto loaderr;
290              }
291          } else if ((!strcasecmp(argv[0],"proto-max-bulk-len")) && argc == 2) {
292              server.proto_max_bulk_len = memtoll(argv[1],NULL);
293          } else if ((!strcasecmp(argv[0],"client-query-buffer-limit")) && argc == 2) {
294              server.client_max_querybuf_len = memtoll(argv[1],NULL);
295          } else if (!strcasecmp(argv[0],"lfu-log-factor") && argc == 2) {
296              server.lfu_log_factor = atoi(argv[1]);
297              if (server.lfu_log_factor < 0) {
298                  err = "lfu-log-factor must be 0 or greater";
299                  goto loaderr;
300              }
301          } else if (!strcasecmp(argv[0],"lfu-decay-time") && argc == 2) {
302              server.lfu_decay_time = atoi(argv[1]);
303              if (server.lfu_decay_time < 0) {
304                  err = "lfu-decay-time must be 0 or greater";
305                  goto loaderr;
306              }
307          } else if ((!strcasecmp(argv[0],"slaveof") ||
308                      !strcasecmp(argv[0],"replicaof")) && argc == 3) {
309              slaveof_linenum = linenum;
310              server.masterhost = sdsnew(argv[1]);
311              server.masterport = atoi(argv[2]);
312              server.repl_state = REPL_STATE_CONNECT;
313          } else if ((!strcasecmp(argv[0],"repl-ping-slave-period") ||
314                      !strcasecmp(argv[0],"repl-ping-replica-period")) &&
315                      argc == 2)
316          {
317              server.repl_ping_slave_period = atoi(argv[1]);
318              if (server.repl_ping_slave_period <= 0) {
319                  err = "repl-ping-replica-period must be 1 or greater";
320                  goto loaderr;
321              }
322          } else if (!strcasecmp(argv[0],"repl-timeout") && argc == 2) {
323              server.repl_timeout = atoi(argv[1]);
324              if (server.repl_timeout <= 0) {
325                  err = "repl-timeout must be 1 or greater";
326                  goto loaderr;
327              }
328          } else if (!strcasecmp(argv[0],"repl-disable-tcp-nodelay") && argc==2) {
329              if ((server.repl_disable_tcp_nodelay = yesnotoi(argv[1])) == -1) {
330                  err = "argument must be 'yes' or 'no'"; goto loaderr;
331              }
332          } else if (!strcasecmp(argv[0],"repl-diskless-sync") && argc==2) {
333              if ((server.repl_diskless_sync = yesnotoi(argv[1])) == -1) {
334                  err = "argument must be 'yes' or 'no'"; goto loaderr;
335              }
336          } else if (!strcasecmp(argv[0],"repl-diskless-sync-delay") && argc==2) {
337              server.repl_diskless_sync_delay = atoi(argv[1]);
338              if (server.repl_diskless_sync_delay < 0) {
339                  err = "repl-diskless-sync-delay can't be negative";
340                  goto loaderr;
341              }
342          } else if (!strcasecmp(argv[0],"repl-backlog-size") && argc == 2) {
343              PORT_LONGLONG size = memtoll(argv[1],NULL);
344              if (size <= 0) {
345                  err = "repl-backlog-size must be 1 or greater.";
346                  goto loaderr;
347              }
348              resizeReplicationBacklog(size);
349          } else if (!strcasecmp(argv[0],"repl-backlog-ttl") && argc == 2) {
350              server.repl_backlog_time_limit = atoi(argv[1]);
351              if (server.repl_backlog_time_limit < 0) {
352                  err = "repl-backlog-ttl can't be negative ";
353                  goto loaderr;
354              }
355          } else if (!strcasecmp(argv[0],"masterauth") && argc == 2) {
356              zfree(server.masterauth);
357              server.masterauth = argv[1][0] ? zstrdup(argv[1]) : NULL;
358          } else if ((!strcasecmp(argv[0],"slave-serve-stale-data") ||
359                      !strcasecmp(argv[0],"replica-serve-stale-data"))
360                      && argc == 2)
361          {
362              if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {
363                  err = "argument must be 'yes' or 'no'"; goto loaderr;
364              }
365          } else if ((!strcasecmp(argv[0],"slave-read-only") ||
366                      !strcasecmp(argv[0],"replica-read-only"))
367                      && argc == 2)
368          {
369              if ((server.repl_slave_ro = yesnotoi(argv[1])) == -1) {
370                  err = "argument must be 'yes' or 'no'"; goto loaderr;
371              }
372          } else if ((!strcasecmp(argv[0],"slave-ignore-maxmemory") ||
373                      !strcasecmp(argv[0],"replica-ignore-maxmemory"))
374                      && argc == 2)
375          {
376              if ((server.repl_slave_ignore_maxmemory = yesnotoi(argv[1])) == -1) {
377                  err = "argument must be 'yes' or 'no'"; goto loaderr;
378              }
379          } else if (!strcasecmp(argv[0],"rdbcompression") && argc == 2) {
380              if ((server.rdb_compression = yesnotoi(argv[1])) == -1) {
381                  err = "argument must be 'yes' or 'no'"; goto loaderr;
382              }
383          } else if (!strcasecmp(argv[0],"rdbchecksum") && argc == 2) {
384              if ((server.rdb_checksum = yesnotoi(argv[1])) == -1) {
385                  err = "argument must be 'yes' or 'no'"; goto loaderr;
386              }
387          } else if (!strcasecmp(argv[0],"activerehashing") && argc == 2) {
388              if ((server.activerehashing = yesnotoi(argv[1])) == -1) {
389                  err = "argument must be 'yes' or 'no'"; goto loaderr;
390              }
391          } else if (!strcasecmp(argv[0],"lazyfree-lazy-eviction") && argc == 2) {
392              if ((server.lazyfree_lazy_eviction = yesnotoi(argv[1])) == -1) {
393                  err = "argument must be 'yes' or 'no'"; goto loaderr;
394              }
395          } else if (!strcasecmp(argv[0],"lazyfree-lazy-expire") && argc == 2) {
396              if ((server.lazyfree_lazy_expire = yesnotoi(argv[1])) == -1) {
397                  err = "argument must be 'yes' or 'no'"; goto loaderr;
398              }
399          } else if (!strcasecmp(argv[0],"lazyfree-lazy-server-del") && argc == 2){
400              if ((server.lazyfree_lazy_server_del = yesnotoi(argv[1])) == -1) {
401                  err = "argument must be 'yes' or 'no'"; goto loaderr;
402              }
403          } else if ((!strcasecmp(argv[0],"slave-lazy-flush") ||
404                      !strcasecmp(argv[0],"replica-lazy-flush")) && argc == 2)
405          {
406              if ((server.repl_slave_lazy_flush = yesnotoi(argv[1])) == -1) {
407                  err = "argument must be 'yes' or 'no'"; goto loaderr;
408              }
409          } else if (!strcasecmp(argv[0],"activedefrag") && argc == 2) {
410              if ((server.active_defrag_enabled = yesnotoi(argv[1])) == -1) {
411                  err = "argument must be 'yes' or 'no'"; goto loaderr;
412              }
413              if (server.active_defrag_enabled) {
414  #ifndef HAVE_DEFRAG
415                  err = "active defrag can't be enabled without proper jemalloc support"; goto loaderr;
416  #endif
417              }
418          } else if (!strcasecmp(argv[0],"daemonize") && argc == 2) {
419              if ((server.daemonize = yesnotoi(argv[1])) == -1) {
420                  err = "argument must be 'yes' or 'no'"; goto loaderr;
421              }
422          } else if (!strcasecmp(argv[0],"dynamic-hz") && argc == 2) {
423              if ((server.dynamic_hz = yesnotoi(argv[1])) == -1) {
424                  err = "argument must be 'yes' or 'no'"; goto loaderr;
425              }
426          } else if (!strcasecmp(argv[0],"hz") && argc == 2) {
427              server.config_hz = atoi(argv[1]);
428              if (server.config_hz < CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;
429              if (server.config_hz > CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;
430          } else if (!strcasecmp(argv[0],"appendonly") && argc == 2) {
431              int yes;
432              if ((yes = yesnotoi(argv[1])) == -1) {
433                  err = "argument must be 'yes' or 'no'"; goto loaderr;
434              }
435              server.aof_state = yes ? AOF_ON : AOF_OFF;
436          } else if (!strcasecmp(argv[0],"appendfilename") && argc == 2) {
437              if (!pathIsBaseName(argv[1])) {
438                  err = "appendfilename can't be a path, just a filename";
439                  goto loaderr;
440              }
441              zfree(server.aof_filename);
442              server.aof_filename = zstrdup(argv[1]);
443          } else if (!strcasecmp(argv[0],"no-appendfsync-on-rewrite")
444                     && argc == 2) {
445              if ((server.aof_no_fsync_on_rewrite= yesnotoi(argv[1])) == -1) {
446                  err = "argument must be 'yes' or 'no'"; goto loaderr;
447              }
448          } else if (!strcasecmp(argv[0],"appendfsync") && argc == 2) {
449              server.aof_fsync = configEnumGetValue(aof_fsync_enum,argv[1]);
450              if (server.aof_fsync == INT_MIN) {
451                  err = "argument must be 'no', 'always' or 'everysec'";
452                  goto loaderr;
453              }
454          } else if (!strcasecmp(argv[0],"auto-aof-rewrite-percentage") &&
455                     argc == 2)
456          {
457              server.aof_rewrite_perc = atoi(argv[1]);
458              if (server.aof_rewrite_perc < 0) {
459                  err = "Invalid negative percentage for AOF auto rewrite";
460                  goto loaderr;
461              }
462          } else if (!strcasecmp(argv[0],"auto-aof-rewrite-min-size") &&
463                     argc == 2)
464          {
465              server.aof_rewrite_min_size = memtoll(argv[1],NULL);
466          } else if (!strcasecmp(argv[0],"aof-rewrite-incremental-fsync") &&
467                     argc == 2)
468          {
469              if ((server.aof_rewrite_incremental_fsync =
470                   yesnotoi(argv[1])) == -1) {
471                  err = "argument must be 'yes' or 'no'"; goto loaderr;
472              }
473          } else if (!strcasecmp(argv[0],"rdb-save-incremental-fsync") &&
474                     argc == 2)
475          {
476              if ((server.rdb_save_incremental_fsync =
477                   yesnotoi(argv[1])) == -1) {
478                  err = "argument must be 'yes' or 'no'"; goto loaderr;
479              }
480          } else if (!strcasecmp(argv[0],"aof-load-truncated") && argc == 2) {
481              if ((server.aof_load_truncated = yesnotoi(argv[1])) == -1) {
482                  err = "argument must be 'yes' or 'no'"; goto loaderr;
483              }
484          } else if (!strcasecmp(argv[0],"aof-use-rdb-preamble") && argc == 2) {
485              if ((server.aof_use_rdb_preamble = yesnotoi(argv[1])) == -1) {
486                  err = "argument must be 'yes' or 'no'"; goto loaderr;
487              }
488          } else if (!strcasecmp(argv[0],"requirepass") && argc == 2) {
489              if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {
490                  err = "Password is longer than CONFIG_AUTHPASS_MAX_LEN";
491                  goto loaderr;
492              }
493              server.requirepass = argv[1][0] ? zstrdup(argv[1]) : NULL;
494          } else if (!strcasecmp(argv[0],"pidfile") && argc == 2) {
495              zfree(server.pidfile);
496              server.pidfile = zstrdup(argv[1]);
497          } else if (!strcasecmp(argv[0],"dbfilename") && argc == 2) {
498              if (!pathIsBaseName(argv[1])) {
499                  err = "dbfilename can't be a path, just a filename";
500                  goto loaderr;
501              }
502              zfree(server.rdb_filename);
503              server.rdb_filename = zstrdup(argv[1]);
504          } else if (!strcasecmp(argv[0],"active-defrag-threshold-lower") && argc == 2) {
505              server.active_defrag_threshold_lower = atoi(argv[1]);
506              if (server.active_defrag_threshold_lower < 0 ||
507                  server.active_defrag_threshold_lower > 1000) {
508                  err = "active-defrag-threshold-lower must be between 0 and 1000";
509                  goto loaderr;
510              }
511          } else if (!strcasecmp(argv[0],"active-defrag-threshold-upper") && argc == 2) {
512              server.active_defrag_threshold_upper = atoi(argv[1]);
513              if (server.active_defrag_threshold_upper < 0 ||
514                  server.active_defrag_threshold_upper > 1000) {
515                  err = "active-defrag-threshold-upper must be between 0 and 1000";
516                  goto loaderr;
517              }
518          } else if (!strcasecmp(argv[0],"active-defrag-ignore-bytes") && argc == 2) {
519              server.active_defrag_ignore_bytes = memtoll(argv[1], NULL);
520              if (server.active_defrag_ignore_bytes <= 0) {
521                  err = "active-defrag-ignore-bytes must above 0";
522                  goto loaderr;
523              }
524          } else if (!strcasecmp(argv[0],"active-defrag-cycle-min") && argc == 2) {
525              server.active_defrag_cycle_min = atoi(argv[1]);
526              if (server.active_defrag_cycle_min < 1 || server.active_defrag_cycle_min > 99) {
527                  err = "active-defrag-cycle-min must be between 1 and 99";
528                  goto loaderr;
529              }
530          } else if (!strcasecmp(argv[0],"active-defrag-cycle-max") && argc == 2) {
531              server.active_defrag_cycle_max = atoi(argv[1]);
532              if (server.active_defrag_cycle_max < 1 || server.active_defrag_cycle_max > 99) {
533                  err = "active-defrag-cycle-max must be between 1 and 99";
534                  goto loaderr;
535              }
536          } else if (!strcasecmp(argv[0],"active-defrag-max-scan-fields") && argc == 2) {
537              server.active_defrag_max_scan_fields = strtoll(argv[1],NULL,10);
538              if (server.active_defrag_max_scan_fields < 1) {
539                  err = "active-defrag-max-scan-fields must be positive";
540                  goto loaderr;
541              }
542          } else if (!strcasecmp(argv[0],"hash-max-ziplist-entries") && argc == 2) {
543              server.hash_max_ziplist_entries = memtoll(argv[1], NULL);
544          } else if (!strcasecmp(argv[0],"hash-max-ziplist-value") && argc == 2) {
545              server.hash_max_ziplist_value = memtoll(argv[1], NULL);
546          } else if (!strcasecmp(argv[0],"stream-node-max-bytes") && argc == 2) {
547              server.stream_node_max_bytes = memtoll(argv[1], NULL);
548          } else if (!strcasecmp(argv[0],"stream-node-max-entries") && argc == 2) {
549              server.stream_node_max_entries = atoi(argv[1]);
550          } else if (!strcasecmp(argv[0],"list-max-ziplist-entries") && argc == 2){
551          } else if (!strcasecmp(argv[0],"list-max-ziplist-value") && argc == 2) {
552          } else if (!strcasecmp(argv[0],"list-max-ziplist-size") && argc == 2) {
553              server.list_max_ziplist_size = atoi(argv[1]);
554          } else if (!strcasecmp(argv[0],"list-compress-depth") && argc == 2) {
555              server.list_compress_depth = atoi(argv[1]);
556          } else if (!strcasecmp(argv[0],"set-max-intset-entries") && argc == 2) {
557              server.set_max_intset_entries = memtoll(argv[1], NULL);
558          } else if (!strcasecmp(argv[0],"zset-max-ziplist-entries") && argc == 2) {
559              server.zset_max_ziplist_entries = memtoll(argv[1], NULL);
560          } else if (!strcasecmp(argv[0],"zset-max-ziplist-value") && argc == 2) {
561              server.zset_max_ziplist_value = memtoll(argv[1], NULL);
562          } else if (!strcasecmp(argv[0],"hll-sparse-max-bytes") && argc == 2) {
563              server.hll_sparse_max_bytes = memtoll(argv[1], NULL);
564          } else if (!strcasecmp(argv[0],"rename-command") && argc == 3) {
565              struct redisCommand *cmd = lookupCommand(argv[1]);
566              int retval;
567              if (!cmd) {
568                  err = "No such command in rename-command";
569                  goto loaderr;
570              }
571              retval = dictDelete(server.commands, argv[1]);
572              serverAssert(retval == DICT_OK);
573              if (sdslen(argv[2]) != 0) {
574                  sds copy = sdsdup(argv[2]);
575                  retval = dictAdd(server.commands, copy, cmd);
576                  if (retval != DICT_OK) {
577                      sdsfree(copy);
578                      err = "Target command name already exists"; goto loaderr;
579                  }
580              }
581          } else if (!strcasecmp(argv[0],"cluster-enabled") && argc == 2) {
582              if ((server.cluster_enabled = yesnotoi(argv[1])) == -1) {
583                  err = "argument must be 'yes' or 'no'"; goto loaderr;
584              }
585          } else if (!strcasecmp(argv[0],"cluster-config-file") && argc == 2) {
586              zfree(server.cluster_configfile);
587              server.cluster_configfile = zstrdup(argv[1]);
588          } else if (!strcasecmp(argv[0],"cluster-announce-ip") && argc == 2) {
589              zfree(server.cluster_announce_ip);
590              server.cluster_announce_ip = zstrdup(argv[1]);
591          } else if (!strcasecmp(argv[0],"cluster-announce-port") && argc == 2) {
592              server.cluster_announce_port = atoi(argv[1]);
593              if (server.cluster_announce_port < 0 ||
594                  server.cluster_announce_port > 65535)
595              {
596                  err = "Invalid port"; goto loaderr;
597              }
598          } else if (!strcasecmp(argv[0],"cluster-announce-bus-port") &&
599                     argc == 2)
600          {
601              server.cluster_announce_bus_port = atoi(argv[1]);
602              if (server.cluster_announce_bus_port < 0 ||
603                  server.cluster_announce_bus_port > 65535)
604              {
605                  err = "Invalid port"; goto loaderr;
606              }
607          } else if (!strcasecmp(argv[0],"cluster-require-full-coverage") &&
608                      argc == 2)
609          {
610              if ((server.cluster_require_full_coverage = yesnotoi(argv[1])) == -1)
611              {
612                  err = "argument must be 'yes' or 'no'"; goto loaderr;
613              }
614          } else if (!strcasecmp(argv[0],"cluster-node-timeout") && argc == 2) {
615              server.cluster_node_timeout = strtoll(argv[1],NULL,10);
616              if (server.cluster_node_timeout <= 0) {
617                  err = "cluster node timeout must be 1 or greater"; goto loaderr;
618              }
619          } else if (!strcasecmp(argv[0],"cluster-migration-barrier")
620                     && argc == 2)
621          {
622              server.cluster_migration_barrier = atoi(argv[1]);
623              if (server.cluster_migration_barrier < 0) {
624                  err = "cluster migration barrier must zero or positive";
625                  goto loaderr;
626              }
627          } else if ((!strcasecmp(argv[0],"cluster-slave-validity-factor") ||
628                      !strcasecmp(argv[0],"cluster-replica-validity-factor"))
629                     && argc == 2)
630          {
631              server.cluster_slave_validity_factor = atoi(argv[1]);
632              if (server.cluster_slave_validity_factor < 0) {
633                  err = "cluster replica validity factor must be zero or positive";
634                  goto loaderr;
635              }
636          } else if ((!strcasecmp(argv[0],"cluster-slave-no-failover") ||
637                      !strcasecmp(argv[0],"cluster-replica-no-failover")) &&
638                     argc == 2)
639          {
640              server.cluster_slave_no_failover = yesnotoi(argv[1]);
641              if (server.cluster_slave_no_failover == -1) {
642                  err = "argument must be 'yes' or 'no'";
643                  goto loaderr;
644              }
645          } else if (!strcasecmp(argv[0],"lua-time-limit") && argc == 2) {
646              server.lua_time_limit = strtoll(argv[1],NULL,10);
647          } else if (!strcasecmp(argv[0],"lua-replicate-commands") && argc == 2) {
648              server.lua_always_replicate_commands = yesnotoi(argv[1]);
649          } else if (!strcasecmp(argv[0],"slowlog-log-slower-than") &&
650                     argc == 2)
651          {
652              server.slowlog_log_slower_than = strtoll(argv[1],NULL,10);
653          } else if (!strcasecmp(argv[0],"latency-monitor-threshold") &&
654                     argc == 2)
655          {
656              server.latency_monitor_threshold = strtoll(argv[1],NULL,10);
657              if (server.latency_monitor_threshold < 0) {
658                  err = "The latency threshold can't be negative";
659                  goto loaderr;
660              }
661          } else if (!strcasecmp(argv[0],"slowlog-max-len") && argc == 2) {
662              server.slowlog_max_len = (PORT_ULONG)(strtoll(argv[1],NULL,10));    WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
663          } else if (!strcasecmp(argv[0],"client-output-buffer-limit") &&
664                     argc == 5)
665          {
666              int class = getClientTypeByName(argv[1]);
667              PORT_ULONGLONG hard, soft;
668              int soft_seconds;
669              if (class == -1 || class == CLIENT_TYPE_MASTER) {
670                  err = "Unrecognized client limit class: the user specified "
671                  "an invalid one, or 'master' which has no buffer limits.";
672                  goto loaderr;
673              }
674              hard = memtoll(argv[2],NULL);
675              soft = memtoll(argv[3],NULL);
676              soft_seconds = atoi(argv[4]);
677              if (soft_seconds < 0) {
678                  err = "Negative number of seconds in soft limit is invalid";
679                  goto loaderr;
680              }
681              server.client_obuf_limits[class].hard_limit_bytes = hard;
682              server.client_obuf_limits[class].soft_limit_bytes = soft;
683              server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;
684          } else if (!strcasecmp(argv[0],"stop-writes-on-bgsave-error") &&
685                     argc == 2) {
686              if ((server.stop_writes_on_bgsave_err = yesnotoi(argv[1])) == -1) {
687                  err = "argument must be 'yes' or 'no'"; goto loaderr;
688              }
689          } else if ((!strcasecmp(argv[0],"slave-priority") ||
690                      !strcasecmp(argv[0],"replica-priority")) && argc == 2)
691          {
692              server.slave_priority = atoi(argv[1]);
693          } else if ((!strcasecmp(argv[0],"slave-announce-ip") ||
694                      !strcasecmp(argv[0],"replica-announce-ip")) && argc == 2)
695          {
696              zfree(server.slave_announce_ip);
697              server.slave_announce_ip = zstrdup(argv[1]);
698          } else if ((!strcasecmp(argv[0],"slave-announce-port") ||
699                      !strcasecmp(argv[0],"replica-announce-port")) && argc == 2)
700          {
701              server.slave_announce_port = atoi(argv[1]);
702              if (server.slave_announce_port < 0 ||
703                  server.slave_announce_port > 65535)
704              {
705                  err = "Invalid port"; goto loaderr;
706              }
707          } else if ((!strcasecmp(argv[0],"min-slaves-to-write") ||
708                      !strcasecmp(argv[0],"min-replicas-to-write")) && argc == 2)
709          {
710              server.repl_min_slaves_to_write = atoi(argv[1]);
711              if (server.repl_min_slaves_to_write < 0) {
712                  err = "Invalid value for min-replicas-to-write."; goto loaderr;
713              }
714          } else if ((!strcasecmp(argv[0],"min-slaves-max-lag") ||
715                      !strcasecmp(argv[0],"min-replicas-max-lag")) && argc == 2)
716          {
717              server.repl_min_slaves_max_lag = atoi(argv[1]);
718              if (server.repl_min_slaves_max_lag < 0) {
719                  err = "Invalid value for min-replicas-max-lag."; goto loaderr;
720              }
721          } else if (!strcasecmp(argv[0],"notify-keyspace-events") && argc == 2) {
722              int flags = keyspaceEventsStringToFlags(argv[1]);
723              if (flags == -1) {
724                  err = "Invalid event class character. Use 'g$lshzxeA'.";
725                  goto loaderr;
726              }
727              server.notify_keyspace_events = flags;
728          } else if (!strcasecmp(argv[0],"supervised") && argc == 2) {
729              server.supervised_mode =
730                  configEnumGetValue(supervised_mode_enum,argv[1]);
731              if (server.supervised_mode == INT_MIN) {
732                  err = "Invalid option for 'supervised'. "
733                      "Allowed values: 'upstart', 'systemd', 'auto', or 'no'";
734                  goto loaderr;
735              }
736          } else if (!strcasecmp(argv[0],"loadmodule") && argc >= 2) {
737              queueLoadModule(argv[1],&argv[2],argc-2);
738          } else if (!strcasecmp(argv[0],"sentinel")) {
739              if (argc != 1) {
740                  if (!server.sentinel_mode) {
741                      err = "sentinel directive while not in sentinel mode";
742                      goto loaderr;
743                  }
744                  err = sentinelHandleConfiguration(argv+1,argc-1);
745                  if (err) goto loaderr;
746              }
747  #ifdef _WIN32
748          } else if (!strcasecmp(argv[0], "service-name")) {
749          } else if (!strcasecmp(argv[0], "persistence-available")) {
750              if (strcasecmp(argv[1], "no") == 0) {
751                  int retval;
752                  sds bgsave;
753                  sds bgrewriteaof;
754                  sds replconf;
755                  sds psync;
756                  sds sync;
757                  bgsave = sdsnew("bgsave");
758                  bgrewriteaof = sdsnew("bgrewriteaof");
759                  replconf = sdsnew("replconf");
760                  psync = sdsnew("psync");
761                  sync = sdsnew("sync");
762                  retval = dictDelete(server.commands, bgsave);
763                  serverAssert(retval == DICT_OK);
764                  retval = dictDelete(server.commands, bgrewriteaof);
765                  serverAssert(retval == DICT_OK);
766                  retval = dictDelete(server.commands, replconf);
767                  serverAssert(retval == DICT_OK);
768                  retval = dictDelete(server.commands, psync);
769                  serverAssert(retval == DICT_OK);
770                  retval = dictDelete(server.commands, sync);
771                  serverAssert(retval == DICT_OK);
772                  sdsfree(bgsave);
773                  sdsfree(bgrewriteaof);
774                  sdsfree(replconf);
775                  sdsfree(psync);
776                  sdsfree(sync);
777              }
778  #endif
779          } else {
780              err = "Bad directive or wrong number of arguments"; goto loaderr;
781          }
782          sdsfreesplitres(argv,argc);
783      }
784      if (server.cluster_enabled && server.masterhost) {
785          linenum = slaveof_linenum;
786          i = linenum-1;
787          err = "replicaof directive not allowed in cluster mode";
788          goto loaderr;
789      }
790      sdsfreesplitres(lines,totlines);
791      return;
792  loaderr:
793  #ifdef _WIN32
794      serverLog(LL_WARNING, "\n*** FATAL CONFIG FILE ERROR ***\n");
795      serverLog(LL_WARNING, "Reading the configuration file, at line %d\n", linenum);
796      serverLog(LL_WARNING, ">>> '%s'\n", lines[i]);
797      serverLog(LL_WARNING, "%s\n", err);
798  #else
799      fprintf(stderr, "\n*** FATAL CONFIG FILE ERROR ***\n");
800      fprintf(stderr, "Reading the configuration file, at line %d\n", linenum);
801      fprintf(stderr, ">>> '%s'\n", lines[i]);
802      fprintf(stderr, "%s\n", err);
803  #endif
804      exit(1);
805  }
806  void loadServerConfig(char *filename, char *options) {
807      sds config = sdsempty();
808      char buf[CONFIG_MAX_LINE+1];
809      if (filename) {
810          FILE *fp;
811          if (filename[0] == '-' && filename[1] == '\0') {
812              fp = stdin;
813          } else {
814              if ((fp = fopen(filename,IF_WIN32("rb","r"))) == NULL) {
815                  serverLog(LL_WARNING,
816                      "Fatal error, can't open config file '%s'", filename);
817                  exit(1);
818              }
819          }
820          while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)
821              config = sdscat(config,buf);
822          if (fp != stdin) fclose(fp);
823      }
824      if (options) {
825          config = sdscat(config,"\n");
826          config = sdscat(config,options);
827      }
828      loadServerConfigFromString(config);
829      sdsfree(config);
830  }
831  #define config_set_bool_field(_name,_var) \
832      } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \
833          int yn = yesnotoi(o->ptr); \
834          if (yn == -1) goto badfmt; \
835          _var = yn;
836  #define config_set_numerical_field(_name,_var,min,max) \
837      } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \
838          if (getLongLongFromObject(o,&ll) == C_ERR) goto badfmt; \
839          if (min != LLONG_MIN && ll < min) goto badfmt; \
840          if (max != LLONG_MAX && ll > max) goto badfmt; \
841          _var = ll;
842  #define config_set_memory_field(_name,_var) \
843      } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \
844          ll = memtoll(o->ptr,&err); \
845          if (err || ll < 0) goto badfmt; \
846          _var = ll;
847  #define config_set_enum_field(_name,_var,_enumvar) \
848      } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \
849          int enumval = configEnumGetValue(_enumvar,o->ptr); \
850          if (enumval == INT_MIN) goto badfmt; \
851          _var = enumval;
852  #define config_set_special_field(_name) \
853      } else if (!strcasecmp(c->argv[2]->ptr,_name)) {
854  #define config_set_special_field_with_alias(_name1,_name2) \
855      } else if (!strcasecmp(c->argv[2]->ptr,_name1) || \
856                 !strcasecmp(c->argv[2]->ptr,_name2)) {
857  #define config_set_else } else
858  void configSetCommand(client *c) {
859      robj *o;
860      PORT_LONGLONG ll;
861      int err;
862      serverAssertWithInfo(c,c->argv[2],sdsEncodedObject(c->argv[2]));
863      serverAssertWithInfo(c,c->argv[3],sdsEncodedObject(c->argv[3]));
864      o = c->argv[3];
865      if (0) { &bsol;* this starts the config_set macros else-if chain. */
866      config_set_special_field("dbfilename") {
867          if (!pathIsBaseName(o->ptr)) {
868              addReplyError(c, "dbfilename can't be a path, just a filename");
869              return;
870          }
871          zfree(server.rdb_filename);
872          server.rdb_filename = zstrdup(o->ptr);
873      } config_set_special_field("requirepass") {
874          if (sdslen(o->ptr) > CONFIG_AUTHPASS_MAX_LEN) goto badfmt;
875          zfree(server.requirepass);
876          server.requirepass = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
877      } config_set_special_field("masterauth") {
878          zfree(server.masterauth);
879          server.masterauth = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
880      } config_set_special_field("cluster-announce-ip") {
881          zfree(server.cluster_announce_ip);
882          server.cluster_announce_ip = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
883      } config_set_special_field("maxclients") {
884          int orig_value = server.maxclients;
885          if (getLongLongFromObject(o,&ll) == C_ERR || ll < 1) goto badfmt;
886          server.maxclients = (PORT_ULONGLONG)ll;                                            WIN_PORT_FIX &bsol;* cast (PORT_ULONGLONG) */
887          if (ll > orig_value) {
888              adjustOpenFilesLimit();
889              if (server.maxclients != ll) {
890                  addReplyErrorFormat(c,"The operating system is not able to handle the specified number of clients, try with %lld", server.maxclients);
891                  server.maxclients = orig_value;
892                  return;
893              }
894              if ((unsigned int) aeGetSetSize(server.el) <
895                  server.maxclients + CONFIG_FDSET_INCR)
896              {
897                  if (aeResizeSetSize(server.el,
898                      server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)
899                  {
900                      addReplyError(c,"The event loop API used by Redis is not able to handle the specified number of clients");
901                      server.maxclients = orig_value;
902                      return;
903                  }
904              }
905          }
906      } config_set_special_field("appendonly") {
907          int enable = yesnotoi(o->ptr);
908          if (enable == -1) goto badfmt;
909          if (enable == 0 && server.aof_state != AOF_OFF) {
910              stopAppendOnly();
911          } else if (enable && server.aof_state == AOF_OFF) {
912              if (startAppendOnly() == C_ERR) {
913                  addReplyError(c,
914                      "Unable to turn on AOF. Check server logs.");
915                  return;
916              }
917          }
918      } config_set_special_field("save") {
919          int vlen, j;
920          sds *v = sdssplitlen(o->ptr,sdslen(o->ptr)," ",1,&vlen);
921          if (vlen & 1) {
922              sdsfreesplitres(v,vlen);
923              goto badfmt;
924          }
925          for (j = 0; j < vlen; j++) {
926              char *eptr;
927              PORT_LONG val;
928              val = strtoll(v[j], &eptr, 10);
929              if (eptr[0] != '\0' ||
930                  ((j & 1) == 0 && val < 1) ||
931                  ((j & 1) == 1 && val < 0)) {
932                  sdsfreesplitres(v,vlen);
933                  goto badfmt;
934              }
935          }
936          resetServerSaveParams();
937          for (j = 0; j < vlen; j += 2) {
938              time_t seconds;
939              int changes;
940              seconds = strtoll(v[j],NULL,10);
941              changes = strtoll(v[j+1],NULL,10);
942              appendServerSaveParams(seconds, changes);
943          }
944          sdsfreesplitres(v,vlen);
945      } config_set_special_field("dir") {
946          if (chdir((char*)o->ptr) == -1) {
947              addReplyErrorFormat(c,"Changing directory: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
948              return;
949          }
950      } config_set_special_field("client-output-buffer-limit") {
951          int vlen, j;
952          sds *v = sdssplitlen(o->ptr,sdslen(o->ptr)," ",1,&vlen);
953          if (vlen % 4) {
954              sdsfreesplitres(v,vlen);
955              goto badfmt;
956          }
957          for (j = 0; j < vlen; j++) {
958              PORT_LONG val;
959              if ((j % 4) == 0) {
960                  int class = getClientTypeByName(v[j]);
961                  if (class == -1 || class == CLIENT_TYPE_MASTER) {
962                      sdsfreesplitres(v,vlen);
963                      goto badfmt;
964                  }
965              } else {
966                  val = memtoll(v[j], &err);
967                  if (err || val < 0) {
968                      sdsfreesplitres(v,vlen);
969                      goto badfmt;
970                  }
971              }
972          }
973          for (j = 0; j < vlen; j += 4) {
974              int class;
975              PORT_ULONGLONG hard, soft;
976              int soft_seconds;
977              class = getClientTypeByName(v[j]);
978              hard = memtoll(v[j+1],NULL);
979              soft = memtoll(v[j+2],NULL);
980              soft_seconds = strtoll(v[j+3],NULL,10);
981              server.client_obuf_limits[class].hard_limit_bytes = hard;
982              server.client_obuf_limits[class].soft_limit_bytes = soft;
983              server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;
984          }
985          sdsfreesplitres(v,vlen);
986      } config_set_special_field("notify-keyspace-events") {
987          int flags = keyspaceEventsStringToFlags(o->ptr);
988          if (flags == -1) goto badfmt;
989          server.notify_keyspace_events = flags;
990      } config_set_special_field_with_alias("slave-announce-ip",
991                                            "replica-announce-ip")
992      {
993          zfree(server.slave_announce_ip);
994          server.slave_announce_ip = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
995      } config_set_bool_field(
996        "rdbcompression", server.rdb_compression) {
997      } config_set_bool_field(
998        "repl-disable-tcp-nodelay",server.repl_disable_tcp_nodelay) {
999      } config_set_bool_field(
1000        "repl-diskless-sync",server.repl_diskless_sync) {
1001      } config_set_bool_field(
1002        "cluster-require-full-coverage",server.cluster_require_full_coverage) {
1003      } config_set_bool_field(
1004        "cluster-slave-no-failover",server.cluster_slave_no_failover) {
1005      } config_set_bool_field(
1006        "cluster-replica-no-failover",server.cluster_slave_no_failover) {
1007      } config_set_bool_field(
1008        "aof-rewrite-incremental-fsync",server.aof_rewrite_incremental_fsync) {
1009      } config_set_bool_field(
1010        "rdb-save-incremental-fsync",server.rdb_save_incremental_fsync) {
1011      } config_set_bool_field(
1012        "aof-load-truncated",server.aof_load_truncated) {
1013      } config_set_bool_field(
1014        "aof-use-rdb-preamble",server.aof_use_rdb_preamble) {
1015      } config_set_bool_field(
1016        "slave-serve-stale-data",server.repl_serve_stale_data) {
1017      } config_set_bool_field(
1018        "replica-serve-stale-data",server.repl_serve_stale_data) {
1019      } config_set_bool_field(
1020        "slave-read-only",server.repl_slave_ro) {
1021      } config_set_bool_field(
1022        "replica-read-only",server.repl_slave_ro) {
1023      } config_set_bool_field(
1024        "slave-ignore-maxmemory",server.repl_slave_ignore_maxmemory) {
1025      } config_set_bool_field(
1026        "replica-ignore-maxmemory",server.repl_slave_ignore_maxmemory) {
1027      } config_set_bool_field(
1028        "activerehashing",server.activerehashing) {
1029      } config_set_bool_field(
1030        "activedefrag",server.active_defrag_enabled) {
1031  #ifndef HAVE_DEFRAG
1032          if (server.active_defrag_enabled) {
1033              server.active_defrag_enabled = 0;
1034              addReplyError(c,
1035                  "-DISABLED Active defragmentation cannot be enabled: it "
1036                  "requires a Redis server compiled with a modified Jemalloc "
1037                  "like the one shipped by default with the Redis source "
1038                  "distribution");
1039              return;
1040          }
1041  #endif
1042      } config_set_bool_field(
1043        "protected-mode",server.protected_mode) {
1044      } config_set_bool_field(
1045        "stop-writes-on-bgsave-error",server.stop_writes_on_bgsave_err) {
1046      } config_set_bool_field(
1047        "lazyfree-lazy-eviction",server.lazyfree_lazy_eviction) {
1048      } config_set_bool_field(
1049        "lazyfree-lazy-expire",server.lazyfree_lazy_expire) {
1050      } config_set_bool_field(
1051        "lazyfree-lazy-server-del",server.lazyfree_lazy_server_del) {
1052      } config_set_bool_field(
1053        "slave-lazy-flush",server.repl_slave_lazy_flush) {
1054      } config_set_bool_field(
1055        "replica-lazy-flush",server.repl_slave_lazy_flush) {
1056      } config_set_bool_field(
1057        "no-appendfsync-on-rewrite",server.aof_no_fsync_on_rewrite) {
1058      } config_set_bool_field(
1059        "dynamic-hz",server.dynamic_hz) {
1060      } config_set_numerical_field(
1061        "tcp-keepalive",server.tcpkeepalive,0,INT_MAX) {
1062      } config_set_numerical_field(
1063        "maxmemory-samples",server.maxmemory_samples,1,INT_MAX) {
1064      } config_set_numerical_field(
1065        "lfu-log-factor",server.lfu_log_factor,0,INT_MAX) {
1066      } config_set_numerical_field(
1067        "lfu-decay-time",server.lfu_decay_time,0,INT_MAX) {
1068      } config_set_numerical_field(
1069        "timeout",server.maxidletime,0,INT_MAX) {
1070      } config_set_numerical_field(
1071        "active-defrag-threshold-lower",server.active_defrag_threshold_lower,0,1000) {
1072      } config_set_numerical_field(
1073        "active-defrag-threshold-upper",server.active_defrag_threshold_upper,0,1000) {
1074      } config_set_memory_field(
1075        "active-defrag-ignore-bytes",server.active_defrag_ignore_bytes) {
1076      } config_set_numerical_field(
1077        "active-defrag-cycle-min",server.active_defrag_cycle_min,1,99) {
1078      } config_set_numerical_field(
1079        "active-defrag-cycle-max",server.active_defrag_cycle_max,1,99) {
1080      } config_set_numerical_field(
1081        "active-defrag-max-scan-fields",server.active_defrag_max_scan_fields,1,LONG_MAX) {
1082      } config_set_numerical_field(
1083        "auto-aof-rewrite-percentage",server.aof_rewrite_perc,0,INT_MAX){
1084      } config_set_numerical_field(
1085        "hash-max-ziplist-entries",server.hash_max_ziplist_entries,0,LONG_MAX) {
1086      } config_set_numerical_field(
1087        "hash-max-ziplist-value",server.hash_max_ziplist_value,0,LONG_MAX) {
1088      } config_set_numerical_field(
1089        "stream-node-max-bytes",server.stream_node_max_bytes,0,LONG_MAX) {
1090      } config_set_numerical_field(
1091        "stream-node-max-entries",server.stream_node_max_entries,0,LLONG_MAX) {
1092      } config_set_numerical_field(
1093        "list-max-ziplist-size",server.list_max_ziplist_size,INT_MIN,INT_MAX) {
1094      } config_set_numerical_field(
1095        "list-compress-depth",server.list_compress_depth,0,INT_MAX) {
1096      } config_set_numerical_field(
1097        "set-max-intset-entries",server.set_max_intset_entries,0,LONG_MAX) {
1098      } config_set_numerical_field(
1099        "zset-max-ziplist-entries",server.zset_max_ziplist_entries,0,LONG_MAX) {
1100      } config_set_numerical_field(
1101        "zset-max-ziplist-value",server.zset_max_ziplist_value,0,LONG_MAX) {
1102      } config_set_numerical_field(
1103        "hll-sparse-max-bytes",server.hll_sparse_max_bytes,0,LONG_MAX) {
1104      } config_set_numerical_field(
1105        "lua-time-limit",server.lua_time_limit,0,LONG_MAX) {
1106      } config_set_numerical_field(
1107        "slowlog-log-slower-than",server.slowlog_log_slower_than,-1,LLONG_MAX) {
1108      } config_set_numerical_field(
1109        "slowlog-max-len",ll,0,LONG_MAX) {
1110          server.slowlog_max_len = (PORT_ULONG)ll;
1111      } config_set_numerical_field(
1112        "latency-monitor-threshold",server.latency_monitor_threshold,0,LLONG_MAX){
1113      } config_set_numerical_field(
1114        "repl-ping-slave-period",server.repl_ping_slave_period,1,INT_MAX) {
1115      } config_set_numerical_field(
1116        "repl-ping-replica-period",server.repl_ping_slave_period,1,INT_MAX) {
1117      } config_set_numerical_field(
1118        "repl-timeout",server.repl_timeout,1,INT_MAX) {
1119      } config_set_numerical_field(
1120        "repl-backlog-ttl",server.repl_backlog_time_limit,0,LONG_MAX) {
1121      } config_set_numerical_field(
1122        "repl-diskless-sync-delay",server.repl_diskless_sync_delay,0,INT_MAX) {
1123      } config_set_numerical_field(
1124        "slave-priority",server.slave_priority,0,INT_MAX) {
1125      } config_set_numerical_field(
1126        "replica-priority",server.slave_priority,0,INT_MAX) {
1127      } config_set_numerical_field(
1128        "slave-announce-port",server.slave_announce_port,0,65535) {
1129      } config_set_numerical_field(
1130        "replica-announce-port",server.slave_announce_port,0,65535) {
1131      } config_set_numerical_field(
1132        "min-slaves-to-write",server.repl_min_slaves_to_write,0,INT_MAX) {
1133          refreshGoodSlavesCount();
1134      } config_set_numerical_field(
1135        "min-replicas-to-write",server.repl_min_slaves_to_write,0,INT_MAX) {
1136          refreshGoodSlavesCount();
1137      } config_set_numerical_field(
1138        "min-slaves-max-lag",server.repl_min_slaves_max_lag,0,INT_MAX) {
1139          refreshGoodSlavesCount();
1140      } config_set_numerical_field(
1141        "min-replicas-max-lag",server.repl_min_slaves_max_lag,0,INT_MAX) {
1142          refreshGoodSlavesCount();
1143      } config_set_numerical_field(
1144        "cluster-node-timeout",server.cluster_node_timeout,0,LLONG_MAX) {
1145      } config_set_numerical_field(
1146        "cluster-announce-port",server.cluster_announce_port,0,65535) {
1147      } config_set_numerical_field(
1148        "cluster-announce-bus-port",server.cluster_announce_bus_port,0,65535) {
1149      } config_set_numerical_field(
1150        "cluster-migration-barrier",server.cluster_migration_barrier,0,INT_MAX){
1151      } config_set_numerical_field(
1152        "cluster-slave-validity-factor",server.cluster_slave_validity_factor,0,INT_MAX) {
1153      } config_set_numerical_field(
1154        "cluster-replica-validity-factor",server.cluster_slave_validity_factor,0,INT_MAX) {
1155      } config_set_numerical_field(
1156        "hz",server.config_hz,0,INT_MAX) {
1157          if (server.config_hz < CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;
1158          if (server.config_hz > CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;
1159      } config_set_numerical_field(
1160        "watchdog-period",ll,0,INT_MAX) {
1161          if (ll)
1162              enableWatchdog(ll);
1163          else
1164              disableWatchdog();
1165      } config_set_memory_field("maxmemory",server.maxmemory) {
1166          if (server.maxmemory) {
1167              if (server.maxmemory < zmalloc_used_memory()) {
1168                  serverLog(LL_WARNING,"WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in key eviction and/or the inability to accept new write commands depending on the maxmemory-policy.");
1169              }
1170              freeMemoryIfNeededAndSafe();
1171          }
1172      } config_set_memory_field(
1173        "proto-max-bulk-len",server.proto_max_bulk_len) {
1174      } config_set_memory_field(
1175        "client-query-buffer-limit",server.client_max_querybuf_len) {
1176      } config_set_memory_field("repl-backlog-size",ll) {
1177          resizeReplicationBacklog(ll);
1178      } config_set_memory_field("auto-aof-rewrite-min-size",ll) {
1179          server.aof_rewrite_min_size = ll;
1180      } config_set_enum_field(
1181        "loglevel",server.verbosity,loglevel_enum) {
1182  #ifdef _WIN32
1183          setLogVerbosityLevel(server.verbosity);
1184  #endif
1185      } config_set_enum_field(
1186        "maxmemory-policy",server.maxmemory_policy,maxmemory_policy_enum) {
1187      } config_set_enum_field(
1188        "appendfsync",server.aof_fsync,aof_fsync_enum) {
1189      } config_set_else {
1190          addReplyErrorFormat(c,"Unsupported CONFIG parameter: %s",
1191              (char*)c->argv[2]->ptr);
1192          return;
1193      }
1194      addReply(c,shared.ok);
1195      return;
1196  badfmt: &bsol;* Bad format errors */
1197      addReplyErrorFormat(c,"Invalid argument '%s' for CONFIG SET '%s'",
1198              (char*)o->ptr,
1199              (char*)c->argv[2]->ptr);
1200  }
1201  #define config_get_string_field(_name,_var) do { \
1202      if (stringmatch(pattern,_name,1)) { \
1203          addReplyBulkCString(c,_name); \
1204          addReplyBulkCString(c,_var ? _var : ""); \
1205          matches++; \
1206      } \
1207  } while(0);
1208  #define config_get_bool_field(_name,_var) do { \
1209      if (stringmatch(pattern,_name,1)) { \
1210          addReplyBulkCString(c,_name); \
1211          addReplyBulkCString(c,_var ? "yes" : "no"); \
1212          matches++; \
1213      } \
1214  } while(0);
1215  #define config_get_numerical_field(_name,_var) do { \
1216      if (stringmatch(pattern,_name,1)) { \
1217          ll2string(buf,sizeof(buf),_var); \
1218          addReplyBulkCString(c,_name); \
1219          addReplyBulkCString(c,buf); \
1220          matches++; \
1221      } \
1222  } while(0);
1223  #define config_get_enum_field(_name,_var,_enumvar) do { \
1224      if (stringmatch(pattern,_name,1)) { \
1225          addReplyBulkCString(c,_name); \
1226          addReplyBulkCString(c,configEnumGetNameOrUnknown(_enumvar,_var)); \
1227          matches++; \
1228      } \
1229  } while(0);
1230  void configGetCommand(client *c) {
1231      robj *o = c->argv[2];
1232      void *replylen = addDeferredMultiBulkLength(c);
1233      char *pattern = o->ptr;
1234      char buf[128];
1235      int matches = 0;
1236      serverAssertWithInfo(c,o,sdsEncodedObject(o));
1237      config_get_string_field("dbfilename",server.rdb_filename);
1238      config_get_string_field("requirepass",server.requirepass);
1239      config_get_string_field("masterauth",server.masterauth);
1240      config_get_string_field("cluster-announce-ip",server.cluster_announce_ip);
1241      config_get_string_field("unixsocket",server.unixsocket);
1242      config_get_string_field("logfile",server.logfile);
1243      config_get_string_field("pidfile",server.pidfile);
1244      config_get_string_field("slave-announce-ip",server.slave_announce_ip);
1245      config_get_string_field("replica-announce-ip",server.slave_announce_ip);
1246      config_get_numerical_field("maxmemory",server.maxmemory);
1247      config_get_numerical_field("proto-max-bulk-len",server.proto_max_bulk_len);
1248      config_get_numerical_field("client-query-buffer-limit",server.client_max_querybuf_len);
1249      config_get_numerical_field("maxmemory-samples",server.maxmemory_samples);
1250      config_get_numerical_field("lfu-log-factor",server.lfu_log_factor);
1251      config_get_numerical_field("lfu-decay-time",server.lfu_decay_time);
1252      config_get_numerical_field("timeout",server.maxidletime);
1253      config_get_numerical_field("active-defrag-threshold-lower",server.active_defrag_threshold_lower);
1254      config_get_numerical_field("active-defrag-threshold-upper",server.active_defrag_threshold_upper);
1255      config_get_numerical_field("active-defrag-ignore-bytes",server.active_defrag_ignore_bytes);
1256      config_get_numerical_field("active-defrag-cycle-min",server.active_defrag_cycle_min);
1257      config_get_numerical_field("active-defrag-cycle-max",server.active_defrag_cycle_max);
1258      config_get_numerical_field("active-defrag-max-scan-fields",server.active_defrag_max_scan_fields);
1259      config_get_numerical_field("auto-aof-rewrite-percentage",
1260              server.aof_rewrite_perc);
1261      config_get_numerical_field("auto-aof-rewrite-min-size",
1262              server.aof_rewrite_min_size);
1263      config_get_numerical_field("hash-max-ziplist-entries",
1264              server.hash_max_ziplist_entries);
1265      config_get_numerical_field("hash-max-ziplist-value",
1266              server.hash_max_ziplist_value);
1267      config_get_numerical_field("stream-node-max-bytes",
1268              server.stream_node_max_bytes);
1269      config_get_numerical_field("stream-node-max-entries",
1270              server.stream_node_max_entries);
1271      config_get_numerical_field("list-max-ziplist-size",
1272              server.list_max_ziplist_size);
1273      config_get_numerical_field("list-compress-depth",
1274              server.list_compress_depth);
1275      config_get_numerical_field("set-max-intset-entries",
1276              server.set_max_intset_entries);
1277      config_get_numerical_field("zset-max-ziplist-entries",
1278              server.zset_max_ziplist_entries);
1279      config_get_numerical_field("zset-max-ziplist-value",
1280              server.zset_max_ziplist_value);
1281      config_get_numerical_field("hll-sparse-max-bytes",
1282              server.hll_sparse_max_bytes);
1283      config_get_numerical_field("lua-time-limit",server.lua_time_limit);
1284      config_get_numerical_field("slowlog-log-slower-than",
1285              server.slowlog_log_slower_than);
1286      config_get_numerical_field("latency-monitor-threshold",
1287              server.latency_monitor_threshold);
1288      config_get_numerical_field("slowlog-max-len",
1289              server.slowlog_max_len);
1290      config_get_numerical_field("port",server.port);
1291      config_get_numerical_field("cluster-announce-port",server.cluster_announce_port);
1292      config_get_numerical_field("cluster-announce-bus-port",server.cluster_announce_bus_port);
1293      config_get_numerical_field("tcp-backlog",server.tcp_backlog);
1294      config_get_numerical_field("databases",server.dbnum);
1295      config_get_numerical_field("repl-ping-slave-period",server.repl_ping_slave_period);
1296      config_get_numerical_field("repl-ping-replica-period",server.repl_ping_slave_period);
1297      config_get_numerical_field("repl-timeout",server.repl_timeout);
1298      config_get_numerical_field("repl-backlog-size",server.repl_backlog_size);
1299      config_get_numerical_field("repl-backlog-ttl",server.repl_backlog_time_limit);
1300      config_get_numerical_field("maxclients",server.maxclients);
1301      config_get_numerical_field("watchdog-period",server.watchdog_period);
1302      config_get_numerical_field("slave-priority",server.slave_priority);
1303      config_get_numerical_field("replica-priority",server.slave_priority);
1304      config_get_numerical_field("slave-announce-port",server.slave_announce_port);
1305      config_get_numerical_field("replica-announce-port",server.slave_announce_port);
1306      config_get_numerical_field("min-slaves-to-write",server.repl_min_slaves_to_write);
1307      config_get_numerical_field("min-replicas-to-write",server.repl_min_slaves_to_write);
1308      config_get_numerical_field("min-slaves-max-lag",server.repl_min_slaves_max_lag);
1309      config_get_numerical_field("min-replicas-max-lag",server.repl_min_slaves_max_lag);
1310      config_get_numerical_field("hz",server.config_hz);
1311      config_get_numerical_field("cluster-node-timeout",server.cluster_node_timeout);
1312      config_get_numerical_field("cluster-migration-barrier",server.cluster_migration_barrier);
1313      config_get_numerical_field("cluster-slave-validity-factor",server.cluster_slave_validity_factor);
1314      config_get_numerical_field("cluster-replica-validity-factor",server.cluster_slave_validity_factor);
1315      config_get_numerical_field("repl-diskless-sync-delay",server.repl_diskless_sync_delay);
1316      config_get_numerical_field("tcp-keepalive",server.tcpkeepalive);
1317      config_get_bool_field("cluster-require-full-coverage",
1318              server.cluster_require_full_coverage);
1319      config_get_bool_field("cluster-slave-no-failover",
1320              server.cluster_slave_no_failover);
1321      config_get_bool_field("cluster-replica-no-failover",
1322              server.cluster_slave_no_failover);
1323      config_get_bool_field("no-appendfsync-on-rewrite",
1324              server.aof_no_fsync_on_rewrite);
1325      config_get_bool_field("slave-serve-stale-data",
1326              server.repl_serve_stale_data);
1327      config_get_bool_field("replica-serve-stale-data",
1328              server.repl_serve_stale_data);
1329      config_get_bool_field("slave-read-only",
1330              server.repl_slave_ro);
1331      config_get_bool_field("replica-read-only",
1332              server.repl_slave_ro);
1333      config_get_bool_field("slave-ignore-maxmemory",
1334              server.repl_slave_ignore_maxmemory);
1335      config_get_bool_field("replica-ignore-maxmemory",
1336              server.repl_slave_ignore_maxmemory);
1337      config_get_bool_field("stop-writes-on-bgsave-error",
1338              server.stop_writes_on_bgsave_err);
1339      config_get_bool_field("daemonize", server.daemonize);
1340      config_get_bool_field("rdbcompression", server.rdb_compression);
1341      config_get_bool_field("rdbchecksum", server.rdb_checksum);
1342      config_get_bool_field("activerehashing", server.activerehashing);
1343      config_get_bool_field("activedefrag", server.active_defrag_enabled);
1344      config_get_bool_field("protected-mode", server.protected_mode);
1345      config_get_bool_field("repl-disable-tcp-nodelay",
1346              server.repl_disable_tcp_nodelay);
1347      config_get_bool_field("repl-diskless-sync",
1348              server.repl_diskless_sync);
1349      config_get_bool_field("aof-rewrite-incremental-fsync",
1350              server.aof_rewrite_incremental_fsync);
1351      config_get_bool_field("rdb-save-incremental-fsync",
1352              server.rdb_save_incremental_fsync);
1353      config_get_bool_field("aof-load-truncated",
1354              server.aof_load_truncated);
1355      config_get_bool_field("aof-use-rdb-preamble",
1356              server.aof_use_rdb_preamble);
1357      config_get_bool_field("lazyfree-lazy-eviction",
1358              server.lazyfree_lazy_eviction);
1359      config_get_bool_field("lazyfree-lazy-expire",
1360              server.lazyfree_lazy_expire);
1361      config_get_bool_field("lazyfree-lazy-server-del",
1362              server.lazyfree_lazy_server_del);
1363      config_get_bool_field("slave-lazy-flush",
1364              server.repl_slave_lazy_flush);
1365      config_get_bool_field("replica-lazy-flush",
1366              server.repl_slave_lazy_flush);
1367      config_get_bool_field("dynamic-hz",
1368              server.dynamic_hz);
1369      config_get_enum_field("maxmemory-policy",
1370              server.maxmemory_policy,maxmemory_policy_enum);
1371      config_get_enum_field("loglevel",
1372              server.verbosity,loglevel_enum);
1373      config_get_enum_field("supervised",
1374              server.supervised_mode,supervised_mode_enum);
1375      config_get_enum_field("appendfsync",
1376              server.aof_fsync,aof_fsync_enum);
1377  #ifndef _WIN32
1378      config_get_enum_field("syslog-facility",
1379              server.syslog_facility,syslog_facility_enum);
1380  #endif
1381      if (stringmatch(pattern,"appendonly",1)) {
1382          addReplyBulkCString(c,"appendonly");
1383          addReplyBulkCString(c,server.aof_state == AOF_OFF ? "no" : "yes");
1384          matches++;
1385      }
1386      if (stringmatch(pattern,"dir",1)) {
1387          char buf[1024];
1388          if (getcwd(buf,sizeof(buf)) == NULL)
1389              buf[0] = '\0';
1390          addReplyBulkCString(c,"dir");
1391          addReplyBulkCString(c,buf);
1392          matches++;
1393      }
1394      if (stringmatch(pattern,"save",1)) {
1395          sds buf = sdsempty();
1396          int j;
1397          for (j = 0; j < server.saveparamslen; j++) {
1398              buf = sdscatprintf(buf,"%jd %d",
1399                      (intmax_t)server.saveparams[j].seconds,
1400                      server.saveparams[j].changes);
1401              if (j != server.saveparamslen-1)
1402                  buf = sdscatlen(buf," ",1);
1403          }
1404          addReplyBulkCString(c,"save");
1405          addReplyBulkCString(c,buf);
1406          sdsfree(buf);
1407          matches++;
1408      }
1409      if (stringmatch(pattern,"client-output-buffer-limit",1)) {
1410          sds buf = sdsempty();
1411          int j;
1412          for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
1413              buf = sdscatprintf(buf,"%s %llu %llu %Id",                                WIN_PORT_FIX &bsol;* %ld -> %Id */
1414                      getClientTypeName(j),
1415                      server.client_obuf_limits[j].hard_limit_bytes,
1416                      server.client_obuf_limits[j].soft_limit_bytes,
1417                      (PORT_LONG) server.client_obuf_limits[j].soft_limit_seconds);
1418              if (j != CLIENT_TYPE_OBUF_COUNT-1)
1419                  buf = sdscatlen(buf," ",1);
1420          }
1421          addReplyBulkCString(c,"client-output-buffer-limit");
1422          addReplyBulkCString(c,buf);
1423          sdsfree(buf);
1424          matches++;
1425      }
1426      if (stringmatch(pattern,"unixsocketperm",1)) {
1427          char buf[32];
1428          snprintf(buf,sizeof(buf),"%o",server.unixsocketperm);
1429          addReplyBulkCString(c,"unixsocketperm");
1430          addReplyBulkCString(c,buf);
1431          matches++;
1432      }
1433      if (stringmatch(pattern,"slaveof",1) ||
1434          stringmatch(pattern,"replicaof",1))
1435      {
1436          char *optname = stringmatch(pattern,"slaveof",1) ?
1437                          "slaveof" : "replicaof";
1438          char buf[256];
1439          addReplyBulkCString(c,optname);
1440          if (server.masterhost)
1441              snprintf(buf,sizeof(buf),"%s %d",
1442                  server.masterhost, server.masterport);
1443          else
1444              buf[0] = '\0';
1445          addReplyBulkCString(c,buf);
1446          matches++;
1447      }
1448      if (stringmatch(pattern,"notify-keyspace-events",1)) {
1449          robj *flagsobj = createObject(OBJ_STRING,
1450              keyspaceEventsFlagsToString(server.notify_keyspace_events));
1451          addReplyBulkCString(c,"notify-keyspace-events");
1452          addReplyBulk(c,flagsobj);
1453          decrRefCount(flagsobj);
1454          matches++;
1455      }
1456      if (stringmatch(pattern,"bind",1)) {
1457          sds aux = sdsjoin(server.bindaddr,server.bindaddr_count," ");
1458          addReplyBulkCString(c,"bind");
1459          addReplyBulkCString(c,aux);
1460          sdsfree(aux);
1461          matches++;
1462      }
1463      setDeferredMultiBulkLength(c,replylen,(PORT_LONG)matches*2);  WIN_PORT_FIX &bsol;* cat (PORT_LONG) */
1464  }
1465  #define REDIS_CONFIG_REWRITE_SIGNATURE "# Generated by CONFIG REWRITE"
1466  uint64_t dictSdsCaseHash(const void *key);
1467  int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
1468  void dictSdsDestructor(void *privdata, void *val);
1469  void dictListDestructor(void *privdata, void *val);
1470  void rewriteConfigSentinelOption(struct rewriteConfigState *state);
1471  dictType optionToLineDictType = {
1472      dictSdsCaseHash,            &bsol;* hash function */
1473      NULL,                       &bsol;* key dup */
1474      NULL,                       &bsol;* val dup */
1475      dictSdsKeyCaseCompare,      &bsol;* key compare */
1476      dictSdsDestructor,          &bsol;* key destructor */
1477      dictListDestructor          &bsol;* val destructor */
1478  };
1479  dictType optionSetDictType = {
1480      dictSdsCaseHash,            &bsol;* hash function */
1481      NULL,                       &bsol;* key dup */
1482      NULL,                       &bsol;* val dup */
1483      dictSdsKeyCaseCompare,      &bsol;* key compare */
1484      dictSdsDestructor,          &bsol;* key destructor */
1485      NULL                        &bsol;* val destructor */
1486  };
1487  struct rewriteConfigState {
1488      dict *option_to_line; &bsol;* Option -> list of config file lines map */
1489      dict *rewritten;      &bsol;* Dictionary of already processed options */
1490      int numlines;         &bsol;* Number of lines in current config */
1491      sds *lines;           &bsol;* Current lines as an array of sds strings */
1492      int has_tail;         &bsol;* True if we already added directives that were
1493                               not present in the original config file. */
1494  };
1495  void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
1496      state->lines = zrealloc(state->lines, sizeof(char*) * ((PORT_ULONG)state->numlines+1));  WIN_PORT_FIX &bsol;* cat (PORT_ULONG) */
1497      state->lines[state->numlines++] = line;
1498  }
1499  void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {
1500      list *l = dictFetchValue(state->option_to_line,option);
1501      if (l == NULL) {
1502          l = listCreate();
1503          dictAdd(state->option_to_line,sdsdup(option),l);
1504      }
1505      listAddNodeTail(l,(void*)(PORT_LONG)linenum);
1506  }
1507  void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {
1508      sds opt = sdsnew(option);
1509      if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
1510  }
1511  struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
1512      FILE *fp = fopen(path,"r");
1513      if (fp == NULL && errno != ENOENT) return NULL;
1514      char buf[CONFIG_MAX_LINE+1];
1515      int linenum = -1;
1516      struct rewriteConfigState *state = zmalloc(sizeof(*state));
1517      state->option_to_line = dictCreate(&optionToLineDictType,NULL);
1518      state->rewritten = dictCreate(&optionSetDictType,NULL);
1519      state->numlines = 0;
1520      state->lines = NULL;
1521      state->has_tail = 0;
1522      if (fp == NULL) return state;
1523      while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {
1524          int argc;
1525          sds *argv;
1526          sds line = sdstrim(sdsnew(buf),"\r\n\t ");
1527          linenum++; &bsol;* Zero based, so we init at -1 */
1528          if (line[0] == '#' || line[0] == '\0') {
1529              if (!state->has_tail && !strcmp(line,REDIS_CONFIG_REWRITE_SIGNATURE))
1530                  state->has_tail = 1;
1531              rewriteConfigAppendLine(state,line);
1532              continue;
1533          }
1534          argv = sdssplitargs(line,&argc);
1535          if (argv == NULL) {
1536              sds aux = sdsnew("# ??? ");
1537              aux = sdscatsds(aux,line);
1538              sdsfree(line);
1539              rewriteConfigAppendLine(state,aux);
1540              continue;
1541          }
1542          sdstolower(argv[0]); &bsol;* We only want lowercase config directives. */
1543          rewriteConfigAppendLine(state,line);
1544          char *p = strstr(argv[0],"slave");
1545          if (p) {
1546              sds alt = sdsempty();
1547              alt = sdscatlen(alt,argv[0],p-argv[0]);;
1548              alt = sdscatlen(alt,"replica",7);
1549              alt = sdscatlen(alt,p+5,strlen(p+5));
1550              sdsfree(argv[0]);
1551              argv[0] = alt;
1552          }
1553          rewriteConfigAddLineNumberToOption(state,argv[0],linenum);
1554          sdsfreesplitres(argv,argc);
1555      }
1556      fclose(fp);
1557      return state;
1558  }
1559  void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {
1560      sds o = sdsnew(option);
1561      list *l = dictFetchValue(state->option_to_line,o);
1562      rewriteConfigMarkAsProcessed(state,option);
1563      if (!l && !force) {
1564          sdsfree(line);
1565          sdsfree(o);
1566          return;
1567      }
1568      if (l) {
1569          listNode *ln = listFirst(l);
1570          int linenum = (int)((PORT_LONG) ln->value);                             WIN_PORT_FIX &bsol;* cast (int) */
1571          listDelNode(l,ln);
1572          if (listLength(l) == 0) dictDelete(state->option_to_line,o);
1573          sdsfree(state->lines[linenum]);
1574          state->lines[linenum] = line;
1575      } else {
1576          if (!state->has_tail) {
1577              rewriteConfigAppendLine(state,
1578                  sdsnew(REDIS_CONFIG_REWRITE_SIGNATURE));
1579              state->has_tail = 1;
1580          }
1581          rewriteConfigAppendLine(state,line);
1582      }
1583      sdsfree(o);
1584  }
1585  int rewriteConfigFormatMemory(char *buf, size_t len, PORT_LONGLONG bytes) {
1586      int gb = 1024*1024*1024;
1587      int mb = 1024*1024;
1588      int kb = 1024;
1589      if (bytes && (bytes % gb) == 0) {
1590          return snprintf(buf,len,"%lldgb",bytes/gb);
1591      } else if (bytes && (bytes % mb) == 0) {
1592          return snprintf(buf,len,"%lldmb",bytes/mb);
1593      } else if (bytes && (bytes % kb) == 0) {
1594          return snprintf(buf,len,"%lldkb",bytes/kb);
1595      } else {
1596          return snprintf(buf,len,"%lld",bytes);
1597      }
1598  }
1599  void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, PORT_LONGLONG value, PORT_LONGLONG defvalue) {
1600      char buf[64];
1601      int force = value != defvalue;
1602      sds line;
1603      rewriteConfigFormatMemory(buf,sizeof(buf),value);
1604      line = sdscatprintf(sdsempty(),"%s %s",option,buf);
1605      rewriteConfigRewriteLine(state,option,line,force);
1606  }
1607  void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
1608      int force = value != defvalue;
1609      sds line = sdscatprintf(sdsempty(),"%s %s",option,
1610          value ? "yes" : "no");
1611      rewriteConfigRewriteLine(state,option,line,force);
<span onclick='openModal()' class='match'>1612  }
1613  void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {
1614      int force = 1;
</span>1615      sds line;
1616      if (value == NULL) {
1617          rewriteConfigMarkAsProcessed(state,option);
1618          return;
1619      }
1620      if (defvalue && strcmp(value,defvalue) == 0) force = 0;
1621      line = sdsnew(option);
1622      line = sdscatlen(line, " ", 1);
1623      line = sdscatrepr(line, value, strlen(value));
1624      rewriteConfigRewriteLine(state,option,line,force);
1625  }
1626  void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, PORT_LONGLONG value, PORT_LONGLONG defvalue) {
1627      int force = value != defvalue;
1628      sds line = sdscatprintf(sdsempty(),"%s %lld",option,value);
1629      rewriteConfigRewriteLine(state,option,line,force);
1630  }
1631  void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
1632      int force = value != defvalue;
1633      sds line = sdscatprintf(sdsempty(),"%s %o",option,value);
1634      rewriteConfigRewriteLine(state,option,line,force);
1635  }
1636  void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval) {
1637      sds line;
1638      const char *name = configEnumGetNameOrUnknown(ce,value);
1639      int force = value != defval;
1640      line = sdscatprintf(sdsempty(),"%s %s",option,name);
1641      rewriteConfigRewriteLine(state,option,line,force);
1642  }
1643  #ifndef _WIN32
1644  void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {
1645      int value = server.syslog_facility;
1646      int force = value != LOG_LOCAL0;
1647      const char *name = NULL, *option = "syslog-facility";
1648      sds line;
1649      name = configEnumGetNameOrUnknown(syslog_facility_enum,value);
1650      line = sdscatprintf(sdsempty(),"%s %s",option,name);
1651      rewriteConfigRewriteLine(state,option,line,force);
1652  }
1653  #endif
1654  void rewriteConfigSaveOption(struct rewriteConfigState *state) {
1655      int j;
1656      sds line;
1657      for (j = 0; j < server.saveparamslen; j++) {
1658          line = sdscatprintf(sdsempty(),"save %Id %d",                                      WIN_PORT_FIX &bsol;* %ld -> %Id */
1659              (PORT_LONG) server.saveparams[j].seconds, server.saveparams[j].changes);
1660          rewriteConfigRewriteLine(state,"save",line,1);
1661      }
1662      rewriteConfigMarkAsProcessed(state,"save");
1663  }
1664  void rewriteConfigDirOption(struct rewriteConfigState *state) {
1665      char cwd[1024];
1666      if (getcwd(cwd,sizeof(cwd)) == NULL) {
1667          rewriteConfigMarkAsProcessed(state,"dir");
1668          return; &bsol;* no rewrite on error. */
1669      }
1670      rewriteConfigStringOption(state,"dir",cwd,NULL);
1671  }
1672  void rewriteConfigSlaveofOption(struct rewriteConfigState *state, char *option) {
1673      sds line;
1674      if (server.cluster_enabled || server.masterhost == NULL) {
1675          rewriteConfigMarkAsProcessed(state,option);
1676          return;
1677      }
1678      line = sdscatprintf(sdsempty(),"%s %s %d", option,
1679          server.masterhost, server.masterport);
1680      rewriteConfigRewriteLine(state,option,line,1);
1681  }
1682  void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {
1683      int force = server.notify_keyspace_events != 0;
1684      char *option = "notify-keyspace-events";
1685      sds line, flags;
1686      flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);
1687      line = sdsnew(option);
1688      line = sdscatlen(line, " ", 1);
1689      line = sdscatrepr(line, flags, sdslen(flags));
1690      sdsfree(flags);
1691      rewriteConfigRewriteLine(state,option,line,force);
1692  }
1693  void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {
1694      int j;
1695      char *option = "client-output-buffer-limit";
1696      for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
1697          int force = (server.client_obuf_limits[j].hard_limit_bytes !=
1698                      clientBufferLimitsDefaults[j].hard_limit_bytes) ||
1699                      (server.client_obuf_limits[j].soft_limit_bytes !=
1700                      clientBufferLimitsDefaults[j].soft_limit_bytes) ||
1701                      (server.client_obuf_limits[j].soft_limit_seconds !=
1702                      clientBufferLimitsDefaults[j].soft_limit_seconds);
1703          sds line;
1704          char hard[64], soft[64];
1705          rewriteConfigFormatMemory(hard,sizeof(hard),
1706                  server.client_obuf_limits[j].hard_limit_bytes);
1707          rewriteConfigFormatMemory(soft,sizeof(soft),
1708                  server.client_obuf_limits[j].soft_limit_bytes);
1709          char *typename = getClientTypeName(j);
1710          if (!strcmp(typename,"slave")) typename = "replica";
1711          line = sdscatprintf(sdsempty(),"%s %s %s %s %Id", WIN_PORT_FIX &bsol;* %ld -> %Id */
1712                  option, typename, hard, soft,
1713                  (PORT_LONG) server.client_obuf_limits[j].soft_limit_seconds);
1714          rewriteConfigRewriteLine(state,option,line,force);
1715      }
1716  }
1717  void rewriteConfigBindOption(struct rewriteConfigState *state) {
1718      int force = 1;
1719      sds line, addresses;
1720      char *option = "bind";
1721      if (server.bindaddr_count == 0) {
1722          rewriteConfigMarkAsProcessed(state,option);
1723          return;
1724      }
1725      addresses = sdsjoin(server.bindaddr,server.bindaddr_count," ");
1726      line = sdsnew(option);
1727      line = sdscatlen(line, " ", 1);
1728      line = sdscatsds(line, addresses);
1729      sdsfree(addresses);
1730      rewriteConfigRewriteLine(state,option,line,force);
1731  }
1732  sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
1733      sds content = sdsempty();
1734      int j, was_empty = 0;
1735      for (j = 0; j < state->numlines; j++) {
1736          if (sdslen(state->lines[j]) == 0) {
1737              if (was_empty) continue;
1738              was_empty = 1;
1739          } else {
1740              was_empty = 0;
1741          }
1742          content = sdscatsds(content,state->lines[j]);
1743          content = sdscatlen(content,"\n",1);
1744      }
1745      return content;
1746  }
1747  void rewriteConfigReleaseState(struct rewriteConfigState *state) {
1748      sdsfreesplitres(state->lines,state->numlines);
1749      dictRelease(state->option_to_line);
1750      dictRelease(state->rewritten);
1751      zfree(state);
1752  }
1753  void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
1754      dictIterator *di = dictGetIterator(state->option_to_line);
1755      dictEntry *de;
1756      while((de = dictNext(di)) != NULL) {
1757          list *l = dictGetVal(de);
1758          sds option = dictGetKey(de);
1759          if (dictFind(state->rewritten,option) == NULL) {
1760              serverLog(LL_DEBUG,"Not rewritten option: %s", option);
1761              continue;
1762          }
1763          while(listLength(l)) {
1764              listNode *ln = listFirst(l);
1765              int linenum = (int)((PORT_LONG) ln->value);                         WIN_PORT_FIX &bsol;* cast (int) */
1766              sdsfree(state->lines[linenum]);
1767              state->lines[linenum] = sdsempty();
1768              listDelNode(l,ln);
1769          }
1770      }
1771      dictReleaseIterator(di);
1772  }
1773  int rewriteConfigOverwriteFile(char *configfile, sds content) {
1774      int retval = 0;
1775      int fd = open(configfile,O_RDWR|O_CREAT,0644);
1776      int content_size = (int)sdslen(content), padding = 0;                       WIN_PORT_FIX &bsol;* cast (int) */
1777      struct IF_WIN32(_stat64,stat) sb;                                           
1778      sds content_padded;
1779      if (fd == -1) return -1; &bsol;* errno set by open(). */
1780      if (fstat(fd,&sb) == -1) {
1781          close(fd);
1782          return -1; &bsol;* errno set by fstat(). */
1783      }
1784      content_padded = sdsdup(content);
1785      if (content_size < sb.st_size) {
1786          padding = (int)(sb.st_size - content_size);                             WIN_PORT_FIX &bsol;* cast (int) */
1787          content_padded = sdsgrowzero(content_padded,sb.st_size);
1788          content_padded[content_size] = '\n';
1789          memset(content_padded+content_size+1,'#',(size_t)padding-1);            WIN_PORT_FIX &bsol;* cat (size_t) */
1790      }
1791      if (write(fd,content_padded,strlen(content_padded)) == -1) {
1792          retval = -1;
1793          goto cleanup;
1794      }
1795      if (padding) {
1796          if (ftruncate(fd,content_size) == -1) {
1797          }
1798      }
1799  cleanup:
1800      sdsfree(content_padded);
1801      close(fd);
1802      return retval;
1803  }
1804  int rewriteConfig(char *path) {
1805      struct rewriteConfigState *state;
1806      sds newcontent;
1807      int retval;
1808      if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
1809      rewriteConfigYesNoOption(state,"daemonize",server.daemonize,0);
1810      rewriteConfigStringOption(state,"pidfile",server.pidfile,CONFIG_DEFAULT_PID_FILE);
1811      rewriteConfigNumericalOption(state,"port",server.port,CONFIG_DEFAULT_SERVER_PORT);
1812      rewriteConfigNumericalOption(state,"cluster-announce-port",server.cluster_announce_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT);
1813      rewriteConfigNumericalOption(state,"cluster-announce-bus-port",server.cluster_announce_bus_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT);
1814      rewriteConfigNumericalOption(state,"tcp-backlog",server.tcp_backlog,CONFIG_DEFAULT_TCP_BACKLOG);
1815      rewriteConfigBindOption(state);
1816      rewriteConfigStringOption(state,"unixsocket",server.unixsocket,NULL);
1817      rewriteConfigOctalOption(state,"unixsocketperm",server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);
1818      rewriteConfigNumericalOption(state,"timeout",server.maxidletime,CONFIG_DEFAULT_CLIENT_TIMEOUT);
1819      rewriteConfigNumericalOption(state,"tcp-keepalive",server.tcpkeepalive,CONFIG_DEFAULT_TCP_KEEPALIVE);
1820      rewriteConfigNumericalOption(state,"replica-announce-port",server.slave_announce_port,CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT);
1821      rewriteConfigEnumOption(state,"loglevel",server.verbosity,loglevel_enum,CONFIG_DEFAULT_VERBOSITY);
1822      rewriteConfigStringOption(state,"logfile",server.logfile,CONFIG_DEFAULT_LOGFILE);
1823      rewriteConfigYesNoOption(state,"syslog-enabled",server.syslog_enabled,CONFIG_DEFAULT_SYSLOG_ENABLED);
1824      rewriteConfigStringOption(state,"syslog-ident",server.syslog_ident,CONFIG_DEFAULT_SYSLOG_IDENT);
1825  #ifndef _WIN32
1826      rewriteConfigSyslogfacilityOption(state);
1827  #endif
1828      rewriteConfigSaveOption(state);
1829      rewriteConfigNumericalOption(state,"databases",server.dbnum,CONFIG_DEFAULT_DBNUM);
1830      rewriteConfigYesNoOption(state,"stop-writes-on-bgsave-error",server.stop_writes_on_bgsave_err,CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR);
1831      rewriteConfigYesNoOption(state,"rdbcompression",server.rdb_compression,CONFIG_DEFAULT_RDB_COMPRESSION);
1832      rewriteConfigYesNoOption(state,"rdbchecksum",server.rdb_checksum,CONFIG_DEFAULT_RDB_CHECKSUM);
1833      rewriteConfigStringOption(state,"dbfilename",server.rdb_filename,CONFIG_DEFAULT_RDB_FILENAME);
1834      rewriteConfigDirOption(state);
1835      rewriteConfigSlaveofOption(state,"replicaof");
1836      rewriteConfigStringOption(state,"replica-announce-ip",server.slave_announce_ip,CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP);
1837      rewriteConfigStringOption(state,"masterauth",server.masterauth,NULL);
1838      rewriteConfigStringOption(state,"cluster-announce-ip",server.cluster_announce_ip,NULL);
1839      rewriteConfigYesNoOption(state,"replica-serve-stale-data",server.repl_serve_stale_data,CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA);
1840      rewriteConfigYesNoOption(state,"replica-read-only",server.repl_slave_ro,CONFIG_DEFAULT_SLAVE_READ_ONLY);
1841      rewriteConfigYesNoOption(state,"replica-ignore-maxmemory",server.repl_slave_ignore_maxmemory,CONFIG_DEFAULT_SLAVE_IGNORE_MAXMEMORY);
1842      rewriteConfigNumericalOption(state,"repl-ping-replica-period",server.repl_ping_slave_period,CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD);
1843      rewriteConfigNumericalOption(state,"repl-timeout",server.repl_timeout,CONFIG_DEFAULT_REPL_TIMEOUT);
1844      rewriteConfigBytesOption(state,"repl-backlog-size",server.repl_backlog_size,CONFIG_DEFAULT_REPL_BACKLOG_SIZE);
1845      rewriteConfigBytesOption(state,"repl-backlog-ttl",server.repl_backlog_time_limit,CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT);
1846      rewriteConfigYesNoOption(state,"repl-disable-tcp-nodelay",server.repl_disable_tcp_nodelay,CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY);
1847      rewriteConfigYesNoOption(state,"repl-diskless-sync",server.repl_diskless_sync,CONFIG_DEFAULT_REPL_DISKLESS_SYNC);
1848      rewriteConfigNumericalOption(state,"repl-diskless-sync-delay",server.repl_diskless_sync_delay,CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY);
1849      rewriteConfigNumericalOption(state,"replica-priority",server.slave_priority,CONFIG_DEFAULT_SLAVE_PRIORITY);
1850      rewriteConfigNumericalOption(state,"min-replicas-to-write",server.repl_min_slaves_to_write,CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE);
1851      rewriteConfigNumericalOption(state,"min-replicas-max-lag",server.repl_min_slaves_max_lag,CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG);
1852      rewriteConfigStringOption(state,"requirepass",server.requirepass,NULL);
1853      rewriteConfigNumericalOption(state,"maxclients",server.maxclients,CONFIG_DEFAULT_MAX_CLIENTS);
1854      rewriteConfigBytesOption(state,"maxmemory",server.maxmemory,CONFIG_DEFAULT_MAXMEMORY);
1855      rewriteConfigBytesOption(state,"proto-max-bulk-len",server.proto_max_bulk_len,CONFIG_DEFAULT_PROTO_MAX_BULK_LEN);
1856      rewriteConfigBytesOption(state,"client-query-buffer-limit",server.client_max_querybuf_len,PROTO_MAX_QUERYBUF_LEN);
1857      rewriteConfigEnumOption(state,"maxmemory-policy",server.maxmemory_policy,maxmemory_policy_enum,CONFIG_DEFAULT_MAXMEMORY_POLICY);
1858      rewriteConfigNumericalOption(state,"maxmemory-samples",server.maxmemory_samples,CONFIG_DEFAULT_MAXMEMORY_SAMPLES);
1859      rewriteConfigNumericalOption(state,"lfu-log-factor",server.lfu_log_factor,CONFIG_DEFAULT_LFU_LOG_FACTOR);
1860      rewriteConfigNumericalOption(state,"lfu-decay-time",server.lfu_decay_time,CONFIG_DEFAULT_LFU_DECAY_TIME);
1861      rewriteConfigNumericalOption(state,"active-defrag-threshold-lower",server.active_defrag_threshold_lower,CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER);
1862      rewriteConfigNumericalOption(state,"active-defrag-threshold-upper",server.active_defrag_threshold_upper,CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER);
1863      rewriteConfigBytesOption(state,"active-defrag-ignore-bytes",server.active_defrag_ignore_bytes,CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES);
1864      rewriteConfigNumericalOption(state,"active-defrag-cycle-min",server.active_defrag_cycle_min,CONFIG_DEFAULT_DEFRAG_CYCLE_MIN);
1865      rewriteConfigNumericalOption(state,"active-defrag-cycle-max",server.active_defrag_cycle_max,CONFIG_DEFAULT_DEFRAG_CYCLE_MAX);
1866      rewriteConfigNumericalOption(state,"active-defrag-max-scan-fields",server.active_defrag_max_scan_fields,CONFIG_DEFAULT_DEFRAG_MAX_SCAN_FIELDS);
1867      rewriteConfigYesNoOption(state,"appendonly",server.aof_state != AOF_OFF,0);
1868      rewriteConfigStringOption(state,"appendfilename",server.aof_filename,CONFIG_DEFAULT_AOF_FILENAME);
1869      rewriteConfigEnumOption(state,"appendfsync",server.aof_fsync,aof_fsync_enum,CONFIG_DEFAULT_AOF_FSYNC);
1870      rewriteConfigYesNoOption(state,"no-appendfsync-on-rewrite",server.aof_no_fsync_on_rewrite,CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);
1871      rewriteConfigNumericalOption(state,"auto-aof-rewrite-percentage",server.aof_rewrite_perc,AOF_REWRITE_PERC);
1872      rewriteConfigBytesOption(state,"auto-aof-rewrite-min-size",server.aof_rewrite_min_size,AOF_REWRITE_MIN_SIZE);
1873      rewriteConfigNumericalOption(state,"lua-time-limit",server.lua_time_limit,LUA_SCRIPT_TIME_LIMIT);
1874      rewriteConfigYesNoOption(state,"cluster-enabled",server.cluster_enabled,0);
1875      rewriteConfigStringOption(state,"cluster-config-file",server.cluster_configfile,CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);
1876      rewriteConfigYesNoOption(state,"cluster-require-full-coverage",server.cluster_require_full_coverage,CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE);
1877      rewriteConfigYesNoOption(state,"cluster-replica-no-failover",server.cluster_slave_no_failover,CLUSTER_DEFAULT_SLAVE_NO_FAILOVER);
1878      rewriteConfigNumericalOption(state,"cluster-node-timeout",server.cluster_node_timeout,CLUSTER_DEFAULT_NODE_TIMEOUT);
1879      rewriteConfigNumericalOption(state,"cluster-migration-barrier",server.cluster_migration_barrier,CLUSTER_DEFAULT_MIGRATION_BARRIER);
1880      rewriteConfigNumericalOption(state,"cluster-replica-validity-factor",server.cluster_slave_validity_factor,CLUSTER_DEFAULT_SLAVE_VALIDITY);
1881      rewriteConfigNumericalOption(state,"slowlog-log-slower-than",server.slowlog_log_slower_than,CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN);
1882      rewriteConfigNumericalOption(state,"latency-monitor-threshold",server.latency_monitor_threshold,CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD);
1883      rewriteConfigNumericalOption(state,"slowlog-max-len",server.slowlog_max_len,CONFIG_DEFAULT_SLOWLOG_MAX_LEN);
1884      rewriteConfigNotifykeyspaceeventsOption(state);
1885      rewriteConfigNumericalOption(state,"hash-max-ziplist-entries",server.hash_max_ziplist_entries,OBJ_HASH_MAX_ZIPLIST_ENTRIES);
1886      rewriteConfigNumericalOption(state,"hash-max-ziplist-value",server.hash_max_ziplist_value,OBJ_HASH_MAX_ZIPLIST_VALUE);
1887      rewriteConfigNumericalOption(state,"stream-node-max-bytes",server.stream_node_max_bytes,OBJ_STREAM_NODE_MAX_BYTES);
1888      rewriteConfigNumericalOption(state,"stream-node-max-entries",server.stream_node_max_entries,OBJ_STREAM_NODE_MAX_ENTRIES);
1889      rewriteConfigNumericalOption(state,"list-max-ziplist-size",server.list_max_ziplist_size,OBJ_LIST_MAX_ZIPLIST_SIZE);
1890      rewriteConfigNumericalOption(state,"list-compress-depth",server.list_compress_depth,OBJ_LIST_COMPRESS_DEPTH);
1891      rewriteConfigNumericalOption(state,"set-max-intset-entries",server.set_max_intset_entries,OBJ_SET_MAX_INTSET_ENTRIES);
1892      rewriteConfigNumericalOption(state,"zset-max-ziplist-entries",server.zset_max_ziplist_entries,OBJ_ZSET_MAX_ZIPLIST_ENTRIES);
1893      rewriteConfigNumericalOption(state,"zset-max-ziplist-value",server.zset_max_ziplist_value,OBJ_ZSET_MAX_ZIPLIST_VALUE);
1894      rewriteConfigNumericalOption(state,"hll-sparse-max-bytes",server.hll_sparse_max_bytes,CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES);
1895      rewriteConfigYesNoOption(state,"activerehashing",server.activerehashing,CONFIG_DEFAULT_ACTIVE_REHASHING);
1896      rewriteConfigYesNoOption(state,"activedefrag",server.active_defrag_enabled,CONFIG_DEFAULT_ACTIVE_DEFRAG);
1897      rewriteConfigYesNoOption(state,"protected-mode",server.protected_mode,CONFIG_DEFAULT_PROTECTED_MODE);
1898      rewriteConfigClientoutputbufferlimitOption(state);
1899      rewriteConfigNumericalOption(state,"hz",server.config_hz,CONFIG_DEFAULT_HZ);
1900      rewriteConfigYesNoOption(state,"aof-rewrite-incremental-fsync",server.aof_rewrite_incremental_fsync,CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);
1901      rewriteConfigYesNoOption(state,"rdb-save-incremental-fsync",server.rdb_save_incremental_fsync,CONFIG_DEFAULT_RDB_SAVE_INCREMENTAL_FSYNC);
1902      rewriteConfigYesNoOption(state,"aof-load-truncated",server.aof_load_truncated,CONFIG_DEFAULT_AOF_LOAD_TRUNCATED);
1903      rewriteConfigYesNoOption(state,"aof-use-rdb-preamble",server.aof_use_rdb_preamble,CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE);
1904      rewriteConfigEnumOption(state,"supervised",server.supervised_mode,supervised_mode_enum,SUPERVISED_NONE);
1905      rewriteConfigYesNoOption(state,"lazyfree-lazy-eviction",server.lazyfree_lazy_eviction,CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION);
1906      rewriteConfigYesNoOption(state,"lazyfree-lazy-expire",server.lazyfree_lazy_expire,CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE);
1907      rewriteConfigYesNoOption(state,"lazyfree-lazy-server-del",server.lazyfree_lazy_server_del,CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL);
1908      rewriteConfigYesNoOption(state,"replica-lazy-flush",server.repl_slave_lazy_flush,CONFIG_DEFAULT_SLAVE_LAZY_FLUSH);
1909      rewriteConfigYesNoOption(state,"dynamic-hz",server.dynamic_hz,CONFIG_DEFAULT_DYNAMIC_HZ);
1910      if (server.sentinel_mode) rewriteConfigSentinelOption(state);
1911      rewriteConfigRemoveOrphaned(state);
1912      newcontent = rewriteConfigGetContentFromState(state);
1913      retval = rewriteConfigOverwriteFile(server.configfile,newcontent);
1914      sdsfree(newcontent);
1915      rewriteConfigReleaseState(state);
1916      return retval;
1917  }
1918  void configCommand(client *c) {
1919      if (server.loading && strcasecmp(c->argv[1]->ptr,"get")) {
1920          addReplyError(c,"Only CONFIG GET is allowed during loading");
1921          return;
1922      }
1923      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
1924          const char *help[] = {
1925  "GET <pattern> -- Return parameters matching the glob-like <pattern> and their values.",
1926  "SET <parameter> <value> -- Set parameter to value.",
1927  "RESETSTAT -- Reset statistics reported by INFO.",
1928  "REWRITE -- Rewrite the configuration file.",
1929  NULL
1930          };
1931          addReplyHelp(c, help);
1932      } else if (!strcasecmp(c->argv[1]->ptr,"set") && c->argc == 4) {
1933          configSetCommand(c);
1934      } else if (!strcasecmp(c->argv[1]->ptr,"get") && c->argc == 3) {
1935          configGetCommand(c);
1936      } else if (!strcasecmp(c->argv[1]->ptr,"resetstat") && c->argc == 2) {
1937          resetServerStats();
1938          resetCommandTableStats();
1939          addReply(c,shared.ok);
1940      } else if (!strcasecmp(c->argv[1]->ptr,"rewrite") && c->argc == 2) {
1941          if (server.configfile == NULL) {
1942              addReplyError(c,"The server is running without a config file");
1943              return;
1944          }
1945          if (rewriteConfig(server.configfile) == -1) {
1946              serverLog(LL_WARNING,"CONFIG REWRITE failed: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1947              addReplyErrorFormat(c,"Rewriting config file: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1948          } else {
1949              serverLog(LL_WARNING,"CONFIG REWRITE executed with success.");
1950              addReply(c,shared.ok);
1951          }
1952      } else {
1953          addReplySubcommandSyntaxError(c);
1954          return;
1955      }
1956  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-replication.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-config.c</div>
                </div>
                <div class="column column_space"><pre><code>571  }
572  #else
573  void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
574      client *slave = privdata;
</pre></code></div>
                <div class="column column_space"><pre><code>1612  }
1613  void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {
1614      int force = 1;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    