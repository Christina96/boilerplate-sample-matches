
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.420361247947454%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-filters_mips_dsp_r2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MIPS_DSP_R2)
3  #include "src/dsp/dsp.h"
4  #include <assert.h>
5  #include <stdlib.h>
6  #include <string.h>
7  # define SANITY_CHECK(in, out)                                                 \
8    assert(in != NULL);                                                          \
9    assert(out != NULL);                                                         \
10    assert(width > 0);                                                           \
11    assert(height > 0);                                                          \
12    assert(stride >= width);                                                     \
13    assert(row >= 0 && num_rows > 0 && row + num_rows <= height);                \
14    (void)height;  
15  #define DO_PREDICT_LINE(SRC, DST, LENGTH, INVERSE) do {                        \
16      const uint8_t* psrc = (uint8_t*)(SRC);                                     \
17      uint8_t* pdst = (uint8_t*)(DST);                                           \
18      const int ilength = (int)(LENGTH);                                         \
19      int temp0, temp1, temp2, temp3, temp4, temp5, temp6;                       \
20      __asm__ volatile (                                                         \
21        ".set      push                                   \n\t"                  \
22        ".set      noreorder                              \n\t"                  \
23        "srl       %[temp0],    %[length],    2           \n\t"                  \
24        "beqz      %[temp0],    4f                        \n\t"                  \
25        " andi     %[temp6],    %[length],    3           \n\t"                  \
26      ".if " #INVERSE "                                   \n\t"                  \
27      "1:                                                 \n\t"                  \
28        "lbu       %[temp1],    -1(%[dst])                \n\t"                  \
29        "lbu       %[temp2],    0(%[src])                 \n\t"                  \
30        "lbu       %[temp3],    1(%[src])                 \n\t"                  \
31        "lbu       %[temp4],    2(%[src])                 \n\t"                  \
32        "lbu       %[temp5],    3(%[src])                 \n\t"                  \
33        "addu      %[temp1],    %[temp1],     %[temp2]    \n\t"                  \
34        "addu      %[temp2],    %[temp1],     %[temp3]    \n\t"                  \
35        "addu      %[temp3],    %[temp2],     %[temp4]    \n\t"                  \
36        "addu      %[temp4],    %[temp3],     %[temp5]    \n\t"                  \
37        "sb        %[temp1],    0(%[dst])                 \n\t"                  \
38        "sb        %[temp2],    1(%[dst])                 \n\t"                  \
39        "sb        %[temp3],    2(%[dst])                 \n\t"                  \
40        "sb        %[temp4],    3(%[dst])                 \n\t"                  \
41        "addiu     %[src],      %[src],       4           \n\t"                  \
42        "addiu     %[temp0],    %[temp0],     -1          \n\t"                  \
43        "bnez      %[temp0],    1b                        \n\t"                  \
44        " addiu    %[dst],      %[dst],       4           \n\t"                  \
45      ".else                                              \n\t"                  \
46      "1:                                                 \n\t"                  \
47        "ulw       %[temp1],    -1(%[src])                \n\t"                  \
48        "ulw       %[temp2],    0(%[src])                 \n\t"                  \
49        "addiu     %[src],      %[src],       4           \n\t"                  \
50        "addiu     %[temp0],    %[temp0],     -1          \n\t"                  \
51        "subu.qb   %[temp3],    %[temp2],     %[temp1]    \n\t"                  \
52        "usw       %[temp3],    0(%[dst])                 \n\t"                  \
53        "bnez      %[temp0],    1b                        \n\t"                  \
54        " addiu    %[dst],      %[dst],       4           \n\t"                  \
55      ".endif                                             \n\t"                  \
56      "4:                                                 \n\t"                  \
57        "beqz      %[temp6],    3f                        \n\t"                  \
58        " nop                                             \n\t"                  \
59      "2:                                                 \n\t"                  \
60        "lbu       %[temp2],    0(%[src])                 \n\t"                  \
61      ".if " #INVERSE "                                   \n\t"                  \
62        "lbu       %[temp1],    -1(%[dst])                \n\t"                  \
63        "addu      %[temp3],    %[temp1],     %[temp2]    \n\t"                  \
64      ".else                                              \n\t"                  \
65        "lbu       %[temp1],    -1(%[src])                \n\t"                  \
66        "subu      %[temp3],    %[temp1],     %[temp2]    \n\t"                  \
67      ".endif                                             \n\t"                  \
68        "addiu     %[src],      %[src],       1           \n\t"                  \
69        "sb        %[temp3],    0(%[dst])                 \n\t"                  \
70        "addiu     %[temp6],    %[temp6],     -1          \n\t"                  \
71        "bnez      %[temp6],    2b                        \n\t"                  \
72        " addiu    %[dst],      %[dst],       1           \n\t"                  \
73      "3:                                                 \n\t"                  \
74        ".set      pop                                    \n\t"                  \
75        : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),         \
76          [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),         \
77          [temp6]"=&r"(temp6), [dst]"+&r"(pdst), [src]"+&r"(psrc)                \
78        : [length]"r"(ilength)                                                   \
79        : "memory"                                                               \
80      );                                                                         \
81    } while (0)
82  static WEBP_INLINE void PredictLine_MIPSdspR2(const uint8_t* src, uint8_t* dst,
83                                                int length) {
84    DO_PREDICT_LINE(src, dst, length, 0);
85  }
86  #define DO_PREDICT_LINE_VERTICAL(SRC, PRED, DST, LENGTH, INVERSE) do {         \
87      const uint8_t* psrc = (uint8_t*)(SRC);                                     \
88      const uint8_t* ppred = (uint8_t*)(PRED);                                   \
89      uint8_t* pdst = (uint8_t*)(DST);                                           \
90      const int ilength = (int)(LENGTH);                                         \
91      int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;                \
92      __asm__ volatile (                                                         \
93        ".set      push                                   \n\t"                  \
94        ".set      noreorder                              \n\t"                  \
95        "srl       %[temp0],    %[length],    0x3         \n\t"                  \
96        "beqz      %[temp0],    4f                        \n\t"                  \
97        " andi     %[temp7],    %[length],    0x7         \n\t"                  \
98      "1:                                                 \n\t"                  \
99        "ulw       %[temp1],    0(%[src])                 \n\t"                  \
100        "ulw       %[temp2],    0(%[pred])                \n\t"                  \
101        "ulw       %[temp3],    4(%[src])                 \n\t"                  \
102        "ulw       %[temp4],    4(%[pred])                \n\t"                  \
103        "addiu     %[src],      %[src],       8           \n\t"                  \
104      ".if " #INVERSE "                                   \n\t"                  \
105        "addu.qb   %[temp5],    %[temp1],     %[temp2]    \n\t"                  \
106        "addu.qb   %[temp6],    %[temp3],     %[temp4]    \n\t"                  \
107      ".else                                              \n\t"                  \
108        "subu.qb   %[temp5],    %[temp1],     %[temp2]    \n\t"                  \
109        "subu.qb   %[temp6],    %[temp3],     %[temp4]    \n\t"                  \
110      ".endif                                             \n\t"                  \
111        "addiu     %[pred],     %[pred],      8           \n\t"                  \
112        "usw       %[temp5],    0(%[dst])                 \n\t"                  \
113        "usw       %[temp6],    4(%[dst])                 \n\t"                  \
114        "addiu     %[temp0],    %[temp0],     -1          \n\t"                  \
115        "bnez      %[temp0],    1b                        \n\t"                  \
116        " addiu    %[dst],      %[dst],       8           \n\t"                  \
117      "4:                                                 \n\t"                  \
118        "beqz      %[temp7],    3f                        \n\t"                  \
119        " nop                                             \n\t"                  \
120      "2:                                                 \n\t"                  \
121        "lbu       %[temp1],    0(%[src])                 \n\t"                  \
122        "lbu       %[temp2],    0(%[pred])                \n\t"                  \
123        "addiu     %[src],      %[src],       1           \n\t"                  \
124        "addiu     %[pred],     %[pred],      1           \n\t"                  \
125      ".if " #INVERSE "                                   \n\t"                  \
126        "addu      %[temp3],    %[temp1],     %[temp2]    \n\t"                  \
127      ".else                                              \n\t"                  \
128        "subu      %[temp3],    %[temp1],     %[temp2]    \n\t"                  \
129      ".endif                                             \n\t"                  \
130        "sb        %[temp3],    0(%[dst])                 \n\t"                  \
131        "addiu     %[temp7],    %[temp7],     -1          \n\t"                  \
132        "bnez      %[temp7],    2b                        \n\t"                  \
133        " addiu    %[dst],      %[dst],       1           \n\t"                  \
134      "3:                                                 \n\t"                  \
135        ".set      pop                                    \n\t"                  \
136        : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),         \
137          [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),         \
138          [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [pred]"+&r"(ppred),          \
139          [dst]"+&r"(pdst), [src]"+&r"(psrc)                                     \
140        : [length]"r"(ilength)                                                   \
141        : "memory"                                                               \
142      );                                                                         \
143    } while (0)
144  #define PREDICT_LINE_ONE_PASS(SRC, PRED, DST) do {                             \
145      int temp1, temp2, temp3;                                                   \
146      __asm__ volatile (                                                         \
147        "lbu       %[temp1],   0(%[src])               \n\t"                     \
148        "lbu       %[temp2],   0(%[pred])              \n\t"                     \
149        "subu      %[temp3],   %[temp1],   %[temp2]    \n\t"                     \
150        "sb        %[temp3],   0(%[dst])               \n\t"                     \
151        : [temp1]"=&r"(temp1), [temp2]"=&r"(temp2), [temp3]"=&r"(temp3)          \
152        : [pred]"r"((PRED)), [dst]"r"((DST)), [src]"r"((SRC))                    \
153        : "memory"                                                               \
154      );                                                                         \
155    } while (0)
156  #define FILTER_LINE_BY_LINE do {                                               \
157      while (row < last_row) {                                                   \
158        PREDICT_LINE_ONE_PASS(in, preds - stride, out);                          \
159        DO_PREDICT_LINE(in + 1, out + 1, width - 1, 0);                          \
160        ++row;                                                                   \
161        preds += stride;                                                         \
162        in += stride;                                                            \
163        out += stride;                                                           \
164      }                                                                          \
165    } while (0)
166  static WEBP_INLINE void DoHorizontalFilter_MIPSdspR2(const uint8_t* in,
167                                                       int width, int height,
168                                                       int stride,
169                                                       int row, int num_rows,
170                                                       uint8_t* out) {
171    const uint8_t* preds;
172    const size_t start_offset = row * stride;
173    const int last_row = row + num_rows;
174    SANITY_CHECK(in, out);
175    in += start_offset;
176    out += start_offset;
177    preds = in;
178    if (row == 0) {
179      out[0] = in[0];
180      PredictLine_MIPSdspR2(in + 1, out + 1, width - 1);
181      row = 1;
182      preds += stride;
183      in += stride;
184      out += stride;
185    }
186    FILTER_LINE_BY_LINE;
187  }
188  #undef FILTER_LINE_BY_LINE
189  static void HorizontalFilter_MIPSdspR2(const uint8_t* data,
190                                         int width, int height,
191                                         int stride, uint8_t* filtered_data) {
192    DoHorizontalFilter_MIPSdspR2(data, width, height, stride, 0, height,
193                                 filtered_data);
194  }
195  #define FILTER_LINE_BY_LINE do {                                               \
196      while (row < last_row) {                                                   \
197        DO_PREDICT_LINE_VERTICAL(in, preds, out, width, 0);                      \
198        ++row;                                                                   \
199        preds += stride;                                                         \
200        in += stride;                                                            \
201        out += stride;                                                           \
202      }                                                                          \
203    } while (0)
204  static WEBP_INLINE void DoVerticalFilter_MIPSdspR2(const uint8_t* in,
205                                                     int width, int height,
206                                                     int stride,
207                                                     int row, int num_rows,
208                                                     uint8_t* out) {
209    const uint8_t* preds;
210    const size_t start_offset = row * stride;
211    const int last_row = row + num_rows;
212    SANITY_CHECK(in, out);
213    in += start_offset;
214    out += start_offset;
215    preds = in;
216    if (row == 0) {
217      out[0] = in[0];
218      PredictLine_MIPSdspR2(in + 1, out + 1, width - 1);
219      row = 1;
220      in += stride;
221      out += stride;
222    } else {
223      preds -= stride;
224    }
225    FILTER_LINE_BY_LINE;
226  }
227  #undef FILTER_LINE_BY_LINE
<span onclick='openModal()' class='match'>228  static void VerticalFilter_MIPSdspR2(const uint8_t* data, int width, int height,
229                                       int stride, uint8_t* filtered_data) {
230    DoVerticalFilter_MIPSdspR2(data, width, height, stride, 0, height,
231                               filtered_data);
232  }
233  static int GradientPredictor_MIPSdspR2(uint8_t a, uint8_t b, uint8_t c) {
</span>234    int temp0;
235    __asm__ volatile (
236      "addu             %[temp0],   %[a],       %[b]        \n\t"
237      "subu             %[temp0],   %[temp0],   %[c]        \n\t"
238      "shll_s.w         %[temp0],   %[temp0],   23          \n\t"
239      "precrqu_s.qb.ph  %[temp0],   %[temp0],   $zero       \n\t"
240      "srl              %[temp0],   %[temp0],   24          \n\t"
241      : [temp0]"=&r"(temp0)
242      : [a]"r"(a),[b]"r"(b),[c]"r"(c)
243    );
244    return temp0;
245  }
246  #define FILTER_LINE_BY_LINE(PREDS, OPERATION) do {                             \
247      while (row < last_row) {                                                   \
248        int w;                                                                   \
249        PREDICT_LINE_ONE_PASS(in, PREDS - stride, out);                          \
250        for (w = 1; w < width; ++w) {                                            \
251          const int pred = GradientPredictor_MIPSdspR2(PREDS[w - 1],             \
252                                                       PREDS[w - stride],        \
253                                                       PREDS[w - stride - 1]);   \
254          out[w] = in[w] OPERATION pred;                                         \
255        }                                                                        \
256        ++row;                                                                   \
257        in += stride;                                                            \
258        out += stride;                                                           \
259      }                                                                          \
260    } while (0)
261  static void DoGradientFilter_MIPSdspR2(const uint8_t* in,
262                                         int width, int height, int stride,
263                                         int row, int num_rows, uint8_t* out) {
264    const uint8_t* preds;
265    const size_t start_offset = row * stride;
266    const int last_row = row + num_rows;
267    SANITY_CHECK(in, out);
268    in += start_offset;
269    out += start_offset;
270    preds = in;
271    if (row == 0) {
272      out[0] = in[0];
273      PredictLine_MIPSdspR2(in + 1, out + 1, width - 1);
274      row = 1;
275      preds += stride;
276      in += stride;
277      out += stride;
278    }
279    FILTER_LINE_BY_LINE(in, -);
280  }
281  #undef FILTER_LINE_BY_LINE
282  static void GradientFilter_MIPSdspR2(const uint8_t* data, int width, int height,
283                                       int stride, uint8_t* filtered_data) {
284    DoGradientFilter_MIPSdspR2(data, width, height, stride, 0, height,
285                               filtered_data);
286  }
287  static void HorizontalUnfilter_MIPSdspR2(const uint8_t* prev, const uint8_t* in,
288                                           uint8_t* out, int width) {
289   out[0] = in[0] + (prev == NULL ? 0 : prev[0]);
290   DO_PREDICT_LINE(in + 1, out + 1, width - 1, 1);
291  }
292  static void VerticalUnfilter_MIPSdspR2(const uint8_t* prev, const uint8_t* in,
293                                         uint8_t* out, int width) {
294    if (prev == NULL) {
295      HorizontalUnfilter_MIPSdspR2(NULL, in, out, width);
296    } else {
297      DO_PREDICT_LINE_VERTICAL(in, prev, out, width, 1);
298    }
299  }
300  static void GradientUnfilter_MIPSdspR2(const uint8_t* prev, const uint8_t* in,
301                                         uint8_t* out, int width) {
302    if (prev == NULL) {
303      HorizontalUnfilter_MIPSdspR2(NULL, in, out, width);
304    } else {
305      uint8_t top = prev[0], top_left = top, left = top;
306      int i;
307      for (i = 0; i < width; ++i) {
308        top = prev[i];  
309        left = in[i] + GradientPredictor_MIPSdspR2(left, top, top_left);
310        top_left = top;
311        out[i] = left;
312      }
313    }
314  }
315  #undef DO_PREDICT_LINE_VERTICAL
316  #undef PREDICT_LINE_ONE_PASS
317  #undef DO_PREDICT_LINE
318  #undef SANITY_CHECK
319  extern void VP8FiltersInitMIPSdspR2(void);
320  WEBP_TSAN_IGNORE_FUNCTION void VP8FiltersInitMIPSdspR2(void) {
321    WebPUnfilters[WEBP_FILTER_HORIZONTAL] = HorizontalUnfilter_MIPSdspR2;
322    WebPUnfilters[WEBP_FILTER_VERTICAL] = VerticalUnfilter_MIPSdspR2;
323    WebPUnfilters[WEBP_FILTER_GRADIENT] = GradientUnfilter_MIPSdspR2;
324    WebPFilters[WEBP_FILTER_HORIZONTAL] = HorizontalFilter_MIPSdspR2;
325    WebPFilters[WEBP_FILTER_VERTICAL] = VerticalFilter_MIPSdspR2;
326    WebPFilters[WEBP_FILTER_GRADIENT] = GradientFilter_MIPSdspR2;
327  }
328  #else  
329  WEBP_DSP_INIT_STUB(VP8FiltersInitMIPSdspR2)
330  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-large.c</h3>
            <pre><code>1  #define JEMALLOC_LARGE_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/assert.h"
5  #include "jemalloc/internal/extent_mmap.h"
6  #include "jemalloc/internal/mutex.h"
7  #include "jemalloc/internal/rtree.h"
8  #include "jemalloc/internal/util.h"
9  void *
10  large_malloc(tsdn_t *tsdn, arena_t *arena, size_t usize, bool zero) {
11  	assert(usize == sz_s2u(usize));
12  	return large_palloc(tsdn, arena, usize, CACHELINE, zero);
13  }
14  void *
15  large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
16      bool zero) {
17  	size_t ausize;
18  	extent_t *extent;
19  	bool is_zeroed;
20  	UNUSED bool idump JEMALLOC_CC_SILENCE_INIT(false);
21  	assert(!tsdn_null(tsdn) || arena != NULL);
22  	ausize = sz_sa2u(usize, alignment);
23  	if (unlikely(ausize == 0 || ausize > SC_LARGE_MAXCLASS)) {
24  		return NULL;
25  	}
26  	if (config_fill && unlikely(opt_zero)) {
27  		zero = true;
28  	}
29  	is_zeroed = zero;
30  	if (likely(!tsdn_null(tsdn))) {
31  		arena = arena_choose_maybe_huge(tsdn_tsd(tsdn), arena, usize);
32  	}
33  	if (unlikely(arena == NULL) || (extent = arena_extent_alloc_large(tsdn,
34  	    arena, usize, alignment, &is_zeroed)) == NULL) {
35  		return NULL;
36  	}
37  	if (!arena_is_auto(arena)) {
38  		malloc_mutex_lock(tsdn, &arena->large_mtx);
39  		extent_list_append(&arena->large, extent);
40  		malloc_mutex_unlock(tsdn, &arena->large_mtx);
41  	}
42  	if (config_prof && arena_prof_accum(tsdn, arena, usize)) {
43  		prof_idump(tsdn);
44  	}
45  	if (zero) {
46  		assert(is_zeroed);
47  	} else if (config_fill && unlikely(opt_junk_alloc)) {
48  		memset(extent_addr_get(extent), JEMALLOC_ALLOC_JUNK,
49  		    extent_usize_get(extent));
50  	}
51  	arena_decay_tick(tsdn, arena);
52  	return extent_addr_get(extent);
53  }
54  static void
55  large_dalloc_junk_impl(void *ptr, size_t size) {
56  	memset(ptr, JEMALLOC_FREE_JUNK, size);
57  }
58  large_dalloc_junk_t *JET_MUTABLE large_dalloc_junk = large_dalloc_junk_impl;
59  static void
60  large_dalloc_maybe_junk_impl(void *ptr, size_t size) {
61  	if (config_fill && have_dss && unlikely(opt_junk_free)) {
62  		if (opt_retain || (have_dss && extent_in_dss(ptr))) {
63  			large_dalloc_junk(ptr, size);
64  		}
65  	}
66  }
67  large_dalloc_maybe_junk_t *JET_MUTABLE large_dalloc_maybe_junk =
68      large_dalloc_maybe_junk_impl;
69  static bool
70  large_ralloc_no_move_shrink(tsdn_t *tsdn, extent_t *extent, size_t usize) {
71  	arena_t *arena = extent_arena_get(extent);
72  	size_t oldusize = extent_usize_get(extent);
73  	extent_hooks_t *extent_hooks = extent_hooks_get(arena);
74  	size_t diff = extent_size_get(extent) - (usize + sz_large_pad);
75  	assert(oldusize > usize);
76  	if (extent_hooks->split == NULL) {
77  		return true;
78  	}
79  	if (diff != 0) {
80  		extent_t *trail = extent_split_wrapper(tsdn, arena,
81  		    &extent_hooks, extent, usize + sz_large_pad,
82  		    sz_size2index(usize), false, diff, SC_NSIZES, false);
83  		if (trail == NULL) {
84  			return true;
85  		}
86  		if (config_fill && unlikely(opt_junk_free)) {
87  			large_dalloc_maybe_junk(extent_addr_get(trail),
88  			    extent_size_get(trail));
89  		}
90  		arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, trail);
91  	}
92  	arena_extent_ralloc_large_shrink(tsdn, arena, extent, oldusize);
93  	return false;
94  }
95  static bool
96  large_ralloc_no_move_expand(tsdn_t *tsdn, extent_t *extent, size_t usize,
97      bool zero) {
98  	arena_t *arena = extent_arena_get(extent);
99  	size_t oldusize = extent_usize_get(extent);
100  	extent_hooks_t *extent_hooks = extent_hooks_get(arena);
101  	size_t trailsize = usize - oldusize;
102  	if (extent_hooks->merge == NULL) {
103  		return true;
104  	}
105  	if (config_fill && unlikely(opt_zero)) {
106  		zero = true;
107  	}
108  	bool is_zeroed_trail = zero;
109  	bool commit = true;
110  	extent_t *trail;
111  	bool new_mapping;
112  	if ((trail = extents_alloc(tsdn, arena, &extent_hooks,
113  	    &arena->extents_dirty, extent_past_get(extent), trailsize, 0,
114  	    CACHELINE, false, SC_NSIZES, &is_zeroed_trail, &commit)) != NULL
115  	    || (trail = extents_alloc(tsdn, arena, &extent_hooks,
116  	    &arena->extents_muzzy, extent_past_get(extent), trailsize, 0,
117  	    CACHELINE, false, SC_NSIZES, &is_zeroed_trail, &commit)) != NULL) {
118  		if (config_stats) {
119  			new_mapping = false;
120  		}
121  	} else {
122  		if ((trail = extent_alloc_wrapper(tsdn, arena, &extent_hooks,
123  		    extent_past_get(extent), trailsize, 0, CACHELINE, false,
124  		    SC_NSIZES, &is_zeroed_trail, &commit)) == NULL) {
125  			return true;
126  		}
127  		if (config_stats) {
128  			new_mapping = true;
129  		}
130  	}
131  	if (extent_merge_wrapper(tsdn, arena, &extent_hooks, extent, trail)) {
132  		extent_dalloc_wrapper(tsdn, arena, &extent_hooks, trail);
133  		return true;
134  	}
135  	rtree_ctx_t rtree_ctx_fallback;
136  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
137  	szind_t szind = sz_size2index(usize);
138  	extent_szind_set(extent, szind);
139  	rtree_szind_slab_update(tsdn, &extents_rtree, rtree_ctx,
140  	    (uintptr_t)extent_addr_get(extent), szind, false);
141  	if (config_stats && new_mapping) {
142  		arena_stats_mapped_add(tsdn, &arena->stats, trailsize);
143  	}
144  	if (zero) {
145  		if (config_cache_oblivious) {
146  			void *zbase = (void *)
147  			    ((uintptr_t)extent_addr_get(extent) + oldusize);
148  			void *zpast = PAGE_ADDR2BASE((void *)((uintptr_t)zbase +
149  			    PAGE));
150  			size_t nzero = (uintptr_t)zpast - (uintptr_t)zbase;
151  			assert(nzero > 0);
152  			memset(zbase, 0, nzero);
153  		}
154  		assert(is_zeroed_trail);
155  	} else if (config_fill && unlikely(opt_junk_alloc)) {
156  		memset((void *)((uintptr_t)extent_addr_get(extent) + oldusize),
157  		    JEMALLOC_ALLOC_JUNK, usize - oldusize);
158  	}
159  	arena_extent_ralloc_large_expand(tsdn, arena, extent, oldusize);
160  	return false;
161  }
162  bool
163  large_ralloc_no_move(tsdn_t *tsdn, extent_t *extent, size_t usize_min,
164      size_t usize_max, bool zero) {
165  	size_t oldusize = extent_usize_get(extent);
166  	assert(usize_min > 0 && usize_max <= SC_LARGE_MAXCLASS);
167  	assert(oldusize >= SC_LARGE_MINCLASS
168  	    && usize_max >= SC_LARGE_MINCLASS);
169  	if (usize_max > oldusize) {
170  		if (!large_ralloc_no_move_expand(tsdn, extent, usize_max,
171  		    zero)) {
172  			arena_decay_tick(tsdn, extent_arena_get(extent));
173  			return false;
174  		}
175  		if (usize_min < usize_max && usize_min > oldusize &&
176  		    large_ralloc_no_move_expand(tsdn, extent, usize_min,
177  		    zero)) {
178  			arena_decay_tick(tsdn, extent_arena_get(extent));
179  			return false;
180  		}
181  	}
182  	if (oldusize >= usize_min && oldusize <= usize_max) {
183  		arena_decay_tick(tsdn, extent_arena_get(extent));
184  		return false;
185  	}
186  	if (oldusize > usize_max) {
187  		if (!large_ralloc_no_move_shrink(tsdn, extent, usize_max)) {
188  			arena_decay_tick(tsdn, extent_arena_get(extent));
189  			return false;
190  		}
191  	}
192  	return true;
193  }
194  static void *
195  large_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
196      size_t alignment, bool zero) {
197  	if (alignment <= CACHELINE) {
198  		return large_malloc(tsdn, arena, usize, zero);
199  	}
200  	return large_palloc(tsdn, arena, usize, alignment, zero);
201  }
202  void *
203  large_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t usize,
204      size_t alignment, bool zero, tcache_t *tcache,
205      hook_ralloc_args_t *hook_args) {
206  	extent_t *extent = iealloc(tsdn, ptr);
207  	size_t oldusize = extent_usize_get(extent);
208  	assert(usize > 0 && usize <= SC_LARGE_MAXCLASS);
209  	assert(oldusize >= SC_LARGE_MINCLASS
210  	    && usize >= SC_LARGE_MINCLASS);
211  	if (!large_ralloc_no_move(tsdn, extent, usize, usize, zero)) {
212  		hook_invoke_expand(hook_args->is_realloc
213  		    ? hook_expand_realloc : hook_expand_rallocx, ptr, oldusize,
214  		    usize, (uintptr_t)ptr, hook_args->args);
215  		return extent_addr_get(extent);
216  	}
217  	void *ret = large_ralloc_move_helper(tsdn, arena, usize, alignment,
218  	    zero);
219  	if (ret == NULL) {
220  		return NULL;
221  	}
222  	hook_invoke_alloc(hook_args->is_realloc
223  	    ? hook_alloc_realloc : hook_alloc_rallocx, ret, (uintptr_t)ret,
224  	    hook_args->args);
225  	hook_invoke_dalloc(hook_args->is_realloc
226  	    ? hook_dalloc_realloc : hook_dalloc_rallocx, ptr, hook_args->args);
227  	size_t copysize = (usize < oldusize) ? usize : oldusize;
228  	memcpy(ret, extent_addr_get(extent), copysize);
229  	isdalloct(tsdn, extent_addr_get(extent), oldusize, tcache, NULL, true);
230  	return ret;
231  }
232  static void
233  large_dalloc_prep_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
234      bool junked_locked) {
235  	if (!junked_locked) {
236  		if (!arena_is_auto(arena)) {
237  			malloc_mutex_lock(tsdn, &arena->large_mtx);
238  			extent_list_remove(&arena->large, extent);
239  			malloc_mutex_unlock(tsdn, &arena->large_mtx);
240  		}
241  		large_dalloc_maybe_junk(extent_addr_get(extent),
242  		    extent_usize_get(extent));
243  	} else {
244  		if (!arena_is_auto(arena)) {
245  			malloc_mutex_assert_owner(tsdn, &arena->large_mtx);
246  			extent_list_remove(&arena->large, extent);
247  		}
248  	}
249  	arena_extent_dalloc_large_prep(tsdn, arena, extent);
250  }
251  static void
252  large_dalloc_finish_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
253  	extent_hooks_t *extent_hooks = EXTENT_HOOKS_INITIALIZER;
254  	arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, extent);
255  }
256  void
257  large_dalloc_prep_junked_locked(tsdn_t *tsdn, extent_t *extent) {
258  	large_dalloc_prep_impl(tsdn, extent_arena_get(extent), extent, true);
259  }
260  void
261  large_dalloc_finish(tsdn_t *tsdn, extent_t *extent) {
<span onclick='openModal()' class='match'>262  	large_dalloc_finish_impl(tsdn, extent_arena_get(extent), extent);
263  }
264  void
265  large_dalloc(tsdn_t *tsdn, extent_t *extent) {
266  	arena_t *arena = extent_arena_get(extent);
</span>267  	large_dalloc_prep_impl(tsdn, arena, extent, false);
268  	large_dalloc_finish_impl(tsdn, arena, extent);
269  	arena_decay_tick(tsdn, arena);
270  }
271  size_t
272  large_salloc(tsdn_t *tsdn, const extent_t *extent) {
273  	return extent_usize_get(extent);
274  }
275  prof_tctx_t *
276  large_prof_tctx_get(tsdn_t *tsdn, const extent_t *extent) {
277  	return extent_prof_tctx_get(extent);
278  }
279  void
280  large_prof_tctx_set(tsdn_t *tsdn, extent_t *extent, prof_tctx_t *tctx) {
281  	extent_prof_tctx_set(extent, tctx);
282  }
283  void
284  large_prof_tctx_reset(tsdn_t *tsdn, extent_t *extent) {
285  	large_prof_tctx_set(tsdn, extent, (prof_tctx_t *)(uintptr_t)1U);
286  }
287  nstime_t
288  large_prof_alloc_time_get(const extent_t *extent) {
289  	return extent_prof_alloc_time_get(extent);
290  }
291  void
292  large_prof_alloc_time_set(extent_t *extent, nstime_t t) {
293  	extent_prof_alloc_time_set(extent, t);
294  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-filters_mips_dsp_r2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-large.c</div>
                </div>
                <div class="column column_space"><pre><code>228  static void VerticalFilter_MIPSdspR2(const uint8_t* data, int width, int height,
229                                       int stride, uint8_t* filtered_data) {
230    DoVerticalFilter_MIPSdspR2(data, width, height, stride, 0, height,
231                               filtered_data);
232  }
233  static int GradientPredictor_MIPSdspR2(uint8_t a, uint8_t b, uint8_t c) {
</pre></code></div>
                <div class="column column_space"><pre><code>262  	large_dalloc_finish_impl(tsdn, extent_arena_get(extent), extent);
263  }
264  void
265  large_dalloc(tsdn_t *tsdn, extent_t *extent) {
266  	arena_t *arena = extent_arena_get(extent);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    