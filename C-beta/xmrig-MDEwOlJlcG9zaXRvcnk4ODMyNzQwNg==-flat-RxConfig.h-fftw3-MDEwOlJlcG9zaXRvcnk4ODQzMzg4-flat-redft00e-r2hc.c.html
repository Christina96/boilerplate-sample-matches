
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.244897959183673%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-RxConfig.h</h3>
            <pre><code>1  #ifndef XMRIG_RXCONFIG_H
2  #define XMRIG_RXCONFIG_H
3  #include "3rdparty/rapidjson/fwd.h"
4  #ifdef XMRIG_FEATURE_MSR
5  #   include "hw/msr/MsrItem.h"
6  #endif
7  #include <vector>
8  namespace xmrig {
9  class RxConfig
10  {
11  public:
12      enum Mode : uint32_t {
13          AutoMode,
14          FastMode,
15          LightMode,
16          ModeMax
17      };
18      enum ScratchpadPrefetchMode : uint32_t {
19          ScratchpadPrefetchOff,
20          ScratchpadPrefetchT0,
21          ScratchpadPrefetchNTA,
22          ScratchpadPrefetchMov,
23          ScratchpadPrefetchMax,
24      };
25      static const char *kCacheQoS;
26      static const char *kField;
27      static const char *kInit;
28      static const char *kInitAVX2;
29      static const char *kMode;
30      static const char *kOneGbPages;
31      static const char *kRdmsr;
32      static const char *kScratchpadPrefetchMode;
33      static const char *kWrmsr;
34  #   ifdef XMRIG_FEATURE_HWLOC
35      static const char *kNUMA;
36  #   endif
37      bool read(const rapidjson::Value &value);
38      rapidjson::Value toJSON(rapidjson::Document &doc) const;
39  #   ifdef XMRIG_FEATURE_HWLOC
40      std::vector<uint32_t> nodeset() const;
41  #   else
42      inline std::vector<uint32_t> nodeset() const { return std::vector<uint32_t>(); }
43  #   endif
44      const char *modeName() const;
45      uint32_t threads(uint32_t limit = 100) const;
46      inline int initDatasetAVX2() const  { return m_initDatasetAVX2; }
47      inline bool isOneGbPages() const    { return m_oneGbPages; }
48      inline bool rdmsr() const           { return m_rdmsr; }
49      inline bool wrmsr() const           { return m_wrmsr; }
50      inline bool cacheQoS() const        { return m_cacheQoS; }
51      inline Mode mode() const            { return m_mode; }
52      inline ScratchpadPrefetchMode scratchpadPrefetchMode() const { return m_scratchpadPrefetchMode; }
53  #   ifdef XMRIG_FEATURE_MSR
54      const char *msrPresetName() const;
55      const MsrItems &msrPreset() const;
56  #   endif
57  private:
58  #   ifdef XMRIG_FEATURE_MSR
59      uint32_t msrMod() const;
<span onclick='openModal()' class='match'>60      void readMSR(const rapidjson::Value &value);
61      bool m_wrmsr = true;
62      MsrItems m_msrPreset;
63  #   else
64      bool m_wrmsr = false;
</span>65  #   endif
66      bool m_cacheQoS = false;
67      static Mode readMode(const rapidjson::Value &value);
68      bool m_oneGbPages     = false;
69      bool m_rdmsr          = true;
70      int m_threads         = -1;
71      int m_initDatasetAVX2 = -1;
72      Mode m_mode           = AutoMode;
73      ScratchpadPrefetchMode m_scratchpadPrefetchMode = ScratchpadPrefetchT0;
74  #   ifdef XMRIG_FEATURE_HWLOC
75      bool m_numa           = true;
76      std::vector<uint32_t> m_nodeset;
77  #   endif
78  };
79  } &bsol;* namespace xmrig */
80  #endif &bsol;* XMRIG_RXCONFIG_H */
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-redft00e-r2hc.c</h3>
            <pre><code>1  #include "reodft/reodft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft super;
7       plan *cld;
8       twid *td;
9       INT is, os;
10       INT n;
11       INT vl;
12       INT ivs, ovs;
13  } P;
<span onclick='openModal()' class='match'>14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       INT is = ego->is, os = ego->os;
</span>18       INT i, n = ego->n;
19       INT iv, vl = ego->vl;
20       INT ivs = ego->ivs, ovs = ego->ovs;
21       R *W = ego->td->W;
22       R *buf;
23       E csum;
24       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
25       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
26  	  buf[0] = I[0] + I[is * n];
27  	  csum = I[0] - I[is * n];
28  	  for (i = 1; i < n - i; ++i) {
29  	       E a, b, apb, amb;
30  	       a = I[is * i];
31  	       b = I[is * (n - i)];
32  	       csum += W[2*i] * (amb = K(2.0)*(a - b));
33  	       amb = W[2*i+1] * amb;
34  	       apb = (a + b);
35  	       buf[i] = apb - amb;
36  	       buf[n - i] = apb + amb;
37  	  }
38  	  if (i == n - i) {
39  	       buf[i] = K(2.0) * I[is * i];
40  	  }
41  	  {
42  	       plan_rdft *cld = (plan_rdft *) ego->cld;
43  	       cld->apply((plan *) cld, buf, buf);
44  	  }
45  	  O[0] = buf[0];
46  	  O[os] = csum;
47  	  for (i = 1; i + i < n; ++i) {
48  	       INT k = i + i;
49  	       O[os * k] = buf[i];
50  	       O[os * (k + 1)] = O[os * (k - 1)] - buf[n - i];
51  	  }
52  	  if (i + i == n) {
53  	       O[os * n] = buf[i];
54  	  }
55       }
56       X(ifree)(buf);
57  }
58  static void awake(plan *ego_, enum wakefulness wakefulness)
59  {
60       P *ego = (P *) ego_;
61       static const tw_instr redft00e_tw[] = {
62            { TW_COS, 0, 1 },
63            { TW_SIN, 0, 1 },
64            { TW_NEXT, 1, 0 }
65       };
66       X(plan_awake)(ego->cld, wakefulness);
67       X(twiddle_awake)(wakefulness,
68  		      &ego->td, redft00e_tw, 2*ego->n, 1, (ego->n+1)/2);
69  }
70  static void destroy(plan *ego_)
71  {
72       P *ego = (P *) ego_;
73       X(plan_destroy_internal)(ego->cld);
74  }
75  static void print(const plan *ego_, printer *p)
76  {
77       const P *ego = (const P *) ego_;
78       p->print(p, "(redft00e-r2hc-%D%v%(%p%))", ego->n + 1, ego->vl, ego->cld);
79  }
80  static int applicable0(const solver *ego_, const problem *p_)
81  {
82       const problem_rdft *p = (const problem_rdft *) p_;
83       UNUSED(ego_);
84       return (1
85  	     && p->sz->rnk == 1
86  	     && p->vecsz->rnk <= 1
87  	     && p->kind[0] == REDFT00
88  	     && p->sz->dims[0].n > 1  &bsol;* n == 1 is not well-defined */
89  	  );
90  }
91  static int applicable(const solver *ego, const problem *p, const planner *plnr)
92  {
93       return (!NO_SLOWP(plnr) && applicable0(ego, p));
94  }
95  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
96  {
97       P *pln;
98       const problem_rdft *p;
99       plan *cld;
100       R *buf;
101       INT n;
102       opcnt ops;
103       static const plan_adt padt = {
104  	  X(rdft_solve), awake, print, destroy
105       };
106       if (!applicable(ego_, p_, plnr))
107            return (plan *)0;
108       p = (const problem_rdft *) p_;
109       n = p->sz->dims[0].n - 1;
110       A(n > 0);
111       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
112       cld = X(mkplan_d)(plnr, X(mkproblem_rdft_1_d)(X(mktensor_1d)(n, 1, 1), 
113  						   X(mktensor_0d)(), 
114  						   buf, buf, R2HC));
115       X(ifree)(buf);
116       if (!cld)
117            return (plan *)0;
118       pln = MKPLAN_RDFT(P, &padt, apply);
119       pln->n = n;
120       pln->is = p->sz->dims[0].is;
121       pln->os = p->sz->dims[0].os;
122       pln->cld = cld;
123       pln->td = 0;
124       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
125       X(ops_zero)(&ops);
126       ops.other = 8 + (n-1)/2 * 11 + (1 - n % 2) * 5;
127       ops.add = 2 + (n-1)/2 * 5;
128       ops.mul = (n-1)/2 * 3 + (1 - n % 2) * 1;
129       X(ops_zero)(&pln->super.super.ops);
130       X(ops_madd2)(pln->vl, &ops, &pln->super.super.ops);
131       X(ops_madd2)(pln->vl, &cld->ops, &pln->super.super.ops);
132       return &(pln->super.super);
133  }
134  static solver *mksolver(void)
135  {
136       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
137       S *slv = MKSOLVER(S, &sadt);
138       return &(slv->super);
139  }
140  void X(redft00e_r2hc_register)(planner *p)
141  {
142       REGISTER_SOLVER(p, mksolver());
143  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-RxConfig.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-redft00e-r2hc.c</div>
                </div>
                <div class="column column_space"><pre><code>60      void readMSR(const rapidjson::Value &value);
61      bool m_wrmsr = true;
62      MsrItems m_msrPreset;
63  #   else
64      bool m_wrmsr = false;
</pre></code></div>
                <div class="column column_space"><pre><code>14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       INT is = ego->is, os = ego->os;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    