
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 21.428571428571427%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-bench-user.h</h3>
            <pre><code>1  #ifndef __BENCH_USER_H__
2  #define __BENCH_USER_H__
3  #ifdef __cplusplus
4  extern "C" {
5  #endif                          &bsol;* __cplusplus */
6  #include "config.h"
7  #include <limits.h>
8  #if HAVE_STDDEF_H
9  #include <stddef.h>
10  #endif
11  #if HAVE_STDLIB_H
12  #include <stdlib.h>
13  #endif
14  #if defined(BENCHFFT_SINGLE)
15  typedef float bench_real;
16  #elif defined(BENCHFFT_LDOUBLE)
17  typedef long double bench_real;
18  #elif defined(BENCHFFT_QUAD)
19  typedef __float128 bench_real;
20  #else
21  typedef double bench_real;
22  #endif
23  typedef bench_real bench_complex[2];
24  #define c_re(c)  ((c)[0])
25  #define c_im(c)  ((c)[1])
26  #undef DOUBLE_PRECISION
27  #define DOUBLE_PRECISION (sizeof(bench_real) == sizeof(double))
28  #undef SINGLE_PRECISION
29  #define SINGLE_PRECISION (!DOUBLE_PRECISION && sizeof(bench_real) == sizeof(float))
30  #undef LDOUBLE_PRECISION
31  #define LDOUBLE_PRECISION (!DOUBLE_PRECISION && sizeof(bench_real) == sizeof(long double))
32  #undef QUAD_PRECISION
33  #ifdef BENCHFFT_QUAD
34  #define QUAD_PRECISION (!LDOUBLE_PRECISION && sizeof(bench_real) == sizeof(__float128))
35  #else
36  #define QUAD_PRECISION 0
37  #endif
38  typedef enum { PROBLEM_COMPLEX, PROBLEM_REAL, PROBLEM_R2R } problem_kind_t;
39  typedef enum {
40       R2R_R2HC, R2R_HC2R, R2R_DHT,
41       R2R_REDFT00, R2R_REDFT01, R2R_REDFT10, R2R_REDFT11,
42       R2R_RODFT00, R2R_RODFT01, R2R_RODFT10, R2R_RODFT11
43  } r2r_kind_t;
44  typedef struct {
45       int n;
46       int is;			&bsol;* input stride */
47       int os;			&bsol;* output stride */
48  } bench_iodim;
49  typedef struct {
50       int rnk;
51       bench_iodim *dims;
52  } bench_tensor;
<span onclick='openModal()' class='match'>53  bench_tensor *mktensor(int rnk);
54  void tensor_destroy(bench_tensor *sz);
55  size_t tensor_sz(const bench_tensor *sz);
56  bench_tensor *tensor_compress(const bench_tensor *sz);
57  int tensor_unitstridep(bench_tensor *t);
58  int tensor_rowmajorp(bench_tensor *t);
59  int tensor_real_rowmajorp(bench_tensor *t, int sign, int in_place);
60  bench_tensor *tensor_append(const bench_tensor *a, const bench_tensor *b);
61  bench_tensor *tensor_copy(const bench_tensor *sz);
62  bench_tensor *tensor_copy_sub(const bench_tensor *sz, int start_dim, int rnk);
</span>63  bench_tensor *tensor_copy_swapio(const bench_tensor *sz);
64  void tensor_ibounds(bench_tensor *t, int *lbp, int *ubp);
65  void tensor_obounds(bench_tensor *t, int *lbp, int *ubp);
66  #define BENCH_RNK_MINFTY  INT_MAX
67  #define BENCH_FINITE_RNK(rnk) ((rnk) != BENCH_RNK_MINFTY)
68  typedef struct {
69       problem_kind_t kind;
70       r2r_kind_t *k;
71       bench_tensor *sz;
72       bench_tensor *vecsz;
73       int sign;
74       int in_place;
75       int destroy_input;
76       int split;
77       void *in, *out;
78       void *inphys, *outphys;
79       int iphyssz, ophyssz;
80       char *pstring;
81       void *userinfo; &bsol;* user can store whatever */
82       int scrambled_in, scrambled_out; &bsol;* hack for MPI */
83       void *ini, *outi; &bsol;* if nonzero, point to imag. parts for dft */
84       double setup_time;
85  } bench_problem;
86  extern int verbose;
87  extern int no_speed_allocation;
88  extern int always_pad_real;
89  #define LIBBENCH_TIMER 0
90  #define USER_TIMER 1
91  #define BENCH_NTIMERS 2
92  extern void timer_start(int which_timer);
93  extern double timer_stop(int which_timer);
94  extern int can_do(bench_problem *p);
95  extern void setup(bench_problem *p);
96  extern void doit(int iter, bench_problem *p);
97  extern void done(bench_problem *p);
98  extern void main_init(int *argc, char ***argv);
99  extern void cleanup(void);
100  extern void verify(const char *param, int rounds, double tol);
101  extern void useropt(const char *arg);
102  extern void verify_problem(bench_problem *p, int rounds, double tol);
103  extern void problem_alloc(bench_problem *p);
104  extern void problem_free(bench_problem *p);
105  extern void problem_zero(bench_problem *p);
106  extern void problem_destroy(bench_problem *p);
107  extern int power_of_two(int n);
108  extern int log_2(int n);
109  #define CASSIGN(out, in) (c_re(out) = c_re(in), c_im(out) = c_im(in))
110  bench_tensor *verify_pack(const bench_tensor *sz, int s);
111  typedef struct {
112       double l;
113       double i;
114       double s;
115  } errors;
116  void verify_dft(bench_problem *p, int rounds, double tol, errors *e);
117  void verify_rdft2(bench_problem *p, int rounds, double tol, errors *e);
118  void verify_r2r(bench_problem *p, int rounds, double tol, errors *e);
119  extern void after_problem_ccopy_from(bench_problem *p, bench_real *ri, bench_real *ii);
120  extern void after_problem_ccopy_to(bench_problem *p, bench_real *ro, bench_real *io);
121  extern void after_problem_hccopy_from(bench_problem *p, bench_real *ri, bench_real *ii);
122  extern void after_problem_hccopy_to(bench_problem *p, bench_real *ro, bench_real *io);
123  extern void after_problem_rcopy_from(bench_problem *p, bench_real *ri);
124  extern void after_problem_rcopy_to(bench_problem *p, bench_real *ro);
125  extern void bench_exit(int status);
126  extern double bench_cost_postprocess(double cost);
127  extern void *bench_malloc(size_t size);
128  extern void bench_free(void *ptr);
129  extern void bench_free0(void *ptr);
130  #ifdef HAVE_ALLOCA_H
131  #include <alloca.h>
132  #endif
133  extern void bench_assertion_failed(const char *s, int line, const char *file);
134  #define BENCH_ASSERT(ex)						 \
135        (void)((ex) || (bench_assertion_failed(#ex, __LINE__, __FILE__), 0))
136  #define UNUSED(x) (void)x
137  struct bench_doc {
138       const char *key;
139       const char *val;
140       const char *(*f)(void);
141  };
142  extern struct bench_doc bench_doc[];
143  #ifdef CC
144  #define CC_DOC BENCH_DOC("cc", CC)
145  #elif defined(BENCH_CC)
146  #define CC_DOC BENCH_DOC("cc", BENCH_CC)
147  #else
148  #define CC_DOC &bsol;* none */
149  #endif
150  #ifdef CXX
151  #define CXX_DOC BENCH_DOC("cxx", CXX)
152  #elif defined(BENCH_CXX)
153  #define CXX_DOC BENCH_DOC("cxx", BENCH_CXX)
154  #else
155  #define CXX_DOC &bsol;* none */
156  #endif
157  #ifdef F77
158  #define F77_DOC BENCH_DOC("f77", F77)
159  #elif defined(BENCH_F77)
160  #define F77_DOC BENCH_DOC("f77", BENCH_F77)
161  #else
162  #define F77_DOC &bsol;* none */
163  #endif
164  #ifdef F90
165  #define F90_DOC BENCH_DOC("f90", F90)
166  #elif defined(BENCH_F90)
167  #define F90_DOC BENCH_DOC("f90", BENCH_F90)
168  #else
169  #define F90_DOC &bsol;* none */
170  #endif
171  #define BEGIN_BENCH_DOC						\
172  struct bench_doc bench_doc[] = {				\
173      CC_DOC							\
174      CXX_DOC							\
175      F77_DOC							\
176      F90_DOC
177  #define BENCH_DOC(key, val) { key, val, 0 },
178  #define BENCH_DOCF(key, f) { key, 0, f },
179  #define END_BENCH_DOC				\
180       {0, 0, 0}};
181  #ifdef __cplusplus
182  }                               &bsol;* extern "C" */
183  #endif                          &bsol;* __cplusplus */
184  #endif &bsol;* __BENCH_USER_H__ */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CudaConfig.h</h3>
            <pre><code>1  #ifndef XMRIG_CUDACONFIG_H
2  #define XMRIG_CUDACONFIG_H
3  #include "backend/cuda/CudaLaunchData.h"
4  #include "backend/common/Threads.h"
5  #include "backend/cuda/CudaThreads.h"
6  namespace xmrig {
7  class CudaConfig
8  {
9  public:
10      CudaConfig() = default;
<span onclick='openModal()' class='match'>11      rapidjson::Value toJSON(rapidjson::Document &doc) const;
12      std::vector<CudaLaunchData> get(const Miner *miner, const Algorithm &algorithm, const std::vector<CudaDevice> &devices) const;
13      void read(const rapidjson::Value &value);
</span>14      inline bool isEnabled() const                               { return m_enabled; }
15      inline bool isShouldSave() const                            { return m_shouldSave; }
16      inline const std::vector<uint32_t> &devicesHint() const     { return m_devicesHint; }
17      inline const String &loader() const                         { return m_loader; }
18      inline const Threads<CudaThreads> &threads() const          { return m_threads; }
19      inline int32_t bfactor() const                              { return m_bfactor; }
20      inline int32_t bsleep() const                               { return m_bsleep; }
21  #   ifdef XMRIG_FEATURE_NVML
22      inline bool isNvmlEnabled() const                           { return m_nvml; }
23      inline const String &nvmlLoader() const                     { return m_nvmlLoader; }
24  #   endif
25  private:
26      void generate();
27      void setDevicesHint(const char *devicesHint);
28      bool m_enabled          = false;
29      bool m_shouldSave       = false;
30      std::vector<uint32_t> m_devicesHint;
31      String m_loader;
32      Threads<CudaThreads> m_threads;
33  #   ifdef _WIN32
34      int32_t m_bfactor      = 6;
35      int32_t m_bsleep       = 25;
36  #   else
37      int32_t m_bfactor      = 0;
38      int32_t m_bsleep       = 0;
39  #   endif
40  #   ifdef XMRIG_FEATURE_NVML
41      bool m_nvml            = true;
42      String m_nvmlLoader;
43  #   endif
44  };
45  } &bsol;* namespace xmrig */
46  #endif &bsol;* XMRIG_CUDACONFIG_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-bench-user.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CudaConfig.h</div>
                </div>
                <div class="column column_space"><pre><code>53  bench_tensor *mktensor(int rnk);
54  void tensor_destroy(bench_tensor *sz);
55  size_t tensor_sz(const bench_tensor *sz);
56  bench_tensor *tensor_compress(const bench_tensor *sz);
57  int tensor_unitstridep(bench_tensor *t);
58  int tensor_rowmajorp(bench_tensor *t);
59  int tensor_real_rowmajorp(bench_tensor *t, int sign, int in_place);
60  bench_tensor *tensor_append(const bench_tensor *a, const bench_tensor *b);
61  bench_tensor *tensor_copy(const bench_tensor *sz);
62  bench_tensor *tensor_copy_sub(const bench_tensor *sz, int start_dim, int rnk);
</pre></code></div>
                <div class="column column_space"><pre><code>11      rapidjson::Value toJSON(rapidjson::Document &doc) const;
12      std::vector<CudaLaunchData> get(const Miner *miner, const Algorithm &algorithm, const std::vector<CudaDevice> &devices) const;
13      void read(const rapidjson::Value &value);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    