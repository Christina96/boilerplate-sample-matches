
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.953488372093023%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_fdapi_crt.h</h3>
            <pre><code>1  #pragma once
2  #include <cstdint>
3  #include <stdio.h>
4  int crt_pipe(int *pfds, unsigned int psize, int textmode);
5  int crt_close(int fd);
6  int crt_read(int fd, void *buffer, unsigned int count);
7  int crt_write(int fd, const void *buffer, unsigned int count);
8  int crt_open(const char *filename, int oflag, int pmode);
9  int crt_open_osfhandle(intptr_t osfhandle, int flags);
10  intptr_t crt_get_osfhandle(int fd);
<span onclick='openModal()' class='match'>11  int crt_setmode(int fd, int mode);
12  size_t crt_fwrite(const void *buffer, size_t size, size_t count, FILE *file);
13  int crt_fclose(FILE* file);
14  int crt_fileno(FILE* file);
</span>15  int crt_isatty(int fd);
16  int crt_access(const char *pathname, int mode);
17  __int64 crt_lseek64(int fd, __int64 offset, int origin);
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sc_14.c</h3>
            <pre><code>1  #include "jemalloc/internal/jemalloc_preamble.h"
2  #include "jemalloc/internal/assert.h"
3  #include "jemalloc/internal/bit_util.h"
4  #include "jemalloc/internal/bitmap.h"
5  #include "jemalloc/internal/pages.h"
6  #include "jemalloc/internal/sc.h"
7  sc_data_t sc_data_global;
8  static size_t
9  reg_size_compute(int lg_base, int lg_delta, int ndelta) {
10  	return (ZU(1) << lg_base) + (ZU(ndelta) << lg_delta);
11  }
12  static int
13  slab_size(int lg_page, int lg_base, int lg_delta, int ndelta) {
14  	size_t page = (ZU(1) << lg_page);
15  	size_t reg_size = reg_size_compute(lg_base, lg_delta, ndelta);
16  	size_t try_slab_size = page;
17  	size_t try_nregs = try_slab_size / reg_size;
18  	size_t perfect_slab_size = 0;
19  	bool perfect = false;
20  	while (!perfect) {
21  		perfect_slab_size = try_slab_size;
22  		size_t perfect_nregs = try_nregs;
23  		try_slab_size += page;
24  		try_nregs = try_slab_size / reg_size;
25  		if (perfect_slab_size == perfect_nregs * reg_size) {
26  			perfect = true;
27  		}
28  	}
29  	return (int)(perfect_slab_size / page);
30  }
31  static void
32  size_class(
33      sc_t *sc,
34      int lg_max_lookup, int lg_page, int lg_ngroup,
35      int index, int lg_base, int lg_delta, int ndelta) {
36  	sc->index = index;
37  	sc->lg_base = lg_base;
38  	sc->lg_delta = lg_delta;
39  	sc->ndelta = ndelta;
40  	sc->psz = (reg_size_compute(lg_base, lg_delta, ndelta)
41  	    % (ZU(1) << lg_page) == 0);
42  	size_t size = (ZU(1) << lg_base) + (ZU(ndelta) << lg_delta);
43  	if (index == 0) {
44  		assert(!sc->psz);
45  	}
46  	if (size < (ZU(1) << (lg_page + lg_ngroup))) {
47  		sc->bin = true;
48  		sc->pgs = slab_size(lg_page, lg_base, lg_delta, ndelta);
49  	} else {
50  		sc->bin = false;
51  		sc->pgs = 0;
52  	}
53  	if (size <= (ZU(1) << lg_max_lookup)) {
54  		sc->lg_delta_lookup = lg_delta;
55  	} else {
56  		sc->lg_delta_lookup = 0;
57  	}
58  }
59  static void
60  size_classes(
61      sc_data_t *sc_data,
62      size_t lg_ptr_size, int lg_quantum,
63      int lg_tiny_min, int lg_max_lookup, int lg_page, int lg_ngroup) {
64  	int ptr_bits = (1 << lg_ptr_size) * 8;
65  	int ngroup = (1 << lg_ngroup);
66  	int ntiny = 0;
67  	int nlbins = 0;
68  	int lg_tiny_maxclass = (unsigned)-1;
69  	int nbins = 0;
70  	int npsizes = 0;
71  	int index = 0;
72  	int ndelta = 0;
73  	int lg_base = lg_tiny_min;
74  	int lg_delta = lg_base;
75  	size_t lookup_maxclass = 0;
76  	size_t small_maxclass = 0;
77  	int lg_large_minclass = 0;
78  	size_t large_maxclass = 0;
79  	while (lg_base < lg_quantum) {
80  		sc_t *sc = &sc_data->sc[index];
<span onclick='openModal()' class='match'>81  		size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
82  		    lg_base, lg_delta, ndelta);
</span>83  		if (sc->lg_delta_lookup != 0) {
84  			nlbins = index + 1;
85  		}
86  		if (sc->psz) {
87  			npsizes++;
88  		}
89  		if (sc->bin) {
90  			nbins++;
91  		}
92  		ntiny++;
93  		lg_tiny_maxclass = lg_base;
94  		index++;
95  		lg_delta = lg_base;
96  		lg_base++;
97  	}
98  	if (ntiny != 0) {
99  		sc_t *sc = &sc_data->sc[index];
100  		lg_base--;
101  		ndelta = 1;
102  		size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
103  		    lg_base, lg_delta, ndelta);
104  		index++;
105  		lg_base++;
106  		lg_delta++;
107  		if (sc->psz) {
108  			npsizes++;
109  		}
110  		if (sc->bin) {
111  			nbins++;
112  		}
113  	}
114  	while (ndelta < ngroup) {
115  		sc_t *sc = &sc_data->sc[index];
116  		size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
117  		    lg_base, lg_delta, ndelta);
118  		index++;
119  		ndelta++;
120  		if (sc->psz) {
121  			npsizes++;
122  		}
123  		if (sc->bin) {
124  			nbins++;
125  		}
126  	}
127  	lg_base = lg_base + lg_ngroup;
128  	while (lg_base < ptr_bits - 1) {
129  		ndelta = 1;
130  		int ndelta_limit;
131  		if (lg_base == ptr_bits - 2) {
132  			ndelta_limit = ngroup - 1;
133  		} else {
134  			ndelta_limit = ngroup;
135  		}
136  		while (ndelta <= ndelta_limit) {
137  			sc_t *sc = &sc_data->sc[index];
138  			size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
139  			    lg_base, lg_delta, ndelta);
140  			if (sc->lg_delta_lookup != 0) {
141  				nlbins = index + 1;
142  				lookup_maxclass = (ZU(1) << lg_base)
143  				    + (ZU(ndelta) << lg_delta);
144  			}
145  			if (sc->psz) {
146  				npsizes++;
147  			}
148  			if (sc->bin) {
149  				nbins++;
150  				small_maxclass = (ZU(1) << lg_base)
151  				    + (ZU(ndelta) << lg_delta);
152  				if (lg_ngroup > 0) {
153  					lg_large_minclass = lg_base + 1;
154  				} else {
155  					lg_large_minclass = lg_base + 2;
156  				}
157  			}
158  			large_maxclass = (ZU(1) << lg_base)
159  			    + (ZU(ndelta) << lg_delta);
160  			index++;
161  			ndelta++;
162  		}
163  		lg_base++;
164  		lg_delta++;
165  	}
166  	int nsizes = index;
167  	unsigned lg_ceil_nsizes = lg_ceil(nsizes);
168  	sc_data->ntiny = ntiny;
169  	sc_data->nlbins = nlbins;
170  	sc_data->nbins = nbins;
171  	sc_data->nsizes = nsizes;
172  	sc_data->lg_ceil_nsizes = lg_ceil_nsizes;
173  	sc_data->npsizes = npsizes;
174  	sc_data->lg_tiny_maxclass = lg_tiny_maxclass;
175  	sc_data->lookup_maxclass = lookup_maxclass;
176  	sc_data->small_maxclass = small_maxclass;
177  	sc_data->lg_large_minclass = lg_large_minclass;
178  	sc_data->large_minclass = (ZU(1) << lg_large_minclass);
179  	sc_data->large_maxclass = large_maxclass;
180  	assert(sc_data->npsizes == SC_NPSIZES);
181  	assert(sc_data->lg_tiny_maxclass == SC_LG_TINY_MAXCLASS);
182  	assert(sc_data->small_maxclass == SC_SMALL_MAXCLASS);
183  	assert(sc_data->large_minclass == SC_LARGE_MINCLASS);
184  	assert(sc_data->lg_large_minclass == SC_LG_LARGE_MINCLASS);
185  	assert(sc_data->large_maxclass == SC_LARGE_MAXCLASS);
186  	assert(SC_LARGE_MAXCLASS < SSIZE_MAX);
187  }
188  void
189  sc_data_init(sc_data_t *sc_data) {
190  	assert(!sc_data->initialized);
191  	int lg_max_lookup = 12;
192  	size_classes(sc_data, LG_SIZEOF_PTR, LG_QUANTUM, SC_LG_TINY_MIN,
193  	    lg_max_lookup, LG_PAGE, 2);
194  	sc_data->initialized = true;
195  }
196  static void
197  sc_data_update_sc_slab_size(sc_t *sc, size_t reg_size, size_t pgs_guess) {
198  	size_t min_pgs = reg_size / PAGE;
199  	if (reg_size % PAGE != 0) {
200  		min_pgs++;
201  	}
202  	size_t max_pgs = BITMAP_MAXBITS * reg_size / PAGE;
203  	assert(min_pgs <= max_pgs);
204  	assert(min_pgs > 0);
205  	assert(max_pgs >= 1);
206  	if (pgs_guess < min_pgs) {
207  		sc->pgs = (int)min_pgs;
208  	} else if (pgs_guess > max_pgs) {
209  		sc->pgs = (int)max_pgs;
210  	} else {
211  		sc->pgs = (int)pgs_guess;
212  	}
213  }
214  void
215  sc_data_update_slab_size(sc_data_t *data, size_t begin, size_t end, int pgs) {
216  	assert(data->initialized);
217  	for (int i = 0; i < data->nsizes; i++) {
218  		sc_t *sc = &data->sc[i];
219  		if (!sc->bin) {
220  			break;
221  		}
222  		size_t reg_size = reg_size_compute(sc->lg_base, sc->lg_delta,
223  		    sc->ndelta);
224  		if (begin <= reg_size && reg_size <= end) {
225  			sc_data_update_sc_slab_size(sc, reg_size, pgs);
226  		}
227  	}
228  }
229  void
230  sc_boot(sc_data_t *data) {
231  	sc_data_init(data);
232  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_fdapi_crt.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sc_14.c</div>
                </div>
                <div class="column column_space"><pre><code>11  int crt_setmode(int fd, int mode);
12  size_t crt_fwrite(const void *buffer, size_t size, size_t count, FILE *file);
13  int crt_fclose(FILE* file);
14  int crt_fileno(FILE* file);
</pre></code></div>
                <div class="column column_space"><pre><code>81  		size_class(sc, lg_max_lookup, lg_page, lg_ngroup, index,
82  		    lg_base, lg_delta, ndelta);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    