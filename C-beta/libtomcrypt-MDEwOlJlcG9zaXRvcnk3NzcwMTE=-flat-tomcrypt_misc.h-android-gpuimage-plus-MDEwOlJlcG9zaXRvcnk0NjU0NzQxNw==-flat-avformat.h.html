
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 34.3649946638207%, Tokens: 73, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</h3>
            <pre><code>1  #ifdef LTC_BASE64
2  int base64_encode(const unsigned char *in,  unsigned long inlen,
3                                   char *out, unsigned long *outlen);
4  int base64_decode(const char *in,  unsigned long inlen,
5                          unsigned char *out, unsigned long *outlen);
6  int base64_strict_decode(const char *in,  unsigned long inlen,
7                          unsigned char *out, unsigned long *outlen);
8  int base64_sane_decode(const char *in,  unsigned long inlen,
9                          unsigned char *out, unsigned long *outlen);
10  #endif
11  #ifdef LTC_BASE64_URL
12  int base64url_encode(const unsigned char *in,  unsigned long inlen,
13                                      char *out, unsigned long *outlen);
14  int base64url_strict_encode(const unsigned char *in,  unsigned long inlen,
15                                             char *out, unsigned long *outlen);
16  int base64url_decode(const char *in,  unsigned long inlen,
17                          unsigned char *out, unsigned long *outlen);
18  int base64url_strict_decode(const char *in,  unsigned long inlen,
19                          unsigned char *out, unsigned long *outlen);
20  int base64url_sane_decode(const char *in,  unsigned long inlen,
21                          unsigned char *out, unsigned long *outlen);
22  #endif
23  #ifdef LTC_BASE32
24  typedef enum {
25     BASE32_RFC4648   = 0,
26     BASE32_BASE32HEX = 1,
27     BASE32_ZBASE32   = 2,
28     BASE32_CROCKFORD = 3
29  } base32_alphabet;
<span onclick='openModal()' class='match'>30  int base32_encode(const unsigned char *in,  unsigned long inlen,
31                                   char *out, unsigned long *outlen,
32                          base32_alphabet id);
33  int base32_decode(const          char *in,  unsigned long inlen,
34                          unsigned char *out, unsigned long *outlen,
35                          base32_alphabet id);
36  #endif
37  #ifdef LTC_BASE16
38  int base16_encode(const unsigned char *in,  unsigned long  inlen,
39                                   char *out, unsigned long *outlen,
40                          unsigned int   options);
41  int base16_decode(const          char *in,  unsigned long  inlen,
42                          unsigned char *out, unsigned long *outlen);
43  #endif
44  #ifdef LTC_BCRYPT
45  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
46                           const unsigned char *salt,   unsigned long salt_len,
47                                 unsigned int  rounds,            int hash_idx,
48                                 unsigned char *out,    unsigned long *outlen);
49  #endif
50  #ifdef LTC_HKDF
51  int hkdf_test(void);
52  int hkdf_extract(int hash_idx,
53                   const unsigned char *salt, unsigned long saltlen,
54                   const unsigned char *in,   unsigned long inlen,
55                         unsigned char *out,  unsigned long *outlen);
56  int hkdf_expand(int hash_idx,
57                  const unsigned char *info, unsigned long infolen,
58                  const unsigned char *in,   unsigned long inlen,
59                        unsigned char *out,  unsigned long outlen);
60  int hkdf(int hash_idx,
61           const unsigned char *salt, unsigned long saltlen,
62           const unsigned char *info, unsigned long infolen,
63           const unsigned char *in,   unsigned long inlen,
64                 unsigned char *out,  unsigned long outlen);
65  #endif  &bsol;* LTC_HKDF */
66  int mem_neq(const void *a, const void *b, size_t len);
67  void zeromem(volatile void *out, size_t outlen);
68  void burn_stack(unsigned long len);
69  const char *error_to_string(int err);
70  extern const char *crypt_build_settings;
71  int crypt_fsa(void *mp, ...) LTC_NULL_TERMINATED;
72  int crypt_get_constant(const char* namein, int *valueout);
73  int crypt_list_all_constants(char *names_list, unsigned int *names_list_size);
74  int crypt_get_size(const char* namein, unsigned int *sizeout);
75  int crypt_list_all_sizes(char *names_list, unsigned int *names_list_size);
76  #ifdef LTM_DESC
77  LTC_DEPRECATED(crypt_mp_init) void init_LTM(void);
78  #endif
79  #ifdef TFM_DESC
80  LTC_DEPRECATED(crypt_mp_init) void init_TFM(void);
81  #endif
82  #ifdef GMP_DESC
83  LTC_DEPRECATED(crypt_mp_init) void init_GMP(void);
84  #endif
85  int crypt_mp_init(const char* mpi);
</span>86  #ifdef LTC_ADLER32
87  typedef struct adler32_state_s
88  {
89     unsigned short s[2];
90  } adler32_state;
91  void adler32_init(adler32_state *ctx);
92  void adler32_update(adler32_state *ctx, const unsigned char *input, unsigned long length);
93  void adler32_finish(const adler32_state *ctx, void *hash, unsigned long size);
94  int adler32_test(void);
95  #endif
96  #ifdef LTC_CRC32
97  typedef struct crc32_state_s
98  {
99     ulong32 crc;
100  } crc32_state;
101  void crc32_init(crc32_state *ctx);
102  void crc32_update(crc32_state *ctx, const unsigned char *input, unsigned long length);
103  void crc32_finish(const crc32_state *ctx, void *hash, unsigned long size);
104  int crc32_test(void);
105  #endif
106  #ifdef LTC_PADDING
107  enum padding_type {
108     LTC_PAD_PKCS7        = 0x0000U,
109  #ifdef LTC_RNG_GET_BYTES
110     LTC_PAD_ISO_10126    = 0x1000U,
111  #endif
112     LTC_PAD_ANSI_X923    = 0x2000U,
113     LTC_PAD_SSH          = 0x3000U,
114     LTC_PAD_ONE_AND_ZERO = 0x8000U,
115     LTC_PAD_ZERO         = 0x9000U,
116     LTC_PAD_ZERO_ALWAYS  = 0xA000U,
117  };
118  int padding_pad(unsigned char *data, unsigned long length, unsigned long* padded_length, unsigned long mode);
119  int padding_depad(const unsigned char *data, unsigned long *length, unsigned long mode);
120  #endif  &bsol;* LTC_PADDING */
121  #ifdef LTC_SSH
122  typedef enum ssh_data_type_ {
123     LTC_SSHDATA_EOL,
124     LTC_SSHDATA_BYTE,
125     LTC_SSHDATA_BOOLEAN,
126     LTC_SSHDATA_UINT32,
127     LTC_SSHDATA_UINT64,
128     LTC_SSHDATA_STRING,
129     LTC_SSHDATA_MPINT,
130     LTC_SSHDATA_NAMELIST,
131  } ssh_data_type;
132  int ssh_encode_sequence_multi(unsigned char *out, unsigned long *outlen, ...) LTC_NULL_TERMINATED;
133  int ssh_decode_sequence_multi(const unsigned char *in, unsigned long *inlen, ...) LTC_NULL_TERMINATED;
134  #endif &bsol;* LTC_SSH */
135  int compare_testvector(const void* is, const unsigned long is_len, const void* should, const unsigned long should_len, const char* what, int which);
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-avformat.h</h3>
            <pre><code>1  #ifndef AVFORMAT_AVFORMAT_H
2  #define AVFORMAT_AVFORMAT_H
3  #include <time.h>
4  #include <stdio.h>  &bsol;* FILE */
5  #include "libavcodec/avcodec.h"
6  #include "libavutil/dict.h"
7  #include "libavutil/log.h"
8  #include "avio.h"
9  #include "libavformat/version.h"
10  struct AVFormatContext;
11  struct AVDeviceInfoList;
12  struct AVDeviceCapabilitiesQuery;
13  int av_get_packet(AVIOContext *s, AVPacket *pkt, int size);
14  int av_append_packet(AVIOContext *s, AVPacket *pkt, int size);
15  #if FF_API_LAVF_FRAC
16  typedef struct AVFrac {
17      int64_t val, num, den;
18  } AVFrac;
19  #endif
20  struct AVCodecTag;
21  typedef struct AVProbeData {
22      const char *filename;
23      unsigned char *buf; &bsol;**< Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero. */
24      int buf_size;       &bsol;**< Size of buf except extra allocated bytes */
25      const char *mime_type; &bsol;**< mime_type, when known. */
26  } AVProbeData;
27  #define AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)
28  #define AVPROBE_SCORE_STREAM_RETRY (AVPROBE_SCORE_MAX/4-1)
29  #define AVPROBE_SCORE_EXTENSION  50 
30  #define AVPROBE_SCORE_MIME       75 
31  #define AVPROBE_SCORE_MAX       100 
32  #define AVPROBE_PADDING_SIZE 32             
33  #define AVFMT_NOFILE        0x0001
34  #define AVFMT_NEEDNUMBER    0x0002 &bsol;**< Needs '%d' in filename. */
35  #define AVFMT_SHOW_IDS      0x0008 &bsol;**< Show format stream IDs numbers. */
36  #if FF_API_LAVF_FMT_RAWPICTURE
37  #define AVFMT_RAWPICTURE    0x0020 &bsol;**< Format wants AVPicture structure for
38                                        raw picture data. @deprecated Not used anymore */
39  #endif
40  #define AVFMT_GLOBALHEADER  0x0040 &bsol;**< Format wants global header. */
41  #define AVFMT_NOTIMESTAMPS  0x0080 &bsol;**< Format does not need / have any timestamps. */
42  #define AVFMT_GENERIC_INDEX 0x0100 &bsol;**< Use generic index building code. */
43  #define AVFMT_TS_DISCONT    0x0200 &bsol;**< Format allows timestamp discontinuities. Note, muxers always require valid (monotone) timestamps */
44  #define AVFMT_VARIABLE_FPS  0x0400 &bsol;**< Format allows variable fps. */
45  #define AVFMT_NODIMENSIONS  0x0800 &bsol;**< Format does not need width/height */
46  #define AVFMT_NOSTREAMS     0x1000 &bsol;**< Format does not require any streams */
47  #define AVFMT_NOBINSEARCH   0x2000 &bsol;**< Format does not allow to fall back on binary search via read_timestamp */
48  #define AVFMT_NOGENSEARCH   0x4000 &bsol;**< Format does not allow to fall back on generic search */
49  #define AVFMT_NO_BYTE_SEEK  0x8000 &bsol;**< Format does not allow seeking by bytes */
50  #define AVFMT_ALLOW_FLUSH  0x10000 &bsol;**< Format allows flushing. If not set, the muxer will not receive a NULL packet in the write_packet function. */
51  #define AVFMT_TS_NONSTRICT 0x20000 &bsol;**< Format does not require strictly
52                                          increasing timestamps, but they must
53                                          still be monotonic */
54  #define AVFMT_TS_NEGATIVE  0x40000 &bsol;**< Format allows muxing negative
55                                          timestamps. If not set the timestamp
56                                          will be shifted in av_write_frame and
57                                          av_interleaved_write_frame so they
58                                          start from 0.
59                                          The user or muxer can override this through
60                                          AVFormatContext.avoid_negative_ts
61                                          */
62  #define AVFMT_SEEK_TO_PTS   0x4000000 &bsol;**< Seeking is based on PTS */
63  typedef struct AVOutputFormat {
64      const char *name;
65      const char *long_name;
66      const char *mime_type;
67      const char *extensions; &bsol;**< comma-separated filename extensions */
68      enum AVCodecID audio_codec;    &bsol;**< default audio codec */
69      enum AVCodecID video_codec;    &bsol;**< default video codec */
70      enum AVCodecID subtitle_codec; &bsol;**< default subtitle codec */
71      int flags;
72      const struct AVCodecTag * const *codec_tag;
73      const AVClass *priv_class; 
74      struct AVOutputFormat *next;
75      int priv_data_size;
76      int (*write_header)(struct AVFormatContext *);
77      int (*write_packet)(struct AVFormatContext *, AVPacket *pkt);
78      int (*write_trailer)(struct AVFormatContext *);
79      int (*interleave_packet)(struct AVFormatContext *, AVPacket *out,
80                               AVPacket *in, int flush);
81      int (*query_codec)(enum AVCodecID id, int std_compliance);
82      void (*get_output_timestamp)(struct AVFormatContext *s, int stream,
83                                   int64_t *dts, int64_t *wall);
84      int (*control_message)(struct AVFormatContext *s, int type,
85                             void *data, size_t data_size);
86      int (*write_uncoded_frame)(struct AVFormatContext *, int stream_index,
87                                 AVFrame **frame, unsigned flags);
88      int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list);
89      int (*create_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);
90      int (*free_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);
91      enum AVCodecID data_codec; &bsol;**< default data codec */
92      int (*init)(struct AVFormatContext *);
93      void (*deinit)(struct AVFormatContext *);
94      int (*check_bitstream)(struct AVFormatContext *, const AVPacket *pkt);
95  } AVOutputFormat;
96  typedef struct AVInputFormat {
97      const char *name;
98      const char *long_name;
99      int flags;
100      const char *extensions;
101      const struct AVCodecTag * const *codec_tag;
102      const AVClass *priv_class; 
103      const char *mime_type;
104      struct AVInputFormat *next;
105      int raw_codec_id;
106      int priv_data_size;
107      int (*read_probe)(AVProbeData *);
108      int (*read_header)(struct AVFormatContext *);
109      int (*read_packet)(struct AVFormatContext *, AVPacket *pkt);
110      int (*read_close)(struct AVFormatContext *);
111      int (*read_seek)(struct AVFormatContext *,
112                       int stream_index, int64_t timestamp, int flags);
113      int64_t (*read_timestamp)(struct AVFormatContext *s, int stream_index,
114                                int64_t *pos, int64_t pos_limit);
115      int (*read_play)(struct AVFormatContext *);
116      int (*read_pause)(struct AVFormatContext *);
117      int (*read_seek2)(struct AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags);
118      int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list);
119      int (*create_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);
120      int (*free_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);
121  } AVInputFormat;
122  enum AVStreamParseType {
123      AVSTREAM_PARSE_NONE,
124      AVSTREAM_PARSE_FULL,       &bsol;**< full parsing and repack */
125      AVSTREAM_PARSE_HEADERS,    &bsol;**< Only parse headers, do not repack. */
126      AVSTREAM_PARSE_TIMESTAMPS, &bsol;**< full parsing and interpolation of timestamps for frames not starting on a packet boundary */
127      AVSTREAM_PARSE_FULL_ONCE,  &bsol;**< full parsing and repack of the first frame only, only implemented for H.264 currently */
128      AVSTREAM_PARSE_FULL_RAW=MKTAG(0,'R','A','W'),       &bsol;**< full parsing and repack with timestamp and position generation by parser for raw
129                                                               this assumes that each packet in the file contains no demuxer level headers and
130                                                               just codec level data, otherwise position generation would fail */
131  };
132  typedef struct AVIndexEntry {
133      int64_t pos;
134      int64_t timestamp;        &bsol;**<
135                                 * Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available
136                                 * when seeking to this entry. That means preferable PTS on keyframe based formats.
137                                 * But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better
138                                 * is known
139                                 */
140  #define AVINDEX_KEYFRAME 0x0001
141  #define AVINDEX_DISCARD_FRAME  0x0002    &bsol;**
142                                            * Flag is used to indicate which frame should be discarded after decoding.
143                                            */
144      int flags:2;
145      int size:30; 
146      int min_distance;         &bsol;**< Minimum distance between this and the previous keyframe, used to avoid unneeded searching. */
147  } AVIndexEntry;
148  #define AV_DISPOSITION_DEFAULT   0x0001
149  #define AV_DISPOSITION_DUB       0x0002
150  #define AV_DISPOSITION_ORIGINAL  0x0004
151  #define AV_DISPOSITION_COMMENT   0x0008
152  #define AV_DISPOSITION_LYRICS    0x0010
153  #define AV_DISPOSITION_KARAOKE   0x0020
154  #define AV_DISPOSITION_FORCED    0x0040
155  #define AV_DISPOSITION_HEARING_IMPAIRED  0x0080  &bsol;**< stream for hearing impaired audiences */
156  #define AV_DISPOSITION_VISUAL_IMPAIRED   0x0100  &bsol;**< stream for visual impaired audiences */
157  #define AV_DISPOSITION_CLEAN_EFFECTS     0x0200  &bsol;**< stream without voice */
158  #define AV_DISPOSITION_ATTACHED_PIC      0x0400
159  #define AV_DISPOSITION_TIMED_THUMBNAILS  0x0800
160  typedef struct AVStreamInternal AVStreamInternal;
161  #define AV_DISPOSITION_CAPTIONS     0x10000
162  #define AV_DISPOSITION_DESCRIPTIONS 0x20000
163  #define AV_DISPOSITION_METADATA     0x40000
164  #define AV_PTS_WRAP_IGNORE      0   
165  #define AV_PTS_WRAP_ADD_OFFSET  1   
166  #define AV_PTS_WRAP_SUB_OFFSET  -1  
167  typedef struct AVStream {
168      int index;    &bsol;**< stream index in AVFormatContext */
169      int id;
170  #if FF_API_LAVF_AVCTX
171      attribute_deprecated
172      AVCodecContext *codec;
173  #endif
174      void *priv_data;
175  #if FF_API_LAVF_FRAC
176      attribute_deprecated
177      struct AVFrac pts;
178  #endif
179      AVRational time_base;
180      int64_t start_time;
181      int64_t duration;
182      int64_t nb_frames;                 
183      int disposition; &bsol;**< AV_DISPOSITION_* bit field */
184      enum AVDiscard discard; 
185      AVRational sample_aspect_ratio;
186      AVDictionary *metadata;
187      AVRational avg_frame_rate;
188      AVPacket attached_pic;
189      AVPacketSideData *side_data;
190      int            nb_side_data;
191      int event_flags;
192  #define AVSTREAM_EVENT_FLAG_METADATA_UPDATED 0x0001 
193  #define MAX_STD_TIMEBASES (30*12+30+3+6)
194      struct {
195          int64_t last_dts;
196          int64_t duration_gcd;
197          int duration_count;
198          int64_t rfps_duration_sum;
199          double (*duration_error)[2][MAX_STD_TIMEBASES];
200          int64_t codec_info_duration;
201          int64_t codec_info_duration_fields;
202          int found_decoder;
203          int64_t last_duration;
204          int64_t fps_first_dts;
205          int     fps_first_dts_idx;
206          int64_t fps_last_dts;
207          int     fps_last_dts_idx;
208      } *info;
209      int pts_wrap_bits; &bsol;**< number of bits in pts (used for wrapping control) */
210      int64_t first_dts;
211      int64_t cur_dts;
212      int64_t last_IP_pts;
213      int last_IP_duration;
214      int probe_packets;
215      int codec_info_nb_frames;
216      enum AVStreamParseType need_parsing;
217      struct AVCodecParserContext *parser;
218      struct AVPacketList *last_in_packet_buffer;
219      AVProbeData probe_data;
220  #define MAX_REORDER_DELAY 16
221      int64_t pts_buffer[MAX_REORDER_DELAY+1];
222      AVIndexEntry *index_entries; &bsol;**< Only used if the format does not
223                                      support seeking natively. */
224      int nb_index_entries;
225      unsigned int index_entries_allocated_size;
226      AVRational r_frame_rate;
227      int stream_identifier;
228      int64_t interleaver_chunk_size;
229      int64_t interleaver_chunk_duration;
230      int request_probe;
231      int skip_to_keyframe;
232      int skip_samples;
233      int64_t start_skip_samples;
234      int64_t first_discard_sample;
235      int64_t last_discard_sample;
236      int nb_decoded_frames;
237      int64_t mux_ts_offset;
238      int64_t pts_wrap_reference;
239      int pts_wrap_behavior;
240      int update_initial_durations_done;
241      int64_t pts_reorder_error[MAX_REORDER_DELAY+1];
242      uint8_t pts_reorder_error_count[MAX_REORDER_DELAY+1];
243      int64_t last_dts_for_order_check;
244      uint8_t dts_ordered;
245      uint8_t dts_misordered;
246      int inject_global_side_data;
247      char *recommended_encoder_configuration;
248      AVRational display_aspect_ratio;
249      struct FFFrac *priv_pts;
250      AVStreamInternal *internal;
251      AVCodecParameters *codecpar;
252  } AVStream;
253  AVRational av_stream_get_r_frame_rate(const AVStream *s);
254  void       av_stream_set_r_frame_rate(AVStream *s, AVRational r);
255  struct AVCodecParserContext *av_stream_get_parser(const AVStream *s);
256  char* av_stream_get_recommended_encoder_configuration(const AVStream *s);
257  void  av_stream_set_recommended_encoder_configuration(AVStream *s, char *configuration);
258  int64_t    av_stream_get_end_pts(const AVStream *st);
259  #define AV_PROGRAM_RUNNING 1
260  typedef struct AVProgram {
261      int            id;
262      int            flags;
263      enum AVDiscard discard;        
264      unsigned int   *stream_index;
265      unsigned int   nb_stream_indexes;
266      AVDictionary *metadata;
267      int program_num;
268      int pmt_pid;
269      int pcr_pid;
270      int64_t start_time;
271      int64_t end_time;
272      int64_t pts_wrap_reference;    
273      int pts_wrap_behavior;         
274  } AVProgram;
275  #define AVFMTCTX_NOHEADER      0x0001 &bsol;**< signal that no header is present
276                                           (streams are added dynamically) */
277  typedef struct AVChapter {
278      int id;                 
279      AVRational time_base;   
280      int64_t start, end;     
281      AVDictionary *metadata;
282  } AVChapter;
283  typedef int (*av_format_control_message)(struct AVFormatContext *s, int type,
284                                           void *data, size_t data_size);
285  typedef int (*AVOpenCallback)(struct AVFormatContext *s, AVIOContext **pb, const char *url, int flags,
286                                const AVIOInterruptCB *int_cb, AVDictionary **options);
287  enum AVDurationEstimationMethod {
288      AVFMT_DURATION_FROM_PTS,    
289      AVFMT_DURATION_FROM_STREAM, 
290      AVFMT_DURATION_FROM_BITRATE 
291  };
292  typedef struct AVFormatInternal AVFormatInternal;
293  typedef struct AVFormatContext {
<span onclick='openModal()' class='match'>294      const AVClass *av_class;
295      struct AVInputFormat *iformat;
296      struct AVOutputFormat *oformat;
297      void *priv_data;
298      AVIOContext *pb;
299      int ctx_flags;
300      unsigned int nb_streams;
301      AVStream **streams;
302      char filename[1024];
303      int64_t start_time;
304      int64_t duration;
305      int64_t bit_rate;
306      unsigned int packet_size;
307      int max_delay;
308      int flags;
309  #define AVFMT_FLAG_GENPTS       0x0001 
310  #define AVFMT_FLAG_IGNIDX       0x0002 
311  #define AVFMT_FLAG_NONBLOCK     0x0004 
312  #define AVFMT_FLAG_IGNDTS       0x0008 
313  #define AVFMT_FLAG_NOFILLIN     0x0010 
314  #define AVFMT_FLAG_NOPARSE      0x0020 
315  #define AVFMT_FLAG_NOBUFFER     0x0040 
316  #define AVFMT_FLAG_CUSTOM_IO    0x0080 
317  #define AVFMT_FLAG_DISCARD_CORRUPT  0x0100 
318  #define AVFMT_FLAG_FLUSH_PACKETS    0x0200 
319  #define AVFMT_FLAG_BITEXACT         0x0400
320  #define AVFMT_FLAG_MP4A_LATM    0x8000 
321  #define AVFMT_FLAG_SORT_DTS    0x10000 
322  #define AVFMT_FLAG_PRIV_OPT    0x20000 
323  #if FF_API_LAVF_KEEPSIDE_FLAG
324  #define AVFMT_FLAG_KEEP_SIDE_DATA 0x40000 
325  #endif
326  #define AVFMT_FLAG_FAST_SEEK   0x80000 
327  #define AVFMT_FLAG_SHORTEST   0x100000 
328  #define AVFMT_FLAG_AUTO_BSF   0x200000 
329      int64_t probesize;
330      int64_t max_analyze_duration;
331      const uint8_t *key;
332      int keylen;
333      unsigned int nb_programs;
334      AVProgram **programs;
335      enum AVCodecID video_codec_id;
336      enum AVCodecID audio_codec_id;
337      enum AVCodecID subtitle_codec_id;
338      unsigned int max_index_size;
339      unsigned int max_picture_buffer;
340      unsigned int nb_chapters;
341      AVChapter **chapters;
342      AVDictionary *metadata;
343      int64_t start_time_realtime;
344      int fps_probe_size;
345      int error_recognition;
346      AVIOInterruptCB interrupt_callback;
347      int debug;
348  #define FF_FDEBUG_TS        0x0001
349      int64_t max_interleave_delta;
350      int strict_std_compliance;
351      int event_flags;
352  #define AVFMT_EVENT_FLAG_METADATA_UPDATED 0x0001 
353      int max_ts_probe;
354      int avoid_negative_ts;
355  #define AVFMT_AVOID_NEG_TS_AUTO             -1 
356  #define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1 
357  #define AVFMT_AVOID_NEG_TS_MAKE_ZERO         2 
358      int ts_id;
359      int audio_preload;
360      int max_chunk_duration;
361      int max_chunk_size;
362      int use_wallclock_as_timestamps;
363      int avio_flags;
364      enum AVDurationEstimationMethod duration_estimation_method;
365      int64_t skip_initial_bytes;
366      unsigned int correct_ts_overflow;
367      int seek2any;
368      int flush_packets;
369      int probe_score;
370      int format_probesize;
371      char *codec_whitelist;
372      char *format_whitelist;
373      AVFormatInternal *internal;
374      int io_repositioned;
375      AVCodec *video_codec;
376      AVCodec *audio_codec;
377      AVCodec *subtitle_codec;
378      AVCodec *data_codec;
379      int metadata_header_padding;
380      void *opaque;
381      av_format_control_message control_message_cb;
382      int64_t output_ts_offset;
383      uint8_t *dump_separator;
384      enum AVCodecID data_codec_id;
385  #if FF_API_OLD_OPEN_CALLBACKS
386      attribute_deprecated
387      int (*open_cb)(struct AVFormatContext *s, AVIOContext **p, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options);
</span>388  #endif
389      char *protocol_whitelist;
390      int (*io_open)(struct AVFormatContext *s, AVIOContext **pb, const char *url,
391                     int flags, AVDictionary **options);
392      void (*io_close)(struct AVFormatContext *s, AVIOContext *pb);
393      char *protocol_blacklist;
394      int max_streams;
395  } AVFormatContext;
396  int av_format_get_probe_score(const AVFormatContext *s);
397  AVCodec * av_format_get_video_codec(const AVFormatContext *s);
398  void      av_format_set_video_codec(AVFormatContext *s, AVCodec *c);
399  AVCodec * av_format_get_audio_codec(const AVFormatContext *s);
400  void      av_format_set_audio_codec(AVFormatContext *s, AVCodec *c);
401  AVCodec * av_format_get_subtitle_codec(const AVFormatContext *s);
402  void      av_format_set_subtitle_codec(AVFormatContext *s, AVCodec *c);
403  AVCodec * av_format_get_data_codec(const AVFormatContext *s);
404  void      av_format_set_data_codec(AVFormatContext *s, AVCodec *c);
405  int       av_format_get_metadata_header_padding(const AVFormatContext *s);
406  void      av_format_set_metadata_header_padding(AVFormatContext *s, int c);
407  void *    av_format_get_opaque(const AVFormatContext *s);
408  void      av_format_set_opaque(AVFormatContext *s, void *opaque);
409  av_format_control_message av_format_get_control_message_cb(const AVFormatContext *s);
410  void      av_format_set_control_message_cb(AVFormatContext *s, av_format_control_message callback);
411  #if FF_API_OLD_OPEN_CALLBACKS
412  attribute_deprecated AVOpenCallback av_format_get_open_cb(const AVFormatContext *s);
413  attribute_deprecated void av_format_set_open_cb(AVFormatContext *s, AVOpenCallback callback);
414  #endif
415  void av_format_inject_global_side_data(AVFormatContext *s);
416  enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(const AVFormatContext* ctx);
417  typedef struct AVPacketList {
418      AVPacket pkt;
419      struct AVPacketList *next;
420  } AVPacketList;
421  unsigned avformat_version(void);
422  const char *avformat_configuration(void);
423  const char *avformat_license(void);
424  void av_register_all(void);
425  void av_register_input_format(AVInputFormat *format);
426  void av_register_output_format(AVOutputFormat *format);
427  int avformat_network_init(void);
428  int avformat_network_deinit(void);
429  AVInputFormat  *av_iformat_next(const AVInputFormat  *f);
430  AVOutputFormat *av_oformat_next(const AVOutputFormat *f);
431  AVFormatContext *avformat_alloc_context(void);
432  void avformat_free_context(AVFormatContext *s);
433  const AVClass *avformat_get_class(void);
434  AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c);
435  int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type,
436                              uint8_t *data, size_t size);
437  uint8_t *av_stream_new_side_data(AVStream *stream,
438                                   enum AVPacketSideDataType type, int size);
439  #if FF_API_NOCONST_GET_SIDE_DATA
440  uint8_t *av_stream_get_side_data(AVStream *stream,
441                                   enum AVPacketSideDataType type, int *size);
442  #else
443  uint8_t *av_stream_get_side_data(const AVStream *stream,
444                                   enum AVPacketSideDataType type, int *size);
445  #endif
446  AVProgram *av_new_program(AVFormatContext *s, int id);
447  int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat,
448                                     const char *format_name, const char *filename);
449  AVInputFormat *av_find_input_format(const char *short_name);
450  AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened);
451  AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max);
452  AVInputFormat *av_probe_input_format3(AVProbeData *pd, int is_opened, int *score_ret);
453  int av_probe_input_buffer2(AVIOContext *pb, AVInputFormat **fmt,
454                             const char *url, void *logctx,
455                             unsigned int offset, unsigned int max_probe_size);
456  int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
457                            const char *url, void *logctx,
458                            unsigned int offset, unsigned int max_probe_size);
459  int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options);
460  attribute_deprecated
461  int av_demuxer_open(AVFormatContext *ic);
462  int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);
463  AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s);
464  void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx);
465  int av_find_best_stream(AVFormatContext *ic,
466                          enum AVMediaType type,
467                          int wanted_stream_nb,
468                          int related_stream,
469                          AVCodec **decoder_ret,
470                          int flags);
471  int av_read_frame(AVFormatContext *s, AVPacket *pkt);
472  int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp,
473                    int flags);
474  int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags);
475  int avformat_flush(AVFormatContext *s);
476  int av_read_play(AVFormatContext *s);
477  int av_read_pause(AVFormatContext *s);
478  void avformat_close_input(AVFormatContext **s);
479  #define AVSEEK_FLAG_BACKWARD 1 
480  #define AVSEEK_FLAG_BYTE     2 
481  #define AVSEEK_FLAG_ANY      4 
482  #define AVSEEK_FLAG_FRAME    8 
483  #define AVSTREAM_INIT_IN_WRITE_HEADER 0 
484  #define AVSTREAM_INIT_IN_INIT_OUTPUT  1 
485  av_warn_unused_result
486  int avformat_write_header(AVFormatContext *s, AVDictionary **options);
487  av_warn_unused_result
488  int avformat_init_output(AVFormatContext *s, AVDictionary **options);
489  int av_write_frame(AVFormatContext *s, AVPacket *pkt);
490  int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt);
491  int av_write_uncoded_frame(AVFormatContext *s, int stream_index,
492                             AVFrame *frame);
493  int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index,
494                                         AVFrame *frame);
495  int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index);
496  int av_write_trailer(AVFormatContext *s);
497  AVOutputFormat *av_guess_format(const char *short_name,
498                                  const char *filename,
499                                  const char *mime_type);
500  enum AVCodecID av_guess_codec(AVOutputFormat *fmt, const char *short_name,
501                              const char *filename, const char *mime_type,
502                              enum AVMediaType type);
503  int av_get_output_timestamp(struct AVFormatContext *s, int stream,
504                              int64_t *dts, int64_t *wall);
505  void av_hex_dump(FILE *f, const uint8_t *buf, int size);
506  void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size);
507  void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st);
508  void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload,
509                        const AVStream *st);
510  enum AVCodecID av_codec_get_id(const struct AVCodecTag * const *tags, unsigned int tag);
511  unsigned int av_codec_get_tag(const struct AVCodecTag * const *tags, enum AVCodecID id);
512  int av_codec_get_tag2(const struct AVCodecTag * const *tags, enum AVCodecID id,
513                        unsigned int *tag);
514  int av_find_default_stream_index(AVFormatContext *s);
515  int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags);
516  int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,
517                         int size, int distance, int flags);
518  void av_url_split(char *proto,         int proto_size,
519                    char *authorization, int authorization_size,
520                    char *hostname,      int hostname_size,
521                    int *port_ptr,
522                    char *path,          int path_size,
523                    const char *url);
524  void av_dump_format(AVFormatContext *ic,
525                      int index,
526                      const char *url,
527                      int is_output);
528  #define AV_FRAME_FILENAME_FLAGS_MULTIPLE 1 
529  int av_get_frame_filename2(char *buf, int buf_size,
530                            const char *path, int number, int flags);
531  int av_get_frame_filename(char *buf, int buf_size,
532                            const char *path, int number);
533  int av_filename_number_test(const char *filename);
534  int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size);
535  int av_match_ext(const char *filename, const char *extensions);
536  int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id,
537                           int std_compliance);
538  const struct AVCodecTag *avformat_get_riff_video_tags(void);
539  const struct AVCodecTag *avformat_get_riff_audio_tags(void);
540  const struct AVCodecTag *avformat_get_mov_video_tags(void);
541  const struct AVCodecTag *avformat_get_mov_audio_tags(void);
542  AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, AVFrame *frame);
543  AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, AVFrame *frame);
544  int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st,
545                                      const char *spec);
546  int avformat_queue_attached_pictures(AVFormatContext *s);
547  #if FF_API_OLD_BSF
548  attribute_deprecated
549  int av_apply_bitstream_filters(AVCodecContext *codec, AVPacket *pkt,
550                                 AVBitStreamFilterContext *bsfc);
551  #endif
552  enum AVTimebaseSource {
553      AVFMT_TBCF_AUTO = -1,
554      AVFMT_TBCF_DECODER,
555      AVFMT_TBCF_DEMUXER,
556  #if FF_API_R_FRAME_RATE
557      AVFMT_TBCF_R_FRAMERATE,
558  #endif
559  };
560  int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt,
561                                                    AVStream *ost, const AVStream *ist,
562                                                    enum AVTimebaseSource copy_tb);
563  AVRational av_stream_get_codec_timebase(const AVStream *st);
564  #endif &bsol;* AVFORMAT_AVFORMAT_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-avformat.h</div>
                </div>
                <div class="column column_space"><pre><code>30  int base32_encode(const unsigned char *in,  unsigned long inlen,
31                                   char *out, unsigned long *outlen,
32                          base32_alphabet id);
33  int base32_decode(const          char *in,  unsigned long inlen,
34                          unsigned char *out, unsigned long *outlen,
35                          base32_alphabet id);
36  #endif
37  #ifdef LTC_BASE16
38  int base16_encode(const unsigned char *in,  unsigned long  inlen,
39                                   char *out, unsigned long *outlen,
40                          unsigned int   options);
41  int base16_decode(const          char *in,  unsigned long  inlen,
42                          unsigned char *out, unsigned long *outlen);
43  #endif
44  #ifdef LTC_BCRYPT
45  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
46                           const unsigned char *salt,   unsigned long salt_len,
47                                 unsigned int  rounds,            int hash_idx,
48                                 unsigned char *out,    unsigned long *outlen);
49  #endif
50  #ifdef LTC_HKDF
51  int hkdf_test(void);
52  int hkdf_extract(int hash_idx,
53                   const unsigned char *salt, unsigned long saltlen,
54                   const unsigned char *in,   unsigned long inlen,
55                         unsigned char *out,  unsigned long *outlen);
56  int hkdf_expand(int hash_idx,
57                  const unsigned char *info, unsigned long infolen,
58                  const unsigned char *in,   unsigned long inlen,
59                        unsigned char *out,  unsigned long outlen);
60  int hkdf(int hash_idx,
61           const unsigned char *salt, unsigned long saltlen,
62           const unsigned char *info, unsigned long infolen,
63           const unsigned char *in,   unsigned long inlen,
64                 unsigned char *out,  unsigned long outlen);
65  #endif  &bsol;* LTC_HKDF */
66  int mem_neq(const void *a, const void *b, size_t len);
67  void zeromem(volatile void *out, size_t outlen);
68  void burn_stack(unsigned long len);
69  const char *error_to_string(int err);
70  extern const char *crypt_build_settings;
71  int crypt_fsa(void *mp, ...) LTC_NULL_TERMINATED;
72  int crypt_get_constant(const char* namein, int *valueout);
73  int crypt_list_all_constants(char *names_list, unsigned int *names_list_size);
74  int crypt_get_size(const char* namein, unsigned int *sizeout);
75  int crypt_list_all_sizes(char *names_list, unsigned int *names_list_size);
76  #ifdef LTM_DESC
77  LTC_DEPRECATED(crypt_mp_init) void init_LTM(void);
78  #endif
79  #ifdef TFM_DESC
80  LTC_DEPRECATED(crypt_mp_init) void init_TFM(void);
81  #endif
82  #ifdef GMP_DESC
83  LTC_DEPRECATED(crypt_mp_init) void init_GMP(void);
84  #endif
85  int crypt_mp_init(const char* mpi);
</pre></code></div>
                <div class="column column_space"><pre><code>294      const AVClass *av_class;
295      struct AVInputFormat *iformat;
296      struct AVOutputFormat *oformat;
297      void *priv_data;
298      AVIOContext *pb;
299      int ctx_flags;
300      unsigned int nb_streams;
301      AVStream **streams;
302      char filename[1024];
303      int64_t start_time;
304      int64_t duration;
305      int64_t bit_rate;
306      unsigned int packet_size;
307      int max_delay;
308      int flags;
309  #define AVFMT_FLAG_GENPTS       0x0001 
310  #define AVFMT_FLAG_IGNIDX       0x0002 
311  #define AVFMT_FLAG_NONBLOCK     0x0004 
312  #define AVFMT_FLAG_IGNDTS       0x0008 
313  #define AVFMT_FLAG_NOFILLIN     0x0010 
314  #define AVFMT_FLAG_NOPARSE      0x0020 
315  #define AVFMT_FLAG_NOBUFFER     0x0040 
316  #define AVFMT_FLAG_CUSTOM_IO    0x0080 
317  #define AVFMT_FLAG_DISCARD_CORRUPT  0x0100 
318  #define AVFMT_FLAG_FLUSH_PACKETS    0x0200 
319  #define AVFMT_FLAG_BITEXACT         0x0400
320  #define AVFMT_FLAG_MP4A_LATM    0x8000 
321  #define AVFMT_FLAG_SORT_DTS    0x10000 
322  #define AVFMT_FLAG_PRIV_OPT    0x20000 
323  #if FF_API_LAVF_KEEPSIDE_FLAG
324  #define AVFMT_FLAG_KEEP_SIDE_DATA 0x40000 
325  #endif
326  #define AVFMT_FLAG_FAST_SEEK   0x80000 
327  #define AVFMT_FLAG_SHORTEST   0x100000 
328  #define AVFMT_FLAG_AUTO_BSF   0x200000 
329      int64_t probesize;
330      int64_t max_analyze_duration;
331      const uint8_t *key;
332      int keylen;
333      unsigned int nb_programs;
334      AVProgram **programs;
335      enum AVCodecID video_codec_id;
336      enum AVCodecID audio_codec_id;
337      enum AVCodecID subtitle_codec_id;
338      unsigned int max_index_size;
339      unsigned int max_picture_buffer;
340      unsigned int nb_chapters;
341      AVChapter **chapters;
342      AVDictionary *metadata;
343      int64_t start_time_realtime;
344      int fps_probe_size;
345      int error_recognition;
346      AVIOInterruptCB interrupt_callback;
347      int debug;
348  #define FF_FDEBUG_TS        0x0001
349      int64_t max_interleave_delta;
350      int strict_std_compliance;
351      int event_flags;
352  #define AVFMT_EVENT_FLAG_METADATA_UPDATED 0x0001 
353      int max_ts_probe;
354      int avoid_negative_ts;
355  #define AVFMT_AVOID_NEG_TS_AUTO             -1 
356  #define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1 
357  #define AVFMT_AVOID_NEG_TS_MAKE_ZERO         2 
358      int ts_id;
359      int audio_preload;
360      int max_chunk_duration;
361      int max_chunk_size;
362      int use_wallclock_as_timestamps;
363      int avio_flags;
364      enum AVDurationEstimationMethod duration_estimation_method;
365      int64_t skip_initial_bytes;
366      unsigned int correct_ts_overflow;
367      int seek2any;
368      int flush_packets;
369      int probe_score;
370      int format_probesize;
371      char *codec_whitelist;
372      char *format_whitelist;
373      AVFormatInternal *internal;
374      int io_repositioned;
375      AVCodec *video_codec;
376      AVCodec *audio_codec;
377      AVCodec *subtitle_codec;
378      AVCodec *data_codec;
379      int metadata_header_padding;
380      void *opaque;
381      av_format_control_message control_message_cb;
382      int64_t output_ts_offset;
383      uint8_t *dump_separator;
384      enum AVCodecID data_codec_id;
385  #if FF_API_OLD_OPEN_CALLBACKS
386      attribute_deprecated
387      int (*open_cb)(struct AVFormatContext *s, AVIOContext **p, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    