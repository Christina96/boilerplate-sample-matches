
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.619718309859154%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft2 super;
7       plan *cld, *cldrest;
8       INT n, vl, nbuf, bufdist;
9       INT cs, ivs, ovs;
10  } P;
11  static void hc2c(INT n, R *r, R *rio, R *iio, INT os)
12  {
13       INT i;
14       rio[0] = r[0];
15       iio[0] = 0;
16       for (i = 1; i + i < n; ++i) {
17  	  rio[i * os] = r[i];
18  	  iio[i * os] = r[n - i];
19       }
20       if (i + i == n) {	&bsol;* store the Nyquist frequency */
21  	  rio[i * os] = r[i];
22  	  iio[i * os] = K(0.0);
23       }
24  }
25  static void c2hc(INT n, R *rio, R *iio, INT is, R *r)
26  {
27       INT i;
28       r[0] = rio[0];
29       for (i = 1; i + i < n; ++i) {
30  	  r[i] = rio[i * is];
31  	  r[n - i] = iio[i * is];
32       }
33       if (i + i == n)		&bsol;* store the Nyquist frequency */
34  	  r[i] = rio[i * is];
35  }
36  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
37  {
38       const P *ego = (const P *) ego_;
39       plan_rdft *cld = (plan_rdft *) ego->cld;
40       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
41       INT n = ego->n;
42       INT ivs = ego->ivs, ovs = ego->ovs, os = ego->cs;
43       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
44       plan_rdft2 *cldrest;
45       for (i = nbuf; i <= vl; i += nbuf) {
46            cld->apply((plan *) cld, r0, bufs);
47  	  r0 += ivs * nbuf; r1 += ivs * nbuf;
48  	  for (j = 0; j < nbuf; ++j, cr += ovs, ci += ovs)
49  	       hc2c(n, bufs + j*bufdist, cr, ci, os);
50       }
51       X(ifree)(bufs);
52       cldrest = (plan_rdft2 *) ego->cldrest;
53       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
54  }
55  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
56  {
57       const P *ego = (const P *) ego_;
58       plan_rdft *cld = (plan_rdft *) ego->cld;
59       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
60       INT n = ego->n;
61       INT ivs = ego->ivs, ovs = ego->ovs, is = ego->cs;
62       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
63       plan_rdft2 *cldrest;
64       for (i = nbuf; i <= vl; i += nbuf) {
65  	  for (j = 0; j < nbuf; ++j, cr += ivs, ci += ivs)
66  	       c2hc(n, cr, ci, is, bufs + j*bufdist);
67            cld->apply((plan *) cld, bufs, r0);
68  	  r0 += ovs * nbuf; r1 += ovs * nbuf;
69       }
70       X(ifree)(bufs);
71       cldrest = (plan_rdft2 *) ego->cldrest;
72       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
73  }
74  static void awake(plan *ego_, enum wakefulness wakefulness)
75  {
76       P *ego = (P *) ego_;
77       X(plan_awake)(ego->cld, wakefulness);
78       X(plan_awake)(ego->cldrest, wakefulness);
79  }
80  static void destroy(plan *ego_)
81  {
82       P *ego = (P *) ego_;
83       X(plan_destroy_internal)(ego->cldrest);
84       X(plan_destroy_internal)(ego->cld);
85  }
86  static void print(const plan *ego_, printer *p)
87  {
88       const P *ego = (const P *) ego_;
89       p->print(p, "(rdft2-rdft-%s-%D%v/%D-%D%(%p%)%(%p%))",
90  	      ego->super.apply == apply_r2hc ? "r2hc" : "hc2r",
91                ego->n, ego->nbuf,
92                ego->vl, ego->bufdist % ego->n,
93                ego->cld, ego->cldrest);
94  }
95  static INT min_nbuf(const problem_rdft2 *p, INT n, INT vl)
96  {
97       INT is, os, ivs, ovs;
98       if (p->r0 != p->cr)
99  	  return 1;
100       if (X(rdft2_inplace_strides(p, RNK_MINFTY)))
101  	  return 1;
102       A(p->vecsz->rnk == 1); &bsol;*  rank 0 and MINFTY are inplace */
103       X(rdft2_strides)(p->kind, p->sz->dims, &is, &os);
104       X(rdft2_strides)(p->kind, p->vecsz->dims, &ivs, &ovs);
105       if (n * X(iabs)(is) <= X(iabs)(ivs)
106  	 && (n/2 + 1) * X(iabs)(os) <= X(iabs)(ovs)
107  	 && ( ((p->cr - p->ci) <= X(iabs)(os)) || 
108  	      ((p->ci - p->cr) <= X(iabs)(os)) )
109  	 && ivs > 0 && ovs > 0) {
110  	  INT vsmin = X(imin)(ivs, ovs);
111  	  INT vsmax = X(imax)(ivs, ovs);
112  	  return(((vsmax - vsmin) * vl + vsmin - 1) / vsmin);
113       }
114       return vl; &bsol;* punt: just buffer the whole vector */
115  }
116  static int applicable0(const problem *p_, const S *ego, const planner *plnr)
117  {
118       const problem_rdft2 *p = (const problem_rdft2 *) p_;
119       UNUSED(ego);
120       return(1
121  	    && p->vecsz->rnk <= 1
122  	    && p->sz->rnk == 1
123  	    && (p->kind == R2HC || p->kind == HC2R)
124  	    && (2 * (p->r1 - p->r0) ==
125  		(((p->kind == R2HC) ? p->sz->dims[0].is : p->sz->dims[0].os)))
<span onclick='openModal()' class='match'>126  	    && !(X(toobig)(p->sz->dims[0].n) && CONSERVE_MEMORYP(plnr))
127  	  );
128  }
129  static int applicable(const problem *p_, const S *ego, const planner *plnr)
130  {
131       const problem_rdft2 *p;
</span>132       if (NO_BUFFERINGP(plnr)) return 0;
133       if (!applicable0(p_, ego, plnr)) return 0;
134       p = (const problem_rdft2 *) p_;
135       if (NO_UGLYP(plnr)) {
136  	  if (p->r0 != p->cr) return 0;
137  	  if (X(toobig)(p->sz->dims[0].n)) return 0;
138       }
139       return 1;
140  }
141  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
142  {
143       const S *ego = (const S *) ego_;
144       P *pln;
145       plan *cld = (plan *) 0;
146       plan *cldrest = (plan *) 0;
147       const problem_rdft2 *p = (const problem_rdft2 *) p_;
148       R *bufs = (R *) 0;
149       INT nbuf = 0, bufdist, n, vl;
150       INT ivs, ovs, rs, id, od;
151       static const plan_adt padt = {
152  	  X(rdft2_solve), awake, print, destroy
153       };
154       if (!applicable(p_, ego, plnr))
155            goto nada;
156       n = p->sz->dims[0].n;
157       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
158       nbuf = X(imax)(X(nbuf)(n, vl, 0), min_nbuf(p, n, vl));
159       bufdist = X(bufdist)(n, vl);
160       A(nbuf > 0);
161       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
162       id = ivs * (nbuf * (vl / nbuf));
163       od = ovs * (nbuf * (vl / nbuf));
164       if (p->kind == R2HC) {
165  	  cld = X(mkplan_f_d)(
166  	       plnr,
167  	       X(mkproblem_rdft_d)(
168  		    X(mktensor_1d)(n, p->sz->dims[0].is/2, 1),
169  		    X(mktensor_1d)(nbuf, ivs, bufdist),
170  		    TAINT(p->r0, ivs * nbuf), bufs, &p->kind),
171  	       0, 0, (p->r0 == p->cr) ? NO_DESTROY_INPUT : 0);
172  	  if (!cld) goto nada;
173  	  X(ifree)(bufs); bufs = 0;
174  	  cldrest = X(mkplan_d)(plnr, 
175  				X(mkproblem_rdft2_d)(
176  				     X(tensor_copy)(p->sz),
177  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
178  				     p->r0 + id, p->r1 + id, 
179  				     p->cr + od, p->ci + od,
180  				     p->kind));
181  	  if (!cldrest) goto nada;
182  	  pln = MKPLAN_RDFT2(P, &padt, apply_r2hc);
183       } else {
184  	  A(p->kind == HC2R);
185  	  cld = X(mkplan_f_d)(
186  	       plnr,
187  	       X(mkproblem_rdft_d)(
188  		    X(mktensor_1d)(n, 1, p->sz->dims[0].os/2),
189  		    X(mktensor_1d)(nbuf, bufdist, ovs),
190  		    bufs, TAINT(p->r0, ovs * nbuf), &p->kind),
191  	       0, 0, NO_DESTROY_INPUT); &bsol;* always ok to destroy bufs */
192  	  if (!cld) goto nada;
193  	  X(ifree)(bufs); bufs = 0;
194  	  cldrest = X(mkplan_d)(plnr, 
195  				X(mkproblem_rdft2_d)(
196  				     X(tensor_copy)(p->sz),
197  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
198  				     p->r0 + od, p->r1 + od, 
199  				     p->cr + id, p->ci + id,
200  				     p->kind));
201  	  if (!cldrest) goto nada;
202  	  pln = MKPLAN_RDFT2(P, &padt, apply_hc2r);
203       }
204       pln->cld = cld;
205       pln->cldrest = cldrest;
206       pln->n = n;
207       pln->vl = vl;
208       pln->ivs = ivs;
209       pln->ovs = ovs;
210       X(rdft2_strides)(p->kind, &p->sz->dims[0], &rs, &pln->cs);
211       pln->nbuf = nbuf;
212       pln->bufdist = bufdist;
213       X(ops_madd)(vl / nbuf, &cld->ops, &cldrest->ops,
214  		 &pln->super.super.ops);
215       pln->super.super.ops.other += (p->kind == R2HC ? (n + 2) : n) * vl;
216       return &(pln->super.super);
217   nada:
218       X(ifree0)(bufs);
219       X(plan_destroy_internal)(cldrest);
220       X(plan_destroy_internal)(cld);
221       return (plan *) 0;
222  }
223  static solver *mksolver(void)
224  {
225       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
226       S *slv = MKSOLVER(S, &sadt);
227       return &(slv->super);
228  }
229  void X(rdft2_rdft_register)(planner *p)
230  {
231       REGISTER_SOLVER(p, mksolver());
232  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-pointer.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_POINTER_H_
2  #define RAPIDJSON_POINTER_H_
3  #include "document.h"
4  #include "uri.h"
5  #include "internal/itoa.h"
6  #ifdef __clang__
7  RAPIDJSON_DIAG_PUSH
8  RAPIDJSON_DIAG_OFF(switch-enum)
9  #elif defined(_MSC_VER)
10  RAPIDJSON_DIAG_PUSH
11  RAPIDJSON_DIAG_OFF(4512) 
12  #endif
13  RAPIDJSON_NAMESPACE_BEGIN
14  static const SizeType kPointerInvalidIndex = ~SizeType(0);  
15  enum PointerParseErrorCode {
16      kPointerParseErrorNone = 0,                     
17      kPointerParseErrorTokenMustBeginWithSolidus,    
18      kPointerParseErrorInvalidEscape,                
19      kPointerParseErrorInvalidPercentEncoding,       
20      kPointerParseErrorCharacterMustPercentEncode    
21  };
22  template <typename ValueType, typename Allocator = CrtAllocator>
23  class GenericPointer {
24  public:
25      typedef typename ValueType::EncodingType EncodingType;  
26      typedef typename ValueType::Ch Ch;                      
27      typedef GenericUri<ValueType, Allocator> UriType;
28      struct Token {
29          const Ch* name;             
30          SizeType length;            
31          SizeType index;             
32      };
33      GenericPointer(Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {}
34      explicit GenericPointer(const Ch* source, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
35          Parse(source, internal::StrLen(source));
36      }
37  #if RAPIDJSON_HAS_STDSTRING
38      explicit GenericPointer(const std::basic_string<Ch>& source, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
39          Parse(source.c_str(), source.size());
40      }
41  #endif
42      GenericPointer(const Ch* source, size_t length, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
43          Parse(source, length);
44      }
45      GenericPointer(const Token* tokens, size_t tokenCount) : allocator_(), ownAllocator_(), nameBuffer_(), tokens_(const_cast<Token*>(tokens)), tokenCount_(tokenCount), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {}
46      GenericPointer(const GenericPointer& rhs) : allocator_(), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
47          *this = rhs;
48      }
49      GenericPointer(const GenericPointer& rhs, Allocator* allocator) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
50          *this = rhs;
51      }
52      ~GenericPointer() {
53          if (nameBuffer_)    
54              Allocator::Free(tokens_);
55          RAPIDJSON_DELETE(ownAllocator_);
56      }
57      GenericPointer& operator=(const GenericPointer& rhs) {
58          if (this != &rhs) {
59              if (nameBuffer_)
60                  Allocator::Free(tokens_);
61              tokenCount_ = rhs.tokenCount_;
62              parseErrorOffset_ = rhs.parseErrorOffset_;
63              parseErrorCode_ = rhs.parseErrorCode_;
64              if (rhs.nameBuffer_)
65                  CopyFromRaw(rhs); 
66              else {
67                  tokens_ = rhs.tokens_; 
68                  nameBuffer_ = 0;
69              }
70          }
71          return *this;
72      }
73      GenericPointer& Swap(GenericPointer& other) RAPIDJSON_NOEXCEPT {
74          internal::Swap(allocator_, other.allocator_);
75          internal::Swap(ownAllocator_, other.ownAllocator_);
76          internal::Swap(nameBuffer_, other.nameBuffer_);
77          internal::Swap(tokens_, other.tokens_);
78          internal::Swap(tokenCount_, other.tokenCount_);
79          internal::Swap(parseErrorOffset_, other.parseErrorOffset_);
80          internal::Swap(parseErrorCode_, other.parseErrorCode_);
81          return *this;
82      }
83      friend inline void swap(GenericPointer& a, GenericPointer& b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
84      GenericPointer Append(const Token& token, Allocator* allocator = 0) const {
85          GenericPointer r;
86          r.allocator_ = allocator;
87          Ch *p = r.CopyFromRaw(*this, 1, token.length + 1);
88          std::memcpy(p, token.name, (token.length + 1) * sizeof(Ch));
89          r.tokens_[tokenCount_].name = p;
90          r.tokens_[tokenCount_].length = token.length;
91          r.tokens_[tokenCount_].index = token.index;
92          return r;
93      }
94      GenericPointer Append(const Ch* name, SizeType length, Allocator* allocator = 0) const {
95          Token token = { name, length, kPointerInvalidIndex };
96          return Append(token, allocator);
97      }
98      template <typename T>
99      RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >), (GenericPointer))
100      Append(T* name, Allocator* allocator = 0) const {
101          return Append(name, internal::StrLen(name), allocator);
102      }
103  #if RAPIDJSON_HAS_STDSTRING
104      GenericPointer Append(const std::basic_string<Ch>& name, Allocator* allocator = 0) const {
<span onclick='openModal()' class='match'>105          return Append(name.c_str(), static_cast<SizeType>(name.size()), allocator);
106      }
107  #endif
108      GenericPointer Append(SizeType index, Allocator* allocator = 0) const {
109          char buffer[21];
110          char* end = sizeof(SizeType) == 4 ? internal::u32toa(index, buffer) : internal::u64toa(index, buffer);
</span>111          SizeType length = static_cast<SizeType>(end - buffer);
112          buffer[length] = '\0';
113          if (sizeof(Ch) == 1) {
114              Token token = { reinterpret_cast<Ch*>(buffer), length, index };
115              return Append(token, allocator);
116          }
117          else {
118              Ch name[21];
119              for (size_t i = 0; i <= length; i++)
120                  name[i] = static_cast<Ch>(buffer[i]);
121              Token token = { name, length, index };
122              return Append(token, allocator);
123          }
124      }
125      GenericPointer Append(const ValueType& token, Allocator* allocator = 0) const {
126          if (token.IsString())
127              return Append(token.GetString(), token.GetStringLength(), allocator);
128          else {
129              RAPIDJSON_ASSERT(token.IsUint64());
130              RAPIDJSON_ASSERT(token.GetUint64() <= SizeType(~0));
131              return Append(static_cast<SizeType>(token.GetUint64()), allocator);
132          }
133      }
134      bool IsValid() const { return parseErrorCode_ == kPointerParseErrorNone; }
135      size_t GetParseErrorOffset() const { return parseErrorOffset_; }
136      PointerParseErrorCode GetParseErrorCode() const { return parseErrorCode_; }
137      Allocator& GetAllocator() { return *allocator_; }
138      const Token* GetTokens() const { return tokens_; }
139      size_t GetTokenCount() const { return tokenCount_; }
140      bool operator==(const GenericPointer& rhs) const {
141          if (!IsValid() || !rhs.IsValid() || tokenCount_ != rhs.tokenCount_)
142              return false;
143          for (size_t i = 0; i < tokenCount_; i++) {
144              if (tokens_[i].index != rhs.tokens_[i].index ||
145                  tokens_[i].length != rhs.tokens_[i].length ||
146                  (tokens_[i].length != 0 && std::memcmp(tokens_[i].name, rhs.tokens_[i].name, sizeof(Ch)* tokens_[i].length) != 0))
147              {
148                  return false;
149              }
150          }
151          return true;
152      }
153      bool operator!=(const GenericPointer& rhs) const { return !(*this == rhs); }
154      bool operator<(const GenericPointer& rhs) const {
155          if (!IsValid())
156              return false;
157          if (!rhs.IsValid())
158              return true;
159          if (tokenCount_ != rhs.tokenCount_)
160              return tokenCount_ < rhs.tokenCount_;
161          for (size_t i = 0; i < tokenCount_; i++) {
162              if (tokens_[i].index != rhs.tokens_[i].index)
163                  return tokens_[i].index < rhs.tokens_[i].index;
164              if (tokens_[i].length != rhs.tokens_[i].length)
165                  return tokens_[i].length < rhs.tokens_[i].length;
166              if (int cmp = std::memcmp(tokens_[i].name, rhs.tokens_[i].name, sizeof(Ch) * tokens_[i].length))
167                  return cmp < 0;
168          }
169          return false;
170      }
171      template<typename OutputStream>
172      bool Stringify(OutputStream& os) const {
173          return Stringify<false, OutputStream>(os);
174      }
175      template<typename OutputStream>
176      bool StringifyUriFragment(OutputStream& os) const {
177          return Stringify<true, OutputStream>(os);
178      }
179      ValueType& Create(ValueType& root, typename ValueType::AllocatorType& allocator, bool* alreadyExist = 0) const {
180          RAPIDJSON_ASSERT(IsValid());
181          ValueType* v = &root;
182          bool exist = true;
183          for (const Token *t = tokens_; t != tokens_ + tokenCount_; ++t) {
184              if (v->IsArray() && t->name[0] == '-' && t->length == 1) {
185                  v->PushBack(ValueType().Move(), allocator);
186                  v = &((*v)[v->Size() - 1]);
187                  exist = false;
188              }
189              else {
190                  if (t->index == kPointerInvalidIndex) { 
191                      if (!v->IsObject())
192                          v->SetObject(); 
193                  }
194                  else { 
195                      if (!v->IsArray() && !v->IsObject())
196                          v->SetArray(); 
197                  }
198                  if (v->IsArray()) {
199                      if (t->index >= v->Size()) {
200                          v->Reserve(t->index + 1, allocator);
201                          while (t->index >= v->Size())
202                              v->PushBack(ValueType().Move(), allocator);
203                          exist = false;
204                      }
205                      v = &((*v)[t->index]);
206                  }
207                  else {
208                      typename ValueType::MemberIterator m = v->FindMember(GenericValue<EncodingType>(GenericStringRef<Ch>(t->name, t->length)));
209                      if (m == v->MemberEnd()) {
210                          v->AddMember(ValueType(t->name, t->length, allocator).Move(), ValueType().Move(), allocator);
211                          m = v->MemberEnd();
212                          v = &(--m)->value; 
213                          exist = false;
214                      }
215                      else
216                          v = &m->value;
217                  }
218              }
219          }
220          if (alreadyExist)
221              *alreadyExist = exist;
222          return *v;
223      }
224      template <typename stackAllocator>
225      ValueType& Create(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, bool* alreadyExist = 0) const {
226          return Create(document, document.GetAllocator(), alreadyExist);
227      }
228      UriType GetUri(ValueType& root, const UriType& rootUri, size_t* unresolvedTokenIndex = 0, Allocator* allocator = 0) const {
229          static const Ch kIdString[] = { 'i', 'd', '\0' };
230          static const ValueType kIdValue(kIdString, 2);
231          UriType base = UriType(rootUri, allocator);
232          RAPIDJSON_ASSERT(IsValid());
233          ValueType* v = &root;
234          for (const Token *t = tokens_; t != tokens_ + tokenCount_; ++t) {
235              switch (v->GetType()) {
236                  case kObjectType:
237                  {
238                      typename ValueType::MemberIterator m = v->FindMember(kIdValue);
239                      if (m != v->MemberEnd() && (m->value).IsString()) {
240                          UriType here = UriType(m->value, allocator).Resolve(base, allocator);
241                          base = here;
242                      }
243                      m = v->FindMember(GenericValue<EncodingType>(GenericStringRef<Ch>(t->name, t->length)));
244                      if (m == v->MemberEnd())
245                          break;
246                      v = &m->value;
247                  }
248                    continue;
249                  case kArrayType:
250                      if (t->index == kPointerInvalidIndex || t->index >= v->Size())
251                          break;
252                      v = &((*v)[t->index]);
253                      continue;
254                  default:
255                      break;
256              }
257              if (unresolvedTokenIndex)
258                  *unresolvedTokenIndex = static_cast<size_t>(t - tokens_);
259              return UriType(allocator);
260          }
261          return base;
262      }
263      UriType GetUri(const ValueType& root, const UriType& rootUri, size_t* unresolvedTokenIndex = 0, Allocator* allocator = 0) const {
264        return GetUri(const_cast<ValueType&>(root), rootUri, unresolvedTokenIndex, allocator);
265      }
266      ValueType* Get(ValueType& root, size_t* unresolvedTokenIndex = 0) const {
267          RAPIDJSON_ASSERT(IsValid());
268          ValueType* v = &root;
269          for (const Token *t = tokens_; t != tokens_ + tokenCount_; ++t) {
270              switch (v->GetType()) {
271              case kObjectType:
272                  {
273                      typename ValueType::MemberIterator m = v->FindMember(GenericValue<EncodingType>(GenericStringRef<Ch>(t->name, t->length)));
274                      if (m == v->MemberEnd())
275                          break;
276                      v = &m->value;
277                  }
278                  continue;
279              case kArrayType:
280                  if (t->index == kPointerInvalidIndex || t->index >= v->Size())
281                      break;
282                  v = &((*v)[t->index]);
283                  continue;
284              default:
285                  break;
286              }
287              if (unresolvedTokenIndex)
288                  *unresolvedTokenIndex = static_cast<size_t>(t - tokens_);
289              return 0;
290          }
291          return v;
292      }
293      const ValueType* Get(const ValueType& root, size_t* unresolvedTokenIndex = 0) const {
294          return Get(const_cast<ValueType&>(root), unresolvedTokenIndex);
295      }
296      ValueType& GetWithDefault(ValueType& root, const ValueType& defaultValue, typename ValueType::AllocatorType& allocator) const {
297          bool alreadyExist;
298          ValueType& v = Create(root, allocator, &alreadyExist);
299          return alreadyExist ? v : v.CopyFrom(defaultValue, allocator);
300      }
301      ValueType& GetWithDefault(ValueType& root, const Ch* defaultValue, typename ValueType::AllocatorType& allocator) const {
302          bool alreadyExist;
303          ValueType& v = Create(root, allocator, &alreadyExist);
304          return alreadyExist ? v : v.SetString(defaultValue, allocator);
305      }
306  #if RAPIDJSON_HAS_STDSTRING
307      ValueType& GetWithDefault(ValueType& root, const std::basic_string<Ch>& defaultValue, typename ValueType::AllocatorType& allocator) const {
308          bool alreadyExist;
309          ValueType& v = Create(root, allocator, &alreadyExist);
310          return alreadyExist ? v : v.SetString(defaultValue, allocator);
311      }
312  #endif
313      template <typename T>
314      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
315      GetWithDefault(ValueType& root, T defaultValue, typename ValueType::AllocatorType& allocator) const {
316          return GetWithDefault(root, ValueType(defaultValue).Move(), allocator);
317      }
318      template <typename stackAllocator>
319      ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const ValueType& defaultValue) const {
320          return GetWithDefault(document, defaultValue, document.GetAllocator());
321      }
322      template <typename stackAllocator>
323      ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const Ch* defaultValue) const {
324          return GetWithDefault(document, defaultValue, document.GetAllocator());
325      }
326  #if RAPIDJSON_HAS_STDSTRING
327      template <typename stackAllocator>
328      ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const std::basic_string<Ch>& defaultValue) const {
329          return GetWithDefault(document, defaultValue, document.GetAllocator());
330      }
331  #endif
332      template <typename T, typename stackAllocator>
333      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
334      GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, T defaultValue) const {
335          return GetWithDefault(document, defaultValue, document.GetAllocator());
336      }
337      ValueType& Set(ValueType& root, ValueType& value, typename ValueType::AllocatorType& allocator) const {
338          return Create(root, allocator) = value;
339      }
340      ValueType& Set(ValueType& root, const ValueType& value, typename ValueType::AllocatorType& allocator) const {
341          return Create(root, allocator).CopyFrom(value, allocator);
342      }
343      ValueType& Set(ValueType& root, const Ch* value, typename ValueType::AllocatorType& allocator) const {
344          return Create(root, allocator) = ValueType(value, allocator).Move();
345      }
346  #if RAPIDJSON_HAS_STDSTRING
347      ValueType& Set(ValueType& root, const std::basic_string<Ch>& value, typename ValueType::AllocatorType& allocator) const {
348          return Create(root, allocator) = ValueType(value, allocator).Move();
349      }
350  #endif
351      template <typename T>
352      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
353      Set(ValueType& root, T value, typename ValueType::AllocatorType& allocator) const {
354          return Create(root, allocator) = ValueType(value).Move();
355      }
356      template <typename stackAllocator>
357      ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, ValueType& value) const {
358          return Create(document) = value;
359      }
360      template <typename stackAllocator>
361      ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const ValueType& value) const {
362          return Create(document).CopyFrom(value, document.GetAllocator());
363      }
364      template <typename stackAllocator>
365      ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const Ch* value) const {
366          return Create(document) = ValueType(value, document.GetAllocator()).Move();
367      }
368  #if RAPIDJSON_HAS_STDSTRING
369      template <typename stackAllocator>
370      ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const std::basic_string<Ch>& value) const {
371          return Create(document) = ValueType(value, document.GetAllocator()).Move();
372      }
373  #endif
374      template <typename T, typename stackAllocator>
375      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
376          Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, T value) const {
377              return Create(document) = value;
378      }
379      ValueType& Swap(ValueType& root, ValueType& value, typename ValueType::AllocatorType& allocator) const {
380          return Create(root, allocator).Swap(value);
381      }
382      template <typename stackAllocator>
383      ValueType& Swap(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, ValueType& value) const {
384          return Create(document).Swap(value);
385      }
386      bool Erase(ValueType& root) const {
387          RAPIDJSON_ASSERT(IsValid());
388          if (tokenCount_ == 0) 
389              return false;
390          ValueType* v = &root;
391          const Token* last = tokens_ + (tokenCount_ - 1);
392          for (const Token *t = tokens_; t != last; ++t) {
393              switch (v->GetType()) {
394              case kObjectType:
395                  {
396                      typename ValueType::MemberIterator m = v->FindMember(GenericValue<EncodingType>(GenericStringRef<Ch>(t->name, t->length)));
397                      if (m == v->MemberEnd())
398                          return false;
399                      v = &m->value;
400                  }
401                  break;
402              case kArrayType:
403                  if (t->index == kPointerInvalidIndex || t->index >= v->Size())
404                      return false;
405                  v = &((*v)[t->index]);
406                  break;
407              default:
408                  return false;
409              }
410          }
411          switch (v->GetType()) {
412          case kObjectType:
413              return v->EraseMember(GenericStringRef<Ch>(last->name, last->length));
414          case kArrayType:
415              if (last->index == kPointerInvalidIndex || last->index >= v->Size())
416                  return false;
417              v->Erase(v->Begin() + last->index);
418              return true;
419          default:
420              return false;
421          }
422      }
423  private:
424      Ch* CopyFromRaw(const GenericPointer& rhs, size_t extraToken = 0, size_t extraNameBufferSize = 0) {
425          if (!allocator_) 
426              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
427          size_t nameBufferSize = rhs.tokenCount_; 
428          for (Token *t = rhs.tokens_; t != rhs.tokens_ + rhs.tokenCount_; ++t)
429              nameBufferSize += t->length;
430          tokenCount_ = rhs.tokenCount_ + extraToken;
431          tokens_ = static_cast<Token *>(allocator_->Malloc(tokenCount_ * sizeof(Token) + (nameBufferSize + extraNameBufferSize) * sizeof(Ch)));
432          nameBuffer_ = reinterpret_cast<Ch *>(tokens_ + tokenCount_);
433          if (rhs.tokenCount_ > 0) {
434              std::memcpy(tokens_, rhs.tokens_, rhs.tokenCount_ * sizeof(Token));
435          }
436          if (nameBufferSize > 0) {
437              std::memcpy(nameBuffer_, rhs.nameBuffer_, nameBufferSize * sizeof(Ch));
438          }
439          std::ptrdiff_t diff = nameBuffer_ - rhs.nameBuffer_;
440          for (Token *t = tokens_; t != tokens_ + rhs.tokenCount_; ++t)
441              t->name += diff;
442          return nameBuffer_ + nameBufferSize;
443      }
444      bool NeedPercentEncode(Ch c) const {
445          return !((c >= '0' && c <= '9') || (c >= 'A' && c <='Z') || (c >= 'a' && c <= 'z') || c == '-' || c == '.' || c == '_' || c =='~');
446      }
447  #ifndef __clang__ 
448  #endif
449      void Parse(const Ch* source, size_t length) {
450          RAPIDJSON_ASSERT(source != NULL);
451          RAPIDJSON_ASSERT(nameBuffer_ == 0);
452          RAPIDJSON_ASSERT(tokens_ == 0);
453          if (!allocator_)
454              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
455          tokenCount_ = 0;
456          for (const Ch* s = source; s != source + length; s++)
457              if (*s == '/')
458                  tokenCount_++;
459          Token* token = tokens_ = static_cast<Token *>(allocator_->Malloc(tokenCount_ * sizeof(Token) + length * sizeof(Ch)));
460          Ch* name = nameBuffer_ = reinterpret_cast<Ch *>(tokens_ + tokenCount_);
461          size_t i = 0;
462          bool uriFragment = false;
463          if (source[i] == '#') {
464              uriFragment = true;
465              i++;
466          }
467          if (i != length && source[i] != '/') {
468              parseErrorCode_ = kPointerParseErrorTokenMustBeginWithSolidus;
469              goto error;
470          }
471          while (i < length) {
472              RAPIDJSON_ASSERT(source[i] == '/');
473              i++; 
474              token->name = name;
475              bool isNumber = true;
476              while (i < length && source[i] != '/') {
477                  Ch c = source[i];
478                  if (uriFragment) {
479                      if (c == '%') {
480                          PercentDecodeStream is(&source[i], source + length);
481                          GenericInsituStringStream<EncodingType> os(name);
482                          Ch* begin = os.PutBegin();
483                          if (!Transcoder<UTF8<>, EncodingType>().Validate(is, os) || !is.IsValid()) {
484                              parseErrorCode_ = kPointerParseErrorInvalidPercentEncoding;
485                              goto error;
486                          }
487                          size_t len = os.PutEnd(begin);
488                          i += is.Tell() - 1;
489                          if (len == 1)
490                              c = *name;
491                          else {
492                              name += len;
493                              isNumber = false;
494                              i++;
495                              continue;
496                          }
497                      }
498                      else if (NeedPercentEncode(c)) {
499                          parseErrorCode_ = kPointerParseErrorCharacterMustPercentEncode;
500                          goto error;
501                      }
502                  }
503                  i++;
504                  if (c == '~') {
505                      if (i < length) {
506                          c = source[i];
507                          if (c == '0')       c = '~';
508                          else if (c == '1')  c = '/';
509                          else {
510                              parseErrorCode_ = kPointerParseErrorInvalidEscape;
511                              goto error;
512                          }
513                          i++;
514                      }
515                      else {
516                          parseErrorCode_ = kPointerParseErrorInvalidEscape;
517                          goto error;
518                      }
519                  }
520                  if (c < '0' || c > '9')
521                      isNumber = false;
522                  *name++ = c;
523              }
524              token->length = static_cast<SizeType>(name - token->name);
525              if (token->length == 0)
526                  isNumber = false;
527              *name++ = '\0'; 
528              if (isNumber && token->length > 1 && token->name[0] == '0')
529                  isNumber = false;
530              SizeType n = 0;
531              if (isNumber) {
532                  for (size_t j = 0; j < token->length; j++) {
533                      SizeType m = n * 10 + static_cast<SizeType>(token->name[j] - '0');
534                      if (m < n) {   
535                          isNumber = false;
536                          break;
537                      }
538                      n = m;
539                  }
540              }
541              token->index = isNumber ? n : kPointerInvalidIndex;
542              token++;
543          }
544          RAPIDJSON_ASSERT(name <= nameBuffer_ + length); 
545          parseErrorCode_ = kPointerParseErrorNone;
546          return;
547      error:
548          Allocator::Free(tokens_);
549          nameBuffer_ = 0;
550          tokens_ = 0;
551          tokenCount_ = 0;
552          parseErrorOffset_ = i;
553          return;
554      }
555      template<bool uriFragment, typename OutputStream>
556      bool Stringify(OutputStream& os) const {
557          RAPIDJSON_ASSERT(IsValid());
558          if (uriFragment)
559              os.Put('#');
560          for (Token *t = tokens_; t != tokens_ + tokenCount_; ++t) {
561              os.Put('/');
562              for (size_t j = 0; j < t->length; j++) {
563                  Ch c = t->name[j];
564                  if (c == '~') {
565                      os.Put('~');
566                      os.Put('0');
567                  }
568                  else if (c == '/') {
569                      os.Put('~');
570                      os.Put('1');
571                  }
572                  else if (uriFragment && NeedPercentEncode(c)) {
573                      GenericStringStream<typename ValueType::EncodingType> source(&t->name[j]);
574                      PercentEncodeStream<OutputStream> target(os);
575                      if (!Transcoder<EncodingType, UTF8<> >().Validate(source, target))
576                          return false;
577                      j += source.Tell() - 1;
578                  }
579                  else
580                      os.Put(c);
581              }
582          }
583          return true;
584      }
585      class PercentDecodeStream {
586      public:
587          typedef typename ValueType::Ch Ch;
588          PercentDecodeStream(const Ch* source, const Ch* end) : src_(source), head_(source), end_(end), valid_(true) {}
589          Ch Take() {
590              if (*src_ != '%' || src_ + 3 > end_) { 
591                  valid_ = false;
592                  return 0;
593              }
594              src_++;
595              Ch c = 0;
596              for (int j = 0; j < 2; j++) {
597                  c = static_cast<Ch>(c << 4);
598                  Ch h = *src_;
599                  if      (h >= '0' && h <= '9') c = static_cast<Ch>(c + h - '0');
600                  else if (h >= 'A' && h <= 'F') c = static_cast<Ch>(c + h - 'A' + 10);
601                  else if (h >= 'a' && h <= 'f') c = static_cast<Ch>(c + h - 'a' + 10);
602                  else {
603                      valid_ = false;
604                      return 0;
605                  }
606                  src_++;
607              }
608              return c;
609          }
610          size_t Tell() const { return static_cast<size_t>(src_ - head_); }
611          bool IsValid() const { return valid_; }
612      private:
613          const Ch* src_;     
614          const Ch* head_;    
615          const Ch* end_;     
616          bool valid_;        
617      };
618      template <typename OutputStream>
619      class PercentEncodeStream {
620      public:
621          PercentEncodeStream(OutputStream& os) : os_(os) {}
622          void Put(char c) { 
623              unsigned char u = static_cast<unsigned char>(c);
624              static const char hexDigits[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
625              os_.Put('%');
626              os_.Put(static_cast<typename OutputStream::Ch>(hexDigits[u >> 4]));
627              os_.Put(static_cast<typename OutputStream::Ch>(hexDigits[u & 15]));
628          }
629      private:
630          OutputStream& os_;
631      };
632      Allocator* allocator_;                  
633      Allocator* ownAllocator_;               
634      Ch* nameBuffer_;                        
635      Token* tokens_;                         
636      size_t tokenCount_;                     
637      size_t parseErrorOffset_;               
638      PointerParseErrorCode parseErrorCode_;  
639  };
640  typedef GenericPointer<Value> Pointer;
641  template <typename T>
642  typename T::ValueType& CreateValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::AllocatorType& a) {
643      return pointer.Create(root, a);
644  }
645  template <typename T, typename CharType, size_t N>
646  typename T::ValueType& CreateValueByPointer(T& root, const CharType(&source)[N], typename T::AllocatorType& a) {
647      return GenericPointer<typename T::ValueType>(source, N - 1).Create(root, a);
648  }
649  template <typename DocumentType>
650  typename DocumentType::ValueType& CreateValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer) {
651      return pointer.Create(document);
652  }
653  template <typename DocumentType, typename CharType, size_t N>
654  typename DocumentType::ValueType& CreateValueByPointer(DocumentType& document, const CharType(&source)[N]) {
655      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Create(document);
656  }
657  template <typename T>
658  typename T::ValueType* GetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, size_t* unresolvedTokenIndex = 0) {
659      return pointer.Get(root, unresolvedTokenIndex);
660  }
661  template <typename T>
662  const typename T::ValueType* GetValueByPointer(const T& root, const GenericPointer<typename T::ValueType>& pointer, size_t* unresolvedTokenIndex = 0) {
663      return pointer.Get(root, unresolvedTokenIndex);
664  }
665  template <typename T, typename CharType, size_t N>
666  typename T::ValueType* GetValueByPointer(T& root, const CharType (&source)[N], size_t* unresolvedTokenIndex = 0) {
667      return GenericPointer<typename T::ValueType>(source, N - 1).Get(root, unresolvedTokenIndex);
668  }
669  template <typename T, typename CharType, size_t N>
670  const typename T::ValueType* GetValueByPointer(const T& root, const CharType(&source)[N], size_t* unresolvedTokenIndex = 0) {
671      return GenericPointer<typename T::ValueType>(source, N - 1).Get(root, unresolvedTokenIndex);
672  }
673  template <typename T>
674  typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::ValueType& defaultValue, typename T::AllocatorType& a) {
675      return pointer.GetWithDefault(root, defaultValue, a);
676  }
677  template <typename T>
678  typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::Ch* defaultValue, typename T::AllocatorType& a) {
679      return pointer.GetWithDefault(root, defaultValue, a);
680  }
681  #if RAPIDJSON_HAS_STDSTRING
682  template <typename T>
683  typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const std::basic_string<typename T::Ch>& defaultValue, typename T::AllocatorType& a) {
684      return pointer.GetWithDefault(root, defaultValue, a);
685  }
686  #endif
687  template <typename T, typename T2>
688  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
689  GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, T2 defaultValue, typename T::AllocatorType& a) {
690      return pointer.GetWithDefault(root, defaultValue, a);
691  }
692  template <typename T, typename CharType, size_t N>
693  typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const typename T::ValueType& defaultValue, typename T::AllocatorType& a) {
694      return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
695  }
696  template <typename T, typename CharType, size_t N>
697  typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const typename T::Ch* defaultValue, typename T::AllocatorType& a) {
698      return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
699  }
700  #if RAPIDJSON_HAS_STDSTRING
701  template <typename T, typename CharType, size_t N>
702  typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const std::basic_string<typename T::Ch>& defaultValue, typename T::AllocatorType& a) {
703      return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
704  }
705  #endif
706  template <typename T, typename CharType, size_t N, typename T2>
707  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
708  GetValueByPointerWithDefault(T& root, const CharType(&source)[N], T2 defaultValue, typename T::AllocatorType& a) {
709      return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
710  }
711  template <typename DocumentType>
712  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::ValueType& defaultValue) {
713      return pointer.GetWithDefault(document, defaultValue);
714  }
715  template <typename DocumentType>
716  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::Ch* defaultValue) {
717      return pointer.GetWithDefault(document, defaultValue);
718  }
719  #if RAPIDJSON_HAS_STDSTRING
720  template <typename DocumentType>
721  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const std::basic_string<typename DocumentType::Ch>& defaultValue) {
722      return pointer.GetWithDefault(document, defaultValue);
723  }
724  #endif
725  template <typename DocumentType, typename T2>
726  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
727  GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, T2 defaultValue) {
728      return pointer.GetWithDefault(document, defaultValue);
729  }
730  template <typename DocumentType, typename CharType, size_t N>
731  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const typename DocumentType::ValueType& defaultValue) {
732      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
733  }
734  template <typename DocumentType, typename CharType, size_t N>
735  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const typename DocumentType::Ch* defaultValue) {
736      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
737  }
738  #if RAPIDJSON_HAS_STDSTRING
739  template <typename DocumentType, typename CharType, size_t N>
740  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const std::basic_string<typename DocumentType::Ch>& defaultValue) {
741      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
742  }
743  #endif
744  template <typename DocumentType, typename CharType, size_t N, typename T2>
745  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
746  GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], T2 defaultValue) {
747      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
748  }
749  template <typename T>
750  typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::ValueType& value, typename T::AllocatorType& a) {
751      return pointer.Set(root, value, a);
752  }
753  template <typename T>
754  typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::ValueType& value, typename T::AllocatorType& a) {
755      return pointer.Set(root, value, a);
756  }
757  template <typename T>
758  typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::Ch* value, typename T::AllocatorType& a) {
759      return pointer.Set(root, value, a);
760  }
761  #if RAPIDJSON_HAS_STDSTRING
762  template <typename T>
763  typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const std::basic_string<typename T::Ch>& value, typename T::AllocatorType& a) {
764      return pointer.Set(root, value, a);
765  }
766  #endif
767  template <typename T, typename T2>
768  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
769  SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, T2 value, typename T::AllocatorType& a) {
770      return pointer.Set(root, value, a);
771  }
772  template <typename T, typename CharType, size_t N>
773  typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], typename T::ValueType& value, typename T::AllocatorType& a) {
774      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
775  }
776  template <typename T, typename CharType, size_t N>
777  typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const typename T::ValueType& value, typename T::AllocatorType& a) {
778      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
779  }
780  template <typename T, typename CharType, size_t N>
781  typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const typename T::Ch* value, typename T::AllocatorType& a) {
782      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
783  }
784  #if RAPIDJSON_HAS_STDSTRING
785  template <typename T, typename CharType, size_t N>
786  typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const std::basic_string<typename T::Ch>& value, typename T::AllocatorType& a) {
787      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
788  }
789  #endif
790  template <typename T, typename CharType, size_t N, typename T2>
791  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
792  SetValueByPointer(T& root, const CharType(&source)[N], T2 value, typename T::AllocatorType& a) {
793      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
794  }
795  template <typename DocumentType>
796  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, typename DocumentType::ValueType& value) {
797      return pointer.Set(document, value);
798  }
799  template <typename DocumentType>
800  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::ValueType& value) {
801      return pointer.Set(document, value);
802  }
803  template <typename DocumentType>
804  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::Ch* value) {
805      return pointer.Set(document, value);
806  }
807  #if RAPIDJSON_HAS_STDSTRING
808  template <typename DocumentType>
809  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const std::basic_string<typename DocumentType::Ch>& value) {
810      return pointer.Set(document, value);
811  }
812  #endif
813  template <typename DocumentType, typename T2>
814  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
815  SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, T2 value) {
816      return pointer.Set(document, value);
817  }
818  template <typename DocumentType, typename CharType, size_t N>
819  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], typename DocumentType::ValueType& value) {
820      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
821  }
822  template <typename DocumentType, typename CharType, size_t N>
823  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const typename DocumentType::ValueType& value) {
824      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
825  }
826  template <typename DocumentType, typename CharType, size_t N>
827  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const typename DocumentType::Ch* value) {
828      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
829  }
830  #if RAPIDJSON_HAS_STDSTRING
831  template <typename DocumentType, typename CharType, size_t N>
832  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const std::basic_string<typename DocumentType::Ch>& value) {
833      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
834  }
835  #endif
836  template <typename DocumentType, typename CharType, size_t N, typename T2>
837  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
838  SetValueByPointer(DocumentType& document, const CharType(&source)[N], T2 value) {
839      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
840  }
841  template <typename T>
842  typename T::ValueType& SwapValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::ValueType& value, typename T::AllocatorType& a) {
843      return pointer.Swap(root, value, a);
844  }
845  template <typename T, typename CharType, size_t N>
846  typename T::ValueType& SwapValueByPointer(T& root, const CharType(&source)[N], typename T::ValueType& value, typename T::AllocatorType& a) {
847      return GenericPointer<typename T::ValueType>(source, N - 1).Swap(root, value, a);
848  }
849  template <typename DocumentType>
850  typename DocumentType::ValueType& SwapValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, typename DocumentType::ValueType& value) {
851      return pointer.Swap(document, value);
852  }
853  template <typename DocumentType, typename CharType, size_t N>
854  typename DocumentType::ValueType& SwapValueByPointer(DocumentType& document, const CharType(&source)[N], typename DocumentType::ValueType& value) {
855      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Swap(document, value);
856  }
857  template <typename T>
858  bool EraseValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer) {
859      return pointer.Erase(root);
860  }
861  template <typename T, typename CharType, size_t N>
862  bool EraseValueByPointer(T& root, const CharType(&source)[N]) {
863      return GenericPointer<typename T::ValueType>(source, N - 1).Erase(root);
864  }
865  RAPIDJSON_NAMESPACE_END
866  #if defined(__clang__) || defined(_MSC_VER)
867  RAPIDJSON_DIAG_POP
868  #endif
869  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-pointer.h</div>
                </div>
                <div class="column column_space"><pre><code>126  	    && !(X(toobig)(p->sz->dims[0].n) && CONSERVE_MEMORYP(plnr))
127  	  );
128  }
129  static int applicable(const problem *p_, const S *ego, const planner *plnr)
130  {
131       const problem_rdft2 *p;
</pre></code></div>
                <div class="column column_space"><pre><code>105          return Append(name.c_str(), static_cast<SizeType>(name.size()), allocator);
106      }
107  #endif
108      GenericPointer Append(SizeType index, Allocator* allocator = 0) const {
109          char buffer[21];
110          char* end = sizeof(SizeType) == 4 ? internal::u32toa(index, buffer) : internal::u64toa(index, buffer);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    