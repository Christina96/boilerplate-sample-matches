
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.473423104181432%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-vrank-geq1.c</h3>
            <pre><code>1  #include "threads/threads.h"
2  typedef struct {
3       solver super;
4       int vecloop_dim;
5       const int *buddies;
6       size_t nbuddies;
7  } S;
8  typedef struct {
9       plan_dft super;
10       plan **cldrn;
11       INT its, ots;
12       int nthr;
13       const S *solver;
14  } P;
15  typedef struct {
16       INT its, ots;
17       R *ri, *ii, *ro, *io;
18       plan **cldrn;
19  } PD;
20  static void *spawn_apply(spawn_data *d)
21  {
22       PD *ego = (PD *) d->data;
23       INT its = ego->its;
24       INT ots = ego->ots;
25       int thr_num = d->thr_num;
26       plan_dft *cld = (plan_dft *) ego->cldrn[thr_num];
27       cld->apply((plan *) cld,
28  		ego->ri + thr_num * its, ego->ii + thr_num * its,
29  		ego->ro + thr_num * ots, ego->io + thr_num * ots);
30       return 0;
31  }
32  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
33  {
34       const P *ego = (const P *) ego_;
35       PD d;
36       d.its = ego->its;
37       d.ots = ego->ots;
38       d.cldrn = ego->cldrn;
39       d.ri = ri; d.ii = ii; d.ro = ro; d.io = io;
40       X(spawn_loop)(ego->nthr, ego->nthr, spawn_apply, (void*) &d);
41  }
42  static void awake(plan *ego_, enum wakefulness wakefulness)
43  {
44       P *ego = (P *) ego_;
45       int i;
46       for (i = 0; i < ego->nthr; ++i)
47  	  X(plan_awake)(ego->cldrn[i], wakefulness);
48  }
49  static void destroy(plan *ego_)
50  {
51       P *ego = (P *) ego_;
52       int i;
53       for (i = 0; i < ego->nthr; ++i)
54  	  X(plan_destroy_internal)(ego->cldrn[i]);
55       X(ifree)(ego->cldrn);
56  }
57  static void print(const plan *ego_, printer *p)
58  {
59       const P *ego = (const P *) ego_;
60       const S *s = ego->solver;
61       int i;
62       p->print(p, "(dft-thr-vrank>=1-x%d/%d", ego->nthr, s->vecloop_dim);
63       for (i = 0; i < ego->nthr; ++i)
64  	  if (i == 0 || (ego->cldrn[i] != ego->cldrn[i-1] &&
65  			 (i <= 1 || ego->cldrn[i] != ego->cldrn[i-2])))
66  	       p->print(p, "%(%p%)", ego->cldrn[i]);
67       p->putchr(p, ')');
68  }
69  static int pickdim(const S *ego, const tensor *vecsz, int oop, int *dp)
70  {
71       return X(pickdim)(ego->vecloop_dim, ego->buddies, ego->nbuddies,
72                         vecsz, oop, dp);
73  }
74  static int applicable0(const solver *ego_, const problem *p_,
75  		       const planner *plnr, int *dp)
76  {
77       const S *ego = (const S *) ego_;
78       const problem_dft *p = (const problem_dft *) p_;
79       return (1
80  	     && plnr->nthr > 1
81  	     && FINITE_RNK(p->vecsz->rnk)
82  	     && p->vecsz->rnk > 0
83  	     && pickdim(ego, p->vecsz, p->ri != p->ro, dp)
84  	  );
85  }
86  static int applicable(const solver *ego_, const problem *p_,
87  		      const planner *plnr, int *dp)
88  {
89       const S *ego = (const S *)ego_;
90       if (!applicable0(ego_, p_, plnr, dp)) return 0;
91       if (NO_VRANK_SPLITSP(plnr) && (ego->vecloop_dim != ego->buddies[0]))
92  	  return 0;
93       return 1;
94  }
95  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
96  {
97       const S *ego = (const S *) ego_;
98       const problem_dft *p;
99       P *pln;
100       problem *cldp;
101       int vdim;
102       iodim *d;
103       plan **cldrn = (plan **) 0;
104       int i, nthr;
105       INT its, ots, block_size;
106       tensor *vecsz = 0;
107       static const plan_adt padt = {
108  	  X(dft_solve), awake, print, destroy
109       };
110       if (!applicable(ego_, p_, plnr, &vdim))
111            return (plan *) 0;
112       p = (const problem_dft *) p_;
113       d = p->vecsz->dims + vdim;
114       block_size = (d->n + plnr->nthr - 1) / plnr->nthr;
115       nthr = (int)((d->n + block_size - 1) / block_size);
116       plnr->nthr = (plnr->nthr + nthr - 1) / nthr;
117       its = d->is * block_size;
118       ots = d->os * block_size;
119       cldrn = (plan **)MALLOC(sizeof(plan *) * nthr, PLANS);
120       for (i = 0; i < nthr; ++i) cldrn[i] = (plan *) 0;
121       vecsz = X(tensor_copy)(p->vecsz);
122       for (i = 0; i < nthr; ++i) {
123  	  vecsz->dims[vdim].n =
124  	       (i == nthr - 1) ? (d->n - i*block_size) : block_size;
125  	  cldp = X(mkproblem_dft)(p->sz, vecsz,
126  				  p->ri + i*its, p->ii + i*its, 
127  				  p->ro + i*ots, p->io + i*ots);
128  	  cldrn[i] = X(mkplan_d)(plnr, cldp);
129  	  if (!cldrn[i]) goto nada;
130       }
131       X(tensor_destroy)(vecsz);
132       pln = MKPLAN_DFT(P, &padt, apply);
133       pln->cldrn = cldrn;
134       pln->its = its;
135       pln->ots = ots;
136       pln->nthr = nthr;
137       pln->solver = ego;
138       X(ops_zero)(&pln->super.super.ops);
139       pln->super.super.pcost = 0;
140       for (i = 0; i < nthr; ++i) {
141  	  X(ops_add2)(&cldrn[i]->ops, &pln->super.super.ops);
142  	  pln->super.super.pcost += cldrn[i]->pcost;
143       }
144       return &(pln->super.super);
145   nada:
146       if (cldrn) {
147  	  for (i = 0; i < nthr; ++i)
148  	       X(plan_destroy_internal)(cldrn[i]);
149  	  X(ifree)(cldrn);
150       }
<span onclick='openModal()' class='match'>151       X(tensor_destroy)(vecsz);
152       return (plan *) 0;
153  }
154  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
155  {
156       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
</span>157       S *slv = MKSOLVER(S, &sadt);
158       slv->vecloop_dim = vecloop_dim;
159       slv->buddies = buddies;
160       slv->nbuddies = nbuddies;
161       return &(slv->super);
162  }
163  void X(dft_thr_vrank_geq1_register)(planner *p)
164  {
165       static const int buddies[] = { 1, -1 };
166       size_t i;
167       for (i = 0; i < NELEM(buddies); ++i)
168            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
169  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hiredis.c</h3>
            <pre><code>1  #include "fmacros.h"
2  #include <string.h>
3  #include <stdlib.h>
4  #ifndef _WIN32
5  #include <unistd.h>
6  #endif
7  #include <assert.h>
8  #include <errno.h>
9  #include <ctype.h>
10  #include "hiredis.h"
11  #include "net.h"
12  #include "sds.h"
13  #ifdef _WIN32
14  #include "win32_hiredis.h"
15  #endif
16  static redisReply *createReplyObject(int type);
17  static void *createStringObject(const redisReadTask *task, char *str, size_t len);
18  static void *createArrayObject(const redisReadTask *task, int elements);
19  static void *createIntegerObject(const redisReadTask *task, PORT_LONGLONG value);
20  static void *createNilObject(const redisReadTask *task);
21  static redisReplyObjectFunctions defaultFunctions = {
22  	createStringObject,
23  	createArrayObject,
24  	createIntegerObject,
25  	createNilObject,
26  	freeReplyObject
27  };
28  static redisReply *createReplyObject(int type) {
29  	redisReply *r = calloc(1, sizeof(*r));
30  	if (r == NULL)
31  		return NULL;
32  	r->type = type;
33  	return r;
34  }
35  void freeReplyObject(void *reply) {
36  	redisReply *r = reply;
37  	size_t j;
38  	if (r == NULL)
39  		return;
40  	switch (r->type) {
41  	case REDIS_REPLY_INTEGER:
42  		break; &bsol;* Nothing to free */
43  	case REDIS_REPLY_ARRAY:
44  		if (r->element != NULL) {
45  			for (j = 0; j < r->elements; j++)
46  				if (r->element[j] != NULL)
47  					freeReplyObject(r->element[j]);
48  			free(r->element);
49  		}
50  		break;
51  	case REDIS_REPLY_ERROR:
52  	case REDIS_REPLY_STATUS:
53  	case REDIS_REPLY_STRING:
54  		if (r->str != NULL)
55  			free(r->str);
56  		break;
57  	}
58  	free(r);
59  }
60  static void *createStringObject(const redisReadTask *task, char *str, size_t len) {
61  	redisReply *r, *parent;
62  	char *buf;
63  	r = createReplyObject(task->type);
64  	if (r == NULL)
65  		return NULL;
66  	buf = malloc(len + 1);
67  	if (buf == NULL) {
68  		freeReplyObject(r);
69  		return NULL;
70  	}
71  	assert(task->type == REDIS_REPLY_ERROR ||
72  		task->type == REDIS_REPLY_STATUS ||
73  		task->type == REDIS_REPLY_STRING);
74  	memcpy(buf, str, len);
75  	buf[len] = '\0';
76  	r->str = buf;
77  	r->len = (int)len;
78  	if (task->parent) {
79  		parent = task->parent->obj;
80  		assert(parent->type == REDIS_REPLY_ARRAY);
81  		parent->element[task->idx] = r;
82  	}
83  	return r;
84  }
85  static void *createArrayObject(const redisReadTask *task, int elements) {
86  	redisReply *r, *parent;
87  	r = createReplyObject(REDIS_REPLY_ARRAY);
88  	if (r == NULL)
89  		return NULL;
90  	if (elements > 0) {
91  		r->element = calloc(elements, sizeof(redisReply*));
92  		if (r->element == NULL) {
93  			freeReplyObject(r);
94  			return NULL;
95  		}
96  	}
97  	r->elements = elements;
98  	if (task->parent) {
99  		parent = task->parent->obj;
100  		assert(parent->type == REDIS_REPLY_ARRAY);
101  		parent->element[task->idx] = r;
102  	}
103  	return r;
104  }
105  static void *createIntegerObject(const redisReadTask *task, PORT_LONGLONG value) {
106  	redisReply *r, *parent;
107  	r = createReplyObject(REDIS_REPLY_INTEGER);
108  	if (r == NULL)
109  		return NULL;
110  	r->integer = value;
111  	if (task->parent) {
112  		parent = task->parent->obj;
113  		assert(parent->type == REDIS_REPLY_ARRAY);
114  		parent->element[task->idx] = r;
115  	}
116  	return r;
117  }
118  static void *createNilObject(const redisReadTask *task) {
119  	redisReply *r, *parent;
120  	r = createReplyObject(REDIS_REPLY_NIL);
121  	if (r == NULL)
122  		return NULL;
123  	if (task->parent) {
124  		parent = task->parent->obj;
125  		assert(parent->type == REDIS_REPLY_ARRAY);
126  		parent->element[task->idx] = r;
127  	}
128  	return r;
129  }
130  static uint32_t countDigits(uint64_t v) {
131  	uint32_t result = 1;
132  	for (;;) {
133  		if (v < 10) return result;
134  		if (v < 100) return result + 1;
135  		if (v < 1000) return result + 2;
136  		if (v < 10000) return result + 3;
137  		v /= 10000U;
138  		result += 4;
139  	}
140  }
141  static size_t bulklen(size_t len) {
142  	return (size_t)(1 + countDigits(len) + 2 + len + 2);
143  }
144  int redisvFormatCommand(char **target, const char *format, va_list ap) {
145  	const char *c = format;
146  	char *cmd = NULL; &bsol;* final command */
147  	int pos; &bsol;* position in final command */
148  	sds curarg, newarg; &bsol;* current argument */
149  	int touched = 0; &bsol;* was the current argument touched? */
150  	char **curargv = NULL, **newargv = NULL;
151  	int argc = 0;
152  	int totlen = 0;
153  	int error_type = 0; &bsol;* 0 = no error; -1 = memory error; -2 = format error */
154  	int j;
155  	if (target == NULL)
156  		return -1;
157  	curarg = sdsempty();
158  	if (curarg == NULL)
159  		return -1;
160  	while (*c != '\0') {
161  		if (*c != '%' || c[1] == '\0') {
162  			if (*c == ' ') {
163  				if (touched) {
164  					newargv = realloc(curargv, sizeof(char*)*(argc + 1));
165  					if (newargv == NULL) goto memory_err;
166  					curargv = newargv;
167  					curargv[argc++] = curarg;
168  					totlen += (int)bulklen(sdslen(curarg));
169  					curarg = sdsempty();
170  					if (curarg == NULL) goto memory_err;
171  					touched = 0;
172  				}
173  			}
174  			else {
175  				newarg = sdscatlen(curarg, c, 1);
176  				if (newarg == NULL) goto memory_err;
177  				curarg = newarg;
178  				touched = 1;
179  			}
180  		}
181  		else {
182  			char *arg;
183  			size_t size;
184  			newarg = curarg;
185  			switch (c[1]) {
186  			case 's':
187  				arg = va_arg(ap, char*);
188  				size = strlen(arg);
189  				if (size > 0)
190  					newarg = sdscatlen(curarg, arg, size);
191  				break;
192  			case 'b':
193  				arg = va_arg(ap, char*);
194  				size = va_arg(ap, size_t);
195  				if (size > 0)
196  					newarg = sdscatlen(curarg, arg, size);
197  				break;
198  			case '%':
199  				newarg = sdscat(curarg, "%");
200  				break;
201  			default:
202  			{
203  				static const char intfmts[] = "diouxX";
204  				static const char flags[] = "#0-+ ";
205  				char _format[16];
206  				const char *_p = c + 1;
207  				size_t _l = 0;
208  				va_list _cpy;
209  				while (*_p != '\0' && strchr(flags, *_p) != NULL) _p++;
210  				while (*_p != '\0' && isdigit(*_p)) _p++;
211  				if (*_p == '.') {
212  					_p++;
213  					while (*_p != '\0' && isdigit(*_p)) _p++;
214  				}
215  				va_copy(_cpy, ap);
216  				if (strchr(intfmts, *_p) != NULL) {
217  					va_arg(ap, int);
218  					goto fmt_valid;
219  				}
220  				if (strchr("eEfFgGaA", *_p) != NULL) {
221  					va_arg(ap, double);
222  					goto fmt_valid;
223  				}
224  				if (_p[0] == 'h' && _p[1] == 'h') {
225  					_p += 2;
226  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
227  						va_arg(ap, int); &bsol;* char gets promoted to int */
228  						goto fmt_valid;
229  					}
230  					goto fmt_invalid;
231  				}
232  				if (_p[0] == 'h') {
233  					_p += 1;
234  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
235  						va_arg(ap, int); &bsol;* short gets promoted to int */
236  						goto fmt_valid;
237  					}
238  					goto fmt_invalid;
239  				}
240  				if (_p[0] == 'l' && _p[1] == 'l') {
241  					_p += 2;
242  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
243  						va_arg(ap, PORT_LONGLONG);
244  						goto fmt_valid;
245  					}
246  					goto fmt_invalid;
247  				}
248  				if (_p[0] == 'l') {
249  					_p += 1;
250  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
251  						va_arg(ap, PORT_LONG);
252  						goto fmt_valid;
253  					}
254  					goto fmt_invalid;
255  				}
256  			fmt_invalid:
257  				va_end(_cpy);
258  				goto format_err;
259  			fmt_valid:
260  				_l = (_p + 1) - c;
261  				if (_l < sizeof(_format) - 2) {
262  					memcpy(_format, c, _l);
263  					_format[_l] = '\0';
264  					newarg = sdscatvprintf(curarg, _format, _cpy);
265  					c = _p - 1;
266  				}
267  				va_end(_cpy);
268  				break;
269  			}
270  			}
271  			if (newarg == NULL) goto memory_err;
272  			curarg = newarg;
273  			touched = 1;
274  			c++;
275  		}
276  		c++;
277  	}
278  	if (touched) {
279  		newargv = realloc(curargv, sizeof(char*)*(argc + 1));
280  		if (newargv == NULL) goto memory_err;
281  		curargv = newargv;
282  		curargv[argc++] = curarg;
283  		totlen += (int)bulklen(sdslen(curarg));
284  	}	else {
285  		sdsfree(curarg);
286  	}
287  	curarg = NULL;
288  	totlen += 1 + countDigits(argc) + 2;
289  	cmd = malloc(totlen + 1);
290  	if (cmd == NULL) goto memory_err;
291  	pos = sprintf(cmd, "*%d\r\n", argc);
292  	for (j = 0; j < argc; j++) {
293  		pos += sprintf(cmd + pos, "$%Iu\r\n", sdslen(curargv[j]));                  WIN_PORT_FIX &bsol;* %zu -> %Iu */
294  			memcpy(cmd + pos, curargv[j], sdslen(curargv[j]));
295  		pos += (int)sdslen(curargv[j]);
296  		sdsfree(curargv[j]);
297  		cmd[pos++] = '\r';
298  		cmd[pos++] = '\n';
299  	}
300  	assert(pos == totlen);
301  	cmd[pos] = '\0';
302  	free(curargv);
303  	*target = cmd;
304  	return totlen;
305  format_err:
306  	error_type = -2;
307  	goto cleanup;
308  memory_err:
309  	error_type = -1;
310  	goto cleanup;
311  cleanup:
312  	if (curargv) {
313  		while (argc--)
314  			sdsfree(curargv[argc]);
315  		free(curargv);
316  	}
317  	sdsfree(curarg);
318  	if (cmd != NULL)
319  		free(cmd);
320  	return error_type;
321  }
322  int redisFormatCommand(char **target, const char *format, ...) {
323  	va_list ap;
324  	int len;
325  	va_start(ap, format);
326  	len = redisvFormatCommand(target, format, ap);
327  	va_end(ap);
328  	if (len < 0)
329  		len = -1;
330  	return len;
331  }
332  int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
333  	const size_t *argvlen)
334  {
335  	sds cmd;
336  	PORT_ULONGLONG totlen;
337  	int j;
338  	size_t len;
339  	if (target == NULL)
340  		return -1;
341  	totlen = 1 + countDigits(argc) + 2;
342  	for (j = 0; j < argc; j++) {
343  		len = argvlen ? argvlen[j] : strlen(argv[j]);
344  		totlen += bulklen(len);
345  	}
346  	cmd = sdsempty();
347  	if (cmd == NULL)
348  		return -1;
349  	cmd = sdsMakeRoomFor(cmd, totlen);
350  	if (cmd == NULL)
351  		return -1;
352  	cmd = sdscatfmt(cmd, "*%i\r\n", argc);
353  	for (j = 0; j < argc; j++) {
354  		len = argvlen ? argvlen[j] : strlen(argv[j]);
355  		cmd = sdscatfmt(cmd, "$%u\r\n", len);
356  		cmd = sdscatlen(cmd, argv[j], len);
357  		cmd = sdscatlen(cmd, "\r\n", sizeof("\r\n") - 1);
358  	}
359  	assert(sdslen(cmd) == totlen);
360  	*target = cmd;
361  	return totlen;
362  }
363  void redisFreeSdsCommand(sds cmd) {
364  	sdsfree(cmd);
365  }
366  int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {
367  	char *cmd = NULL; &bsol;* final command */
368  	int pos; &bsol;* position in final command */
369  	size_t len;
370  	int totlen, j;
371  	if (target == NULL)
372  		return -1;
373  	totlen = 1 + countDigits(argc) + 2;
374  	for (j = 0; j < argc; j++) {
375  		len = argvlen ? argvlen[j] : strlen(argv[j]);
376  		totlen += bulklen(len);
377  	}
378  	cmd = malloc(totlen + 1);
379  	if (cmd == NULL)
380  		return -1;
381  	pos = sprintf(cmd, "*%d\r\n", argc);
382  	for (j = 0; j < argc; j++) {
383  		len = argvlen ? argvlen[j] : strlen(argv[j]);
384  		pos += sprintf(cmd + pos, "$%Iu\r\n", len);                                 WIN_PORT_FIX &bsol;* %zu -> %Iu */
385  			memcpy(cmd + pos, argv[j], len);
386  		pos += (int)len;
387  		cmd[pos++] = '\r';
388  		cmd[pos++] = '\n';
389  	}
390  	assert(pos == totlen);
391  	cmd[pos] = '\0';
392  	*target = cmd;
393  	return totlen;
394  }
395  void redisFreeCommand(char *cmd) {
396  	free(cmd);
397  }
398  void __redisSetError(redisContext *c, int type, const char *str) {
399  	size_t len;
400  	c->err = type;
401  	if (str != NULL) {
402  		len = strlen(str);
403  		len = len < (sizeof(c->errstr) - 1) ? len : (sizeof(c->errstr) - 1);
404  		memcpy(c->errstr, str, len);
405  		c->errstr[len] = '\0';
406      } else {
407  		assert(type == REDIS_ERR_IO);
408  		__redis_strerror_r(errno, c->errstr, sizeof(c->errstr));
409  	}
410  }
411  redisReader *redisReaderCreate(void) {
412  	return redisReaderCreateWithFunctions(&defaultFunctions);
413  }
414  static redisContext *redisContextInit(void) {
415  	redisContext *c;
416  	c = calloc(1, sizeof(redisContext));
417  	if (c == NULL)
418  		return NULL;
419  	c->err = 0;
420  	c->errstr[0] = '\0';
421  	c->obuf = sdsempty();
422  	c->reader = redisReaderCreate();
423  	c->tcp.host = NULL;
424  	c->tcp.source_addr = NULL;
425  	c->unix_sock.path = NULL;
426  	c->timeout = NULL;
427  	if (c->obuf == NULL || c->reader == NULL) {
428  		redisFree(c);
429  		return NULL;
430  	}
431  	return c;
432  }
433  void redisFree(redisContext *c) {
434  	if (c == NULL)
435  		return;
436  	if (c->fd > 0)
437  		close(c->fd);
438  	if (c->obuf != NULL)
439  		sdsfree(c->obuf);
440  	if (c->reader != NULL)
441  		redisReaderFree(c->reader);
442  	if (c->tcp.host)
443  		free(c->tcp.host);
444  	if (c->tcp.source_addr)
445  		free(c->tcp.source_addr);
446  	if (c->unix_sock.path)
447  		free(c->unix_sock.path);
448  	if (c->timeout)
449  		free(c->timeout);
450  	free(c);
451  }
452  int redisFreeKeepFd(redisContext *c) {
453  	int fd = c->fd;
454  	c->fd = -1;
455  	redisFree(c);
456  	return fd;
457  }
458  int redisReconnect(redisContext *c) {
459  	c->err = 0;
460  	memset(c->errstr, '\0', strlen(c->errstr));
461  	if (c->fd > 0) {
462  		close(c->fd);
463  	}
464  	sdsfree(c->obuf);
465  	redisReaderFree(c->reader);
466  	c->obuf = sdsempty();
467  	c->reader = redisReaderCreate();
468  	if (c->connection_type == REDIS_CONN_TCP) {
469  		return redisContextConnectBindTcp(c, c->tcp.host, c->tcp.port,
470  			c->timeout, c->tcp.source_addr);
471      } else if (c->connection_type == REDIS_CONN_UNIX) {
472  		return redisContextConnectUnix(c, c->unix_sock.path, c->timeout);
473      } else {
474  		__redisSetError(c, REDIS_ERR_OTHER, "Not enough information to reconnect");
475  	}
476  	return REDIS_ERR;
477  }
478  redisContext *redisConnect(const char *ip, int port) {
479  	redisContext *c;
480  	c = redisContextInit();
481  	if (c == NULL)
482  		return NULL;
483  	c->flags |= REDIS_BLOCK;
<span onclick='openModal()' class='match'>484  	redisContextConnectTcp(c, ip, port, NULL);
485  	return c;
486  }
487  redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {
488  	redisContext *c;
489  	c = redisContextInit();
</span>490  	if (c == NULL)
491  		return NULL;
492  	c->flags |= REDIS_BLOCK;
493  	redisContextConnectTcp(c, ip, port, &tv);
494  	return c;
495  }
496  redisContext *redisConnectNonBlock(const char *ip, int port) {
497  	redisContext *c;
498  	c = redisContextInit();
499  	if (c == NULL)
500  		return NULL;
501  	c->flags &= ~REDIS_BLOCK;
502  	redisContextConnectTcp(c, ip, port, NULL);
503  	return c;
504  }
505  redisContext *redisConnectBindNonBlock(const char *ip, int port,
506  	const char *source_addr) {
507  	redisContext *c = redisContextInit();
508  	c->flags &= ~REDIS_BLOCK;
509  	redisContextConnectBindTcp(c, ip, port, NULL, source_addr);
510  	return c;
511  }
512  redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
513  	const char *source_addr) {
514  	redisContext *c = redisContextInit();
515  	c->flags &= ~REDIS_BLOCK;
516  	c->flags |= REDIS_REUSEADDR;
517  	redisContextConnectBindTcp(c, ip, port, NULL, source_addr);
518  	return c;
519  }
520  redisContext *redisConnectUnix(const char *path) {
521  	redisContext *c;
522  	c = redisContextInit();
523  	if (c == NULL)
524  		return NULL;
525  	c->flags |= REDIS_BLOCK;
526  	redisContextConnectUnix(c, path, NULL);
527  	return c;
528  }
529  redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {
530  	redisContext *c;
531  	c = redisContextInit();
532  	if (c == NULL)
533  		return NULL;
534  	c->flags |= REDIS_BLOCK;
535  	redisContextConnectUnix(c, path, &tv);
536  	return c;
537  }
538  redisContext *redisConnectUnixNonBlock(const char *path) {
539  	redisContext *c;
540  	c = redisContextInit();
541  	if (c == NULL)
542  		return NULL;
543  	c->flags &= ~REDIS_BLOCK;
544  	redisContextConnectUnix(c, path, NULL);
545  	return c;
546  }
547  redisContext *redisConnectFd(int fd) {
548  	redisContext *c;
549  	c = redisContextInit();
550  	if (c == NULL)
551  		return NULL;
552  	c->fd = fd;
553  	c->flags |= REDIS_BLOCK | REDIS_CONNECTED;
554  	return c;
555  }
556  #ifdef _WIN32
557  redisContext *redisPreConnectNonBlock(const char *ip, int port, SOCKADDR_STORAGE *ss) {
558  	redisContext *c = redisContextInit();
559  	c->fd = -1;
560  	c->flags &= ~REDIS_BLOCK;
561  	redisContextPreConnectTcp(c, ip, port, NULL, ss);
562  	return c;
563  }
564  #endif
565  int redisSetTimeout(redisContext *c, const struct timeval tv) {
566  	if (c->flags & REDIS_BLOCK)
567  		return redisContextSetTimeout(c, tv);
568  	return REDIS_ERR;
569  }
570  int redisEnableKeepAlive(redisContext *c) {
571  	if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK)
572  		return REDIS_ERR;
573  	return REDIS_OK;
574  }
575  int redisBufferRead(redisContext *c) {
576  	char buf[1024 * 16];
577  	int nread;
578  	if (c->err)
579  		return REDIS_ERR;
580  	nread = (int)read(c->fd, buf, sizeof(buf));                                   WIN_PORT_FIX &bsol;* cast (int) */
581  		if (nread == -1) {
582  			if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {
583  			}
584  			else {
585  				__redisSetError(c, REDIS_ERR_IO, NULL);
586  				return REDIS_ERR;
587  			}
588  		}
589  		else if (nread == 0) {
590  			__redisSetError(c, REDIS_ERR_EOF, "Server closed the connection");
591  			return REDIS_ERR;
592  		}
593  		else {
594  			if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {
595  				__redisSetError(c, c->reader->err, c->reader->errstr);
596  				return REDIS_ERR;
597  			}
598  		}
599  		return REDIS_OK;
600  }
601  #ifdef _WIN32
602  int redisBufferReadDone(redisContext *c, char *buf, ssize_t nread) {
603  	if (nread == -1) {
604  		if (errno == EAGAIN && !(c->flags & REDIS_BLOCK)) {
605  		}
606  		else {
607  			__redisSetError(c, REDIS_ERR_IO, NULL);
608  			return REDIS_ERR;
609  		}
610  	}
611  	else if (nread == 0) {
612  		__redisSetError(c, REDIS_ERR_EOF, sdsnew("Server closed the connection"));
613  		return REDIS_ERR;
614  	}
615  	else {
616  		if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {
617  			__redisSetError(c, c->reader->err, c->reader->errstr);
618  			return REDIS_ERR;
619  		}
620  	}
621  	return REDIS_OK;
622  }
623  #endif
624  int redisBufferWrite(redisContext *c, int *done) {
625  	int nwritten;
626  	if (c->err)
627  		return REDIS_ERR;
628  	if (sdslen(c->obuf) > 0) {
629  		nwritten = (int)write(c->fd, c->obuf, sdslen(c->obuf));                   WIN_PORT_FIX &bsol;* cast (int) */
630  			if (nwritten == -1) {
631  				if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {
632  				}
633  				else {
634  					__redisSetError(c, REDIS_ERR_IO, NULL);
635  					return REDIS_ERR;
636  				}
637  			}
638  			else if (nwritten > 0) {
639  				if (nwritten == (signed)sdslen(c->obuf)) {
640  					sdsfree(c->obuf);
641  					c->obuf = sdsempty();
642  				}
643  				else {
644  					sdsrange(c->obuf, nwritten, -1);
645  				}
646  			}
647  	}
648  	if (done != NULL) *done = (sdslen(c->obuf) == 0);
649  	return REDIS_OK;
650  }
651  #ifdef _WIN32
652  int redisBufferWriteDone(redisContext *c, int nwritten, int *done) {
653  	if (nwritten > 0) {
654  		if (nwritten == (signed)sdslen(c->obuf)) {
655  			sdsfree(c->obuf);
656  			c->obuf = sdsempty();
657  		}
658  		else {
659  			sdsrange(c->obuf, nwritten, -1);
660  		}
661  	}
662  	if (done != NULL) *done = (sdslen(c->obuf) == 0);
663  	return REDIS_OK;
664  }
665  #endif
666  int redisGetReplyFromReader(redisContext *c, void **reply) {
667  	if (redisReaderGetReply(c->reader, reply) == REDIS_ERR) {
668  		__redisSetError(c, c->reader->err, c->reader->errstr);
669  		return REDIS_ERR;
670  	}
671  	return REDIS_OK;
672  }
673  int redisGetReply(redisContext *c, void **reply) {
674  	int wdone = 0;
675  	void *aux = NULL;
676  	if (redisGetReplyFromReader(c, &aux) == REDIS_ERR)
677  		return REDIS_ERR;
678  	if (aux == NULL && c->flags & REDIS_BLOCK) {
679  		do {
680  			if (redisBufferWrite(c, &wdone) == REDIS_ERR)
681  				return REDIS_ERR;
682  		} while (!wdone);
683  		do {
684  			if (redisBufferRead(c) == REDIS_ERR)
685  				return REDIS_ERR;
686  			if (redisGetReplyFromReader(c, &aux) == REDIS_ERR)
687  				return REDIS_ERR;
688  		} while (aux == NULL);
689  	}
690  	if (reply != NULL) *reply = aux;
691  	return REDIS_OK;
692  }
693  int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {
694  	sds newbuf;
695  	newbuf = sdscatlen(c->obuf, cmd, len);
696  	if (newbuf == NULL) {
697  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
698  		return REDIS_ERR;
699  	}
700  	c->obuf = newbuf;
701  	return REDIS_OK;
702  }
703  int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {
704  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
705  		return REDIS_ERR;
706  	}
707  	return REDIS_OK;
708  }
709  int redisvAppendCommand(redisContext *c, const char *format, va_list ap) {
710  	char *cmd;
711  	int len;
712  	len = redisvFormatCommand(&cmd, format, ap);
713  	if (len == -1) {
714  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
715  		return REDIS_ERR;
716  	}
717  	else if (len == -2) {
718  		__redisSetError(c, REDIS_ERR_OTHER, "Invalid format string");
719  		return REDIS_ERR;
720  	}
721  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
722  		free(cmd);
723  		return REDIS_ERR;
724  	}
725  	free(cmd);
726  	return REDIS_OK;
727  }
728  int redisAppendCommand(redisContext *c, const char *format, ...) {
729  	va_list ap;
730  	int ret;
731  	va_start(ap, format);
732  	ret = redisvAppendCommand(c, format, ap);
733  	va_end(ap);
734  	return ret;
735  }
736  int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
737  	sds cmd;
738  	int len;
739  	len = redisFormatSdsCommandArgv(&cmd, argc, argv, argvlen);
740  	if (len == -1) {
741  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
742  		return REDIS_ERR;
743  	}
744  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
745  		sdsfree(cmd);
746  		return REDIS_ERR;
747  	}
748  	sdsfree(cmd);
749  	return REDIS_OK;
750  }
751  static void *__redisBlockForReply(redisContext *c) {
752  	void *reply;
753  	if (c->flags & REDIS_BLOCK) {
754  		if (redisGetReply(c, &reply) != REDIS_OK)
755  			return NULL;
756  		return reply;
757  	}
758  	return NULL;
759  }
760  void *redisvCommand(redisContext *c, const char *format, va_list ap) {
761  	if (redisvAppendCommand(c, format, ap) != REDIS_OK)
762  		return NULL;
763  	return __redisBlockForReply(c);
764  }
765  void *redisCommand(redisContext *c, const char *format, ...) {
766  	va_list ap;
767  	void *reply = NULL;
768  	va_start(ap, format);
769  	reply = redisvCommand(c, format, ap);
770  	va_end(ap);
771  	return reply;
772  }
773  void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
774  	if (redisAppendCommandArgv(c, argc, argv, argvlen) != REDIS_OK)
775  		return NULL;
776  	return __redisBlockForReply(c);
777  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-vrank-geq1.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hiredis.c</div>
                </div>
                <div class="column column_space"><pre><code>151       X(tensor_destroy)(vecsz);
152       return (plan *) 0;
153  }
154  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
155  {
156       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
</pre></code></div>
                <div class="column column_space"><pre><code>484  	redisContextConnectTcp(c, ip, port, NULL);
485  	return c;
486  }
487  redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {
488  	redisContext *c;
489  	c = redisContextInit();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    