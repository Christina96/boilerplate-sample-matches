
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.390977443609022%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-block.c</h3>
            <pre><code>1  #include "ifftw-mpi.h"
2  INT XM(num_blocks)(INT n, INT block)
3  {
<span onclick='openModal()' class='match'>4       return (n + block - 1) / block;
5  }
6  int XM(num_blocks_ok)(INT n, INT block, MPI_Comm comm)
7  {
8       int n_pes;
9       MPI_Comm_size(comm, &n_pes);
10       return n_pes >= XM(num_blocks)(n, block);
</span>11  }
12  INT XM(default_block)(INT n, int n_pes)
13  {
14       return ((n + n_pes - 1) / n_pes);
15  }
16  INT XM(block)(INT n, INT block, int which_block)
17  {
18       INT d = n - which_block * block;
19       return d <= 0 ? 0 : (d > block ? block : d);
20  }
21  static INT num_blocks_kind(const ddim *dim, block_kind k)
22  {
23       return XM(num_blocks)(dim->n, dim->b[k]);
24  }
25  INT XM(num_blocks_total)(const dtensor *sz, block_kind k)
26  {
27       if (FINITE_RNK(sz->rnk)) {
28  	  int i;
29  	  INT ntot = 1;
30  	  for (i = 0; i < sz->rnk; ++i)
31  	       ntot *= num_blocks_kind(sz->dims + i, k);
32  	  return ntot;
33       }
34       else
35  	  return 0;
36  }
37  int XM(idle_process)(const dtensor *sz, block_kind k, int which_pe)
38  {
39       return (which_pe >= XM(num_blocks_total)(sz, k));
40  }
41  void XM(block_coords)(const dtensor *sz, block_kind k, int which_pe, 
42  		     INT *coords)
43  {
44       int i;
45       A(!XM(idle_process)(sz, k, which_pe) && FINITE_RNK(sz->rnk));
46       for (i = sz->rnk - 1; i >= 0; --i) {
47  	  INT nb = num_blocks_kind(sz->dims + i, k);
48  	  coords[i] = which_pe % nb;
49  	  which_pe /= nb;
50       }
51  }
52  INT XM(total_block)(const dtensor *sz, block_kind k, int which_pe)
53  {
54       if (XM(idle_process)(sz, k, which_pe))
55  	  return 0;
56       else {
57  	  int i;
58  	  INT N = 1, *coords;
59  	  STACK_MALLOC(INT*, coords, sizeof(INT) * sz->rnk);
60  	  XM(block_coords)(sz, k, which_pe, coords);
61  	  for (i = 0; i < sz->rnk; ++i)
62  	       N *= XM(block)(sz->dims[i].n, sz->dims[i].b[k], coords[i]);
63  	  STACK_FREE(coords);
64  	  return N;
65       }
66  }
67  int XM(is_local_after)(int dim, const dtensor *sz, block_kind k)
68  {
69       if (FINITE_RNK(sz->rnk))
70  	  for (; dim < sz->rnk; ++dim)
71  	       if (XM(num_blocks)(sz->dims[dim].n, sz->dims[dim].b[k]) > 1)
72  		    return 0;
73       return 1;
74  }
75  int XM(is_local)(const dtensor *sz, block_kind k)
76  {
77       return XM(is_local_after)(0, sz, k);
78  }
79  int XM(is_block1d)(const dtensor *sz, block_kind k)
80  {
81       int i;
82       if (!FINITE_RNK(sz->rnk)) return 0;
83       for (i = 0; i < sz->rnk && num_blocks_kind(sz->dims + i, k) == 1; ++i) ;
84       return(i < sz->rnk && i < 2 && XM(is_local_after)(i + 1, sz, k));
85  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-pngdec.c</h3>
            <pre><code>1  #include "./pngdec.h"
2  #ifdef HAVE_CONFIG_H
3  #include "webp/config.h"
4  #endif
5  #include <stdio.h>
6  #ifdef WEBP_HAVE_PNG
7  #ifndef PNG_USER_MEM_SUPPORTED
8  #define PNG_USER_MEM_SUPPORTED  
9  #endif
10  #include <png.h>
11  #include <setjmp.h>   
12  #include <stdlib.h>
13  #include <string.h>
14  #include "webp/encode.h"
15  #include "./imageio_util.h"
16  #include "./metadata.h"
17  #define LOCAL_PNG_VERSION ((PNG_LIBPNG_VER_MAJOR << 8) | PNG_LIBPNG_VER_MINOR)
18  #define LOCAL_PNG_PREREQ(maj, min) \
19     (LOCAL_PNG_VERSION >= (((maj) << 8) | (min)))
20  static void PNGAPI error_function(png_structp png, png_const_charp error) {
21    if (error != NULL) fprintf(stderr, "libpng error: %s\n", error);
22    longjmp(png_jmpbuf(png), 1);
23  }
24  #if LOCAL_PNG_PREREQ(1,4)
25  typedef png_alloc_size_t LocalPngAllocSize;
26  #else
27  typedef png_size_t LocalPngAllocSize;
28  #endif
29  static png_voidp MallocFunc(png_structp png_ptr, LocalPngAllocSize size) {
30    (void)png_ptr;
31    if (size != (size_t)size) return NULL;
32    if (!ImgIoUtilCheckSizeArgumentsOverflow(size, 1)) return NULL;
33    return (png_voidp)malloc((size_t)size);
34  }
35  static void FreeFunc(png_structp png_ptr, png_voidp ptr) {
36    (void)png_ptr;
37    free(ptr);
38  }
39  static uint8_t* HexStringToBytes(const char* hexstring,
40                                   size_t expected_length) {
41    const char* src = hexstring;
42    size_t actual_length = 0;
43    uint8_t* const raw_data = (uint8_t*)malloc(expected_length);
44    uint8_t* dst;
45    if (raw_data == NULL) return NULL;
46    for (dst = raw_data; actual_length < expected_length && *src != '\0'; ++src) {
47      char* end;
48      char val[3];
49      if (*src == '\n') continue;
50      val[0] = *src++;
51      val[1] = *src;
52      val[2] = '\0';
53      *dst++ = (uint8_t)strtol(val, &end, 16);
54      if (end != val + 2) break;
55      ++actual_length;
56    }
57    if (actual_length != expected_length) {
58      free(raw_data);
59      return NULL;
60    }
61    return raw_data;
62  }
63  static int ProcessRawProfile(const char* profile, size_t profile_len,
64                               MetadataPayload* const payload) {
65    const char* src = profile;
66    char* end;
67    int expected_length;
68    if (profile == NULL || profile_len == 0) return 0;
69    if (*src != '\n') {
70      fprintf(stderr, "Malformed raw profile, expected '\\n' got '\\x%.2X'\n",
71              *src);
72      return 0;
73    }
74    ++src;
75    while (*src != '\0' && *src++ != '\n') {}
76    expected_length = (int)strtol(src, &end, 10);
77    if (*end != '\n') {
78      fprintf(stderr, "Malformed raw profile, expected '\\n' got '\\x%.2X'\n",
79              *end);
80      return 0;
81    }
82    ++end;
83    payload->bytes = HexStringToBytes(end, expected_length);
84    if (payload->bytes == NULL) return 0;
85    payload->size = expected_length;
86    return 1;
87  }
88  static const struct {
89    const char* name;
90    int (*process)(const char* profile, size_t profile_len,
91                   MetadataPayload* const payload);
92    size_t storage_offset;
93  } kPNGMetadataMap[] = {
94    { "Raw profile type exif", ProcessRawProfile, METADATA_OFFSET(exif) },
95    { "Raw profile type xmp",  ProcessRawProfile, METADATA_OFFSET(xmp) },
96    { "Raw profile type APP1", ProcessRawProfile, METADATA_OFFSET(exif) },
97    { "XML:com.adobe.xmp",     MetadataCopy,      METADATA_OFFSET(xmp) },
98    { NULL, NULL, 0 },
99  };
100  static int ExtractMetadataFromPNG(png_structp png,
101                                    png_infop const head_info,
102                                    png_infop const end_info,
103                                    Metadata* const metadata) {
104    int p;
105    for (p = 0; p < 2; ++p)  {
106      png_infop const info = (p == 0) ? head_info : end_info;
107      png_textp text = NULL;
108      const png_uint_32 num = png_get_text(png, info, &text, NULL);
109      png_uint_32 i;
110      for (i = 0; i < num; ++i, ++text) {
111        int j;
112        for (j = 0; kPNGMetadataMap[j].name != NULL; ++j) {
113          if (!strcmp(text->key, kPNGMetadataMap[j].name)) {
114            MetadataPayload* const payload =
115                (MetadataPayload*)((uint8_t*)metadata +
116                                   kPNGMetadataMap[j].storage_offset);
117            png_size_t text_length;
118            switch (text->compression) {
119  #ifdef PNG_iTXt_SUPPORTED
120              case PNG_ITXT_COMPRESSION_NONE:
121              case PNG_ITXT_COMPRESSION_zTXt:
122                text_length = text->itxt_length;
123                break;
124  #endif
125              case PNG_TEXT_COMPRESSION_NONE:
126              case PNG_TEXT_COMPRESSION_zTXt:
127              default:
128                text_length = text->text_length;
129                break;
130            }
131            if (payload->bytes != NULL) {
132              fprintf(stderr, "Ignoring additional '%s'\n", text->key);
133            } else if (!kPNGMetadataMap[j].process(text->text, text_length,
134                                                   payload)) {
135              fprintf(stderr, "Failed to process: '%s'\n", text->key);
136              return 0;
137            }
138            break;
139          }
140        }
141      }
142      {
143        png_charp name;
144        int comp_type;
145  #if LOCAL_PNG_PREREQ(1,5)
146        png_bytep profile;
147  #else
148        png_charp profile;
149  #endif
150        png_uint_32 len;
151        if (png_get_iCCP(png, info,
152                         &name, &comp_type, &profile, &len) == PNG_INFO_iCCP) {
153          if (!MetadataCopy((const char*)profile, len, &metadata->iccp)) return 0;
154        }
155      }
156    }
157    return 1;
158  }
159  typedef struct {
160    const uint8_t* data;
161    size_t data_size;
162    png_size_t offset;
163  } PNGReadContext;
164  static void ReadFunc(png_structp png_ptr, png_bytep data, png_size_t length) {
165    PNGReadContext* const ctx = (PNGReadContext*)png_get_io_ptr(png_ptr);
166    if (ctx->data_size - ctx->offset < length) {
167      png_error(png_ptr, "ReadFunc: invalid read length (overflow)!");
168    }
169    memcpy(data, ctx->data + ctx->offset, length);
170    ctx->offset += length;
171  }
172  int ReadPNG(const uint8_t* const data, size_t data_size,
173              struct WebPPicture* const pic,
174              int keep_alpha, struct Metadata* const metadata) {
175    volatile png_structp png = NULL;
176    volatile png_infop info = NULL;
177    volatile png_infop end_info = NULL;
178    PNGReadContext context = { NULL, 0, 0 };
179    int color_type, bit_depth, interlaced;
180    int has_alpha;
181    int num_passes;
182    int p;
183    volatile int ok = 0;
184    png_uint_32 width, height, y;
185    int64_t stride;
186    uint8_t* volatile rgb = NULL;
187    if (data == NULL || data_size == 0 || pic == NULL) return 0;
188    context.data = data;
189    context.data_size = data_size;
190    png = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,
191                                   NULL, MallocFunc, FreeFunc);
192    if (png == NULL) goto End;
193    png_set_error_fn(png, 0, error_function, NULL);
194    if (setjmp(png_jmpbuf(png))) {
195   Error:
196      MetadataFree(metadata);
197      goto End;
198    }
199    info = png_create_info_struct(png);
200    if (info == NULL) goto Error;
201    end_info = png_create_info_struct(png);
202    if (end_info == NULL) goto Error;
203    png_set_read_fn(png, &context, ReadFunc);
204    png_read_info(png, info);
205    if (!png_get_IHDR(png, info,
206                      &width, &height, &bit_depth, &color_type, &interlaced,
207                      NULL, NULL)) goto Error;
208    png_set_strip_16(png);
209    png_set_packing(png);
210    if (color_type == PNG_COLOR_TYPE_PALETTE) {
211      png_set_palette_to_rgb(png);
212    }
213    if (color_type == PNG_COLOR_TYPE_GRAY ||
214        color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
215      if (bit_depth < 8) {
216        png_set_expand_gray_1_2_4_to_8(png);
217      }
218      png_set_gray_to_rgb(png);
219    }
220    if (png_get_valid(png, info, PNG_INFO_tRNS)) {
221      png_set_tRNS_to_alpha(png);
222      has_alpha = 1;
223    } else {
224      has_alpha = !!(color_type & PNG_COLOR_MASK_ALPHA);
225    }
226    {
227      double image_gamma = 1 / 2.2, screen_gamma = 2.2;
228      int srgb_intent;
229      if (png_get_sRGB(png, info, &srgb_intent) ||
230          png_get_gAMA(png, info, &image_gamma)) {
231        png_set_gamma(png, screen_gamma, image_gamma);
232      }
233    }
234    if (!keep_alpha) {
235      png_set_strip_alpha(png);
236      has_alpha = 0;
237    }
238    num_passes = png_set_interlace_handling(png);
239    png_read_update_info(png, info);
240    stride = (int64_t)(has_alpha ? 4 : 3) * width * sizeof(*rgb);
241    if (stride != (int)stride ||
242        !ImgIoUtilCheckSizeArgumentsOverflow(stride, height)) {
243      goto Error;
244    }
245    rgb = (uint8_t*)malloc((size_t)stride * height);
246    if (rgb == NULL) goto Error;
247    for (p = 0; p < num_passes; ++p) {
248      png_bytep row = rgb;
249      for (y = 0; y < height; ++y) {
250        png_read_rows(png, &row, NULL, 1);
251        row += stride;
252      }
253    }
254    png_read_end(png, end_info);
255    if (metadata != NULL &&
256        !ExtractMetadataFromPNG(png, info, end_info, metadata)) {
257      fprintf(stderr, "Error extracting PNG metadata!\n");
258      goto Error;
259    }
260    pic->width = (int)width;
261    pic->height = (int)height;
262    ok = has_alpha ? WebPPictureImportRGBA(pic, rgb, (int)stride)
263                   : WebPPictureImportRGB(pic, rgb, (int)stride);
264    if (!ok) {
265      goto Error;
266    }
267   End:
268    if (png != NULL) {
269      png_destroy_read_struct((png_structpp)&png,
270                              (png_infopp)&info, (png_infopp)&end_info);
271    }
272    free(rgb);
<span onclick='openModal()' class='match'>273    return ok;
274  }
275  #else  
276  int ReadPNG(const uint8_t* const data, size_t data_size,
277              struct WebPPicture* const pic,
278              int keep_alpha, struct Metadata* const metadata) {
279    (void)data;
280    (void)data_size;
281    (void)pic;
282    (void)keep_alpha;
283    (void)metadata;
284    fprintf(stderr, "PNG support not compiled. Please install the libpng "
285            "development package before building.\n");
286    return 0;
</span>287  }
288  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-block.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-pngdec.c</div>
                </div>
                <div class="column column_space"><pre><code>4       return (n + block - 1) / block;
5  }
6  int XM(num_blocks_ok)(INT n, INT block, MPI_Comm comm)
7  {
8       int n_pes;
9       MPI_Comm_size(comm, &n_pes);
10       return n_pes >= XM(num_blocks)(n, block);
</pre></code></div>
                <div class="column column_space"><pre><code>273    return ok;
274  }
275  #else  
276  int ReadPNG(const uint8_t* const data, size_t data_size,
277              struct WebPPicture* const pic,
278              int keep_alpha, struct Metadata* const metadata) {
279    (void)data;
280    (void)data_size;
281    (void)pic;
282    (void)keep_alpha;
283    (void)metadata;
284    fprintf(stderr, "PNG support not compiled. Please install the libpng "
285            "development package before building.\n");
286    return 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    