
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.198300283286118%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-block.c</h3>
            <pre><code>1  #include "ifftw-mpi.h"
2  INT XM(num_blocks)(INT n, INT block)
3  {
4       return (n + block - 1) / block;
5  }
6  int XM(num_blocks_ok)(INT n, INT block, MPI_Comm comm)
7  {
8       int n_pes;
9       MPI_Comm_size(comm, &n_pes);
10       return n_pes >= XM(num_blocks)(n, block);
11  }
12  INT XM(default_block)(INT n, int n_pes)
13  {
14       return ((n + n_pes - 1) / n_pes);
15  }
16  INT XM(block)(INT n, INT block, int which_block)
17  {
18       INT d = n - which_block * block;
19       return d <= 0 ? 0 : (d > block ? block : d);
20  }
21  static INT num_blocks_kind(const ddim *dim, block_kind k)
22  {
23       return XM(num_blocks)(dim->n, dim->b[k]);
24  }
25  INT XM(num_blocks_total)(const dtensor *sz, block_kind k)
26  {
27       if (FINITE_RNK(sz->rnk)) {
28  	  int i;
29  	  INT ntot = 1;
30  	  for (i = 0; i < sz->rnk; ++i)
31  	       ntot *= num_blocks_kind(sz->dims + i, k);
32  	  return ntot;
33       }
34       else
35  	  return 0;
36  }
37  int XM(idle_process)(const dtensor *sz, block_kind k, int which_pe)
38  {
39       return (which_pe >= XM(num_blocks_total)(sz, k));
40  }
41  void XM(block_coords)(const dtensor *sz, block_kind k, int which_pe, 
42  		     INT *coords)
43  {
44       int i;
45       A(!XM(idle_process)(sz, k, which_pe) && FINITE_RNK(sz->rnk));
46       for (i = sz->rnk - 1; i >= 0; --i) {
47  	  INT nb = num_blocks_kind(sz->dims + i, k);
48  	  coords[i] = which_pe % nb;
49  	  which_pe /= nb;
50       }
51  }
52  INT XM(total_block)(const dtensor *sz, block_kind k, int which_pe)
53  {
54       if (XM(idle_process)(sz, k, which_pe))
55  	  return 0;
56       else {
57  	  int i;
58  	  INT N = 1, *coords;
59  	  STACK_MALLOC(INT*, coords, sizeof(INT) * sz->rnk);
60  	  XM(block_coords)(sz, k, which_pe, coords);
61  	  for (i = 0; i < sz->rnk; ++i)
62  	       N *= XM(block)(sz->dims[i].n, sz->dims[i].b[k], coords[i]);
63  	  STACK_FREE(coords);
64  	  return N;
65       }
66  }
67  int XM(is_local_after)(int dim, const dtensor *sz, block_kind k)
68  {
69       if (FINITE_RNK(sz->rnk))
70  	  for (; dim < sz->rnk; ++dim)
71  	       if (XM(num_blocks)(sz->dims[dim].n, sz->dims[dim].b[k]) > 1)
72  		    return 0;
73       return 1;
74  }
75  int XM(is_local)(const dtensor *sz, block_kind k)
76  {
<span onclick='openModal()' class='match'>77       return XM(is_local_after)(0, sz, k);
78  }
79  int XM(is_block1d)(const dtensor *sz, block_kind k)
80  {
81       int i;
</span>82       if (!FINITE_RNK(sz->rnk)) return 0;
83       for (i = 0; i < sz->rnk && num_blocks_kind(sz->dims + i, k) == 1; ++i) ;
84       return(i < sz->rnk && i < 2 && XM(is_local_after)(i + 1, sz, k));
85  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-verify-dft.c</h3>
            <pre><code>1  #include "verify.h"
2  typedef struct {
3       dotens2_closure k;
4       R *ra; R *ia;
5       R *rb; R *ib;
6       int scalea, scaleb;
7  } cpy_closure;
8  static void cpy0(dotens2_closure *k_, 
9  		 int indxa, int ondxa, int indxb, int ondxb)
10  {
11       cpy_closure *k = (cpy_closure *)k_;
12       k->rb[indxb * k->scaleb] = k->ra[ondxa * k->scalea];
13       k->ib[indxb * k->scaleb] = k->ia[ondxa * k->scalea];
14       UNUSED(indxa); UNUSED(ondxb);
15  }
16  static void cpy(R *ra, R *ia, const bench_tensor *sza, int scalea,
17  		R *rb, R *ib, const bench_tensor *szb, int scaleb)
18  {
19       cpy_closure k;
20       k.k.apply = cpy0;
21       k.ra = ra; k.ia = ia; k.rb = rb; k.ib = ib;
22       k.scalea = scalea; k.scaleb = scaleb;
23       bench_dotens2(sza, szb, &k.k);
24  }
25  typedef struct {
26       dofft_closure k;
27       bench_problem *p;
28  } dofft_dft_closure;
29  static void dft_apply(dofft_closure *k_, bench_complex *in, bench_complex *out)
30  {
31       dofft_dft_closure *k = (dofft_dft_closure *)k_;
32       bench_problem *p = k->p;
33       bench_tensor *totalsz, *pckdsz;
34       bench_tensor *totalsz_swap, *pckdsz_swap;
35       bench_real *ri, *ii, *ro, *io;
36       int totalscale;
37       totalsz = tensor_append(p->vecsz, p->sz);
38       pckdsz = verify_pack(totalsz, 2);
39       ri = (bench_real *) p->in;
40       ro = (bench_real *) p->out;
41       totalsz_swap = tensor_copy_swapio(totalsz);
42       pckdsz_swap = tensor_copy_swapio(pckdsz);
43       if (p->split) {
44  	  ii = p->ini ? (bench_real *) p->ini : ri + p->iphyssz;
45  	  io = p->outi ? (bench_real *) p->outi : ro + p->ophyssz;
46  	  totalscale = 1;
47       } else {
48  	  ii = p->ini ? (bench_real *) p->ini : ri + 1;
49  	  io = p->outi ? (bench_real *) p->outi : ro + 1;
50  	  totalscale = 2;
51       }
52       cpy(&c_re(in[0]), &c_im(in[0]), pckdsz, 1,
53  	    ri, ii, totalsz, totalscale);
54       after_problem_ccopy_from(p, ri, ii);
55       doit(1, p);
56       after_problem_ccopy_to(p, ro, io);
57       if (k->k.recopy_input)
58  	  cpy(ri, ii, totalsz_swap, totalscale,
59  	      &c_re(in[0]), &c_im(in[0]), pckdsz_swap, 1);
60       cpy(ro, io, totalsz, totalscale,
61  	 &c_re(out[0]), &c_im(out[0]), pckdsz, 1);
62       tensor_destroy(totalsz);
63       tensor_destroy(pckdsz);
<span onclick='openModal()' class='match'>64       tensor_destroy(totalsz_swap);
65       tensor_destroy(pckdsz_swap);
66  }
67  void verify_dft(bench_problem *p, int rounds, double tol, errors *e)
</span>68  {
69       C *inA, *inB, *inC, *outA, *outB, *outC, *tmp;
70       int n, vecn, N;
71       dofft_dft_closure k;
72       BENCH_ASSERT(p->kind == PROBLEM_COMPLEX);
73       k.k.apply = dft_apply;
74       k.k.recopy_input = 0;
75       k.p = p;
76       if (rounds == 0)
77  	  rounds = 20;  &bsol;* default value */
78       n = tensor_sz(p->sz);
79       vecn = tensor_sz(p->vecsz);
80       N = n * vecn;
81       inA = (C *) bench_malloc(N * sizeof(C));
82       inB = (C *) bench_malloc(N * sizeof(C));
83       inC = (C *) bench_malloc(N * sizeof(C));
84       outA = (C *) bench_malloc(N * sizeof(C));
85       outB = (C *) bench_malloc(N * sizeof(C));
86       outC = (C *) bench_malloc(N * sizeof(C));
87       tmp = (C *) bench_malloc(N * sizeof(C));
88       e->i = impulse(&k.k, n, vecn, inA, inB, inC, outA, outB, outC, 
89  		    tmp, rounds, tol);
90       e->l = linear(&k.k, 0, N, inA, inB, inC, outA, outB, outC,
91  		   tmp, rounds, tol);
92       e->s = 0.0;
93       e->s = dmax(e->s, tf_shift(&k.k, 0, p->sz, n, vecn, p->sign,
94  				inA, inB, outA, outB, 
95  				tmp, rounds, tol, TIME_SHIFT));
96       e->s = dmax(e->s, tf_shift(&k.k, 0, p->sz, n, vecn, p->sign,
97  				inA, inB, outA, outB, 
98  				tmp, rounds, tol, FREQ_SHIFT));
99       if (!p->in_place && !p->destroy_input)
100  	  preserves_input(&k.k, 0, N, inA, inB, outB, rounds);
101       bench_free(tmp);
102       bench_free(outC);
103       bench_free(outB);
104       bench_free(outA);
105       bench_free(inC);
106       bench_free(inB);
107       bench_free(inA);
108  }
109  void accuracy_dft(bench_problem *p, int rounds, int impulse_rounds,
110  		  double t[6])
111  {
112       dofft_dft_closure k;
113       int n;
114       C *a, *b;
115       BENCH_ASSERT(p->kind == PROBLEM_COMPLEX);
116       BENCH_ASSERT(p->sz->rnk == 1);
117       BENCH_ASSERT(p->vecsz->rnk == 0);
118       k.k.apply = dft_apply;
119       k.k.recopy_input = 0;
120       k.p = p;
121       n = tensor_sz(p->sz);
122       a = (C *) bench_malloc(n * sizeof(C));
123       b = (C *) bench_malloc(n * sizeof(C));
124       accuracy_test(&k.k, 0, p->sign, n, a, b, rounds, impulse_rounds, t);
125       bench_free(b);
126       bench_free(a);
127  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-block.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-verify-dft.c</div>
                </div>
                <div class="column column_space"><pre><code>77       return XM(is_local_after)(0, sz, k);
78  }
79  int XM(is_block1d)(const dtensor *sz, block_kind k)
80  {
81       int i;
</pre></code></div>
                <div class="column column_space"><pre><code>64       tensor_destroy(totalsz_swap);
65       tensor_destroy(pckdsz_swap);
66  }
67  void verify_dft(bench_problem *p, int rounds, double tol, errors *e)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    