
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 83.6248012718601%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-pixfmt.h</h3>
            <pre><code>1  #ifndef AVUTIL_PIXFMT_H
2  #define AVUTIL_PIXFMT_H
3  #include "libavutil/avconfig.h"
4  #include "version.h"
5  #define AVPALETTE_SIZE 1024
6  #define AVPALETTE_COUNT 256
7  enum AVPixelFormat {
8      AV_PIX_FMT_NONE = -1,
9      AV_PIX_FMT_YUV420P,   
10      AV_PIX_FMT_YUYV422,   
11      AV_PIX_FMT_RGB24,     
12      AV_PIX_FMT_BGR24,     
13      AV_PIX_FMT_YUV422P,   
14      AV_PIX_FMT_YUV444P,   
15      AV_PIX_FMT_YUV410P,   
16      AV_PIX_FMT_YUV411P,   
17      AV_PIX_FMT_GRAY8,     
18      AV_PIX_FMT_MONOWHITE, 
19      AV_PIX_FMT_MONOBLACK, 
20      AV_PIX_FMT_PAL8,      
21      AV_PIX_FMT_YUVJ420P,  
22      AV_PIX_FMT_YUVJ422P,  
23      AV_PIX_FMT_YUVJ444P,  
24  #if FF_API_XVMC
25      AV_PIX_FMT_XVMC_MPEG2_MC,
26      AV_PIX_FMT_XVMC_MPEG2_IDCT,
27      AV_PIX_FMT_XVMC = AV_PIX_FMT_XVMC_MPEG2_IDCT,
28  #endif &bsol;* FF_API_XVMC */
29      AV_PIX_FMT_UYVY422,   
30      AV_PIX_FMT_UYYVYY411, 
31      AV_PIX_FMT_BGR8,      
32      AV_PIX_FMT_BGR4,      
33      AV_PIX_FMT_BGR4_BYTE, 
34      AV_PIX_FMT_RGB8,      
35      AV_PIX_FMT_RGB4,      
36      AV_PIX_FMT_RGB4_BYTE, 
37      AV_PIX_FMT_NV12,      
38      AV_PIX_FMT_NV21,      
39      AV_PIX_FMT_ARGB,      
40      AV_PIX_FMT_RGBA,      
41      AV_PIX_FMT_ABGR,      
42      AV_PIX_FMT_BGRA,      
43      AV_PIX_FMT_GRAY16BE,  
44      AV_PIX_FMT_GRAY16LE,  
45      AV_PIX_FMT_YUV440P,   
46      AV_PIX_FMT_YUVJ440P,  
47      AV_PIX_FMT_YUVA420P,  
48  #if FF_API_VDPAU
49      AV_PIX_FMT_VDPAU_H264,
50      AV_PIX_FMT_VDPAU_MPEG1,
51      AV_PIX_FMT_VDPAU_MPEG2,
52      AV_PIX_FMT_VDPAU_WMV3,
53      AV_PIX_FMT_VDPAU_VC1, 
54  #endif
55      AV_PIX_FMT_RGB48BE,   
56      AV_PIX_FMT_RGB48LE,   
57      AV_PIX_FMT_RGB565BE,  
58      AV_PIX_FMT_RGB565LE,  
59      AV_PIX_FMT_RGB555BE,  
60      AV_PIX_FMT_RGB555LE,  
61      AV_PIX_FMT_BGR565BE,  
62      AV_PIX_FMT_BGR565LE,  
63      AV_PIX_FMT_BGR555BE,  
64      AV_PIX_FMT_BGR555LE,  
65  #if FF_API_VAAPI
66      AV_PIX_FMT_VAAPI_MOCO, 
67      AV_PIX_FMT_VAAPI_IDCT, 
68      AV_PIX_FMT_VAAPI_VLD,  
69      AV_PIX_FMT_VAAPI = AV_PIX_FMT_VAAPI_VLD,
70  #else
71      AV_PIX_FMT_VAAPI,
72  #endif
73      AV_PIX_FMT_YUV420P16LE,  
74      AV_PIX_FMT_YUV420P16BE,  
75      AV_PIX_FMT_YUV422P16LE,  
76      AV_PIX_FMT_YUV422P16BE,  
77      AV_PIX_FMT_YUV444P16LE,  
78      AV_PIX_FMT_YUV444P16BE,  
79  #if FF_API_VDPAU
80      AV_PIX_FMT_VDPAU_MPEG4,  
81  #endif
82      AV_PIX_FMT_DXVA2_VLD,    
83      AV_PIX_FMT_RGB444LE,  
84      AV_PIX_FMT_RGB444BE,  
85      AV_PIX_FMT_BGR444LE,  
86      AV_PIX_FMT_BGR444BE,  
87      AV_PIX_FMT_YA8,       
88      AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8, 
89      AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8, 
90      AV_PIX_FMT_BGR48BE,   
91      AV_PIX_FMT_BGR48LE,   
92      AV_PIX_FMT_YUV420P9BE, 
93      AV_PIX_FMT_YUV420P9LE, 
94      AV_PIX_FMT_YUV420P10BE,
95      AV_PIX_FMT_YUV420P10LE,
96      AV_PIX_FMT_YUV422P10BE,
97      AV_PIX_FMT_YUV422P10LE,
98      AV_PIX_FMT_YUV444P9BE, 
99      AV_PIX_FMT_YUV444P9LE, 
100      AV_PIX_FMT_YUV444P10BE,
101      AV_PIX_FMT_YUV444P10LE,
102      AV_PIX_FMT_YUV422P9BE, 
103      AV_PIX_FMT_YUV422P9LE, 
104      AV_PIX_FMT_VDA_VLD,    
105      AV_PIX_FMT_GBRP,      
106      AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP, 
107      AV_PIX_FMT_GBRP9BE,   
108      AV_PIX_FMT_GBRP9LE,   
109      AV_PIX_FMT_GBRP10BE,  
110      AV_PIX_FMT_GBRP10LE,  
111      AV_PIX_FMT_GBRP16BE,  
112      AV_PIX_FMT_GBRP16LE,  
113      AV_PIX_FMT_YUVA422P,  
114      AV_PIX_FMT_YUVA444P,  
115      AV_PIX_FMT_YUVA420P9BE,  
116      AV_PIX_FMT_YUVA420P9LE,  
117      AV_PIX_FMT_YUVA422P9BE,  
118      AV_PIX_FMT_YUVA422P9LE,  
119      AV_PIX_FMT_YUVA444P9BE,  
120      AV_PIX_FMT_YUVA444P9LE,  
121      AV_PIX_FMT_YUVA420P10BE, 
122      AV_PIX_FMT_YUVA420P10LE, 
123      AV_PIX_FMT_YUVA422P10BE, 
124      AV_PIX_FMT_YUVA422P10LE, 
125      AV_PIX_FMT_YUVA444P10BE, 
126      AV_PIX_FMT_YUVA444P10LE, 
127      AV_PIX_FMT_YUVA420P16BE, 
128      AV_PIX_FMT_YUVA420P16LE, 
129      AV_PIX_FMT_YUVA422P16BE, 
130      AV_PIX_FMT_YUVA422P16LE, 
131      AV_PIX_FMT_YUVA444P16BE, 
132      AV_PIX_FMT_YUVA444P16LE, 
133      AV_PIX_FMT_VDPAU,     
134      AV_PIX_FMT_XYZ12LE,      
135      AV_PIX_FMT_XYZ12BE,      
136      AV_PIX_FMT_NV16,         
137      AV_PIX_FMT_NV20LE,       
138      AV_PIX_FMT_NV20BE,       
139      AV_PIX_FMT_RGBA64BE,     
140      AV_PIX_FMT_RGBA64LE,     
141      AV_PIX_FMT_BGRA64BE,     
142      AV_PIX_FMT_BGRA64LE,     
143      AV_PIX_FMT_YVYU422,   
144      AV_PIX_FMT_VDA,          
145      AV_PIX_FMT_YA16BE,       
146      AV_PIX_FMT_YA16LE,       
147      AV_PIX_FMT_GBRAP,        
148      AV_PIX_FMT_GBRAP16BE,    
149      AV_PIX_FMT_GBRAP16LE,    
150      AV_PIX_FMT_QSV,
151      AV_PIX_FMT_MMAL,
152      AV_PIX_FMT_D3D11VA_VLD,  
153      AV_PIX_FMT_CUDA,
154      AV_PIX_FMT_0RGB=0x123+4,
155      AV_PIX_FMT_RGB0,        
156      AV_PIX_FMT_0BGR,        
157      AV_PIX_FMT_BGR0,        
158      AV_PIX_FMT_YUV420P12BE, 
159      AV_PIX_FMT_YUV420P12LE, 
160      AV_PIX_FMT_YUV420P14BE, 
161      AV_PIX_FMT_YUV420P14LE, 
162      AV_PIX_FMT_YUV422P12BE, 
163      AV_PIX_FMT_YUV422P12LE, 
164      AV_PIX_FMT_YUV422P14BE, 
165      AV_PIX_FMT_YUV422P14LE, 
166      AV_PIX_FMT_YUV444P12BE, 
167      AV_PIX_FMT_YUV444P12LE, 
168      AV_PIX_FMT_YUV444P14BE, 
169      AV_PIX_FMT_YUV444P14LE, 
170      AV_PIX_FMT_GBRP12BE,    
171      AV_PIX_FMT_GBRP12LE,    
172      AV_PIX_FMT_GBRP14BE,    
173      AV_PIX_FMT_GBRP14LE,    
174      AV_PIX_FMT_YUVJ411P,    
175      AV_PIX_FMT_BAYER_BGGR8,    
176      AV_PIX_FMT_BAYER_RGGB8,    
177      AV_PIX_FMT_BAYER_GBRG8,    
178      AV_PIX_FMT_BAYER_GRBG8,    
179      AV_PIX_FMT_BAYER_BGGR16LE, 
180      AV_PIX_FMT_BAYER_BGGR16BE, 
181      AV_PIX_FMT_BAYER_RGGB16LE, 
182      AV_PIX_FMT_BAYER_RGGB16BE, 
183      AV_PIX_FMT_BAYER_GBRG16LE, 
184      AV_PIX_FMT_BAYER_GBRG16BE, 
185      AV_PIX_FMT_BAYER_GRBG16LE, 
186      AV_PIX_FMT_BAYER_GRBG16BE, 
187  #if !FF_API_XVMC
188      AV_PIX_FMT_XVMC,
189  #endif &bsol;* !FF_API_XVMC */
190      AV_PIX_FMT_YUV440P10LE, 
191      AV_PIX_FMT_YUV440P10BE, 
192      AV_PIX_FMT_YUV440P12LE, 
193      AV_PIX_FMT_YUV440P12BE, 
194      AV_PIX_FMT_AYUV64LE,    
195      AV_PIX_FMT_AYUV64BE,    
196      AV_PIX_FMT_VIDEOTOOLBOX, 
197      AV_PIX_FMT_P010LE, 
198      AV_PIX_FMT_P010BE, 
199      AV_PIX_FMT_GBRAP12BE,  
200      AV_PIX_FMT_GBRAP12LE,  
201      AV_PIX_FMT_GBRAP10BE,  
202      AV_PIX_FMT_GBRAP10LE,  
203      AV_PIX_FMT_MEDIACODEC, 
204      AV_PIX_FMT_GRAY12BE,   
205      AV_PIX_FMT_GRAY12LE,   
206      AV_PIX_FMT_GRAY10BE,   
207      AV_PIX_FMT_GRAY10LE,   
208      AV_PIX_FMT_P016LE, 
209      AV_PIX_FMT_P016BE, 
210      AV_PIX_FMT_D3D11,
211      AV_PIX_FMT_GRAY9BE,   
212      AV_PIX_FMT_GRAY9LE,   
213      AV_PIX_FMT_GBRPF32BE,  
214      AV_PIX_FMT_GBRPF32LE,  
215      AV_PIX_FMT_GBRAPF32BE, 
216      AV_PIX_FMT_GBRAPF32LE, 
217      AV_PIX_FMT_DRM_PRIME,
218      AV_PIX_FMT_NB         
219  };
220  #if AV_HAVE_BIGENDIAN
221  #   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##be
222  #else
223  #   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##le
224  #endif
225  #define AV_PIX_FMT_RGB32   AV_PIX_FMT_NE(ARGB, BGRA)
226  #define AV_PIX_FMT_RGB32_1 AV_PIX_FMT_NE(RGBA, ABGR)
227  #define AV_PIX_FMT_BGR32   AV_PIX_FMT_NE(ABGR, RGBA)
228  #define AV_PIX_FMT_BGR32_1 AV_PIX_FMT_NE(BGRA, ARGB)
229  #define AV_PIX_FMT_0RGB32  AV_PIX_FMT_NE(0RGB, BGR0)
230  #define AV_PIX_FMT_0BGR32  AV_PIX_FMT_NE(0BGR, RGB0)
231  #define AV_PIX_FMT_GRAY9  AV_PIX_FMT_NE(GRAY9BE,  GRAY9LE)
232  #define AV_PIX_FMT_GRAY10 AV_PIX_FMT_NE(GRAY10BE, GRAY10LE)
233  #define AV_PIX_FMT_GRAY12 AV_PIX_FMT_NE(GRAY12BE, GRAY12LE)
234  #define AV_PIX_FMT_GRAY16 AV_PIX_FMT_NE(GRAY16BE, GRAY16LE)
235  #define AV_PIX_FMT_YA16   AV_PIX_FMT_NE(YA16BE,   YA16LE)
236  #define AV_PIX_FMT_RGB48  AV_PIX_FMT_NE(RGB48BE,  RGB48LE)
237  #define AV_PIX_FMT_RGB565 AV_PIX_FMT_NE(RGB565BE, RGB565LE)
238  #define AV_PIX_FMT_RGB555 AV_PIX_FMT_NE(RGB555BE, RGB555LE)
239  #define AV_PIX_FMT_RGB444 AV_PIX_FMT_NE(RGB444BE, RGB444LE)
240  #define AV_PIX_FMT_RGBA64 AV_PIX_FMT_NE(RGBA64BE, RGBA64LE)
241  #define AV_PIX_FMT_BGR48  AV_PIX_FMT_NE(BGR48BE,  BGR48LE)
242  #define AV_PIX_FMT_BGR565 AV_PIX_FMT_NE(BGR565BE, BGR565LE)
243  #define AV_PIX_FMT_BGR555 AV_PIX_FMT_NE(BGR555BE, BGR555LE)
244  #define AV_PIX_FMT_BGR444 AV_PIX_FMT_NE(BGR444BE, BGR444LE)
245  #define AV_PIX_FMT_BGRA64 AV_PIX_FMT_NE(BGRA64BE, BGRA64LE)
246  #define AV_PIX_FMT_YUV420P9  AV_PIX_FMT_NE(YUV420P9BE , YUV420P9LE)
247  #define AV_PIX_FMT_YUV422P9  AV_PIX_FMT_NE(YUV422P9BE , YUV422P9LE)
248  #define AV_PIX_FMT_YUV444P9  AV_PIX_FMT_NE(YUV444P9BE , YUV444P9LE)
249  #define AV_PIX_FMT_YUV420P10 AV_PIX_FMT_NE(YUV420P10BE, YUV420P10LE)
250  #define AV_PIX_FMT_YUV422P10 AV_PIX_FMT_NE(YUV422P10BE, YUV422P10LE)
251  #define AV_PIX_FMT_YUV440P10 AV_PIX_FMT_NE(YUV440P10BE, YUV440P10LE)
252  #define AV_PIX_FMT_YUV444P10 AV_PIX_FMT_NE(YUV444P10BE, YUV444P10LE)
253  #define AV_PIX_FMT_YUV420P12 AV_PIX_FMT_NE(YUV420P12BE, YUV420P12LE)
254  #define AV_PIX_FMT_YUV422P12 AV_PIX_FMT_NE(YUV422P12BE, YUV422P12LE)
255  #define AV_PIX_FMT_YUV440P12 AV_PIX_FMT_NE(YUV440P12BE, YUV440P12LE)
256  #define AV_PIX_FMT_YUV444P12 AV_PIX_FMT_NE(YUV444P12BE, YUV444P12LE)
257  #define AV_PIX_FMT_YUV420P14 AV_PIX_FMT_NE(YUV420P14BE, YUV420P14LE)
258  #define AV_PIX_FMT_YUV422P14 AV_PIX_FMT_NE(YUV422P14BE, YUV422P14LE)
259  #define AV_PIX_FMT_YUV444P14 AV_PIX_FMT_NE(YUV444P14BE, YUV444P14LE)
260  #define AV_PIX_FMT_YUV420P16 AV_PIX_FMT_NE(YUV420P16BE, YUV420P16LE)
261  #define AV_PIX_FMT_YUV422P16 AV_PIX_FMT_NE(YUV422P16BE, YUV422P16LE)
262  #define AV_PIX_FMT_YUV444P16 AV_PIX_FMT_NE(YUV444P16BE, YUV444P16LE)
263  #define AV_PIX_FMT_GBRP9     AV_PIX_FMT_NE(GBRP9BE ,    GBRP9LE)
264  #define AV_PIX_FMT_GBRP10    AV_PIX_FMT_NE(GBRP10BE,    GBRP10LE)
265  #define AV_PIX_FMT_GBRP12    AV_PIX_FMT_NE(GBRP12BE,    GBRP12LE)
266  #define AV_PIX_FMT_GBRP14    AV_PIX_FMT_NE(GBRP14BE,    GBRP14LE)
267  #define AV_PIX_FMT_GBRP16    AV_PIX_FMT_NE(GBRP16BE,    GBRP16LE)
268  #define AV_PIX_FMT_GBRAP10   AV_PIX_FMT_NE(GBRAP10BE,   GBRAP10LE)
269  #define AV_PIX_FMT_GBRAP12   AV_PIX_FMT_NE(GBRAP12BE,   GBRAP12LE)
270  #define AV_PIX_FMT_GBRAP16   AV_PIX_FMT_NE(GBRAP16BE,   GBRAP16LE)
271  #define AV_PIX_FMT_BAYER_BGGR16 AV_PIX_FMT_NE(BAYER_BGGR16BE,    BAYER_BGGR16LE)
272  #define AV_PIX_FMT_BAYER_RGGB16 AV_PIX_FMT_NE(BAYER_RGGB16BE,    BAYER_RGGB16LE)
273  #define AV_PIX_FMT_BAYER_GBRG16 AV_PIX_FMT_NE(BAYER_GBRG16BE,    BAYER_GBRG16LE)
274  #define AV_PIX_FMT_BAYER_GRBG16 AV_PIX_FMT_NE(BAYER_GRBG16BE,    BAYER_GRBG16LE)
275  #define AV_PIX_FMT_GBRPF32    AV_PIX_FMT_NE(GBRPF32BE,  GBRPF32LE)
276  #define AV_PIX_FMT_GBRAPF32   AV_PIX_FMT_NE(GBRAPF32BE, GBRAPF32LE)
277  #define AV_PIX_FMT_YUVA420P9  AV_PIX_FMT_NE(YUVA420P9BE , YUVA420P9LE)
278  #define AV_PIX_FMT_YUVA422P9  AV_PIX_FMT_NE(YUVA422P9BE , YUVA422P9LE)
279  #define AV_PIX_FMT_YUVA444P9  AV_PIX_FMT_NE(YUVA444P9BE , YUVA444P9LE)
280  #define AV_PIX_FMT_YUVA420P10 AV_PIX_FMT_NE(YUVA420P10BE, YUVA420P10LE)
281  #define AV_PIX_FMT_YUVA422P10 AV_PIX_FMT_NE(YUVA422P10BE, YUVA422P10LE)
282  #define AV_PIX_FMT_YUVA444P10 AV_PIX_FMT_NE(YUVA444P10BE, YUVA444P10LE)
283  #define AV_PIX_FMT_YUVA420P16 AV_PIX_FMT_NE(YUVA420P16BE, YUVA420P16LE)
284  #define AV_PIX_FMT_YUVA422P16 AV_PIX_FMT_NE(YUVA422P16BE, YUVA422P16LE)
285  #define AV_PIX_FMT_YUVA444P16 AV_PIX_FMT_NE(YUVA444P16BE, YUVA444P16LE)
286  #define AV_PIX_FMT_XYZ12      AV_PIX_FMT_NE(XYZ12BE, XYZ12LE)
287  #define AV_PIX_FMT_NV20       AV_PIX_FMT_NE(NV20BE,  NV20LE)
288  #define AV_PIX_FMT_AYUV64     AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)
289  #define AV_PIX_FMT_P010       AV_PIX_FMT_NE(P010BE,  P010LE)
290  #define AV_PIX_FMT_P016       AV_PIX_FMT_NE(P016BE,  P016LE)
291  enum AVColorPrimaries {
<span onclick='openModal()' class='match'>292      AVCOL_PRI_RESERVED0   = 0,
293      AVCOL_PRI_BT709       = 1,  
294      AVCOL_PRI_UNSPECIFIED = 2,
295      AVCOL_PRI_RESERVED    = 3,
296      AVCOL_PRI_BT470M      = 4,  
297      AVCOL_PRI_BT470BG     = 5,  
298      AVCOL_PRI_SMPTE170M   = 6,  
299      AVCOL_PRI_SMPTE240M   = 7,  
300      AVCOL_PRI_FILM        = 8,  
301      AVCOL_PRI_BT2020      = 9,  
302      AVCOL_PRI_SMPTE428    = 10, 
303      AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,
304      AVCOL_PRI_SMPTE431    = 11, 
305      AVCOL_PRI_SMPTE432    = 12, 
306      AVCOL_PRI_JEDEC_P22   = 22, 
307      AVCOL_PRI_NB                
</span>308  };
309  enum AVColorTransferCharacteristic {
310      AVCOL_TRC_RESERVED0    = 0,
311      AVCOL_TRC_BT709        = 1,  
312      AVCOL_TRC_UNSPECIFIED  = 2,
313      AVCOL_TRC_RESERVED     = 3,
314      AVCOL_TRC_GAMMA22      = 4,  
315      AVCOL_TRC_GAMMA28      = 5,  
316      AVCOL_TRC_SMPTE170M    = 6,  
317      AVCOL_TRC_SMPTE240M    = 7,
318      AVCOL_TRC_LINEAR       = 8,  
319      AVCOL_TRC_LOG          = 9,  
320      AVCOL_TRC_LOG_SQRT     = 10, 
321      AVCOL_TRC_IEC61966_2_4 = 11, 
322      AVCOL_TRC_BT1361_ECG   = 12, 
323      AVCOL_TRC_IEC61966_2_1 = 13, 
324      AVCOL_TRC_BT2020_10    = 14, 
325      AVCOL_TRC_BT2020_12    = 15, 
326      AVCOL_TRC_SMPTE2084    = 16, 
327      AVCOL_TRC_SMPTEST2084  = AVCOL_TRC_SMPTE2084,
328      AVCOL_TRC_SMPTE428     = 17, 
329      AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428,
330      AVCOL_TRC_ARIB_STD_B67 = 18, 
331      AVCOL_TRC_NB                 
332  };
333  enum AVColorSpace {
334      AVCOL_SPC_RGB         = 0,  
335      AVCOL_SPC_BT709       = 1,  
336      AVCOL_SPC_UNSPECIFIED = 2,
337      AVCOL_SPC_RESERVED    = 3,
338      AVCOL_SPC_FCC         = 4,  
339      AVCOL_SPC_BT470BG     = 5,  
340      AVCOL_SPC_SMPTE170M   = 6,  
341      AVCOL_SPC_SMPTE240M   = 7,  
342      AVCOL_SPC_YCGCO       = 8,  
343      AVCOL_SPC_YCOCG       = AVCOL_SPC_YCGCO,
344      AVCOL_SPC_BT2020_NCL  = 9,  
345      AVCOL_SPC_BT2020_CL   = 10, 
346      AVCOL_SPC_SMPTE2085   = 11, 
347      AVCOL_SPC_CHROMA_DERIVED_NCL = 12, 
348      AVCOL_SPC_CHROMA_DERIVED_CL = 13, 
349      AVCOL_SPC_ICTCP       = 14, 
350      AVCOL_SPC_NB                
351  };
352  enum AVColorRange {
353      AVCOL_RANGE_UNSPECIFIED = 0,
354      AVCOL_RANGE_MPEG        = 1, 
355      AVCOL_RANGE_JPEG        = 2, 
356      AVCOL_RANGE_NB               
357  };
358  enum AVChromaLocation {
359      AVCHROMA_LOC_UNSPECIFIED = 0,
360      AVCHROMA_LOC_LEFT        = 1, 
361      AVCHROMA_LOC_CENTER      = 2, 
362      AVCHROMA_LOC_TOPLEFT     = 3, 
363      AVCHROMA_LOC_TOP         = 4,
364      AVCHROMA_LOC_BOTTOMLEFT  = 5,
365      AVCHROMA_LOC_BOTTOM      = 6,
366      AVCHROMA_LOC_NB               
367  };
368  #endif &bsol;* AVUTIL_PIXFMT_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_private.h</h3>
            <pre><code>1  #include "tomcrypt.h"
2  #define LTC_PAD_MASK       (0xF000U)
3  #ifndef LTC_NULL
4     #define LTC_NULL ((void *)0)
5  #endif
6  enum ltc_oid_id {
7     LTC_OID_RSA,
8     LTC_OID_DSA,
9     LTC_OID_EC,
10     LTC_OID_EC_PRIMEF,
11     LTC_OID_X25519,
12     LTC_OID_ED25519,
13  };
14  typedef struct {
15    int size;
16    const char *name, *base, *prime;
17  } ltc_dh_set_type;
18  typedef int (*fn_kdf_t)(const unsigned char *password, unsigned long password_len,
19                                const unsigned char *salt,     unsigned long salt_len,
20                                int iteration_count,  int hash_idx,
21                                unsigned char *out,   unsigned long *outlen);
22  typedef struct {
23     fn_kdf_t kdf;
24     const char* h;
25     const char* c;
26     unsigned long keylen;
27     unsigned long blocklen;
28  } pbes_properties;
29  typedef struct
30  {
31     pbes_properties type;
32     const void *pwd;
33     unsigned long pwdlen;
34     ltc_asn1_list *enc_data;
35     ltc_asn1_list *salt;
36     ltc_asn1_list *iv;
37     unsigned long iterations;
38     unsigned long key_bits;
39  } pbes_arg;
40  void blowfish_enc(ulong32 *data, unsigned long blocks, const symmetric_key *skey);
41  int blowfish_expand(const unsigned char *key, int keylen,
42                      const unsigned char *data, int datalen,
43                      symmetric_key *skey);
44  int blowfish_setup_with_data(const unsigned char *key, int keylen,
45                               const unsigned char *data, int datalen,
46                               symmetric_key *skey);
47  #define HASH_PROCESS(func_name, compress_name, state_var, block_size)                       \
48  int func_name (hash_state * md, const unsigned char *in, unsigned long inlen)               \
49  {                                                                                           \
50      unsigned long n;                                                                        \
51      int           err;                                                                      \
52      LTC_ARGCHK(md != NULL);                                                                 \
53      LTC_ARGCHK(in != NULL);                                                                 \
54      if (md-> state_var .curlen > sizeof(md-> state_var .buf)) {                             \
55         return CRYPT_INVALID_ARG;                                                            \
56      }                                                                                       \
57      if (((md-> state_var .length + inlen * 8) < md-> state_var .length)                     \
58            || ((inlen * 8) < inlen)) {                                                       \
59        return CRYPT_HASH_OVERFLOW;                                                           \
60      }                                                                                       \
61      while (inlen > 0) {                                                                     \
62          if (md-> state_var .curlen == 0 && inlen >= block_size) {                           \
63             if ((err = compress_name (md, in)) != CRYPT_OK) {                                \
64                return err;                                                                   \
65             }                                                                                \
66             md-> state_var .length += block_size * 8;                                        \
67             in             += block_size;                                                    \
68             inlen          -= block_size;                                                    \
69          } else {                                                                            \
70             n = MIN(inlen, (block_size - md-> state_var .curlen));                           \
71             XMEMCPY(md-> state_var .buf + md-> state_var.curlen, in, (size_t)n);             \
72             md-> state_var .curlen += n;                                                     \
73             in             += n;                                                             \
74             inlen          -= n;                                                             \
75             if (md-> state_var .curlen == block_size) {                                      \
76                if ((err = compress_name (md, md-> state_var .buf)) != CRYPT_OK) {            \
77                   return err;                                                                \
78                }                                                                             \
79                md-> state_var .length += 8*block_size;                                       \
80                md-> state_var .curlen = 0;                                                   \
81             }                                                                                \
82         }                                                                                    \
83      }                                                                                       \
84      return CRYPT_OK;                                                                        \
85  }
86  int ocb3_int_ntz(unsigned long x);
87  void ocb3_int_xor_blocks(unsigned char *out, const unsigned char *block_a, const unsigned char *block_b, unsigned long block_len);
88  #if !defined(DESC_DEF_ONLY)
89  #define MP_DIGIT_BIT                 ltc_mp.bits_per_digit
90  #define mp_init(a)                   ltc_mp.init(a)
91  #define mp_init_multi                ltc_init_multi
92  #define mp_clear(a)                  ltc_mp.deinit(a)
93  #define mp_clear_multi               ltc_deinit_multi
94  #define mp_cleanup_multi             ltc_cleanup_multi
95  #define mp_init_copy(a, b)           ltc_mp.init_copy(a, b)
96  #define mp_neg(a, b)                 ltc_mp.neg(a, b)
97  #define mp_copy(a, b)                ltc_mp.copy(a, b)
98  #define mp_set(a, b)                 ltc_mp.set_int(a, b)
99  #define mp_set_int(a, b)             ltc_mp.set_int(a, b)
100  #define mp_get_int(a)                ltc_mp.get_int(a)
101  #define mp_get_digit(a, n)           ltc_mp.get_digit(a, n)
102  #define mp_get_digit_count(a)        ltc_mp.get_digit_count(a)
103  #define mp_cmp(a, b)                 ltc_mp.compare(a, b)
104  #define mp_cmp_d(a, b)               ltc_mp.compare_d(a, b)
105  #define mp_count_bits(a)             ltc_mp.count_bits(a)
106  #define mp_cnt_lsb(a)                ltc_mp.count_lsb_bits(a)
107  #define mp_2expt(a, b)               ltc_mp.twoexpt(a, b)
108  #define mp_read_radix(a, b, c)       ltc_mp.read_radix(a, b, c)
109  #define mp_toradix(a, b, c)          ltc_mp.write_radix(a, b, c)
110  #define mp_unsigned_bin_size(a)      ltc_mp.unsigned_size(a)
111  #define mp_to_unsigned_bin(a, b)     ltc_mp.unsigned_write(a, b)
112  #define mp_read_unsigned_bin(a, b, c) ltc_mp.unsigned_read(a, b, c)
113  #define mp_add(a, b, c)              ltc_mp.add(a, b, c)
114  #define mp_add_d(a, b, c)            ltc_mp.addi(a, b, c)
115  #define mp_sub(a, b, c)              ltc_mp.sub(a, b, c)
116  #define mp_sub_d(a, b, c)            ltc_mp.subi(a, b, c)
117  #define mp_mul(a, b, c)              ltc_mp.mul(a, b, c)
118  #define mp_mul_d(a, b, c)            ltc_mp.muli(a, b, c)
119  #define mp_sqr(a, b)                 ltc_mp.sqr(a, b)
120  #define mp_sqrtmod_prime(a, b, c)    ltc_mp.sqrtmod_prime(a, b, c)
121  #define mp_div(a, b, c, d)           ltc_mp.mpdiv(a, b, c, d)
122  #define mp_div_2(a, b)               ltc_mp.div_2(a, b)
123  #define mp_mod(a, b, c)              ltc_mp.mpdiv(a, b, NULL, c)
124  #define mp_mod_d(a, b, c)            ltc_mp.modi(a, b, c)
125  #define mp_gcd(a, b, c)              ltc_mp.gcd(a, b, c)
126  #define mp_lcm(a, b, c)              ltc_mp.lcm(a, b, c)
127  #define mp_addmod(a, b, c, d)        ltc_mp.addmod(a, b, c, d)
128  #define mp_submod(a, b, c, d)        ltc_mp.submod(a, b, c, d)
129  #define mp_mulmod(a, b, c, d)        ltc_mp.mulmod(a, b, c, d)
130  #define mp_sqrmod(a, b, c)           ltc_mp.sqrmod(a, b, c)
131  #define mp_invmod(a, b, c)           ltc_mp.invmod(a, b, c)
132  #define mp_montgomery_setup(a, b)    ltc_mp.montgomery_setup(a, b)
133  #define mp_montgomery_normalization(a, b) ltc_mp.montgomery_normalization(a, b)
134  #define mp_montgomery_reduce(a, b, c)   ltc_mp.montgomery_reduce(a, b, c)
135  #define mp_montgomery_free(a)        ltc_mp.montgomery_deinit(a)
136  #define mp_exptmod(a,b,c,d)          ltc_mp.exptmod(a,b,c,d)
137  #define mp_prime_is_prime(a, b, c)   ltc_mp.isprime(a, b, c)
138  #define mp_iszero(a)                 (mp_cmp_d(a, 0) == LTC_MP_EQ ? LTC_MP_YES : LTC_MP_NO)
139  #define mp_isodd(a)                  (mp_get_digit_count(a) > 0 ? (mp_get_digit(a, 0) & 1 ? LTC_MP_YES : LTC_MP_NO) : LTC_MP_NO)
140  #define mp_exch(a, b)                do { void *ABC__tmp = a; a = b; b = ABC__tmp; } while(0)
141  #define mp_tohex(a, b)               mp_toradix(a, b, 16)
142  #define mp_rand(a, b)                ltc_mp.rand(a, b)
143  #endif
144  typedef enum {
145     BASE64_PEM_CRLF = 1,
146     BASE64_PEM_SSH = 2,
147  } base64_pem_flags;
148  int base64_encode_pem(const unsigned char *in,  unsigned long inlen,
149                                       char *out, unsigned long *outlen,
150                              unsigned int  flags);
151  void copy_or_zeromem(const unsigned char* src, unsigned char* dest, unsigned long len, int coz);
152  int pbes_decrypt(const pbes_arg  *arg, unsigned char *dec_data, unsigned long *dec_size);
153  int pbes1_extract(const ltc_asn1_list *s, pbes_arg *res);
154  int pbes2_extract(const ltc_asn1_list *s, pbes_arg *res);
155  int rand_bn_bits(void *N, int bits, prng_state *prng, int wprng);
156  int rand_bn_upto(void *N, void *limit, prng_state *prng, int wprng);
157  int pk_get_oid(enum ltc_oid_id id, const char **st);
158  int pk_oid_str_to_num(const char *OID, unsigned long *oid, unsigned long *oidlen);
159  int pk_oid_num_to_str(const unsigned long *oid, unsigned long oidlen, char *OID, unsigned long *outlen);
160  #ifdef LTC_MRSA
161  int rsa_init(rsa_key *key);
162  void rsa_shrink_key(rsa_key *key);
163  int rsa_make_key_bn_e(prng_state *prng, int wprng, int size, void *e,
164                        rsa_key *key); &bsol;* used by op-tee */
165  int rsa_import_pkcs1(const unsigned char *in, unsigned long inlen, rsa_key *key);
166  #endif &bsol;* LTC_MRSA */
167  #ifdef LTC_MDH
168  extern const ltc_dh_set_type ltc_dh_sets[];
169  int dh_check_pubkey(const dh_key *key);
170  #endif &bsol;* LTC_MDH */
171  #ifdef LTC_MECC
172  int ecc_set_curve_from_mpis(void *a, void *b, void *prime, void *order, void *gx, void *gy, unsigned long cofactor, ecc_key *key);
173  int ecc_copy_curve(const ecc_key *srckey, ecc_key *key);
174  int ecc_set_curve_by_size(int size, ecc_key *key);
175  int ecc_import_subject_public_key_info(const unsigned char *in, unsigned long inlen, ecc_key *key);
176  #ifdef LTC_SSH
177  int ecc_ssh_ecdsa_encode_name(char *buffer, unsigned long *buflen, const ecc_key *key);
178  #endif
179  ecc_point *ltc_ecc_new_point(void);
180  void       ltc_ecc_del_point(ecc_point *p);
181  int        ltc_ecc_set_point_xyz(ltc_mp_digit x, ltc_mp_digit y, ltc_mp_digit z, ecc_point *p);
182  int        ltc_ecc_copy_point(const ecc_point *src, ecc_point *dst);
183  int        ltc_ecc_is_point(const ltc_ecc_dp *dp, void *x, void *y);
184  int        ltc_ecc_is_point_at_infinity(const ecc_point *P, void *modulus, int *retval);
185  int        ltc_ecc_import_point(const unsigned char *in, unsigned long inlen, void *prime, void *a, void *b, void *x, void *y);
186  int        ltc_ecc_export_point(unsigned char *out, unsigned long *outlen, void *x, void *y, unsigned long size, int compressed);
187  int        ltc_ecc_verify_key(const ecc_key *key);
188  #if !defined(LTC_MECC_ACCEL) || defined(LTM_DESC) || defined(GMP_DESC)
189  int ltc_ecc_projective_dbl_point(const ecc_point *P, ecc_point *R, void *ma, void *modulus, void *mp);
190  int ltc_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *mp);
191  #endif
192  #if defined(LTC_MECC_FP)
193  int ltc_ecc_fp_mulmod(void *k, ecc_point *G, ecc_point *R, void *a, void *modulus, int map);
194  int ltc_ecc_fp_save_state(unsigned char **out, unsigned long *outlen);
195  int ltc_ecc_fp_restore_state(unsigned char *in, unsigned long inlen);
196  void ltc_ecc_fp_free(void);
197  int ltc_ecc_fp_add_point(ecc_point *g, void *modulus, int lock);
198  void ltc_ecc_fp_tablelock(int lock);
199  #endif
200  int ltc_ecc_mulmod(void *k, const ecc_point *G, ecc_point *R, void *a, void *modulus, int map);
201  #ifdef LTC_ECC_SHAMIR
202  int ltc_ecc_mul2add(const ecc_point *A, void *kA,
203                      const ecc_point *B, void *kB,
204                            ecc_point *C,
205                                 void *ma,
206                                 void *modulus);
207  #ifdef LTC_MECC_FP
208  int ltc_ecc_fp_mul2add(const ecc_point *A, void *kA,
209                         const ecc_point *B, void *kB,
210                               ecc_point *C,
211                                    void *ma,
212                                    void *modulus);
213  #endif
214  #endif
215  int ltc_ecc_map(ecc_point *P, void *modulus, void *mp);
216  #endif &bsol;* LTC_MECC */
217  #ifdef LTC_MDSA
218  int dsa_int_validate_xy(const dsa_key *key, int *stat);
219  int dsa_int_validate_pqg(const dsa_key *key, int *stat);
220  int dsa_int_validate_primes(const dsa_key *key, int *stat);
221  #endif &bsol;* LTC_MDSA */
222  #ifdef LTC_CURVE25519
223  int tweetnacl_crypto_sign(
224    unsigned char *sm,unsigned long long *smlen,
225    const unsigned char *m,unsigned long long mlen,
226    const unsigned char *sk,const unsigned char *pk,
227    const unsigned char *ctx,unsigned long long cs);
228  int tweetnacl_crypto_sign_open(
229    int *stat,
230    unsigned char *m,unsigned long long *mlen,
231    const unsigned char *sm,unsigned long long smlen,
232    const unsigned char *ctx, unsigned long long cs,
233    const unsigned char *pk);
234  int tweetnacl_crypto_sign_keypair(prng_state *prng, int wprng, unsigned char *pk,unsigned char *sk);
235  int tweetnacl_crypto_sk_to_pk(unsigned char *pk, const unsigned char *sk);
236  int tweetnacl_crypto_scalarmult(unsigned char *q, const unsigned char *n, const unsigned char *p);
237  int tweetnacl_crypto_scalarmult_base(unsigned char *q,const unsigned char *n);
238  int tweetnacl_crypto_ph(unsigned char *out, const unsigned char *msg, unsigned long long msglen);
239  typedef int (*sk_to_pk)(unsigned char *pk ,const unsigned char *sk);
240  int ec25519_import_pkcs8(const unsigned char *in, unsigned long inlen,
241                         const void *pwd, unsigned long pwdlen,
242                         enum ltc_oid_id id, sk_to_pk fp,
243                         curve25519_key *key);
244  int ec25519_export(       unsigned char *out, unsigned long *outlen,
245                                      int  which,
246                     const curve25519_key *key);
247  int ec25519_crypto_ctx(      unsigned char *out, unsigned long *outlen,
248                               unsigned char flag,
249                         const unsigned char *ctx, unsigned long  ctxlen);
250  #endif &bsol;* LTC_CURVE25519 */
251  #ifdef LTC_DER
252  #define LTC_ASN1_IS_TYPE(e, t) (((e) != NULL) && ((e)->type == (t)))
253  int der_decode_custom_type_ex(const unsigned char *in, unsigned long  inlen,
254                             ltc_asn1_list *root,
255                             ltc_asn1_list *list,     unsigned long  outlen, unsigned int flags);
256  int der_encode_asn1_identifier(const ltc_asn1_list *id, unsigned char *out, unsigned long *outlen);
257  int der_decode_asn1_identifier(const unsigned char *in, unsigned long *inlen, ltc_asn1_list *id);
258  int der_length_asn1_identifier(const ltc_asn1_list *id, unsigned long *idlen);
259  int der_encode_asn1_length(unsigned long len, unsigned char* out, unsigned long* outlen);
260  int der_decode_asn1_length(const unsigned char *in, unsigned long *inlen, unsigned long *outlen);
261  int der_length_asn1_length(unsigned long len, unsigned long *outlen);
262  int der_length_sequence_ex(const ltc_asn1_list *list, unsigned long inlen,
263                             unsigned long *outlen, unsigned long *payloadlen);
264  extern const ltc_asn1_type  der_asn1_tag_to_type_map[];
<span onclick='openModal()' class='match'>265  extern const unsigned long  der_asn1_tag_to_type_map_sz;
266  extern const int der_asn1_type_to_identifier_map[];
267  extern const unsigned long der_asn1_type_to_identifier_map_sz;
268  int der_decode_sequence_multi_ex(const unsigned char *in, unsigned long inlen, unsigned int flags, ...)
269                                   LTC_NULL_TERMINATED;
270  int der_teletex_char_encode(int c);
271  int der_teletex_value_decode(int v);
272  int der_utf8_valid_char(const wchar_t c);
273  typedef int (*public_key_decode_cb)(const unsigned char *in, unsigned long inlen, void *ctx);
</span>274  int x509_decode_public_key_from_certificate(const unsigned char *in, unsigned long inlen,
275                                              enum ltc_oid_id algorithm, ltc_asn1_type param_type,
276                                              ltc_asn1_list* parameters, unsigned long *parameters_len,
277                                              public_key_decode_cb callback, void *ctx);
278  int x509_encode_subject_public_key_info(unsigned char *out, unsigned long *outlen,
279          unsigned int algorithm, const void* public_key, unsigned long public_key_len,
280          ltc_asn1_type parameters_type, ltc_asn1_list* parameters, unsigned long parameters_len);
281  int x509_decode_subject_public_key_info(const unsigned char *in, unsigned long inlen,
282          unsigned int algorithm, void* public_key, unsigned long* public_key_len,
283          ltc_asn1_type parameters_type, ltc_asn1_list* parameters, unsigned long *parameters_len);
284  int pk_oid_cmp_with_ulong(const char *o1, const unsigned long *o2, unsigned long o2size);
285  int pk_oid_cmp_with_asn1(const char *o1, const ltc_asn1_list *o2);
286  #endif &bsol;* LTC_DER */
287  #ifdef LTC_PKCS_8
288  int pkcs8_decode_flexi(const unsigned char  *in,  unsigned long inlen,
289                                      const void  *pwd, unsigned long pwdlen,
290                                   ltc_asn1_list **decoded_list);
291  #endif  &bsol;* LTC_PKCS_8 */
292  #ifdef LTC_PKCS_12
293  int pkcs12_utf8_to_utf16(const unsigned char *in,  unsigned long  inlen,
294                                 unsigned char *out, unsigned long *outlen);
295  int pkcs12_kdf(               int   hash_id,
296                 const unsigned char *pw,         unsigned long pwlen,
297                 const unsigned char *salt,       unsigned long saltlen,
298                       unsigned int   iterations, unsigned char purpose,
299                       unsigned char *out,        unsigned long outlen);
300  #endif  &bsol;* LTC_PKCS_12 */
301  #define LTC_PRNG_EXPORT(which) \
302  int which ## _export(unsigned char *out, unsigned long *outlen, prng_state *prng)      \
303  {                                                                                      \
304     unsigned long len = which ## _desc.export_size;                                     \
305                                                                                         \
306     LTC_ARGCHK(prng   != NULL);                                                         \
307     LTC_ARGCHK(out    != NULL);                                                         \
308     LTC_ARGCHK(outlen != NULL);                                                         \
309                                                                                         \
310     if (*outlen < len) {                                                                \
311        *outlen = len;                                                                   \
312        return CRYPT_BUFFER_OVERFLOW;                                                    \
313     }                                                                                   \
314                                                                                         \
315     if (which ## _read(out, len, prng) != len) {                                        \
316        return CRYPT_ERROR_READPRNG;                                                     \
317     }                                                                                   \
318                                                                                         \
319     *outlen = len;                                                                      \
320     return CRYPT_OK;                                                                    \
321  }
322  #ifdef _MSC_VER
323     #define LTC_BYTE(x, n) ((unsigned char)((x) >> (8 * (n))))
324  #else
325     #define LTC_BYTE(x, n) (((x) >> (8 * (n))) & 255)
326  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-pixfmt.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_private.h</div>
                </div>
                <div class="column column_space"><pre><code>292      AVCOL_PRI_RESERVED0   = 0,
293      AVCOL_PRI_BT709       = 1,  
294      AVCOL_PRI_UNSPECIFIED = 2,
295      AVCOL_PRI_RESERVED    = 3,
296      AVCOL_PRI_BT470M      = 4,  
297      AVCOL_PRI_BT470BG     = 5,  
298      AVCOL_PRI_SMPTE170M   = 6,  
299      AVCOL_PRI_SMPTE240M   = 7,  
300      AVCOL_PRI_FILM        = 8,  
301      AVCOL_PRI_BT2020      = 9,  
302      AVCOL_PRI_SMPTE428    = 10, 
303      AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,
304      AVCOL_PRI_SMPTE431    = 11, 
305      AVCOL_PRI_SMPTE432    = 12, 
306      AVCOL_PRI_JEDEC_P22   = 22, 
307      AVCOL_PRI_NB                
</pre></code></div>
                <div class="column column_space"><pre><code>265  extern const unsigned long  der_asn1_tag_to_type_map_sz;
266  extern const int der_asn1_type_to_identifier_map[];
267  extern const unsigned long der_asn1_type_to_identifier_map_sz;
268  int der_decode_sequence_multi_ex(const unsigned char *in, unsigned long inlen, unsigned int flags, ...)
269                                   LTC_NULL_TERMINATED;
270  int der_teletex_char_encode(int c);
271  int der_teletex_value_decode(int v);
272  int der_utf8_valid_char(const wchar_t c);
273  typedef int (*public_key_decode_cb)(const unsigned char *in, unsigned long inlen, void *ctx);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    