
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.86080586080586%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-n.c</h3>
            <pre><code>1  #include "dft/codelet-dft.h"
2  #include "dft/scalar/n.h"
<span onclick='openModal()' class='match'>3  static int okp(const kdft_desc *d,
4  	       const R *ri, const R *ii, 
5  	       const R *ro, const R *io,
6  	       INT is, INT os, INT vl, INT ivs, INT ovs,
</span>7  	       const planner *plnr)
8  {
9       UNUSED(ri); UNUSED(ii); UNUSED(ro); UNUSED(io); UNUSED(vl); UNUSED(plnr);
10       return (1
11  	     && (!d->is || (d->is == is))
12  	     && (!d->os || (d->os == os))
13  	     && (!d->ivs || (d->ivs == ivs))
14  	     && (!d->ovs || (d->ovs == ovs))
15  	  );
16  }
17  const kdft_genus GENUS = { okp, 1 };
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  TEST_BEGIN(test_stats_summary) {
3  	size_t sz, allocated, active, resident, mapped;
4  	int expected = config_stats ? 0 : ENOENT;
5  	sz = sizeof(size_t);
6  	assert_d_eq(mallctl("stats.allocated", (void *)&allocated, &sz, NULL,
7  	    0), expected, "Unexpected mallctl() result");
8  	assert_d_eq(mallctl("stats.active", (void *)&active, &sz, NULL, 0),
9  	    expected, "Unexpected mallctl() result");
10  	assert_d_eq(mallctl("stats.resident", (void *)&resident, &sz, NULL, 0),
11  	    expected, "Unexpected mallctl() result");
12  	assert_d_eq(mallctl("stats.mapped", (void *)&mapped, &sz, NULL, 0),
13  	    expected, "Unexpected mallctl() result");
14  	if (config_stats) {
15  		assert_zu_le(allocated, active,
16  		    "allocated should be no larger than active");
17  		assert_zu_lt(active, resident,
18  		    "active should be less than resident");
19  		assert_zu_lt(active, mapped,
20  		    "active should be less than mapped");
21  	}
22  }
<span onclick='openModal()' class='match'>23  TEST_END
24  TEST_BEGIN(test_stats_large) {
25  	void *p;
26  	uint64_t epoch;
27  	size_t allocated;
28  	uint64_t nmalloc, ndalloc, nrequests;
29  	size_t sz;
30  	int expected = config_stats ? 0 : ENOENT;
</span>31  	p = mallocx(SC_SMALL_MAXCLASS + 1, MALLOCX_ARENA(0));
32  	assert_ptr_not_null(p, "Unexpected mallocx() failure");
33  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
34  	    0, "Unexpected mallctl() failure");
35  	sz = sizeof(size_t);
36  	assert_d_eq(mallctl("stats.arenas.0.large.allocated",
37  	    (void *)&allocated, &sz, NULL, 0), expected,
38  	    "Unexpected mallctl() result");
39  	sz = sizeof(uint64_t);
40  	assert_d_eq(mallctl("stats.arenas.0.large.nmalloc", (void *)&nmalloc,
41  	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
42  	assert_d_eq(mallctl("stats.arenas.0.large.ndalloc", (void *)&ndalloc,
43  	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
44  	assert_d_eq(mallctl("stats.arenas.0.large.nrequests",
45  	    (void *)&nrequests, &sz, NULL, 0), expected,
46  	    "Unexpected mallctl() result");
47  	if (config_stats) {
48  		assert_zu_gt(allocated, 0,
49  		    "allocated should be greater than zero");
50  		assert_u64_ge(nmalloc, ndalloc,
51  		    "nmalloc should be at least as large as ndalloc");
52  		assert_u64_le(nmalloc, nrequests,
53  		    "nmalloc should no larger than nrequests");
54  	}
55  	dallocx(p, 0);
56  }
57  TEST_END
58  TEST_BEGIN(test_stats_arenas_summary) {
59  	void *little, *large;
60  	uint64_t epoch;
61  	size_t sz;
62  	int expected = config_stats ? 0 : ENOENT;
63  	size_t mapped;
64  	uint64_t dirty_npurge, dirty_nmadvise, dirty_purged;
65  	uint64_t muzzy_npurge, muzzy_nmadvise, muzzy_purged;
66  	little = mallocx(SC_SMALL_MAXCLASS, MALLOCX_ARENA(0));
67  	assert_ptr_not_null(little, "Unexpected mallocx() failure");
68  	large = mallocx((1U << SC_LG_LARGE_MINCLASS),
69  	    MALLOCX_ARENA(0));
70  	assert_ptr_not_null(large, "Unexpected mallocx() failure");
71  	dallocx(little, 0);
72  	dallocx(large, 0);
73  	assert_d_eq(mallctl("thread.tcache.flush", NULL, NULL, NULL, 0),
74  	    opt_tcache ? 0 : EFAULT, "Unexpected mallctl() result");
75  	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
76  	    "Unexpected mallctl() failure");
77  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
78  	    0, "Unexpected mallctl() failure");
79  	sz = sizeof(size_t);
80  	assert_d_eq(mallctl("stats.arenas.0.mapped", (void *)&mapped, &sz, NULL,
81  	    0), expected, "Unexepected mallctl() result");
82  	sz = sizeof(uint64_t);
83  	assert_d_eq(mallctl("stats.arenas.0.dirty_npurge",
84  	    (void *)&dirty_npurge, &sz, NULL, 0), expected,
85  	    "Unexepected mallctl() result");
86  	assert_d_eq(mallctl("stats.arenas.0.dirty_nmadvise",
87  	    (void *)&dirty_nmadvise, &sz, NULL, 0), expected,
88  	    "Unexepected mallctl() result");
89  	assert_d_eq(mallctl("stats.arenas.0.dirty_purged",
90  	    (void *)&dirty_purged, &sz, NULL, 0), expected,
91  	    "Unexepected mallctl() result");
92  	assert_d_eq(mallctl("stats.arenas.0.muzzy_npurge",
93  	    (void *)&muzzy_npurge, &sz, NULL, 0), expected,
94  	    "Unexepected mallctl() result");
95  	assert_d_eq(mallctl("stats.arenas.0.muzzy_nmadvise",
96  	    (void *)&muzzy_nmadvise, &sz, NULL, 0), expected,
97  	    "Unexepected mallctl() result");
98  	assert_d_eq(mallctl("stats.arenas.0.muzzy_purged",
99  	    (void *)&muzzy_purged, &sz, NULL, 0), expected,
100  	    "Unexepected mallctl() result");
101  	if (config_stats) {
102  		if (!background_thread_enabled()) {
103  			assert_u64_gt(dirty_npurge + muzzy_npurge, 0,
104  			    "At least one purge should have occurred");
105  		}
106  		assert_u64_le(dirty_nmadvise, dirty_purged,
107  		    "dirty_nmadvise should be no greater than dirty_purged");
108  		assert_u64_le(muzzy_nmadvise, muzzy_purged,
109  		    "muzzy_nmadvise should be no greater than muzzy_purged");
110  	}
111  }
112  TEST_END
113  void *
114  thd_start(void *arg) {
115  	return NULL;
116  }
117  static void
118  no_lazy_lock(void) {
119  	thd_t thd;
120  	thd_create(&thd, thd_start, NULL);
121  	thd_join(thd, NULL);
122  }
123  TEST_BEGIN(test_stats_arenas_small) {
124  	void *p;
125  	size_t sz, allocated;
126  	uint64_t epoch, nmalloc, ndalloc, nrequests;
127  	int expected = config_stats ? 0 : ENOENT;
128  	no_lazy_lock(); &bsol;* Lazy locking would dodge tcache testing. */
129  	p = mallocx(SC_SMALL_MAXCLASS, MALLOCX_ARENA(0));
130  	assert_ptr_not_null(p, "Unexpected mallocx() failure");
131  	assert_d_eq(mallctl("thread.tcache.flush", NULL, NULL, NULL, 0),
132  	    opt_tcache ? 0 : EFAULT, "Unexpected mallctl() result");
133  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
134  	    0, "Unexpected mallctl() failure");
135  	sz = sizeof(size_t);
136  	assert_d_eq(mallctl("stats.arenas.0.small.allocated",
137  	    (void *)&allocated, &sz, NULL, 0), expected,
138  	    "Unexpected mallctl() result");
139  	sz = sizeof(uint64_t);
140  	assert_d_eq(mallctl("stats.arenas.0.small.nmalloc", (void *)&nmalloc,
141  	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
142  	assert_d_eq(mallctl("stats.arenas.0.small.ndalloc", (void *)&ndalloc,
143  	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
144  	assert_d_eq(mallctl("stats.arenas.0.small.nrequests",
145  	    (void *)&nrequests, &sz, NULL, 0), expected,
146  	    "Unexpected mallctl() result");
147  	if (config_stats) {
148  		assert_zu_gt(allocated, 0,
149  		    "allocated should be greater than zero");
150  		assert_u64_gt(nmalloc, 0,
151  		    "nmalloc should be no greater than zero");
152  		assert_u64_ge(nmalloc, ndalloc,
153  		    "nmalloc should be at least as large as ndalloc");
154  		assert_u64_gt(nrequests, 0,
155  		    "nrequests should be greater than zero");
156  	}
157  	dallocx(p, 0);
158  }
159  TEST_END
160  TEST_BEGIN(test_stats_arenas_large) {
161  	void *p;
162  	size_t sz, allocated;
163  	uint64_t epoch, nmalloc, ndalloc;
164  	int expected = config_stats ? 0 : ENOENT;
165  	p = mallocx((1U << SC_LG_LARGE_MINCLASS), MALLOCX_ARENA(0));
166  	assert_ptr_not_null(p, "Unexpected mallocx() failure");
167  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
168  	    0, "Unexpected mallctl() failure");
169  	sz = sizeof(size_t);
170  	assert_d_eq(mallctl("stats.arenas.0.large.allocated",
171  	    (void *)&allocated, &sz, NULL, 0), expected,
172  	    "Unexpected mallctl() result");
173  	sz = sizeof(uint64_t);
174  	assert_d_eq(mallctl("stats.arenas.0.large.nmalloc", (void *)&nmalloc,
175  	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
176  	assert_d_eq(mallctl("stats.arenas.0.large.ndalloc", (void *)&ndalloc,
177  	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
178  	if (config_stats) {
179  		assert_zu_gt(allocated, 0,
180  		    "allocated should be greater than zero");
181  		assert_u64_gt(nmalloc, 0,
182  		    "nmalloc should be greater than zero");
183  		assert_u64_ge(nmalloc, ndalloc,
184  		    "nmalloc should be at least as large as ndalloc");
185  	}
186  	dallocx(p, 0);
187  }
188  TEST_END
189  static void
190  gen_mallctl_str(char *cmd, char *name, unsigned arena_ind) {
191  	sprintf(cmd, "stats.arenas.%u.bins.0.%s", arena_ind, name);
192  }
193  TEST_BEGIN(test_stats_arenas_bins) {
194  	void *p;
195  	size_t sz, curslabs, curregs, nonfull_slabs;
196  	uint64_t epoch, nmalloc, ndalloc, nrequests, nfills, nflushes;
197  	uint64_t nslabs, nreslabs;
198  	int expected = config_stats ? 0 : ENOENT;
199  	assert_d_eq(mallctl("thread.tcache.flush", NULL, NULL, NULL, 0),
200  	    opt_tcache ? 0 : EFAULT, "Unexpected mallctl() result");
201  	unsigned arena_ind, old_arena_ind;
202  	sz = sizeof(unsigned);
203  	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz, NULL, 0),
204  	    0, "Arena creation failure");
205  	sz = sizeof(arena_ind);
206  	assert_d_eq(mallctl("thread.arena", (void *)&old_arena_ind, &sz,
207  	    (void *)&arena_ind, sizeof(arena_ind)), 0,
208  	    "Unexpected mallctl() failure");
209  	p = malloc(bin_infos[0].reg_size);
210  	assert_ptr_not_null(p, "Unexpected malloc() failure");
211  	assert_d_eq(mallctl("thread.tcache.flush", NULL, NULL, NULL, 0),
212  	    opt_tcache ? 0 : EFAULT, "Unexpected mallctl() result");
213  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
214  	    0, "Unexpected mallctl() failure");
215  	char cmd[128];
216  	sz = sizeof(uint64_t);
217  	gen_mallctl_str(cmd, "nmalloc", arena_ind);
218  	assert_d_eq(mallctl(cmd, (void *)&nmalloc, &sz, NULL, 0), expected,
219  	    "Unexpected mallctl() result");
220  	gen_mallctl_str(cmd, "ndalloc", arena_ind);
221  	assert_d_eq(mallctl(cmd, (void *)&ndalloc, &sz, NULL, 0), expected,
222  	    "Unexpected mallctl() result");
223  	gen_mallctl_str(cmd, "nrequests", arena_ind);
224  	assert_d_eq(mallctl(cmd, (void *)&nrequests, &sz, NULL, 0), expected,
225  	    "Unexpected mallctl() result");
226  	sz = sizeof(size_t);
227  	gen_mallctl_str(cmd, "curregs", arena_ind);
228  	assert_d_eq(mallctl(cmd, (void *)&curregs, &sz, NULL, 0), expected,
229  	    "Unexpected mallctl() result");
230  	sz = sizeof(uint64_t);
231  	gen_mallctl_str(cmd, "nfills", arena_ind);
232  	assert_d_eq(mallctl(cmd, (void *)&nfills, &sz, NULL, 0), expected,
233  	    "Unexpected mallctl() result");
234  	gen_mallctl_str(cmd, "nflushes", arena_ind);
235  	assert_d_eq(mallctl(cmd, (void *)&nflushes, &sz, NULL, 0), expected,
236  	    "Unexpected mallctl() result");
237  	gen_mallctl_str(cmd, "nslabs", arena_ind);
238  	assert_d_eq(mallctl(cmd, (void *)&nslabs, &sz, NULL, 0), expected,
239  	    "Unexpected mallctl() result");
240  	gen_mallctl_str(cmd, "nreslabs", arena_ind);
241  	assert_d_eq(mallctl(cmd, (void *)&nreslabs, &sz, NULL, 0), expected,
242  	    "Unexpected mallctl() result");
243  	sz = sizeof(size_t);
244  	gen_mallctl_str(cmd, "curslabs", arena_ind);
245  	assert_d_eq(mallctl(cmd, (void *)&curslabs, &sz, NULL, 0), expected,
246  	    "Unexpected mallctl() result");
247  	gen_mallctl_str(cmd, "nonfull_slabs", arena_ind);
248  	assert_d_eq(mallctl(cmd, (void *)&nonfull_slabs, &sz, NULL, 0),
249  	    expected, "Unexpected mallctl() result");
250  	if (config_stats) {
251  		assert_u64_gt(nmalloc, 0,
252  		    "nmalloc should be greater than zero");
253  		assert_u64_ge(nmalloc, ndalloc,
254  		    "nmalloc should be at least as large as ndalloc");
255  		assert_u64_gt(nrequests, 0,
256  		    "nrequests should be greater than zero");
257  		assert_zu_gt(curregs, 0,
258  		    "allocated should be greater than zero");
259  		if (opt_tcache) {
260  			assert_u64_gt(nfills, 0,
261  			    "At least one fill should have occurred");
262  			assert_u64_gt(nflushes, 0,
263  			    "At least one flush should have occurred");
264  		}
265  		assert_u64_gt(nslabs, 0,
266  		    "At least one slab should have been allocated");
267  		assert_zu_gt(curslabs, 0,
268  		    "At least one slab should be currently allocated");
269  		assert_zu_eq(nonfull_slabs, 0,
270  		    "slabs_nonfull should be empty");
271  	}
272  	dallocx(p, 0);
273  }
274  TEST_END
275  TEST_BEGIN(test_stats_arenas_lextents) {
276  	void *p;
277  	uint64_t epoch, nmalloc, ndalloc;
278  	size_t curlextents, sz, hsize;
279  	int expected = config_stats ? 0 : ENOENT;
280  	sz = sizeof(size_t);
281  	assert_d_eq(mallctl("arenas.lextent.0.size", (void *)&hsize, &sz, NULL,
282  	    0), 0, "Unexpected mallctl() failure");
283  	p = mallocx(hsize, MALLOCX_ARENA(0));
284  	assert_ptr_not_null(p, "Unexpected mallocx() failure");
285  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
286  	    0, "Unexpected mallctl() failure");
287  	sz = sizeof(uint64_t);
288  	assert_d_eq(mallctl("stats.arenas.0.lextents.0.nmalloc",
289  	    (void *)&nmalloc, &sz, NULL, 0), expected,
290  	    "Unexpected mallctl() result");
291  	assert_d_eq(mallctl("stats.arenas.0.lextents.0.ndalloc",
292  	    (void *)&ndalloc, &sz, NULL, 0), expected,
293  	    "Unexpected mallctl() result");
294  	sz = sizeof(size_t);
295  	assert_d_eq(mallctl("stats.arenas.0.lextents.0.curlextents",
296  	    (void *)&curlextents, &sz, NULL, 0), expected,
297  	    "Unexpected mallctl() result");
298  	if (config_stats) {
299  		assert_u64_gt(nmalloc, 0,
300  		    "nmalloc should be greater than zero");
301  		assert_u64_ge(nmalloc, ndalloc,
302  		    "nmalloc should be at least as large as ndalloc");
303  		assert_u64_gt(curlextents, 0,
304  		    "At least one extent should be currently allocated");
305  	}
306  	dallocx(p, 0);
307  }
308  TEST_END
309  int
310  main(void) {
311  	return test_no_reentrancy(
312  	    test_stats_summary,
313  	    test_stats_large,
314  	    test_stats_arenas_summary,
315  	    test_stats_arenas_small,
316  	    test_stats_arenas_large,
317  	    test_stats_arenas_bins,
318  	    test_stats_arenas_lextents);
319  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-n.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats.c</div>
                </div>
                <div class="column column_space"><pre><code>3  static int okp(const kdft_desc *d,
4  	       const R *ri, const R *ii, 
5  	       const R *ro, const R *io,
6  	       INT is, INT os, INT vl, INT ivs, INT ovs,
</pre></code></div>
                <div class="column column_space"><pre><code>23  TEST_END
24  TEST_BEGIN(test_stats_large) {
25  	void *p;
26  	uint64_t epoch;
27  	size_t allocated;
28  	uint64_t nmalloc, ndalloc, nrequests;
29  	size_t sz;
30  	int expected = config_stats ? 0 : ENOENT;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    