
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.477611940298507%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-BLEClientIas.h</h3>
            <pre><code>1  #ifndef ADAFRUIT_NRF52_ARDUINO_BLECLIENTIAS_H
2  #define ADAFRUIT_NRF52_ARDUINO_BLECLIENTIAS_H
3  #include "bluefruit_common.h"
4  #include "BLEClientCharacteristic.h"
5  #include "BLEClientService.h"
6  class BLEClientIas : public BLEClientService {
7  public:
<span onclick='openModal()' class='match'>8      BLEClientIas(void);
9      virtual bool begin(void);
10      virtual bool discover(uint16_t conn_handle);
11      uint16_t getAlertLevel (void);
12  private:
13      BLEClientCharacteristic _alert;
</span>14  };
15  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-liolib.c</h3>
            <pre><code>1  #include <errno.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #define liolib_c
6  #define LUA_LIB
7  #include "lua.h"
8  #include "lauxlib.h"
9  #include "lualib.h"
10  #define IO_INPUT	1
11  #define IO_OUTPUT	2
12  static const char *const fnames[] = {"input", "output"};
13  static int pushresult (lua_State *L, int i, const char *filename) {
14    int en = errno;  &bsol;* calls to Lua API may change this value */
15    if (i) {
16      lua_pushboolean(L, 1);
17      return 1;
18    }
19    else {
20      lua_pushnil(L);
21      if (filename)
22        lua_pushfstring(L, "%s: %s", filename, strerror(en));
23      else
24        lua_pushfstring(L, "%s", strerror(en));
25      lua_pushinteger(L, en);
26      return 3;
27    }
28  }
29  static void fileerror (lua_State *L, int arg, const char *filename) {
30    lua_pushfstring(L, "%s: %s", filename, strerror(errno));
31    luaL_argerror(L, arg, lua_tostring(L, -1));
32  }
33  #define tofilep(L)	((FILE **)luaL_checkudata(L, 1, LUA_FILEHANDLE))
34  static int io_type (lua_State *L) {
35    void *ud;
36    luaL_checkany(L, 1);
37    ud = lua_touserdata(L, 1);
38    lua_getfield(L, LUA_REGISTRYINDEX, LUA_FILEHANDLE);
39    if (ud == NULL || !lua_getmetatable(L, 1) || !lua_rawequal(L, -2, -1))
40      lua_pushnil(L);  &bsol;* not a file */
41    else if (*((FILE **)ud) == NULL)
42      lua_pushliteral(L, "closed file");
43    else
44      lua_pushliteral(L, "file");
45    return 1;
46  }
47  static FILE *tofile (lua_State *L) {
48    FILE **f = tofilep(L);
49    if (*f == NULL)
50      luaL_error(L, "attempt to use a closed file");
51    return *f;
52  }
53  static FILE **newfile (lua_State *L) {
54    FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));
55    *pf = NULL;  &bsol;* file handle is currently `closed' */
56    luaL_getmetatable(L, LUA_FILEHANDLE);
57    lua_setmetatable(L, -2);
58    return pf;
59  }
60  static int io_noclose (lua_State *L) {
61    lua_pushnil(L);
62    lua_pushliteral(L, "cannot close standard file");
63    return 2;
64  }
65  static int io_pclose (lua_State *L) {
66    FILE **p = tofilep(L);
67    int ok = lua_pclose(L, *p);
68    *p = NULL;
69    return pushresult(L, ok, NULL);
70  }
71  static int io_fclose (lua_State *L) {
72    FILE **p = tofilep(L);
73    int ok = (fclose(*p) == 0);
74    *p = NULL;
75    return pushresult(L, ok, NULL);
76  }
77  static int aux_close (lua_State *L) {
78    lua_getfenv(L, 1);
79    lua_getfield(L, -1, "__close");
80    return (lua_tocfunction(L, -1))(L);
81  }
82  static int io_close (lua_State *L) {
83    if (lua_isnone(L, 1))
84      lua_rawgeti(L, LUA_ENVIRONINDEX, IO_OUTPUT);
85    tofile(L);  &bsol;* make sure argument is a file */
86    return aux_close(L);
87  }
88  static int io_gc (lua_State *L) {
89    FILE *f = *tofilep(L);
90    if (f != NULL)
91      aux_close(L);
92    return 0;
93  }
94  static int io_tostring (lua_State *L) {
95    FILE *f = *tofilep(L);
96    if (f == NULL)
97      lua_pushliteral(L, "file (closed)");
98    else
99      lua_pushfstring(L, "file (%p)", f);
100    return 1;
101  }
102  static int io_open (lua_State *L) {
103    const char *filename = luaL_checkstring(L, 1);
104    const char *mode = luaL_optstring(L, 2, "r");
105    FILE **pf = newfile(L);
106    *pf = fopen(filename, mode);
107    return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
108  }
109  static int io_popen (lua_State *L) {
110    const char *filename = luaL_checkstring(L, 1);
111    const char *mode = luaL_optstring(L, 2, "r");
112    FILE **pf = newfile(L);
113    *pf = lua_popen(L, filename, mode);
114    return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
115  }
116  static int io_tmpfile (lua_State *L) {
117    FILE **pf = newfile(L);
118    *pf = tmpfile();
119    return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
120  }
121  static FILE *getiofile (lua_State *L, int findex) {
122    FILE *f;
123    lua_rawgeti(L, LUA_ENVIRONINDEX, findex);
124    f = *(FILE **)lua_touserdata(L, -1);
125    if (f == NULL)
126      luaL_error(L, "standard %s file is closed", fnames[findex - 1]);
127    return f;
128  }
129  static int g_iofile (lua_State *L, int f, const char *mode) {
130    if (!lua_isnoneornil(L, 1)) {
131      const char *filename = lua_tostring(L, 1);
132      if (filename) {
133        FILE **pf = newfile(L);
134        *pf = fopen(filename, mode);
135        if (*pf == NULL)
136          fileerror(L, 1, filename);
137      }
138      else {
139        tofile(L);  &bsol;* check that it's a valid file handle */
140        lua_pushvalue(L, 1);
141      }
142      lua_rawseti(L, LUA_ENVIRONINDEX, f);
143    }
144    lua_rawgeti(L, LUA_ENVIRONINDEX, f);
145    return 1;
146  }
147  static int io_input (lua_State *L) {
148    return g_iofile(L, IO_INPUT, "r");
149  }
150  static int io_output (lua_State *L) {
151    return g_iofile(L, IO_OUTPUT, "w");
152  }
153  static int io_readline (lua_State *L);
154  static void aux_lines (lua_State *L, int idx, int toclose) {
155    lua_pushvalue(L, idx);
156    lua_pushboolean(L, toclose);  &bsol;* close/not close file when finished */
157    lua_pushcclosure(L, io_readline, 2);
158  }
159  static int f_lines (lua_State *L) {
160    tofile(L);  &bsol;* check that it's a valid file handle */
161    aux_lines(L, 1, 0);
162    return 1;
163  }
164  static int io_lines (lua_State *L) {
165    if (lua_isnoneornil(L, 1)) {  &bsol;* no arguments? */
166      lua_rawgeti(L, LUA_ENVIRONINDEX, IO_INPUT);
167      return f_lines(L);
168    }
169    else {
170      const char *filename = luaL_checkstring(L, 1);
171      FILE **pf = newfile(L);
172      *pf = fopen(filename, "r");
173      if (*pf == NULL)
174        fileerror(L, 1, filename);
175      aux_lines(L, lua_gettop(L), 1);
176      return 1;
177    }
178  }
179  static int read_number (lua_State *L, FILE *f) {
180    lua_Number d;
181    if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
182      lua_pushnumber(L, d);
183      return 1;
184    }
185    else {
186      lua_pushnil(L);  &bsol;* "result" to be removed */
187      return 0;  &bsol;* read fails */
188    }
189  }
190  static int test_eof (lua_State *L, FILE *f) {
191    int c = getc(f);
192    ungetc(c, f);
193    lua_pushlstring(L, NULL, 0);
194    return (c != EOF);
195  }
196  static int read_line (lua_State *L, FILE *f) {
197    luaL_Buffer b;
198    luaL_buffinit(L, &b);
199    for (;;) {
200      size_t l;
201      char *p = luaL_prepbuffer(&b);
202      if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  &bsol;* eof? */
203        luaL_pushresult(&b);  &bsol;* close buffer */
204        return (lua_objlen(L, -1) > 0);  &bsol;* check whether read something */
205      }
206      l = strlen(p);
207      if (l == 0 || p[l-1] != '\n')
208        luaL_addsize(&b, l);
209      else {
210        luaL_addsize(&b, l - 1);  &bsol;* do not include `eol' */
211        luaL_pushresult(&b);  &bsol;* close buffer */
212        return 1;  &bsol;* read at least an `eol' */
213      }
214    }
215  }
<span onclick='openModal()' class='match'>216  static int read_chars (lua_State *L, FILE *f, size_t n) {
217    size_t rlen;  &bsol;* how much to read */
218    size_t nr;  &bsol;* number of chars actually read */
</span>219    luaL_Buffer b;
220    luaL_buffinit(L, &b);
221    rlen = LUAL_BUFFERSIZE;  &bsol;* try to read that much each time */
222    do {
223      char *p = luaL_prepbuffer(&b);
224      if (rlen > n) rlen = n;  &bsol;* cannot read more than asked */
225      nr = fread(p, sizeof(char), rlen, f);
226      luaL_addsize(&b, nr);
227      n -= nr;  &bsol;* still have to read `n' chars */
228    } while (n > 0 && nr == rlen);  &bsol;* until end of count or eof */
229    luaL_pushresult(&b);  &bsol;* close buffer */
230    return (n == 0 || lua_objlen(L, -1) > 0);
231  }
232  static int g_read (lua_State *L, FILE *f, int first) {
233    int nargs = lua_gettop(L) - 1;
234    int success;
235    int n;
236    clearerr(f);
237    if (nargs == 0) {  &bsol;* no arguments? */
238      success = read_line(L, f);
239      n = first+1;  &bsol;* to return 1 result */
240    }
241    else {  &bsol;* ensure stack space for all results and for auxlib's buffer */
242      luaL_checkstack(L, nargs+LUA_MINSTACK, "too many arguments");
243      success = 1;
244      for (n = first; nargs-- && success; n++) {
245        if (lua_type(L, n) == LUA_TNUMBER) {
246          size_t l = (size_t)lua_tointeger(L, n);
247          success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
248        }
249        else {
250          const char *p = lua_tostring(L, n);
251          luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
252          switch (p[1]) {
253            case 'n':  &bsol;* number */
254              success = read_number(L, f);
255              break;
256            case 'l':  &bsol;* line */
257              success = read_line(L, f);
258              break;
259            case 'a':  &bsol;* file */
260              read_chars(L, f, ~((size_t)0));  &bsol;* read MAX_SIZE_T chars */
261              success = 1; &bsol;* always success */
262              break;
263            default:
264              return luaL_argerror(L, n, "invalid format");
265          }
266        }
267      }
268    }
269    if (ferror(f))
270      return pushresult(L, 0, NULL);
271    if (!success) {
272      lua_pop(L, 1);  &bsol;* remove last result */
273      lua_pushnil(L);  &bsol;* push nil instead */
274    }
275    return n - first;
276  }
277  static int io_read (lua_State *L) {
278    return g_read(L, getiofile(L, IO_INPUT), 1);
279  }
280  static int f_read (lua_State *L) {
281    return g_read(L, tofile(L), 2);
282  }
283  static int io_readline (lua_State *L) {
284    FILE *f = *(FILE **)lua_touserdata(L, lua_upvalueindex(1));
285    int sucess;
286    if (f == NULL)  &bsol;* file is already closed? */
287      luaL_error(L, "file is already closed");
288    sucess = read_line(L, f);
289    if (ferror(f))
290      return luaL_error(L, "%s", strerror(errno));
291    if (sucess) return 1;
292    else {  &bsol;* EOF */
293      if (lua_toboolean(L, lua_upvalueindex(2))) {  &bsol;* generator created file? */
294        lua_settop(L, 0);
295        lua_pushvalue(L, lua_upvalueindex(1));
296        aux_close(L);  &bsol;* close it */
297      }
298      return 0;
299    }
300  }
301  static int g_write (lua_State *L, FILE *f, int arg) {
302    int nargs = lua_gettop(L) - 1;
303    int status = 1;
304    for (; nargs--; arg++) {
305      if (lua_type(L, arg) == LUA_TNUMBER) {
306        status = status &&
307            fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
308      }
309      else {
310        size_t l;
311        const char *s = luaL_checklstring(L, arg, &l);
312        status = status && (fwrite(s, sizeof(char), l, f) == l);
313      }
314    }
315    return pushresult(L, status, NULL);
316  }
317  static int io_write (lua_State *L) {
318    return g_write(L, getiofile(L, IO_OUTPUT), 1);
319  }
320  static int f_write (lua_State *L) {
321    return g_write(L, tofile(L), 2);
322  }
323  static int f_seek (lua_State *L) {
324    static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
325    static const char *const modenames[] = {"set", "cur", "end", NULL};
326    FILE *f = tofile(L);
327    int op = luaL_checkoption(L, 2, "cur", modenames);
328    long offset = luaL_optlong(L, 3, 0);
329    op = fseek(f, offset, mode[op]);
330    if (op)
331      return pushresult(L, 0, NULL);  &bsol;* error */
332    else {
333      lua_pushinteger(L, ftell(f));
334      return 1;
335    }
336  }
337  static int f_setvbuf (lua_State *L) {
338    static const int mode[] = {_IONBF, _IOFBF, _IOLBF};
339    static const char *const modenames[] = {"no", "full", "line", NULL};
340    FILE *f = tofile(L);
341    int op = luaL_checkoption(L, 2, NULL, modenames);
342    lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
343    int res = setvbuf(f, NULL, mode[op], sz);
344    return pushresult(L, res == 0, NULL);
345  }
346  static int io_flush (lua_State *L) {
347    return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
348  }
349  static int f_flush (lua_State *L) {
350    return pushresult(L, fflush(tofile(L)) == 0, NULL);
351  }
352  static const luaL_Reg iolib[] = {
353    {"close", io_close},
354    {"flush", io_flush},
355    {"input", io_input},
356    {"lines", io_lines},
357    {"open", io_open},
358    {"output", io_output},
359    {"popen", io_popen},
360    {"read", io_read},
361    {"tmpfile", io_tmpfile},
362    {"type", io_type},
363    {"write", io_write},
364    {NULL, NULL}
365  };
366  static const luaL_Reg flib[] = {
367    {"close", io_close},
368    {"flush", f_flush},
369    {"lines", f_lines},
370    {"read", f_read},
371    {"seek", f_seek},
372    {"setvbuf", f_setvbuf},
373    {"write", f_write},
374    {"__gc", io_gc},
375    {"__tostring", io_tostring},
376    {NULL, NULL}
377  };
378  static void createmeta (lua_State *L) {
379    luaL_newmetatable(L, LUA_FILEHANDLE);  &bsol;* create metatable for file handles */
380    lua_pushvalue(L, -1);  &bsol;* push metatable */
381    lua_setfield(L, -2, "__index");  &bsol;* metatable.__index = metatable */
382    luaL_register(L, NULL, flib);  &bsol;* file methods */
383  }
384  static void createstdfile (lua_State *L, FILE *f, int k, const char *fname) {
385    *newfile(L) = f;
386    if (k > 0) {
387      lua_pushvalue(L, -1);
388      lua_rawseti(L, LUA_ENVIRONINDEX, k);
389    }
390    lua_pushvalue(L, -2);  &bsol;* copy environment */
391    lua_setfenv(L, -2);  &bsol;* set it */
392    lua_setfield(L, -3, fname);
393  }
394  static void newfenv (lua_State *L, lua_CFunction cls) {
395    lua_createtable(L, 0, 1);
396    lua_pushcfunction(L, cls);
397    lua_setfield(L, -2, "__close");
398  }
399  LUALIB_API int luaopen_io (lua_State *L) {
400    createmeta(L);
401    newfenv(L, io_fclose);
402    lua_replace(L, LUA_ENVIRONINDEX);
403    luaL_register(L, LUA_IOLIBNAME, iolib);
404    newfenv(L, io_noclose);  &bsol;* close function for default files */
405    createstdfile(L, stdin, IO_INPUT, "stdin");
406    createstdfile(L, stdout, IO_OUTPUT, "stdout");
407    createstdfile(L, stderr, 0, "stderr");
408    lua_pop(L, 1);  &bsol;* pop environment for default files */
409    lua_getfield(L, -1, "popen");
410    newfenv(L, io_pclose);  &bsol;* create environment for 'popen' */
411    lua_setfenv(L, -2);  &bsol;* set fenv for 'popen' */
412    lua_pop(L, 1);  &bsol;* pop 'popen' */
413    return 1;
414  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-BLEClientIas.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-liolib.c</div>
                </div>
                <div class="column column_space"><pre><code>8      BLEClientIas(void);
9      virtual bool begin(void);
10      virtual bool discover(uint16_t conn_handle);
11      uint16_t getAlertLevel (void);
12  private:
13      BLEClientCharacteristic _alert;
</pre></code></div>
                <div class="column column_space"><pre><code>216  static int read_chars (lua_State *L, FILE *f, size_t n) {
217    size_t rlen;  &bsol;* how much to read */
218    size_t nr;  &bsol;* number of chars actually read */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    