
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.78318931657502%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-diff.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "private/private.h"
3  #include "private/misc.h"
4  int hwloc_topology_diff_destroy(hwloc_topology_diff_t diff)
5  {
6  	hwloc_topology_diff_t next;
7  	while (diff) {
8  		next = diff->generic.next;
9  		switch (diff->generic.type) {
10  		default:
11  			break;
12  		case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR:
13  			switch (diff->obj_attr.diff.generic.type) {
14  			default:
15  				break;
16  			case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
17  			case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
18  				free(diff->obj_attr.diff.string.name);
19  				free(diff->obj_attr.diff.string.oldvalue);
20  				free(diff->obj_attr.diff.string.newvalue);
21  				break;
22  			}
23  			break;
24  		}
25  		free(diff);
26  		diff = next;
27  	}
28  	return 0;
29  }
30  static void hwloc_append_diff(hwloc_topology_diff_t newdiff,
31  			      hwloc_topology_diff_t *firstdiffp,
32  			      hwloc_topology_diff_t *lastdiffp)
33  {
34  	if (*firstdiffp)
35  		(*lastdiffp)->generic.next = newdiff;
36  	else
37  		*firstdiffp = newdiff;
38  	*lastdiffp = newdiff;
39  	newdiff->generic.next = NULL;
40  }
41  static int hwloc_append_diff_too_complex(hwloc_obj_t obj1,
42  					 hwloc_topology_diff_t *firstdiffp,
43  					 hwloc_topology_diff_t *lastdiffp)
44  {
45  	hwloc_topology_diff_t newdiff;
46  	newdiff = malloc(sizeof(*newdiff));
47  	if (!newdiff)
48  		return -1;
49  	newdiff->too_complex.type = HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX;
50  	newdiff->too_complex.obj_depth = obj1->depth;
51  	newdiff->too_complex.obj_index = obj1->logical_index;
52  	hwloc_append_diff(newdiff, firstdiffp, lastdiffp);
53  	return 0;
54  }
55  static int hwloc_append_diff_obj_attr_string(hwloc_obj_t obj,
56  					     hwloc_topology_diff_obj_attr_type_t type,
57  					     const char *name,
58  					     const char *oldvalue,
59  					     const char *newvalue,
60  					     hwloc_topology_diff_t *firstdiffp,
61  					     hwloc_topology_diff_t *lastdiffp)
62  {
63  	hwloc_topology_diff_t newdiff;
64  	newdiff = malloc(sizeof(*newdiff));
65  	if (!newdiff)
66  		return -1;
67  	newdiff->obj_attr.type = HWLOC_TOPOLOGY_DIFF_OBJ_ATTR;
68  	newdiff->obj_attr.obj_depth = obj->depth;
69  	newdiff->obj_attr.obj_index = obj->logical_index;
70  	newdiff->obj_attr.diff.string.type = type;
71  	newdiff->obj_attr.diff.string.name = name ? strdup(name) : NULL;
72  	newdiff->obj_attr.diff.string.oldvalue = oldvalue ? strdup(oldvalue) : NULL;
73  	newdiff->obj_attr.diff.string.newvalue = newvalue ? strdup(newvalue) : NULL;
74  	hwloc_append_diff(newdiff, firstdiffp, lastdiffp);
75  	return 0;
76  }
77  static int hwloc_append_diff_obj_attr_uint64(hwloc_obj_t obj,
78  					     hwloc_topology_diff_obj_attr_type_t type,
79  					     hwloc_uint64_t idx,
80  					     hwloc_uint64_t oldvalue,
81  					     hwloc_uint64_t newvalue,
82  					     hwloc_topology_diff_t *firstdiffp,
83  					     hwloc_topology_diff_t *lastdiffp)
84  {
85  	hwloc_topology_diff_t newdiff;
86  	newdiff = malloc(sizeof(*newdiff));
87  	if (!newdiff)
88  		return -1;
89  	newdiff->obj_attr.type = HWLOC_TOPOLOGY_DIFF_OBJ_ATTR;
90  	newdiff->obj_attr.obj_depth = obj->depth;
91  	newdiff->obj_attr.obj_index = obj->logical_index;
92  	newdiff->obj_attr.diff.uint64.type = type;
93  	newdiff->obj_attr.diff.uint64.index = idx;
94  	newdiff->obj_attr.diff.uint64.oldvalue = oldvalue;
95  	newdiff->obj_attr.diff.uint64.newvalue = newvalue;
96  	hwloc_append_diff(newdiff, firstdiffp, lastdiffp);
97  	return 0;
98  }
99  static int
100  hwloc_diff_trees(hwloc_topology_t topo1, hwloc_obj_t obj1,
101  		 hwloc_topology_t topo2, hwloc_obj_t obj2,
102  		 unsigned flags,
103  		 hwloc_topology_diff_t *firstdiffp, hwloc_topology_diff_t *lastdiffp)
104  {
105  	unsigned i;
106  	int err;
107  	hwloc_obj_t child1, child2;
108  	if (obj1->depth != obj2->depth)
109  		goto out_too_complex;
110  	if (obj1->type != obj2->type)
111  		goto out_too_complex;
112  	if ((!obj1->subtype) != (!obj2->subtype)
113  	    || (obj1->subtype && strcmp(obj1->subtype, obj2->subtype)))
114  		goto out_too_complex;
115  	if (obj1->os_index != obj2->os_index)
116  		goto out_too_complex;
117  #define _SETS_DIFFERENT(_set1, _set2) \
118   (   ( !(_set1) != !(_set2) ) \
119    || ( (_set1) && !hwloc_bitmap_isequal(_set1, _set2) ) )
120  #define SETS_DIFFERENT(_set, _obj1, _obj2) _SETS_DIFFERENT((_obj1)->_set, (_obj2)->_set)
121  	if (SETS_DIFFERENT(cpuset, obj1, obj2)
122  	    || SETS_DIFFERENT(complete_cpuset, obj1, obj2)
123  	    || SETS_DIFFERENT(nodeset, obj1, obj2)
124  	    || SETS_DIFFERENT(complete_nodeset, obj1, obj2))
125  		goto out_too_complex;
126  	if ((!obj1->name) != (!obj2->name)
127  	    || (obj1->name && strcmp(obj1->name, obj2->name))) {
128  		err = hwloc_append_diff_obj_attr_string(obj1,
129  						       HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME,
130  						       NULL,
131  						       obj1->name,
132  						       obj2->name,
133  						       firstdiffp, lastdiffp);
134  		if (err < 0)
135  			return err;
136  	}
137  	switch (obj1->type) {
138  	default:
139  		break;
140  	case HWLOC_OBJ_NUMANODE:
141  		if (obj1->attr->numanode.local_memory != obj2->attr->numanode.local_memory) {
142  			err = hwloc_append_diff_obj_attr_uint64(obj1,
143  								HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE,
144  								0,
145  								obj1->attr->numanode.local_memory,
146  								obj2->attr->numanode.local_memory,
147  								firstdiffp, lastdiffp);
148  			if (err < 0)
149  				return err;
150  		}
151  		break;
152  	case HWLOC_OBJ_L1CACHE:
153  	case HWLOC_OBJ_L2CACHE:
154  	case HWLOC_OBJ_L3CACHE:
155  	case HWLOC_OBJ_L4CACHE:
156  	case HWLOC_OBJ_L5CACHE:
157  	case HWLOC_OBJ_L1ICACHE:
158  	case HWLOC_OBJ_L2ICACHE:
159  	case HWLOC_OBJ_L3ICACHE:
160  		if (memcmp(obj1->attr, obj2->attr, sizeof(obj1->attr->cache)))
161  			goto out_too_complex;
162  		break;
163  	case HWLOC_OBJ_GROUP:
164  		if (memcmp(obj1->attr, obj2->attr, sizeof(obj1->attr->group)))
165  			goto out_too_complex;
166  		break;
167  	case HWLOC_OBJ_PCI_DEVICE:
168  		if (memcmp(obj1->attr, obj2->attr, sizeof(obj1->attr->pcidev)))
169  			goto out_too_complex;
170  		break;
171  	case HWLOC_OBJ_BRIDGE:
172  		if (memcmp(obj1->attr, obj2->attr, sizeof(obj1->attr->bridge)))
173  			goto out_too_complex;
174  		break;
175  	case HWLOC_OBJ_OS_DEVICE:
176  		if (memcmp(obj1->attr, obj2->attr, sizeof(obj1->attr->osdev)))
177  			goto out_too_complex;
178  		break;
179  	}
180  	if (obj1->infos_count != obj2->infos_count)
181  		goto out_too_complex;
182  	for(i=0; i<obj1->infos_count; i++) {
183  		struct hwloc_info_s *info1 = &obj1->infos[i], *info2 = &obj2->infos[i];
184  		if (strcmp(info1->name, info2->name))
185  			goto out_too_complex;
186  		if (strcmp(info1->value, info2->value)) {
187  			err = hwloc_append_diff_obj_attr_string(obj1,
188  								HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO,
189  								info1->name,
190  								info1->value,
191  								info2->value,
192  								firstdiffp, lastdiffp);
193  			if (err < 0)
194  				return err;
195  		}
196  	}
197  	for(child1 = obj1->first_child, child2 = obj2->first_child;
198  	    child1 != NULL && child2 != NULL;
199  	    child1 = child1->next_sibling, child2 = child2->next_sibling) {
200  		err = hwloc_diff_trees(topo1, child1,
201  				       topo2, child2,
202  				       flags,
203  				       firstdiffp, lastdiffp);
204  		if (err < 0)
205  			return err;
206  	}
207  	if (child1 || child2)
208  		goto out_too_complex;
209  	for(child1 = obj1->memory_first_child, child2 = obj2->memory_first_child;
210  	    child1 != NULL && child2 != NULL;
211  	    child1 = child1->next_sibling, child2 = child2->next_sibling) {
212  		err = hwloc_diff_trees(topo1, child1,
213  				       topo2, child2,
214  				       flags,
215  				       firstdiffp, lastdiffp);
216  		if (err < 0)
217  			return err;
218  	}
219  	if (child1 || child2)
220  		goto out_too_complex;
221  	for(child1 = obj1->io_first_child, child2 = obj2->io_first_child;
222  	    child1 != NULL && child2 != NULL;
223  	    child1 = child1->next_sibling, child2 = child2->next_sibling) {
224  		err = hwloc_diff_trees(topo1, child1,
225  				       topo2, child2,
226  				       flags,
227  				       firstdiffp, lastdiffp);
228  		if (err < 0)
229  			return err;
230  	}
231  	if (child1 || child2)
232  		goto out_too_complex;
233  	for(child1 = obj1->misc_first_child, child2 = obj2->misc_first_child;
234  	    child1 != NULL && child2 != NULL;
235  	    child1 = child1->next_sibling, child2 = child2->next_sibling) {
236  		err = hwloc_diff_trees(topo1, child1,
237  				       topo2, child2,
238  				       flags,
239  				       firstdiffp, lastdiffp);
240  		if (err < 0)
241  			return err;
242  	}
243  	if (child1 || child2)
244  		goto out_too_complex;
245  	return 0;
246  out_too_complex:
247  	hwloc_append_diff_too_complex(obj1, firstdiffp, lastdiffp);
<span onclick='openModal()' class='match'>248  	return 0;
249  }
250  int hwloc_topology_diff_build(hwloc_topology_t topo1,
251  			      hwloc_topology_t topo2,
252  			      unsigned long flags,
253  			      hwloc_topology_diff_t *diffp)
254  {
255  	hwloc_topology_diff_t lastdiff, tmpdiff;
</span>256  	struct hwloc_internal_distances_s *dist1, *dist2;
257  	unsigned i;
258  	int err;
259  	if (!topo1->is_loaded || !topo2->is_loaded) {
260  	  errno = EINVAL;
261  	  return -1;
262  	}
263  	if (flags != 0) {
264  		errno = EINVAL;
265  		return -1;
266  	}
267  	*diffp = NULL;
268  	err = hwloc_diff_trees(topo1, hwloc_get_root_obj(topo1),
269  			       topo2, hwloc_get_root_obj(topo2),
270  			       flags,
271  			       diffp, &lastdiff);
272  	if (!err) {
273  		tmpdiff = *diffp;
274  		while (tmpdiff) {
275  			if (tmpdiff->generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
276  				err = 1;
277  				break;
278  			}
279  			tmpdiff = tmpdiff->generic.next;
280  		}
281  	}
282  	if (!err) {
283  		if (SETS_DIFFERENT(allowed_cpuset, topo1, topo2)
284  		    || SETS_DIFFERENT(allowed_nodeset, topo1, topo2))
285                    goto roottoocomplex;
286  	}
287  	if (!err) {
288  		hwloc_internal_distances_refresh(topo1);
289  		hwloc_internal_distances_refresh(topo2);
290  		dist1 = topo1->first_dist;
291  		dist2 = topo2->first_dist;
292  		while (dist1 || dist2) {
293  			if (!!dist1 != !!dist2)
294                            goto roottoocomplex;
295  			if (dist1->unique_type != dist2->unique_type
296  			    || dist1->different_types || dist2->different_types &bsol;* too lazy to support this case */
297  			    || dist1->nbobjs != dist2->nbobjs
298  			    || dist1->kind != dist2->kind
299  			    || memcmp(dist1->values, dist2->values, dist1->nbobjs * dist1->nbobjs * sizeof(*dist1->values)))
300                            goto roottoocomplex;
301  			for(i=0; i<dist1->nbobjs; i++)
302  				if (dist1->objs[i]->logical_index != dist2->objs[i]->logical_index)
303                                    goto roottoocomplex;
304  			dist1 = dist1->next;
305  			dist2 = dist2->next;
306  		}
307  	}
308          if (!err) {
309            hwloc_internal_memattrs_refresh(topo1);
310            hwloc_internal_memattrs_refresh(topo2);
311            if (topo1->nr_memattrs != topo2->nr_memattrs)
312              goto roottoocomplex;
313            for(i=0; i<topo1->nr_memattrs; i++) {
314              struct hwloc_internal_memattr_s *imattr1 = &topo1->memattrs[i], *imattr2 = &topo2->memattrs[i];
315              unsigned j;
316             if (strcmp(imattr1->name, imattr2->name)
317                  || imattr1->flags != imattr2->flags
318                  || imattr1->nr_targets != imattr2->nr_targets)
319                goto roottoocomplex;
320              if (i == HWLOC_MEMATTR_ID_CAPACITY
321                  || i == HWLOC_MEMATTR_ID_LOCALITY)
322                continue;
323              for(j=0; j<imattr1->nr_targets; j++) {
324                struct hwloc_internal_memattr_target_s *imtg1 = &imattr1->targets[j], *imtg2 = &imattr2->targets[j];
325                if (imtg1->type != imtg2->type)
326                  goto roottoocomplex;
327                if (imtg1->obj->logical_index != imtg2->obj->logical_index)
328                  goto roottoocomplex;
329                if (imattr1->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
330                  unsigned k;
331                  for(k=0; k<imtg1->nr_initiators; k++) {
332                    struct hwloc_internal_memattr_initiator_s *imi1 = &imtg1->initiators[k], *imi2 = &imtg2->initiators[k];
333                    if (imi1->value != imi2->value
334                        || imi1->initiator.type != imi2->initiator.type)
335                      goto roottoocomplex;
336                    if (imi1->initiator.type == HWLOC_LOCATION_TYPE_CPUSET) {
337                      if (!hwloc_bitmap_isequal(imi1->initiator.location.cpuset, imi2->initiator.location.cpuset))
338                        goto roottoocomplex;
339                    } else if (imi1->initiator.type == HWLOC_LOCATION_TYPE_OBJECT) {
340                      if (imi1->initiator.location.object.type != imi2->initiator.location.object.type)
341                        goto roottoocomplex;
342                      if (imi1->initiator.location.object.obj->logical_index != imi2->initiator.location.object.obj->logical_index)
343                        goto roottoocomplex;
344                    } else {
345                      assert(0);
346                    }
347                  }
348                } else {
349                  if (imtg1->noinitiator_value != imtg2->noinitiator_value)
350                    goto roottoocomplex;
351                }
352              }
353            }
354          }
355  	return err;
356   roottoocomplex:
357    hwloc_append_diff_too_complex(hwloc_get_root_obj(topo1), diffp, &lastdiff);
358    return 1;
359  }
360  static int
361  hwloc_apply_diff_one(hwloc_topology_t topology,
362  		     hwloc_topology_diff_t diff,
363  		     unsigned long flags)
364  {
365  	int reverse = !!(flags & HWLOC_TOPOLOGY_DIFF_APPLY_REVERSE);
366  	switch (diff->generic.type) {
367  	case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR: {
368  		struct hwloc_topology_diff_obj_attr_s *obj_attr = &diff->obj_attr;
369  		hwloc_obj_t obj = hwloc_get_obj_by_depth(topology, obj_attr->obj_depth, obj_attr->obj_index);
370  		if (!obj)
371  			return -1;
372  		switch (obj_attr->diff.generic.type) {
373  		case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE: {
374  			hwloc_obj_t tmpobj;
375  			hwloc_uint64_t oldvalue = reverse ? obj_attr->diff.uint64.newvalue : obj_attr->diff.uint64.oldvalue;
376  			hwloc_uint64_t newvalue = reverse ? obj_attr->diff.uint64.oldvalue : obj_attr->diff.uint64.newvalue;
377  			hwloc_uint64_t valuediff = newvalue - oldvalue;
378  			if (obj->type != HWLOC_OBJ_NUMANODE)
379  				return -1;
380  			if (obj->attr->numanode.local_memory != oldvalue)
381  				return -1;
382  			obj->attr->numanode.local_memory = newvalue;
383  			tmpobj = obj;
384  			while (tmpobj) {
385  				tmpobj->total_memory += valuediff;
386  				tmpobj = tmpobj->parent;
387  			}
388  			break;
389  		}
390  		case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME: {
391  			const char *oldvalue = reverse ? obj_attr->diff.string.newvalue : obj_attr->diff.string.oldvalue;
392  			const char *newvalue = reverse ? obj_attr->diff.string.oldvalue : obj_attr->diff.string.newvalue;
393  			if (!obj->name || strcmp(obj->name, oldvalue))
394  				return -1;
395  			free(obj->name);
396  			obj->name = strdup(newvalue);
397  			break;
398  		}
399  		case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO: {
400  			const char *name = obj_attr->diff.string.name;
401  			const char *oldvalue = reverse ? obj_attr->diff.string.newvalue : obj_attr->diff.string.oldvalue;
402  			const char *newvalue = reverse ? obj_attr->diff.string.oldvalue : obj_attr->diff.string.newvalue;
403  			unsigned i;
404  			int found = 0;
405  			for(i=0; i<obj->infos_count; i++) {
406  				struct hwloc_info_s *info = &obj->infos[i];
407  				if (!strcmp(info->name, name)
408  				    && !strcmp(info->value, oldvalue)) {
409  					free(info->value);
410  					info->value = strdup(newvalue);
411  					found = 1;
412  					break;
413  				}
414  			}
415  			if (!found)
416  				return -1;
417  			break;
418  		}
419  		default:
420  			return -1;
421  		}
422  		break;
423  	}
424  	default:
425  		return -1;
426  	}
427  	return 0;
428  }
429  int hwloc_topology_diff_apply(hwloc_topology_t topology,
430  			      hwloc_topology_diff_t diff,
431  			      unsigned long flags)
432  {
433  	hwloc_topology_diff_t tmpdiff, tmpdiff2;
434  	int err, nr;
435  	if (!topology->is_loaded) {
436  	  errno = EINVAL;
437  	  return -1;
438  	}
439  	if (topology->adopted_shmem_addr) {
440  	  errno = EPERM;
441  	  return -1;
442  	}
443  	if (flags & ~HWLOC_TOPOLOGY_DIFF_APPLY_REVERSE) {
444  		errno = EINVAL;
445  		return -1;
446  	}
447  	tmpdiff = diff;
448  	nr = 0;
449  	while (tmpdiff) {
450  		nr++;
451  		err = hwloc_apply_diff_one(topology, tmpdiff, flags);
452  		if (err < 0)
453  			goto cancel;
454  		tmpdiff = tmpdiff->generic.next;
455  	}
456  	return 0;
457  cancel:
458  	tmpdiff2 = tmpdiff;
459  	tmpdiff = diff;
460  	while (tmpdiff != tmpdiff2) {
461  		hwloc_apply_diff_one(topology, tmpdiff, flags ^ HWLOC_TOPOLOGY_DIFF_APPLY_REVERSE);
462  		tmpdiff = tmpdiff->generic.next;
463  	}
464  	errno = EINVAL;
465  	return -nr; &bsol;* return the index (starting at 1) of the first element that couldn't be applied */
466  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-twofish.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_TWOFISH
3  #ifdef LTC_TWOFISH_ALL_TABLES
4  #ifndef LTC_TWOFISH_TABLES
5  #define LTC_TWOFISH_TABLES
6  #endif
7  #endif
8  const struct ltc_cipher_descriptor twofish_desc =
9  {
10      "twofish",
11      7,
12      16, 32, 16, 16,
13      &twofish_setup,
14      &twofish_ecb_encrypt,
15      &twofish_ecb_decrypt,
16      &twofish_test,
17      &twofish_done,
18      &twofish_keysize,
19      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
20  };
21  #ifndef LTC_TWOFISH_TABLES
22  #define MDS_POLY          0x169
23  #endif
24  #ifndef LTC_TWOFISH_ALL_TABLES
25  #define RS_POLY           0x14D
26  #endif
27  static const unsigned char RS[4][8] = {
28      { 0x01, 0xA4, 0x55, 0x87, 0x5A, 0x58, 0xDB, 0x9E },
29      { 0xA4, 0x56, 0x82, 0xF3, 0X1E, 0XC6, 0X68, 0XE5 },
30      { 0X02, 0XA1, 0XFC, 0XC1, 0X47, 0XAE, 0X3D, 0X19 },
31      { 0XA4, 0X55, 0X87, 0X5A, 0X58, 0XDB, 0X9E, 0X03 }
32  };
33  #ifdef LTC_TWOFISH_SMALL
34  static const unsigned char qord[4][5] = {
35     { 1, 1, 0, 0, 1 },
36     { 0, 1, 1, 0, 0 },
37     { 0, 0, 0, 1, 1 },
38     { 1, 0, 1, 1, 0 }
39  };
40  #endif &bsol;* LTC_TWOFISH_SMALL */
41  #ifdef LTC_TWOFISH_TABLES
42  #define LTC_TWOFISH_TAB_C
43  #include "twofish_tab.c"
44  #define sbox(i, x) ((ulong32)SBOX[i][(x)&255])
45  #else
46  static const unsigned char qbox[2][4][16] = {
47  {
48     { 0x8, 0x1, 0x7, 0xD, 0x6, 0xF, 0x3, 0x2, 0x0, 0xB, 0x5, 0x9, 0xE, 0xC, 0xA, 0x4 },
49     { 0xE, 0XC, 0XB, 0X8, 0X1, 0X2, 0X3, 0X5, 0XF, 0X4, 0XA, 0X6, 0X7, 0X0, 0X9, 0XD },
50     { 0XB, 0XA, 0X5, 0XE, 0X6, 0XD, 0X9, 0X0, 0XC, 0X8, 0XF, 0X3, 0X2, 0X4, 0X7, 0X1 },
51     { 0XD, 0X7, 0XF, 0X4, 0X1, 0X2, 0X6, 0XE, 0X9, 0XB, 0X3, 0X0, 0X8, 0X5, 0XC, 0XA }
52  },
53  {
54     { 0X2, 0X8, 0XB, 0XD, 0XF, 0X7, 0X6, 0XE, 0X3, 0X1, 0X9, 0X4, 0X0, 0XA, 0XC, 0X5 },
55     { 0X1, 0XE, 0X2, 0XB, 0X4, 0XC, 0X3, 0X7, 0X6, 0XD, 0XA, 0X5, 0XF, 0X9, 0X0, 0X8 },
56     { 0X4, 0XC, 0X7, 0X5, 0X1, 0X6, 0X9, 0XA, 0X0, 0XE, 0XD, 0X8, 0X2, 0XB, 0X3, 0XF },
57     { 0xB, 0X9, 0X5, 0X1, 0XC, 0X3, 0XD, 0XE, 0X6, 0X4, 0X7, 0XF, 0X2, 0X0, 0X8, 0XA }
58  }
59  };
60  #ifdef LTC_CLEAN_STACK
61  static ulong32 s_sbox(int i, ulong32 x)
62  #else
63  static ulong32 sbox(int i, ulong32 x)
64  #endif
65  {
66     unsigned char a0,b0,a1,b1,a2,b2,a3,b3,a4,b4,y;
67     a0 = (unsigned char)((x>>4)&15);
68     b0 = (unsigned char)((x)&15);
69     a1 = a0 ^ b0;
70     b1 = (a0 ^ ((b0<<3)|(b0>>1)) ^ (a0<<3)) & 15;
71     a2 = qbox[i][0][(int)a1];
72     b2 = qbox[i][1][(int)b1];
73     a3 = a2 ^ b2;
74     b3 = (a2 ^ ((b2<<3)|(b2>>1)) ^ (a2<<3)) & 15;
75     a4 = qbox[i][2][(int)a3];
76     b4 = qbox[i][3][(int)b3];
77     y = (b4 << 4) + a4;
78     return (ulong32)y;
79  }
80  #ifdef LTC_CLEAN_STACK
81  static ulong32 sbox(int i, ulong32 x)
82  {
83     ulong32 y;
84     y = s_sbox(i, x);
85     burn_stack(sizeof(unsigned char) * 11);
86     return y;
87  }
88  #endif &bsol;* LTC_CLEAN_STACK */
89  #endif &bsol;* LTC_TWOFISH_TABLES */
90  static ulong32 gf_mult(ulong32 a, ulong32 b, ulong32 p)
91  {
92     ulong32 result, B[2], P[2];
93     P[1] = p;
94     B[1] = b;
95     result = P[0] = B[0] = 0;
96     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
97     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
98     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
99     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
100     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
101     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
102     result ^= B[a&1]; a >>= 1;  B[1] = P[B[1]>>7] ^ (B[1] << 1);
103     result ^= B[a&1];
104     return result;
105  }
106  #ifndef LTC_TWOFISH_TABLES
107  static ulong32 mds_column_mult(unsigned char in, int col)
108  {
109     ulong32 x01, x5B, xEF;
110     x01 = in;
111     x5B = gf_mult(in, 0x5B, MDS_POLY);
112     xEF = gf_mult(in, 0xEF, MDS_POLY);
113     switch (col) {
114         case 0:
115            return (x01 << 0 ) |
116                   (x5B << 8 ) |
117                   (xEF << 16) |
118                   (xEF << 24);
119         case 1:
120            return (xEF << 0 ) |
121                   (xEF << 8 ) |
122                   (x5B << 16) |
123                   (x01 << 24);
124         case 2:
125            return (x5B << 0 ) |
126                   (xEF << 8 ) |
127                   (x01 << 16) |
128                   (xEF << 24);
129         case 3:
130            return (x5B << 0 ) |
131                   (x01 << 8 ) |
132                   (xEF << 16) |
133                   (x5B << 24);
134     }
135     return 0;
136  }
137  #else &bsol;* !LTC_TWOFISH_TABLES */
138  #define mds_column_mult(x, i) mds_tab[i][x]
139  #endif &bsol;* LTC_TWOFISH_TABLES */
140  static void mds_mult(const unsigned char *in, unsigned char *out)
141  {
142    int x;
143    ulong32 tmp;
144    for (tmp = x = 0; x < 4; x++) {
145        tmp ^= mds_column_mult(in[x], x);
146    }
147    STORE32L(tmp, out);
148  }
149  #ifdef LTC_TWOFISH_ALL_TABLES
150  static void rs_mult(const unsigned char *in, unsigned char *out)
151  {
152     ulong32 tmp;
153     tmp = rs_tab0[in[0]] ^ rs_tab1[in[1]] ^ rs_tab2[in[2]] ^ rs_tab3[in[3]] ^
154           rs_tab4[in[4]] ^ rs_tab5[in[5]] ^ rs_tab6[in[6]] ^ rs_tab7[in[7]];
155     STORE32L(tmp, out);
156  }
157  #else &bsol;* !LTC_TWOFISH_ALL_TABLES */
158  static void rs_mult(const unsigned char *in, unsigned char *out)
159  {
160    int x, y;
161    for (x = 0; x < 4; x++) {
162        out[x] = 0;
163        for (y = 0; y < 8; y++) {
164            out[x] ^= gf_mult(in[y], RS[x][y], RS_POLY);
165        }
166    }
167  }
168  #endif
169  static void h_func(const unsigned char *in, unsigned char *out, const unsigned char *M, int k, int offset)
170  {
171    int x;
172    unsigned char y[4];
173    for (x = 0; x < 4; x++) {
174        y[x] = in[x];
175    }
176    switch (k) {
177       case 4:
178              y[0] = (unsigned char)(sbox(1, (ulong32)y[0]) ^ M[4 * (6 + offset) + 0]);
179              y[1] = (unsigned char)(sbox(0, (ulong32)y[1]) ^ M[4 * (6 + offset) + 1]);
180              y[2] = (unsigned char)(sbox(0, (ulong32)y[2]) ^ M[4 * (6 + offset) + 2]);
181              y[3] = (unsigned char)(sbox(1, (ulong32)y[3]) ^ M[4 * (6 + offset) + 3]);
182       case 3:
183              y[0] = (unsigned char)(sbox(1, (ulong32)y[0]) ^ M[4 * (4 + offset) + 0]);
184              y[1] = (unsigned char)(sbox(1, (ulong32)y[1]) ^ M[4 * (4 + offset) + 1]);
185              y[2] = (unsigned char)(sbox(0, (ulong32)y[2]) ^ M[4 * (4 + offset) + 2]);
186              y[3] = (unsigned char)(sbox(0, (ulong32)y[3]) ^ M[4 * (4 + offset) + 3]);
187       case 2:
188              y[0] = (unsigned char)(sbox(1, sbox(0, sbox(0, (ulong32)y[0]) ^ M[4 * (2 + offset) + 0]) ^ M[4 * (0 + offset) + 0]));
189              y[1] = (unsigned char)(sbox(0, sbox(0, sbox(1, (ulong32)y[1]) ^ M[4 * (2 + offset) + 1]) ^ M[4 * (0 + offset) + 1]));
190              y[2] = (unsigned char)(sbox(1, sbox(1, sbox(0, (ulong32)y[2]) ^ M[4 * (2 + offset) + 2]) ^ M[4 * (0 + offset) + 2]));
191              y[3] = (unsigned char)(sbox(0, sbox(1, sbox(1, (ulong32)y[3]) ^ M[4 * (2 + offset) + 3]) ^ M[4 * (0 + offset) + 3]));
192    }
193    mds_mult(y, out);
194  }
195  #ifndef LTC_TWOFISH_SMALL
196  #if defined(__GNUC__)
197      #define S1 skey->twofish.S[0]
198      #define S2 skey->twofish.S[1]
199      #define S3 skey->twofish.S[2]
200      #define S4 skey->twofish.S[3]
201  #endif
202  #define g_func(x, dum)  (S1[LTC_BYTE(x,0)] ^ S2[LTC_BYTE(x,1)] ^ S3[LTC_BYTE(x,2)] ^ S4[LTC_BYTE(x,3)])
203  #define g1_func(x, dum) (S2[LTC_BYTE(x,0)] ^ S3[LTC_BYTE(x,1)] ^ S4[LTC_BYTE(x,2)] ^ S1[LTC_BYTE(x,3)])
204  #else
205  #ifdef LTC_CLEAN_STACK
206  static ulong32 s_g_func(ulong32 x, const symmetric_key *key)
207  #else
208  static ulong32 g_func(ulong32 x, const symmetric_key *key)
209  #endif
210  {
211     unsigned char g, i, y, z;
212     ulong32 res;
213     res = 0;
214     for (y = 0; y < 4; y++) {
215         z = key->twofish.start;
216         g = sbox(qord[y][z++], (x >> (8*y)) & 255);
217         i = 0;
218         while (z != 5) {
219            g = g ^ key->twofish.S[4*i++ + y];
220            g = sbox(qord[y][z++], g);
221         }
222         res ^= mds_column_mult(g, y);
223     }
224     return res;
225  }
226  #define g1_func(x, key) g_func(ROLc(x, 8), key)
227  #ifdef LTC_CLEAN_STACK
228  static ulong32 g_func(ulong32 x, const symmetric_key *key)
229  {
230      ulong32 y;
231      y = s_g_func(x, key);
232      burn_stack(sizeof(unsigned char) * 4 + sizeof(ulong32));
233      return y;
234  }
235  #endif &bsol;* LTC_CLEAN_STACK */
236  #endif &bsol;* LTC_TWOFISH_SMALL */
237  #ifdef LTC_CLEAN_STACK
238  static int s_twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
239  #else
240  int twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
241  #endif
242  {
243  #ifndef LTC_TWOFISH_SMALL
244     unsigned char S[4*4], tmpx0, tmpx1;
245  #endif
246     int k, x, y;
247     unsigned char tmp[4], tmp2[4], M[8*4];
248     ulong32 A, B;
249     LTC_ARGCHK(key  != NULL);
250     LTC_ARGCHK(skey != NULL);
251     if (num_rounds != 16 && num_rounds != 0) {
252        return CRYPT_INVALID_ROUNDS;
253     }
254     if (keylen != 16 && keylen != 24 && keylen != 32) {
255        return CRYPT_INVALID_KEYSIZE;
256     }
257     k = keylen / 8;
258     for (x = 0; x < keylen; x++) {
259         M[x] = key[x] & 255;
260     }
261  #ifndef LTC_TWOFISH_SMALL
262     for (x = 0; x < k; x++) {
263         rs_mult(M+(x*8), S+(x*4));
264     }
265  #else
266     for (x = 0; x < k; x++) {
267         rs_mult(M+(x*8), skey->twofish.S+(x*4));
268     }
269  #endif
270     for (x = 0; x < 20; x++) {
271         for (y = 0; y < 4; y++) {
272             tmp[y] = x+x;
273         }
274         h_func(tmp, tmp2, M, k, 0);
275         LOAD32L(A, tmp2);
276         for (y = 0; y < 4; y++) {
277             tmp[y] = (unsigned char)(x+x+1);
278         }
279         h_func(tmp, tmp2, M, k, 1);
280         LOAD32L(B, tmp2);
281         B = ROLc(B, 8);
282         skey->twofish.K[x+x] = (A + B) & 0xFFFFFFFFUL;
283         skey->twofish.K[x+x+1] = ROLc(B + B + A, 9);
284     }
285  #ifndef LTC_TWOFISH_SMALL
286     if (k == 2) {
287          for (x = 0; x < 256; x++) {
288             tmpx0 = (unsigned char)sbox(0, x);
289             tmpx1 = (unsigned char)sbox(1, x);
290             skey->twofish.S[0][x] = mds_column_mult(sbox(1, (sbox(0, tmpx0 ^ S[0]) ^ S[4])),0);
291             skey->twofish.S[1][x] = mds_column_mult(sbox(0, (sbox(0, tmpx1 ^ S[1]) ^ S[5])),1);
292             skey->twofish.S[2][x] = mds_column_mult(sbox(1, (sbox(1, tmpx0 ^ S[2]) ^ S[6])),2);
293             skey->twofish.S[3][x] = mds_column_mult(sbox(0, (sbox(1, tmpx1 ^ S[3]) ^ S[7])),3);
294          }
295     } else if (k == 3) {
296          for (x = 0; x < 256; x++) {
297             tmpx0 = (unsigned char)sbox(0, x);
298             tmpx1 = (unsigned char)sbox(1, x);
299             skey->twofish.S[0][x] = mds_column_mult(sbox(1, (sbox(0, sbox(0, tmpx1 ^ S[0]) ^ S[4]) ^ S[8])),0);
300             skey->twofish.S[1][x] = mds_column_mult(sbox(0, (sbox(0, sbox(1, tmpx1 ^ S[1]) ^ S[5]) ^ S[9])),1);
301             skey->twofish.S[2][x] = mds_column_mult(sbox(1, (sbox(1, sbox(0, tmpx0 ^ S[2]) ^ S[6]) ^ S[10])),2);
302             skey->twofish.S[3][x] = mds_column_mult(sbox(0, (sbox(1, sbox(1, tmpx0 ^ S[3]) ^ S[7]) ^ S[11])),3);
303          }
304     } else {
305          for (x = 0; x < 256; x++) {
306             tmpx0 = (unsigned char)sbox(0, x);
307             tmpx1 = (unsigned char)sbox(1, x);
308             skey->twofish.S[0][x] = mds_column_mult(sbox(1, (sbox(0, sbox(0, sbox(1, tmpx1 ^ S[0]) ^ S[4]) ^ S[8]) ^ S[12])),0);
309             skey->twofish.S[1][x] = mds_column_mult(sbox(0, (sbox(0, sbox(1, sbox(1, tmpx0 ^ S[1]) ^ S[5]) ^ S[9]) ^ S[13])),1);
310             skey->twofish.S[2][x] = mds_column_mult(sbox(1, (sbox(1, sbox(0, sbox(0, tmpx0 ^ S[2]) ^ S[6]) ^ S[10]) ^ S[14])),2);
311             skey->twofish.S[3][x] = mds_column_mult(sbox(0, (sbox(1, sbox(1, sbox(0, tmpx1 ^ S[3]) ^ S[7]) ^ S[11]) ^ S[15])),3);
312          }
313     }
314  #else
315     switch (k) {
316           case 4 : skey->twofish.start = 0; break;
317           case 3 : skey->twofish.start = 1; break;
318           default: skey->twofish.start = 2; break;
319     }
320  #endif
<span onclick='openModal()' class='match'>321     return CRYPT_OK;
322  }
323  #ifdef LTC_CLEAN_STACK
324  int twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
325  {
326     int x;
</span>327     x = s_twofish_setup(key, keylen, num_rounds, skey);
328     burn_stack(sizeof(int) * 7 + sizeof(unsigned char) * 56 + sizeof(ulong32) * 2);
329     return x;
330  }
331  #endif
332  #ifdef LTC_CLEAN_STACK
333  static int s_twofish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
334  #else
335  int twofish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
336  #endif
337  {
338      ulong32 a,b,c,d,ta,tb,tc,td,t1,t2;
339      const ulong32 *k;
340      int r;
341  #if !defined(LTC_TWOFISH_SMALL) && !defined(__GNUC__)
342      const ulong32 *S1, *S2, *S3, *S4;
343  #endif
344      LTC_ARGCHK(pt   != NULL);
345      LTC_ARGCHK(ct   != NULL);
346      LTC_ARGCHK(skey != NULL);
347  #if !defined(LTC_TWOFISH_SMALL) && !defined(__GNUC__)
348      S1 = skey->twofish.S[0];
349      S2 = skey->twofish.S[1];
350      S3 = skey->twofish.S[2];
351      S4 = skey->twofish.S[3];
352  #endif
353      LOAD32L(a,&pt[0]); LOAD32L(b,&pt[4]);
354      LOAD32L(c,&pt[8]); LOAD32L(d,&pt[12]);
355      a ^= skey->twofish.K[0];
356      b ^= skey->twofish.K[1];
357      c ^= skey->twofish.K[2];
358      d ^= skey->twofish.K[3];
359      k  = skey->twofish.K + 8;
360      for (r = 8; r != 0; --r) {
361          t2 = g1_func(b, skey);
362          t1 = g_func(a, skey) + t2;
363          c  = RORc(c ^ (t1 + k[0]), 1);
364          d  = ROLc(d, 1) ^ (t2 + t1 + k[1]);
365          t2 = g1_func(d, skey);
366          t1 = g_func(c, skey) + t2;
367          a  = RORc(a ^ (t1 + k[2]), 1);
368          b  = ROLc(b, 1) ^ (t2 + t1 + k[3]);
369          k += 4;
370      }
371      ta = c ^ skey->twofish.K[4];
372      tb = d ^ skey->twofish.K[5];
373      tc = a ^ skey->twofish.K[6];
374      td = b ^ skey->twofish.K[7];
375      STORE32L(ta,&ct[0]); STORE32L(tb,&ct[4]);
376      STORE32L(tc,&ct[8]); STORE32L(td,&ct[12]);
377      return CRYPT_OK;
378  }
379  #ifdef LTC_CLEAN_STACK
380  int twofish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
381  {
382     int err = s_twofish_ecb_encrypt(pt, ct, skey);
383     burn_stack(sizeof(ulong32) * 10 + sizeof(int));
384     return err;
385  }
386  #endif
387  #ifdef LTC_CLEAN_STACK
388  static int s_twofish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
389  #else
390  int twofish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
391  #endif
392  {
393      ulong32 a,b,c,d,ta,tb,tc,td,t1,t2;
394      const ulong32 *k;
395      int r;
396  #if !defined(LTC_TWOFISH_SMALL) && !defined(__GNUC__)
397      const ulong32 *S1, *S2, *S3, *S4;
398  #endif
399      LTC_ARGCHK(pt   != NULL);
400      LTC_ARGCHK(ct   != NULL);
401      LTC_ARGCHK(skey != NULL);
402  #if !defined(LTC_TWOFISH_SMALL) && !defined(__GNUC__)
403      S1 = skey->twofish.S[0];
404      S2 = skey->twofish.S[1];
405      S3 = skey->twofish.S[2];
406      S4 = skey->twofish.S[3];
407  #endif
408      LOAD32L(ta,&ct[0]); LOAD32L(tb,&ct[4]);
409      LOAD32L(tc,&ct[8]); LOAD32L(td,&ct[12]);
410      a = tc ^ skey->twofish.K[6];
411      b = td ^ skey->twofish.K[7];
412      c = ta ^ skey->twofish.K[4];
413      d = tb ^ skey->twofish.K[5];
414      k = skey->twofish.K + 36;
415      for (r = 8; r != 0; --r) {
416          t2 = g1_func(d, skey);
417          t1 = g_func(c, skey) + t2;
418          a = ROLc(a, 1) ^ (t1 + k[2]);
419          b = RORc(b ^ (t2 + t1 + k[3]), 1);
420          t2 = g1_func(b, skey);
421          t1 = g_func(a, skey) + t2;
422          c = ROLc(c, 1) ^ (t1 + k[0]);
423          d = RORc(d ^ (t2 +  t1 + k[1]), 1);
424          k -= 4;
425      }
426      a ^= skey->twofish.K[0];
427      b ^= skey->twofish.K[1];
428      c ^= skey->twofish.K[2];
429      d ^= skey->twofish.K[3];
430      STORE32L(a, &pt[0]); STORE32L(b, &pt[4]);
431      STORE32L(c, &pt[8]); STORE32L(d, &pt[12]);
432      return CRYPT_OK;
433  }
434  #ifdef LTC_CLEAN_STACK
435  int twofish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
436  {
437     int err = s_twofish_ecb_decrypt(ct, pt, skey);
438     burn_stack(sizeof(ulong32) * 10 + sizeof(int));
439     return err;
440  }
441  #endif
442  int twofish_test(void)
443  {
444   #ifndef LTC_TEST
445      return CRYPT_NOP;
446   #else
447   static const struct {
448       int keylen;
449       unsigned char key[32], pt[16], ct[16];
450   } tests[] = {
451     { 16,
452       { 0x9F, 0x58, 0x9F, 0x5C, 0xF6, 0x12, 0x2C, 0x32,
453         0xB6, 0xBF, 0xEC, 0x2F, 0x2A, 0xE8, 0xC3, 0x5A },
454       { 0xD4, 0x91, 0xDB, 0x16, 0xE7, 0xB1, 0xC3, 0x9E,
455         0x86, 0xCB, 0x08, 0x6B, 0x78, 0x9F, 0x54, 0x19 },
456       { 0x01, 0x9F, 0x98, 0x09, 0xDE, 0x17, 0x11, 0x85,
457         0x8F, 0xAA, 0xC3, 0xA3, 0xBA, 0x20, 0xFB, 0xC3 }
458     }, {
459       24,
460       { 0x88, 0xB2, 0xB2, 0x70, 0x6B, 0x10, 0x5E, 0x36,
461         0xB4, 0x46, 0xBB, 0x6D, 0x73, 0x1A, 0x1E, 0x88,
462         0xEF, 0xA7, 0x1F, 0x78, 0x89, 0x65, 0xBD, 0x44 },
463       { 0x39, 0xDA, 0x69, 0xD6, 0xBA, 0x49, 0x97, 0xD5,
464         0x85, 0xB6, 0xDC, 0x07, 0x3C, 0xA3, 0x41, 0xB2 },
465       { 0x18, 0x2B, 0x02, 0xD8, 0x14, 0x97, 0xEA, 0x45,
466         0xF9, 0xDA, 0xAC, 0xDC, 0x29, 0x19, 0x3A, 0x65 }
467     }, {
468       32,
469       { 0xD4, 0x3B, 0xB7, 0x55, 0x6E, 0xA3, 0x2E, 0x46,
470         0xF2, 0xA2, 0x82, 0xB7, 0xD4, 0x5B, 0x4E, 0x0D,
471         0x57, 0xFF, 0x73, 0x9D, 0x4D, 0xC9, 0x2C, 0x1B,
472         0xD7, 0xFC, 0x01, 0x70, 0x0C, 0xC8, 0x21, 0x6F },
473       { 0x90, 0xAF, 0xE9, 0x1B, 0xB2, 0x88, 0x54, 0x4F,
474         0x2C, 0x32, 0xDC, 0x23, 0x9B, 0x26, 0x35, 0xE6 },
475       { 0x6C, 0xB4, 0x56, 0x1C, 0x40, 0xBF, 0x0A, 0x97,
476         0x05, 0x93, 0x1C, 0xB6, 0xD4, 0x08, 0xE7, 0xFA }
477     }
478  };
479    symmetric_key key;
480    unsigned char tmp[2][16];
481    int err, i, y;
482    for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
483      if ((err = twofish_setup(tests[i].key, tests[i].keylen, 0, &key)) != CRYPT_OK) {
484         return err;
485      }
486      twofish_ecb_encrypt(tests[i].pt, tmp[0], &key);
487      twofish_ecb_decrypt(tmp[0], tmp[1], &key);
488      if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "Twofish Encrypt", i) != 0 ||
489            compare_testvector(tmp[1], 16, tests[i].pt, 16, "Twofish Decrypt", i) != 0) {
490         return CRYPT_FAIL_TESTVECTOR;
491      }
492      for (y = 0; y < 16; y++) tmp[0][y] = 0;
493      for (y = 0; y < 1000; y++) twofish_ecb_encrypt(tmp[0], tmp[0], &key);
494      for (y = 0; y < 1000; y++) twofish_ecb_decrypt(tmp[0], tmp[0], &key);
495      for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
496    }
497    return CRYPT_OK;
498  #endif
499  }
500  void twofish_done(symmetric_key *skey)
501  {
502    LTC_UNUSED_PARAM(skey);
503  }
504  int twofish_keysize(int *keysize)
505  {
506     LTC_ARGCHK(keysize);
507     if (*keysize < 16) {
508        return CRYPT_INVALID_KEYSIZE;
509     }
510     if (*keysize < 24) {
511        *keysize = 16;
512        return CRYPT_OK;
513     }
514     if (*keysize < 32) {
515        *keysize = 24;
516        return CRYPT_OK;
517     }
518     *keysize = 32;
519     return CRYPT_OK;
520  }
521  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-diff.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-twofish.c</div>
                </div>
                <div class="column column_space"><pre><code>248  	return 0;
249  }
250  int hwloc_topology_diff_build(hwloc_topology_t topo1,
251  			      hwloc_topology_t topo2,
252  			      unsigned long flags,
253  			      hwloc_topology_diff_t *diffp)
254  {
255  	hwloc_topology_diff_t lastdiff, tmpdiff;
</pre></code></div>
                <div class="column column_space"><pre><code>321     return CRYPT_OK;
322  }
323  #ifdef LTC_CLEAN_STACK
324  int twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
325  {
326     int x;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    