
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.857142857142858%, Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-event_groups.h</h3>
            <pre><code>1  #ifndef EVENT_GROUPS_H
2  #define EVENT_GROUPS_H
3  #ifndef INC_FREERTOS_H
4  	#error "include FreeRTOS.h" must appear in source files before "include event_groups.h"
5  #endif
6  #include "timers.h"
7  #ifdef __cplusplus
8  extern "C" {
9  #endif
<span onclick='openModal()' class='match'>10  typedef void * EventGroupHandle_t;
11  typedef TickType_t EventBits_t;
12  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
13  	EventGroupHandle_t xEventGroupCreate( void ) PRIVILEGED_FUNCTION;
14  #endif
15  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
16  	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) PRIVILEGED_FUNCTION;
17  #endif
18  EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
19  EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) PRIVILEGED_FUNCTION;
20  #if( configUSE_TRACE_FACILITY == 1 )
21  	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
22  #else
23  	#define xEventGroupClearBitsFromISR( xEventGroup, uxBitsToClear ) xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL )
24  #endif
25  EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
26  #if( configUSE_TRACE_FACILITY == 1 )
27  	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
28  #else
29  	#define xEventGroupSetBitsFromISR( xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken ) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken )
30  #endif
31  EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
32  #define xEventGroupGetBits( xEventGroup ) xEventGroupClearBits( xEventGroup, 0 )
33  EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
34  void vEventGroupDelete( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
35  void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet ) PRIVILEGED_FUNCTION;
36  void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;
37  #if (configUSE_TRACE_FACILITY == 1)
38  	UBaseType_t uxEventGroupGetNumber( void* xEventGroup ) PRIVILEGED_FUNCTION;
39  	void vEventGroupSetNumber( void* xEventGroup, UBaseType_t uxEventGroupNumber ) PRIVILEGED_FUNCTION;
</span>40  #endif
41  #ifdef __cplusplus
42  }
43  #endif
44  #endif &bsol;* EVENT_GROUPS_H */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_pdm.h</h3>
            <pre><code>1  #ifndef NRF_PDM_H_
2  #define NRF_PDM_H_
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #ifndef NRF_PDM0
8  #define NRF_PDM0 NRF_PDM
9  #endif
10  #if defined(PDM_MCLKCONFIG_SRC_Msk) || defined(__NRFX_DOXYGEN__)
11  #define NRF_PDM_HAS_MCLKCONFIG 1
12  #else
13  #define NRF_PDM_HAS_MCLKCONFIG 0
14  #endif
15  #if defined(PDM_RATIO_RATIO_Msk) || defined(__NRFX_DOXYGEN__)
16  #define NRF_PDM_HAS_RATIO_CONFIG 1
17  #else
18  #define NRF_PDM_HAS_RATIO_CONFIG 0
19  #endif
20  #define NRF_PDM_GAIN_MINIMUM  0x00
21  #define NRF_PDM_GAIN_DEFAULT  0x28
22  #define NRF_PDM_GAIN_MAXIMUM  0x50
23  typedef uint8_t nrf_pdm_gain_t;
24  typedef enum
25  {
26      NRF_PDM_TASK_START = offsetof(NRF_PDM_Type, TASKS_START), 
27      NRF_PDM_TASK_STOP  = offsetof(NRF_PDM_Type, TASKS_STOP)   
28  } nrf_pdm_task_t;
29  typedef enum
30  {
31      NRF_PDM_EVENT_STARTED = offsetof(NRF_PDM_Type, EVENTS_STARTED), 
32      NRF_PDM_EVENT_STOPPED = offsetof(NRF_PDM_Type, EVENTS_STOPPED), 
33      NRF_PDM_EVENT_END     = offsetof(NRF_PDM_Type, EVENTS_END)      
34  } nrf_pdm_event_t;
35  typedef enum
36  {
37      NRF_PDM_INT_STARTED = PDM_INTENSET_STARTED_Msk, 
38      NRF_PDM_INT_STOPPED = PDM_INTENSET_STOPPED_Msk, 
39      NRF_PDM_INT_END     = PDM_INTENSET_END_Msk      
40  } nrf_pdm_int_mask_t;
41  typedef enum
42  {
43      NRF_PDM_FREQ_1000K = PDM_PDMCLKCTRL_FREQ_1000K,   
44      NRF_PDM_FREQ_1032K = PDM_PDMCLKCTRL_FREQ_Default, 
45      NRF_PDM_FREQ_1067K = PDM_PDMCLKCTRL_FREQ_1067K,   
46  #if defined(PDM_PDMCLKCTRL_FREQ_1231K) || defined(__NRFX_DOXYGEN__)
47      NRF_PDM_FREQ_1231K = PDM_PDMCLKCTRL_FREQ_1231K,   
48  #endif
49  #if defined(PDM_PDMCLKCTRL_FREQ_1280K) || defined(__NRFX_DOXYGEN__)
50      NRF_PDM_FREQ_1280K = PDM_PDMCLKCTRL_FREQ_1280K,   
51  #endif
52  #if defined(PDM_PDMCLKCTRL_FREQ_1333K) || defined(__NRFX_DOXYGEN__)
53      NRF_PDM_FREQ_1333K = PDM_PDMCLKCTRL_FREQ_1333K    
54  #endif
55  } nrf_pdm_freq_t;
56  #if NRF_PDM_HAS_RATIO_CONFIG
57  typedef enum
58  {
59      NRF_PDM_RATIO_64X = PDM_RATIO_RATIO_Ratio64, 
60      NRF_PDM_RATIO_80X = PDM_RATIO_RATIO_Ratio80  
61  } nrf_pdm_ratio_t;
62  #endif
63  typedef enum
64  {
65      NRF_PDM_MODE_STEREO = PDM_MODE_OPERATION_Stereo,  
66      NRF_PDM_MODE_MONO   = PDM_MODE_OPERATION_Mono     
67  } nrf_pdm_mode_t;
68  typedef enum
69  {
70      NRF_PDM_EDGE_LEFTFALLING = PDM_MODE_EDGE_LeftFalling,  
71      NRF_PDM_EDGE_LEFTRISING  = PDM_MODE_EDGE_LeftRising    
72  } nrf_pdm_edge_t;
73  #if NRF_PDM_HAS_MCLKCONFIG
74  typedef enum
75  {
76      NRF_PDM_MCLKSRC_PCLK32M = PDM_MCLKCONFIG_SRC_PCLK32M, 
77      NRF_PDM_MCLKSRC_ACLK    = PDM_MCLKCONFIG_SRC_ACLK     
78  } nrf_pdm_mclksrc_t;
79  #endif
<span onclick='openModal()' class='match'>80  NRF_STATIC_INLINE void nrf_pdm_task_trigger(NRF_PDM_Type * p_reg, nrf_pdm_task_t task);
81  NRF_STATIC_INLINE uint32_t nrf_pdm_task_address_get(NRF_PDM_Type const * p_reg,
82                                                      nrf_pdm_task_t       task);
83  NRF_STATIC_INLINE bool nrf_pdm_event_check(NRF_PDM_Type const * p_reg, nrf_pdm_event_t event);
84  NRF_STATIC_INLINE void nrf_pdm_event_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event);
85  NRF_STATIC_INLINE uint32_t nrf_pdm_event_address_get(NRF_PDM_Type const * p_reg,
86                                                       nrf_pdm_event_t      event);
87  NRF_STATIC_INLINE void nrf_pdm_int_enable(NRF_PDM_Type * p_reg, uint32_t mask);
88  NRF_STATIC_INLINE uint32_t nrf_pdm_int_enable_check(NRF_PDM_Type const * p_reg, uint32_t mask);
89  NRF_STATIC_INLINE void nrf_pdm_int_disable(NRF_PDM_Type * p_reg, uint32_t mask);
90  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
91  NRF_STATIC_INLINE void nrf_pdm_subscribe_set(NRF_PDM_Type * p_reg,
92                                               nrf_pdm_task_t task,
93                                               uint8_t        channel);
94  NRF_STATIC_INLINE void nrf_pdm_subscribe_clear(NRF_PDM_Type * p_reg, nrf_pdm_task_t task);
95  NRF_STATIC_INLINE void nrf_pdm_publish_set(NRF_PDM_Type *  p_reg,
96                                             nrf_pdm_event_t event,
97                                             uint8_t         channel);
98  NRF_STATIC_INLINE void nrf_pdm_publish_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event);
</span>99  #endif 
100  NRF_STATIC_INLINE void nrf_pdm_enable(NRF_PDM_Type * p_reg);
101  NRF_STATIC_INLINE void nrf_pdm_disable(NRF_PDM_Type * p_reg);
102  NRF_STATIC_INLINE bool nrf_pdm_enable_check(NRF_PDM_Type const * p_reg);
103  NRF_STATIC_INLINE void nrf_pdm_mode_set(NRF_PDM_Type * p_reg,
104                                          nrf_pdm_mode_t pdm_mode,
105                                          nrf_pdm_edge_t pdm_edge);
106  NRF_STATIC_INLINE void nrf_pdm_mode_get(NRF_PDM_Type const * p_reg,
107                                          nrf_pdm_mode_t *     p_pdm_mode,
108                                          nrf_pdm_edge_t *     p_pdm_edge);
109  NRF_STATIC_INLINE void nrf_pdm_clock_set(NRF_PDM_Type * p_reg, nrf_pdm_freq_t pdm_freq);
110  NRF_STATIC_INLINE nrf_pdm_freq_t nrf_pdm_clock_get(NRF_PDM_Type const * p_reg);
111  NRF_STATIC_INLINE void nrf_pdm_psel_connect(NRF_PDM_Type * p_reg,
112                                              uint32_t       psel_clk,
113                                              uint32_t       psel_din);
114  NRF_STATIC_INLINE void nrf_pdm_psel_disconnect(NRF_PDM_Type * p_reg);
115  NRF_STATIC_INLINE void nrf_pdm_gain_set(NRF_PDM_Type * p_reg,
116                                          nrf_pdm_gain_t gain_l,
117                                          nrf_pdm_gain_t gain_r);
118  NRF_STATIC_INLINE void nrf_pdm_gain_get(NRF_PDM_Type const * p_reg,
119                                          nrf_pdm_gain_t *     p_gain_l,
120                                          nrf_pdm_gain_t *     p_gain_r);
121  NRF_STATIC_INLINE void nrf_pdm_buffer_set(NRF_PDM_Type * p_reg, uint32_t * p_buffer, uint32_t num);
122  NRF_STATIC_INLINE uint32_t * nrf_pdm_buffer_get(NRF_PDM_Type const * p_reg);
123  #if NRF_PDM_HAS_RATIO_CONFIG
124  NRF_STATIC_INLINE void nrf_pdm_ratio_set(NRF_PDM_Type * p_reg, nrf_pdm_ratio_t ratio);
125  #endif
126  #if NRF_PDM_HAS_MCLKCONFIG
127  NRF_STATIC_INLINE void nrf_pdm_mclksrc_configure(NRF_PDM_Type * p_reg, nrf_pdm_mclksrc_t mclksrc);
128  #endif
129  #ifndef NRF_DECLARE_ONLY
130  NRF_STATIC_INLINE void nrf_pdm_task_trigger(NRF_PDM_Type * p_reg, nrf_pdm_task_t task)
131  {
132      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
133  }
134  NRF_STATIC_INLINE uint32_t nrf_pdm_task_address_get(NRF_PDM_Type const * p_reg, nrf_pdm_task_t task)
135  {
136      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
137  }
138  NRF_STATIC_INLINE bool nrf_pdm_event_check(NRF_PDM_Type const * p_reg, nrf_pdm_event_t event)
139  {
140      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
141  }
142  NRF_STATIC_INLINE void nrf_pdm_event_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event)
143  {
144      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
145  #if __CORTEX_M == 0x04
146      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
147      (void)dummy;
148  #endif
149  }
150  NRF_STATIC_INLINE uint32_t nrf_pdm_event_address_get(NRF_PDM_Type const * p_reg,
151                                                       nrf_pdm_event_t      event)
152  {
153      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
154  }
155  NRF_STATIC_INLINE void nrf_pdm_int_enable(NRF_PDM_Type * p_reg, uint32_t mask)
156  {
157      p_reg->INTENSET = mask;
158  }
159  NRF_STATIC_INLINE uint32_t nrf_pdm_int_enable_check(NRF_PDM_Type const * p_reg, uint32_t mask)
160  {
161      return p_reg->INTENSET & mask;
162  }
163  NRF_STATIC_INLINE void nrf_pdm_int_disable(NRF_PDM_Type * p_reg, uint32_t mask)
164  {
165      p_reg->INTENCLR = mask;
166  }
167  #if defined(DPPI_PRESENT)
168  NRF_STATIC_INLINE void nrf_pdm_subscribe_set(NRF_PDM_Type * p_reg,
169                                               nrf_pdm_task_t task,
170                                               uint8_t        channel)
171  {
172      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
173              ((uint32_t)channel | PDM_SUBSCRIBE_START_EN_Msk);
174  }
175  NRF_STATIC_INLINE void nrf_pdm_subscribe_clear(NRF_PDM_Type * p_reg, nrf_pdm_task_t task)
176  {
177      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
178  }
179  NRF_STATIC_INLINE void nrf_pdm_publish_set(NRF_PDM_Type *  p_reg,
180                                             nrf_pdm_event_t event,
181                                             uint8_t         channel)
182  {
183      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
184              ((uint32_t)channel | PDM_PUBLISH_STARTED_EN_Msk);
185  }
186  NRF_STATIC_INLINE void nrf_pdm_publish_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event)
187  {
188      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
189  }
190  #endif 
191  NRF_STATIC_INLINE void nrf_pdm_enable(NRF_PDM_Type * p_reg)
192  {
193      p_reg->ENABLE = (PDM_ENABLE_ENABLE_Enabled << PDM_ENABLE_ENABLE_Pos);
194  }
195  NRF_STATIC_INLINE void nrf_pdm_disable(NRF_PDM_Type * p_reg)
196  {
197      p_reg->ENABLE = (PDM_ENABLE_ENABLE_Disabled << PDM_ENABLE_ENABLE_Pos);
198  }
199  NRF_STATIC_INLINE bool nrf_pdm_enable_check(NRF_PDM_Type const * p_reg)
200  {
201      return (p_reg->ENABLE == (PDM_ENABLE_ENABLE_Enabled << PDM_ENABLE_ENABLE_Pos));
202  }
203  NRF_STATIC_INLINE void nrf_pdm_mode_set(NRF_PDM_Type * p_reg,
204                                          nrf_pdm_mode_t pdm_mode,
205                                          nrf_pdm_edge_t pdm_edge)
206  {
207      p_reg->MODE = ((pdm_mode << PDM_MODE_OPERATION_Pos) & PDM_MODE_OPERATION_Msk)
208                      | ((pdm_edge << PDM_MODE_EDGE_Pos) & PDM_MODE_EDGE_Msk);
209  }
210  NRF_STATIC_INLINE void nrf_pdm_mode_get(NRF_PDM_Type const * p_reg,
211                                          nrf_pdm_mode_t * p_pdm_mode,
212                                          nrf_pdm_edge_t * p_pdm_edge)
213  {
214      uint32_t mode = p_reg->MODE;
215      *p_pdm_mode = (nrf_pdm_mode_t)((mode & PDM_MODE_OPERATION_Msk ) >> PDM_MODE_OPERATION_Pos);
216      *p_pdm_edge = (nrf_pdm_edge_t)((mode & PDM_MODE_EDGE_Msk ) >> PDM_MODE_EDGE_Pos);
217  }
218  NRF_STATIC_INLINE void nrf_pdm_clock_set(NRF_PDM_Type * p_reg, nrf_pdm_freq_t pdm_freq)
219  {
220      p_reg->PDMCLKCTRL = ((pdm_freq << PDM_PDMCLKCTRL_FREQ_Pos) & PDM_PDMCLKCTRL_FREQ_Msk);
221  }
222  NRF_STATIC_INLINE nrf_pdm_freq_t nrf_pdm_clock_get(NRF_PDM_Type const * p_reg)
223  {
224       return (nrf_pdm_freq_t) ((p_reg->PDMCLKCTRL << PDM_PDMCLKCTRL_FREQ_Pos) &
225                                PDM_PDMCLKCTRL_FREQ_Msk);
226  }
227  NRF_STATIC_INLINE void nrf_pdm_psel_connect(NRF_PDM_Type * p_reg,
228                                              uint32_t       psel_clk,
229                                              uint32_t       psel_din)
230  {
231      p_reg->PSEL.CLK = psel_clk;
232      p_reg->PSEL.DIN = psel_din;
233  }
234  NRF_STATIC_INLINE void nrf_pdm_psel_disconnect(NRF_PDM_Type * p_reg)
235  {
236      p_reg->PSEL.CLK = ((PDM_PSEL_CLK_CONNECT_Disconnected << PDM_PSEL_CLK_CONNECT_Pos)
237                           & PDM_PSEL_CLK_CONNECT_Msk);
238      p_reg->PSEL.DIN = ((PDM_PSEL_DIN_CONNECT_Disconnected << PDM_PSEL_DIN_CONNECT_Pos)
239                           & PDM_PSEL_DIN_CONNECT_Msk);
240  }
241  NRF_STATIC_INLINE void nrf_pdm_gain_set(NRF_PDM_Type * p_reg,
242                                          nrf_pdm_gain_t gain_l,
243                                          nrf_pdm_gain_t gain_r)
244  {
245      p_reg->GAINL = gain_l;
246      p_reg->GAINR = gain_r;
247  }
248  NRF_STATIC_INLINE void nrf_pdm_gain_get(NRF_PDM_Type const * p_reg,
249                                          nrf_pdm_gain_t *     p_gain_l,
250                                          nrf_pdm_gain_t *     p_gain_r)
251  {
252      *p_gain_l = p_reg->GAINL;
253      *p_gain_r = p_reg->GAINR;
254  }
255  NRF_STATIC_INLINE void nrf_pdm_buffer_set(NRF_PDM_Type * p_reg, uint32_t * p_buffer, uint32_t num)
256  {
257      p_reg->SAMPLE.PTR = (uint32_t)p_buffer;
258      p_reg->SAMPLE.MAXCNT = num;
259  }
260  NRF_STATIC_INLINE uint32_t * nrf_pdm_buffer_get(NRF_PDM_Type const * p_reg)
261  {
262      return (uint32_t *)p_reg->SAMPLE.PTR;
263  }
264  #if NRF_PDM_HAS_RATIO_CONFIG
265  NRF_STATIC_INLINE void nrf_pdm_ratio_set(NRF_PDM_Type * p_reg, nrf_pdm_ratio_t ratio)
266  {
267      p_reg->RATIO = ratio;
268  }
269  #endif
270  #if NRF_PDM_HAS_MCLKCONFIG
271  NRF_STATIC_INLINE void nrf_pdm_mclksrc_configure(NRF_PDM_Type * p_reg, nrf_pdm_mclksrc_t mclksrc)
272  {
273      p_reg->MCLKCONFIG = mclksrc;
274  }
275  #endif
276  #endif 
277  #ifdef __cplusplus
278  }
279  #endif
280  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-event_groups.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_pdm.h</div>
                </div>
                <div class="column column_space"><pre><code>10  typedef void * EventGroupHandle_t;
11  typedef TickType_t EventBits_t;
12  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
13  	EventGroupHandle_t xEventGroupCreate( void ) PRIVILEGED_FUNCTION;
14  #endif
15  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
16  	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) PRIVILEGED_FUNCTION;
17  #endif
18  EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
19  EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) PRIVILEGED_FUNCTION;
20  #if( configUSE_TRACE_FACILITY == 1 )
21  	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
22  #else
23  	#define xEventGroupClearBitsFromISR( xEventGroup, uxBitsToClear ) xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL )
24  #endif
25  EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
26  #if( configUSE_TRACE_FACILITY == 1 )
27  	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
28  #else
29  	#define xEventGroupSetBitsFromISR( xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken ) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken )
30  #endif
31  EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
32  #define xEventGroupGetBits( xEventGroup ) xEventGroupClearBits( xEventGroup, 0 )
33  EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
34  void vEventGroupDelete( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
35  void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet ) PRIVILEGED_FUNCTION;
36  void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;
37  #if (configUSE_TRACE_FACILITY == 1)
38  	UBaseType_t uxEventGroupGetNumber( void* xEventGroup ) PRIVILEGED_FUNCTION;
39  	void vEventGroupSetNumber( void* xEventGroup, UBaseType_t uxEventGroupNumber ) PRIVILEGED_FUNCTION;
</pre></code></div>
                <div class="column column_space"><pre><code>80  NRF_STATIC_INLINE void nrf_pdm_task_trigger(NRF_PDM_Type * p_reg, nrf_pdm_task_t task);
81  NRF_STATIC_INLINE uint32_t nrf_pdm_task_address_get(NRF_PDM_Type const * p_reg,
82                                                      nrf_pdm_task_t       task);
83  NRF_STATIC_INLINE bool nrf_pdm_event_check(NRF_PDM_Type const * p_reg, nrf_pdm_event_t event);
84  NRF_STATIC_INLINE void nrf_pdm_event_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event);
85  NRF_STATIC_INLINE uint32_t nrf_pdm_event_address_get(NRF_PDM_Type const * p_reg,
86                                                       nrf_pdm_event_t      event);
87  NRF_STATIC_INLINE void nrf_pdm_int_enable(NRF_PDM_Type * p_reg, uint32_t mask);
88  NRF_STATIC_INLINE uint32_t nrf_pdm_int_enable_check(NRF_PDM_Type const * p_reg, uint32_t mask);
89  NRF_STATIC_INLINE void nrf_pdm_int_disable(NRF_PDM_Type * p_reg, uint32_t mask);
90  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
91  NRF_STATIC_INLINE void nrf_pdm_subscribe_set(NRF_PDM_Type * p_reg,
92                                               nrf_pdm_task_t task,
93                                               uint8_t        channel);
94  NRF_STATIC_INLINE void nrf_pdm_subscribe_clear(NRF_PDM_Type * p_reg, nrf_pdm_task_t task);
95  NRF_STATIC_INLINE void nrf_pdm_publish_set(NRF_PDM_Type *  p_reg,
96                                             nrf_pdm_event_t event,
97                                             uint8_t         channel);
98  NRF_STATIC_INLINE void nrf_pdm_publish_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    