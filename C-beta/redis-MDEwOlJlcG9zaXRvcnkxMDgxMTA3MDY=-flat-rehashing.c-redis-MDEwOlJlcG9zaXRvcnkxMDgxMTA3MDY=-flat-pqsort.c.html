
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.43952802359882%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rehashing.c</h3>
            <pre><code>1  #include "redis.h"
2  #include "dict.h"
3  void _redisAssert(char *x, char *y, int l) {
4      printf("ASSERT: %s %s %d\n",x,y,l);
5      exit(1);
6  }
7  unsigned int dictKeyHash(const void *keyp) {
8      unsigned long key = (unsigned long)keyp;
9      key = dictGenHashFunction(&key,sizeof(key));
10      key += ~(key << 15);
11      key ^=  (key >> 10);
12      key +=  (key << 3);
13      key ^=  (key >> 6);
14      key += ~(key << 11);
15      key ^=  (key >> 16);
16      return key;
17  }
18  int dictKeyCompare(void *privdata, const void *key1, const void *key2) {
19      unsigned long k1 = (unsigned long)key1;
20      unsigned long k2 = (unsigned long)key2;
21      return k1 == k2;
22  }
23  dictType dictTypeTest = {
24      dictKeyHash,                   &bsol;* hash function */
25      NULL,                          &bsol;* key dup */
26      NULL,                          &bsol;* val dup */
27      dictKeyCompare,                &bsol;* key compare */
28      NULL,                          &bsol;* key destructor */
29      NULL                           &bsol;* val destructor */
30  };
31  void showBuckets(dictht ht) {
32      if (ht.table == NULL) {
33          printf("NULL\n");
34      } else {
35          int j;
36          for (j = 0; j < ht.size; j++) {
37              printf("%c", ht.table[j] ? '1' : '0');
38          }
39          printf("\n");
40      }
41  }
42  void show(dict *d) {
43      int j;
44      if (d->rehashidx != -1) {
45          printf("rhidx: ");
46          for (j = 0; j < d->rehashidx; j++)
47              printf(".");
48          printf("|\n");
49      }
50      printf("ht[0]: ");
51      showBuckets(d->ht[0]);
52      printf("ht[1]: ");
53      showBuckets(d->ht[1]);
54      printf("\n");
55  }
56  int sortPointers(const void *a, const void *b) {
57      unsigned long la, lb;
58      la = (long) (*((dictEntry**)a));
59      lb = (long) (*((dictEntry**)b));
60      return la-lb;
<span onclick='openModal()' class='match'>61  }
62  void stressGetKeys(dict *d, int times, int *perfect_run, int *approx_run) {
63      int j;
64      dictEntry **des = zmalloc(sizeof(dictEntry*)*dictSize(d));
</span>65      for (j = 0; j < times; j++) {
66          int requested = rand() % (dictSize(d)+1);
67          int returned = dictGetSomeKeys(d, des, requested);
68          int dup = 0;
69          qsort(des,returned,sizeof(dictEntry*),sortPointers);
70          if (returned > 1) {
71              int i;
72              for (i = 0; i < returned-1; i++) {
73                  if (des[i] == des[i+1]) dup++;
74              }
75          }
76          if (requested == returned && dup == 0) {
77              (*perfect_run)++;
78          } else {
79              (*approx_run)++;
80              printf("Requested, returned, duplicated: %d %d %d\n",
81                  requested, returned, dup);
82          }
83      }
84      zfree(des);
85  }
86  #define MAX1 120
87  #define MAX2 1000
88  int main(void) {
89      dict *d = dictCreate(&dictTypeTest,NULL);
90      unsigned long i;
91      srand(time(NULL));
92      for (i = 0; i < MAX1; i++) {
93          dictAdd(d,(void*)i,NULL);
94          show(d);
95      }
96      printf("Size: %d\n", (int)dictSize(d));
97      for (i = 0; i < MAX1; i++) {
98          dictDelete(d,(void*)i);
99          dictResize(d);
100          show(d);
101      }
102      dictRelease(d);
103      d = dictCreate(&dictTypeTest,NULL);
104      printf("Stress testing dictGetSomeKeys\n");
105      int perfect_run = 0, approx_run = 0;
106      for (i = 0; i < MAX2; i++) {
107          dictAdd(d,(void*)i,NULL);
108          stressGetKeys(d,100,&perfect_run,&approx_run);
109      }
110      for (i = 0; i < MAX2; i++) {
111          dictDelete(d,(void*)i);
112          dictResize(d);
113          stressGetKeys(d,100,&perfect_run,&approx_run);
114      }
115      printf("dictGetSomeKey, %d perfect runs, %d approximated runs\n",
116          perfect_run, approx_run);
117      dictRelease(d);
118      printf("TEST PASSED!\n");
119      return 0;
120  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-pqsort.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/win32_types.h"
4  #endif
5  #include <sys/types.h>
6  #include <errno.h>
7  #include <stdlib.h>
8  static inline char	*med3 (char *, char *, char *,
9      int (*)(const void *, const void *));
10  static inline void	 swapfunc (char *, char *, size_t, int);
11  #ifndef _WIN32
12  #define min(a, b)	(a) < (b) ? a : b
13  #endif
14  #define swapcode(TYPE, parmi, parmj, n) { 		\
15  	size_t i = (n) / sizeof (TYPE); 		\
16  	TYPE *pi = (TYPE *)(void *)(parmi); 		\
17  	TYPE *pj = (TYPE *)(void *)(parmj); 		\
18  	do { 						\
19  		TYPE	t = *pi;			\
20  		*pi++ = *pj;				\
21  		*pj++ = t;				\
22          } while (--i > 0);				\
23  }
24  #define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(PORT_LONG) || \
25  	es % sizeof(PORT_LONG) ? 2 : es == sizeof(PORT_LONG)? 0 : 1;
26  static inline void
27  swapfunc(char *a, char *b, size_t n, int swaptype)
28  {
29  	if (swaptype <= 1)
30  		swapcode(PORT_LONG, a, b, n)
31  	else
32  		swapcode(char, a, b, n)
33  }
34  #define swap(a, b)						\
35  	if (swaptype == 0) {					\
36  		PORT_LONG t = *(PORT_LONG *)(void *)(a);			\
37  		*(PORT_LONG *)(void *)(a) = *(PORT_LONG *)(void *)(b);	\
38  		*(PORT_LONG *)(void *)(b) = t;			\
39  	} else							\
40  		swapfunc(a, b, es, swaptype)
41  #define vecswap(a, b, n) if ((n) > 0) swapfunc((a), (b), (size_t)(n), swaptype)
42  static inline char *
43  med3(char *a, char *b, char *c,
44      int (*cmp) (const void *, const void *))
45  {
46  	return cmp(a, b) < 0 ?
47  	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
48                :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
<span onclick='openModal()' class='match'>49  }
50  static void
51  _pqsort(void *a, size_t n, size_t es,
52      int (*cmp) (const void *, const void *), void *lrange, void *rrange)
</span>53  {
54  	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
55  	size_t d, r;
56  	int swaptype, cmp_result;
57  loop:	SWAPINIT(a, es);
58  	if (n < 7) {
59  		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
60  			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
61  			     pl -= es)
62  				swap(pl, pl - es);
63  		return;
64  	}
65  	pm = (char *) a + (n / 2) * es;
66  	if (n > 7) {
67  		pl = (char *) a;
68  		pn = (char *) a + (n - 1) * es;
69  		if (n > 40) {
70  			d = (n / 8) * es;
71  			pl = med3(pl, pl + d, pl + 2 * d, cmp);
72  			pm = med3(pm - d, pm, pm + d, cmp);
73  			pn = med3(pn - 2 * d, pn - d, pn, cmp);
74  		}
75  		pm = med3(pl, pm, pn, cmp);
76  	}
77  	swap(a, pm);
78  	pa = pb = (char *) a + es;
79  	pc = pd = (char *) a + (n - 1) * es;
80  	for (;;) {
81  		while (pb <= pc && (cmp_result = cmp(pb, a)) <= 0) {
82  			if (cmp_result == 0) {
83  				swap(pa, pb);
84  				pa += es;
85  			}
86  			pb += es;
87  		}
88  		while (pb <= pc && (cmp_result = cmp(pc, a)) >= 0) {
89  			if (cmp_result == 0) {
90  				swap(pc, pd);
91  				pd -= es;
92  			}
93  			pc -= es;
94  		}
95  		if (pb > pc)
96  			break;
97  		swap(pb, pc);
98  		pb += es;
99  		pc -= es;
100  	}
101  	pn = (char *) a + n * es;
102  	r = min(pa - (char *) a, pb - pa);
103  	vecswap(a, pb - r, r);
104  	r = min((size_t)(pd - pc), pn - pd - es);
105  	vecswap(pb, pn - r, r);
106  	if ((r = pb - pa) > es) {
107                  void *_l = a, *_r = ((unsigned char*)a)+r-1;
108                  if (!((lrange < _l && rrange < _l) ||
109                      (lrange > _r && rrange > _r)))
110  		    _pqsort(a, r / es, es, cmp, lrange, rrange);
111          }
112  	if ((r = pd - pc) > es) {
113                  void *_l, *_r;
114  		a = pn - r;
115  		n = r / es;
116                  _l = a;
117                  _r = ((unsigned char*)a)+r-1;
118                  if (!((lrange < _l && rrange < _l) ||
119                      (lrange > _r && rrange > _r)))
120  		    goto loop;
121  	}
122  }
123  void
124  pqsort(void *a, size_t n, size_t es,
125      int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
126  {
127      _pqsort(a,n,es,cmp,((unsigned char*)a)+(lrange*es),
128                         ((unsigned char*)a)+((rrange+1)*es)-1);
129  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rehashing.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-pqsort.c</div>
                </div>
                <div class="column column_space"><pre><code>61  }
62  void stressGetKeys(dict *d, int times, int *perfect_run, int *approx_run) {
63      int j;
64      dictEntry **des = zmalloc(sizeof(dictEntry*)*dictSize(d));
</pre></code></div>
                <div class="column column_space"><pre><code>49  }
50  static void
51  _pqsort(void *a, size_t n, size_t es,
52      int (*cmp) (const void *, const void *), void *lrange, void *rrange)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    