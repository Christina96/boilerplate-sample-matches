
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.726375434107109%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-x86.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/debug.h"
5  #include "private/misc.h"
6  #include "private/cpuid-x86.h"
7  #include <sys/types.h>
8  #ifdef HAVE_DIRENT_H
9  #include <dirent.h>
10  #endif
11  #ifdef HAVE_VALGRIND_VALGRIND_H
12  #include <valgrind/valgrind.h>
13  #endif
14  struct hwloc_x86_backend_data_s {
15    unsigned nbprocs;
16    hwloc_bitmap_t apicid_set;
17    int apicid_unique;
18    char *src_cpuiddump_path;
19    int is_knl;
20  };
21  struct cpuiddump {
22    unsigned nr;
23    struct cpuiddump_entry {
24      unsigned inmask; &bsol;* which of ine[abcd]x are set on input */
25      unsigned ineax;
26      unsigned inebx;
27      unsigned inecx;
28      unsigned inedx;
29      unsigned outeax;
30      unsigned outebx;
31      unsigned outecx;
32      unsigned outedx;
33    } *entries;
34  };
35  static void
36  cpuiddump_free(struct cpuiddump *cpuiddump)
37  {
38    if (cpuiddump->nr)
39      free(cpuiddump->entries);
40    free(cpuiddump);
41  }
42  static struct cpuiddump *
43  cpuiddump_read(const char *dirpath, unsigned idx)
44  {
45    struct cpuiddump *cpuiddump;
46    struct cpuiddump_entry *cur;
47    size_t filenamelen;
48    char *filename;
49    FILE *file;
50    char line[128];
51    unsigned nr;
52    cpuiddump = malloc(sizeof(*cpuiddump));
53    if (!cpuiddump) {
54      fprintf(stderr, "Failed to allocate cpuiddump for PU #%u, ignoring cpuiddump.\n", idx);
55      goto out;
56    }
57    filenamelen = strlen(dirpath) + 15;
58    filename = malloc(filenamelen);
59    if (!filename)
60      goto out_with_dump;
61    snprintf(filename, filenamelen, "%s/pu%u", dirpath, idx);
62    file = fopen(filename, "r");
63    if (!file) {
64      fprintf(stderr, "Could not read dumped cpuid file %s, ignoring cpuiddump.\n", filename);
65      goto out_with_filename;
66    }
67    nr = 0;
68    while (fgets(line, sizeof(line), file))
69      nr++;
70    cpuiddump->entries = malloc(nr * sizeof(struct cpuiddump_entry));
71    if (!cpuiddump->entries) {
72      fprintf(stderr, "Failed to allocate %u cpuiddump entries for PU #%u, ignoring cpuiddump.\n", nr, idx);
73      goto out_with_file;
74    }
75    fseek(file, 0, SEEK_SET);
76    cur = &cpuiddump->entries[0];
77    nr = 0;
78    while (fgets(line, sizeof(line), file)) {
79      if (*line == '#')
80        continue;
81      if (sscanf(line, "%x %x %x %x %x => %x %x %x %x",
82  	      &cur->inmask,
83  	      &cur->ineax, &cur->inebx, &cur->inecx, &cur->inedx,
84  	      &cur->outeax, &cur->outebx, &cur->outecx, &cur->outedx) == 9) {
85        cur++;
86        nr++;
87      }
88    }
89    cpuiddump->nr = nr;
90    fclose(file);
91    free(filename);
92    return cpuiddump;
93   out_with_file:
94    fclose(file);
95   out_with_filename:
96    free(filename);
97   out_with_dump:
98    free(cpuiddump);
99   out:
100    return NULL;
101  }
102  static void
103  cpuiddump_find_by_input(unsigned *eax, unsigned *ebx, unsigned *ecx, unsigned *edx, struct cpuiddump *cpuiddump)
104  {
105    unsigned i;
106    for(i=0; i<cpuiddump->nr; i++) {
107      struct cpuiddump_entry *entry = &cpuiddump->entries[i];
108      if ((entry->inmask & 0x1) && *eax != entry->ineax)
109        continue;
110      if ((entry->inmask & 0x2) && *ebx != entry->inebx)
111        continue;
112      if ((entry->inmask & 0x4) && *ecx != entry->inecx)
113        continue;
114      if ((entry->inmask & 0x8) && *edx != entry->inedx)
115        continue;
116      *eax = entry->outeax;
117      *ebx = entry->outebx;
118      *ecx = entry->outecx;
119      *edx = entry->outedx;
120      return;
121    }
122    fprintf(stderr, "Couldn't find %x,%x,%x,%x in dumped cpuid, returning 0s.\n",
123  	  *eax, *ebx, *ecx, *edx);
124    *eax = 0;
125    *ebx = 0;
126    *ecx = 0;
127    *edx = 0;
128  }
129  static void cpuid_or_from_dump(unsigned *eax, unsigned *ebx, unsigned *ecx, unsigned *edx, struct cpuiddump *src_cpuiddump)
130  {
131    if (src_cpuiddump) {
132      cpuiddump_find_by_input(eax, ebx, ecx, edx, src_cpuiddump);
133    } else {
134      hwloc_x86_cpuid(eax, ebx, ecx, edx);
135    }
136  }
137  enum hwloc_x86_disc_flags {
138    HWLOC_X86_DISC_FLAG_FULL = (1<<0), &bsol;* discover everything instead of only annotating */
139    HWLOC_X86_DISC_FLAG_TOPOEXT_NUMANODES = (1<<1) &bsol;* use AMD topoext numanode information */
140  };
141  #define has_topoext(features) ((features)[6] & (1 << 22))
142  #define has_x2apic(features) ((features)[4] & (1 << 21))
143  #define has_hybrid(features) ((features)[18] & (1 << 15))
144  struct cacheinfo {
145    hwloc_obj_cache_type_t type;
146    unsigned level;
147    unsigned nbthreads_sharing;
148    unsigned cacheid;
149    unsigned linesize;
150    unsigned linepart;
151    int inclusive;
152    int ways;
153    unsigned sets;
154    unsigned long size;
155  };
156  struct procinfo {
157    unsigned present;
158    unsigned apicid;
159  #define PKG 0
160  #define CORE 1
161  #define NODE 2
162  #define UNIT 3
163  #define TILE 4
164  #define MODULE 5
165  #define DIE 6
166  #define HWLOC_X86_PROCINFO_ID_NR 7
167    unsigned ids[HWLOC_X86_PROCINFO_ID_NR];
168    unsigned *otherids;
169    unsigned levels;
170    unsigned numcaches;
171    struct cacheinfo *cache;
172    char cpuvendor[13];
173    char cpumodel[3*4*4+1];
174    unsigned cpustepping;
175    unsigned cpumodelnumber;
176    unsigned cpufamilynumber;
177    unsigned hybridcoretype;
178    unsigned hybridnativemodel;
179  };
180  enum cpuid_type {
181    intel,
182    amd,
183    zhaoxin,
184    hygon,
185    unknown
186  };
187  static void setup__amd_cache_legacy(struct procinfo *infos, unsigned level, hwloc_obj_cache_type_t type, unsigned nbthreads_sharing, unsigned cpuid)
188  {
189    struct cacheinfo *cache, *tmpcaches;
190    unsigned cachenum;
191    unsigned long size = 0;
192    if (level == 1)
193      size = ((cpuid >> 24)) << 10;
194    else if (level == 2)
195      size = ((cpuid >> 16)) << 10;
196    else if (level == 3)
197      size = ((cpuid >> 18)) << 19;
198    if (!size)
199      return;
200    tmpcaches = realloc(infos->cache, (infos->numcaches+1)*sizeof(*infos->cache));
201    if (!tmpcaches)
202      return;
203    infos->cache = tmpcaches;
204    cachenum = infos->numcaches++;
205    cache = &infos->cache[cachenum];
206    cache->type = type;
207    cache->level = level;
208    cache->nbthreads_sharing = nbthreads_sharing;
209    cache->linesize = cpuid & 0xff;
210    cache->linepart = 0;
211    cache->inclusive = 0; &bsol;* old AMD (K8-K10) supposed to have exclusive caches */
212    if (level == 1) {
213      cache->ways = (cpuid >> 16) & 0xff;
214      if (cache->ways == 0xff)
215        cache->ways = -1;
216    } else {
217      static const unsigned ways_tab[] = { 0, 1, 2, 0, 4, 0, 8, 0, 16, 0, 32, 48, 64, 96, 128, -1 };
218      unsigned ways = (cpuid >> 12) & 0xf;
219      cache->ways = ways_tab[ways];
220    }
221    cache->size = size;
222    cache->sets = 0;
223    hwloc_debug("cache L%u t%u linesize %u ways %d size %luKB\n", cache->level, cache->nbthreads_sharing, cache->linesize, cache->ways, cache->size >> 10);
224  }
225  static void read_amd_caches_legacy(struct procinfo *infos, struct cpuiddump *src_cpuiddump, unsigned legacy_max_log_proc)
226  {
227    unsigned eax, ebx, ecx, edx;
228    eax = 0x80000005;
229    cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
230    setup__amd_cache_legacy(infos, 1, HWLOC_OBJ_CACHE_DATA, 1, ecx); &bsol;* private L1d */
231    setup__amd_cache_legacy(infos, 1, HWLOC_OBJ_CACHE_INSTRUCTION, 1, edx); &bsol;* private L1i */
232    eax = 0x80000006;
233    cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
234    if (ecx & 0xf000)
235      setup__amd_cache_legacy(infos, 2, HWLOC_OBJ_CACHE_UNIFIED, 1, ecx); &bsol;* private L2u */
236    if (edx & 0xf000)
237      setup__amd_cache_legacy(infos, 3, HWLOC_OBJ_CACHE_UNIFIED, legacy_max_log_proc, edx); &bsol;* package-wide L3u */
238  }
239  static void read_amd_caches_topoext(struct procinfo *infos, struct cpuiddump *src_cpuiddump)
240  {
241    unsigned eax, ebx, ecx, edx;
242    unsigned cachenum;
243    struct cacheinfo *cache;
244    assert(!infos->numcaches);
245    for (cachenum = 0; ; cachenum++) {
246      eax = 0x8000001d;
247      ecx = cachenum;
248      cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
249      if ((eax & 0x1f) == 0)
250        break;
251      infos->numcaches++;
252    }
253    cache = infos->cache = malloc(infos->numcaches * sizeof(*infos->cache));
254    if (cache) {
255      for (cachenum = 0; ; cachenum++) {
256        unsigned long linesize, linepart, ways, sets;
257        eax = 0x8000001d;
258        ecx = cachenum;
259        cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
260        if ((eax & 0x1f) == 0)
261  	break;
262        switch (eax & 0x1f) {
263        case 1: cache->type = HWLOC_OBJ_CACHE_DATA; break;
264        case 2: cache->type = HWLOC_OBJ_CACHE_INSTRUCTION; break;
265        default: cache->type = HWLOC_OBJ_CACHE_UNIFIED; break;
266        }
267        cache->level = (eax >> 5) & 0x7;
268        cache->nbthreads_sharing = ((eax >> 14) &  0xfff) + 1;
269        cache->linesize = linesize = (ebx & 0xfff) + 1;
270        cache->linepart = linepart = ((ebx >> 12) & 0x3ff) + 1;
271        ways = ((ebx >> 22) & 0x3ff) + 1;
272        if (eax & (1 << 9))
273  	cache->ways = -1;
274        else
275  	cache->ways = ways;
276        cache->sets = sets = ecx + 1;
277        cache->size = linesize * linepart * ways * sets;
278        cache->inclusive = edx & 0x2;
279        hwloc_debug("cache %u L%u%c t%u linesize %lu linepart %lu ways %lu sets %lu, size %luKB\n",
280  		  cachenum, cache->level,
281  		  cache->type == HWLOC_OBJ_CACHE_DATA ? 'd' : cache->type == HWLOC_OBJ_CACHE_INSTRUCTION ? 'i' : 'u',
282  		  cache->nbthreads_sharing, linesize, linepart, ways, sets, cache->size >> 10);
283        cache++;
284      }
285    } else {
286      infos->numcaches = 0;
287    }
288  }
289  static void read_intel_caches(struct hwloc_x86_backend_data_s *data, struct procinfo *infos, struct cpuiddump *src_cpuiddump)
290  {
291    unsigned level;
292    struct cacheinfo *tmpcaches;
293    unsigned eax, ebx, ecx, edx;
294    unsigned oldnumcaches = infos->numcaches; &bsol;* in case we got caches above */
295    unsigned cachenum;
296    struct cacheinfo *cache;
297    for (cachenum = 0; ; cachenum++) {
298      eax = 0x04;
299      ecx = cachenum;
300      cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
301      hwloc_debug("cache %u type %u\n", cachenum, eax & 0x1f);
302      if ((eax & 0x1f) == 0)
303        break;
304      level = (eax >> 5) & 0x7;
305      if (data->is_knl && level == 3)
306        break;
307      infos->numcaches++;
308    }
309    tmpcaches = realloc(infos->cache, infos->numcaches * sizeof(*infos->cache));
310    if (!tmpcaches) {
311      infos->numcaches = oldnumcaches;
312    } else {
313      infos->cache = tmpcaches;
314      cache = &infos->cache[oldnumcaches];
315      for (cachenum = 0; ; cachenum++) {
316        unsigned long linesize, linepart, ways, sets;
317        eax = 0x04;
318        ecx = cachenum;
319        cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
320        if ((eax & 0x1f) == 0)
321  	break;
322        level = (eax >> 5) & 0x7;
323        if (data->is_knl && level == 3)
324  	break;
325        switch (eax & 0x1f) {
326        case 1: cache->type = HWLOC_OBJ_CACHE_DATA; break;
327        case 2: cache->type = HWLOC_OBJ_CACHE_INSTRUCTION; break;
328        default: cache->type = HWLOC_OBJ_CACHE_UNIFIED; break;
329        }
330        cache->level = level;
331        cache->nbthreads_sharing = ((eax >> 14) & 0xfff) + 1;
332        cache->linesize = linesize = (ebx & 0xfff) + 1;
333        cache->linepart = linepart = ((ebx >> 12) & 0x3ff) + 1;
334        ways = ((ebx >> 22) & 0x3ff) + 1;
335        if (eax & (1 << 9))
336          cache->ways = -1;
337        else
338          cache->ways = ways;
339        cache->sets = sets = ecx + 1;
340        cache->size = linesize * linepart * ways * sets;
341        cache->inclusive = edx & 0x2;
342        hwloc_debug("cache %u L%u%c t%u linesize %lu linepart %lu ways %lu sets %lu, size %luKB\n",
343  		  cachenum, cache->level,
344  		  cache->type == HWLOC_OBJ_CACHE_DATA ? 'd' : cache->type == HWLOC_OBJ_CACHE_INSTRUCTION ? 'i' : 'u',
345  		  cache->nbthreads_sharing, linesize, linepart, ways, sets, cache->size >> 10);
346        cache++;
347      }
348    }
349  }
350  static void read_amd_cores_legacy(struct procinfo *infos, struct cpuiddump *src_cpuiddump)
351  {
352    unsigned eax, ebx, ecx, edx;
353    unsigned max_nbcores;
354    unsigned max_nbthreads;
355    unsigned coreidsize;
356    unsigned logprocid;
357    unsigned threadid __hwloc_attribute_unused;
358    eax = 0x80000008;
359    cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
360    coreidsize = (ecx >> 12) & 0xf;
361    hwloc_debug("core ID size: %u\n", coreidsize);
362    if (!coreidsize) {
363      max_nbcores = (ecx & 0xff) + 1;
364    } else
365      max_nbcores = 1 << coreidsize;
366    hwloc_debug("Thus max # of cores: %u\n", max_nbcores);
367    max_nbthreads = 1 ;
368    hwloc_debug("and max # of threads: %u\n", max_nbthreads);
369    infos->ids[PKG] = infos->apicid / max_nbcores;
370    logprocid = infos->apicid % max_nbcores;
371    infos->ids[CORE] = logprocid / max_nbthreads;
372    threadid = logprocid % max_nbthreads;
373    hwloc_debug("this is thread %u of core %u\n", threadid, infos->ids[CORE]);
374  }
375  static void read_amd_cores_topoext(struct procinfo *infos, unsigned long flags, struct cpuiddump *src_cpuiddump)
376  {
377    unsigned apic_id, nodes_per_proc = 0;
378    unsigned eax, ebx, ecx, edx;
379    eax = 0x8000001e;
380    cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
381    infos->apicid = apic_id = eax;
382    if (flags & HWLOC_X86_DISC_FLAG_TOPOEXT_NUMANODES) {
383      if (infos->cpufamilynumber == 0x16) {
384        infos->ids[NODE] = 0;
385        nodes_per_proc = 1;
386      } else {
387        infos->ids[NODE] = ecx & 0xff;
388        nodes_per_proc = ((ecx >> 8) & 7) + 1;
389      }
390      if ((infos->cpufamilynumber == 0x15 && nodes_per_proc > 2)
391  	|| ((infos->cpufamilynumber == 0x17 || infos->cpufamilynumber == 0x18) && nodes_per_proc > 4)
392          || (infos->cpufamilynumber == 0x19 && nodes_per_proc > 1)) {
393        hwloc_debug("warning: undefined nodes_per_proc value %u, assuming it means %u\n", nodes_per_proc, nodes_per_proc);
394      }
395    }
396    if (infos->cpufamilynumber <= 0x16) { &bsol;* topoext appeared in 0x15 and compute-units were only used in 0x15 and 0x16 */
397      unsigned cores_per_unit;
398      infos->ids[UNIT] = ebx & 0xff;
399      cores_per_unit = ((ebx >> 8) & 0xff) + 1;
400      hwloc_debug("topoext %08x, %u nodes, node %u, %u cores in unit %u\n", apic_id, nodes_per_proc, infos->ids[NODE], cores_per_unit, infos->ids[UNIT]);
401    } else {
402      unsigned threads_per_core;
403      infos->ids[CORE] = ebx & 0xff;
404      threads_per_core = ((ebx >> 8) & 0xff) + 1;
405      hwloc_debug("topoext %08x, %u nodes, node %u, %u threads in core %u\n", apic_id, nodes_per_proc, infos->ids[NODE], threads_per_core, infos->ids[CORE]);
406    }
407  }
408  static void read_intel_cores_exttopoenum(struct procinfo *infos, unsigned leaf, struct cpuiddump *src_cpuiddump)
409  {
410    unsigned level, apic_nextshift, apic_number, apic_type, apic_id = 0, apic_shift = 0, id;
411    unsigned threadid __hwloc_attribute_unused = 0; &bsol;* shut-up compiler */
412    unsigned eax, ebx, ecx = 0, edx;
413    int apic_packageshift = 0;
414    for (level = 0; ; level++) {
415      ecx = level;
416      eax = leaf;
417      cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
418      if (!eax && !ebx)
419        break;
420      apic_packageshift = eax & 0x1f;
421    }
422    if (level) {
423      infos->otherids = malloc(level * sizeof(*infos->otherids));
424      if (infos->otherids) {
425        infos->levels = level;
426        for (level = 0; ; level++) {
427  	ecx = level;
428  	eax = leaf;
429  	cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
430  	if (!eax && !ebx)
431  	  break;
432  	apic_nextshift = eax & 0x1f;
433  	apic_number = ebx & 0xffff;
434  	apic_type = (ecx & 0xff00) >> 8;
435  	apic_id = edx;
436  	id = (apic_id >> apic_shift) & ((1 << (apic_packageshift - apic_shift)) - 1);
437  	hwloc_debug("x2APIC %08x %u: nextshift %u num %2u type %u id %2u\n", apic_id, level, apic_nextshift, apic_number, apic_type, id);
438  	infos->apicid = apic_id;
439  	infos->otherids[level] = UINT_MAX;
440  	switch (apic_type) {
441  	case 1:
442  	  threadid = id;
443  	  break;
444  	case 2:
445  	  infos->ids[CORE] = id;
446  	  break;
447  	case 3:
448  	  infos->ids[MODULE] = id;
449  	  break;
450  	case 4:
451  	  infos->ids[TILE] = id;
452  	  break;
453  	case 5:
454  	  infos->ids[DIE] = id;
455  	  break;
456  	default:
457  	  hwloc_debug("x2APIC %u: unknown type %u\n", level, apic_type);
458  	  infos->otherids[level] = apic_id >> apic_shift;
459  	  break;
460  	}
461  	apic_shift = apic_nextshift;
462        }
463        infos->apicid = apic_id;
464        infos->ids[PKG] = apic_id >> apic_shift;
465        hwloc_debug("x2APIC remainder: %u\n", infos->ids[PKG]);
466        hwloc_debug("this is thread %u of core %u\n", threadid, infos->ids[CORE]);
467      }
468    }
469  }
470  static void look_proc(struct hwloc_backend *backend, struct procinfo *infos, unsigned long flags, unsigned highest_cpuid, unsigned highest_ext_cpuid, unsigned *features, enum cpuid_type cpuid_type, struct cpuiddump *src_cpuiddump)
471  {
472    struct hwloc_x86_backend_data_s *data = backend->private_data;
473    unsigned eax, ebx, ecx = 0, edx;
474    unsigned cachenum;
475    struct cacheinfo *cache;
476    unsigned regs[4];
477    unsigned legacy_max_log_proc; &bsol;* not valid on Intel processors with > 256 threads, or when cpuid 0x80000008 is supported */
478    unsigned legacy_log_proc_id;
479    unsigned _model, _extendedmodel, _family, _extendedfamily;
480    infos->present = 1;
481    eax = 0x01;
482    cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
483    infos->apicid = ebx >> 24;
484    if (edx & (1 << 28)) {
485      legacy_max_log_proc = 1 << hwloc_flsl(((ebx >> 16) & 0xff) - 1);
486    } else {
487      hwloc_debug("HTT bit not set in CPUID 0x01.edx, assuming legacy_max_log_proc = 1\n");
488      legacy_max_log_proc = 1;
489    }
490    hwloc_debug("APIC ID 0x%02x legacy_max_log_proc %u\n", infos->apicid, legacy_max_log_proc);
491    infos->ids[PKG] = infos->apicid / legacy_max_log_proc;
492    legacy_log_proc_id = infos->apicid % legacy_max_log_proc;
493    hwloc_debug("phys %u legacy thread %u\n", infos->ids[PKG], legacy_log_proc_id);
494    _model          = (eax>>4) & 0xf;
495    _extendedmodel  = (eax>>16) & 0xf;
496    _family         = (eax>>8) & 0xf;
497    _extendedfamily = (eax>>20) & 0xff;
498    if ((cpuid_type == intel || cpuid_type == amd || cpuid_type == hygon) && _family == 0xf) {
499      infos->cpufamilynumber = _family + _extendedfamily;
500    } else {
501      infos->cpufamilynumber = _family;
502    }
503    if ((cpuid_type == intel && (_family == 0x6 || _family == 0xf))
504        || ((cpuid_type == amd || cpuid_type == hygon) && _family == 0xf)
505        || (cpuid_type == zhaoxin && (_family == 0x6 || _family == 0x7))) {
506      infos->cpumodelnumber = _model + (_extendedmodel << 4);
507    } else {
508      infos->cpumodelnumber = _model;
509    }
510    infos->cpustepping = eax & 0xf;
511    if (cpuid_type == intel && infos->cpufamilynumber == 0x6 &&
512        (infos->cpumodelnumber == 0x57 || infos->cpumodelnumber == 0x85))
513      data->is_knl = 1; &bsol;* KNM is the same as KNL */
514    memset(regs, 0, sizeof(regs));
515    regs[0] = 0;
516    cpuid_or_from_dump(&regs[0], &regs[1], &regs[3], &regs[2], src_cpuiddump);
517    memcpy(infos->cpuvendor, regs+1, 4*3);
518    if (highest_ext_cpuid >= 0x80000004) {
519      memset(regs, 0, sizeof(regs));
520      regs[0] = 0x80000002;
521      cpuid_or_from_dump(&regs[0], &regs[1], &regs[2], &regs[3], src_cpuiddump);
522      memcpy(infos->cpumodel, regs, 4*4);
523      regs[0] = 0x80000003;
524      cpuid_or_from_dump(&regs[0], &regs[1], &regs[2], &regs[3], src_cpuiddump);
525      memcpy(infos->cpumodel + 4*4, regs, 4*4);
526      regs[0] = 0x80000004;
527      cpuid_or_from_dump(&regs[0], &regs[1], &regs[2], &regs[3], src_cpuiddump);
528      memcpy(infos->cpumodel + 4*4*2, regs, 4*4);
529    }
530    if ((cpuid_type != amd && cpuid_type != hygon) && highest_cpuid >= 0x04) {
531      eax = 0x04;
532      ecx = 0;
533      cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
534      if ((eax & 0x1f) != 0) {
535        unsigned max_nbcores;
536        unsigned max_nbthreads;
537        unsigned threadid __hwloc_attribute_unused;
538        hwloc_debug("Trying to get core/thread IDs from 0x04...\n");
539        max_nbcores = ((eax >> 26) & 0x3f) + 1;
540        hwloc_debug("found %u cores max\n", max_nbcores);
541        if (!max_nbcores) {
542          hwloc_debug("cannot detect core/thread IDs from 0x04 without a valid max of cores\n");
543        } else {
544          max_nbthreads = legacy_max_log_proc / max_nbcores;
545          hwloc_debug("found %u threads max\n", max_nbthreads);
546          if (!max_nbthreads) {
547            hwloc_debug("cannot detect core/thread IDs from 0x04 without a valid max of threads\n");
548          } else {
549            threadid = legacy_log_proc_id % max_nbthreads;
550            infos->ids[CORE] = legacy_log_proc_id / max_nbthreads;
551            hwloc_debug("this is thread %u of core %u\n", threadid, infos->ids[CORE]);
552          }
553        }
554      }
555    }
556    if (highest_cpuid >= 0x1a && has_hybrid(features)) {
557      eax = 0x1a;
558      ecx = 0;
559      cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
560      infos->hybridcoretype = eax >> 24;
561      infos->hybridnativemodel = eax & 0xffffff;
562    }
563    if (cpuid_type != intel && cpuid_type != zhaoxin && highest_ext_cpuid >= 0x80000008 && !has_x2apic(features)) {
564      read_amd_cores_legacy(infos, src_cpuiddump);
565    }
566    if (cpuid_type != intel && cpuid_type != zhaoxin && has_topoext(features)) {
567      read_amd_cores_topoext(infos, flags, src_cpuiddump);
568    }
569    if ((cpuid_type == intel) && highest_cpuid >= 0x1f) {
570      read_intel_cores_exttopoenum(infos, 0x1f, src_cpuiddump);
571    } else if ((cpuid_type == intel || cpuid_type == amd || cpuid_type == zhaoxin)
572  	     && highest_cpuid >= 0x0b && has_x2apic(features)) {
573      read_intel_cores_exttopoenum(infos, 0x0b, src_cpuiddump);
574    }
575    infos->numcaches = 0;
576    infos->cache = NULL;
577    if (cpuid_type != intel && cpuid_type != zhaoxin && has_topoext(features)) {
578      read_amd_caches_topoext(infos, src_cpuiddump);
579    } else if (cpuid_type != intel && cpuid_type != zhaoxin && highest_ext_cpuid >= 0x80000006) {
580      read_amd_caches_legacy(infos, src_cpuiddump, legacy_max_log_proc);
581    }
582    if ((cpuid_type != amd && cpuid_type != hygon) && highest_cpuid >= 0x04) {
583      read_intel_caches(data, infos, src_cpuiddump);
584    }
585    for (cachenum = 0; cachenum < infos->numcaches; cachenum++) {
586      cache = &infos->cache[cachenum];
587      cache->cacheid = infos->apicid / cache->nbthreads_sharing;
588      if (cpuid_type == intel) {
589        unsigned bits = hwloc_flsl(cache->nbthreads_sharing-1);
590        unsigned mask = ~((1U<<bits) - 1);
591        cache->cacheid = infos->apicid & mask;
592      } else if (cpuid_type == amd) {
593        if (infos->cpufamilynumber >= 0x17 && cache->level == 3) {
594          unsigned nbapics_sharing = cache->nbthreads_sharing;
595          if (nbapics_sharing & (nbapics_sharing-1))
596            nbapics_sharing = 1U<<(1+hwloc_ffsl(nbapics_sharing));
597  	cache->cacheid = infos->apicid / nbapics_sharing;
598        } else if (infos->cpufamilynumber== 0x10 && infos->cpumodelnumber == 0x9
599  	  && cache->level == 3
600  	  && (cache->ways == -1 || (cache->ways % 2 == 0)) && cache->nbthreads_sharing >= 8) {
601  	if (cache->nbthreads_sharing == 16)
602  	  cache->nbthreads_sharing = 12; &bsol;* nbthreads_sharing is a power of 2 but the processor actually has 8 or 12 cores */
603  	cache->nbthreads_sharing /= 2;
604  	cache->size /= 2;
605  	if (cache->ways != -1)
606  	  cache->ways /= 2;
<span onclick='openModal()' class='match'>607  	cache->cacheid = (infos->apicid % legacy_max_log_proc) / cache->nbthreads_sharing &bsol;* cacheid within the package */
608  	  + 2 * (infos->apicid / legacy_max_log_proc); &bsol;* add 2 caches per previous package */
</span>609        } else if (infos->cpufamilynumber == 0x15
610  		 && (infos->cpumodelnumber == 0x1 &bsol;* Bulldozer */ || infos->cpumodelnumber == 0x2 &bsol;* Piledriver */)
611  		 && cache->level == 3 && cache->nbthreads_sharing == 6) {
612  	cache->cacheid = (infos->apicid % legacy_max_log_proc) / cache->nbthreads_sharing &bsol;* cacheid within the package */
613  	  + 2 * (infos->apicid / legacy_max_log_proc); &bsol;* add 2 cache per previous package */
614        }
615      } else if (cpuid_type == hygon) {
616        if (infos->cpufamilynumber == 0x18
617  	  && cache->level == 3 && cache->nbthreads_sharing == 6) {
618          cache->cacheid = infos->apicid / 8;
619        }
620      }
621    }
622    if (hwloc_bitmap_isset(data->apicid_set, infos->apicid))
623      data->apicid_unique = 0;
624    else
625      hwloc_bitmap_set(data->apicid_set, infos->apicid);
626  }
627  static void
628  hwloc_x86_add_cpuinfos(hwloc_obj_t obj, struct procinfo *info, int replace)
629  {
630    char number[12];
631    if (info->cpuvendor[0])
632      hwloc__add_info_nodup(&obj->infos, &obj->infos_count, "CPUVendor", info->cpuvendor, replace);
633    snprintf(number, sizeof(number), "%u", info->cpufamilynumber);
634    hwloc__add_info_nodup(&obj->infos, &obj->infos_count, "CPUFamilyNumber", number, replace);
635    snprintf(number, sizeof(number), "%u", info->cpumodelnumber);
636    hwloc__add_info_nodup(&obj->infos, &obj->infos_count, "CPUModelNumber", number, replace);
637    if (info->cpumodel[0]) {
638      const char *c = info->cpumodel;
639      while (*c == ' ')
640        c++;
641      hwloc__add_info_nodup(&obj->infos, &obj->infos_count, "CPUModel", c, replace);
642    }
643    snprintf(number, sizeof(number), "%u", info->cpustepping);
644    hwloc__add_info_nodup(&obj->infos, &obj->infos_count, "CPUStepping", number, replace);
645  }
646  static void
647  hwloc_x86_add_groups(hwloc_topology_t topology,
648  		     struct procinfo *infos,
649  		     unsigned nbprocs,
650  		     hwloc_bitmap_t remaining_cpuset,
651  		     unsigned type,
652  		     const char *subtype,
653  		     unsigned kind,
654  		     int dont_merge)
655  {
656    hwloc_bitmap_t obj_cpuset;
657    hwloc_obj_t obj;
658    unsigned i, j;
659    while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
660      unsigned packageid = infos[i].ids[PKG];
661      unsigned id = infos[i].ids[type];
662      if (id == (unsigned)-1) {
663        hwloc_bitmap_clr(remaining_cpuset, i);
664        continue;
665      }
666      obj_cpuset = hwloc_bitmap_alloc();
667      for (j = i; j < nbprocs; j++) {
668        if (infos[j].ids[type] == (unsigned) -1) {
669  	hwloc_bitmap_clr(remaining_cpuset, j);
670  	continue;
671        }
672        if (infos[j].ids[PKG] == packageid && infos[j].ids[type] == id) {
673  	hwloc_bitmap_set(obj_cpuset, j);
674  	hwloc_bitmap_clr(remaining_cpuset, j);
675        }
676      }
677      obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, id);
678      obj->cpuset = obj_cpuset;
679      obj->subtype = strdup(subtype);
680      obj->attr->group.kind = kind;
681      obj->attr->group.dont_merge = dont_merge;
682      hwloc_debug_2args_bitmap("os %s %u has cpuset %s\n",
683  			     subtype, id, obj_cpuset);
684      hwloc__insert_object_by_cpuset(topology, NULL, obj, "x86:group");
685    }
686  }
687  static void summarize(struct hwloc_backend *backend, struct procinfo *infos, unsigned long flags)
688  {
689    struct hwloc_topology *topology = backend->topology;
690    struct hwloc_x86_backend_data_s *data = backend->private_data;
691    unsigned nbprocs = data->nbprocs;
692    hwloc_bitmap_t complete_cpuset = hwloc_bitmap_alloc();
693    unsigned i, j, l, level;
694    int one = -1;
695    hwloc_bitmap_t remaining_cpuset;
696    int gotnuma = 0;
697    int fulldiscovery = (flags & HWLOC_X86_DISC_FLAG_FULL);
698  #ifdef HWLOC_DEBUG
699    hwloc_debug("\nSummary of x86 CPUID topology:\n");
700    for(i=0; i<nbprocs; i++) {
701      hwloc_debug("PU %u present=%u apicid=%u on PKG %d CORE %d DIE %d NODE %d\n",
702                  i, infos[i].present, infos[i].apicid,
703                  infos[i].ids[PKG], infos[i].ids[CORE], infos[i].ids[DIE], infos[i].ids[NODE]);
704    }
705    hwloc_debug("\n");
706  #endif
707    for (i = 0; i < nbprocs; i++)
708      if (infos[i].present) {
709        hwloc_bitmap_set(complete_cpuset, i);
710        one = i;
711      }
712    if (one == -1) {
713      hwloc_bitmap_free(complete_cpuset);
714      return;
715    }
716    remaining_cpuset = hwloc_bitmap_alloc();
717    if (hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_PACKAGE)) {
718      hwloc_obj_t package;
719      hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
720      while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
721        if (fulldiscovery) {
722  	unsigned packageid = infos[i].ids[PKG];
723  	hwloc_bitmap_t package_cpuset = hwloc_bitmap_alloc();
724  	for (j = i; j < nbprocs; j++) {
725  	  if (infos[j].ids[PKG] == packageid) {
726  	    hwloc_bitmap_set(package_cpuset, j);
727  	    hwloc_bitmap_clr(remaining_cpuset, j);
728  	  }
729  	}
730  	package = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PACKAGE, packageid);
731  	package->cpuset = package_cpuset;
732  	hwloc_x86_add_cpuinfos(package, &infos[i], 0);
733  	hwloc_debug_1arg_bitmap("os package %u has cpuset %s\n",
734  				packageid, package_cpuset);
735  	hwloc__insert_object_by_cpuset(topology, NULL, package, "x86:package");
736        } else {
737  	hwloc_bitmap_t set = hwloc_bitmap_alloc();
738  	hwloc_bitmap_set(set, i);
739  	package = hwloc_get_next_obj_covering_cpuset_by_type(topology, set, HWLOC_OBJ_PACKAGE, NULL);
740  	hwloc_bitmap_free(set);
741  	if (package) {
742  	  hwloc_x86_add_cpuinfos(package, &infos[i], 1);
743  	  hwloc_bitmap_andnot(remaining_cpuset, remaining_cpuset, package->cpuset);
744  	} else {
745  	  hwloc_x86_add_cpuinfos(hwloc_get_root_obj(topology), &infos[i], 1);
746  	  break;
747  	}
748        }
749      }
750    }
751    if (fulldiscovery && (flags & HWLOC_X86_DISC_FLAG_TOPOEXT_NUMANODES)) {
752      hwloc_bitmap_t node_cpuset;
753      hwloc_obj_t node;
754      hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
755      while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
756        unsigned packageid = infos[i].ids[PKG];
757        unsigned nodeid = infos[i].ids[NODE];
758        if (nodeid == (unsigned)-1) {
759          hwloc_bitmap_clr(remaining_cpuset, i);
760  	continue;
761        }
762        node_cpuset = hwloc_bitmap_alloc();
763        for (j = i; j < nbprocs; j++) {
764  	if (infos[j].ids[NODE] == (unsigned) -1) {
765  	  hwloc_bitmap_clr(remaining_cpuset, j);
766  	  continue;
767  	}
768          if (infos[j].ids[PKG] == packageid && infos[j].ids[NODE] == nodeid) {
769            hwloc_bitmap_set(node_cpuset, j);
770            hwloc_bitmap_clr(remaining_cpuset, j);
771          }
772        }
773        node = hwloc_alloc_setup_object(topology, HWLOC_OBJ_NUMANODE, nodeid);
774        node->cpuset = node_cpuset;
775        node->nodeset = hwloc_bitmap_alloc();
776        hwloc_bitmap_set(node->nodeset, nodeid);
777        hwloc_debug_1arg_bitmap("os node %u has cpuset %s\n",
778            nodeid, node_cpuset);
779        hwloc__insert_object_by_cpuset(topology, NULL, node, "x86:numa");
780        gotnuma++;
781      }
782    }
783    if (hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
784      if (fulldiscovery) {
785        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
786        hwloc_x86_add_groups(topology, infos, nbprocs, remaining_cpuset,
787  			   UNIT, "Compute Unit",
788  			   HWLOC_GROUP_KIND_AMD_COMPUTE_UNIT, 0);
789        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
790        hwloc_x86_add_groups(topology, infos, nbprocs, remaining_cpuset,
791  			   MODULE, "Module",
792  			   HWLOC_GROUP_KIND_INTEL_MODULE, 0);
793        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
794        hwloc_x86_add_groups(topology, infos, nbprocs, remaining_cpuset,
795  			   TILE, "Tile",
796  			   HWLOC_GROUP_KIND_INTEL_TILE, 0);
797        if (infos[one].otherids) {
798  	for (level = infos[one].levels-1; level <= infos[one].levels-1; level--) {
799  	  if (infos[one].otherids[level] != UINT_MAX) {
800  	    hwloc_bitmap_t unknown_cpuset;
801  	    hwloc_obj_t unknown_obj;
802  	    hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
803  	    while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
804  	      unsigned unknownid = infos[i].otherids[level];
805  	      unknown_cpuset = hwloc_bitmap_alloc();
806  	      for (j = i; j < nbprocs; j++) {
807  		if (infos[j].otherids[level] == unknownid) {
808  		  hwloc_bitmap_set(unknown_cpuset, j);
809  		  hwloc_bitmap_clr(remaining_cpuset, j);
810  		}
811  	      }
812  	      unknown_obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, unknownid);
813  	      unknown_obj->cpuset = unknown_cpuset;
814  	      unknown_obj->attr->group.kind = HWLOC_GROUP_KIND_INTEL_EXTTOPOENUM_UNKNOWN;
815  	      unknown_obj->attr->group.subkind = level;
816  	      hwloc_debug_2args_bitmap("os unknown%u %u has cpuset %s\n",
817  				       level, unknownid, unknown_cpuset);
818  	      hwloc__insert_object_by_cpuset(topology, NULL, unknown_obj, "x86:group:unknown");
819  	    }
820  	  }
821  	}
822        }
823      }
824    }
825    if (hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_DIE)) {
826      if (fulldiscovery) {
827        hwloc_bitmap_t die_cpuset;
828        hwloc_obj_t die;
829        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
830        while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
831  	unsigned packageid = infos[i].ids[PKG];
832  	unsigned dieid = infos[i].ids[DIE];
833  	if (dieid == (unsigned) -1) {
834  	  hwloc_bitmap_clr(remaining_cpuset, i);
835  	  continue;
836  	}
837  	die_cpuset = hwloc_bitmap_alloc();
838  	for (j = i; j < nbprocs; j++) {
839  	  if (infos[j].ids[DIE] == (unsigned) -1) {
840  	    hwloc_bitmap_clr(remaining_cpuset, j);
841  	    continue;
842  	  }
843  	  if (infos[j].ids[PKG] == packageid && infos[j].ids[DIE] == dieid) {
844  	    hwloc_bitmap_set(die_cpuset, j);
845  	    hwloc_bitmap_clr(remaining_cpuset, j);
846  	  }
847  	}
848  	die = hwloc_alloc_setup_object(topology, HWLOC_OBJ_DIE, dieid);
849  	die->cpuset = die_cpuset;
850  	hwloc_debug_1arg_bitmap("os die %u has cpuset %s\n",
851  				dieid, die_cpuset);
852  	hwloc__insert_object_by_cpuset(topology, NULL, die, "x86:die");
853        }
854      }
855    }
856    if (hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_CORE)) {
857      if (fulldiscovery) {
858        hwloc_bitmap_t core_cpuset;
859        hwloc_obj_t core;
860        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
861        while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
862  	unsigned packageid = infos[i].ids[PKG];
863  	unsigned nodeid = infos[i].ids[NODE];
864  	unsigned coreid = infos[i].ids[CORE];
865  	if (coreid == (unsigned) -1) {
866  	  hwloc_bitmap_clr(remaining_cpuset, i);
867  	  continue;
868  	}
869  	core_cpuset = hwloc_bitmap_alloc();
870  	for (j = i; j < nbprocs; j++) {
871  	  if (infos[j].ids[CORE] == (unsigned) -1) {
872  	    hwloc_bitmap_clr(remaining_cpuset, j);
873  	    continue;
874  	  }
875  	  if (infos[j].ids[PKG] == packageid && infos[j].ids[NODE] == nodeid && infos[j].ids[CORE] == coreid) {
876  	    hwloc_bitmap_set(core_cpuset, j);
877  	    hwloc_bitmap_clr(remaining_cpuset, j);
878  	  }
879  	}
880  	core = hwloc_alloc_setup_object(topology, HWLOC_OBJ_CORE, coreid);
881  	core->cpuset = core_cpuset;
882  	hwloc_debug_1arg_bitmap("os core %u has cpuset %s\n",
883  				coreid, core_cpuset);
884  	hwloc__insert_object_by_cpuset(topology, NULL, core, "x86:core");
885        }
886      }
887    }
888    if (fulldiscovery) {
889      hwloc_debug("%s", "\n\n * CPU cpusets *\n\n");
890      for (i=0; i<nbprocs; i++)
891        if(infos[i].present) { &bsol;* Only add present PU. We don't know if others actually exist */
892         struct hwloc_obj *obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PU, i);
893         obj->cpuset = hwloc_bitmap_alloc();
894         hwloc_bitmap_only(obj->cpuset, i);
895         hwloc_debug_1arg_bitmap("PU %u has cpuset %s\n", i, obj->cpuset);
896         hwloc__insert_object_by_cpuset(topology, NULL, obj, "x86:pu");
897       }
898    }
899    level = 0;
900    for (i = 0; i < nbprocs; i++)
901      for (j = 0; j < infos[i].numcaches; j++)
902        if (infos[i].cache[j].level > level)
903          level = infos[i].cache[j].level;
904    while (level > 0) {
905      hwloc_obj_cache_type_t type;
906      HWLOC_BUILD_ASSERT(HWLOC_OBJ_CACHE_DATA == HWLOC_OBJ_CACHE_UNIFIED+1);
907      HWLOC_BUILD_ASSERT(HWLOC_OBJ_CACHE_INSTRUCTION == HWLOC_OBJ_CACHE_DATA+1);
908      for (type = HWLOC_OBJ_CACHE_UNIFIED; type <= HWLOC_OBJ_CACHE_INSTRUCTION; type++) {
909        hwloc_obj_type_t otype;
910        hwloc_obj_t cache;
911        otype = hwloc_cache_type_by_depth_type(level, type);
912        if (otype == HWLOC_OBJ_TYPE_NONE)
913  	continue;
914        if (!hwloc_filter_check_keep_object_type(topology, otype))
915  	continue;
916        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
917        while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
918  	hwloc_bitmap_t puset;
919  	for (l = 0; l < infos[i].numcaches; l++) {
920  	  if (infos[i].cache[l].level == level && infos[i].cache[l].type == type)
921  	    break;
922  	}
923  	if (l == infos[i].numcaches) {
924  	  hwloc_bitmap_clr(remaining_cpuset, i);
925  	  continue;
926  	}
927  	puset = hwloc_bitmap_alloc();
928  	hwloc_bitmap_set(puset, i);
929  	cache = hwloc_get_next_obj_covering_cpuset_by_type(topology, puset, otype, NULL);
930  	hwloc_bitmap_free(puset);
931  	if (cache) {
932  	  if (!hwloc_obj_get_info_by_name(cache, "Inclusive"))
933  	    hwloc_obj_add_info(cache, "Inclusive", infos[i].cache[l].inclusive ? "1" : "0");
934  	  hwloc_bitmap_andnot(remaining_cpuset, remaining_cpuset, cache->cpuset);
935  	} else {
936  	  hwloc_bitmap_t cache_cpuset;
937  	  unsigned packageid = infos[i].ids[PKG];
938  	  unsigned cacheid = infos[i].cache[l].cacheid;
939  	  cache_cpuset = hwloc_bitmap_alloc();
940  	  for (j = i; j < nbprocs; j++) {
941  	    unsigned l2;
942  	    for (l2 = 0; l2 < infos[j].numcaches; l2++) {
943  	      if (infos[j].cache[l2].level == level && infos[j].cache[l2].type == type)
944  		break;
945  	    }
946  	    if (l2 == infos[j].numcaches) {
947  	      hwloc_bitmap_clr(remaining_cpuset, j);
948  	      continue;
949  	    }
950  	    if (infos[j].ids[PKG] == packageid && infos[j].cache[l2].cacheid == cacheid) {
951  	      hwloc_bitmap_set(cache_cpuset, j);
952  	      hwloc_bitmap_clr(remaining_cpuset, j);
953  	    }
954  	  }
955  	  cache = hwloc_alloc_setup_object(topology, otype, HWLOC_UNKNOWN_INDEX);
956  	  cache->attr->cache.depth = level;
957  	  cache->attr->cache.size = infos[i].cache[l].size;
958  	  cache->attr->cache.linesize = infos[i].cache[l].linesize;
959  	  cache->attr->cache.associativity = infos[i].cache[l].ways;
960  	  cache->attr->cache.type = infos[i].cache[l].type;
961  	  cache->cpuset = cache_cpuset;
962  	  hwloc_obj_add_info(cache, "Inclusive", infos[i].cache[l].inclusive ? "1" : "0");
963  	  hwloc_debug_2args_bitmap("os L%u cache %u has cpuset %s\n",
964  				   level, cacheid, cache_cpuset);
965  	  hwloc__insert_object_by_cpuset(topology, NULL, cache, "x86:cache");
966  	}
967        }
968      }
969      level--;
970    }
971    hwloc_bitmap_free(remaining_cpuset);
972    hwloc_bitmap_free(complete_cpuset);
973    if (gotnuma)
974      topology->support.discovery->numa = 1;
975  }
976  static int
977  look_procs(struct hwloc_backend *backend, struct procinfo *infos, unsigned long flags,
978  	   unsigned highest_cpuid, unsigned highest_ext_cpuid, unsigned *features, enum cpuid_type cpuid_type,
979  	   int (*get_cpubind)(hwloc_topology_t topology, hwloc_cpuset_t set, int flags),
980  	   int (*set_cpubind)(hwloc_topology_t topology, hwloc_const_cpuset_t set, int flags),
981             hwloc_bitmap_t restrict_set)
982  {
983    struct hwloc_x86_backend_data_s *data = backend->private_data;
984    struct hwloc_topology *topology = backend->topology;
985    unsigned nbprocs = data->nbprocs;
986    hwloc_bitmap_t orig_cpuset = NULL;
987    hwloc_bitmap_t set = NULL;
988    unsigned i;
989    if (!data->src_cpuiddump_path) {
990      orig_cpuset = hwloc_bitmap_alloc();
991      if (get_cpubind(topology, orig_cpuset, HWLOC_CPUBIND_STRICT)) {
992        hwloc_bitmap_free(orig_cpuset);
993        return -1;
994      }
995      set = hwloc_bitmap_alloc();
996    }
997    for (i = 0; i < nbprocs; i++) {
998      struct cpuiddump *src_cpuiddump = NULL;
999      if (restrict_set && !hwloc_bitmap_isset(restrict_set, i)) {
1000        continue;
1001      }
1002      if (data->src_cpuiddump_path) {
1003        src_cpuiddump = cpuiddump_read(data->src_cpuiddump_path, i);
1004        if (!src_cpuiddump)
1005  	continue;
1006      } else {
1007        hwloc_bitmap_only(set, i);
1008        hwloc_debug("binding to CPU%u\n", i);
1009        if (set_cpubind(topology, set, HWLOC_CPUBIND_STRICT)) {
1010  	hwloc_debug("could not bind to CPU%u: %s\n", i, strerror(errno));
1011  	continue;
1012        }
1013      }
1014      look_proc(backend, &infos[i], flags, highest_cpuid, highest_ext_cpuid, features, cpuid_type, src_cpuiddump);
1015      if (data->src_cpuiddump_path) {
1016        cpuiddump_free(src_cpuiddump);
1017      }
1018    }
1019    if (!data->src_cpuiddump_path) {
1020      set_cpubind(topology, orig_cpuset, 0);
1021      hwloc_bitmap_free(set);
1022      hwloc_bitmap_free(orig_cpuset);
1023    }
1024    if (data->apicid_unique) {
1025      summarize(backend, infos, flags);
1026      if (has_hybrid(features) && !(topology->flags & HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS)) {
1027        hwloc_bitmap_t atomset = hwloc_bitmap_alloc();
1028        hwloc_bitmap_t coreset = hwloc_bitmap_alloc();
1029        for(i=0; i<nbprocs; i++) {
1030          if (infos[i].hybridcoretype == 0x20)
1031            hwloc_bitmap_set(atomset, i);
1032          else if (infos[i].hybridcoretype == 0x40)
1033            hwloc_bitmap_set(coreset, i);
1034        }
1035        if (!hwloc_bitmap_iszero(atomset)) {
1036          struct hwloc_info_s infoattr;
1037          infoattr.name = (char *) "CoreType";
1038          infoattr.value = (char *) "IntelAtom";
1039          hwloc_internal_cpukinds_register(topology, atomset, HWLOC_CPUKIND_EFFICIENCY_UNKNOWN, &infoattr, 1, 0);
1040        } else {
1041          hwloc_bitmap_free(atomset);
1042        }
1043        if (!hwloc_bitmap_iszero(coreset)) {
1044          struct hwloc_info_s infoattr;
1045          infoattr.name = (char *) "CoreType";
1046          infoattr.value = (char *) "IntelCore";
1047          hwloc_internal_cpukinds_register(topology, coreset, HWLOC_CPUKIND_EFFICIENCY_UNKNOWN, &infoattr, 1, 0);
1048        } else {
1049          hwloc_bitmap_free(coreset);
1050        }
1051      }
1052    }
1053    return 0;
1054  }
1055  #if defined HWLOC_FREEBSD_SYS && defined HAVE_CPUSET_SETID
1056  #include <sys/param.h>
1057  #include <sys/cpuset.h>
1058  typedef cpusetid_t hwloc_x86_os_state_t;
1059  static void hwloc_x86_os_state_save(hwloc_x86_os_state_t *state, struct cpuiddump *src_cpuiddump)
1060  {
1061    if (!src_cpuiddump) {
1062      cpuset_getid(CPU_LEVEL_CPUSET, CPU_WHICH_PID, -1, state);
1063      cpuset_setid(CPU_WHICH_PID, -1, 0);
1064    }
1065  }
1066  static void hwloc_x86_os_state_restore(hwloc_x86_os_state_t *state, struct cpuiddump *src_cpuiddump)
1067  {
1068    if (!src_cpuiddump) {
1069      cpuset_setid(CPU_WHICH_PID, -1, *state);
1070    }
1071  }
1072  #else &bsol;* !defined HWLOC_FREEBSD_SYS || !defined HAVE_CPUSET_SETID */
1073  typedef void * hwloc_x86_os_state_t;
1074  static void hwloc_x86_os_state_save(hwloc_x86_os_state_t *state __hwloc_attribute_unused, struct cpuiddump *src_cpuiddump __hwloc_attribute_unused) { }
1075  static void hwloc_x86_os_state_restore(hwloc_x86_os_state_t *state __hwloc_attribute_unused, struct cpuiddump *src_cpuiddump __hwloc_attribute_unused) { }
1076  #endif &bsol;* !defined HWLOC_FREEBSD_SYS || !defined HAVE_CPUSET_SETID */
1077  #define INTEL_EBX ('G' | ('e'<<8) | ('n'<<16) | ('u'<<24))
1078  #define INTEL_EDX ('i' | ('n'<<8) | ('e'<<16) | ('I'<<24))
1079  #define INTEL_ECX ('n' | ('t'<<8) | ('e'<<16) | ('l'<<24))
1080  #define AMD_EBX ('A' | ('u'<<8) | ('t'<<16) | ('h'<<24))
1081  #define AMD_EDX ('e' | ('n'<<8) | ('t'<<16) | ('i'<<24))
1082  #define AMD_ECX ('c' | ('A'<<8) | ('M'<<16) | ('D'<<24))
1083  #define HYGON_EBX ('H' | ('y'<<8) | ('g'<<16) | ('o'<<24))
1084  #define HYGON_EDX ('n' | ('G'<<8) | ('e'<<16) | ('n'<<24))
1085  #define HYGON_ECX ('u' | ('i'<<8) | ('n'<<16) | ('e'<<24))
1086  #define ZX_EBX ('C' | ('e'<<8) | ('n'<<16) | ('t'<<24))
1087  #define ZX_EDX ('a' | ('u'<<8) | ('r'<<16) | ('H'<<24))
1088  #define ZX_ECX ('a' | ('u'<<8) | ('l'<<16) | ('s'<<24))
1089  #define SH_EBX (' ' | (' '<<8) | ('S'<<16) | ('h'<<24))
1090  #define SH_EDX ('a' | ('n'<<8) | ('g'<<16) | ('h'<<24))
1091  #define SH_ECX ('a' | ('i'<<8) | (' '<<16) | (' '<<24))
1092  static int fake_get_cpubind(hwloc_topology_t topology __hwloc_attribute_unused,
1093  			    hwloc_cpuset_t set __hwloc_attribute_unused,
1094  			    int flags __hwloc_attribute_unused)
1095  {
1096    return 0;
1097  }
1098  static int fake_set_cpubind(hwloc_topology_t topology __hwloc_attribute_unused,
1099  			    hwloc_const_cpuset_t set __hwloc_attribute_unused,
1100  			    int flags __hwloc_attribute_unused)
1101  {
1102    return 0;
1103  }
1104  static
1105  int hwloc_look_x86(struct hwloc_backend *backend, unsigned long flags)
1106  {
1107    struct hwloc_x86_backend_data_s *data = backend->private_data;
1108    struct hwloc_topology *topology = backend->topology;
1109    unsigned nbprocs = data->nbprocs;
1110    unsigned eax, ebx, ecx = 0, edx;
1111    unsigned i;
1112    unsigned highest_cpuid;
1113    unsigned highest_ext_cpuid;
1114    unsigned features[19] = { 0 };
1115    struct procinfo *infos = NULL;
1116    enum cpuid_type cpuid_type = unknown;
1117    hwloc_x86_os_state_t os_state;
1118    struct hwloc_binding_hooks hooks;
1119    struct hwloc_topology_support support;
1120    struct hwloc_topology_membind_support memsupport __hwloc_attribute_unused;
1121    int (*get_cpubind)(hwloc_topology_t topology, hwloc_cpuset_t set, int flags) = NULL;
1122    int (*set_cpubind)(hwloc_topology_t topology, hwloc_const_cpuset_t set, int flags) = NULL;
1123    hwloc_bitmap_t restrict_set = NULL;
1124    struct cpuiddump *src_cpuiddump = NULL;
1125    int ret = -1;
1126    memset(&hooks, 0, sizeof(hooks));
1127    support.membind = &memsupport;
1128    hwloc_set_native_binding_hooks(&hooks, &support);
1129    if (data->src_cpuiddump_path) {
1130      src_cpuiddump = cpuiddump_read(data->src_cpuiddump_path, 0);
1131      if (!src_cpuiddump)
1132        goto out;
1133    } else {
1134      if (hooks.get_thisthread_cpubind && hooks.set_thisthread_cpubind) {
1135        get_cpubind = hooks.get_thisthread_cpubind;
1136        set_cpubind = hooks.set_thisthread_cpubind;
1137      } else if (hooks.get_thisproc_cpubind && hooks.set_thisproc_cpubind) {
1138        get_cpubind = hooks.get_thisproc_cpubind;
1139        set_cpubind = hooks.set_thisproc_cpubind;
1140      } else {
1141        if (nbprocs > 1)
1142  	goto out;
1143        get_cpubind = fake_get_cpubind;
1144        set_cpubind = fake_set_cpubind;
1145      }
1146    }
1147    if (topology->flags & HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING) {
1148      restrict_set = hwloc_bitmap_alloc();
1149      if (!restrict_set)
1150        goto out;
1151      if (hooks.get_thisproc_cpubind)
1152        hooks.get_thisproc_cpubind(topology, restrict_set, 0);
1153      else if (hooks.get_thisthread_cpubind)
1154        hooks.get_thisthread_cpubind(topology, restrict_set, 0);
1155      if (hwloc_bitmap_iszero(restrict_set)) {
1156        hwloc_bitmap_free(restrict_set);
1157        restrict_set = NULL;
1158      }
1159    }
1160    if (!src_cpuiddump && !hwloc_have_x86_cpuid())
1161      goto out;
1162    infos = calloc(nbprocs, sizeof(struct procinfo));
1163    if (NULL == infos)
1164      goto out;
1165    for (i = 0; i < nbprocs; i++) {
1166      infos[i].ids[PKG] = (unsigned) -1;
1167      infos[i].ids[CORE] = (unsigned) -1;
1168      infos[i].ids[NODE] = (unsigned) -1;
1169      infos[i].ids[UNIT] = (unsigned) -1;
1170      infos[i].ids[TILE] = (unsigned) -1;
1171      infos[i].ids[MODULE] = (unsigned) -1;
1172      infos[i].ids[DIE] = (unsigned) -1;
1173    }
1174    eax = 0x00;
1175    cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
1176    highest_cpuid = eax;
1177    if (ebx == INTEL_EBX && ecx == INTEL_ECX && edx == INTEL_EDX)
1178      cpuid_type = intel;
1179    else if (ebx == AMD_EBX && ecx == AMD_ECX && edx == AMD_EDX)
1180      cpuid_type = amd;
1181    else if ((ebx == ZX_EBX && ecx == ZX_ECX && edx == ZX_EDX)
1182  	   || (ebx == SH_EBX && ecx == SH_ECX && edx == SH_EDX))
1183      cpuid_type = zhaoxin;
1184    else if (ebx == HYGON_EBX && ecx == HYGON_ECX && edx == HYGON_EDX)
1185      cpuid_type = hygon;
1186    hwloc_debug("highest cpuid %x, cpuid type %u\n", highest_cpuid, cpuid_type);
1187    if (highest_cpuid < 0x01) {
1188        goto out_with_infos;
1189    }
1190    eax = 0x01;
1191    cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
1192    features[0] = edx;
1193    features[4] = ecx;
1194    eax = 0x80000000;
1195    cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
1196    highest_ext_cpuid = eax;
1197    hwloc_debug("highest extended cpuid %x\n", highest_ext_cpuid);
1198    if (highest_cpuid >= 0x7) {
1199      eax = 0x7;
1200      ecx = 0;
1201      cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
1202      features[9] = ebx;
1203      features[18] = edx;
1204    }
1205    if (cpuid_type != intel && highest_ext_cpuid >= 0x80000001) {
1206      eax = 0x80000001;
1207      cpuid_or_from_dump(&eax, &ebx, &ecx, &edx, src_cpuiddump);
1208      features[1] = edx;
1209      features[6] = ecx;
1210    }
1211    hwloc_x86_os_state_save(&os_state, src_cpuiddump);
1212    ret = look_procs(backend, infos, flags,
1213  		   highest_cpuid, highest_ext_cpuid, features, cpuid_type,
1214  		   get_cpubind, set_cpubind, restrict_set);
1215    if (!ret)
1216      goto out_with_os_state;
1217    if (nbprocs == 1) {
1218      look_proc(backend, &infos[0], flags, highest_cpuid, highest_ext_cpuid, features, cpuid_type, src_cpuiddump);
1219      summarize(backend, infos, flags);
1220      ret = 0;
1221    }
1222  out_with_os_state:
1223    hwloc_x86_os_state_restore(&os_state, src_cpuiddump);
1224  out_with_infos:
1225    if (NULL != infos) {
1226      for (i = 0; i < nbprocs; i++) {
1227        free(infos[i].cache);
1228        free(infos[i].otherids);
1229      }
1230      free(infos);
1231    }
1232  out:
1233    hwloc_bitmap_free(restrict_set);
1234    if (src_cpuiddump)
1235      cpuiddump_free(src_cpuiddump);
1236    return ret;
1237  }
1238  static int
1239  hwloc_x86_discover(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
1240  {
1241    struct hwloc_x86_backend_data_s *data = backend->private_data;
1242    struct hwloc_topology *topology = backend->topology;
1243    unsigned long flags = 0;
1244    int alreadypus = 0;
1245    int ret;
1246    assert(dstatus->phase == HWLOC_DISC_PHASE_CPU);
1247    if (topology->flags & HWLOC_TOPOLOGY_FLAG_DONT_CHANGE_BINDING) {
1248      return 0;
1249    }
1250    if (getenv("HWLOC_X86_TOPOEXT_NUMANODES")) {
1251      flags |= HWLOC_X86_DISC_FLAG_TOPOEXT_NUMANODES;
1252    }
1253  #if HAVE_DECL_RUNNING_ON_VALGRIND
1254    if (RUNNING_ON_VALGRIND && !data->src_cpuiddump_path) {
1255      fprintf(stderr, "hwloc x86 backend cannot work under Valgrind, disabling.\n"
1256  	    "May be reenabled by dumping CPUIDs with hwloc-gather-cpuid\n"
1257  	    "and reloading them under Valgrind with HWLOC_CPUID_PATH.\n");
1258      return 0;
1259    }
1260  #endif
1261    if (data->src_cpuiddump_path) {
1262      assert(data->nbprocs > 0); &bsol;* enforced by hwloc_x86_component_instantiate() */
1263      topology->support.discovery->pu = 1;
1264    } else {
1265      int nbprocs = hwloc_fallback_nbprocessors(HWLOC_FALLBACK_NBPROCESSORS_INCLUDE_OFFLINE);
1266      if (nbprocs >= 1)
1267        topology->support.discovery->pu = 1;
1268      else
1269        nbprocs = 1;
1270      data->nbprocs = (unsigned) nbprocs;
1271    }
1272    if (topology->levels[0][0]->cpuset) {
1273      hwloc_topology_reconnect(topology, 0);
1274      if (topology->nb_levels == 2 && topology->level_nbobjects[1] == data->nbprocs) {
1275        alreadypus = 1;
1276        goto fulldiscovery;
1277      }
1278      ret = hwloc_look_x86(backend, flags);
1279      if (ret)
1280        hwloc_obj_add_info(topology->levels[0][0], "Backend", "x86");
1281      return 0;
1282    } else {
1283      hwloc_alloc_root_sets(topology->levels[0][0]);
1284    }
1285  fulldiscovery:
1286    if (hwloc_look_x86(backend, flags | HWLOC_X86_DISC_FLAG_FULL) < 0) {
1287      if (!alreadypus)
1288        hwloc_setup_pu_level(topology, data->nbprocs);
1289    }
1290    hwloc_obj_add_info(topology->levels[0][0], "Backend", "x86");
1291    if (!data->src_cpuiddump_path) { &bsol;* CPUID dump works for both x86 and x86_64 */
1292  #ifdef HAVE_UNAME
1293      hwloc_add_uname_info(topology, NULL); &bsol;* we already know is_thissystem() is true */
1294  #else
1295  #ifdef HWLOC_X86_64_ARCH
1296      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "x86_64");
1297  #else
1298      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "x86");
1299  #endif
1300  #endif
1301    }
1302    return 1;
1303  }
1304  static int
1305  hwloc_x86_check_cpuiddump_input(const char *src_cpuiddump_path, hwloc_bitmap_t set)
1306  {
1307  #if !(defined HWLOC_WIN_SYS && !defined __MINGW32__ && !defined __CYGWIN__) &bsol;* needs a lot of work */
1308    struct dirent *dirent;
1309    DIR *dir;
1310    char *path;
1311    FILE *file;
1312    char line [32];
1313    dir = opendir(src_cpuiddump_path);
1314    if (!dir) 
1315      return -1;
1316    path = malloc(strlen(src_cpuiddump_path) + strlen("/hwloc-cpuid-info") + 1);
1317    if (!path)
1318      goto out_with_dir;
1319    sprintf(path, "%s/hwloc-cpuid-info", src_cpuiddump_path);
1320    file = fopen(path, "r");
1321    if (!file) {
1322      fprintf(stderr, "Couldn't open dumped cpuid summary %s\n", path);
1323      goto out_with_path;
1324    }
1325    if (!fgets(line, sizeof(line), file)) {
1326      fprintf(stderr, "Found read dumped cpuid summary in %s\n", path);
1327      fclose(file);
1328      goto out_with_path;
1329    }
1330    fclose(file);
1331    if (strcmp(line, "Architecture: x86\n")) {
1332      fprintf(stderr, "Found non-x86 dumped cpuid summary in %s: %s\n", path, line);
1333      goto out_with_path;
1334    }
1335    free(path);
1336    while ((dirent = readdir(dir)) != NULL) {
1337      if (!strncmp(dirent->d_name, "pu", 2)) {
1338        char *end;
1339        unsigned long idx = strtoul(dirent->d_name+2, &end, 10);
1340        if (!*end)
1341  	hwloc_bitmap_set(set, idx);
1342        else
1343  	fprintf(stderr, "Ignoring invalid dirent `%s' in dumped cpuid directory `%s'\n",
1344  		dirent->d_name, src_cpuiddump_path);
1345      }
1346    }
1347    closedir(dir);
1348    if (hwloc_bitmap_iszero(set)) {
1349      fprintf(stderr, "Did not find any valid pu%%u entry in dumped cpuid directory `%s'\n",
1350  	    src_cpuiddump_path);
1351      return -1;
1352    } else if (hwloc_bitmap_last(set) != hwloc_bitmap_weight(set) - 1) {
1353      fprintf(stderr, "Found non-contigous pu%%u range in dumped cpuid directory `%s'\n",
1354  	    src_cpuiddump_path);
1355      return -1;
1356    }
1357    return 0;
1358   out_with_path:
1359    free(path);
1360   out_with_dir:
1361    closedir(dir);
1362  #endif &bsol;* HWLOC_WIN_SYS & !__MINGW32__ needs a lot of work */
1363    return -1;
1364  }
1365  static void
1366  hwloc_x86_backend_disable(struct hwloc_backend *backend)
1367  {
1368    struct hwloc_x86_backend_data_s *data = backend->private_data;
1369    hwloc_bitmap_free(data->apicid_set);
1370    free(data->src_cpuiddump_path);
1371    free(data);
1372  }
1373  static struct hwloc_backend *
1374  hwloc_x86_component_instantiate(struct hwloc_topology *topology,
1375  				struct hwloc_disc_component *component,
1376  				unsigned excluded_phases __hwloc_attribute_unused,
1377  				const void *_data1 __hwloc_attribute_unused,
1378  				const void *_data2 __hwloc_attribute_unused,
1379  				const void *_data3 __hwloc_attribute_unused)
1380  {
1381    struct hwloc_backend *backend;
1382    struct hwloc_x86_backend_data_s *data;
1383    const char *src_cpuiddump_path;
1384    backend = hwloc_backend_alloc(topology, component);
1385    if (!backend)
1386      goto out;
1387    data = malloc(sizeof(*data));
1388    if (!data) {
1389      errno = ENOMEM;
1390      goto out_with_backend;
1391    }
1392    backend->private_data = data;
1393    backend->discover = hwloc_x86_discover;
1394    backend->disable = hwloc_x86_backend_disable;
1395    data->is_knl = 0;
1396    data->apicid_set = hwloc_bitmap_alloc();
1397    data->apicid_unique = 1;
1398    data->src_cpuiddump_path = NULL;
1399    src_cpuiddump_path = getenv("HWLOC_CPUID_PATH");
1400    if (src_cpuiddump_path) {
1401      hwloc_bitmap_t set = hwloc_bitmap_alloc();
1402      if (!hwloc_x86_check_cpuiddump_input(src_cpuiddump_path, set)) {
1403        backend->is_thissystem = 0;
1404        data->src_cpuiddump_path = strdup(src_cpuiddump_path);
1405        assert(!hwloc_bitmap_iszero(set)); &bsol;* enforced by hwloc_x86_check_cpuiddump_input() */
1406        data->nbprocs = hwloc_bitmap_weight(set);
1407      } else {
1408        fprintf(stderr, "Ignoring dumped cpuid directory.\n");
1409      }
1410      hwloc_bitmap_free(set);
1411    }
1412    return backend;
1413   out_with_backend:
1414    free(backend);
1415   out:
1416    return NULL;
1417  }
1418  static struct hwloc_disc_component hwloc_x86_disc_component = {
1419    "x86",
1420    HWLOC_DISC_PHASE_CPU,
1421    HWLOC_DISC_PHASE_GLOBAL,
1422    hwloc_x86_component_instantiate,
1423    45, &bsol;* between native and no_os */
1424    1,
1425    NULL
1426  };
1427  const struct hwloc_component hwloc_x86_component = {
1428    HWLOC_COMPONENT_ABI,
1429    NULL, NULL,
1430    HWLOC_COMPONENT_TYPE_DISC,
1431    0,
1432    &hwloc_x86_disc_component
1433  };
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf52833.h</h3>
            <pre><code>1  #ifndef NRF52833_H
2  #define NRF52833_H
3  #ifdef __cplusplus
4  extern "C" {
5  #endif
6  typedef enum {
7    Reset_IRQn                = -15,              &bsol;*!< -15  Reset Vector, invoked on Power up and warm reset                     */
8    NonMaskableInt_IRQn       = -14,              &bsol;*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
9    HardFault_IRQn            = -13,              &bsol;*!< -13  Hard Fault, all classes of Fault                                     */
10    MemoryManagement_IRQn     = -12,              &bsol;*!< -12  Memory Management, MPU mismatch, including Access Violation
11                                                       and No Match                                                              */
12    BusFault_IRQn             = -11,              &bsol;*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
13                                                       related Fault                                                             */
14    UsageFault_IRQn           = -10,              &bsol;*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
15    SVCall_IRQn               =  -5,              &bsol;*!< -5 System Service Call via SVC instruction                                */
16    DebugMonitor_IRQn         =  -4,              &bsol;*!< -4 Debug Monitor                                                          */
17    PendSV_IRQn               =  -2,              &bsol;*!< -2 Pendable request for system service                                    */
18    SysTick_IRQn              =  -1,              &bsol;*!< -1 System Tick Timer                                                      */
19    POWER_CLOCK_IRQn          =   0,              &bsol;*!< 0  POWER_CLOCK                                                            */
20    RADIO_IRQn                =   1,              &bsol;*!< 1  RADIO                                                                  */
21    UARTE0_UART0_IRQn         =   2,              &bsol;*!< 2  UARTE0_UART0                                                           */
22    SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn=   3,  &bsol;*!< 3  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0                                      */
23    SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQn=   4,  &bsol;*!< 4  SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1                                      */
24    NFCT_IRQn                 =   5,              &bsol;*!< 5  NFCT                                                                   */
25    GPIOTE_IRQn               =   6,              &bsol;*!< 6  GPIOTE                                                                 */
26    SAADC_IRQn                =   7,              &bsol;*!< 7  SAADC                                                                  */
27    TIMER0_IRQn               =   8,              &bsol;*!< 8  TIMER0                                                                 */
28    TIMER1_IRQn               =   9,              &bsol;*!< 9  TIMER1                                                                 */
29    TIMER2_IRQn               =  10,              &bsol;*!< 10 TIMER2                                                                 */
30    RTC0_IRQn                 =  11,              &bsol;*!< 11 RTC0                                                                   */
31    TEMP_IRQn                 =  12,              &bsol;*!< 12 TEMP                                                                   */
32    RNG_IRQn                  =  13,              &bsol;*!< 13 RNG                                                                    */
33    ECB_IRQn                  =  14,              &bsol;*!< 14 ECB                                                                    */
34    CCM_AAR_IRQn              =  15,              &bsol;*!< 15 CCM_AAR                                                                */
35    WDT_IRQn                  =  16,              &bsol;*!< 16 WDT                                                                    */
36    RTC1_IRQn                 =  17,              &bsol;*!< 17 RTC1                                                                   */
37    QDEC_IRQn                 =  18,              &bsol;*!< 18 QDEC                                                                   */
38    COMP_LPCOMP_IRQn          =  19,              &bsol;*!< 19 COMP_LPCOMP                                                            */
39    SWI0_EGU0_IRQn            =  20,              &bsol;*!< 20 SWI0_EGU0                                                              */
40    SWI1_EGU1_IRQn            =  21,              &bsol;*!< 21 SWI1_EGU1                                                              */
41    SWI2_EGU2_IRQn            =  22,              &bsol;*!< 22 SWI2_EGU2                                                              */
42    SWI3_EGU3_IRQn            =  23,              &bsol;*!< 23 SWI3_EGU3                                                              */
43    SWI4_EGU4_IRQn            =  24,              &bsol;*!< 24 SWI4_EGU4                                                              */
44    SWI5_EGU5_IRQn            =  25,              &bsol;*!< 25 SWI5_EGU5                                                              */
45    TIMER3_IRQn               =  26,              &bsol;*!< 26 TIMER3                                                                 */
46    TIMER4_IRQn               =  27,              &bsol;*!< 27 TIMER4                                                                 */
47    PWM0_IRQn                 =  28,              &bsol;*!< 28 PWM0                                                                   */
48    PDM_IRQn                  =  29,              &bsol;*!< 29 PDM                                                                    */
49    MWU_IRQn                  =  32,              &bsol;*!< 32 MWU                                                                    */
50    PWM1_IRQn                 =  33,              &bsol;*!< 33 PWM1                                                                   */
51    PWM2_IRQn                 =  34,              &bsol;*!< 34 PWM2                                                                   */
52    SPIM2_SPIS2_SPI2_IRQn     =  35,              &bsol;*!< 35 SPIM2_SPIS2_SPI2                                                       */
53    RTC2_IRQn                 =  36,              &bsol;*!< 36 RTC2                                                                   */
54    I2S_IRQn                  =  37,              &bsol;*!< 37 I2S                                                                    */
55    FPU_IRQn                  =  38,              &bsol;*!< 38 FPU                                                                    */
56    USBD_IRQn                 =  39,              &bsol;*!< 39 USBD                                                                   */
57    UARTE1_IRQn               =  40,              &bsol;*!< 40 UARTE1                                                                 */
58    PWM3_IRQn                 =  45,              &bsol;*!< 45 PWM3                                                                   */
59    SPIM3_IRQn                =  47               &bsol;*!< 47 SPIM3                                                                  */
60  } IRQn_Type;
61  #define __CM4_REV                 0x0001U       &bsol;*!< CM4 Core Revision                                                         */
62  #define __DSP_PRESENT                  0        &bsol;*!< DSP present or not                                                        */
63  #define __VTOR_PRESENT                 1        &bsol;*!< Set to 1 if CPU supports Vector Table Offset Register                     */
64  #define __NVIC_PRIO_BITS               3        &bsol;*!< Number of Bits used for Priority Levels                                   */
65  #define __Vendor_SysTickConfig         0        &bsol;*!< Set to 1 if different SysTick Config is used                              */
66  #define __MPU_PRESENT                  1        &bsol;*!< MPU present                                                               */
67  #define __FPU_PRESENT                  1        &bsol;*!< FPU present                                                               */
68  #include "core_cm4.h"                           &bsol;*!< ARM Cortex-M4 processor and core peripherals                              */
69  #include "system_nrf52833.h"                    &bsol;*!< nrf52833 System                                                           */
70  #ifndef __IM                                    &bsol;*!< Fallback for older CMSIS versions                                         */
71    #define __IM   __I
72  #endif
73  #ifndef __OM                                    &bsol;*!< Fallback for older CMSIS versions                                         */
74    #define __OM   __O
75  #endif
76  #ifndef __IOM                                   &bsol;*!< Fallback for older CMSIS versions                                         */
77    #define __IOM  __IO
78  #endif
79  #if defined (__CC_ARM)
80    #pragma push
81    #pragma anon_unions
82  #elif defined (__ICCARM__)
83    #pragma language=extended
84  #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
85    #pragma clang diagnostic push
86    #pragma clang diagnostic ignored "-Wc11-extensions"
87    #pragma clang diagnostic ignored "-Wreserved-id-macro"
88    #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
89    #pragma clang diagnostic ignored "-Wnested-anon-types"
90  #elif defined (__GNUC__)
91  #elif defined (__TMS470__)
92  #elif defined (__TASKING__)
93    #pragma warning 586
94  #elif defined (__CSMC__)
95  #else
96    #warning Not supported compiler type
97  #endif
98  typedef struct {
99    __IM  uint32_t  PART;                         &bsol;*!< (@ 0x00000000) Part code                                                  */
100    __IM  uint32_t  VARIANT;                      &bsol;*!< (@ 0x00000004) Build code (hardware version and production configuration) */
101    __IM  uint32_t  PACKAGE;                      &bsol;*!< (@ 0x00000008) Package option                                             */
102    __IM  uint32_t  RAM;                          &bsol;*!< (@ 0x0000000C) RAM variant                                                */
103    __IM  uint32_t  FLASH;                        &bsol;*!< (@ 0x00000010) Flash variant                                              */
104  } FICR_INFO_Type;                               &bsol;*!< Size = 20 (0x14)                                                          */
105  typedef struct {
106    __IM  uint32_t  A0;                           &bsol;*!< (@ 0x00000000) Slope definition A0                                        */
107    __IM  uint32_t  A1;                           &bsol;*!< (@ 0x00000004) Slope definition A1                                        */
108    __IM  uint32_t  A2;                           &bsol;*!< (@ 0x00000008) Slope definition A2                                        */
109    __IM  uint32_t  A3;                           &bsol;*!< (@ 0x0000000C) Slope definition A3                                        */
110    __IM  uint32_t  A4;                           &bsol;*!< (@ 0x00000010) Slope definition A4                                        */
111    __IM  uint32_t  A5;                           &bsol;*!< (@ 0x00000014) Slope definition A5                                        */
112    __IM  uint32_t  B0;                           &bsol;*!< (@ 0x00000018) Y-intercept B0                                             */
113    __IM  uint32_t  B1;                           &bsol;*!< (@ 0x0000001C) Y-intercept B1                                             */
114    __IM  uint32_t  B2;                           &bsol;*!< (@ 0x00000020) Y-intercept B2                                             */
115    __IM  uint32_t  B3;                           &bsol;*!< (@ 0x00000024) Y-intercept B3                                             */
116    __IM  uint32_t  B4;                           &bsol;*!< (@ 0x00000028) Y-intercept B4                                             */
117    __IM  uint32_t  B5;                           &bsol;*!< (@ 0x0000002C) Y-intercept B5                                             */
118    __IM  uint32_t  T0;                           &bsol;*!< (@ 0x00000030) Segment end T0                                             */
119    __IM  uint32_t  T1;                           &bsol;*!< (@ 0x00000034) Segment end T1                                             */
120    __IM  uint32_t  T2;                           &bsol;*!< (@ 0x00000038) Segment end T2                                             */
121    __IM  uint32_t  T3;                           &bsol;*!< (@ 0x0000003C) Segment end T3                                             */
122    __IM  uint32_t  T4;                           &bsol;*!< (@ 0x00000040) Segment end T4                                             */
123  } FICR_TEMP_Type;                               &bsol;*!< Size = 68 (0x44)                                                          */
124  typedef struct {
125    __IM  uint32_t  TAGHEADER0;                   &bsol;*!< (@ 0x00000000) Default header for NFC tag. Software can read
126                                                                      these values to populate NFCID1_3RD_LAST,
127                                                                      NFCID1_2ND_LAST, and NFCID1_LAST.                          */
128    __IM  uint32_t  TAGHEADER1;                   &bsol;*!< (@ 0x00000004) Default header for NFC tag. Software can read
129                                                                      these values to populate NFCID1_3RD_LAST,
130                                                                      NFCID1_2ND_LAST, and NFCID1_LAST.                          */
131    __IM  uint32_t  TAGHEADER2;                   &bsol;*!< (@ 0x00000008) Default header for NFC tag. Software can read
132                                                                      these values to populate NFCID1_3RD_LAST,
133                                                                      NFCID1_2ND_LAST, and NFCID1_LAST.                          */
134    __IM  uint32_t  TAGHEADER3;                   &bsol;*!< (@ 0x0000000C) Default header for NFC tag. Software can read
135                                                                      these values to populate NFCID1_3RD_LAST,
136                                                                      NFCID1_2ND_LAST, and NFCID1_LAST.                          */
137  } FICR_NFC_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
138  typedef struct {
139    __IOM uint32_t  POWER;                        &bsol;*!< (@ 0x00000000) Description cluster: RAMn power control register           */
140    __OM  uint32_t  POWERSET;                     &bsol;*!< (@ 0x00000004) Description cluster: RAMn power control set register       */
141    __OM  uint32_t  POWERCLR;                     &bsol;*!< (@ 0x00000008) Description cluster: RAMn power control clear
142                                                                      register                                                   */
143    __IM  uint32_t  RESERVED;
144  } POWER_RAM_Type;                               &bsol;*!< Size = 16 (0x10)                                                          */
145  typedef struct {
146    __IOM uint32_t  DFEGPIO[8];                   &bsol;*!< (@ 0x00000000) Description collection: Pin select for DFE pin
147                                                                      n                                                          */
148  } RADIO_PSEL_Type;                              &bsol;*!< Size = 32 (0x20)                                                          */
149  typedef struct {
150    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
151    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of buffer words to transfer                 */
152    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of samples transferred in the last transaction      */
<span onclick='openModal()' class='match'>153  } RADIO_DFEPACKET_Type;                         &bsol;*!< Size = 12 (0xc)                                                           */
154  typedef struct {
155    __IOM uint32_t  RTS;                          &bsol;*!< (@ 0x00000000) Pin select for RTS                                         */
156    __IOM uint32_t  TXD;                          &bsol;*!< (@ 0x00000004) Pin select for TXD                                         */
157    __IOM uint32_t  CTS;                          &bsol;*!< (@ 0x00000008) Pin select for CTS                                         */
158    __IOM uint32_t  RXD;                          &bsol;*!< (@ 0x0000000C) Pin select for RXD                                         */
</span>159  } UART_PSEL_Type;                               &bsol;*!< Size = 16 (0x10)                                                          */
160  typedef struct {
161    __IOM uint32_t  RTS;                          &bsol;*!< (@ 0x00000000) Pin select for RTS signal                                  */
162    __IOM uint32_t  TXD;                          &bsol;*!< (@ 0x00000004) Pin select for TXD signal                                  */
163    __IOM uint32_t  CTS;                          &bsol;*!< (@ 0x00000008) Pin select for CTS signal                                  */
164    __IOM uint32_t  RXD;                          &bsol;*!< (@ 0x0000000C) Pin select for RXD signal                                  */
165  } UARTE_PSEL_Type;                              &bsol;*!< Size = 16 (0x10)                                                          */
166  typedef struct {
167    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
168    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
169    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
170  } UARTE_RXD_Type;                               &bsol;*!< Size = 12 (0xc)                                                           */
171  typedef struct {
172    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
173    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
174    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
175  } UARTE_TXD_Type;                               &bsol;*!< Size = 12 (0xc)                                                           */
176  typedef struct {
177    __IOM uint32_t  SCK;                          &bsol;*!< (@ 0x00000000) Pin select for SCK                                         */
178    __IOM uint32_t  MOSI;                         &bsol;*!< (@ 0x00000004) Pin select for MOSI signal                                 */
179    __IOM uint32_t  MISO;                         &bsol;*!< (@ 0x00000008) Pin select for MISO signal                                 */
180  } SPI_PSEL_Type;                                &bsol;*!< Size = 12 (0xc)                                                           */
181  typedef struct {
182    __IOM uint32_t  SCK;                          &bsol;*!< (@ 0x00000000) Pin select for SCK                                         */
183    __IOM uint32_t  MOSI;                         &bsol;*!< (@ 0x00000004) Pin select for MOSI signal                                 */
184    __IOM uint32_t  MISO;                         &bsol;*!< (@ 0x00000008) Pin select for MISO signal                                 */
185    __IOM uint32_t  CSN;                          &bsol;*!< (@ 0x0000000C) Pin select for CSN                                         */
186  } SPIM_PSEL_Type;                               &bsol;*!< Size = 16 (0x10)                                                          */
187  typedef struct {
188    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
189    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
190    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
191    __IOM uint32_t  LIST;                         &bsol;*!< (@ 0x0000000C) EasyDMA list type                                          */
192  } SPIM_RXD_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
193  typedef struct {
194    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
195    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Number of bytes in transmit buffer                         */
196    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
197    __IOM uint32_t  LIST;                         &bsol;*!< (@ 0x0000000C) EasyDMA list type                                          */
198  } SPIM_TXD_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
199  typedef struct {
200    __IOM uint32_t  RXDELAY;                      &bsol;*!< (@ 0x00000000) Sample delay for input serial data on MISO                 */
201    __IOM uint32_t  CSNDUR;                       &bsol;*!< (@ 0x00000004) Minimum duration between edge of CSN and edge
202                                                                      of SCK and minimum duration CSN must stay
203                                                                      high between transactions                                  */
204  } SPIM_IFTIMING_Type;                           &bsol;*!< Size = 8 (0x8)                                                            */
205  typedef struct {
206    __IOM uint32_t  SCK;                          &bsol;*!< (@ 0x00000000) Pin select for SCK                                         */
207    __IOM uint32_t  MISO;                         &bsol;*!< (@ 0x00000004) Pin select for MISO signal                                 */
208    __IOM uint32_t  MOSI;                         &bsol;*!< (@ 0x00000008) Pin select for MOSI signal                                 */
209    __IOM uint32_t  CSN;                          &bsol;*!< (@ 0x0000000C) Pin select for CSN signal                                  */
210  } SPIS_PSEL_Type;                               &bsol;*!< Size = 16 (0x10)                                                          */
211  typedef struct {
212    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) RXD data pointer                                           */
213    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
214    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes received in last granted transaction       */
215    __IOM uint32_t  LIST;                         &bsol;*!< (@ 0x0000000C) EasyDMA list type                                          */
216  } SPIS_RXD_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
217  typedef struct {
218    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) TXD data pointer                                           */
219    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
220    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transmitted in last granted transaction    */
221    __IOM uint32_t  LIST;                         &bsol;*!< (@ 0x0000000C) EasyDMA list type                                          */
222  } SPIS_TXD_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
223  typedef struct {
224    __IOM uint32_t  SCL;                          &bsol;*!< (@ 0x00000000) Pin select for SCL                                         */
225    __IOM uint32_t  SDA;                          &bsol;*!< (@ 0x00000004) Pin select for SDA                                         */
226  } TWI_PSEL_Type;                                &bsol;*!< Size = 8 (0x8)                                                            */
227  typedef struct {
228    __IOM uint32_t  SCL;                          &bsol;*!< (@ 0x00000000) Pin select for SCL signal                                  */
229    __IOM uint32_t  SDA;                          &bsol;*!< (@ 0x00000004) Pin select for SDA signal                                  */
230  } TWIM_PSEL_Type;                               &bsol;*!< Size = 8 (0x8)                                                            */
231  typedef struct {
232    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
233    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
234    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
235    __IOM uint32_t  LIST;                         &bsol;*!< (@ 0x0000000C) EasyDMA list type                                          */
236  } TWIM_RXD_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
237  typedef struct {
238    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
239    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
240    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
241    __IOM uint32_t  LIST;                         &bsol;*!< (@ 0x0000000C) EasyDMA list type                                          */
242  } TWIM_TXD_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
243  typedef struct {
244    __IOM uint32_t  SCL;                          &bsol;*!< (@ 0x00000000) Pin select for SCL signal                                  */
245    __IOM uint32_t  SDA;                          &bsol;*!< (@ 0x00000004) Pin select for SDA signal                                  */
246  } TWIS_PSEL_Type;                               &bsol;*!< Size = 8 (0x8)                                                            */
247  typedef struct {
248    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) RXD Data pointer                                           */
249    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in RXD buffer                      */
250    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last RXD transaction    */
251    __IOM uint32_t  LIST;                         &bsol;*!< (@ 0x0000000C) EasyDMA list type                                          */
252  } TWIS_RXD_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
253  typedef struct {
254    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) TXD Data pointer                                           */
255    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes in TXD buffer                      */
256    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last TXD transaction    */
257    __IOM uint32_t  LIST;                         &bsol;*!< (@ 0x0000000C) EasyDMA list type                                          */
258  } TWIS_TXD_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
259  typedef struct {
260    __IOM uint32_t  RX;                           &bsol;*!< (@ 0x00000000) Result of last incoming frame                              */
261  } NFCT_FRAMESTATUS_Type;                        &bsol;*!< Size = 4 (0x4)                                                            */
262  typedef struct {
263    __IOM uint32_t  FRAMECONFIG;                  &bsol;*!< (@ 0x00000000) Configuration of outgoing frames                           */
264    __IOM uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000004) Size of outgoing frame                                     */
265  } NFCT_TXD_Type;                                &bsol;*!< Size = 8 (0x8)                                                            */
266  typedef struct {
267    __IOM uint32_t  FRAMECONFIG;                  &bsol;*!< (@ 0x00000000) Configuration of incoming frames                           */
268    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000004) Size of last incoming frame                                */
269  } NFCT_RXD_Type;                                &bsol;*!< Size = 8 (0x8)                                                            */
270  typedef struct {
271    __IOM uint32_t  LIMITH;                       &bsol;*!< (@ 0x00000000) Description cluster: Last result is equal or
272                                                                      above CH[n].LIMIT.HIGH                                     */
273    __IOM uint32_t  LIMITL;                       &bsol;*!< (@ 0x00000004) Description cluster: Last result is equal or
274                                                                      below CH[n].LIMIT.LOW                                      */
275  } SAADC_EVENTS_CH_Type;                         &bsol;*!< Size = 8 (0x8)                                                            */
276  typedef struct {
277    __IOM uint32_t  PSELP;                        &bsol;*!< (@ 0x00000000) Description cluster: Input positive pin selection
278                                                                      for CH[n]                                                  */
279    __IOM uint32_t  PSELN;                        &bsol;*!< (@ 0x00000004) Description cluster: Input negative pin selection
280                                                                      for CH[n]                                                  */
281    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x00000008) Description cluster: Input configuration for
282                                                                      CH[n]                                                      */
283    __IOM uint32_t  LIMIT;                        &bsol;*!< (@ 0x0000000C) Description cluster: High/low limits for event
284                                                                      monitoring of a channel                                    */
285  } SAADC_CH_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
286  typedef struct {
287    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
288    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of 16-bit samples to be written
289                                                                      to output RAM buffer                                       */
290    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of 16-bit samples written to output RAM
291                                                                      buffer since the previous START task                       */
292  } SAADC_RESULT_Type;                            &bsol;*!< Size = 12 (0xc)                                                           */
293  typedef struct {
294    __IOM uint32_t  LED;                          &bsol;*!< (@ 0x00000000) Pin select for LED signal                                  */
295    __IOM uint32_t  A;                            &bsol;*!< (@ 0x00000004) Pin select for A signal                                    */
296    __IOM uint32_t  B;                            &bsol;*!< (@ 0x00000008) Pin select for B signal                                    */
297  } QDEC_PSEL_Type;                               &bsol;*!< Size = 12 (0xc)                                                           */
298  typedef struct {
299    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Description cluster: Beginning address in RAM
300                                                                      of this sequence                                           */
301    __IOM uint32_t  CNT;                          &bsol;*!< (@ 0x00000004) Description cluster: Number of values (duty cycles)
302                                                                      in this sequence                                           */
303    __IOM uint32_t  REFRESH;                      &bsol;*!< (@ 0x00000008) Description cluster: Number of additional PWM
304                                                                      periods between samples loaded into compare
305                                                                      register                                                   */
306    __IOM uint32_t  ENDDELAY;                     &bsol;*!< (@ 0x0000000C) Description cluster: Time added after the sequence         */
307    __IM  uint32_t  RESERVED[4];
308  } PWM_SEQ_Type;                                 &bsol;*!< Size = 32 (0x20)                                                          */
309  typedef struct {
310    __IOM uint32_t  OUT[4];                       &bsol;*!< (@ 0x00000000) Description collection: Output pin select for
311                                                                      PWM channel n                                              */
312  } PWM_PSEL_Type;                                &bsol;*!< Size = 16 (0x10)                                                          */
313  typedef struct {
314    __IOM uint32_t  CLK;                          &bsol;*!< (@ 0x00000000) Pin number configuration for PDM CLK signal                */
315    __IOM uint32_t  DIN;                          &bsol;*!< (@ 0x00000004) Pin number configuration for PDM DIN signal                */
316  } PDM_PSEL_Type;                                &bsol;*!< Size = 8 (0x8)                                                            */
317  typedef struct {
318    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) RAM address pointer to write samples to with
319                                                                      EasyDMA                                                    */
320    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Number of samples to allocate memory for in EasyDMA
321                                                                      mode                                                       */
322  } PDM_SAMPLE_Type;                              &bsol;*!< Size = 8 (0x8)                                                            */
323  typedef struct {
324    __IOM uint32_t  ADDR;                         &bsol;*!< (@ 0x00000000) Description cluster: Configure the word-aligned
325                                                                      start address of region n to protect                       */
326    __IOM uint32_t  SIZE;                         &bsol;*!< (@ 0x00000004) Description cluster: Size of region to protect
327                                                                      counting from address ACL[n].ADDR. Write
328                                                                      '0' as no effect.                                          */
329    __IOM uint32_t  PERM;                         &bsol;*!< (@ 0x00000008) Description cluster: Access permissions for region
330                                                                      n as defined by start address ACL[n].ADDR
331                                                                      and size ACL[n].SIZE                                       */
332    __IM  uint32_t  RESERVED;
333  } ACL_ACL_Type;                                 &bsol;*!< Size = 16 (0x10)                                                          */
334  typedef struct {
335    __OM  uint32_t  EN;                           &bsol;*!< (@ 0x00000000) Description cluster: Enable channel group n                */
336    __OM  uint32_t  DIS;                          &bsol;*!< (@ 0x00000004) Description cluster: Disable channel group n               */
337  } PPI_TASKS_CHG_Type;                           &bsol;*!< Size = 8 (0x8)                                                            */
338  typedef struct {
339    __IOM uint32_t  EEP;                          &bsol;*!< (@ 0x00000000) Description cluster: Channel n event end-point             */
340    __IOM uint32_t  TEP;                          &bsol;*!< (@ 0x00000004) Description cluster: Channel n task end-point              */
341  } PPI_CH_Type;                                  &bsol;*!< Size = 8 (0x8)                                                            */
342  typedef struct {
343    __IOM uint32_t  TEP;                          &bsol;*!< (@ 0x00000000) Description cluster: Channel n task end-point              */
344  } PPI_FORK_Type;                                &bsol;*!< Size = 4 (0x4)                                                            */
345  typedef struct {
346    __IOM uint32_t  WA;                           &bsol;*!< (@ 0x00000000) Description cluster: Write access to region n
347                                                                      detected                                                   */
348    __IOM uint32_t  RA;                           &bsol;*!< (@ 0x00000004) Description cluster: Read access to region n
349                                                                      detected                                                   */
350  } MWU_EVENTS_REGION_Type;                       &bsol;*!< Size = 8 (0x8)                                                            */
351  typedef struct {
352    __IOM uint32_t  WA;                           &bsol;*!< (@ 0x00000000) Description cluster: Write access to peripheral
353                                                                      region n detected                                          */
354    __IOM uint32_t  RA;                           &bsol;*!< (@ 0x00000004) Description cluster: Read access to peripheral
355                                                                      region n detected                                          */
356  } MWU_EVENTS_PREGION_Type;                      &bsol;*!< Size = 8 (0x8)                                                            */
357  typedef struct {
358    __IOM uint32_t  SUBSTATWA;                    &bsol;*!< (@ 0x00000000) Description cluster: Source of event/interrupt
359                                                                      in region n, write access detected while
360                                                                      corresponding subregion was enabled for
361                                                                      watching                                                   */
362    __IOM uint32_t  SUBSTATRA;                    &bsol;*!< (@ 0x00000004) Description cluster: Source of event/interrupt
363                                                                      in region n, read access detected while
364                                                                      corresponding subregion was enabled for
365                                                                      watching                                                   */
366  } MWU_PERREGION_Type;                           &bsol;*!< Size = 8 (0x8)                                                            */
367  typedef struct {
368    __IOM uint32_t  START;                        &bsol;*!< (@ 0x00000000) Description cluster: Start address for region
369                                                                      n                                                          */
370    __IOM uint32_t  END;                          &bsol;*!< (@ 0x00000004) Description cluster: End address of region n               */
371    __IM  uint32_t  RESERVED[2];
372  } MWU_REGION_Type;                              &bsol;*!< Size = 16 (0x10)                                                          */
373  typedef struct {
374    __IM  uint32_t  START;                        &bsol;*!< (@ 0x00000000) Description cluster: Reserved for future use               */
375    __IM  uint32_t  END;                          &bsol;*!< (@ 0x00000004) Description cluster: Reserved for future use               */
376    __IOM uint32_t  SUBS;                         &bsol;*!< (@ 0x00000008) Description cluster: Subregions of region n                */
377    __IM  uint32_t  RESERVED;
378  } MWU_PREGION_Type;                             &bsol;*!< Size = 16 (0x10)                                                          */
379  typedef struct {
380    __IOM uint32_t  MODE;                         &bsol;*!< (@ 0x00000000) I2S mode.                                                  */
381    __IOM uint32_t  RXEN;                         &bsol;*!< (@ 0x00000004) Reception (RX) enable.                                     */
382    __IOM uint32_t  TXEN;                         &bsol;*!< (@ 0x00000008) Transmission (TX) enable.                                  */
383    __IOM uint32_t  MCKEN;                        &bsol;*!< (@ 0x0000000C) Master clock generator enable.                             */
384    __IOM uint32_t  MCKFREQ;                      &bsol;*!< (@ 0x00000010) Master clock generator frequency.                          */
385    __IOM uint32_t  RATIO;                        &bsol;*!< (@ 0x00000014) MCK / LRCK ratio.                                          */
386    __IOM uint32_t  SWIDTH;                       &bsol;*!< (@ 0x00000018) Sample width.                                              */
387    __IOM uint32_t  ALIGN;                        &bsol;*!< (@ 0x0000001C) Alignment of sample within a frame.                        */
388    __IOM uint32_t  FORMAT;                       &bsol;*!< (@ 0x00000020) Frame format.                                              */
389    __IOM uint32_t  CHANNELS;                     &bsol;*!< (@ 0x00000024) Enable channels.                                           */
390  } I2S_CONFIG_Type;                              &bsol;*!< Size = 40 (0x28)                                                          */
391  typedef struct {
392    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Receive buffer RAM start address.                          */
393  } I2S_RXD_Type;                                 &bsol;*!< Size = 4 (0x4)                                                            */
394  typedef struct {
395    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Transmit buffer RAM start address.                         */
396  } I2S_TXD_Type;                                 &bsol;*!< Size = 4 (0x4)                                                            */
397  typedef struct {
398    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000000) Size of RXD and TXD buffers.                               */
399  } I2S_RXTXD_Type;                               &bsol;*!< Size = 4 (0x4)                                                            */
400  typedef struct {
401    __IOM uint32_t  MCK;                          &bsol;*!< (@ 0x00000000) Pin select for MCK signal.                                 */
402    __IOM uint32_t  SCK;                          &bsol;*!< (@ 0x00000004) Pin select for SCK signal.                                 */
403    __IOM uint32_t  LRCK;                         &bsol;*!< (@ 0x00000008) Pin select for LRCK signal.                                */
404    __IOM uint32_t  SDIN;                         &bsol;*!< (@ 0x0000000C) Pin select for SDIN signal.                                */
405    __IOM uint32_t  SDOUT;                        &bsol;*!< (@ 0x00000010) Pin select for SDOUT signal.                               */
406  } I2S_PSEL_Type;                                &bsol;*!< Size = 20 (0x14)                                                          */
407  typedef struct {
408    __IM  uint32_t  EPIN[8];                      &bsol;*!< (@ 0x00000000) Description collection: IN endpoint halted status.
409                                                                      Can be used as is as response to a GetStatus()
410                                                                      request to endpoint.                                       */
411    __IM  uint32_t  RESERVED;
412    __IM  uint32_t  EPOUT[8];                     &bsol;*!< (@ 0x00000024) Description collection: OUT endpoint halted status.
413                                                                      Can be used as is as response to a GetStatus()
414                                                                      request to endpoint.                                       */
415  } USBD_HALTED_Type;                             &bsol;*!< Size = 68 (0x44)                                                          */
416  typedef struct {
417    __IOM uint32_t  EPOUT[8];                     &bsol;*!< (@ 0x00000000) Description collection: Number of bytes received
418                                                                      last in the data stage of this OUT endpoint                */
419    __IM  uint32_t  ISOOUT;                       &bsol;*!< (@ 0x00000020) Number of bytes received last on this ISO OUT
420                                                                      data endpoint                                              */
421  } USBD_SIZE_Type;                               &bsol;*!< Size = 36 (0x24)                                                          */
422  typedef struct {
423    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Description cluster: Data pointer                          */
424    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Description cluster: Maximum number of bytes
425                                                                      to transfer                                                */
426    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Description cluster: Number of bytes transferred
427                                                                      in the last transaction                                    */
428    __IM  uint32_t  RESERVED[2];
429  } USBD_EPIN_Type;                               &bsol;*!< Size = 20 (0x14)                                                          */
430  typedef struct {
431    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
432    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes to transfer                        */
433    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
434  } USBD_ISOIN_Type;                              &bsol;*!< Size = 12 (0xc)                                                           */
435  typedef struct {
436    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Description cluster: Data pointer                          */
437    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Description cluster: Maximum number of bytes
438                                                                      to transfer                                                */
439    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Description cluster: Number of bytes transferred
440                                                                      in the last transaction                                    */
441    __IM  uint32_t  RESERVED[2];
442  } USBD_EPOUT_Type;                              &bsol;*!< Size = 20 (0x14)                                                          */
443  typedef struct {
444    __IOM uint32_t  PTR;                          &bsol;*!< (@ 0x00000000) Data pointer                                               */
445    __IOM uint32_t  MAXCNT;                       &bsol;*!< (@ 0x00000004) Maximum number of bytes to transfer                        */
446    __IM  uint32_t  AMOUNT;                       &bsol;*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
447  } USBD_ISOOUT_Type;                             &bsol;*!< Size = 12 (0xc)                                                           */
448  typedef struct {                                &bsol;*!< (@ 0x10000000) FICR Structure                                             */
449    __IM  uint32_t  RESERVED[4];
450    __IM  uint32_t  CODEPAGESIZE;                 &bsol;*!< (@ 0x00000010) Code memory page size                                      */
451    __IM  uint32_t  CODESIZE;                     &bsol;*!< (@ 0x00000014) Code memory size                                           */
452    __IM  uint32_t  RESERVED1[18];
453    __IM  uint32_t  DEVICEID[2];                  &bsol;*!< (@ 0x00000060) Description collection: Device identifier                  */
454    __IM  uint32_t  RESERVED2[6];
455    __IM  uint32_t  ER[4];                        &bsol;*!< (@ 0x00000080) Description collection: Encryption root, word
456                                                                      n                                                          */
457    __IM  uint32_t  IR[4];                        &bsol;*!< (@ 0x00000090) Description collection: Identity Root, word n              */
458    __IM  uint32_t  DEVICEADDRTYPE;               &bsol;*!< (@ 0x000000A0) Device address type                                        */
459    __IM  uint32_t  DEVICEADDR[2];                &bsol;*!< (@ 0x000000A4) Description collection: Device address n                   */
460    __IM  uint32_t  RESERVED3[21];
461    __IM  FICR_INFO_Type INFO;                    &bsol;*!< (@ 0x00000100) Device info                                                */
462    __IM  uint32_t  RESERVED4[143];
463    __IM  uint32_t  PRODTEST[3];                  &bsol;*!< (@ 0x00000350) Description collection: Production test signature
464                                                                      n                                                          */
465    __IM  uint32_t  RESERVED5[42];
466    __IM  FICR_TEMP_Type TEMP;                    &bsol;*!< (@ 0x00000404) Registers storing factory TEMP module linearization
467                                                                      coefficients                                               */
468    __IM  uint32_t  RESERVED6[2];
469    __IOM FICR_NFC_Type NFC;                      &bsol;*!< (@ 0x00000450) Unspecified                                                */
470  } NRF_FICR_Type;                                &bsol;*!< Size = 1120 (0x460)                                                       */
471  typedef struct {                                &bsol;*!< (@ 0x10001000) UICR Structure                                             */
472    __IM  uint32_t  RESERVED[5];
473    __IOM uint32_t  NRFFW[13];                    &bsol;*!< (@ 0x00000014) Description collection: Reserved for Nordic firmware
474                                                                      design                                                     */
475    __IM  uint32_t  RESERVED1[2];
476    __IOM uint32_t  NRFHW[12];                    &bsol;*!< (@ 0x00000050) Description collection: Reserved for Nordic hardware
477                                                                      design                                                     */
478    __IOM uint32_t  CUSTOMER[32];                 &bsol;*!< (@ 0x00000080) Description collection: Reserved for customer              */
479    __IM  uint32_t  RESERVED2[64];
480    __IOM uint32_t  PSELRESET[2];                 &bsol;*!< (@ 0x00000200) Description collection: Mapping of the nRESET
481                                                                      function (see POWER chapter for details)                   */
482    __IOM uint32_t  APPROTECT;                    &bsol;*!< (@ 0x00000208) Access port protection                                     */
483    __IOM uint32_t  NFCPINS;                      &bsol;*!< (@ 0x0000020C) Setting of pins dedicated to NFC functionality:
484                                                                      NFC antenna or GPIO                                        */
485    __IOM uint32_t  DEBUGCTRL;                    &bsol;*!< (@ 0x00000210) Processor debug control                                    */
486    __IM  uint32_t  RESERVED3[60];
487    __IOM uint32_t  REGOUT0;                      &bsol;*!< (@ 0x00000304) Output voltage from REG0 regulator stage. The
488                                                                      maximum output voltage from this stage is
489                                                                      given as VDDH - VREG0DROP.                                 */
490  } NRF_UICR_Type;                                &bsol;*!< Size = 776 (0x308)                                                        */
491  typedef struct {                                &bsol;*!< (@ 0x40000000) CLOCK Structure                                            */
492    __OM  uint32_t  TASKS_HFCLKSTART;             &bsol;*!< (@ 0x00000000) Start HFXO crystal oscillator                              */
493    __OM  uint32_t  TASKS_HFCLKSTOP;              &bsol;*!< (@ 0x00000004) Stop HFXO crystal oscillator                               */
494    __OM  uint32_t  TASKS_LFCLKSTART;             &bsol;*!< (@ 0x00000008) Start LFCLK                                                */
495    __OM  uint32_t  TASKS_LFCLKSTOP;              &bsol;*!< (@ 0x0000000C) Stop LFCLK                                                 */
496    __OM  uint32_t  TASKS_CAL;                    &bsol;*!< (@ 0x00000010) Start calibration of LFRC                                  */
497    __OM  uint32_t  TASKS_CTSTART;                &bsol;*!< (@ 0x00000014) Start calibration timer                                    */
498    __OM  uint32_t  TASKS_CTSTOP;                 &bsol;*!< (@ 0x00000018) Stop calibration timer                                     */
499    __IM  uint32_t  RESERVED[57];
500    __IOM uint32_t  EVENTS_HFCLKSTARTED;          &bsol;*!< (@ 0x00000100) HFXO crystal oscillator started                            */
501    __IOM uint32_t  EVENTS_LFCLKSTARTED;          &bsol;*!< (@ 0x00000104) LFCLK started                                              */
502    __IM  uint32_t  RESERVED1;
503    __IOM uint32_t  EVENTS_DONE;                  &bsol;*!< (@ 0x0000010C) Calibration of LFRC completed                              */
504    __IOM uint32_t  EVENTS_CTTO;                  &bsol;*!< (@ 0x00000110) Calibration timer timeout                                  */
505    __IM  uint32_t  RESERVED2[5];
506    __IOM uint32_t  EVENTS_CTSTARTED;             &bsol;*!< (@ 0x00000128) Calibration timer has been started and is ready
507                                                                      to process new tasks                                       */
508    __IOM uint32_t  EVENTS_CTSTOPPED;             &bsol;*!< (@ 0x0000012C) Calibration timer has been stopped and is ready
509                                                                      to process new tasks                                       */
510    __IM  uint32_t  RESERVED3[117];
511    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
512    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
513    __IM  uint32_t  RESERVED4[63];
514    __IM  uint32_t  HFCLKRUN;                     &bsol;*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
515                                                                      triggered                                                  */
516    __IM  uint32_t  HFCLKSTAT;                    &bsol;*!< (@ 0x0000040C) HFCLK status                                               */
517    __IM  uint32_t  RESERVED5;
518    __IM  uint32_t  LFCLKRUN;                     &bsol;*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
519                                                                      triggered                                                  */
520    __IM  uint32_t  LFCLKSTAT;                    &bsol;*!< (@ 0x00000418) LFCLK status                                               */
521    __IM  uint32_t  LFCLKSRCCOPY;                 &bsol;*!< (@ 0x0000041C) Copy of LFCLKSRC register, set when LFCLKSTART
522                                                                      task was triggered                                         */
523    __IM  uint32_t  RESERVED6[62];
524    __IOM uint32_t  LFCLKSRC;                     &bsol;*!< (@ 0x00000518) Clock source for the LFCLK                                 */
525    __IM  uint32_t  RESERVED7[3];
526    __IOM uint32_t  HFXODEBOUNCE;                 &bsol;*!< (@ 0x00000528) HFXO debounce time. The HFXO is started by triggering
527                                                                      the TASKS_HFCLKSTART task.                                 */
528    __IOM uint32_t  LFXODEBOUNCE;                 &bsol;*!< (@ 0x0000052C) LFXO debounce time. The LFXO is started by triggering
529                                                                      the TASKS_LFCLKSTART task when the LFCLKSRC
530                                                                      register is configured for Xtal.                           */
531    __IM  uint32_t  RESERVED8[2];
532    __IOM uint32_t  CTIV;                         &bsol;*!< (@ 0x00000538) Calibration timer interval                                 */
533    __IM  uint32_t  RESERVED9[8];
534    __IOM uint32_t  TRACECONFIG;                  &bsol;*!< (@ 0x0000055C) Clocking options for the trace port debug interface        */
535  } NRF_CLOCK_Type;                               &bsol;*!< Size = 1376 (0x560)                                                       */
536  typedef struct {                                &bsol;*!< (@ 0x40000000) POWER Structure                                            */
537    __IM  uint32_t  RESERVED[30];
538    __OM  uint32_t  TASKS_CONSTLAT;               &bsol;*!< (@ 0x00000078) Enable Constant Latency mode                               */
539    __OM  uint32_t  TASKS_LOWPWR;                 &bsol;*!< (@ 0x0000007C) Enable Low-power mode (variable latency)                   */
540    __IM  uint32_t  RESERVED1[34];
541    __IOM uint32_t  EVENTS_POFWARN;               &bsol;*!< (@ 0x00000108) Power failure warning                                      */
542    __IM  uint32_t  RESERVED2[2];
543    __IOM uint32_t  EVENTS_SLEEPENTER;            &bsol;*!< (@ 0x00000114) CPU entered WFI/WFE sleep                                  */
544    __IOM uint32_t  EVENTS_SLEEPEXIT;             &bsol;*!< (@ 0x00000118) CPU exited WFI/WFE sleep                                   */
545    __IOM uint32_t  EVENTS_USBDETECTED;           &bsol;*!< (@ 0x0000011C) Voltage supply detected on VBUS                            */
546    __IOM uint32_t  EVENTS_USBREMOVED;            &bsol;*!< (@ 0x00000120) Voltage supply removed from VBUS                           */
547    __IOM uint32_t  EVENTS_USBPWRRDY;             &bsol;*!< (@ 0x00000124) USB 3.3 V supply ready                                     */
548    __IM  uint32_t  RESERVED3[119];
549    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
550    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
551    __IM  uint32_t  RESERVED4[61];
552    __IOM uint32_t  RESETREAS;                    &bsol;*!< (@ 0x00000400) Reset reason                                               */
553    __IM  uint32_t  RESERVED5[9];
554    __IM  uint32_t  RAMSTATUS;                    &bsol;*!< (@ 0x00000428) Deprecated register - RAM status register                  */
555    __IM  uint32_t  RESERVED6[3];
556    __IM  uint32_t  USBREGSTATUS;                 &bsol;*!< (@ 0x00000438) USB supply status                                          */
557    __IM  uint32_t  RESERVED7[49];
558    __OM  uint32_t  SYSTEMOFF;                    &bsol;*!< (@ 0x00000500) System OFF register                                        */
559    __IM  uint32_t  RESERVED8[3];
560    __IOM uint32_t  POFCON;                       &bsol;*!< (@ 0x00000510) Power-fail comparator configuration                        */
561    __IM  uint32_t  RESERVED9[2];
562    __IOM uint32_t  GPREGRET;                     &bsol;*!< (@ 0x0000051C) General purpose retention register                         */
563    __IOM uint32_t  GPREGRET2;                    &bsol;*!< (@ 0x00000520) General purpose retention register                         */
564    __IM  uint32_t  RESERVED10[21];
565    __IOM uint32_t  DCDCEN;                       &bsol;*!< (@ 0x00000578) Enable DC/DC converter for REG1 stage                      */
566    __IM  uint32_t  RESERVED11[49];
567    __IM  uint32_t  MAINREGSTATUS;                &bsol;*!< (@ 0x00000640) Main supply status                                         */
568    __IM  uint32_t  RESERVED12[175];
569    __IOM POWER_RAM_Type RAM[9];                  &bsol;*!< (@ 0x00000900) Unspecified                                                */
570  } NRF_POWER_Type;                               &bsol;*!< Size = 2448 (0x990)                                                       */
571  typedef struct {                                &bsol;*!< (@ 0x50000000) P0 Structure                                               */
572    __IM  uint32_t  RESERVED[321];
573    __IOM uint32_t  OUT;                          &bsol;*!< (@ 0x00000504) Write GPIO port                                            */
574    __IOM uint32_t  OUTSET;                       &bsol;*!< (@ 0x00000508) Set individual bits in GPIO port                           */
575    __IOM uint32_t  OUTCLR;                       &bsol;*!< (@ 0x0000050C) Clear individual bits in GPIO port                         */
576    __IM  uint32_t  IN;                           &bsol;*!< (@ 0x00000510) Read GPIO port                                             */
577    __IOM uint32_t  DIR;                          &bsol;*!< (@ 0x00000514) Direction of GPIO pins                                     */
578    __IOM uint32_t  DIRSET;                       &bsol;*!< (@ 0x00000518) DIR set register                                           */
579    __IOM uint32_t  DIRCLR;                       &bsol;*!< (@ 0x0000051C) DIR clear register                                         */
580    __IOM uint32_t  LATCH;                        &bsol;*!< (@ 0x00000520) Latch register indicating what GPIO pins that
581                                                                      have met the criteria set in the PIN_CNF[n].SENSE
582                                                                      registers                                                  */
583    __IOM uint32_t  DETECTMODE;                   &bsol;*!< (@ 0x00000524) Select between default DETECT signal behaviour
584                                                                      and LDETECT mode                                           */
585    __IM  uint32_t  RESERVED1[118];
586    __IOM uint32_t  PIN_CNF[32];                  &bsol;*!< (@ 0x00000700) Description collection: Configuration of GPIO
587                                                                      pins                                                       */
588  } NRF_GPIO_Type;                                &bsol;*!< Size = 1920 (0x780)                                                       */
589  typedef struct {                                &bsol;*!< (@ 0x40001000) RADIO Structure                                            */
590    __OM  uint32_t  TASKS_TXEN;                   &bsol;*!< (@ 0x00000000) Enable RADIO in TX mode                                    */
591    __OM  uint32_t  TASKS_RXEN;                   &bsol;*!< (@ 0x00000004) Enable RADIO in RX mode                                    */
592    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000008) Start RADIO                                                */
593    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x0000000C) Stop RADIO                                                 */
594    __OM  uint32_t  TASKS_DISABLE;                &bsol;*!< (@ 0x00000010) Disable RADIO                                              */
595    __OM  uint32_t  TASKS_RSSISTART;              &bsol;*!< (@ 0x00000014) Start the RSSI and take one single sample of
596                                                                      the receive signal strength                                */
597    __OM  uint32_t  TASKS_RSSISTOP;               &bsol;*!< (@ 0x00000018) Stop the RSSI measurement                                  */
598    __OM  uint32_t  TASKS_BCSTART;                &bsol;*!< (@ 0x0000001C) Start the bit counter                                      */
599    __OM  uint32_t  TASKS_BCSTOP;                 &bsol;*!< (@ 0x00000020) Stop the bit counter                                       */
600    __OM  uint32_t  TASKS_EDSTART;                &bsol;*!< (@ 0x00000024) Start the energy detect measurement used in IEEE
601                                                                      802.15.4 mode                                              */
602    __OM  uint32_t  TASKS_EDSTOP;                 &bsol;*!< (@ 0x00000028) Stop the energy detect measurement                         */
603    __OM  uint32_t  TASKS_CCASTART;               &bsol;*!< (@ 0x0000002C) Start the clear channel assessment used in IEEE
604                                                                      802.15.4 mode                                              */
605    __OM  uint32_t  TASKS_CCASTOP;                &bsol;*!< (@ 0x00000030) Stop the clear channel assessment                          */
606    __IM  uint32_t  RESERVED[51];
607    __IOM uint32_t  EVENTS_READY;                 &bsol;*!< (@ 0x00000100) RADIO has ramped up and is ready to be started             */
608    __IOM uint32_t  EVENTS_ADDRESS;               &bsol;*!< (@ 0x00000104) Address sent or received                                   */
609    __IOM uint32_t  EVENTS_PAYLOAD;               &bsol;*!< (@ 0x00000108) Packet payload sent or received                            */
610    __IOM uint32_t  EVENTS_END;                   &bsol;*!< (@ 0x0000010C) Packet sent or received                                    */
611    __IOM uint32_t  EVENTS_DISABLED;              &bsol;*!< (@ 0x00000110) RADIO has been disabled                                    */
612    __IOM uint32_t  EVENTS_DEVMATCH;              &bsol;*!< (@ 0x00000114) A device address match occurred on the last received
613                                                                      packet                                                     */
614    __IOM uint32_t  EVENTS_DEVMISS;               &bsol;*!< (@ 0x00000118) No device address match occurred on the last
615                                                                      received packet                                            */
616    __IOM uint32_t  EVENTS_RSSIEND;               &bsol;*!< (@ 0x0000011C) Sampling of receive signal strength complete               */
617    __IM  uint32_t  RESERVED1[2];
618    __IOM uint32_t  EVENTS_BCMATCH;               &bsol;*!< (@ 0x00000128) Bit counter reached bit count value                        */
619    __IM  uint32_t  RESERVED2;
620    __IOM uint32_t  EVENTS_CRCOK;                 &bsol;*!< (@ 0x00000130) Packet received with CRC ok                                */
621    __IOM uint32_t  EVENTS_CRCERROR;              &bsol;*!< (@ 0x00000134) Packet received with CRC error                             */
622    __IOM uint32_t  EVENTS_FRAMESTART;            &bsol;*!< (@ 0x00000138) IEEE 802.15.4 length field received                        */
623    __IOM uint32_t  EVENTS_EDEND;                 &bsol;*!< (@ 0x0000013C) Sampling of energy detection complete. A new
624                                                                      ED sample is ready for readout from the
625                                                                      RADIO.EDSAMPLE register                                    */
626    __IOM uint32_t  EVENTS_EDSTOPPED;             &bsol;*!< (@ 0x00000140) The sampling of energy detection has stopped               */
627    __IOM uint32_t  EVENTS_CCAIDLE;               &bsol;*!< (@ 0x00000144) Wireless medium in idle - clear to send                    */
628    __IOM uint32_t  EVENTS_CCABUSY;               &bsol;*!< (@ 0x00000148) Wireless medium busy - do not send                         */
629    __IOM uint32_t  EVENTS_CCASTOPPED;            &bsol;*!< (@ 0x0000014C) The CCA has stopped                                        */
630    __IOM uint32_t  EVENTS_RATEBOOST;             &bsol;*!< (@ 0x00000150) Ble_LR CI field received, receive mode is changed
631                                                                      from Ble_LR125Kbit to Ble_LR500Kbit.                       */
632    __IOM uint32_t  EVENTS_TXREADY;               &bsol;*!< (@ 0x00000154) RADIO has ramped up and is ready to be started
633                                                                      TX path                                                    */
634    __IOM uint32_t  EVENTS_RXREADY;               &bsol;*!< (@ 0x00000158) RADIO has ramped up and is ready to be started
635                                                                      RX path                                                    */
636    __IOM uint32_t  EVENTS_MHRMATCH;              &bsol;*!< (@ 0x0000015C) MAC header match found                                     */
637    __IM  uint32_t  RESERVED3[2];
638    __IOM uint32_t  EVENTS_SYNC;                  &bsol;*!< (@ 0x00000168) Preamble indicator                                         */
639    __IOM uint32_t  EVENTS_PHYEND;                &bsol;*!< (@ 0x0000016C) Generated when last bit is sent on air, or received
640                                                                      from air                                                   */
641    __IOM uint32_t  EVENTS_CTEPRESENT;            &bsol;*!< (@ 0x00000170) CTE is present (early warning right after receiving
642                                                                      CTEInfo byte)                                              */
643    __IM  uint32_t  RESERVED4[35];
644    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
645    __IM  uint32_t  RESERVED5[64];
646    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
647    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
648    __IM  uint32_t  RESERVED6[61];
649    __IM  uint32_t  CRCSTATUS;                    &bsol;*!< (@ 0x00000400) CRC status                                                 */
650    __IM  uint32_t  RESERVED7;
651    __IM  uint32_t  RXMATCH;                      &bsol;*!< (@ 0x00000408) Received address                                           */
652    __IM  uint32_t  RXCRC;                        &bsol;*!< (@ 0x0000040C) CRC field of previously received packet                    */
653    __IM  uint32_t  DAI;                          &bsol;*!< (@ 0x00000410) Device address match index                                 */
654    __IM  uint32_t  PDUSTAT;                      &bsol;*!< (@ 0x00000414) Payload status                                             */
655    __IM  uint32_t  RESERVED8[13];
656    __IM  uint32_t  CTESTATUS;                    &bsol;*!< (@ 0x0000044C) CTEInfo parsed from received packet                        */
657    __IM  uint32_t  RESERVED9[2];
658    __IM  uint32_t  DFESTATUS;                    &bsol;*!< (@ 0x00000458) DFE status information                                     */
659    __IM  uint32_t  RESERVED10[42];
660    __IOM uint32_t  PACKETPTR;                    &bsol;*!< (@ 0x00000504) Packet pointer                                             */
661    __IOM uint32_t  FREQUENCY;                    &bsol;*!< (@ 0x00000508) Frequency                                                  */
662    __IOM uint32_t  TXPOWER;                      &bsol;*!< (@ 0x0000050C) Output power                                               */
663    __IOM uint32_t  MODE;                         &bsol;*!< (@ 0x00000510) Data rate and modulation                                   */
664    __IOM uint32_t  PCNF0;                        &bsol;*!< (@ 0x00000514) Packet configuration register 0                            */
665    __IOM uint32_t  PCNF1;                        &bsol;*!< (@ 0x00000518) Packet configuration register 1                            */
666    __IOM uint32_t  BASE0;                        &bsol;*!< (@ 0x0000051C) Base address 0                                             */
667    __IOM uint32_t  BASE1;                        &bsol;*!< (@ 0x00000520) Base address 1                                             */
668    __IOM uint32_t  PREFIX0;                      &bsol;*!< (@ 0x00000524) Prefixes bytes for logical addresses 0-3                   */
669    __IOM uint32_t  PREFIX1;                      &bsol;*!< (@ 0x00000528) Prefixes bytes for logical addresses 4-7                   */
670    __IOM uint32_t  TXADDRESS;                    &bsol;*!< (@ 0x0000052C) Transmit address select                                    */
671    __IOM uint32_t  RXADDRESSES;                  &bsol;*!< (@ 0x00000530) Receive address select                                     */
672    __IOM uint32_t  CRCCNF;                       &bsol;*!< (@ 0x00000534) CRC configuration                                          */
673    __IOM uint32_t  CRCPOLY;                      &bsol;*!< (@ 0x00000538) CRC polynomial                                             */
674    __IOM uint32_t  CRCINIT;                      &bsol;*!< (@ 0x0000053C) CRC initial value                                          */
675    __IM  uint32_t  RESERVED11;
676    __IOM uint32_t  TIFS;                         &bsol;*!< (@ 0x00000544) Interframe spacing in us                                   */
677    __IM  uint32_t  RSSISAMPLE;                   &bsol;*!< (@ 0x00000548) RSSI sample                                                */
678    __IM  uint32_t  RESERVED12;
679    __IM  uint32_t  STATE;                        &bsol;*!< (@ 0x00000550) Current radio state                                        */
680    __IOM uint32_t  DATAWHITEIV;                  &bsol;*!< (@ 0x00000554) Data whitening initial value                               */
681    __IM  uint32_t  RESERVED13[2];
682    __IOM uint32_t  BCC;                          &bsol;*!< (@ 0x00000560) Bit counter compare                                        */
683    __IM  uint32_t  RESERVED14[39];
684    __IOM uint32_t  DAB[8];                       &bsol;*!< (@ 0x00000600) Description collection: Device address base segment
685                                                                      n                                                          */
686    __IOM uint32_t  DAP[8];                       &bsol;*!< (@ 0x00000620) Description collection: Device address prefix
687                                                                      n                                                          */
688    __IOM uint32_t  DACNF;                        &bsol;*!< (@ 0x00000640) Device address match configuration                         */
689    __IOM uint32_t  MHRMATCHCONF;                 &bsol;*!< (@ 0x00000644) Search pattern configuration                               */
690    __IOM uint32_t  MHRMATCHMAS;                  &bsol;*!< (@ 0x00000648) Pattern mask                                               */
691    __IM  uint32_t  RESERVED15;
692    __IOM uint32_t  MODECNF0;                     &bsol;*!< (@ 0x00000650) Radio mode configuration register 0                        */
693    __IM  uint32_t  RESERVED16[3];
694    __IOM uint32_t  SFD;                          &bsol;*!< (@ 0x00000660) IEEE 802.15.4 start of frame delimiter                     */
695    __IOM uint32_t  EDCNT;                        &bsol;*!< (@ 0x00000664) IEEE 802.15.4 energy detect loop count                     */
696    __IM  uint32_t  EDSAMPLE;                     &bsol;*!< (@ 0x00000668) IEEE 802.15.4 energy detect level                          */
697    __IOM uint32_t  CCACTRL;                      &bsol;*!< (@ 0x0000066C) IEEE 802.15.4 clear channel assessment control             */
698    __IM  uint32_t  RESERVED17[164];
699    __IOM uint32_t  DFEMODE;                      &bsol;*!< (@ 0x00000900) Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure
700                                                                      (AOD)                                                      */
701    __IOM uint32_t  CTEINLINECONF;                &bsol;*!< (@ 0x00000904) Configuration for CTE inline mode                          */
702    __IM  uint32_t  RESERVED18[2];
703    __IOM uint32_t  DFECTRL1;                     &bsol;*!< (@ 0x00000910) Various configuration for Direction finding                */
704    __IOM uint32_t  DFECTRL2;                     &bsol;*!< (@ 0x00000914) Start offset for Direction finding                         */
705    __IM  uint32_t  RESERVED19[4];
706    __IOM uint32_t  SWITCHPATTERN;                &bsol;*!< (@ 0x00000928) GPIO patterns to be used for each antenna                  */
707    __IOM uint32_t  CLEARPATTERN;                 &bsol;*!< (@ 0x0000092C) Clear the GPIO pattern array for antenna control           */
708    __IOM RADIO_PSEL_Type PSEL;                   &bsol;*!< (@ 0x00000930) Unspecified                                                */
709    __IOM RADIO_DFEPACKET_Type DFEPACKET;         &bsol;*!< (@ 0x00000950) DFE packet EasyDMA channel                                 */
710    __IM  uint32_t  RESERVED20[424];
711    __IOM uint32_t  POWER;                        &bsol;*!< (@ 0x00000FFC) Peripheral power control                                   */
712  } NRF_RADIO_Type;                               &bsol;*!< Size = 4096 (0x1000)                                                      */
713  typedef struct {                                &bsol;*!< (@ 0x40002000) UART0 Structure                                            */
714    __OM  uint32_t  TASKS_STARTRX;                &bsol;*!< (@ 0x00000000) Start UART receiver                                        */
715    __OM  uint32_t  TASKS_STOPRX;                 &bsol;*!< (@ 0x00000004) Stop UART receiver                                         */
716    __OM  uint32_t  TASKS_STARTTX;                &bsol;*!< (@ 0x00000008) Start UART transmitter                                     */
717    __OM  uint32_t  TASKS_STOPTX;                 &bsol;*!< (@ 0x0000000C) Stop UART transmitter                                      */
718    __IM  uint32_t  RESERVED[3];
719    __OM  uint32_t  TASKS_SUSPEND;                &bsol;*!< (@ 0x0000001C) Suspend UART                                               */
720    __IM  uint32_t  RESERVED1[56];
721    __IOM uint32_t  EVENTS_CTS;                   &bsol;*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
722    __IOM uint32_t  EVENTS_NCTS;                  &bsol;*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
723    __IOM uint32_t  EVENTS_RXDRDY;                &bsol;*!< (@ 0x00000108) Data received in RXD                                       */
724    __IM  uint32_t  RESERVED2[4];
725    __IOM uint32_t  EVENTS_TXDRDY;                &bsol;*!< (@ 0x0000011C) Data sent from TXD                                         */
726    __IM  uint32_t  RESERVED3;
727    __IOM uint32_t  EVENTS_ERROR;                 &bsol;*!< (@ 0x00000124) Error detected                                             */
728    __IM  uint32_t  RESERVED4[7];
729    __IOM uint32_t  EVENTS_RXTO;                  &bsol;*!< (@ 0x00000144) Receiver timeout                                           */
730    __IM  uint32_t  RESERVED5[46];
731    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
732    __IM  uint32_t  RESERVED6[64];
733    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
734    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
735    __IM  uint32_t  RESERVED7[93];
736    __IOM uint32_t  ERRORSRC;                     &bsol;*!< (@ 0x00000480) Error source                                               */
737    __IM  uint32_t  RESERVED8[31];
738    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable UART                                                */
739    __IM  uint32_t  RESERVED9;
740    __IOM UART_PSEL_Type PSEL;                    &bsol;*!< (@ 0x00000508) Unspecified                                                */
741    __IM  uint32_t  RXD;                          &bsol;*!< (@ 0x00000518) RXD register                                               */
742    __OM  uint32_t  TXD;                          &bsol;*!< (@ 0x0000051C) TXD register                                               */
743    __IM  uint32_t  RESERVED10;
744    __IOM uint32_t  BAUDRATE;                     &bsol;*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
745                                                                      selected.                                                  */
746    __IM  uint32_t  RESERVED11[17];
747    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
748  } NRF_UART_Type;                                &bsol;*!< Size = 1392 (0x570)                                                       */
749  typedef struct {                                &bsol;*!< (@ 0x40002000) UARTE0 Structure                                           */
750    __OM  uint32_t  TASKS_STARTRX;                &bsol;*!< (@ 0x00000000) Start UART receiver                                        */
751    __OM  uint32_t  TASKS_STOPRX;                 &bsol;*!< (@ 0x00000004) Stop UART receiver                                         */
752    __OM  uint32_t  TASKS_STARTTX;                &bsol;*!< (@ 0x00000008) Start UART transmitter                                     */
753    __OM  uint32_t  TASKS_STOPTX;                 &bsol;*!< (@ 0x0000000C) Stop UART transmitter                                      */
754    __IM  uint32_t  RESERVED[7];
755    __OM  uint32_t  TASKS_FLUSHRX;                &bsol;*!< (@ 0x0000002C) Flush RX FIFO into RX buffer                               */
756    __IM  uint32_t  RESERVED1[52];
757    __IOM uint32_t  EVENTS_CTS;                   &bsol;*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
758    __IOM uint32_t  EVENTS_NCTS;                  &bsol;*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
759    __IOM uint32_t  EVENTS_RXDRDY;                &bsol;*!< (@ 0x00000108) Data received in RXD (but potentially not yet
760                                                                      transferred to Data RAM)                                   */
761    __IM  uint32_t  RESERVED2;
762    __IOM uint32_t  EVENTS_ENDRX;                 &bsol;*!< (@ 0x00000110) Receive buffer is filled up                                */
763    __IM  uint32_t  RESERVED3[2];
764    __IOM uint32_t  EVENTS_TXDRDY;                &bsol;*!< (@ 0x0000011C) Data sent from TXD                                         */
765    __IOM uint32_t  EVENTS_ENDTX;                 &bsol;*!< (@ 0x00000120) Last TX byte transmitted                                   */
766    __IOM uint32_t  EVENTS_ERROR;                 &bsol;*!< (@ 0x00000124) Error detected                                             */
767    __IM  uint32_t  RESERVED4[7];
768    __IOM uint32_t  EVENTS_RXTO;                  &bsol;*!< (@ 0x00000144) Receiver timeout                                           */
769    __IM  uint32_t  RESERVED5;
770    __IOM uint32_t  EVENTS_RXSTARTED;             &bsol;*!< (@ 0x0000014C) UART receiver has started                                  */
771    __IOM uint32_t  EVENTS_TXSTARTED;             &bsol;*!< (@ 0x00000150) UART transmitter has started                               */
772    __IM  uint32_t  RESERVED6;
773    __IOM uint32_t  EVENTS_TXSTOPPED;             &bsol;*!< (@ 0x00000158) Transmitter stopped                                        */
774    __IM  uint32_t  RESERVED7[41];
775    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
776    __IM  uint32_t  RESERVED8[63];
777    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
778    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
779    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
780    __IM  uint32_t  RESERVED9[93];
781    __IOM uint32_t  ERRORSRC;                     &bsol;*!< (@ 0x00000480) Error source Note : this register is read / write
782                                                                      one to clear.                                              */
783    __IM  uint32_t  RESERVED10[31];
784    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable UART                                                */
785    __IM  uint32_t  RESERVED11;
786    __IOM UARTE_PSEL_Type PSEL;                   &bsol;*!< (@ 0x00000508) Unspecified                                                */
787    __IM  uint32_t  RESERVED12[3];
788    __IOM uint32_t  BAUDRATE;                     &bsol;*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
789                                                                      selected.                                                  */
790    __IM  uint32_t  RESERVED13[3];
791    __IOM UARTE_RXD_Type RXD;                     &bsol;*!< (@ 0x00000534) RXD EasyDMA channel                                        */
792    __IM  uint32_t  RESERVED14;
793    __IOM UARTE_TXD_Type TXD;                     &bsol;*!< (@ 0x00000544) TXD EasyDMA channel                                        */
794    __IM  uint32_t  RESERVED15[7];
795    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
796  } NRF_UARTE_Type;                               &bsol;*!< Size = 1392 (0x570)                                                       */
797  typedef struct {                                &bsol;*!< (@ 0x40003000) SPI0 Structure                                             */
798    __IM  uint32_t  RESERVED[66];
799    __IOM uint32_t  EVENTS_READY;                 &bsol;*!< (@ 0x00000108) TXD byte sent and RXD byte received                        */
800    __IM  uint32_t  RESERVED1[126];
801    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
802    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
803    __IM  uint32_t  RESERVED2[125];
804    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable SPI                                                 */
805    __IM  uint32_t  RESERVED3;
806    __IOM SPI_PSEL_Type PSEL;                     &bsol;*!< (@ 0x00000508) Unspecified                                                */
807    __IM  uint32_t  RESERVED4;
808    __IM  uint32_t  RXD;                          &bsol;*!< (@ 0x00000518) RXD register                                               */
809    __IOM uint32_t  TXD;                          &bsol;*!< (@ 0x0000051C) TXD register                                               */
810    __IM  uint32_t  RESERVED5;
811    __IOM uint32_t  FREQUENCY;                    &bsol;*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
812                                                                      source selected.                                           */
813    __IM  uint32_t  RESERVED6[11];
814    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x00000554) Configuration register                                     */
815  } NRF_SPI_Type;                                 &bsol;*!< Size = 1368 (0x558)                                                       */
816  typedef struct {                                &bsol;*!< (@ 0x40003000) SPIM0 Structure                                            */
817    __IM  uint32_t  RESERVED[4];
818    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000010) Start SPI transaction                                      */
819    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000014) Stop SPI transaction                                       */
820    __IM  uint32_t  RESERVED1;
821    __OM  uint32_t  TASKS_SUSPEND;                &bsol;*!< (@ 0x0000001C) Suspend SPI transaction                                    */
822    __OM  uint32_t  TASKS_RESUME;                 &bsol;*!< (@ 0x00000020) Resume SPI transaction                                     */
823    __IM  uint32_t  RESERVED2[56];
824    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000104) SPI transaction has stopped                                */
825    __IM  uint32_t  RESERVED3[2];
826    __IOM uint32_t  EVENTS_ENDRX;                 &bsol;*!< (@ 0x00000110) End of RXD buffer reached                                  */
827    __IM  uint32_t  RESERVED4;
828    __IOM uint32_t  EVENTS_END;                   &bsol;*!< (@ 0x00000118) End of RXD buffer and TXD buffer reached                   */
829    __IM  uint32_t  RESERVED5;
830    __IOM uint32_t  EVENTS_ENDTX;                 &bsol;*!< (@ 0x00000120) End of TXD buffer reached                                  */
831    __IM  uint32_t  RESERVED6[10];
832    __IOM uint32_t  EVENTS_STARTED;               &bsol;*!< (@ 0x0000014C) Transaction started                                        */
833    __IM  uint32_t  RESERVED7[44];
834    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
835    __IM  uint32_t  RESERVED8[64];
836    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
837    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
838    __IM  uint32_t  RESERVED9[61];
839    __IOM uint32_t  STALLSTAT;                    &bsol;*!< (@ 0x00000400) Stall status for EasyDMA RAM accesses. The fields
840                                                                      in this register is set to STALL by hardware
841                                                                      whenever a stall occurres and can be cleared
842                                                                      (set to NOSTALL) by the CPU.                               */
843    __IM  uint32_t  RESERVED10[63];
844    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable SPIM                                                */
845    __IM  uint32_t  RESERVED11;
846    __IOM SPIM_PSEL_Type PSEL;                    &bsol;*!< (@ 0x00000508) Unspecified                                                */
847    __IM  uint32_t  RESERVED12[3];
848    __IOM uint32_t  FREQUENCY;                    &bsol;*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
849                                                                      source selected.                                           */
850    __IM  uint32_t  RESERVED13[3];
851    __IOM SPIM_RXD_Type RXD;                      &bsol;*!< (@ 0x00000534) RXD EasyDMA channel                                        */
852    __IOM SPIM_TXD_Type TXD;                      &bsol;*!< (@ 0x00000544) TXD EasyDMA channel                                        */
853    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x00000554) Configuration register                                     */
854    __IM  uint32_t  RESERVED14[2];
855    __IOM SPIM_IFTIMING_Type IFTIMING;            &bsol;*!< (@ 0x00000560) Unspecified                                                */
856    __IOM uint32_t  CSNPOL;                       &bsol;*!< (@ 0x00000568) Polarity of CSN output                                     */
857    __IOM uint32_t  PSELDCX;                      &bsol;*!< (@ 0x0000056C) Pin select for DCX signal                                  */
858    __IOM uint32_t  DCXCNT;                       &bsol;*!< (@ 0x00000570) DCX configuration                                          */
859    __IM  uint32_t  RESERVED15[19];
860    __IOM uint32_t  ORC;                          &bsol;*!< (@ 0x000005C0) Byte transmitted after TXD.MAXCNT bytes have
861                                                                      been transmitted in the case when RXD.MAXCNT
862                                                                      is greater than TXD.MAXCNT                                 */
863  } NRF_SPIM_Type;                                &bsol;*!< Size = 1476 (0x5c4)                                                       */
864  typedef struct {                                &bsol;*!< (@ 0x40003000) SPIS0 Structure                                            */
865    __IM  uint32_t  RESERVED[9];
866    __OM  uint32_t  TASKS_ACQUIRE;                &bsol;*!< (@ 0x00000024) Acquire SPI semaphore                                      */
867    __OM  uint32_t  TASKS_RELEASE;                &bsol;*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
868                                                                      to acquire it                                              */
869    __IM  uint32_t  RESERVED1[54];
870    __IOM uint32_t  EVENTS_END;                   &bsol;*!< (@ 0x00000104) Granted transaction completed                              */
871    __IM  uint32_t  RESERVED2[2];
872    __IOM uint32_t  EVENTS_ENDRX;                 &bsol;*!< (@ 0x00000110) End of RXD buffer reached                                  */
873    __IM  uint32_t  RESERVED3[5];
874    __IOM uint32_t  EVENTS_ACQUIRED;              &bsol;*!< (@ 0x00000128) Semaphore acquired                                         */
875    __IM  uint32_t  RESERVED4[53];
876    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
877    __IM  uint32_t  RESERVED5[64];
878    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
879    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
880    __IM  uint32_t  RESERVED6[61];
881    __IM  uint32_t  SEMSTAT;                      &bsol;*!< (@ 0x00000400) Semaphore status register                                  */
882    __IM  uint32_t  RESERVED7[15];
883    __IOM uint32_t  STATUS;                       &bsol;*!< (@ 0x00000440) Status from last transaction                               */
884    __IM  uint32_t  RESERVED8[47];
885    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable SPI slave                                           */
886    __IM  uint32_t  RESERVED9;
887    __IOM SPIS_PSEL_Type PSEL;                    &bsol;*!< (@ 0x00000508) Unspecified                                                */
888    __IM  uint32_t  RESERVED10[7];
889    __IOM SPIS_RXD_Type RXD;                      &bsol;*!< (@ 0x00000534) Unspecified                                                */
890    __IOM SPIS_TXD_Type TXD;                      &bsol;*!< (@ 0x00000544) Unspecified                                                */
891    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x00000554) Configuration register                                     */
892    __IM  uint32_t  RESERVED11;
893    __IOM uint32_t  DEF;                          &bsol;*!< (@ 0x0000055C) Default character. Character clocked out in case
894                                                                      of an ignored transaction.                                 */
895    __IM  uint32_t  RESERVED12[24];
896    __IOM uint32_t  ORC;                          &bsol;*!< (@ 0x000005C0) Over-read character                                        */
897  } NRF_SPIS_Type;                                &bsol;*!< Size = 1476 (0x5c4)                                                       */
898  typedef struct {                                &bsol;*!< (@ 0x40003000) TWI0 Structure                                             */
899    __OM  uint32_t  TASKS_STARTRX;                &bsol;*!< (@ 0x00000000) Start TWI receive sequence                                 */
900    __IM  uint32_t  RESERVED;
901    __OM  uint32_t  TASKS_STARTTX;                &bsol;*!< (@ 0x00000008) Start TWI transmit sequence                                */
902    __IM  uint32_t  RESERVED1[2];
903    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000014) Stop TWI transaction                                       */
904    __IM  uint32_t  RESERVED2;
905    __OM  uint32_t  TASKS_SUSPEND;                &bsol;*!< (@ 0x0000001C) Suspend TWI transaction                                    */
906    __OM  uint32_t  TASKS_RESUME;                 &bsol;*!< (@ 0x00000020) Resume TWI transaction                                     */
907    __IM  uint32_t  RESERVED3[56];
908    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000104) TWI stopped                                                */
909    __IOM uint32_t  EVENTS_RXDREADY;              &bsol;*!< (@ 0x00000108) TWI RXD byte received                                      */
910    __IM  uint32_t  RESERVED4[4];
911    __IOM uint32_t  EVENTS_TXDSENT;               &bsol;*!< (@ 0x0000011C) TWI TXD byte sent                                          */
912    __IM  uint32_t  RESERVED5;
913    __IOM uint32_t  EVENTS_ERROR;                 &bsol;*!< (@ 0x00000124) TWI error                                                  */
914    __IM  uint32_t  RESERVED6[4];
915    __IOM uint32_t  EVENTS_BB;                    &bsol;*!< (@ 0x00000138) TWI byte boundary, generated before each byte
916                                                                      that is sent or received                                   */
917    __IM  uint32_t  RESERVED7[3];
918    __IOM uint32_t  EVENTS_SUSPENDED;             &bsol;*!< (@ 0x00000148) TWI entered the suspended state                            */
919    __IM  uint32_t  RESERVED8[45];
920    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
921    __IM  uint32_t  RESERVED9[64];
922    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
923    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
924    __IM  uint32_t  RESERVED10[110];
925    __IOM uint32_t  ERRORSRC;                     &bsol;*!< (@ 0x000004C4) Error source                                               */
926    __IM  uint32_t  RESERVED11[14];
927    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable TWI                                                 */
928    __IM  uint32_t  RESERVED12;
929    __IOM TWI_PSEL_Type PSEL;                     &bsol;*!< (@ 0x00000508) Unspecified                                                */
930    __IM  uint32_t  RESERVED13[2];
931    __IM  uint32_t  RXD;                          &bsol;*!< (@ 0x00000518) RXD register                                               */
932    __IOM uint32_t  TXD;                          &bsol;*!< (@ 0x0000051C) TXD register                                               */
933    __IM  uint32_t  RESERVED14;
934    __IOM uint32_t  FREQUENCY;                    &bsol;*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
935                                                                      source selected.                                           */
936    __IM  uint32_t  RESERVED15[24];
937    __IOM uint32_t  ADDRESS;                      &bsol;*!< (@ 0x00000588) Address used in the TWI transfer                           */
938  } NRF_TWI_Type;                                 &bsol;*!< Size = 1420 (0x58c)                                                       */
939  typedef struct {                                &bsol;*!< (@ 0x40003000) TWIM0 Structure                                            */
940    __OM  uint32_t  TASKS_STARTRX;                &bsol;*!< (@ 0x00000000) Start TWI receive sequence                                 */
941    __IM  uint32_t  RESERVED;
942    __OM  uint32_t  TASKS_STARTTX;                &bsol;*!< (@ 0x00000008) Start TWI transmit sequence                                */
943    __IM  uint32_t  RESERVED1[2];
944    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000014) Stop TWI transaction. Must be issued while the
945                                                                      TWI master is not suspended.                               */
946    __IM  uint32_t  RESERVED2;
947    __OM  uint32_t  TASKS_SUSPEND;                &bsol;*!< (@ 0x0000001C) Suspend TWI transaction                                    */
948    __OM  uint32_t  TASKS_RESUME;                 &bsol;*!< (@ 0x00000020) Resume TWI transaction                                     */
949    __IM  uint32_t  RESERVED3[56];
950    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000104) TWI stopped                                                */
951    __IM  uint32_t  RESERVED4[7];
952    __IOM uint32_t  EVENTS_ERROR;                 &bsol;*!< (@ 0x00000124) TWI error                                                  */
953    __IM  uint32_t  RESERVED5[8];
954    __IOM uint32_t  EVENTS_SUSPENDED;             &bsol;*!< (@ 0x00000148) Last byte has been sent out after the SUSPEND
955                                                                      task has been issued, TWI traffic is now
956                                                                      suspended.                                                 */
957    __IOM uint32_t  EVENTS_RXSTARTED;             &bsol;*!< (@ 0x0000014C) Receive sequence started                                   */
958    __IOM uint32_t  EVENTS_TXSTARTED;             &bsol;*!< (@ 0x00000150) Transmit sequence started                                  */
959    __IM  uint32_t  RESERVED6[2];
960    __IOM uint32_t  EVENTS_LASTRX;                &bsol;*!< (@ 0x0000015C) Byte boundary, starting to receive the last byte           */
961    __IOM uint32_t  EVENTS_LASTTX;                &bsol;*!< (@ 0x00000160) Byte boundary, starting to transmit the last
962                                                                      byte                                                       */
963    __IM  uint32_t  RESERVED7[39];
964    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
965    __IM  uint32_t  RESERVED8[63];
966    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
967    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
968    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
969    __IM  uint32_t  RESERVED9[110];
970    __IOM uint32_t  ERRORSRC;                     &bsol;*!< (@ 0x000004C4) Error source                                               */
971    __IM  uint32_t  RESERVED10[14];
972    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable TWIM                                                */
973    __IM  uint32_t  RESERVED11;
974    __IOM TWIM_PSEL_Type PSEL;                    &bsol;*!< (@ 0x00000508) Unspecified                                                */
975    __IM  uint32_t  RESERVED12[5];
976    __IOM uint32_t  FREQUENCY;                    &bsol;*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
977                                                                      source selected.                                           */
978    __IM  uint32_t  RESERVED13[3];
979    __IOM TWIM_RXD_Type RXD;                      &bsol;*!< (@ 0x00000534) RXD EasyDMA channel                                        */
980    __IOM TWIM_TXD_Type TXD;                      &bsol;*!< (@ 0x00000544) TXD EasyDMA channel                                        */
981    __IM  uint32_t  RESERVED14[13];
982    __IOM uint32_t  ADDRESS;                      &bsol;*!< (@ 0x00000588) Address used in the TWI transfer                           */
983  } NRF_TWIM_Type;                                &bsol;*!< Size = 1420 (0x58c)                                                       */
984  typedef struct {                                &bsol;*!< (@ 0x40003000) TWIS0 Structure                                            */
985    __IM  uint32_t  RESERVED[5];
986    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000014) Stop TWI transaction                                       */
987    __IM  uint32_t  RESERVED1;
988    __OM  uint32_t  TASKS_SUSPEND;                &bsol;*!< (@ 0x0000001C) Suspend TWI transaction                                    */
989    __OM  uint32_t  TASKS_RESUME;                 &bsol;*!< (@ 0x00000020) Resume TWI transaction                                     */
990    __IM  uint32_t  RESERVED2[3];
991    __OM  uint32_t  TASKS_PREPARERX;              &bsol;*!< (@ 0x00000030) Prepare the TWI slave to respond to a write command        */
992    __OM  uint32_t  TASKS_PREPARETX;              &bsol;*!< (@ 0x00000034) Prepare the TWI slave to respond to a read command         */
993    __IM  uint32_t  RESERVED3[51];
994    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000104) TWI stopped                                                */
995    __IM  uint32_t  RESERVED4[7];
996    __IOM uint32_t  EVENTS_ERROR;                 &bsol;*!< (@ 0x00000124) TWI error                                                  */
997    __IM  uint32_t  RESERVED5[9];
998    __IOM uint32_t  EVENTS_RXSTARTED;             &bsol;*!< (@ 0x0000014C) Receive sequence started                                   */
999    __IOM uint32_t  EVENTS_TXSTARTED;             &bsol;*!< (@ 0x00000150) Transmit sequence started                                  */
1000    __IM  uint32_t  RESERVED6[4];
1001    __IOM uint32_t  EVENTS_WRITE;                 &bsol;*!< (@ 0x00000164) Write command received                                     */
1002    __IOM uint32_t  EVENTS_READ;                  &bsol;*!< (@ 0x00000168) Read command received                                      */
1003    __IM  uint32_t  RESERVED7[37];
1004    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1005    __IM  uint32_t  RESERVED8[63];
1006    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1007    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1008    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1009    __IM  uint32_t  RESERVED9[113];
1010    __IOM uint32_t  ERRORSRC;                     &bsol;*!< (@ 0x000004D0) Error source                                               */
1011    __IM  uint32_t  MATCH;                        &bsol;*!< (@ 0x000004D4) Status register indicating which address had
1012                                                                      a match                                                    */
1013    __IM  uint32_t  RESERVED10[10];
1014    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable TWIS                                                */
1015    __IM  uint32_t  RESERVED11;
1016    __IOM TWIS_PSEL_Type PSEL;                    &bsol;*!< (@ 0x00000508) Unspecified                                                */
1017    __IM  uint32_t  RESERVED12[9];
1018    __IOM TWIS_RXD_Type RXD;                      &bsol;*!< (@ 0x00000534) RXD EasyDMA channel                                        */
1019    __IOM TWIS_TXD_Type TXD;                      &bsol;*!< (@ 0x00000544) TXD EasyDMA channel                                        */
1020    __IM  uint32_t  RESERVED13[13];
1021    __IOM uint32_t  ADDRESS[2];                   &bsol;*!< (@ 0x00000588) Description collection: TWI slave address n                */
1022    __IM  uint32_t  RESERVED14;
1023    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x00000594) Configuration register for the address match
1024                                                                      mechanism                                                  */
1025    __IM  uint32_t  RESERVED15[10];
1026    __IOM uint32_t  ORC;                          &bsol;*!< (@ 0x000005C0) Over-read character. Character sent out in case
1027                                                                      of an over-read of the transmit buffer.                    */
1028  } NRF_TWIS_Type;                                &bsol;*!< Size = 1476 (0x5c4)                                                       */
1029  typedef struct {                                &bsol;*!< (@ 0x40005000) NFCT Structure                                             */
1030    __OM  uint32_t  TASKS_ACTIVATE;               &bsol;*!< (@ 0x00000000) Activate NFCT peripheral for incoming and outgoing
1031                                                                      frames, change state to activated                          */
1032    __OM  uint32_t  TASKS_DISABLE;                &bsol;*!< (@ 0x00000004) Disable NFCT peripheral                                    */
1033    __OM  uint32_t  TASKS_SENSE;                  &bsol;*!< (@ 0x00000008) Enable NFC sense field mode, change state to
1034                                                                      sense mode                                                 */
1035    __OM  uint32_t  TASKS_STARTTX;                &bsol;*!< (@ 0x0000000C) Start transmission of an outgoing frame, change
1036                                                                      state to transmit                                          */
1037    __IM  uint32_t  RESERVED[3];
1038    __OM  uint32_t  TASKS_ENABLERXDATA;           &bsol;*!< (@ 0x0000001C) Initializes the EasyDMA for receive.                       */
1039    __IM  uint32_t  RESERVED1;
1040    __OM  uint32_t  TASKS_GOIDLE;                 &bsol;*!< (@ 0x00000024) Force state machine to IDLE state                          */
1041    __OM  uint32_t  TASKS_GOSLEEP;                &bsol;*!< (@ 0x00000028) Force state machine to SLEEP_A state                       */
1042    __IM  uint32_t  RESERVED2[53];
1043    __IOM uint32_t  EVENTS_READY;                 &bsol;*!< (@ 0x00000100) The NFCT peripheral is ready to receive and send
1044                                                                      frames                                                     */
1045    __IOM uint32_t  EVENTS_FIELDDETECTED;         &bsol;*!< (@ 0x00000104) Remote NFC field detected                                  */
1046    __IOM uint32_t  EVENTS_FIELDLOST;             &bsol;*!< (@ 0x00000108) Remote NFC field lost                                      */
1047    __IOM uint32_t  EVENTS_TXFRAMESTART;          &bsol;*!< (@ 0x0000010C) Marks the start of the first symbol of a transmitted
1048                                                                      frame                                                      */
1049    __IOM uint32_t  EVENTS_TXFRAMEEND;            &bsol;*!< (@ 0x00000110) Marks the end of the last transmitted on-air
1050                                                                      symbol of a frame                                          */
1051    __IOM uint32_t  EVENTS_RXFRAMESTART;          &bsol;*!< (@ 0x00000114) Marks the end of the first symbol of a received
1052                                                                      frame                                                      */
1053    __IOM uint32_t  EVENTS_RXFRAMEEND;            &bsol;*!< (@ 0x00000118) Received data has been checked (CRC, parity)
1054                                                                      and transferred to RAM, and EasyDMA has
1055                                                                      ended accessing the RX buffer                              */
1056    __IOM uint32_t  EVENTS_ERROR;                 &bsol;*!< (@ 0x0000011C) NFC error reported. The ERRORSTATUS register
1057                                                                      contains details on the source of the error.               */
1058    __IM  uint32_t  RESERVED3[2];
1059    __IOM uint32_t  EVENTS_RXERROR;               &bsol;*!< (@ 0x00000128) NFC RX frame error reported. The FRAMESTATUS.RX
1060                                                                      register contains details on the source
1061                                                                      of the error.                                              */
1062    __IOM uint32_t  EVENTS_ENDRX;                 &bsol;*!< (@ 0x0000012C) RX buffer (as defined by PACKETPTR and MAXLEN)
1063                                                                      in Data RAM full.                                          */
1064    __IOM uint32_t  EVENTS_ENDTX;                 &bsol;*!< (@ 0x00000130) Transmission of data in RAM has ended, and EasyDMA
1065                                                                      has ended accessing the TX buffer                          */
1066    __IM  uint32_t  RESERVED4;
1067    __IOM uint32_t  EVENTS_AUTOCOLRESSTARTED;     &bsol;*!< (@ 0x00000138) Auto collision resolution process has started              */
1068    __IM  uint32_t  RESERVED5[3];
1069    __IOM uint32_t  EVENTS_COLLISION;             &bsol;*!< (@ 0x00000148) NFC auto collision resolution error reported.              */
1070    __IOM uint32_t  EVENTS_SELECTED;              &bsol;*!< (@ 0x0000014C) NFC auto collision resolution successfully completed       */
1071    __IOM uint32_t  EVENTS_STARTED;               &bsol;*!< (@ 0x00000150) EasyDMA is ready to receive or send frames.                */
1072    __IM  uint32_t  RESERVED6[43];
1073    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1074    __IM  uint32_t  RESERVED7[63];
1075    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1076    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1077    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1078    __IM  uint32_t  RESERVED8[62];
1079    __IOM uint32_t  ERRORSTATUS;                  &bsol;*!< (@ 0x00000404) NFC Error Status register                                  */
1080    __IM  uint32_t  RESERVED9;
1081    __IOM NFCT_FRAMESTATUS_Type FRAMESTATUS;      &bsol;*!< (@ 0x0000040C) Unspecified                                                */
1082    __IM  uint32_t  NFCTAGSTATE;                  &bsol;*!< (@ 0x00000410) NfcTag state register                                      */
1083    __IM  uint32_t  RESERVED10[3];
1084    __IM  uint32_t  SLEEPSTATE;                   &bsol;*!< (@ 0x00000420) Sleep state during automatic collision resolution          */
1085    __IM  uint32_t  RESERVED11[6];
1086    __IM  uint32_t  FIELDPRESENT;                 &bsol;*!< (@ 0x0000043C) Indicates the presence or not of a valid field             */
1087    __IM  uint32_t  RESERVED12[49];
1088    __IOM uint32_t  FRAMEDELAYMIN;                &bsol;*!< (@ 0x00000504) Minimum frame delay                                        */
1089    __IOM uint32_t  FRAMEDELAYMAX;                &bsol;*!< (@ 0x00000508) Maximum frame delay                                        */
1090    __IOM uint32_t  FRAMEDELAYMODE;               &bsol;*!< (@ 0x0000050C) Configuration register for the Frame Delay Timer           */
1091    __IOM uint32_t  PACKETPTR;                    &bsol;*!< (@ 0x00000510) Packet pointer for TXD and RXD data storage in
1092                                                                      Data RAM                                                   */
1093    __IOM uint32_t  MAXLEN;                       &bsol;*!< (@ 0x00000514) Size of the RAM buffer allocated to TXD and RXD
1094                                                                      data storage each                                          */
1095    __IOM NFCT_TXD_Type TXD;                      &bsol;*!< (@ 0x00000518) Unspecified                                                */
1096    __IOM NFCT_RXD_Type RXD;                      &bsol;*!< (@ 0x00000520) Unspecified                                                */
1097    __IM  uint32_t  RESERVED13;
1098    __IOM uint32_t  MODULATIONCTRL;               &bsol;*!< (@ 0x0000052C) Enables the modulation output to a GPIO pin which
1099                                                                      can be connected to a second external antenna.             */
1100    __IM  uint32_t  RESERVED14[2];
1101    __IOM uint32_t  MODULATIONPSEL;               &bsol;*!< (@ 0x00000538) Pin select for Modulation control.                         */
1102    __IM  uint32_t  RESERVED15[21];
1103    __IOM uint32_t  NFCID1_LAST;                  &bsol;*!< (@ 0x00000590) Last NFCID1 part (4, 7 or 10 bytes ID)                     */
1104    __IOM uint32_t  NFCID1_2ND_LAST;              &bsol;*!< (@ 0x00000594) Second last NFCID1 part (7 or 10 bytes ID)                 */
1105    __IOM uint32_t  NFCID1_3RD_LAST;              &bsol;*!< (@ 0x00000598) Third last NFCID1 part (10 bytes ID)                       */
1106    __IOM uint32_t  AUTOCOLRESCONFIG;             &bsol;*!< (@ 0x0000059C) Controls the auto collision resolution function.
1107                                                                      This setting must be done before the NFCT
1108                                                                      peripheral is activated.                                   */
1109    __IOM uint32_t  SENSRES;                      &bsol;*!< (@ 0x000005A0) NFC-A SENS_RES auto-response settings                      */
1110    __IOM uint32_t  SELRES;                       &bsol;*!< (@ 0x000005A4) NFC-A SEL_RES auto-response settings                       */
1111  } NRF_NFCT_Type;                                &bsol;*!< Size = 1448 (0x5a8)                                                       */
1112  typedef struct {                                &bsol;*!< (@ 0x40006000) GPIOTE Structure                                           */
1113    __OM  uint32_t  TASKS_OUT[8];                 &bsol;*!< (@ 0x00000000) Description collection: Task for writing to pin
1114                                                                      specified in CONFIG[n].PSEL. Action on pin
1115                                                                      is configured in CONFIG[n].POLARITY.                       */
1116    __IM  uint32_t  RESERVED[4];
1117    __OM  uint32_t  TASKS_SET[8];                 &bsol;*!< (@ 0x00000030) Description collection: Task for writing to pin
1118                                                                      specified in CONFIG[n].PSEL. Action on pin
1119                                                                      is to set it high.                                         */
1120    __IM  uint32_t  RESERVED1[4];
1121    __OM  uint32_t  TASKS_CLR[8];                 &bsol;*!< (@ 0x00000060) Description collection: Task for writing to pin
1122                                                                      specified in CONFIG[n].PSEL. Action on pin
1123                                                                      is to set it low.                                          */
1124    __IM  uint32_t  RESERVED2[32];
1125    __IOM uint32_t  EVENTS_IN[8];                 &bsol;*!< (@ 0x00000100) Description collection: Event generated from
1126                                                                      pin specified in CONFIG[n].PSEL                            */
1127    __IM  uint32_t  RESERVED3[23];
1128    __IOM uint32_t  EVENTS_PORT;                  &bsol;*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
1129                                                                      with SENSE mechanism enabled                               */
1130    __IM  uint32_t  RESERVED4[97];
1131    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1132    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1133    __IM  uint32_t  RESERVED5[129];
1134    __IOM uint32_t  CONFIG[8];                    &bsol;*!< (@ 0x00000510) Description collection: Configuration for OUT[n],
1135                                                                      SET[n], and CLR[n] tasks and IN[n] event                   */
1136  } NRF_GPIOTE_Type;                              &bsol;*!< Size = 1328 (0x530)                                                       */
1137  typedef struct {                                &bsol;*!< (@ 0x40007000) SAADC Structure                                            */
1138    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Starts the SAADC and prepares the result buffer
1139                                                                      in RAM                                                     */
1140    __OM  uint32_t  TASKS_SAMPLE;                 &bsol;*!< (@ 0x00000004) Takes one SAADC sample                                     */
1141    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000008) Stops the SAADC and terminates all on-going conversions    */
1142    __OM  uint32_t  TASKS_CALIBRATEOFFSET;        &bsol;*!< (@ 0x0000000C) Starts offset auto-calibration                             */
1143    __IM  uint32_t  RESERVED[60];
1144    __IOM uint32_t  EVENTS_STARTED;               &bsol;*!< (@ 0x00000100) The SAADC has started                                      */
1145    __IOM uint32_t  EVENTS_END;                   &bsol;*!< (@ 0x00000104) The SAADC has filled up the result buffer                  */
1146    __IOM uint32_t  EVENTS_DONE;                  &bsol;*!< (@ 0x00000108) A conversion task has been completed. Depending
1147                                                                      on the configuration, multiple conversions
1148                                                                      might be needed for a result to be transferred
1149                                                                      to RAM.                                                    */
1150    __IOM uint32_t  EVENTS_RESULTDONE;            &bsol;*!< (@ 0x0000010C) Result ready for transfer to RAM                           */
1151    __IOM uint32_t  EVENTS_CALIBRATEDONE;         &bsol;*!< (@ 0x00000110) Calibration is complete                                    */
1152    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000114) The SAADC has stopped                                      */
1153    __IOM SAADC_EVENTS_CH_Type EVENTS_CH[8];      &bsol;*!< (@ 0x00000118) Peripheral events.                                         */
1154    __IM  uint32_t  RESERVED1[106];
1155    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1156    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1157    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1158    __IM  uint32_t  RESERVED2[61];
1159    __IM  uint32_t  STATUS;                       &bsol;*!< (@ 0x00000400) Status                                                     */
1160    __IM  uint32_t  RESERVED3[63];
1161    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable or disable SAADC                                    */
1162    __IM  uint32_t  RESERVED4[3];
1163    __IOM SAADC_CH_Type CH[8];                    &bsol;*!< (@ 0x00000510) Unspecified                                                */
1164    __IM  uint32_t  RESERVED5[24];
1165    __IOM uint32_t  RESOLUTION;                   &bsol;*!< (@ 0x000005F0) Resolution configuration                                   */
1166    __IOM uint32_t  OVERSAMPLE;                   &bsol;*!< (@ 0x000005F4) Oversampling configuration. The RESOLUTION is
1167                                                                      applied before averaging, thus for high
1168                                                                      OVERSAMPLE a higher RESOLUTION should be
1169                                                                      used.                                                      */
1170    __IOM uint32_t  SAMPLERATE;                   &bsol;*!< (@ 0x000005F8) Controls normal or continuous sample rate                  */
1171    __IM  uint32_t  RESERVED6[12];
1172    __IOM SAADC_RESULT_Type RESULT;               &bsol;*!< (@ 0x0000062C) RESULT EasyDMA channel                                     */
1173  } NRF_SAADC_Type;                               &bsol;*!< Size = 1592 (0x638)                                                       */
1174  typedef struct {                                &bsol;*!< (@ 0x40008000) TIMER0 Structure                                           */
1175    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Start Timer                                                */
1176    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Stop Timer                                                 */
1177    __OM  uint32_t  TASKS_COUNT;                  &bsol;*!< (@ 0x00000008) Increment Timer (Counter mode only)                        */
1178    __OM  uint32_t  TASKS_CLEAR;                  &bsol;*!< (@ 0x0000000C) Clear time                                                 */
1179    __OM  uint32_t  TASKS_SHUTDOWN;               &bsol;*!< (@ 0x00000010) Deprecated register - Shut down timer                      */
1180    __IM  uint32_t  RESERVED[11];
1181    __OM  uint32_t  TASKS_CAPTURE[6];             &bsol;*!< (@ 0x00000040) Description collection: Capture Timer value to
1182                                                                      CC[n] register                                             */
1183    __IM  uint32_t  RESERVED1[58];
1184    __IOM uint32_t  EVENTS_COMPARE[6];            &bsol;*!< (@ 0x00000140) Description collection: Compare event on CC[n]
1185                                                                      match                                                      */
1186    __IM  uint32_t  RESERVED2[42];
1187    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1188    __IM  uint32_t  RESERVED3[64];
1189    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1190    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1191    __IM  uint32_t  RESERVED4[126];
1192    __IOM uint32_t  MODE;                         &bsol;*!< (@ 0x00000504) Timer mode selection                                       */
1193    __IOM uint32_t  BITMODE;                      &bsol;*!< (@ 0x00000508) Configure the number of bits used by the TIMER             */
1194    __IM  uint32_t  RESERVED5;
1195    __IOM uint32_t  PRESCALER;                    &bsol;*!< (@ 0x00000510) Timer prescaler register                                   */
1196    __IM  uint32_t  RESERVED6[11];
1197    __IOM uint32_t  CC[6];                        &bsol;*!< (@ 0x00000540) Description collection: Capture/Compare register
1198                                                                      n                                                          */
1199  } NRF_TIMER_Type;                               &bsol;*!< Size = 1368 (0x558)                                                       */
1200  typedef struct {                                &bsol;*!< (@ 0x4000B000) RTC0 Structure                                             */
1201    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Start RTC COUNTER                                          */
1202    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Stop RTC COUNTER                                           */
1203    __OM  uint32_t  TASKS_CLEAR;                  &bsol;*!< (@ 0x00000008) Clear RTC COUNTER                                          */
1204    __OM  uint32_t  TASKS_TRIGOVRFLW;             &bsol;*!< (@ 0x0000000C) Set COUNTER to 0xFFFFF0                                    */
1205    __IM  uint32_t  RESERVED[60];
1206    __IOM uint32_t  EVENTS_TICK;                  &bsol;*!< (@ 0x00000100) Event on COUNTER increment                                 */
1207    __IOM uint32_t  EVENTS_OVRFLW;                &bsol;*!< (@ 0x00000104) Event on COUNTER overflow                                  */
1208    __IM  uint32_t  RESERVED1[14];
1209    __IOM uint32_t  EVENTS_COMPARE[4];            &bsol;*!< (@ 0x00000140) Description collection: Compare event on CC[n]
1210                                                                      match                                                      */
1211    __IM  uint32_t  RESERVED2[109];
1212    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1213    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1214    __IM  uint32_t  RESERVED3[13];
1215    __IOM uint32_t  EVTEN;                        &bsol;*!< (@ 0x00000340) Enable or disable event routing                            */
1216    __IOM uint32_t  EVTENSET;                     &bsol;*!< (@ 0x00000344) Enable event routing                                       */
1217    __IOM uint32_t  EVTENCLR;                     &bsol;*!< (@ 0x00000348) Disable event routing                                      */
1218    __IM  uint32_t  RESERVED4[110];
1219    __IM  uint32_t  COUNTER;                      &bsol;*!< (@ 0x00000504) Current COUNTER value                                      */
1220    __IOM uint32_t  PRESCALER;                    &bsol;*!< (@ 0x00000508) 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Mu
1221                                                                      t be written when RTC is stopped                           */
1222    __IM  uint32_t  RESERVED5[13];
1223    __IOM uint32_t  CC[4];                        &bsol;*!< (@ 0x00000540) Description collection: Compare register n                 */
1224  } NRF_RTC_Type;                                 &bsol;*!< Size = 1360 (0x550)                                                       */
1225  typedef struct {                                &bsol;*!< (@ 0x4000C000) TEMP Structure                                             */
1226    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Start temperature measurement                              */
1227    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Stop temperature measurement                               */
1228    __IM  uint32_t  RESERVED[62];
1229    __IOM uint32_t  EVENTS_DATARDY;               &bsol;*!< (@ 0x00000100) Temperature measurement complete, data ready               */
1230    __IM  uint32_t  RESERVED1[128];
1231    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1232    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1233    __IM  uint32_t  RESERVED2[127];
1234    __IM  int32_t   TEMP;                         &bsol;*!< (@ 0x00000508) Temperature in degC (0.25deg steps)                        */
1235    __IM  uint32_t  RESERVED3[5];
1236    __IOM uint32_t  A0;                           &bsol;*!< (@ 0x00000520) Slope of 1st piece wise linear function                    */
1237    __IOM uint32_t  A1;                           &bsol;*!< (@ 0x00000524) Slope of 2nd piece wise linear function                    */
1238    __IOM uint32_t  A2;                           &bsol;*!< (@ 0x00000528) Slope of 3rd piece wise linear function                    */
1239    __IOM uint32_t  A3;                           &bsol;*!< (@ 0x0000052C) Slope of 4th piece wise linear function                    */
1240    __IOM uint32_t  A4;                           &bsol;*!< (@ 0x00000530) Slope of 5th piece wise linear function                    */
1241    __IOM uint32_t  A5;                           &bsol;*!< (@ 0x00000534) Slope of 6th piece wise linear function                    */
1242    __IM  uint32_t  RESERVED4[2];
1243    __IOM uint32_t  B0;                           &bsol;*!< (@ 0x00000540) y-intercept of 1st piece wise linear function              */
1244    __IOM uint32_t  B1;                           &bsol;*!< (@ 0x00000544) y-intercept of 2nd piece wise linear function              */
1245    __IOM uint32_t  B2;                           &bsol;*!< (@ 0x00000548) y-intercept of 3rd piece wise linear function              */
1246    __IOM uint32_t  B3;                           &bsol;*!< (@ 0x0000054C) y-intercept of 4th piece wise linear function              */
1247    __IOM uint32_t  B4;                           &bsol;*!< (@ 0x00000550) y-intercept of 5th piece wise linear function              */
1248    __IOM uint32_t  B5;                           &bsol;*!< (@ 0x00000554) y-intercept of 6th piece wise linear function              */
1249    __IM  uint32_t  RESERVED5[2];
1250    __IOM uint32_t  T0;                           &bsol;*!< (@ 0x00000560) End point of 1st piece wise linear function                */
1251    __IOM uint32_t  T1;                           &bsol;*!< (@ 0x00000564) End point of 2nd piece wise linear function                */
1252    __IOM uint32_t  T2;                           &bsol;*!< (@ 0x00000568) End point of 3rd piece wise linear function                */
1253    __IOM uint32_t  T3;                           &bsol;*!< (@ 0x0000056C) End point of 4th piece wise linear function                */
1254    __IOM uint32_t  T4;                           &bsol;*!< (@ 0x00000570) End point of 5th piece wise linear function                */
1255  } NRF_TEMP_Type;                                &bsol;*!< Size = 1396 (0x574)                                                       */
1256  typedef struct {                                &bsol;*!< (@ 0x4000D000) RNG Structure                                              */
1257    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Task starting the random number generator                  */
1258    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Task stopping the random number generator                  */
1259    __IM  uint32_t  RESERVED[62];
1260    __IOM uint32_t  EVENTS_VALRDY;                &bsol;*!< (@ 0x00000100) Event being generated for every new random number
1261                                                                      written to the VALUE register                              */
1262    __IM  uint32_t  RESERVED1[63];
1263    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1264    __IM  uint32_t  RESERVED2[64];
1265    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1266    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1267    __IM  uint32_t  RESERVED3[126];
1268    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x00000504) Configuration register                                     */
1269    __IM  uint32_t  VALUE;                        &bsol;*!< (@ 0x00000508) Output random number                                       */
1270  } NRF_RNG_Type;                                 &bsol;*!< Size = 1292 (0x50c)                                                       */
1271  typedef struct {                                &bsol;*!< (@ 0x4000E000) ECB Structure                                              */
1272    __OM  uint32_t  TASKS_STARTECB;               &bsol;*!< (@ 0x00000000) Start ECB block encrypt                                    */
1273    __OM  uint32_t  TASKS_STOPECB;                &bsol;*!< (@ 0x00000004) Abort a possible executing ECB operation                   */
1274    __IM  uint32_t  RESERVED[62];
1275    __IOM uint32_t  EVENTS_ENDECB;                &bsol;*!< (@ 0x00000100) ECB block encrypt complete                                 */
1276    __IOM uint32_t  EVENTS_ERRORECB;              &bsol;*!< (@ 0x00000104) ECB block encrypt aborted because of a STOPECB
1277                                                                      task or due to an error                                    */
1278    __IM  uint32_t  RESERVED1[127];
1279    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1280    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1281    __IM  uint32_t  RESERVED2[126];
1282    __IOM uint32_t  ECBDATAPTR;                   &bsol;*!< (@ 0x00000504) ECB block encrypt memory pointers                          */
1283  } NRF_ECB_Type;                                 &bsol;*!< Size = 1288 (0x508)                                                       */
1284  typedef struct {                                &bsol;*!< (@ 0x4000F000) AAR Structure                                              */
1285    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Start resolving addresses based on IRKs specified
1286                                                                      in the IRK data structure                                  */
1287    __IM  uint32_t  RESERVED;
1288    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000008) Stop resolving addresses                                   */
1289    __IM  uint32_t  RESERVED1[61];
1290    __IOM uint32_t  EVENTS_END;                   &bsol;*!< (@ 0x00000100) Address resolution procedure complete                      */
1291    __IOM uint32_t  EVENTS_RESOLVED;              &bsol;*!< (@ 0x00000104) Address resolved                                           */
1292    __IOM uint32_t  EVENTS_NOTRESOLVED;           &bsol;*!< (@ 0x00000108) Address not resolved                                       */
1293    __IM  uint32_t  RESERVED2[126];
1294    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1295    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1296    __IM  uint32_t  RESERVED3[61];
1297    __IM  uint32_t  STATUS;                       &bsol;*!< (@ 0x00000400) Resolution status                                          */
1298    __IM  uint32_t  RESERVED4[63];
1299    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable AAR                                                 */
1300    __IOM uint32_t  NIRK;                         &bsol;*!< (@ 0x00000504) Number of IRKs                                             */
1301    __IOM uint32_t  IRKPTR;                       &bsol;*!< (@ 0x00000508) Pointer to IRK data structure                              */
1302    __IM  uint32_t  RESERVED5;
1303    __IOM uint32_t  ADDRPTR;                      &bsol;*!< (@ 0x00000510) Pointer to the resolvable address                          */
1304    __IOM uint32_t  SCRATCHPTR;                   &bsol;*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
1305  } NRF_AAR_Type;                                 &bsol;*!< Size = 1304 (0x518)                                                       */
1306  typedef struct {                                &bsol;*!< (@ 0x4000F000) CCM Structure                                              */
1307    __OM  uint32_t  TASKS_KSGEN;                  &bsol;*!< (@ 0x00000000) Start generation of key-stream. This operation
1308                                                                      will stop by itself when completed.                        */
1309    __OM  uint32_t  TASKS_CRYPT;                  &bsol;*!< (@ 0x00000004) Start encryption/decryption. This operation will
1310                                                                      stop by itself when completed.                             */
1311    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000008) Stop encryption/decryption                                 */
1312    __OM  uint32_t  TASKS_RATEOVERRIDE;           &bsol;*!< (@ 0x0000000C) Override DATARATE setting in MODE register with
1313                                                                      the contents of the RATEOVERRIDE register
1314                                                                      for any ongoing encryption/decryption                      */
1315    __IM  uint32_t  RESERVED[60];
1316    __IOM uint32_t  EVENTS_ENDKSGEN;              &bsol;*!< (@ 0x00000100) Key-stream generation complete                             */
1317    __IOM uint32_t  EVENTS_ENDCRYPT;              &bsol;*!< (@ 0x00000104) Encrypt/decrypt complete                                   */
1318    __IOM uint32_t  EVENTS_ERROR;                 &bsol;*!< (@ 0x00000108) Deprecated register - CCM error event                      */
1319    __IM  uint32_t  RESERVED1[61];
1320    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1321    __IM  uint32_t  RESERVED2[64];
1322    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1323    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1324    __IM  uint32_t  RESERVED3[61];
1325    __IM  uint32_t  MICSTATUS;                    &bsol;*!< (@ 0x00000400) MIC check result                                           */
1326    __IM  uint32_t  RESERVED4[63];
1327    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable                                                     */
1328    __IOM uint32_t  MODE;                         &bsol;*!< (@ 0x00000504) Operation mode                                             */
1329    __IOM uint32_t  CNFPTR;                       &bsol;*!< (@ 0x00000508) Pointer to data structure holding AES key and
1330                                                                      NONCE vector                                               */
1331    __IOM uint32_t  INPTR;                        &bsol;*!< (@ 0x0000050C) Input pointer                                              */
1332    __IOM uint32_t  OUTPTR;                       &bsol;*!< (@ 0x00000510) Output pointer                                             */
1333    __IOM uint32_t  SCRATCHPTR;                   &bsol;*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
1334    __IOM uint32_t  MAXPACKETSIZE;                &bsol;*!< (@ 0x00000518) Length of key-stream generated when MODE.LENGTH
1335                                                                      = Extended.                                                */
1336    __IOM uint32_t  RATEOVERRIDE;                 &bsol;*!< (@ 0x0000051C) Data rate override setting.                                */
1337  } NRF_CCM_Type;                                 &bsol;*!< Size = 1312 (0x520)                                                       */
1338  typedef struct {                                &bsol;*!< (@ 0x40010000) WDT Structure                                              */
1339    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Start the watchdog                                         */
1340    __IM  uint32_t  RESERVED[63];
1341    __IOM uint32_t  EVENTS_TIMEOUT;               &bsol;*!< (@ 0x00000100) Watchdog timeout                                           */
1342    __IM  uint32_t  RESERVED1[128];
1343    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1344    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1345    __IM  uint32_t  RESERVED2[61];
1346    __IM  uint32_t  RUNSTATUS;                    &bsol;*!< (@ 0x00000400) Run status                                                 */
1347    __IM  uint32_t  REQSTATUS;                    &bsol;*!< (@ 0x00000404) Request status                                             */
1348    __IM  uint32_t  RESERVED3[63];
1349    __IOM uint32_t  CRV;                          &bsol;*!< (@ 0x00000504) Counter reload value                                       */
1350    __IOM uint32_t  RREN;                         &bsol;*!< (@ 0x00000508) Enable register for reload request registers               */
1351    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x0000050C) Configuration register                                     */
1352    __IM  uint32_t  RESERVED4[60];
1353    __OM  uint32_t  RR[8];                        &bsol;*!< (@ 0x00000600) Description collection: Reload request n                   */
1354  } NRF_WDT_Type;                                 &bsol;*!< Size = 1568 (0x620)                                                       */
1355  typedef struct {                                &bsol;*!< (@ 0x40012000) QDEC Structure                                             */
1356    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Task starting the quadrature decoder                       */
1357    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Task stopping the quadrature decoder                       */
1358    __OM  uint32_t  TASKS_READCLRACC;             &bsol;*!< (@ 0x00000008) Read and clear ACC and ACCDBL                              */
1359    __OM  uint32_t  TASKS_RDCLRACC;               &bsol;*!< (@ 0x0000000C) Read and clear ACC                                         */
1360    __OM  uint32_t  TASKS_RDCLRDBL;               &bsol;*!< (@ 0x00000010) Read and clear ACCDBL                                      */
1361    __IM  uint32_t  RESERVED[59];
1362    __IOM uint32_t  EVENTS_SAMPLERDY;             &bsol;*!< (@ 0x00000100) Event being generated for every new sample value
1363                                                                      written to the SAMPLE register                             */
1364    __IOM uint32_t  EVENTS_REPORTRDY;             &bsol;*!< (@ 0x00000104) Non-null report ready                                      */
1365    __IOM uint32_t  EVENTS_ACCOF;                 &bsol;*!< (@ 0x00000108) ACC or ACCDBL register overflow                            */
1366    __IOM uint32_t  EVENTS_DBLRDY;                &bsol;*!< (@ 0x0000010C) Double displacement(s) detected                            */
1367    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000110) QDEC has been stopped                                      */
1368    __IM  uint32_t  RESERVED1[59];
1369    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1370    __IM  uint32_t  RESERVED2[64];
1371    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1372    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1373    __IM  uint32_t  RESERVED3[125];
1374    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable the quadrature decoder                              */
1375    __IOM uint32_t  LEDPOL;                       &bsol;*!< (@ 0x00000504) LED output pin polarity                                    */
1376    __IOM uint32_t  SAMPLEPER;                    &bsol;*!< (@ 0x00000508) Sample period                                              */
1377    __IM  int32_t   SAMPLE;                       &bsol;*!< (@ 0x0000050C) Motion sample value                                        */
1378    __IOM uint32_t  REPORTPER;                    &bsol;*!< (@ 0x00000510) Number of samples to be taken before REPORTRDY
1379                                                                      and DBLRDY events can be generated                         */
1380    __IM  int32_t   ACC;                          &bsol;*!< (@ 0x00000514) Register accumulating the valid transitions                */
1381    __IM  int32_t   ACCREAD;                      &bsol;*!< (@ 0x00000518) Snapshot of the ACC register, updated by the
1382                                                                      READCLRACC or RDCLRACC task                                */
1383    __IOM QDEC_PSEL_Type PSEL;                    &bsol;*!< (@ 0x0000051C) Unspecified                                                */
1384    __IOM uint32_t  DBFEN;                        &bsol;*!< (@ 0x00000528) Enable input debounce filters                              */
1385    __IM  uint32_t  RESERVED4[5];
1386    __IOM uint32_t  LEDPRE;                       &bsol;*!< (@ 0x00000540) Time period the LED is switched ON prior to sampling       */
1387    __IM  uint32_t  ACCDBL;                       &bsol;*!< (@ 0x00000544) Register accumulating the number of detected
1388                                                                      double transitions                                         */
1389    __IM  uint32_t  ACCDBLREAD;                   &bsol;*!< (@ 0x00000548) Snapshot of the ACCDBL, updated by the READCLRACC
1390                                                                      or RDCLRDBL task                                           */
1391  } NRF_QDEC_Type;                                &bsol;*!< Size = 1356 (0x54c)                                                       */
1392  typedef struct {                                &bsol;*!< (@ 0x40013000) COMP Structure                                             */
1393    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Start comparator                                           */
1394    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Stop comparator                                            */
1395    __OM  uint32_t  TASKS_SAMPLE;                 &bsol;*!< (@ 0x00000008) Sample comparator value                                    */
1396    __IM  uint32_t  RESERVED[61];
1397    __IOM uint32_t  EVENTS_READY;                 &bsol;*!< (@ 0x00000100) COMP is ready and output is valid                          */
1398    __IOM uint32_t  EVENTS_DOWN;                  &bsol;*!< (@ 0x00000104) Downward crossing                                          */
1399    __IOM uint32_t  EVENTS_UP;                    &bsol;*!< (@ 0x00000108) Upward crossing                                            */
1400    __IOM uint32_t  EVENTS_CROSS;                 &bsol;*!< (@ 0x0000010C) Downward or upward crossing                                */
1401    __IM  uint32_t  RESERVED1[60];
1402    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1403    __IM  uint32_t  RESERVED2[63];
1404    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1405    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1406    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1407    __IM  uint32_t  RESERVED3[61];
1408    __IM  uint32_t  RESULT;                       &bsol;*!< (@ 0x00000400) Compare result                                             */
1409    __IM  uint32_t  RESERVED4[63];
1410    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) COMP enable                                                */
1411    __IOM uint32_t  PSEL;                         &bsol;*!< (@ 0x00000504) Pin select                                                 */
1412    __IOM uint32_t  REFSEL;                       &bsol;*!< (@ 0x00000508) Reference source select for single-ended mode              */
1413    __IOM uint32_t  EXTREFSEL;                    &bsol;*!< (@ 0x0000050C) External reference select                                  */
1414    __IM  uint32_t  RESERVED5[8];
1415    __IOM uint32_t  TH;                           &bsol;*!< (@ 0x00000530) Threshold configuration for hysteresis unit                */
1416    __IOM uint32_t  MODE;                         &bsol;*!< (@ 0x00000534) Mode configuration                                         */
1417    __IOM uint32_t  HYST;                         &bsol;*!< (@ 0x00000538) Comparator hysteresis enable                               */
1418  } NRF_COMP_Type;                                &bsol;*!< Size = 1340 (0x53c)                                                       */
1419  typedef struct {                                &bsol;*!< (@ 0x40013000) LPCOMP Structure                                           */
1420    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Start comparator                                           */
1421    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Stop comparator                                            */
1422    __OM  uint32_t  TASKS_SAMPLE;                 &bsol;*!< (@ 0x00000008) Sample comparator value                                    */
1423    __IM  uint32_t  RESERVED[61];
1424    __IOM uint32_t  EVENTS_READY;                 &bsol;*!< (@ 0x00000100) LPCOMP is ready and output is valid                        */
1425    __IOM uint32_t  EVENTS_DOWN;                  &bsol;*!< (@ 0x00000104) Downward crossing                                          */
1426    __IOM uint32_t  EVENTS_UP;                    &bsol;*!< (@ 0x00000108) Upward crossing                                            */
1427    __IOM uint32_t  EVENTS_CROSS;                 &bsol;*!< (@ 0x0000010C) Downward or upward crossing                                */
1428    __IM  uint32_t  RESERVED1[60];
1429    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1430    __IM  uint32_t  RESERVED2[64];
1431    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1432    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1433    __IM  uint32_t  RESERVED3[61];
1434    __IM  uint32_t  RESULT;                       &bsol;*!< (@ 0x00000400) Compare result                                             */
1435    __IM  uint32_t  RESERVED4[63];
1436    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable LPCOMP                                              */
1437    __IOM uint32_t  PSEL;                         &bsol;*!< (@ 0x00000504) Input pin select                                           */
1438    __IOM uint32_t  REFSEL;                       &bsol;*!< (@ 0x00000508) Reference select                                           */
1439    __IOM uint32_t  EXTREFSEL;                    &bsol;*!< (@ 0x0000050C) External reference select                                  */
1440    __IM  uint32_t  RESERVED5[4];
1441    __IOM uint32_t  ANADETECT;                    &bsol;*!< (@ 0x00000520) Analog detect configuration                                */
1442    __IM  uint32_t  RESERVED6[5];
1443    __IOM uint32_t  HYST;                         &bsol;*!< (@ 0x00000538) Comparator hysteresis enable                               */
1444  } NRF_LPCOMP_Type;                              &bsol;*!< Size = 1340 (0x53c)                                                       */
1445  typedef struct {                                &bsol;*!< (@ 0x40014000) EGU0 Structure                                             */
1446    __OM  uint32_t  TASKS_TRIGGER[16];            &bsol;*!< (@ 0x00000000) Description collection: Trigger n for triggering
1447                                                                      the corresponding TRIGGERED[n] event                       */
1448    __IM  uint32_t  RESERVED[48];
1449    __IOM uint32_t  EVENTS_TRIGGERED[16];         &bsol;*!< (@ 0x00000100) Description collection: Event number n generated
1450                                                                      by triggering the corresponding TRIGGER[n]
1451                                                                      task                                                       */
1452    __IM  uint32_t  RESERVED1[112];
1453    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1454    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1455    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1456  } NRF_EGU_Type;                                 &bsol;*!< Size = 780 (0x30c)                                                        */
1457  typedef struct {                                &bsol;*!< (@ 0x40014000) SWI0 Structure                                             */
1458    __IM  uint32_t  UNUSED;                       &bsol;*!< (@ 0x00000000) Unused.                                                    */
1459  } NRF_SWI_Type;                                 &bsol;*!< Size = 4 (0x4)                                                            */
1460  typedef struct {                                &bsol;*!< (@ 0x4001C000) PWM0 Structure                                             */
1461    __IM  uint32_t  RESERVED;
1462    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Stops PWM pulse generation on all channels at
1463                                                                      the end of current PWM period, and stops
1464                                                                      sequence playback                                          */
1465    __OM  uint32_t  TASKS_SEQSTART[2];            &bsol;*!< (@ 0x00000008) Description collection: Loads the first PWM value
1466                                                                      on all enabled channels from sequence n,
1467                                                                      and starts playing that sequence at the
1468                                                                      rate defined in SEQ[n]REFRESH and/or DECODER.MODE.
1469                                                                      Causes PWM generation to start if not running.             */
1470    __OM  uint32_t  TASKS_NEXTSTEP;               &bsol;*!< (@ 0x00000010) Steps by one value in the current sequence on
1471                                                                      all enabled channels if DECODER.MODE=NextStep.
1472                                                                      Does not cause PWM generation to start if
1473                                                                      not running.                                               */
1474    __IM  uint32_t  RESERVED1[60];
1475    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000104) Response to STOP task, emitted when PWM pulses
1476                                                                      are no longer generated                                    */
1477    __IOM uint32_t  EVENTS_SEQSTARTED[2];         &bsol;*!< (@ 0x00000108) Description collection: First PWM period started
1478                                                                      on sequence n                                              */
1479    __IOM uint32_t  EVENTS_SEQEND[2];             &bsol;*!< (@ 0x00000110) Description collection: Emitted at end of every
1480                                                                      sequence n, when last value from RAM has
1481                                                                      been applied to wave counter                               */
1482    __IOM uint32_t  EVENTS_PWMPERIODEND;          &bsol;*!< (@ 0x00000118) Emitted at the end of each PWM period                      */
1483    __IOM uint32_t  EVENTS_LOOPSDONE;             &bsol;*!< (@ 0x0000011C) Concatenated sequences have been played the amount
1484                                                                      of times defined in LOOP.CNT                               */
1485    __IM  uint32_t  RESERVED2[56];
1486    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1487    __IM  uint32_t  RESERVED3[63];
1488    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1489    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1490    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1491    __IM  uint32_t  RESERVED4[125];
1492    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) PWM module enable register                                 */
1493    __IOM uint32_t  MODE;                         &bsol;*!< (@ 0x00000504) Selects operating mode of the wave counter                 */
1494    __IOM uint32_t  COUNTERTOP;                   &bsol;*!< (@ 0x00000508) Value up to which the pulse generator counter
1495                                                                      counts                                                     */
1496    __IOM uint32_t  PRESCALER;                    &bsol;*!< (@ 0x0000050C) Configuration for PWM_CLK                                  */
1497    __IOM uint32_t  DECODER;                      &bsol;*!< (@ 0x00000510) Configuration of the decoder                               */
1498    __IOM uint32_t  LOOP;                         &bsol;*!< (@ 0x00000514) Number of playbacks of a loop                              */
1499    __IM  uint32_t  RESERVED5[2];
1500    __IOM PWM_SEQ_Type SEQ[2];                    &bsol;*!< (@ 0x00000520) Unspecified                                                */
1501    __IOM PWM_PSEL_Type PSEL;                     &bsol;*!< (@ 0x00000560) Unspecified                                                */
1502  } NRF_PWM_Type;                                 &bsol;*!< Size = 1392 (0x570)                                                       */
1503  typedef struct {                                &bsol;*!< (@ 0x4001D000) PDM Structure                                              */
1504    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Starts continuous PDM transfer                             */
1505    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Stops PDM transfer                                         */
1506    __IM  uint32_t  RESERVED[62];
1507    __IOM uint32_t  EVENTS_STARTED;               &bsol;*!< (@ 0x00000100) PDM transfer has started                                   */
1508    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000104) PDM transfer has finished                                  */
1509    __IOM uint32_t  EVENTS_END;                   &bsol;*!< (@ 0x00000108) The PDM has written the last sample specified
1510                                                                      by SAMPLE.MAXCNT (or the last sample after
1511                                                                      a STOP task has been received) to Data RAM                 */
1512    __IM  uint32_t  RESERVED1[125];
1513    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1514    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1515    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1516    __IM  uint32_t  RESERVED2[125];
1517    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) PDM module enable register                                 */
1518    __IOM uint32_t  PDMCLKCTRL;                   &bsol;*!< (@ 0x00000504) PDM clock generator control                                */
1519    __IOM uint32_t  MODE;                         &bsol;*!< (@ 0x00000508) Defines the routing of the connected PDM microphones'
1520                                                                      signals                                                    */
1521    __IM  uint32_t  RESERVED3[3];
1522    __IOM uint32_t  GAINL;                        &bsol;*!< (@ 0x00000518) Left output gain adjustment                                */
1523    __IOM uint32_t  GAINR;                        &bsol;*!< (@ 0x0000051C) Right output gain adjustment                               */
1524    __IOM uint32_t  RATIO;                        &bsol;*!< (@ 0x00000520) Selects the ratio between PDM_CLK and output
1525                                                                      sample rate. Change PDMCLKCTRL accordingly.                */
1526    __IM  uint32_t  RESERVED4[7];
1527    __IOM PDM_PSEL_Type PSEL;                     &bsol;*!< (@ 0x00000540) Unspecified                                                */
1528    __IM  uint32_t  RESERVED5[6];
1529    __IOM PDM_SAMPLE_Type SAMPLE;                 &bsol;*!< (@ 0x00000560) Unspecified                                                */
1530  } NRF_PDM_Type;                                 &bsol;*!< Size = 1384 (0x568)                                                       */
1531  typedef struct {                                &bsol;*!< (@ 0x4001E000) ACL Structure                                              */
1532    __IM  uint32_t  RESERVED[512];
1533    __IOM ACL_ACL_Type ACL[8];                    &bsol;*!< (@ 0x00000800) Unspecified                                                */
1534  } NRF_ACL_Type;                                 &bsol;*!< Size = 2176 (0x880)                                                       */
1535  typedef struct {                                &bsol;*!< (@ 0x4001E000) NVMC Structure                                             */
1536    __IM  uint32_t  RESERVED[256];
1537    __IM  uint32_t  READY;                        &bsol;*!< (@ 0x00000400) Ready flag                                                 */
1538    __IM  uint32_t  RESERVED1;
1539    __IM  uint32_t  READYNEXT;                    &bsol;*!< (@ 0x00000408) Ready flag                                                 */
1540    __IM  uint32_t  RESERVED2[62];
1541    __IOM uint32_t  CONFIG;                       &bsol;*!< (@ 0x00000504) Configuration register                                     */
1542    union {
1543      __OM  uint32_t ERASEPAGE;                   &bsol;*!< (@ 0x00000508) Register for erasing a page in code area                   */
1544      __OM  uint32_t ERASEPCR1;                   &bsol;*!< (@ 0x00000508) Deprecated register - Register for erasing a
1545                                                                      page in code area, equivalent to ERASEPAGE                 */
1546    };
1547    __OM  uint32_t  ERASEALL;                     &bsol;*!< (@ 0x0000050C) Register for erasing all non-volatile user memory          */
1548    __OM  uint32_t  ERASEPCR0;                    &bsol;*!< (@ 0x00000510) Deprecated register - Register for erasing a
1549                                                                      page in code area, equivalent to ERASEPAGE                 */
1550    __OM  uint32_t  ERASEUICR;                    &bsol;*!< (@ 0x00000514) Register for erasing user information configuration
1551                                                                      registers                                                  */
1552    __OM  uint32_t  ERASEPAGEPARTIAL;             &bsol;*!< (@ 0x00000518) Register for partial erase of a page in code
1553                                                                      area                                                       */
1554    __IOM uint32_t  ERASEPAGEPARTIALCFG;          &bsol;*!< (@ 0x0000051C) Register for partial erase configuration                   */
1555    __IM  uint32_t  RESERVED3[8];
1556    __IOM uint32_t  ICACHECNF;                    &bsol;*!< (@ 0x00000540) I-code cache configuration register                        */
1557    __IM  uint32_t  RESERVED4;
1558    __IOM uint32_t  IHIT;                         &bsol;*!< (@ 0x00000548) I-code cache hit counter                                   */
1559    __IOM uint32_t  IMISS;                        &bsol;*!< (@ 0x0000054C) I-code cache miss counter                                  */
1560  } NRF_NVMC_Type;                                &bsol;*!< Size = 1360 (0x550)                                                       */
1561  typedef struct {                                &bsol;*!< (@ 0x4001F000) PPI Structure                                              */
1562    __OM  PPI_TASKS_CHG_Type TASKS_CHG[6];        &bsol;*!< (@ 0x00000000) Channel group tasks                                        */
1563    __IM  uint32_t  RESERVED[308];
1564    __IOM uint32_t  CHEN;                         &bsol;*!< (@ 0x00000500) Channel enable register                                    */
1565    __IOM uint32_t  CHENSET;                      &bsol;*!< (@ 0x00000504) Channel enable set register                                */
1566    __IOM uint32_t  CHENCLR;                      &bsol;*!< (@ 0x00000508) Channel enable clear register                              */
1567    __IM  uint32_t  RESERVED1;
1568    __IOM PPI_CH_Type CH[20];                     &bsol;*!< (@ 0x00000510) PPI Channel                                                */
1569    __IM  uint32_t  RESERVED2[148];
1570    __IOM uint32_t  CHG[6];                       &bsol;*!< (@ 0x00000800) Description collection: Channel group n                    */
1571    __IM  uint32_t  RESERVED3[62];
1572    __IOM PPI_FORK_Type FORK[32];                 &bsol;*!< (@ 0x00000910) Fork                                                       */
1573  } NRF_PPI_Type;                                 &bsol;*!< Size = 2448 (0x990)                                                       */
1574  typedef struct {                                &bsol;*!< (@ 0x40020000) MWU Structure                                              */
1575    __IM  uint32_t  RESERVED[64];
1576    __IOM MWU_EVENTS_REGION_Type EVENTS_REGION[4];&bsol;*!< (@ 0x00000100) Peripheral events.                                         */
1577    __IM  uint32_t  RESERVED1[16];
1578    __IOM MWU_EVENTS_PREGION_Type EVENTS_PREGION[2];&bsol;*!< (@ 0x00000160) Peripheral events.                                       */
1579    __IM  uint32_t  RESERVED2[100];
1580    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1581    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1582    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1583    __IM  uint32_t  RESERVED3[5];
1584    __IOM uint32_t  NMIEN;                        &bsol;*!< (@ 0x00000320) Enable or disable interrupt                                */
1585    __IOM uint32_t  NMIENSET;                     &bsol;*!< (@ 0x00000324) Enable interrupt                                           */
1586    __IOM uint32_t  NMIENCLR;                     &bsol;*!< (@ 0x00000328) Disable interrupt                                          */
1587    __IM  uint32_t  RESERVED4[53];
1588    __IOM MWU_PERREGION_Type PERREGION[2];        &bsol;*!< (@ 0x00000400) Unspecified                                                */
1589    __IM  uint32_t  RESERVED5[64];
1590    __IOM uint32_t  REGIONEN;                     &bsol;*!< (@ 0x00000510) Enable/disable regions watch                               */
1591    __IOM uint32_t  REGIONENSET;                  &bsol;*!< (@ 0x00000514) Enable regions watch                                       */
1592    __IOM uint32_t  REGIONENCLR;                  &bsol;*!< (@ 0x00000518) Disable regions watch                                      */
1593    __IM  uint32_t  RESERVED6[57];
1594    __IOM MWU_REGION_Type REGION[4];              &bsol;*!< (@ 0x00000600) Unspecified                                                */
1595    __IM  uint32_t  RESERVED7[32];
1596    __IOM MWU_PREGION_Type PREGION[2];            &bsol;*!< (@ 0x000006C0) Unspecified                                                */
1597  } NRF_MWU_Type;                                 &bsol;*!< Size = 1760 (0x6e0)                                                       */
1598  typedef struct {                                &bsol;*!< (@ 0x40025000) I2S Structure                                              */
1599    __OM  uint32_t  TASKS_START;                  &bsol;*!< (@ 0x00000000) Starts continuous I2S transfer. Also starts MCK
1600                                                                      generator when this is enabled.                            */
1601    __OM  uint32_t  TASKS_STOP;                   &bsol;*!< (@ 0x00000004) Stops I2S transfer. Also stops MCK generator.
1602                                                                      Triggering this task will cause the STOPPED
1603                                                                      event to be generated.                                     */
1604    __IM  uint32_t  RESERVED[63];
1605    __IOM uint32_t  EVENTS_RXPTRUPD;              &bsol;*!< (@ 0x00000104) The RXD.PTR register has been copied to internal
1606                                                                      double-buffers. When the I2S module is started
1607                                                                      and RX is enabled, this event will be generated
1608                                                                      for every RXTXD.MAXCNT words that are received
1609                                                                      on the SDIN pin.                                           */
1610    __IOM uint32_t  EVENTS_STOPPED;               &bsol;*!< (@ 0x00000108) I2S transfer stopped.                                      */
1611    __IM  uint32_t  RESERVED1[2];
1612    __IOM uint32_t  EVENTS_TXPTRUPD;              &bsol;*!< (@ 0x00000114) The TDX.PTR register has been copied to internal
1613                                                                      double-buffers. When the I2S module is started
1614                                                                      and TX is enabled, this event will be generated
1615                                                                      for every RXTXD.MAXCNT words that are sent
1616                                                                      on the SDOUT pin.                                          */
1617    __IM  uint32_t  RESERVED2[122];
1618    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1619    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1620    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1621    __IM  uint32_t  RESERVED3[125];
1622    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable I2S module.                                         */
1623    __IOM I2S_CONFIG_Type CONFIG;                 &bsol;*!< (@ 0x00000504) Unspecified                                                */
1624    __IM  uint32_t  RESERVED4[3];
1625    __IOM I2S_RXD_Type RXD;                       &bsol;*!< (@ 0x00000538) Unspecified                                                */
1626    __IM  uint32_t  RESERVED5;
1627    __IOM I2S_TXD_Type TXD;                       &bsol;*!< (@ 0x00000540) Unspecified                                                */
1628    __IM  uint32_t  RESERVED6[3];
1629    __IOM I2S_RXTXD_Type RXTXD;                   &bsol;*!< (@ 0x00000550) Unspecified                                                */
1630    __IM  uint32_t  RESERVED7[3];
1631    __IOM I2S_PSEL_Type PSEL;                     &bsol;*!< (@ 0x00000560) Unspecified                                                */
1632  } NRF_I2S_Type;                                 &bsol;*!< Size = 1396 (0x574)                                                       */
1633  typedef struct {                                &bsol;*!< (@ 0x40026000) FPU Structure                                              */
1634    __IM  uint32_t  UNUSED;                       &bsol;*!< (@ 0x00000000) Unused.                                                    */
1635  } NRF_FPU_Type;                                 &bsol;*!< Size = 4 (0x4)                                                            */
1636  typedef struct {                                &bsol;*!< (@ 0x40027000) USBD Structure                                             */
1637    __IM  uint32_t  RESERVED;
1638    __OM  uint32_t  TASKS_STARTEPIN[8];           &bsol;*!< (@ 0x00000004) Description collection: Captures the EPIN[n].PTR
1639                                                                      and EPIN[n].MAXCNT registers values, and
1640                                                                      enables endpoint IN n to respond to traffic
1641                                                                      from host                                                  */
1642    __OM  uint32_t  TASKS_STARTISOIN;             &bsol;*!< (@ 0x00000024) Captures the ISOIN.PTR and ISOIN.MAXCNT registers
1643                                                                      values, and enables sending data on ISO
1644                                                                      endpoint                                                   */
1645    __OM  uint32_t  TASKS_STARTEPOUT[8];          &bsol;*!< (@ 0x00000028) Description collection: Captures the EPOUT[n].PTR
1646                                                                      and EPOUT[n].MAXCNT registers values, and
1647                                                                      enables endpoint n to respond to traffic
1648                                                                      from host                                                  */
1649    __OM  uint32_t  TASKS_STARTISOOUT;            &bsol;*!< (@ 0x00000048) Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers
1650                                                                      values, and enables receiving of data on
1651                                                                      ISO endpoint                                               */
1652    __OM  uint32_t  TASKS_EP0RCVOUT;              &bsol;*!< (@ 0x0000004C) Allows OUT data stage on control endpoint 0                */
1653    __OM  uint32_t  TASKS_EP0STATUS;              &bsol;*!< (@ 0x00000050) Allows status stage on control endpoint 0                  */
1654    __OM  uint32_t  TASKS_EP0STALL;               &bsol;*!< (@ 0x00000054) Stalls data and status stage on control endpoint
1655                                                                      0                                                          */
1656    __OM  uint32_t  TASKS_DPDMDRIVE;              &bsol;*!< (@ 0x00000058) Forces D+ and D- lines into the state defined
1657                                                                      in the DPDMVALUE register                                  */
1658    __OM  uint32_t  TASKS_DPDMNODRIVE;            &bsol;*!< (@ 0x0000005C) Stops forcing D+ and D- lines into any state
1659                                                                      (USB engine takes control)                                 */
1660    __IM  uint32_t  RESERVED1[40];
1661    __IOM uint32_t  EVENTS_USBRESET;              &bsol;*!< (@ 0x00000100) Signals that a USB reset condition has been detected
1662                                                                      on USB lines                                               */
1663    __IOM uint32_t  EVENTS_STARTED;               &bsol;*!< (@ 0x00000104) Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT,
1664                                                                      or EPOUT[n].PTR and EPOUT[n].MAXCNT registers
1665                                                                      have been captured on all endpoints reported
1666                                                                      in the EPSTATUS register                                   */
1667    __IOM uint32_t  EVENTS_ENDEPIN[8];            &bsol;*!< (@ 0x00000108) Description collection: The whole EPIN[n] buffer
1668                                                                      has been consumed. The buffer can be accessed
1669                                                                      safely by software.                                        */
1670    __IOM uint32_t  EVENTS_EP0DATADONE;           &bsol;*!< (@ 0x00000128) An acknowledged data transfer has taken place
1671                                                                      on the control endpoint                                    */
1672    __IOM uint32_t  EVENTS_ENDISOIN;              &bsol;*!< (@ 0x0000012C) The whole ISOIN buffer has been consumed. The
1673                                                                      buffer can be accessed safely by software.                 */
1674    __IOM uint32_t  EVENTS_ENDEPOUT[8];           &bsol;*!< (@ 0x00000130) Description collection: The whole EPOUT[n] buffer
1675                                                                      has been consumed. The buffer can be accessed
1676                                                                      safely by software.                                        */
1677    __IOM uint32_t  EVENTS_ENDISOOUT;             &bsol;*!< (@ 0x00000150) The whole ISOOUT buffer has been consumed. The
1678                                                                      buffer can be accessed safely by software.                 */
1679    __IOM uint32_t  EVENTS_SOF;                   &bsol;*!< (@ 0x00000154) Signals that a SOF (start of frame) condition
1680                                                                      has been detected on USB lines                             */
1681    __IOM uint32_t  EVENTS_USBEVENT;              &bsol;*!< (@ 0x00000158) An event or an error not covered by specific
1682                                                                      events has occurred. Check EVENTCAUSE register
1683                                                                      to find the cause.                                         */
1684    __IOM uint32_t  EVENTS_EP0SETUP;              &bsol;*!< (@ 0x0000015C) A valid SETUP token has been received (and acknowledged)
1685                                                                      on the control endpoint                                    */
1686    __IOM uint32_t  EVENTS_EPDATA;                &bsol;*!< (@ 0x00000160) A data transfer has occurred on a data endpoint,
1687                                                                      indicated by the EPDATASTATUS register                     */
1688    __IM  uint32_t  RESERVED2[39];
1689    __IOM uint32_t  SHORTS;                       &bsol;*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
1690    __IM  uint32_t  RESERVED3[63];
1691    __IOM uint32_t  INTEN;                        &bsol;*!< (@ 0x00000300) Enable or disable interrupt                                */
1692    __IOM uint32_t  INTENSET;                     &bsol;*!< (@ 0x00000304) Enable interrupt                                           */
1693    __IOM uint32_t  INTENCLR;                     &bsol;*!< (@ 0x00000308) Disable interrupt                                          */
1694    __IM  uint32_t  RESERVED4[61];
1695    __IOM uint32_t  EVENTCAUSE;                   &bsol;*!< (@ 0x00000400) Details on what caused the USBEVENT event                  */
1696    __IM  uint32_t  RESERVED5[7];
1697    __IOM USBD_HALTED_Type HALTED;                &bsol;*!< (@ 0x00000420) Unspecified                                                */
1698    __IM  uint32_t  RESERVED6;
1699    __IOM uint32_t  EPSTATUS;                     &bsol;*!< (@ 0x00000468) Provides information on which endpoint's EasyDMA
1700                                                                      registers have been captured                               */
1701    __IOM uint32_t  EPDATASTATUS;                 &bsol;*!< (@ 0x0000046C) Provides information on which endpoint(s) an
1702                                                                      acknowledged data transfer has occurred
1703                                                                      (EPDATA event)                                             */
1704    __IM  uint32_t  USBADDR;                      &bsol;*!< (@ 0x00000470) Device USB address                                         */
1705    __IM  uint32_t  RESERVED7[3];
1706    __IM  uint32_t  BMREQUESTTYPE;                &bsol;*!< (@ 0x00000480) SETUP data, byte 0, bmRequestType                          */
1707    __IM  uint32_t  BREQUEST;                     &bsol;*!< (@ 0x00000484) SETUP data, byte 1, bRequest                               */
1708    __IM  uint32_t  WVALUEL;                      &bsol;*!< (@ 0x00000488) SETUP data, byte 2, LSB of wValue                          */
1709    __IM  uint32_t  WVALUEH;                      &bsol;*!< (@ 0x0000048C) SETUP data, byte 3, MSB of wValue                          */
1710    __IM  uint32_t  WINDEXL;                      &bsol;*!< (@ 0x00000490) SETUP data, byte 4, LSB of wIndex                          */
1711    __IM  uint32_t  WINDEXH;                      &bsol;*!< (@ 0x00000494) SETUP data, byte 5, MSB of wIndex                          */
1712    __IM  uint32_t  WLENGTHL;                     &bsol;*!< (@ 0x00000498) SETUP data, byte 6, LSB of wLength                         */
1713    __IM  uint32_t  WLENGTHH;                     &bsol;*!< (@ 0x0000049C) SETUP data, byte 7, MSB of wLength                         */
1714    __IOM USBD_SIZE_Type SIZE;                    &bsol;*!< (@ 0x000004A0) Unspecified                                                */
1715    __IM  uint32_t  RESERVED8[15];
1716    __IOM uint32_t  ENABLE;                       &bsol;*!< (@ 0x00000500) Enable USB                                                 */
1717    __IOM uint32_t  USBPULLUP;                    &bsol;*!< (@ 0x00000504) Control of the USB pull-up                                 */
1718    __IOM uint32_t  DPDMVALUE;                    &bsol;*!< (@ 0x00000508) State D+ and D- lines will be forced into by
1719                                                                      the DPDMDRIVE task. The DPDMNODRIVE task
1720                                                                      reverts the control of the lines to MAC
1721                                                                      IP (no forcing).                                           */
1722    __IOM uint32_t  DTOGGLE;                      &bsol;*!< (@ 0x0000050C) Data toggle control and status                             */
1723    __IOM uint32_t  EPINEN;                       &bsol;*!< (@ 0x00000510) Endpoint IN enable                                         */
1724    __IOM uint32_t  EPOUTEN;                      &bsol;*!< (@ 0x00000514) Endpoint OUT enable                                        */
1725    __OM  uint32_t  EPSTALL;                      &bsol;*!< (@ 0x00000518) STALL endpoints                                            */
1726    __IOM uint32_t  ISOSPLIT;                     &bsol;*!< (@ 0x0000051C) Controls the split of ISO buffers                          */
1727    __IM  uint32_t  FRAMECNTR;                    &bsol;*!< (@ 0x00000520) Returns the current value of the start of frame
1728                                                                      counter                                                    */
1729    __IM  uint32_t  RESERVED9[2];
1730    __IOM uint32_t  LOWPOWER;                     &bsol;*!< (@ 0x0000052C) Controls USBD peripheral low power mode during
1731                                                                      USB suspend                                                */
1732    __IOM uint32_t  ISOINCONFIG;                  &bsol;*!< (@ 0x00000530) Controls the response of the ISO IN endpoint
1733                                                                      to an IN token when no data is ready to
1734                                                                      be sent                                                    */
1735    __IM  uint32_t  RESERVED10[51];
1736    __IOM USBD_EPIN_Type EPIN[8];                 &bsol;*!< (@ 0x00000600) Unspecified                                                */
1737    __IOM USBD_ISOIN_Type ISOIN;                  &bsol;*!< (@ 0x000006A0) Unspecified                                                */
1738    __IM  uint32_t  RESERVED11[21];
1739    __IOM USBD_EPOUT_Type EPOUT[8];               &bsol;*!< (@ 0x00000700) Unspecified                                                */
1740    __IOM USBD_ISOOUT_Type ISOOUT;                &bsol;*!< (@ 0x000007A0) Unspecified                                                */
1741  } NRF_USBD_Type;                                &bsol;*!< Size = 1964 (0x7ac)                                                       */
1742  #define NRF_FICR_BASE               0x10000000UL
1743  #define NRF_UICR_BASE               0x10001000UL
1744  #define NRF_CLOCK_BASE              0x40000000UL
1745  #define NRF_POWER_BASE              0x40000000UL
1746  #define NRF_P0_BASE                 0x50000000UL
1747  #define NRF_P1_BASE                 0x50000300UL
1748  #define NRF_RADIO_BASE              0x40001000UL
1749  #define NRF_UART0_BASE              0x40002000UL
1750  #define NRF_UARTE0_BASE             0x40002000UL
1751  #define NRF_SPI0_BASE               0x40003000UL
1752  #define NRF_SPIM0_BASE              0x40003000UL
1753  #define NRF_SPIS0_BASE              0x40003000UL
1754  #define NRF_TWI0_BASE               0x40003000UL
1755  #define NRF_TWIM0_BASE              0x40003000UL
1756  #define NRF_TWIS0_BASE              0x40003000UL
1757  #define NRF_SPI1_BASE               0x40004000UL
1758  #define NRF_SPIM1_BASE              0x40004000UL
1759  #define NRF_SPIS1_BASE              0x40004000UL
1760  #define NRF_TWI1_BASE               0x40004000UL
1761  #define NRF_TWIM1_BASE              0x40004000UL
1762  #define NRF_TWIS1_BASE              0x40004000UL
1763  #define NRF_NFCT_BASE               0x40005000UL
1764  #define NRF_GPIOTE_BASE             0x40006000UL
1765  #define NRF_SAADC_BASE              0x40007000UL
1766  #define NRF_TIMER0_BASE             0x40008000UL
1767  #define NRF_TIMER1_BASE             0x40009000UL
1768  #define NRF_TIMER2_BASE             0x4000A000UL
1769  #define NRF_RTC0_BASE               0x4000B000UL
1770  #define NRF_TEMP_BASE               0x4000C000UL
1771  #define NRF_RNG_BASE                0x4000D000UL
1772  #define NRF_ECB_BASE                0x4000E000UL
1773  #define NRF_AAR_BASE                0x4000F000UL
1774  #define NRF_CCM_BASE                0x4000F000UL
1775  #define NRF_WDT_BASE                0x40010000UL
1776  #define NRF_RTC1_BASE               0x40011000UL
1777  #define NRF_QDEC_BASE               0x40012000UL
1778  #define NRF_COMP_BASE               0x40013000UL
1779  #define NRF_LPCOMP_BASE             0x40013000UL
1780  #define NRF_EGU0_BASE               0x40014000UL
1781  #define NRF_SWI0_BASE               0x40014000UL
1782  #define NRF_EGU1_BASE               0x40015000UL
1783  #define NRF_SWI1_BASE               0x40015000UL
1784  #define NRF_EGU2_BASE               0x40016000UL
1785  #define NRF_SWI2_BASE               0x40016000UL
1786  #define NRF_EGU3_BASE               0x40017000UL
1787  #define NRF_SWI3_BASE               0x40017000UL
1788  #define NRF_EGU4_BASE               0x40018000UL
1789  #define NRF_SWI4_BASE               0x40018000UL
1790  #define NRF_EGU5_BASE               0x40019000UL
1791  #define NRF_SWI5_BASE               0x40019000UL
1792  #define NRF_TIMER3_BASE             0x4001A000UL
1793  #define NRF_TIMER4_BASE             0x4001B000UL
1794  #define NRF_PWM0_BASE               0x4001C000UL
1795  #define NRF_PDM_BASE                0x4001D000UL
1796  #define NRF_ACL_BASE                0x4001E000UL
1797  #define NRF_NVMC_BASE               0x4001E000UL
1798  #define NRF_PPI_BASE                0x4001F000UL
1799  #define NRF_MWU_BASE                0x40020000UL
1800  #define NRF_PWM1_BASE               0x40021000UL
1801  #define NRF_PWM2_BASE               0x40022000UL
1802  #define NRF_SPI2_BASE               0x40023000UL
1803  #define NRF_SPIM2_BASE              0x40023000UL
1804  #define NRF_SPIS2_BASE              0x40023000UL
1805  #define NRF_RTC2_BASE               0x40024000UL
1806  #define NRF_I2S_BASE                0x40025000UL
1807  #define NRF_FPU_BASE                0x40026000UL
1808  #define NRF_USBD_BASE               0x40027000UL
1809  #define NRF_UARTE1_BASE             0x40028000UL
1810  #define NRF_PWM3_BASE               0x4002D000UL
1811  #define NRF_SPIM3_BASE              0x4002F000UL
1812  #define NRF_FICR                    ((NRF_FICR_Type*)          NRF_FICR_BASE)
1813  #define NRF_UICR                    ((NRF_UICR_Type*)          NRF_UICR_BASE)
1814  #define NRF_CLOCK                   ((NRF_CLOCK_Type*)         NRF_CLOCK_BASE)
1815  #define NRF_POWER                   ((NRF_POWER_Type*)         NRF_POWER_BASE)
1816  #define NRF_P0                      ((NRF_GPIO_Type*)          NRF_P0_BASE)
1817  #define NRF_P1                      ((NRF_GPIO_Type*)          NRF_P1_BASE)
1818  #define NRF_RADIO                   ((NRF_RADIO_Type*)         NRF_RADIO_BASE)
1819  #define NRF_UART0                   ((NRF_UART_Type*)          NRF_UART0_BASE)
1820  #define NRF_UARTE0                  ((NRF_UARTE_Type*)         NRF_UARTE0_BASE)
1821  #define NRF_SPI0                    ((NRF_SPI_Type*)           NRF_SPI0_BASE)
1822  #define NRF_SPIM0                   ((NRF_SPIM_Type*)          NRF_SPIM0_BASE)
1823  #define NRF_SPIS0                   ((NRF_SPIS_Type*)          NRF_SPIS0_BASE)
1824  #define NRF_TWI0                    ((NRF_TWI_Type*)           NRF_TWI0_BASE)
1825  #define NRF_TWIM0                   ((NRF_TWIM_Type*)          NRF_TWIM0_BASE)
1826  #define NRF_TWIS0                   ((NRF_TWIS_Type*)          NRF_TWIS0_BASE)
1827  #define NRF_SPI1                    ((NRF_SPI_Type*)           NRF_SPI1_BASE)
1828  #define NRF_SPIM1                   ((NRF_SPIM_Type*)          NRF_SPIM1_BASE)
1829  #define NRF_SPIS1                   ((NRF_SPIS_Type*)          NRF_SPIS1_BASE)
1830  #define NRF_TWI1                    ((NRF_TWI_Type*)           NRF_TWI1_BASE)
1831  #define NRF_TWIM1                   ((NRF_TWIM_Type*)          NRF_TWIM1_BASE)
1832  #define NRF_TWIS1                   ((NRF_TWIS_Type*)          NRF_TWIS1_BASE)
1833  #define NRF_NFCT                    ((NRF_NFCT_Type*)          NRF_NFCT_BASE)
1834  #define NRF_GPIOTE                  ((NRF_GPIOTE_Type*)        NRF_GPIOTE_BASE)
1835  #define NRF_SAADC                   ((NRF_SAADC_Type*)         NRF_SAADC_BASE)
1836  #define NRF_TIMER0                  ((NRF_TIMER_Type*)         NRF_TIMER0_BASE)
1837  #define NRF_TIMER1                  ((NRF_TIMER_Type*)         NRF_TIMER1_BASE)
1838  #define NRF_TIMER2                  ((NRF_TIMER_Type*)         NRF_TIMER2_BASE)
1839  #define NRF_RTC0                    ((NRF_RTC_Type*)           NRF_RTC0_BASE)
1840  #define NRF_TEMP                    ((NRF_TEMP_Type*)          NRF_TEMP_BASE)
1841  #define NRF_RNG                     ((NRF_RNG_Type*)           NRF_RNG_BASE)
1842  #define NRF_ECB                     ((NRF_ECB_Type*)           NRF_ECB_BASE)
1843  #define NRF_AAR                     ((NRF_AAR_Type*)           NRF_AAR_BASE)
1844  #define NRF_CCM                     ((NRF_CCM_Type*)           NRF_CCM_BASE)
1845  #define NRF_WDT                     ((NRF_WDT_Type*)           NRF_WDT_BASE)
1846  #define NRF_RTC1                    ((NRF_RTC_Type*)           NRF_RTC1_BASE)
1847  #define NRF_QDEC                    ((NRF_QDEC_Type*)          NRF_QDEC_BASE)
1848  #define NRF_COMP                    ((NRF_COMP_Type*)          NRF_COMP_BASE)
1849  #define NRF_LPCOMP                  ((NRF_LPCOMP_Type*)        NRF_LPCOMP_BASE)
1850  #define NRF_EGU0                    ((NRF_EGU_Type*)           NRF_EGU0_BASE)
1851  #define NRF_SWI0                    ((NRF_SWI_Type*)           NRF_SWI0_BASE)
1852  #define NRF_EGU1                    ((NRF_EGU_Type*)           NRF_EGU1_BASE)
1853  #define NRF_SWI1                    ((NRF_SWI_Type*)           NRF_SWI1_BASE)
1854  #define NRF_EGU2                    ((NRF_EGU_Type*)           NRF_EGU2_BASE)
1855  #define NRF_SWI2                    ((NRF_SWI_Type*)           NRF_SWI2_BASE)
1856  #define NRF_EGU3                    ((NRF_EGU_Type*)           NRF_EGU3_BASE)
1857  #define NRF_SWI3                    ((NRF_SWI_Type*)           NRF_SWI3_BASE)
1858  #define NRF_EGU4                    ((NRF_EGU_Type*)           NRF_EGU4_BASE)
1859  #define NRF_SWI4                    ((NRF_SWI_Type*)           NRF_SWI4_BASE)
1860  #define NRF_EGU5                    ((NRF_EGU_Type*)           NRF_EGU5_BASE)
1861  #define NRF_SWI5                    ((NRF_SWI_Type*)           NRF_SWI5_BASE)
1862  #define NRF_TIMER3                  ((NRF_TIMER_Type*)         NRF_TIMER3_BASE)
1863  #define NRF_TIMER4                  ((NRF_TIMER_Type*)         NRF_TIMER4_BASE)
1864  #define NRF_PWM0                    ((NRF_PWM_Type*)           NRF_PWM0_BASE)
1865  #define NRF_PDM                     ((NRF_PDM_Type*)           NRF_PDM_BASE)
1866  #define NRF_ACL                     ((NRF_ACL_Type*)           NRF_ACL_BASE)
1867  #define NRF_NVMC                    ((NRF_NVMC_Type*)          NRF_NVMC_BASE)
1868  #define NRF_PPI                     ((NRF_PPI_Type*)           NRF_PPI_BASE)
1869  #define NRF_MWU                     ((NRF_MWU_Type*)           NRF_MWU_BASE)
1870  #define NRF_PWM1                    ((NRF_PWM_Type*)           NRF_PWM1_BASE)
1871  #define NRF_PWM2                    ((NRF_PWM_Type*)           NRF_PWM2_BASE)
1872  #define NRF_SPI2                    ((NRF_SPI_Type*)           NRF_SPI2_BASE)
1873  #define NRF_SPIM2                   ((NRF_SPIM_Type*)          NRF_SPIM2_BASE)
1874  #define NRF_SPIS2                   ((NRF_SPIS_Type*)          NRF_SPIS2_BASE)
1875  #define NRF_RTC2                    ((NRF_RTC_Type*)           NRF_RTC2_BASE)
1876  #define NRF_I2S                     ((NRF_I2S_Type*)           NRF_I2S_BASE)
1877  #define NRF_FPU                     ((NRF_FPU_Type*)           NRF_FPU_BASE)
1878  #define NRF_USBD                    ((NRF_USBD_Type*)          NRF_USBD_BASE)
1879  #define NRF_UARTE1                  ((NRF_UARTE_Type*)         NRF_UARTE1_BASE)
1880  #define NRF_PWM3                    ((NRF_PWM_Type*)           NRF_PWM3_BASE)
1881  #define NRF_SPIM3                   ((NRF_SPIM_Type*)          NRF_SPIM3_BASE)
1882  #if defined (__CC_ARM)
1883    #pragma pop
1884  #elif defined (__ICCARM__)
1885  #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
1886    #pragma clang diagnostic pop
1887  #elif defined (__GNUC__)
1888  #elif defined (__TMS470__)
1889  #elif defined (__TASKING__)
1890    #pragma warning restore
1891  #elif defined (__CSMC__)
1892  #endif
1893  #ifdef __cplusplus
1894  }
1895  #endif
1896  #endif &bsol;* NRF52833_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-x86.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf52833.h</div>
                </div>
                <div class="column column_space"><pre><code>607  	cache->cacheid = (infos->apicid % legacy_max_log_proc) / cache->nbthreads_sharing &bsol;* cacheid within the package */
608  	  + 2 * (infos->apicid / legacy_max_log_proc); &bsol;* add 2 caches per previous package */
</pre></code></div>
                <div class="column column_space"><pre><code>153  } RADIO_DFEPACKET_Type;                         &bsol;*!< Size = 12 (0xc)                                                           */
154  typedef struct {
155    __IOM uint32_t  RTS;                          &bsol;*!< (@ 0x00000000) Pin select for RTS                                         */
156    __IOM uint32_t  TXD;                          &bsol;*!< (@ 0x00000004) Pin select for TXD                                         */
157    __IOM uint32_t  CTS;                          &bsol;*!< (@ 0x00000008) Pin select for CTS                                         */
158    __IOM uint32_t  RXD;                          &bsol;*!< (@ 0x0000000C) Pin select for RXD                                         */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    