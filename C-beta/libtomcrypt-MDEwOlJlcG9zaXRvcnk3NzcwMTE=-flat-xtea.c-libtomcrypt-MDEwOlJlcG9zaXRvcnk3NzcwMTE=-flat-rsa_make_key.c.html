
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.87648456057007%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-xtea.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_XTEA
3  const struct ltc_cipher_descriptor xtea_desc =
4  {
5      "xtea",
6      1,
7      16, 16, 8, 32,
8      &xtea_setup,
9      &xtea_ecb_encrypt,
10      &xtea_ecb_decrypt,
11      &xtea_test,
12      &xtea_done,
13      &xtea_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  int xtea_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
17  {
18     ulong32 x, sum, K[4];
19     LTC_ARGCHK(key != NULL);
20     LTC_ARGCHK(skey != NULL);
21     if (keylen != 16) {
22        return CRYPT_INVALID_KEYSIZE;
23     }
24     if (num_rounds != 0 && num_rounds != 32) {
25        return CRYPT_INVALID_ROUNDS;
26     }
27     LOAD32H(K[0], key+0);
28     LOAD32H(K[1], key+4);
29     LOAD32H(K[2], key+8);
30     LOAD32H(K[3], key+12);
31     for (x = sum = 0; x < 32; x++) {
32         skey->xtea.A[x] = (sum + K[sum&3]) & 0xFFFFFFFFUL;
33         sum = (sum + 0x9E3779B9UL) & 0xFFFFFFFFUL;
34         skey->xtea.B[x] = (sum + K[(sum>>11)&3]) & 0xFFFFFFFFUL;
35     }
36  #ifdef LTC_CLEAN_STACK
37     zeromem(&K, sizeof(K));
38  #endif
39     return CRYPT_OK;
40  }
41  int xtea_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
42  {
43     ulong32 y, z;
44     int r;
45     LTC_ARGCHK(pt   != NULL);
46     LTC_ARGCHK(ct   != NULL);
47     LTC_ARGCHK(skey != NULL);
48     LOAD32H(y, &pt[0]);
49     LOAD32H(z, &pt[4]);
50     for (r = 0; r < 32; r += 4) {
51         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r])) & 0xFFFFFFFFUL;
52         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r])) & 0xFFFFFFFFUL;
53         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r+1])) & 0xFFFFFFFFUL;
54         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r+1])) & 0xFFFFFFFFUL;
55         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r+2])) & 0xFFFFFFFFUL;
56         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r+2])) & 0xFFFFFFFFUL;
57         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r+3])) & 0xFFFFFFFFUL;
58         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r+3])) & 0xFFFFFFFFUL;
59     }
60     STORE32H(y, &ct[0]);
61     STORE32H(z, &ct[4]);
<span onclick='openModal()' class='match'>62     return CRYPT_OK;
63  }
64  int xtea_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
65  {
66     ulong32 y, z;
67     int r;
</span>68     LTC_ARGCHK(pt   != NULL);
69     LTC_ARGCHK(ct   != NULL);
70     LTC_ARGCHK(skey != NULL);
71     LOAD32H(y, &ct[0]);
72     LOAD32H(z, &ct[4]);
73     for (r = 31; r >= 0; r -= 4) {
74         z = (z - ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r])) & 0xFFFFFFFFUL;
75         y = (y - ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r])) & 0xFFFFFFFFUL;
76         z = (z - ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r-1])) & 0xFFFFFFFFUL;
77         y = (y - ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r-1])) & 0xFFFFFFFFUL;
78         z = (z - ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r-2])) & 0xFFFFFFFFUL;
79         y = (y - ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r-2])) & 0xFFFFFFFFUL;
80         z = (z - ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r-3])) & 0xFFFFFFFFUL;
81         y = (y - ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r-3])) & 0xFFFFFFFFUL;
82     }
83     STORE32H(y, &pt[0]);
84     STORE32H(z, &pt[4]);
85     return CRYPT_OK;
86  }
87  int xtea_test(void)
88  {
89   #ifndef LTC_TEST
90      return CRYPT_NOP;
91   #else
92      static const struct {
93          unsigned char key[16], pt[8], ct[8];
94      } tests[] = {
95         {
96           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
97             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
98           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
99           { 0xde, 0xe9, 0xd4, 0xd8, 0xf7, 0x13, 0x1e, 0xd9 }
100         }, {
101           { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
102             0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04 },
103           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
104           { 0xa5, 0x97, 0xab, 0x41, 0x76, 0x01, 0x4d, 0x72 }
105         }, {
106           { 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
107             0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06 },
108           { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02 },
109           { 0xb1, 0xfd, 0x5d, 0xa9, 0xcc, 0x6d, 0xc9, 0xdc }
110         }, {
111           { 0x78, 0x69, 0x5a, 0x4b, 0x3c, 0x2d, 0x1e, 0x0f,
112             0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
113           { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
114           { 0x70, 0x4b, 0x31, 0x34, 0x47, 0x44, 0xdf, 0xab }
115         }, {
116           { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
117             0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
118           { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48 },
119           { 0x49, 0x7d, 0xf3, 0xd0, 0x72, 0x61, 0x2c, 0xb5 }
120         }, {
121           { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
122             0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
123           { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 },
124           { 0xe7, 0x8f, 0x2d, 0x13, 0x74, 0x43, 0x41, 0xd8 }
125         }, {
126           { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
127             0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
128           { 0x5a, 0x5b, 0x6e, 0x27, 0x89, 0x48, 0xd7, 0x7f },
129           { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 }
130         }, {
131           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
132             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
133           { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48 },
134           { 0xa0, 0x39, 0x05, 0x89, 0xf8, 0xb8, 0xef, 0xa5 }
135         }, {
136           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
137             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
138           { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 },
139           { 0xed, 0x23, 0x37, 0x5a, 0x82, 0x1a, 0x8c, 0x2d }
140         }, {
141           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
142             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
143           { 0x70, 0xe1, 0x22, 0x5d, 0x6e, 0x4e, 0x76, 0x55 },
144           { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 }
145         }
146      };
147     unsigned char tmp[2][8];
148     symmetric_key skey;
149     int i, err, y;
150     for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
151         zeromem(&skey, sizeof(skey));
152         if ((err = xtea_setup(tests[i].key, 16, 0, &skey)) != CRYPT_OK)  {
153            return err;
154         }
155         xtea_ecb_encrypt(tests[i].pt, tmp[0], &skey);
156         xtea_ecb_decrypt(tmp[0], tmp[1], &skey);
157         if (compare_testvector(tmp[0], 8, tests[i].ct, 8, "XTEA Encrypt", i) != 0 ||
158               compare_testvector(tmp[1], 8, tests[i].pt, 8, "XTEA Decrypt", i) != 0) {
159            return CRYPT_FAIL_TESTVECTOR;
160         }
161        for (y = 0; y < 8; y++) tmp[0][y] = 0;
162        for (y = 0; y < 1000; y++) xtea_ecb_encrypt(tmp[0], tmp[0], &skey);
163        for (y = 0; y < 1000; y++) xtea_ecb_decrypt(tmp[0], tmp[0], &skey);
164        for (y = 0; y < 8; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
165     } &bsol;* for */
166     return CRYPT_OK;
167   #endif
168  }
169  void xtea_done(symmetric_key *skey)
170  {
171    LTC_UNUSED_PARAM(skey);
172  }
173  int xtea_keysize(int *keysize)
174  {
175     LTC_ARGCHK(keysize != NULL);
176     if (*keysize < 16) {
177        return CRYPT_INVALID_KEYSIZE;
178     }
179     *keysize = 16;
180     return CRYPT_OK;
181  }
182  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rsa_make_key.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MRSA
3  static int s_rsa_make_key(prng_state *prng, int wprng, int size, void *e, rsa_key *key)
4  {
5     void *p, *q, *tmp1, *tmp2;
6     int    err;
7     LTC_ARGCHK(ltc_mp.name != NULL);
8     LTC_ARGCHK(key         != NULL);
9     LTC_ARGCHK(size        > 0);
10     if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
11        return err;
12     }
13     if ((err = mp_init_multi(&p, &q, &tmp1, &tmp2, LTC_NULL)) != CRYPT_OK) {
14        return err;
15     }
16     do {
17         if ((err = rand_prime( p, size/2, prng, wprng)) != CRYPT_OK)  { goto cleanup; }
18         if ((err = mp_sub_d( p, 1,  tmp1)) != CRYPT_OK)               { goto cleanup; }  &bsol;* tmp1 = p-1 */
19         if ((err = mp_gcd( tmp1,  e,  tmp2)) != CRYPT_OK)             { goto cleanup; }  &bsol;* tmp2 = gcd(p-1, e) */
20     } while (mp_cmp_d( tmp2, 1) != 0);                                                  &bsol;* while e divides p-1 */
21     do {
22         if ((err = rand_prime( q, size/2, prng, wprng)) != CRYPT_OK)  { goto cleanup; }
23         if ((err = mp_sub_d( q, 1,  tmp1)) != CRYPT_OK)               { goto cleanup; } &bsol;* tmp1 = q-1 */
24         if ((err = mp_gcd( tmp1,  e,  tmp2)) != CRYPT_OK)          { goto cleanup; } &bsol;* tmp2 = gcd(q-1, e) */
25     } while (mp_cmp_d( tmp2, 1) != 0);                                                 &bsol;* while e divides q-1 */
26     if ((err = mp_sub_d( p, 1,  tmp2)) != CRYPT_OK)                   { goto cleanup; } &bsol;* tmp2 = p-1 */
27     if ((err = mp_lcm( tmp1,  tmp2,  tmp1)) != CRYPT_OK)              { goto cleanup; } &bsol;* tmp1 = lcm(p-1, q-1) */
28     if ((err = rsa_init(key)) != CRYPT_OK) {
29        goto errkey;
30     }
31     if ((err = mp_copy( e,  key->e)) != CRYPT_OK)                       { goto errkey; } &bsol;* key->e =  e */
32     if ((err = mp_invmod( key->e,  tmp1,  key->d)) != CRYPT_OK)         { goto errkey; } &bsol;* key->d = 1/e mod lcm(p-1,q-1) */
33     if ((err = mp_mul( p,  q,  key->N)) != CRYPT_OK)                    { goto errkey; } &bsol;* key->N = pq */
34     if ((err = mp_sub_d( p, 1,  tmp1)) != CRYPT_OK)                     { goto errkey; } &bsol;* tmp1 = p-1 */
35     if ((err = mp_sub_d( q, 1,  tmp2)) != CRYPT_OK)                     { goto errkey; } &bsol;* tmp2 = q-1 */
36     if ((err = mp_mod( key->d,  tmp1,  key->dP)) != CRYPT_OK)           { goto errkey; } &bsol;* dP = d mod p-1 */
37     if ((err = mp_mod( key->d,  tmp2,  key->dQ)) != CRYPT_OK)           { goto errkey; } &bsol;* dQ = d mod q-1 */
38     if ((err = mp_invmod( q,  p,  key->qP)) != CRYPT_OK)                { goto errkey; } &bsol;* qP = 1/q mod p */
39     if ((err = mp_copy( p,  key->p)) != CRYPT_OK)                       { goto errkey; }
40     if ((err = mp_copy( q,  key->q)) != CRYPT_OK)                       { goto errkey; }
41     key->type = PK_PRIVATE;
42     err       = CRYPT_OK;
43     goto cleanup;
44  errkey:
45     rsa_free(key);
46  cleanup:
47     mp_clear_multi(tmp2, tmp1, q, p, LTC_NULL);
48     return err;
49  }
50  int rsa_make_key(prng_state *prng, int wprng, int size, long e, rsa_key *key)
51  {
52     void *tmp_e;
53     int err;
54     if ((e < 3) || ((e & 1) == 0)) {
55       return CRYPT_INVALID_ARG;
56     }
57     if ((err = mp_init(&tmp_e)) != CRYPT_OK) {
58       return err;
59     }
60     if ((err = mp_set_int(tmp_e, e)) == CRYPT_OK)
61       err = s_rsa_make_key(prng, wprng, size, tmp_e, key);
62     mp_clear(tmp_e);
63     return err;
64  }
65  int rsa_make_key_ubin_e(prng_state *prng, int wprng, int size,
66                          const unsigned char *e, unsigned long elen, rsa_key *key)
67  {
68     int err;
69     void *tmp_e;
70     if ((err = mp_init(&tmp_e)) != CRYPT_OK) {
71        return err;
72     }
73     if ((err = mp_read_unsigned_bin(tmp_e, (unsigned char *)e, elen)) == CRYPT_OK)
74       err = rsa_make_key_bn_e(prng, wprng, size, tmp_e, key);
75     mp_clear(tmp_e);
<span onclick='openModal()' class='match'>76     return err;
77  }
78  int rsa_make_key_bn_e(prng_state *prng, int wprng, int size, void *e, rsa_key *key)
</span>79  {
80     int err;
81     int e_bits;
82     e_bits = mp_count_bits(e);
83     if ((e_bits > 1 && e_bits < 256) && (mp_get_digit(e, 0) & 1)) {
84       err = s_rsa_make_key(prng, wprng, size, e, key);
85     } else {
86       err = CRYPT_INVALID_ARG;
87     }
88     return err;
89  }
90  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-xtea.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rsa_make_key.c</div>
                </div>
                <div class="column column_space"><pre><code>62     return CRYPT_OK;
63  }
64  int xtea_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
65  {
66     ulong32 y, z;
67     int r;
</pre></code></div>
                <div class="column column_space"><pre><code>76     return err;
77  }
78  int rsa_make_key_bn_e(prng_state *prng, int wprng, int size, void *e, rsa_key *key)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    