
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.576271186440678%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-quant_levels_dec_utils.c</h3>
            <pre><code>1  #include "src/utils/quant_levels_dec_utils.h"
2  #include <string.h>   
3  #include "src/utils/utils.h"
4  #define FIX 16     
5  #define LFIX 2     
6  #define LUT_SIZE ((1 << (8 + LFIX)) - 1)  
7  #if defined(USE_DITHERING)
8  #define DFIX 4           
9  #define DSIZE 4          
10  static const uint8_t kOrderedDither[DSIZE][DSIZE] = {
11    {  0,  8,  2, 10 },     
12    { 12,  4, 14,  6 },
13    {  3, 11,  1,  9 },
14    { 15,  7, 13,  5 }
15  };
16  #else
17  #define DFIX 0
18  #endif
19  typedef struct {
20    int width_, height_;  
21    int stride_;          
22    int row_;             
23    uint8_t* src_;        
24    uint8_t* dst_;        
25    int radius_;          
26    int scale_;           
27    void* mem_;           
28    uint16_t* start_;
29    uint16_t* cur_;
30    uint16_t* end_;
31    uint16_t* top_;
32    uint16_t* average_;
33    int num_levels_;       
34    int min_, max_;        
35    int min_level_dist_;   
36    int16_t* correction_;  
37  } SmoothParams;
38  #define CLIP_8b_MASK (int)(~0U << (8 + DFIX))
39  static WEBP_INLINE uint8_t clip_8b(int v) {
40    return (!(v & CLIP_8b_MASK)) ? (uint8_t)(v >> DFIX) : (v < 0) ? 0u : 255u;
41  }
42  #undef CLIP_8b_MASK
43  static void VFilter(SmoothParams* const p) {
44    const uint8_t* src = p->src_;
45    const int w = p->width_;
46    uint16_t* const cur = p->cur_;
47    const uint16_t* const top = p->top_;
48    uint16_t* const out = p->end_;
49    uint16_t sum = 0;               
50    int x;
51    for (x = 0; x < w; ++x) {
52      uint16_t new_value;
53      sum += src[x];
54      new_value = top[x] + sum;
55      out[x] = new_value - cur[x];  
56      cur[x] = new_value;
57    }
58    p->top_ = p->cur_;
59    p->cur_ += w;
60    if (p->cur_ == p->end_) p->cur_ = p->start_;  
61    if (p->row_ >= 0 && p->row_ < p->height_ - 1) {
62      p->src_ += p->stride_;
63    }
64  }
65  static void HFilter(SmoothParams* const p) {
66    const uint16_t* const in = p->end_;
67    uint16_t* const out = p->average_;
68    const uint32_t scale = p->scale_;
69    const int w = p->width_;
70    const int r = p->radius_;
71    int x;
72    for (x = 0; x <= r; ++x) {   
73      const uint16_t delta = in[x + r - 1] + in[r - x];
74      out[x] = (delta * scale) >> FIX;
75    }
76    for (; x < w - r; ++x) {     
77      const uint16_t delta = in[x + r] - in[x - r - 1];
78      out[x] = (delta * scale) >> FIX;
79    }
80    for (; x < w; ++x) {         
81      const uint16_t delta =
82          2 * in[w - 1] - in[2 * w - 2 - r - x] - in[x - r - 1];
83      out[x] = (delta * scale) >> FIX;
84    }
85  }
86  static void ApplyFilter(SmoothParams* const p) {
87    const uint16_t* const average = p->average_;
88    const int w = p->width_;
89    const int16_t* const correction = p->correction_;
90  #if defined(USE_DITHERING)
91    const uint8_t* const dither = kOrderedDither[p->row_ % DSIZE];
92  #endif
93    uint8_t* const dst = p->dst_;
94    int x;
95    for (x = 0; x < w; ++x) {
96      const int v = dst[x];
97      if (v < p->max_ && v > p->min_) {
98        const int c = (v << DFIX) + correction[average[x] - (v << LFIX)];
99  #if defined(USE_DITHERING)
100        dst[x] = clip_8b(c + dither[x % DSIZE]);
101  #else
102        dst[x] = clip_8b(c);
103  #endif
104      }
105    }
106    p->dst_ += p->stride_;  
107  }
108  static void InitCorrectionLUT(int16_t* const lut, int min_dist) {
109    const int threshold1 = min_dist << LFIX;
110    const int threshold2 = (3 * threshold1) >> 2;
111    const int max_threshold = threshold2 << DFIX;
112    const int delta = threshold1 - threshold2;
113    int i;
114    for (i = 1; i <= LUT_SIZE; ++i) {
115      int c = (i <= threshold2) ? (i << DFIX)
116            : (i < threshold1) ? max_threshold * (threshold1 - i) / delta
117            : 0;
118      c >>= LFIX;
119      lut[+i] = +c;
120      lut[-i] = -c;
121    }
122    lut[0] = 0;
123  }
124  static void CountLevels(SmoothParams* const p) {
125    int i, j, last_level;
126    uint8_t used_levels[256] = { 0 };
127    const uint8_t* data = p->src_;
128    p->min_ = 255;
129    p->max_ = 0;
130    for (j = 0; j < p->height_; ++j) {
131      for (i = 0; i < p->width_; ++i) {
132        const int v = data[i];
133        if (v < p->min_) p->min_ = v;
134        if (v > p->max_) p->max_ = v;
135        used_levels[v] = 1;
136      }
137      data += p->stride_;
138    }
139    p->min_level_dist_ = p->max_ - p->min_;
140    last_level = -1;
141    for (i = 0; i < 256; ++i) {
142      if (used_levels[i]) {
143        ++p->num_levels_;
144        if (last_level >= 0) {
145          const int level_dist = i - last_level;
146          if (level_dist < p->min_level_dist_) {
147            p->min_level_dist_ = level_dist;
148          }
149        }
150        last_level = i;
151      }
152    }
<span onclick='openModal()' class='match'>153  }
154  static int InitParams(uint8_t* const data, int width, int height, int stride,
155                        int radius, SmoothParams* const p) {
156    const int R = 2 * radius + 1;  
</span>157    const size_t size_scratch_m = (R + 1) * width * sizeof(*p->start_);
158    const size_t size_m =  width * sizeof(*p->average_);
159    const size_t size_lut = (1 + 2 * LUT_SIZE) * sizeof(*p->correction_);
160    const size_t total_size = size_scratch_m + size_m + size_lut;
161    uint8_t* mem = (uint8_t*)WebPSafeMalloc(1U, total_size);
162    if (mem == NULL) return 0;
163    p->mem_ = (void*)mem;
164    p->start_ = (uint16_t*)mem;
165    p->cur_ = p->start_;
166    p->end_ = p->start_ + R * width;
167    p->top_ = p->end_ - width;
168    memset(p->top_, 0, width * sizeof(*p->top_));
169    mem += size_scratch_m;
170    p->average_ = (uint16_t*)mem;
171    mem += size_m;
172    p->width_ = width;
173    p->height_ = height;
174    p->stride_ = stride;
175    p->src_ = data;
176    p->dst_ = data;
177    p->radius_ = radius;
178    p->scale_ = (1 << (FIX + LFIX)) / (R * R);  
179    p->row_ = -radius;
180    CountLevels(p);
181    p->correction_ = ((int16_t*)mem) + LUT_SIZE;
182    InitCorrectionLUT(p->correction_, p->min_level_dist_);
183    return 1;
184  }
185  static void CleanupParams(SmoothParams* const p) {
186    WebPSafeFree(p->mem_);
187  }
188  int WebPDequantizeLevels(uint8_t* const data, int width, int height, int stride,
189                           int strength) {
190    int radius = 4 * strength / 100;
191    if (strength < 0 || strength > 100) return 0;
192    if (data == NULL || width <= 0 || height <= 0) return 0;  
193    if (2 * radius + 1 > width) radius = (width - 1) >> 1;
194    if (2 * radius + 1 > height) radius = (height - 1) >> 1;
195    if (radius > 0) {
196      SmoothParams p;
197      memset(&p, 0, sizeof(p));
198      if (!InitParams(data, width, height, stride, radius, &p)) return 0;
199      if (p.num_levels_ > 2) {
200        for (; p.row_ < p.height_; ++p.row_) {
201          VFilter(&p);  
202          if (p.row_ >= p.radius_) {
203            HFilter(&p);
204            ApplyFilter(&p);
205          }
206        }
207      }
208      CleanupParams(&p);
209    }
210    return 1;
211  }
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_i2s.h</h3>
            <pre><code>1  #ifndef NRF_I2S_H__
2  #define NRF_I2S_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(I2S_CONFIG_CLKCONFIG_CLKSRC_Msk) || defined(__NRFX_DOXYGEN__)
8  #define NRF_I2S_HAS_CLKCONFIG 1
9  #else
10  #define NRF_I2S_HAS_CLKCONFIG 0
11  #endif
12  #define NRF_I2S_PIN_NOT_CONNECTED  0xFFFFFFFF
13  typedef enum
14  {
15      NRF_I2S_TASK_START = offsetof(NRF_I2S_Type, TASKS_START), 
16      NRF_I2S_TASK_STOP  = offsetof(NRF_I2S_Type, TASKS_STOP)   
17  } nrf_i2s_task_t;
18  typedef enum
19  {
20      NRF_I2S_EVENT_RXPTRUPD   = offsetof(NRF_I2S_Type, EVENTS_RXPTRUPD),  
21      NRF_I2S_EVENT_TXPTRUPD   = offsetof(NRF_I2S_Type, EVENTS_TXPTRUPD),  
22      NRF_I2S_EVENT_STOPPED    = offsetof(NRF_I2S_Type, EVENTS_STOPPED),   
23  #if defined(I2S_INTENSET_FRAMESTART_Msk) || defined(__NRFX_DOXYGEN_)
24      NRF_I2S_EVENT_FRAMESTART = offsetof(NRF_I2S_Type, EVENTS_FRAMESTART) 
25  #endif
26  } nrf_i2s_event_t;
27  typedef enum
28  {
29      NRF_I2S_INT_RXPTRUPD_MASK   = I2S_INTENSET_RXPTRUPD_Msk,  
30      NRF_I2S_INT_TXPTRUPD_MASK   = I2S_INTENSET_TXPTRUPD_Msk,  
31      NRF_I2S_INT_STOPPED_MASK    = I2S_INTENSET_STOPPED_Msk,   
32  #if defined(I2S_INTENSET_FRAMESTART_Msk) || defined(__NRFX_DOXYGEN_)
33      NRF_I2S_INT_FRAMESTART_MASK = I2S_INTENCLR_FRAMESTART_Msk 
34  #endif
35  } nrf_i2s_int_mask_t;
36  typedef enum
37  {
38      NRF_I2S_MODE_MASTER = I2S_CONFIG_MODE_MODE_Master, 
39      NRF_I2S_MODE_SLAVE  = I2S_CONFIG_MODE_MODE_Slave   
40  } nrf_i2s_mode_t;
41  typedef enum
42  {
43      NRF_I2S_MCK_DISABLED  = 0,                                       
44  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2) || defined(__NRFX_DOXYGEN__)
45      NRF_I2S_MCK_32MDIV2   = (int)I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2, 
46  #endif
47  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3) || defined(__NRFX_DOXYGEN__)
48      NRF_I2S_MCK_32MDIV3   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3,      
49  #endif
50  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4) || defined(__NRFX_DOXYGEN__)
51      NRF_I2S_MCK_32MDIV4   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4,      
52  #endif
53  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5) || defined(__NRFX_DOXYGEN__)
54      NRF_I2S_MCK_32MDIV5   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5,      
55  #endif
56  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6) || defined(__NRFX_DOXYGEN__)
57      NRF_I2S_MCK_32MDIV6   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6,      
58  #endif
59      NRF_I2S_MCK_32MDIV8   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV8,      
60      NRF_I2S_MCK_32MDIV10  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV10,     
61      NRF_I2S_MCK_32MDIV11  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV11,     
62      NRF_I2S_MCK_32MDIV15  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV15,     
63      NRF_I2S_MCK_32MDIV16  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV16,     
64      NRF_I2S_MCK_32MDIV21  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV21,     
65      NRF_I2S_MCK_32MDIV23  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV23,     
66      NRF_I2S_MCK_32MDIV30  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV30,     
67      NRF_I2S_MCK_32MDIV31  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV31,     
68      NRF_I2S_MCK_32MDIV32  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV32,     
69      NRF_I2S_MCK_32MDIV42  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV42,     
70      NRF_I2S_MCK_32MDIV63  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV63,     
71      NRF_I2S_MCK_32MDIV125 = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV125     
72  } nrf_i2s_mck_t;
73  typedef enum
74  {
75      NRF_I2S_RATIO_32X  = I2S_CONFIG_RATIO_RATIO_32X,  
76      NRF_I2S_RATIO_48X  = I2S_CONFIG_RATIO_RATIO_48X,  
77      NRF_I2S_RATIO_64X  = I2S_CONFIG_RATIO_RATIO_64X,  
78      NRF_I2S_RATIO_96X  = I2S_CONFIG_RATIO_RATIO_96X,  
79      NRF_I2S_RATIO_128X = I2S_CONFIG_RATIO_RATIO_128X, 
80      NRF_I2S_RATIO_192X = I2S_CONFIG_RATIO_RATIO_192X, 
81      NRF_I2S_RATIO_256X = I2S_CONFIG_RATIO_RATIO_256X, 
82      NRF_I2S_RATIO_384X = I2S_CONFIG_RATIO_RATIO_384X, 
83      NRF_I2S_RATIO_512X = I2S_CONFIG_RATIO_RATIO_512X  
84  } nrf_i2s_ratio_t;
85  typedef enum
86  {
87      NRF_I2S_SWIDTH_8BIT          = I2S_CONFIG_SWIDTH_SWIDTH_8Bit,      
88      NRF_I2S_SWIDTH_16BIT         = I2S_CONFIG_SWIDTH_SWIDTH_16Bit,     
89      NRF_I2S_SWIDTH_24BIT         = I2S_CONFIG_SWIDTH_SWIDTH_24Bit,     
90  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_32Bit) || defined(__NRFX_DOXYGEN__)
91      NRF_I2S_SWIDTH_32BIT         = I2S_CONFIG_SWIDTH_SWIDTH_32Bit,     
92  #endif
93  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_8BitIn16) || defined(__NRFX_DOXYGEN__)
94      NRF_I2S_SWIDTH_8BIT_IN16BIT  = I2S_CONFIG_SWIDTH_SWIDTH_8BitIn16,  
95  #endif
96  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_8BitIn32) || defined(__NRFX_DOXYGEN__)
97      NRF_I2S_SWIDTH_8BIT_IN32BIT  = I2S_CONFIG_SWIDTH_SWIDTH_8BitIn32,  
98  #endif
99  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_16BitIn32) || defined(__NRFX_DOXYGEN__)
100      NRF_I2S_SWIDTH_16BIT_IN32BIT = I2S_CONFIG_SWIDTH_SWIDTH_16BitIn32, 
101  #endif
102  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_24BitIn32) || defined(__NRFX_DOXYGEN__)
103      NRF_I2S_SWIDTH_24BIT_IN32BIT = I2S_CONFIG_SWIDTH_SWIDTH_24BitIn32, 
104  #endif
105  } nrf_i2s_swidth_t;
106  typedef enum
107  {
108      NRF_I2S_ALIGN_LEFT  = I2S_CONFIG_ALIGN_ALIGN_Left, 
109      NRF_I2S_ALIGN_RIGHT = I2S_CONFIG_ALIGN_ALIGN_Right 
110  } nrf_i2s_align_t;
111  typedef enum
112  {
113      NRF_I2S_FORMAT_I2S     = I2S_CONFIG_FORMAT_FORMAT_I2S,    
114      NRF_I2S_FORMAT_ALIGNED = I2S_CONFIG_FORMAT_FORMAT_Aligned 
115  } nrf_i2s_format_t;
116  typedef enum
117  {
118      NRF_I2S_CHANNELS_STEREO = I2S_CONFIG_CHANNELS_CHANNELS_Stereo, 
119      NRF_I2S_CHANNELS_LEFT   = I2S_CONFIG_CHANNELS_CHANNELS_Left,   
120      NRF_I2S_CHANNELS_RIGHT  = I2S_CONFIG_CHANNELS_CHANNELS_Right   
121  } nrf_i2s_channels_t;
122  #if NRF_I2S_HAS_CLKCONFIG
123  typedef enum
124  {
125      NRF_I2S_CLKSRC_PCLK32M = I2S_CONFIG_CLKCONFIG_CLKSRC_PCLK32M, 
126      NRF_I2S_CLKSRC_ACLK    = I2S_CONFIG_CLKCONFIG_CLKSRC_ACLK     
127  } nrf_i2s_clksrc_t;
128  #endif
129  NRF_STATIC_INLINE void nrf_i2s_task_trigger(NRF_I2S_Type * p_reg,
130                                              nrf_i2s_task_t task);
131  NRF_STATIC_INLINE uint32_t nrf_i2s_task_address_get(NRF_I2S_Type const * p_reg,
132                                                      nrf_i2s_task_t       task);
133  NRF_STATIC_INLINE void nrf_i2s_event_clear(NRF_I2S_Type *  p_reg,
134                                             nrf_i2s_event_t event);
135  NRF_STATIC_INLINE bool nrf_i2s_event_check(NRF_I2S_Type const * p_reg,
136                                             nrf_i2s_event_t      event);
137  NRF_STATIC_INLINE uint32_t nrf_i2s_event_address_get(NRF_I2S_Type const * p_reg,
138                                                       nrf_i2s_event_t      event);
139  NRF_STATIC_INLINE void nrf_i2s_int_enable(NRF_I2S_Type * p_reg, uint32_t mask);
140  NRF_STATIC_INLINE void nrf_i2s_int_disable(NRF_I2S_Type * p_reg, uint32_t mask);
141  NRF_STATIC_INLINE uint32_t nrf_i2s_int_enable_check(NRF_I2S_Type const * p_reg, uint32_t mask);
142  NRF_STATIC_INLINE void nrf_i2s_enable(NRF_I2S_Type * p_reg);
143  NRF_STATIC_INLINE void nrf_i2s_disable(NRF_I2S_Type * p_reg);
144  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
145  NRF_STATIC_INLINE void nrf_i2s_subscribe_set(NRF_I2S_Type * p_reg,
146                                               nrf_i2s_task_t task,
147                                               uint8_t        channel);
148  NRF_STATIC_INLINE void nrf_i2s_subscribe_clear(NRF_I2S_Type * p_reg,
149                                                 nrf_i2s_task_t task);
150  NRF_STATIC_INLINE void nrf_i2s_publish_set(NRF_I2S_Type *  p_reg,
151                                             nrf_i2s_event_t event,
152                                             uint8_t         channel);
153  NRF_STATIC_INLINE void nrf_i2s_publish_clear(NRF_I2S_Type *  p_reg,
154                                               nrf_i2s_event_t event);
155  #endif 
156  NRF_STATIC_INLINE void nrf_i2s_pins_set(NRF_I2S_Type * p_reg,
157                                          uint32_t       sck_pin,
158                                          uint32_t       lrck_pin,
159                                          uint32_t       mck_pin,
160                                          uint32_t       sdout_pin,
161                                          uint32_t       sdin_pin);
162  NRF_STATIC_INLINE bool nrf_i2s_configure(NRF_I2S_Type *     p_reg,
163                                           nrf_i2s_mode_t     mode,
164                                           nrf_i2s_format_t   format,
165                                           nrf_i2s_align_t    alignment,
166                                           nrf_i2s_swidth_t   sample_width,
167                                           nrf_i2s_channels_t channels,
168                                           nrf_i2s_mck_t      mck_setup,
169                                           nrf_i2s_ratio_t    ratio);
170  NRF_STATIC_INLINE void nrf_i2s_transfer_set(NRF_I2S_Type *   p_reg,
171                                              uint16_t         size,
172                                              uint32_t *       p_rx_buffer,
173                                              uint32_t const * p_tx_buffer);
174  NRF_STATIC_INLINE void nrf_i2s_rx_buffer_set(NRF_I2S_Type * p_reg,
175                                               uint32_t *     p_buffer);
176  NRF_STATIC_INLINE uint32_t * nrf_i2s_rx_buffer_get(NRF_I2S_Type const * p_reg);
177  NRF_STATIC_INLINE void nrf_i2s_tx_buffer_set(NRF_I2S_Type *   p_reg,
178                                               uint32_t const * p_buffer);
179  NRF_STATIC_INLINE uint32_t * nrf_i2s_tx_buffer_get(NRF_I2S_Type const * p_reg);
180  #if NRF_I2S_HAS_CLKCONFIG
181  NRF_STATIC_INLINE void nrf_i2s_clk_configure(NRF_I2S_Type *   p_reg,
182                                               nrf_i2s_clksrc_t clksrc,
183                                               bool             enable_bypass);
184  #endif
185  #ifndef NRF_DECLARE_ONLY
186  NRF_STATIC_INLINE void nrf_i2s_task_trigger(NRF_I2S_Type * p_reg,
187                                              nrf_i2s_task_t task)
188  {
189      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
190  }
191  NRF_STATIC_INLINE uint32_t nrf_i2s_task_address_get(NRF_I2S_Type const * p_reg,
192                                                      nrf_i2s_task_t       task)
193  {
194      return ((uint32_t)p_reg + (uint32_t)task);
195  }
196  NRF_STATIC_INLINE void nrf_i2s_event_clear(NRF_I2S_Type *  p_reg,
197                                             nrf_i2s_event_t event)
198  {
199      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
200  #if __CORTEX_M == 0x04
201      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
202      (void)dummy;
203  #endif
204  }
205  NRF_STATIC_INLINE bool nrf_i2s_event_check(NRF_I2S_Type const * p_reg,
206                                             nrf_i2s_event_t      event)
207  {
208      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
209  }
210  NRF_STATIC_INLINE uint32_t nrf_i2s_event_address_get(NRF_I2S_Type const * p_reg,
211                                                       nrf_i2s_event_t      event)
212  {
213      return ((uint32_t)p_reg + (uint32_t)event);
214  }
215  NRF_STATIC_INLINE void nrf_i2s_int_enable(NRF_I2S_Type * p_reg, uint32_t mask)
216  {
217      p_reg->INTENSET = mask;
218  }
219  NRF_STATIC_INLINE void nrf_i2s_int_disable(NRF_I2S_Type * p_reg, uint32_t mask)
220  {
221      p_reg->INTENCLR = mask;
222  }
223  NRF_STATIC_INLINE uint32_t nrf_i2s_int_enable_check(NRF_I2S_Type const * p_reg, uint32_t mask)
224  {
225      return p_reg->INTENSET & mask;
226  }
227  NRF_STATIC_INLINE void nrf_i2s_enable(NRF_I2S_Type * p_reg)
228  {
229      p_reg->ENABLE = (I2S_ENABLE_ENABLE_Enabled << I2S_ENABLE_ENABLE_Pos);
230  }
231  NRF_STATIC_INLINE void nrf_i2s_disable(NRF_I2S_Type * p_reg)
232  {
233      p_reg->ENABLE = (I2S_ENABLE_ENABLE_Disabled << I2S_ENABLE_ENABLE_Pos);
234  }
235  #if defined(DPPI_PRESENT)
236  NRF_STATIC_INLINE void nrf_i2s_subscribe_set(NRF_I2S_Type * p_reg,
237                                               nrf_i2s_task_t task,
238                                               uint8_t        channel)
239  {
240      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
241              ((uint32_t)channel | I2S_SUBSCRIBE_START_EN_Msk);
242  }
243  NRF_STATIC_INLINE void nrf_i2s_subscribe_clear(NRF_I2S_Type * p_reg,
244                                                 nrf_i2s_task_t task)
245  {
246      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
247  }
248  NRF_STATIC_INLINE void nrf_i2s_publish_set(NRF_I2S_Type *  p_reg,
249                                             nrf_i2s_event_t event,
250                                             uint8_t         channel)
251  {
252      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
253              ((uint32_t)channel | I2S_PUBLISH_STOPPED_EN_Msk);
254  }
255  NRF_STATIC_INLINE void nrf_i2s_publish_clear(NRF_I2S_Type *  p_reg,
256                                               nrf_i2s_event_t event)
257  {
258      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
259  }
260  #endif 
261  NRF_STATIC_INLINE void nrf_i2s_pins_set(NRF_I2S_Type * p_reg,
262                                          uint32_t       sck_pin,
263                                          uint32_t       lrck_pin,
264                                          uint32_t       mck_pin,
265                                          uint32_t       sdout_pin,
266                                          uint32_t       sdin_pin)
267  {
268      p_reg->PSEL.SCK   = sck_pin;
269      p_reg->PSEL.LRCK  = lrck_pin;
270      p_reg->PSEL.MCK   = mck_pin;
271      p_reg->PSEL.SDOUT = sdout_pin;
272      p_reg->PSEL.SDIN  = sdin_pin;
<span onclick='openModal()' class='match'>273  }
274  NRF_STATIC_INLINE bool nrf_i2s_configure(NRF_I2S_Type *     p_reg,
275                                           nrf_i2s_mode_t     mode,
276                                           nrf_i2s_format_t   format,
277                                           nrf_i2s_align_t    alignment,
278                                           nrf_i2s_swidth_t   sample_width,
279                                           nrf_i2s_channels_t channels,
280                                           nrf_i2s_mck_t      mck_setup,
</span>281                                           nrf_i2s_ratio_t    ratio)
282  {
283      if (mode == NRF_I2S_MODE_MASTER)
284      {
285          if (((sample_width == NRF_I2S_SWIDTH_16BIT) &&
286                   (ratio == NRF_I2S_RATIO_48X))
287              ||
288              ((sample_width == NRF_I2S_SWIDTH_24BIT) &&
289                  ((ratio == NRF_I2S_RATIO_32X)  ||
290                   (ratio == NRF_I2S_RATIO_64X)  ||
291                   (ratio == NRF_I2S_RATIO_128X) ||
292                   (ratio == NRF_I2S_RATIO_256X) ||
293                   (ratio == NRF_I2S_RATIO_512X))))
294          {
295              return false;
296          }
297      }
298      p_reg->CONFIG.MODE     = mode;
299      p_reg->CONFIG.FORMAT   = format;
300      p_reg->CONFIG.ALIGN    = alignment;
301      p_reg->CONFIG.SWIDTH   = sample_width;
302      p_reg->CONFIG.CHANNELS = channels;
303      p_reg->CONFIG.RATIO    = ratio;
304      if (mck_setup == NRF_I2S_MCK_DISABLED)
305      {
306          p_reg->CONFIG.MCKEN =
307              (I2S_CONFIG_MCKEN_MCKEN_Disabled << I2S_CONFIG_MCKEN_MCKEN_Pos);
308      }
309      else
310      {
311          p_reg->CONFIG.MCKFREQ = mck_setup;
312          p_reg->CONFIG.MCKEN =
313              (I2S_CONFIG_MCKEN_MCKEN_Enabled << I2S_CONFIG_MCKEN_MCKEN_Pos);
314      }
315      return true;
316  }
317  NRF_STATIC_INLINE void nrf_i2s_transfer_set(NRF_I2S_Type *   p_reg,
318                                              uint16_t         size,
319                                              uint32_t *       p_buffer_rx,
320                                              uint32_t const * p_buffer_tx)
321  {
322      p_reg->RXTXD.MAXCNT = size;
323      nrf_i2s_rx_buffer_set(p_reg, p_buffer_rx);
324      p_reg->CONFIG.RXEN = (p_buffer_rx != NULL) ? 1 : 0;
325      nrf_i2s_tx_buffer_set(p_reg, p_buffer_tx);
326      p_reg->CONFIG.TXEN = (p_buffer_tx != NULL) ? 1 : 0;
327  }
328  NRF_STATIC_INLINE void nrf_i2s_rx_buffer_set(NRF_I2S_Type * p_reg,
329                                               uint32_t * p_buffer)
330  {
331      p_reg->RXD.PTR = (uint32_t)p_buffer;
332  }
333  NRF_STATIC_INLINE uint32_t * nrf_i2s_rx_buffer_get(NRF_I2S_Type const * p_reg)
334  {
335      return (uint32_t *)(p_reg->RXD.PTR);
336  }
337  NRF_STATIC_INLINE void nrf_i2s_tx_buffer_set(NRF_I2S_Type *   p_reg,
338                                               uint32_t const * p_buffer)
339  {
340      p_reg->TXD.PTR = (uint32_t)p_buffer;
341  }
342  NRF_STATIC_INLINE uint32_t * nrf_i2s_tx_buffer_get(NRF_I2S_Type const * p_reg)
343  {
344      return (uint32_t *)(p_reg->TXD.PTR);
345  }
346  #if NRF_I2S_HAS_CLKCONFIG
347  NRF_STATIC_INLINE void nrf_i2s_clk_configure(NRF_I2S_Type *   p_reg,
348                                               nrf_i2s_clksrc_t clksrc,
349                                               bool             enable_bypass)
350  {
351      p_reg->CONFIG.CLKCONFIG = ((uint32_t) clksrc << I2S_CONFIG_CLKCONFIG_CLKSRC_Pos) |
352                                ((uint32_t) enable_bypass << I2S_CONFIG_CLKCONFIG_BYPASS_Pos);
353  }
354  #endif
355  #endif 
356  #ifdef __cplusplus
357  }
358  #endif
359  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-quant_levels_dec_utils.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_i2s.h</div>
                </div>
                <div class="column column_space"><pre><code>153  }
154  static int InitParams(uint8_t* const data, int width, int height, int stride,
155                        int radius, SmoothParams* const p) {
156    const int R = 2 * radius + 1;  
</pre></code></div>
                <div class="column column_space"><pre><code>273  }
274  NRF_STATIC_INLINE bool nrf_i2s_configure(NRF_I2S_Type *     p_reg,
275                                           nrf_i2s_mode_t     mode,
276                                           nrf_i2s_format_t   format,
277                                           nrf_i2s_align_t    alignment,
278                                           nrf_i2s_swidth_t   sample_width,
279                                           nrf_i2s_channels_t channels,
280                                           nrf_i2s_mck_t      mck_setup,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    