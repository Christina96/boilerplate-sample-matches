
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.709175738724728%, Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-pf.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <sys/types.h>
5  #include <sys/time.h>
6  #include <sys/timeb.h>
7  #include <sys/socket.h>
8  #include <sys/file.h>
9  #include <sys/ioctl.h>
10  #include <net/pfilt.h>
11  struct mbuf;
12  struct rtentry;
13  #include <net/if.h>
14  #include <netinet/in.h>
15  #include <netinet/in_systm.h>
16  #include <netinet/ip.h>
17  #include <netinet/if_ether.h>
18  #include <netinet/ip_var.h>
19  #include <netinet/udp.h>
20  #include <netinet/udp_var.h>
21  #include <netinet/tcp.h>
22  #include <netinet/tcpip.h>
23  #include <errno.h>
24  #include <netdb.h>
25  #include <stdio.h>
26  #include <stdlib.h>
27  #include <string.h>
28  #include <unistd.h>
29  #define PCAP_DONT_INCLUDE_PCAP_BPF_H
30  #include <net/bpf.h>
31  #include "pcap-int.h"
32  #ifdef HAVE_OS_PROTO_H
33  #include "os-proto.h"
34  #endif
35  #define       PCAP_FDDIPAD 3
36  struct pcap_pf {
<span onclick='openModal()' class='match'>37  	int	filtering_in_kernel; &bsol;* using kernel filter */
38  	u_long	TotPkts;	&bsol;* can't oflow for 79 hrs on ether */
39  	u_long	TotAccepted;	&bsol;* count accepted by filter */
40  	u_long	TotDrops;	&bsol;* count of dropped packets */
41  	long	TotMissed;	&bsol;* missed by i/f during this run */
42  	long	OrigMissed;	&bsol;* missed by i/f before this run */
</span>43  };
44  static int pcap_setfilter_pf(pcap_t *, struct bpf_program *);
45  #define BUFSPACE (200 * 256)
46  static int
47  pcap_read_pf(pcap_t *pc, int cnt, pcap_handler callback, u_char *user)
48  {
49  	struct pcap_pf *pf = pc->priv;
50  	register u_char *p, *bp;
51  	register int cc, n, buflen, inc;
52  	register struct enstamp *sp;
53  	struct enstamp stamp;
54  	register u_int pad;
55   again:
56  	cc = pc->cc;
57  	if (cc == 0) {
58  		cc = read(pc->fd, (char *)pc->buffer + pc->offset, pc->bufsize);
59  		if (cc < 0) {
60  			if (errno == EWOULDBLOCK)
61  				return (0);
62  			if (errno == EINVAL &&
63  			    lseek(pc->fd, 0L, SEEK_CUR) + pc->bufsize < 0) {
64  				(void)lseek(pc->fd, 0L, SEEK_SET);
65  				goto again;
66  			}
67  			pcap_fmt_errmsg_for_errno(pc->errbuf,
68  			    sizeof(pc->errbuf), errno, "pf read");
69  			return (-1);
70  		}
71  		bp = pc->buffer + pc->offset;
72  	} else
73  		bp = pc->bp;
74  	n = 0;
75  	pad = pc->fddipad;
76  	while (cc > 0) {
77  		if (pc->break_loop) {
78  			if (n == 0) {
79  				pc->break_loop = 0;
80  				return (-2);
81  			} else {
82  				pc->cc = cc;
83  				pc->bp = bp;
84  				return (n);
85  			}
86  		}
87  		if (cc < sizeof(*sp)) {
88  			snprintf(pc->errbuf, sizeof(pc->errbuf),
89  			    "pf short read (%d)", cc);
90  			return (-1);
91  		}
92  		if ((long)bp & 3) {
93  			sp = &stamp;
94  			memcpy((char *)sp, (char *)bp, sizeof(*sp));
95  		} else
96  			sp = (struct enstamp *)bp;
97  		if (sp->ens_stamplen != sizeof(*sp)) {
98  			snprintf(pc->errbuf, sizeof(pc->errbuf),
99  			    "pf short stamplen (%d)",
100  			    sp->ens_stamplen);
101  			return (-1);
102  		}
103  		p = bp + sp->ens_stamplen;
104  		buflen = sp->ens_count;
105  		if (buflen > pc->snapshot)
106  			buflen = pc->snapshot;
107  		inc = ENALIGN(buflen + sp->ens_stamplen);
108  		cc -= inc;
109  		bp += inc;
110  		pf->TotPkts++;
111  		pf->TotDrops += sp->ens_dropped;
112  		pf->TotMissed = sp->ens_ifoverflows;
113  		if (pf->OrigMissed < 0)
114  			pf->OrigMissed = pf->TotMissed;
115  		if (pf->filtering_in_kernel ||
116  		    pcap_filter(pc->fcode.bf_insns, p, sp->ens_count, buflen)) {
117  			struct pcap_pkthdr h;
118  			pf->TotAccepted++;
119  			h.ts = sp->ens_tstamp;
120  			h.len = sp->ens_count - pad;
121  			p += pad;
122  			buflen -= pad;
123  			h.caplen = buflen;
124  			(*callback)(user, &h, p);
125  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
126  				pc->cc = cc;
127  				pc->bp = bp;
128  				return (n);
129  			}
130  		}
131  	}
132  	pc->cc = 0;
133  	return (n);
134  }
135  static int
136  pcap_inject_pf(pcap_t *p, const void *buf, int size)
137  {
138  	int ret;
139  	ret = write(p->fd, buf, size);
140  	if (ret == -1) {
141  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
142  		    errno, "send");
143  		return (-1);
144  	}
145  	return (ret);
146  }
147  static int
148  pcap_stats_pf(pcap_t *p, struct pcap_stat *ps)
149  {
150  	struct pcap_pf *pf = p->priv;
151  	ps->ps_recv = pf->TotAccepted;
152  	ps->ps_drop = pf->TotDrops;
153  	ps->ps_ifdrop = pf->TotMissed - pf->OrigMissed;
154  	return (0);
155  }
156  #ifndef DLT_DOCSIS
157  #define DLT_DOCSIS	143
158  #endif
159  static int
160  pcap_activate_pf(pcap_t *p)
161  {
162  	struct pcap_pf *pf = p->priv;
163  	short enmode;
164  	int backlog = -1;	&bsol;* request the most */
165  	struct enfilter Filter;
166  	struct endevp devparams;
167  	int err;
168  	p->fd = pfopen(p->opt.device, O_RDWR);
169  	if (p->fd == -1 && errno == EACCES)
170  		p->fd = pfopen(p->opt.device, O_RDONLY);
171  	if (p->fd < 0) {
172  		if (errno == EACCES) {
173  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
174  			    "pf open: %s: Permission denied\n"
175  "your system may not be properly configured; see the packetfilter(4) man page",
176  			    p->opt.device);
177  			err = PCAP_ERROR_PERM_DENIED;
178  		} else {
179  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
180  			    errno, "pf open: %s", p->opt.device);
181  			err = PCAP_ERROR;
182  		}
183  		goto bad;
184  	}
185  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
186  		p->snapshot = MAXIMUM_SNAPLEN;
187  	pf->OrigMissed = -1;
188  	enmode = ENTSTAMP|ENNONEXCL;
189  	if (!p->opt.immediate)
190  		enmode |= ENBATCH;
191  	if (p->opt.promisc)
192  		enmode |= ENPROMISC;
193  	if (ioctl(p->fd, EIOCMBIS, (caddr_t)&enmode) < 0) {
194  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
195  		    errno, "EIOCMBIS");
196  		err = PCAP_ERROR;
197  		goto bad;
198  	}
199  #ifdef	ENCOPYALL
200  	enmode = ENCOPYALL;
201  	(void)ioctl(p->fd, EIOCMBIS, (caddr_t)&enmode);&bsol;* OK if this fails */
202  #endif
203  	if (ioctl(p->fd, EIOCSETW, (caddr_t)&backlog) < 0) {
204  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
205  		    errno, "EIOCSETW");
206  		err = PCAP_ERROR;
207  		goto bad;
208  	}
209  	if (ioctl(p->fd, EIOCDEVP, (caddr_t)&devparams) < 0) {
210  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
211  		    errno, "EIOCDEVP");
212  		err = PCAP_ERROR;
213  		goto bad;
214  	}
215  #ifndef	ENDT_FDDI
216  #define	ENDT_FDDI	4
217  #endif
218  	switch (devparams.end_dev_type) {
219  	case ENDT_10MB:
220  		p->linktype = DLT_EN10MB;
221  		p->offset = 2;
222  		p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
223  		if (p->dlt_list != NULL) {
224  			p->dlt_list[0] = DLT_EN10MB;
225  			p->dlt_list[1] = DLT_DOCSIS;
226  			p->dlt_count = 2;
227  		}
228  		break;
229  	case ENDT_FDDI:
230  		p->linktype = DLT_FDDI;
231  		break;
232  #ifdef ENDT_SLIP
233  	case ENDT_SLIP:
234  		p->linktype = DLT_SLIP;
235  		break;
236  #endif
237  #ifdef ENDT_PPP
238  	case ENDT_PPP:
239  		p->linktype = DLT_PPP;
240  		break;
241  #endif
242  #ifdef ENDT_LOOPBACK
243  	case ENDT_LOOPBACK:
244  		p->linktype = DLT_EN10MB;
245  		p->offset = 2;
246  		break;
247  #endif
248  #ifdef ENDT_TRN
249  	case ENDT_TRN:
250  		p->linktype = DLT_IEEE802;
251  		break;
252  #endif
253  	default:
254  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
255  		    "unknown data-link type %u", devparams.end_dev_type);
256  		err = PCAP_ERROR;
257  		goto bad;
258  	}
259  	if (p->linktype == DLT_FDDI) {
260  		p->fddipad = PCAP_FDDIPAD;
261  		p->snapshot += PCAP_FDDIPAD;
262  	} else
263  		p->fddipad = 0;
264  	if (ioctl(p->fd, EIOCTRUNCATE, (caddr_t)&p->snapshot) < 0) {
265  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
266  		    errno, "EIOCTRUNCATE");
267  		err = PCAP_ERROR;
268  		goto bad;
269  	}
270  	memset(&Filter, 0, sizeof(Filter));
271  	Filter.enf_Priority = 37;	&bsol;* anything > 2 */
272  	Filter.enf_FilterLen = 0;	&bsol;* means "always true" */
273  	if (ioctl(p->fd, EIOCSETF, (caddr_t)&Filter) < 0) {
274  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
275  		    errno, "EIOCSETF");
276  		err = PCAP_ERROR;
277  		goto bad;
278  	}
279  	if (p->opt.timeout != 0) {
280  		struct timeval timeout;
281  		timeout.tv_sec = p->opt.timeout / 1000;
282  		timeout.tv_usec = (p->opt.timeout * 1000) % 1000000;
283  		if (ioctl(p->fd, EIOCSRTIMEOUT, (caddr_t)&timeout) < 0) {
284  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
285  			    errno, "EIOCSRTIMEOUT");
286  			err = PCAP_ERROR;
287  			goto bad;
288  		}
289  	}
290  	p->bufsize = BUFSPACE;
291  	p->buffer = malloc(p->bufsize + p->offset);
292  	if (p->buffer == NULL) {
293  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
294  		    errno, "malloc");
295  		err = PCAP_ERROR;
296  		goto bad;
297  	}
298  	p->selectable_fd = p->fd;
299  	p->read_op = pcap_read_pf;
300  	p->inject_op = pcap_inject_pf;
301  	p->setfilter_op = pcap_setfilter_pf;
302  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
303  	p->set_datalink_op = NULL;	&bsol;* can't change data link type */
304  	p->getnonblock_op = pcap_getnonblock_fd;
305  	p->setnonblock_op = pcap_setnonblock_fd;
306  	p->stats_op = pcap_stats_pf;
307  	return (0);
308   bad:
309  	pcap_cleanup_live_common(p);
310  	return (err);
311  }
312  pcap_t *
313  pcap_create_interface(const char *device _U_, char *ebuf)
314  {
315  	pcap_t *p;
316  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_pf);
317  	if (p == NULL)
318  		return (NULL);
319  	p->activate_op = pcap_activate_pf;
320  	return (p);
321  }
322  static int
323  can_be_bound(const char *name _U_)
324  {
325  	return (1);
326  }
327  static int
328  get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
329  {
330  	if (*flags & PCAP_IF_LOOPBACK) {
331  		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
332  		return (0);
333  	}
334  	return (0);
335  }
336  int
337  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
338  {
339  	return (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
340  	    get_if_flags));
341  }
342  static int
343  pcap_setfilter_pf(pcap_t *p, struct bpf_program *fp)
344  {
345  	struct pcap_pf *pf = p->priv;
346  	struct bpf_version bv;
347  	if (ioctl(p->fd, BIOCVERSION, (caddr_t)&bv) >= 0) {
348  		if (bv.bv_major == BPF_MAJOR_VERSION &&
349  		    bv.bv_minor >= BPF_MINOR_VERSION) {
350  			if (ioctl(p->fd, BIOCSETF, (caddr_t)fp) < 0) {
351  				pcap_fmt_errmsg_for_errno(p->errbuf,
352  				    sizeof(p->errbuf), errno, "BIOCSETF");
353  				return (-1);
354  			}
355  			fprintf(stderr, "tcpdump: Using kernel BPF filter\n");
356  			pf->filtering_in_kernel = 1;
357  			p->cc = 0;
358  			return (0);
359  		}
360  		fprintf(stderr,
361  	    "tcpdump: Requires BPF language %d.%d or higher; kernel is %d.%d\n",
362  		    BPF_MAJOR_VERSION, BPF_MINOR_VERSION,
363  		    bv.bv_major, bv.bv_minor);
364  	}
365  	if (pcap_install_bpf_program(p, fp) < 0)
366  		return (-1);
367  	fprintf(stderr, "tcpdump: Filtering in user process\n");
368  	pf->filtering_in_kernel = 0;
369  	return (0);
370  }
371  const char *
372  pcap_lib_version(void)
373  {
374  	return (PCAP_VERSION_STRING);
375  }
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-resolv.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "config.h"
3  #endif
4  #include <stdio.h>
5  #include <stdlib.h>
6  #include <string.h>
7  #include <fcntl.h>
8  #include <ev.h>
9  #include <udns.h>
10  #ifdef __MINGW32__
11  #include "win32.h"
12  #else
13  #include <sys/socket.h>
14  #include <netinet/in.h>
15  #include <errno.h>
16  #include <unistd.h>
17  #endif
18  #include "resolv.h"
19  #include "utils.h"
20  #include "netutils.h"
21  struct ResolvQuery {
22      void (*client_cb)(struct sockaddr *, void *);
23      void (*client_free_cb)(void *);
24      void *client_cb_data;
25      struct dns_query *queries[2];
26      size_t response_count;
27      struct sockaddr **responses;
28      uint16_t port;
29  };
30  extern int verbose;
31  static struct ev_io resolv_io_watcher;
32  static struct ev_timer resolv_timeout_watcher;
33  static const int MODE_IPV4_ONLY  = 0;
34  static const int MODE_IPV6_ONLY  = 1;
35  static const int MODE_IPV4_FIRST = 2;
36  static const int MODE_IPV6_FIRST = 3;
37  static int resolv_mode           = 0;
<span onclick='openModal()' class='match'>38  static void resolv_sock_cb(struct ev_loop *, struct ev_io *, int);
39  static void resolv_timeout_cb(struct ev_loop *, struct ev_timer *, int);
40  static void dns_query_v4_cb(struct dns_ctx *, struct dns_rr_a4 *, void *);
41  static void dns_query_v6_cb(struct dns_ctx *, struct dns_rr_a6 *, void *);
42  static void dns_timer_setup_cb(struct dns_ctx *, int, void *);
43  static void process_client_callback(struct ResolvQuery *);
44  static inline int all_queries_are_null(struct ResolvQuery *);
45  static struct sockaddr *choose_ipv4_first(struct ResolvQuery *);
46  static struct sockaddr *choose_ipv6_first(struct ResolvQuery *);
47  static struct sockaddr *choose_any(struct ResolvQuery *);
</span>48  int
49  resolv_init(struct ev_loop *loop, char **nameservers, int nameserver_num, int ipv6first)
50  {
51      if (ipv6first)
52          resolv_mode = MODE_IPV6_FIRST;
53      else
54          resolv_mode = MODE_IPV4_FIRST;
55      struct dns_ctx *ctx = &dns_defctx;
56      if (nameservers == NULL) {
57          dns_init(ctx, 0);
58      } else {
59          dns_reset(ctx);
60          for (int i = 0; i < nameserver_num; i++) {
61              char *server = nameservers[i];
62              dns_add_serv(ctx, server);
63          }
64      }
65      int sockfd = dns_open(ctx);
66      if (sockfd < 0) {
67          FATAL("Failed to open DNS resolver socket");
68      }
69      if (nameserver_num == 1 && nameservers != NULL) {
70          if (strncmp("127.0.0.1", nameservers[0], 9) == 0
71              || strncmp("::1", nameservers[0], 3) == 0) {
72              if (verbose) {
73                  LOGI("bind UDP resolver to %s", nameservers[0]);
74              }
75              if (bind_to_address(sockfd, nameservers[0]) == -1)
76                  ERROR("bind_to_address");
77          }
78      }
79  #ifdef __MINGW32__
80      setnonblocking(sockfd);
81  #else
82      int flags = fcntl(sockfd, F_GETFL, 0);
83      fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
84  #endif
85      ev_io_init(&resolv_io_watcher, resolv_sock_cb, sockfd, EV_READ);
86      resolv_io_watcher.data = ctx;
87      ev_io_start(loop, &resolv_io_watcher);
88      ev_timer_init(&resolv_timeout_watcher, resolv_timeout_cb, 0.0, 0.0);
89      resolv_timeout_watcher.data = ctx;
90      dns_set_tmcbck(ctx, dns_timer_setup_cb, loop);
91      return sockfd;
92  }
93  void
94  resolv_shutdown(struct ev_loop *loop)
95  {
96      struct dns_ctx *ctx = (struct dns_ctx *)resolv_io_watcher.data;
97      ev_io_stop(loop, &resolv_io_watcher);
98      if (ev_is_active(&resolv_timeout_watcher)) {
99          ev_timer_stop(loop, &resolv_timeout_watcher);
100      }
101      dns_close(ctx);
102  }
103  struct ResolvQuery *
104  resolv_query(const char *hostname, void (*client_cb)(struct sockaddr *, void *),
105               void (*client_free_cb)(void *), void *client_cb_data,
106               uint16_t port)
107  {
108      struct dns_ctx *ctx = (struct dns_ctx *)resolv_io_watcher.data;
109      struct ResolvQuery *cb_data = ss_malloc(sizeof(struct ResolvQuery));
110      if (cb_data == NULL) {
111          LOGE("Failed to allocate memory for DNS query callback data.");
112          return NULL;
113      }
114      memset(cb_data, 0, sizeof(struct ResolvQuery));
115      cb_data->client_cb      = client_cb;
116      cb_data->client_free_cb = client_free_cb;
117      cb_data->client_cb_data = client_cb_data;
118      memset(cb_data->queries, 0, sizeof(cb_data->queries));
119      cb_data->response_count = 0;
120      cb_data->responses      = NULL;
121      cb_data->port           = port;
122      if (resolv_mode != MODE_IPV6_ONLY) {
123          cb_data->queries[0] = dns_submit_a4(ctx,
124                                              hostname, 0,
125                                              dns_query_v4_cb, cb_data);
126          if (cb_data->queries[0] == NULL) {
127              LOGE("Failed to submit DNS query: %s",
128                   dns_strerror(dns_status(ctx)));
129          }
130      }
131      if (resolv_mode != MODE_IPV4_ONLY) {
132          cb_data->queries[1] = dns_submit_a6(ctx,
133                                              hostname, 0,
134                                              dns_query_v6_cb, cb_data);
135          if (cb_data->queries[1] == NULL) {
136              LOGE("Failed to submit DNS query: %s",
137                   dns_strerror(dns_status(ctx)));
138          }
139      }
140      if (all_queries_are_null(cb_data)) {
141          if (cb_data->client_free_cb != NULL) {
142              cb_data->client_free_cb(cb_data->client_cb_data);
143          }
144          ss_free(cb_data);
145      }
146      return cb_data;
147  }
148  void
149  resolv_cancel(struct ResolvQuery *query_handle)
150  {
151      struct ResolvQuery *cb_data = (struct ResolvQuery *)query_handle;
152      struct dns_ctx *ctx         = (struct dns_ctx *)resolv_io_watcher.data;
153      for (int i = 0; i < sizeof(cb_data->queries) / sizeof(cb_data->queries[0]);
154           i++)
155          if (cb_data->queries[i] != NULL) {
156              dns_cancel(ctx, cb_data->queries[i]);
157              ss_free(cb_data->queries[i]);
158          }
159      if (cb_data->client_free_cb != NULL) {
160          cb_data->client_free_cb(cb_data->client_cb_data);
161      }
162      ss_free(cb_data);
163  }
164  static void
165  resolv_sock_cb(struct ev_loop *loop, struct ev_io *w, int revents)
166  {
167      struct dns_ctx *ctx = (struct dns_ctx *)w->data;
168      if (revents & EV_READ) {
169          dns_ioevent(ctx, ev_now(loop));
170      }
171  }
172  static void
173  dns_query_v4_cb(struct dns_ctx *ctx, struct dns_rr_a4 *result, void *data)
174  {
175      struct ResolvQuery *cb_data = (struct ResolvQuery *)data;
176      if (result == NULL) {
177          if (verbose) {
178              LOGI("IPv4 resolv: %s", dns_strerror(dns_status(ctx)));
179          }
180      } else if (result->dnsa4_nrr > 0) {
181          struct sockaddr **new_responses = ss_realloc(cb_data->responses,
182                                                       (cb_data->response_count +
183                                                        result->dnsa4_nrr) *
184                                                       sizeof(struct sockaddr *));
185          if (new_responses == NULL) {
186              LOGE("Failed to allocate memory for additional DNS responses");
187          } else {
188              cb_data->responses = new_responses;
189              for (int i = 0; i < result->dnsa4_nrr; i++) {
190                  struct sockaddr_in *sa =
191                      (struct sockaddr_in *)ss_malloc(sizeof(struct sockaddr_in));
192                  sa->sin_family = AF_INET;
193                  sa->sin_port   = cb_data->port;
194                  sa->sin_addr   = result->dnsa4_addr[i];
195                  cb_data->responses[cb_data->response_count] =
196                      (struct sockaddr *)sa;
197                  if (cb_data->responses[cb_data->response_count] == NULL) {
198                      LOGE(
199                          "Failed to allocate memory for DNS query result address");
200                  } else {
201                      cb_data->response_count++;
202                  }
203              }
204          }
205      }
206      ss_free(result);
207      cb_data->queries[0] = NULL; &bsol;* mark A query as being completed */
208      if (all_queries_are_null(cb_data)) {
209          return process_client_callback(cb_data);
210      }
211  }
212  static void
213  dns_query_v6_cb(struct dns_ctx *ctx, struct dns_rr_a6 *result, void *data)
214  {
215      struct ResolvQuery *cb_data = (struct ResolvQuery *)data;
216      if (result == NULL) {
217          if (verbose) {
218              LOGI("IPv6 resolv: %s", dns_strerror(dns_status(ctx)));
219          }
220      } else if (result->dnsa6_nrr > 0) {
221          struct sockaddr **new_responses = ss_realloc(cb_data->responses,
222                                                       (cb_data->response_count +
223                                                        result->dnsa6_nrr) *
224                                                       sizeof(struct sockaddr *));
225          if (new_responses == NULL) {
226              LOGE("Failed to allocate memory for additional DNS responses");
227          } else {
228              cb_data->responses = new_responses;
229              for (int i = 0; i < result->dnsa6_nrr; i++) {
230                  struct sockaddr_in6 *sa =
231                      (struct sockaddr_in6 *)ss_malloc(sizeof(struct sockaddr_in6));
232                  sa->sin6_family = AF_INET6;
233                  sa->sin6_port   = cb_data->port;
234                  sa->sin6_addr   = result->dnsa6_addr[i];
235                  cb_data->responses[cb_data->response_count] =
236                      (struct sockaddr *)sa;
237                  if (cb_data->responses[cb_data->response_count] == NULL) {
238                      LOGE(
239                          "Failed to allocate memory for DNS query result address");
240                  } else {
241                      cb_data->response_count++;
242                  }
243              }
244          }
245      }
246      ss_free(result);
247      cb_data->queries[1] = NULL; &bsol;* mark AAAA query as being completed */
248      if (all_queries_are_null(cb_data)) {
249          return process_client_callback(cb_data);
250      }
251  }
252  static void
253  process_client_callback(struct ResolvQuery *cb_data)
254  {
255      struct sockaddr *best_address = NULL;
256      if (resolv_mode == MODE_IPV4_FIRST) {
257          best_address = choose_ipv4_first(cb_data);
258      } else if (resolv_mode == MODE_IPV6_FIRST) {
259          best_address = choose_ipv6_first(cb_data);
260      } else {
261          best_address = choose_any(cb_data);
262      }
263      cb_data->client_cb(best_address, cb_data->client_cb_data);
264      for (int i = 0; i < cb_data->response_count; i++)
265          ss_free(cb_data->responses[i]);
266      ss_free(cb_data->responses);
267      if (cb_data->client_free_cb != NULL) {
268          cb_data->client_free_cb(cb_data->client_cb_data);
269      }
270      ss_free(cb_data);
271  }
272  static struct sockaddr *
273  choose_ipv4_first(struct ResolvQuery *cb_data)
274  {
275      for (int i = 0; i < cb_data->response_count; i++)
276          if (cb_data->responses[i]->sa_family == AF_INET) {
277              return cb_data->responses[i];
278          }
279      return choose_any(cb_data);
280  }
281  static struct sockaddr *
282  choose_ipv6_first(struct ResolvQuery *cb_data)
283  {
284      for (int i = 0; i < cb_data->response_count; i++)
285          if (cb_data->responses[i]->sa_family == AF_INET6) {
286              return cb_data->responses[i];
287          }
288      return choose_any(cb_data);
289  }
290  static struct sockaddr *
291  choose_any(struct ResolvQuery *cb_data)
292  {
293      if (cb_data->response_count >= 1) {
294          return cb_data->responses[0];
295      }
296      return NULL;
297  }
298  static void
299  resolv_timeout_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
300  {
301      struct dns_ctx *ctx = (struct dns_ctx *)w->data;
302      if (revents & EV_TIMER) {
303          dns_timeouts(ctx, 30, ev_now(loop));
304      }
305  }
306  static void
307  dns_timer_setup_cb(struct dns_ctx *ctx, int timeout, void *data)
308  {
309      struct ev_loop *loop = (struct ev_loop *)data;
310      if (ev_is_active(&resolv_timeout_watcher)) {
311          ev_timer_stop(loop, &resolv_timeout_watcher);
312      }
313      if (ctx != NULL && timeout >= 0) {
314          ev_timer_set(&resolv_timeout_watcher, timeout, 0.0);
315          ev_timer_start(loop, &resolv_timeout_watcher);
316      }
317  }
318  static inline int
319  all_queries_are_null(struct ResolvQuery *cb_data)
320  {
321      int result = 1;
322      for (int i = 0; i < sizeof(cb_data->queries) / sizeof(cb_data->queries[0]);
323           i++)
324          result = result && cb_data->queries[i] == NULL;
325      return result;
326  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-pf.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-resolv.c</div>
                </div>
                <div class="column column_space"><pre><code>37  	int	filtering_in_kernel; &bsol;* using kernel filter */
38  	u_long	TotPkts;	&bsol;* can't oflow for 79 hrs on ether */
39  	u_long	TotAccepted;	&bsol;* count accepted by filter */
40  	u_long	TotDrops;	&bsol;* count of dropped packets */
41  	long	TotMissed;	&bsol;* missed by i/f during this run */
42  	long	OrigMissed;	&bsol;* missed by i/f before this run */
</pre></code></div>
                <div class="column column_space"><pre><code>38  static void resolv_sock_cb(struct ev_loop *, struct ev_io *, int);
39  static void resolv_timeout_cb(struct ev_loop *, struct ev_timer *, int);
40  static void dns_query_v4_cb(struct dns_ctx *, struct dns_rr_a4 *, void *);
41  static void dns_query_v6_cb(struct dns_ctx *, struct dns_rr_a6 *, void *);
42  static void dns_timer_setup_cb(struct dns_ctx *, int, void *);
43  static void process_client_callback(struct ResolvQuery *);
44  static inline int all_queries_are_null(struct ResolvQuery *);
45  static struct sockaddr *choose_ipv4_first(struct ResolvQuery *);
46  static struct sockaddr *choose_ipv6_first(struct ResolvQuery *);
47  static struct sockaddr *choose_any(struct ResolvQuery *);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    