
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 37.45928338762215%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-cl_13.h</h3>
            <pre><code>1  #ifndef __OPENCL_CL_H
2  #define __OPENCL_CL_H
3  #include <CL/cl_version.h>
4  #include <CL/cl_platform.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  typedef struct _cl_platform_id *    cl_platform_id;
9  typedef struct _cl_device_id *      cl_device_id;
10  typedef struct _cl_context *        cl_context;
11  typedef struct _cl_command_queue *  cl_command_queue;
12  typedef struct _cl_mem *            cl_mem;
13  typedef struct _cl_program *        cl_program;
14  typedef struct _cl_kernel *         cl_kernel;
15  typedef struct _cl_event *          cl_event;
16  typedef struct _cl_sampler *        cl_sampler;
17  typedef cl_uint             cl_bool;                     &bsol;* WARNING!  Unlike cl_ types in cl_platform.h, cl_bool is not guaranteed to be the same size as the bool in kernels. */
18  typedef cl_ulong            cl_bitfield;
19  typedef cl_bitfield         cl_device_type;
20  typedef cl_uint             cl_platform_info;
21  typedef cl_uint             cl_device_info;
22  typedef cl_bitfield         cl_device_fp_config;
23  typedef cl_uint             cl_device_mem_cache_type;
24  typedef cl_uint             cl_device_local_mem_type;
25  typedef cl_bitfield         cl_device_exec_capabilities;
26  #ifdef CL_VERSION_2_0
27  typedef cl_bitfield         cl_device_svm_capabilities;
28  #endif
29  typedef cl_bitfield         cl_command_queue_properties;
30  #ifdef CL_VERSION_1_2
31  typedef intptr_t            cl_device_partition_property;
32  typedef cl_bitfield         cl_device_affinity_domain;
33  #endif
34  typedef intptr_t            cl_context_properties;
35  typedef cl_uint             cl_context_info;
36  #ifdef CL_VERSION_2_0
37  typedef cl_bitfield         cl_queue_properties;
38  #endif
39  typedef cl_uint             cl_command_queue_info;
40  typedef cl_uint             cl_channel_order;
41  typedef cl_uint             cl_channel_type;
42  typedef cl_bitfield         cl_mem_flags;
43  #ifdef CL_VERSION_2_0
44  typedef cl_bitfield         cl_svm_mem_flags;
45  #endif
46  typedef cl_uint             cl_mem_object_type;
47  typedef cl_uint             cl_mem_info;
48  #ifdef CL_VERSION_1_2
49  typedef cl_bitfield         cl_mem_migration_flags;
50  #endif
51  typedef cl_uint             cl_image_info;
52  #ifdef CL_VERSION_1_1
53  typedef cl_uint             cl_buffer_create_type;
54  #endif
55  typedef cl_uint             cl_addressing_mode;
56  typedef cl_uint             cl_filter_mode;
57  typedef cl_uint             cl_sampler_info;
58  typedef cl_bitfield         cl_map_flags;
59  #ifdef CL_VERSION_2_0
60  typedef intptr_t            cl_pipe_properties;
61  typedef cl_uint             cl_pipe_info;
62  #endif
63  typedef cl_uint             cl_program_info;
64  typedef cl_uint             cl_program_build_info;
65  #ifdef CL_VERSION_1_2
66  typedef cl_uint             cl_program_binary_type;
67  #endif
68  typedef cl_int              cl_build_status;
69  typedef cl_uint             cl_kernel_info;
70  #ifdef CL_VERSION_1_2
71  typedef cl_uint             cl_kernel_arg_info;
72  typedef cl_uint             cl_kernel_arg_address_qualifier;
73  typedef cl_uint             cl_kernel_arg_access_qualifier;
74  typedef cl_bitfield         cl_kernel_arg_type_qualifier;
75  #endif
76  typedef cl_uint             cl_kernel_work_group_info;
77  #ifdef CL_VERSION_2_1
78  typedef cl_uint             cl_kernel_sub_group_info;
79  #endif
80  typedef cl_uint             cl_event_info;
81  typedef cl_uint             cl_command_type;
82  typedef cl_uint             cl_profiling_info;
83  #ifdef CL_VERSION_2_0
84  typedef cl_bitfield         cl_sampler_properties;
85  typedef cl_uint             cl_kernel_exec_info;
86  #endif
87  typedef struct _cl_image_format {
88      cl_channel_order        image_channel_order;
89      cl_channel_type         image_channel_data_type;
90  } cl_image_format;
91  #ifdef CL_VERSION_1_2
92  typedef struct _cl_image_desc {
93      cl_mem_object_type      image_type;
94      size_t                  image_width;
95      size_t                  image_height;
96      size_t                  image_depth;
97      size_t                  image_array_size;
98      size_t                  image_row_pitch;
99      size_t                  image_slice_pitch;
100      cl_uint                 num_mip_levels;
101      cl_uint                 num_samples;
102  #ifdef CL_VERSION_2_0
103  #ifdef __GNUC__
104      __extension__   &bsol;* Prevents warnings about anonymous union in -pedantic builds */
105  #endif
106  #ifdef _MSC_VER
107  #pragma warning( push )
108  #pragma warning( disable : 4201 ) &bsol;* Prevents warning about nameless struct/union in /W4 /Za builds */
109  #endif
110      union {
111  #endif
112        cl_mem                  buffer;
113  #ifdef CL_VERSION_2_0
114        cl_mem                  mem_object;
115      };
116  #ifdef _MSC_VER
117  #pragma warning( pop )
118  #endif
119  #endif
120  } cl_image_desc;
121  #endif
122  #ifdef CL_VERSION_1_1
123  typedef struct _cl_buffer_region {
124      size_t                  origin;
125      size_t                  size;
126  } cl_buffer_region;
127  #endif
128  #define CL_SUCCESS                                  0
129  #define CL_DEVICE_NOT_FOUND                         -1
130  #define CL_DEVICE_NOT_AVAILABLE                     -2
131  #define CL_COMPILER_NOT_AVAILABLE                   -3
132  #define CL_MEM_OBJECT_ALLOCATION_FAILURE            -4
133  #define CL_OUT_OF_RESOURCES                         -5
134  #define CL_OUT_OF_HOST_MEMORY                       -6
135  #define CL_PROFILING_INFO_NOT_AVAILABLE             -7
136  #define CL_MEM_COPY_OVERLAP                         -8
137  #define CL_IMAGE_FORMAT_MISMATCH                    -9
138  #define CL_IMAGE_FORMAT_NOT_SUPPORTED               -10
139  #define CL_BUILD_PROGRAM_FAILURE                    -11
140  #define CL_MAP_FAILURE                              -12
141  #ifdef CL_VERSION_1_1
142  #define CL_MISALIGNED_SUB_BUFFER_OFFSET             -13
143  #define CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST -14
144  #endif
145  #ifdef CL_VERSION_1_2
146  #define CL_COMPILE_PROGRAM_FAILURE                  -15
147  #define CL_LINKER_NOT_AVAILABLE                     -16
148  #define CL_LINK_PROGRAM_FAILURE                     -17
149  #define CL_DEVICE_PARTITION_FAILED                  -18
150  #define CL_KERNEL_ARG_INFO_NOT_AVAILABLE            -19
151  #endif
152  #define CL_INVALID_VALUE                            -30
153  #define CL_INVALID_DEVICE_TYPE                      -31
154  #define CL_INVALID_PLATFORM                         -32
155  #define CL_INVALID_DEVICE                           -33
156  #define CL_INVALID_CONTEXT                          -34
157  #define CL_INVALID_QUEUE_PROPERTIES                 -35
158  #define CL_INVALID_COMMAND_QUEUE                    -36
159  #define CL_INVALID_HOST_PTR                         -37
160  #define CL_INVALID_MEM_OBJECT                       -38
161  #define CL_INVALID_IMAGE_FORMAT_DESCRIPTOR          -39
162  #define CL_INVALID_IMAGE_SIZE                       -40
163  #define CL_INVALID_SAMPLER                          -41
164  #define CL_INVALID_BINARY                           -42
165  #define CL_INVALID_BUILD_OPTIONS                    -43
166  #define CL_INVALID_PROGRAM                          -44
167  #define CL_INVALID_PROGRAM_EXECUTABLE               -45
168  #define CL_INVALID_KERNEL_NAME                      -46
169  #define CL_INVALID_KERNEL_DEFINITION                -47
170  #define CL_INVALID_KERNEL                           -48
171  #define CL_INVALID_ARG_INDEX                        -49
172  #define CL_INVALID_ARG_VALUE                        -50
173  #define CL_INVALID_ARG_SIZE                         -51
174  #define CL_INVALID_KERNEL_ARGS                      -52
175  #define CL_INVALID_WORK_DIMENSION                   -53
176  #define CL_INVALID_WORK_GROUP_SIZE                  -54
177  #define CL_INVALID_WORK_ITEM_SIZE                   -55
178  #define CL_INVALID_GLOBAL_OFFSET                    -56
179  #define CL_INVALID_EVENT_WAIT_LIST                  -57
180  #define CL_INVALID_EVENT                            -58
181  #define CL_INVALID_OPERATION                        -59
182  #define CL_INVALID_GL_OBJECT                        -60
183  #define CL_INVALID_BUFFER_SIZE                      -61
184  #define CL_INVALID_MIP_LEVEL                        -62
185  #define CL_INVALID_GLOBAL_WORK_SIZE                 -63
186  #ifdef CL_VERSION_1_1
187  #define CL_INVALID_PROPERTY                         -64
188  #endif
189  #ifdef CL_VERSION_1_2
190  #define CL_INVALID_IMAGE_DESCRIPTOR                 -65
191  #define CL_INVALID_COMPILER_OPTIONS                 -66
192  #define CL_INVALID_LINKER_OPTIONS                   -67
193  #define CL_INVALID_DEVICE_PARTITION_COUNT           -68
194  #endif
195  #ifdef CL_VERSION_2_0
196  #define CL_INVALID_PIPE_SIZE                        -69
197  #define CL_INVALID_DEVICE_QUEUE                     -70
198  #endif
199  #ifdef CL_VERSION_2_2
200  #define CL_INVALID_SPEC_ID                          -71
201  #define CL_MAX_SIZE_RESTRICTION_EXCEEDED            -72
202  #endif
203  #define CL_FALSE                                    0
204  #define CL_TRUE                                     1
205  #ifdef CL_VERSION_1_2
206  #define CL_BLOCKING                                 CL_TRUE
207  #define CL_NON_BLOCKING                             CL_FALSE
208  #endif
209  #define CL_PLATFORM_PROFILE                         0x0900
210  #define CL_PLATFORM_VERSION                         0x0901
211  #define CL_PLATFORM_NAME                            0x0902
212  #define CL_PLATFORM_VENDOR                          0x0903
213  #define CL_PLATFORM_EXTENSIONS                      0x0904
214  #ifdef CL_VERSION_2_1
215  #define CL_PLATFORM_HOST_TIMER_RESOLUTION           0x0905
216  #endif
217  #define CL_DEVICE_TYPE_DEFAULT                      (1 << 0)
218  #define CL_DEVICE_TYPE_CPU                          (1 << 1)
219  #define CL_DEVICE_TYPE_GPU                          (1 << 2)
220  #define CL_DEVICE_TYPE_ACCELERATOR                  (1 << 3)
221  #ifdef CL_VERSION_1_2
222  #define CL_DEVICE_TYPE_CUSTOM                       (1 << 4)
223  #endif
224  #define CL_DEVICE_TYPE_ALL                          0xFFFFFFFF
225  #define CL_DEVICE_TYPE                                   0x1000
226  #define CL_DEVICE_VENDOR_ID                              0x1001
227  #define CL_DEVICE_MAX_COMPUTE_UNITS                      0x1002
228  #define CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS               0x1003
229  #define CL_DEVICE_MAX_WORK_GROUP_SIZE                    0x1004
230  #define CL_DEVICE_MAX_WORK_ITEM_SIZES                    0x1005
231  #define CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR            0x1006
232  #define CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT           0x1007
233  #define CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT             0x1008
234  #define CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG            0x1009
235  #define CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT           0x100A
236  #define CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE          0x100B
237  #define CL_DEVICE_MAX_CLOCK_FREQUENCY                    0x100C
238  #define CL_DEVICE_ADDRESS_BITS                           0x100D
239  #define CL_DEVICE_MAX_READ_IMAGE_ARGS                    0x100E
240  #define CL_DEVICE_MAX_WRITE_IMAGE_ARGS                   0x100F
241  #define CL_DEVICE_MAX_MEM_ALLOC_SIZE                     0x1010
242  #define CL_DEVICE_IMAGE2D_MAX_WIDTH                      0x1011
243  #define CL_DEVICE_IMAGE2D_MAX_HEIGHT                     0x1012
244  #define CL_DEVICE_IMAGE3D_MAX_WIDTH                      0x1013
245  #define CL_DEVICE_IMAGE3D_MAX_HEIGHT                     0x1014
246  #define CL_DEVICE_IMAGE3D_MAX_DEPTH                      0x1015
247  #define CL_DEVICE_IMAGE_SUPPORT                          0x1016
248  #define CL_DEVICE_MAX_PARAMETER_SIZE                     0x1017
249  #define CL_DEVICE_MAX_SAMPLERS                           0x1018
250  #define CL_DEVICE_MEM_BASE_ADDR_ALIGN                    0x1019
251  #define CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE               0x101A
252  #define CL_DEVICE_SINGLE_FP_CONFIG                       0x101B
253  #define CL_DEVICE_GLOBAL_MEM_CACHE_TYPE                  0x101C
254  #define CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE              0x101D
255  #define CL_DEVICE_GLOBAL_MEM_CACHE_SIZE                  0x101E
256  #define CL_DEVICE_GLOBAL_MEM_SIZE                        0x101F
257  #define CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE               0x1020
258  #define CL_DEVICE_MAX_CONSTANT_ARGS                      0x1021
259  #define CL_DEVICE_LOCAL_MEM_TYPE                         0x1022
260  #define CL_DEVICE_LOCAL_MEM_SIZE                         0x1023
261  #define CL_DEVICE_ERROR_CORRECTION_SUPPORT               0x1024
262  #define CL_DEVICE_PROFILING_TIMER_RESOLUTION             0x1025
263  #define CL_DEVICE_ENDIAN_LITTLE                          0x1026
264  #define CL_DEVICE_AVAILABLE                              0x1027
265  #define CL_DEVICE_COMPILER_AVAILABLE                     0x1028
266  #define CL_DEVICE_EXECUTION_CAPABILITIES                 0x1029
267  #define CL_DEVICE_QUEUE_PROPERTIES                       0x102A    &bsol;* deprecated */
268  #ifdef CL_VERSION_2_0
269  #define CL_DEVICE_QUEUE_ON_HOST_PROPERTIES               0x102A
270  #endif
271  #define CL_DEVICE_NAME                                   0x102B
272  #define CL_DEVICE_VENDOR                                 0x102C
273  #define CL_DRIVER_VERSION                                0x102D
274  #define CL_DEVICE_PROFILE                                0x102E
275  #define CL_DEVICE_VERSION                                0x102F
276  #define CL_DEVICE_EXTENSIONS                             0x1030
277  #define CL_DEVICE_PLATFORM                               0x1031
278  #ifdef CL_VERSION_1_2
279  #define CL_DEVICE_DOUBLE_FP_CONFIG                       0x1032
280  #endif
281  #ifdef CL_VERSION_1_1
282  #define CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF            0x1034
283  #define CL_DEVICE_HOST_UNIFIED_MEMORY                    0x1035   &bsol;* deprecated */
284  #define CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR               0x1036
285  #define CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT              0x1037
286  #define CL_DEVICE_NATIVE_VECTOR_WIDTH_INT                0x1038
287  #define CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG               0x1039
288  #define CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT              0x103A
289  #define CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE             0x103B
290  #define CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF               0x103C
291  #define CL_DEVICE_OPENCL_C_VERSION                       0x103D
292  #endif
293  #ifdef CL_VERSION_1_2
294  #define CL_DEVICE_LINKER_AVAILABLE                       0x103E
295  #define CL_DEVICE_BUILT_IN_KERNELS                       0x103F
296  #define CL_DEVICE_IMAGE_MAX_BUFFER_SIZE                  0x1040
297  #define CL_DEVICE_IMAGE_MAX_ARRAY_SIZE                   0x1041
298  #define CL_DEVICE_PARENT_DEVICE                          0x1042
299  #define CL_DEVICE_PARTITION_MAX_SUB_DEVICES              0x1043
300  #define CL_DEVICE_PARTITION_PROPERTIES                   0x1044
301  #define CL_DEVICE_PARTITION_AFFINITY_DOMAIN              0x1045
302  #define CL_DEVICE_PARTITION_TYPE                         0x1046
303  #define CL_DEVICE_REFERENCE_COUNT                        0x1047
304  #define CL_DEVICE_PREFERRED_INTEROP_USER_SYNC            0x1048
305  #define CL_DEVICE_PRINTF_BUFFER_SIZE                     0x1049
306  #endif
307  #ifdef CL_VERSION_2_0
308  #define CL_DEVICE_IMAGE_PITCH_ALIGNMENT                  0x104A
309  #define CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT           0x104B
310  #define CL_DEVICE_MAX_READ_WRITE_IMAGE_ARGS              0x104C
311  #define CL_DEVICE_MAX_GLOBAL_VARIABLE_SIZE               0x104D
312  #define CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES             0x104E
313  #define CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE         0x104F
314  #define CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE               0x1050
315  #define CL_DEVICE_MAX_ON_DEVICE_QUEUES                   0x1051
316  #define CL_DEVICE_MAX_ON_DEVICE_EVENTS                   0x1052
317  #define CL_DEVICE_SVM_CAPABILITIES                       0x1053
318  #define CL_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE   0x1054
319  #define CL_DEVICE_MAX_PIPE_ARGS                          0x1055
320  #define CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS           0x1056
321  #define CL_DEVICE_PIPE_MAX_PACKET_SIZE                   0x1057
322  #define CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT    0x1058
323  #define CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT      0x1059
324  #define CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT       0x105A
325  #endif
326  #ifdef CL_VERSION_2_1
327  #define CL_DEVICE_IL_VERSION                             0x105B
328  #define CL_DEVICE_MAX_NUM_SUB_GROUPS                     0x105C
329  #define CL_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS 0x105D
330  #endif
331  #define CL_FP_DENORM                                (1 << 0)
332  #define CL_FP_INF_NAN                               (1 << 1)
333  #define CL_FP_ROUND_TO_NEAREST                      (1 << 2)
334  #define CL_FP_ROUND_TO_ZERO                         (1 << 3)
335  #define CL_FP_ROUND_TO_INF                          (1 << 4)
336  #define CL_FP_FMA                                   (1 << 5)
337  #ifdef CL_VERSION_1_1
338  #define CL_FP_SOFT_FLOAT                            (1 << 6)
339  #endif
340  #ifdef CL_VERSION_1_2
341  #define CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT         (1 << 7)
342  #endif
343  #define CL_NONE                                     0x0
344  #define CL_READ_ONLY_CACHE                          0x1
345  #define CL_READ_WRITE_CACHE                         0x2
346  #define CL_LOCAL                                    0x1
347  #define CL_GLOBAL                                   0x2
348  #define CL_EXEC_KERNEL                              (1 << 0)
349  #define CL_EXEC_NATIVE_KERNEL                       (1 << 1)
350  #define CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE      (1 << 0)
351  #define CL_QUEUE_PROFILING_ENABLE                   (1 << 1)
352  #ifdef CL_VERSION_2_0
353  #define CL_QUEUE_ON_DEVICE                          (1 << 2)
354  #define CL_QUEUE_ON_DEVICE_DEFAULT                  (1 << 3)
355  #endif
356  #define CL_CONTEXT_REFERENCE_COUNT                  0x1080
357  #define CL_CONTEXT_DEVICES                          0x1081
358  #define CL_CONTEXT_PROPERTIES                       0x1082
359  #ifdef CL_VERSION_1_1
360  #define CL_CONTEXT_NUM_DEVICES                      0x1083
361  #endif
362  #define CL_CONTEXT_PLATFORM                         0x1084
363  #ifdef CL_VERSION_1_2
364  #define CL_CONTEXT_INTEROP_USER_SYNC                0x1085
365  #endif
366  #ifdef CL_VERSION_1_2
367  #define CL_DEVICE_PARTITION_EQUALLY                 0x1086
368  #define CL_DEVICE_PARTITION_BY_COUNTS               0x1087
369  #define CL_DEVICE_PARTITION_BY_COUNTS_LIST_END      0x0
370  #define CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN      0x1088
371  #endif
372  #ifdef CL_VERSION_1_2
373  #define CL_DEVICE_AFFINITY_DOMAIN_NUMA               (1 << 0)
374  #define CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE           (1 << 1)
375  #define CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE           (1 << 2)
376  #define CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE           (1 << 3)
377  #define CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE           (1 << 4)
378  #define CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE (1 << 5)
379  #endif
380  #ifdef CL_VERSION_2_0
381  #define CL_DEVICE_SVM_COARSE_GRAIN_BUFFER           (1 << 0)
382  #define CL_DEVICE_SVM_FINE_GRAIN_BUFFER             (1 << 1)
383  #define CL_DEVICE_SVM_FINE_GRAIN_SYSTEM             (1 << 2)
384  #define CL_DEVICE_SVM_ATOMICS                       (1 << 3)
385  #endif
386  #define CL_QUEUE_CONTEXT                            0x1090
387  #define CL_QUEUE_DEVICE                             0x1091
388  #define CL_QUEUE_REFERENCE_COUNT                    0x1092
389  #define CL_QUEUE_PROPERTIES                         0x1093
390  #ifdef CL_VERSION_2_0
391  #define CL_QUEUE_SIZE                               0x1094
392  #endif
393  #ifdef CL_VERSION_2_1
394  #define CL_QUEUE_DEVICE_DEFAULT                     0x1095
395  #endif
396  #define CL_MEM_READ_WRITE                           (1 << 0)
397  #define CL_MEM_WRITE_ONLY                           (1 << 1)
398  #define CL_MEM_READ_ONLY                            (1 << 2)
399  #define CL_MEM_USE_HOST_PTR                         (1 << 3)
400  #define CL_MEM_ALLOC_HOST_PTR                       (1 << 4)
401  #define CL_MEM_COPY_HOST_PTR                        (1 << 5)
402  #ifdef CL_VERSION_1_2
403  #define CL_MEM_HOST_WRITE_ONLY                      (1 << 7)
404  #define CL_MEM_HOST_READ_ONLY                       (1 << 8)
405  #define CL_MEM_HOST_NO_ACCESS                       (1 << 9)
406  #endif
407  #ifdef CL_VERSION_2_0
408  #define CL_MEM_SVM_FINE_GRAIN_BUFFER                (1 << 10)   &bsol;* used by cl_svm_mem_flags only */
409  #define CL_MEM_SVM_ATOMICS                          (1 << 11)   &bsol;* used by cl_svm_mem_flags only */
410  #define CL_MEM_KERNEL_READ_AND_WRITE                (1 << 12)
411  #endif
412  #ifdef CL_VERSION_1_2
413  #define CL_MIGRATE_MEM_OBJECT_HOST                  (1 << 0)
414  #define CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED     (1 << 1)
415  #endif
416  #define CL_R                                        0x10B0
417  #define CL_A                                        0x10B1
418  #define CL_RG                                       0x10B2
419  #define CL_RA                                       0x10B3
420  #define CL_RGB                                      0x10B4
421  #define CL_RGBA                                     0x10B5
422  #define CL_BGRA                                     0x10B6
423  #define CL_ARGB                                     0x10B7
424  #define CL_INTENSITY                                0x10B8
425  #define CL_LUMINANCE                                0x10B9
426  #ifdef CL_VERSION_1_1
427  #define CL_Rx                                       0x10BA
428  #define CL_RGx                                      0x10BB
429  #define CL_RGBx                                     0x10BC
430  #endif
431  #ifdef CL_VERSION_1_2
432  #define CL_DEPTH                                    0x10BD
433  #define CL_DEPTH_STENCIL                            0x10BE
434  #endif
435  #ifdef CL_VERSION_2_0
436  #define CL_sRGB                                     0x10BF
437  #define CL_sRGBx                                    0x10C0
438  #define CL_sRGBA                                    0x10C1
439  #define CL_sBGRA                                    0x10C2
440  #define CL_ABGR                                     0x10C3
441  #endif
442  #define CL_SNORM_INT8                               0x10D0
443  #define CL_SNORM_INT16                              0x10D1
444  #define CL_UNORM_INT8                               0x10D2
445  #define CL_UNORM_INT16                              0x10D3
446  #define CL_UNORM_SHORT_565                          0x10D4
447  #define CL_UNORM_SHORT_555                          0x10D5
448  #define CL_UNORM_INT_101010                         0x10D6
449  #define CL_SIGNED_INT8                              0x10D7
450  #define CL_SIGNED_INT16                             0x10D8
451  #define CL_SIGNED_INT32                             0x10D9
452  #define CL_UNSIGNED_INT8                            0x10DA
453  #define CL_UNSIGNED_INT16                           0x10DB
454  #define CL_UNSIGNED_INT32                           0x10DC
455  #define CL_HALF_FLOAT                               0x10DD
456  #define CL_FLOAT                                    0x10DE
457  #ifdef CL_VERSION_1_2
458  #define CL_UNORM_INT24                              0x10DF
459  #endif
460  #ifdef CL_VERSION_2_1
461  #define CL_UNORM_INT_101010_2                       0x10E0
462  #endif
463  #define CL_MEM_OBJECT_BUFFER                        0x10F0
464  #define CL_MEM_OBJECT_IMAGE2D                       0x10F1
465  #define CL_MEM_OBJECT_IMAGE3D                       0x10F2
466  #ifdef CL_VERSION_1_2
467  #define CL_MEM_OBJECT_IMAGE2D_ARRAY                 0x10F3
468  #define CL_MEM_OBJECT_IMAGE1D                       0x10F4
469  #define CL_MEM_OBJECT_IMAGE1D_ARRAY                 0x10F5
470  #define CL_MEM_OBJECT_IMAGE1D_BUFFER                0x10F6
471  #endif
472  #ifdef CL_VERSION_2_0
473  #define CL_MEM_OBJECT_PIPE                          0x10F7
474  #endif
475  #define CL_MEM_TYPE                                 0x1100
476  #define CL_MEM_FLAGS                                0x1101
477  #define CL_MEM_SIZE                                 0x1102
478  #define CL_MEM_HOST_PTR                             0x1103
479  #define CL_MEM_MAP_COUNT                            0x1104
480  #define CL_MEM_REFERENCE_COUNT                      0x1105
481  #define CL_MEM_CONTEXT                              0x1106
482  #ifdef CL_VERSION_1_1
483  #define CL_MEM_ASSOCIATED_MEMOBJECT                 0x1107
484  #define CL_MEM_OFFSET                               0x1108
485  #endif
486  #ifdef CL_VERSION_2_0
487  #define CL_MEM_USES_SVM_POINTER                     0x1109
488  #endif
489  #define CL_IMAGE_FORMAT                             0x1110
490  #define CL_IMAGE_ELEMENT_SIZE                       0x1111
491  #define CL_IMAGE_ROW_PITCH                          0x1112
492  #define CL_IMAGE_SLICE_PITCH                        0x1113
493  #define CL_IMAGE_WIDTH                              0x1114
494  #define CL_IMAGE_HEIGHT                             0x1115
495  #define CL_IMAGE_DEPTH                              0x1116
496  #ifdef CL_VERSION_1_2
497  #define CL_IMAGE_ARRAY_SIZE                         0x1117
498  #define CL_IMAGE_BUFFER                             0x1118
499  #define CL_IMAGE_NUM_MIP_LEVELS                     0x1119
500  #define CL_IMAGE_NUM_SAMPLES                        0x111A
501  #endif
502  #ifdef CL_VERSION_2_0
503  #define CL_PIPE_PACKET_SIZE                         0x1120
504  #define CL_PIPE_MAX_PACKETS                         0x1121
505  #endif
506  #define CL_ADDRESS_NONE                             0x1130
507  #define CL_ADDRESS_CLAMP_TO_EDGE                    0x1131
508  #define CL_ADDRESS_CLAMP                            0x1132
509  #define CL_ADDRESS_REPEAT                           0x1133
510  #ifdef CL_VERSION_1_1
511  #define CL_ADDRESS_MIRRORED_REPEAT                  0x1134
512  #endif
513  #define CL_FILTER_NEAREST                           0x1140
514  #define CL_FILTER_LINEAR                            0x1141
515  #define CL_SAMPLER_REFERENCE_COUNT                  0x1150
516  #define CL_SAMPLER_CONTEXT                          0x1151
517  #define CL_SAMPLER_NORMALIZED_COORDS                0x1152
518  #define CL_SAMPLER_ADDRESSING_MODE                  0x1153
519  #define CL_SAMPLER_FILTER_MODE                      0x1154
520  #ifdef CL_VERSION_2_0
521  #define CL_SAMPLER_MIP_FILTER_MODE                  0x1155
522  #define CL_SAMPLER_LOD_MIN                          0x1156
523  #define CL_SAMPLER_LOD_MAX                          0x1157
524  #endif
525  #define CL_MAP_READ                                 (1 << 0)
526  #define CL_MAP_WRITE                                (1 << 1)
527  #ifdef CL_VERSION_1_2
528  #define CL_MAP_WRITE_INVALIDATE_REGION              (1 << 2)
529  #endif
530  #define CL_PROGRAM_REFERENCE_COUNT                  0x1160
531  #define CL_PROGRAM_CONTEXT                          0x1161
532  #define CL_PROGRAM_NUM_DEVICES                      0x1162
533  #define CL_PROGRAM_DEVICES                          0x1163
534  #define CL_PROGRAM_SOURCE                           0x1164
535  #define CL_PROGRAM_BINARY_SIZES                     0x1165
536  #define CL_PROGRAM_BINARIES                         0x1166
537  #ifdef CL_VERSION_1_2
538  #define CL_PROGRAM_NUM_KERNELS                      0x1167
539  #define CL_PROGRAM_KERNEL_NAMES                     0x1168
540  #endif
541  #ifdef CL_VERSION_2_1
542  #define CL_PROGRAM_IL                               0x1169
543  #endif
544  #ifdef CL_VERSION_2_2
545  #define CL_PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT       0x116A
546  #define CL_PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT       0x116B
547  #endif
548  #define CL_PROGRAM_BUILD_STATUS                     0x1181
549  #define CL_PROGRAM_BUILD_OPTIONS                    0x1182
550  #define CL_PROGRAM_BUILD_LOG                        0x1183
551  #ifdef CL_VERSION_1_2
552  #define CL_PROGRAM_BINARY_TYPE                      0x1184
553  #endif
554  #ifdef CL_VERSION_2_0
555  #define CL_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE 0x1185
556  #endif
557  #ifdef CL_VERSION_1_2
558  #define CL_PROGRAM_BINARY_TYPE_NONE                 0x0
559  #define CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT      0x1
560  #define CL_PROGRAM_BINARY_TYPE_LIBRARY              0x2
561  #define CL_PROGRAM_BINARY_TYPE_EXECUTABLE           0x4
562  #endif
563  #define CL_BUILD_SUCCESS                            0
564  #define CL_BUILD_NONE                               -1
565  #define CL_BUILD_ERROR                              -2
566  #define CL_BUILD_IN_PROGRESS                        -3
567  #define CL_KERNEL_FUNCTION_NAME                     0x1190
568  #define CL_KERNEL_NUM_ARGS                          0x1191
569  #define CL_KERNEL_REFERENCE_COUNT                   0x1192
570  #define CL_KERNEL_CONTEXT                           0x1193
571  #define CL_KERNEL_PROGRAM                           0x1194
572  #ifdef CL_VERSION_1_2
573  #define CL_KERNEL_ATTRIBUTES                        0x1195
574  #endif
575  #ifdef CL_VERSION_2_1
576  #define CL_KERNEL_MAX_NUM_SUB_GROUPS                0x11B9
577  #define CL_KERNEL_COMPILE_NUM_SUB_GROUPS            0x11BA
578  #endif
579  #ifdef CL_VERSION_1_2
580  #define CL_KERNEL_ARG_ADDRESS_QUALIFIER             0x1196
581  #define CL_KERNEL_ARG_ACCESS_QUALIFIER              0x1197
582  #define CL_KERNEL_ARG_TYPE_NAME                     0x1198
583  #define CL_KERNEL_ARG_TYPE_QUALIFIER                0x1199
584  #define CL_KERNEL_ARG_NAME                          0x119A
585  #endif
586  #ifdef CL_VERSION_1_2
587  #define CL_KERNEL_ARG_ADDRESS_GLOBAL                0x119B
588  #define CL_KERNEL_ARG_ADDRESS_LOCAL                 0x119C
589  #define CL_KERNEL_ARG_ADDRESS_CONSTANT              0x119D
590  #define CL_KERNEL_ARG_ADDRESS_PRIVATE               0x119E
591  #endif
592  #ifdef CL_VERSION_1_2
593  #define CL_KERNEL_ARG_ACCESS_READ_ONLY              0x11A0
594  #define CL_KERNEL_ARG_ACCESS_WRITE_ONLY             0x11A1
595  #define CL_KERNEL_ARG_ACCESS_READ_WRITE             0x11A2
596  #define CL_KERNEL_ARG_ACCESS_NONE                   0x11A3
597  #endif
598  #ifdef CL_VERSION_1_2
599  #define CL_KERNEL_ARG_TYPE_NONE                     0
600  #define CL_KERNEL_ARG_TYPE_CONST                    (1 << 0)
601  #define CL_KERNEL_ARG_TYPE_RESTRICT                 (1 << 1)
602  #define CL_KERNEL_ARG_TYPE_VOLATILE                 (1 << 2)
603  #ifdef CL_VERSION_2_0
604  #define CL_KERNEL_ARG_TYPE_PIPE                     (1 << 3)
605  #endif
606  #endif
607  #define CL_KERNEL_WORK_GROUP_SIZE                   0x11B0
608  #define CL_KERNEL_COMPILE_WORK_GROUP_SIZE           0x11B1
609  #define CL_KERNEL_LOCAL_MEM_SIZE                    0x11B2
610  #define CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE 0x11B3
611  #define CL_KERNEL_PRIVATE_MEM_SIZE                  0x11B4
612  #ifdef CL_VERSION_1_2
613  #define CL_KERNEL_GLOBAL_WORK_SIZE                  0x11B5
614  #endif
615  #ifdef CL_VERSION_2_1
616  #define CL_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE    0x2033
617  #define CL_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE       0x2034
618  #define CL_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT    0x11B8
619  #endif
620  #ifdef CL_VERSION_2_0
621  #define CL_KERNEL_EXEC_INFO_SVM_PTRS                0x11B6
622  #define CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM   0x11B7
623  #endif
624  #define CL_EVENT_COMMAND_QUEUE                      0x11D0
625  #define CL_EVENT_COMMAND_TYPE                       0x11D1
626  #define CL_EVENT_REFERENCE_COUNT                    0x11D2
627  #define CL_EVENT_COMMAND_EXECUTION_STATUS           0x11D3
628  #ifdef CL_VERSION_1_1
629  #define CL_EVENT_CONTEXT                            0x11D4
630  #endif
631  #define CL_COMMAND_NDRANGE_KERNEL                   0x11F0
632  #define CL_COMMAND_TASK                             0x11F1
633  #define CL_COMMAND_NATIVE_KERNEL                    0x11F2
634  #define CL_COMMAND_READ_BUFFER                      0x11F3
635  #define CL_COMMAND_WRITE_BUFFER                     0x11F4
636  #define CL_COMMAND_COPY_BUFFER                      0x11F5
637  #define CL_COMMAND_READ_IMAGE                       0x11F6
638  #define CL_COMMAND_WRITE_IMAGE                      0x11F7
639  #define CL_COMMAND_COPY_IMAGE                       0x11F8
640  #define CL_COMMAND_COPY_IMAGE_TO_BUFFER             0x11F9
641  #define CL_COMMAND_COPY_BUFFER_TO_IMAGE             0x11FA
642  #define CL_COMMAND_MAP_BUFFER                       0x11FB
643  #define CL_COMMAND_MAP_IMAGE                        0x11FC
644  #define CL_COMMAND_UNMAP_MEM_OBJECT                 0x11FD
645  #define CL_COMMAND_MARKER                           0x11FE
646  #define CL_COMMAND_ACQUIRE_GL_OBJECTS               0x11FF
647  #define CL_COMMAND_RELEASE_GL_OBJECTS               0x1200
648  #ifdef CL_VERSION_1_1
649  #define CL_COMMAND_READ_BUFFER_RECT                 0x1201
650  #define CL_COMMAND_WRITE_BUFFER_RECT                0x1202
651  #define CL_COMMAND_COPY_BUFFER_RECT                 0x1203
652  #define CL_COMMAND_USER                             0x1204
653  #endif
654  #ifdef CL_VERSION_1_2
655  #define CL_COMMAND_BARRIER                          0x1205
656  #define CL_COMMAND_MIGRATE_MEM_OBJECTS              0x1206
657  #define CL_COMMAND_FILL_BUFFER                      0x1207
658  #define CL_COMMAND_FILL_IMAGE                       0x1208
659  #endif
660  #ifdef CL_VERSION_2_0
661  #define CL_COMMAND_SVM_FREE                         0x1209
662  #define CL_COMMAND_SVM_MEMCPY                       0x120A
663  #define CL_COMMAND_SVM_MEMFILL                      0x120B
664  #define CL_COMMAND_SVM_MAP                          0x120C
665  #define CL_COMMAND_SVM_UNMAP                        0x120D
666  #endif
667  #define CL_COMPLETE                                 0x0
668  #define CL_RUNNING                                  0x1
669  #define CL_SUBMITTED                                0x2
670  #define CL_QUEUED                                   0x3
671  #ifdef CL_VERSION_1_1
672  #define CL_BUFFER_CREATE_TYPE_REGION                0x1220
673  #endif
674  #define CL_PROFILING_COMMAND_QUEUED                 0x1280
675  #define CL_PROFILING_COMMAND_SUBMIT                 0x1281
676  #define CL_PROFILING_COMMAND_START                  0x1282
677  #define CL_PROFILING_COMMAND_END                    0x1283
678  #ifdef CL_VERSION_2_0
679  #define CL_PROFILING_COMMAND_COMPLETE               0x1284
680  #endif
681  extern CL_API_ENTRY cl_int CL_API_CALL
<span onclick='openModal()' class='match'>682  clGetPlatformIDs(cl_uint          num_entries,
683                   cl_platform_id * platforms,
684                   cl_uint *        num_platforms) CL_API_SUFFIX__VERSION_1_0;
685  extern CL_API_ENTRY cl_int CL_API_CALL
686  clGetPlatformInfo(cl_platform_id   platform,
687                    cl_platform_info param_name,
688                    size_t           param_value_size,
689                    void *           param_value,
690                    size_t *         param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
691  extern CL_API_ENTRY cl_int CL_API_CALL
692  clGetDeviceIDs(cl_platform_id   platform,
693                 cl_device_type   device_type,
694                 cl_uint          num_entries,
695                 cl_device_id *   devices,
696                 cl_uint *        num_devices) CL_API_SUFFIX__VERSION_1_0;
697  extern CL_API_ENTRY cl_int CL_API_CALL
698  clGetDeviceInfo(cl_device_id    device,
699                  cl_device_info  param_name,
700                  size_t          param_value_size,
701                  void *          param_value,
702                  size_t *        param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
703  #ifdef CL_VERSION_1_2
704  extern CL_API_ENTRY cl_int CL_API_CALL
705  clCreateSubDevices(cl_device_id                         in_device,
706                     const cl_device_partition_property * properties,
707                     cl_uint                              num_devices,
708                     cl_device_id *                       out_devices,
709                     cl_uint *                            num_devices_ret) CL_API_SUFFIX__VERSION_1_2;
710  extern CL_API_ENTRY cl_int CL_API_CALL
711  clRetainDevice(cl_device_id device) CL_API_SUFFIX__VERSION_1_2;
712  extern CL_API_ENTRY cl_int CL_API_CALL
713  clReleaseDevice(cl_device_id device) CL_API_SUFFIX__VERSION_1_2;
</span>714  #endif
715  #ifdef CL_VERSION_2_1
716  extern CL_API_ENTRY cl_int CL_API_CALL
717  clSetDefaultDeviceCommandQueue(cl_context           context,
718                                 cl_device_id         device,
719                                 cl_command_queue     command_queue) CL_API_SUFFIX__VERSION_2_1;
720  extern CL_API_ENTRY cl_int CL_API_CALL
721  clGetDeviceAndHostTimer(cl_device_id    device,
722                          cl_ulong*       device_timestamp,
723                          cl_ulong*       host_timestamp) CL_API_SUFFIX__VERSION_2_1;
724  extern CL_API_ENTRY cl_int CL_API_CALL
725  clGetHostTimer(cl_device_id device,
726                 cl_ulong *   host_timestamp) CL_API_SUFFIX__VERSION_2_1;
727  #endif
728  extern CL_API_ENTRY cl_context CL_API_CALL
729  clCreateContext(const cl_context_properties * properties,
730                  cl_uint              num_devices,
731                  const cl_device_id * devices,
732                  void (CL_CALLBACK * pfn_notify)(const char * errinfo,
733                                                  const void * private_info,
734                                                  size_t       cb,
735                                                  void *       user_data),
736                  void *               user_data,
737                  cl_int *             errcode_ret) CL_API_SUFFIX__VERSION_1_0;
738  extern CL_API_ENTRY cl_context CL_API_CALL
739  clCreateContextFromType(const cl_context_properties * properties,
740                          cl_device_type      device_type,
741                          void (CL_CALLBACK * pfn_notify)(const char * errinfo,
742                                                          const void * private_info,
743                                                          size_t       cb,
744                                                          void *       user_data),
745                          void *              user_data,
746                          cl_int *            errcode_ret) CL_API_SUFFIX__VERSION_1_0;
747  extern CL_API_ENTRY cl_int CL_API_CALL
748  clRetainContext(cl_context context) CL_API_SUFFIX__VERSION_1_0;
749  extern CL_API_ENTRY cl_int CL_API_CALL
750  clReleaseContext(cl_context context) CL_API_SUFFIX__VERSION_1_0;
751  extern CL_API_ENTRY cl_int CL_API_CALL
752  clGetContextInfo(cl_context         context,
753                   cl_context_info    param_name,
754                   size_t             param_value_size,
755                   void *             param_value,
756                   size_t *           param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
757  #ifdef CL_VERSION_2_0
758  extern CL_API_ENTRY cl_command_queue CL_API_CALL
759  clCreateCommandQueueWithProperties(cl_context               context,
760                                     cl_device_id             device,
761                                     const cl_queue_properties *    properties,
762                                     cl_int *                 errcode_ret) CL_API_SUFFIX__VERSION_2_0;
763  #endif
764  extern CL_API_ENTRY cl_int CL_API_CALL
765  clRetainCommandQueue(cl_command_queue command_queue) CL_API_SUFFIX__VERSION_1_0;
766  extern CL_API_ENTRY cl_int CL_API_CALL
767  clReleaseCommandQueue(cl_command_queue command_queue) CL_API_SUFFIX__VERSION_1_0;
768  extern CL_API_ENTRY cl_int CL_API_CALL
769  clGetCommandQueueInfo(cl_command_queue      command_queue,
770                        cl_command_queue_info param_name,
771                        size_t                param_value_size,
772                        void *                param_value,
773                        size_t *              param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
774  extern CL_API_ENTRY cl_mem CL_API_CALL
775  clCreateBuffer(cl_context   context,
776                 cl_mem_flags flags,
777                 size_t       size,
778                 void *       host_ptr,
779                 cl_int *     errcode_ret) CL_API_SUFFIX__VERSION_1_0;
780  #ifdef CL_VERSION_1_1
781  extern CL_API_ENTRY cl_mem CL_API_CALL
782  clCreateSubBuffer(cl_mem                   buffer,
783                    cl_mem_flags             flags,
784                    cl_buffer_create_type    buffer_create_type,
785                    const void *             buffer_create_info,
786                    cl_int *                 errcode_ret) CL_API_SUFFIX__VERSION_1_1;
787  #endif
788  #ifdef CL_VERSION_1_2
789  extern CL_API_ENTRY cl_mem CL_API_CALL
790  clCreateImage(cl_context              context,
791                cl_mem_flags            flags,
792                const cl_image_format * image_format,
793                const cl_image_desc *   image_desc,
794                void *                  host_ptr,
795                cl_int *                errcode_ret) CL_API_SUFFIX__VERSION_1_2;
796  #endif
797  #ifdef CL_VERSION_2_0
798  extern CL_API_ENTRY cl_mem CL_API_CALL
799  clCreatePipe(cl_context                 context,
800               cl_mem_flags               flags,
801               cl_uint                    pipe_packet_size,
802               cl_uint                    pipe_max_packets,
803               const cl_pipe_properties * properties,
804               cl_int *                   errcode_ret) CL_API_SUFFIX__VERSION_2_0;
805  #endif
806  extern CL_API_ENTRY cl_int CL_API_CALL
807  clRetainMemObject(cl_mem memobj) CL_API_SUFFIX__VERSION_1_0;
808  extern CL_API_ENTRY cl_int CL_API_CALL
809  clReleaseMemObject(cl_mem memobj) CL_API_SUFFIX__VERSION_1_0;
810  extern CL_API_ENTRY cl_int CL_API_CALL
811  clGetSupportedImageFormats(cl_context           context,
812                             cl_mem_flags         flags,
813                             cl_mem_object_type   image_type,
814                             cl_uint              num_entries,
815                             cl_image_format *    image_formats,
816                             cl_uint *            num_image_formats) CL_API_SUFFIX__VERSION_1_0;
817  extern CL_API_ENTRY cl_int CL_API_CALL
818  clGetMemObjectInfo(cl_mem           memobj,
819                     cl_mem_info      param_name,
820                     size_t           param_value_size,
821                     void *           param_value,
822                     size_t *         param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
823  extern CL_API_ENTRY cl_int CL_API_CALL
824  clGetImageInfo(cl_mem           image,
825                 cl_image_info    param_name,
826                 size_t           param_value_size,
827                 void *           param_value,
828                 size_t *         param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
829  #ifdef CL_VERSION_2_0
830  extern CL_API_ENTRY cl_int CL_API_CALL
831  clGetPipeInfo(cl_mem           pipe,
832                cl_pipe_info     param_name,
833                size_t           param_value_size,
834                void *           param_value,
835                size_t *         param_value_size_ret) CL_API_SUFFIX__VERSION_2_0;
836  #endif
837  #ifdef CL_VERSION_1_1
838  extern CL_API_ENTRY cl_int CL_API_CALL
839  clSetMemObjectDestructorCallback(cl_mem memobj,
840                                   void (CL_CALLBACK * pfn_notify)(cl_mem memobj,
841                                                                   void * user_data),
842                                   void * user_data) CL_API_SUFFIX__VERSION_1_1;
843  #endif
844  #ifdef CL_VERSION_2_0
845  extern CL_API_ENTRY void * CL_API_CALL
846  clSVMAlloc(cl_context       context,
847             cl_svm_mem_flags flags,
848             size_t           size,
849             cl_uint          alignment) CL_API_SUFFIX__VERSION_2_0;
850  extern CL_API_ENTRY void CL_API_CALL
851  clSVMFree(cl_context        context,
852            void *            svm_pointer) CL_API_SUFFIX__VERSION_2_0;
853  #endif
854  #ifdef CL_VERSION_2_0
855  extern CL_API_ENTRY cl_sampler CL_API_CALL
856  clCreateSamplerWithProperties(cl_context                     context,
857                                const cl_sampler_properties *  sampler_properties,
858                                cl_int *                       errcode_ret) CL_API_SUFFIX__VERSION_2_0;
859  #endif
860  extern CL_API_ENTRY cl_int CL_API_CALL
861  clRetainSampler(cl_sampler sampler) CL_API_SUFFIX__VERSION_1_0;
862  extern CL_API_ENTRY cl_int CL_API_CALL
863  clReleaseSampler(cl_sampler sampler) CL_API_SUFFIX__VERSION_1_0;
864  extern CL_API_ENTRY cl_int CL_API_CALL
865  clGetSamplerInfo(cl_sampler         sampler,
866                   cl_sampler_info    param_name,
867                   size_t             param_value_size,
868                   void *             param_value,
869                   size_t *           param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
870  extern CL_API_ENTRY cl_program CL_API_CALL
871  clCreateProgramWithSource(cl_context        context,
872                            cl_uint           count,
873                            const char **     strings,
874                            const size_t *    lengths,
875                            cl_int *          errcode_ret) CL_API_SUFFIX__VERSION_1_0;
876  extern CL_API_ENTRY cl_program CL_API_CALL
877  clCreateProgramWithBinary(cl_context                     context,
878                            cl_uint                        num_devices,
879                            const cl_device_id *           device_list,
880                            const size_t *                 lengths,
881                            const unsigned char **         binaries,
882                            cl_int *                       binary_status,
883                            cl_int *                       errcode_ret) CL_API_SUFFIX__VERSION_1_0;
884  #ifdef CL_VERSION_1_2
885  extern CL_API_ENTRY cl_program CL_API_CALL
886  clCreateProgramWithBuiltInKernels(cl_context            context,
887                                    cl_uint               num_devices,
888                                    const cl_device_id *  device_list,
889                                    const char *          kernel_names,
890                                    cl_int *              errcode_ret) CL_API_SUFFIX__VERSION_1_2;
891  #endif
892  #ifdef CL_VERSION_2_1
893  extern CL_API_ENTRY cl_program CL_API_CALL
894  clCreateProgramWithIL(cl_context    context,
895                       const void*    il,
896                       size_t         length,
897                       cl_int*        errcode_ret) CL_API_SUFFIX__VERSION_2_1;
898  #endif
899  extern CL_API_ENTRY cl_int CL_API_CALL
900  clRetainProgram(cl_program program) CL_API_SUFFIX__VERSION_1_0;
901  extern CL_API_ENTRY cl_int CL_API_CALL
902  clReleaseProgram(cl_program program) CL_API_SUFFIX__VERSION_1_0;
903  extern CL_API_ENTRY cl_int CL_API_CALL
904  clBuildProgram(cl_program           program,
905                 cl_uint              num_devices,
906                 const cl_device_id * device_list,
907                 const char *         options,
908                 void (CL_CALLBACK *  pfn_notify)(cl_program program,
909                                                  void * user_data),
910                 void *               user_data) CL_API_SUFFIX__VERSION_1_0;
911  #ifdef CL_VERSION_1_2
912  extern CL_API_ENTRY cl_int CL_API_CALL
913  clCompileProgram(cl_program           program,
914                   cl_uint              num_devices,
915                   const cl_device_id * device_list,
916                   const char *         options,
917                   cl_uint              num_input_headers,
918                   const cl_program *   input_headers,
919                   const char **        header_include_names,
920                   void (CL_CALLBACK *  pfn_notify)(cl_program program,
921                                                    void * user_data),
922                   void *               user_data) CL_API_SUFFIX__VERSION_1_2;
923  extern CL_API_ENTRY cl_program CL_API_CALL
924  clLinkProgram(cl_context           context,
925                cl_uint              num_devices,
926                const cl_device_id * device_list,
927                const char *         options,
928                cl_uint              num_input_programs,
929                const cl_program *   input_programs,
930                void (CL_CALLBACK *  pfn_notify)(cl_program program,
931                                                 void * user_data),
932                void *               user_data,
933                cl_int *             errcode_ret) CL_API_SUFFIX__VERSION_1_2;
934  #endif
935  #ifdef CL_VERSION_2_2
936  extern CL_API_ENTRY cl_int CL_API_CALL
937  clSetProgramReleaseCallback(cl_program          program,
938                              void (CL_CALLBACK * pfn_notify)(cl_program program,
939                                                              void * user_data),
940                              void *              user_data) CL_API_SUFFIX__VERSION_2_2;
941  extern CL_API_ENTRY cl_int CL_API_CALL
942  clSetProgramSpecializationConstant(cl_program  program,
943                                     cl_uint     spec_id,
944                                     size_t      spec_size,
945                                     const void* spec_value) CL_API_SUFFIX__VERSION_2_2;
946  #endif
947  #ifdef CL_VERSION_1_2
948  extern CL_API_ENTRY cl_int CL_API_CALL
949  clUnloadPlatformCompiler(cl_platform_id platform) CL_API_SUFFIX__VERSION_1_2;
950  #endif
951  extern CL_API_ENTRY cl_int CL_API_CALL
952  clGetProgramInfo(cl_program         program,
953                   cl_program_info    param_name,
954                   size_t             param_value_size,
955                   void *             param_value,
956                   size_t *           param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
957  extern CL_API_ENTRY cl_int CL_API_CALL
958  clGetProgramBuildInfo(cl_program            program,
959                        cl_device_id          device,
960                        cl_program_build_info param_name,
961                        size_t                param_value_size,
962                        void *                param_value,
963                        size_t *              param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
964  extern CL_API_ENTRY cl_kernel CL_API_CALL
965  clCreateKernel(cl_program      program,
966                 const char *    kernel_name,
967                 cl_int *        errcode_ret) CL_API_SUFFIX__VERSION_1_0;
968  extern CL_API_ENTRY cl_int CL_API_CALL
969  clCreateKernelsInProgram(cl_program     program,
970                           cl_uint        num_kernels,
971                           cl_kernel *    kernels,
972                           cl_uint *      num_kernels_ret) CL_API_SUFFIX__VERSION_1_0;
973  #ifdef CL_VERSION_2_1
974  extern CL_API_ENTRY cl_kernel CL_API_CALL
975  clCloneKernel(cl_kernel     source_kernel,
976                cl_int*       errcode_ret) CL_API_SUFFIX__VERSION_2_1;
977  #endif
978  extern CL_API_ENTRY cl_int CL_API_CALL
979  clRetainKernel(cl_kernel    kernel) CL_API_SUFFIX__VERSION_1_0;
980  extern CL_API_ENTRY cl_int CL_API_CALL
981  clReleaseKernel(cl_kernel   kernel) CL_API_SUFFIX__VERSION_1_0;
982  extern CL_API_ENTRY cl_int CL_API_CALL
983  clSetKernelArg(cl_kernel    kernel,
984                 cl_uint      arg_index,
985                 size_t       arg_size,
986                 const void * arg_value) CL_API_SUFFIX__VERSION_1_0;
987  #ifdef CL_VERSION_2_0
988  extern CL_API_ENTRY cl_int CL_API_CALL
989  clSetKernelArgSVMPointer(cl_kernel    kernel,
990                           cl_uint      arg_index,
991                           const void * arg_value) CL_API_SUFFIX__VERSION_2_0;
992  extern CL_API_ENTRY cl_int CL_API_CALL
993  clSetKernelExecInfo(cl_kernel            kernel,
994                      cl_kernel_exec_info  param_name,
995                      size_t               param_value_size,
996                      const void *         param_value) CL_API_SUFFIX__VERSION_2_0;
997  #endif
998  extern CL_API_ENTRY cl_int CL_API_CALL
999  clGetKernelInfo(cl_kernel       kernel,
1000                  cl_kernel_info  param_name,
1001                  size_t          param_value_size,
1002                  void *          param_value,
1003                  size_t *        param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
1004  #ifdef CL_VERSION_1_2
1005  extern CL_API_ENTRY cl_int CL_API_CALL
1006  clGetKernelArgInfo(cl_kernel       kernel,
1007                     cl_uint         arg_indx,
1008                     cl_kernel_arg_info  param_name,
1009                     size_t          param_value_size,
1010                     void *          param_value,
1011                     size_t *        param_value_size_ret) CL_API_SUFFIX__VERSION_1_2;
1012  #endif
1013  extern CL_API_ENTRY cl_int CL_API_CALL
1014  clGetKernelWorkGroupInfo(cl_kernel                  kernel,
1015                           cl_device_id               device,
1016                           cl_kernel_work_group_info  param_name,
1017                           size_t                     param_value_size,
1018                           void *                     param_value,
1019                           size_t *                   param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
1020  #ifdef CL_VERSION_2_1
1021  extern CL_API_ENTRY cl_int CL_API_CALL
1022  clGetKernelSubGroupInfo(cl_kernel                   kernel,
1023                          cl_device_id                device,
1024                          cl_kernel_sub_group_info    param_name,
1025                          size_t                      input_value_size,
1026                          const void*                 input_value,
1027                          size_t                      param_value_size,
1028                          void*                       param_value,
1029                          size_t*                     param_value_size_ret) CL_API_SUFFIX__VERSION_2_1;
1030  #endif
1031  extern CL_API_ENTRY cl_int CL_API_CALL
1032  clWaitForEvents(cl_uint             num_events,
1033                  const cl_event *    event_list) CL_API_SUFFIX__VERSION_1_0;
1034  extern CL_API_ENTRY cl_int CL_API_CALL
1035  clGetEventInfo(cl_event         event,
1036                 cl_event_info    param_name,
1037                 size_t           param_value_size,
1038                 void *           param_value,
1039                 size_t *         param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
1040  #ifdef CL_VERSION_1_1
1041  extern CL_API_ENTRY cl_event CL_API_CALL
1042  clCreateUserEvent(cl_context    context,
1043                    cl_int *      errcode_ret) CL_API_SUFFIX__VERSION_1_1;
1044  #endif
1045  extern CL_API_ENTRY cl_int CL_API_CALL
1046  clRetainEvent(cl_event event) CL_API_SUFFIX__VERSION_1_0;
1047  extern CL_API_ENTRY cl_int CL_API_CALL
1048  clReleaseEvent(cl_event event) CL_API_SUFFIX__VERSION_1_0;
1049  #ifdef CL_VERSION_1_1
1050  extern CL_API_ENTRY cl_int CL_API_CALL
1051  clSetUserEventStatus(cl_event   event,
1052                       cl_int     execution_status) CL_API_SUFFIX__VERSION_1_1;
1053  extern CL_API_ENTRY cl_int CL_API_CALL
1054  clSetEventCallback(cl_event    event,
1055                     cl_int      command_exec_callback_type,
1056                     void (CL_CALLBACK * pfn_notify)(cl_event event,
1057                                                     cl_int   event_command_status,
1058                                                     void *   user_data),
1059                     void *      user_data) CL_API_SUFFIX__VERSION_1_1;
1060  #endif
1061  extern CL_API_ENTRY cl_int CL_API_CALL
1062  clGetEventProfilingInfo(cl_event            event,
1063                          cl_profiling_info   param_name,
1064                          size_t              param_value_size,
1065                          void *              param_value,
1066                          size_t *            param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
1067  extern CL_API_ENTRY cl_int CL_API_CALL
1068  clFlush(cl_command_queue command_queue) CL_API_SUFFIX__VERSION_1_0;
1069  extern CL_API_ENTRY cl_int CL_API_CALL
1070  clFinish(cl_command_queue command_queue) CL_API_SUFFIX__VERSION_1_0;
1071  extern CL_API_ENTRY cl_int CL_API_CALL
1072  clEnqueueReadBuffer(cl_command_queue    command_queue,
1073                      cl_mem              buffer,
1074                      cl_bool             blocking_read,
1075                      size_t              offset,
1076                      size_t              size,
1077                      void *              ptr,
1078                      cl_uint             num_events_in_wait_list,
1079                      const cl_event *    event_wait_list,
1080                      cl_event *          event) CL_API_SUFFIX__VERSION_1_0;
1081  #ifdef CL_VERSION_1_1
1082  extern CL_API_ENTRY cl_int CL_API_CALL
1083  clEnqueueReadBufferRect(cl_command_queue    command_queue,
1084                          cl_mem              buffer,
1085                          cl_bool             blocking_read,
1086                          const size_t *      buffer_offset,
1087                          const size_t *      host_offset,
1088                          const size_t *      region,
1089                          size_t              buffer_row_pitch,
1090                          size_t              buffer_slice_pitch,
1091                          size_t              host_row_pitch,
1092                          size_t              host_slice_pitch,
1093                          void *              ptr,
1094                          cl_uint             num_events_in_wait_list,
1095                          const cl_event *    event_wait_list,
1096                          cl_event *          event) CL_API_SUFFIX__VERSION_1_1;
1097  #endif
1098  extern CL_API_ENTRY cl_int CL_API_CALL
1099  clEnqueueWriteBuffer(cl_command_queue   command_queue,
1100                       cl_mem             buffer,
1101                       cl_bool            blocking_write,
1102                       size_t             offset,
1103                       size_t             size,
1104                       const void *       ptr,
1105                       cl_uint            num_events_in_wait_list,
1106                       const cl_event *   event_wait_list,
1107                       cl_event *         event) CL_API_SUFFIX__VERSION_1_0;
1108  #ifdef CL_VERSION_1_1
1109  extern CL_API_ENTRY cl_int CL_API_CALL
1110  clEnqueueWriteBufferRect(cl_command_queue    command_queue,
1111                           cl_mem              buffer,
1112                           cl_bool             blocking_write,
1113                           const size_t *      buffer_offset,
1114                           const size_t *      host_offset,
1115                           const size_t *      region,
1116                           size_t              buffer_row_pitch,
1117                           size_t              buffer_slice_pitch,
1118                           size_t              host_row_pitch,
1119                           size_t              host_slice_pitch,
1120                           const void *        ptr,
1121                           cl_uint             num_events_in_wait_list,
1122                           const cl_event *    event_wait_list,
1123                           cl_event *          event) CL_API_SUFFIX__VERSION_1_1;
1124  #endif
1125  #ifdef CL_VERSION_1_2
1126  extern CL_API_ENTRY cl_int CL_API_CALL
1127  clEnqueueFillBuffer(cl_command_queue   command_queue,
1128                      cl_mem             buffer,
1129                      const void *       pattern,
1130                      size_t             pattern_size,
1131                      size_t             offset,
1132                      size_t             size,
1133                      cl_uint            num_events_in_wait_list,
1134                      const cl_event *   event_wait_list,
1135                      cl_event *         event) CL_API_SUFFIX__VERSION_1_2;
1136  #endif
1137  extern CL_API_ENTRY cl_int CL_API_CALL
1138  clEnqueueCopyBuffer(cl_command_queue    command_queue,
1139                      cl_mem              src_buffer,
1140                      cl_mem              dst_buffer,
1141                      size_t              src_offset,
1142                      size_t              dst_offset,
1143                      size_t              size,
1144                      cl_uint             num_events_in_wait_list,
1145                      const cl_event *    event_wait_list,
1146                      cl_event *          event) CL_API_SUFFIX__VERSION_1_0;
1147  #ifdef CL_VERSION_1_1
1148  extern CL_API_ENTRY cl_int CL_API_CALL
1149  clEnqueueCopyBufferRect(cl_command_queue    command_queue,
1150                          cl_mem              src_buffer,
1151                          cl_mem              dst_buffer,
1152                          const size_t *      src_origin,
1153                          const size_t *      dst_origin,
1154                          const size_t *      region,
1155                          size_t              src_row_pitch,
1156                          size_t              src_slice_pitch,
1157                          size_t              dst_row_pitch,
1158                          size_t              dst_slice_pitch,
1159                          cl_uint             num_events_in_wait_list,
1160                          const cl_event *    event_wait_list,
1161                          cl_event *          event) CL_API_SUFFIX__VERSION_1_1;
1162  #endif
1163  extern CL_API_ENTRY cl_int CL_API_CALL
1164  clEnqueueReadImage(cl_command_queue     command_queue,
1165                     cl_mem               image,
1166                     cl_bool              blocking_read,
1167                     const size_t *       origin,
1168                     const size_t *       region,
1169                     size_t               row_pitch,
1170                     size_t               slice_pitch,
1171                     void *               ptr,
1172                     cl_uint              num_events_in_wait_list,
1173                     const cl_event *     event_wait_list,
1174                     cl_event *           event) CL_API_SUFFIX__VERSION_1_0;
1175  extern CL_API_ENTRY cl_int CL_API_CALL
1176  clEnqueueWriteImage(cl_command_queue    command_queue,
1177                      cl_mem              image,
1178                      cl_bool             blocking_write,
1179                      const size_t *      origin,
1180                      const size_t *      region,
1181                      size_t              input_row_pitch,
1182                      size_t              input_slice_pitch,
1183                      const void *        ptr,
1184                      cl_uint             num_events_in_wait_list,
1185                      const cl_event *    event_wait_list,
1186                      cl_event *          event) CL_API_SUFFIX__VERSION_1_0;
1187  #ifdef CL_VERSION_1_2
1188  extern CL_API_ENTRY cl_int CL_API_CALL
1189  clEnqueueFillImage(cl_command_queue   command_queue,
1190                     cl_mem             image,
1191                     const void *       fill_color,
1192                     const size_t *     origin,
1193                     const size_t *     region,
1194                     cl_uint            num_events_in_wait_list,
1195                     const cl_event *   event_wait_list,
1196                     cl_event *         event) CL_API_SUFFIX__VERSION_1_2;
1197  #endif
1198  extern CL_API_ENTRY cl_int CL_API_CALL
1199  clEnqueueCopyImage(cl_command_queue     command_queue,
1200                     cl_mem               src_image,
1201                     cl_mem               dst_image,
1202                     const size_t *       src_origin,
1203                     const size_t *       dst_origin,
1204                     const size_t *       region,
1205                     cl_uint              num_events_in_wait_list,
1206                     const cl_event *     event_wait_list,
1207                     cl_event *           event) CL_API_SUFFIX__VERSION_1_0;
1208  extern CL_API_ENTRY cl_int CL_API_CALL
1209  clEnqueueCopyImageToBuffer(cl_command_queue command_queue,
1210                             cl_mem           src_image,
1211                             cl_mem           dst_buffer,
1212                             const size_t *   src_origin,
1213                             const size_t *   region,
1214                             size_t           dst_offset,
1215                             cl_uint          num_events_in_wait_list,
1216                             const cl_event * event_wait_list,
1217                             cl_event *       event) CL_API_SUFFIX__VERSION_1_0;
1218  extern CL_API_ENTRY cl_int CL_API_CALL
1219  clEnqueueCopyBufferToImage(cl_command_queue command_queue,
1220                             cl_mem           src_buffer,
1221                             cl_mem           dst_image,
1222                             size_t           src_offset,
1223                             const size_t *   dst_origin,
1224                             const size_t *   region,
1225                             cl_uint          num_events_in_wait_list,
1226                             const cl_event * event_wait_list,
1227                             cl_event *       event) CL_API_SUFFIX__VERSION_1_0;
1228  extern CL_API_ENTRY void * CL_API_CALL
1229  clEnqueueMapBuffer(cl_command_queue command_queue,
1230                     cl_mem           buffer,
1231                     cl_bool          blocking_map,
1232                     cl_map_flags     map_flags,
1233                     size_t           offset,
1234                     size_t           size,
1235                     cl_uint          num_events_in_wait_list,
1236                     const cl_event * event_wait_list,
1237                     cl_event *       event,
1238                     cl_int *         errcode_ret) CL_API_SUFFIX__VERSION_1_0;
1239  extern CL_API_ENTRY void * CL_API_CALL
1240  clEnqueueMapImage(cl_command_queue  command_queue,
1241                    cl_mem            image,
1242                    cl_bool           blocking_map,
1243                    cl_map_flags      map_flags,
1244                    const size_t *    origin,
1245                    const size_t *    region,
1246                    size_t *          image_row_pitch,
1247                    size_t *          image_slice_pitch,
1248                    cl_uint           num_events_in_wait_list,
1249                    const cl_event *  event_wait_list,
1250                    cl_event *        event,
1251                    cl_int *          errcode_ret) CL_API_SUFFIX__VERSION_1_0;
1252  extern CL_API_ENTRY cl_int CL_API_CALL
1253  clEnqueueUnmapMemObject(cl_command_queue command_queue,
1254                          cl_mem           memobj,
1255                          void *           mapped_ptr,
1256                          cl_uint          num_events_in_wait_list,
1257                          const cl_event * event_wait_list,
1258                          cl_event *       event) CL_API_SUFFIX__VERSION_1_0;
1259  #ifdef CL_VERSION_1_2
1260  extern CL_API_ENTRY cl_int CL_API_CALL
1261  clEnqueueMigrateMemObjects(cl_command_queue       command_queue,
1262                             cl_uint                num_mem_objects,
1263                             const cl_mem *         mem_objects,
1264                             cl_mem_migration_flags flags,
1265                             cl_uint                num_events_in_wait_list,
1266                             const cl_event *       event_wait_list,
1267                             cl_event *             event) CL_API_SUFFIX__VERSION_1_2;
1268  #endif
1269  extern CL_API_ENTRY cl_int CL_API_CALL
1270  clEnqueueNDRangeKernel(cl_command_queue command_queue,
1271                         cl_kernel        kernel,
1272                         cl_uint          work_dim,
1273                         const size_t *   global_work_offset,
1274                         const size_t *   global_work_size,
1275                         const size_t *   local_work_size,
1276                         cl_uint          num_events_in_wait_list,
1277                         const cl_event * event_wait_list,
1278                         cl_event *       event) CL_API_SUFFIX__VERSION_1_0;
1279  extern CL_API_ENTRY cl_int CL_API_CALL
1280  clEnqueueNativeKernel(cl_command_queue  command_queue,
1281                        void (CL_CALLBACK * user_func)(void *),
1282                        void *            args,
1283                        size_t            cb_args,
1284                        cl_uint           num_mem_objects,
1285                        const cl_mem *    mem_list,
1286                        const void **     args_mem_loc,
1287                        cl_uint           num_events_in_wait_list,
1288                        const cl_event *  event_wait_list,
1289                        cl_event *        event) CL_API_SUFFIX__VERSION_1_0;
1290  #ifdef CL_VERSION_1_2
1291  extern CL_API_ENTRY cl_int CL_API_CALL
1292  clEnqueueMarkerWithWaitList(cl_command_queue  command_queue,
1293                              cl_uint           num_events_in_wait_list,
1294                              const cl_event *  event_wait_list,
1295                              cl_event *        event) CL_API_SUFFIX__VERSION_1_2;
1296  extern CL_API_ENTRY cl_int CL_API_CALL
1297  clEnqueueBarrierWithWaitList(cl_command_queue  command_queue,
1298                               cl_uint           num_events_in_wait_list,
1299                               const cl_event *  event_wait_list,
1300                               cl_event *        event) CL_API_SUFFIX__VERSION_1_2;
1301  #endif
1302  #ifdef CL_VERSION_2_0
1303  extern CL_API_ENTRY cl_int CL_API_CALL
1304  clEnqueueSVMFree(cl_command_queue  command_queue,
1305                   cl_uint           num_svm_pointers,
1306                   void *            svm_pointers[],
1307                   void (CL_CALLBACK * pfn_free_func)(cl_command_queue queue,
1308                                                      cl_uint          num_svm_pointers,
1309                                                      void *           svm_pointers[],
1310                                                      void *           user_data),
1311                   void *            user_data,
1312                   cl_uint           num_events_in_wait_list,
1313                   const cl_event *  event_wait_list,
1314                   cl_event *        event) CL_API_SUFFIX__VERSION_2_0;
1315  extern CL_API_ENTRY cl_int CL_API_CALL
1316  clEnqueueSVMMemcpy(cl_command_queue  command_queue,
1317                     cl_bool           blocking_copy,
1318                     void *            dst_ptr,
1319                     const void *      src_ptr,
1320                     size_t            size,
1321                     cl_uint           num_events_in_wait_list,
1322                     const cl_event *  event_wait_list,
1323                     cl_event *        event) CL_API_SUFFIX__VERSION_2_0;
1324  extern CL_API_ENTRY cl_int CL_API_CALL
1325  clEnqueueSVMMemFill(cl_command_queue  command_queue,
1326                      void *            svm_ptr,
1327                      const void *      pattern,
1328                      size_t            pattern_size,
1329                      size_t            size,
1330                      cl_uint           num_events_in_wait_list,
1331                      const cl_event *  event_wait_list,
1332                      cl_event *        event) CL_API_SUFFIX__VERSION_2_0;
1333  extern CL_API_ENTRY cl_int CL_API_CALL
1334  clEnqueueSVMMap(cl_command_queue  command_queue,
1335                  cl_bool           blocking_map,
1336                  cl_map_flags      flags,
1337                  void *            svm_ptr,
1338                  size_t            size,
1339                  cl_uint           num_events_in_wait_list,
1340                  const cl_event *  event_wait_list,
1341                  cl_event *        event) CL_API_SUFFIX__VERSION_2_0;
1342  extern CL_API_ENTRY cl_int CL_API_CALL
1343  clEnqueueSVMUnmap(cl_command_queue  command_queue,
1344                    void *            svm_ptr,
1345                    cl_uint           num_events_in_wait_list,
1346                    const cl_event *  event_wait_list,
1347                    cl_event *        event) CL_API_SUFFIX__VERSION_2_0;
1348  #endif
1349  #ifdef CL_VERSION_2_1
1350  extern CL_API_ENTRY cl_int CL_API_CALL
1351  clEnqueueSVMMigrateMem(cl_command_queue         command_queue,
1352                         cl_uint                  num_svm_pointers,
1353                         const void **            svm_pointers,
1354                         const size_t *           sizes,
1355                         cl_mem_migration_flags   flags,
1356                         cl_uint                  num_events_in_wait_list,
1357                         const cl_event *         event_wait_list,
1358                         cl_event *               event) CL_API_SUFFIX__VERSION_2_1;
1359  #endif
1360  #ifdef CL_VERSION_1_2
1361  extern CL_API_ENTRY void * CL_API_CALL
1362  clGetExtensionFunctionAddressForPlatform(cl_platform_id platform,
1363                                           const char *   func_name) CL_API_SUFFIX__VERSION_1_2;
1364  #endif
1365  #ifdef CL_USE_DEPRECATED_OPENCL_1_0_APIS
1366      extern CL_API_ENTRY cl_int CL_API_CALL
1367      clSetCommandQueueProperty(cl_command_queue              command_queue,
1368                                cl_command_queue_properties   properties,
1369                                cl_bool                       enable,
1370                                cl_command_queue_properties * old_properties) CL_EXT_SUFFIX__VERSION_1_0_DEPRECATED;
1371  #endif &bsol;* CL_USE_DEPRECATED_OPENCL_1_0_APIS */
1372  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_mem CL_API_CALL
1373  clCreateImage2D(cl_context              context,
1374                  cl_mem_flags            flags,
1375                  const cl_image_format * image_format,
1376                  size_t                  image_width,
1377                  size_t                  image_height,
1378                  size_t                  image_row_pitch,
1379                  void *                  host_ptr,
1380                  cl_int *                errcode_ret) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1381  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_mem CL_API_CALL
1382  clCreateImage3D(cl_context              context,
1383                  cl_mem_flags            flags,
1384                  const cl_image_format * image_format,
1385                  size_t                  image_width,
1386                  size_t                  image_height,
1387                  size_t                  image_depth,
1388                  size_t                  image_row_pitch,
1389                  size_t                  image_slice_pitch,
1390                  void *                  host_ptr,
1391                  cl_int *                errcode_ret) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1392  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int CL_API_CALL
1393  clEnqueueMarker(cl_command_queue    command_queue,
1394                  cl_event *          event) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1395  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int CL_API_CALL
1396  clEnqueueWaitForEvents(cl_command_queue  command_queue,
1397                          cl_uint          num_events,
1398                          const cl_event * event_list) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1399  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int CL_API_CALL
1400  clEnqueueBarrier(cl_command_queue command_queue) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1401  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int CL_API_CALL
1402  clUnloadCompiler(void) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1403  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED void * CL_API_CALL
1404  clGetExtensionFunctionAddress(const char * func_name) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1405  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_2_DEPRECATED cl_command_queue CL_API_CALL
1406  clCreateCommandQueue(cl_context                     context,
1407                       cl_device_id                   device,
1408                       cl_command_queue_properties    properties,
1409                       cl_int *                       errcode_ret) CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED;
1410  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_2_DEPRECATED cl_sampler CL_API_CALL
1411  clCreateSampler(cl_context          context,
1412                  cl_bool             normalized_coords,
1413                  cl_addressing_mode  addressing_mode,
1414                  cl_filter_mode      filter_mode,
1415                  cl_int *            errcode_ret) CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED;
1416  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_2_DEPRECATED cl_int CL_API_CALL
1417  clEnqueueTask(cl_command_queue  command_queue,
1418                cl_kernel         kernel,
1419                cl_uint           num_events_in_wait_list,
1420                const cl_event *  event_wait_list,
1421                cl_event *        event) CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED;
1422  #ifdef __cplusplus
1423  }
1424  #endif
1425  #endif  &bsol;* __OPENCL_CL_H */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_simd.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include <limits.h>
4  #include "sph_simd.h"
5  #ifdef __cplusplus
6  extern "C"{
7  #endif
8  #if SPH_SMALL_FOOTPRINT && !defined SPH_SMALL_FOOTPRINT_SIMD
9  #define SPH_SMALL_FOOTPRINT_SIMD   1
10  #endif
11  #ifdef _MSC_VER
12  #pragma warning (disable: 4146)
13  #endif
14  typedef sph_u32 u32;
15  typedef sph_s32 s32;
16  #define C32     SPH_C32
17  #define T32     SPH_T32
18  #define ROL32   SPH_ROTL32
19  #define XCAT(x, y)    XCAT_(x, y)
20  #define XCAT_(x, y)   x ## y
21  static const s32 alpha_tab[] = {
22  	  1,  41, 139,  45,  46,  87, 226,  14,  60, 147, 116, 130,
23  	190,  80, 196,  69,   2,  82,  21,  90,  92, 174, 195,  28,
24  	120,  37, 232,   3, 123, 160, 135, 138,   4, 164,  42, 180,
25  	184,  91, 133,  56, 240,  74, 207,   6, 246,  63,  13,  19,
26  	  8,  71,  84, 103, 111, 182,   9, 112, 223, 148, 157,  12,
27  	235, 126,  26,  38,  16, 142, 168, 206, 222, 107,  18, 224,
28  	189,  39,  57,  24, 213, 252,  52,  76,  32,  27,  79, 155,
29  	187, 214,  36, 191, 121,  78, 114,  48, 169, 247, 104, 152,
30  	 64,  54, 158,  53, 117, 171,  72, 125, 242, 156, 228,  96,
31  	 81, 237, 208,  47, 128, 108,  59, 106, 234,  85, 144, 250,
32  	227,  55, 199, 192, 162, 217, 159,  94, 256, 216, 118, 212,
33  	211, 170,  31, 243, 197, 110, 141, 127,  67, 177,  61, 188,
34  	255, 175, 236, 167, 165,  83,  62, 229, 137, 220,  25, 254,
35  	134,  97, 122, 119, 253,  93, 215,  77,  73, 166, 124, 201,
36  	 17, 183,  50, 251,  11, 194, 244, 238, 249, 186, 173, 154,
37  	146,  75, 248, 145,  34, 109, 100, 245,  22, 131, 231, 219,
38  	241, 115,  89,  51,  35, 150, 239,  33,  68, 218, 200, 233,
39  	 44,   5, 205, 181, 225, 230, 178, 102,  70,  43, 221,  66,
40  	136, 179, 143, 209,  88,  10, 153, 105, 193, 203,  99, 204,
41  	140,  86, 185, 132,  15, 101,  29, 161, 176,  20,  49, 210,
42  	129, 149, 198, 151,  23, 172, 113,   7,  30, 202,  58,  65,
43  	 95,  40,  98, 163
44  };
45  #define REDS1(x)    (((x) & 0xFF) - ((x) >> 8))
46  #define REDS2(x)    (((x) & 0xFFFF) + ((x) >> 16))
47  #define FFT_LOOP(rb, hk, as, id)   do { \
48  		size_t u, v; \
49  		s32 m = q[(rb)]; \
50  		s32 n = q[(rb) + (hk)]; \
51  		q[(rb)] = m + n; \
52  		q[(rb) + (hk)] = m - n; \
53  		u = v = 0; \
54  		goto id; \
55  		for (; u < (hk); u += 4, v += 4 * (as)) { \
56  			s32 t; \
57  			m = q[(rb) + u + 0]; \
58  			n = q[(rb) + u + 0 + (hk)]; \
59  			t = REDS2(n * alpha_tab[v + 0 * (as)]); \
60  			q[(rb) + u + 0] = m + t; \
61  			q[(rb) + u + 0 + (hk)] = m - t; \
62  		id: \
63  			m = q[(rb) + u + 1]; \
64  			n = q[(rb) + u + 1 + (hk)]; \
65  			t = REDS2(n * alpha_tab[v + 1 * (as)]); \
66  			q[(rb) + u + 1] = m + t; \
67  			q[(rb) + u + 1 + (hk)] = m - t; \
68  			m = q[(rb) + u + 2]; \
69  			n = q[(rb) + u + 2 + (hk)]; \
70  			t = REDS2(n * alpha_tab[v + 2 * (as)]); \
71  			q[(rb) + u + 2] = m + t; \
72  			q[(rb) + u + 2 + (hk)] = m - t; \
73  			m = q[(rb) + u + 3]; \
74  			n = q[(rb) + u + 3 + (hk)]; \
75  			t = REDS2(n * alpha_tab[v + 3 * (as)]); \
76  			q[(rb) + u + 3] = m + t; \
77  			q[(rb) + u + 3 + (hk)] = m - t; \
78  		} \
79  	} while (0)
80  #define FFT8(xb, xs, d)   do { \
81  		s32 x0 = x[(xb)]; \
82  		s32 x1 = x[(xb) + (xs)]; \
83  		s32 x2 = x[(xb) + 2 * (xs)]; \
84  		s32 x3 = x[(xb) + 3 * (xs)]; \
85  		s32 a0 = x0 + x2; \
86  		s32 a1 = x0 + (x2 << 4); \
87  		s32 a2 = x0 - x2; \
88  		s32 a3 = x0 - (x2 << 4); \
89  		s32 b0 = x1 + x3; \
90  		s32 b1 = REDS1((x1 << 2) + (x3 << 6)); \
91  		s32 b2 = (x1 << 4) - (x3 << 4); \
92  		s32 b3 = REDS1((x1 << 6) + (x3 << 2)); \
93  		d ## 0 = a0 + b0; \
94  		d ## 1 = a1 + b1; \
95  		d ## 2 = a2 + b2; \
96  		d ## 3 = a3 + b3; \
97  		d ## 4 = a0 - b0; \
98  		d ## 5 = a1 - b1; \
99  		d ## 6 = a2 - b2; \
100  		d ## 7 = a3 - b3; \
101  	} while (0)
102  #define FFT16(xb, xs, rb)   do { \
103  		s32 d1_0, d1_1, d1_2, d1_3, d1_4, d1_5, d1_6, d1_7; \
104  		s32 d2_0, d2_1, d2_2, d2_3, d2_4, d2_5, d2_6, d2_7; \
105  		FFT8(xb, (xs) << 1, d1_); \
106  		FFT8((xb) + (xs), (xs) << 1, d2_); \
107  		q[(rb) +  0] = d1_0 + d2_0; \
108  		q[(rb) +  1] = d1_1 + (d2_1 << 1); \
109  		q[(rb) +  2] = d1_2 + (d2_2 << 2); \
110  		q[(rb) +  3] = d1_3 + (d2_3 << 3); \
111  		q[(rb) +  4] = d1_4 + (d2_4 << 4); \
112  		q[(rb) +  5] = d1_5 + (d2_5 << 5); \
113  		q[(rb) +  6] = d1_6 + (d2_6 << 6); \
114  		q[(rb) +  7] = d1_7 + (d2_7 << 7); \
115  		q[(rb) +  8] = d1_0 - d2_0; \
116  		q[(rb) +  9] = d1_1 - (d2_1 << 1); \
117  		q[(rb) + 10] = d1_2 - (d2_2 << 2); \
118  		q[(rb) + 11] = d1_3 - (d2_3 << 3); \
119  		q[(rb) + 12] = d1_4 - (d2_4 << 4); \
120  		q[(rb) + 13] = d1_5 - (d2_5 << 5); \
121  		q[(rb) + 14] = d1_6 - (d2_6 << 6); \
122  		q[(rb) + 15] = d1_7 - (d2_7 << 7); \
123  	} while (0)
124  #define FFT32(xb, xs, rb, id)   do { \
125  		FFT16(xb, (xs) << 1, rb); \
126  		FFT16((xb) + (xs), (xs) << 1, (rb) + 16); \
127  		FFT_LOOP(rb, 16, 8, id); \
128  	} while (0)
129  #define FFT64(xb, xs, rb, id)   do { \
130  		FFT32(xb, (xs) << 1, rb, XCAT(id, a)); \
131  		FFT32((xb) + (xs), (xs) << 1, (rb) + 32, XCAT(id, b)); \
132  		FFT_LOOP(rb, 32, 4, id); \
133  	} while (0)
134  #if SPH_SMALL_FOOTPRINT_SIMD
135  static void
136  fft32(unsigned char *x, size_t xs, s32 *q)
137  {
138  	size_t xd;
139  	xd = xs << 1;
140  	FFT16(0, xd, 0);
141  	FFT16(xs, xd, 16);
142  	FFT_LOOP(0, 16, 8, label_);
143  }
144  #define FFT128(xb, xs, rb, id)   do { \
145  		fft32(x + (xb) + ((xs) * 0), (xs) << 2, &q[(rb) +  0]); \
146  		fft32(x + (xb) + ((xs) * 2), (xs) << 2, &q[(rb) + 32]); \
147  		FFT_LOOP(rb, 32, 4, XCAT(id, aa)); \
148  		fft32(x + (xb) + ((xs) * 1), (xs) << 2, &q[(rb) + 64]); \
149  		fft32(x + (xb) + ((xs) * 3), (xs) << 2, &q[(rb) + 96]); \
150  		FFT_LOOP((rb) + 64, 32, 4, XCAT(id, ab)); \
151  		FFT_LOOP(rb, 64, 2, XCAT(id, a)); \
152  	} while (0)
153  #else
154  #define FFT128(xb, xs, rb, id)   do { \
155  		FFT64(xb, (xs) << 1, rb, XCAT(id, a)); \
156  		FFT64((xb) + (xs), (xs) << 1, (rb) + 64, XCAT(id, b)); \
157  		FFT_LOOP(rb, 64, 2, id); \
158  	} while (0)
159  #endif
160  static void
161  fft64(unsigned char *x, size_t xs, s32 *q)
162  {
163  	size_t xd;
164  	xd = xs << 1;
165  	FFT32(0, xd, 0, label_a);
166  	FFT32(xs, xd, 32, label_b);
167  	FFT_LOOP(0, 32, 4, label_);
168  }
169  #define FFT256(xb, xs, rb, id)   do { \
170  		fft64(x + (xb) + ((xs) * 0), (xs) << 2, &q[(rb) +   0]); \
171  		fft64(x + (xb) + ((xs) * 2), (xs) << 2, &q[(rb) +  64]); \
172  		FFT_LOOP(rb, 64, 2, XCAT(id, aa)); \
173  		fft64(x + (xb) + ((xs) * 1), (xs) << 2, &q[(rb) + 128]); \
174  		fft64(x + (xb) + ((xs) * 3), (xs) << 2, &q[(rb) + 192]); \
175  		FFT_LOOP((rb) + 128, 64, 2, XCAT(id, ab)); \
176  		FFT_LOOP(rb, 128, 1, XCAT(id, a)); \
177  	} while (0)
178  static const unsigned short yoff_s_n[] = {
179  	  1,  98,  95,  58,  30, 113,  23, 198, 129,  49, 176,  29,
180  	 15, 185, 140,  99, 193, 153,  88, 143, 136, 221,  70, 178,
181  	225, 205,  44, 200,  68, 239,  35,  89, 241, 231,  22, 100,
182  	 34, 248, 146, 173, 249, 244,  11,  50,  17, 124,  73, 215,
183  	253, 122, 134,  25, 137,  62, 165, 236, 255,  61,  67, 141,
184  	197,  31, 211, 118, 256, 159, 162, 199, 227, 144, 234,  59,
185  	128, 208,  81, 228, 242,  72, 117, 158,  64, 104, 169, 114,
186  	121,  36, 187,  79,  32,  52, 213,  57, 189,  18, 222, 168,
187  	 16,  26, 235, 157, 223,   9, 111,  84,   8,  13, 246, 207,
188  	240, 133, 184,  42,   4, 135, 123, 232, 120, 195,  92,  21,
189  	  2, 196, 190, 116,  60, 226,  46, 139
190  };
191  static const unsigned short yoff_s_f[] = {
192  	  2, 156, 118, 107,  45, 212, 111, 162,  97, 249, 211,   3,
193  	 49, 101, 151, 223, 189, 178, 253, 204,  76,  82, 232,  65,
194  	 96, 176, 161,  47, 189,  61, 248, 107,   0, 131, 133, 113,
195  	 17,  33,  12, 111, 251, 103,  57, 148,  47,  65, 249, 143,
196  	189,   8, 204, 230, 205, 151, 187, 227, 247, 111, 140,   6,
197  	 77,  10,  21, 149, 255, 101, 139, 150, 212,  45, 146,  95,
198  	160,   8,  46, 254, 208, 156, 106,  34,  68,  79,   4,  53,
199  	181, 175,  25, 192, 161,  81,  96, 210,  68, 196,   9, 150,
200  	  0, 126, 124, 144, 240, 224, 245, 146,   6, 154, 200, 109,
201  	210, 192,   8, 114,  68, 249,  53,  27,  52, 106,  70,  30,
202  	 10, 146, 117, 251, 180, 247, 236, 108
203  };
204  static const unsigned short yoff_b_n[] = {
205  	  1, 163,  98,  40,  95,  65,  58, 202,  30,   7, 113, 172,
206  	 23, 151, 198, 149, 129, 210,  49,  20, 176, 161,  29, 101,
207  	 15, 132, 185,  86, 140, 204,  99, 203, 193, 105, 153,  10,
208  	 88, 209, 143, 179, 136,  66, 221,  43,  70, 102, 178, 230,
209  	225, 181, 205,   5,  44, 233, 200, 218,  68,  33, 239, 150,
210  	 35,  51,  89, 115, 241, 219, 231, 131,  22, 245, 100, 109,
211  	 34, 145, 248,  75, 146, 154, 173, 186, 249, 238, 244, 194,
212  	 11, 251,  50, 183,  17, 201, 124, 166,  73,  77, 215,  93,
213  	253, 119, 122,  97, 134, 254,  25, 220, 137, 229,  62,  83,
214  	165, 167, 236, 175, 255, 188,  61, 177,  67, 127, 141, 110,
215  	197, 243,  31, 170, 211, 212, 118, 216, 256,  94, 159, 217,
216  	162, 192, 199,  55, 227, 250, 144,  85, 234, 106,  59, 108,
217  	128,  47, 208, 237,  81,  96, 228, 156, 242, 125,  72, 171,
218  	117,  53, 158,  54,  64, 152, 104, 247, 169,  48, 114,  78,
219  	121, 191,  36, 214, 187, 155,  79,  27,  32,  76,  52, 252,
220  	213,  24,  57,  39, 189, 224,  18, 107, 222, 206, 168, 142,
221  	 16,  38,  26, 126, 235,  12, 157, 148, 223, 112,   9, 182,
222  	111, 103,  84,  71,   8,  19,  13,  63, 246,   6, 207,  74,
223  	240,  56, 133,  91, 184, 180,  42, 164,   4, 138, 135, 160,
224  	123,   3, 232,  37, 120,  28, 195, 174,  92,  90,  21,  82,
225  	  2,  69, 196,  80, 190, 130, 116, 147,  60,  14, 226,  87,
226  	 46,  45, 139,  41
227  };
228  static const unsigned short yoff_b_f[] = {
229  	  2, 203, 156,  47, 118, 214, 107, 106,  45,  93, 212,  20,
230  	111,  73, 162, 251,  97, 215, 249,  53, 211,  19,   3,  89,
231  	 49, 207, 101,  67, 151, 130, 223,  23, 189, 202, 178, 239,
232  	253, 127, 204,  49,  76, 236,  82, 137, 232, 157,  65,  79,
233  	 96, 161, 176, 130, 161,  30,  47,   9, 189, 247,  61, 226,
234  	248,  90, 107,  64,   0,  88, 131, 243, 133,  59, 113, 115,
235  	 17, 236,  33, 213,  12, 191, 111,  19, 251,  61, 103, 208,
236  	 57,  35, 148, 248,  47, 116,  65, 119, 249, 178, 143,  40,
237  	189, 129,   8, 163, 204, 227, 230, 196, 205, 122, 151,  45,
238  	187,  19, 227,  72, 247, 125, 111, 121, 140, 220,   6, 107,
239  	 77,  69,  10, 101,  21,  65, 149, 171, 255,  54, 101, 210,
240  	139,  43, 150, 151, 212, 164,  45, 237, 146, 184,  95,   6,
241  	160,  42,   8, 204,  46, 238, 254, 168, 208,  50, 156, 190,
242  	106, 127,  34, 234,  68,  55,  79,  18,   4, 130,  53, 208,
243  	181,  21, 175, 120,  25, 100, 192, 178, 161,  96,  81, 127,
244  	 96, 227, 210, 248,  68,  10, 196,  31,   9, 167, 150, 193,
245  	  0, 169, 126,  14, 124, 198, 144, 142, 240,  21, 224,  44,
246  	245,  66, 146, 238,   6, 196, 154,  49, 200, 222, 109,   9,
247  	210, 141, 192, 138,   8,  79, 114, 217,  68, 128, 249,  94,
248  	 53,  30,  27,  61,  52, 135, 106, 212,  70, 238,  30, 185,
249  	 10, 132, 146, 136, 117,  37, 251, 150, 180, 188, 247, 156,
250  	236, 192, 108,  86
251  };
252  #define INNER(l, h, mm)   (((u32)((l) * (mm)) & 0xFFFFU) \
253                            + ((u32)((h) * (mm)) << 16))
254  #define W_SMALL(sb, o1, o2, mm) \
255  	(INNER(q[8 * (sb) + 2 * 0 + o1], q[8 * (sb) + 2 * 0 + o2], mm), \
256  	 INNER(q[8 * (sb) + 2 * 1 + o1], q[8 * (sb) + 2 * 1 + o2], mm), \
257  	 INNER(q[8 * (sb) + 2 * 2 + o1], q[8 * (sb) + 2 * 2 + o2], mm), \
258  	 INNER(q[8 * (sb) + 2 * 3 + o1], q[8 * (sb) + 2 * 3 + o2], mm)
259  #define WS_0_0   W_SMALL( 4,    0,    1, 185)
260  #define WS_0_1   W_SMALL( 6,    0,    1, 185)
261  #define WS_0_2   W_SMALL( 0,    0,    1, 185)
262  #define WS_0_3   W_SMALL( 2,    0,    1, 185)
263  #define WS_0_4   W_SMALL( 7,    0,    1, 185)
264  #define WS_0_5   W_SMALL( 5,    0,    1, 185)
265  #define WS_0_6   W_SMALL( 3,    0,    1, 185)
266  #define WS_0_7   W_SMALL( 1,    0,    1, 185)
267  #define WS_1_0   W_SMALL(15,    0,    1, 185)
268  #define WS_1_1   W_SMALL(11,    0,    1, 185)
269  #define WS_1_2   W_SMALL(12,    0,    1, 185)
270  #define WS_1_3   W_SMALL( 8,    0,    1, 185)
271  #define WS_1_4   W_SMALL( 9,    0,    1, 185)
272  #define WS_1_5   W_SMALL(13,    0,    1, 185)
273  #define WS_1_6   W_SMALL(10,    0,    1, 185)
274  #define WS_1_7   W_SMALL(14,    0,    1, 185)
275  #define WS_2_0   W_SMALL(17, -128,  -64, 233)
276  #define WS_2_1   W_SMALL(18, -128,  -64, 233)
277  #define WS_2_2   W_SMALL(23, -128,  -64, 233)
278  #define WS_2_3   W_SMALL(20, -128,  -64, 233)
279  #define WS_2_4   W_SMALL(22, -128,  -64, 233)
280  #define WS_2_5   W_SMALL(21, -128,  -64, 233)
281  #define WS_2_6   W_SMALL(16, -128,  -64, 233)
282  #define WS_2_7   W_SMALL(19, -128,  -64, 233)
283  #define WS_3_0   W_SMALL(30, -191, -127, 233)
284  #define WS_3_1   W_SMALL(24, -191, -127, 233)
285  #define WS_3_2   W_SMALL(25, -191, -127, 233)
286  #define WS_3_3   W_SMALL(31, -191, -127, 233)
287  #define WS_3_4   W_SMALL(27, -191, -127, 233)
288  #define WS_3_5   W_SMALL(29, -191, -127, 233)
289  #define WS_3_6   W_SMALL(28, -191, -127, 233)
290  #define WS_3_7   W_SMALL(26, -191, -127, 233)
291  #define W_BIG(sb, o1, o2, mm) \
292  	(INNER(q[16 * (sb) + 2 * 0 + o1], q[16 * (sb) + 2 * 0 + o2], mm), \
293  	 INNER(q[16 * (sb) + 2 * 1 + o1], q[16 * (sb) + 2 * 1 + o2], mm), \
294  	 INNER(q[16 * (sb) + 2 * 2 + o1], q[16 * (sb) + 2 * 2 + o2], mm), \
295  	 INNER(q[16 * (sb) + 2 * 3 + o1], q[16 * (sb) + 2 * 3 + o2], mm), \
296  	 INNER(q[16 * (sb) + 2 * 4 + o1], q[16 * (sb) + 2 * 4 + o2], mm), \
297  	 INNER(q[16 * (sb) + 2 * 5 + o1], q[16 * (sb) + 2 * 5 + o2], mm), \
298  	 INNER(q[16 * (sb) + 2 * 6 + o1], q[16 * (sb) + 2 * 6 + o2], mm), \
299  	 INNER(q[16 * (sb) + 2 * 7 + o1], q[16 * (sb) + 2 * 7 + o2], mm)
300  #define WB_0_0   W_BIG( 4,    0,    1, 185)
301  #define WB_0_1   W_BIG( 6,    0,    1, 185)
302  #define WB_0_2   W_BIG( 0,    0,    1, 185)
303  #define WB_0_3   W_BIG( 2,    0,    1, 185)
304  #define WB_0_4   W_BIG( 7,    0,    1, 185)
305  #define WB_0_5   W_BIG( 5,    0,    1, 185)
306  #define WB_0_6   W_BIG( 3,    0,    1, 185)
307  #define WB_0_7   W_BIG( 1,    0,    1, 185)
308  #define WB_1_0   W_BIG(15,    0,    1, 185)
309  #define WB_1_1   W_BIG(11,    0,    1, 185)
310  #define WB_1_2   W_BIG(12,    0,    1, 185)
311  #define WB_1_3   W_BIG( 8,    0,    1, 185)
312  #define WB_1_4   W_BIG( 9,    0,    1, 185)
313  #define WB_1_5   W_BIG(13,    0,    1, 185)
314  #define WB_1_6   W_BIG(10,    0,    1, 185)
315  #define WB_1_7   W_BIG(14,    0,    1, 185)
316  #define WB_2_0   W_BIG(17, -256, -128, 233)
317  #define WB_2_1   W_BIG(18, -256, -128, 233)
318  #define WB_2_2   W_BIG(23, -256, -128, 233)
319  #define WB_2_3   W_BIG(20, -256, -128, 233)
320  #define WB_2_4   W_BIG(22, -256, -128, 233)
321  #define WB_2_5   W_BIG(21, -256, -128, 233)
322  #define WB_2_6   W_BIG(16, -256, -128, 233)
323  #define WB_2_7   W_BIG(19, -256, -128, 233)
324  #define WB_3_0   W_BIG(30, -383, -255, 233)
325  #define WB_3_1   W_BIG(24, -383, -255, 233)
326  #define WB_3_2   W_BIG(25, -383, -255, 233)
327  #define WB_3_3   W_BIG(31, -383, -255, 233)
328  #define WB_3_4   W_BIG(27, -383, -255, 233)
329  #define WB_3_5   W_BIG(29, -383, -255, 233)
330  #define WB_3_6   W_BIG(28, -383, -255, 233)
331  #define WB_3_7   W_BIG(26, -383, -255, 233)
332  #define IF(x, y, z)    ((((y) ^ (z)) & (x)) ^ (z))
333  #define MAJ(x, y, z)   (((x) & (y)) | (((x) | (y)) & (z)))
334  #define PP4_0_0   1
335  #define PP4_0_1   0
336  #define PP4_0_2   3
337  #define PP4_0_3   2
338  #define PP4_1_0   2
339  #define PP4_1_1   3
340  #define PP4_1_2   0
341  #define PP4_1_3   1
342  #define PP4_2_0   3
343  #define PP4_2_1   2
344  #define PP4_2_2   1
345  #define PP4_2_3   0
346  #define PP8_0_0   1
347  #define PP8_0_1   0
348  #define PP8_0_2   3
349  #define PP8_0_3   2
350  #define PP8_0_4   5
351  #define PP8_0_5   4
352  #define PP8_0_6   7
353  #define PP8_0_7   6
354  #define PP8_1_0   6
355  #define PP8_1_1   7
356  #define PP8_1_2   4
357  #define PP8_1_3   5
358  #define PP8_1_4   2
359  #define PP8_1_5   3
360  #define PP8_1_6   0
361  #define PP8_1_7   1
362  #define PP8_2_0   2
363  #define PP8_2_1   3
364  #define PP8_2_2   0
365  #define PP8_2_3   1
366  #define PP8_2_4   6
367  #define PP8_2_5   7
368  #define PP8_2_6   4
369  #define PP8_2_7   5
370  #define PP8_3_0   3
371  #define PP8_3_1   2
372  #define PP8_3_2   1
373  #define PP8_3_3   0
374  #define PP8_3_4   7
375  #define PP8_3_5   6
376  #define PP8_3_6   5
377  #define PP8_3_7   4
378  #define PP8_4_0   5
379  #define PP8_4_1   4
380  #define PP8_4_2   7
381  #define PP8_4_3   6
382  #define PP8_4_4   1
383  #define PP8_4_5   0
384  #define PP8_4_6   3
385  #define PP8_4_7   2
386  #define PP8_5_0   7
387  #define PP8_5_1   6
388  #define PP8_5_2   5
389  #define PP8_5_3   4
390  #define PP8_5_4   3
391  #define PP8_5_5   2
392  #define PP8_5_6   1
393  #define PP8_5_7   0
394  #define PP8_6_0   4
395  #define PP8_6_1   5
396  #define PP8_6_2   6
397  #define PP8_6_3   7
398  #define PP8_6_4   0
399  #define PP8_6_5   1
400  #define PP8_6_6   2
401  #define PP8_6_7   3
402  #if SPH_SIMD_NOCOPY
403  #define DECL_STATE_SMALL
404  #define READ_STATE_SMALL(sc)
405  #define WRITE_STATE_SMALL(sc)
406  #define DECL_STATE_BIG
407  #define READ_STATE_BIG(sc)
408  #define WRITE_STATE_BIG(sc)
409  #else
410  #define DECL_STATE_SMALL   \
411  	u32 A0, A1, A2, A3, B0, B1, B2, B3, C0, C1, C2, C3, D0, D1, D2, D3;
412  #define READ_STATE_SMALL(sc)   do { \
413  		A0 = (sc)->state[ 0]; \
414  		A1 = (sc)->state[ 1]; \
415  		A2 = (sc)->state[ 2]; \
416  		A3 = (sc)->state[ 3]; \
417  		B0 = (sc)->state[ 4]; \
418  		B1 = (sc)->state[ 5]; \
419  		B2 = (sc)->state[ 6]; \
420  		B3 = (sc)->state[ 7]; \
421  		C0 = (sc)->state[ 8]; \
422  		C1 = (sc)->state[ 9]; \
423  		C2 = (sc)->state[10]; \
424  		C3 = (sc)->state[11]; \
425  		D0 = (sc)->state[12]; \
426  		D1 = (sc)->state[13]; \
427  		D2 = (sc)->state[14]; \
428  		D3 = (sc)->state[15]; \
429  	} while (0)
430  #define WRITE_STATE_SMALL(sc)   do { \
431  		(sc)->state[ 0] = A0; \
432  		(sc)->state[ 1] = A1; \
433  		(sc)->state[ 2] = A2; \
434  		(sc)->state[ 3] = A3; \
435  		(sc)->state[ 4] = B0; \
436  		(sc)->state[ 5] = B1; \
437  		(sc)->state[ 6] = B2; \
438  		(sc)->state[ 7] = B3; \
439  		(sc)->state[ 8] = C0; \
440  		(sc)->state[ 9] = C1; \
441  		(sc)->state[10] = C2; \
442  		(sc)->state[11] = C3; \
443  		(sc)->state[12] = D0; \
444  		(sc)->state[13] = D1; \
445  		(sc)->state[14] = D2; \
446  		(sc)->state[15] = D3; \
447  	} while (0)
448  #define DECL_STATE_BIG   \
449  	u32 A0, A1, A2, A3, A4, A5, A6, A7; \
450  	u32 B0, B1, B2, B3, B4, B5, B6, B7; \
451  	u32 C0, C1, C2, C3, C4, C5, C6, C7; \
452  	u32 D0, D1, D2, D3, D4, D5, D6, D7;
453  #define READ_STATE_BIG(sc)   do { \
454  		A0 = (sc)->state[ 0]; \
455  		A1 = (sc)->state[ 1]; \
456  		A2 = (sc)->state[ 2]; \
457  		A3 = (sc)->state[ 3]; \
458  		A4 = (sc)->state[ 4]; \
459  		A5 = (sc)->state[ 5]; \
460  		A6 = (sc)->state[ 6]; \
461  		A7 = (sc)->state[ 7]; \
462  		B0 = (sc)->state[ 8]; \
463  		B1 = (sc)->state[ 9]; \
464  		B2 = (sc)->state[10]; \
465  		B3 = (sc)->state[11]; \
466  		B4 = (sc)->state[12]; \
467  		B5 = (sc)->state[13]; \
468  		B6 = (sc)->state[14]; \
469  		B7 = (sc)->state[15]; \
470  		C0 = (sc)->state[16]; \
471  		C1 = (sc)->state[17]; \
472  		C2 = (sc)->state[18]; \
473  		C3 = (sc)->state[19]; \
474  		C4 = (sc)->state[20]; \
475  		C5 = (sc)->state[21]; \
476  		C6 = (sc)->state[22]; \
477  		C7 = (sc)->state[23]; \
478  		D0 = (sc)->state[24]; \
479  		D1 = (sc)->state[25]; \
480  		D2 = (sc)->state[26]; \
481  		D3 = (sc)->state[27]; \
482  		D4 = (sc)->state[28]; \
483  		D5 = (sc)->state[29]; \
484  		D6 = (sc)->state[30]; \
485  		D7 = (sc)->state[31]; \
486  	} while (0)
487  #define WRITE_STATE_BIG(sc)   do { \
488  		(sc)->state[ 0] = A0; \
489  		(sc)->state[ 1] = A1; \
490  		(sc)->state[ 2] = A2; \
491  		(sc)->state[ 3] = A3; \
492  		(sc)->state[ 4] = A4; \
493  		(sc)->state[ 5] = A5; \
494  		(sc)->state[ 6] = A6; \
495  		(sc)->state[ 7] = A7; \
496  		(sc)->state[ 8] = B0; \
497  		(sc)->state[ 9] = B1; \
498  		(sc)->state[10] = B2; \
499  		(sc)->state[11] = B3; \
500  		(sc)->state[12] = B4; \
501  		(sc)->state[13] = B5; \
502  		(sc)->state[14] = B6; \
503  		(sc)->state[15] = B7; \
504  		(sc)->state[16] = C0; \
505  		(sc)->state[17] = C1; \
506  		(sc)->state[18] = C2; \
507  		(sc)->state[19] = C3; \
508  		(sc)->state[20] = C4; \
509  		(sc)->state[21] = C5; \
510  		(sc)->state[22] = C6; \
511  		(sc)->state[23] = C7; \
512  		(sc)->state[24] = D0; \
513  		(sc)->state[25] = D1; \
514  		(sc)->state[26] = D2; \
515  		(sc)->state[27] = D3; \
516  		(sc)->state[28] = D4; \
517  		(sc)->state[29] = D5; \
518  		(sc)->state[30] = D6; \
519  		(sc)->state[31] = D7; \
520  	} while (0)
521  #endif
522  #define STEP_ELT(n, w, fun, s, ppb)   do { \
523  		u32 tt = T32(D ## n + (w) + fun(A ## n, B ## n, C ## n)); \
524  		A ## n = T32(ROL32(tt, s) + XCAT(tA, XCAT(ppb, n))); \
525  		D ## n = C ## n; \
526  		C ## n = B ## n; \
527  		B ## n = tA ## n; \
528  	} while (0)
529  #define STEP_SMALL(w0, w1, w2, w3, fun, r, s, pp4b)   do { \
530  		u32 tA0 = ROL32(A0, r); \
531  		u32 tA1 = ROL32(A1, r); \
532  		u32 tA2 = ROL32(A2, r); \
533  		u32 tA3 = ROL32(A3, r); \
534  		STEP_ELT(0, w0, fun, s, pp4b); \
535  		STEP_ELT(1, w1, fun, s, pp4b); \
536  		STEP_ELT(2, w2, fun, s, pp4b); \
537  		STEP_ELT(3, w3, fun, s, pp4b); \
538  	} while (0)
539  #define STEP_BIG(w0, w1, w2, w3, w4, w5, w6, w7, fun, r, s, pp8b)   do { \
540  		u32 tA0 = ROL32(A0, r); \
541  		u32 tA1 = ROL32(A1, r); \
542  		u32 tA2 = ROL32(A2, r); \
543  		u32 tA3 = ROL32(A3, r); \
544  		u32 tA4 = ROL32(A4, r); \
545  		u32 tA5 = ROL32(A5, r); \
546  		u32 tA6 = ROL32(A6, r); \
547  		u32 tA7 = ROL32(A7, r); \
548  		STEP_ELT(0, w0, fun, s, pp8b); \
549  		STEP_ELT(1, w1, fun, s, pp8b); \
550  		STEP_ELT(2, w2, fun, s, pp8b); \
551  		STEP_ELT(3, w3, fun, s, pp8b); \
552  		STEP_ELT(4, w4, fun, s, pp8b); \
553  		STEP_ELT(5, w5, fun, s, pp8b); \
554  		STEP_ELT(6, w6, fun, s, pp8b); \
555  		STEP_ELT(7, w7, fun, s, pp8b); \
556  	} while (0)
557  #define M3_0_0   0_
558  #define M3_1_0   1_
559  #define M3_2_0   2_
560  #define M3_3_0   0_
561  #define M3_4_0   1_
562  #define M3_5_0   2_
563  #define M3_6_0   0_
564  #define M3_7_0   1_
565  #define M3_0_1   1_
566  #define M3_1_1   2_
567  #define M3_2_1   0_
568  #define M3_3_1   1_
569  #define M3_4_1   2_
570  #define M3_5_1   0_
571  #define M3_6_1   1_
572  #define M3_7_1   2_
573  #define M3_0_2   2_
574  #define M3_1_2   0_
575  #define M3_2_2   1_
576  #define M3_3_2   2_
577  #define M3_4_2   0_
578  #define M3_5_2   1_
579  #define M3_6_2   2_
580  #define M3_7_2   0_
581  #define STEP_SMALL_(w, fun, r, s, pp4b)   STEP_SMALL w, fun, r, s, pp4b)
582  #define ONE_ROUND_SMALL(ri, isp, p0, p1, p2, p3)   do { \
583  		STEP_SMALL_(WS_ ## ri ## 0, \
584  			IF,  p0, p1, XCAT(PP4_, M3_0_ ## isp)); \
585  		STEP_SMALL_(WS_ ## ri ## 1, \
586  			IF,  p1, p2, XCAT(PP4_, M3_1_ ## isp)); \
587  		STEP_SMALL_(WS_ ## ri ## 2, \
588  			IF,  p2, p3, XCAT(PP4_, M3_2_ ## isp)); \
589  		STEP_SMALL_(WS_ ## ri ## 3, \
590  			IF,  p3, p0, XCAT(PP4_, M3_3_ ## isp)); \
591  		STEP_SMALL_(WS_ ## ri ## 4, \
592  			MAJ, p0, p1, XCAT(PP4_, M3_4_ ## isp)); \
593  		STEP_SMALL_(WS_ ## ri ## 5, \
594  			MAJ, p1, p2, XCAT(PP4_, M3_5_ ## isp)); \
595  		STEP_SMALL_(WS_ ## ri ## 6, \
596  			MAJ, p2, p3, XCAT(PP4_, M3_6_ ## isp)); \
597  		STEP_SMALL_(WS_ ## ri ## 7, \
598  			MAJ, p3, p0, XCAT(PP4_, M3_7_ ## isp)); \
599  	} while (0)
600  #define M7_0_0   0_
601  #define M7_1_0   1_
602  #define M7_2_0   2_
603  #define M7_3_0   3_
604  #define M7_4_0   4_
605  #define M7_5_0   5_
606  #define M7_6_0   6_
607  #define M7_7_0   0_
608  #define M7_0_1   1_
609  #define M7_1_1   2_
610  #define M7_2_1   3_
611  #define M7_3_1   4_
612  #define M7_4_1   5_
613  #define M7_5_1   6_
614  #define M7_6_1   0_
615  #define M7_7_1   1_
616  #define M7_0_2   2_
617  #define M7_1_2   3_
618  #define M7_2_2   4_
619  #define M7_3_2   5_
620  #define M7_4_2   6_
621  #define M7_5_2   0_
622  #define M7_6_2   1_
623  #define M7_7_2   2_
624  #define M7_0_3   3_
625  #define M7_1_3   4_
626  #define M7_2_3   5_
627  #define M7_3_3   6_
628  #define M7_4_3   0_
629  #define M7_5_3   1_
630  #define M7_6_3   2_
631  #define M7_7_3   3_
632  #define STEP_BIG_(w, fun, r, s, pp8b)   STEP_BIG w, fun, r, s, pp8b)
633  #define ONE_ROUND_BIG(ri, isp, p0, p1, p2, p3)   do { \
634  		STEP_BIG_(WB_ ## ri ## 0, \
635  			IF,  p0, p1, XCAT(PP8_, M7_0_ ## isp)); \
636  		STEP_BIG_(WB_ ## ri ## 1, \
637  			IF,  p1, p2, XCAT(PP8_, M7_1_ ## isp)); \
638  		STEP_BIG_(WB_ ## ri ## 2, \
639  			IF,  p2, p3, XCAT(PP8_, M7_2_ ## isp)); \
640  		STEP_BIG_(WB_ ## ri ## 3, \
641  			IF,  p3, p0, XCAT(PP8_, M7_3_ ## isp)); \
642  		STEP_BIG_(WB_ ## ri ## 4, \
643  			MAJ, p0, p1, XCAT(PP8_, M7_4_ ## isp)); \
644  		STEP_BIG_(WB_ ## ri ## 5, \
645  			MAJ, p1, p2, XCAT(PP8_, M7_5_ ## isp)); \
646  		STEP_BIG_(WB_ ## ri ## 6, \
647  			MAJ, p2, p3, XCAT(PP8_, M7_6_ ## isp)); \
648  		STEP_BIG_(WB_ ## ri ## 7, \
649  			MAJ, p3, p0, XCAT(PP8_, M7_7_ ## isp)); \
650  	} while (0)
651  #if SPH_SMALL_FOOTPRINT_SIMD
652  #define A0   state[ 0]
653  #define A1   state[ 1]
654  #define A2   state[ 2]
655  #define A3   state[ 3]
656  #define B0   state[ 4]
657  #define B1   state[ 5]
658  #define B2   state[ 6]
659  #define B3   state[ 7]
660  #define C0   state[ 8]
661  #define C1   state[ 9]
662  #define C2   state[10]
663  #define C3   state[11]
664  #define D0   state[12]
665  #define D1   state[13]
666  #define D2   state[14]
667  #define D3   state[15]
668  #define STEP2_ELT(n, w, fun, s, ppb)   do { \
669  		u32 tt = T32(D ## n + (w) + fun(A ## n, B ## n, C ## n)); \
670  		A ## n = T32(ROL32(tt, s) + tA[(ppb) ^ n]); \
671  		D ## n = C ## n; \
672  		C ## n = B ## n; \
673  		B ## n = tA[n]; \
674  	} while (0)
675  #define STEP2_SMALL(w0, w1, w2, w3, fun, r, s, pp4b)   do { \
676  		u32 tA[4]; \
677  		tA[0] = ROL32(A0, r); \
678  		tA[1] = ROL32(A1, r); \
679  		tA[2] = ROL32(A2, r); \
680  		tA[3] = ROL32(A3, r); \
681  		STEP2_ELT(0, w0, fun, s, pp4b); \
682  		STEP2_ELT(1, w1, fun, s, pp4b); \
683  		STEP2_ELT(2, w2, fun, s, pp4b); \
684  		STEP2_ELT(3, w3, fun, s, pp4b); \
685  	} while (0)
686  static void
687  one_round_small(u32 *state, u32 *w, int isp, int p0, int p1, int p2, int p3)
688  {
689  	static const int pp4k[] = { 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2 };
690  	STEP2_SMALL(w[ 0], w[ 1], w[ 2], w[ 3], IF,  p0, p1, pp4k[isp + 0]);
691  	STEP2_SMALL(w[ 4], w[ 5], w[ 6], w[ 7], IF,  p1, p2, pp4k[isp + 1]);
692  	STEP2_SMALL(w[ 8], w[ 9], w[10], w[11], IF,  p2, p3, pp4k[isp + 2]);
693  	STEP2_SMALL(w[12], w[13], w[14], w[15], IF,  p3, p0, pp4k[isp + 3]);
694  	STEP2_SMALL(w[16], w[17], w[18], w[19], MAJ, p0, p1, pp4k[isp + 4]);
695  	STEP2_SMALL(w[20], w[21], w[22], w[23], MAJ, p1, p2, pp4k[isp + 5]);
696  	STEP2_SMALL(w[24], w[25], w[26], w[27], MAJ, p2, p3, pp4k[isp + 6]);
697  	STEP2_SMALL(w[28], w[29], w[30], w[31], MAJ, p3, p0, pp4k[isp + 7]);
698  }
699  static void
700  compress_small(sph_simd_small_context *sc, int last)
701  {
702  	unsigned char *x;
703  	s32 q[128];
704  	int i;
705  	u32 w[32];
706  	u32 state[16];
707  	size_t u;
708  	static const size_t wsp[32] = {
709  		 4 << 3,  6 << 3,  0 << 3,  2 << 3,
710  		 7 << 3,  5 << 3,  3 << 3,  1 << 3,
711  		15 << 3, 11 << 3, 12 << 3,  8 << 3,
712  		 9 << 3, 13 << 3, 10 << 3, 14 << 3,
713  		17 << 3, 18 << 3, 23 << 3, 20 << 3,
714  		22 << 3, 21 << 3, 16 << 3, 19 << 3,
715  		30 << 3, 24 << 3, 25 << 3, 31 << 3,
716  		27 << 3, 29 << 3, 28 << 3, 26 << 3
717  	};
718  	x = sc->buf;
719  	FFT128(0, 1, 0, ll);
720  	if (last) {
721  		for (i = 0; i < 128; i ++) {
722  			s32 tq;
723  			tq = q[i] + yoff_s_f[i];
724  			tq = REDS2(tq);
725  			tq = REDS1(tq);
726  			tq = REDS1(tq);
727  			q[i] = (tq <= 128 ? tq : tq - 257);
728  		}
729  	} else {
730  		for (i = 0; i < 128; i ++) {
731  			s32 tq;
732  			tq = q[i] + yoff_s_n[i];
733  			tq = REDS2(tq);
734  			tq = REDS1(tq);
735  			tq = REDS1(tq);
736  			q[i] = (tq <= 128 ? tq : tq - 257);
737  		}
738  	}
739  	for (i = 0; i < 16; i += 4) {
740  		state[i + 0] = sc->state[i + 0]
741  			^ sph_dec32le_aligned(x + 4 * (i + 0));
742  		state[i + 1] = sc->state[i + 1]
743  			^ sph_dec32le_aligned(x + 4 * (i + 1));
744  		state[i + 2] = sc->state[i + 2]
745  			^ sph_dec32le_aligned(x + 4 * (i + 2));
746  		state[i + 3] = sc->state[i + 3]
747  			^ sph_dec32le_aligned(x + 4 * (i + 3));
748  	}
749  #define WSREAD(sb, o1, o2, mm)   do { \
750  		for (u = 0; u < 32; u += 4) { \
751  			size_t v = wsp[(u >> 2) + (sb)]; \
752  			w[u + 0] = INNER(q[v + 2 * 0 + (o1)], \
753  				q[v + 2 * 0 + (o2)], mm); \
754  			w[u + 1] = INNER(q[v + 2 * 1 + (o1)], \
755  				q[v + 2 * 1 + (o2)], mm); \
756  			w[u + 2] = INNER(q[v + 2 * 2 + (o1)], \
757  				q[v + 2 * 2 + (o2)], mm); \
758  			w[u + 3] = INNER(q[v + 2 * 3 + (o1)], \
759  				q[v + 2 * 3 + (o2)], mm); \
760  		} \
761  	} while (0)
762  	WSREAD( 0,    0,    1, 185);
763  	one_round_small(state, w, 0,  3, 23, 17, 27);
764  	WSREAD( 8,    0,    1, 185);
765  	one_round_small(state, w, 2, 28, 19, 22,  7);
766  	WSREAD(16, -128,  -64, 233);
767  	one_round_small(state, w, 1, 29,  9, 15,  5);
768  	WSREAD(24, -191, -127, 233);
769  	one_round_small(state, w, 0,  4, 13, 10, 25);
770  #undef WSREAD
771  	STEP_SMALL(sc->state[ 0], sc->state[ 1], sc->state[ 2], sc->state[ 3],
772  		IF,  4, 13, PP4_2_);
773  	STEP_SMALL(sc->state[ 4], sc->state[ 5], sc->state[ 6], sc->state[ 7],
774  		IF, 13, 10, PP4_0_);
775  	STEP_SMALL(sc->state[ 8], sc->state[ 9], sc->state[10], sc->state[11],
776  		IF, 10, 25, PP4_1_);
777  	STEP_SMALL(sc->state[12], sc->state[13], sc->state[14], sc->state[15],
778  		IF, 25,  4, PP4_2_);
779  	memcpy(sc->state, state, sizeof state);
780  }
781  #undef A0
782  #undef A1
783  #undef A2
784  #undef A3
785  #undef B0
786  #undef B1
787  #undef B2
788  #undef B3
789  #undef C0
790  #undef C1
791  #undef C2
792  #undef C3
793  #undef D0
794  #undef D1
795  #undef D2
796  #undef D3
797  #else
798  #if SPH_SIMD_NOCOPY
799  #define A0   (sc->state[ 0])
800  #define A1   (sc->state[ 1])
801  #define A2   (sc->state[ 2])
802  #define A3   (sc->state[ 3])
803  #define B0   (sc->state[ 4])
804  #define B1   (sc->state[ 5])
805  #define B2   (sc->state[ 6])
806  #define B3   (sc->state[ 7])
807  #define C0   (sc->state[ 8])
808  #define C1   (sc->state[ 9])
809  #define C2   (sc->state[10])
810  #define C3   (sc->state[11])
811  #define D0   (sc->state[12])
812  #define D1   (sc->state[13])
813  #define D2   (sc->state[14])
814  #define D3   (sc->state[15])
815  #endif
816  static void
817  compress_small(sph_simd_small_context *sc, int last)
818  {
819  	unsigned char *x;
820  	s32 q[128];
821  	int i;
822  	DECL_STATE_SMALL
823  #if SPH_SIMD_NOCOPY
824  	sph_u32 saved[16];
825  #endif
826  #if SPH_SIMD_NOCOPY
827  	memcpy(saved, sc->state, sizeof saved);
828  #endif
829  	x = sc->buf;
830  	FFT128(0, 1, 0, ll);
831  	if (last) {
832  		for (i = 0; i < 128; i ++) {
833  			s32 tq;
834  			tq = q[i] + yoff_s_f[i];
835  			tq = REDS2(tq);
836  			tq = REDS1(tq);
837  			tq = REDS1(tq);
838  			q[i] = (tq <= 128 ? tq : tq - 257);
839  		}
840  	} else {
841  		for (i = 0; i < 128; i ++) {
842  			s32 tq;
843  			tq = q[i] + yoff_s_n[i];
844  			tq = REDS2(tq);
845  			tq = REDS1(tq);
846  			tq = REDS1(tq);
847  			q[i] = (tq <= 128 ? tq : tq - 257);
848  		}
849  	}
850  	READ_STATE_SMALL(sc);
851  	A0 ^= sph_dec32le_aligned(x +  0);
852  	A1 ^= sph_dec32le_aligned(x +  4);
853  	A2 ^= sph_dec32le_aligned(x +  8);
854  	A3 ^= sph_dec32le_aligned(x + 12);
855  	B0 ^= sph_dec32le_aligned(x + 16);
856  	B1 ^= sph_dec32le_aligned(x + 20);
857  	B2 ^= sph_dec32le_aligned(x + 24);
858  	B3 ^= sph_dec32le_aligned(x + 28);
859  	C0 ^= sph_dec32le_aligned(x + 32);
860  	C1 ^= sph_dec32le_aligned(x + 36);
861  	C2 ^= sph_dec32le_aligned(x + 40);
862  	C3 ^= sph_dec32le_aligned(x + 44);
863  	D0 ^= sph_dec32le_aligned(x + 48);
864  	D1 ^= sph_dec32le_aligned(x + 52);
865  	D2 ^= sph_dec32le_aligned(x + 56);
866  	D3 ^= sph_dec32le_aligned(x + 60);
867  	ONE_ROUND_SMALL(0_, 0,  3, 23, 17, 27);
868  	ONE_ROUND_SMALL(1_, 2, 28, 19, 22,  7);
869  	ONE_ROUND_SMALL(2_, 1, 29,  9, 15,  5);
870  	ONE_ROUND_SMALL(3_, 0,  4, 13, 10, 25);
871  #if SPH_SIMD_NOCOPY
872  	STEP_SMALL(saved[ 0], saved[ 1], saved[ 2], saved[ 3],
873  		IF,  4, 13, PP4_2_);
874  	STEP_SMALL(saved[ 4], saved[ 5], saved[ 6], saved[ 7],
875  		IF, 13, 10, PP4_0_);
876  	STEP_SMALL(saved[ 8], saved[ 9], saved[10], saved[11],
877  		IF, 10, 25, PP4_1_);
878  	STEP_SMALL(saved[12], saved[13], saved[14], saved[15],
879  		IF, 25,  4, PP4_2_);
880  #else
881  	STEP_SMALL(sc->state[ 0], sc->state[ 1], sc->state[ 2], sc->state[ 3],
882  		IF,  4, 13, PP4_2_);
883  	STEP_SMALL(sc->state[ 4], sc->state[ 5], sc->state[ 6], sc->state[ 7],
884  		IF, 13, 10, PP4_0_);
885  	STEP_SMALL(sc->state[ 8], sc->state[ 9], sc->state[10], sc->state[11],
886  		IF, 10, 25, PP4_1_);
887  	STEP_SMALL(sc->state[12], sc->state[13], sc->state[14], sc->state[15],
888  		IF, 25,  4, PP4_2_);
889  	WRITE_STATE_SMALL(sc);
890  #endif
891  }
892  #if SPH_SIMD_NOCOPY
893  #undef A0
894  #undef A1
895  #undef A2
896  #undef A3
897  #undef B0
898  #undef B1
899  #undef B2
900  #undef B3
901  #undef C0
902  #undef C1
903  #undef C2
904  #undef C3
905  #undef D0
906  #undef D1
907  #undef D2
908  #undef D3
909  #endif
910  #endif
911  #if SPH_SMALL_FOOTPRINT_SIMD
912  #define A0   state[ 0]
913  #define A1   state[ 1]
914  #define A2   state[ 2]
915  #define A3   state[ 3]
916  #define A4   state[ 4]
917  #define A5   state[ 5]
918  #define A6   state[ 6]
919  #define A7   state[ 7]
920  #define B0   state[ 8]
921  #define B1   state[ 9]
922  #define B2   state[10]
923  #define B3   state[11]
924  #define B4   state[12]
925  #define B5   state[13]
926  #define B6   state[14]
927  #define B7   state[15]
928  #define C0   state[16]
929  #define C1   state[17]
930  #define C2   state[18]
931  #define C3   state[19]
932  #define C4   state[20]
933  #define C5   state[21]
934  #define C6   state[22]
935  #define C7   state[23]
936  #define D0   state[24]
937  #define D1   state[25]
938  #define D2   state[26]
939  #define D3   state[27]
940  #define D4   state[28]
941  #define D5   state[29]
942  #define D6   state[30]
943  #define D7   state[31]
944  #define STEP2_BIG(w0, w1, w2, w3, w4, w5, w6, w7, fun, r, s, pp8b)   do { \
945  		u32 tA[8]; \
946  		tA[0] = ROL32(A0, r); \
947  		tA[1] = ROL32(A1, r); \
948  		tA[2] = ROL32(A2, r); \
949  		tA[3] = ROL32(A3, r); \
950  		tA[4] = ROL32(A4, r); \
951  		tA[5] = ROL32(A5, r); \
952  		tA[6] = ROL32(A6, r); \
953  		tA[7] = ROL32(A7, r); \
954  		STEP2_ELT(0, w0, fun, s, pp8b); \
955  		STEP2_ELT(1, w1, fun, s, pp8b); \
956  		STEP2_ELT(2, w2, fun, s, pp8b); \
957  		STEP2_ELT(3, w3, fun, s, pp8b); \
958  		STEP2_ELT(4, w4, fun, s, pp8b); \
959  		STEP2_ELT(5, w5, fun, s, pp8b); \
960  		STEP2_ELT(6, w6, fun, s, pp8b); \
961  		STEP2_ELT(7, w7, fun, s, pp8b); \
962  	} while (0)
963  static void
964  one_round_big(u32 *state, u32 *w, int isp, int p0, int p1, int p2, int p3)
965  {
966  	static const int pp8k[] = { 1, 6, 2, 3, 5, 7, 4, 1, 6, 2, 3 };
967  	STEP2_BIG(w[ 0], w[ 1], w[ 2], w[ 3], w[ 4], w[ 5], w[ 6], w[ 7],
968  		IF,  p0, p1, pp8k[isp + 0]);
969  	STEP2_BIG(w[ 8], w[ 9], w[10], w[11], w[12], w[13], w[14], w[15],
970  		IF,  p1, p2, pp8k[isp + 1]);
971  	STEP2_BIG(w[16], w[17], w[18], w[19], w[20], w[21], w[22], w[23],
972  		IF,  p2, p3, pp8k[isp + 2]);
973  	STEP2_BIG(w[24], w[25], w[26], w[27], w[28], w[29], w[30], w[31],
974  		IF,  p3, p0, pp8k[isp + 3]);
975  	STEP2_BIG(w[32], w[33], w[34], w[35], w[36], w[37], w[38], w[39],
976  		MAJ, p0, p1, pp8k[isp + 4]);
<span onclick='openModal()' class='match'>977  	STEP2_BIG(w[40], w[41], w[42], w[43], w[44], w[45], w[46], w[47],
978  		MAJ, p1, p2, pp8k[isp + 5]);
</span>979  	STEP2_BIG(w[48], w[49], w[50], w[51], w[52], w[53], w[54], w[55],
980  		MAJ, p2, p3, pp8k[isp + 6]);
981  	STEP2_BIG(w[56], w[57], w[58], w[59], w[60], w[61], w[62], w[63],
982  		MAJ, p3, p0, pp8k[isp + 7]);
983  }
984  static void
985  compress_big(sph_simd_big_context *sc, int last)
986  {
987  	unsigned char *x;
988  	s32 q[256];
989  	int i;
990  	u32 w[64];
991  	u32 state[32];
992  	size_t u;
993  	static const size_t wbp[32] = {
994  		 4 << 4,  6 << 4,  0 << 4,  2 << 4,
995  		 7 << 4,  5 << 4,  3 << 4,  1 << 4,
996  		15 << 4, 11 << 4, 12 << 4,  8 << 4,
997  		 9 << 4, 13 << 4, 10 << 4, 14 << 4,
998  		17 << 4, 18 << 4, 23 << 4, 20 << 4,
999  		22 << 4, 21 << 4, 16 << 4, 19 << 4,
1000  		30 << 4, 24 << 4, 25 << 4, 31 << 4,
1001  		27 << 4, 29 << 4, 28 << 4, 26 << 4
1002  	};
1003  	x = sc->buf;
1004  	FFT256(0, 1, 0, ll);
1005  	if (last) {
1006  		for (i = 0; i < 256; i ++) {
1007  			s32 tq;
1008  			tq = q[i] + yoff_b_f[i];
1009  			tq = REDS2(tq);
1010  			tq = REDS1(tq);
1011  			tq = REDS1(tq);
1012  			q[i] = (tq <= 128 ? tq : tq - 257);
1013  		}
1014  	} else {
1015  		for (i = 0; i < 256; i ++) {
1016  			s32 tq;
1017  			tq = q[i] + yoff_b_n[i];
1018  			tq = REDS2(tq);
1019  			tq = REDS1(tq);
1020  			tq = REDS1(tq);
1021  			q[i] = (tq <= 128 ? tq : tq - 257);
1022  		}
1023  	}
1024  	for (i = 0; i < 32; i += 8) {
1025  		state[i + 0] = sc->state[i + 0]
1026  			^ sph_dec32le_aligned(x + 4 * (i + 0));
1027  		state[i + 1] = sc->state[i + 1]
1028  			^ sph_dec32le_aligned(x + 4 * (i + 1));
1029  		state[i + 2] = sc->state[i + 2]
1030  			^ sph_dec32le_aligned(x + 4 * (i + 2));
1031  		state[i + 3] = sc->state[i + 3]
1032  			^ sph_dec32le_aligned(x + 4 * (i + 3));
1033  		state[i + 4] = sc->state[i + 4]
1034  			^ sph_dec32le_aligned(x + 4 * (i + 4));
1035  		state[i + 5] = sc->state[i + 5]
1036  			^ sph_dec32le_aligned(x + 4 * (i + 5));
1037  		state[i + 6] = sc->state[i + 6]
1038  			^ sph_dec32le_aligned(x + 4 * (i + 6));
1039  		state[i + 7] = sc->state[i + 7]
1040  			^ sph_dec32le_aligned(x + 4 * (i + 7));
1041  	}
1042  #define WBREAD(sb, o1, o2, mm)   do { \
1043  		for (u = 0; u < 64; u += 8) { \
1044  			size_t v = wbp[(u >> 3) + (sb)]; \
1045  			w[u + 0] = INNER(q[v + 2 * 0 + (o1)], \
1046  				q[v + 2 * 0 + (o2)], mm); \
1047  			w[u + 1] = INNER(q[v + 2 * 1 + (o1)], \
1048  				q[v + 2 * 1 + (o2)], mm); \
1049  			w[u + 2] = INNER(q[v + 2 * 2 + (o1)], \
1050  				q[v + 2 * 2 + (o2)], mm); \
1051  			w[u + 3] = INNER(q[v + 2 * 3 + (o1)], \
1052  				q[v + 2 * 3 + (o2)], mm); \
1053  			w[u + 4] = INNER(q[v + 2 * 4 + (o1)], \
1054  				q[v + 2 * 4 + (o2)], mm); \
1055  			w[u + 5] = INNER(q[v + 2 * 5 + (o1)], \
1056  				q[v + 2 * 5 + (o2)], mm); \
1057  			w[u + 6] = INNER(q[v + 2 * 6 + (o1)], \
1058  				q[v + 2 * 6 + (o2)], mm); \
1059  			w[u + 7] = INNER(q[v + 2 * 7 + (o1)], \
1060  				q[v + 2 * 7 + (o2)], mm); \
1061  		} \
1062  	} while (0)
1063  	WBREAD( 0,    0,    1, 185);
1064  	one_round_big(state, w, 0,  3, 23, 17, 27);
1065  	WBREAD( 8,    0,    1, 185);
1066  	one_round_big(state, w, 1, 28, 19, 22,  7);
1067  	WBREAD(16, -256, -128, 233);
1068  	one_round_big(state, w, 2, 29,  9, 15,  5);
1069  	WBREAD(24, -383, -255, 233);
1070  	one_round_big(state, w, 3,  4, 13, 10, 25);
1071  #undef WBREAD
1072  	STEP_BIG(
1073  		sc->state[ 0], sc->state[ 1], sc->state[ 2], sc->state[ 3],
1074  		sc->state[ 4], sc->state[ 5], sc->state[ 6], sc->state[ 7],
1075  		IF,  4, 13, PP8_4_);
1076  	STEP_BIG(
1077  		sc->state[ 8], sc->state[ 9], sc->state[10], sc->state[11],
1078  		sc->state[12], sc->state[13], sc->state[14], sc->state[15],
1079  		IF, 13, 10, PP8_5_);
1080  	STEP_BIG(
1081  		sc->state[16], sc->state[17], sc->state[18], sc->state[19],
1082  		sc->state[20], sc->state[21], sc->state[22], sc->state[23],
1083  		IF, 10, 25, PP8_6_);
1084  	STEP_BIG(
1085  		sc->state[24], sc->state[25], sc->state[26], sc->state[27],
1086  		sc->state[28], sc->state[29], sc->state[30], sc->state[31],
1087  		IF, 25,  4, PP8_0_);
1088  	memcpy(sc->state, state, sizeof state);
1089  }
1090  #undef A0
1091  #undef A1
1092  #undef A2
1093  #undef A3
1094  #undef A4
1095  #undef A5
1096  #undef A6
1097  #undef A7
1098  #undef B0
1099  #undef B1
1100  #undef B2
1101  #undef B3
1102  #undef B4
1103  #undef B5
1104  #undef B6
1105  #undef B7
1106  #undef C0
1107  #undef C1
1108  #undef C2
1109  #undef C3
1110  #undef C4
1111  #undef C5
1112  #undef C6
1113  #undef C7
1114  #undef D0
1115  #undef D1
1116  #undef D2
1117  #undef D3
1118  #undef D4
1119  #undef D5
1120  #undef D6
1121  #undef D7
1122  #else
1123  #if SPH_SIMD_NOCOPY
1124  #define A0   (sc->state[ 0])
1125  #define A1   (sc->state[ 1])
1126  #define A2   (sc->state[ 2])
1127  #define A3   (sc->state[ 3])
1128  #define A4   (sc->state[ 4])
1129  #define A5   (sc->state[ 5])
1130  #define A6   (sc->state[ 6])
1131  #define A7   (sc->state[ 7])
1132  #define B0   (sc->state[ 8])
1133  #define B1   (sc->state[ 9])
1134  #define B2   (sc->state[10])
1135  #define B3   (sc->state[11])
1136  #define B4   (sc->state[12])
1137  #define B5   (sc->state[13])
1138  #define B6   (sc->state[14])
1139  #define B7   (sc->state[15])
1140  #define C0   (sc->state[16])
1141  #define C1   (sc->state[17])
1142  #define C2   (sc->state[18])
1143  #define C3   (sc->state[19])
1144  #define C4   (sc->state[20])
1145  #define C5   (sc->state[21])
1146  #define C6   (sc->state[22])
1147  #define C7   (sc->state[23])
1148  #define D0   (sc->state[24])
1149  #define D1   (sc->state[25])
1150  #define D2   (sc->state[26])
1151  #define D3   (sc->state[27])
1152  #define D4   (sc->state[28])
1153  #define D5   (sc->state[29])
1154  #define D6   (sc->state[30])
1155  #define D7   (sc->state[31])
1156  #endif
1157  static void
1158  compress_big(sph_simd_big_context *sc, int last)
1159  {
1160  	unsigned char *x;
1161  	s32 q[256];
1162  	int i;
1163  	DECL_STATE_BIG
1164  #if SPH_SIMD_NOCOPY
1165  	sph_u32 saved[32];
1166  #endif
1167  #if SPH_SIMD_NOCOPY
1168  	memcpy(saved, sc->state, sizeof saved);
1169  #endif
1170  	x = sc->buf;
1171  	FFT256(0, 1, 0, ll);
1172  	if (last) {
1173  		for (i = 0; i < 256; i ++) {
1174  			s32 tq;
1175  			tq = q[i] + yoff_b_f[i];
1176  			tq = REDS2(tq);
1177  			tq = REDS1(tq);
1178  			tq = REDS1(tq);
1179  			q[i] = (tq <= 128 ? tq : tq - 257);
1180  		}
1181  	} else {
1182  		for (i = 0; i < 256; i ++) {
1183  			s32 tq;
1184  			tq = q[i] + yoff_b_n[i];
1185  			tq = REDS2(tq);
1186  			tq = REDS1(tq);
1187  			tq = REDS1(tq);
1188  			q[i] = (tq <= 128 ? tq : tq - 257);
1189  		}
1190  	}
1191  	READ_STATE_BIG(sc);
1192  	A0 ^= sph_dec32le_aligned(x +   0);
1193  	A1 ^= sph_dec32le_aligned(x +   4);
1194  	A2 ^= sph_dec32le_aligned(x +   8);
1195  	A3 ^= sph_dec32le_aligned(x +  12);
1196  	A4 ^= sph_dec32le_aligned(x +  16);
1197  	A5 ^= sph_dec32le_aligned(x +  20);
1198  	A6 ^= sph_dec32le_aligned(x +  24);
1199  	A7 ^= sph_dec32le_aligned(x +  28);
1200  	B0 ^= sph_dec32le_aligned(x +  32);
1201  	B1 ^= sph_dec32le_aligned(x +  36);
1202  	B2 ^= sph_dec32le_aligned(x +  40);
1203  	B3 ^= sph_dec32le_aligned(x +  44);
1204  	B4 ^= sph_dec32le_aligned(x +  48);
1205  	B5 ^= sph_dec32le_aligned(x +  52);
1206  	B6 ^= sph_dec32le_aligned(x +  56);
1207  	B7 ^= sph_dec32le_aligned(x +  60);
1208  	C0 ^= sph_dec32le_aligned(x +  64);
1209  	C1 ^= sph_dec32le_aligned(x +  68);
1210  	C2 ^= sph_dec32le_aligned(x +  72);
1211  	C3 ^= sph_dec32le_aligned(x +  76);
1212  	C4 ^= sph_dec32le_aligned(x +  80);
1213  	C5 ^= sph_dec32le_aligned(x +  84);
1214  	C6 ^= sph_dec32le_aligned(x +  88);
1215  	C7 ^= sph_dec32le_aligned(x +  92);
1216  	D0 ^= sph_dec32le_aligned(x +  96);
1217  	D1 ^= sph_dec32le_aligned(x + 100);
1218  	D2 ^= sph_dec32le_aligned(x + 104);
1219  	D3 ^= sph_dec32le_aligned(x + 108);
1220  	D4 ^= sph_dec32le_aligned(x + 112);
1221  	D5 ^= sph_dec32le_aligned(x + 116);
1222  	D6 ^= sph_dec32le_aligned(x + 120);
1223  	D7 ^= sph_dec32le_aligned(x + 124);
1224  	ONE_ROUND_BIG(0_, 0,  3, 23, 17, 27);
1225  	ONE_ROUND_BIG(1_, 1, 28, 19, 22,  7);
1226  	ONE_ROUND_BIG(2_, 2, 29,  9, 15,  5);
1227  	ONE_ROUND_BIG(3_, 3,  4, 13, 10, 25);
1228  #if SPH_SIMD_NOCOPY
1229  	STEP_BIG(
1230  		saved[ 0], saved[ 1], saved[ 2], saved[ 3],
1231  		saved[ 4], saved[ 5], saved[ 6], saved[ 7],
1232  		IF,  4, 13, PP8_4_);
1233  	STEP_BIG(
1234  		saved[ 8], saved[ 9], saved[10], saved[11],
1235  		saved[12], saved[13], saved[14], saved[15],
1236  		IF, 13, 10, PP8_5_);
1237  	STEP_BIG(
1238  		saved[16], saved[17], saved[18], saved[19],
1239  		saved[20], saved[21], saved[22], saved[23],
1240  		IF, 10, 25, PP8_6_);
1241  	STEP_BIG(
1242  		saved[24], saved[25], saved[26], saved[27],
1243  		saved[28], saved[29], saved[30], saved[31],
1244  		IF, 25,  4, PP8_0_);
1245  #else
1246  	STEP_BIG(
1247  		sc->state[ 0], sc->state[ 1], sc->state[ 2], sc->state[ 3],
1248  		sc->state[ 4], sc->state[ 5], sc->state[ 6], sc->state[ 7],
1249  		IF,  4, 13, PP8_4_);
1250  	STEP_BIG(
1251  		sc->state[ 8], sc->state[ 9], sc->state[10], sc->state[11],
1252  		sc->state[12], sc->state[13], sc->state[14], sc->state[15],
1253  		IF, 13, 10, PP8_5_);
1254  	STEP_BIG(
1255  		sc->state[16], sc->state[17], sc->state[18], sc->state[19],
1256  		sc->state[20], sc->state[21], sc->state[22], sc->state[23],
1257  		IF, 10, 25, PP8_6_);
1258  	STEP_BIG(
1259  		sc->state[24], sc->state[25], sc->state[26], sc->state[27],
1260  		sc->state[28], sc->state[29], sc->state[30], sc->state[31],
1261  		IF, 25,  4, PP8_0_);
1262  	WRITE_STATE_BIG(sc);
1263  #endif
1264  }
1265  #if SPH_SIMD_NOCOPY
1266  #undef A0
1267  #undef A1
1268  #undef A2
1269  #undef A3
1270  #undef A4
1271  #undef A5
1272  #undef A6
1273  #undef A7
1274  #undef B0
1275  #undef B1
1276  #undef B2
1277  #undef B3
1278  #undef B4
1279  #undef B5
1280  #undef B6
1281  #undef B7
1282  #undef C0
1283  #undef C1
1284  #undef C2
1285  #undef C3
1286  #undef C4
1287  #undef C5
1288  #undef C6
1289  #undef C7
1290  #undef D0
1291  #undef D1
1292  #undef D2
1293  #undef D3
1294  #undef D4
1295  #undef D5
1296  #undef D6
1297  #undef D7
1298  #endif
1299  #endif
1300  static const u32 IV224[] = {
1301  	C32(0x33586E9F), C32(0x12FFF033), C32(0xB2D9F64D), C32(0x6F8FEA53),
1302  	C32(0xDE943106), C32(0x2742E439), C32(0x4FBAB5AC), C32(0x62B9FF96),
1303  	C32(0x22E7B0AF), C32(0xC862B3A8), C32(0x33E00CDC), C32(0x236B86A6),
1304  	C32(0xF64AE77C), C32(0xFA373B76), C32(0x7DC1EE5B), C32(0x7FB29CE8)
1305  };
1306  static const u32 IV256[] = {
1307  	C32(0x4D567983), C32(0x07190BA9), C32(0x8474577B), C32(0x39D726E9),
1308  	C32(0xAAF3D925), C32(0x3EE20B03), C32(0xAFD5E751), C32(0xC96006D3),
1309  	C32(0xC2C2BA14), C32(0x49B3BCB4), C32(0xF67CAF46), C32(0x668626C9),
1310  	C32(0xE2EAA8D2), C32(0x1FF47833), C32(0xD0C661A5), C32(0x55693DE1)
1311  };
1312  static const u32 IV384[] = {
1313  	C32(0x8A36EEBC), C32(0x94A3BD90), C32(0xD1537B83), C32(0xB25B070B),
1314  	C32(0xF463F1B5), C32(0xB6F81E20), C32(0x0055C339), C32(0xB4D144D1),
1315  	C32(0x7360CA61), C32(0x18361A03), C32(0x17DCB4B9), C32(0x3414C45A),
1316  	C32(0xA699A9D2), C32(0xE39E9664), C32(0x468BFE77), C32(0x51D062F8),
1317  	C32(0xB9E3BFE8), C32(0x63BECE2A), C32(0x8FE506B9), C32(0xF8CC4AC2),
1318  	C32(0x7AE11542), C32(0xB1AADDA1), C32(0x64B06794), C32(0x28D2F462),
1319  	C32(0xE64071EC), C32(0x1DEB91A8), C32(0x8AC8DB23), C32(0x3F782AB5),
1320  	C32(0x039B5CB8), C32(0x71DDD962), C32(0xFADE2CEA), C32(0x1416DF71)
1321  };
1322  static const u32 IV512[] = {
1323  	C32(0x0BA16B95), C32(0x72F999AD), C32(0x9FECC2AE), C32(0xBA3264FC),
1324  	C32(0x5E894929), C32(0x8E9F30E5), C32(0x2F1DAA37), C32(0xF0F2C558),
1325  	C32(0xAC506643), C32(0xA90635A5), C32(0xE25B878B), C32(0xAAB7878F),
1326  	C32(0x88817F7A), C32(0x0A02892B), C32(0x559A7550), C32(0x598F657E),
1327  	C32(0x7EEF60A1), C32(0x6B70E3E8), C32(0x9C1714D1), C32(0xB958E2A8),
1328  	C32(0xAB02675E), C32(0xED1C014F), C32(0xCD8D65BB), C32(0xFDB7A257),
1329  	C32(0x09254899), C32(0xD699C7BC), C32(0x9019B6DC), C32(0x2B9022E4),
1330  	C32(0x8FA14956), C32(0x21BF9BD3), C32(0xB94D0943), C32(0x6FFDDC22)
1331  };
1332  static void
1333  init_small(void *cc, const u32 *iv)
1334  {
1335  	sph_simd_small_context *sc;
1336  	sc = cc;
1337  	memcpy(sc->state, iv, sizeof sc->state);
1338  	sc->count_low = sc->count_high = 0;
1339  	sc->ptr = 0;
1340  }
1341  static void
1342  init_big(void *cc, const u32 *iv)
1343  {
1344  	sph_simd_big_context *sc;
1345  	sc = cc;
1346  	memcpy(sc->state, iv, sizeof sc->state);
1347  	sc->count_low = sc->count_high = 0;
1348  	sc->ptr = 0;
1349  }
1350  static void
1351  update_small(void *cc, const void *data, size_t len)
1352  {
1353  	sph_simd_small_context *sc;
1354  	sc = cc;
1355  	while (len > 0) {
1356  		size_t clen;
1357  		clen = (sizeof sc->buf) - sc->ptr;
1358  		if (clen > len)
1359  			clen = len;
1360  		memcpy(sc->buf + sc->ptr, data, clen);
1361  		data = (const unsigned char *)data + clen;
1362  		len -= clen;
1363  		if ((sc->ptr += clen) == sizeof sc->buf) {
1364  			compress_small(sc, 0);
1365  			sc->ptr = 0;
1366  			sc->count_low = T32(sc->count_low + 1);
1367  			if (sc->count_low == 0)
1368  				sc->count_high ++;
1369  		}
1370  	}
1371  }
1372  static void
1373  update_big(void *cc, const void *data, size_t len)
1374  {
1375  	sph_simd_big_context *sc;
1376  	sc = cc;
1377  	while (len > 0) {
1378  		size_t clen;
1379  		clen = (sizeof sc->buf) - sc->ptr;
1380  		if (clen > len)
1381  			clen = len;
1382  		memcpy(sc->buf + sc->ptr, data, clen);
1383  		data = (const unsigned char *)data + clen;
1384  		len -= clen;
1385  		if ((sc->ptr += clen) == sizeof sc->buf) {
1386  			compress_big(sc, 0);
1387  			sc->ptr = 0;
1388  			sc->count_low = T32(sc->count_low + 1);
1389  			if (sc->count_low == 0)
1390  				sc->count_high ++;
1391  		}
1392  	}
1393  }
1394  static void
1395  encode_count_small(unsigned char *dst,
1396  	u32 low, u32 high, size_t ptr, unsigned n)
1397  {
1398  	low = T32(low << 9);
1399  	high = T32(high << 9) + (low >> 23);
1400  	low += (ptr << 3) + n;
1401  	sph_enc32le(dst, low);
1402  	sph_enc32le(dst + 4, high);
1403  }
1404  static void
1405  encode_count_big(unsigned char *dst,
1406  	u32 low, u32 high, size_t ptr, unsigned n)
1407  {
1408  	low = T32(low << 10);
1409  	high = T32(high << 10) + (low >> 22);
1410  	low += (ptr << 3) + n;
1411  	sph_enc32le(dst, low);
1412  	sph_enc32le(dst + 4, high);
1413  }
1414  static void
1415  finalize_small(void *cc, unsigned ub, unsigned n, void *dst, size_t dst_len)
1416  {
1417  	sph_simd_small_context *sc;
1418  	unsigned char *d;
1419  	size_t u;
1420  	sc = cc;
1421  	if (sc->ptr > 0 || n > 0) {
1422  		memset(sc->buf + sc->ptr, 0,
1423  			(sizeof sc->buf) - sc->ptr);
1424  		sc->buf[sc->ptr] = ub & (0xFF << (8 - n));
1425  		compress_small(sc, 0);
1426  	}
1427  	memset(sc->buf, 0, sizeof sc->buf);
1428  	encode_count_small(sc->buf, sc->count_low, sc->count_high, sc->ptr, n);
1429  	compress_small(sc, 1);
1430  	d = dst;
1431  	for (d = dst, u = 0; u < dst_len; u ++)
1432  		sph_enc32le(d + (u << 2), sc->state[u]);
1433  }
1434  static void
1435  finalize_big(void *cc, unsigned ub, unsigned n, void *dst, size_t dst_len)
1436  {
1437  	sph_simd_big_context *sc;
1438  	unsigned char *d;
1439  	size_t u;
1440  	sc = cc;
1441  	if (sc->ptr > 0 || n > 0) {
1442  		memset(sc->buf + sc->ptr, 0,
1443  			(sizeof sc->buf) - sc->ptr);
1444  		sc->buf[sc->ptr] = ub & (0xFF << (8 - n));
1445  		compress_big(sc, 0);
1446  	}
1447  	memset(sc->buf, 0, sizeof sc->buf);
1448  	encode_count_big(sc->buf, sc->count_low, sc->count_high, sc->ptr, n);
1449  	compress_big(sc, 1);
1450  	d = dst;
1451  	for (d = dst, u = 0; u < dst_len; u ++)
1452  		sph_enc32le(d + (u << 2), sc->state[u]);
1453  }
1454  void
1455  sph_simd224_init(void *cc)
1456  {
1457  	init_small(cc, IV224);
1458  }
1459  void
1460  sph_simd224(void *cc, const void *data, size_t len)
1461  {
1462  	update_small(cc, data, len);
1463  }
1464  void
1465  sph_simd224_close(void *cc, void *dst)
1466  {
1467  	sph_simd224_addbits_and_close(cc, 0, 0, dst);
1468  }
1469  void
1470  sph_simd224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1471  {
1472  	finalize_small(cc, ub, n, dst, 7);
1473  	sph_simd224_init(cc);
1474  }
1475  void
1476  sph_simd256_init(void *cc)
1477  {
1478  	init_small(cc, IV256);
1479  }
1480  void
1481  sph_simd256(void *cc, const void *data, size_t len)
1482  {
1483  	update_small(cc, data, len);
1484  }
1485  void
1486  sph_simd256_close(void *cc, void *dst)
1487  {
1488  	sph_simd256_addbits_and_close(cc, 0, 0, dst);
1489  }
1490  void
1491  sph_simd256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1492  {
1493  	finalize_small(cc, ub, n, dst, 8);
1494  	sph_simd256_init(cc);
1495  }
1496  void
1497  sph_simd384_init(void *cc)
1498  {
1499  	init_big(cc, IV384);
1500  }
1501  void
1502  sph_simd384(void *cc, const void *data, size_t len)
1503  {
1504  	update_big(cc, data, len);
1505  }
1506  void
1507  sph_simd384_close(void *cc, void *dst)
1508  {
1509  	sph_simd384_addbits_and_close(cc, 0, 0, dst);
1510  }
1511  void
1512  sph_simd384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1513  {
1514  	finalize_big(cc, ub, n, dst, 12);
1515  	sph_simd384_init(cc);
1516  }
1517  void
1518  sph_simd512_init(void *cc)
1519  {
1520  	init_big(cc, IV512);
1521  }
1522  void
1523  sph_simd512(void *cc, const void *data, size_t len)
1524  {
1525  	update_big(cc, data, len);
1526  }
1527  void
1528  sph_simd512_close(void *cc, void *dst)
1529  {
1530  	sph_simd512_addbits_and_close(cc, 0, 0, dst);
1531  }
1532  void
1533  sph_simd512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1534  {
1535  	finalize_big(cc, ub, n, dst, 16);
1536  	sph_simd512_init(cc);
1537  }
1538  #ifdef __cplusplus
1539  }
1540  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-cl_13.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_simd.c</div>
                </div>
                <div class="column column_space"><pre><code>682  clGetPlatformIDs(cl_uint          num_entries,
683                   cl_platform_id * platforms,
684                   cl_uint *        num_platforms) CL_API_SUFFIX__VERSION_1_0;
685  extern CL_API_ENTRY cl_int CL_API_CALL
686  clGetPlatformInfo(cl_platform_id   platform,
687                    cl_platform_info param_name,
688                    size_t           param_value_size,
689                    void *           param_value,
690                    size_t *         param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
691  extern CL_API_ENTRY cl_int CL_API_CALL
692  clGetDeviceIDs(cl_platform_id   platform,
693                 cl_device_type   device_type,
694                 cl_uint          num_entries,
695                 cl_device_id *   devices,
696                 cl_uint *        num_devices) CL_API_SUFFIX__VERSION_1_0;
697  extern CL_API_ENTRY cl_int CL_API_CALL
698  clGetDeviceInfo(cl_device_id    device,
699                  cl_device_info  param_name,
700                  size_t          param_value_size,
701                  void *          param_value,
702                  size_t *        param_value_size_ret) CL_API_SUFFIX__VERSION_1_0;
703  #ifdef CL_VERSION_1_2
704  extern CL_API_ENTRY cl_int CL_API_CALL
705  clCreateSubDevices(cl_device_id                         in_device,
706                     const cl_device_partition_property * properties,
707                     cl_uint                              num_devices,
708                     cl_device_id *                       out_devices,
709                     cl_uint *                            num_devices_ret) CL_API_SUFFIX__VERSION_1_2;
710  extern CL_API_ENTRY cl_int CL_API_CALL
711  clRetainDevice(cl_device_id device) CL_API_SUFFIX__VERSION_1_2;
712  extern CL_API_ENTRY cl_int CL_API_CALL
713  clReleaseDevice(cl_device_id device) CL_API_SUFFIX__VERSION_1_2;
</pre></code></div>
                <div class="column column_space"><pre><code>977  	STEP2_BIG(w[40], w[41], w[42], w[43], w[44], w[45], w[46], w[47],
978  		MAJ, p1, p2, pp8k[isp + 5]);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    