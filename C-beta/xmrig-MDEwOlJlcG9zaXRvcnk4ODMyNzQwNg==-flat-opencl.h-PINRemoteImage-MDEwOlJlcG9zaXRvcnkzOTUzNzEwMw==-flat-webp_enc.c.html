
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.966457023060797%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-opencl.h</h3>
            <pre><code>1  #ifndef HWLOC_OPENCL_H
2  #define HWLOC_OPENCL_H
3  #include "hwloc.h"
4  #include "hwloc/autogen/config.h"
5  #include "hwloc/helper.h"
6  #ifdef HWLOC_LINUX_SYS
7  #include "hwloc/linux.h"
8  #endif
9  #ifdef __APPLE__
10  #include <OpenCL/cl.h>
11  #else
12  #include <CL/cl.h>
13  #endif
14  #include <stdio.h>
15  #ifdef __cplusplus
16  extern "C" {
17  #endif
18  #define HWLOC_CL_DEVICE_TOPOLOGY_AMD 0x4037
19  typedef union {
20      struct { cl_uint type; cl_uint data[5]; } raw;
21      struct { cl_uint type; cl_char unused[17]; cl_char bus; cl_char device; cl_char function; } pcie;
22  } hwloc_cl_device_topology_amd;
23  #define HWLOC_CL_DEVICE_TOPOLOGY_TYPE_PCIE_AMD 1
24  #define HWLOC_CL_DEVICE_PCI_BUS_ID_NV 0x4008
25  #define HWLOC_CL_DEVICE_PCI_SLOT_ID_NV 0x4009
26  #define HWLOC_CL_DEVICE_PCI_DOMAIN_ID_NV 0x400A
27  static __hwloc_inline int
28  hwloc_opencl_get_device_pci_busid(cl_device_id device,
29                                 unsigned *domain, unsigned *bus, unsigned *dev, unsigned *func)
30  {
31  	hwloc_cl_device_topology_amd amdtopo;
32  	cl_uint nvbus, nvslot, nvdomain;
33  	cl_int clret;
34  	clret = clGetDeviceInfo(device, HWLOC_CL_DEVICE_TOPOLOGY_AMD, sizeof(amdtopo), &amdtopo, NULL);
35  	if (CL_SUCCESS == clret
36  	    && HWLOC_CL_DEVICE_TOPOLOGY_TYPE_PCIE_AMD == amdtopo.raw.type) {
37  		*domain = 0; &bsol;* can't do anything better */
38  		*bus = (unsigned) (unsigned char) amdtopo.pcie.bus;
39  		*dev = (unsigned) (unsigned char) amdtopo.pcie.device;
40  		*func = (unsigned) (unsigned char) amdtopo.pcie.function;
41  		return 0;
42  	}
43  	clret = clGetDeviceInfo(device, HWLOC_CL_DEVICE_PCI_BUS_ID_NV, sizeof(nvbus), &nvbus, NULL);
44  	if (CL_SUCCESS == clret) {
45  		clret = clGetDeviceInfo(device, HWLOC_CL_DEVICE_PCI_SLOT_ID_NV, sizeof(nvslot), &nvslot, NULL);
46  		if (CL_SUCCESS == clret) {
47  			clret = clGetDeviceInfo(device, HWLOC_CL_DEVICE_PCI_DOMAIN_ID_NV, sizeof(nvdomain), &nvdomain, NULL);
48  			if (CL_SUCCESS == clret) { &bsol;* available since CUDA 10.2 */
49  				*domain = nvdomain;
50  			} else {
51  				*domain = 0;
52  			}
53  			*bus = nvbus & 0xff;
54  			*dev = nvslot >> 3;
55  			*func = nvslot & 0x7;
<span onclick='openModal()' class='match'>56  			return 0;
57  		}
58  	}
59  	return -1;
60  }
61  static __hwloc_inline int
62  hwloc_opencl_get_device_cpuset(hwloc_topology_t topology __hwloc_attribute_unused,
63  			       cl_device_id device __hwloc_attribute_unused,
64  			       hwloc_cpuset_t set)
</span>65  {
66  #if (defined HWLOC_LINUX_SYS)
67  #define HWLOC_OPENCL_DEVICE_SYSFS_PATH_MAX 128
68  	char path[HWLOC_OPENCL_DEVICE_SYSFS_PATH_MAX];
69  	unsigned pcidomain, pcibus, pcidev, pcifunc;
70  	if (!hwloc_topology_is_thissystem(topology)) {
71  		errno = EINVAL;
72  		return -1;
73  	}
74  	if (hwloc_opencl_get_device_pci_busid(device, &pcidomain, &pcibus, &pcidev, &pcifunc) < 0) {
75  		hwloc_bitmap_copy(set, hwloc_topology_get_complete_cpuset(topology));
76  		return 0;
77  	}
78  	sprintf(path, "/sys/bus/pci/devices/%04x:%02x:%02x.%01x/local_cpus", pcidomain, pcibus, pcidev, pcifunc);
79  	if (hwloc_linux_read_path_as_cpumask(path, set) < 0
80  	    || hwloc_bitmap_iszero(set))
81  		hwloc_bitmap_copy(set, hwloc_topology_get_complete_cpuset(topology));
82  #else
83  	hwloc_bitmap_copy(set, hwloc_topology_get_complete_cpuset(topology));
84  #endif
85    return 0;
86  }
87  static __hwloc_inline hwloc_obj_t
88  hwloc_opencl_get_device_osdev_by_index(hwloc_topology_t topology,
89  				       unsigned platform_index, unsigned device_index)
90  {
91  	unsigned x = (unsigned) -1, y = (unsigned) -1;
92  	hwloc_obj_t osdev = NULL;
93  	while ((osdev = hwloc_get_next_osdev(topology, osdev)) != NULL) {
94  		if (HWLOC_OBJ_OSDEV_COPROC == osdev->attr->osdev.type
95                      && osdev->name
96  		    && sscanf(osdev->name, "opencl%ud%u", &x, &y) == 2
97  		    && platform_index == x && device_index == y)
98                          return osdev;
99          }
100          return NULL;
101  }
102  static __hwloc_inline hwloc_obj_t
103  hwloc_opencl_get_device_osdev(hwloc_topology_t topology __hwloc_attribute_unused,
104  			      cl_device_id device __hwloc_attribute_unused)
105  {
106  	hwloc_obj_t osdev;
107  	unsigned pcidomain, pcibus, pcidevice, pcifunc;
108  	if (hwloc_opencl_get_device_pci_busid(device, &pcidomain, &pcibus, &pcidevice, &pcifunc) < 0) {
109  		errno = EINVAL;
110  		return NULL;
111  	}
112  	osdev = NULL;
113  	while ((osdev = hwloc_get_next_osdev(topology, osdev)) != NULL) {
114  		hwloc_obj_t pcidev = osdev->parent;
115  		if (strncmp(osdev->name, "opencl", 6))
116  			continue;
117  		if (pcidev
118  		    && pcidev->type == HWLOC_OBJ_PCI_DEVICE
119  		    && pcidev->attr->pcidev.domain == pcidomain
120  		    && pcidev->attr->pcidev.bus == pcibus
121  		    && pcidev->attr->pcidev.dev == pcidevice
122  		    && pcidev->attr->pcidev.func == pcifunc)
123  			return osdev;
124  	}
125  	return NULL;
126  }
127  #ifdef __cplusplus
128  } &bsol;* extern "C" */
129  #endif
130  #endif &bsol;* HWLOC_OPENCL_H */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include <math.h>
5  #include "src/enc/cost_enc.h"
6  #include "src/enc/vp8i_enc.h"
7  #include "src/enc/vp8li_enc.h"
8  #include "src/utils/utils.h"
9  #ifdef PRINT_MEMORY_INFO
10  #include <stdio.h>
11  #endif
12  int WebPGetEncoderVersion(void) {
13    return (ENC_MAJ_VERSION << 16) | (ENC_MIN_VERSION << 8) | ENC_REV_VERSION;
14  }
15  static void ResetSegmentHeader(VP8Encoder* const enc) {
16    VP8EncSegmentHeader* const hdr = &enc->segment_hdr_;
17    hdr->num_segments_ = enc->config_->segments;
18    hdr->update_map_  = (hdr->num_segments_ > 1);
19    hdr->size_ = 0;
20  }
21  static void ResetFilterHeader(VP8Encoder* const enc) {
22    VP8EncFilterHeader* const hdr = &enc->filter_hdr_;
23    hdr->simple_ = 1;
24    hdr->level_ = 0;
25    hdr->sharpness_ = 0;
26    hdr->i4x4_lf_delta_ = 0;
27  }
28  static void ResetBoundaryPredictions(VP8Encoder* const enc) {
29    int i;
30    uint8_t* const top = enc->preds_ - enc->preds_w_;
31    uint8_t* const left = enc->preds_ - 1;
32    for (i = -1; i < 4 * enc->mb_w_; ++i) {
33      top[i] = B_DC_PRED;
34    }
35    for (i = 0; i < 4 * enc->mb_h_; ++i) {
36      left[i * enc->preds_w_] = B_DC_PRED;
37    }
38    enc->nz_[-1] = 0;   
39  }
40  static void MapConfigToTools(VP8Encoder* const enc) {
41    const WebPConfig* const config = enc->config_;
42    const int method = config->method;
43    const int limit = 100 - config->partition_limit;
44    enc->method_ = method;
45    enc->rd_opt_level_ = (method >= 6) ? RD_OPT_TRELLIS_ALL
46                       : (method >= 5) ? RD_OPT_TRELLIS
47                       : (method >= 3) ? RD_OPT_BASIC
48                       : RD_OPT_NONE;
49    enc->max_i4_header_bits_ =
50        256 * 16 * 16 *                 
51        (limit * limit) / (100 * 100);  
52    enc->mb_header_limit_ =
53        (score_t)256 * 510 * 8 * 1024 / (enc->mb_w_ * enc->mb_h_);
54    enc->thread_level_ = config->thread_level;
55    enc->do_search_ = (config->target_size > 0 || config->target_PSNR > 0);
56    if (!config->low_memory) {
57  #if !defined(DISABLE_TOKEN_BUFFER)
58      enc->use_tokens_ = (enc->rd_opt_level_ >= RD_OPT_BASIC);  
59  #endif
60      if (enc->use_tokens_) {
61        enc->num_parts_ = 1;   
62      }
63    }
64  }
65  static VP8Encoder* InitVP8Encoder(const WebPConfig* const config,
66                                    WebPPicture* const picture) {
67    VP8Encoder* enc;
68    const int use_filter =
69        (config->filter_strength > 0) || (config->autofilter > 0);
70    const int mb_w = (picture->width + 15) >> 4;
71    const int mb_h = (picture->height + 15) >> 4;
72    const int preds_w = 4 * mb_w + 1;
73    const int preds_h = 4 * mb_h + 1;
74    const size_t preds_size = preds_w * preds_h * sizeof(*enc->preds_);
75    const int top_stride = mb_w * 16;
76    const size_t nz_size = (mb_w + 1) * sizeof(*enc->nz_) + WEBP_ALIGN_CST;
77    const size_t info_size = mb_w * mb_h * sizeof(*enc->mb_info_);
78    const size_t samples_size =
79        2 * top_stride * sizeof(*enc->y_top_)  
80        + WEBP_ALIGN_CST;                      
81    const size_t lf_stats_size =
82        config->autofilter ? sizeof(*enc->lf_stats_) + WEBP_ALIGN_CST : 0;
83    const size_t top_derr_size =
84        (config->quality <= ERROR_DIFFUSION_QUALITY || config->pass > 1) ?
85            mb_w * sizeof(*enc->top_derr_) : 0;
86    uint8_t* mem;
87    const uint64_t size = (uint64_t)sizeof(*enc)   
88                        + WEBP_ALIGN_CST           
89                        + info_size                
90                        + preds_size               
91                        + samples_size             
92                        + top_derr_size            
93                        + nz_size                  
94                        + lf_stats_size;           
95  #ifdef PRINT_MEMORY_INFO
96    printf("===================================\n");
97    printf("Memory used:\n"
98           "             encoder: %ld\n"
99           "                info: %ld\n"
100           "               preds: %ld\n"
101           "         top samples: %ld\n"
102           "       top diffusion: %ld\n"
103           "            non-zero: %ld\n"
104           "            lf-stats: %ld\n"
105           "               total: %ld\n",
106           sizeof(*enc) + WEBP_ALIGN_CST, info_size,
107           preds_size, samples_size, top_derr_size, nz_size, lf_stats_size, size);
108    printf("Transient object sizes:\n"
109           "      VP8EncIterator: %ld\n"
110           "        VP8ModeScore: %ld\n"
111           "      VP8SegmentInfo: %ld\n"
112           "         VP8EncProba: %ld\n"
113           "             LFStats: %ld\n",
114           sizeof(VP8EncIterator), sizeof(VP8ModeScore),
115           sizeof(VP8SegmentInfo), sizeof(VP8EncProba),
116           sizeof(LFStats));
117    printf("Picture size (yuv): %ld\n",
118           mb_w * mb_h * 384 * sizeof(uint8_t));
119    printf("===================================\n");
120  #endif
121    mem = (uint8_t*)WebPSafeMalloc(size, sizeof(*mem));
122    if (mem == NULL) {
123      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
124      return NULL;
125    }
126    enc = (VP8Encoder*)mem;
127    mem = (uint8_t*)WEBP_ALIGN(mem + sizeof(*enc));
128    memset(enc, 0, sizeof(*enc));
129    enc->num_parts_ = 1 << config->partitions;
130    enc->mb_w_ = mb_w;
131    enc->mb_h_ = mb_h;
132    enc->preds_w_ = preds_w;
133    enc->mb_info_ = (VP8MBInfo*)mem;
134    mem += info_size;
135    enc->preds_ = mem + 1 + enc->preds_w_;
136    mem += preds_size;
137    enc->nz_ = 1 + (uint32_t*)WEBP_ALIGN(mem);
138    mem += nz_size;
139    enc->lf_stats_ = lf_stats_size ? (LFStats*)WEBP_ALIGN(mem) : NULL;
140    mem += lf_stats_size;
141    mem = (uint8_t*)WEBP_ALIGN(mem);
142    enc->y_top_ = mem;
143    enc->uv_top_ = enc->y_top_ + top_stride;
144    mem += 2 * top_stride;
145    enc->top_derr_ = top_derr_size ? (DError*)mem : NULL;
146    mem += top_derr_size;
147    assert(mem <= (uint8_t*)enc + size);
148    enc->config_ = config;
149    enc->profile_ = use_filter ? ((config->filter_type == 1) ? 0 : 1) : 2;
150    enc->pic_ = picture;
151    enc->percent_ = 0;
152    MapConfigToTools(enc);
153    VP8EncDspInit();
154    VP8DefaultProbas(enc);
155    ResetSegmentHeader(enc);
156    ResetFilterHeader(enc);
157    ResetBoundaryPredictions(enc);
158    VP8EncDspCostInit();
159    VP8EncInitAlpha(enc);
160    {
161      const float scale = 1.f + config->quality * 5.f / 100.f;  
162      VP8TBufferInit(&enc->tokens_, (int)(mb_w * mb_h * 4 * scale));
163    }
164    return enc;
165  }
166  static int DeleteVP8Encoder(VP8Encoder* enc) {
167    int ok = 1;
168    if (enc != NULL) {
169      ok = VP8EncDeleteAlpha(enc);
170      VP8TBufferClear(&enc->tokens_);
171      WebPSafeFree(enc);
172    }
173    return ok;
174  }
175  #if !defined(WEBP_DISABLE_STATS)
176  static double GetPSNR(uint64_t err, uint64_t size) {
177    return (err > 0 && size > 0) ? 10. * log10(255. * 255. * size / err) : 99.;
178  }
179  static void FinalizePSNR(const VP8Encoder* const enc) {
180    WebPAuxStats* stats = enc->pic_->stats;
181    const uint64_t size = enc->sse_count_;
182    const uint64_t* const sse = enc->sse_;
183    stats->PSNR[0] = (float)GetPSNR(sse[0], size);
184    stats->PSNR[1] = (float)GetPSNR(sse[1], size / 4);
185    stats->PSNR[2] = (float)GetPSNR(sse[2], size / 4);
186    stats->PSNR[3] = (float)GetPSNR(sse[0] + sse[1] + sse[2], size * 3 / 2);
187    stats->PSNR[4] = (float)GetPSNR(sse[3], size);
188  }
189  #endif  
190  static void StoreStats(VP8Encoder* const enc) {
191  #if !defined(WEBP_DISABLE_STATS)
192    WebPAuxStats* const stats = enc->pic_->stats;
193    if (stats != NULL) {
194      int i, s;
195      for (i = 0; i < NUM_MB_SEGMENTS; ++i) {
196        stats->segment_level[i] = enc->dqm_[i].fstrength_;
197        stats->segment_quant[i] = enc->dqm_[i].quant_;
198        for (s = 0; s <= 2; ++s) {
199          stats->residual_bytes[s][i] = enc->residual_bytes_[s][i];
200        }
201      }
202      FinalizePSNR(enc);
203      stats->coded_size = enc->coded_size_;
204      for (i = 0; i < 3; ++i) {
205        stats->block_count[i] = enc->block_count_[i];
206      }
207    }
208  #else  
209    WebPReportProgress(enc->pic_, 100, &enc->percent_);  
210  #endif  
211  }
212  int WebPEncodingSetError(const WebPPicture* const pic,
213                           WebPEncodingError error) {
214    assert((int)error < VP8_ENC_ERROR_LAST);
215    assert((int)error >= VP8_ENC_OK);
216    ((WebPPicture*)pic)->error_code = error;
217    return 0;
218  }
219  int WebPReportProgress(const WebPPicture* const pic,
220                         int percent, int* const percent_store) {
221    if (percent_store != NULL && percent != *percent_store) {
222      *percent_store = percent;
223      if (pic->progress_hook && !pic->progress_hook(percent, pic)) {
224        WebPEncodingSetError(pic, VP8_ENC_ERROR_USER_ABORT);
<span onclick='openModal()' class='match'>225        return 0;
226      }
227    }
228    return 1;  
229  }
230  int WebPEncode(const WebPConfig* config, WebPPicture* pic) {
231    int ok = 0;
</span>232    if (pic == NULL) return 0;
233    WebPEncodingSetError(pic, VP8_ENC_OK);  
234    if (config == NULL) {  
235      return WebPEncodingSetError(pic, VP8_ENC_ERROR_NULL_PARAMETER);
236    }
237    if (!WebPValidateConfig(config)) {
238      return WebPEncodingSetError(pic, VP8_ENC_ERROR_INVALID_CONFIGURATION);
239    }
240    if (pic->width <= 0 || pic->height <= 0) {
241      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
242    }
243    if (pic->width > WEBP_MAX_DIMENSION || pic->height > WEBP_MAX_DIMENSION) {
244      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
245    }
246    if (pic->stats != NULL) memset(pic->stats, 0, sizeof(*pic->stats));
247    if (!config->lossless) {
248      VP8Encoder* enc = NULL;
249      if (pic->use_argb || pic->y == NULL || pic->u == NULL || pic->v == NULL) {
250        if (config->use_sharp_yuv || (config->preprocessing & 4)) {
251          if (!WebPPictureSharpARGBToYUVA(pic)) {
252            return 0;
253          }
254        } else {
255          float dithering = 0.f;
256          if (config->preprocessing & 2) {
257            const float x = config->quality / 100.f;
258            const float x2 = x * x;
259            dithering = 1.0f + (0.5f - 1.0f) * x2 * x2;
260          }
261          if (!WebPPictureARGBToYUVADithered(pic, WEBP_YUV420, dithering)) {
262            return 0;
263          }
264        }
265      }
266      if (!config->exact) {
267        WebPCleanupTransparentArea(pic);
268      }
269      enc = InitVP8Encoder(config, pic);
270      if (enc == NULL) return 0;  
271      ok = VP8EncAnalyze(enc);
272      ok = ok && VP8EncStartAlpha(enc);   
273      if (!enc->use_tokens_) {
274        ok = ok && VP8EncLoop(enc);
275      } else {
276        ok = ok && VP8EncTokenLoop(enc);
277      }
278      ok = ok && VP8EncFinishAlpha(enc);
279      ok = ok && VP8EncWrite(enc);
280      StoreStats(enc);
281      if (!ok) {
282        VP8EncFreeBitWriters(enc);
283      }
284      ok &= DeleteVP8Encoder(enc);  
285    } else {
286      if (pic->argb == NULL && !WebPPictureYUVAToARGB(pic)) {
287        return 0;
288      }
289      if (!config->exact) {
290        WebPCleanupTransparentAreaLossless(pic);
291      }
292      ok = VP8LEncodeImage(config, pic);  
293    }
294    return ok;
295  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-opencl.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>56  			return 0;
57  		}
58  	}
59  	return -1;
60  }
61  static __hwloc_inline int
62  hwloc_opencl_get_device_cpuset(hwloc_topology_t topology __hwloc_attribute_unused,
63  			       cl_device_id device __hwloc_attribute_unused,
64  			       hwloc_cpuset_t set)
</pre></code></div>
                <div class="column column_space"><pre><code>225        return 0;
226      }
227    }
228    return 1;  
229  }
230  int WebPEncode(const WebPConfig* config, WebPPicture* pic) {
231    int ok = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    