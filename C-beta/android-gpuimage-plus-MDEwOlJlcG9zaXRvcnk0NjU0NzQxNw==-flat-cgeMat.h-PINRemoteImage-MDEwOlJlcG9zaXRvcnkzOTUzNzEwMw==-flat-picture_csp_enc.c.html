
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 26.452732003469208%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeMat.h</h3>
            <pre><code>1  &bsol;*
2  Author: wysaid
3  Blog: blog.wysaid.org
4  Data: 2013-10-31
5  Description: Provide some cpu math algorithms like glsl shaders.
6  @             Some algorithms are from http:&bsol;&bsol;www.opengl.org/
7  @Attention: I'm using radian, not degree!
8  */
9  #ifndef _CGE_MAT_H_
10  #define _CGE_MAT_H_
11  #include "cgeStaticAssert.h"
12  #include "cgeVec.h"
13  #include <algorithm>
14  #include <cmath>
15  #ifndef M_PI
16  #define M_PI 3.141592653589793f
17  #endif
18  namespace CGE
19  {
20  inline void normalize(float& x, float& y, float& z)
21  {
22      const float scale = 1.0f / sqrtf(x * x + y * y + z * z);
23      x *= scale;
24      y *= scale;
25      z *= scale;
26  }
27  inline void normalize(float& x, float& y, float& z, float& w)
28  {
29      const float scale = 1.0f / sqrtf(x * x + y * y + z * z + w * w);
30      x *= scale;
31      y *= scale;
32      z *= scale;
33      w *= scale;
34  }
35  struct Mat2
36  {
37      const static Mat2& makeIdentity()
38      {
39          const static Mat2 sIdentity = Mat2(1.0f, 0.0f,
40                                             0.0f, 1.0f);
41          return sIdentity;
42      }
43      static inline Mat2& makeMatrix(Mat2& m, float m00, float m01,
44                                     float m10, float m11)
45      {
46          m[0][0] = m00;
47          m[0][1] = m01;
48          m[1][0] = m10;
49          m[1][1] = m11;
50          return m;
51      }
52      static inline Mat2 makeRotation(float rad)
53      {
54          const float cosRad = cosf(rad);
55          const float sinRad = sinf(rad);
56          return Mat2(cosRad, sinRad, -sinRad, cosRad);
57      }
58      Mat2() {}
59      Mat2(float m00, float m01, float m10, float m11)
60      {
61          makeMatrix(*this, m00, m01, m10, m11);
62      }
63      inline void rotate(float rad)
64      {
65          *this *= makeRotation(rad);
66      }
67      inline float* operator[](int index)
68      {
69          return data[index];
70      }
71      inline const float* operator[](int index) const
72      {
73          return data[index];
74      }
75      inline Vec2f operator*(const Vec2f& v) const
76      {
77          return Vec2f(data[0][0] * v[0] + data[1][0] * v[1],
78                       data[0][1] * v[0] + data[1][1] * v[1]);
79      }
80      inline Mat2 operator*(const Mat2& m) const
81      {
82          return Mat2(data[0][0] * m[0][0] + data[1][0] * m[0][1],
83                      data[0][1] * m[0][0] + data[1][1] * m[0][1],
84                      data[0][0] * m[1][0] + data[1][0] * m[1][1],
85                      data[0][1] * m[1][0] + data[1][1] * m[1][1]);
86      }
87      inline Mat2& operator*=(const Mat2& m)
88      {
89          return *this = *this * m;
90      }
91      inline void loadIdentity()
92      {
93          *this = makeIdentity();
94      }
95      float data[2][2];
96  };
97  struct Mat3
98  {
99      const static Mat3& makeIdentity()
100      {
101          const static Mat3 sIdentity = Mat3(1.0f, 0.0f, 0.0f,
102                                             0.0f, 1.0f, 0.0f,
103                                             0.0f, 0.0f, 1.0f);
104          return sIdentity;
105      }
106      static inline Mat3& makeMatrix(Mat3& m, float m00, float m01, float m02,
107                                     float m10, float m11, float m12,
108                                     float m20, float m21, float m22)
109      {
110          m[0][0] = m00;
111          m[0][1] = m01;
112          m[0][2] = m02;
113          m[1][0] = m10;
114          m[1][1] = m11;
115          m[1][2] = m12;
116          m[2][0] = m20;
117          m[2][1] = m21;
118          m[2][2] = m22;
119          return m;
120      }
121      static inline Mat3 makeRotation(float rad, float x, float y, float z)
122      {
123          normalize(x, y, z);
124          const float cosRad = cosf(rad);
125          const float cosp = 1.0f - cosRad;
126          const float sinRad = sinf(rad);
127          return Mat3(cosRad + cosp * x * x,
128                      cosp * x * y + z * sinRad,
129                      cosp * x * z - y * sinRad,
130                      cosp * x * y - z * sinRad,
131                      cosRad + cosp * y * y,
132                      cosp * y * z + x * sinRad,
133                      cosp * x * z + y * sinRad,
134                      cosp * y * z - x * sinRad,
135                      cosRad + cosp * z * z);
136      }
137      static inline Mat3 makeXRotation(float rad)
138      {
139          const float cosRad = cosf(rad);
140          const float sinRad = sinf(rad);
141          return Mat3(1.0f, 0.0f, 0.0f,
142                      0.0f, cosRad, sinRad,
143                      0.0f, -sinRad, cosRad);
144      }
145      static inline Mat3 makeYRotation(float rad)
146      {
147          const float cosRad = cosf(rad);
148          const float sinRad = sinf(rad);
149          return Mat3(cosRad, 0.0f, -sinRad,
150                      0.0f, 1.0f, 0.0f,
151                      sinRad, 0.0f, cosRad);
152      }
153      static inline Mat3 makeZRotation(float rad)
154      {
155          const float cosRad = cosf(rad);
156          const float sinRad = sinf(rad);
157          return Mat3(cosRad, sinRad, 0.0f,
158                      -sinRad, cosRad, 0.0f,
159                      0.0f, 0.0f, 1.0f);
160      }
161      Mat3() {}
162      Mat3(float m00, float m01, float m02,
163           float m10, float m11, float m12,
164           float m20, float m21, float m22)
165      {
166          makeMatrix(*this, m00, m01, m02,
167                     m10, m11, m12,
168                     m20, m21, m22);
169      }
170      inline float* operator[](int index)
171      {
172          return data[index];
173      }
174      inline const float* operator[](int index) const
175      {
176          return data[index];
177      }
178      inline Vec3f operator*(const Vec3f& v) const
179      {
180          return Vec3f(data[0][0] * v[0] + data[1][0] * v[1] + data[2][0] * v[2],
181                       data[0][1] * v[0] + data[1][1] * v[1] + data[2][1] * v[2],
182                       data[0][2] * v[0] + data[1][2] * v[1] + data[2][2] * v[2]);
183      }
184      inline Mat3 operator*(const Mat3& m) const
185      {
186          return Mat3(data[0][0] * m[0][0] + data[1][0] * m[0][1] + data[2][0] * m[0][2],
187                      data[0][1] * m[0][0] + data[1][1] * m[0][1] + data[2][1] * m[0][2],
188                      data[0][2] * m[0][0] + data[1][2] * m[0][1] + data[2][2] * m[0][2],
189                      data[0][0] * m[1][0] + data[1][0] * m[1][1] + data[2][0] * m[1][2],
190                      data[0][1] * m[1][0] + data[1][1] * m[1][1] + data[2][1] * m[1][2],
191                      data[0][2] * m[1][0] + data[1][2] * m[1][1] + data[2][2] * m[1][2],
192                      data[0][0] * m[2][0] + data[1][0] * m[2][1] + data[2][0] * m[2][2],
193                      data[0][1] * m[2][0] + data[1][1] * m[2][1] + data[2][1] * m[2][2],
194                      data[0][2] * m[2][0] + data[1][2] * m[2][1] + data[2][2] * m[2][2]);
195      }
196      inline Mat3& operator*=(const Mat3& m)
197      {
198          return *this = *this * m;
199      }
200      inline void rotate(float rad, float x, float y, float z)
201      {
202          *this *= makeRotation(rad, x, y, z);
203      }
204      inline void rotateX(float rad)
205      {
206          *this *= makeXRotation(rad); 
207      }
208      inline void rotateY(float rad)
209      {
210          *this *= makeYRotation(rad); 
211      }
212      inline void rotateZ(float rad)
213      {
214          *this *= makeZRotation(rad); 
215      }
216      inline void loadIdentity()
217      {
218          *this = makeIdentity();
219      }
220      float data[3][3];
221  };
222  struct Mat4
223  {
224      const static inline Mat4& makeIdentity()
225      {
226          const static Mat4 sIdentity = Mat4(1.0f, 0.0f, 0.0f, 0.0f,
227                                             0.0f, 1.0f, 0.0f, 0.0f,
228                                             0.0f, 0.0f, 1.0f, 0.0f,
229                                             0.0f, 0.0f, 0.0f, 1.0f);
230          return sIdentity;
231      }
232      static inline Mat4& makeMatrix(Mat4& m, float m00, float m01, float m02, float m03,
233                                     float m10, float m11, float m12, float m13,
234                                     float m20, float m21, float m22, float m23,
235                                     float m30, float m31, float m32, float m33)
236      {
237          m[0][0] = m00;
238          m[0][1] = m01;
239          m[0][2] = m02;
240          m[0][3] = m03;
241          m[1][0] = m10;
242          m[1][1] = m11;
243          m[1][2] = m12;
244          m[1][3] = m13;
245          m[2][0] = m20;
246          m[2][1] = m21;
247          m[2][2] = m22;
248          m[2][3] = m23;
249          m[3][0] = m30;
250          m[3][1] = m31;
251          m[3][2] = m32;
252          m[3][3] = m33;
253          return m;
254      }
255      static inline Mat4& makeMatrixTranspose(Mat4& m, float m00, float m01, float m02, float m03,
256                                              float m10, float m11, float m12, float m13,
257                                              float m20, float m21, float m22, float m23,
258                                              float m30, float m31, float m32, float m33)
259      {
260          m[0][0] = m00;
261          m[0][1] = m10;
262          m[0][2] = m20;
263          m[0][3] = m30;
264          m[1][0] = m01;
265          m[1][1] = m11;
266          m[1][2] = m21;
267          m[1][3] = m31;
268          m[2][0] = m02;
269          m[2][1] = m12;
270          m[2][2] = m22;
271          m[2][3] = m32;
272          m[3][0] = m03;
273          m[3][1] = m13;
274          m[3][2] = m23;
275          m[3][3] = m33;
276          return m;
277      }
278      static inline Mat4 makeMatrix(float m00, float m01, float m02, float m03,
279                                    float m10, float m11, float m12, float m13,
280                                    float m20, float m21, float m22, float m23,
281                                    float m30, float m31, float m32, float m33)
282      {
283          return Mat4(m00, m01, m02, m03,
284                      m10, m11, m12, m13,
285                      m20, m21, m22, m23,
286                      m30, m31, m32, m33);
287      }
288      static inline Mat4 makeMatrixTranspose(float m00, float m01, float m02, float m03,
289                                             float m10, float m11, float m12, float m13,
290                                             float m20, float m21, float m22, float m23,
291                                             float m30, float m31, float m32, float m33)
292      {
293          return Mat4(m00, m10, m20, m30,
294                      m01, m11, m21, m31,
295                      m02, m12, m22, m32,
296                      m03, m13, m23, m33);
297      }
298      static inline Mat4 makeTranslation(float x, float y, float z)
299      {
300          return Mat4(1.0f, 0.0f, 0.0f, 0.0f,
301                      0.0f, 1.0f, 0.0f, 0.0f,
302                      0.0f, 0.0f, 1.0f, 0.0f,
303                      x, y, z, 1.0f);
304      }
305      static inline Mat4 makeScale(float x, float y, float z)
306      {
<span onclick='openModal()' class='match'>307          return Mat4(x, 0.0f, 0.0f, 0.0f,
308                      0.0f, y, 0.0f, 0.0f,
309                      0.0f, 0.0f, z, 0.0f,
310                      0.0f, 0.0f, 0.0f, 1.0f);
311      }
312      static inline Mat4 makeRotation(float rad, float x, float y, float z)
</span>313      {
314          normalize(x, y, z);
315          const float cosRad = cosf(rad);
316          const float cosp = 1.0f - cosRad;
317          const float sinRad = sinf(rad);
318          return Mat4(cosRad + cosp * x * x,
319                      cosp * x * y + z * sinRad,
320                      cosp * x * z - y * sinRad,
321                      0.0f,
322                      cosp * x * y - z * sinRad,
323                      cosRad + cosp * y * y,
324                      cosp * y * z + x * sinRad,
325                      0.0f,
326                      cosp * x * z + y * sinRad,
327                      cosp * y * z - x * sinRad,
328                      cosRad + cosp * z * z,
329                      0.0f,
330                      0.0f,
331                      0.0f,
332                      0.0f,
333                      1.0f);
334      }
335      static inline Mat4 makeXRotation(float rad)
336      {
337          const float cosRad = cosf(rad);
338          const float sinRad = sinf(rad);
339          return Mat4(1.0f, 0.0f, 0.0f, 0.0f,
340                      0.0f, cosRad, sinRad, 0.0f,
341                      0.0f, -sinRad, cosRad, 0.0f,
342                      0.0f, 0.0f, 0.0f, 1.0f);
343      }
344      static inline Mat4 makeYRotation(float rad)
345      {
346          const float cosRad = cosf(rad);
347          const float sinRad = sinf(rad);
348          return Mat4(cosRad, 0.0f, -sinRad, 0.0f,
349                      0.0f, 1.0f, 0.0f, 0.0f,
350                      sinRad, 0.0f, cosRad, 0.0f,
351                      0.0f, 0.0f, 0.0f, 1.0f);
352      }
353      static inline Mat4 makeZRotation(float rad)
354      {
355          const float cosRad = cosf(rad);
356          const float sinRad = sinf(rad);
357          return Mat4(cosRad, sinRad, 0.0f, 0.0f,
358                      -sinRad, cosRad, 0.0f, 0.0f,
359                      0.0f, 0.0f, 1.0f, 0.0f,
360                      0.0f, 0.0f, 0.0f, 1.0f);
361      }
362      static inline Mat4 makePerspective(float fovyRad, float aspect, float nearZ, float farZ)
363      {
364          const float cotan = 1.0f / tanf(fovyRad / 2.0f);
365          return Mat4(cotan / aspect, 0.0f, 0.0f, 0.0f,
366                      0.0f, cotan, 0.0f, 0.0f,
367                      0.0f, 0.0f, (farZ + nearZ) / (nearZ - farZ), -1.0f,
368                      0.0f, 0.0f, (2.0f * farZ * nearZ) / (nearZ - farZ), 0.0f);
369      }
370      static inline Mat4 makeFrustum(float left, float right, float bottom, float top, float nearZ, float farZ)
371      {
372          const float ral = right + left;
373          const float rsl = right - left;
374          const float tsb = top - bottom;
375          const float tab = top + bottom;
376          const float fan = farZ + nearZ;
377          const float fsn = farZ - nearZ;
378          return Mat4(2.0f * nearZ / rsl, 0.0f, 0.0f, 0.0f,
379                      0.0f, 2.0f * nearZ / tsb, 0.0f, 0.0f,
380                      ral / rsl, tab / tsb, -fan / fsn, -1.0f,
381                      0.0f, 0.0f, (-2.0f * farZ * nearZ) / fsn, 0.0f);
382      }
383      static inline Mat4 makeOrtho(float left, float right, float bottom, float top, float nearZ, float farZ)
384      {
385          const float ral = right + left;
386          const float rsl = right - left;
387          const float tsb = top - bottom;
388          const float tab = top + bottom;
389          const float fan = farZ + nearZ;
390          const float fsn = farZ - nearZ;
391          return Mat4(2.0f / rsl, 0.0f, 0.0f, 0.0f,
392                      0.0f, 2.0f / tsb, 0.0f, 0.0f,
393                      0.0f, 0.0f, -2.0f / fsn, 0.0f,
394                      -ral / rsl, -tab / tsb, -fan / fsn, 1.0f);
395      }
396      static inline Mat4 makeLookAt(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ)
397      {
398          Vec3f ev(eyeX, eyeY, eyeZ);
399          Vec3f cv(centerX, centerY, centerZ);
400          Vec3f uv(upX, upY, upZ);
401          return makeLookAt(ev, cv, uv);
402      }
403      static inline Mat4 makeLookAt(const Vec3f& eye, const Vec3f& center, const Vec3f& up)
404      {
405          Vec3f forward((eye - center).normalize());
406          Vec3f side(crossV3f(up, forward).normalize());
407          Vec3f upVector(crossV3f(forward, side));
408          return Mat4(side[0], upVector[0], forward[0], 0.0f,
409                      side[1], upVector[1], forward[1], 0.0f,
410                      side[2], upVector[2], forward[2], 0.0f,
411                      -side.dot(eye),
412                      -upVector.dot(eye),
413                      -forward.dot(eye),
414                      1.0f);
415      }
416      static inline Mat4 mat4Rotate(Mat4& m, float rad, float x, float y, float z)
417      {
418          return m * makeRotation(rad, x, y, z);
419      }
420      static inline Mat4 mat4RotateX(Mat4& m, float rad)
421      {
422          return m * makeXRotation(rad);
423      }
424      static inline Mat4 mat4RotateY(Mat4& m, float rad)
425      {
426          return m * makeYRotation(rad);
427      }
428      static inline Mat4 mat4RotateZ(Mat4& m, float rad)
429      {
430          return m * makeZRotation(rad);
431      }
432      static inline Vec3f mat4MulVec3WithTranslation(Mat4& m, Vec3f& v)
433      {
434          return Vec3f(
435              m[0][0] * v[0] + m[0][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3],
436              m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3],
437              m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3]);
438      }
439      static inline Vec3f mat4MulAndProjVec3(Mat4& m, Vec3f& v3)
440      {
441          Vec4f v4 = m * Vec4f(v3[0], v3[1], v3[2], 1.0f);
442          return Vec3f(v4[0], v4[1], v4[2]) / v4[3];
443      }
444      static inline bool projectM4fPerspective(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewPort, Vec3f& winCoord)
445      {
446          float fTempo[8];
447          fTempo[0] = modelView[0][0] * obj[0] + modelView[1][0] * obj[1] + modelView[2][0] * obj[2] + modelView[3][0]; 
448          fTempo[1] = modelView[0][1] * obj[0] + modelView[1][1] * obj[1] + modelView[2][1] * obj[2] + modelView[3][1];
449          fTempo[2] = modelView[0][2] * obj[0] + modelView[1][2] * obj[1] + modelView[2][2] * obj[2] + modelView[3][2];
450          fTempo[3] = modelView[0][3] * obj[0] + modelView[1][3] * obj[1] + modelView[2][3] * obj[2] + modelView[3][3];
451          fTempo[4] = proj[0][0] * fTempo[0] + proj[1][0] * fTempo[1] + proj[2][0] * fTempo[2] + proj[3][0] * fTempo[3];
452          fTempo[5] = proj[0][1] * fTempo[0] + proj[1][1] * fTempo[1] + proj[2][1] * fTempo[2] + proj[3][1] * fTempo[3];
453          fTempo[6] = proj[0][2] * fTempo[0] + proj[1][2] * fTempo[1] + proj[2][2] * fTempo[2] + proj[3][2] * fTempo[3];
454          fTempo[7] = -fTempo[2];
455          if (fTempo[7] == 0.0f) 
456              return false;
457          fTempo[7] = 1.0f / fTempo[7];
458          fTempo[4] *= fTempo[7];
459          fTempo[5] *= fTempo[7];
460          fTempo[6] *= fTempo[7];
461          winCoord[0] = (fTempo[4] * 0.5f + 0.5f) * viewPort[2] + viewPort[0];
462          winCoord[1] = (fTempo[5] * 0.5f + 0.5f) * viewPort[3] + viewPort[1];
463          winCoord[2] = (1.0f + fTempo[6]) * 0.5f; 
464          return true;
465      }
466      static inline bool projectM4fPerspective(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewPort, Vec2f& winCoord)
467      {
468          float fTempo[8];
469          fTempo[0] = modelView[0][0] * obj[0] + modelView[1][0] * obj[1] + modelView[2][0] * obj[2] + modelView[3][0]; 
470          fTempo[1] = modelView[0][1] * obj[0] + modelView[1][1] * obj[1] + modelView[2][1] * obj[2] + modelView[3][1];
471          fTempo[2] = modelView[0][2] * obj[0] + modelView[1][2] * obj[1] + modelView[2][2] * obj[2] + modelView[3][2];
472          fTempo[3] = modelView[0][3] * obj[0] + modelView[1][3] * obj[1] + modelView[2][3] * obj[2] + modelView[3][3];
473          fTempo[4] = proj[0][0] * fTempo[0] + proj[1][0] * fTempo[1] + proj[2][0] * fTempo[2] + proj[3][0] * fTempo[3];
474          fTempo[5] = proj[0][1] * fTempo[0] + proj[1][1] * fTempo[1] + proj[2][1] * fTempo[2] + proj[3][1] * fTempo[3];
475          fTempo[6] = proj[0][2] * fTempo[0] + proj[1][2] * fTempo[1] + proj[2][2] * fTempo[2] + proj[3][2] * fTempo[3];
476          fTempo[7] = -fTempo[2];
477          if (fTempo[7] == 0.0f) 
478              return false;
479          fTempo[7] = 1.0f / fTempo[7];
480          fTempo[4] *= fTempo[7];
481          fTempo[5] *= fTempo[7];
482          fTempo[6] *= fTempo[7];
483          winCoord[0] = (fTempo[4] * 0.5f + 0.5f) * viewPort[2] + viewPort[0];
484          winCoord[1] = (fTempo[5] * 0.5f + 0.5f) * viewPort[3] + viewPort[1];
485          return true;
486      }
487      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewport, Vec3f& winCoord)
488      {
489          Vec4f result = (modelView * Vec4f(obj[0], obj[1], obj[2], 1.0f)) * proj;
490          if (result[3] == 0.0f)
491              return false;
492          result[0] /= result[3];
493          result[1] /= result[3];
494          result[2] /= result[3];
495          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
496          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
497          winCoord[2] = (1.0f + result[2]) / 2.0f;
498          return true;
499      }
500      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewport, Vec2f& winCoord)
501      {
502          Vec4f result = (modelView * Vec4f(obj[0], obj[1], obj[2], 1.0f)) * proj;
503          if (result[3] == 0.0f)
504              return false;
505          result[0] /= result[3];
506          result[1] /= result[3];
507          result[2] /= result[3];
508          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
509          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
510          return true;
511      }
512      static inline bool projectM4f(const Vec2f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewport, Vec2f& winCoord)
513      {
514          Vec4f result = (modelView * Vec4f(obj[0], obj[1], 0.0f, 1.0f)) * proj;
515          if (result[3] == 0.0f)
516              return false;
517          result[0] /= result[3];
518          result[1] /= result[3];
519          result[2] /= result[3];
520          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
521          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
522          return true;
523      }
524      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelViewProjection, const Vec4f& viewport, Vec3f& winCoord)
525      {
526          Vec4f result = modelViewProjection * Vec4f(obj[0], obj[1], obj[2], 1.0f);
527          if (result[3] == 0.0f)
528              return false;
529          result[0] /= result[3];
530          result[1] /= result[3];
531          result[2] /= result[3];
532          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
533          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
534          winCoord[2] = (1.0f + result[2]) / 2.0f;
535          return true;
536      }
537      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelViewProjection, const Vec4f& viewport, Vec2f& winCoord)
538      {
539          Vec4f result = modelViewProjection * Vec4f(obj[0], obj[1], obj[2], 1.0f);
540          if (result[3] == 0.0f)
541              return false;
542          result[0] /= result[3];
543          result[1] /= result[3];
544          result[2] /= result[3];
545          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
546          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
547          return true;
548      }
549      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, Vec2f& winCoord, float width = 1.0f, float height = 1.0f)
550      {
551          Vec4f result = (modelView * Vec4f(obj[0], obj[1], obj[2], 1.0f)) * proj;
552          if (result[3] == 0.0f)
553              return false;
554          result[0] /= result[3];
555          result[1] /= result[3];
556          winCoord[0] = (1.0f + result[0]) * width / 2.0f;
557          winCoord[1] = (1.0f + result[1]) * height / 2.0f;
558          return true;
559      }
560      static inline bool projectM4f(const Vec3f& obj, const Mat4& mvp, Vec2f& winCoord, float width = 1.0f, float height = 1.0f)
561      {
562          Vec4f result = mvp * Vec4f(obj[0], obj[1], obj[2], 1.0f);
563          if (result[3] == 0.0f)
564              return false;
565          result[0] /= result[3];
566          result[1] /= result[3];
567          winCoord[0] = (1.0f + result[0]) * width / 2.0f;
568          winCoord[1] = (1.0f + result[1]) * height / 2.0f;
569          return true;
570      }
571      inline float* operator[](int index)
572      {
573          return data[index];
574      }
575      inline const float* operator[](int index) const
576      {
577          return data[index];
578      }
579      Mat4() {}
580      Mat4(float m00, float m01, float m02, float m03,
581           float m10, float m11, float m12, float m13,
582           float m20, float m21, float m22, float m23,
583           float m30, float m31, float m32, float m33)
584      {
585          makeMatrix(*this, m00, m01, m02, m03,
586                     m10, m11, m12, m13,
587                     m20, m21, m22, m23,
588                     m30, m31, m32, m33);
589      }
590      Mat4(float values[16])
591      {
592          makeMatrix(*this, values[0], values[1], values[2], values[3],
593                     values[4], values[5], values[6], values[7],
594                     values[8], values[9], values[10], values[11],
595                     values[12], values[13], values[14], values[15]);
596      }
597      Mat4(Vec4f row0, Vec4f row1, Vec4f row2, Vec4f row3)
598      {
599          makeMatrix(*this, row0[0], row0[1], row0[2], row0[3],
600                     row1[0], row1[1], row1[2], row1[3],
601                     row2[0], row2[1], row2[2], row2[3],
602                     row3[0], row3[1], row3[2], row3[3]);
603      }
604      Mat4(Mat3& m, float v)
605      {
606          makeMatrix(*this, m[0][0], m[0][1], m[0][2], v,
607                     m[1][0], m[1][1], m[1][2], v,
608                     m[2][0], m[2][1], m[2][2], v,
609                     v, v, v, v);
610      }
611      inline const Mat4& transPose()
612      {
613          return makeMatrix(*this, data[0][0], data[1][0], data[2][0], data[3][0],
614                            data[0][1], data[1][1], data[2][1], data[3][1],
615                            data[0][2], data[1][2], data[2][2], data[3][2],
616                            data[0][3], data[1][3], data[2][3], data[3][3]);
617      }
618      inline void loadIdentity()
619      {
620          *this = makeIdentity();
621      }
622      inline const Mat4& initWithQuaternion(float x, float y, float z, float w)
623      {
624          normalize(x, y, z, w);
625          const float _2x = x + x;
626          const float _2y = y + y;
627          const float _2z = z + z;
628          const float _2w = w + w;
629          makeMatrix(*this, 1.0f - _2y * y - _2z * z,
630                     _2x * y + _2w * z,
631                     _2x * z - _2w * y,
632                     0.0f,
633                     _2x * y - _2w * z,
634                     1.0f - _2x * x - _2z * z,
635                     _2y * z + _2w * x,
636                     0.0f,
637                     _2x * z + _2w * y,
638                     _2y * z - _2w * x,
639                     1.0f - _2x * x - _2y * y,
640                     0.0f,
641                     0.0f,
642                     0.0f,
643                     0.0f,
644                     1.0f);
645          return *this;
646      }
647      inline Mat3 getMat3()
648      {
649          return Mat3(data[0][0], data[0][1], data[0][2],
650                      data[1][0], data[1][1], data[1][2],
651                      data[2][0], data[2][1], data[2][2]);
652      }
653      inline Mat2 getMat2()
654      {
655          return Mat2(data[0][0], data[0][1],
656                      data[1][0], data[1][1]);
657      }
658      inline Mat4 operator*(const Mat4& m) const
659      {
660          return Mat4(data[0][0] * m[0][0] + data[1][0] * m[0][1] + data[2][0] * m[0][2] + data[3][0] * m[0][3],
661                      data[0][1] * m[0][0] + data[1][1] * m[0][1] + data[2][1] * m[0][2] + data[3][1] * m[0][3],
662                      data[0][2] * m[0][0] + data[1][2] * m[0][1] + data[2][2] * m[0][2] + data[3][2] * m[0][3],
663                      data[0][3] * m[0][0] + data[1][3] * m[0][1] + data[2][3] * m[0][2] + data[3][3] * m[0][3],
664                      data[0][0] * m[1][0] + data[1][0] * m[1][1] + data[2][0] * m[1][2] + data[3][0] * m[1][3],
665                      data[0][1] * m[1][0] + data[1][1] * m[1][1] + data[2][1] * m[1][2] + data[3][1] * m[1][3],
666                      data[0][2] * m[1][0] + data[1][2] * m[1][1] + data[2][2] * m[1][2] + data[3][2] * m[1][3],
667                      data[0][3] * m[1][0] + data[1][3] * m[1][1] + data[2][3] * m[1][2] + data[3][3] * m[1][3],
668                      data[0][0] * m[2][0] + data[1][0] * m[2][1] + data[2][0] * m[2][2] + data[3][0] * m[2][3],
669                      data[0][1] * m[2][0] + data[1][1] * m[2][1] + data[2][1] * m[2][2] + data[3][1] * m[2][3],
670                      data[0][2] * m[2][0] + data[1][2] * m[2][1] + data[2][2] * m[2][2] + data[3][2] * m[2][3],
671                      data[0][3] * m[2][0] + data[1][3] * m[2][1] + data[2][3] * m[2][2] + data[3][3] * m[2][3],
672                      data[0][0] * m[3][0] + data[1][0] * m[3][1] + data[2][0] * m[3][2] + data[3][0] * m[3][3],
673                      data[0][1] * m[3][0] + data[1][1] * m[3][1] + data[2][1] * m[3][2] + data[3][1] * m[3][3],
674                      data[0][2] * m[3][0] + data[1][2] * m[3][1] + data[2][2] * m[3][2] + data[3][2] * m[3][3],
675                      data[0][3] * m[3][0] + data[1][3] * m[3][1] + data[2][3] * m[3][2] + data[3][3] * m[3][3]);
676      }
677      inline Mat4 operator*(const Mat3& m) const
678      {
679          return Mat4(data[0][0] * m[0][0] + data[1][0] * m[0][1] + data[2][0] * m[0][2],
680                      data[0][1] * m[0][0] + data[1][1] * m[0][1] + data[2][1] * m[0][2],
681                      data[0][2] * m[0][0] + data[1][2] * m[0][1] + data[2][2] * m[0][2],
682                      data[0][3] * m[0][0] + data[1][3] * m[0][1] + data[2][3] * m[0][2],
683                      data[0][0] * m[1][0] + data[1][0] * m[1][1] + data[2][0] * m[1][2],
684                      data[0][1] * m[1][0] + data[1][1] * m[1][1] + data[2][1] * m[1][2],
685                      data[0][2] * m[1][0] + data[1][2] * m[1][1] + data[2][2] * m[1][2],
686                      data[0][3] * m[1][0] + data[1][3] * m[1][1] + data[2][3] * m[1][2],
687                      data[0][0] * m[2][0] + data[1][0] * m[2][1] + data[2][0] * m[2][2],
688                      data[0][1] * m[2][0] + data[1][1] * m[2][1] + data[2][1] * m[2][2],
689                      data[0][2] * m[2][0] + data[1][2] * m[2][1] + data[2][2] * m[2][2],
690                      data[0][3] * m[2][0] + data[1][3] * m[2][1] + data[2][3] * m[2][2],
691                      data[3][0],
692                      data[3][1],
693                      data[3][2],
694                      data[3][3]);
695      }
696      inline Mat4& operator*=(const Mat4& m)
697      {
698          *this = *this * m;
699          return *this;
700      }
701      inline Vec4f operator*(const Vec4f& v) const
702      {
703          return Vec4f(
704              data[0][0] * v[0] + data[1][0] * v[1] + data[2][0] * v[2] + data[3][0] * v[3],
705              data[0][1] * v[0] + data[1][1] * v[1] + data[2][1] * v[2] + data[3][1] * v[3],
706              data[0][2] * v[0] + data[1][2] * v[1] + data[2][2] * v[2] + data[3][2] * v[3],
707              data[0][3] * v[0] + data[1][3] * v[1] + data[2][3] * v[2] + data[3][3] * v[3]);
708      }
709      inline Vec3f operator*(const Vec3f& v) const
710      {
711          return Vec3f(data[0][0] * v[0] + data[1][0] * v[1] + data[2][0] * v[2],
712                       data[0][1] * v[0] + data[1][1] * v[1] + data[2][1] * v[2],
713                       data[0][2] * v[0] + data[1][2] * v[1] + data[2][2] * v[2]);
714      }
715      friend inline Vec4f operator*(const Vec4f& v, const Mat4& m)
716      {
717          return m * v;
718      }
719      friend inline Vec3f operator*(const Vec3f& v, const Mat4& m)
720      {
721          return m * v;
722      }
723      inline Mat4 operator+(const Mat4& m) const
724      {
725          return Mat4(data[0][0] + m[0][0],
726                      data[0][1] + m[0][1],
727                      data[0][2] + m[0][2],
728                      data[0][3] + m[0][3],
729                      data[1][0] + m[1][0],
730                      data[1][1] + m[1][1],
731                      data[1][2] + m[1][2],
732                      data[1][3] + m[1][3],
733                      data[2][0] + m[2][0],
734                      data[2][1] + m[2][1],
735                      data[2][2] + m[2][2],
736                      data[2][3] + m[2][3],
737                      data[3][0] + m[3][0],
738                      data[3][1] + m[3][1],
739                      data[3][2] + m[3][2],
740                      data[3][3] + m[3][3]);
741      }
742      inline Mat4& operator+=(const Mat4& m)
743      {
744          *this = *this + m;
745          return *this;
746      }
747      inline Mat4 operator-(const Mat4& m) const
748      {
749          return Mat4(data[0][0] - m[0][0],
750                      data[0][1] - m[0][1],
751                      data[0][2] - m[0][2],
752                      data[0][3] - m[0][3],
753                      data[1][0] - m[1][0],
754                      data[1][1] - m[1][1],
755                      data[1][2] - m[1][2],
756                      data[1][3] - m[1][3],
757                      data[2][0] - m[2][0],
758                      data[2][1] - m[2][1],
759                      data[2][2] - m[2][2],
760                      data[2][3] - m[2][3],
761                      data[3][0] - m[3][0],
762                      data[3][1] - m[3][1],
763                      data[3][2] - m[3][2],
764                      data[3][3] - m[3][3]);
765      }
766      inline Mat4& operator-=(const Mat4& m)
767      {
768          *this = *this - m;
769          return *this;
770      }
771      inline void translateX(float x)
772      {
773          data[3][0] += data[0][0] * x;
774          data[3][1] += data[0][1] * x;
775          data[3][2] += data[0][2] * x;
776      }
777      inline void translateY(float y)
778      {
779          data[3][0] += data[1][0] * y;
780          data[3][1] += data[1][1] * y;
781          data[3][2] += data[1][2] * y;
782      }
783      inline void translateZ(float z)
784      {
785          data[3][0] += data[2][0] * z;
786          data[3][1] += data[2][1] * z;
787          data[3][2] += data[2][2] * z;
788      }
789      inline void translate(float x, float y, float z)
790      {
791          data[3][0] += data[0][0] * x + data[1][0] * y + data[2][0] * z;
792          data[3][1] += data[0][1] * x + data[1][1] * y + data[2][1] * z;
793          data[3][2] += data[0][2] * x + data[1][2] * y + data[2][2] * z;
794      }
795      inline void scaleX(float x)
796      {
797          data[0][0] *= x;
798          data[0][1] *= x;
799          data[0][2] *= x;
800          data[0][3] *= x;
801      }
802      inline void scaleY(float y)
803      {
804          data[1][0] *= y;
805          data[1][1] *= y;
806          data[1][2] *= y;
807          data[1][3] *= y;
808      }
809      inline void scaleZ(float z)
810      {
811          data[2][0] *= z;
812          data[2][1] *= z;
813          data[2][2] *= z;
814          data[2][3] *= z;
815      }
816      inline void scale(float x, float y, float z)
817      {
818          scaleX(x);
819          scaleY(y);
820          scaleZ(z);
821      }
822      inline void rotate(float rad, float x, float y, float z)
823      {
824          *this *= makeRotation(rad, x, y, z);
825      }
826      inline void rotateX(float rad)
827      {
828          *this *= makeXRotation(rad);
829      }
830      inline void rotateY(float rad)
831      {
832          *this *= makeYRotation(rad);
833      }
834      inline void rotateZ(float rad)
835      {
836          *this *= makeZRotation(rad);
837      }
838      inline Mat3 toMat3()
839      {
840          return Mat3(data[0][0], data[0][1], data[0][2],
841                      data[1][0], data[1][1], data[1][2],
842                      data[2][0], data[2][1], data[2][2]);
843      }
844      float data[4][4];
845  };
846  } 
847  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_csp_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <math.h>
4  #include "src/enc/vp8i_enc.h"
5  #include "src/utils/random_utils.h"
6  #include "src/utils/utils.h"
7  #include "src/dsp/dsp.h"
8  #include "src/dsp/lossless.h"
9  #include "src/dsp/yuv.h"
10  #define USE_GAMMA_COMPRESSION
11  #define USE_INVERSE_ALPHA_TABLE
12  #ifdef WORDS_BIGENDIAN
13  #define CHANNEL_OFFSET(i) (i)
14  #else
15  #define CHANNEL_OFFSET(i) (3-(i))
16  #endif
17  #define ALPHA_OFFSET CHANNEL_OFFSET(0)
18  static int CheckNonOpaque(const uint8_t* alpha, int width, int height,
19                            int x_step, int y_step) {
20    if (alpha == NULL) return 0;
21    WebPInitAlphaProcessing();
22    if (x_step == 1) {
23      for (; height-- > 0; alpha += y_step) {
24        if (WebPHasAlpha8b(alpha, width)) return 1;
25      }
26    } else {
27      for (; height-- > 0; alpha += y_step) {
28        if (WebPHasAlpha32b(alpha, width)) return 1;
29      }
30    }
31    return 0;
32  }
33  int WebPPictureHasTransparency(const WebPPicture* picture) {
34    if (picture == NULL) return 0;
35    if (!picture->use_argb) {
36      return CheckNonOpaque(picture->a, picture->width, picture->height,
37                            1, picture->a_stride);
38    } else {
39      const int alpha_offset = ALPHA_OFFSET;
40      return CheckNonOpaque((const uint8_t*)picture->argb + alpha_offset,
41                            picture->width, picture->height,
42                            4, picture->argb_stride * sizeof(*picture->argb));
43    }
44    return 0;
45  }
46  #if defined(USE_GAMMA_COMPRESSION)
47  #define kGamma 0.80      
48  #define kGammaFix 12     
49  #define kGammaScale ((1 << kGammaFix) - 1)
50  #define kGammaTabFix 7   
51  #define kGammaTabScale (1 << kGammaTabFix)
52  #define kGammaTabRounder (kGammaTabScale >> 1)
53  #define kGammaTabSize (1 << (kGammaFix - kGammaTabFix))
54  static int kLinearToGammaTab[kGammaTabSize + 1];
55  static uint16_t kGammaToLinearTab[256];
56  static volatile int kGammaTablesOk = 0;
57  static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTables(void) {
58    if (!kGammaTablesOk) {
59      int v;
60      const double scale = (double)(1 << kGammaTabFix) / kGammaScale;
61      const double norm = 1. / 255.;
62      for (v = 0; v <= 255; ++v) {
63        kGammaToLinearTab[v] =
64            (uint16_t)(pow(norm * v, kGamma) * kGammaScale + .5);
65      }
66      for (v = 0; v <= kGammaTabSize; ++v) {
67        kLinearToGammaTab[v] = (int)(255. * pow(scale * v, 1. / kGamma) + .5);
68      }
69      kGammaTablesOk = 1;
70    }
71  }
72  static WEBP_INLINE uint32_t GammaToLinear(uint8_t v) {
73    return kGammaToLinearTab[v];
74  }
75  static WEBP_INLINE int Interpolate(int v) {
76    const int tab_pos = v >> (kGammaTabFix + 2);    
77    const int x = v & ((kGammaTabScale << 2) - 1);  
78    const int v0 = kLinearToGammaTab[tab_pos];
79    const int v1 = kLinearToGammaTab[tab_pos + 1];
80    const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   
81    assert(tab_pos + 1 < kGammaTabSize + 1);
82    return y;
83  }
84  static WEBP_INLINE int LinearToGamma(uint32_t base_value, int shift) {
85    const int y = Interpolate(base_value << shift);   
86    return (y + kGammaTabRounder) >> kGammaTabFix;    
87  }
88  #else
89  static void InitGammaTables(void) {}
90  static WEBP_INLINE uint32_t GammaToLinear(uint8_t v) { return v; }
91  static WEBP_INLINE int LinearToGamma(uint32_t base_value, int shift) {
92    return (int)(base_value << shift);
93  }
94  #endif    
95  static int RGBToY(int r, int g, int b, VP8Random* const rg) {
96    return (rg == NULL) ? VP8RGBToY(r, g, b, YUV_HALF)
97                        : VP8RGBToY(r, g, b, VP8RandomBits(rg, YUV_FIX));
98  }
99  static int RGBToU(int r, int g, int b, VP8Random* const rg) {
100    return (rg == NULL) ? VP8RGBToU(r, g, b, YUV_HALF << 2)
101                        : VP8RGBToU(r, g, b, VP8RandomBits(rg, YUV_FIX + 2));
102  }
103  static int RGBToV(int r, int g, int b, VP8Random* const rg) {
104    return (rg == NULL) ? VP8RGBToV(r, g, b, YUV_HALF << 2)
105                        : VP8RGBToV(r, g, b, VP8RandomBits(rg, YUV_FIX + 2));
106  }
107  static const int kNumIterations = 4;
108  static const int kMinDimensionIterativeConversion = 4;
109  #define SFIX 2                
110  typedef int16_t fixed_t;      
111  typedef uint16_t fixed_y_t;   
112  #define SHALF (1 << SFIX >> 1)
113  #define MAX_Y_T ((256 << SFIX) - 1)
114  #define SROUNDER (1 << (YUV_FIX + SFIX - 1))
115  #if defined(USE_GAMMA_COMPRESSION)
116  #define kGammaF (1./0.45)
117  static uint32_t kLinearToGammaTabS[kGammaTabSize + 2];
118  #define GAMMA_TO_LINEAR_BITS 14
119  static uint32_t kGammaToLinearTabS[MAX_Y_T + 1];   
120  static volatile int kGammaTablesSOk = 0;
121  static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTablesS(void) {
122    assert(2 * GAMMA_TO_LINEAR_BITS < 32);  
123    if (!kGammaTablesSOk) {
124      int v;
125      const double norm = 1. / MAX_Y_T;
126      const double scale = 1. / kGammaTabSize;
127      const double a = 0.09929682680944;
128      const double thresh = 0.018053968510807;
129      const double final_scale = 1 << GAMMA_TO_LINEAR_BITS;
130      for (v = 0; v <= MAX_Y_T; ++v) {
131        const double g = norm * v;
132        double value;
133        if (g <= thresh * 4.5) {
134          value = g / 4.5;
135        } else {
136          const double a_rec = 1. / (1. + a);
137          value = pow(a_rec * (g + a), kGammaF);
138        }
139        kGammaToLinearTabS[v] = (uint32_t)(value * final_scale + .5);
140      }
141      for (v = 0; v <= kGammaTabSize; ++v) {
142        const double g = scale * v;
143        double value;
144        if (g <= thresh) {
145          value = 4.5 * g;
146        } else {
147          value = (1. + a) * pow(g, 1. / kGammaF) - a;
148        }
149        kLinearToGammaTabS[v] =
150            (uint32_t)(MAX_Y_T * value) + (1 << GAMMA_TO_LINEAR_BITS >> 1);
151      }
152      kLinearToGammaTabS[kGammaTabSize + 1] = kLinearToGammaTabS[kGammaTabSize];
153      kGammaTablesSOk = 1;
154    }
155  }
156  static WEBP_INLINE uint32_t GammaToLinearS(int v) {
157    return kGammaToLinearTabS[v];
158  }
159  static WEBP_INLINE uint32_t LinearToGammaS(uint32_t value) {
160    const uint32_t v = value * kGammaTabSize;
161    const uint32_t tab_pos = v >> GAMMA_TO_LINEAR_BITS;
162    const uint32_t x = v - (tab_pos << GAMMA_TO_LINEAR_BITS);  
163    const uint32_t v0 = kLinearToGammaTabS[tab_pos + 0];
164    const uint32_t v1 = kLinearToGammaTabS[tab_pos + 1];
165    const uint32_t v2 = (v1 - v0) * x;    
166    const uint32_t result = v0 + (v2 >> GAMMA_TO_LINEAR_BITS);
167    return result;
168  }
169  #else
170  static void InitGammaTablesS(void) {}
171  static WEBP_INLINE uint32_t GammaToLinearS(int v) {
172    return (v << GAMMA_TO_LINEAR_BITS) / MAX_Y_T;
173  }
174  static WEBP_INLINE uint32_t LinearToGammaS(uint32_t value) {
175    return (MAX_Y_T * value) >> GAMMA_TO_LINEAR_BITS;
176  }
177  #endif    
178  static uint8_t clip_8b(fixed_t v) {
179    return (!(v & ~0xff)) ? (uint8_t)v : (v < 0) ? 0u : 255u;
180  }
181  static fixed_y_t clip_y(int y) {
182    return (!(y & ~MAX_Y_T)) ? (fixed_y_t)y : (y < 0) ? 0 : MAX_Y_T;
183  }
184  static int RGBToGray(int r, int g, int b) {
185    const int luma = 13933 * r + 46871 * g + 4732 * b + YUV_HALF;
186    return (luma >> YUV_FIX);
187  }
188  static uint32_t ScaleDown(int a, int b, int c, int d) {
189    const uint32_t A = GammaToLinearS(a);
190    const uint32_t B = GammaToLinearS(b);
191    const uint32_t C = GammaToLinearS(c);
192    const uint32_t D = GammaToLinearS(d);
193    return LinearToGammaS((A + B + C + D + 2) >> 2);
194  }
195  static WEBP_INLINE void UpdateW(const fixed_y_t* src, fixed_y_t* dst, int w) {
196    int i;
197    for (i = 0; i < w; ++i) {
198      const uint32_t R = GammaToLinearS(src[0 * w + i]);
199      const uint32_t G = GammaToLinearS(src[1 * w + i]);
200      const uint32_t B = GammaToLinearS(src[2 * w + i]);
201      const uint32_t Y = RGBToGray(R, G, B);
202      dst[i] = (fixed_y_t)LinearToGammaS(Y);
203    }
204  }
205  static void UpdateChroma(const fixed_y_t* src1, const fixed_y_t* src2,
206                           fixed_t* dst, int uv_w) {
207    int i;
208    for (i = 0; i < uv_w; ++i) {
209      const int r = ScaleDown(src1[0 * uv_w + 0], src1[0 * uv_w + 1],
210                              src2[0 * uv_w + 0], src2[0 * uv_w + 1]);
211      const int g = ScaleDown(src1[2 * uv_w + 0], src1[2 * uv_w + 1],
212                              src2[2 * uv_w + 0], src2[2 * uv_w + 1]);
213      const int b = ScaleDown(src1[4 * uv_w + 0], src1[4 * uv_w + 1],
214                              src2[4 * uv_w + 0], src2[4 * uv_w + 1]);
215      const int W = RGBToGray(r, g, b);
216      dst[0 * uv_w] = (fixed_t)(r - W);
217      dst[1 * uv_w] = (fixed_t)(g - W);
218      dst[2 * uv_w] = (fixed_t)(b - W);
219      dst  += 1;
220      src1 += 2;
221      src2 += 2;
222    }
223  }
224  static void StoreGray(const fixed_y_t* rgb, fixed_y_t* y, int w) {
225    int i;
226    for (i = 0; i < w; ++i) {
227      y[i] = RGBToGray(rgb[0 * w + i], rgb[1 * w + i], rgb[2 * w + i]);
228    }
229  }
230  static WEBP_INLINE fixed_y_t Filter2(int A, int B, int W0) {
231    const int v0 = (A * 3 + B + 2) >> 2;
232    return clip_y(v0 + W0);
233  }
234  static WEBP_INLINE fixed_y_t UpLift(uint8_t a) {  
235    return ((fixed_y_t)a << SFIX) | SHALF;
236  }
237  static void ImportOneRow(const uint8_t* const r_ptr,
238                           const uint8_t* const g_ptr,
239                           const uint8_t* const b_ptr,
240                           int step,
241                           int pic_width,
242                           fixed_y_t* const dst) {
243    int i;
244    const int w = (pic_width + 1) & ~1;
245    for (i = 0; i < pic_width; ++i) {
246      const int off = i * step;
247      dst[i + 0 * w] = UpLift(r_ptr[off]);
248      dst[i + 1 * w] = UpLift(g_ptr[off]);
249      dst[i + 2 * w] = UpLift(b_ptr[off]);
250    }
251    if (pic_width & 1) {  
252      dst[pic_width + 0 * w] = dst[pic_width + 0 * w - 1];
253      dst[pic_width + 1 * w] = dst[pic_width + 1 * w - 1];
254      dst[pic_width + 2 * w] = dst[pic_width + 2 * w - 1];
255    }
256  }
257  static void InterpolateTwoRows(const fixed_y_t* const best_y,
258                                 const fixed_t* prev_uv,
259                                 const fixed_t* cur_uv,
260                                 const fixed_t* next_uv,
261                                 int w,
262                                 fixed_y_t* out1,
263                                 fixed_y_t* out2) {
264    const int uv_w = w >> 1;
265    const int len = (w - 1) >> 1;   
266    int k = 3;
267    while (k-- > 0) {   
268      out1[0] = Filter2(cur_uv[0], prev_uv[0], best_y[0]);
269      out2[0] = Filter2(cur_uv[0], next_uv[0], best_y[w]);
270      WebPSharpYUVFilterRow(cur_uv, prev_uv, len, best_y + 0 + 1, out1 + 1);
271      WebPSharpYUVFilterRow(cur_uv, next_uv, len, best_y + w + 1, out2 + 1);
272      if (!(w & 1)) {
273        out1[w - 1] = Filter2(cur_uv[uv_w - 1], prev_uv[uv_w - 1],
274                              best_y[w - 1 + 0]);
275        out2[w - 1] = Filter2(cur_uv[uv_w - 1], next_uv[uv_w - 1],
276                              best_y[w - 1 + w]);
277      }
278      out1 += w;
279      out2 += w;
280      prev_uv += uv_w;
281      cur_uv  += uv_w;
282      next_uv += uv_w;
283    }
284  }
285  static WEBP_INLINE uint8_t ConvertRGBToY(int r, int g, int b) {
286    const int luma = 16839 * r + 33059 * g + 6420 * b + SROUNDER;
<span onclick='openModal()' class='match'>287    return clip_8b(16 + (luma >> (YUV_FIX + SFIX)));
288  }
289  static WEBP_INLINE uint8_t ConvertRGBToU(int r, int g, int b) {
290    const int u =  -9719 * r - 19081 * g + 28800 * b + SROUNDER;
</span>291    return clip_8b(128 + (u >> (YUV_FIX + SFIX)));
292  }
293  static WEBP_INLINE uint8_t ConvertRGBToV(int r, int g, int b) {
294    const int v = +28800 * r - 24116 * g -  4684 * b + SROUNDER;
295    return clip_8b(128 + (v >> (YUV_FIX + SFIX)));
296  }
297  static int ConvertWRGBToYUV(const fixed_y_t* best_y, const fixed_t* best_uv,
298                              WebPPicture* const picture) {
299    int i, j;
300    uint8_t* dst_y = picture->y;
301    uint8_t* dst_u = picture->u;
302    uint8_t* dst_v = picture->v;
303    const fixed_t* const best_uv_base = best_uv;
304    const int w = (picture->width + 1) & ~1;
305    const int h = (picture->height + 1) & ~1;
306    const int uv_w = w >> 1;
307    const int uv_h = h >> 1;
308    for (best_uv = best_uv_base, j = 0; j < picture->height; ++j) {
309      for (i = 0; i < picture->width; ++i) {
310        const int off = (i >> 1);
311        const int W = best_y[i];
312        const int r = best_uv[off + 0 * uv_w] + W;
313        const int g = best_uv[off + 1 * uv_w] + W;
314        const int b = best_uv[off + 2 * uv_w] + W;
315        dst_y[i] = ConvertRGBToY(r, g, b);
316      }
317      best_y += w;
318      best_uv += (j & 1) * 3 * uv_w;
319      dst_y += picture->y_stride;
320    }
321    for (best_uv = best_uv_base, j = 0; j < uv_h; ++j) {
322      for (i = 0; i < uv_w; ++i) {
323        const int off = i;
324        const int r = best_uv[off + 0 * uv_w];
325        const int g = best_uv[off + 1 * uv_w];
326        const int b = best_uv[off + 2 * uv_w];
327        dst_u[i] = ConvertRGBToU(r, g, b);
328        dst_v[i] = ConvertRGBToV(r, g, b);
329      }
330      best_uv += 3 * uv_w;
331      dst_u += picture->uv_stride;
332      dst_v += picture->uv_stride;
333    }
334    return 1;
335  }
336  #define SAFE_ALLOC(W, H, T) ((T*)WebPSafeMalloc((W) * (H), sizeof(T)))
337  static int PreprocessARGB(const uint8_t* r_ptr,
338                            const uint8_t* g_ptr,
339                            const uint8_t* b_ptr,
340                            int step, int rgb_stride,
341                            WebPPicture* const picture) {
342    const int w = (picture->width + 1) & ~1;
343    const int h = (picture->height + 1) & ~1;
344    const int uv_w = w >> 1;
345    const int uv_h = h >> 1;
346    uint64_t prev_diff_y_sum = ~0;
347    int j, iter;
348    fixed_y_t* const tmp_buffer = SAFE_ALLOC(w * 3, 2, fixed_y_t);   
349    fixed_y_t* const best_y_base = SAFE_ALLOC(w, h, fixed_y_t);
350    fixed_y_t* const target_y_base = SAFE_ALLOC(w, h, fixed_y_t);
351    fixed_y_t* const best_rgb_y = SAFE_ALLOC(w, 2, fixed_y_t);
352    fixed_t* const best_uv_base = SAFE_ALLOC(uv_w * 3, uv_h, fixed_t);
353    fixed_t* const target_uv_base = SAFE_ALLOC(uv_w * 3, uv_h, fixed_t);
354    fixed_t* const best_rgb_uv = SAFE_ALLOC(uv_w * 3, 1, fixed_t);
355    fixed_y_t* best_y = best_y_base;
356    fixed_y_t* target_y = target_y_base;
357    fixed_t* best_uv = best_uv_base;
358    fixed_t* target_uv = target_uv_base;
359    const uint64_t diff_y_threshold = (uint64_t)(3.0 * w * h);
360    int ok;
361    if (best_y_base == NULL || best_uv_base == NULL ||
362        target_y_base == NULL || target_uv_base == NULL ||
363        best_rgb_y == NULL || best_rgb_uv == NULL ||
364        tmp_buffer == NULL) {
365      ok = WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
366      goto End;
367    }
368    assert(picture->width >= kMinDimensionIterativeConversion);
369    assert(picture->height >= kMinDimensionIterativeConversion);
370    WebPInitConvertARGBToYUV();
371    for (j = 0; j < picture->height; j += 2) {
372      const int is_last_row = (j == picture->height - 1);
373      fixed_y_t* const src1 = tmp_buffer + 0 * w;
374      fixed_y_t* const src2 = tmp_buffer + 3 * w;
375      ImportOneRow(r_ptr, g_ptr, b_ptr, step, picture->width, src1);
376      if (!is_last_row) {
377        ImportOneRow(r_ptr + rgb_stride, g_ptr + rgb_stride, b_ptr + rgb_stride,
378                     step, picture->width, src2);
379      } else {
380        memcpy(src2, src1, 3 * w * sizeof(*src2));
381      }
382      StoreGray(src1, best_y + 0, w);
383      StoreGray(src2, best_y + w, w);
384      UpdateW(src1, target_y, w);
385      UpdateW(src2, target_y + w, w);
386      UpdateChroma(src1, src2, target_uv, uv_w);
387      memcpy(best_uv, target_uv, 3 * uv_w * sizeof(*best_uv));
388      best_y += 2 * w;
389      best_uv += 3 * uv_w;
390      target_y += 2 * w;
391      target_uv += 3 * uv_w;
392      r_ptr += 2 * rgb_stride;
393      g_ptr += 2 * rgb_stride;
394      b_ptr += 2 * rgb_stride;
395    }
396    for (iter = 0; iter < kNumIterations; ++iter) {
397      const fixed_t* cur_uv = best_uv_base;
398      const fixed_t* prev_uv = best_uv_base;
399      uint64_t diff_y_sum = 0;
400      best_y = best_y_base;
401      best_uv = best_uv_base;
402      target_y = target_y_base;
403      target_uv = target_uv_base;
404      for (j = 0; j < h; j += 2) {
405        fixed_y_t* const src1 = tmp_buffer + 0 * w;
406        fixed_y_t* const src2 = tmp_buffer + 3 * w;
407        {
408          const fixed_t* const next_uv = cur_uv + ((j < h - 2) ? 3 * uv_w : 0);
409          InterpolateTwoRows(best_y, prev_uv, cur_uv, next_uv, w, src1, src2);
410          prev_uv = cur_uv;
411          cur_uv = next_uv;
412        }
413        UpdateW(src1, best_rgb_y + 0 * w, w);
414        UpdateW(src2, best_rgb_y + 1 * w, w);
415        UpdateChroma(src1, src2, best_rgb_uv, uv_w);
416        diff_y_sum += WebPSharpYUVUpdateY(target_y, best_rgb_y, best_y, 2 * w);
417        WebPSharpYUVUpdateRGB(target_uv, best_rgb_uv, best_uv, 3 * uv_w);
418        best_y += 2 * w;
419        best_uv += 3 * uv_w;
420        target_y += 2 * w;
421        target_uv += 3 * uv_w;
422      }
423      if (iter > 0) {
424        if (diff_y_sum < diff_y_threshold) break;
425        if (diff_y_sum > prev_diff_y_sum) break;
426      }
427      prev_diff_y_sum = diff_y_sum;
428    }
429    ok = ConvertWRGBToYUV(best_y_base, best_uv_base, picture);
430   End:
431    WebPSafeFree(best_y_base);
432    WebPSafeFree(best_uv_base);
433    WebPSafeFree(target_y_base);
434    WebPSafeFree(target_uv_base);
435    WebPSafeFree(best_rgb_y);
436    WebPSafeFree(best_rgb_uv);
437    WebPSafeFree(tmp_buffer);
438    return ok;
439  }
440  #undef SAFE_ALLOC
441  #define SUM4(ptr, step) LinearToGamma(                     \
442      GammaToLinear((ptr)[0]) +                              \
443      GammaToLinear((ptr)[(step)]) +                         \
444      GammaToLinear((ptr)[rgb_stride]) +                     \
445      GammaToLinear((ptr)[rgb_stride + (step)]), 0)          \
446  
447  #define SUM2(ptr) \
448      LinearToGamma(GammaToLinear((ptr)[0]) + GammaToLinear((ptr)[rgb_stride]), 1)
449  #define SUM2ALPHA(ptr) ((ptr)[0] + (ptr)[rgb_stride])
450  #define SUM4ALPHA(ptr) (SUM2ALPHA(ptr) + SUM2ALPHA((ptr) + 4))
451  #if defined(USE_INVERSE_ALPHA_TABLE)
452  static const int kAlphaFix = 19;
453  static const uint32_t kInvAlpha[4 * 0xff + 1] = {
454    0,  &bsol;* alpha = 0 */
455    524288, 262144, 174762, 131072, 104857, 87381, 74898, 65536,
456    58254, 52428, 47662, 43690, 40329, 37449, 34952, 32768,
457    30840, 29127, 27594, 26214, 24966, 23831, 22795, 21845,
458    20971, 20164, 19418, 18724, 18078, 17476, 16912, 16384,
459    15887, 15420, 14979, 14563, 14169, 13797, 13443, 13107,
460    12787, 12483, 12192, 11915, 11650, 11397, 11155, 10922,
461    10699, 10485, 10280, 10082, 9892, 9709, 9532, 9362,
462    9198, 9039, 8886, 8738, 8594, 8456, 8322, 8192,
463    8065, 7943, 7825, 7710, 7598, 7489, 7384, 7281,
464    7182, 7084, 6990, 6898, 6808, 6721, 6636, 6553,
465    6472, 6393, 6316, 6241, 6168, 6096, 6026, 5957,
466    5890, 5825, 5761, 5698, 5637, 5577, 5518, 5461,
467    5405, 5349, 5295, 5242, 5190, 5140, 5090, 5041,
468    4993, 4946, 4899, 4854, 4809, 4766, 4723, 4681,
469    4639, 4599, 4559, 4519, 4481, 4443, 4405, 4369,
470    4332, 4297, 4262, 4228, 4194, 4161, 4128, 4096,
471    4064, 4032, 4002, 3971, 3942, 3912, 3883, 3855,
472    3826, 3799, 3771, 3744, 3718, 3692, 3666, 3640,
473    3615, 3591, 3566, 3542, 3518, 3495, 3472, 3449,
474    3426, 3404, 3382, 3360, 3339, 3318, 3297, 3276,
475    3256, 3236, 3216, 3196, 3177, 3158, 3139, 3120,
476    3102, 3084, 3066, 3048, 3030, 3013, 2995, 2978,
477    2962, 2945, 2928, 2912, 2896, 2880, 2864, 2849,
478    2833, 2818, 2803, 2788, 2774, 2759, 2744, 2730,
479    2716, 2702, 2688, 2674, 2661, 2647, 2634, 2621,
480    2608, 2595, 2582, 2570, 2557, 2545, 2532, 2520,
481    2508, 2496, 2484, 2473, 2461, 2449, 2438, 2427,
482    2416, 2404, 2394, 2383, 2372, 2361, 2351, 2340,
483    2330, 2319, 2309, 2299, 2289, 2279, 2269, 2259,
484    2250, 2240, 2231, 2221, 2212, 2202, 2193, 2184,
485    2175, 2166, 2157, 2148, 2139, 2131, 2122, 2114,
486    2105, 2097, 2088, 2080, 2072, 2064, 2056, 2048,
487    2040, 2032, 2024, 2016, 2008, 2001, 1993, 1985,
488    1978, 1971, 1963, 1956, 1949, 1941, 1934, 1927,
489    1920, 1913, 1906, 1899, 1892, 1885, 1879, 1872,
490    1865, 1859, 1852, 1846, 1839, 1833, 1826, 1820,
491    1814, 1807, 1801, 1795, 1789, 1783, 1777, 1771,
492    1765, 1759, 1753, 1747, 1741, 1736, 1730, 1724,
493    1718, 1713, 1707, 1702, 1696, 1691, 1685, 1680,
494    1675, 1669, 1664, 1659, 1653, 1648, 1643, 1638,
495    1633, 1628, 1623, 1618, 1613, 1608, 1603, 1598,
496    1593, 1588, 1583, 1579, 1574, 1569, 1565, 1560,
497    1555, 1551, 1546, 1542, 1537, 1533, 1528, 1524,
498    1519, 1515, 1510, 1506, 1502, 1497, 1493, 1489,
499    1485, 1481, 1476, 1472, 1468, 1464, 1460, 1456,
500    1452, 1448, 1444, 1440, 1436, 1432, 1428, 1424,
501    1420, 1416, 1413, 1409, 1405, 1401, 1398, 1394,
502    1390, 1387, 1383, 1379, 1376, 1372, 1368, 1365,
503    1361, 1358, 1354, 1351, 1347, 1344, 1340, 1337,
504    1334, 1330, 1327, 1323, 1320, 1317, 1314, 1310,
505    1307, 1304, 1300, 1297, 1294, 1291, 1288, 1285,
506    1281, 1278, 1275, 1272, 1269, 1266, 1263, 1260,
507    1257, 1254, 1251, 1248, 1245, 1242, 1239, 1236,
508    1233, 1230, 1227, 1224, 1222, 1219, 1216, 1213,
509    1210, 1208, 1205, 1202, 1199, 1197, 1194, 1191,
510    1188, 1186, 1183, 1180, 1178, 1175, 1172, 1170,
511    1167, 1165, 1162, 1159, 1157, 1154, 1152, 1149,
512    1147, 1144, 1142, 1139, 1137, 1134, 1132, 1129,
513    1127, 1125, 1122, 1120, 1117, 1115, 1113, 1110,
514    1108, 1106, 1103, 1101, 1099, 1096, 1094, 1092,
515    1089, 1087, 1085, 1083, 1081, 1078, 1076, 1074,
516    1072, 1069, 1067, 1065, 1063, 1061, 1059, 1057,
517    1054, 1052, 1050, 1048, 1046, 1044, 1042, 1040,
518    1038, 1036, 1034, 1032, 1030, 1028, 1026, 1024,
519    1022, 1020, 1018, 1016, 1014, 1012, 1010, 1008,
520    1006, 1004, 1002, 1000, 998, 996, 994, 992,
521    991, 989, 987, 985, 983, 981, 979, 978,
522    976, 974, 972, 970, 969, 967, 965, 963,
523    961, 960, 958, 956, 954, 953, 951, 949,
524    948, 946, 944, 942, 941, 939, 937, 936,
525    934, 932, 931, 929, 927, 926, 924, 923,
526    921, 919, 918, 916, 914, 913, 911, 910,
527    908, 907, 905, 903, 902, 900, 899, 897,
528    896, 894, 893, 891, 890, 888, 887, 885,
529    884, 882, 881, 879, 878, 876, 875, 873,
530    872, 870, 869, 868, 866, 865, 863, 862,
531    860, 859, 858, 856, 855, 853, 852, 851,
532    849, 848, 846, 845, 844, 842, 841, 840,
533    838, 837, 836, 834, 833, 832, 830, 829,
534    828, 826, 825, 824, 823, 821, 820, 819,
535    817, 816, 815, 814, 812, 811, 810, 809,
536    807, 806, 805, 804, 802, 801, 800, 799,
537    798, 796, 795, 794, 793, 791, 790, 789,
538    788, 787, 786, 784, 783, 782, 781, 780,
539    779, 777, 776, 775, 774, 773, 772, 771,
540    769, 768, 767, 766, 765, 764, 763, 762,
541    760, 759, 758, 757, 756, 755, 754, 753,
542    752, 751, 750, 748, 747, 746, 745, 744,
543    743, 742, 741, 740, 739, 738, 737, 736,
544    735, 734, 733, 732, 731, 730, 729, 728,
545    727, 726, 725, 724, 723, 722, 721, 720,
546    719, 718, 717, 716, 715, 714, 713, 712,
547    711, 710, 709, 708, 707, 706, 705, 704,
548    703, 702, 701, 700, 699, 699, 698, 697,
549    696, 695, 694, 693, 692, 691, 690, 689,
550    688, 688, 687, 686, 685, 684, 683, 682,
551    681, 680, 680, 679, 678, 677, 676, 675,
552    674, 673, 673, 672, 671, 670, 669, 668,
553    667, 667, 666, 665, 664, 663, 662, 661,
554    661, 660, 659, 658, 657, 657, 656, 655,
555    654, 653, 652, 652, 651, 650, 649, 648,
556    648, 647, 646, 645, 644, 644, 643, 642,
557    641, 640, 640, 639, 638, 637, 637, 636,
558    635, 634, 633, 633, 632, 631, 630, 630,
559    629, 628, 627, 627, 626, 625, 624, 624,
560    623, 622, 621, 621, 620, 619, 618, 618,
561    617, 616, 616, 615, 614, 613, 613, 612,
562    611, 611, 610, 609, 608, 608, 607, 606,
563    606, 605, 604, 604, 603, 602, 601, 601,
564    600, 599, 599, 598, 597, 597, 596, 595,
565    595, 594, 593, 593, 592, 591, 591, 590,
566    589, 589, 588, 587, 587, 586, 585, 585,
567    584, 583, 583, 582, 581, 581, 580, 579,
568    579, 578, 578, 577, 576, 576, 575, 574,
569    574, 573, 572, 572, 571, 571, 570, 569,
570    569, 568, 568, 567, 566, 566, 565, 564,
571    564, 563, 563, 562, 561, 561, 560, 560,
572    559, 558, 558, 557, 557, 556, 555, 555,
573    554, 554, 553, 553, 552, 551, 551, 550,
574    550, 549, 548, 548, 547, 547, 546, 546,
575    545, 544, 544, 543, 543, 542, 542, 541,
576    541, 540, 539, 539, 538, 538, 537, 537,
577    536, 536, 535, 534, 534, 533, 533, 532,
578    532, 531, 531, 530, 530, 529, 529, 528,
579    527, 527, 526, 526, 525, 525, 524, 524,
580    523, 523, 522, 522, 521, 521, 520, 520,
581    519, 519, 518, 518, 517, 517, 516, 516,
582    515, 515, 514, 514
583  };
584  #define DIVIDE_BY_ALPHA(sum, a)  (((sum) * kInvAlpha[(a)]) >> (kAlphaFix - 2))
585  #else
586  #define DIVIDE_BY_ALPHA(sum, a) (4 * (sum) / (a))
587  #endif  
588  static WEBP_INLINE int LinearToGammaWeighted(const uint8_t* src,
589                                               const uint8_t* a_ptr,
590                                               uint32_t total_a, int step,
591                                               int rgb_stride) {
592    const uint32_t sum =
593        a_ptr[0] * GammaToLinear(src[0]) +
594        a_ptr[step] * GammaToLinear(src[step]) +
595        a_ptr[rgb_stride] * GammaToLinear(src[rgb_stride]) +
596        a_ptr[rgb_stride + step] * GammaToLinear(src[rgb_stride + step]);
597    assert(total_a > 0 && total_a <= 4 * 0xff);
598  #if defined(USE_INVERSE_ALPHA_TABLE)
599    assert((uint64_t)sum * kInvAlpha[total_a] < ((uint64_t)1 << 32));
600  #endif
601    return LinearToGamma(DIVIDE_BY_ALPHA(sum, total_a), 0);
602  }
603  static WEBP_INLINE void ConvertRowToY(const uint8_t* const r_ptr,
604                                        const uint8_t* const g_ptr,
605                                        const uint8_t* const b_ptr,
606                                        int step,
607                                        uint8_t* const dst_y,
608                                        int width,
609                                        VP8Random* const rg) {
610    int i, j;
611    for (i = 0, j = 0; i < width; i += 1, j += step) {
612      dst_y[i] = RGBToY(r_ptr[j], g_ptr[j], b_ptr[j], rg);
613    }
614  }
615  static WEBP_INLINE void AccumulateRGBA(const uint8_t* const r_ptr,
616                                         const uint8_t* const g_ptr,
617                                         const uint8_t* const b_ptr,
618                                         const uint8_t* const a_ptr,
619                                         int rgb_stride,
620                                         uint16_t* dst, int width) {
621    int i, j;
622    for (i = 0, j = 0; i < (width >> 1); i += 1, j += 2 * 4, dst += 4) {
623      const uint32_t a = SUM4ALPHA(a_ptr + j);
624      int r, g, b;
625      if (a == 4 * 0xff || a == 0) {
626        r = SUM4(r_ptr + j, 4);
627        g = SUM4(g_ptr + j, 4);
628        b = SUM4(b_ptr + j, 4);
629      } else {
630        r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 4, rgb_stride);
631        g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 4, rgb_stride);
632        b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 4, rgb_stride);
633      }
634      dst[0] = r;
635      dst[1] = g;
636      dst[2] = b;
637      dst[3] = a;
638    }
639    if (width & 1) {
640      const uint32_t a = 2u * SUM2ALPHA(a_ptr + j);
641      int r, g, b;
642      if (a == 4 * 0xff || a == 0) {
643        r = SUM2(r_ptr + j);
644        g = SUM2(g_ptr + j);
645        b = SUM2(b_ptr + j);
646      } else {
647        r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 0, rgb_stride);
648        g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 0, rgb_stride);
649        b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 0, rgb_stride);
650      }
651      dst[0] = r;
652      dst[1] = g;
653      dst[2] = b;
654      dst[3] = a;
655    }
656  }
657  static WEBP_INLINE void AccumulateRGB(const uint8_t* const r_ptr,
658                                        const uint8_t* const g_ptr,
659                                        const uint8_t* const b_ptr,
660                                        int step, int rgb_stride,
661                                        uint16_t* dst, int width) {
662    int i, j;
663    for (i = 0, j = 0; i < (width >> 1); i += 1, j += 2 * step, dst += 4) {
664      dst[0] = SUM4(r_ptr + j, step);
665      dst[1] = SUM4(g_ptr + j, step);
666      dst[2] = SUM4(b_ptr + j, step);
667    }
668    if (width & 1) {
669      dst[0] = SUM2(r_ptr + j);
670      dst[1] = SUM2(g_ptr + j);
671      dst[2] = SUM2(b_ptr + j);
672    }
673  }
674  static WEBP_INLINE void ConvertRowsToUV(const uint16_t* rgb,
675                                          uint8_t* const dst_u,
676                                          uint8_t* const dst_v,
677                                          int width,
678                                          VP8Random* const rg) {
679    int i;
680    for (i = 0; i < width; i += 1, rgb += 4) {
681      const int r = rgb[0], g = rgb[1], b = rgb[2];
682      dst_u[i] = RGBToU(r, g, b, rg);
683      dst_v[i] = RGBToV(r, g, b, rg);
684    }
685  }
686  static int ImportYUVAFromRGBA(const uint8_t* r_ptr,
687                                const uint8_t* g_ptr,
688                                const uint8_t* b_ptr,
689                                const uint8_t* a_ptr,
690                                int step,         
691                                int rgb_stride,   
692                                float dithering,
693                                int use_iterative_conversion,
694                                WebPPicture* const picture) {
695    int y;
696    const int width = picture->width;
697    const int height = picture->height;
698    const int has_alpha = CheckNonOpaque(a_ptr, width, height, step, rgb_stride);
699    const int is_rgb = (r_ptr < b_ptr);  
700    picture->colorspace = has_alpha ? WEBP_YUV420A : WEBP_YUV420;
701    picture->use_argb = 0;
702    if (width < kMinDimensionIterativeConversion ||
703        height < kMinDimensionIterativeConversion) {
704      use_iterative_conversion = 0;
705    }
706    if (!WebPPictureAllocYUVA(picture, width, height)) {
707      return 0;
708    }
709    if (has_alpha) {
710      assert(step == 4);
711  #if defined(USE_GAMMA_COMPRESSION) && defined(USE_INVERSE_ALPHA_TABLE)
712      assert(kAlphaFix + kGammaFix <= 31);
713  #endif
714    }
715    if (use_iterative_conversion) {
716      InitGammaTablesS();
717      if (!PreprocessARGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, picture)) {
718        return 0;
719      }
720      if (has_alpha) {
721        WebPExtractAlpha(a_ptr, rgb_stride, width, height,
722                         picture->a, picture->a_stride);
723      }
724    } else {
725      const int uv_width = (width + 1) >> 1;
726      int use_dsp = (step == 3);  
727      uint16_t* const tmp_rgb =
728          (uint16_t*)WebPSafeMalloc(4 * uv_width, sizeof(*tmp_rgb));
729      uint8_t* dst_y = picture->y;
730      uint8_t* dst_u = picture->u;
731      uint8_t* dst_v = picture->v;
732      uint8_t* dst_a = picture->a;
733      VP8Random base_rg;
734      VP8Random* rg = NULL;
735      if (dithering > 0.) {
736        VP8InitRandom(&base_rg, dithering);
737        rg = &base_rg;
738        use_dsp = 0;   
739      }
740      WebPInitConvertARGBToYUV();
741      InitGammaTables();
742      if (tmp_rgb == NULL) return 0;  
743      for (y = 0; y < (height >> 1); ++y) {
744        int rows_have_alpha = has_alpha;
745        if (use_dsp) {
746          if (is_rgb) {
747            WebPConvertRGB24ToY(r_ptr, dst_y, width);
748            WebPConvertRGB24ToY(r_ptr + rgb_stride,
749                                dst_y + picture->y_stride, width);
750          } else {
751            WebPConvertBGR24ToY(b_ptr, dst_y, width);
752            WebPConvertBGR24ToY(b_ptr + rgb_stride,
753                                dst_y + picture->y_stride, width);
754          }
755        } else {
756          ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
757          ConvertRowToY(r_ptr + rgb_stride,
758                        g_ptr + rgb_stride,
759                        b_ptr + rgb_stride, step,
760                        dst_y + picture->y_stride, width, rg);
761        }
762        dst_y += 2 * picture->y_stride;
763        if (has_alpha) {
764          rows_have_alpha &= !WebPExtractAlpha(a_ptr, rgb_stride, width, 2,
765                                               dst_a, picture->a_stride);
766          dst_a += 2 * picture->a_stride;
767        }
768        if (!rows_have_alpha) {
769          AccumulateRGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, tmp_rgb, width);
770        } else {
771          AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, rgb_stride, tmp_rgb, width);
772        }
773        if (rg == NULL) {
774          WebPConvertRGBA32ToUV(tmp_rgb, dst_u, dst_v, uv_width);
775        } else {
776          ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
777        }
778        dst_u += picture->uv_stride;
779        dst_v += picture->uv_stride;
780        r_ptr += 2 * rgb_stride;
781        b_ptr += 2 * rgb_stride;
782        g_ptr += 2 * rgb_stride;
783        if (has_alpha) a_ptr += 2 * rgb_stride;
784      }
785      if (height & 1) {    
786        int row_has_alpha = has_alpha;
787        if (use_dsp) {
788          if (r_ptr < b_ptr) {
789            WebPConvertRGB24ToY(r_ptr, dst_y, width);
790          } else {
791            WebPConvertBGR24ToY(b_ptr, dst_y, width);
792          }
793        } else {
794          ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
795        }
796        if (row_has_alpha) {
797          row_has_alpha &= !WebPExtractAlpha(a_ptr, 0, width, 1, dst_a, 0);
798        }
799        if (!row_has_alpha) {
800          AccumulateRGB(r_ptr, g_ptr, b_ptr, step, &bsol;* rgb_stride = */ 0,
801                        tmp_rgb, width);
802        } else {
803          AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, &bsol;* rgb_stride = */ 0,
804                         tmp_rgb, width);
805        }
806        if (rg == NULL) {
807          WebPConvertRGBA32ToUV(tmp_rgb, dst_u, dst_v, uv_width);
808        } else {
809          ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
810        }
811      }
812      WebPSafeFree(tmp_rgb);
813    }
814    return 1;
815  }
816  #undef SUM4
817  #undef SUM2
818  #undef SUM4ALPHA
819  #undef SUM2ALPHA
820  static int PictureARGBToYUVA(WebPPicture* picture, WebPEncCSP colorspace,
821                               float dithering, int use_iterative_conversion) {
822    if (picture == NULL) return 0;
823    if (picture->argb == NULL) {
824      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
825    } else if ((colorspace & WEBP_CSP_UV_MASK) != WEBP_YUV420) {
826      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
827    } else {
828      const uint8_t* const argb = (const uint8_t*)picture->argb;
829      const uint8_t* const a = argb + CHANNEL_OFFSET(0);
830      const uint8_t* const r = argb + CHANNEL_OFFSET(1);
831      const uint8_t* const g = argb + CHANNEL_OFFSET(2);
832      const uint8_t* const b = argb + CHANNEL_OFFSET(3);
833      picture->colorspace = WEBP_YUV420;
834      return ImportYUVAFromRGBA(r, g, b, a, 4, 4 * picture->argb_stride,
835                                dithering, use_iterative_conversion, picture);
836    }
837  }
838  int WebPPictureARGBToYUVADithered(WebPPicture* picture, WebPEncCSP colorspace,
839                                    float dithering) {
840    return PictureARGBToYUVA(picture, colorspace, dithering, 0);
841  }
842  int WebPPictureARGBToYUVA(WebPPicture* picture, WebPEncCSP colorspace) {
843    return PictureARGBToYUVA(picture, colorspace, 0.f, 0);
844  }
845  int WebPPictureSharpARGBToYUVA(WebPPicture* picture) {
846    return PictureARGBToYUVA(picture, WEBP_YUV420, 0.f, 1);
847  }
848  int WebPPictureSmartARGBToYUVA(WebPPicture* picture) {
849    return WebPPictureSharpARGBToYUVA(picture);
850  }
851  int WebPPictureYUVAToARGB(WebPPicture* picture) {
852    if (picture == NULL) return 0;
853    if (picture->y == NULL || picture->u == NULL || picture->v == NULL) {
854      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
855    }
856    if ((picture->colorspace & WEBP_CSP_ALPHA_BIT) && picture->a == NULL) {
857      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
858    }
859    if ((picture->colorspace & WEBP_CSP_UV_MASK) != WEBP_YUV420) {
860      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
861    }
862    if (!WebPPictureAllocARGB(picture, picture->width, picture->height)) return 0;
863    picture->use_argb = 1;
864    {
865      int y;
866      const int width = picture->width;
867      const int height = picture->height;
868      const int argb_stride = 4 * picture->argb_stride;
869      uint8_t* dst = (uint8_t*)picture->argb;
870      const uint8_t* cur_u = picture->u, *cur_v = picture->v, *cur_y = picture->y;
871      WebPUpsampleLinePairFunc upsample =
872          WebPGetLinePairConverter(ALPHA_OFFSET > 0);
873      upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, width);
874      cur_y += picture->y_stride;
875      dst += argb_stride;
876      for (y = 1; y + 1 < height; y += 2) {
877        const uint8_t* const top_u = cur_u;
878        const uint8_t* const top_v = cur_v;
879        cur_u += picture->uv_stride;
880        cur_v += picture->uv_stride;
881        upsample(cur_y, cur_y + picture->y_stride, top_u, top_v, cur_u, cur_v,
882                 dst, dst + argb_stride, width);
883        cur_y += 2 * picture->y_stride;
884        dst += 2 * argb_stride;
885      }
886      if (height > 1 && !(height & 1)) {
887        upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, width);
888      }
889      if (picture->colorspace & WEBP_CSP_ALPHA_BIT) {
890        for (y = 0; y < height; ++y) {
891          uint32_t* const argb_dst = picture->argb + y * picture->argb_stride;
892          const uint8_t* const src = picture->a + y * picture->a_stride;
893          int x;
894          for (x = 0; x < width; ++x) {
895            argb_dst[x] = (argb_dst[x] & 0x00ffffffu) | ((uint32_t)src[x] << 24);
896          }
897        }
898      }
899    }
900    return 1;
901  }
902  static int Import(WebPPicture* const picture,
903                    const uint8_t* rgb, int rgb_stride,
904                    int step, int swap_rb, int import_alpha) {
905    int y;
906    const uint8_t* r_ptr = rgb + (swap_rb ? 2 : 0);
907    const uint8_t* g_ptr = rgb + 1;
908    const uint8_t* b_ptr = rgb + (swap_rb ? 0 : 2);
909    const int width = picture->width;
910    const int height = picture->height;
911    if (!picture->use_argb) {
912      const uint8_t* a_ptr = import_alpha ? rgb + 3 : NULL;
913      return ImportYUVAFromRGBA(r_ptr, g_ptr, b_ptr, a_ptr, step, rgb_stride,
914                                0.f &bsol;* no dithering */, 0, picture);
915    }
916    if (!WebPPictureAlloc(picture)) return 0;
917    VP8LDspInit();
918    WebPInitAlphaProcessing();
919    if (import_alpha) {
920      uint32_t* dst = picture->argb;
921      const int do_copy = (ALPHA_OFFSET == 3) && swap_rb;
922      assert(step == 4);
923      if (do_copy) {
924        for (y = 0; y < height; ++y) {
925          memcpy(dst, rgb, width * 4);
926          rgb += rgb_stride;
927          dst += picture->argb_stride;
928        }
929      } else {
930        for (y = 0; y < height; ++y) {
931  #ifdef WORDS_BIGENDIAN
932          const uint8_t* a_ptr = rgb + 3;
933          WebPPackARGB(a_ptr, r_ptr, g_ptr, b_ptr, width, dst);
934          r_ptr += rgb_stride;
935          g_ptr += rgb_stride;
936          b_ptr += rgb_stride;
937  #else
938          VP8LConvertBGRAToRGBA((const uint32_t*)rgb, width, (uint8_t*)dst);
939  #endif
940          rgb += rgb_stride;
941          dst += picture->argb_stride;
942        }
943      }
944    } else {
945      uint32_t* dst = picture->argb;
946      assert(step >= 3);
947      for (y = 0; y < height; ++y) {
948        WebPPackRGB(r_ptr, g_ptr, b_ptr, width, step, dst);
949        r_ptr += rgb_stride;
950        g_ptr += rgb_stride;
951        b_ptr += rgb_stride;
952        dst += picture->argb_stride;
953      }
954    }
955    return 1;
956  }
957  #if !defined(WEBP_REDUCE_CSP)
958  int WebPPictureImportBGR(WebPPicture* picture,
959                           const uint8_t* rgb, int rgb_stride) {
960    return (picture != NULL && rgb != NULL)
961               ? Import(picture, rgb, rgb_stride, 3, 1, 0)
962               : 0;
963  }
964  int WebPPictureImportBGRA(WebPPicture* picture,
965                            const uint8_t* rgba, int rgba_stride) {
966    return (picture != NULL && rgba != NULL)
967               ? Import(picture, rgba, rgba_stride, 4, 1, 1)
968               : 0;
969  }
970  int WebPPictureImportBGRX(WebPPicture* picture,
971                            const uint8_t* rgba, int rgba_stride) {
972    return (picture != NULL && rgba != NULL)
973               ? Import(picture, rgba, rgba_stride, 4, 1, 0)
974               : 0;
975  }
976  #endif   
977  int WebPPictureImportRGB(WebPPicture* picture,
978                           const uint8_t* rgb, int rgb_stride) {
979    return (picture != NULL && rgb != NULL)
980               ? Import(picture, rgb, rgb_stride, 3, 0, 0)
981               : 0;
982  }
983  int WebPPictureImportRGBA(WebPPicture* picture,
984                            const uint8_t* rgba, int rgba_stride) {
985    return (picture != NULL && rgba != NULL)
986               ? Import(picture, rgba, rgba_stride, 4, 0, 1)
987               : 0;
988  }
989  int WebPPictureImportRGBX(WebPPicture* picture,
990                            const uint8_t* rgba, int rgba_stride) {
991    return (picture != NULL && rgba != NULL)
992               ? Import(picture, rgba, rgba_stride, 4, 0, 0)
993               : 0;
994  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeMat.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_csp_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>307          return Mat4(x, 0.0f, 0.0f, 0.0f,
308                      0.0f, y, 0.0f, 0.0f,
309                      0.0f, 0.0f, z, 0.0f,
310                      0.0f, 0.0f, 0.0f, 1.0f);
311      }
312      static inline Mat4 makeRotation(float rad, float x, float y, float z)
</pre></code></div>
                <div class="column column_space"><pre><code>287    return clip_8b(16 + (luma >> (YUV_FIX + SFIX)));
288  }
289  static WEBP_INLINE uint8_t ConvertRGBToU(int r, int g, int b) {
290    const int u =  -9719 * r - 19081 * g + 28800 * b + SROUNDER;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    