
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.535714285714285%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-bignum.h</h3>
            <pre><code>1  #ifndef POLARSSL_BIGNUM_H
2  #define POLARSSL_BIGNUM_H
3  #if !defined(POLARSSL_CONFIG_FILE)
4  #include "config.h"
5  #else
6  #include POLARSSL_CONFIG_FILE
7  #endif
8  #include <stddef.h>
9  #if defined(POLARSSL_FS_IO)
10  #include <stdio.h>
11  #endif
12  #if defined(_MSC_VER) && !defined(EFIX64) && !defined(EFI32)
13  #include <basetsd.h>
14  #if (_MSC_VER <= 1200)
15  typedef   signed short  int16_t;
16  typedef unsigned short uint16_t;
17  #else
18  typedef  INT16  int16_t;
19  typedef UINT16 uint16_t;
20  #endif
21  typedef  INT32  int32_t;
22  typedef  INT64  int64_t;
23  typedef UINT32 uint32_t;
24  typedef UINT64 uint64_t;
25  #else
26  #include <inttypes.h>
27  #endif &bsol;* _MSC_VER && !EFIX64 && !EFI32 */
28  #define POLARSSL_ERR_MPI_FILE_IO_ERROR                     -0x0002  &bsol;**< An error occurred while reading from or writing to a file. */
29  #define POLARSSL_ERR_MPI_BAD_INPUT_DATA                    -0x0004  &bsol;**< Bad input parameters to function. */
30  #define POLARSSL_ERR_MPI_INVALID_CHARACTER                 -0x0006  &bsol;**< There is an invalid character in the digit string. */
31  #define POLARSSL_ERR_MPI_BUFFER_TOO_SMALL                  -0x0008  &bsol;**< The buffer is too small to write to. */
32  #define POLARSSL_ERR_MPI_NEGATIVE_VALUE                    -0x000A  &bsol;**< The input arguments are negative or result in illegal output. */
33  #define POLARSSL_ERR_MPI_DIVISION_BY_ZERO                  -0x000C  &bsol;**< The input argument for division is zero, which is not allowed. */
34  #define POLARSSL_ERR_MPI_NOT_ACCEPTABLE                    -0x000E  &bsol;**< The input arguments are not acceptable. */
35  #define POLARSSL_ERR_MPI_MALLOC_FAILED                     -0x0010  &bsol;**< Memory allocation failed. */
36  #define MPI_CHK(f) do { if( ( ret = f ) != 0 ) goto cleanup; } while( 0 )
37  #define POLARSSL_MPI_MAX_LIMBS                             10000
38  #if !defined(POLARSSL_MPI_WINDOW_SIZE)
39  #define POLARSSL_MPI_WINDOW_SIZE                           6        &bsol;**< Maximum windows size used. */
40  #endif &bsol;* !POLARSSL_MPI_WINDOW_SIZE */
41  #if !defined(POLARSSL_MPI_MAX_SIZE)
42  #define POLARSSL_MPI_MAX_SIZE                              1024     &bsol;**< Maximum number of bytes for usable MPIs. */
43  #endif &bsol;* !POLARSSL_MPI_MAX_SIZE */
44  #define POLARSSL_MPI_MAX_BITS                              ( 8 * POLARSSL_MPI_MAX_SIZE )    &bsol;**< Maximum number of bits for usable MPIs. */
45  #define POLARSSL_MPI_MAX_BITS_SCALE100          ( 100 * POLARSSL_MPI_MAX_BITS )
46  #define LN_2_DIV_LN_10_SCALE100                 332
47  #define POLARSSL_MPI_RW_BUFFER_SIZE             ( ((POLARSSL_MPI_MAX_BITS_SCALE100 + LN_2_DIV_LN_10_SCALE100 - 1) / LN_2_DIV_LN_10_SCALE100) + 10 + 6 )
48  #if defined(POLARSSL_HAVE_INT8)
49  typedef   signed char  t_sint;
50  typedef unsigned char  t_uint;
51  typedef uint16_t       t_udbl;
52  #define POLARSSL_HAVE_UDBL
53  #else
54  #if defined(POLARSSL_HAVE_INT16)
55  typedef  int16_t t_sint;
<span onclick='openModal()' class='match'>56  typedef uint16_t t_uint;
57  typedef uint32_t t_udbl;
58  #define POLARSSL_HAVE_UDBL
59  #else
60    #if ( ! defined(POLARSSL_HAVE_INT32) && \
61            defined(_MSC_VER) && defined(_M_AMD64) )
62      #define POLARSSL_HAVE_INT64
63      typedef  int64_t t_sint;
64      typedef uint64_t t_uint;
65    #else
66      #if ( ! defined(POLARSSL_HAVE_INT32) &&               \
67            defined(__GNUC__) && (                          \
68            defined(__amd64__) || defined(__x86_64__)    || \
69            defined(__ppc64__) || defined(__powerpc64__) || \
70            defined(__ia64__)  || defined(__alpha__)     || \
71            (defined(__sparc__) && defined(__arch64__))  || \
72            defined(__s390x__) || defined(__mips64) ) )
73         #define POLARSSL_HAVE_INT64
74         typedef  int64_t t_sint;
75         typedef uint64_t t_uint;
76         typedef unsigned int t_udbl __attribute__((mode(TI)));
77         #define POLARSSL_HAVE_UDBL
78      #else
79         #define POLARSSL_HAVE_INT32
80         typedef  int32_t t_sint;
81         typedef uint32_t t_uint;
</span>82         #if ( defined(_MSC_VER) && defined(_M_IX86) )
83           typedef uint64_t t_udbl;
84           #define POLARSSL_HAVE_UDBL
85         #else
86           #if defined( POLARSSL_HAVE_LONGLONG )
87             typedef unsigned long long t_udbl;
88             #define POLARSSL_HAVE_UDBL
89           #endif
90         #endif
91      #endif &bsol;* !POLARSSL_HAVE_INT32 && __GNUC__ && 64-bit platform */
92    #endif &bsol;* !POLARSSL_HAVE_INT32 && _MSC_VER && _M_AMD64 */
93  #endif &bsol;* POLARSSL_HAVE_INT16 */
94  #endif &bsol;* POLARSSL_HAVE_INT8  */
95  #ifdef __cplusplus
96  extern "C" {
97  #endif
98  typedef struct
99  {
100      int s;              &bsol;*!<  integer sign      */
101      size_t n;           &bsol;*!<  total # of limbs  */
102      t_uint *p;          &bsol;*!<  pointer to limbs  */
103  }
104  mpi;
105  void mpi_init( mpi *X );
106  void mpi_free( mpi *X );
107  int mpi_grow( mpi *X, size_t nblimbs );
108  int mpi_shrink( mpi *X, size_t nblimbs );
109  int mpi_copy( mpi *X, const mpi *Y );
110  void mpi_swap( mpi *X, mpi *Y );
111  int mpi_safe_cond_assign( mpi *X, const mpi *Y, unsigned char assign );
112  int mpi_safe_cond_swap( mpi *X, mpi *Y, unsigned char assign );
113  int mpi_lset( mpi *X, t_sint z );
114  int mpi_get_bit( const mpi *X, size_t pos );
115  int mpi_set_bit( mpi *X, size_t pos, unsigned char val );
116  size_t mpi_lsb( const mpi *X );
117  size_t mpi_msb( const mpi *X );
118  size_t mpi_size( const mpi *X );
119  int mpi_read_string( mpi *X, int radix, const char *s );
120  int mpi_write_string( const mpi *X, int radix, char *s, size_t *slen );
121  #if defined(POLARSSL_FS_IO)
122  int mpi_read_file( mpi *X, int radix, FILE *fin );
123  int mpi_write_file( const char *p, const mpi *X, int radix, FILE *fout );
124  #endif &bsol;* POLARSSL_FS_IO */
125  int mpi_read_binary( mpi *X, const unsigned char *buf, size_t buflen );
126  int mpi_write_binary( const mpi *X, unsigned char *buf, size_t buflen );
127  int mpi_shift_l( mpi *X, size_t count );
128  int mpi_shift_r( mpi *X, size_t count );
129  int mpi_cmp_abs( const mpi *X, const mpi *Y );
130  int mpi_cmp_mpi( const mpi *X, const mpi *Y );
131  int mpi_cmp_int( const mpi *X, t_sint z );
132  int mpi_add_abs( mpi *X, const mpi *A, const mpi *B );
133  int mpi_sub_abs( mpi *X, const mpi *A, const mpi *B );
134  int mpi_add_mpi( mpi *X, const mpi *A, const mpi *B );
135  int mpi_sub_mpi( mpi *X, const mpi *A, const mpi *B );
136  int mpi_add_int( mpi *X, const mpi *A, t_sint b );
137  int mpi_sub_int( mpi *X, const mpi *A, t_sint b );
138  int mpi_mul_mpi( mpi *X, const mpi *A, const mpi *B );
139  int mpi_mul_int( mpi *X, const mpi *A, t_sint b );
140  int mpi_div_mpi( mpi *Q, mpi *R, const mpi *A, const mpi *B );
141  int mpi_div_int( mpi *Q, mpi *R, const mpi *A, t_sint b );
142  int mpi_mod_mpi( mpi *R, const mpi *A, const mpi *B );
143  int mpi_mod_int( t_uint *r, const mpi *A, t_sint b );
144  int mpi_exp_mod( mpi *X, const mpi *A, const mpi *E, const mpi *N, mpi *_RR );
145  int mpi_fill_random( mpi *X, size_t size,
146                       int (*f_rng)(void *, unsigned char *, size_t),
147                       void *p_rng );
148  int mpi_gcd( mpi *G, const mpi *A, const mpi *B );
149  int mpi_inv_mod( mpi *X, const mpi *A, const mpi *N );
150  int mpi_is_prime( mpi *X,
151                    int (*f_rng)(void *, unsigned char *, size_t),
152                    void *p_rng );
153  int mpi_gen_prime( mpi *X, size_t nbits, int dh_flag,
154                     int (*f_rng)(void *, unsigned char *, size_t),
155                     void *p_rng );
156  int mpi_self_test( int verbose );
157  #ifdef __cplusplus
158  }
159  #endif
160  #endif &bsol;* bignum.h */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc_internal_inlines_c.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_INLINES_C_H
2  #define JEMALLOC_INTERNAL_INLINES_C_H
3  #include "jemalloc/internal/hook.h"
4  #include "jemalloc/internal/jemalloc_internal_types.h"
5  #include "jemalloc/internal/sz.h"
6  #include "jemalloc/internal/witness.h"
7  JEMALLOC_ALWAYS_INLINE arena_t *
8  iaalloc(tsdn_t *tsdn, const void *ptr) {
9  	assert(ptr != NULL);
10  	return arena_aalloc(tsdn, ptr);
11  }
12  JEMALLOC_ALWAYS_INLINE size_t
13  isalloc(tsdn_t *tsdn, const void *ptr) {
14  	assert(ptr != NULL);
15  	return arena_salloc(tsdn, ptr);
16  }
17  JEMALLOC_ALWAYS_INLINE void *
18  iallocztm(tsdn_t *tsdn, size_t size, szind_t ind, bool zero, tcache_t *tcache,
19      bool is_internal, arena_t *arena, bool slow_path) {
20  	void *ret;
21  	assert(!is_internal || tcache == NULL);
22  	assert(!is_internal || arena == NULL || arena_is_auto(arena));
23  	if (!tsdn_null(tsdn) && tsd_reentrancy_level_get(tsdn_tsd(tsdn)) == 0) {
24  		witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
25  		    WITNESS_RANK_CORE, 0);
26  	}
27  	ret = arena_malloc(tsdn, arena, size, ind, zero, tcache, slow_path);
28  	if (config_stats && is_internal && likely(ret != NULL)) {
29  		arena_internal_add(iaalloc(tsdn, ret), isalloc(tsdn, ret));
30  	}
31  	return ret;
32  }
33  JEMALLOC_ALWAYS_INLINE void *
34  ialloc(tsd_t *tsd, size_t size, szind_t ind, bool zero, bool slow_path) {
35  	return iallocztm(tsd_tsdn(tsd), size, ind, zero, tcache_get(tsd), false,
36  	    NULL, slow_path);
37  }
38  JEMALLOC_ALWAYS_INLINE void *
39  ipallocztm(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
40      tcache_t *tcache, bool is_internal, arena_t *arena) {
41  	void *ret;
42  	assert(usize != 0);
43  	assert(usize == sz_sa2u(usize, alignment));
44  	assert(!is_internal || tcache == NULL);
45  	assert(!is_internal || arena == NULL || arena_is_auto(arena));
46  	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
47  	    WITNESS_RANK_CORE, 0);
48  	ret = arena_palloc(tsdn, arena, usize, alignment, zero, tcache);
49  	assert(ALIGNMENT_ADDR2BASE(ret, alignment) == ret);
50  	if (config_stats && is_internal && likely(ret != NULL)) {
51  		arena_internal_add(iaalloc(tsdn, ret), isalloc(tsdn, ret));
52  	}
53  	return ret;
54  }
55  JEMALLOC_ALWAYS_INLINE void *
56  ipalloct(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
57      tcache_t *tcache, arena_t *arena) {
58  	return ipallocztm(tsdn, usize, alignment, zero, tcache, false, arena);
59  }
60  JEMALLOC_ALWAYS_INLINE void *
61  ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero) {
62  	return ipallocztm(tsd_tsdn(tsd), usize, alignment, zero,
63  	    tcache_get(tsd), false, NULL);
64  }
65  JEMALLOC_ALWAYS_INLINE size_t
66  ivsalloc(tsdn_t *tsdn, const void *ptr) {
67  	return arena_vsalloc(tsdn, ptr);
68  }
69  JEMALLOC_ALWAYS_INLINE void
70  idalloctm(tsdn_t *tsdn, void *ptr, tcache_t *tcache, alloc_ctx_t *alloc_ctx,
71      bool is_internal, bool slow_path) {
72  	assert(ptr != NULL);
73  	assert(!is_internal || tcache == NULL);
74  	assert(!is_internal || arena_is_auto(iaalloc(tsdn, ptr)));
75  	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
76  	    WITNESS_RANK_CORE, 0);
77  	if (config_stats && is_internal) {
78  		arena_internal_sub(iaalloc(tsdn, ptr), isalloc(tsdn, ptr));
79  	}
80  	if (!is_internal && !tsdn_null(tsdn) &&
81  	    tsd_reentrancy_level_get(tsdn_tsd(tsdn)) != 0) {
82  		assert(tcache == NULL);
83  	}
84  	arena_dalloc(tsdn, ptr, tcache, alloc_ctx, slow_path);
85  }
86  JEMALLOC_ALWAYS_INLINE void
87  idalloc(tsd_t *tsd, void *ptr) {
88  	idalloctm(tsd_tsdn(tsd), ptr, tcache_get(tsd), NULL, false, true);
89  }
90  JEMALLOC_ALWAYS_INLINE void
91  isdalloct(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
92      alloc_ctx_t *alloc_ctx, bool slow_path) {
93  	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
94  	    WITNESS_RANK_CORE, 0);
95  	arena_sdalloc(tsdn, ptr, size, tcache, alloc_ctx, slow_path);
96  }
97  JEMALLOC_ALWAYS_INLINE void *
<span onclick='openModal()' class='match'>98  iralloct_realign(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size,
99      size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,
100      hook_ralloc_args_t *hook_args) {
101  	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
102  	    WITNESS_RANK_CORE, 0);
103  	void *p;
104  	size_t usize, copysize;
</span>105  	usize = sz_sa2u(size, alignment);
106  	if (unlikely(usize == 0 || usize > SC_LARGE_MAXCLASS)) {
107  		return NULL;
108  	}
109  	p = ipalloct(tsdn, usize, alignment, zero, tcache, arena);
110  	if (p == NULL) {
111  		return NULL;
112  	}
113  	copysize = (size < oldsize) ? size : oldsize;
114  	memcpy(p, ptr, copysize);
115  	hook_invoke_alloc(hook_args->is_realloc
116  	    ? hook_alloc_realloc : hook_alloc_rallocx, p, (uintptr_t)p,
117  	    hook_args->args);
118  	hook_invoke_dalloc(hook_args->is_realloc
119  	    ? hook_dalloc_realloc : hook_dalloc_rallocx, ptr, hook_args->args);
120  	isdalloct(tsdn, ptr, oldsize, tcache, NULL, true);
121  	return p;
122  }
123  JEMALLOC_ALWAYS_INLINE void *
124  iralloct(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size, size_t alignment,
125      bool zero, tcache_t *tcache, arena_t *arena, hook_ralloc_args_t *hook_args)
126  {
127  	assert(ptr != NULL);
128  	assert(size != 0);
129  	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
130  	    WITNESS_RANK_CORE, 0);
131  	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
132  	    != 0) {
133  		return iralloct_realign(tsdn, ptr, oldsize, size, alignment,
134  		    zero, tcache, arena, hook_args);
135  	}
136  	return arena_ralloc(tsdn, arena, ptr, oldsize, size, alignment, zero,
137  	    tcache, hook_args);
138  }
139  JEMALLOC_ALWAYS_INLINE void *
140  iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
141      bool zero, hook_ralloc_args_t *hook_args) {
142  	return iralloct(tsd_tsdn(tsd), ptr, oldsize, size, alignment, zero,
143  	    tcache_get(tsd), NULL, hook_args);
144  }
145  JEMALLOC_ALWAYS_INLINE bool
146  ixalloc(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size, size_t extra,
147      size_t alignment, bool zero, size_t *newsize) {
148  	assert(ptr != NULL);
149  	assert(size != 0);
150  	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
151  	    WITNESS_RANK_CORE, 0);
152  	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
153  	    != 0) {
154  		*newsize = oldsize;
155  		return true;
156  	}
157  	return arena_ralloc_no_move(tsdn, ptr, oldsize, size, extra, zero,
158  	    newsize);
159  }
160  JEMALLOC_ALWAYS_INLINE int
161  iget_defrag_hint(tsdn_t *tsdn, void* ptr, int *bin_util, int *run_util) {
162  	int defrag = 0;
163  	rtree_ctx_t rtree_ctx_fallback;
164  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
165  	szind_t szind;
166  	bool is_slab;
167  	rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx, (uintptr_t)ptr, true, &szind, &is_slab);
168  	if (likely(is_slab)) {
169  		extent_t *slab = iealloc(tsdn, ptr);
170  		arena_t *arena = extent_arena_get(slab);
171  		szind_t binind = extent_szind_get(slab);
172  		bin_t *bin = arena->bins[binind].bin_shards;
173  		malloc_mutex_lock(tsdn, &bin->lock);
174  		if (slab != bin->slabcur) {
175  			const bin_info_t *bin_info = &bin_infos[binind];
176  			size_t availregs = bin_info->nregs * bin->stats.curslabs;
177  			*bin_util = ((long long)bin->stats.curregs<<16) / availregs;
178  			*run_util = ((long long)(bin_info->nregs - extent_nfree_get(slab))<<16) / bin_info->nregs;
179  			defrag = 1;
180  		}
181  		malloc_mutex_unlock(tsdn, &bin->lock);
182  	}
183  	return defrag;
184  }
185  #endif &bsol;* JEMALLOC_INTERNAL_INLINES_C_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-bignum.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc_internal_inlines_c.h</div>
                </div>
                <div class="column column_space"><pre><code>56  typedef uint16_t t_uint;
57  typedef uint32_t t_udbl;
58  #define POLARSSL_HAVE_UDBL
59  #else
60    #if ( ! defined(POLARSSL_HAVE_INT32) && \
61            defined(_MSC_VER) && defined(_M_AMD64) )
62      #define POLARSSL_HAVE_INT64
63      typedef  int64_t t_sint;
64      typedef uint64_t t_uint;
65    #else
66      #if ( ! defined(POLARSSL_HAVE_INT32) &&               \
67            defined(__GNUC__) && (                          \
68            defined(__amd64__) || defined(__x86_64__)    || \
69            defined(__ppc64__) || defined(__powerpc64__) || \
70            defined(__ia64__)  || defined(__alpha__)     || \
71            (defined(__sparc__) && defined(__arch64__))  || \
72            defined(__s390x__) || defined(__mips64) ) )
73         #define POLARSSL_HAVE_INT64
74         typedef  int64_t t_sint;
75         typedef uint64_t t_uint;
76         typedef unsigned int t_udbl __attribute__((mode(TI)));
77         #define POLARSSL_HAVE_UDBL
78      #else
79         #define POLARSSL_HAVE_INT32
80         typedef  int32_t t_sint;
81         typedef uint32_t t_uint;
</pre></code></div>
                <div class="column column_space"><pre><code>98  iralloct_realign(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size,
99      size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,
100      hook_ralloc_args_t *hook_args) {
101  	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
102  	    WITNESS_RANK_CORE, 0);
103  	void *p;
104  	size_t usize, copysize;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    