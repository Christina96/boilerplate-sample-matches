
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.90273556231003%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-lfs.c</h3>
            <pre><code>1  #include "lfs.h"
2  #include "lfs_util.h"
3  #include <inttypes.h>
4  static int lfs_cache_read(lfs_t *lfs, lfs_cache_t *rcache,
5          const lfs_cache_t *pcache, lfs_block_t block,
6          lfs_off_t off, void *buffer, lfs_size_t size) {
7      uint8_t *data = buffer;
8      LFS_ASSERT(block < lfs->cfg->block_count);
9      while (size > 0) {
10          if (pcache && block == pcache->block && off >= pcache->off &&
11                  off < pcache->off + lfs->cfg->prog_size) {
12              lfs_size_t diff = lfs_min(size,
13                      lfs->cfg->prog_size - (off-pcache->off));
14              memcpy(data, &pcache->buffer[off-pcache->off], diff);
15              data += diff;
16              off += diff;
17              size -= diff;
18              continue;
19          }
20          if (block == rcache->block && off >= rcache->off &&
21                  off < rcache->off + lfs->cfg->read_size) {
22              lfs_size_t diff = lfs_min(size,
23                      lfs->cfg->read_size - (off-rcache->off));
24              memcpy(data, &rcache->buffer[off-rcache->off], diff);
25              data += diff;
26              off += diff;
27              size -= diff;
28              continue;
29          }
30          if (off % lfs->cfg->read_size == 0 && size >= lfs->cfg->read_size) {
31              lfs_size_t diff = size - (size % lfs->cfg->read_size);
32              int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);
33              if (err) {
34                  return err;
35              }
36              data += diff;
37              off += diff;
38              size -= diff;
39              continue;
40          }
41          rcache->block = block;
42          rcache->off = off - (off % lfs->cfg->read_size);
43          int err = lfs->cfg->read(lfs->cfg, rcache->block,
44                  rcache->off, rcache->buffer, lfs->cfg->read_size);
45          if (err) {
46              return err;
47          }
48      }
49      return 0;
50  }
<span onclick='openModal()' class='match'>51  static int lfs_cache_cmp(lfs_t *lfs, lfs_cache_t *rcache,
52          const lfs_cache_t *pcache, lfs_block_t block,
53          lfs_off_t off, const void *buffer, lfs_size_t size) {
54      const uint8_t *data = buffer;
</span>55      for (lfs_off_t i = 0; i < size; i++) {
56          uint8_t c;
57          int err = lfs_cache_read(lfs, rcache, pcache,
58                  block, off+i, &c, 1);
59          if (err) {
60              return err;
61          }
62          if (c != data[i]) {
63              return false;
64          }
65      }
66      return true;
67  }
68  static int lfs_cache_crc(lfs_t *lfs, lfs_cache_t *rcache,
69          const lfs_cache_t *pcache, lfs_block_t block,
70          lfs_off_t off, lfs_size_t size, uint32_t *crc) {
71      for (lfs_off_t i = 0; i < size; i++) {
72          uint8_t c;
73          int err = lfs_cache_read(lfs, rcache, pcache,
74                  block, off+i, &c, 1);
75          if (err) {
76              return err;
77          }
78          lfs_crc(crc, &c, 1);
79      }
80      return 0;
81  }
82  static inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {
83      (void)lfs;
84      rcache->block = 0xffffffff;
85  }
86  static inline void lfs_cache_zero(lfs_t *lfs, lfs_cache_t *pcache) {
87      memset(pcache->buffer, 0xff, lfs->cfg->prog_size);
88      pcache->block = 0xffffffff;
89  }
90  static int lfs_cache_flush(lfs_t *lfs,
91          lfs_cache_t *pcache, lfs_cache_t *rcache) {
92      if (pcache->block != 0xffffffff) {
93          int err = lfs->cfg->prog(lfs->cfg, pcache->block,
94                  pcache->off, pcache->buffer, lfs->cfg->prog_size);
95          if (err) {
96              return err;
97          }
98          if (rcache) {
99              int res = lfs_cache_cmp(lfs, rcache, NULL, pcache->block,
100                      pcache->off, pcache->buffer, lfs->cfg->prog_size);
101              if (res < 0) {
102                  return res;
103              }
104              if (!res) {
105                  return LFS_ERR_CORRUPT;
106              }
107          }
108          lfs_cache_zero(lfs, pcache);
109      }
110      return 0;
111  }
112  static int lfs_cache_prog(lfs_t *lfs, lfs_cache_t *pcache,
113          lfs_cache_t *rcache, lfs_block_t block,
114          lfs_off_t off, const void *buffer, lfs_size_t size) {
115      const uint8_t *data = buffer;
116      LFS_ASSERT(block < lfs->cfg->block_count);
117      while (size > 0) {
118          if (block == pcache->block && off >= pcache->off &&
119                  off < pcache->off + lfs->cfg->prog_size) {
120              lfs_size_t diff = lfs_min(size,
121                      lfs->cfg->prog_size - (off-pcache->off));
122              memcpy(&pcache->buffer[off-pcache->off], data, diff);
123              data += diff;
124              off += diff;
125              size -= diff;
126              if (off % lfs->cfg->prog_size == 0) {
127                  int err = lfs_cache_flush(lfs, pcache, rcache);
128                  if (err) {
129                      return err;
130                  }
131              }
132              continue;
133          }
134          LFS_ASSERT(pcache->block == 0xffffffff);
135          if (off % lfs->cfg->prog_size == 0 &&
136                  size >= lfs->cfg->prog_size) {
137              lfs_size_t diff = size - (size % lfs->cfg->prog_size);
138              int err = lfs->cfg->prog(lfs->cfg, block, off, data, diff);
139              if (err) {
140                  return err;
141              }
142              if (rcache) {
143                  int res = lfs_cache_cmp(lfs, rcache, NULL,
144                          block, off, data, diff);
145                  if (res < 0) {
146                      return res;
147                  }
148                  if (!res) {
149                      return LFS_ERR_CORRUPT;
150                  }
151              }
152              data += diff;
153              off += diff;
154              size -= diff;
155              continue;
156          }
157          pcache->block = block;
158          pcache->off = off - (off % lfs->cfg->prog_size);
159      }
160      return 0;
161  }
162  static int lfs_bd_read(lfs_t *lfs, lfs_block_t block,
163          lfs_off_t off, void *buffer, lfs_size_t size) {
164      return lfs_cache_read(lfs, &lfs->rcache, NULL,
165              block, off, buffer, size);
166  }
167  static int lfs_bd_prog(lfs_t *lfs, lfs_block_t block,
168          lfs_off_t off, const void *buffer, lfs_size_t size) {
169      return lfs_cache_prog(lfs, &lfs->pcache, NULL,
170              block, off, buffer, size);
171  }
172  static int lfs_bd_cmp(lfs_t *lfs, lfs_block_t block,
173          lfs_off_t off, const void *buffer, lfs_size_t size) {
174      return lfs_cache_cmp(lfs, &lfs->rcache, NULL, block, off, buffer, size);
175  }
176  static int lfs_bd_crc(lfs_t *lfs, lfs_block_t block,
177          lfs_off_t off, lfs_size_t size, uint32_t *crc) {
178      return lfs_cache_crc(lfs, &lfs->rcache, NULL, block, off, size, crc);
179  }
180  static int lfs_bd_erase(lfs_t *lfs, lfs_block_t block) {
181      return lfs->cfg->erase(lfs->cfg, block);
182  }
183  static int lfs_bd_sync(lfs_t *lfs) {
184      lfs_cache_drop(lfs, &lfs->rcache);
185      int err = lfs_cache_flush(lfs, &lfs->pcache, NULL);
186      if (err) {
187          return err;
188      }
189      return lfs->cfg->sync(lfs->cfg);
190  }
191  int lfs_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data);
192  static int lfs_pred(lfs_t *lfs, const lfs_block_t dir[2], lfs_dir_t *pdir);
193  static int lfs_parent(lfs_t *lfs, const lfs_block_t dir[2],
194          lfs_dir_t *parent, lfs_entry_t *entry);
195  static int lfs_moved(lfs_t *lfs, const void *e);
196  static int lfs_relocate(lfs_t *lfs,
197          const lfs_block_t oldpair[2], const lfs_block_t newpair[2]);
198  int lfs_deorphan(lfs_t *lfs);
199  static int lfs_alloc_lookahead(void *p, lfs_block_t block) {
200      lfs_t *lfs = p;
201      lfs_block_t off = ((block - lfs->free.off)
202              + lfs->cfg->block_count) % lfs->cfg->block_count;
203      if (off < lfs->free.size) {
204          lfs->free.buffer[off / 32] |= 1U << (off % 32);
205      }
206      return 0;
207  }
208  static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
209      while (true) {
210          while (lfs->free.i != lfs->free.size) {
211              lfs_block_t off = lfs->free.i;
212              lfs->free.i += 1;
213              lfs->free.ack -= 1;
214              if (!(lfs->free.buffer[off / 32] & (1U << (off % 32)))) {
215                  *block = (lfs->free.off + off) % lfs->cfg->block_count;
216                  while (lfs->free.i != lfs->free.size &&
217                          (lfs->free.buffer[lfs->free.i / 32]
218                              & (1U << (lfs->free.i % 32)))) {
219                      lfs->free.i += 1;
220                      lfs->free.ack -= 1;
221                  }
222                  return 0;
223              }
224          }
225          if (lfs->free.ack == 0) {
226              LFS_WARN("No more free space %" PRIu32,
227                      lfs->free.i + lfs->free.off);
228              return LFS_ERR_NOSPC;
229          }
230          lfs->free.off = (lfs->free.off + lfs->free.size)
231                  % lfs->cfg->block_count;
232          lfs->free.size = lfs_min(lfs->cfg->lookahead, lfs->free.ack);
233          lfs->free.i = 0;
234          memset(lfs->free.buffer, 0, lfs->cfg->lookahead/8);
235          int err = lfs_traverse(lfs, lfs_alloc_lookahead, lfs);
236          if (err) {
237              return err;
238          }
239      }
240  }
241  static void lfs_alloc_ack(lfs_t *lfs) {
242      lfs->free.ack = lfs->cfg->block_count;
243  }
244  static void lfs_dir_fromle32(struct lfs_disk_dir *d) {
245      d->rev     = lfs_fromle32(d->rev);
246      d->size    = lfs_fromle32(d->size);
247      d->tail[0] = lfs_fromle32(d->tail[0]);
248      d->tail[1] = lfs_fromle32(d->tail[1]);
249  }
250  static void lfs_dir_tole32(struct lfs_disk_dir *d) {
251      d->rev     = lfs_tole32(d->rev);
252      d->size    = lfs_tole32(d->size);
253      d->tail[0] = lfs_tole32(d->tail[0]);
254      d->tail[1] = lfs_tole32(d->tail[1]);
255  }
256  static void lfs_entry_fromle32(struct lfs_disk_entry *d) {
257      d->u.dir[0] = lfs_fromle32(d->u.dir[0]);
258      d->u.dir[1] = lfs_fromle32(d->u.dir[1]);
259  }
260  static void lfs_entry_tole32(struct lfs_disk_entry *d) {
261      d->u.dir[0] = lfs_tole32(d->u.dir[0]);
262      d->u.dir[1] = lfs_tole32(d->u.dir[1]);
263  }
264  static void lfs_superblock_fromle32(struct lfs_disk_superblock *d) {
265      d->root[0]     = lfs_fromle32(d->root[0]);
266      d->root[1]     = lfs_fromle32(d->root[1]);
267      d->block_size  = lfs_fromle32(d->block_size);
268      d->block_count = lfs_fromle32(d->block_count);
269      d->version     = lfs_fromle32(d->version);
270  }
271  static void lfs_superblock_tole32(struct lfs_disk_superblock *d) {
272      d->root[0]     = lfs_tole32(d->root[0]);
273      d->root[1]     = lfs_tole32(d->root[1]);
274      d->block_size  = lfs_tole32(d->block_size);
275      d->block_count = lfs_tole32(d->block_count);
276      d->version     = lfs_tole32(d->version);
277  }
278  static inline void lfs_pairswap(lfs_block_t pair[2]) {
279      lfs_block_t t = pair[0];
280      pair[0] = pair[1];
281      pair[1] = t;
282  }
283  static inline bool lfs_pairisnull(const lfs_block_t pair[2]) {
284      return pair[0] == 0xffffffff || pair[1] == 0xffffffff;
285  }
286  static inline int lfs_paircmp(
287          const lfs_block_t paira[2],
288          const lfs_block_t pairb[2]) {
289      return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
290               paira[0] == pairb[1] || paira[1] == pairb[0]);
291  }
292  static inline bool lfs_pairsync(
293          const lfs_block_t paira[2],
294          const lfs_block_t pairb[2]) {
295      return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
296             (paira[0] == pairb[1] && paira[1] == pairb[0]);
297  }
298  static inline lfs_size_t lfs_entry_size(const lfs_entry_t *entry) {
299      return 4 + entry->d.elen + entry->d.alen + entry->d.nlen;
300  }
301  static int lfs_dir_alloc(lfs_t *lfs, lfs_dir_t *dir) {
302      for (int i = 0; i < 2; i++) {
303          int err = lfs_alloc(lfs, &dir->pair[i]);
304          if (err) {
305              return err;
306          }
307      }
308      int err = lfs_bd_read(lfs, dir->pair[0], 0, &dir->d.rev, 4);
309      if (err && err != LFS_ERR_CORRUPT) {
310          return err;
311      }
312      if (err != LFS_ERR_CORRUPT) {
313          dir->d.rev = lfs_fromle32(dir->d.rev);
314      }
315      dir->d.rev += 1;
316      dir->d.size = sizeof(dir->d)+4;
317      dir->d.tail[0] = 0xffffffff;
318      dir->d.tail[1] = 0xffffffff;
319      dir->off = sizeof(dir->d);
320      return 0;
321  }
322  static int lfs_dir_fetch(lfs_t *lfs,
323          lfs_dir_t *dir, const lfs_block_t pair[2]) {
324      const lfs_block_t tpair[2] = {pair[0], pair[1]};
325      bool valid = false;
326      for (int i = 0; i < 2; i++) {
327          struct lfs_disk_dir test;
328          int err = lfs_bd_read(lfs, tpair[i], 0, &test, sizeof(test));
329          lfs_dir_fromle32(&test);
330          if (err) {
331              if (err == LFS_ERR_CORRUPT) {
332                  continue;
333              }
334              return err;
335          }
336          if (valid && lfs_scmp(test.rev, dir->d.rev) < 0) {
337              continue;
338          }
339          if ((0x7fffffff & test.size) < sizeof(test)+4 ||
340              (0x7fffffff & test.size) > lfs->cfg->block_size) {
341              continue;
342          }
343          uint32_t crc = 0xffffffff;
344          lfs_dir_tole32(&test);
345          lfs_crc(&crc, &test, sizeof(test));
346          lfs_dir_fromle32(&test);
347          err = lfs_bd_crc(lfs, tpair[i], sizeof(test),
348                  (0x7fffffff & test.size) - sizeof(test), &crc);
349          if (err) {
350              if (err == LFS_ERR_CORRUPT) {
351                  continue;
352              }
353              return err;
354          }
355          if (crc != 0) {
356              continue;
357          }
358          valid = true;
359          dir->pair[0] = tpair[(i+0) % 2];
360          dir->pair[1] = tpair[(i+1) % 2];
361          dir->off = sizeof(dir->d);
362          dir->d = test;
363      }
364      if (!valid) {
365          LFS_ERROR("Corrupted dir pair at %" PRIu32 " %" PRIu32 ,
366                  tpair[0], tpair[1]);
367          return LFS_ERR_CORRUPT;
368      }
369      return 0;
370  }
371  struct lfs_region {
372      lfs_off_t oldoff;
373      lfs_size_t oldlen;
374      const void *newdata;
375      lfs_size_t newlen;
376  };
377  static int lfs_dir_commit(lfs_t *lfs, lfs_dir_t *dir,
378          const struct lfs_region *regions, int count) {
379      dir->d.rev += 1;
380      lfs_pairswap(dir->pair);
381      for (int i = 0; i < count; i++) {
382          dir->d.size += regions[i].newlen - regions[i].oldlen;
383      }
384      const lfs_block_t oldpair[2] = {dir->pair[0], dir->pair[1]};
385      bool relocated = false;
386      while (true) {
387          if (true) {
388              int err = lfs_bd_erase(lfs, dir->pair[0]);
389              if (err) {
390                  if (err == LFS_ERR_CORRUPT) {
391                      goto relocate;
392                  }
393                  return err;
394              }
395              uint32_t crc = 0xffffffff;
396              lfs_dir_tole32(&dir->d);
397              lfs_crc(&crc, &dir->d, sizeof(dir->d));
398              err = lfs_bd_prog(lfs, dir->pair[0], 0, &dir->d, sizeof(dir->d));
399              lfs_dir_fromle32(&dir->d);
400              if (err) {
401                  if (err == LFS_ERR_CORRUPT) {
402                      goto relocate;
403                  }
404                  return err;
405              }
406              int i = 0;
407              lfs_off_t oldoff = sizeof(dir->d);
408              lfs_off_t newoff = sizeof(dir->d);
409              while (newoff < (0x7fffffff & dir->d.size)-4) {
410                  if (i < count && regions[i].oldoff == oldoff) {
411                      lfs_crc(&crc, regions[i].newdata, regions[i].newlen);
412                      err = lfs_bd_prog(lfs, dir->pair[0],
413                              newoff, regions[i].newdata, regions[i].newlen);
414                      if (err) {
415                          if (err == LFS_ERR_CORRUPT) {
416                              goto relocate;
417                          }
418                          return err;
419                      }
420                      oldoff += regions[i].oldlen;
421                      newoff += regions[i].newlen;
422                      i += 1;
423                  } else {
424                      uint8_t data;
425                      err = lfs_bd_read(lfs, oldpair[1], oldoff, &data, 1);
426                      if (err) {
427                          return err;
428                      }
429                      lfs_crc(&crc, &data, 1);
430                      err = lfs_bd_prog(lfs, dir->pair[0], newoff, &data, 1);
431                      if (err) {
432                          if (err == LFS_ERR_CORRUPT) {
433                              goto relocate;
434                          }
435                          return err;
436                      }
437                      oldoff += 1;
438                      newoff += 1;
439                  }
440              }
441              crc = lfs_tole32(crc);
442              err = lfs_bd_prog(lfs, dir->pair[0], newoff, &crc, 4);
443              crc = lfs_fromle32(crc);
444              if (err) {
445                  if (err == LFS_ERR_CORRUPT) {
446                      goto relocate;
447                  }
448                  return err;
449              }
450              err = lfs_bd_sync(lfs);
451              if (err) {
452                  if (err == LFS_ERR_CORRUPT) {
453                      goto relocate;
454                  }
455                  return err;
456              }
457              uint32_t ncrc = 0xffffffff;
458              err = lfs_bd_crc(lfs, dir->pair[0], 0,
459                      (0x7fffffff & dir->d.size)-4, &ncrc);
460              if (err) {
461                  return err;
462              }
463              if (ncrc != crc) {
464                  goto relocate;
465              }
466          }
467          break;
468  relocate:
469          LFS_DEBUG("Bad block at %" PRIu32, dir->pair[0]);
470          relocated = true;
471          lfs_cache_drop(lfs, &lfs->pcache);
472          if (lfs_paircmp(oldpair, (const lfs_block_t[2]){0, 1}) == 0) {
473              LFS_WARN("Superblock %" PRIu32 " has become unwritable",
474                      oldpair[0]);
475              return LFS_ERR_CORRUPT;
476          }
477          int err = lfs_alloc(lfs, &dir->pair[0]);
478          if (err) {
479              return err;
480          }
481      }
482      if (relocated) {
483          LFS_DEBUG("Relocating %" PRIu32 " %" PRIu32 " to %" PRIu32 " %" PRIu32,
484                  oldpair[0], oldpair[1], dir->pair[0], dir->pair[1]);
485          int err = lfs_relocate(lfs, oldpair, dir->pair);
486          if (err) {
487              return err;
488          }
489      }
490      for (lfs_dir_t *d = lfs->dirs; d; d = d->next) {
491          if (lfs_paircmp(d->pair, dir->pair) == 0) {
492              d->pair[0] = dir->pair[0];
493              d->pair[1] = dir->pair[1];
494          }
495      }
496      return 0;
497  }
498  static int lfs_dir_update(lfs_t *lfs, lfs_dir_t *dir,
499          lfs_entry_t *entry, const void *data) {
500      lfs_entry_tole32(&entry->d);
501      int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
502              {entry->off, sizeof(entry->d), &entry->d, sizeof(entry->d)},
503              {entry->off+sizeof(entry->d), entry->d.nlen, data, entry->d.nlen}
504          }, data ? 2 : 1);
505      lfs_entry_fromle32(&entry->d);
506      return err;
507  }
508  static int lfs_dir_append(lfs_t *lfs, lfs_dir_t *dir,
509          lfs_entry_t *entry, const void *data) {
510      while (true) {
511          if (dir->d.size + lfs_entry_size(entry) <= lfs->cfg->block_size) {
512              entry->off = dir->d.size - 4;
513              lfs_entry_tole32(&entry->d);
514              int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
515                      {entry->off, 0, &entry->d, sizeof(entry->d)},
516                      {entry->off, 0, data, entry->d.nlen}
517                  }, 2);
518              lfs_entry_fromle32(&entry->d);
519              return err;
520          }
521          if (!(0x80000000 & dir->d.size)) {
522              lfs_dir_t olddir = *dir;
523              int err = lfs_dir_alloc(lfs, dir);
524              if (err) {
525                  return err;
526              }
527              dir->d.tail[0] = olddir.d.tail[0];
528              dir->d.tail[1] = olddir.d.tail[1];
529              entry->off = dir->d.size - 4;
530              lfs_entry_tole32(&entry->d);
531              err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
532                      {entry->off, 0, &entry->d, sizeof(entry->d)},
533                      {entry->off, 0, data, entry->d.nlen}
534                  }, 2);
535              lfs_entry_fromle32(&entry->d);
536              if (err) {
537                  return err;
538              }
539              olddir.d.size |= 0x80000000;
540              olddir.d.tail[0] = dir->pair[0];
541              olddir.d.tail[1] = dir->pair[1];
542              return lfs_dir_commit(lfs, &olddir, NULL, 0);
543          }
544          int err = lfs_dir_fetch(lfs, dir, dir->d.tail);
545          if (err) {
546              return err;
547          }
548      }
549  }
550  static int lfs_dir_remove(lfs_t *lfs, lfs_dir_t *dir, lfs_entry_t *entry) {
551      if ((dir->d.size & 0x7fffffff) == sizeof(dir->d)+4
552              + lfs_entry_size(entry)) {
553          lfs_dir_t pdir;
554          int res = lfs_pred(lfs, dir->pair, &pdir);
555          if (res < 0) {
556              return res;
557          }
558          if (pdir.d.size & 0x80000000) {
559              pdir.d.size &= dir->d.size | 0x7fffffff;
560              pdir.d.tail[0] = dir->d.tail[0];
561              pdir.d.tail[1] = dir->d.tail[1];
562              return lfs_dir_commit(lfs, &pdir, NULL, 0);
563          }
564      }
565      int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
566              {entry->off, lfs_entry_size(entry), NULL, 0},
567          }, 1);
568      if (err) {
569          return err;
570      }
571      for (lfs_file_t *f = lfs->files; f; f = f->next) {
572          if (lfs_paircmp(f->pair, dir->pair) == 0) {
573              if (f->poff == entry->off) {
574                  f->pair[0] = 0xffffffff;
575                  f->pair[1] = 0xffffffff;
576              } else if (f->poff > entry->off) {
577                  f->poff -= lfs_entry_size(entry);
578              }
579          }
580      }
581      for (lfs_dir_t *d = lfs->dirs; d; d = d->next) {
582          if (lfs_paircmp(d->pair, dir->pair) == 0) {
583              if (d->off > entry->off) {
584                  d->off -= lfs_entry_size(entry);
585                  d->pos -= lfs_entry_size(entry);
586              }
587          }
588      }
589      return 0;
590  }
591  static int lfs_dir_next(lfs_t *lfs, lfs_dir_t *dir, lfs_entry_t *entry) {
592      while (dir->off + sizeof(entry->d) > (0x7fffffff & dir->d.size)-4) {
593          if (!(0x80000000 & dir->d.size)) {
594              entry->off = dir->off;
595              return LFS_ERR_NOENT;
596          }
597          int err = lfs_dir_fetch(lfs, dir, dir->d.tail);
598          if (err) {
599              return err;
600          }
601          dir->off = sizeof(dir->d);
602          dir->pos += sizeof(dir->d) + 4;
603      }
604      int err = lfs_bd_read(lfs, dir->pair[0], dir->off,
605              &entry->d, sizeof(entry->d));
606      lfs_entry_fromle32(&entry->d);
607      if (err) {
608          return err;
609      }
610      entry->off = dir->off;
611      dir->off += lfs_entry_size(entry);
612      dir->pos += lfs_entry_size(entry);
613      return 0;
614  }
615  static int lfs_dir_find(lfs_t *lfs, lfs_dir_t *dir,
616          lfs_entry_t *entry, const char **path) {
617      const char *pathname = *path;
618      size_t pathlen;
619      entry->d.type = LFS_TYPE_DIR;
620      entry->d.elen = sizeof(entry->d) - 4;
621      entry->d.alen = 0;
622      entry->d.nlen = 0;
623      entry->d.u.dir[0] = lfs->root[0];
624      entry->d.u.dir[1] = lfs->root[1];
625      while (true) {
626  nextname:
627          pathname += strspn(pathname, "/");
628          pathlen = strcspn(pathname, "/");
629          if ((pathlen == 1 && memcmp(pathname, ".", 1) == 0) ||
630              (pathlen == 2 && memcmp(pathname, "..", 2) == 0)) {
631              pathname += pathlen;
632              goto nextname;
633          }
634          const char *suffix = pathname + pathlen;
635          size_t sufflen;
636          int depth = 1;
637          while (true) {
638              suffix += strspn(suffix, "/");
639              sufflen = strcspn(suffix, "/");
640              if (sufflen == 0) {
641                  break;
642              }
643              if (sufflen == 2 && memcmp(suffix, "..", 2) == 0) {
644                  depth -= 1;
645                  if (depth == 0) {
646                      pathname = suffix + sufflen;
647                      goto nextname;
648                  }
649              } else {
650                  depth += 1;
651              }
652              suffix += sufflen;
653          }
654          if (pathname[0] == '\0') {
655              return 0;
656          }
657          *path = pathname;
658          if (entry->d.type != LFS_TYPE_DIR) {
659              return LFS_ERR_NOTDIR;
660          }
661          int err = lfs_dir_fetch(lfs, dir, entry->d.u.dir);
662          if (err) {
663              return err;
664          }
665          while (true) {
666              err = lfs_dir_next(lfs, dir, entry);
667              if (err) {
668                  return err;
669              }
670              if (((0x7f & entry->d.type) != LFS_TYPE_REG &&
671                   (0x7f & entry->d.type) != LFS_TYPE_DIR) ||
672                  entry->d.nlen != pathlen) {
673                  continue;
674              }
675              int res = lfs_bd_cmp(lfs, dir->pair[0],
676                      entry->off + 4+entry->d.elen+entry->d.alen,
677                      pathname, pathlen);
678              if (res < 0) {
679                  return res;
680              }
681              if (res) {
682                  break;
683              }
684          }
685          if (entry->d.type & 0x80) {
686              int moved = lfs_moved(lfs, &entry->d.u);
687              if (moved < 0 || moved) {
688                  return (moved < 0) ? moved : LFS_ERR_NOENT;
689              }
690              entry->d.type &= ~0x80;
691          }
692          pathname += pathlen;
693      }
694  }
695  int lfs_mkdir(lfs_t *lfs, const char *path) {
696      if (!lfs->deorphaned) {
697          int err = lfs_deorphan(lfs);
698          if (err) {
699              return err;
700          }
701      }
702      lfs_dir_t cwd;
703      lfs_entry_t entry;
704      int err = lfs_dir_find(lfs, &cwd, &entry, &path);
705      if (err != LFS_ERR_NOENT || strchr(path, '/') != NULL) {
706          return err ? err : LFS_ERR_EXIST;
707      }
708      lfs_alloc_ack(lfs);
709      lfs_dir_t dir;
710      err = lfs_dir_alloc(lfs, &dir);
711      if (err) {
712          return err;
713      }
714      dir.d.tail[0] = cwd.d.tail[0];
715      dir.d.tail[1] = cwd.d.tail[1];
716      err = lfs_dir_commit(lfs, &dir, NULL, 0);
717      if (err) {
718          return err;
719      }
720      entry.d.type = LFS_TYPE_DIR;
721      entry.d.elen = sizeof(entry.d) - 4;
722      entry.d.alen = 0;
723      entry.d.nlen = strlen(path);
724      entry.d.u.dir[0] = dir.pair[0];
725      entry.d.u.dir[1] = dir.pair[1];
726      cwd.d.tail[0] = dir.pair[0];
727      cwd.d.tail[1] = dir.pair[1];
728      err = lfs_dir_append(lfs, &cwd, &entry, path);
729      if (err) {
730          return err;
731      }
732      lfs_alloc_ack(lfs);
733      return 0;
734  }
735  int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
736      dir->pair[0] = lfs->root[0];
737      dir->pair[1] = lfs->root[1];
738      lfs_entry_t entry;
739      int err = lfs_dir_find(lfs, dir, &entry, &path);
740      if (err) {
741          return err;
742      } else if (entry.d.type != LFS_TYPE_DIR) {
743          return LFS_ERR_NOTDIR;
744      }
745      err = lfs_dir_fetch(lfs, dir, entry.d.u.dir);
746      if (err) {
747          return err;
748      }
749      dir->head[0] = dir->pair[0];
750      dir->head[1] = dir->pair[1];
751      dir->pos = sizeof(dir->d) - 2;
752      dir->off = sizeof(dir->d);
753      dir->next = lfs->dirs;
754      lfs->dirs = dir;
755      return 0;
756  }
757  int lfs_dir_close(lfs_t *lfs, lfs_dir_t *dir) {
758      for (lfs_dir_t **p = &lfs->dirs; *p; p = &(*p)->next) {
759          if (*p == dir) {
760              *p = dir->next;
761              break;
762          }
763      }
764      return 0;
765  }
766  int lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {
767      memset(info, 0, sizeof(*info));
768      if (dir->pos == sizeof(dir->d) - 2) {
769          info->type = LFS_TYPE_DIR;
770          strcpy(info->name, ".");
771          dir->pos += 1;
772          return 1;
773      } else if (dir->pos == sizeof(dir->d) - 1) {
774          info->type = LFS_TYPE_DIR;
775          strcpy(info->name, "..");
776          dir->pos += 1;
777          return 1;
778      }
779      lfs_entry_t entry;
780      while (true) {
781          int err = lfs_dir_next(lfs, dir, &entry);
782          if (err) {
783              return (err == LFS_ERR_NOENT) ? 0 : err;
784          }
785          if ((0x7f & entry.d.type) != LFS_TYPE_REG &&
786              (0x7f & entry.d.type) != LFS_TYPE_DIR) {
787              continue;
788          }
789          if (entry.d.type & 0x80) {
790              int moved = lfs_moved(lfs, &entry.d.u);
791              if (moved < 0) {
792                  return moved;
793              }
794              if (moved) {
795                  continue;
796              }
797              entry.d.type &= ~0x80;
798          }
799          break;
800      }
801      info->type = entry.d.type;
802      if (info->type == LFS_TYPE_REG) {
803          info->size = entry.d.u.file.size;
804      }
805      int err = lfs_bd_read(lfs, dir->pair[0],
806              entry.off + 4+entry.d.elen+entry.d.alen,
807              info->name, entry.d.nlen);
808      if (err) {
809          return err;
810      }
811      return 1;
812  }
813  int lfs_dir_seek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {
814      int err = lfs_dir_rewind(lfs, dir);
815      if (err) {
816          return err;
817      }
818      dir->pos = off;
819      while (off > (0x7fffffff & dir->d.size)) {
820          off -= 0x7fffffff & dir->d.size;
821          if (!(0x80000000 & dir->d.size)) {
822              return LFS_ERR_INVAL;
823          }
824          err = lfs_dir_fetch(lfs, dir, dir->d.tail);
825          if (err) {
826              return err;
827          }
828      }
829      dir->off = off;
830      return 0;
831  }
832  lfs_soff_t lfs_dir_tell(lfs_t *lfs, lfs_dir_t *dir) {
833      (void)lfs;
834      return dir->pos;
835  }
836  int lfs_dir_rewind(lfs_t *lfs, lfs_dir_t *dir) {
837      int err = lfs_dir_fetch(lfs, dir, dir->head);
838      if (err) {
839          return err;
840      }
841      dir->pair[0] = dir->head[0];
842      dir->pair[1] = dir->head[1];
843      dir->pos = sizeof(dir->d) - 2;
844      dir->off = sizeof(dir->d);
845      return 0;
846  }
847  static int lfs_ctz_index(lfs_t *lfs, lfs_off_t *off) {
848      lfs_off_t size = *off;
849      lfs_off_t b = lfs->cfg->block_size - 2*4;
850      lfs_off_t i = size / b;
851      if (i == 0) {
852          return 0;
853      }
854      i = (size - 4*(lfs_popc(i-1)+2)) / b;
855      *off = size - b*i - 4*lfs_popc(i);
856      return i;
857  }
858  static int lfs_ctz_find(lfs_t *lfs,
859          lfs_cache_t *rcache, const lfs_cache_t *pcache,
860          lfs_block_t head, lfs_size_t size,
861          lfs_size_t pos, lfs_block_t *block, lfs_off_t *off) {
862      if (size == 0) {
863          *block = 0xffffffff;
864          *off = 0;
865          return 0;
866      }
867      lfs_off_t current = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
868      lfs_off_t target = lfs_ctz_index(lfs, &pos);
869      while (current > target) {
870          lfs_size_t skip = lfs_min(
871                  lfs_npw2(current-target+1) - 1,
872                  lfs_ctz(current));
873          int err = lfs_cache_read(lfs, rcache, pcache, head, 4*skip, &head, 4);
874          head = lfs_fromle32(head);
875          if (err) {
876              return err;
877          }
878          LFS_ASSERT(head >= 2 && head <= lfs->cfg->block_count);
879          current -= 1 << skip;
880      }
881      *block = head;
882      *off = pos;
883      return 0;
884  }
885  static int lfs_ctz_extend(lfs_t *lfs,
886          lfs_cache_t *rcache, lfs_cache_t *pcache,
887          lfs_block_t head, lfs_size_t size,
888          lfs_block_t *block, lfs_off_t *off) {
889      while (true) {
890          lfs_block_t nblock;
891          int err = lfs_alloc(lfs, &nblock);
892          if (err) {
893              return err;
894          }
895          LFS_ASSERT(nblock >= 2 && nblock <= lfs->cfg->block_count);
896          if (true) {
897              err = lfs_bd_erase(lfs, nblock);
898              if (err) {
899                  if (err == LFS_ERR_CORRUPT) {
900                      goto relocate;
901                  }
902                  return err;
903              }
904              if (size == 0) {
905                  *block = nblock;
906                  *off = 0;
907                  return 0;
908              }
909              size -= 1;
910              lfs_off_t index = lfs_ctz_index(lfs, &size);
911              size += 1;
912              if (size != lfs->cfg->block_size) {
913                  for (lfs_off_t i = 0; i < size; i++) {
914                      uint8_t data;
915                      err = lfs_cache_read(lfs, rcache, NULL,
916                              head, i, &data, 1);
917                      if (err) {
918                          return err;
919                      }
920                      err = lfs_cache_prog(lfs, pcache, rcache,
921                              nblock, i, &data, 1);
922                      if (err) {
923                          if (err == LFS_ERR_CORRUPT) {
924                              goto relocate;
925                          }
926                          return err;
927                      }
928                  }
929                  *block = nblock;
930                  *off = size;
931                  return 0;
932              }
933              index += 1;
934              lfs_size_t skips = lfs_ctz(index) + 1;
935              for (lfs_off_t i = 0; i < skips; i++) {
936                  head = lfs_tole32(head);
937                  err = lfs_cache_prog(lfs, pcache, rcache,
938                          nblock, 4*i, &head, 4);
939                  head = lfs_fromle32(head);
940                  if (err) {
941                      if (err == LFS_ERR_CORRUPT) {
942                          goto relocate;
943                      }
944                      return err;
945                  }
946                  if (i != skips-1) {
947                      err = lfs_cache_read(lfs, rcache, NULL,
948                              head, 4*i, &head, 4);
949                      head = lfs_fromle32(head);
950                      if (err) {
951                          return err;
952                      }
953                  }
954                  LFS_ASSERT(head >= 2 && head <= lfs->cfg->block_count);
955              }
956              *block = nblock;
957              *off = 4*skips;
958              return 0;
959          }
960  relocate:
961          LFS_DEBUG("Bad block at %" PRIu32, nblock);
962          lfs_cache_drop(lfs, &lfs->pcache);
963      }
964  }
965  static int lfs_ctz_traverse(lfs_t *lfs,
966          lfs_cache_t *rcache, const lfs_cache_t *pcache,
967          lfs_block_t head, lfs_size_t size,
968          int (*cb)(void*, lfs_block_t), void *data) {
969      if (size == 0) {
970          return 0;
971      }
972      lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
973      while (true) {
974          int err = cb(data, head);
975          if (err) {
976              return err;
977          }
978          if (index == 0) {
979              return 0;
980          }
981          lfs_block_t heads[2];
982          int count = 2 - (index & 1);
983          err = lfs_cache_read(lfs, rcache, pcache, head, 0, &heads, count*4);
984          heads[0] = lfs_fromle32(heads[0]);
985          heads[1] = lfs_fromle32(heads[1]);
986          if (err) {
987              return err;
988          }
989          for (int i = 0; i < count-1; i++) {
990              err = cb(data, heads[i]);
991              if (err) {
992                  return err;
993              }
994          }
995          head = heads[count-1];
996          index -= count;
997      }
998  }
999  int lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,
1000          const char *path, int flags,
1001          const struct lfs_file_config *cfg) {
1002      if ((flags & 3) != LFS_O_RDONLY && !lfs->deorphaned) {
1003          int err = lfs_deorphan(lfs);
1004          if (err) {
1005              return err;
1006          }
1007      }
1008      lfs_dir_t cwd;
1009      lfs_entry_t entry;
1010      int err = lfs_dir_find(lfs, &cwd, &entry, &path);
1011      if (err && (err != LFS_ERR_NOENT || strchr(path, '/') != NULL)) {
1012          return err;
1013      }
1014      if (err == LFS_ERR_NOENT) {
1015          if (!(flags & LFS_O_CREAT)) {
1016              return LFS_ERR_NOENT;
1017          }
1018          entry.d.type = LFS_TYPE_REG;
1019          entry.d.elen = sizeof(entry.d) - 4;
1020          entry.d.alen = 0;
1021          entry.d.nlen = strlen(path);
1022          entry.d.u.file.head = 0xffffffff;
1023          entry.d.u.file.size = 0;
1024          err = lfs_dir_append(lfs, &cwd, &entry, path);
1025          if (err) {
1026              return err;
1027          }
1028      } else if (entry.d.type == LFS_TYPE_DIR) {
1029          return LFS_ERR_ISDIR;
1030      } else if (flags & LFS_O_EXCL) {
1031          return LFS_ERR_EXIST;
1032      }
1033      file->cfg = cfg;
1034      file->pair[0] = cwd.pair[0];
1035      file->pair[1] = cwd.pair[1];
1036      file->poff = entry.off;
1037      file->head = entry.d.u.file.head;
1038      file->size = entry.d.u.file.size;
1039      file->flags = flags;
1040      file->pos = 0;
1041      if (flags & LFS_O_TRUNC) {
1042          if (file->size != 0) {
1043              file->flags |= LFS_F_DIRTY;
1044          }
1045          file->head = 0xffffffff;
1046          file->size = 0;
1047      }
1048      file->cache.block = 0xffffffff;
1049      if (file->cfg && file->cfg->buffer) {
1050          file->cache.buffer = file->cfg->buffer;
1051      } else if (lfs->cfg->file_buffer) {
1052          if (lfs->files) {
1053              return LFS_ERR_NOMEM;
1054          }
1055          file->cache.buffer = lfs->cfg->file_buffer;
1056      } else if ((file->flags & 3) == LFS_O_RDONLY) {
1057          file->cache.buffer = lfs_malloc(lfs->cfg->read_size);
1058          if (!file->cache.buffer) {
1059              return LFS_ERR_NOMEM;
1060          }
1061      } else {
1062          file->cache.buffer = lfs_malloc(lfs->cfg->prog_size);
1063          if (!file->cache.buffer) {
1064              return LFS_ERR_NOMEM;
1065          }
1066      }
1067      lfs_cache_drop(lfs, &file->cache);
1068      if ((file->flags & 3) != LFS_O_RDONLY) {
1069          lfs_cache_zero(lfs, &file->cache);
1070      }
1071      file->next = lfs->files;
1072      lfs->files = file;
1073      return 0;
1074  }
1075  int lfs_file_open(lfs_t *lfs, lfs_file_t *file,
1076          const char *path, int flags) {
1077      return lfs_file_opencfg(lfs, file, path, flags, NULL);
1078  }
1079  int lfs_file_close(lfs_t *lfs, lfs_file_t *file) {
1080      int err = lfs_file_sync(lfs, file);
1081      for (lfs_file_t **p = &lfs->files; *p; p = &(*p)->next) {
1082          if (*p == file) {
1083              *p = file->next;
1084              break;
1085          }
1086      }
1087      if (!(file->cfg && file->cfg->buffer) && !lfs->cfg->file_buffer) {
1088          lfs_free(file->cache.buffer);
1089      }
1090      return err;
1091  }
1092  static int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {
1093  relocate:
1094      LFS_DEBUG("Bad block at %" PRIu32, file->block);
1095      lfs_block_t nblock;
1096      int err = lfs_alloc(lfs, &nblock);
1097      if (err) {
1098          return err;
1099      }
1100      err = lfs_bd_erase(lfs, nblock);
1101      if (err) {
1102          if (err == LFS_ERR_CORRUPT) {
1103              goto relocate;
1104          }
1105          return err;
1106      }
1107      for (lfs_off_t i = 0; i < file->off; i++) {
1108          uint8_t data;
1109          err = lfs_cache_read(lfs, &lfs->rcache, &file->cache,
1110                  file->block, i, &data, 1);
1111          if (err) {
1112              return err;
1113          }
1114          err = lfs_cache_prog(lfs, &lfs->pcache, &lfs->rcache,
1115                  nblock, i, &data, 1);
1116          if (err) {
1117              if (err == LFS_ERR_CORRUPT) {
1118                  goto relocate;
1119              }
1120              return err;
1121          }
1122      }
1123      memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->prog_size);
1124      file->cache.block = lfs->pcache.block;
1125      file->cache.off = lfs->pcache.off;
1126      lfs_cache_zero(lfs, &lfs->pcache);
1127      file->block = nblock;
1128      return 0;
1129  }
1130  static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
1131      if (file->flags & LFS_F_READING) {
1132          lfs_cache_drop(lfs, &file->cache);
1133          file->flags &= ~LFS_F_READING;
1134      }
1135      if (file->flags & LFS_F_WRITING) {
1136          lfs_off_t pos = file->pos;
1137          lfs_file_t orig = {
1138              .head = file->head,
1139              .size = file->size,
1140              .flags = LFS_O_RDONLY,
1141              .pos = file->pos,
1142              .cache = lfs->rcache,
1143          };
1144          lfs_cache_drop(lfs, &lfs->rcache);
1145          while (file->pos < file->size) {
1146              uint8_t data;
1147              lfs_ssize_t res = lfs_file_read(lfs, &orig, &data, 1);
1148              if (res < 0) {
1149                  return res;
1150              }
1151              res = lfs_file_write(lfs, file, &data, 1);
1152              if (res < 0) {
1153                  return res;
1154              }
1155              if (lfs->rcache.block != 0xffffffff) {
1156                  lfs_cache_drop(lfs, &orig.cache);
1157                  lfs_cache_drop(lfs, &lfs->rcache);
1158              }
1159          }
1160          while (true) {
1161              int err = lfs_cache_flush(lfs, &file->cache, &lfs->rcache);
1162              if (err) {
1163                  if (err == LFS_ERR_CORRUPT) {
1164                      goto relocate;
1165                  }
1166                  return err;
1167              }
1168              break;
1169  relocate:
1170              err = lfs_file_relocate(lfs, file);
1171              if (err) {
1172                  return err;
1173              }
1174          }
1175          file->head = file->block;
1176          file->size = file->pos;
1177          file->flags &= ~LFS_F_WRITING;
1178          file->flags |= LFS_F_DIRTY;
1179          file->pos = pos;
1180      }
1181      return 0;
1182  }
1183  int lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {
1184      int err = lfs_file_flush(lfs, file);
1185      if (err) {
1186          return err;
1187      }
1188      if ((file->flags & LFS_F_DIRTY) &&
1189              !(file->flags & LFS_F_ERRED) &&
1190              !lfs_pairisnull(file->pair)) {
1191          lfs_dir_t cwd;
1192          err = lfs_dir_fetch(lfs, &cwd, file->pair);
1193          if (err) {
1194              return err;
1195          }
1196          lfs_entry_t entry = {.off = file->poff};
1197          err = lfs_bd_read(lfs, cwd.pair[0], entry.off,
1198                  &entry.d, sizeof(entry.d));
1199          lfs_entry_fromle32(&entry.d);
1200          if (err) {
1201              return err;
1202          }
1203          LFS_ASSERT(entry.d.type == LFS_TYPE_REG);
1204          entry.d.u.file.head = file->head;
1205          entry.d.u.file.size = file->size;
1206          err = lfs_dir_update(lfs, &cwd, &entry, NULL);
1207          if (err) {
1208              return err;
1209          }
1210          file->flags &= ~LFS_F_DIRTY;
1211      }
1212      return 0;
1213  }
1214  lfs_ssize_t lfs_file_read(lfs_t *lfs, lfs_file_t *file,
1215          void *buffer, lfs_size_t size) {
1216      uint8_t *data = buffer;
1217      lfs_size_t nsize = size;
1218      if ((file->flags & 3) == LFS_O_WRONLY) {
1219          return LFS_ERR_BADF;
1220      }
1221      if (file->flags & LFS_F_WRITING) {
1222          int err = lfs_file_flush(lfs, file);
1223          if (err) {
1224              return err;
1225          }
1226      }
1227      if (file->pos >= file->size) {
1228          return 0;
1229      }
1230      size = lfs_min(size, file->size - file->pos);
1231      nsize = size;
1232      while (nsize > 0) {
1233          if (!(file->flags & LFS_F_READING) ||
1234                  file->off == lfs->cfg->block_size) {
1235              int err = lfs_ctz_find(lfs, &file->cache, NULL,
1236                      file->head, file->size,
1237                      file->pos, &file->block, &file->off);
1238              if (err) {
1239                  return err;
1240              }
1241              file->flags |= LFS_F_READING;
1242          }
1243          lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
1244          int err = lfs_cache_read(lfs, &file->cache, NULL,
1245                  file->block, file->off, data, diff);
1246          if (err) {
1247              return err;
1248          }
1249          file->pos += diff;
1250          file->off += diff;
1251          data += diff;
1252          nsize -= diff;
1253      }
1254      return size;
1255  }
1256  lfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,
1257          const void *buffer, lfs_size_t size) {
1258      const uint8_t *data = buffer;
1259      lfs_size_t nsize = size;
1260      if ((file->flags & 3) == LFS_O_RDONLY) {
1261          return LFS_ERR_BADF;
1262      }
1263      if (file->flags & LFS_F_READING) {
1264          int err = lfs_file_flush(lfs, file);
1265          if (err) {
1266              return err;
1267          }
1268      }
1269      if ((file->flags & LFS_O_APPEND) && file->pos < file->size) {
1270          file->pos = file->size;
1271      }
1272      if (!(file->flags & LFS_F_WRITING) && file->pos > file->size) {
1273          lfs_off_t pos = file->pos;
1274          file->pos = file->size;
1275          while (file->pos < pos) {
1276              lfs_ssize_t res = lfs_file_write(lfs, file, &(uint8_t){0}, 1);
1277              if (res < 0) {
1278                  return res;
1279              }
1280          }
1281      }
1282      while (nsize > 0) {
1283          if (!(file->flags & LFS_F_WRITING) ||
1284                  file->off == lfs->cfg->block_size) {
1285              if (!(file->flags & LFS_F_WRITING) && file->pos > 0) {
1286                  int err = lfs_ctz_find(lfs, &file->cache, NULL,
1287                          file->head, file->size,
1288                          file->pos-1, &file->block, &file->off);
1289                  if (err) {
1290                      file->flags |= LFS_F_ERRED;
1291                      return err;
1292                  }
1293                  lfs_cache_zero(lfs, &file->cache);
1294              }
1295              lfs_alloc_ack(lfs);
1296              int err = lfs_ctz_extend(lfs, &lfs->rcache, &file->cache,
1297                      file->block, file->pos,
1298                      &file->block, &file->off);
1299              if (err) {
1300                  file->flags |= LFS_F_ERRED;
1301                  return err;
1302              }
1303              file->flags |= LFS_F_WRITING;
1304          }
1305          lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
1306          while (true) {
1307              int err = lfs_cache_prog(lfs, &file->cache, &lfs->rcache,
1308                      file->block, file->off, data, diff);
1309              if (err) {
1310                  if (err == LFS_ERR_CORRUPT) {
1311                      goto relocate;
1312                  }
1313                  file->flags |= LFS_F_ERRED;
1314                  return err;
1315              }
1316              break;
1317  relocate:
1318              err = lfs_file_relocate(lfs, file);
1319              if (err) {
1320                  file->flags |= LFS_F_ERRED;
1321                  return err;
1322              }
1323          }
1324          file->pos += diff;
1325          file->off += diff;
1326          data += diff;
1327          nsize -= diff;
1328          lfs_alloc_ack(lfs);
1329      }
1330      file->flags &= ~LFS_F_ERRED;
1331      return size;
1332  }
1333  lfs_soff_t lfs_file_seek(lfs_t *lfs, lfs_file_t *file,
1334          lfs_soff_t off, int whence) {
1335      int err = lfs_file_flush(lfs, file);
1336      if (err) {
1337          return err;
1338      }
1339      if (whence == LFS_SEEK_SET) {
1340          file->pos = off;
1341      } else if (whence == LFS_SEEK_CUR) {
1342          if (off < 0 && (lfs_off_t)-off > file->pos) {
1343              return LFS_ERR_INVAL;
1344          }
1345          file->pos = file->pos + off;
1346      } else if (whence == LFS_SEEK_END) {
1347          if (off < 0 && (lfs_off_t)-off > file->size) {
1348              return LFS_ERR_INVAL;
1349          }
1350          file->pos = file->size + off;
1351      }
1352      return file->pos;
1353  }
1354  int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
1355      if ((file->flags & 3) == LFS_O_RDONLY) {
1356          return LFS_ERR_BADF;
1357      }
1358      lfs_off_t oldsize = lfs_file_size(lfs, file);
1359      if (size < oldsize) {
1360          int err = lfs_file_flush(lfs, file);
1361          if (err) {
1362              return err;
1363          }
1364          err = lfs_ctz_find(lfs, &file->cache, NULL,
1365                  file->head, file->size,
1366                  size, &file->head, &(lfs_off_t){0});
1367          if (err) {
1368              return err;
1369          }
1370          file->size = size;
1371          file->flags |= LFS_F_DIRTY;
1372      } else if (size > oldsize) {
1373          lfs_off_t pos = file->pos;
1374          if (file->pos != oldsize) {
1375              int err = lfs_file_seek(lfs, file, 0, LFS_SEEK_END);
1376              if (err < 0) {
1377                  return err;
1378              }
1379          }
1380          while (file->pos < size) {
1381              lfs_ssize_t res = lfs_file_write(lfs, file, &(uint8_t){0}, 1);
1382              if (res < 0) {
1383                  return res;
1384              }
1385          }
1386          int err = lfs_file_seek(lfs, file, pos, LFS_SEEK_SET);
1387          if (err < 0) {
1388              return err;
1389          }
1390      }
1391      return 0;
1392  }
1393  lfs_soff_t lfs_file_tell(lfs_t *lfs, lfs_file_t *file) {
1394      (void)lfs;
1395      return file->pos;
1396  }
1397  int lfs_file_rewind(lfs_t *lfs, lfs_file_t *file) {
1398      lfs_soff_t res = lfs_file_seek(lfs, file, 0, LFS_SEEK_SET);
1399      if (res < 0) {
1400          return res;
1401      }
1402      return 0;
1403  }
1404  lfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file) {
1405      (void)lfs;
1406      if (file->flags & LFS_F_WRITING) {
1407          return lfs_max(file->pos, file->size);
1408      } else {
1409          return file->size;
1410      }
1411  }
1412  int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {
1413      lfs_dir_t cwd;
1414      lfs_entry_t entry;
1415      int err = lfs_dir_find(lfs, &cwd, &entry, &path);
1416      if (err) {
1417          return err;
1418      }
1419      memset(info, 0, sizeof(*info));
1420      info->type = entry.d.type;
1421      if (info->type == LFS_TYPE_REG) {
1422          info->size = entry.d.u.file.size;
1423      }
1424      if (lfs_paircmp(entry.d.u.dir, lfs->root) == 0) {
1425          strcpy(info->name, "/");
1426      } else {
1427          err = lfs_bd_read(lfs, cwd.pair[0],
1428                  entry.off + 4+entry.d.elen+entry.d.alen,
1429                  info->name, entry.d.nlen);
1430          if (err) {
1431              return err;
1432          }
1433      }
1434      return 0;
1435  }
1436  int lfs_remove(lfs_t *lfs, const char *path) {
1437      if (!lfs->deorphaned) {
1438          int err = lfs_deorphan(lfs);
1439          if (err) {
1440              return err;
1441          }
1442      }
1443      lfs_dir_t cwd;
1444      lfs_entry_t entry;
1445      int err = lfs_dir_find(lfs, &cwd, &entry, &path);
1446      if (err) {
1447          return err;
1448      }
1449      lfs_dir_t dir;
1450      if (entry.d.type == LFS_TYPE_DIR) {
1451          err = lfs_dir_fetch(lfs, &dir, entry.d.u.dir);
1452          if (err) {
1453              return err;
1454          } &bsol;* else if (dir.d.size != sizeof(dir.d)+4) {
1455              return LFS_ERR_NOTEMPTY;
1456          }  adafruit: allow to remove non-empty folder,
1457             According to below issue, comment these 2 line won't corrupt filesystem
1458             https:&bsol;&bsol;github.com/ARMmbed/littlefs/issues/43 */
1459      }
1460      err = lfs_dir_remove(lfs, &cwd, &entry);
1461      if (err) {
1462          return err;
1463      }
1464      if (entry.d.type == LFS_TYPE_DIR) {
1465          int res = lfs_pred(lfs, dir.pair, &cwd);
1466          if (res < 0) {
1467              return res;
1468          }
1469          LFS_ASSERT(res); 
1470          cwd.d.tail[0] = dir.d.tail[0];
1471          cwd.d.tail[1] = dir.d.tail[1];
1472          err = lfs_dir_commit(lfs, &cwd, NULL, 0);
1473          if (err) {
1474              return err;
1475          }
1476      }
1477      return 0;
1478  }
1479  int lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath) {
1480      if (!lfs->deorphaned) {
1481          int err = lfs_deorphan(lfs);
1482          if (err) {
1483              return err;
1484          }
1485      }
1486      lfs_dir_t oldcwd;
1487      lfs_entry_t oldentry;
1488      int err = lfs_dir_find(lfs, &oldcwd, &oldentry, &oldpath);
1489      if (err) {
1490          return err;
1491      }
1492      lfs_dir_t newcwd;
1493      lfs_entry_t preventry;
1494      err = lfs_dir_find(lfs, &newcwd, &preventry, &newpath);
1495      if (err && (err != LFS_ERR_NOENT || strchr(newpath, '/') != NULL)) {
1496          return err;
1497      }
1498      bool prevexists = (err != LFS_ERR_NOENT);
1499      bool samepair = (lfs_paircmp(oldcwd.pair, newcwd.pair) == 0);
1500      if (prevexists && preventry.d.type != oldentry.d.type) {
1501          return LFS_ERR_ISDIR;
1502      }
1503      lfs_dir_t dir;
1504      if (prevexists && preventry.d.type == LFS_TYPE_DIR) {
1505          err = lfs_dir_fetch(lfs, &dir, preventry.d.u.dir);
1506          if (err) {
1507              return err;
1508          } else if (dir.d.size != sizeof(dir.d)+4) {
1509              return LFS_ERR_NOTEMPTY;
1510          }
1511      }
1512      oldentry.d.type |= 0x80;
1513      err = lfs_dir_update(lfs, &oldcwd, &oldentry, NULL);
1514      if (err) {
1515          return err;
1516      }
1517      if (samepair) {
1518          newcwd = oldcwd;
1519      }
1520      lfs_entry_t newentry = preventry;
1521      newentry.d = oldentry.d;
1522      newentry.d.type &= ~0x80;
1523      newentry.d.nlen = strlen(newpath);
1524      if (prevexists) {
1525          err = lfs_dir_update(lfs, &newcwd, &newentry, newpath);
1526          if (err) {
1527              return err;
1528          }
1529      } else {
1530          err = lfs_dir_append(lfs, &newcwd, &newentry, newpath);
1531          if (err) {
1532              return err;
1533          }
1534      }
1535      if (samepair) {
1536          oldcwd = newcwd;
1537      }
1538      err = lfs_dir_remove(lfs, &oldcwd, &oldentry);
1539      if (err) {
1540          return err;
1541      }
1542      if (prevexists && preventry.d.type == LFS_TYPE_DIR) {
1543          int res = lfs_pred(lfs, dir.pair, &newcwd);
1544          if (res < 0) {
1545              return res;
1546          }
1547          LFS_ASSERT(res); 
1548          newcwd.d.tail[0] = dir.d.tail[0];
1549          newcwd.d.tail[1] = dir.d.tail[1];
1550          err = lfs_dir_commit(lfs, &newcwd, NULL, 0);
1551          if (err) {
1552              return err;
1553          }
1554      }
1555      return 0;
1556  }
1557  static void lfs_deinit(lfs_t *lfs) {
1558      if (!lfs->cfg->read_buffer) {
1559          lfs_free(lfs->rcache.buffer);
1560      }
1561      if (!lfs->cfg->prog_buffer) {
1562          lfs_free(lfs->pcache.buffer);
1563      }
1564      if (!lfs->cfg->lookahead_buffer) {
1565          lfs_free(lfs->free.buffer);
1566      }
1567  }
1568  static int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {
1569      lfs->cfg = cfg;
1570      if (lfs->cfg->read_buffer) {
1571          lfs->rcache.buffer = lfs->cfg->read_buffer;
1572      } else {
1573          lfs->rcache.buffer = lfs_malloc(lfs->cfg->read_size);
1574          if (!lfs->rcache.buffer) {
1575              goto cleanup;
1576          }
1577      }
1578      if (lfs->cfg->prog_buffer) {
1579          lfs->pcache.buffer = lfs->cfg->prog_buffer;
1580      } else {
1581          lfs->pcache.buffer = lfs_malloc(lfs->cfg->prog_size);
1582          if (!lfs->pcache.buffer) {
1583              goto cleanup;
1584          }
1585      }
1586      lfs_cache_zero(lfs, &lfs->pcache);
1587      lfs_cache_drop(lfs, &lfs->rcache);
1588      LFS_ASSERT(lfs->cfg->lookahead % 32 == 0);
1589      LFS_ASSERT(lfs->cfg->lookahead > 0);
1590      if (lfs->cfg->lookahead_buffer) {
1591          lfs->free.buffer = lfs->cfg->lookahead_buffer;
1592      } else {
1593          lfs->free.buffer = lfs_malloc(lfs->cfg->lookahead/8);
1594          if (!lfs->free.buffer) {
1595              goto cleanup;
1596          }
1597      }
1598      LFS_ASSERT(lfs->cfg->prog_size % lfs->cfg->read_size == 0);
1599      LFS_ASSERT(lfs->cfg->block_size % lfs->cfg->prog_size == 0);
1600      LFS_ASSERT(4*lfs_npw2(0xffffffff / (lfs->cfg->block_size-2*4))
1601              <= lfs->cfg->block_size);
1602      lfs->root[0] = 0xffffffff;
1603      lfs->root[1] = 0xffffffff;
1604      lfs->files = NULL;
1605      lfs->dirs = NULL;
1606      lfs->deorphaned = false;
1607      return 0;
1608  cleanup:
1609      lfs_deinit(lfs);
1610      return LFS_ERR_NOMEM;
1611  }
1612  int lfs_format(lfs_t *lfs, const struct lfs_config *cfg) {
1613      int err = 0;
1614      if (true) {
1615          err = lfs_init(lfs, cfg);
1616          if (err) {
1617              return err;
1618          }
1619          memset(lfs->free.buffer, 0, lfs->cfg->lookahead/8);
1620          lfs->free.off = 0;
1621          lfs->free.size = lfs_min(lfs->cfg->lookahead, lfs->cfg->block_count);
1622          lfs->free.i = 0;
1623          lfs_alloc_ack(lfs);
1624          lfs_dir_t superdir;
1625          err = lfs_dir_alloc(lfs, &superdir);
1626          if (err) {
1627              goto cleanup;
1628          }
1629          lfs_dir_t root;
1630          err = lfs_dir_alloc(lfs, &root);
1631          if (err) {
1632              goto cleanup;
1633          }
1634          err = lfs_dir_commit(lfs, &root, NULL, 0);
1635          if (err) {
1636              goto cleanup;
1637          }
1638          lfs->root[0] = root.pair[0];
1639          lfs->root[1] = root.pair[1];
1640          lfs_superblock_t superblock = {
1641              .off = sizeof(superdir.d),
1642              .d.type = LFS_TYPE_SUPERBLOCK,
1643              .d.elen = sizeof(superblock.d) - sizeof(superblock.d.magic) - 4,
1644              .d.nlen = sizeof(superblock.d.magic),
1645              .d.version = LFS_DISK_VERSION,
1646              .d.magic = {"littlefs"},
1647              .d.block_size  = lfs->cfg->block_size,
1648              .d.block_count = lfs->cfg->block_count,
1649              .d.root = {lfs->root[0], lfs->root[1]},
1650          };
1651          superdir.d.tail[0] = root.pair[0];
1652          superdir.d.tail[1] = root.pair[1];
1653          superdir.d.size = sizeof(superdir.d) + sizeof(superblock.d) + 4;
1654          lfs_superblock_tole32(&superblock.d);
1655          bool valid = false;
1656          for (int i = 0; i < 2; i++) {
1657              err = lfs_dir_commit(lfs, &superdir, (struct lfs_region[]){
1658                      {sizeof(superdir.d), sizeof(superblock.d),
1659                       &superblock.d, sizeof(superblock.d)}
1660                  }, 1);
1661              if (err && err != LFS_ERR_CORRUPT) {
1662                  goto cleanup;
1663              }
1664              valid = valid || !err;
1665          }
1666          if (!valid) {
1667              err = LFS_ERR_CORRUPT;
1668              goto cleanup;
1669          }
1670          err = lfs_dir_fetch(lfs, &superdir, (const lfs_block_t[2]){0, 1});
1671          if (err) {
1672              goto cleanup;
1673          }
1674          lfs_alloc_ack(lfs);
1675      }
1676  cleanup:
1677      lfs_deinit(lfs);
1678      return err;
1679  }
1680  int lfs_mount(lfs_t *lfs, const struct lfs_config *cfg) {
1681      int err = 0;
1682      if (true) {
1683          err = lfs_init(lfs, cfg);
1684          if (err) {
1685              return err;
1686          }
1687          lfs->free.off = 0;
1688          lfs->free.size = 0;
1689          lfs->free.i = 0;
1690          lfs_alloc_ack(lfs);
1691          lfs_dir_t dir;
1692          lfs_superblock_t superblock;
1693          err = lfs_dir_fetch(lfs, &dir, (const lfs_block_t[2]){0, 1});
1694          if (err && err != LFS_ERR_CORRUPT) {
1695              goto cleanup;
1696          }
1697          if (!err) {
1698              err = lfs_bd_read(lfs, dir.pair[0], sizeof(dir.d),
1699                      &superblock.d, sizeof(superblock.d));
1700              lfs_superblock_fromle32(&superblock.d);
1701              if (err) {
1702                  goto cleanup;
1703              }
1704              lfs->root[0] = superblock.d.root[0];
1705              lfs->root[1] = superblock.d.root[1];
1706          }
1707          if (err || memcmp(superblock.d.magic, "littlefs", 8) != 0) {
1708              LFS_ERROR("Invalid superblock at %d %d", 0, 1);
1709              err = LFS_ERR_CORRUPT;
1710              goto cleanup;
1711          }
1712          uint16_t major_version = (0xffff & (superblock.d.version >> 16));
1713          uint16_t minor_version = (0xffff & (superblock.d.version >>  0));
1714          if ((major_version != LFS_DISK_VERSION_MAJOR ||
1715               minor_version > LFS_DISK_VERSION_MINOR)) {
1716              LFS_ERROR("Invalid version %d.%d", major_version, minor_version);
1717              err = LFS_ERR_INVAL;
1718              goto cleanup;
1719          }
1720          return 0;
1721      }
1722  cleanup:
1723      lfs_deinit(lfs);
1724      return err;
1725  }
1726  int lfs_unmount(lfs_t *lfs) {
1727      lfs_deinit(lfs);
1728      return 0;
1729  }
1730  int lfs_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data) {
1731      if (lfs_pairisnull(lfs->root)) {
1732          return 0;
1733      }
1734      lfs_dir_t dir;
1735      lfs_entry_t entry;
1736      lfs_block_t cwd[2] = {0, 1};
1737      while (true) {
1738          for (int i = 0; i < 2; i++) {
1739              int err = cb(data, cwd[i]);
1740              if (err) {
1741                  return err;
1742              }
1743          }
1744          int err = lfs_dir_fetch(lfs, &dir, cwd);
1745          if (err) {
1746              return err;
1747          }
1748          while (dir.off + sizeof(entry.d) <= (0x7fffffff & dir.d.size)-4) {
1749              err = lfs_bd_read(lfs, dir.pair[0], dir.off,
1750                      &entry.d, sizeof(entry.d));
1751              lfs_entry_fromle32(&entry.d);
1752              if (err) {
1753                  return err;
1754              }
1755              dir.off += lfs_entry_size(&entry);
1756              if ((0x70 & entry.d.type) == (0x70 & LFS_TYPE_REG)) {
1757                  err = lfs_ctz_traverse(lfs, &lfs->rcache, NULL,
1758                          entry.d.u.file.head, entry.d.u.file.size, cb, data);
1759                  if (err) {
1760                      return err;
1761                  }
1762              }
1763          }
1764          cwd[0] = dir.d.tail[0];
1765          cwd[1] = dir.d.tail[1];
1766          if (lfs_pairisnull(cwd)) {
1767              break;
1768          }
1769      }
1770      for (lfs_file_t *f = lfs->files; f; f = f->next) {
1771          if (f->flags & LFS_F_DIRTY) {
1772              int err = lfs_ctz_traverse(lfs, &lfs->rcache, &f->cache,
1773                      f->head, f->size, cb, data);
1774              if (err) {
1775                  return err;
1776              }
1777          }
1778          if (f->flags & LFS_F_WRITING) {
1779              int err = lfs_ctz_traverse(lfs, &lfs->rcache, &f->cache,
1780                      f->block, f->pos, cb, data);
1781              if (err) {
1782                  return err;
1783              }
1784          }
1785      }
1786      return 0;
1787  }
1788  static int lfs_pred(lfs_t *lfs, const lfs_block_t dir[2], lfs_dir_t *pdir) {
1789      if (lfs_pairisnull(lfs->root)) {
1790          return 0;
1791      }
1792      int err = lfs_dir_fetch(lfs, pdir, (const lfs_block_t[2]){0, 1});
1793      if (err) {
1794          return err;
1795      }
1796      while (!lfs_pairisnull(pdir->d.tail)) {
1797          if (lfs_paircmp(pdir->d.tail, dir) == 0) {
1798              return true;
1799          }
1800          err = lfs_dir_fetch(lfs, pdir, pdir->d.tail);
1801          if (err) {
1802              return err;
1803          }
1804      }
1805      return false;
1806  }
1807  static int lfs_parent(lfs_t *lfs, const lfs_block_t dir[2],
1808          lfs_dir_t *parent, lfs_entry_t *entry) {
1809      if (lfs_pairisnull(lfs->root)) {
1810          return 0;
1811      }
1812      parent->d.tail[0] = 0;
1813      parent->d.tail[1] = 1;
1814      while (!lfs_pairisnull(parent->d.tail)) {
1815          int err = lfs_dir_fetch(lfs, parent, parent->d.tail);
1816          if (err) {
1817              return err;
1818          }
1819          while (true) {
1820              err = lfs_dir_next(lfs, parent, entry);
1821              if (err && err != LFS_ERR_NOENT) {
1822                  return err;
1823              }
1824              if (err == LFS_ERR_NOENT) {
1825                  break;
1826              }
1827              if (((0x70 & entry->d.type) == (0x70 & LFS_TYPE_DIR)) &&
1828                   lfs_paircmp(entry->d.u.dir, dir) == 0) {
1829                  return true;
1830              }
1831          }
1832      }
1833      return false;
1834  }
1835  static int lfs_moved(lfs_t *lfs, const void *e) {
1836      if (lfs_pairisnull(lfs->root)) {
1837          return 0;
1838      }
1839      lfs_dir_t cwd;
1840      int err = lfs_dir_fetch(lfs, &cwd, (const lfs_block_t[2]){0, 1});
1841      if (err) {
1842          return err;
1843      }
1844      lfs_entry_t entry;
1845      while (!lfs_pairisnull(cwd.d.tail)) {
1846          err = lfs_dir_fetch(lfs, &cwd, cwd.d.tail);
1847          if (err) {
1848              return err;
1849          }
1850          while (true) {
1851              err = lfs_dir_next(lfs, &cwd, &entry);
1852              if (err && err != LFS_ERR_NOENT) {
1853                  return err;
1854              }
1855              if (err == LFS_ERR_NOENT) {
1856                  break;
1857              }
1858              if (!(0x80 & entry.d.type) &&
1859                   memcmp(&entry.d.u, e, sizeof(entry.d.u)) == 0) {
1860                  return true;
1861              }
1862          }
1863      }
1864      return false;
1865  }
1866  static int lfs_relocate(lfs_t *lfs,
1867          const lfs_block_t oldpair[2], const lfs_block_t newpair[2]) {
1868      lfs_dir_t parent;
1869      lfs_entry_t entry;
1870      int res = lfs_parent(lfs, oldpair, &parent, &entry);
1871      if (res < 0) {
1872          return res;
1873      }
1874      if (res) {
1875          entry.d.u.dir[0] = newpair[0];
1876          entry.d.u.dir[1] = newpair[1];
1877          int err = lfs_dir_update(lfs, &parent, &entry, NULL);
1878          if (err) {
1879              return err;
1880          }
1881          if (lfs_paircmp(oldpair, lfs->root) == 0) {
1882              LFS_DEBUG("Relocating root %" PRIu32 " %" PRIu32,
1883                      newpair[0], newpair[1]);
1884              lfs->root[0] = newpair[0];
1885              lfs->root[1] = newpair[1];
1886          }
1887          return lfs_deorphan(lfs);
1888      }
1889      res = lfs_pred(lfs, oldpair, &parent);
1890      if (res < 0) {
1891          return res;
1892      }
1893      if (res) {
1894          parent.d.tail[0] = newpair[0];
1895          parent.d.tail[1] = newpair[1];
1896          return lfs_dir_commit(lfs, &parent, NULL, 0);
1897      }
1898      return 0;
1899  }
1900  int lfs_deorphan(lfs_t *lfs) {
1901      lfs->deorphaned = true;
1902      if (lfs_pairisnull(lfs->root)) {
1903          return 0;
1904      }
1905      lfs_dir_t pdir = {.d.size = 0x80000000};
1906      lfs_dir_t cwd = {.d.tail[0] = 0, .d.tail[1] = 1};
1907      for (lfs_size_t i = 0; i < lfs->cfg->block_count; i++) {
1908          if (lfs_pairisnull(cwd.d.tail)) {
1909              return 0;
1910          }
1911          int err = lfs_dir_fetch(lfs, &cwd, cwd.d.tail);
1912          if (err) {
1913              return err;
1914          }
1915          if (!(0x80000000 & pdir.d.size)) {
1916              lfs_dir_t parent;
1917              lfs_entry_t entry;
1918              int res = lfs_parent(lfs, pdir.d.tail, &parent, &entry);
1919              if (res < 0) {
1920                  return res;
1921              }
1922              if (!res) {
1923                  LFS_DEBUG("Found orphan %" PRIu32 " %" PRIu32,
1924                          pdir.d.tail[0], pdir.d.tail[1]);
1925                  pdir.d.tail[0] = cwd.d.tail[0];
1926                  pdir.d.tail[1] = cwd.d.tail[1];
1927                  err = lfs_dir_commit(lfs, &pdir, NULL, 0);
1928                  if (err) {
1929                      return err;
1930                  }
1931                  return 0;
1932              }
1933              if (!lfs_pairsync(entry.d.u.dir, pdir.d.tail)) {
1934                  LFS_DEBUG("Found desync %" PRIu32 " %" PRIu32,
1935                          entry.d.u.dir[0], entry.d.u.dir[1]);
1936                  pdir.d.tail[0] = entry.d.u.dir[0];
1937                  pdir.d.tail[1] = entry.d.u.dir[1];
1938                  err = lfs_dir_commit(lfs, &pdir, NULL, 0);
1939                  if (err) {
1940                      return err;
1941                  }
1942                  return 0;
1943              }
1944          }
1945          lfs_entry_t entry;
1946          while (true) {
1947              err = lfs_dir_next(lfs, &cwd, &entry);
1948              if (err && err != LFS_ERR_NOENT) {
1949                  return err;
1950              }
1951              if (err == LFS_ERR_NOENT) {
1952                  break;
1953              }
1954              if (entry.d.type & 0x80) {
1955                  int moved = lfs_moved(lfs, &entry.d.u);
1956                  if (moved < 0) {
1957                      return moved;
1958                  }
1959                  if (moved) {
1960                      LFS_DEBUG("Found move %" PRIu32 " %" PRIu32,
1961                              entry.d.u.dir[0], entry.d.u.dir[1]);
1962                      err = lfs_dir_remove(lfs, &cwd, &entry);
1963                      if (err) {
1964                          return err;
1965                      }
1966                  } else {
1967                      LFS_DEBUG("Found partial move %" PRIu32 " %" PRIu32,
1968                              entry.d.u.dir[0], entry.d.u.dir[1]);
1969                      entry.d.type &= ~0x80;
1970                      err = lfs_dir_update(lfs, &cwd, &entry, NULL);
1971                      if (err) {
1972                          return err;
1973                      }
1974                  }
1975              }
1976          }
1977          memcpy(&pdir, &cwd, sizeof(pdir));
1978      }
1979      return LFS_ERR_CORRUPT;
1980  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-server.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/Win32_FDAPI.h"
4  #include "Win32_Interop/Win32_ThreadControl.h"
5  #include "Win32_Interop/Win32_QFork.h"
6  #include "Win32_Interop/Win32_Error.h"
7  #endif
8  #include "server.h"
9  #include "cluster.h"
10  #include "slowlog.h"
11  #include "bio.h"
12  #include "latency.h"
13  #include "atomicvar.h"
14  #include <time.h>
15  #include <signal.h>
16  POSIX_ONLY(#include <sys/wait.h>)
17  #include <errno.h>
18  #include <assert.h>
19  #include <ctype.h>
20  #include <stdarg.h>
21  POSIX_ONLY(#include <arpa/inet.h>)
22  #include <sys/stat.h>
23  #include <fcntl.h>
24  POSIX_ONLY(#include <sys/time.h>)
25  POSIX_ONLY(#include <sys/resource.h>)
26  POSIX_ONLY(#include <sys/uio.h>)
27  POSIX_ONLY(#include <sys/un.h>)
28  #include <limits.h>
29  #include <float.h>
30  #include <math.h>
31  POSIX_ONLY(#include <sys/resource.h>)
32  POSIX_ONLY(#include <sys/utsname.h>)
33  #include <locale.h>
34  POSIX_ONLY(#include <sys/socket.h>)
35  struct sharedObjectsStruct shared;
36  double R_Zero, R_PosInf, R_NegInf, R_Nan;
37  struct redisServer server; &bsol;* Server global state */
38  volatile PORT_ULONG lru_clock; &bsol;* Server global current LRU time. */
39  struct redisCommand redisCommandTable[] = {
40      {"module",moduleCommand,-2,"as",0,NULL,0,0,0,0,0},
41      {"get",getCommand,2,"rF",0,NULL,1,1,1,0,0},
42      {"set",setCommand,-3,"wm",0,NULL,1,1,1,0,0},
43      {"setnx",setnxCommand,3,"wmF",0,NULL,1,1,1,0,0},
44      {"setex",setexCommand,4,"wm",0,NULL,1,1,1,0,0},
45      {"psetex",psetexCommand,4,"wm",0,NULL,1,1,1,0,0},
46      {"append",appendCommand,3,"wm",0,NULL,1,1,1,0,0},
47      {"strlen",strlenCommand,2,"rF",0,NULL,1,1,1,0,0},
48      {"del",delCommand,-2,"w",0,NULL,1,-1,1,0,0},
49      {"unlink",unlinkCommand,-2,"wF",0,NULL,1,-1,1,0,0},
50      {"exists",existsCommand,-2,"rF",0,NULL,1,-1,1,0,0},
51      {"setbit",setbitCommand,4,"wm",0,NULL,1,1,1,0,0},
52      {"getbit",getbitCommand,3,"rF",0,NULL,1,1,1,0,0},
53      {"bitfield",bitfieldCommand,-2,"wm",0,NULL,1,1,1,0,0},
54      {"setrange",setrangeCommand,4,"wm",0,NULL,1,1,1,0,0},
55      {"getrange",getrangeCommand,4,"r",0,NULL,1,1,1,0,0},
56      {"substr",getrangeCommand,4,"r",0,NULL,1,1,1,0,0},
57      {"incr",incrCommand,2,"wmF",0,NULL,1,1,1,0,0},
58      {"decr",decrCommand,2,"wmF",0,NULL,1,1,1,0,0},
59      {"mget",mgetCommand,-2,"rF",0,NULL,1,-1,1,0,0},
60      {"rpush",rpushCommand,-3,"wmF",0,NULL,1,1,1,0,0},
61      {"lpush",lpushCommand,-3,"wmF",0,NULL,1,1,1,0,0},
62      {"rpushx",rpushxCommand,-3,"wmF",0,NULL,1,1,1,0,0},
63      {"lpushx",lpushxCommand,-3,"wmF",0,NULL,1,1,1,0,0},
64      {"linsert",linsertCommand,5,"wm",0,NULL,1,1,1,0,0},
65      {"rpop",rpopCommand,2,"wF",0,NULL,1,1,1,0,0},
66      {"lpop",lpopCommand,2,"wF",0,NULL,1,1,1,0,0},
67      {"brpop",brpopCommand,-3,"ws",0,NULL,1,-2,1,0,0},
68      {"brpoplpush",brpoplpushCommand,4,"wms",0,NULL,1,2,1,0,0},
69      {"blpop",blpopCommand,-3,"ws",0,NULL,1,-2,1,0,0},
70      {"llen",llenCommand,2,"rF",0,NULL,1,1,1,0,0},
71      {"lindex",lindexCommand,3,"r",0,NULL,1,1,1,0,0},
72      {"lset",lsetCommand,4,"wm",0,NULL,1,1,1,0,0},
73      {"lrange",lrangeCommand,4,"r",0,NULL,1,1,1,0,0},
74      {"ltrim",ltrimCommand,4,"w",0,NULL,1,1,1,0,0},
75      {"lrem",lremCommand,4,"w",0,NULL,1,1,1,0,0},
76      {"rpoplpush",rpoplpushCommand,3,"wm",0,NULL,1,2,1,0,0},
77      {"sadd",saddCommand,-3,"wmF",0,NULL,1,1,1,0,0},
78      {"srem",sremCommand,-3,"wF",0,NULL,1,1,1,0,0},
79      {"smove",smoveCommand,4,"wF",0,NULL,1,2,1,0,0},
80      {"sismember",sismemberCommand,3,"rF",0,NULL,1,1,1,0,0},
81      {"scard",scardCommand,2,"rF",0,NULL,1,1,1,0,0},
82      {"spop",spopCommand,-2,"wRF",0,NULL,1,1,1,0,0},
83      {"srandmember",srandmemberCommand,-2,"rR",0,NULL,1,1,1,0,0},
84      {"sinter",sinterCommand,-2,"rS",0,NULL,1,-1,1,0,0},
85      {"sinterstore",sinterstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
86      {"sunion",sunionCommand,-2,"rS",0,NULL,1,-1,1,0,0},
87      {"sunionstore",sunionstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
88      {"sdiff",sdiffCommand,-2,"rS",0,NULL,1,-1,1,0,0},
89      {"sdiffstore",sdiffstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
90      {"smembers",sinterCommand,2,"rS",0,NULL,1,1,1,0,0},
91      {"sscan",sscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
92      {"zadd",zaddCommand,-4,"wmF",0,NULL,1,1,1,0,0},
93      {"zincrby",zincrbyCommand,4,"wmF",0,NULL,1,1,1,0,0},
94      {"zrem",zremCommand,-3,"wF",0,NULL,1,1,1,0,0},
95      {"zremrangebyscore",zremrangebyscoreCommand,4,"w",0,NULL,1,1,1,0,0},
96      {"zremrangebyrank",zremrangebyrankCommand,4,"w",0,NULL,1,1,1,0,0},
97      {"zremrangebylex",zremrangebylexCommand,4,"w",0,NULL,1,1,1,0,0},
98      {"zunionstore",zunionstoreCommand,-4,"wm",0,zunionInterGetKeys,0,0,0,0,0},
99      {"zinterstore",zinterstoreCommand,-4,"wm",0,zunionInterGetKeys,0,0,0,0,0},
100      {"zrange",zrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
101      {"zrangebyscore",zrangebyscoreCommand,-4,"r",0,NULL,1,1,1,0,0},
102      {"zrevrangebyscore",zrevrangebyscoreCommand,-4,"r",0,NULL,1,1,1,0,0},
103      {"zrangebylex",zrangebylexCommand,-4,"r",0,NULL,1,1,1,0,0},
104      {"zrevrangebylex",zrevrangebylexCommand,-4,"r",0,NULL,1,1,1,0,0},
105      {"zcount",zcountCommand,4,"rF",0,NULL,1,1,1,0,0},
106      {"zlexcount",zlexcountCommand,4,"rF",0,NULL,1,1,1,0,0},
107      {"zrevrange",zrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
108      {"zcard",zcardCommand,2,"rF",0,NULL,1,1,1,0,0},
109      {"zscore",zscoreCommand,3,"rF",0,NULL,1,1,1,0,0},
110      {"zrank",zrankCommand,3,"rF",0,NULL,1,1,1,0,0},
111      {"zrevrank",zrevrankCommand,3,"rF",0,NULL,1,1,1,0,0},
112      {"zscan",zscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
113      {"zpopmin",zpopminCommand,-2,"wF",0,NULL,1,1,1,0,0},
114      {"zpopmax",zpopmaxCommand,-2,"wF",0,NULL,1,1,1,0,0},
115      {"bzpopmin",bzpopminCommand,-3,"wsF",0,NULL,1,-2,1,0,0},
116      {"bzpopmax",bzpopmaxCommand,-3,"wsF",0,NULL,1,-2,1,0,0},
117      {"hset",hsetCommand,-4,"wmF",0,NULL,1,1,1,0,0},
118      {"hsetnx",hsetnxCommand,4,"wmF",0,NULL,1,1,1,0,0},
119      {"hget",hgetCommand,3,"rF",0,NULL,1,1,1,0,0},
120      {"hmset",hsetCommand,-4,"wmF",0,NULL,1,1,1,0,0},
121      {"hmget",hmgetCommand,-3,"rF",0,NULL,1,1,1,0,0},
122      {"hincrby",hincrbyCommand,4,"wmF",0,NULL,1,1,1,0,0},
123      {"hincrbyfloat",hincrbyfloatCommand,4,"wmF",0,NULL,1,1,1,0,0},
124      {"hdel",hdelCommand,-3,"wF",0,NULL,1,1,1,0,0},
125      {"hlen",hlenCommand,2,"rF",0,NULL,1,1,1,0,0},
126      {"hstrlen",hstrlenCommand,3,"rF",0,NULL,1,1,1,0,0},
127      {"hkeys",hkeysCommand,2,"rS",0,NULL,1,1,1,0,0},
128      {"hvals",hvalsCommand,2,"rS",0,NULL,1,1,1,0,0},
129      {"hgetall",hgetallCommand,2,"rR",0,NULL,1,1,1,0,0},
130      {"hexists",hexistsCommand,3,"rF",0,NULL,1,1,1,0,0},
131      {"hscan",hscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
132      {"incrby",incrbyCommand,3,"wmF",0,NULL,1,1,1,0,0},
133      {"decrby",decrbyCommand,3,"wmF",0,NULL,1,1,1,0,0},
134      {"incrbyfloat",incrbyfloatCommand,3,"wmF",0,NULL,1,1,1,0,0},
135      {"getset",getsetCommand,3,"wm",0,NULL,1,1,1,0,0},
136      {"mset",msetCommand,-3,"wm",0,NULL,1,-1,2,0,0},
137      {"msetnx",msetnxCommand,-3,"wm",0,NULL,1,-1,2,0,0},
138      {"randomkey",randomkeyCommand,1,"rR",0,NULL,0,0,0,0,0},
139      {"select",selectCommand,2,"lF",0,NULL,0,0,0,0,0},
140      {"swapdb",swapdbCommand,3,"wF",0,NULL,0,0,0,0,0},
141      {"move",moveCommand,3,"wF",0,NULL,1,1,1,0,0},
142      {"rename",renameCommand,3,"w",0,NULL,1,2,1,0,0},
143      {"renamenx",renamenxCommand,3,"wF",0,NULL,1,2,1,0,0},
144      {"expire",expireCommand,3,"wF",0,NULL,1,1,1,0,0},
145      {"expireat",expireatCommand,3,"wF",0,NULL,1,1,1,0,0},
146      {"pexpire",pexpireCommand,3,"wF",0,NULL,1,1,1,0,0},
147      {"pexpireat",pexpireatCommand,3,"wF",0,NULL,1,1,1,0,0},
148      {"keys",keysCommand,2,"rS",0,NULL,0,0,0,0,0},
149      {"scan",scanCommand,-2,"rR",0,NULL,0,0,0,0,0},
150      {"dbsize",dbsizeCommand,1,"rF",0,NULL,0,0,0,0,0},
151      {"auth",authCommand,2,"sltMF",0,NULL,0,0,0,0,0},
152      {"ping",pingCommand,-1,"tF",0,NULL,0,0,0,0,0},
153      {"echo",echoCommand,2,"F",0,NULL,0,0,0,0,0},
154      {"save",saveCommand,1,"as",0,NULL,0,0,0,0,0},
155      {"bgsave",bgsaveCommand,-1,"as",0,NULL,0,0,0,0,0},
156      {"bgrewriteaof",bgrewriteaofCommand,1,"as",0,NULL,0,0,0,0,0},
157      {"shutdown",shutdownCommand,-1,"aslt",0,NULL,0,0,0,0,0},
158      {"lastsave",lastsaveCommand,1,"RF",0,NULL,0,0,0,0,0},
159      {"type",typeCommand,2,"rF",0,NULL,1,1,1,0,0},
160      {"multi",multiCommand,1,"sF",0,NULL,0,0,0,0,0},
161      {"exec",execCommand,1,"sM",0,NULL,0,0,0,0,0},
162      {"discard",discardCommand,1,"sF",0,NULL,0,0,0,0,0},
163      {"sync",syncCommand,1,"ars",0,NULL,0,0,0,0,0},
164      {"psync",syncCommand,3,"ars",0,NULL,0,0,0,0,0},
165      {"replconf",replconfCommand,-1,"aslt",0,NULL,0,0,0,0,0},
166      {"flushdb",flushdbCommand,-1,"w",0,NULL,0,0,0,0,0},
167      {"flushall",flushallCommand,-1,"w",0,NULL,0,0,0,0,0},
168      {"sort",sortCommand,-2,"wm",0,sortGetKeys,1,1,1,0,0},
169      {"info",infoCommand,-1,"ltR",0,NULL,0,0,0,0,0},
170      {"monitor",monitorCommand,1,"as",0,NULL,0,0,0,0,0},
171      {"ttl",ttlCommand,2,"rFR",0,NULL,1,1,1,0,0},
172      {"touch",touchCommand,-2,"rF",0,NULL,1,1,1,0,0},
173      {"pttl",pttlCommand,2,"rFR",0,NULL,1,1,1,0,0},
174      {"persist",persistCommand,2,"wF",0,NULL,1,1,1,0,0},
175      {"slaveof",replicaofCommand,3,"ast",0,NULL,0,0,0,0,0},
176      {"replicaof",replicaofCommand,3,"ast",0,NULL,0,0,0,0,0},
177      {"role",roleCommand,1,"lst",0,NULL,0,0,0,0,0},
178      {"debug",debugCommand,-2,"as",0,NULL,0,0,0,0,0},
179      {"config",configCommand,-2,"last",0,NULL,0,0,0,0,0},
180      {"subscribe",subscribeCommand,-2,"pslt",0,NULL,0,0,0,0,0},
181      {"unsubscribe",unsubscribeCommand,-1,"pslt",0,NULL,0,0,0,0,0},
182      {"psubscribe",psubscribeCommand,-2,"pslt",0,NULL,0,0,0,0,0},
183      {"punsubscribe",punsubscribeCommand,-1,"pslt",0,NULL,0,0,0,0,0},
184      {"publish",publishCommand,3,"pltF",0,NULL,0,0,0,0,0},
185      {"pubsub",pubsubCommand,-2,"pltR",0,NULL,0,0,0,0,0},
186      {"watch",watchCommand,-2,"sF",0,NULL,1,-1,1,0,0},
187      {"unwatch",unwatchCommand,1,"sF",0,NULL,0,0,0,0,0},
188      {"cluster",clusterCommand,-2,"a",0,NULL,0,0,0,0,0},
189      {"restore",restoreCommand,-4,"wm",0,NULL,1,1,1,0,0},
190      {"restore-asking",restoreCommand,-4,"wmk",0,NULL,1,1,1,0,0},
191      {"migrate",migrateCommand,-6,"wR",0,migrateGetKeys,0,0,0,0,0},
192      {"asking",askingCommand,1,"F",0,NULL,0,0,0,0,0},
193      {"readonly",readonlyCommand,1,"F",0,NULL,0,0,0,0,0},
194      {"readwrite",readwriteCommand,1,"F",0,NULL,0,0,0,0,0},
195      {"dump",dumpCommand,2,"rR",0,NULL,1,1,1,0,0},
196      {"object",objectCommand,-2,"rR",0,NULL,2,2,1,0,0},
197      {"memory",memoryCommand,-2,"rR",0,NULL,0,0,0,0,0},
198      {"client",clientCommand,-2,"as",0,NULL,0,0,0,0,0},
199      {"eval",evalCommand,-3,"s",0,evalGetKeys,0,0,0,0,0},
200      {"evalsha",evalShaCommand,-3,"s",0,evalGetKeys,0,0,0,0,0},
201      {"slowlog",slowlogCommand,-2,"aR",0,NULL,0,0,0,0,0},
202      {"script",scriptCommand,-2,"s",0,NULL,0,0,0,0,0},
203      {"time",timeCommand,1,"RF",0,NULL,0,0,0,0,0},
204      {"bitop",bitopCommand,-4,"wm",0,NULL,2,-1,1,0,0},
205      {"bitcount",bitcountCommand,-2,"r",0,NULL,1,1,1,0,0},
206      {"bitpos",bitposCommand,-3,"r",0,NULL,1,1,1,0,0},
207      {"wait",waitCommand,3,"s",0,NULL,0,0,0,0,0},
208      {"command",commandCommand,0,"ltR",0,NULL,0,0,0,0,0},
209      {"geoadd",geoaddCommand,-5,"wm",0,NULL,1,1,1,0,0},
210      {"georadius",georadiusCommand,-6,"w",0,georadiusGetKeys,1,1,1,0,0},
211      {"georadius_ro",georadiusroCommand,-6,"r",0,georadiusGetKeys,1,1,1,0,0},
212      {"georadiusbymember",georadiusbymemberCommand,-5,"w",0,georadiusGetKeys,1,1,1,0,0},
213      {"georadiusbymember_ro",georadiusbymemberroCommand,-5,"r",0,georadiusGetKeys,1,1,1,0,0},
214      {"geohash",geohashCommand,-2,"r",0,NULL,1,1,1,0,0},
215      {"geopos",geoposCommand,-2,"r",0,NULL,1,1,1,0,0},
216      {"geodist",geodistCommand,-4,"r",0,NULL,1,1,1,0,0},
217      {"pfselftest",pfselftestCommand,1,"a",0,NULL,0,0,0,0,0},
218      {"pfadd",pfaddCommand,-2,"wmF",0,NULL,1,1,1,0,0},
219      {"pfcount",pfcountCommand,-2,"r",0,NULL,1,-1,1,0,0},
220      {"pfmerge",pfmergeCommand,-2,"wm",0,NULL,1,-1,1,0,0},
221      {"pfdebug",pfdebugCommand,-3,"w",0,NULL,0,0,0,0,0},
222      {"xadd",xaddCommand,-5,"wmFR",0,NULL,1,1,1,0,0},
223      {"xrange",xrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
224      {"xrevrange",xrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
225      {"xlen",xlenCommand,2,"rF",0,NULL,1,1,1,0,0},
226      {"xread",xreadCommand,-4,"rs",0,xreadGetKeys,1,1,1,0,0},
227      {"xreadgroup",xreadCommand,-7,"ws",0,xreadGetKeys,1,1,1,0,0},
228      {"xgroup",xgroupCommand,-2,"wm",0,NULL,2,2,1,0,0},
229      {"xsetid",xsetidCommand,3,"wmF",0,NULL,1,1,1,0,0},
230      {"xack",xackCommand,-4,"wF",0,NULL,1,1,1,0,0},
231      {"xpending",xpendingCommand,-3,"rR",0,NULL,1,1,1,0,0},
232      {"xclaim",xclaimCommand,-6,"wRF",0,NULL,1,1,1,0,0},
233      {"xinfo",xinfoCommand,-2,"rR",0,NULL,2,2,1,0,0},
234      {"xdel",xdelCommand,-3,"wF",0,NULL,1,1,1,0,0},
235      {"xtrim",xtrimCommand,-2,"wFR",0,NULL,1,1,1,0,0},
236      {"post",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
237      {"host:",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
238      {"latency",latencyCommand,-2,"aslt",0,NULL,0,0,0,0,0},
239      {"lolwut",lolwutCommand,-1,"r",0,NULL,0,0,0,0,0}
240  };
241  void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);
242  #ifndef _WIN32 
243  void serverLogRaw(int level, const char *msg) {
244      const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };
245      const char *c = ".-*#";
246      FILE *fp;
247      char buf[64];
248      int rawmode = (level & LL_RAW);
249      int log_to_stdout = server.logfile[0] == '\0';
250      level &= 0xff; &bsol;* clear flags */
251      if (level < server.verbosity) return;
252      fp = log_to_stdout ? stdout : fopen(server.logfile,"a");
253      if (!fp) return;
254      if (rawmode) {
255          fprintf(fp,"%s",msg);
256      } else {
257          int off;
258          struct timeval tv;
259          int role_char;
260          pid_t pid = getpid();
261          gettimeofday(&tv,NULL);
262          struct tm tm;
263          nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);
264          off = strftime(buf,sizeof(buf),"%d %b %Y %H:%M:%S.",&tm);
265          snprintf(buf+off,sizeof(buf)-off,"%03d",(int)tv.tv_usec/1000);
266          if (server.sentinel_mode) {
267              role_char = 'X'; &bsol;* Sentinel. */
268          } else if (pid != server.pid) {
269              role_char = 'C'; &bsol;* RDB / AOF writing child. */
270          } else {
271              role_char = (server.masterhost ? 'S':'M'); &bsol;* Slave or Master. */
272          }
273          fprintf(fp,"%d:%c %s %c %s\n",
274              (int)getpid(),role_char, buf,c[level],msg);
275      }
276      fflush(fp);
277      if (!log_to_stdout) fclose(fp);
278      if (server.syslog_enabled) syslog(syslogLevelMap[level], "%s", msg);
279  }
280  void serverLog(int level, const char *fmt, ...) {
281      va_list ap;
282      char msg[LOG_MAX_LEN];
283      if ((level&0xff) < server.verbosity) return;
284      va_start(ap, fmt);
285      vsnprintf(msg, sizeof(msg), fmt, ap);
286      va_end(ap);
287      serverLogRaw(level,msg);
288  }
289  void serverLogFromHandler(int level, const char *msg) {
290      int fd;
291      int log_to_stdout = server.logfile[0] == '\0';
292      char buf[64];
293      if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))
294          return;
295      fd = log_to_stdout ? STDOUT_FILENO :
296                           open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
297      if (fd == -1) return;
298      ll2string(buf,sizeof(buf),getpid());
299      if (write(fd,buf,strlen(buf)) == -1) goto err;
300      if (write(fd,":signal-handler (",17) == -1) goto err;
301      ll2string(buf,sizeof(buf),time(NULL));
302      if (write(fd,buf,strlen(buf)) == -1) goto err;
303      if (write(fd,") ",2) == -1) goto err;
304      if (write(fd,msg,strlen(msg)) == -1) goto err;
305      if (write(fd,"\n",1) == -1) goto err;
306  err:
307      if (!log_to_stdout) close(fd);
308  }
309  #endif
310  PORT_LONGLONG ustime(void) {
311      struct timeval tv;
312      PORT_LONGLONG ust;
313      gettimeofday(&tv, NULL);
314      ust = ((PORT_LONGLONG)tv.tv_sec)*1000000;
315      ust += tv.tv_usec;
316      return ust;
317  }
318  PORT_LONGLONG mstime(void) {
319      return ustime()/1000;
320  }
321  void exitFromChild(int retcode) {
322  #ifdef COVERAGE_TEST
323      exit(retcode);
324  #else
325      _exit(retcode);
326  #endif
327  }
328  void dictVanillaFree(void *privdata, void *val)
329  {
330      DICT_NOTUSED(privdata);
331      zfree(val);
332  }
333  void dictListDestructor(void *privdata, void *val)
334  {
335      DICT_NOTUSED(privdata);
336      listRelease((list*)val);
337  }
338  int dictSdsKeyCompare(void *privdata, const void *key1,
339          const void *key2)
340  {
341      int l1,l2;
342      DICT_NOTUSED(privdata);
343      l1 = (int)sdslen((sds)key1);                                                WIN_PORT_FIX &bsol;* cast (int) */
344      l2 = (int)sdslen((sds)key2);                                                WIN_PORT_FIX &bsol;* cast (int) */
345      if (l1 != l2) return 0;
346      return memcmp(key1, key2, l1) == 0;
347  }
348  int dictSdsKeyCaseCompare(void *privdata, const void *key1,
349          const void *key2)
350  {
351      DICT_NOTUSED(privdata);
352      return strcasecmp(key1, key2) == 0;
353  }
354  void dictObjectDestructor(void *privdata, void *val)
355  {
356      DICT_NOTUSED(privdata);
357      if (val == NULL) return; &bsol;* Lazy freeing will set value to NULL. */
358      decrRefCount(val);
359  }
360  void dictSdsDestructor(void *privdata, void *val)
361  {
362      DICT_NOTUSED(privdata);
363      sdsfree(val);
364  }
365  int dictObjKeyCompare(void *privdata, const void *key1,
366          const void *key2)
367  {
368      const robj *o1 = key1, *o2 = key2;
369      return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
370  }
371  uint64_t dictObjHash(const void *key) {
372      const robj *o = key;
373      return dictGenHashFunction(o->ptr, (int)sdslen((sds)o->ptr));               WIN_PORT_FIX &bsol;* cast (int) */
374  }
375  uint64_t dictSdsHash(const void *key) {
376      return dictGenHashFunction((unsigned char*)key, (int)sdslen((char*)key));   WIN_PORT_FIX &bsol;* cast (int) */
377  }
378  uint64_t dictSdsCaseHash(const void *key) {
379      return dictGenCaseHashFunction((unsigned char*)key, (int)sdslen((char*)key)); WIN_PORT_FIX &bsol;* cast (int) */
380  }
381  int dictEncObjKeyCompare(void *privdata, const void *key1,
382          const void *key2)
383  {
384      robj *o1 = (robj*) key1, *o2 = (robj*) key2;
385      int cmp;
386      if (o1->encoding == OBJ_ENCODING_INT &&
387          o2->encoding == OBJ_ENCODING_INT)
388              return o1->ptr == o2->ptr;
389      o1 = getDecodedObject(o1);
390      o2 = getDecodedObject(o2);
391      cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
392      decrRefCount(o1);
393      decrRefCount(o2);
394      return cmp;
395  }
396  uint64_t dictEncObjHash(const void *key) {
397      robj *o = (robj*) key;
398      if (sdsEncodedObject(o)) {
399          return dictGenHashFunction(o->ptr, (int)sdslen((sds)o->ptr));          WIN_PORT_FIX &bsol;* cast (int) */
400      } else {
401          if (o->encoding == OBJ_ENCODING_INT) {
402              char buf[32];
403              int len;
404              len = ll2string(buf,32,(PORT_LONG)o->ptr);
405              return dictGenHashFunction((unsigned char*)buf, len);
406          } else {
407              uint64_t hash;
408              o = getDecodedObject(o);
409              hash = dictGenHashFunction(o->ptr, (int)sdslen((sds)o->ptr));      WIN_PORT_FIX &bsol;* cast (int) */
410              decrRefCount(o);
411              return hash;
412          }
413      }
414  }
415  dictType objectKeyPointerValueDictType = {
416      dictEncObjHash,            &bsol;* hash function */
417      NULL,                      &bsol;* key dup */
418      NULL,                      &bsol;* val dup */
419      dictEncObjKeyCompare,      &bsol;* key compare */
420      dictObjectDestructor,      &bsol;* key destructor */
421      NULL                       &bsol;* val destructor */
422  };
423  dictType objectKeyHeapPointerValueDictType = {
424      dictEncObjHash,            &bsol;* hash function */
425      NULL,                      &bsol;* key dup */
426      NULL,                      &bsol;* val dup */
427      dictEncObjKeyCompare,      &bsol;* key compare */
428      dictObjectDestructor,      &bsol;* key destructor */
429      dictVanillaFree            &bsol;* val destructor */
430  };
431  dictType setDictType = {
432      dictSdsHash,               &bsol;* hash function */
433      NULL,                      &bsol;* key dup */
434      NULL,                      &bsol;* val dup */
435      dictSdsKeyCompare,         &bsol;* key compare */
436      dictSdsDestructor,         &bsol;* key destructor */
437      NULL                       &bsol;* val destructor */
438  };
439  dictType zsetDictType = {
440      dictSdsHash,               &bsol;* hash function */
441      NULL,                      &bsol;* key dup */
442      NULL,                      &bsol;* val dup */
443      dictSdsKeyCompare,         &bsol;* key compare */
444      NULL,                      &bsol;* Note: SDS string shared & freed by skiplist */
445      NULL                       &bsol;* val destructor */
446  };
447  dictType dbDictType = {
448      dictSdsHash,                &bsol;* hash function */
449      NULL,                       &bsol;* key dup */
450      NULL,                       &bsol;* val dup */
451      dictSdsKeyCompare,          &bsol;* key compare */
452      dictSdsDestructor,          &bsol;* key destructor */
453      dictObjectDestructor   &bsol;* val destructor */
454  };
455  dictType shaScriptObjectDictType = {
456      dictSdsCaseHash,            &bsol;* hash function */
457      NULL,                       &bsol;* key dup */
458      NULL,                       &bsol;* val dup */
459      dictSdsKeyCaseCompare,      &bsol;* key compare */
460      dictSdsDestructor,          &bsol;* key destructor */
461      dictObjectDestructor        &bsol;* val destructor */
462  };
463  dictType keyptrDictType = {
464      dictSdsHash,                &bsol;* hash function */
465      NULL,                       &bsol;* key dup */
<span onclick='openModal()' class='match'>466      NULL,                       &bsol;* val dup */
467      dictSdsKeyCompare,          &bsol;* key compare */
468      NULL,                       &bsol;* key destructor */
469      NULL                        &bsol;* val destructor */
470  };
471  dictType commandTableDictType = {
</span>472      dictSdsCaseHash,            &bsol;* hash function */
473      NULL,                       &bsol;* key dup */
474      NULL,                       &bsol;* val dup */
475      dictSdsKeyCaseCompare,      &bsol;* key compare */
476      dictSdsDestructor,          &bsol;* key destructor */
477      NULL                        &bsol;* val destructor */
478  };
479  dictType hashDictType = {
480      dictSdsHash,                &bsol;* hash function */
481      NULL,                       &bsol;* key dup */
482      NULL,                       &bsol;* val dup */
483      dictSdsKeyCompare,          &bsol;* key compare */
484      dictSdsDestructor,          &bsol;* key destructor */
485      dictSdsDestructor           &bsol;* val destructor */
486  };
487  dictType keylistDictType = {
488      dictObjHash,                &bsol;* hash function */
489      NULL,                       &bsol;* key dup */
490      NULL,                       &bsol;* val dup */
491      dictObjKeyCompare,          &bsol;* key compare */
492      dictObjectDestructor,       &bsol;* key destructor */
493      dictListDestructor          &bsol;* val destructor */
494  };
495  dictType clusterNodesDictType = {
496      dictSdsHash,                &bsol;* hash function */
497      NULL,                       &bsol;* key dup */
498      NULL,                       &bsol;* val dup */
499      dictSdsKeyCompare,          &bsol;* key compare */
500      dictSdsDestructor,          &bsol;* key destructor */
501      NULL                        &bsol;* val destructor */
502  };
503  dictType clusterNodesBlackListDictType = {
504      dictSdsCaseHash,            &bsol;* hash function */
505      NULL,                       &bsol;* key dup */
506      NULL,                       &bsol;* val dup */
507      dictSdsKeyCaseCompare,      &bsol;* key compare */
508      dictSdsDestructor,          &bsol;* key destructor */
509      NULL                        &bsol;* val destructor */
510  };
511  dictType modulesDictType = {
512      dictSdsCaseHash,            &bsol;* hash function */
513      NULL,                       &bsol;* key dup */
514      NULL,                       &bsol;* val dup */
515      dictSdsKeyCaseCompare,      &bsol;* key compare */
516      dictSdsDestructor,          &bsol;* key destructor */
517      NULL                        &bsol;* val destructor */
518  };
519  dictType migrateCacheDictType = {
520      dictSdsHash,                &bsol;* hash function */
521      NULL,                       &bsol;* key dup */
522      NULL,                       &bsol;* val dup */
523      dictSdsKeyCompare,          &bsol;* key compare */
524      dictSdsDestructor,          &bsol;* key destructor */
525      NULL                        &bsol;* val destructor */
526  };
527  dictType replScriptCacheDictType = {
528      dictSdsCaseHash,            &bsol;* hash function */
529      NULL,                       &bsol;* key dup */
530      NULL,                       &bsol;* val dup */
531      dictSdsKeyCaseCompare,      &bsol;* key compare */
532      dictSdsDestructor,          &bsol;* key destructor */
533      NULL                        &bsol;* val destructor */
534  };
535  int htNeedsResize(dict *dict) {
536      PORT_LONGLONG size, used;
537      size = dictSlots(dict);
538      used = dictSize(dict);
539      return (size > DICT_HT_INITIAL_SIZE &&
540              (used*100/size < HASHTABLE_MIN_FILL));
541  }
542  void tryResizeHashTables(int dbid) {
543      if (htNeedsResize(server.db[dbid].dict))
544          dictResize(server.db[dbid].dict);
545      if (htNeedsResize(server.db[dbid].expires))
546          dictResize(server.db[dbid].expires);
547  }
548  int incrementallyRehash(int dbid) {
549      if (dictIsRehashing(server.db[dbid].dict)) {
550          dictRehashMilliseconds(server.db[dbid].dict,1);
551          return 1; &bsol;* already used our millisecond for this loop... */
552      }
553      if (dictIsRehashing(server.db[dbid].expires)) {
554          dictRehashMilliseconds(server.db[dbid].expires,1);
555          return 1; &bsol;* already used our millisecond for this loop... */
556      }
557      return 0;
558  }
559  void updateDictResizePolicy(void) {
560      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1)
561          dictEnableResize();
562      else
563          dictDisableResize();
564  }
565  int hasActiveChildProcess() {
566      return server.rdb_child_pid != -1 ||
567             server.aof_child_pid != -1;
568  }
569  void trackInstantaneousMetric(int metric, PORT_LONGLONG current_reading) {
570      PORT_LONGLONG t = mstime() - server.inst_metric[metric].last_sample_time;
571      PORT_LONGLONG ops = current_reading -
572                      server.inst_metric[metric].last_sample_count;
573      PORT_LONGLONG ops_sec;
574      ops_sec = t > 0 ? (ops*1000/t) : 0;
575      server.inst_metric[metric].samples[server.inst_metric[metric].idx] =
576          ops_sec;
577      server.inst_metric[metric].idx++;
578      server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;
579      server.inst_metric[metric].last_sample_time = mstime();
580      server.inst_metric[metric].last_sample_count = current_reading;
581  }
582  PORT_LONGLONG getInstantaneousMetric(int metric) {
583      int j;
584      PORT_LONGLONG sum = 0;
585      for (j = 0; j < STATS_METRIC_SAMPLES; j++)
586          sum += server.inst_metric[metric].samples[j];
587      return sum / STATS_METRIC_SAMPLES;
588  }
589  int clientsCronHandleTimeout(client *c, mstime_t now_ms) {
590      time_t now = now_ms/1000;
591      if (server.maxidletime &&
592          !(c->flags & CLIENT_SLAVE) &&    &bsol;* no timeout for slaves and monitors */
593          !(c->flags & CLIENT_MASTER) &&   &bsol;* no timeout for masters */
594          !(c->flags & CLIENT_BLOCKED) &&  &bsol;* no timeout for BLPOP */
595          !(c->flags & CLIENT_PUBSUB) &&   &bsol;* no timeout for Pub/Sub clients */
596          (now - c->lastinteraction > server.maxidletime))
597      {
598          serverLog(LL_VERBOSE,"Closing idle client");
599          freeClient(c);
600          return 1;
601      } else if (c->flags & CLIENT_BLOCKED) {
602          if (c->bpop.timeout != 0 && c->bpop.timeout < now_ms) {
603              replyToBlockedClientTimedOut(c);
604              unblockClient(c);
605          } else if (server.cluster_enabled) {
606              if (clusterRedirectBlockedClientIfNeeded(c))
607                  unblockClient(c);
608          }
609      }
610      return 0;
611  }
612  int clientsCronResizeQueryBuffer(client *c) {
613      size_t querybuf_size = sdsAllocSize(c->querybuf);
614      time_t idletime = server.unixtime - c->lastinteraction;
615      if (querybuf_size > PROTO_MBULK_BIG_ARG &&
616           ((querybuf_size/(c->querybuf_peak+1)) > 2 ||
617            idletime > 2))
618      {
619          if (sdsavail(c->querybuf) > 1024*4) {
620              c->querybuf = sdsRemoveFreeSpace(c->querybuf);
621          }
622      }
623      c->querybuf_peak = 0;
624      if (c->flags & CLIENT_MASTER) {
625          size_t pending_querybuf_size = sdsAllocSize(c->pending_querybuf);
626          if(pending_querybuf_size > LIMIT_PENDING_QUERYBUF &&
627             sdslen(c->pending_querybuf) < (pending_querybuf_size/2))
628          {
629              c->pending_querybuf = sdsRemoveFreeSpace(c->pending_querybuf);
630          }
631      }
632      return 0;
633  }
634  #define CLIENTS_PEAK_MEM_USAGE_SLOTS 8
635  size_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS];
636  size_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS];
637  int clientsCronTrackExpansiveClients(client *c) {
638      size_t in_usage = sdsAllocSize(c->querybuf);
639      size_t out_usage = getClientOutputBufferMemoryUsage(c);
640      int i = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;
641      int zeroidx = (i+1) % CLIENTS_PEAK_MEM_USAGE_SLOTS;
642      ClientsPeakMemInput[zeroidx] = 0;
643      ClientsPeakMemOutput[zeroidx] = 0;
644      if (in_usage > ClientsPeakMemInput[i]) ClientsPeakMemInput[i] = in_usage;
645      if (out_usage > ClientsPeakMemOutput[i]) ClientsPeakMemOutput[i] = out_usage;
646      return 0; &bsol;* This function never terminates the client. */
647  }
648  void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
649      size_t i = 0, o = 0;
650      for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {
651          if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];
652          if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];
653      }
654      *in_usage = i;
655      *out_usage = o;
656  }
657  #define CLIENTS_CRON_MIN_ITERATIONS 5
658  void clientsCron(void) {
659      int numclients = (int)listLength(server.clients);                           WIN_PORT_FIX &bsol;* cast (int) */
660      int iterations = numclients/server.hz;
661      mstime_t now = mstime();
662      if (iterations < CLIENTS_CRON_MIN_ITERATIONS)
663          iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?
664                       numclients : CLIENTS_CRON_MIN_ITERATIONS;
665      while(listLength(server.clients) && iterations--) {
666          client *c;
667          listNode *head;
668          listRotateTailToHead(server.clients);
669          head = listFirst(server.clients);
670          c = listNodeValue(head);
671          if (clientsCronHandleTimeout(c,now)) continue;
672          if (clientsCronResizeQueryBuffer(c)) continue;
673          if (clientsCronTrackExpansiveClients(c)) continue;
674      }
675  }
676  void databasesCron(void) {
677      if (server.active_expire_enabled) {
678          if (server.masterhost == NULL) {
679              activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);
680          } else {
681              expireSlaveKeys();
682          }
683      }
684      if (server.active_defrag_enabled)
685          activeDefragCycle();
686      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {
687          static unsigned int resize_db = 0;
688          static unsigned int rehash_db = 0;
689          int dbs_per_call = CRON_DBS_PER_CALL;
690          int j;
691          if (dbs_per_call > server.dbnum) dbs_per_call = server.dbnum;
692          for (j = 0; j < dbs_per_call; j++) {
693              tryResizeHashTables(resize_db % server.dbnum);
694              resize_db++;
695          }
696          if (server.activerehashing) {
697              for (j = 0; j < dbs_per_call; j++) {
698                  int work_done = incrementallyRehash(rehash_db);
699                  if (work_done) {
700                      break;
701                  } else {
702                      rehash_db++;
703                      rehash_db %= server.dbnum;
704                  }
705              }
706          }
707      }
708  }
709  void updateCachedTime(int update_daylight_info) {
710      server.ustime = ustime();
711      server.mstime = server.ustime / 1000;
712      time_t unixtime = server.mstime / 1000;
713      atomicSet(server.unixtime,unixtime);
714      if (update_daylight_info) {
715          struct tm tm;
716          time_t ut = server.unixtime;
717  #ifdef _WIN32
718          localtime_s(&tm,&ut);
719  #else
720          localtime_r(&ut,&tm);
721  #endif
722          server.daylight_active = tm.tm_isdst;
723      }
724  }
725  int serverCron(struct aeEventLoop *eventLoop, PORT_LONGLONG id, void *clientData) {
726      int j;
727      UNUSED(eventLoop);
728      UNUSED(id);
729      UNUSED(clientData);
730      if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);
731      updateCachedTime(1);
732      server.hz = server.config_hz;
733      if (server.dynamic_hz) {
734          while (listLength(server.clients) / server.hz >
735                 MAX_CLIENTS_PER_CLOCK_TICK)
736          {
737              server.hz *= 2;
738              if (server.hz > CONFIG_MAX_HZ) {
739                  server.hz = CONFIG_MAX_HZ;
740                  break;
741              }
742          }
743      }
744      run_with_period(100) {
745          trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);
746          trackInstantaneousMetric(STATS_METRIC_NET_INPUT,
747                  server.stat_net_input_bytes);
748          trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,
749                  server.stat_net_output_bytes);
750      }
751      unsigned long lruclock = getLRUClock();
752      atomicSet(server.lruclock,lruclock);
753      if (zmalloc_used_memory() > server.stat_peak_memory)
754          server.stat_peak_memory = zmalloc_used_memory();
755      run_with_period(100) {
756          server.cron_malloc_stats.process_rss = zmalloc_get_rss();
757          server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();
758          zmalloc_get_allocator_info(&server.cron_malloc_stats.allocator_allocated,
759                                     &server.cron_malloc_stats.allocator_active,
760                                     &server.cron_malloc_stats.allocator_resident);
761          if (!server.cron_malloc_stats.allocator_resident) {
762              size_t lua_memory = lua_gc(server.lua,LUA_GCCOUNT,0)*(PORT_LONGLONG)1024;  
763              server.cron_malloc_stats.allocator_resident = server.cron_malloc_stats.process_rss - lua_memory;
764          }
765          if (!server.cron_malloc_stats.allocator_active)
766              server.cron_malloc_stats.allocator_active = server.cron_malloc_stats.allocator_resident;
767          if (!server.cron_malloc_stats.allocator_allocated)
768              server.cron_malloc_stats.allocator_allocated = server.cron_malloc_stats.zmalloc_used;
769      }
770      if (server.shutdown_asap) {
771          if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);
772          serverLog(LL_WARNING,"SIGTERM received but errors trying to shut down the server, check the logs for more information");
773          server.shutdown_asap = 0;
774      }
775      run_with_period(5000) {
776          for (j = 0; j < server.dbnum; j++) {
777              PORT_LONGLONG size, used, vkeys;
778              size = dictSlots(server.db[j].dict);
779              used = dictSize(server.db[j].dict);
780              vkeys = dictSize(server.db[j].expires);
781              if (used || vkeys) {
782                  serverLog(LL_VERBOSE,"DB %d: %lld keys (%lld volatile) in %lld slots HT.",j,used,vkeys,size);
783              }
784          }
785      }
786      if (!server.sentinel_mode) {
787          run_with_period(5000) {
788              serverLog(LL_VERBOSE,
789                  "%Iu clients connected (%Iu replicas), %Iu bytes in use", WIN_PORT_FIX &bsol;* %zu -> %Iu, %lu -> %Iu */
790                  listLength(server.clients)-listLength(server.slaves),
791                  listLength(server.slaves),
792                  zmalloc_used_memory());
793          }
794      }
795      clientsCron();
796      databasesCron();
797      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
798          server.aof_rewrite_scheduled)
799      {
800          rewriteAppendOnlyFileBackground();
801      }
802      if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||
803          ldbPendingChildren())
804      {
805  #ifdef _WIN32
806          if (GetForkOperationStatus() == osCOMPLETE || GetForkOperationStatus() == osFAILED) {
807              RequestSuspension();
808              if (SuspensionCompleted()) {
809                  int exitcode;
810                  int bysignal;
811                  bysignal = (int) (GetForkOperationStatus() == osFAILED);
812                  serverLog(LL_WARNING, (bysignal ? "fork operation failed" : "fork operation complete"));
813                  EndForkOperation(&exitcode);
814                  ResumeFromSuspension();
815                  if (server.rdb_child_pid != -1) {
816                      backgroundSaveDoneHandler(exitcode, bysignal);
817                      if (!bysignal && exitcode == 0) receiveChildInfo();
818                  }
819                  else {
820                      backgroundRewriteDoneHandler(exitcode, bysignal);
821                      if (!bysignal && exitcode == 0) receiveChildInfo();
822                  }
823                  updateDictResizePolicy();
824              }
825          }
826  #else
827          int statloc;
828          pid_t pid;
829          if ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) {
830              int exitcode = WEXITSTATUS(statloc);
831              int bysignal = 0;
832              if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
833              if (pid == -1) {
834                  serverLog(LL_WARNING,"wait3() returned an error: %s. "
835                      "rdb_child_pid = %d, aof_child_pid = %d",
836                      strerror(errno),
837                      (int) server.rdb_child_pid,
838                      (int) server.aof_child_pid);
839              } else if (pid == server.rdb_child_pid) {
840                  backgroundSaveDoneHandler(exitcode,bysignal);
841                  if (!bysignal && exitcode == 0) receiveChildInfo();
842              } else if (pid == server.aof_child_pid) {
843                  backgroundRewriteDoneHandler(exitcode,bysignal);
844                  if (!bysignal && exitcode == 0) receiveChildInfo();
845              } else {
846                  if (!ldbRemoveChild(pid)) {
847                      serverLog(LL_WARNING,
848                          "Warning, detected child with unmatched pid: %ld",
849                          (PORT_LONG)pid);
850                  }
851              }
852              updateDictResizePolicy();
853              closeChildInfoPipe();
854          }
855  #endif
856      } else {
857          for (j = 0; j < server.saveparamslen; j++) {
858              struct saveparam *sp = server.saveparams+j;
859              if (server.dirty >= sp->changes &&
860                  server.unixtime-server.lastsave > sp->seconds &&
861                  (server.unixtime-server.lastbgsave_try >
862                   CONFIG_BGSAVE_RETRY_DELAY ||
863                   server.lastbgsave_status == C_OK))
864              {
865                  serverLog(LL_NOTICE,"%d changes in %d seconds. Saving...",
866                      sp->changes, (int)sp->seconds);
867                  rdbSaveInfo rsi, *rsiptr;
868                  rsiptr = rdbPopulateSaveInfo(&rsi);
869                  rdbSaveBackground(server.rdb_filename,rsiptr);
870                  break;
871              }
872          }
873          if (server.aof_state == AOF_ON &&
874              server.rdb_child_pid == -1 &&
875              server.aof_child_pid == -1 &&
876              server.aof_rewrite_perc &&
877              server.aof_current_size > server.aof_rewrite_min_size)
878          {
879              PORT_LONGLONG base = server.aof_rewrite_base_size ?
880                  server.aof_rewrite_base_size : 1;
881              PORT_LONGLONG growth = (server.aof_current_size*100/base) - 100;
882              if (growth >= server.aof_rewrite_perc) {
883                  serverLog(LL_NOTICE,"Starting automatic rewriting of AOF on %lld%% growth",growth);
884                  rewriteAppendOnlyFileBackground();
885              }
886          }
887      }
888      if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);
889      run_with_period(1000) {
890          if (server.aof_last_write_status == C_ERR)
891              flushAppendOnlyFile(0);
892      }
893      freeClientsInAsyncFreeQueue();
894      clientsArePaused(); &bsol;* Don't check return value, just use the side effect.*/
895      run_with_period(1000) replicationCron();
896      run_with_period(100) {
897          if (server.cluster_enabled) clusterCron();
898      }
899      if (server.sentinel_mode) sentinelTimer();
900      run_with_period(1000) {
901          migrateCloseTimedoutSockets();
902      }
903      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
904          server.rdb_bgsave_scheduled &&
905          (server.unixtime-server.lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY ||
906           server.lastbgsave_status == C_OK))
907      {
908          rdbSaveInfo rsi, *rsiptr;
909          rsiptr = rdbPopulateSaveInfo(&rsi);
910          if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)
911              server.rdb_bgsave_scheduled = 0;
912      }
913      server.cronloops++;
914      return 1000/server.hz;
915  }
916  void beforeSleep(struct aeEventLoop *eventLoop) {
917      UNUSED(eventLoop);
918  #ifdef WIN32
919  	aofProcessDiffRewriteEvents(eventLoop);
920  #endif
921      if (server.cluster_enabled) clusterBeforeSleep();
922      if (server.active_expire_enabled && server.masterhost == NULL)
923          activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);
924      if (server.get_ack_from_slaves) {
925          robj *argv[3];
926          argv[0] = createStringObject("REPLCONF",8);
927          argv[1] = createStringObject("GETACK",6);
928          argv[2] = createStringObject("*",1); &bsol;* Not used argument. */
929          replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);
930          decrRefCount(argv[0]);
931          decrRefCount(argv[1]);
932          decrRefCount(argv[2]);
933          server.get_ack_from_slaves = 0;
934      }
935      if (listLength(server.clients_waiting_acks))
936          processClientsWaitingReplicas();
937      moduleHandleBlockedClients();
938      if (listLength(server.unblocked_clients))
939          processUnblockedClients();
940      flushAppendOnlyFile(0);
941      handleClientsWithPendingWrites();
942      if (moduleCount()) moduleReleaseGIL();
943  }
944  void afterSleep(struct aeEventLoop *eventLoop) {
945      UNUSED(eventLoop);
946      if (moduleCount()) moduleAcquireGIL();
947  }
948  void createSharedObjects(void) {
949      int j;
950      shared.crlf = createObject(OBJ_STRING,sdsnew("\r\n"));
951      shared.ok = createObject(OBJ_STRING,sdsnew("+OK\r\n"));
952      shared.err = createObject(OBJ_STRING,sdsnew("-ERR\r\n"));
953      shared.emptybulk = createObject(OBJ_STRING,sdsnew("$0\r\n\r\n"));
954      shared.czero = createObject(OBJ_STRING,sdsnew(":0\r\n"));
955      shared.cone = createObject(OBJ_STRING,sdsnew(":1\r\n"));
956      shared.cnegone = createObject(OBJ_STRING,sdsnew(":-1\r\n"));
957      shared.nullbulk = createObject(OBJ_STRING,sdsnew("$-1\r\n"));
958      shared.nullmultibulk = createObject(OBJ_STRING,sdsnew("*-1\r\n"));
959      shared.emptymultibulk = createObject(OBJ_STRING,sdsnew("*0\r\n"));
960      shared.pong = createObject(OBJ_STRING,sdsnew("+PONG\r\n"));
961      shared.queued = createObject(OBJ_STRING,sdsnew("+QUEUED\r\n"));
962      shared.emptyscan = createObject(OBJ_STRING,sdsnew("*2\r\n$1\r\n0\r\n*0\r\n"));
963      shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(
964          "-WRONGTYPE Operation against a key holding the wrong kind of value\r\n"));
965      shared.nokeyerr = createObject(OBJ_STRING,sdsnew(
966          "-ERR no such key\r\n"));
967      shared.syntaxerr = createObject(OBJ_STRING,sdsnew(
968          "-ERR syntax error\r\n"));
969      shared.sameobjecterr = createObject(OBJ_STRING,sdsnew(
970          "-ERR source and destination objects are the same\r\n"));
971      shared.outofrangeerr = createObject(OBJ_STRING,sdsnew(
972          "-ERR index out of range\r\n"));
973      shared.noscripterr = createObject(OBJ_STRING,sdsnew(
974          "-NOSCRIPT No matching script. Please use EVAL.\r\n"));
975      shared.loadingerr = createObject(OBJ_STRING,sdsnew(
976          "-LOADING Redis is loading the dataset in memory\r\n"));
977      shared.slowscripterr = createObject(OBJ_STRING,sdsnew(
978          "-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\r\n"));
979      shared.masterdownerr = createObject(OBJ_STRING,sdsnew(
980          "-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\r\n"));
981      shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(
982          "-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\r\n"));
983      shared.roslaveerr = createObject(OBJ_STRING,sdsnew(
984          "-READONLY You can't write against a read only replica.\r\n"));
985      shared.noautherr = createObject(OBJ_STRING,sdsnew(
986          "-NOAUTH Authentication required.\r\n"));
987      shared.oomerr = createObject(OBJ_STRING,sdsnew(
988          "-OOM command not allowed when used memory > 'maxmemory'.\r\n"));
989      shared.execaborterr = createObject(OBJ_STRING,sdsnew(
990          "-EXECABORT Transaction discarded because of previous errors.\r\n"));
991      shared.noreplicaserr = createObject(OBJ_STRING,sdsnew(
992          "-NOREPLICAS Not enough good replicas to write.\r\n"));
993      shared.busykeyerr = createObject(OBJ_STRING,sdsnew(
994          "-BUSYKEY Target key name already exists.\r\n"));
995      shared.space = createObject(OBJ_STRING,sdsnew(" "));
996      shared.colon = createObject(OBJ_STRING,sdsnew(":"));
997      shared.plus = createObject(OBJ_STRING,sdsnew("+"));
998      for (j = 0; j < PROTO_SHARED_SELECT_CMDS; j++) {
999          char dictid_str[64];
1000          int dictid_len;
1001          dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);
1002          shared.select[j] = createObject(OBJ_STRING,
1003              sdscatprintf(sdsempty(),
1004                  "*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n",
1005                  dictid_len, dictid_str));
1006      }
1007      shared.messagebulk = createStringObject("$7\r\nmessage\r\n",13);
1008      shared.pmessagebulk = createStringObject("$8\r\npmessage\r\n",14);
1009      shared.subscribebulk = createStringObject("$9\r\nsubscribe\r\n",15);
1010      shared.unsubscribebulk = createStringObject("$11\r\nunsubscribe\r\n",18);
1011      shared.psubscribebulk = createStringObject("$10\r\npsubscribe\r\n",17);
1012      shared.punsubscribebulk = createStringObject("$12\r\npunsubscribe\r\n",19);
1013      shared.del = createStringObject("DEL",3);
1014      shared.unlink = createStringObject("UNLINK",6);
1015      shared.rpop = createStringObject("RPOP",4);
1016      shared.lpop = createStringObject("LPOP",4);
1017      shared.lpush = createStringObject("LPUSH",5);
1018      shared.rpoplpush = createStringObject("RPOPLPUSH",9);
1019      shared.zpopmin = createStringObject("ZPOPMIN",7);
1020      shared.zpopmax = createStringObject("ZPOPMAX",7);
1021      for (j = 0; j < OBJ_SHARED_INTEGERS; j++) {
1022          shared.integers[j] =
1023              makeObjectShared(createObject(OBJ_STRING,(void*)(PORT_LONG)j));
1024          shared.integers[j]->encoding = OBJ_ENCODING_INT;
1025      }
1026      for (j = 0; j < OBJ_SHARED_BULKHDR_LEN; j++) {
1027          shared.mbulkhdr[j] = createObject(OBJ_STRING,
1028              sdscatprintf(sdsempty(),"*%d\r\n",j));
1029          shared.bulkhdr[j] = createObject(OBJ_STRING,
1030              sdscatprintf(sdsempty(),"$%d\r\n",j));
1031      }
1032      shared.minstring = sdsnew("minstring");
1033      shared.maxstring = sdsnew("maxstring");
1034  }
1035  void initServerConfig(void) {
1036      int j;
1037  #ifdef _WIN32
1038  #pragma warning( suppress : 6031 )
1039  #endif
1040      pthread_mutex_init(&server.next_client_id_mutex,NULL);
1041  #ifdef _WIN32
1042  #pragma warning( suppress : 6031 )
1043  #endif
1044      pthread_mutex_init(&server.lruclock_mutex,NULL);
1045  #ifdef _WIN32
1046  #pragma warning( suppress : 6031 )
1047  #endif
1048      pthread_mutex_init(&server.unixtime_mutex,NULL);
1049      updateCachedTime(1);
1050      getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);
1051      server.runid[CONFIG_RUN_ID_SIZE] = '\0';
1052      changeReplicationId();
1053      clearReplicationId2();
1054      server.timezone = getTimeZone(); &bsol;* Initialized by tzset(). */
1055      server.configfile = NULL;
1056      server.executable = NULL;
1057      server.hz = server.config_hz = CONFIG_DEFAULT_HZ;
1058      server.dynamic_hz = CONFIG_DEFAULT_DYNAMIC_HZ;
1059      server.arch_bits = (sizeof(PORT_LONG) == 8) ? 64 : 32;
1060      server.port = CONFIG_DEFAULT_SERVER_PORT;
1061      server.tcp_backlog = CONFIG_DEFAULT_TCP_BACKLOG;
1062      server.bindaddr_count = 0;
1063      server.unixsocket = NULL;
1064      server.unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM;
1065      server.ipfd_count = 0;
1066      server.sofd = -1;
1067      server.protected_mode = CONFIG_DEFAULT_PROTECTED_MODE;
1068      server.dbnum = CONFIG_DEFAULT_DBNUM;
1069      server.verbosity = CONFIG_DEFAULT_VERBOSITY;
1070      WIN32_ONLY(setLogVerbosityLevel(server.verbosity);)
1071      server.maxidletime = CONFIG_DEFAULT_CLIENT_TIMEOUT;
1072      server.tcpkeepalive = CONFIG_DEFAULT_TCP_KEEPALIVE;
1073      server.active_expire_enabled = 1;
1074      server.active_defrag_enabled = CONFIG_DEFAULT_ACTIVE_DEFRAG;
1075      server.active_defrag_ignore_bytes = CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES;
1076      server.active_defrag_threshold_lower = CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER;
1077      server.active_defrag_threshold_upper = CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER;
1078      server.active_defrag_cycle_min = CONFIG_DEFAULT_DEFRAG_CYCLE_MIN;
1079      server.active_defrag_cycle_max = CONFIG_DEFAULT_DEFRAG_CYCLE_MAX;
1080      server.active_defrag_max_scan_fields = CONFIG_DEFAULT_DEFRAG_MAX_SCAN_FIELDS;
1081      server.proto_max_bulk_len = CONFIG_DEFAULT_PROTO_MAX_BULK_LEN;
1082      server.client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN;
1083      server.saveparams = NULL;
1084      server.loading = 0;
1085      server.logfile = zstrdup(CONFIG_DEFAULT_LOGFILE);
1086      server.syslog_enabled = CONFIG_DEFAULT_SYSLOG_ENABLED;
1087      server.syslog_ident = zstrdup(CONFIG_DEFAULT_SYSLOG_IDENT);
1088      POSIX_ONLY(server.syslog_facility = LOG_LOCAL0;)
1089      server.daemonize = CONFIG_DEFAULT_DAEMONIZE;
1090      server.supervised = 0;
1091      server.supervised_mode = SUPERVISED_NONE;
1092      server.aof_state = AOF_OFF;
1093      server.aof_fsync = CONFIG_DEFAULT_AOF_FSYNC;
1094      server.aof_no_fsync_on_rewrite = CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE;
1095      server.aof_rewrite_perc = AOF_REWRITE_PERC;
1096      server.aof_rewrite_min_size = AOF_REWRITE_MIN_SIZE;
1097      server.aof_rewrite_base_size = 0;
1098      server.aof_rewrite_scheduled = 0;
1099      server.aof_last_fsync = time(NULL);
1100      server.aof_rewrite_time_last = -1;
1101      server.aof_rewrite_time_start = -1;
1102      server.aof_lastbgrewrite_status = C_OK;
1103      server.aof_delayed_fsync = 0;
1104      server.aof_fd = -1;
1105      server.aof_selected_db = -1; &bsol;* Make sure the first time will not match */
1106      server.aof_flush_postponed_start = 0;
1107      server.aof_rewrite_incremental_fsync = CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC;
1108      server.rdb_save_incremental_fsync = CONFIG_DEFAULT_RDB_SAVE_INCREMENTAL_FSYNC;
1109      server.aof_load_truncated = CONFIG_DEFAULT_AOF_LOAD_TRUNCATED;
1110      server.aof_use_rdb_preamble = CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE;
1111      server.pidfile = NULL;
1112      server.rdb_filename = zstrdup(CONFIG_DEFAULT_RDB_FILENAME);
1113      server.aof_filename = zstrdup(CONFIG_DEFAULT_AOF_FILENAME);
1114      server.requirepass = NULL;
1115      server.rdb_compression = CONFIG_DEFAULT_RDB_COMPRESSION;
1116      server.rdb_checksum = CONFIG_DEFAULT_RDB_CHECKSUM;
1117      server.stop_writes_on_bgsave_err = CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR;
1118      server.activerehashing = CONFIG_DEFAULT_ACTIVE_REHASHING;
1119      server.active_defrag_running = 0;
1120      server.notify_keyspace_events = 0;
1121      server.maxclients = CONFIG_DEFAULT_MAX_CLIENTS;
1122      server.blocked_clients = 0;
1123      memset(server.blocked_clients_by_type,0,
1124             sizeof(server.blocked_clients_by_type));
1125      server.maxmemory = CONFIG_DEFAULT_MAXMEMORY;
1126      server.maxmemory_policy = CONFIG_DEFAULT_MAXMEMORY_POLICY;
1127      server.maxmemory_samples = CONFIG_DEFAULT_MAXMEMORY_SAMPLES;
1128      server.lfu_log_factor = CONFIG_DEFAULT_LFU_LOG_FACTOR;
1129      server.lfu_decay_time = CONFIG_DEFAULT_LFU_DECAY_TIME;
1130      server.hash_max_ziplist_entries = OBJ_HASH_MAX_ZIPLIST_ENTRIES;
1131      server.hash_max_ziplist_value = OBJ_HASH_MAX_ZIPLIST_VALUE;
1132      server.list_max_ziplist_size = OBJ_LIST_MAX_ZIPLIST_SIZE;
1133      server.list_compress_depth = OBJ_LIST_COMPRESS_DEPTH;
1134      server.set_max_intset_entries = OBJ_SET_MAX_INTSET_ENTRIES;
1135      server.zset_max_ziplist_entries = OBJ_ZSET_MAX_ZIPLIST_ENTRIES;
1136      server.zset_max_ziplist_value = OBJ_ZSET_MAX_ZIPLIST_VALUE;
1137      server.hll_sparse_max_bytes = CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES;
1138      server.stream_node_max_bytes = OBJ_STREAM_NODE_MAX_BYTES;
1139      server.stream_node_max_entries = OBJ_STREAM_NODE_MAX_ENTRIES;
1140      server.shutdown_asap = 0;
1141      server.cluster_enabled = 0;
1142      server.cluster_node_timeout = CLUSTER_DEFAULT_NODE_TIMEOUT;
1143      server.cluster_migration_barrier = CLUSTER_DEFAULT_MIGRATION_BARRIER;
1144      server.cluster_slave_validity_factor = CLUSTER_DEFAULT_SLAVE_VALIDITY;
1145      server.cluster_require_full_coverage = CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE;
1146      server.cluster_slave_no_failover = CLUSTER_DEFAULT_SLAVE_NO_FAILOVER;
1147      server.cluster_configfile = zstrdup(CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);
1148      server.cluster_announce_ip = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP;
1149      server.cluster_announce_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT;
1150      server.cluster_announce_bus_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT;
1151      server.cluster_module_flags = CLUSTER_MODULE_FLAG_NONE;
1152      server.migrate_cached_sockets = dictCreate(&migrateCacheDictType,NULL);
1153      server.next_client_id = 1; &bsol;* Client IDs, start from 1 .*/
1154      server.loading_process_events_interval_bytes = (1024*1024*2);
1155      server.lazyfree_lazy_eviction = CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION;
1156      server.lazyfree_lazy_expire = CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE;
1157      server.lazyfree_lazy_server_del = CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL;
1158      server.always_show_logo = CONFIG_DEFAULT_ALWAYS_SHOW_LOGO;
1159      server.lua_time_limit = LUA_SCRIPT_TIME_LIMIT;
1160      unsigned int lruclock = getLRUClock();
1161      atomicSet(server.lruclock,lruclock);
1162      resetServerSaveParams();
1163      appendServerSaveParams(60*60,1);  &bsol;* save after 1 hour and 1 change */
1164      appendServerSaveParams(300,100);  &bsol;* save after 5 minutes and 100 changes */
1165      appendServerSaveParams(60,10000); &bsol;* save after 1 minute and 10000 changes */
1166      server.masterauth = NULL;
1167      server.masterhost = NULL;
1168      server.masterport = 6379;
1169      server.master = NULL;
1170      server.cached_master = NULL;
1171      server.master_initial_offset = -1;
1172      server.repl_state = REPL_STATE_NONE;
1173      server.repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT;
1174      server.repl_serve_stale_data = CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA;
1175      server.repl_slave_ro = CONFIG_DEFAULT_SLAVE_READ_ONLY;
1176      server.repl_slave_ignore_maxmemory = CONFIG_DEFAULT_SLAVE_IGNORE_MAXMEMORY;
1177      server.repl_slave_lazy_flush = CONFIG_DEFAULT_SLAVE_LAZY_FLUSH;
1178      server.repl_down_since = 0; &bsol;* Never connected, repl is down since EVER. */
1179      server.repl_disable_tcp_nodelay = CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY;
1180      server.repl_diskless_sync = CONFIG_DEFAULT_REPL_DISKLESS_SYNC;
1181      server.repl_diskless_sync_delay = CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY;
1182      server.repl_ping_slave_period = CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD;
1183      server.repl_timeout = CONFIG_DEFAULT_REPL_TIMEOUT;
1184      server.repl_min_slaves_to_write = CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE;
1185      server.repl_min_slaves_max_lag = CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG;
1186      server.slave_priority = CONFIG_DEFAULT_SLAVE_PRIORITY;
1187      server.slave_announce_ip = CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP;
1188      server.slave_announce_port = CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT;
1189      server.master_repl_offset = 0;
1190      server.repl_backlog = NULL;
1191      server.repl_backlog_size = CONFIG_DEFAULT_REPL_BACKLOG_SIZE;
1192      server.repl_backlog_histlen = 0;
1193      server.repl_backlog_idx = 0;
1194      server.repl_backlog_off = 0;
1195      server.repl_backlog_time_limit = CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT;
1196      server.repl_no_slaves_since = time(NULL);
1197      for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++)
1198          server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];
1199      R_Zero = 0.0;
1200      R_PosInf = 1.0/R_Zero;
1201      R_NegInf = -1.0/R_Zero;
1202      R_Nan = R_Zero/R_Zero;
1203      server.commands = dictCreate(&commandTableDictType,NULL);
1204      server.orig_commands = dictCreate(&commandTableDictType,NULL);
1205      populateCommandTable();
1206      server.delCommand = lookupCommandByCString("del");
1207      server.multiCommand = lookupCommandByCString("multi");
1208      server.lpushCommand = lookupCommandByCString("lpush");
1209      server.lpopCommand = lookupCommandByCString("lpop");
1210      server.rpopCommand = lookupCommandByCString("rpop");
1211      server.zpopminCommand = lookupCommandByCString("zpopmin");
1212      server.zpopmaxCommand = lookupCommandByCString("zpopmax");
1213      server.sremCommand = lookupCommandByCString("srem");
1214      server.execCommand = lookupCommandByCString("exec");
1215      server.expireCommand = lookupCommandByCString("expire");
1216      server.pexpireCommand = lookupCommandByCString("pexpire");
1217      server.xclaimCommand = lookupCommandByCString("xclaim");
1218      server.xgroupCommand = lookupCommandByCString("xgroup");
1219      server.slowlog_log_slower_than = CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN;
1220      server.slowlog_max_len = CONFIG_DEFAULT_SLOWLOG_MAX_LEN;
1221      server.latency_monitor_threshold = CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD;
1222      server.assert_failed = "<no assertion failed>";
1223      server.assert_file = "<no file>";
1224      server.assert_line = 0;
1225      server.bug_report_start = 0;
1226      server.watchdog_period = 0;
1227      server.lua_always_replicate_commands = 1;
1228  }
1229  extern char **environ;
1230  int restartServer(int flags, mstime_t delay) {
1231      int j;
1232      if (access(server.executable,X_OK) == -1) {
1233          serverLog(LL_WARNING,"Can't restart: this process has no "
1234                               "permissions to execute %s", server.executable);
1235          return C_ERR;
1236      }
1237      if (flags & RESTART_SERVER_CONFIG_REWRITE &&
1238          server.configfile &&
1239          rewriteConfig(server.configfile) == -1)
1240      {
1241          serverLog(LL_WARNING,"Can't restart: configuration rewrite process "
1242                               "failed");
1243          return C_ERR;
1244      }
1245      if (flags & RESTART_SERVER_GRACEFULLY &&
1246          prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)
1247      {
1248          serverLog(LL_WARNING,"Can't restart: error preparing for shutdown");
1249          return C_ERR;
1250      }
1251      for (j = 3; j < (int)server.maxclients + 1024; j++) {
1252  #if _WIN32
1253          if (fcntl(j, F_GETFL, 0) != -1) close(j);
1254  #else
1255          if (fcntl(j,F_GETFD) != -1) close(j);
1256  #endif
1257      }
1258      if (delay) usleep(delay*1000);
1259      zfree(server.exec_argv[0]);
1260      server.exec_argv[0] = zstrdup(server.executable);
1261      IF_WIN32(_execve,execve)(server.executable,server.exec_argv,environ);
1262      _exit(1);
1263      return C_ERR; &bsol;* Never reached. */
1264  }
1265  void adjustOpenFilesLimit(void) {
1266  #ifndef _WIN32
1267      rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;
1268      struct rlimit limit;
1269      if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {
1270          serverLog(LL_WARNING,"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.",
1271              strerror(errno));
1272          server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;
1273      } else {
1274          rlim_t oldlimit = limit.rlim_cur;
1275          if (oldlimit < maxfiles) {
1276              rlim_t bestlimit;
1277              int setrlimit_error = 0;
1278              bestlimit = maxfiles;
1279              while(bestlimit > oldlimit) {
1280                  rlim_t decr_step = 16;
1281                  limit.rlim_cur = bestlimit;
1282                  limit.rlim_max = bestlimit;
1283                  if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;
1284                  setrlimit_error = errno;
1285                  if (bestlimit < decr_step) break;
1286                  bestlimit -= decr_step;
1287              }
1288              if (bestlimit < oldlimit) bestlimit = oldlimit;
1289              if (bestlimit < maxfiles) {
1290                  unsigned int old_maxclients = server.maxclients;
1291                  server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;
1292                  if (bestlimit <= CONFIG_MIN_RESERVED_FDS) {
1293                      serverLog(LL_WARNING,"Your current 'ulimit -n' "
1294                          "of %llu is not enough for the server to start. "
1295                          "Please increase your open file limit to at least "
1296                          "%llu. Exiting.",
1297                          (PORT_ULONGLONG) oldlimit,
1298                          (PORT_ULONGLONG) maxfiles);
1299                      exit(1);
1300                  }
1301                  serverLog(LL_WARNING,"You requested maxclients of %d "
1302                      "requiring at least %llu max file descriptors.",
1303                      old_maxclients,
1304                      (PORT_ULONGLONG) maxfiles);
1305                  serverLog(LL_WARNING,"Server can't set maximum open files "
1306                      "to %llu because of OS error: %s.",
1307                      (PORT_ULONGLONG) maxfiles, strerror(setrlimit_error));
1308                  serverLog(LL_WARNING,"Current maximum open files is %llu. "
1309                      "maxclients has been reduced to %d to compensate for "
1310                      "low ulimit. "
1311                      "If you need higher maxclients increase 'ulimit -n'.",
1312                      (PORT_ULONGLONG) bestlimit, server.maxclients);
1313              } else {
1314                  serverLog(LL_NOTICE,"Increased maximum number of open files "
1315                      "to %llu (it was originally set to %llu).",
1316                      (PORT_ULONGLONG) maxfiles,
1317                      (PORT_ULONGLONG) oldlimit);
1318              }
1319          }
1320      }
1321  #endif
1322  }
1323  void checkTcpBacklogSettings(void) {
1324  #ifdef HAVE_PROC_SOMAXCONN
1325      FILE *fp = fopen("/proc/sys/net/core/somaxconn","r");
1326      char buf[1024];
1327      if (!fp) return;
1328      if (fgets(buf,sizeof(buf),fp) != NULL) {
1329          int somaxconn = atoi(buf);
1330          if (somaxconn > 0 && somaxconn < server.tcp_backlog) {
1331              serverLog(LL_WARNING,"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.", server.tcp_backlog, somaxconn);
1332          }
1333      }
1334      fclose(fp);
1335  #endif
1336  }
1337  int listenToPort(int port, int *fds, int *count) {
1338      int j;
1339      if (server.bindaddr_count == 0) server.bindaddr[0] = NULL;
1340      for (j = 0; j < server.bindaddr_count || j == 0; j++) {
1341          if (server.bindaddr[j] == NULL) {
1342              int unsupported = 0;
1343              fds[*count] = anetTcp6Server(server.neterr,port,NULL,
1344                  server.tcp_backlog);
1345              if (fds[*count] != ANET_ERR) {
1346                  anetNonBlock(NULL,fds[*count]);
1347                  (*count)++;
1348              } else if (errno == EAFNOSUPPORT) {
1349                  unsupported++;
1350                  serverLog(LL_WARNING,"Not listening to IPv6: unsupproted");
1351              }
1352              if (*count == 1 || unsupported) {
1353                  fds[*count] = anetTcpServer(server.neterr,port,NULL,
1354                      server.tcp_backlog);
1355                  if (fds[*count] != ANET_ERR) {
1356                      anetNonBlock(NULL,fds[*count]);
1357                      (*count)++;
1358                  } else if (errno == EAFNOSUPPORT) {
1359                      unsupported++;
1360                      serverLog(LL_WARNING,"Not listening to IPv4: unsupproted");
1361                  }
1362              }
1363              if (*count + unsupported == 2) break;
1364          } else if (strchr(server.bindaddr[j],':')) {
1365              fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],
1366                  server.tcp_backlog);
1367          } else {
1368              fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],
1369                  server.tcp_backlog);
1370          }
1371          if (fds[*count] == ANET_ERR) {
1372              serverLog(LL_WARNING,
1373                  "Could not create server TCP listening socket %s:%d: %s",
1374                  server.bindaddr[j] ? server.bindaddr[j] : "*",
1375                  port, server.neterr);
1376                  if (errno == ENOPROTOOPT     || errno == EPROTONOSUPPORT ||
1377                      errno == ESOCKTNOSUPPORT || errno == EPFNOSUPPORT ||
1378                      errno == EAFNOSUPPORT    || errno == EADDRNOTAVAIL)
1379                      continue;
1380              return C_ERR;
1381          }
1382          anetNonBlock(NULL,fds[*count]);
1383          (*count)++;
1384      }
1385      return C_OK;
1386  }
1387  void resetServerStats(void) {
1388      int j;
1389      server.stat_numcommands = 0;
1390      server.stat_numconnections = 0;
1391      server.stat_expiredkeys = 0;
1392      server.stat_expired_stale_perc = 0;
1393      server.stat_expired_time_cap_reached_count = 0;
1394      server.stat_evictedkeys = 0;
1395      server.stat_keyspace_misses = 0;
1396      server.stat_keyspace_hits = 0;
1397      server.stat_active_defrag_hits = 0;
1398      server.stat_active_defrag_misses = 0;
1399      server.stat_active_defrag_key_hits = 0;
1400      server.stat_active_defrag_key_misses = 0;
1401      server.stat_active_defrag_scanned = 0;
1402      server.stat_fork_time = 0;
1403      server.stat_fork_rate = 0;
1404      server.stat_rejected_conn = 0;
1405      server.stat_sync_full = 0;
1406      server.stat_sync_partial_ok = 0;
1407      server.stat_sync_partial_err = 0;
1408      for (j = 0; j < STATS_METRIC_COUNT; j++) {
1409          server.inst_metric[j].idx = 0;
1410          server.inst_metric[j].last_sample_time = mstime();
1411          server.inst_metric[j].last_sample_count = 0;
1412          memset(server.inst_metric[j].samples,0,
1413              sizeof(server.inst_metric[j].samples));
1414      }
1415      server.stat_net_input_bytes = 0;
1416      server.stat_net_output_bytes = 0;
1417      server.aof_delayed_fsync = 0;
1418  }
1419  void initServer(void) {
1420      int j;
1421      WIN32_ONLY(HMODULE lib;)
1422      signal(SIGHUP, SIG_IGN);
1423      signal(SIGPIPE, SIG_IGN);
1424      setupSignalHandlers();
1425  #ifdef _WIN32
1426      _fmode = _O_BINARY;
1427      setmode(_fileno(stdin), _O_BINARY);
1428      setmode(_fileno(stdout), _O_BINARY);
1429      setmode(_fileno(stderr), _O_BINARY);
1430      setlocale(LC_ALL, "C");
1431      lib = LoadLibraryA("advapi32.dll");
1432      RtlGenRandom = (RtlGenRandomFunc) GetProcAddress(lib, "SystemFunction036");
1433  #else
1434      if (server.syslog_enabled) {
1435          openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,
1436              server.syslog_facility);
1437      }
1438  #endif
1439      server.hz = server.config_hz;
1440      server.pid = getpid();
1441      server.current_client = NULL;
1442      server.fixed_time_expire = 0;
1443      server.clients = listCreate();
1444      server.clients_index = raxNew();
1445      server.clients_to_close = listCreate();
1446      server.slaves = listCreate();
1447      server.monitors = listCreate();
1448      server.clients_pending_write = listCreate();
1449      server.slaveseldb = -1; &bsol;* Force to emit the first SELECT command. */
1450      server.unblocked_clients = listCreate();
1451      server.ready_keys = listCreate();
1452      server.clients_waiting_acks = listCreate();
1453      server.get_ack_from_slaves = 0;
1454      server.clients_paused = 0;
1455      server.system_memory_size = zmalloc_get_memory_size();
1456      createSharedObjects();
1457      adjustOpenFilesLimit();
1458      server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);
1459      if (server.el == NULL) {
1460          serverLog(LL_WARNING,
1461              "Failed creating the event loop. Error message: '%s'",
1462              IF_WIN32(wsa_strerror(errno), strerror(errno)));
1463          exit(1);
1464      }
1465      server.db = zmalloc(sizeof(redisDb)*server.dbnum);
1466      if (server.port != 0 &&
1467          listenToPort(server.port,server.ipfd,&server.ipfd_count) == C_ERR)
1468          exit(1);
1469      if (server.unixsocket != NULL) {
1470          unlink(server.unixsocket); &bsol;* don't care if this fails */
1471          server.sofd = anetUnixServer(server.neterr,server.unixsocket,
1472              server.unixsocketperm, server.tcp_backlog);
1473          if (server.sofd == ANET_ERR) {
1474              serverLog(LL_WARNING, "Opening Unix socket: %s", server.neterr);
1475              exit(1);
1476          }
1477          anetNonBlock(NULL,server.sofd);
1478      }
1479      if (server.ipfd_count == 0 && server.sofd < 0) {
1480          serverLog(LL_WARNING, "Configured to not listen anywhere, exiting.");
1481          exit(1);
1482      }
1483      for (j = 0; j < server.dbnum; j++) {
1484          server.db[j].dict = dictCreate(&dbDictType,NULL);
1485          server.db[j].expires = dictCreate(&keyptrDictType,NULL);
1486          server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);
1487          server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);
1488          server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);
1489          server.db[j].id = j;
1490          server.db[j].avg_ttl = 0;
1491          server.db[j].defrag_later = listCreate();
1492      }
1493      evictionPoolAlloc(); &bsol;* Initialize the LRU keys pool. */
1494      server.pubsub_channels = dictCreate(&keylistDictType,NULL);
1495      server.pubsub_patterns = listCreate();
1496      listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);
1497      listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);
1498      server.cronloops = 0;
1499      server.rdb_child_pid = -1;
1500      server.aof_child_pid = -1;
1501      server.rdb_child_type = RDB_CHILD_TYPE_NONE;
1502      server.rdb_bgsave_scheduled = 0;
1503      server.child_info_pipe[0] = -1;
1504      server.child_info_pipe[1] = -1;
1505      server.child_info_data.magic = 0;
1506      aofRewriteBufferReset();
1507      server.aof_buf = sdsempty();
1508      server.lastsave = time(NULL); &bsol;* At startup we consider the DB saved. */
1509      server.lastbgsave_try = 0;    &bsol;* At startup we never tried to BGSAVE. */
1510      server.rdb_save_time_last = -1;
1511      server.rdb_save_time_start = -1;
1512      server.dirty = 0;
1513      resetServerStats();
1514      server.stat_starttime = time(NULL);
1515      server.stat_peak_memory = 0;
1516      server.stat_rdb_cow_bytes = 0;
1517      server.stat_aof_cow_bytes = 0;
1518      server.cron_malloc_stats.zmalloc_used = 0;
1519      server.cron_malloc_stats.process_rss = 0;
1520      server.cron_malloc_stats.allocator_allocated = 0;
1521      server.cron_malloc_stats.allocator_active = 0;
1522      server.cron_malloc_stats.allocator_resident = 0;
1523      server.lastbgsave_status = C_OK;
1524      server.aof_last_write_status = C_OK;
1525      server.aof_last_write_errno = 0;
1526      server.repl_good_slaves_count = 0;
1527      if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
1528          serverPanic("Can't create event loop timers.");
1529          exit(1);
1530      }
1531      for (j = 0; j < server.ipfd_count; j++) {
1532          if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,
1533              acceptTcpHandler,NULL) == AE_ERR)
1534              {
1535                  serverPanic(
1536                      "Unrecoverable error creating server.ipfd file event.");
1537              }
1538      }
1539      if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,
1540          acceptUnixHandler,NULL) == AE_ERR) serverPanic("Unrecoverable error creating server.sofd file event.");
1541      if (aeCreateFileEvent(server.el, server.module_blocked_pipe[0], AE_READABLE,
1542          moduleBlockedClientPipeReadable,NULL) == AE_ERR) {
1543              serverPanic(
1544                  "Error registering the readable event for the module "
1545                  "blocked clients subsystem.");
1546      }
1547      if (server.aof_state == AOF_ON) {
1548  #ifdef _WIN32
1549          server.aof_fd = open(server.aof_filename,
1550              O_WRONLY | O_APPEND | O_CREAT | _O_BINARY, _S_IREAD | _S_IWRITE);
1551  #else
1552          server.aof_fd = open(server.aof_filename,
1553                                 O_WRONLY|O_APPEND|O_CREAT,0644);
1554  #endif
1555          if (server.aof_fd == -1) {
1556              serverLog(LL_WARNING, "Can't open the append-only file: %s",
1557                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1558              exit(1);
1559          }
1560      }
1561      if (server.arch_bits == 32 && server.maxmemory == 0) {
1562          serverLog(LL_WARNING,"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.");
1563          server.maxmemory = 3072LL*(1024*1024); &bsol;* 3 GB */
1564          server.maxmemory_policy = MAXMEMORY_NO_EVICTION;
1565      }
1566      if (server.cluster_enabled) clusterInit();
1567      replicationScriptCacheInit();
1568      scriptingInit(1);
1569      slowlogInit();
1570      latencyMonitorInit();
1571  }
1572  void InitServerLast() {
1573      bioInit();
1574      server.initial_memory_usage = zmalloc_used_memory();
1575  }
1576  void populateCommandTable(void) {
1577      int j;
1578      int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);
1579      for (j = 0; j < numcommands; j++) {
1580          struct redisCommand *c = redisCommandTable+j;
1581          char *f = c->sflags;
1582          int retval1, retval2;
1583          while(*f != '\0') {
1584              switch(*f) {
1585              case 'w': c->flags |= CMD_WRITE; break;
1586              case 'r': c->flags |= CMD_READONLY; break;
1587              case 'm': c->flags |= CMD_DENYOOM; break;
1588              case 'a': c->flags |= CMD_ADMIN; break;
1589              case 'p': c->flags |= CMD_PUBSUB; break;
1590              case 's': c->flags |= CMD_NOSCRIPT; break;
1591              case 'R': c->flags |= CMD_RANDOM; break;
1592              case 'S': c->flags |= CMD_SORT_FOR_SCRIPT; break;
1593              case 'l': c->flags |= CMD_LOADING; break;
1594              case 't': c->flags |= CMD_STALE; break;
1595              case 'M': c->flags |= CMD_SKIP_MONITOR; break;
1596              case 'k': c->flags |= CMD_ASKING; break;
1597              case 'F': c->flags |= CMD_FAST; break;
1598              default: serverPanic("Unsupported command flag"); break;
1599              }
1600              f++;
1601          }
1602          retval1 = dictAdd(server.commands, sdsnew(c->name), c);
1603          retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);
1604          serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
1605      }
1606  }
1607  void resetCommandTableStats(void) {
1608      struct redisCommand *c;
1609      dictEntry *de;
1610      dictIterator *di;
1611      di = dictGetSafeIterator(server.commands);
1612      while((de = dictNext(di)) != NULL) {
1613          c = (struct redisCommand *) dictGetVal(de);
1614          c->microseconds = 0;
1615          c->calls = 0;
1616      }
1617      dictReleaseIterator(di);
1618  }
1619  void redisOpArrayInit(redisOpArray *oa) {
1620      oa->ops = NULL;
1621      oa->numops = 0;
1622  }
1623  int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,
1624                         robj **argv, int argc, int target)
1625  {
1626      redisOp *op;
1627      oa->ops = zrealloc(oa->ops,sizeof(redisOp)*((PORT_ULONG)oa->numops+1));  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1628      op = oa->ops+oa->numops;
1629      op->cmd = cmd;
1630      op->dbid = dbid;
1631      op->argv = argv;
1632      op->argc = argc;
1633      op->target = target;
1634      oa->numops++;
1635      return oa->numops;
1636  }
1637  void redisOpArrayFree(redisOpArray *oa) {
1638      while(oa->numops) {
1639          int j;
1640          redisOp *op;
1641          oa->numops--;
1642          op = oa->ops+oa->numops;
1643          for (j = 0; j < op->argc; j++)
1644              decrRefCount(op->argv[j]);
1645          zfree(op->argv);
1646      }
1647      zfree(oa->ops);
1648  }
1649  struct redisCommand *lookupCommand(sds name) {
1650      return dictFetchValue(server.commands, name);
1651  }
1652  struct redisCommand *lookupCommandByCString(char *s) {
1653      struct redisCommand *cmd;
1654      sds name = sdsnew(s);
1655      cmd = dictFetchValue(server.commands, name);
1656      sdsfree(name);
1657      return cmd;
1658  }
1659  struct redisCommand *lookupCommandOrOriginal(sds name) {
1660      struct redisCommand *cmd = dictFetchValue(server.commands, name);
1661      if (!cmd) cmd = dictFetchValue(server.orig_commands,name);
1662      return cmd;
1663  }
1664  void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
1665                 int flags)
1666  {
1667      if (server.aof_state != AOF_OFF && flags & PROPAGATE_AOF)
1668          feedAppendOnlyFile(cmd,dbid,argv,argc);
1669      if (flags & PROPAGATE_REPL)
1670          replicationFeedSlaves(server.slaves,dbid,argv,argc);
1671  }
1672  void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
1673                     int target)
1674  {
1675      robj **argvcopy;
1676      int j;
1677      if (server.loading) return; &bsol;* No propagation during loading. */
1678      argvcopy = zmalloc(sizeof(robj*)*argc);
1679      for (j = 0; j < argc; j++) {
1680          argvcopy[j] = argv[j];
1681          incrRefCount(argv[j]);
1682      }
1683      redisOpArrayAppend(&server.also_propagate,cmd,dbid,argvcopy,argc,target);
1684  }
1685  void forceCommandPropagation(client *c, int flags) {
1686      if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;
1687      if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;
1688  }
1689  void preventCommandPropagation(client *c) {
1690      c->flags |= CLIENT_PREVENT_PROP;
1691  }
1692  void preventCommandAOF(client *c) {
1693      c->flags |= CLIENT_PREVENT_AOF_PROP;
1694  }
1695  void preventCommandReplication(client *c) {
1696      c->flags |= CLIENT_PREVENT_REPL_PROP;
1697  }
1698  void call(client *c, int flags) {
1699      PORT_LONGLONG dirty;
1700      ustime_t start, duration;
1701      int client_old_flags = c->flags;
1702      struct redisCommand *real_cmd = c->cmd;
1703      server.fixed_time_expire++;
1704      if (listLength(server.monitors) &&
1705          !server.loading &&
1706          !(c->cmd->flags & (CMD_SKIP_MONITOR|CMD_ADMIN)))
1707      {
1708          replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
1709      }
1710      c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
1711      redisOpArray prev_also_propagate = server.also_propagate;
1712      redisOpArrayInit(&server.also_propagate);
1713      dirty = server.dirty;
1714      updateCachedTime(0);
1715      start = server.ustime;
1716      c->cmd->proc(c);
1717      duration = ustime()-start;
1718      dirty = server.dirty-dirty;
1719      if (dirty < 0) dirty = 0;
1720      if (server.loading && c->flags & CLIENT_LUA)
1721          flags &= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);
1722      if (c->flags & CLIENT_LUA && server.lua_caller) {
1723          if (c->flags & CLIENT_FORCE_REPL)
1724              server.lua_caller->flags |= CLIENT_FORCE_REPL;
1725          if (c->flags & CLIENT_FORCE_AOF)
1726              server.lua_caller->flags |= CLIENT_FORCE_AOF;
1727      }
1728      if (flags & CMD_CALL_SLOWLOG && c->cmd->proc != execCommand) {
1729          char *latency_event = (c->cmd->flags & CMD_FAST) ?
1730                                "fast-command" : "command";
1731          latencyAddSampleIfNeeded(latency_event,duration/1000);
1732          slowlogPushEntryIfNeeded(c,c->argv,c->argc,duration);
1733      }
1734      if (flags & CMD_CALL_STATS) {
1735          real_cmd->microseconds += duration;
1736          real_cmd->calls++;
1737      }
1738      if (flags & CMD_CALL_PROPAGATE &&
1739          (c->flags & CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)
1740      {
1741          int propagate_flags = PROPAGATE_NONE;
1742          if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);
1743          if (c->flags & CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;
1744          if (c->flags & CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;
1745          if (c->flags & CLIENT_PREVENT_REPL_PROP ||
1746              !(flags & CMD_CALL_PROPAGATE_REPL))
1747                  propagate_flags &= ~PROPAGATE_REPL;
1748          if (c->flags & CLIENT_PREVENT_AOF_PROP ||
1749              !(flags & CMD_CALL_PROPAGATE_AOF))
1750                  propagate_flags &= ~PROPAGATE_AOF;
1751          if (propagate_flags != PROPAGATE_NONE && !(c->cmd->flags & CMD_MODULE))
1752              propagate(c->cmd,c->db->id,c->argv,c->argc,propagate_flags);
1753      }
1754      c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
1755      c->flags |= client_old_flags &
1756          (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
1757      if (server.also_propagate.numops) {
1758          int j;
1759          redisOp *rop;
1760          if (flags & CMD_CALL_PROPAGATE) {
1761              for (j = 0; j < server.also_propagate.numops; j++) {
1762                  rop = &server.also_propagate.ops[j];
1763                  int target = rop->target;
1764                  if (!(flags&CMD_CALL_PROPAGATE_AOF)) target &= ~PROPAGATE_AOF;
1765                  if (!(flags&CMD_CALL_PROPAGATE_REPL)) target &= ~PROPAGATE_REPL;
1766                  if (target)
1767                      propagate(rop->cmd,rop->dbid,rop->argv,rop->argc,target);
1768              }
1769          }
1770          redisOpArrayFree(&server.also_propagate);
1771      }
1772      server.also_propagate = prev_also_propagate;
1773      server.fixed_time_expire--;
1774      server.stat_numcommands++;
1775  }
1776  int processCommand(client *c) {
1777      moduleCallCommandFilters(c);
1778      if (!strcasecmp(c->argv[0]->ptr,"quit")) {
1779          addReply(c,shared.ok);
1780          c->flags |= CLIENT_CLOSE_AFTER_REPLY;
1781          return C_ERR;
1782      }
1783      c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);
1784      if (!c->cmd) {
1785          flagTransaction(c);
1786          sds args = sdsempty();
1787          int i;
1788          for (i=1; i < c->argc && sdslen(args) < 128; i++)
1789              args = sdscatprintf(args, "`%.*s`, ", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
1790          addReplyErrorFormat(c,"unknown command `%s`, with args beginning with: %s",
1791              (char*)c->argv[0]->ptr, args);
1792          sdsfree(args);
1793          return C_OK;
1794      } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
1795                 (c->argc < -c->cmd->arity)) {
1796          flagTransaction(c);
1797          addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
1798              c->cmd->name);
1799          return C_OK;
1800      }
1801      if (server.requirepass && !c->authenticated && c->cmd->proc != authCommand)
1802      {
1803          flagTransaction(c);
1804          addReply(c,shared.noautherr);
1805          return C_OK;
1806      }
1807      if (server.cluster_enabled &&
1808          !(c->flags & CLIENT_MASTER) &&
1809          !(c->flags & CLIENT_LUA &&
1810            server.lua_caller->flags & CLIENT_MASTER) &&
1811          !(c->cmd->getkeys_proc == NULL && c->cmd->firstkey == 0 &&
1812            c->cmd->proc != execCommand))
1813      {
1814          int hashslot;
1815          int error_code;
1816          clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,
1817                                          &hashslot,&error_code);
1818          if (n == NULL || n != server.cluster->myself) {
1819              if (c->cmd->proc == execCommand) {
1820                  discardTransaction(c);
1821              } else {
1822                  flagTransaction(c);
1823              }
1824              clusterRedirectClient(c,n,hashslot,error_code);
1825              return C_OK;
1826          }
1827      }
1828      if (server.maxmemory && !server.lua_timedout) {
1829          int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;
1830          if (server.current_client == NULL) return C_ERR;
1831          if (out_of_memory &&
1832              (c->cmd->flags & CMD_DENYOOM ||
1833               (c->flags & CLIENT_MULTI && c->cmd->proc != execCommand))) {
1834              flagTransaction(c);
1835              addReply(c, shared.oomerr);
1836              return C_OK;
1837          }
1838          if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {
1839              server.lua_oom = out_of_memory;
1840          }
1841      }
1842      int deny_write_type = writeCommandsDeniedByDiskError();
1843      if (deny_write_type != DISK_ERROR_TYPE_NONE &&
1844          server.masterhost == NULL &&
1845          (c->cmd->flags & CMD_WRITE ||
1846           c->cmd->proc == pingCommand))
1847      {
1848          flagTransaction(c);
1849          if (deny_write_type == DISK_ERROR_TYPE_RDB)
1850              addReply(c, shared.bgsaveerr);
1851          else
1852              addReplySds(c,
1853                  sdscatprintf(sdsempty(),
1854                  "-MISCONF Errors writing to the AOF file: %s\r\n",
1855                  strerror(server.aof_last_write_errno)));
1856          return C_OK;
1857      }
1858      if (server.masterhost == NULL &&
1859          server.repl_min_slaves_to_write &&
1860          server.repl_min_slaves_max_lag &&
1861          c->cmd->flags & CMD_WRITE &&
1862          server.repl_good_slaves_count < server.repl_min_slaves_to_write)
1863      {
1864          flagTransaction(c);
1865          addReply(c, shared.noreplicaserr);
1866          return C_OK;
1867      }
1868      if (server.masterhost && server.repl_slave_ro &&
1869          !(c->flags & CLIENT_MASTER) &&
1870          c->cmd->flags & CMD_WRITE)
1871      {
1872          addReply(c, shared.roslaveerr);
1873          return C_OK;
1874      }
1875      if (c->flags & CLIENT_PUBSUB &&
1876          c->cmd->proc != pingCommand &&
1877          c->cmd->proc != subscribeCommand &&
1878          c->cmd->proc != unsubscribeCommand &&
1879          c->cmd->proc != psubscribeCommand &&
1880          c->cmd->proc != punsubscribeCommand) {
1881          addReplyError(c,"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context");
1882          return C_OK;
1883      }
1884      if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&
1885          server.repl_serve_stale_data == 0 &&
1886          !(c->cmd->flags & CMD_STALE))
1887      {
1888          flagTransaction(c);
1889          addReply(c, shared.masterdownerr);
1890          return C_OK;
1891      }
1892      if (server.loading && !(c->cmd->flags & CMD_LOADING)) {
1893          addReply(c, shared.loadingerr);
1894          return C_OK;
1895      }
1896      if (server.lua_timedout &&
1897            c->cmd->proc != authCommand &&
1898            c->cmd->proc != replconfCommand &&
1899          !(c->cmd->proc == shutdownCommand &&
1900            c->argc == 2 &&
1901            tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&
1902          !(c->cmd->proc == scriptCommand &&
1903            c->argc == 2 &&
1904            tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))
1905      {
1906          flagTransaction(c);
1907          addReply(c, shared.slowscripterr);
1908          return C_OK;
1909      }
1910      if (c->flags & CLIENT_MULTI &&
1911          c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&
1912          c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)
1913      {
1914          queueMultiCommand(c);
1915          addReply(c,shared.queued);
1916      } else {
1917          call(c,CMD_CALL_FULL);
1918          c->woff = server.master_repl_offset;
1919          if (listLength(server.ready_keys))
1920              handleClientsBlockedOnKeys();
1921      }
1922      return C_OK;
1923  }
1924  void closeListeningSockets(int unlink_unix_socket) {
1925      int j;
1926      for (j = 0; j < server.ipfd_count; j++) close(server.ipfd[j]);
1927      if (server.sofd != -1) close(server.sofd);
1928      if (server.cluster_enabled)
1929          for (j = 0; j < server.cfd_count; j++) close(server.cfd[j]);
1930  #ifndef _WIN32
1931      if (unlink_unix_socket && server.unixsocket) {
1932          serverLog(LL_NOTICE,"Removing the unix socket file.");
1933          unlink(server.unixsocket); &bsol;* don't care if this fails */
1934      }
1935  #endif
1936  }
1937  int prepareForShutdown(int flags) {
1938      if (server.loading || server.sentinel_mode)
1939          flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;
1940      int save = flags & SHUTDOWN_SAVE;
1941      int nosave = flags & SHUTDOWN_NOSAVE;
1942      serverLog(LL_WARNING,"User requested shutdown...");
1943      ldbKillForkedSessions();
1944      if (server.rdb_child_pid != -1) {
1945          serverLog(LL_WARNING,"There is a child saving an .rdb. Killing it!");
1946          IF_WIN32(AbortForkOperation(), kill(server.rdb_child_pid,SIGUSR1));
1947          rdbRemoveTempFile(server.rdb_child_pid);
1948      }
1949      if (server.aof_state != AOF_OFF) {
1950          if (server.aof_child_pid != -1) {
1951              if (server.aof_state == AOF_WAIT_REWRITE) {
1952                  serverLog(LL_WARNING, "Writing initial AOF, can't exit.");
1953                  return C_ERR;
1954              }
1955              serverLog(LL_WARNING,
1956                  "There is a child rewriting the AOF. Killing it!");
1957              IF_WIN32(AbortForkOperation(), kill(server.aof_child_pid,SIGUSR1));
1958          }
1959          serverLog(LL_NOTICE,"Calling fsync() on the AOF file.");
1960          flushAppendOnlyFile(1);
1961          redis_fsync(server.aof_fd);
1962      }
1963      if ((server.saveparamslen > 0 && !nosave) || save) {
1964          serverLog(LL_NOTICE,"Saving the final RDB snapshot before exiting.");
1965          rdbSaveInfo rsi, *rsiptr;
1966          rsiptr = rdbPopulateSaveInfo(&rsi);
1967          if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {
1968              serverLog(LL_WARNING,"Error trying to save the DB, can't exit.");
1969              return C_ERR;
1970          }
1971      }
1972      if (server.daemonize || server.pidfile) {
1973          serverLog(LL_NOTICE,"Removing the pid file.");
1974          unlink(server.pidfile);
1975      }
1976      flushSlavesOutputBuffers();
1977      closeListeningSockets(1);
1978      serverLog(LL_WARNING,"%s is now ready to exit, bye bye...",
1979          server.sentinel_mode ? "Sentinel" : "Redis");
1980      return C_OK;
1981  }
1982  int writeCommandsDeniedByDiskError(void) {
1983      if (server.stop_writes_on_bgsave_err &&
1984          server.saveparamslen > 0 &&
1985          server.lastbgsave_status == C_ERR)
1986      {
1987          return DISK_ERROR_TYPE_RDB;
1988      } else if (server.aof_state != AOF_OFF &&
1989                 server.aof_last_write_status == C_ERR)
1990      {
1991          return DISK_ERROR_TYPE_AOF;
1992      } else {
1993          return DISK_ERROR_TYPE_NONE;
1994      }
1995  }
1996  int time_independent_strcmp(char *a, char *b) {
1997      char bufa[CONFIG_AUTHPASS_MAX_LEN], bufb[CONFIG_AUTHPASS_MAX_LEN];
1998      unsigned int alen = (unsigned int) strlen(a);                               WIN_PORT_FIX &bsol;* cast (unsigned int) */
1999      unsigned int blen = (unsigned int) strlen(b);                               WIN_PORT_FIX &bsol;* cast (unsigned int) */
2000      unsigned int j;
2001      int diff = 0;
2002      if (alen > sizeof(bufa) || blen > sizeof(bufb)) return 1;
2003      memset(bufa,0,sizeof(bufa));        &bsol;* Constant time. */
2004      memset(bufb,0,sizeof(bufb));        &bsol;* Constant time. */
2005      memcpy(bufa,a,alen);
2006      memcpy(bufb,b,blen);
2007      for (j = 0; j < sizeof(bufa); j++) {
2008          diff |= (bufa[j] ^ bufb[j]);
2009      }
2010      diff |= alen ^ blen;
2011      return diff; &bsol;* If zero strings are the same. */
2012  }
2013  void authCommand(client *c) {
2014      if (!server.requirepass) {
2015          addReplyError(c,"Client sent AUTH, but no password is set");
2016      } else if (!time_independent_strcmp(c->argv[1]->ptr, server.requirepass)) {
2017        c->authenticated = 1;
2018        addReply(c,shared.ok);
2019      } else {
2020        c->authenticated = 0;
2021        addReplyError(c,"invalid password");
2022      }
2023  }
2024  void pingCommand(client *c) {
2025      if (c->argc > 2) {
2026          addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
2027              c->cmd->name);
2028          return;
2029      }
2030      if (c->flags & CLIENT_PUBSUB) {
2031          addReply(c,shared.mbulkhdr[2]);
2032          addReplyBulkCBuffer(c,"pong",4);
2033          if (c->argc == 1)
2034              addReplyBulkCBuffer(c,"",0);
2035          else
2036              addReplyBulk(c,c->argv[1]);
2037      } else {
2038          if (c->argc == 1)
2039              addReply(c,shared.pong);
2040          else
2041              addReplyBulk(c,c->argv[1]);
2042      }
2043  }
2044  void echoCommand(client *c) {
2045      addReplyBulk(c,c->argv[1]);
2046  }
2047  void timeCommand(client *c) {
2048      struct timeval tv;
2049      gettimeofday(&tv,NULL);
2050      addReplyMultiBulkLen(c,2);
2051      addReplyBulkLongLong(c,tv.tv_sec);
2052      addReplyBulkLongLong(c,tv.tv_usec);
2053  }
2054  int addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {
2055      if (cmd->flags & f) {
2056          addReplyStatus(c, reply);
2057          return 1;
2058      }
2059      return 0;
2060  }
2061  void addReplyCommand(client *c, struct redisCommand *cmd) {
2062      if (!cmd) {
2063          addReply(c, shared.nullbulk);
2064      } else {
2065          addReplyMultiBulkLen(c, 6);
2066          addReplyBulkCString(c, cmd->name);
2067          addReplyLongLong(c, cmd->arity);
2068          int flagcount = 0;
2069          void *flaglen = addDeferredMultiBulkLength(c);
2070          flagcount += addReplyCommandFlag(c,cmd,CMD_WRITE, "write");
2071          flagcount += addReplyCommandFlag(c,cmd,CMD_READONLY, "readonly");
2072          flagcount += addReplyCommandFlag(c,cmd,CMD_DENYOOM, "denyoom");
2073          flagcount += addReplyCommandFlag(c,cmd,CMD_ADMIN, "admin");
2074          flagcount += addReplyCommandFlag(c,cmd,CMD_PUBSUB, "pubsub");
2075          flagcount += addReplyCommandFlag(c,cmd,CMD_NOSCRIPT, "noscript");
2076          flagcount += addReplyCommandFlag(c,cmd,CMD_RANDOM, "random");
2077          flagcount += addReplyCommandFlag(c,cmd,CMD_SORT_FOR_SCRIPT,"sort_for_script");
2078          flagcount += addReplyCommandFlag(c,cmd,CMD_LOADING, "loading");
2079          flagcount += addReplyCommandFlag(c,cmd,CMD_STALE, "stale");
2080          flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_MONITOR, "skip_monitor");
2081          flagcount += addReplyCommandFlag(c,cmd,CMD_ASKING, "asking");
2082          flagcount += addReplyCommandFlag(c,cmd,CMD_FAST, "fast");
2083          if ((cmd->getkeys_proc && !(cmd->flags & CMD_MODULE)) ||
2084              cmd->flags & CMD_MODULE_GETKEYS)
2085          {
2086              addReplyStatus(c, "movablekeys");
2087              flagcount += 1;
2088          }
2089          setDeferredMultiBulkLength(c, flaglen, flagcount);
2090          addReplyLongLong(c, cmd->firstkey);
2091          addReplyLongLong(c, cmd->lastkey);
2092          addReplyLongLong(c, cmd->keystep);
2093      }
2094  }
2095  void commandCommand(client *c) {
2096      dictIterator *di;
2097      dictEntry *de;
2098      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
2099          const char *help[] = {
2100  "(no subcommand) -- Return details about all Redis commands.",
2101  "COUNT -- Return the total number of commands in this Redis server.",
2102  "GETKEYS <full-command> -- Return the keys from a full Redis command.",
2103  "INFO [command-name ...] -- Return details about multiple Redis commands.",
2104  NULL
2105          };
2106          addReplyHelp(c, help);
2107      } else if (c->argc == 1) {
2108          addReplyMultiBulkLen(c, dictSize(server.commands));
2109          di = dictGetIterator(server.commands);
2110          while ((de = dictNext(di)) != NULL) {
2111              addReplyCommand(c, dictGetVal(de));
2112          }
2113          dictReleaseIterator(di);
2114      } else if (!strcasecmp(c->argv[1]->ptr, "info")) {
2115          int i;
2116          addReplyMultiBulkLen(c, (PORT_LONG)c->argc-2);  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
2117          for (i = 2; i < c->argc; i++) {
2118              addReplyCommand(c, dictFetchValue(server.commands, c->argv[i]->ptr));
2119          }
2120      } else if (!strcasecmp(c->argv[1]->ptr, "count") && c->argc == 2) {
2121          addReplyLongLong(c, dictSize(server.commands));
2122      } else if (!strcasecmp(c->argv[1]->ptr,"getkeys") && c->argc >= 3) {
2123          struct redisCommand *cmd = lookupCommand(c->argv[2]->ptr);
2124          int *keys, numkeys, j;
2125          if (!cmd) {
2126              addReplyError(c,"Invalid command specified");
2127              return;
2128          } else if (cmd->getkeys_proc == NULL && cmd->firstkey == 0) {
2129              addReplyError(c,"The command has no key arguments");
2130              return;
2131          } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||
2132                     ((c->argc-2) < -cmd->arity))
2133          {
2134              addReplyError(c,"Invalid number of arguments specified for command");
2135              return;
2136          }
2137          keys = getKeysFromCommand(cmd,c->argv+2,c->argc-2,&numkeys);
2138          if (!keys) {
2139              addReplyError(c,"Invalid arguments specified for command");
2140          } else {
2141              addReplyMultiBulkLen(c,numkeys);
2142              for (j = 0; j < numkeys; j++) addReplyBulk(c,c->argv[keys[j]+2]);
2143              getKeysFreeResult(keys);
2144          }
2145      } else {
2146          addReplySubcommandSyntaxError(c);
2147      }
2148  }
2149  void bytesToHuman(char *s, PORT_ULONGLONG n) {
2150      double d;
2151      if (n < 1024) {
2152          sprintf(s,"%lluB",n);
2153      } else if (n < (1024*1024)) {
2154          d = (double)n/(1024);
2155          sprintf(s,"%.2fK",d);
2156      } else if (n < (1024LL*1024*1024)) {
2157          d = (double)(n/(1024*1024));  WIN_PORT_FIX
2158          sprintf(s,"%.2fM",d);
2159      } else if (n < (1024LL*1024*1024*1024)) {
2160          d = (double)n/(1024LL*1024*1024);
2161          sprintf(s,"%.2fG",d);
2162      } else if (n < (1024LL*1024*1024*1024*1024)) {
2163          d = (double)n/(1024LL*1024*1024*1024);
2164          sprintf(s,"%.2fT",d);
2165      } else if (n < (1024LL*1024*1024*1024*1024*1024)) {
2166          d = (double)n/(1024LL*1024*1024*1024*1024);
2167          sprintf(s,"%.2fP",d);
2168      } else {
2169          sprintf(s,"%lluB",n);
2170      }
2171  }
2172  sds genRedisInfoString(char *section) {
2173      sds info = sdsempty();
2174      time_t uptime = server.unixtime-server.stat_starttime;
2175      int j;
2176      struct rusage self_ru, c_ru;
2177      int allsections = 0, defsections = 0;
2178      int sections = 0;
2179      if (section == NULL) section = "default";
2180      allsections = strcasecmp(section,"all") == 0;
2181      defsections = strcasecmp(section,"default") == 0;
2182      getrusage(RUSAGE_SELF, &self_ru);
2183      getrusage(RUSAGE_CHILDREN, &c_ru);
2184      if (allsections || defsections || !strcasecmp(section,"server")) {
2185          POSIX_ONLY(static int call_uname = 1;)
2186          POSIX_ONLY(static struct utsname name;)
2187          char *mode;
2188          if (server.cluster_enabled) mode = "cluster";
2189          else if (server.sentinel_mode) mode = "sentinel";
2190          else mode = "standalone";
2191          if (sections++) info = sdscat(info,"\r\n");
2192  #ifndef _WIN32
2193          if (call_uname) {
2194              uname(&name);
2195              call_uname = 0;
2196          }
2197  #endif
2198          unsigned int lruclock;
2199          atomicGet(server.lruclock,lruclock);
2200          info = sdscatprintf(info,
2201              "# Server\r\n"
2202              "redis_version:%s\r\n"
2203              "redis_git_sha1:%s\r\n"
2204              "redis_git_dirty:%d\r\n"
2205              "redis_build_id:%llx\r\n"
2206              "redis_mode:%s\r\n"
2207              "os:%s %s %s\r\n"
2208              "arch_bits:%d\r\n"
2209              "multiplexing_api:%s\r\n"
2210              "atomicvar_api:%s\r\n"
2211              POSIX_ONLY("gcc_version:%d.%d.%d\r\n")
2212              "process_id:%Id\r\n"                                                WIN_PORT_FIX &bsol;* %ld -> %Id */
2213              "run_id:%s\r\n"
2214              "tcp_port:%d\r\n"
2215              "uptime_in_seconds:%lld\r\n"                                        WIN_PORT_FIX &bsol;* %jd -> %lld */
2216              "uptime_in_days:%lld\r\n"                                           WIN_PORT_FIX &bsol;* %jd -> %lld */
2217              "hz:%d\r\n"
2218              "configured_hz:%d\r\n"
2219              "lru_clock:%Id\r\n"                                                 WIN_PORT_FIX &bsol;* %ld -> %Id */
2220              "executable:%s\r\n"
2221              "config_file:%s\r\n",
2222              REDIS_VERSION,
2223              redisGitSHA1(),
2224              strtol(redisGitDirty(),NULL,10) > 0,
2225              (PORT_ULONGLONG) redisBuildId(),
2226              mode,
2227  #ifdef _WIN32
2228                  "Windows", "", "",
2229  #else
2230              name.sysname, name.release, name.machine,
2231  #endif
2232              server.arch_bits,
2233              aeGetApiName(),
2234              REDIS_ATOMIC_API,
2235  #ifndef _WIN32
2236  #ifdef __GNUC__
2237              __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,
2238  #else
2239              0,0,0,
2240  #endif
2241  #endif
2242              (PORT_LONG) getpid(),
2243              server.runid,
2244              server.port,
2245              (intmax_t)uptime,
2246              (intmax_t)(uptime/(3600*24)),
2247              server.hz,
2248              server.config_hz,
2249              (PORT_ULONG) lruclock,
2250              server.executable ? server.executable : "",
2251              server.configfile ? server.configfile : "");
2252      }
2253      if (allsections || defsections || !strcasecmp(section,"clients")) {
2254          size_t maxin, maxout;
2255          getExpansiveClientsInfo(&maxin,&maxout);
2256          if (sections++) info = sdscat(info,"\r\n");
2257          info = sdscatprintf(info,
2258              "# Clients\r\n"
2259              "connected_clients:%Iu\r\n"                      WIN_PORT_FIX &bsol;* %lu -> %Iu */
2260              "client_recent_max_input_buffer:%Iu\r\n"         WIN_PORT_FIX &bsol;* %zu -> %Iu */
2261              "client_recent_max_output_buffer:%Iu\r\n"        WIN_PORT_FIX &bsol;* %zu -> %Iu */
2262              "blocked_clients:%d\r\n",
2263              listLength(server.clients)-listLength(server.slaves),
2264              maxin, maxout,
2265              server.blocked_clients);
2266      }
2267      if (allsections || defsections || !strcasecmp(section,"memory")) {
2268          char hmem[64];
2269          char peak_hmem[64];
2270          char total_system_hmem[64];
2271          char used_memory_lua_hmem[64];
2272          char used_memory_scripts_hmem[64];
2273          char used_memory_rss_hmem[64];
2274          char maxmemory_hmem[64];
2275          size_t zmalloc_used = zmalloc_used_memory();
2276          size_t total_system_mem = server.system_memory_size;
2277          const char *evict_policy = evictPolicyToString();
2278          PORT_LONGLONG memory_lua = (PORT_LONGLONG)lua_gc(server.lua,LUA_GCCOUNT,0)*1024;
2279          struct redisMemOverhead *mh = getMemoryOverheadData();
2280          if (zmalloc_used > server.stat_peak_memory)
2281              server.stat_peak_memory = zmalloc_used;
2282          bytesToHuman(hmem,zmalloc_used);
2283          bytesToHuman(peak_hmem,server.stat_peak_memory);
2284          bytesToHuman(total_system_hmem,total_system_mem);
2285          bytesToHuman(used_memory_lua_hmem,memory_lua);
2286          bytesToHuman(used_memory_scripts_hmem,mh->lua_caches);
2287          bytesToHuman(used_memory_rss_hmem,server.cron_malloc_stats.process_rss);
2288          bytesToHuman(maxmemory_hmem,server.maxmemory);
2289          if (sections++) info = sdscat(info,"\r\n");
2290          info = sdscatprintf(info,
2291              "# Memory\r\n"
2292              "used_memory:%Iu\r\n"                                               WIN_PORT_FIX &bsol;* %zu -> %Iu */
2293              "used_memory_human:%s\r\n"
2294              "used_memory_rss:%Iu\r\n"                                           WIN_PORT_FIX &bsol;* %zu -> %Iu */
2295              "used_memory_rss_human:%s\r\n"
2296              "used_memory_peak:%Iu\r\n"                                          WIN_PORT_FIX &bsol;* %zu -> %Iu */
2297              "used_memory_peak_human:%s\r\n"
2298              "used_memory_peak_perc:%.2f%%\r\n"
2299              "used_memory_overhead:%Iu\r\n"                                      WIN_PORT_FIX &bsol;* %zu -> %Iu */
2300              "used_memory_startup:%Iu\r\n"                                       WIN_PORT_FIX &bsol;* %zu -> %Iu */
2301              "used_memory_dataset:%Iu\r\n"                                       WIN_PORT_FIX &bsol;* %zu -> %Iu */
2302              "used_memory_dataset_perc:%.2f%%\r\n"
2303              "allocator_allocated:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2304              "allocator_active:%Iu\r\n"			WIN_PORT_FIX &bsol;* %zu -> %Iu */
2305              "allocator_resident:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2306              "total_system_memory:%Iu\r\n"		WIN_PORT_FIX &bsol;* %lu -> %Iu */
2307              "total_system_memory_human:%s\r\n"
2308              "used_memory_lua:%lld\r\n"
2309              "used_memory_lua_human:%s\r\n"
2310              "used_memory_scripts:%lld\r\n"
2311              "used_memory_scripts_human:%s\r\n"
2312              "number_of_cached_scripts:%lu\r\n"
2313              "maxmemory:%lld\r\n"
2314              "maxmemory_human:%s\r\n"
2315              "maxmemory_policy:%s\r\n"
2316              "allocator_frag_ratio:%.2f\r\n"
2317              "allocator_frag_bytes:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2318              "allocator_rss_ratio:%.2f\r\n"
2319              "allocator_rss_bytes:%zd\r\n"
2320              "rss_overhead_ratio:%.2f\r\n"
2321              "rss_overhead_bytes:%zd\r\n"
2322              "mem_fragmentation_ratio:%.2f\r\n"
2323              "mem_fragmentation_bytes:%zd\r\n"
2324              "mem_not_counted_for_evict:%Iu\r\n" WIN_PORT_FIX &bsol;* %zu -> %Iu */
2325              "mem_replication_backlog:%Iu\r\n"	WIN_PORT_FIX &bsol;* %zu -> %Iu */
2326              "mem_clients_slaves:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2327              "mem_clients_normal:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2328              "mem_aof_buffer:%Iu\r\n"			WIN_PORT_FIX &bsol;* %zu -> %Iu */
2329              "mem_allocator:%s\r\n"
2330              "active_defrag_running:%d\r\n"
2331              "lazyfree_pending_objects:%Iu\r\n", WIN_PORT_FIX &bsol;* %zu -> %Iu */
2332              zmalloc_used,
2333              hmem,
2334              server.cron_malloc_stats.process_rss,
2335              used_memory_rss_hmem,
2336              server.stat_peak_memory,
2337              peak_hmem,
2338              mh->peak_perc,
2339              mh->overhead_total,
2340              mh->startup_allocated,
2341              mh->dataset,
2342              mh->dataset_perc,
2343              server.cron_malloc_stats.allocator_allocated,
2344              server.cron_malloc_stats.allocator_active,
2345              server.cron_malloc_stats.allocator_resident,
2346              (PORT_ULONG)total_system_mem,
2347              total_system_hmem,
2348              memory_lua,
2349              used_memory_lua_hmem,
2350              (PORT_LONGLONG) mh->lua_caches,
2351              used_memory_scripts_hmem,
2352              dictSize(server.lua_scripts),
2353              server.maxmemory,
2354              maxmemory_hmem,
2355              evict_policy,
2356              mh->allocator_frag,
2357              mh->allocator_frag_bytes,
2358              mh->allocator_rss,
2359              mh->allocator_rss_bytes,
2360              mh->rss_extra,
2361              mh->rss_extra_bytes,
2362              mh->total_frag, &bsol;* this is the total RSS overhead, including fragmentation, */
2363              mh->total_frag_bytes, &bsol;* named so for backwards compatibility */
2364              freeMemoryGetNotCountedMemory(),
2365              mh->repl_backlog,
2366              mh->clients_slaves,
2367              mh->clients_normal,
2368              mh->aof_buffer,
2369              ZMALLOC_LIB,
2370              server.active_defrag_running,
2371              lazyfreeGetPendingObjectsCount()
2372          );
2373          freeMemoryOverheadData(mh);
2374      }
2375      if (allsections || defsections || !strcasecmp(section,"persistence")) {
2376          if (sections++) info = sdscat(info,"\r\n");
2377          info = sdscatprintf(info,
2378              "# Persistence\r\n"
2379              "loading:%d\r\n"
2380              "rdb_changes_since_last_save:%lld\r\n"
2381              "rdb_bgsave_in_progress:%d\r\n"
2382              "rdb_last_save_time:%lld\r\n"                                       WIN_PORT_FIX &bsol;* %jd -> %lld */
2383              "rdb_last_bgsave_status:%s\r\n"
2384              "rdb_last_bgsave_time_sec:%lld\r\n"                                 WIN_PORT_FIX &bsol;* %jd -> %lld */
2385              "rdb_current_bgsave_time_sec:%lld\r\n"                              WIN_PORT_FIX &bsol;* %jd -> %lld */
2386              "rdb_last_cow_size:%Iu\r\n"                                         WIN_PORT_FIX &bsol;* %zu -> %Iu */
2387              "aof_enabled:%d\r\n"
2388              "aof_rewrite_in_progress:%d\r\n"
2389              "aof_rewrite_scheduled:%d\r\n"
2390              "aof_last_rewrite_time_sec:%lld\r\n"                                WIN_PORT_FIX &bsol;* %jd -> %lld */
2391              "aof_current_rewrite_time_sec:%lld\r\n"                             WIN_PORT_FIX &bsol;* %jd -> %lld */
2392              "aof_last_bgrewrite_status:%s\r\n"
2393              "aof_last_write_status:%s\r\n"
2394              "aof_last_cow_size:%Iu\r\n", WIN_PORT_FIX &bsol;* %zu -> %Iu */
2395              server.loading,
2396              server.dirty,
2397              server.rdb_child_pid != -1,
2398              (intmax_t)server.lastsave,
2399              (server.lastbgsave_status == C_OK) ? "ok" : "err",
2400              (intmax_t)server.rdb_save_time_last,
2401              (intmax_t)((server.rdb_child_pid == -1) ?
2402                  -1 : time(NULL)-server.rdb_save_time_start),
2403              server.stat_rdb_cow_bytes,
2404              server.aof_state != AOF_OFF,
2405              server.aof_child_pid != -1,
2406              server.aof_rewrite_scheduled,
2407              (intmax_t)server.aof_rewrite_time_last,
2408              (intmax_t)((server.aof_child_pid == -1) ?
2409                  -1 : time(NULL)-server.aof_rewrite_time_start),
2410              (server.aof_lastbgrewrite_status == C_OK) ? "ok" : "err",
2411              (server.aof_last_write_status == C_OK) ? "ok" : "err",
2412              server.stat_aof_cow_bytes);
2413          if (server.aof_state != AOF_OFF) {
2414              info = sdscatprintf(info,
2415                  "aof_current_size:%lld\r\n"
2416                  "aof_base_size:%lld\r\n"
2417                  "aof_pending_rewrite:%d\r\n"
2418                  "aof_buffer_length:%Iu\r\n"                                     WIN_PORT_FIX &bsol;* %zu -> %Iu */
2419                  "aof_rewrite_buffer_length:%Iu\r\n"                             WIN_PORT_FIX &bsol;* %lu -> %Iu */
2420                  "aof_pending_bio_fsync:%llu\r\n"
2421                  "aof_delayed_fsync:%Iu\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
2422                  (PORT_LONGLONG) server.aof_current_size,
2423                  (PORT_LONGLONG) server.aof_rewrite_base_size,
2424                  server.aof_rewrite_scheduled,
2425                  sdslen(server.aof_buf),
2426                  aofRewriteBufferSize(),
2427                  bioPendingJobsOfType(BIO_AOF_FSYNC),
2428                  server.aof_delayed_fsync);
2429          }
2430          if (server.loading) {
2431              double perc;
2432              time_t eta, elapsed;
2433              off_t remaining_bytes = server.loading_total_bytes-
2434                                      server.loading_loaded_bytes;
2435              perc = ((double)server.loading_loaded_bytes /
2436                     (server.loading_total_bytes+1)) * 100;
2437              elapsed = time(NULL)-server.loading_start_time;
2438              if (elapsed == 0) {
2439                  eta = 1; &bsol;* A fake 1 second figure if we don't have
2440                              enough info */
2441              } else {
2442                  eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);
2443              }
2444              info = sdscatprintf(info,
2445                  "loading_start_time:%jd\r\n"
2446                  "loading_total_bytes:%llu\r\n"
2447                  "loading_loaded_bytes:%llu\r\n"
2448                  "loading_loaded_perc:%.2f\r\n"
2449                  "loading_eta_seconds:%jd\r\n",
2450                  (intmax_t) server.loading_start_time,
2451                  (PORT_ULONGLONG) server.loading_total_bytes,
2452                  (PORT_ULONGLONG) server.loading_loaded_bytes,
2453                  perc,
2454                  (intmax_t)eta
2455              );
2456          }
2457      }
2458      if (allsections || defsections || !strcasecmp(section,"stats")) {
2459          if (sections++) info = sdscat(info,"\r\n");
2460          info = sdscatprintf(info,
2461              "# Stats\r\n"
2462              "total_connections_received:%lld\r\n"
2463              "total_commands_processed:%lld\r\n"
2464              "instantaneous_ops_per_sec:%lld\r\n"
2465              "total_net_input_bytes:%lld\r\n"
2466              "total_net_output_bytes:%lld\r\n"
2467              "instantaneous_input_kbps:%.2f\r\n"
2468              "instantaneous_output_kbps:%.2f\r\n"
2469              "rejected_connections:%lld\r\n"
2470              "sync_full:%lld\r\n"
2471              "sync_partial_ok:%lld\r\n"
2472              "sync_partial_err:%lld\r\n"
2473              "expired_keys:%lld\r\n"
2474              "expired_stale_perc:%.2f\r\n"
2475              "expired_time_cap_reached_count:%lld\r\n"
2476              "evicted_keys:%lld\r\n"
2477              "keyspace_hits:%lld\r\n"
2478              "keyspace_misses:%lld\r\n"
2479              "pubsub_channels:%Id\r\n"                                           WIN_PORT_FIX &bsol;* %ld -> %Id */
2480              "pubsub_patterns:%Iu\r\n"                                           WIN_PORT_FIX &bsol;* %lu -> %Iu */
2481              "latest_fork_usec:%lld\r\n"
2482              "migrate_cached_sockets:%Id\r\n"                                    WIN_PORT_FIX &bsol;* %ld -> %Id */
2483              "slave_expires_tracked_keys:%Iu\r\n"                                WIN_PORT_FIX &bsol;* %zu -> %Iu */
2484              "active_defrag_hits:%lld\r\n"
2485              "active_defrag_misses:%lld\r\n"
2486              "active_defrag_key_hits:%lld\r\n"
2487              "active_defrag_key_misses:%lld\r\n",
2488              server.stat_numconnections,
2489              server.stat_numcommands,
2490              getInstantaneousMetric(STATS_METRIC_COMMAND),
2491              server.stat_net_input_bytes,
2492              server.stat_net_output_bytes,
2493              (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,
2494              (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,
2495              server.stat_rejected_conn,
2496              server.stat_sync_full,
2497              server.stat_sync_partial_ok,
2498              server.stat_sync_partial_err,
2499              server.stat_expiredkeys,
2500              server.stat_expired_stale_perc*100,
2501              server.stat_expired_time_cap_reached_count,
2502              server.stat_evictedkeys,
2503              server.stat_keyspace_hits,
2504              server.stat_keyspace_misses,
2505              dictSize(server.pubsub_channels),
2506              listLength(server.pubsub_patterns),
2507              server.stat_fork_time,
2508              dictSize(server.migrate_cached_sockets),
2509              getSlaveKeyWithExpireCount(),
2510              server.stat_active_defrag_hits,
2511              server.stat_active_defrag_misses,
2512              server.stat_active_defrag_key_hits,
2513              server.stat_active_defrag_key_misses);
2514      }
2515      if (allsections || defsections || !strcasecmp(section,"replication")) {
2516          if (sections++) info = sdscat(info,"\r\n");
2517          info = sdscatprintf(info,
2518              "# Replication\r\n"
2519              "role:%s\r\n",
2520              server.masterhost == NULL ? "master" : "slave");
2521          if (server.masterhost) {
2522              PORT_LONGLONG slave_repl_offset = 1;
2523              if (server.master)
2524                  slave_repl_offset = server.master->reploff;
2525              else if (server.cached_master)
2526                  slave_repl_offset = server.cached_master->reploff;
2527              info = sdscatprintf(info,
2528                  "master_host:%s\r\n"
2529                  "master_port:%d\r\n"
2530                  "master_link_status:%s\r\n"
2531                  "master_last_io_seconds_ago:%d\r\n"
2532                  "master_sync_in_progress:%d\r\n"
2533                  "slave_repl_offset:%lld\r\n"
2534                  ,server.masterhost,
2535                  server.masterport,
2536                  (server.repl_state == REPL_STATE_CONNECTED) ?
2537                      "up" : "down",
2538                  server.master ?
2539                  ((int)(server.unixtime-server.master->lastinteraction)) : -1,
2540                  server.repl_state == REPL_STATE_TRANSFER,
2541                  slave_repl_offset
2542              );
2543              if (server.repl_state == REPL_STATE_TRANSFER) {
2544                  info = sdscatprintf(info,
2545                      "master_sync_left_bytes:%lld\r\n"
2546                      "master_sync_last_io_seconds_ago:%d\r\n"
2547                      , (PORT_LONGLONG)
2548                          (server.repl_transfer_size - server.repl_transfer_read),
2549                      (int)(server.unixtime-server.repl_transfer_lastio)
2550                  );
2551              }
2552              if (server.repl_state != REPL_STATE_CONNECTED) {
2553                  info = sdscatprintf(info,
2554                      "master_link_down_since_seconds:%jd\r\n",
2555                      (intmax_t)server.unixtime-server.repl_down_since);
2556              }
2557              info = sdscatprintf(info,
2558                  "slave_priority:%d\r\n"
2559                  "slave_read_only:%d\r\n",
2560                  server.slave_priority,
2561                  server.repl_slave_ro);
2562          }
2563          info = sdscatprintf(info,
2564              "connected_slaves:%Iu\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
2565              listLength(server.slaves));
2566          if (server.repl_min_slaves_to_write &&
2567              server.repl_min_slaves_max_lag) {
2568              info = sdscatprintf(info,
2569                  "min_slaves_good_slaves:%d\r\n",
2570                  server.repl_good_slaves_count);
2571          }
2572          if (listLength(server.slaves)) {
2573              int slaveid = 0;
2574              listNode *ln;
2575              listIter li;
2576              listRewind(server.slaves,&li);
2577              while((ln = listNext(&li))) {
2578                  client *slave = listNodeValue(ln);
2579                  char *state = NULL;
2580                  char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;
2581                  int port;
2582                  PORT_LONG lag = 0;
2583                  if (slaveip[0] == '\0') {
2584                      if (anetPeerToString(slave->fd,ip,sizeof(ip),&port) == -1)
2585                          continue;
2586                      slaveip = ip;
2587                  }
2588                  switch(slave->replstate) {
2589                  case SLAVE_STATE_WAIT_BGSAVE_START:
2590                  case SLAVE_STATE_WAIT_BGSAVE_END:
2591                      state = "wait_bgsave";
2592                      break;
2593                  case SLAVE_STATE_SEND_BULK:
2594                      state = "send_bulk";
2595                      break;
2596                  case SLAVE_STATE_ONLINE:
2597                      state = "online";
2598                      break;
2599                  }
2600                  if (state == NULL) continue;
2601                  if (slave->replstate == SLAVE_STATE_ONLINE)
2602                      lag = (PORT_LONG) (time(NULL) - slave->repl_ack_time);       WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
2603                  info = sdscatprintf(info,
2604                      "slave%d:ip=%s,port=%d,state=%s,"
2605                      "offset=%lld,lag=%Id\r\n", WIN_PORT_FIX &bsol;* %ld -> %Id */
2606                      slaveid,slaveip,slave->slave_listening_port,state,
2607                      slave->repl_ack_off, lag);
2608                  slaveid++;
2609              }
2610          }
2611          info = sdscatprintf(info,
2612              "master_replid:%s\r\n"
2613              "master_replid2:%s\r\n"
2614              "master_repl_offset:%lld\r\n"
2615              "second_repl_offset:%lld\r\n"
2616              "repl_backlog_active:%d\r\n"
2617              "repl_backlog_size:%lld\r\n"
2618              "repl_backlog_first_byte_offset:%lld\r\n"
2619              "repl_backlog_histlen:%lld\r\n",
2620              server.replid,
2621              server.replid2,
2622              server.master_repl_offset,
2623              server.second_replid_offset,
2624              server.repl_backlog != NULL,
2625              server.repl_backlog_size,
2626              server.repl_backlog_off,
2627              server.repl_backlog_histlen);
2628      }
2629      if (allsections || defsections || !strcasecmp(section,"cpu")) {
2630          if (sections++) info = sdscat(info,"\r\n");
2631          info = sdscatprintf(info,
2632          "# CPU\r\n"
2633          "used_cpu_sys:%ld.%06ld\r\n"
2634          "used_cpu_user:%ld.%06ld\r\n"
2635          "used_cpu_sys_children:%ld.%06ld\r\n"
2636          "used_cpu_user_children:%ld.%06ld\r\n",
2637          (PORT_LONG)self_ru.ru_stime.tv_sec, (PORT_LONG)self_ru.ru_stime.tv_usec,
2638          (PORT_LONG)self_ru.ru_utime.tv_sec, (PORT_LONG)self_ru.ru_utime.tv_usec,
2639          (PORT_LONG)c_ru.ru_stime.tv_sec, (PORT_LONG)c_ru.ru_stime.tv_usec,
2640          (PORT_LONG)c_ru.ru_utime.tv_sec, (PORT_LONG)c_ru.ru_utime.tv_usec);
2641      }
2642      if (allsections || !strcasecmp(section,"commandstats")) {
2643          if (sections++) info = sdscat(info,"\r\n");
2644          info = sdscatprintf(info, "# Commandstats\r\n");
2645          struct redisCommand *c;
2646          dictEntry *de;
2647          dictIterator *di;
2648          di = dictGetSafeIterator(server.commands);
2649          while((de = dictNext(di)) != NULL) {
2650              c = (struct redisCommand *) dictGetVal(de);
2651              if (!c->calls) continue;
2652              info = sdscatprintf(info,
2653                  "cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f\r\n",
2654                  c->name, c->calls, c->microseconds,
2655                  (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls));
2656          }
2657          dictReleaseIterator(di);
2658      }
2659      if (allsections || defsections || !strcasecmp(section,"cluster")) {
2660          if (sections++) info = sdscat(info,"\r\n");
2661          info = sdscatprintf(info,
2662          "# Cluster\r\n"
2663          "cluster_enabled:%d\r\n",
2664          server.cluster_enabled);
2665      }
2666      if (allsections || defsections || !strcasecmp(section,"keyspace")) {
2667          if (sections++) info = sdscat(info,"\r\n");
2668          info = sdscatprintf(info, "# Keyspace\r\n");
2669          for (j = 0; j < server.dbnum; j++) {
2670              PORT_LONGLONG keys, vkeys;
2671              keys = dictSize(server.db[j].dict);
2672              vkeys = dictSize(server.db[j].expires);
2673              if (keys || vkeys) {
2674                  info = sdscatprintf(info,
2675                      "db%d:keys=%lld,expires=%lld,avg_ttl=%lld\r\n",
2676                      j, keys, vkeys, server.db[j].avg_ttl);
2677              }
2678          }
2679      }
2680      return info;
2681  }
2682  void infoCommand(client *c) {
2683      char *section = c->argc == 2 ? c->argv[1]->ptr : "default";
2684      if (c->argc > 2) {
2685          addReply(c,shared.syntaxerr);
2686          return;
2687      }
2688      addReplyBulkSds(c, genRedisInfoString(section));
2689  }
2690  void monitorCommand(client *c) {
2691      if (c->flags & CLIENT_SLAVE) return;
2692      c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);
2693      listAddNodeTail(server.monitors,c);
2694      addReply(c,shared.ok);
2695  }
2696  #ifdef __linux__
2697  int linuxOvercommitMemoryValue(void) {
2698      FILE *fp = fopen("/proc/sys/vm/overcommit_memory","r");
2699      char buf[64];
2700      if (!fp) return -1;
2701      if (fgets(buf,64,fp) == NULL) {
2702          fclose(fp);
2703          return -1;
2704      }
2705      fclose(fp);
2706      return atoi(buf);
2707  }
2708  void linuxMemoryWarnings(void) {
2709      if (linuxOvercommitMemoryValue() == 0) {
2710          serverLog(LL_WARNING,"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.");
2711      }
2712      if (THPIsEnabled()) {
2713          serverLog(LL_WARNING,"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.");
2714      }
2715  }
2716  #endif &bsol;* __linux__ */
2717  void createPidFile(void) {
2718      if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);
2719      FILE *fp = fopen(server.pidfile,"w");
2720      if (fp) {
2721          fprintf(fp,"%d\n",(int)getpid());
2722          fclose(fp);
2723      }
2724  }
2725  void daemonize(void) {
2726  #ifdef _WIN32
2727      serverLog(LL_WARNING, "Windows does not support daemonize. Start Redis as service");
2728  #else
2729      int fd;
2730      if (fork() != 0) exit(0); &bsol;* parent exits */
2731      setsid(); &bsol;* create a new session */
2732      if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
2733          dup2(fd, STDIN_FILENO);
2734          dup2(fd, STDOUT_FILENO);
2735          dup2(fd, STDERR_FILENO);
2736          if (fd > STDERR_FILENO) close(fd);
2737      }
2738  #endif
2739  }
2740  void version(void) {
2741      printf("Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\n",
2742          REDIS_VERSION,
2743          redisGitSHA1(),
2744          atoi(redisGitDirty()) > 0,
2745          ZMALLOC_LIB,
2746          sizeof(PORT_LONG) == 4 ? 32 : 64,
2747          (PORT_ULONGLONG) redisBuildId());
2748      exit(0);
2749  }
2750  void usage(void) {
2751      fprintf(stderr,"Usage: ./redis-server [/path/to/redis.conf] [options]\n");
2752      fprintf(stderr,"       ./redis-server - (read config from stdin)\n");
2753      fprintf(stderr,"       ./redis-server -v or --version\n");
2754      fprintf(stderr,"       ./redis-server -h or --help\n");
2755      fprintf(stderr,"       ./redis-server --test-memory <megabytes>\n\n");
2756      fprintf(stderr,"Examples:\n");
2757      fprintf(stderr,"       ./redis-server (run the server with default conf)\n");
2758      fprintf(stderr,"       ./redis-server /etc/redis/6379.conf\n");
2759      fprintf(stderr,"       ./redis-server --port 7777\n");
2760      fprintf(stderr,"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\n");
2761      fprintf(stderr,"       ./redis-server /etc/myredis.conf --loglevel verbose\n\n");
2762      fprintf(stderr,"Sentinel mode:\n");
2763      fprintf(stderr,"       ./redis-server /etc/sentinel.conf --sentinel\n");
2764      exit(1);
2765  }
2766  void redisAsciiArt(void) {
2767  #include "asciilogo.h"
2768      char *buf = zmalloc(1024*16);
2769      char *mode;
2770      if (server.cluster_enabled) mode = "cluster";
2771      else if (server.sentinel_mode) mode = "sentinel";
2772      else mode = "standalone";
2773      int show_logo = ((!server.syslog_enabled &&
2774                        server.logfile[0] == '\0' &&
2775                        isatty(fileno(stdout))) ||
2776                       server.always_show_logo);
2777      if (!show_logo) {
2778          serverLog(LL_NOTICE,
2779              "Running mode=%s, port=%d.",
2780              mode, server.port
2781          );
2782      } else {
2783          snprintf(buf,1024*16,ascii_logo,
2784              REDIS_VERSION,
2785              redisGitSHA1(),
2786              strtol(redisGitDirty(),NULL,10) > 0,
2787              (sizeof(PORT_LONG) == 8) ? "64" : "32",
2788              mode, server.port,
2789              (PORT_LONG) getpid()
2790          );
2791          serverLogRaw(LL_NOTICE|LL_RAW,buf);
2792      }
2793      zfree(buf);
2794  }
2795  static void sigShutdownHandler(int sig) {
2796      char *msg;
2797      switch (sig) {
2798      case SIGINT:
2799          msg = "Received SIGINT scheduling shutdown...";
2800          break;
2801      case SIGTERM:
2802          msg = "Received SIGTERM scheduling shutdown...";
2803          break;
2804      default:
2805          msg = "Received shutdown signal, scheduling shutdown...";
2806      };
2807      if (server.shutdown_asap && sig == SIGINT) {
2808          serverLogFromHandler(LL_WARNING, "You insist... exiting now.");
2809          rdbRemoveTempFile(getpid());
2810          exit(1); &bsol;* Exit with an error since this was not a clean shutdown. */
2811      } else if (server.loading) {
2812          serverLogFromHandler(LL_WARNING, "Received shutdown signal during loading, exiting now.");
2813          exit(0);
2814      }
2815      serverLogFromHandler(LL_WARNING, msg);
2816      server.shutdown_asap = 1;
2817  }
2818  void setupSignalHandlers(void) {
2819      struct sigaction act;
2820      sigemptyset(&act.sa_mask);
2821      act.sa_flags = 0;
2822      act.sa_handler = sigShutdownHandler;
2823      sigaction(SIGTERM, &act, NULL);
2824      sigaction(SIGINT, &act, NULL);
2825  #ifdef HAVE_BACKTRACE
2826      sigemptyset(&act.sa_mask);
2827      act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
2828      act.sa_sigaction = sigsegvHandler;
2829      sigaction(SIGSEGV, &act, NULL);
2830      sigaction(SIGBUS, &act, NULL);
2831      sigaction(SIGFPE, &act, NULL);
2832      sigaction(SIGILL, &act, NULL);
2833  #endif
2834      return;
2835  }
2836  void memtest(size_t megabytes, int passes);
2837  int checkForSentinelMode(int argc, char **argv) {
2838      int j;
2839      if (strstr(argv[0],"redis-sentinel") != NULL) return 1;
2840      for (j = 1; j < argc; j++)
2841          if (!strcmp(argv[j],"--sentinel")) return 1;
2842      return 0;
2843  }
2844  void loadDataFromDisk(void) {
2845      PORT_LONGLONG start = ustime();
2846      if (server.aof_state == AOF_ON) {
2847          if (loadAppendOnlyFile(server.aof_filename) == C_OK)
2848              serverLog(LL_NOTICE,"DB loaded from append only file: %.3f seconds",(float)(ustime()-start)/1000000);
2849      } else {
2850          rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
2851          if (rdbLoad(server.rdb_filename,&rsi) == C_OK) {
2852              serverLog(LL_NOTICE,"DB loaded from disk: %.3f seconds",
2853                  (float)(ustime()-start)/1000000);
2854              if ((server.masterhost ||
2855                  (server.cluster_enabled &&
2856                  nodeIsSlave(server.cluster->myself))) &&
2857                  rsi.repl_id_is_set &&
2858                  rsi.repl_offset != -1 &&
2859                  rsi.repl_stream_db != -1)
2860              {
2861                  memcpy(server.replid,rsi.repl_id,sizeof(server.replid));
2862                  server.master_repl_offset = rsi.repl_offset;
2863                  replicationCacheMasterUsingMyself();
2864                  selectDb(server.cached_master,rsi.repl_stream_db);
2865              }
2866          } else if (errno != ENOENT) {
2867              serverLog(LL_WARNING,"Fatal error loading the DB: %s. Exiting.", IF_WIN32(wsa_strerror(errno), strerror(errno)));
2868              exit(1);
2869          }
2870      }
2871  }
2872  void redisOutOfMemoryHandler(size_t allocation_size) {
2873      WIN32_ONLY(bugReportStart();)
2874      serverLog(LL_WARNING,"Out Of Memory allocating %Iu bytes!", WIN_PORT_FIX &bsol;* %zu -> %Iu */
2875          allocation_size);
2876      IF_WIN32(abort(), serverPanic("Redis aborting for OUT OF MEMORY"));
2877  }
2878  void redisSetProcTitle(char *title) {
2879  #ifdef USE_SETPROCTITLE
2880      char *server_mode = "";
2881      if (server.cluster_enabled) server_mode = " [cluster]";
2882      else if (server.sentinel_mode) server_mode = " [sentinel]";
2883      setproctitle("%s %s:%d%s",
2884          title,
2885          server.bindaddr_count ? server.bindaddr[0] : "*",
2886          server.port,
2887          server_mode);
2888  #else
2889      UNUSED(title);
2890  #endif
2891  }
2892  int redisSupervisedUpstart(void) {
2893  #ifndef _WIN32
2894      const char *upstart_job = getenv("UPSTART_JOB");
2895      if (!upstart_job) {
2896          serverLog(LL_WARNING,
2897                  "upstart supervision requested, but UPSTART_JOB not found");
2898          return 0;
2899      }
2900      serverLog(LL_NOTICE, "supervised by upstart, will stop to signal readiness");
2901      raise(SIGSTOP);
2902      unsetenv("UPSTART_JOB");
2903      return 1;
2904  #endif
2905      return 0;
2906  }
2907  int redisSupervisedSystemd(void) {
2908  #ifndef _WIN32
2909      const char *notify_socket = getenv("NOTIFY_SOCKET");
2910      int fd = 1;
2911      struct sockaddr_un su;
2912      struct iovec iov;
2913      struct msghdr hdr;
2914      int sendto_flags = 0;
2915      if (!notify_socket) {
2916          serverLog(LL_WARNING,
2917                  "systemd supervision requested, but NOTIFY_SOCKET not found");
2918          return 0;
2919      }
2920      if ((strchr("@/", notify_socket[0])) == NULL || strlen(notify_socket) < 2) {
2921          return 0;
2922      }
2923      serverLog(LL_NOTICE, "supervised by systemd, will signal readiness");
2924      if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {
2925          serverLog(LL_WARNING,
2926                  "Can't connect to systemd socket %s", notify_socket);
2927          return 0;
2928      }
2929      memset(&su, 0, sizeof(su));
2930      su.sun_family = AF_UNIX;
2931      strncpy (su.sun_path, notify_socket, sizeof(su.sun_path) -1);
2932      su.sun_path[sizeof(su.sun_path) - 1] = '\0';
2933      if (notify_socket[0] == '@')
2934          su.sun_path[0] = '\0';
2935      memset(&iov, 0, sizeof(iov));
2936      iov.iov_base = "READY=1";
2937      iov.iov_len = strlen("READY=1");
2938      memset(&hdr, 0, sizeof(hdr));
2939      hdr.msg_name = &su;
2940      hdr.msg_namelen = offsetof(struct sockaddr_un, sun_path) +
2941          strlen(notify_socket);
2942      hdr.msg_iov = &iov;
2943      hdr.msg_iovlen = 1;
2944      unsetenv("NOTIFY_SOCKET");
2945  #ifdef HAVE_MSG_NOSIGNAL
2946      sendto_flags |= MSG_NOSIGNAL;
2947  #endif
2948      if (sendmsg(fd, &hdr, sendto_flags) < 0) {
2949          serverLog(LL_WARNING, "Can't send notification to systemd");
2950          close(fd);
2951          return 0;
2952      }
2953      close(fd);
2954      return 1;
2955  #endif
2956      return 0;
2957  }
2958  int redisIsSupervised(int mode) {
2959      if (mode == SUPERVISED_AUTODETECT) {
2960          const char *upstart_job = getenv("UPSTART_JOB");
2961          const char *notify_socket = getenv("NOTIFY_SOCKET");
2962          if (upstart_job) {
2963              redisSupervisedUpstart();
2964          } else if (notify_socket) {
2965              redisSupervisedSystemd();
2966          }
2967      } else if (mode == SUPERVISED_UPSTART) {
2968          return redisSupervisedUpstart();
2969      } else if (mode == SUPERVISED_SYSTEMD) {
2970          return redisSupervisedSystemd();
2971      }
2972      return 0;
2973  }
2974  int main(int argc, char **argv) {
2975      struct timeval tv;
2976      int j;
2977  #ifdef REDIS_TEST
2978      if (argc == 3 && !strcasecmp(argv[1], "test")) {
2979          if (!strcasecmp(argv[2], "ziplist")) {
2980              return ziplistTest(argc, argv);
2981          } else if (!strcasecmp(argv[2], "quicklist")) {
2982              quicklistTest(argc, argv);
2983          } else if (!strcasecmp(argv[2], "intset")) {
2984              return intsetTest(argc, argv);
2985          } else if (!strcasecmp(argv[2], "zipmap")) {
2986              return zipmapTest(argc, argv);
2987          } else if (!strcasecmp(argv[2], "sha1test")) {
2988              return sha1Test(argc, argv);
2989          } else if (!strcasecmp(argv[2], "util")) {
2990              return utilTest(argc, argv);
2991          } else if (!strcasecmp(argv[2], "endianconv")) {
2992              return endianconvTest(argc, argv);
2993          } else if (!strcasecmp(argv[2], "crc64")) {
2994              return crc64Test(argc, argv);
2995          } else if (!strcasecmp(argv[2], "zmalloc")) {
2996              return zmalloc_test(argc, argv);
2997          }
2998          return -1; &bsol;* test not found */
2999      }
3000  #endif
3001  #ifdef INIT_SETPROCTITLE_REPLACEMENT
3002      spt_init(argc, argv);
3003  #endif
3004      setlocale(LC_COLLATE,"");
3005      tzset(); &bsol;* Populates 'timezone' global. */
3006      zmalloc_set_oom_handler(redisOutOfMemoryHandler);
3007  #ifdef _WIN32
3008  #pragma warning( suppress : 6031 )
3009      pthread_mutex_init(&lazyfree_objects_mutex, NULL);
3010  #pragma warning( suppress : 6031 )
3011      pthread_mutex_init(&moduleUnblockedClientsMutex, NULL);
3012  #pragma warning( suppress : 6031 )
3013      pthread_mutex_init(&moduleGIL, NULL);
3014  #endif
3015      srand((unsigned int)time(NULL)^getpid());  WIN_PORT_FIX &bsol;* cast (unsigned int) */
3016      gettimeofday(&tv,NULL);
3017      char hashseed[16];
3018      getRandomHexChars(hashseed,sizeof(hashseed));
3019      dictSetHashFunctionSeed((uint8_t*)hashseed);
3020      server.sentinel_mode = checkForSentinelMode(argc,argv);
3021      initServerConfig();
3022      moduleInitModulesSystem();
3023      server.executable = getAbsolutePath(argv[0]);
3024      server.exec_argv = zmalloc(sizeof(char*)*((size_t)argc+1));
3025      server.exec_argv[argc] = NULL;
3026      for (j = 0; j < argc; j++) server.exec_argv[j] = zstrdup(argv[j]);
3027      if (server.sentinel_mode) {
3028          initSentinelConfig();
3029          initSentinel();
3030      }
3031      if (strstr(argv[0],"redis-check-rdb") != NULL)
3032  #ifdef _WIN32
3033          return
3034  #endif
3035          redis_check_rdb_main(argc,argv,NULL);
3036      else if (strstr(argv[0],"redis-check-aof") != NULL)
3037  #ifdef _WIN32
3038          return
3039  #endif
3040          redis_check_aof_main(argc,argv);
3041      if (argc >= 2) {
3042          j = 1; &bsol;* First option to parse in argv[] */
3043          sds options = sdsempty();
3044          char *configfile = NULL;
3045          if (strcmp(argv[1], "-v") == 0 ||
3046              strcmp(argv[1], "--version") == 0) version();
3047          if (strcmp(argv[1], "--help") == 0 ||
3048              strcmp(argv[1], "-h") == 0) usage();
3049          if (strcmp(argv[1], "--test-memory") == 0) {
3050              if (argc == 3) {
3051                  memtest(atoi(argv[2]), IF_WIN32(5, 50));
3052                  exit(0);
3053              } else {
3054                  fprintf(stderr,"Please specify the amount of memory to test in megabytes.\n");
3055                  fprintf(stderr,"Example: ./redis-server --test-memory 4096\n\n");
3056                  exit(1);
3057              }
3058          }
3059          if (argv[j][0] != '-' || argv[j][1] != '-') {
3060              configfile = argv[j];
3061              server.configfile = getAbsolutePath(configfile);
3062              zfree(server.exec_argv[j]);
3063              server.exec_argv[j] = zstrdup(server.configfile);
3064              j++;
3065          }
3066          while(j != argc) {
3067              if (argv[j][0] == '-' && argv[j][1] == '-') {
3068                  if (!strcmp(argv[j], "--check-rdb")) {
3069                      j++;
3070                      continue;
3071                  }
3072                  if (sdslen(options)) options = sdscat(options,"\n");
3073                  options = sdscat(options,argv[j]+2);
3074                  options = sdscat(options," ");
3075              } else {
3076                  options = sdscatrepr(options,argv[j],strlen(argv[j]));
3077                  options = sdscat(options," ");
3078              }
3079              j++;
3080          }
3081          if (server.sentinel_mode && configfile && *configfile == '-') {
3082              serverLog(LL_WARNING,
3083                  "Sentinel config from STDIN not allowed.");
3084              serverLog(LL_WARNING,
3085                  "Sentinel needs config file on disk to save state.  Exiting...");
3086              exit(1);
3087          }
3088          resetServerSaveParams();
3089          loadServerConfig(configfile,options);
3090          sdsfree(options);
3091      }
3092      serverLog(LL_WARNING, "oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo");
3093      serverLog(LL_WARNING,
3094          "Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started",
3095              REDIS_VERSION,
3096              (sizeof(PORT_LONG) == 8) ? 64 : 32,
3097              redisGitSHA1(),
3098              strtol(redisGitDirty(),NULL,10) > 0,
3099              (int)getpid());
3100      if (argc == 1) {
3101          serverLog(LL_WARNING, "Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf", argv[0], server.sentinel_mode ? "sentinel" : "redis");
3102      } else {
3103          serverLog(LL_WARNING, "Configuration loaded");
3104      }
3105      server.supervised = redisIsSupervised(server.supervised_mode);
3106      int background = server.daemonize && !server.supervised;
3107      if (background) daemonize();
3108      initServer();
3109      if (background || server.pidfile) createPidFile();
3110      redisSetProcTitle(argv[0]);
3111      redisAsciiArt();
3112      checkTcpBacklogSettings();
3113      if (!server.sentinel_mode) {
3114          serverLog(LL_WARNING,"Server initialized");
3115      #ifdef __linux__
3116          linuxMemoryWarnings();
3117      #endif
3118          moduleLoadFromQueue();
3119          InitServerLast();
3120          loadDataFromDisk();
3121          if (server.cluster_enabled) {
3122              if (verifyClusterConfigWithData() == C_ERR) {
3123                  serverLog(LL_WARNING,
3124                      "You can't have keys in a DB different than DB 0 when in "
3125                      "Cluster mode. Exiting.");
3126                  exit(1);
3127              }
3128          }
3129          if (server.ipfd_count > 0)
3130              serverLog(LL_NOTICE,"Ready to accept connections");
3131          if (server.sofd > 0)
3132              serverLog(LL_NOTICE,"The server is now ready to accept connections at %s", server.unixsocket);
3133      } else {
3134          InitServerLast();
3135          sentinelIsRunning();
3136      }
3137      if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {
3138          serverLog(LL_WARNING,"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?", server.maxmemory);
3139      }
3140      aeSetBeforeSleepProc(server.el,beforeSleep);
3141      aeSetAfterSleepProc(server.el,afterSleep);
3142      aeMain(server.el);
3143      aeDeleteEventLoop(server.el);
3144      return 0;
3145  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-lfs.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-server.c</div>
                </div>
                <div class="column column_space"><pre><code>51  static int lfs_cache_cmp(lfs_t *lfs, lfs_cache_t *rcache,
52          const lfs_cache_t *pcache, lfs_block_t block,
53          lfs_off_t off, const void *buffer, lfs_size_t size) {
54      const uint8_t *data = buffer;
</pre></code></div>
                <div class="column column_space"><pre><code>466      NULL,                       &bsol;* val dup */
467      dictSdsKeyCompare,          &bsol;* key compare */
468      NULL,                       &bsol;* key destructor */
469      NULL                        &bsol;* val destructor */
470  };
471  dictType commandTableDictType = {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    