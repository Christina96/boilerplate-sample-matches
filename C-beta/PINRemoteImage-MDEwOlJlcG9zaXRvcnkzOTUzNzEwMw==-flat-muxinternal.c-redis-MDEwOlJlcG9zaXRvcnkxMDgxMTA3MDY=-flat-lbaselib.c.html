
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.681914144968331%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-muxinternal.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/mux/muxi.h"
3  #include "src/utils/utils.h"
4  #define UNDEFINED_CHUNK_SIZE ((uint32_t)(-1))
5  const ChunkInfo kChunks[] = {
6    { MKFOURCC('V', 'P', '8', 'X'),  WEBP_CHUNK_VP8X,    VP8X_CHUNK_SIZE },
7    { MKFOURCC('I', 'C', 'C', 'P'),  WEBP_CHUNK_ICCP,    UNDEFINED_CHUNK_SIZE },
8    { MKFOURCC('A', 'N', 'I', 'M'),  WEBP_CHUNK_ANIM,    ANIM_CHUNK_SIZE },
9    { MKFOURCC('A', 'N', 'M', 'F'),  WEBP_CHUNK_ANMF,    ANMF_CHUNK_SIZE },
10    { MKFOURCC('A', 'L', 'P', 'H'),  WEBP_CHUNK_ALPHA,   UNDEFINED_CHUNK_SIZE },
11    { MKFOURCC('V', 'P', '8', ' '),  WEBP_CHUNK_IMAGE,   UNDEFINED_CHUNK_SIZE },
12    { MKFOURCC('V', 'P', '8', 'L'),  WEBP_CHUNK_IMAGE,   UNDEFINED_CHUNK_SIZE },
13    { MKFOURCC('E', 'X', 'I', 'F'),  WEBP_CHUNK_EXIF,    UNDEFINED_CHUNK_SIZE },
14    { MKFOURCC('X', 'M', 'P', ' '),  WEBP_CHUNK_XMP,     UNDEFINED_CHUNK_SIZE },
15    { NIL_TAG,                       WEBP_CHUNK_UNKNOWN, UNDEFINED_CHUNK_SIZE },
16    { NIL_TAG,                       WEBP_CHUNK_NIL,     UNDEFINED_CHUNK_SIZE }
17  };
18  int WebPGetMuxVersion(void) {
19    return (MUX_MAJ_VERSION << 16) | (MUX_MIN_VERSION << 8) | MUX_REV_VERSION;
20  }
21  void ChunkInit(WebPChunk* const chunk) {
22    assert(chunk);
23    memset(chunk, 0, sizeof(*chunk));
24    chunk->tag_ = NIL_TAG;
25  }
26  WebPChunk* ChunkRelease(WebPChunk* const chunk) {
27    WebPChunk* next;
28    if (chunk == NULL) return NULL;
29    if (chunk->owner_) {
30      WebPDataClear(&chunk->data_);
31    }
32    next = chunk->next_;
33    ChunkInit(chunk);
34    return next;
35  }
36  CHUNK_INDEX ChunkGetIndexFromTag(uint32_t tag) {
37    int i;
38    for (i = 0; kChunks[i].tag != NIL_TAG; ++i) {
39      if (tag == kChunks[i].tag) return (CHUNK_INDEX)i;
40    }
41    return IDX_UNKNOWN;
42  }
43  WebPChunkId ChunkGetIdFromTag(uint32_t tag) {
44    int i;
45    for (i = 0; kChunks[i].tag != NIL_TAG; ++i) {
46      if (tag == kChunks[i].tag) return kChunks[i].id;
47    }
48    return WEBP_CHUNK_UNKNOWN;
49  }
50  uint32_t ChunkGetTagFromFourCC(const char fourcc[4]) {
51    return MKFOURCC(fourcc[0], fourcc[1], fourcc[2], fourcc[3]);
52  }
53  CHUNK_INDEX ChunkGetIndexFromFourCC(const char fourcc[4]) {
54    const uint32_t tag = ChunkGetTagFromFourCC(fourcc);
55    return ChunkGetIndexFromTag(tag);
56  }
57  static WebPChunk* ChunkSearchNextInList(WebPChunk* chunk, uint32_t tag) {
58    while (chunk != NULL && chunk->tag_ != tag) {
59      chunk = chunk->next_;
60    }
61    return chunk;
62  }
63  WebPChunk* ChunkSearchList(WebPChunk* first, uint32_t nth, uint32_t tag) {
64    uint32_t iter = nth;
65    first = ChunkSearchNextInList(first, tag);
66    if (first == NULL) return NULL;
67    while (--iter != 0) {
68      WebPChunk* next_chunk = ChunkSearchNextInList(first->next_, tag);
69      if (next_chunk == NULL) break;
70      first = next_chunk;
71    }
72    return ((nth > 0) && (iter > 0)) ? NULL : first;
73  }
74  WebPMuxError ChunkAssignData(WebPChunk* chunk, const WebPData* const data,
75                               int copy_data, uint32_t tag) {
76    if (tag == kChunks[IDX_VP8X].tag || tag == kChunks[IDX_ANIM].tag) {
77      copy_data = 1;
78    }
79    ChunkRelease(chunk);
80    if (data != NULL) {
81      if (copy_data) {        
82        if (!WebPDataCopy(data, &chunk->data_)) return WEBP_MUX_MEMORY_ERROR;
83        chunk->owner_ = 1;    
84      } else {                
85        chunk->data_ = *data;
86      }
87    }
88    chunk->tag_ = tag;
89    return WEBP_MUX_OK;
90  }
91  WebPMuxError ChunkSetHead(WebPChunk* const chunk,
92                            WebPChunk** const chunk_list) {
93    WebPChunk* new_chunk;
94    assert(chunk_list != NULL);
95    if (*chunk_list != NULL) {
96      return WEBP_MUX_NOT_FOUND;
97    }
98    new_chunk = (WebPChunk*)WebPSafeMalloc(1ULL, sizeof(*new_chunk));
99    if (new_chunk == NULL) return WEBP_MUX_MEMORY_ERROR;
100    *new_chunk = *chunk;
101    chunk->owner_ = 0;
102    new_chunk->next_ = NULL;
103    *chunk_list = new_chunk;
104    return WEBP_MUX_OK;
105  }
106  WebPMuxError ChunkAppend(WebPChunk* const chunk,
107                           WebPChunk*** const chunk_list) {
108    assert(chunk_list != NULL && *chunk_list != NULL);
109    if (**chunk_list == NULL) {
110      ChunkSetHead(chunk, *chunk_list);
111    } else {
112      WebPChunk* last_chunk = **chunk_list;
113      while (last_chunk->next_ != NULL) last_chunk = last_chunk->next_;
114      ChunkSetHead(chunk, &last_chunk->next_);
115      *chunk_list = &last_chunk->next_;
116    }
117    return WEBP_MUX_OK;
118  }
119  WebPChunk* ChunkDelete(WebPChunk* const chunk) {
120    WebPChunk* const next = ChunkRelease(chunk);
121    WebPSafeFree(chunk);
122    return next;
123  }
124  void ChunkListDelete(WebPChunk** const chunk_list) {
125    while (*chunk_list != NULL) {
126      *chunk_list = ChunkDelete(*chunk_list);
127    }
<span onclick='openModal()' class='match'>128  }
129  static uint8_t* ChunkEmit(const WebPChunk* const chunk, uint8_t* dst) {
130    const size_t chunk_size = chunk->data_.size;
131    assert(chunk);
132    assert(chunk->tag_ != NIL_TAG);
133    PutLE32(dst + 0, chunk->tag_);
134    PutLE32(dst + TAG_SIZE, (uint32_t)chunk_size);
135    assert(chunk_size == (uint32_t)chunk_size);
</span>136    memcpy(dst + CHUNK_HEADER_SIZE, chunk->data_.bytes, chunk_size);
137    if (chunk_size & 1)
138      dst[CHUNK_HEADER_SIZE + chunk_size] = 0;  
139    return dst + ChunkDiskSize(chunk);
140  }
141  uint8_t* ChunkListEmit(const WebPChunk* chunk_list, uint8_t* dst) {
142    while (chunk_list != NULL) {
143      dst = ChunkEmit(chunk_list, dst);
144      chunk_list = chunk_list->next_;
145    }
146    return dst;
147  }
148  size_t ChunkListDiskSize(const WebPChunk* chunk_list) {
149    size_t size = 0;
150    while (chunk_list != NULL) {
151      size += ChunkDiskSize(chunk_list);
152      chunk_list = chunk_list->next_;
153    }
154    return size;
155  }
156  void MuxImageInit(WebPMuxImage* const wpi) {
157    assert(wpi);
158    memset(wpi, 0, sizeof(*wpi));
159  }
160  WebPMuxImage* MuxImageRelease(WebPMuxImage* const wpi) {
161    WebPMuxImage* next;
162    if (wpi == NULL) return NULL;
163    ChunkListDelete(&wpi->header_);
164    ChunkListDelete(&wpi->alpha_);
165    ChunkListDelete(&wpi->img_);
166    ChunkListDelete(&wpi->unknown_);
167    next = wpi->next_;
168    MuxImageInit(wpi);
169    return next;
170  }
171  static WebPChunk** GetChunkListFromId(const WebPMuxImage* const wpi,
172                                        WebPChunkId id) {
173    assert(wpi != NULL);
174    switch (id) {
175      case WEBP_CHUNK_ANMF:  return (WebPChunk**)&wpi->header_;
176      case WEBP_CHUNK_ALPHA: return (WebPChunk**)&wpi->alpha_;
177      case WEBP_CHUNK_IMAGE: return (WebPChunk**)&wpi->img_;
178      default: return NULL;
179    }
180  }
181  int MuxImageCount(const WebPMuxImage* wpi_list, WebPChunkId id) {
182    int count = 0;
183    const WebPMuxImage* current;
184    for (current = wpi_list; current != NULL; current = current->next_) {
185      if (id == WEBP_CHUNK_NIL) {
186        ++count;  
187      } else {
188        const WebPChunk* const wpi_chunk = *GetChunkListFromId(current, id);
189        if (wpi_chunk != NULL) {
190          const WebPChunkId wpi_chunk_id = ChunkGetIdFromTag(wpi_chunk->tag_);
191          if (wpi_chunk_id == id) ++count;  
192        }
193      }
194    }
195    return count;
196  }
197  static int SearchImageToGetOrDelete(WebPMuxImage** wpi_list, uint32_t nth,
198                                      WebPMuxImage*** const location) {
199    uint32_t count = 0;
200    assert(wpi_list);
201    *location = wpi_list;
202    if (nth == 0) {
203      nth = MuxImageCount(*wpi_list, WEBP_CHUNK_NIL);
204      if (nth == 0) return 0;  
205    }
206    while (*wpi_list != NULL) {
207      WebPMuxImage* const cur_wpi = *wpi_list;
208      ++count;
209      if (count == nth) return 1;  
210      wpi_list = &cur_wpi->next_;
211      *location = wpi_list;
212    }
213    return 0;  
214  }
215  WebPMuxError MuxImagePush(const WebPMuxImage* wpi, WebPMuxImage** wpi_list) {
216    WebPMuxImage* new_wpi;
217    while (*wpi_list != NULL) {
218      WebPMuxImage* const cur_wpi = *wpi_list;
219      if (cur_wpi->next_ == NULL) break;
220      wpi_list = &cur_wpi->next_;
221    }
222    new_wpi = (WebPMuxImage*)WebPSafeMalloc(1ULL, sizeof(*new_wpi));
223    if (new_wpi == NULL) return WEBP_MUX_MEMORY_ERROR;
224    *new_wpi = *wpi;
225    new_wpi->next_ = NULL;
226    if (*wpi_list != NULL) {
227      (*wpi_list)->next_ = new_wpi;
228    } else {
229      *wpi_list = new_wpi;
230    }
231    return WEBP_MUX_OK;
232  }
233  WebPMuxImage* MuxImageDelete(WebPMuxImage* const wpi) {
234    WebPMuxImage* const next = MuxImageRelease(wpi);
235    WebPSafeFree(wpi);
236    return next;
237  }
238  WebPMuxError MuxImageDeleteNth(WebPMuxImage** wpi_list, uint32_t nth) {
239    assert(wpi_list);
240    if (!SearchImageToGetOrDelete(wpi_list, nth, &wpi_list)) {
241      return WEBP_MUX_NOT_FOUND;
242    }
243    *wpi_list = MuxImageDelete(*wpi_list);
244    return WEBP_MUX_OK;
245  }
246  WebPMuxError MuxImageGetNth(const WebPMuxImage** wpi_list, uint32_t nth,
247                              WebPMuxImage** wpi) {
248    assert(wpi_list);
249    assert(wpi);
250    if (!SearchImageToGetOrDelete((WebPMuxImage**)wpi_list, nth,
251                                  (WebPMuxImage***)&wpi_list)) {
252      return WEBP_MUX_NOT_FOUND;
253    }
254    *wpi = (WebPMuxImage*)*wpi_list;
255    return WEBP_MUX_OK;
256  }
257  size_t MuxImageDiskSize(const WebPMuxImage* const wpi) {
258    size_t size = 0;
259    if (wpi->header_ != NULL) size += ChunkDiskSize(wpi->header_);
260    if (wpi->alpha_ != NULL) size += ChunkDiskSize(wpi->alpha_);
261    if (wpi->img_ != NULL) size += ChunkDiskSize(wpi->img_);
262    if (wpi->unknown_ != NULL) size += ChunkListDiskSize(wpi->unknown_);
263    return size;
264  }
265  static uint8_t* ChunkEmitSpecial(const WebPChunk* const header,
266                                   size_t total_size, uint8_t* dst) {
267    const size_t header_size = header->data_.size;
268    const size_t offset_to_next = total_size - CHUNK_HEADER_SIZE;
269    assert(header->tag_ == kChunks[IDX_ANMF].tag);
270    PutLE32(dst + 0, header->tag_);
271    PutLE32(dst + TAG_SIZE, (uint32_t)offset_to_next);
272    assert(header_size == (uint32_t)header_size);
273    memcpy(dst + CHUNK_HEADER_SIZE, header->data_.bytes, header_size);
274    if (header_size & 1) {
275      dst[CHUNK_HEADER_SIZE + header_size] = 0;  
276    }
277    return dst + ChunkDiskSize(header);
278  }
279  uint8_t* MuxImageEmit(const WebPMuxImage* const wpi, uint8_t* dst) {
280    assert(wpi);
281    if (wpi->header_ != NULL) {
282      dst = ChunkEmitSpecial(wpi->header_, MuxImageDiskSize(wpi), dst);
283    }
284    if (wpi->alpha_ != NULL) dst = ChunkEmit(wpi->alpha_, dst);
285    if (wpi->img_ != NULL) dst = ChunkEmit(wpi->img_, dst);
286    if (wpi->unknown_ != NULL) dst = ChunkListEmit(wpi->unknown_, dst);
287    return dst;
288  }
289  int MuxHasAlpha(const WebPMuxImage* images) {
290    while (images != NULL) {
291      if (images->has_alpha_) return 1;
292      images = images->next_;
293    }
294    return 0;
295  }
296  uint8_t* MuxEmitRiffHeader(uint8_t* const data, size_t size) {
297    PutLE32(data + 0, MKFOURCC('R', 'I', 'F', 'F'));
298    PutLE32(data + TAG_SIZE, (uint32_t)size - CHUNK_HEADER_SIZE);
299    assert(size == (uint32_t)size);
300    PutLE32(data + TAG_SIZE + CHUNK_SIZE_BYTES, MKFOURCC('W', 'E', 'B', 'P'));
301    return data + RIFF_HEADER_SIZE;
302  }
303  WebPChunk** MuxGetChunkListFromId(const WebPMux* mux, WebPChunkId id) {
304    assert(mux != NULL);
305    switch (id) {
306      case WEBP_CHUNK_VP8X:    return (WebPChunk**)&mux->vp8x_;
307      case WEBP_CHUNK_ICCP:    return (WebPChunk**)&mux->iccp_;
308      case WEBP_CHUNK_ANIM:    return (WebPChunk**)&mux->anim_;
309      case WEBP_CHUNK_EXIF:    return (WebPChunk**)&mux->exif_;
310      case WEBP_CHUNK_XMP:     return (WebPChunk**)&mux->xmp_;
311      default:                 return (WebPChunk**)&mux->unknown_;
312    }
313  }
314  static int IsNotCompatible(int feature, int num_items) {
315    return (feature != 0) != (num_items > 0);
316  }
317  #define NO_FLAG ((WebPFeatureFlags)0)
318  static WebPMuxError ValidateChunk(const WebPMux* const mux, CHUNK_INDEX idx,
319                                    WebPFeatureFlags feature,
320                                    uint32_t vp8x_flags,
321                                    int max, int* num) {
322    const WebPMuxError err =
323        WebPMuxNumChunks(mux, kChunks[idx].id, num);
324    if (err != WEBP_MUX_OK) return err;
325    if (max > -1 && *num > max) return WEBP_MUX_INVALID_ARGUMENT;
326    if (feature != NO_FLAG && IsNotCompatible(vp8x_flags & feature, *num)) {
327      return WEBP_MUX_INVALID_ARGUMENT;
328    }
329    return WEBP_MUX_OK;
330  }
331  WebPMuxError MuxValidate(const WebPMux* const mux) {
332    int num_iccp;
333    int num_exif;
334    int num_xmp;
335    int num_anim;
336    int num_frames;
337    int num_vp8x;
338    int num_images;
339    int num_alpha;
340    uint32_t flags;
341    WebPMuxError err;
342    if (mux == NULL) return WEBP_MUX_INVALID_ARGUMENT;
343    if (mux->images_ == NULL) return WEBP_MUX_INVALID_ARGUMENT;
344    err = WebPMuxGetFeatures(mux, &flags);
345    if (err != WEBP_MUX_OK) return err;
346    err = ValidateChunk(mux, IDX_ICCP, ICCP_FLAG, flags, 1, &num_iccp);
347    if (err != WEBP_MUX_OK) return err;
348    err = ValidateChunk(mux, IDX_EXIF, EXIF_FLAG, flags, 1, &num_exif);
349    if (err != WEBP_MUX_OK) return err;
350    err = ValidateChunk(mux, IDX_XMP, XMP_FLAG, flags, 1, &num_xmp);
351    if (err != WEBP_MUX_OK) return err;
352    err = ValidateChunk(mux, IDX_ANIM, NO_FLAG, flags, 1, &num_anim);
353    if (err != WEBP_MUX_OK) return err;
354    err = ValidateChunk(mux, IDX_ANMF, NO_FLAG, flags, -1, &num_frames);
355    if (err != WEBP_MUX_OK) return err;
356    {
357      const int has_animation = !!(flags & ANIMATION_FLAG);
358      if (has_animation && (num_anim == 0 || num_frames == 0)) {
359        return WEBP_MUX_INVALID_ARGUMENT;
360      }
361      if (!has_animation && (num_anim == 1 || num_frames > 0)) {
362        return WEBP_MUX_INVALID_ARGUMENT;
363      }
364      if (!has_animation) {
365        const WebPMuxImage* images = mux->images_;
366        if (images == NULL || images->next_ != NULL) {
367          return WEBP_MUX_INVALID_ARGUMENT;
368        }
369        if (mux->canvas_width_ > 0) {
370          if (images->width_ != mux->canvas_width_ ||
371              images->height_ != mux->canvas_height_) {
372            return WEBP_MUX_INVALID_ARGUMENT;
373          }
374        }
375      }
376    }
377    err = ValidateChunk(mux, IDX_VP8X, NO_FLAG, flags, 1, &num_vp8x);
378    if (err != WEBP_MUX_OK) return err;
379    err = ValidateChunk(mux, IDX_VP8, NO_FLAG, flags, -1, &num_images);
380    if (err != WEBP_MUX_OK) return err;
381    if (num_vp8x == 0 && num_images != 1) return WEBP_MUX_INVALID_ARGUMENT;
382    if (MuxHasAlpha(mux->images_)) {
383      if (num_vp8x > 0) {
384        if (!(flags & ALPHA_FLAG)) return WEBP_MUX_INVALID_ARGUMENT;
385      } else {
386        err = WebPMuxNumChunks(mux, WEBP_CHUNK_ALPHA, &num_alpha);
387        if (err != WEBP_MUX_OK) return err;
388        if (num_alpha > 0) return WEBP_MUX_INVALID_ARGUMENT;
389      }
390    }
391    return WEBP_MUX_OK;
392  }
393  #undef NO_FLAG
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lbaselib.c</h3>
            <pre><code>1  #include <ctype.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #define lbaselib_c
6  #define LUA_LIB
7  #include "lua.h"
8  #include "lauxlib.h"
9  #include "lualib.h"
10  static int luaB_print (lua_State *L) {
11    int n = lua_gettop(L);  &bsol;* number of arguments */
12    int i;
13    lua_getglobal(L, "tostring");
14    for (i=1; i<=n; i++) {
15      const char *s;
16      lua_pushvalue(L, -1);  &bsol;* function to be called */
17      lua_pushvalue(L, i);   &bsol;* value to print */
18      lua_call(L, 1, 1);
19      s = lua_tostring(L, -1);  &bsol;* get result */
20      if (s == NULL)
21        return luaL_error(L, LUA_QL("tostring") " must return a string to "
22                             LUA_QL("print"));
23      if (i>1) fputs("\t", stdout);
24      fputs(s, stdout);
25      lua_pop(L, 1);  &bsol;* pop result */
26    }
27    fputs("\n", stdout);
28    return 0;
29  }
30  static int luaB_tonumber (lua_State *L) {
31    int base = luaL_optint(L, 2, 10);
32    if (base == 10) {  &bsol;* standard conversion */
33      luaL_checkany(L, 1);
34      if (lua_isnumber(L, 1)) {
35        lua_pushnumber(L, lua_tonumber(L, 1));
36        return 1;
37      }
38    }
39    else {
40      const char *s1 = luaL_checkstring(L, 1);
41      char *s2;
42      unsigned long n;
43      luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
44      n = strtoul(s1, &s2, base);
45      if (s1 != s2) {  &bsol;* at least one valid digit? */
46        while (isspace((unsigned char)(*s2))) s2++;  &bsol;* skip trailing spaces */
47        if (*s2 == '\0') {  &bsol;* no invalid trailing characters? */
48          lua_pushnumber(L, (lua_Number)n);
49          return 1;
50        }
51      }
52    }
53    lua_pushnil(L);  &bsol;* else not a number */
54    return 1;
55  }
56  static int luaB_error (lua_State *L) {
57    int level = luaL_optint(L, 2, 1);
58    lua_settop(L, 1);
59    if (lua_isstring(L, 1) && level > 0) {  &bsol;* add extra information? */
60      luaL_where(L, level);
61      lua_pushvalue(L, 1);
62      lua_concat(L, 2);
63    }
64    return lua_error(L);
65  }
66  static int luaB_getmetatable (lua_State *L) {
67    luaL_checkany(L, 1);
68    if (!lua_getmetatable(L, 1)) {
69      lua_pushnil(L);
70      return 1;  &bsol;* no metatable */
71    }
72    luaL_getmetafield(L, 1, "__metatable");
73    return 1;  &bsol;* returns either __metatable field (if present) or metatable */
74  }
75  static int luaB_setmetatable (lua_State *L) {
76    int t = lua_type(L, 2);
77    luaL_checktype(L, 1, LUA_TTABLE);
78    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
79                      "nil or table expected");
80    if (luaL_getmetafield(L, 1, "__metatable"))
81      luaL_error(L, "cannot change a protected metatable");
82    lua_settop(L, 2);
83    lua_setmetatable(L, 1);
84    return 1;
85  }
86  static void getfunc (lua_State *L, int opt) {
87    if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
88    else {
89      lua_Debug ar;
90      int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);
91      luaL_argcheck(L, level >= 0, 1, "level must be non-negative");
92      if (lua_getstack(L, level, &ar) == 0)
93        luaL_argerror(L, 1, "invalid level");
94      lua_getinfo(L, "f", &ar);
95      if (lua_isnil(L, -1))
96        luaL_error(L, "no function environment for tail call at level %d",
97                      level);
98    }
99  }
100  static int luaB_getfenv (lua_State *L) {
101    getfunc(L, 1);
102    if (lua_iscfunction(L, -1))  &bsol;* is a C function? */
103      lua_pushvalue(L, LUA_GLOBALSINDEX);  &bsol;* return the thread's global env. */
104    else
105      lua_getfenv(L, -1);
106    return 1;
107  }
108  static int luaB_setfenv (lua_State *L) {
109    luaL_checktype(L, 2, LUA_TTABLE);
110    getfunc(L, 0);
111    lua_pushvalue(L, 2);
112    if (lua_isnumber(L, 1) && lua_tonumber(L, 1) == 0) {
113      lua_pushthread(L);
114      lua_insert(L, -2);
115      lua_setfenv(L, -2);
116      return 0;
117    }
118    else if (lua_iscfunction(L, -2) || lua_setfenv(L, -2) == 0)
119      luaL_error(L,
120            LUA_QL("setfenv") " cannot change environment of given object");
121    return 1;
122  }
123  static int luaB_rawequal (lua_State *L) {
124    luaL_checkany(L, 1);
125    luaL_checkany(L, 2);
126    lua_pushboolean(L, lua_rawequal(L, 1, 2));
127    return 1;
128  }
129  static int luaB_rawget (lua_State *L) {
130    luaL_checktype(L, 1, LUA_TTABLE);
131    luaL_checkany(L, 2);
132    lua_settop(L, 2);
133    lua_rawget(L, 1);
134    return 1;
135  }
136  static int luaB_rawset (lua_State *L) {
137    luaL_checktype(L, 1, LUA_TTABLE);
138    luaL_checkany(L, 2);
139    luaL_checkany(L, 3);
140    lua_settop(L, 3);
141    lua_rawset(L, 1);
142    return 1;
143  }
144  static int luaB_gcinfo (lua_State *L) {
145    lua_pushinteger(L, lua_getgccount(L));
146    return 1;
147  }
148  static int luaB_collectgarbage (lua_State *L) {
149    static const char *const opts[] = {"stop", "restart", "collect",
150      "count", "step", "setpause", "setstepmul", NULL};
151    static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
152      LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
153    int o = luaL_checkoption(L, 1, "collect", opts);
154    int ex = luaL_optint(L, 2, 0);
155    int res = lua_gc(L, optsnum[o], ex);
156    switch (optsnum[o]) {
157      case LUA_GCCOUNT: {
158        int b = lua_gc(L, LUA_GCCOUNTB, 0);
159        lua_pushnumber(L, res + ((lua_Number)b/1024));
160        return 1;
161      }
162      case LUA_GCSTEP: {
163        lua_pushboolean(L, res);
164        return 1;
165      }
166      default: {
167        lua_pushnumber(L, res);
168        return 1;
169      }
170    }
171  }
172  static int luaB_type (lua_State *L) {
173    luaL_checkany(L, 1);
174    lua_pushstring(L, luaL_typename(L, 1));
175    return 1;
176  }
177  static int luaB_next (lua_State *L) {
178    luaL_checktype(L, 1, LUA_TTABLE);
179    lua_settop(L, 2);  &bsol;* create a 2nd argument if there isn't one */
180    if (lua_next(L, 1))
181      return 2;
182    else {
183      lua_pushnil(L);
184      return 1;
185    }
186  }
187  static int luaB_pairs (lua_State *L) {
188    luaL_checktype(L, 1, LUA_TTABLE);
189    lua_pushvalue(L, lua_upvalueindex(1));  &bsol;* return generator, */
190    lua_pushvalue(L, 1);  &bsol;* state, */
191    lua_pushnil(L);  &bsol;* and initial value */
192    return 3;
193  }
194  static int ipairsaux (lua_State *L) {
195    int i = luaL_checkint(L, 2);
196    luaL_checktype(L, 1, LUA_TTABLE);
197    i++;  &bsol;* next value */
198    lua_pushinteger(L, i);
199    lua_rawgeti(L, 1, i);
200    return (lua_isnil(L, -1)) ? 0 : 2;
201  }
202  static int luaB_ipairs (lua_State *L) {
203    luaL_checktype(L, 1, LUA_TTABLE);
204    lua_pushvalue(L, lua_upvalueindex(1));  &bsol;* return generator, */
205    lua_pushvalue(L, 1);  &bsol;* state, */
206    lua_pushinteger(L, 0);  &bsol;* and initial value */
207    return 3;
208  }
209  static int load_aux (lua_State *L, int status) {
210    if (status == 0)  &bsol;* OK? */
211      return 1;
212    else {
213      lua_pushnil(L);
214      lua_insert(L, -2);  &bsol;* put before error message */
215      return 2;  &bsol;* return nil plus error message */
216    }
217  }
218  static int luaB_loadstring (lua_State *L) {
219    size_t l;
220    const char *s = luaL_checklstring(L, 1, &l);
221    const char *chunkname = luaL_optstring(L, 2, s);
222    return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
223  }
224  static int luaB_loadfile (lua_State *L) {
225    const char *fname = luaL_optstring(L, 1, NULL);
226    return load_aux(L, luaL_loadfile(L, fname));
227  }
228  static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
229    (void)ud;  &bsol;* to avoid warnings */
230    luaL_checkstack(L, 2, "too many nested functions");
231    lua_pushvalue(L, 1);  &bsol;* get function */
232    lua_call(L, 0, 1);  &bsol;* call it */
233    if (lua_isnil(L, -1)) {
234      *size = 0;
235      return NULL;
236    }
237    else if (lua_isstring(L, -1)) {
238      lua_replace(L, 3);  &bsol;* save string in a reserved stack slot */
239      return lua_tolstring(L, 3, size);
240    }
241    else luaL_error(L, "reader function must return a string");
242    return NULL;  &bsol;* to avoid warnings */
<span onclick='openModal()' class='match'>243  }
244  static int luaB_load (lua_State *L) {
245    int status;
246    const char *cname = luaL_optstring(L, 2, "=(load)");
247    luaL_checktype(L, 1, LUA_TFUNCTION);
248    lua_settop(L, 3);  &bsol;* function, eventual name, plus one reserved slot */
</span>249    status = lua_load(L, generic_reader, NULL, cname);
250    return load_aux(L, status);
251  }
252  static int luaB_dofile (lua_State *L) {
253    const char *fname = luaL_optstring(L, 1, NULL);
254    int n = lua_gettop(L);
255    if (luaL_loadfile(L, fname) != 0) lua_error(L);
256    lua_call(L, 0, LUA_MULTRET);
257    return lua_gettop(L) - n;
258  }
259  static int luaB_assert (lua_State *L) {
260    luaL_checkany(L, 1);
261    if (!lua_toboolean(L, 1))
262      return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
263    return lua_gettop(L);
264  }
265  static int luaB_unpack (lua_State *L) {
266    int i, e, n;
267    luaL_checktype(L, 1, LUA_TTABLE);
268    i = luaL_optint(L, 2, 1);
269    e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
270    if (i > e) return 0;  &bsol;* empty range */
271    n = e - i + 1;  &bsol;* number of elements */
272    if (n <= 0 || !lua_checkstack(L, n))  &bsol;* n <= 0 means arith. overflow */
273      return luaL_error(L, "too many results to unpack");
274    lua_rawgeti(L, 1, i);  &bsol;* push arg[i] (avoiding overflow problems) */
275    while (i++ < e)  &bsol;* push arg[i + 1...e] */
276      lua_rawgeti(L, 1, i);
277    return n;
278  }
279  static int luaB_select (lua_State *L) {
280    int n = lua_gettop(L);
281    if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
282      lua_pushinteger(L, n-1);
283      return 1;
284    }
285    else {
286      int i = luaL_checkint(L, 1);
287      if (i < 0) i = n + i;
288      else if (i > n) i = n;
289      luaL_argcheck(L, 1 <= i, 1, "index out of range");
290      return n - i;
291    }
292  }
293  static int luaB_pcall (lua_State *L) {
294    int status;
295    luaL_checkany(L, 1);
296    status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
297    lua_pushboolean(L, (status == 0));
298    lua_insert(L, 1);
299    return lua_gettop(L);  &bsol;* return status + all results */
300  }
301  static int luaB_xpcall (lua_State *L) {
302    int status;
303    luaL_checkany(L, 2);
304    lua_settop(L, 2);
305    lua_insert(L, 1);  &bsol;* put error function under function to be called */
306    status = lua_pcall(L, 0, LUA_MULTRET, 1);
307    lua_pushboolean(L, (status == 0));
308    lua_replace(L, 1);
309    return lua_gettop(L);  &bsol;* return status + all results */
310  }
311  static int luaB_tostring (lua_State *L) {
312    luaL_checkany(L, 1);
313    if (luaL_callmeta(L, 1, "__tostring"))  &bsol;* is there a metafield? */
314      return 1;  &bsol;* use its value */
315    switch (lua_type(L, 1)) {
316      case LUA_TNUMBER:
317        lua_pushstring(L, lua_tostring(L, 1));
318        break;
319      case LUA_TSTRING:
320        lua_pushvalue(L, 1);
321        break;
322      case LUA_TBOOLEAN:
323        lua_pushstring(L, (lua_toboolean(L, 1) ? "true" : "false"));
324        break;
325      case LUA_TNIL:
326        lua_pushliteral(L, "nil");
327        break;
328      default:
329        lua_pushfstring(L, "%s: %p", luaL_typename(L, 1), lua_topointer(L, 1));
330        break;
331    }
332    return 1;
333  }
334  static int luaB_newproxy (lua_State *L) {
335    lua_settop(L, 1);
336    lua_newuserdata(L, 0);  &bsol;* create proxy */
337    if (lua_toboolean(L, 1) == 0)
338      return 1;  &bsol;* no metatable */
339    else if (lua_isboolean(L, 1)) {
340      lua_newtable(L);  &bsol;* create a new metatable `m' ... */
341      lua_pushvalue(L, -1);  &bsol;* ... and mark `m' as a valid metatable */
342      lua_pushboolean(L, 1);
343      lua_rawset(L, lua_upvalueindex(1));  &bsol;* weaktable[m] = true */
344    }
345    else {
346      int validproxy = 0;  &bsol;* to check if weaktable[metatable(u)] == true */
347      if (lua_getmetatable(L, 1)) {
348        lua_rawget(L, lua_upvalueindex(1));
349        validproxy = lua_toboolean(L, -1);
350        lua_pop(L, 1);  &bsol;* remove value */
351      }
352      luaL_argcheck(L, validproxy, 1, "boolean or proxy expected");
353      lua_getmetatable(L, 1);  &bsol;* metatable is valid; get it */
354    }
355    lua_setmetatable(L, 2);
356    return 1;
357  }
358  static const luaL_Reg base_funcs[] = {
359    {"assert", luaB_assert},
360    {"collectgarbage", luaB_collectgarbage},
361    {"dofile", luaB_dofile},
362    {"error", luaB_error},
363    {"gcinfo", luaB_gcinfo},
364    {"getfenv", luaB_getfenv},
365    {"getmetatable", luaB_getmetatable},
366    {"loadfile", luaB_loadfile},
367    {"load", luaB_load},
368    {"loadstring", luaB_loadstring},
369    {"next", luaB_next},
370    {"pcall", luaB_pcall},
371    {"print", luaB_print},
372    {"rawequal", luaB_rawequal},
373    {"rawget", luaB_rawget},
374    {"rawset", luaB_rawset},
375    {"select", luaB_select},
376    {"setfenv", luaB_setfenv},
377    {"setmetatable", luaB_setmetatable},
378    {"tonumber", luaB_tonumber},
379    {"tostring", luaB_tostring},
380    {"type", luaB_type},
381    {"unpack", luaB_unpack},
382    {"xpcall", luaB_xpcall},
383    {NULL, NULL}
384  };
385  #define CO_RUN	0	&bsol;* running */
386  #define CO_SUS	1	&bsol;* suspended */
387  #define CO_NOR	2	&bsol;* 'normal' (it resumed another coroutine) */
388  #define CO_DEAD	3
389  static const char *const statnames[] =
390      {"running", "suspended", "normal", "dead"};
391  static int costatus (lua_State *L, lua_State *co) {
392    if (L == co) return CO_RUN;
393    switch (lua_status(co)) {
394      case LUA_YIELD:
395        return CO_SUS;
396      case 0: {
397        lua_Debug ar;
398        if (lua_getstack(co, 0, &ar) > 0)  &bsol;* does it have frames? */
399          return CO_NOR;  &bsol;* it is running */
400        else if (lua_gettop(co) == 0)
401            return CO_DEAD;
402        else
403          return CO_SUS;  &bsol;* initial state */
404      }
405      default:  &bsol;* some error occured */
406        return CO_DEAD;
407    }
408  }
409  static int luaB_costatus (lua_State *L) {
410    lua_State *co = lua_tothread(L, 1);
411    luaL_argcheck(L, co, 1, "coroutine expected");
412    lua_pushstring(L, statnames[costatus(L, co)]);
413    return 1;
414  }
415  static int auxresume (lua_State *L, lua_State *co, int narg) {
416    int status = costatus(L, co);
417    if (!lua_checkstack(co, narg))
418      luaL_error(L, "too many arguments to resume");
419    if (status != CO_SUS) {
420      lua_pushfstring(L, "cannot resume %s coroutine", statnames[status]);
421      return -1;  &bsol;* error flag */
422    }
423    lua_xmove(L, co, narg);
424    lua_setlevel(L, co);
425    status = lua_resume(co, narg);
426    if (status == 0 || status == LUA_YIELD) {
427      int nres = lua_gettop(co);
428      if (!lua_checkstack(L, nres + 1))
429        luaL_error(L, "too many results to resume");
430      lua_xmove(co, L, nres);  &bsol;* move yielded values */
431      return nres;
432    }
433    else {
434      lua_xmove(co, L, 1);  &bsol;* move error message */
435      return -1;  &bsol;* error flag */
436    }
437  }
438  static int luaB_coresume (lua_State *L) {
439    lua_State *co = lua_tothread(L, 1);
440    int r;
441    luaL_argcheck(L, co, 1, "coroutine expected");
442    r = auxresume(L, co, lua_gettop(L) - 1);
443    if (r < 0) {
444      lua_pushboolean(L, 0);
445      lua_insert(L, -2);
446      return 2;  &bsol;* return false + error message */
447    }
448    else {
449      lua_pushboolean(L, 1);
450      lua_insert(L, -(r + 1));
451      return r + 1;  &bsol;* return true + `resume' returns */
452    }
453  }
454  static int luaB_auxwrap (lua_State *L) {
455    lua_State *co = lua_tothread(L, lua_upvalueindex(1));
456    int r = auxresume(L, co, lua_gettop(L));
457    if (r < 0) {
458      if (lua_isstring(L, -1)) {  &bsol;* error object is a string? */
459        luaL_where(L, 1);  &bsol;* add extra info */
460        lua_insert(L, -2);
461        lua_concat(L, 2);
462      }
463      lua_error(L);  &bsol;* propagate error */
464    }
465    return r;
466  }
467  static int luaB_cocreate (lua_State *L) {
468    lua_State *NL = lua_newthread(L);
469    luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
470      "Lua function expected");
471    lua_pushvalue(L, 1);  &bsol;* move function to top */
472    lua_xmove(L, NL, 1);  &bsol;* move function from L to NL */
473    return 1;
474  }
475  static int luaB_cowrap (lua_State *L) {
476    luaB_cocreate(L);
477    lua_pushcclosure(L, luaB_auxwrap, 1);
478    return 1;
479  }
480  static int luaB_yield (lua_State *L) {
481    return lua_yield(L, lua_gettop(L));
482  }
483  static int luaB_corunning (lua_State *L) {
484    if (lua_pushthread(L))
485      lua_pushnil(L);  &bsol;* main thread is not a coroutine */
486    return 1;
487  }
488  static const luaL_Reg co_funcs[] = {
489    {"create", luaB_cocreate},
490    {"resume", luaB_coresume},
491    {"running", luaB_corunning},
492    {"status", luaB_costatus},
493    {"wrap", luaB_cowrap},
494    {"yield", luaB_yield},
495    {NULL, NULL}
496  };
497  static void auxopen (lua_State *L, const char *name,
498                       lua_CFunction f, lua_CFunction u) {
499    lua_pushcfunction(L, u);
500    lua_pushcclosure(L, f, 1);
501    lua_setfield(L, -2, name);
502  }
503  static void base_open (lua_State *L) {
504    lua_pushvalue(L, LUA_GLOBALSINDEX);
505    lua_setglobal(L, "_G");
506    luaL_register(L, "_G", base_funcs);
507    lua_pushliteral(L, LUA_VERSION);
508    lua_setglobal(L, "_VERSION");  &bsol;* set global _VERSION */
509    auxopen(L, "ipairs", luaB_ipairs, ipairsaux);
510    auxopen(L, "pairs", luaB_pairs, luaB_next);
511    lua_createtable(L, 0, 1);  &bsol;* new table `w' */
512    lua_pushvalue(L, -1);  &bsol;* `w' will be its own metatable */
513    lua_setmetatable(L, -2);
514    lua_pushliteral(L, "kv");
515    lua_setfield(L, -2, "__mode");  &bsol;* metatable(w).__mode = "kv" */
516    lua_pushcclosure(L, luaB_newproxy, 1);
517    lua_setglobal(L, "newproxy");  &bsol;* set global `newproxy' */
518  }
519  LUALIB_API int luaopen_base (lua_State *L) {
520    base_open(L);
521    luaL_register(L, LUA_COLIBNAME, co_funcs);
522    return 2;
523  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-muxinternal.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lbaselib.c</div>
                </div>
                <div class="column column_space"><pre><code>128  }
129  static uint8_t* ChunkEmit(const WebPChunk* const chunk, uint8_t* dst) {
130    const size_t chunk_size = chunk->data_.size;
131    assert(chunk);
132    assert(chunk->tag_ != NIL_TAG);
133    PutLE32(dst + 0, chunk->tag_);
134    PutLE32(dst + TAG_SIZE, (uint32_t)chunk_size);
135    assert(chunk_size == (uint32_t)chunk_size);
</pre></code></div>
                <div class="column column_space"><pre><code>243  }
244  static int luaB_load (lua_State *L) {
245    int status;
246    const char *cname = luaL_optstring(L, 2, "=(load)");
247    luaL_checktype(L, 1, LUA_TFUNCTION);
248    lua_settop(L, 3);  &bsol;* function, eventual name, plus one reserved slot */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    