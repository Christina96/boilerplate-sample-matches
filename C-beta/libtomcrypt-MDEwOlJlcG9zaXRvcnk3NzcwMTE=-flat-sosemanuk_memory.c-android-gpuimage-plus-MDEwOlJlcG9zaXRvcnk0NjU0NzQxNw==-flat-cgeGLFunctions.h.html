
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.825242718446602%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sosemanuk_memory.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SOSEMANUK
<span onclick='openModal()' class='match'>3  int sosemanuk_memory(const unsigned char *key,    unsigned long keylen,
4                       const unsigned char *iv,     unsigned long ivlen,
5                       const unsigned char *datain, unsigned long datalen,
6                       unsigned char *dataout)
7  {
8     sosemanuk_state st;
9     int err;
</span>10     if ((err = sosemanuk_setup(&st, key, keylen)) != CRYPT_OK) goto WIPE_KEY;
11     if ((err = sosemanuk_setiv(&st, iv, ivlen))   != CRYPT_OK) goto WIPE_KEY;
12     err = sosemanuk_crypt(&st, datain, datalen, dataout);
13  WIPE_KEY:
14     sosemanuk_done(&st);
15     return err;
16  }
17  #endif &bsol;* LTC_SOSEMANUK */
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeGLFunctions.h</h3>
            <pre><code>1  &bsol;*
2   * cgeGLFunctions.h
3   *
4   *  Created on: 2013-12-5
5   *      Author: Wang Yang
6   *        Mail: admin@wysaid.org
7   */
8  #ifndef _CGEGLFUNCTIONS_H_
9  #define _CGEGLFUNCTIONS_H_
10  #include "cgeCommonDefine.h"
11  #include <cassert>
12  #if defined(_CGE_DISABLE_GLOBALCONTEXT_) && _CGE_DISABLE_GLOBALCONTEXT_
13  #define CGE_ENABLE_GLOBAL_GLCONTEXT(...)
14  #define CGE_DISABLE_GLOBAL_GLCONTEXT(...)
15  #else
16  #define CGE_ENABLE_GLOBAL_GLCONTEXT(...) cgeEnableGlobalGLContext()
17  #define CGE_DISABLE_GLOBAL_GLCONTEXT(...) cgeDisableGlobalGLContext()
18  #endif
19  namespace CGE
20  {
21  #if !(defined(_CGE_DISABLE_GLOBALCONTEXT_) && _CGE_DISABLE_GLOBALCONTEXT_)
22  typedef bool (*CGEEnableGLContextFunction)(void*);
23  typedef bool (*CGEDisableGLContextFunction)(void*);
24  void cgeSetGLContextEnableFunction(CGEEnableGLContextFunction func, void* param);
25  void cgeSetGLContextDisableFunction(CGEDisableGLContextFunction func, void* param);
26  void* cgeGetGLEnableParam();
27  void* cgeGetGLDisableParam();
28  void cgeStopGlobalGLEnableFunction();
29  void cgeRestoreGlobalGLEnableFunction();
30  void cgeEnableGlobalGLContext();
31  void cgeDisableGlobalGLContext();
32  #endif
33  typedef void* (*CGEBufferLoadFun)(const char* sourceName, void** bufferData, GLint* w, GLint* h, CGEBufferFormat* fmt, void* arg);
34  typedef bool (*CGEBufferUnloadFun)(void* arg1, void* arg2);
35  typedef GLuint (*CGETextureLoadFun)(const char* sourceName, GLint* w, GLint* h, void* arg);
36  void cgeSetCommonLoadFunction(CGEBufferLoadFun fun, void* arg);
37  void cgeSetCommonUnloadFunction(CGEBufferUnloadFun fun, void* arg);
38  void* cgeLoadResourceCommon(const char* sourceName, void** bufferData, GLint* w, GLint* h, GLenum* format, GLenum* type);
39  CGEBufferLoadFun cgeGetCommonLoadFunc();
40  void* cgeGetCommonLoadArg();
41  bool cgeUnloadResourceCommon(void* bufferArg);
42  CGEBufferUnloadFun cgeGetCommonUnloadFunc();
43  void* cgeGetCommonUnloadArg();
44  char* cgeGetScaledBufferInSize(const void* buffer, int& w, int& h, int channel, int maxSizeX, int maxSizeY);
45  char* cgeGetScaledBufferOutofSize(const void* buffer, int& w, int& h, int channel, int minSizeX, int minSizeY);
46  inline GLint cgeGetMaxTextureSize()
47  {
48      GLint n;
49      glGetIntegerv(GL_MAX_TEXTURE_SIZE, &n);
50      return n - 1;
51  }
52  class FrameBuffer
53  {
54  public:
55      FrameBuffer() { glGenFramebuffers(1, &m_framebuffer); }
56      ~FrameBuffer() { glDeleteFramebuffers(1, &m_framebuffer); }
57      inline void bind() const { glBindFramebuffer(GL_FRAMEBUFFER, m_framebuffer); }
58      inline void bindTexture2D(GLuint texID, GLsizei w, GLsizei h, GLenum attachment = GL_COLOR_ATTACHMENT0) const
59      {
60          bindTexture2D(texID, 0, 0, w, h, attachment);
61      }
62      inline void bindTexture2D(GLuint texID, GLenum attachment = GL_COLOR_ATTACHMENT0) const
63      {
64          bind();
65          glFramebufferTexture2D(GL_FRAMEBUFFER, attachment, GL_TEXTURE_2D, texID, 0);
66          CGE_LOG_CODE(
67              GLenum code = glCheckFramebufferStatus(GL_FRAMEBUFFER);
68              if (code != GL_FRAMEBUFFER_COMPLETE) {
69                  CGE_LOG_ERROR("CGE::FrameBuffer::bindTexture2D - Frame buffer is not valid: %x\n", code);
70              })
71      }
72      inline void bindTexture2D(GLuint texID, GLsizei x, GLsizei y, GLsizei w, GLsizei h, GLenum attachment = GL_COLOR_ATTACHMENT0) const
73      {
74          bindTexture2D(texID, attachment);
75          glViewport(x, y, w, h);
76      }
77      inline GLuint fbo() { return m_framebuffer; }
78  protected:
79      GLuint m_framebuffer;
80  };
81  struct CGESizei
82  {
83      CGESizei() :
84          width(0), height(0) {}
85      CGESizei(int w, int h) :
86          width(w), height(h) {}
87      void set(int w, int h)
88      {
89          width = w;
90          height = h;
91      }
92      bool operator==(const CGESizei& other) const
93      {
94          return width == other.width && height == other.height;
95      }
96      bool operator!=(const CGESizei& other) const
97      {
98          return width != other.width || height != other.height;
99      }
100      GLint width;
101      GLint height;
102  };
103  struct CGESizef
104  {
105      CGESizef() :
106          width(0.0f), height(0.0f) {}
107      CGESizef(float w, float h) :
108          width(w), height(h) {}
109      void set(float w, float h)
110      {
111          width = w;
112          height = h;
113      }
114      GLfloat width;
115      GLfloat height;
116  };
117  struct TextureInfo
118  {
119      GLuint name{};
120      int width{}, height{};
121  };
122  class TextureObject
123  {
124  public:
125      virtual ~TextureObject();
126      explicit TextureObject(GLuint texture = 0, const CGESizei& size = CGESizei());
127      explicit TextureObject(const TextureObject&) = delete;
128      TextureObject(TextureObject&&) noexcept;
129      explicit TextureObject(TextureInfo&& t) :
130          m_texture(t.name), m_size(t.width, t.height) { t.name = 0; }
131      GLuint texture() const { return m_texture; }
132      GLint width() const { return m_size.width; }
133      GLint height() const { return m_size.height; }
134      CGESizei size() const { return m_size; }
<span onclick='openModal()' class='match'>135      void cleanup(bool deleteTexture = true);
136      bool resize(int w, int h, const void* buffer = nullptr, GLenum format = GL_RGBA);
</span>137      inline bool updateTextureData(int w, int h, const void* buffer = nullptr, GLenum format = GL_RGBA)
138      {
139          return resize(w, h, buffer, format);
140      }
141      TextureObject& operator=(TextureObject&& t) noexcept;
142      TextureObject& operator=(TextureInfo&& t);
143  protected:
144      GLuint m_texture = 0;
145      CGESizei m_size;
146  };
147  class FrameBufferWithTexture : protected FrameBuffer, public TextureObject
148  {
149  public:
150      using FrameBuffer::FrameBuffer;
151      ~FrameBufferWithTexture() override;
152      GLuint renderbuffer() const { return m_renderBuffer; }
153      void bindTexture2D(GLsizei w, GLsizei h, const void* buffer = nullptr);
154      void attachDepthBuffer();
155      bool checkStatus();
156      using FrameBuffer::bind;
157      using FrameBuffer::fbo;
158  private:
159      using TextureObject::resize;
160      GLuint m_renderBuffer = 0;
161  };
162  struct CGELuminance
163  {
164      enum
165      {
166          CalcPrecision = 16
167      };
168      enum
169      {
170          Weight = (1 << CalcPrecision)
171      };
172      enum
173      {
174          RWeight = int(0.299 * Weight),
175          GWeight = int(0.587 * Weight),
176          BWeight = int(0.114 * Weight)
177      };
178      static inline int RGB888(int r, int g, int b)
179      {
180          return (r * RWeight + g * GWeight + b * BWeight) >> CalcPrecision;
181      }
182      static inline int RGB565(unsigned short color)
183      {
184          const int r = (color & 31) << 3;
185          const int g = ((color >> 5) & 63) << 2;
186          const int b = ((color >> 11) & 31) << 3;
187          return RGB888(r, g, b);
188      }
189  };
190  } 
191  #include <ctime>
192  #include <memory>
193  #include <vector>
194  #include "cgeShaderFunctions.h"
195  #include "cgeImageFilter.h"
196  #include "cgeImageHandler.h"
197  #endif &bsol;* _CGEGLFUNCTIONS_H_ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sosemanuk_memory.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeGLFunctions.h</div>
                </div>
                <div class="column column_space"><pre><code>3  int sosemanuk_memory(const unsigned char *key,    unsigned long keylen,
4                       const unsigned char *iv,     unsigned long ivlen,
5                       const unsigned char *datain, unsigned long datalen,
6                       unsigned char *dataout)
7  {
8     sosemanuk_state st;
9     int err;
</pre></code></div>
                <div class="column column_space"><pre><code>135      void cleanup(bool deleteTexture = true);
136      bool resize(int w, int h, const void* buffer = nullptr, GLenum format = GL_RGBA);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    