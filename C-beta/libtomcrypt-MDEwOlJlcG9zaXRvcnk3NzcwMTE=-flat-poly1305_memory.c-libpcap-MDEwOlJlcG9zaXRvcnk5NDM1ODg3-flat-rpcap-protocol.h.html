
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.69620253164557%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-poly1305_memory.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_POLY1305
<span onclick='openModal()' class='match'>3  int poly1305_memory(const unsigned char *key, unsigned long keylen, const unsigned char *in, unsigned long inlen, unsigned char *mac, unsigned long *maclen)
4  {
5     poly1305_state st;
6     int err;
</span>7     LTC_ARGCHK(key    != NULL);
8     LTC_ARGCHK(in     != NULL);
9     LTC_ARGCHK(mac    != NULL);
10     LTC_ARGCHK(maclen != NULL);
11     if ((err = poly1305_init(&st, key, keylen))  != CRYPT_OK) { goto LBL_ERR; }
12     if ((err = poly1305_process(&st, in, inlen)) != CRYPT_OK) { goto LBL_ERR; }
13     err = poly1305_done(&st, mac, maclen);
14  LBL_ERR:
15  #ifdef LTC_CLEAN_STACK
16     zeromem(&st, sizeof(poly1305_state));
17  #endif
18     return err;
19  }
20  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-rpcap-protocol.h</h3>
            <pre><code>1  #ifndef __RPCAP_PROTOCOL_H__
2  #define __RPCAP_PROTOCOL_H__
3  #define RPCAP_DEFAULT_NETPORT "2002" &bsol;* Default port on which the RPCAP daemon is waiting for connections. */
4  #define RPCAP_DEFAULT_NETPORT_ACTIVE "2003"
5  #define RPCAP_DEFAULT_NETADDR ""	&bsol;* Default network address on which the RPCAP daemon binds to. */
6  #define RPCAP_MIN_VERSION 0
7  #define RPCAP_MAX_VERSION 0
8  #if RPCAP_MIN_VERSION == 0
9  #define RPCAP_VERSION_IS_SUPPORTED(v)	\
10  	((v) <= RPCAP_MAX_VERSION)
11  #else
12  #define RPCAP_VERSION_IS_SUPPORTED(v)	\
13  	((v) >= RPCAP_MIN_VERSION && (v) <= RPCAP_MAX_VERSION)
14  #endif
15  #define RPCAP_HOSTLIST_SEP " ,;\n\r"
16  struct rpcap_header
17  {
18  	uint8_t ver;		&bsol;* RPCAP version number */
19  	uint8_t type;		&bsol;* RPCAP message type (error, findalldevs, ...) */
20  	uint16_t value;		&bsol;* Message-dependent value (not always used) */
21  	uint32_t plen;		&bsol;* Length of the payload of this RPCAP message */
22  };
23  struct rpcap_authreply
24  {
25  	uint8_t minvers;		&bsol;* Minimum version supported */
26  	uint8_t maxvers;		&bsol;* Maximum version supported */
27  	uint8_t pad[2];			&bsol;* Pad to 4-byte boundary **/
28  	uint32_t byte_order_magic;	&bsol;* RPCAP_BYTE_ORDER_MAGIC, in server byte order */
29  };
30  #define RPCAP_BYTE_ORDER_MAGIC		0xa1b2c3d4U
31  #define RPCAP_BYTE_ORDER_MAGIC_SWAPPED	0xd4c3b2a1U
32  struct rpcap_authreply_old
33  {
34  	uint8_t minvers;	&bsol;* Minimum version supported */
35  	uint8_t maxvers;	&bsol;* Maximum version supported */
36  };
37  struct rpcap_findalldevs_if
38  {
39  	uint16_t namelen;	&bsol;* Length of the interface name */
40  	uint16_t desclen;	&bsol;* Length of the interface description */
41  	uint32_t flags;		&bsol;* Interface flags */
42  	uint16_t naddr;		&bsol;* Number of addresses */
43  	uint16_t dummy;		&bsol;* Must be zero */
44  };
45  struct rpcap_sockaddr
46  {
47  	uint16_t	family;		&bsol;* Address family */
48  	char		data[128-2];	&bsol;* Data */
49  };
50  #define RPCAP_AF_INET	2		&bsol;* Value on all OSes except for Haiku */
51  struct rpcap_sockaddr_in
52  {
53  	uint16_t family;	&bsol;* Address family */
54  	uint16_t port;		&bsol;* Port number */
55  	uint32_t addr;		&bsol;* IPv4 address */
56  	uint8_t	 zero[8];	&bsol;* Padding */
57  };
58  #define RPCAP_AF_INET6	23		&bsol;* Value on Windows */
<span onclick='openModal()' class='match'>59  struct rpcap_sockaddr_in6
60  {
61  	uint16_t family;		&bsol;* Address family */
62  	uint16_t port;		&bsol;* Port number */
63  	uint32_t flowinfo;	&bsol;* IPv6 flow information */
</span>64  	uint8_t  addr[16];	&bsol;* IPv6 address */
65  	uint32_t scope_id;	&bsol;* Scope zone index */
66  };
67  struct rpcap_findalldevs_ifaddr
68  {
69  	struct rpcap_sockaddr addr;		&bsol;* Network address */
70  	struct rpcap_sockaddr netmask;		&bsol;* Netmask for that address */
71  	struct rpcap_sockaddr broadaddr;	&bsol;* Broadcast address for that address */
72  	struct rpcap_sockaddr dstaddr;		&bsol;* P2P destination address for that address */
73  };
74  struct rpcap_openreply
75  {
76  	int32_t	linktype;	&bsol;* Link type */
77  	int32_t	tzoff;		&bsol;* Timezone offset - not used by newer clients */
78  };
79  struct rpcap_startcapreq
80  {
81  	uint32_t snaplen;	&bsol;* Length of the snapshot (number of bytes to capture for each packet) */
82  	uint32_t read_timeout;	&bsol;* Read timeout in milliseconds */
83  	uint16_t flags;		&bsol;* Flags (see RPCAP_STARTCAPREQ_FLAG_xxx) */
84  	uint16_t portdata;	&bsol;* Network port on which the client is waiting at (if 'serveropen') */
85  };
86  struct rpcap_startcapreply
87  {
88  	int32_t	 bufsize;	&bsol;* Size of the user buffer allocated by WinPcap; it can be different from the one we chose */
89  	uint16_t portdata;	&bsol;* Network port on which the server is waiting at (passive mode only) */
90  	uint16_t dummy;		&bsol;* Must be zero */
91  };
92  struct rpcap_pkthdr
93  {
94  	uint32_t timestamp_sec;		&bsol;* 'struct timeval' compatible, it represents the 'tv_sec' field */
95  	uint32_t timestamp_usec;	&bsol;* 'struct timeval' compatible, it represents the 'tv_usec' field */
96  	uint32_t caplen;		&bsol;* Length of portion present in the capture */
97  	uint32_t len;			&bsol;* Real length of this packet (off wire) */
98  	uint32_t npkt;			&bsol;* Ordinal number of the packet (i.e. the first one captured has '1', the second one '2', etc) */
99  };
100  struct rpcap_filter
101  {
102  	uint16_t filtertype;	&bsol;* type of the filter transferred (BPF instructions, ...) */
103  	uint16_t dummy;		&bsol;* Must be zero */
104  	uint32_t nitems;	&bsol;* Number of items contained into the filter (e.g. BPF instructions for BPF filters) */
105  };
106  struct rpcap_filterbpf_insn
107  {
108  	uint16_t	code;	&bsol;* opcode of the instruction */
109  	uint8_t		jt;	&bsol;* relative offset to jump to in case of 'true' */
110  	uint8_t		jf;	&bsol;* relative offset to jump to in case of 'false' */
111  	int32_t		k;	&bsol;* instruction-dependent value */
112  };
113  struct rpcap_auth
114  {
115  	uint16_t type;	&bsol;* Authentication type */
116  	uint16_t dummy;	&bsol;* Must be zero */
117  	uint16_t slen1;	&bsol;* Length of the first authentication item (e.g. username) */
118  	uint16_t slen2;	&bsol;* Length of the second authentication item (e.g. password) */
119  };
120  struct rpcap_stats
121  {
122  	uint32_t ifrecv;	&bsol;* Packets received by the kernel filter (i.e. pcap_stats.ps_recv) */
123  	uint32_t ifdrop;	&bsol;* Packets dropped by the network interface (e.g. not enough buffers) (i.e. pcap_stats.ps_ifdrop) */
124  	uint32_t krnldrop;	&bsol;* Packets dropped by the kernel filter (i.e. pcap_stats.ps_drop) */
125  	uint32_t svrcapt;	&bsol;* Packets captured by the RPCAP daemon and sent on the network */
126  };
127  struct rpcap_sampling
128  {
129  	uint8_t  method;	&bsol;* Sampling method */
130  	uint8_t  dummy1;	&bsol;* Must be zero */
131  	uint16_t dummy2;	&bsol;* Must be zero */
132  	uint32_t value;		&bsol;* Parameter related to the sampling method */
133  };
134  #define RPCAP_MSG_IS_REPLY		0x080	&bsol;* Flag indicating a reply */
135  #define RPCAP_MSG_ERROR			0x01	&bsol;* Message that keeps an error notification */
136  #define RPCAP_MSG_FINDALLIF_REQ		0x02	&bsol;* Request to list all the remote interfaces */
137  #define RPCAP_MSG_OPEN_REQ		0x03	&bsol;* Request to open a remote device */
138  #define RPCAP_MSG_STARTCAP_REQ		0x04	&bsol;* Request to start a capture on a remote device */
139  #define RPCAP_MSG_UPDATEFILTER_REQ	0x05	&bsol;* Send a compiled filter into the remote device */
140  #define RPCAP_MSG_CLOSE			0x06	&bsol;* Close the connection with the remote peer */
141  #define RPCAP_MSG_PACKET		0x07	&bsol;* This is a 'data' message, which carries a network packet */
142  #define RPCAP_MSG_AUTH_REQ		0x08	&bsol;* Message that keeps the authentication parameters */
143  #define RPCAP_MSG_STATS_REQ		0x09	&bsol;* It requires to have network statistics */
144  #define RPCAP_MSG_ENDCAP_REQ		0x0A	&bsol;* Stops the current capture, keeping the device open */
145  #define RPCAP_MSG_SETSAMPLING_REQ	0x0B	&bsol;* Set sampling parameters */
146  #define RPCAP_MSG_FINDALLIF_REPLY	(RPCAP_MSG_FINDALLIF_REQ | RPCAP_MSG_IS_REPLY)		&bsol;* Keeps the list of all the remote interfaces */
147  #define RPCAP_MSG_OPEN_REPLY		(RPCAP_MSG_OPEN_REQ | RPCAP_MSG_IS_REPLY)		&bsol;* The remote device has been opened correctly */
148  #define RPCAP_MSG_STARTCAP_REPLY	(RPCAP_MSG_STARTCAP_REQ | RPCAP_MSG_IS_REPLY)		&bsol;* The capture is starting correctly */
149  #define RPCAP_MSG_UPDATEFILTER_REPLY	(RPCAP_MSG_UPDATEFILTER_REQ | RPCAP_MSG_IS_REPLY)	&bsol;* The filter has been applied correctly on the remote device */
150  #define RPCAP_MSG_AUTH_REPLY		(RPCAP_MSG_AUTH_REQ | RPCAP_MSG_IS_REPLY)		&bsol;* Sends a message that says 'ok, authorization successful' */
151  #define RPCAP_MSG_STATS_REPLY		(RPCAP_MSG_STATS_REQ | RPCAP_MSG_IS_REPLY)		&bsol;* Message that keeps the network statistics */
152  #define RPCAP_MSG_ENDCAP_REPLY		(RPCAP_MSG_ENDCAP_REQ | RPCAP_MSG_IS_REPLY)		&bsol;* Confirms that the capture stopped successfully */
153  #define RPCAP_MSG_SETSAMPLING_REPLY	(RPCAP_MSG_SETSAMPLING_REQ | RPCAP_MSG_IS_REPLY)		&bsol;* Confirms that the capture stopped successfully */
154  #define RPCAP_STARTCAPREQ_FLAG_PROMISC		0x00000001	&bsol;* Enables promiscuous mode (default: disabled) */
155  #define RPCAP_STARTCAPREQ_FLAG_DGRAM		0x00000002	&bsol;* Use a datagram (i.e. UDP) connection for the data stream (default: use TCP)*/
156  #define RPCAP_STARTCAPREQ_FLAG_SERVEROPEN	0x00000004	&bsol;* The server has to open the data connection toward the client */
157  #define RPCAP_STARTCAPREQ_FLAG_INBOUND		0x00000008	&bsol;* Capture only inbound packets (take care: the flag has no effect with promiscuous enabled) */
158  #define RPCAP_STARTCAPREQ_FLAG_OUTBOUND		0x00000010	&bsol;* Capture only outbound packets (take care: the flag has no effect with promiscuous enabled) */
159  #define RPCAP_UPDATEFILTER_BPF 1			&bsol;* This code tells us that the filter is encoded with the BPF/NPF syntax */
160  #define PCAP_ERR_NETW			1	&bsol;* Network error */
161  #define PCAP_ERR_INITTIMEOUT		2	&bsol;* The RPCAP initial timeout has expired */
162  #define PCAP_ERR_AUTH			3	&bsol;* Generic authentication error */
163  #define PCAP_ERR_FINDALLIF		4	&bsol;* Generic findalldevs error */
164  #define PCAP_ERR_NOREMOTEIF		5	&bsol;* The findalldevs was ok, but the remote end had no interfaces to list */
165  #define PCAP_ERR_OPEN			6	&bsol;* Generic pcap_open error */
166  #define PCAP_ERR_UPDATEFILTER		7	&bsol;* Generic updatefilter error */
167  #define PCAP_ERR_GETSTATS		8	&bsol;* Generic pcap_stats error */
168  #define PCAP_ERR_READEX			9	&bsol;* Generic pcap_next_ex error */
169  #define PCAP_ERR_HOSTNOAUTH		10	&bsol;* The host is not authorized to connect to this server */
170  #define PCAP_ERR_REMOTEACCEPT		11	&bsol;* Generic pcap_remoteaccept error */
171  #define PCAP_ERR_STARTCAPTURE		12	&bsol;* Generic pcap_startcapture error */
172  #define PCAP_ERR_ENDCAPTURE		13	&bsol;* Generic pcap_endcapture error */
173  #define PCAP_ERR_RUNTIMETIMEOUT		14	&bsol;* The RPCAP run-time timeout has expired */
174  #define PCAP_ERR_SETSAMPLING		15	&bsol;* Error during the settings of sampling parameters */
175  #define PCAP_ERR_WRONGMSG		16	&bsol;* The other end endpoint sent a message which has not been recognized */
176  #define PCAP_ERR_WRONGVER		17	&bsol;* The other end endpoint has a version number that is not compatible with our */
177  #define PCAP_ERR_AUTH_FAILED		18	&bsol;* The user couldn't be authenticated */
178  #define PCAP_ERR_TLS_REQUIRED		19	&bsol;* The server requires TLS to connect */
179  #define PCAP_ERR_AUTH_TYPE_NOTSUP	20	&bsol;* The authentication type isn't supported */
180  #define RPCAP_NETBUF_SIZE 64000
181  #include "sockutils.h"
182  #include "sslutils.h"
183  extern void rpcap_createhdr(struct rpcap_header *header, uint8_t ver, uint8_t type, uint16_t value, uint32_t length);
184  extern const char *rpcap_msg_type_string(uint8_t type);
185  extern int rpcap_senderror(SOCKET sock, SSL *ssl, uint8_t ver, uint16_t errcode, const char *error, char *errbuf);
186  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-poly1305_memory.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-rpcap-protocol.h</div>
                </div>
                <div class="column column_space"><pre><code>3  int poly1305_memory(const unsigned char *key, unsigned long keylen, const unsigned char *in, unsigned long inlen, unsigned char *mac, unsigned long *maclen)
4  {
5     poly1305_state st;
6     int err;
</pre></code></div>
                <div class="column column_space"><pre><code>59  struct rpcap_sockaddr_in6
60  {
61  	uint16_t family;		&bsol;* Address family */
62  	uint16_t port;		&bsol;* Port number */
63  	uint32_t flowinfo;	&bsol;* IPv6 flow information */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    