
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.781477627471384%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-bt-linux.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "pcap-int.h"
5  #include "pcap-bt-linux.h"
6  #include "pcap/bluetooth.h"
7  #include <errno.h>
8  #include <stdlib.h>
9  #include <unistd.h>
10  #include <fcntl.h>
11  #include <string.h>
12  #include <sys/ioctl.h>
13  #include <sys/socket.h>
14  #include <arpa/inet.h>
15  #include <bluetooth/bluetooth.h>
16  #include <bluetooth/hci.h>
17  #define BT_IFACE "bluetooth"
18  #define BT_CTRL_SIZE 128
19  static int bt_activate(pcap_t *);
20  static int bt_read_linux(pcap_t *, int , pcap_handler , u_char *);
21  static int bt_inject_linux(pcap_t *, const void *, int);
22  static int bt_setdirection_linux(pcap_t *, pcap_direction_t);
23  static int bt_stats_linux(pcap_t *, struct pcap_stat *);
24  struct pcap_bt {
25  	int dev_id;		&bsol;* device ID of device we're bound to */
26  };
27  int
28  bt_findalldevs(pcap_if_list_t *devlistp, char *err_str)
29  {
30  	struct hci_dev_list_req *dev_list;
31  	struct hci_dev_req *dev_req;
32  	int sock;
33  	unsigned i;
34  	int ret = 0;
35  	sock  = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
36  	if (sock < 0)
37  	{
38  		if (errno == EAFNOSUPPORT)
39  			return 0;
40  		pcap_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,
41  		    errno, "Can't open raw Bluetooth socket");
42  		return -1;
43  	}
44  	dev_list = malloc(HCI_MAX_DEV * sizeof(*dev_req) + sizeof(*dev_list));
45  	if (!dev_list)
46  	{
47  		snprintf(err_str, PCAP_ERRBUF_SIZE, "Can't allocate %zu bytes for Bluetooth device list",
48  			HCI_MAX_DEV * sizeof(*dev_req) + sizeof(*dev_list));
49  		ret = -1;
50  		goto done;
51  	}
52  	memset(dev_list, 0, sizeof(*dev_list));
53  	dev_list->dev_num = HCI_MAX_DEV;
54  	if (ioctl(sock, HCIGETDEVLIST, (void *) dev_list) < 0)
55  	{
56  		pcap_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,
57  		    errno, "Can't get Bluetooth device list via ioctl");
58  		ret = -1;
59  		goto free;
60  	}
61  	dev_req = dev_list->dev_req;
62  	for (i = 0; i < dev_list->dev_num; i++, dev_req++) {
63  		char dev_name[20], dev_descr[40];
64  		snprintf(dev_name, sizeof(dev_name), BT_IFACE"%u", dev_req->dev_id);
65  		snprintf(dev_descr, sizeof(dev_descr), "Bluetooth adapter number %u", i);
66  		if (pcap_add_dev(devlistp, dev_name, PCAP_IF_WIRELESS, dev_descr, err_str)  == NULL)
67  		{
68  			ret = -1;
69  			break;
70  		}
71  	}
72  free:
73  	free(dev_list);
74  done:
75  	close(sock);
76  	return ret;
77  }
78  pcap_t *
79  bt_create(const char *device, char *ebuf, int *is_ours)
80  {
81  	const char *cp;
82  	char *cpend;
83  	long devnum;
84  	pcap_t *p;
85  	cp = strrchr(device, '/');
86  	if (cp == NULL)
87  		cp = device;
88  	if (strncmp(cp, BT_IFACE, sizeof BT_IFACE - 1) != 0) {
89  		*is_ours = 0;
90  		return NULL;
91  	}
92  	cp += sizeof BT_IFACE - 1;
93  	devnum = strtol(cp, &cpend, 10);
94  	if (cpend == cp || *cpend != '\0') {
95  		*is_ours = 0;
96  		return NULL;
97  	}
98  	if (devnum < 0) {
99  		*is_ours = 0;
100  		return NULL;
101  	}
102  	*is_ours = 1;
103  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_bt);
104  	if (p == NULL)
105  		return (NULL);
106  	p->activate_op = bt_activate;
107  	return (p);
108  }
109  static int
110  bt_activate(pcap_t* handle)
111  {
112  	struct pcap_bt *handlep = handle->priv;
113  	struct sockaddr_hci addr;
114  	int opt;
115  	int		dev_id;
116  	struct hci_filter	flt;
117  	int err = PCAP_ERROR;
118  	if (sscanf(handle->opt.device, BT_IFACE"%d", &dev_id) != 1)
119  	{
120  		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
121  			"Can't get Bluetooth device index from %s",
122  			 handle->opt.device);
123  		return PCAP_ERROR;
124  	}
125  	if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)
126  		handle->snapshot = MAXIMUM_SNAPLEN;
127  	handle->bufsize = BT_CTRL_SIZE+sizeof(pcap_bluetooth_h4_header)+handle->snapshot;
128  	handle->linktype = DLT_BLUETOOTH_HCI_H4_WITH_PHDR;
129  	handle->read_op = bt_read_linux;
130  	handle->inject_op = bt_inject_linux;
131  	handle->setfilter_op = pcap_install_bpf_program; &bsol;* no kernel filtering */
<span onclick='openModal()' class='match'>132  	handle->setdirection_op = bt_setdirection_linux;
133  	handle->set_datalink_op = NULL;	&bsol;* can't change data link type */
134  	handle->getnonblock_op = pcap_getnonblock_fd;
135  	handle->setnonblock_op = pcap_setnonblock_fd;
136  	handle->stats_op = bt_stats_linux;
137  	handlep->dev_id = dev_id;
138  	handle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
</span>139  	if (handle->fd < 0) {
140  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
141  		    errno, "Can't create raw socket");
142  		return PCAP_ERROR;
143  	}
144  	handle->buffer = malloc(handle->bufsize);
145  	if (!handle->buffer) {
146  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
147  		    errno, "Can't allocate dump buffer");
148  		goto close_fail;
149  	}
150  	opt = 1;
151  	if (setsockopt(handle->fd, SOL_HCI, HCI_DATA_DIR, &opt, sizeof(opt)) < 0) {
152  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
153  		    errno, "Can't enable data direction info");
154  		goto close_fail;
155  	}
156  	opt = 1;
157  	if (setsockopt(handle->fd, SOL_HCI, HCI_TIME_STAMP, &opt, sizeof(opt)) < 0) {
158  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
159  		    errno, "Can't enable time stamp");
160  		goto close_fail;
161  	}
162  	memset(&flt, 0, sizeof(flt));
163  	memset((void *) &flt.type_mask, 0xff, sizeof(flt.type_mask));
164  	memset((void *) &flt.event_mask, 0xff, sizeof(flt.event_mask));
165  	if (setsockopt(handle->fd, SOL_HCI, HCI_FILTER, &flt, sizeof(flt)) < 0) {
166  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
167  		    errno, "Can't set filter");
168  		goto close_fail;
169  	}
170  	addr.hci_family = AF_BLUETOOTH;
171  	addr.hci_dev = handlep->dev_id;
172  #ifdef HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL
173  	addr.hci_channel = HCI_CHANNEL_RAW;
174  #endif
175  	if (bind(handle->fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
176  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
177  		    errno, "Can't attach to device %d", handlep->dev_id);
178  		goto close_fail;
179  	}
180  	if (handle->opt.rfmon) {
181  		err = PCAP_ERROR_RFMON_NOTSUP;
182  		goto close_fail;
183  	}
184  	if (handle->opt.buffer_size != 0) {
185  		if (setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF,
186  		    &handle->opt.buffer_size,
187  		    sizeof(handle->opt.buffer_size)) == -1) {
188  			pcap_fmt_errmsg_for_errno(handle->errbuf,
189  			    errno, PCAP_ERRBUF_SIZE, "SO_RCVBUF");
190  			goto close_fail;
191  		}
192  	}
193  	handle->selectable_fd = handle->fd;
194  	return 0;
195  close_fail:
196  	pcap_cleanup_live_common(handle);
197  	return err;
198  }
199  static int
200  bt_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)
201  {
202  	struct cmsghdr *cmsg;
203  	struct msghdr msg;
204  	struct iovec  iv;
205  	ssize_t ret;
206  	struct pcap_pkthdr pkth;
207  	pcap_bluetooth_h4_header* bthdr;
208  	u_char *pktd;
209  	int in = 0;
210  	pktd = handle->buffer + BT_CTRL_SIZE;
211  	bthdr = (pcap_bluetooth_h4_header*)(void *)pktd;
212  	iv.iov_base = pktd + sizeof(pcap_bluetooth_h4_header);
213  	iv.iov_len  = handle->snapshot;
214  	memset(&msg, 0, sizeof(msg));
215  	msg.msg_iov = &iv;
216  	msg.msg_iovlen = 1;
217  	msg.msg_control = handle->buffer;
218  	msg.msg_controllen = BT_CTRL_SIZE;
219  	do {
220  		ret = recvmsg(handle->fd, &msg, 0);
221  		if (handle->break_loop)
222  		{
223  			handle->break_loop = 0;
224  			return -2;
225  		}
226  	} while ((ret == -1) && (errno == EINTR));
227  	if (ret < 0) {
228  		if (errno == EAGAIN || errno == EWOULDBLOCK) {
229  			return 0;
230  		}
231  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
232  		    errno, "Can't receive packet");
233  		return -1;
234  	}
235  	pkth.caplen = (bpf_u_int32)ret;
236  	cmsg = CMSG_FIRSTHDR(&msg);
237  	while (cmsg) {
238  		switch (cmsg->cmsg_type) {
239  			case HCI_CMSG_DIR:
240  				memcpy(&in, CMSG_DATA(cmsg), sizeof in);
241  				break;
242  			case HCI_CMSG_TSTAMP:
243  				memcpy(&pkth.ts, CMSG_DATA(cmsg),
244  					sizeof pkth.ts);
245  				break;
246  		}
247  		cmsg = CMSG_NXTHDR(&msg, cmsg);
248  	}
249  	switch (handle->direction) {
250  	case PCAP_D_IN:
251  		if (!in)
252  			return 0;
253  		break;
254  	case PCAP_D_OUT:
255  		if (in)
256  			return 0;
257  		break;
258  	default:
259  		break;
260  	}
261  	bthdr->direction = htonl(in != 0);
262  	pkth.caplen+=sizeof(pcap_bluetooth_h4_header);
263  	pkth.len = pkth.caplen;
264  	if (handle->fcode.bf_insns == NULL ||
265  	    pcap_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {
266  		callback(user, &pkth, pktd);
267  		return 1;
268  	}
269  	return 0;	&bsol;* didn't pass filter */
270  }
271  static int
272  bt_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)
273  {
274  	snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
275  	    "Packet injection is not supported on Bluetooth devices");
276  	return (-1);
277  }
278  static int
279  bt_stats_linux(pcap_t *handle, struct pcap_stat *stats)
280  {
281  	struct pcap_bt *handlep = handle->priv;
282  	int ret;
283  	struct hci_dev_info dev_info;
284  	struct hci_dev_stats * s = &dev_info.stat;
285  	dev_info.dev_id = handlep->dev_id;
286  	do {
287  		ret = ioctl(handle->fd, HCIGETDEVINFO, (void *)&dev_info);
288  	} while ((ret == -1) && (errno == EINTR));
289  	if (ret < 0) {
290  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
291  		    errno, "Can't get stats via ioctl");
292  		return (-1);
293  	}
294  	stats->ps_recv = s->evt_rx + s->acl_rx + s->sco_rx + s->cmd_tx +
295  		s->acl_tx +s->sco_tx;
296  	stats->ps_drop = s->err_rx + s->err_tx;
297  	stats->ps_ifdrop = 0;
298  	return 0;
299  }
300  static int
301  bt_setdirection_linux(pcap_t *p, pcap_direction_t d)
302  {
303  	p->direction = d;
304  	return 0;
305  }
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_radio.h</h3>
            <pre><code>1  #ifndef NRF_RADIO_H__
2  #define NRF_RADIO_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_RADIO_TASK_TXEN      = offsetof(NRF_RADIO_Type, TASKS_TXEN),      &bsol;**< Enable RADIO in TX mode. */
10      NRF_RADIO_TASK_RXEN      = offsetof(NRF_RADIO_Type, TASKS_RXEN),      &bsol;**< Enable RADIO in RX mode. */
11      NRF_RADIO_TASK_START     = offsetof(NRF_RADIO_Type, TASKS_START),     &bsol;**< Start RADIO. */
12      NRF_RADIO_TASK_STOP      = offsetof(NRF_RADIO_Type, TASKS_STOP),      &bsol;**< Stop RADIO. */
13      NRF_RADIO_TASK_DISABLE   = offsetof(NRF_RADIO_Type, TASKS_DISABLE),   &bsol;**< Disable RADIO. */
14      NRF_RADIO_TASK_RSSISTART = offsetof(NRF_RADIO_Type, TASKS_RSSISTART), &bsol;**< Start the RSSI and take one single sample of the receive signal strength. */
15      NRF_RADIO_TASK_RSSISTOP  = offsetof(NRF_RADIO_Type, TASKS_RSSISTOP),  &bsol;**< Stop the RSSI measurement. */
16      NRF_RADIO_TASK_BCSTART   = offsetof(NRF_RADIO_Type, TASKS_BCSTART),   &bsol;**< Start the bit counter. */
17      NRF_RADIO_TASK_BCSTOP    = offsetof(NRF_RADIO_Type, TASKS_BCSTOP),    &bsol;**< Stop the bit counter. */
18  #if defined(RADIO_TASKS_EDSTART_TASKS_EDSTART_Msk) || defined(__NRFX_DOXYGEN__)
19      NRF_RADIO_TASK_EDSTART   = offsetof(NRF_RADIO_Type, TASKS_EDSTART),   &bsol;**< Start the Energy Detect measurement used in IEEE 802.15.4 mode. */
20  #endif
21  #if defined(RADIO_TASKS_EDSTOP_TASKS_EDSTOP_Msk) || defined(__NRFX_DOXYGEN__)
22      NRF_RADIO_TASK_EDSTOP    = offsetof(NRF_RADIO_Type, TASKS_EDSTOP),    &bsol;**< Stop the Energy Detect measurement. */
23  #endif
24  #if defined(RADIO_TASKS_CCASTART_TASKS_CCASTART_Msk) || defined(__NRFX_DOXYGEN__)
25      NRF_RADIO_TASK_CCASTART  = offsetof(NRF_RADIO_Type, TASKS_CCASTART),  &bsol;**< Start the Clear Channel Assessment used in IEEE 802.15.4 mode. */
26  #endif
27  #if defined(RADIO_TASKS_CCASTOP_TASKS_CCASTOP_Msk) || defined(__NRFX_DOXYGEN__)
28      NRF_RADIO_TASK_CCASTOP   = offsetof(NRF_RADIO_Type, TASKS_CCASTOP),   &bsol;**< Stop the Clear Channel Assessment. */
29  #endif
30  } nrf_radio_task_t;
31  typedef enum
32  {
33      NRF_RADIO_EVENT_READY      = offsetof(NRF_RADIO_Type, EVENTS_READY),      &bsol;**< Radio has ramped up and is ready to be started. */
34      NRF_RADIO_EVENT_ADDRESS    = offsetof(NRF_RADIO_Type, EVENTS_ADDRESS),    &bsol;**< Address sent or received. */
35      NRF_RADIO_EVENT_PAYLOAD    = offsetof(NRF_RADIO_Type, EVENTS_PAYLOAD),    &bsol;**< Packet payload sent or received. */
36      NRF_RADIO_EVENT_END        = offsetof(NRF_RADIO_Type, EVENTS_END),        &bsol;**< Packet transmitted or received. */
37      NRF_RADIO_EVENT_DISABLED   = offsetof(NRF_RADIO_Type, EVENTS_DISABLED),   &bsol;**< RADIO has been disabled. */
38      NRF_RADIO_EVENT_DEVMATCH   = offsetof(NRF_RADIO_Type, EVENTS_DEVMATCH),   &bsol;**< A device address match occurred on the last received packet. */
39      NRF_RADIO_EVENT_DEVMISS    = offsetof(NRF_RADIO_Type, EVENTS_DEVMISS),    &bsol;**< No device address match occurred on the last received packet. */
40      NRF_RADIO_EVENT_RSSIEND    = offsetof(NRF_RADIO_Type, EVENTS_RSSIEND),    &bsol;**< Sampling of receive signal strength complete. */
41      NRF_RADIO_EVENT_BCMATCH    = offsetof(NRF_RADIO_Type, EVENTS_BCMATCH),    &bsol;**< Bit counter reached bit count value. */
42  #if defined(RADIO_INTENSET_CRCOK_Msk) || defined(__NRFX_DOXYGEN__)
43      NRF_RADIO_EVENT_CRCOK      = offsetof(NRF_RADIO_Type, EVENTS_CRCOK),      &bsol;**< Packet received with correct CRC. */
44  #endif
45  #if defined(RADIO_INTENSET_CRCERROR_Msk) || defined(__NRFX_DOXYGEN__)
46      NRF_RADIO_EVENT_CRCERROR   = offsetof(NRF_RADIO_Type, EVENTS_CRCERROR),   &bsol;**< Packet received with incorrect CRC. */
47  #endif
48  #if defined(RADIO_INTENSET_FRAMESTART_Msk) || defined(__NRFX_DOXYGEN__)
49      NRF_RADIO_EVENT_FRAMESTART = offsetof(NRF_RADIO_Type, EVENTS_FRAMESTART), &bsol;**< IEEE 802.15.4 length field received. */
50  #endif
51  #if defined(RADIO_INTENSET_EDEND_Msk) || defined(__NRFX_DOXYGEN__)
52      NRF_RADIO_EVENT_EDEND      = offsetof(NRF_RADIO_Type, EVENTS_EDEND),      &bsol;**< Energy Detection procedure ended. */
53  #endif
54  #if defined(RADIO_INTENSET_EDSTOPPED_Msk) || defined(__NRFX_DOXYGEN__)
55      NRF_RADIO_EVENT_EDSTOPPED  = offsetof(NRF_RADIO_Type, EVENTS_EDSTOPPED),  &bsol;**< The sampling of Energy Detection has stopped. */
56  #endif
57  #if defined(RADIO_INTENSET_CCAIDLE_Msk) || defined(__NRFX_DOXYGEN__)
58      NRF_RADIO_EVENT_CCAIDLE    = offsetof(NRF_RADIO_Type, EVENTS_CCAIDLE),    &bsol;**< Wireless medium in idle - clear to send. */
59  #endif
60  #if defined(RADIO_INTENSET_CCABUSY_Msk) || defined(__NRFX_DOXYGEN__)
61      NRF_RADIO_EVENT_CCABUSY    = offsetof(NRF_RADIO_Type, EVENTS_CCABUSY),    &bsol;**< Wireless medium busy - do not send. */
62  #endif
63  #if defined(RADIO_INTENSET_CCASTOPPED_Msk) || defined(__NRFX_DOXYGEN__)
64      NRF_RADIO_EVENT_CCASTOPPED = offsetof(NRF_RADIO_Type, EVENTS_CCASTOPPED), &bsol;**< The CCA has stopped. */
65  #endif
66  #if defined(RADIO_INTENSET_RATEBOOST_Msk) || defined(__NRFX_DOXYGEN__)
67      NRF_RADIO_EVENT_RATEBOOST  = offsetof(NRF_RADIO_Type, EVENTS_RATEBOOST),  &bsol;**< Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit. */
68  #endif
69  #if defined(RADIO_INTENSET_TXREADY_Msk) || defined(__NRFX_DOXYGEN__)
70      NRF_RADIO_EVENT_TXREADY    = offsetof(NRF_RADIO_Type, EVENTS_TXREADY),    &bsol;**< RADIO has ramped up and is ready to be started TX path. */
71  #endif
72  #if defined(RADIO_INTENSET_RXREADY_Msk) || defined(__NRFX_DOXYGEN__)
73      NRF_RADIO_EVENT_RXREADY    = offsetof(NRF_RADIO_Type, EVENTS_RXREADY),    &bsol;**< RADIO has ramped up and is ready to be started RX path. */
74  #endif
75  #if defined(RADIO_INTENSET_MHRMATCH_Msk) || defined(__NRFX_DOXYGEN__)
76      NRF_RADIO_EVENT_MHRMATCH   = offsetof(NRF_RADIO_Type, EVENTS_MHRMATCH),   &bsol;**< MAC Header match found. */
77  #endif
78  #if defined(RADIO_INTENSET_PHYEND_Msk) || defined(__NRFX_DOXYGEN__)
79      NRF_RADIO_EVENT_PHYEND     = offsetof(NRF_RADIO_Type, EVENTS_PHYEND),     &bsol;**< Generated in Ble_LR125Kbit, Ble_LR500Kbit
80                                                                                     and BleIeee802154_250Kbit modes when last
81                                                                                     bit is sent on the air. */
82  #endif
83  #if defined(RADIO_INTENSET_SYNC_Msk) || defined(__NRFX_DOXYGEN__)
84      NRF_RADIO_EVENT_SYNC       = offsetof(NRF_RADIO_Type, EVENTS_SYNC),       &bsol;**< Generated in Ble_LR125Kbit, Ble_LR500Kbit
85                                                                                     and BleIeee802154_250Kbit modes when possible
86                                                                                     preamble has been received. */
87  #endif
88  } nrf_radio_event_t;
89  typedef enum
90  {
91      NRF_RADIO_INT_READY_MASK      = RADIO_INTENSET_READY_Msk,      &bsol;**< Interrupt on READY event.  */
92      NRF_RADIO_INT_ADDRESS_MASK    = RADIO_INTENSET_ADDRESS_Msk,    &bsol;**< Interrupt on ADDRESS event. */
93      NRF_RADIO_INT_PAYLOAD_MASK    = RADIO_INTENSET_PAYLOAD_Msk,    &bsol;**< Interrupt on PAYLOAD event. */
94      NRF_RADIO_INT_END_MASK        = RADIO_INTENSET_END_Msk,        &bsol;**< Interrupt on END event. */
95      NRF_RADIO_INT_DISABLED_MASK   = RADIO_INTENSET_DISABLED_Msk,   &bsol;**< Interrupt on DISABLED event. */
96      NRF_RADIO_INT_DEVMATCH_MASK   = RADIO_INTENSET_DEVMATCH_Msk,   &bsol;**< Interrupt on DEVMATCH event. */
97      NRF_RADIO_INT_DEVMISS_MASK    = RADIO_INTENSET_DEVMISS_Msk,    &bsol;**< Interrupt on DEVMISS event. */
98      NRF_RADIO_INT_RSSIEND_MASK    = RADIO_INTENSET_RSSIEND_Msk,    &bsol;**< Interrupt on RSSIEND event. */
99      NRF_RADIO_INT_BCMATCH_MASK    = RADIO_INTENSET_BCMATCH_Msk,    &bsol;**< Interrupt on BCMATCH event. */
100  #if defined(RADIO_INTENSET_CRCOK_Msk) || defined(__NRFX_DOXYGEN__)
101      NRF_RADIO_INT_CRCOK_MASK      = RADIO_INTENSET_CRCOK_Msk,      &bsol;**< Interrupt on CRCOK event. */
102  #endif
103  #if defined(RADIO_INTENSET_CRCERROR_Msk) || defined(__NRFX_DOXYGEN__)
104      NRF_RADIO_INT_CRCERROR_MASK   = RADIO_INTENSET_CRCERROR_Msk,   &bsol;**< Interrupt on CRCERROR event. */
105  #endif
106  #if defined(RADIO_INTENSET_FRAMESTART_Msk) || defined(__NRFX_DOXYGEN__)
107      NRF_RADIO_INT_FRAMESTART_MASK = RADIO_INTENSET_FRAMESTART_Msk, &bsol;**< Interrupt on FRAMESTART event. */
108  #endif
109  #if defined(RADIO_INTENSET_EDEND_Msk) || defined(__NRFX_DOXYGEN__)
110      NRF_RADIO_INT_EDEND_MASK      = RADIO_INTENSET_EDEND_Msk,      &bsol;**< Interrupt on EDEND event. */
111  #endif
112  #if defined(RADIO_INTENSET_EDSTOPPED_Msk) || defined(__NRFX_DOXYGEN__)
113      NRF_RADIO_INT_EDSTOPPED_MASK  = RADIO_INTENSET_EDSTOPPED_Msk,  &bsol;**< Interrupt on EDSTOPPED event. */
114  #endif
115  #if defined(RADIO_INTENSET_CCAIDLE_Msk) || defined(__NRFX_DOXYGEN__)
116      NRF_RADIO_INT_CCAIDLE_MASK    = RADIO_INTENSET_CCAIDLE_Msk,    &bsol;**< Interrupt on CCAIDLE event. */
117  #endif
118  #if defined(RADIO_INTENSET_CCABUSY_Msk) || defined(__NRFX_DOXYGEN__)
119      NRF_RADIO_INT_CCABUSY_MASK    = RADIO_INTENSET_CCABUSY_Msk,    &bsol;**< Interrupt on CCABUSY event. */
120  #endif
121  #if defined(RADIO_INTENSET_CCASTOPPED_Msk) || defined(__NRFX_DOXYGEN__)
122      NRF_RADIO_INT_CCASTOPPED_MASK = RADIO_INTENSET_CCASTOPPED_Msk, &bsol;**< Interrupt on CCASTOPPED event. */
123  #endif
124  #if defined(RADIO_INTENSET_RATEBOOST_Msk) || defined(__NRFX_DOXYGEN__)
125      NRF_RADIO_INT_RATEBOOST_MASK  = RADIO_INTENSET_RATEBOOST_Msk,  &bsol;**< Interrupt on RATEBOOST event. */
126  #endif
127  #if defined(RADIO_INTENSET_TXREADY_Msk) || defined(__NRFX_DOXYGEN__)
128      NRF_RADIO_INT_TXREADY_MASK    = RADIO_INTENSET_TXREADY_Msk,    &bsol;**< Interrupt on TXREADY event. */
129  #endif
130  #if defined(RADIO_INTENSET_RXREADY_Msk) || defined(__NRFX_DOXYGEN__)
131      NRF_RADIO_INT_RXREADY_MASK    = RADIO_INTENSET_RXREADY_Msk,    &bsol;**< Interrupt on RXREADY event. */
132  #endif
133  #if defined(RADIO_INTENSET_MHRMATCH_Msk) || defined(__NRFX_DOXYGEN__)
134      NRF_RADIO_INT_MHRMATCH_MASK   = RADIO_INTENSET_MHRMATCH_Msk,   &bsol;**< Interrupt on MHRMATCH event. */
135  #endif
136  #if defined(RADIO_INTENSET_PHYEND_Msk) || defined(__NRFX_DOXYGEN__)
<span onclick='openModal()' class='match'>137      NRF_RADIO_INT_PHYEND_MASK     = RADIO_INTENSET_PHYEND_Msk,     &bsol;**< Interrupt on PHYEND event. */
138  #endif
139  #if defined(RADIO_INTENSET_SYNC_Msk) || defined(__NRFX_DOXYGEN__)
140      NRF_RADIO_INT_SYNC_MASK       = RADIO_INTENSET_SYNC_Msk,       &bsol;**< Interrupt on SYNC event. */
141  #endif
142  } nrf_radio_int_mask_t;
143  typedef enum
144  {
145      NRF_RADIO_SHORT_READY_START_MASK        = RADIO_SHORTS_READY_START_Msk,        &bsol;**< Shortcut between READY event and START task. */
146      NRF_RADIO_SHORT_END_DISABLE_MASK        = RADIO_SHORTS_END_DISABLE_Msk,        &bsol;**< Shortcut between END event and DISABLE task. */
147      NRF_RADIO_SHORT_DISABLED_TXEN_MASK      = RADIO_SHORTS_DISABLED_TXEN_Msk,      &bsol;**< Shortcut between DISABLED event and TXEN task. */
148      NRF_RADIO_SHORT_DISABLED_RXEN_MASK      = RADIO_SHORTS_DISABLED_RXEN_Msk,      &bsol;**< Shortcut between DISABLED event and RXEN task. */
149      NRF_RADIO_SHORT_ADDRESS_RSSISTART_MASK  = RADIO_SHORTS_ADDRESS_RSSISTART_Msk,  &bsol;**< Shortcut between ADDRESS event and RSSISTART task. */
</span>150      NRF_RADIO_SHORT_END_START_MASK          = RADIO_SHORTS_END_START_Msk,          &bsol;**< Shortcut between END event and START task. */
151      NRF_RADIO_SHORT_ADDRESS_BCSTART_MASK    = RADIO_SHORTS_ADDRESS_BCSTART_Msk,    &bsol;**< Shortcut between ADDRESS event and BCSTART task. */
152      NRF_RADIO_SHORT_DISABLED_RSSISTOP_MASK  = RADIO_SHORTS_DISABLED_RSSISTOP_Msk,  &bsol;**< Shortcut between DISABLED event and RSSISTOP task. */
153  #if defined(RADIO_SHORTS_RXREADY_CCASTART_Msk) || defined(__NRFX_DOXYGEN__)
154      NRF_RADIO_SHORT_RXREADY_CCASTART_MASK   = RADIO_SHORTS_RXREADY_CCASTART_Msk,   &bsol;**< Shortcut between RXREADY event and CCASTART task. */
155  #endif
156  #if defined(RADIO_SHORTS_CCAIDLE_TXEN_Msk) || defined(__NRFX_DOXYGEN__)
157      NRF_RADIO_SHORT_CCAIDLE_TXEN_MASK       = RADIO_SHORTS_CCAIDLE_TXEN_Msk,       &bsol;**< Shortcut between CCAIDLE event and TXEN task. */
158  #endif
159  #if defined(RADIO_SHORTS_CCABUSY_DISABLE_Msk) || defined(__NRFX_DOXYGEN__)
160      NRF_RADIO_SHORT_CCABUSY_DISABLE_MASK    = RADIO_SHORTS_CCABUSY_DISABLE_Msk,    &bsol;**< Shortcut between CCABUSY event and DISABLE task. */
161  #endif
162  #if defined(RADIO_SHORTS_FRAMESTART_BCSTART_Msk) || defined(__NRFX_DOXYGEN__)
163      NRF_RADIO_SHORT_FRAMESTART_BCSTART_MASK = RADIO_SHORTS_FRAMESTART_BCSTART_Msk, &bsol;**< Shortcut between FRAMESTART event and BCSTART task. */
164  #endif
165  #if defined(RADIO_SHORTS_READY_EDSTART_Msk) || defined(__NRFX_DOXYGEN__)
166      NRF_RADIO_SHORT_READY_EDSTART_MASK      = RADIO_SHORTS_READY_EDSTART_Msk,      &bsol;**< Shortcut between READY event and EDSTART task. */
167  #endif
168  #if defined(RADIO_SHORTS_EDEND_DISABLE_Msk) || defined(__NRFX_DOXYGEN__)
169      NRF_RADIO_SHORT_EDEND_DISABLE_MASK      = RADIO_SHORTS_EDEND_DISABLE_Msk,      &bsol;**< Shortcut between EDEND event and DISABLE task. */
170  #endif
171  #if defined(RADIO_SHORTS_CCAIDLE_STOP_Msk) || defined(__NRFX_DOXYGEN__)
172      NRF_RADIO_SHORT_CCAIDLE_STOP_MASK       = RADIO_SHORTS_CCAIDLE_STOP_Msk,       &bsol;**< Shortcut between CCAIDLE event and STOP task. */
173  #endif
174  #if defined(RADIO_SHORTS_TXREADY_START_Msk) || defined(__NRFX_DOXYGEN__)
175      NRF_RADIO_SHORT_TXREADY_START_MASK      = RADIO_SHORTS_TXREADY_START_Msk,      &bsol;**< Shortcut between TXREADY event and START task. */
176  #endif
177  #if defined(RADIO_SHORTS_RXREADY_START_Msk) || defined(__NRFX_DOXYGEN__)
178      NRF_RADIO_SHORT_RXREADY_START_MASK      = RADIO_SHORTS_RXREADY_START_Msk,      &bsol;**< Shortcut between RXREADY event and START task. */
179  #endif
180  #if defined(RADIO_SHORTS_PHYEND_DISABLE_Msk) || defined(__NRFX_DOXYGEN__)
181      NRF_RADIO_SHORT_PHYEND_DISABLE_MASK     = RADIO_SHORTS_PHYEND_DISABLE_Msk,     &bsol;**< Shortcut between PHYEND event and DISABLE task. */
182  #endif
183  #if defined(RADIO_SHORTS_PHYEND_START_Msk) || defined(__NRFX_DOXYGEN__)
184      NRF_RADIO_SHORT_PHYEND_START_MASK       = RADIO_SHORTS_PHYEND_START_Msk,       &bsol;**< Shortcut between PHYEND event and START task. */
185  #endif
186  } nrf_radio_short_mask_t;
187  #if defined(RADIO_CCACTRL_CCAMODE_Msk) || defined(__NRFX_DOXYGEN__)
188  typedef enum
189  {
190      NRF_RADIO_CCA_MODE_ED             = RADIO_CCACTRL_CCAMODE_EdMode,           &bsol;**< Energy Above Threshold. Will report busy whenever energy is detected above set threshold. */
191      NRF_RADIO_CCA_MODE_CARRIER        = RADIO_CCACTRL_CCAMODE_CarrierMode,      &bsol;**< Carrier Seen. Will report busy whenever compliant IEEE 802.15.4 signal is seen. */
192      NRF_RADIO_CCA_MODE_CARRIER_AND_ED = RADIO_CCACTRL_CCAMODE_CarrierAndEdMode, &bsol;**< Energy Above Threshold AND Carrier Seen. */
193      NRF_RADIO_CCA_MODE_CARRIER_OR_ED  = RADIO_CCACTRL_CCAMODE_CarrierOrEdMode,  &bsol;**< Energy Above Threshold OR Carrier Seen. */
194      NRF_RADIO_CCA_MODE_ED_TEST1       = RADIO_CCACTRL_CCAMODE_EdModeTest1,      &bsol;**< Energy Above Threshold test mode that will abort when first ED measurement over threshold is seen. No averaging. */
195  } nrf_radio_cca_mode_t;
196  #endif 
197  typedef enum
198  {
199      NRF_RADIO_STATE_DISABLED  = RADIO_STATE_STATE_Disabled,  &bsol;**< No operations are going on inside the radio and the power consumption is at a minimum. */
200      NRF_RADIO_STATE_RXRU      = RADIO_STATE_STATE_RxRu,      &bsol;**< The radio is ramping up and preparing for reception. */
201      NRF_RADIO_STATE_RXIDLE    = RADIO_STATE_STATE_RxIdle,    &bsol;**< The radio is ready for reception to start. */
202      NRF_RADIO_STATE_RX        = RADIO_STATE_STATE_Rx,        &bsol;**< Reception has been started. */
203      NRF_RADIO_STATE_RXDISABLE = RADIO_STATE_STATE_RxDisable, &bsol;**< The radio is disabling the receiver. */
204      NRF_RADIO_STATE_TXRU      = RADIO_STATE_STATE_TxRu,      &bsol;**< The radio is ramping up and preparing for transmission. */
205      NRF_RADIO_STATE_TXIDLE    = RADIO_STATE_STATE_TxIdle,    &bsol;**< The radio is ready for transmission to start. */
206      NRF_RADIO_STATE_TX        = RADIO_STATE_STATE_Tx,        &bsol;**< The radio is transmitting a packet. */
207      NRF_RADIO_STATE_TXDISABLE = RADIO_STATE_STATE_TxDisable, &bsol;**< The radio is disabling the transmitter. */
208  } nrf_radio_state_t;
209  typedef enum
210  {
211  #if defined(RADIO_TXPOWER_TXPOWER_Pos8dBm) || defined(__NRFX_DOXYGEN__)
212      NRF_RADIO_TXPOWER_POS8DBM  = RADIO_TXPOWER_TXPOWER_Pos8dBm,  &bsol;**< 8 dBm. */
213  #endif
214  #if defined(RADIO_TXPOWER_TXPOWER_Pos7dBm) || defined(__NRFX_DOXYGEN__)
215      NRF_RADIO_TXPOWER_POS7DBM  = RADIO_TXPOWER_TXPOWER_Pos7dBm,  &bsol;**< 7 dBm. */
216  #endif
217  #if defined(RADIO_TXPOWER_TXPOWER_Pos6dBm) || defined(__NRFX_DOXYGEN__)
218      NRF_RADIO_TXPOWER_POS6DBM  = RADIO_TXPOWER_TXPOWER_Pos6dBm,  &bsol;**< 6 dBm. */
219  #endif
220  #if defined(RADIO_TXPOWER_TXPOWER_Pos5dBm) || defined(__NRFX_DOXYGEN__)
221      NRF_RADIO_TXPOWER_POS5DBM  = RADIO_TXPOWER_TXPOWER_Pos5dBm,  &bsol;**< 5 dBm. */
222  #endif
223  #if defined(RADIO_TXPOWER_TXPOWER_Pos4dBm) || defined(__NRFX_DOXYGEN__)
224      NRF_RADIO_TXPOWER_POS4DBM  = RADIO_TXPOWER_TXPOWER_Pos4dBm,  &bsol;**< 4 dBm. */
225  #endif
226  #if defined(RADIO_TXPOWER_TXPOWER_Pos3dBm) || defined(__NRFX_DOXYGEN__)
227      NRF_RADIO_TXPOWER_POS3DBM  = RADIO_TXPOWER_TXPOWER_Pos3dBm,  &bsol;**< 3 dBm. */
228  #endif
229  #if defined(RADIO_TXPOWER_TXPOWER_Pos2dBm) || defined(__NRFX_DOXYGEN__)
230      NRF_RADIO_TXPOWER_POS2DBM  = RADIO_TXPOWER_TXPOWER_Pos2dBm,  &bsol;**< 2 dBm. */
231  #endif
232      NRF_RADIO_TXPOWER_0DBM     = RADIO_TXPOWER_TXPOWER_0dBm,     &bsol;**< 0 dBm. */
233      NRF_RADIO_TXPOWER_NEG4DBM  = RADIO_TXPOWER_TXPOWER_Neg4dBm,  &bsol;**< -4 dBm. */
234      NRF_RADIO_TXPOWER_NEG8DBM  = RADIO_TXPOWER_TXPOWER_Neg8dBm,  &bsol;**< -8 dBm. */
235      NRF_RADIO_TXPOWER_NEG12DBM = RADIO_TXPOWER_TXPOWER_Neg12dBm, &bsol;**< -12 dBm. */
236      NRF_RADIO_TXPOWER_NEG16DBM = RADIO_TXPOWER_TXPOWER_Neg16dBm, &bsol;**< -16 dBm. */
237      NRF_RADIO_TXPOWER_NEG20DBM = RADIO_TXPOWER_TXPOWER_Neg20dBm, &bsol;**< -20 dBm. */
238      NRF_RADIO_TXPOWER_NEG30DBM = RADIO_TXPOWER_TXPOWER_Neg30dBm, &bsol;**< -30 dBm. */
239  #if defined(RADIO_TXPOWER_TXPOWER_Neg40dBm) || defined(__NRFX_DOXYGEN__)
240      NRF_RADIO_TXPOWER_NEG40DBM = RADIO_TXPOWER_TXPOWER_Neg40dBm, &bsol;**< -40 dBm. */
241  #endif
242  } nrf_radio_txpower_t;
243  typedef enum
244  {
245      NRF_RADIO_MODE_NRF_1MBIT          = RADIO_MODE_MODE_Nrf_1Mbit,          &bsol;**< 1Mbit/s Nordic proprietary radio mode. */
246      NRF_RADIO_MODE_NRF_2MBIT          = RADIO_MODE_MODE_Nrf_2Mbit,          &bsol;**< 2Mbit/s Nordic proprietary radio mode. */
247  #if defined(RADIO_MODE_MODE_Nrf_250Kbit) || defined(__NRFX_DOXYGEN__)
248      NRF_RADIO_MODE_NRF_250KBIT        = RADIO_MODE_MODE_Nrf_250Kbit,        &bsol;**< 250Kbit/s Nordic proprietary radio mode. */
249  #endif
250      NRF_RADIO_MODE_BLE_1MBIT          = RADIO_MODE_MODE_Ble_1Mbit,          &bsol;**< 1 Mbit/s Bluetooth Low Energy. */
251  #if defined(RADIO_MODE_MODE_Ble_2Mbit) || defined(__NRFX_DOXYGEN__)
252      NRF_RADIO_MODE_BLE_2MBIT          = RADIO_MODE_MODE_Ble_2Mbit,          &bsol;**< 2 Mbit/s Bluetooth Low Energy. */
253  #endif
254  #if defined(RADIO_MODE_MODE_Ble_LR125Kbit) || defined(__NRFX_DOXYGEN__)
255      NRF_RADIO_MODE_BLE_LR125KBIT      = RADIO_MODE_MODE_Ble_LR125Kbit,      &bsol;*!< Bluetooth Low Energy Long range 125 kbit/s TX, 125 kbit/s and 500 kbit/s RX */
256  #endif
257  #if defined(RADIO_MODE_MODE_Ble_LR500Kbit) || defined(__NRFX_DOXYGEN__)
258      NRF_RADIO_MODE_BLE_LR500KBIT      = RADIO_MODE_MODE_Ble_LR500Kbit,      &bsol;*!< Bluetooth Low Energy Long range 500 kbit/s TX, 125 kbit/s and 500 kbit/s RX */
259  #endif
260  #if defined(RADIO_MODE_MODE_Ieee802154_250Kbit) || defined(__NRFX_DOXYGEN__)
261      NRF_RADIO_MODE_IEEE802154_250KBIT = RADIO_MODE_MODE_Ieee802154_250Kbit, &bsol;**< IEEE 802.15.4-2006 250 kbit/s. */
262  #endif
263  } nrf_radio_mode_t;
264  #if defined(RADIO_PCNF0_PLEN_Msk) || defined(__NRFX_DOXYGEN__)
265  typedef enum
266  {
267      NRF_RADIO_PREAMBLE_LENGTH_8BIT       = RADIO_PCNF0_PLEN_8bit,      &bsol;**< 8-bit preamble. */
268      NRF_RADIO_PREAMBLE_LENGTH_16BIT      = RADIO_PCNF0_PLEN_16bit,     &bsol;**< 16-bit preamble. */
269  #if defined(RADIO_PCNF0_PLEN_32bitZero) || defined(__NRFX_DOXYGEN__)
270      NRF_RADIO_PREAMBLE_LENGTH_32BIT_ZERO = RADIO_PCNF0_PLEN_32bitZero, &bsol;**< 32-bit zero preamble used for IEEE 802.15.4. */
271  #endif
272  #if defined(RADIO_PCNF0_PLEN_LongRange) || defined(__NRFX_DOXYGEN__)
273      NRF_RADIO_PREAMBLE_LENGTH_LONG_RANGE = RADIO_PCNF0_PLEN_LongRange, &bsol;**< Preamble - used for BTLE Long Range. */
274  #endif
275  } nrf_radio_preamble_length_t;
276  #endif 
277  typedef enum
278  {
279      NRF_RADIO_CRC_ADDR_INCLUDE    = RADIO_CRCCNF_SKIPADDR_Include,    &bsol;**< CRC calculation includes address field. */
280      NRF_RADIO_CRC_ADDR_SKIP       = RADIO_CRCCNF_SKIPADDR_Skip,       &bsol;**< CRC calculation does not include address field. */
281  #if defined(RADIO_CRCCNF_SKIPADDR_Ieee802154) || defined(__NRFX_DOXYGEN__)
282      NRF_RADIO_CRC_ADDR_IEEE802154 = RADIO_CRCCNF_SKIPADDR_Ieee802154, &bsol;**< CRC calculation as per 802.15.4 standard. */
283  #endif
284  } nrf_radio_crc_addr_t;
285  typedef struct
286  {
287      uint8_t lflen;                    &bsol;**< Length on air of LENGTH field in number of bits. */
288      uint8_t s0len;                    &bsol;**< Length on air of S0 field in number of bytes. */
289      uint8_t s1len;                    &bsol;**< Length on air of S1 field in number of bits. */
290  #if defined(RADIO_PCNF0_S1INCL_Msk) || defined(__NRFX_DOXYGEN__)
291      bool s1incl;                      &bsol;**< Include or exclude S1 field in RAM. */
292  #endif
293  #if defined(RADIO_PCNF0_CILEN_Msk) || defined(__NRFX_DOXYGEN__)
294      uint8_t cilen;                    &bsol;**< Length of code indicator - long range. */
295  #endif
296  #if defined(RADIO_PCNF0_PLEN_Msk) || defined(__NRFX_DOXYGEN__)
297      nrf_radio_preamble_length_t plen; &bsol;**< Length of preamble on air. Decision point: TASKS_START task. */
298  #endif
299  #if defined(RADIO_PCNF0_CRCINC_Msk) || defined(__NRFX_DOXYGEN__)
300      bool crcinc;                      &bsol;**< Indicates if LENGTH field contains CRC or not. */
301  #endif
302  #if defined(RADIO_PCNF0_TERMLEN_Msk) || defined(__NRFX_DOXYGEN__)
303      uint8_t termlen;                  &bsol;**< Length of TERM field in Long Range operation. */
304  #endif
305      uint8_t maxlen;                   &bsol;**< Maximum length of packet payload. */
306      uint8_t statlen;                  &bsol;**< Static length in number of bytes. */
307      uint8_t balen;                    &bsol;**< Base address length in number of bytes. */
308      bool big_endian;                  &bsol;**< On air endianness of packet. */
309      bool whiteen;                     &bsol;**< Enable or disable packet whitening. */
310  } nrf_radio_packet_conf_t;
311  NRF_STATIC_INLINE void nrf_radio_task_trigger(NRF_RADIO_Type * p_reg, nrf_radio_task_t task);
312  NRF_STATIC_INLINE uint32_t nrf_radio_task_address_get(NRF_RADIO_Type const * p_reg,
313                                                        nrf_radio_task_t       task);
314  NRF_STATIC_INLINE void nrf_radio_event_clear(NRF_RADIO_Type * p_reg, nrf_radio_event_t event);
315  NRF_STATIC_INLINE bool nrf_radio_event_check(NRF_RADIO_Type const * p_reg, nrf_radio_event_t event);
316  NRF_STATIC_INLINE uint32_t nrf_radio_event_address_get(NRF_RADIO_Type const * p_reg,
317                                                         nrf_radio_event_t      event);
318  NRF_STATIC_INLINE void nrf_radio_shorts_enable(NRF_RADIO_Type * p_reg, uint32_t shorts_mask);
319  NRF_STATIC_INLINE void nrf_radio_shorts_disable(NRF_RADIO_Type * p_reg, uint32_t shorts_mask);
320  NRF_STATIC_INLINE void nrf_radio_shorts_set(NRF_RADIO_Type * p_reg, uint32_t shorts_mask);
321  NRF_STATIC_INLINE uint32_t nrf_radio_shorts_get(NRF_RADIO_Type const * p_reg);
322  NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask);
323  NRF_STATIC_INLINE void nrf_radio_int_disable(NRF_RADIO_Type * p_reg, uint32_t mask);
324  NRF_STATIC_INLINE uint32_t nrf_radio_int_enable_check(NRF_RADIO_Type const * p_reg, uint32_t mask);
325  NRF_STATIC_INLINE bool nrf_radio_crc_status_check(NRF_RADIO_Type const * p_reg);
326  NRF_STATIC_INLINE uint8_t nrf_radio_rxmatch_get(NRF_RADIO_Type const * p_reg);
327  NRF_STATIC_INLINE uint32_t nrf_radio_rxcrc_get(NRF_RADIO_Type const * p_reg);
328  NRF_STATIC_INLINE uint8_t nrf_radio_dai_get(NRF_RADIO_Type const * p_reg);
329  #if defined(RADIO_PDUSTAT_PDUSTAT_Msk) || defined(__NRFX_DOXYGEN__)
330  NRF_STATIC_INLINE uint8_t nrf_radio_pdustat_get(NRF_RADIO_Type const * p_reg);
331  NRF_STATIC_INLINE uint8_t nrf_radio_cistat_get(NRF_RADIO_Type const * p_reg);
332  #endif 
333  NRF_STATIC_INLINE void nrf_radio_packetptr_set(NRF_RADIO_Type * p_reg, void const * p_packet);
334  NRF_STATIC_INLINE void * nrf_radio_packetptr_get(NRF_RADIO_Type const * p_reg);
335  NRF_STATIC_INLINE void nrf_radio_frequency_set(NRF_RADIO_Type * p_reg, uint16_t radio_frequency);
336  NRF_STATIC_INLINE uint16_t nrf_radio_frequency_get(NRF_RADIO_Type const * p_reg);
337  NRF_STATIC_INLINE void nrf_radio_txpower_set(NRF_RADIO_Type * p_reg, nrf_radio_txpower_t tx_power);
338  NRF_STATIC_INLINE nrf_radio_txpower_t nrf_radio_txpower_get(NRF_RADIO_Type const * p_reg);
339  NRF_STATIC_INLINE void nrf_radio_mode_set(NRF_RADIO_Type * p_reg, nrf_radio_mode_t radio_mode);
340  NRF_STATIC_INLINE nrf_radio_mode_t nrf_radio_mode_get(NRF_RADIO_Type const * p_reg);
341  NRF_STATIC_INLINE void nrf_radio_packet_configure(NRF_RADIO_Type *                p_reg,
342                                                    nrf_radio_packet_conf_t const * p_config);
343  NRF_STATIC_INLINE void nrf_radio_base0_set(NRF_RADIO_Type * p_reg, uint32_t address);
344  NRF_STATIC_INLINE uint32_t nrf_radio_base0_get(NRF_RADIO_Type const * p_reg);
345  NRF_STATIC_INLINE void nrf_radio_base1_set(NRF_RADIO_Type * p_reg, uint32_t address);
346  NRF_STATIC_INLINE uint32_t nrf_radio_base1_get(NRF_RADIO_Type const * p_reg);
347  NRF_STATIC_INLINE void nrf_radio_prefix0_set(NRF_RADIO_Type * p_reg, uint32_t prefixes);
348  NRF_STATIC_INLINE uint32_t nrf_radio_prefix0_get(NRF_RADIO_Type const * p_reg);
349  NRF_STATIC_INLINE void nrf_radio_prefix1_set(NRF_RADIO_Type * p_reg, uint32_t prefixes);
350  NRF_STATIC_INLINE uint32_t nrf_radio_prefix1_get(NRF_RADIO_Type const * p_reg);
351  NRF_STATIC_INLINE void nrf_radio_txaddress_set(NRF_RADIO_Type * p_reg, uint8_t txaddress);
352  NRF_STATIC_INLINE uint8_t nrf_radio_txaddress_get(NRF_RADIO_Type const * p_reg);
353  NRF_STATIC_INLINE void nrf_radio_rxaddresses_set(NRF_RADIO_Type * p_reg, uint8_t rxaddresses);
354  NRF_STATIC_INLINE uint8_t nrf_radio_rxaddresses_get(NRF_RADIO_Type const * p_reg);
355  NRF_STATIC_INLINE void nrf_radio_crc_configure(NRF_RADIO_Type *     p_reg,
356                                                 uint8_t              crc_length,
357                                                 nrf_radio_crc_addr_t crc_address,
358                                                 uint32_t             crc_polynominal);
359  NRF_STATIC_INLINE void nrf_radio_crcinit_set(NRF_RADIO_Type * p_reg, uint32_t crc_init_value);
360  NRF_STATIC_INLINE uint32_t nrf_radio_crcinit_get(NRF_RADIO_Type const * p_reg);
361  NRF_STATIC_INLINE void nrf_radio_ifs_set(NRF_RADIO_Type * p_reg, uint32_t radio_ifs);
362  NRF_STATIC_INLINE uint32_t nrf_radio_ifs_get(NRF_RADIO_Type const * p_reg);
363  NRF_STATIC_INLINE uint8_t nrf_radio_rssi_sample_get(NRF_RADIO_Type const * p_reg);
364  NRF_STATIC_INLINE nrf_radio_state_t nrf_radio_state_get(NRF_RADIO_Type const * p_reg);
365  NRF_STATIC_INLINE void nrf_radio_datawhiteiv_set(NRF_RADIO_Type * p_reg, uint8_t datawhiteiv);
366  NRF_STATIC_INLINE uint8_t nrf_radio_datawhiteiv_get(NRF_RADIO_Type const * p_reg);
367  NRF_STATIC_INLINE void nrf_radio_bcc_set(NRF_RADIO_Type * p_reg, uint32_t radio_bcc);
368  NRF_STATIC_INLINE uint32_t nrf_radio_bcc_get(NRF_RADIO_Type const * p_reg);
369  NRF_STATIC_INLINE void nrf_radio_dab_set(NRF_RADIO_Type * p_reg,
370                                           uint32_t         dab_value,
371                                           uint8_t          segment);
372  NRF_STATIC_INLINE uint32_t nrf_radio_dab_get(NRF_RADIO_Type const * p_reg, uint8_t segment);
373  NRF_STATIC_INLINE void nrf_radio_dap_set(NRF_RADIO_Type * p_reg,
374                                           uint16_t         dap_value,
375                                           uint8_t          prefix_index);
376  NRF_STATIC_INLINE uint32_t nrf_radio_dap_get(NRF_RADIO_Type const * p_reg, uint8_t prefix_index);
377  NRF_STATIC_INLINE void nrf_radio_dacnf_set(NRF_RADIO_Type * p_reg, uint8_t ena, uint8_t txadd);
378  NRF_STATIC_INLINE uint8_t nrf_radio_dacnf_ena_get(NRF_RADIO_Type const * p_reg);
379  NRF_STATIC_INLINE uint8_t nrf_radio_dacnf_txadd_get(NRF_RADIO_Type const * p_reg);
380  #if defined(RADIO_INTENSET_MHRMATCH_Msk) || defined(__NRFX_DOXYGEN__)
381  NRF_STATIC_INLINE
382  void nrf_radio_mhmu_search_pattern_set(NRF_RADIO_Type * p_reg,
383                                         uint32_t         radio_mhmu_search_pattern);
384  NRF_STATIC_INLINE uint32_t nrf_radio_mhmu_search_pattern_get(NRF_RADIO_Type const * p_reg);
385  NRF_STATIC_INLINE void nrf_radio_mhmu_pattern_mask_set(NRF_RADIO_Type * p_reg,
386                                                         uint32_t         radio_mhmu_pattern_mask);
387  NRF_STATIC_INLINE uint32_t nrf_radio_mhmu_pattern_mask_get(NRF_RADIO_Type const * p_reg);
388  #endif 
389  #if defined(RADIO_MODECNF0_RU_Msk) || defined(__NRFX_DOXYGEN__)
390  NRF_STATIC_INLINE void nrf_radio_modecnf0_set(NRF_RADIO_Type * p_reg,
391                                                bool             fast_ramp_up,
392                                                uint8_t          default_tx);
393  NRF_STATIC_INLINE bool nrf_radio_modecnf0_ru_get(NRF_RADIO_Type const * p_reg);
394  NRF_STATIC_INLINE uint8_t nrf_radio_modecnf0_dtx_get(NRF_RADIO_Type const * p_reg);
395  #endif 
396  #if defined(RADIO_SFD_SFD_Msk) || defined(__NRFX_DOXYGEN__)
397  NRF_STATIC_INLINE void nrf_radio_sfd_set(NRF_RADIO_Type * p_reg, uint8_t sfd);
398  NRF_STATIC_INLINE uint8_t nrf_radio_sfd_get(NRF_RADIO_Type const * p_reg);
399  #endif 
400  #if defined(RADIO_EDCNT_EDCNT_Msk) || defined(__NRFX_DOXYGEN__)
401  NRF_STATIC_INLINE void nrf_radio_ed_loop_count_set(NRF_RADIO_Type * p_reg, uint32_t ed_loop_count);
402  #endif 
403  #if defined(RADIO_EDSAMPLE_EDLVL_Msk) || defined(__NRFX_DOXYGEN__)
404  NRF_STATIC_INLINE uint8_t nrf_radio_ed_sample_get(NRF_RADIO_Type const * p_reg);
405  #endif 
406  #if defined(RADIO_CCACTRL_CCAMODE_Msk) || defined(__NRFX_DOXYGEN__)
407  NRF_STATIC_INLINE void nrf_radio_cca_configure(NRF_RADIO_Type *     p_reg,
408                                                 nrf_radio_cca_mode_t cca_mode,
409                                                 uint8_t              cca_ed_threshold,
410                                                 uint8_t              cca_corr_threshold,
411                                                 uint8_t              cca_corr_cnt);
412  #endif 
413  NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power);
414  #ifndef NRF_DECLARE_ONLY
415  NRF_STATIC_INLINE void nrf_radio_task_trigger(NRF_RADIO_Type * p_reg, nrf_radio_task_t task)
416  {
417      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
418  }
419  NRF_STATIC_INLINE uint32_t nrf_radio_task_address_get(NRF_RADIO_Type const * p_reg,
420                                                        nrf_radio_task_t       task)
421  {
422      return ((uint32_t)p_reg + (uint32_t)task);
423  }
424  NRF_STATIC_INLINE void nrf_radio_event_clear(NRF_RADIO_Type * p_reg, nrf_radio_event_t event)
425  {
426      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
427  #if __CORTEX_M == 0x04
428      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
429      (void)dummy;
430  #endif
431  }
432  NRF_STATIC_INLINE bool nrf_radio_event_check(NRF_RADIO_Type const * p_reg, nrf_radio_event_t event)
433  {
434      return (bool) *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
435  }
436  NRF_STATIC_INLINE uint32_t nrf_radio_event_address_get(NRF_RADIO_Type const * p_reg,
437                                                         nrf_radio_event_t      event)
438  {
439      return ((uint32_t)p_reg + (uint32_t)event);
440  }
441  NRF_STATIC_INLINE void nrf_radio_shorts_enable(NRF_RADIO_Type * p_reg, uint32_t shorts_mask)
442  {
443      p_reg->SHORTS |= shorts_mask;
444  }
445  NRF_STATIC_INLINE void nrf_radio_shorts_disable(NRF_RADIO_Type * p_reg, uint32_t shorts_mask)
446  {
447      p_reg->SHORTS &= ~shorts_mask;
448  }
449  NRF_STATIC_INLINE void nrf_radio_shorts_set(NRF_RADIO_Type * p_reg, uint32_t shorts_mask)
450  {
451      p_reg->SHORTS = shorts_mask;
452  }
453  NRF_STATIC_INLINE uint32_t nrf_radio_shorts_get(NRF_RADIO_Type const * p_reg)
454  {
455      return p_reg->SHORTS;
456  }
457  NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
458  {
459      p_reg->INTENSET = mask;
460  }
461  NRF_STATIC_INLINE void nrf_radio_int_disable(NRF_RADIO_Type * p_reg, uint32_t mask)
462  {
463      p_reg->INTENCLR = mask;
464  }
465  NRF_STATIC_INLINE uint32_t nrf_radio_int_enable_check(NRF_RADIO_Type const * p_reg, uint32_t mask)
466  {
467      return p_reg->INTENSET & mask;
468  }
469  NRF_STATIC_INLINE bool nrf_radio_crc_status_check(NRF_RADIO_Type const * p_reg)
470  {
471      return ((p_reg->CRCSTATUS & RADIO_CRCSTATUS_CRCSTATUS_Msk) >> RADIO_CRCSTATUS_CRCSTATUS_Pos)
472               == RADIO_CRCSTATUS_CRCSTATUS_CRCOk ;
473  }
474  NRF_STATIC_INLINE uint8_t nrf_radio_rxmatch_get(NRF_RADIO_Type const * p_reg)
475  {
476      return (uint8_t)p_reg->RXMATCH;
477  }
478  NRF_STATIC_INLINE uint32_t nrf_radio_rxcrc_get(NRF_RADIO_Type const * p_reg)
479  {
480      return p_reg->RXCRC;
481  }
482  NRF_STATIC_INLINE uint8_t nrf_radio_dai_get(NRF_RADIO_Type const * p_reg)
483  {
484      return (uint8_t)p_reg->DAI;
485  }
486  #if defined(RADIO_PDUSTAT_PDUSTAT_Msk)
487  NRF_STATIC_INLINE uint8_t nrf_radio_pdustat_get(NRF_RADIO_Type const * p_reg)
488  {
489      return (uint8_t)(p_reg->PDUSTAT & RADIO_PDUSTAT_PDUSTAT_Msk);
490  }
491  NRF_STATIC_INLINE uint8_t nrf_radio_cistat_get(NRF_RADIO_Type const * p_reg)
492  {
493      return (uint8_t)((p_reg->PDUSTAT & RADIO_PDUSTAT_CISTAT_Msk) >> RADIO_PDUSTAT_CISTAT_Pos);
494  }
495  #endif 
496  NRF_STATIC_INLINE void nrf_radio_packetptr_set(NRF_RADIO_Type * p_reg, void const * p_packet)
497  {
498      p_reg->PACKETPTR = (uint32_t)p_packet;
499  }
500  NRF_STATIC_INLINE void * nrf_radio_packetptr_get(NRF_RADIO_Type const * p_reg)
501  {
502      return (void *)p_reg->PACKETPTR;
503  }
504  NRF_STATIC_INLINE void nrf_radio_frequency_set(NRF_RADIO_Type * p_reg, uint16_t radio_frequency)
505  {
506      NRFX_ASSERT(radio_frequency <= 2500);
507  #if defined(RADIO_FREQUENCY_MAP_Msk)
508      NRFX_ASSERT(radio_frequency >= 2360);
509      uint32_t delta;
510      if (radio_frequency < 2400)
511      {
512          delta = ((uint32_t)(radio_frequency - 2360)) |
513                  (RADIO_FREQUENCY_MAP_Low << RADIO_FREQUENCY_MAP_Pos);
514      }
515      else
516      {
517          delta = ((uint32_t)(radio_frequency - 2400)) |
518                  (RADIO_FREQUENCY_MAP_Default << RADIO_FREQUENCY_MAP_Pos);
519      }
520      p_reg->FREQUENCY = delta;
521  #else
522      NRFX_ASSERT(radio_frequency >= 2400);
523      p_reg->FREQUENCY = (uint32_t)(radio_frequency - 2400);
524  #endif 
525  }
526  NRF_STATIC_INLINE uint16_t nrf_radio_frequency_get(NRF_RADIO_Type const * p_reg)
527  {
528      uint32_t freq;
529  #if defined(RADIO_FREQUENCY_MAP_Msk)
530      if (((p_reg->FREQUENCY & RADIO_FREQUENCY_MAP_Msk) >> RADIO_FREQUENCY_MAP_Pos) ==
531          RADIO_FREQUENCY_MAP_Low)
532      {
533          freq = 2360;
534      }
535      else
536  #endif
537      {
538          freq = 2400;
539      }
540      freq += p_reg->FREQUENCY & RADIO_FREQUENCY_FREQUENCY_Msk;
541      return freq;
542  }
543  NRF_STATIC_INLINE void nrf_radio_txpower_set(NRF_RADIO_Type * p_reg, nrf_radio_txpower_t tx_power)
544  {
545      p_reg->TXPOWER = (((uint32_t)tx_power) << RADIO_TXPOWER_TXPOWER_Pos);
546  }
547  NRF_STATIC_INLINE nrf_radio_txpower_t nrf_radio_txpower_get(NRF_RADIO_Type const * p_reg)
548  {
549      return (nrf_radio_txpower_t)(p_reg->TXPOWER >> RADIO_TXPOWER_TXPOWER_Pos);
550  }
551  NRF_STATIC_INLINE void nrf_radio_mode_set(NRF_RADIO_Type * p_reg, nrf_radio_mode_t radio_mode)
552  {
553      p_reg->MODE = ((uint32_t) radio_mode << RADIO_MODE_MODE_Pos);
554  }
555  NRF_STATIC_INLINE nrf_radio_mode_t nrf_radio_mode_get(NRF_RADIO_Type const * p_reg)
556  {
557      return (nrf_radio_mode_t)((p_reg->MODE & RADIO_MODE_MODE_Msk) >> RADIO_MODE_MODE_Pos);
558  }
559  NRF_STATIC_INLINE void nrf_radio_packet_configure(NRF_RADIO_Type *                p_reg,
560                                                    nrf_radio_packet_conf_t const * p_config)
561  {
562      p_reg->PCNF0 = (((uint32_t)p_config->lflen << RADIO_PCNF0_LFLEN_Pos) |
563                      ((uint32_t)p_config->s0len << RADIO_PCNF0_S0LEN_Pos) |
564                      ((uint32_t)p_config->s1len << RADIO_PCNF0_S1LEN_Pos) |
565  #if defined(RADIO_PCNF0_S1INCL_Msk)
566                      (p_config->s1incl ?
567                          (RADIO_PCNF0_S1INCL_Include   << RADIO_PCNF0_S1INCL_Pos) :
568                          (RADIO_PCNF0_S1INCL_Automatic << RADIO_PCNF0_S1INCL_Pos) ) |
569  #endif
570  #if defined(RADIO_PCNF0_CILEN_Msk)
571                      ((uint32_t)p_config->cilen << RADIO_PCNF0_CILEN_Pos) |
572  #endif
573  #if defined(RADIO_PCNF0_PLEN_Msk)
574                      ((uint32_t)p_config->plen << RADIO_PCNF0_PLEN_Pos) |
575  #endif
576  #if defined(RADIO_PCNF0_CRCINC_Msk)
577                      (p_config->crcinc ?
578                          (RADIO_PCNF0_CRCINC_Include << RADIO_PCNF0_CRCINC_Pos) :
579                          (RADIO_PCNF0_CRCINC_Exclude << RADIO_PCNF0_CRCINC_Pos) ) |
580  #endif
581  #if defined(RADIO_PCNF0_TERMLEN_Msk)
582                      ((uint32_t)p_config->termlen << RADIO_PCNF0_TERMLEN_Pos) |
583  #endif
584                      0);
585      p_reg->PCNF1 = (((uint32_t)p_config->maxlen  << RADIO_PCNF1_MAXLEN_Pos) |
586                      ((uint32_t)p_config->statlen << RADIO_PCNF1_STATLEN_Pos) |
587                      ((uint32_t)p_config->balen   << RADIO_PCNF1_BALEN_Pos) |
588                      (p_config->big_endian ?
589                           (RADIO_PCNF1_ENDIAN_Big    << RADIO_PCNF1_ENDIAN_Pos) :
590                           (RADIO_PCNF1_ENDIAN_Little << RADIO_PCNF1_ENDIAN_Pos) ) |
591                      (p_config->whiteen ?
592                           (RADIO_PCNF1_WHITEEN_Enabled  << RADIO_PCNF1_WHITEEN_Pos) :
593                           (RADIO_PCNF1_WHITEEN_Disabled << RADIO_PCNF1_WHITEEN_Pos) ));
594  }
595  NRF_STATIC_INLINE void nrf_radio_base0_set(NRF_RADIO_Type * p_reg, uint32_t address)
596  {
597      p_reg->BASE0 = address;
598  }
599  NRF_STATIC_INLINE uint32_t nrf_radio_base0_get(NRF_RADIO_Type const * p_reg)
600  {
601      return p_reg->BASE0;
602  }
603  NRF_STATIC_INLINE void nrf_radio_base1_set(NRF_RADIO_Type * p_reg, uint32_t address)
604  {
605      p_reg->BASE1 = address;
606  }
607  NRF_STATIC_INLINE uint32_t nrf_radio_base1_get(NRF_RADIO_Type const * p_reg)
608  {
609      return p_reg->BASE1;
610  }
611  NRF_STATIC_INLINE void nrf_radio_prefix0_set(NRF_RADIO_Type * p_reg, uint32_t prefixes)
612  {
613      p_reg->PREFIX0 = prefixes;
614  }
615  NRF_STATIC_INLINE uint32_t nrf_radio_prefix0_get(NRF_RADIO_Type const * p_reg)
616  {
617      return p_reg->PREFIX0;
618  }
619  NRF_STATIC_INLINE void nrf_radio_prefix1_set(NRF_RADIO_Type * p_reg, uint32_t prefixes)
620  {
621      p_reg->PREFIX1 = prefixes;
622  }
623  NRF_STATIC_INLINE uint32_t nrf_radio_prefix1_get(NRF_RADIO_Type const * p_reg)
624  {
625      return p_reg->PREFIX1;
626  }
627  NRF_STATIC_INLINE void nrf_radio_txaddress_set(NRF_RADIO_Type * p_reg, uint8_t txaddress)
628  {
629      p_reg->TXADDRESS = ((uint32_t)txaddress) << RADIO_TXADDRESS_TXADDRESS_Pos;
630  }
631  NRF_STATIC_INLINE uint8_t nrf_radio_txaddress_get(NRF_RADIO_Type const * p_reg)
632  {
633      return (uint8_t)((p_reg->TXADDRESS & RADIO_TXADDRESS_TXADDRESS_Msk) >>
634                       RADIO_TXADDRESS_TXADDRESS_Pos);
635  }
636  NRF_STATIC_INLINE void nrf_radio_rxaddresses_set(NRF_RADIO_Type * p_reg, uint8_t rxaddresses)
637  {
638      p_reg->RXADDRESSES = (uint32_t)(rxaddresses);
639  }
640  NRF_STATIC_INLINE uint8_t nrf_radio_rxaddresses_get(NRF_RADIO_Type const * p_reg)
641  {
642      return (uint8_t)(p_reg->RXADDRESSES);
643  }
644  NRF_STATIC_INLINE void nrf_radio_crc_configure(NRF_RADIO_Type *     p_reg,
645                                                 uint8_t              crc_length,
646                                                 nrf_radio_crc_addr_t crc_address,
647                                                 uint32_t             crc_polynominal)
648  {
649      p_reg->CRCCNF = ((uint32_t)crc_length  << RADIO_CRCCNF_LEN_Pos) |
650                      ((uint32_t)crc_address << RADIO_CRCCNF_SKIPADDR_Pos);
651      p_reg->CRCPOLY = (crc_polynominal << RADIO_CRCPOLY_CRCPOLY_Pos);
652  }
653  NRF_STATIC_INLINE void nrf_radio_crcinit_set(NRF_RADIO_Type * p_reg, uint32_t crc_init_value)
654  {
655      p_reg->CRCINIT = crc_init_value;
656  }
657  NRF_STATIC_INLINE uint32_t nrf_radio_crcinit_get(NRF_RADIO_Type const * p_reg)
658  {
659      return p_reg->CRCINIT;
660  }
661  NRF_STATIC_INLINE void nrf_radio_ifs_set(NRF_RADIO_Type * p_reg, uint32_t radio_ifs)
662  {
663      p_reg->TIFS = radio_ifs;
664  }
665  NRF_STATIC_INLINE uint32_t nrf_radio_ifs_get(NRF_RADIO_Type const * p_reg)
666  {
667      return p_reg->TIFS;
668  }
669  NRF_STATIC_INLINE uint8_t nrf_radio_rssi_sample_get(NRF_RADIO_Type const * p_reg)
670  {
671      return (uint8_t)((p_reg->RSSISAMPLE & RADIO_RSSISAMPLE_RSSISAMPLE_Msk) >>
672                       RADIO_RSSISAMPLE_RSSISAMPLE_Pos);
673  }
674  NRF_STATIC_INLINE nrf_radio_state_t nrf_radio_state_get(NRF_RADIO_Type const * p_reg)
675  {
676      return (nrf_radio_state_t) p_reg->STATE;
677  }
678  NRF_STATIC_INLINE void nrf_radio_datawhiteiv_set(NRF_RADIO_Type * p_reg, uint8_t datawhiteiv)
679  {
680      p_reg->DATAWHITEIV = (((uint32_t)datawhiteiv) & RADIO_DATAWHITEIV_DATAWHITEIV_Msk);
681  }
682  NRF_STATIC_INLINE uint8_t nrf_radio_datawhiteiv_get(NRF_RADIO_Type const * p_reg)
683  {
684      return (uint8_t)(p_reg->DATAWHITEIV & RADIO_DATAWHITEIV_DATAWHITEIV_Msk);
685  }
686  NRF_STATIC_INLINE void nrf_radio_bcc_set(NRF_RADIO_Type * p_reg, uint32_t radio_bcc)
687  {
688      p_reg->BCC = radio_bcc;
689  }
690  NRF_STATIC_INLINE uint32_t nrf_radio_bcc_get(NRF_RADIO_Type const * p_reg)
691  {
692      return p_reg->BCC;
693  }
694  NRF_STATIC_INLINE void nrf_radio_dab_set(NRF_RADIO_Type * p_reg,
695                                           uint32_t         dab_value,
696                                           uint8_t          segment)
697  {
698      NRFX_ASSERT(segment < 8);
699      p_reg->DAB[segment] = dab_value;
700  }
701  NRF_STATIC_INLINE uint32_t nrf_radio_dab_get(NRF_RADIO_Type const * p_reg, uint8_t segment)
702  {
703      NRFX_ASSERT(segment < 8);
704      return p_reg->DAB[segment];
705  }
706  NRF_STATIC_INLINE void nrf_radio_dap_set(NRF_RADIO_Type * p_reg,
707                                           uint16_t         dap_value,
708                                           uint8_t          prefix_index)
709  {
710      NRFX_ASSERT(prefix_index < 8);
711      p_reg->DAP[prefix_index] = (uint32_t)dap_value;
712  }
713  NRF_STATIC_INLINE uint32_t nrf_radio_dap_get(NRF_RADIO_Type const * p_reg, uint8_t prefix_index)
714  {
715      NRFX_ASSERT(prefix_index < 8);
716      return p_reg->DAP[prefix_index];
717  }
718  NRF_STATIC_INLINE void nrf_radio_dacnf_set(NRF_RADIO_Type * p_reg, uint8_t ena, uint8_t txadd)
719  {
720      p_reg->DACNF = (((uint32_t)ena   << RADIO_DACNF_ENA0_Pos) |
721                      ((uint32_t)txadd << RADIO_DACNF_TXADD0_Pos));
722  }
723  NRF_STATIC_INLINE uint8_t nrf_radio_dacnf_ena_get(NRF_RADIO_Type const * p_reg)
724  {
725      return (p_reg->DACNF & (RADIO_DACNF_ENA0_Msk |
726                              RADIO_DACNF_ENA1_Msk |
727                              RADIO_DACNF_ENA2_Msk |
728                              RADIO_DACNF_ENA3_Msk |
729                              RADIO_DACNF_ENA4_Msk |
730                              RADIO_DACNF_ENA5_Msk |
731                              RADIO_DACNF_ENA6_Msk |
732                              RADIO_DACNF_ENA7_Msk)) >> RADIO_DACNF_ENA0_Pos;
733  }
734  NRF_STATIC_INLINE uint8_t nrf_radio_dacnf_txadd_get(NRF_RADIO_Type const * p_reg)
735  {
736      return (p_reg->DACNF & (RADIO_DACNF_TXADD0_Msk |
737                              RADIO_DACNF_TXADD1_Msk |
738                              RADIO_DACNF_TXADD2_Msk |
739                              RADIO_DACNF_TXADD3_Msk |
740                              RADIO_DACNF_TXADD4_Msk |
741                              RADIO_DACNF_TXADD5_Msk |
742                              RADIO_DACNF_TXADD6_Msk |
743                              RADIO_DACNF_TXADD7_Msk)) >> RADIO_DACNF_TXADD0_Pos;
744  }
745  #if defined(RADIO_INTENSET_MHRMATCH_Msk)
746  void nrf_radio_mhmu_search_pattern_set(NRF_RADIO_Type * p_reg,
747                                         uint32_t         radio_mhmu_search_pattern)
748  {
749      p_reg->MHRMATCHCONF = radio_mhmu_search_pattern;
750  }
751  NRF_STATIC_INLINE uint32_t nrf_radio_mhmu_search_pattern_get(NRF_RADIO_Type const * p_reg)
752  {
753      return p_reg->MHRMATCHCONF;
754  }
755  NRF_STATIC_INLINE void nrf_radio_mhmu_pattern_mask_set(NRF_RADIO_Type * p_reg,
756                                                         uint32_t         radio_mhmu_pattern_mask)
757  {
758      p_reg->MHRMATCHMAS = radio_mhmu_pattern_mask;
759  }
760  NRF_STATIC_INLINE uint32_t nrf_radio_mhmu_pattern_mask_get(NRF_RADIO_Type const * p_reg)
761  {
762      return p_reg->MHRMATCHMAS;
763  }
764  #endif 
765  #if defined(RADIO_MODECNF0_RU_Msk)
766  NRF_STATIC_INLINE void nrf_radio_modecnf0_set(NRF_RADIO_Type * p_reg,
767                                                bool             fast_ramp_up,
768                                                uint8_t          default_tx)
769  {
770      p_reg->MODECNF0 = (fast_ramp_up ? (RADIO_MODECNF0_RU_Fast    << RADIO_MODECNF0_RU_Pos) :
771                                        (RADIO_MODECNF0_RU_Default << RADIO_MODECNF0_RU_Pos) ) |
772                        (((uint32_t)default_tx) << RADIO_MODECNF0_DTX_Pos);
773  }
774  NRF_STATIC_INLINE bool nrf_radio_modecnf0_ru_get(NRF_RADIO_Type const * p_reg)
775  {
776      return ((p_reg->MODECNF0 & RADIO_MODECNF0_RU_Msk) >> RADIO_MODECNF0_RU_Pos) ==
777              RADIO_MODECNF0_RU_Fast;
778  }
779  NRF_STATIC_INLINE uint8_t nrf_radio_modecnf0_dtx_get(NRF_RADIO_Type const * p_reg)
780  {
781      return (uint8_t)((p_reg->MODECNF0 & RADIO_MODECNF0_DTX_Msk) >> RADIO_MODECNF0_DTX_Pos);
782  }
783  #endif 
784  #if defined(RADIO_SFD_SFD_Msk)
785  NRF_STATIC_INLINE void nrf_radio_sfd_set(NRF_RADIO_Type * p_reg, uint8_t sfd)
786  {
787      p_reg->SFD = ((uint32_t)sfd) << RADIO_SFD_SFD_Pos;
788  }
789  NRF_STATIC_INLINE uint8_t nrf_radio_sfd_get(NRF_RADIO_Type const * p_reg)
790  {
791      return (uint8_t)((p_reg->SFD & RADIO_SFD_SFD_Msk) >> RADIO_SFD_SFD_Pos);
792  }
793  #endif 
794  #if defined(RADIO_EDCNT_EDCNT_Msk)
795  NRF_STATIC_INLINE void nrf_radio_ed_loop_count_set(NRF_RADIO_Type * p_reg, uint32_t ed_loop_count)
796  {
797      p_reg->EDCNT = (ed_loop_count & RADIO_EDCNT_EDCNT_Msk);
798  }
799  #endif
800  #if defined(RADIO_EDSAMPLE_EDLVL_Msk)
801  NRF_STATIC_INLINE uint8_t nrf_radio_ed_sample_get(NRF_RADIO_Type const * p_reg)
802  {
803      return (uint8_t) p_reg->EDSAMPLE;
804  }
805  #endif
806  #if defined(RADIO_CCACTRL_CCAMODE_Msk)
807  NRF_STATIC_INLINE void nrf_radio_cca_configure(NRF_RADIO_Type *     p_reg,
808                                                 nrf_radio_cca_mode_t cca_mode,
809                                                 uint8_t              cca_ed_threshold,
810                                                 uint8_t              cca_corr_threshold,
811                                                 uint8_t              cca_corr_cnt)
812  {
813      p_reg->CCACTRL = (((uint32_t)cca_mode           << RADIO_CCACTRL_CCAMODE_Pos) |
814                        ((uint32_t)cca_ed_threshold   << RADIO_CCACTRL_CCAEDTHRES_Pos) |
815                        ((uint32_t)cca_corr_threshold << RADIO_CCACTRL_CCACORRTHRES_Pos) |
816                        ((uint32_t)cca_corr_cnt       << RADIO_CCACTRL_CCACORRCNT_Pos));
817  }
818  #endif
819  NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
820  {
821      p_reg->POWER = (uint32_t) radio_power;
822  }
823  #endif 
824  #ifdef __cplusplus
825  }
826  #endif
827  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-bt-linux.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_radio.h</div>
                </div>
                <div class="column column_space"><pre><code>132  	handle->setdirection_op = bt_setdirection_linux;
133  	handle->set_datalink_op = NULL;	&bsol;* can't change data link type */
134  	handle->getnonblock_op = pcap_getnonblock_fd;
135  	handle->setnonblock_op = pcap_setnonblock_fd;
136  	handle->stats_op = bt_stats_linux;
137  	handlep->dev_id = dev_id;
138  	handle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
</pre></code></div>
                <div class="column column_space"><pre><code>137      NRF_RADIO_INT_PHYEND_MASK     = RADIO_INTENSET_PHYEND_Msk,     &bsol;**< Interrupt on PHYEND event. */
138  #endif
139  #if defined(RADIO_INTENSET_SYNC_Msk) || defined(__NRFX_DOXYGEN__)
140      NRF_RADIO_INT_SYNC_MASK       = RADIO_INTENSET_SYNC_Msk,       &bsol;**< Interrupt on SYNC event. */
141  #endif
142  } nrf_radio_int_mask_t;
143  typedef enum
144  {
145      NRF_RADIO_SHORT_READY_START_MASK        = RADIO_SHORTS_READY_START_Msk,        &bsol;**< Shortcut between READY event and START task. */
146      NRF_RADIO_SHORT_END_DISABLE_MASK        = RADIO_SHORTS_END_DISABLE_Msk,        &bsol;**< Shortcut between END event and DISABLE task. */
147      NRF_RADIO_SHORT_DISABLED_TXEN_MASK      = RADIO_SHORTS_DISABLED_TXEN_Msk,      &bsol;**< Shortcut between DISABLED event and TXEN task. */
148      NRF_RADIO_SHORT_DISABLED_RXEN_MASK      = RADIO_SHORTS_DISABLED_RXEN_Msk,      &bsol;**< Shortcut between DISABLED event and RXEN task. */
149      NRF_RADIO_SHORT_ADDRESS_RSSISTART_MASK  = RADIO_SHORTS_ADDRESS_RSSISTART_Msk,  &bsol;**< Shortcut between ADDRESS event and RSSISTART task. */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    