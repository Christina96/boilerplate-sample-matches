
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.682170542635658%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeCommonDefine.h</h3>
            <pre><code>1  &bsol;*
2   * cgeCommonDefine.h
3   *
4   *  Created on: 2013-12-6
5   *      Author: Wang Yang
6   *        Mail: admin@wysaid.org
7   */
8  #ifndef _CGECOMMONDEFINE_H_
9  #define _CGECOMMONDEFINE_H_
10  #include "cgeGlobal.h"
11  #ifndef cgeCheckGLError
12  #ifdef CGE_LOG_ERROR
13  #define cgeCheckGLError(name) _cgeCheckGLError(name, __FILE__, __LINE__);
14  #else
15  #define cgeCheckGLError(name)
16  #endif
17  #endif
18  #ifndef _CGE_GET_MACRO_STRING_HELP
19  #define _CGE_GET_MACRO_STRING_HELP(x) #x
20  #endif
21  #ifndef CGE_GET_MACRO_STRING
22  #define CGE_GET_MACRO_STRING(x) _CGE_GET_MACRO_STRING_HELP(x)
23  #endif
24  #define CGE_FLOATCOMP0(x) (x < 0.001f && x > -0.001f)
25  #define CGE_UNIFORM_MAX_LEN 32
26  #define CGE_DELETE(p) \
27      do                \
28      {                 \
29          delete p;     \
30          p = NULL;     \
31      } while (0)
32  #define CGE_DELETE_ARR(p) \
33      do                    \
34      {                     \
35          delete[] p;       \
36          p = NULL;         \
37      } while (0)
38  #define CGE_TEXTURE_INPUT_IMAGE_INDEX 0
39  #define CGE_TEXTURE_INPUT_IMAGE GL_TEXTURE0
40  #define CGE_TEXTURE_OUTPUT_IMAGE_INDEX 1
41  #define CGE_TEXTURE_OUTPUT_IMAGE GL_TEXTURE1
42  #define CGE_TEXTURE_START_INDEX 2
43  #define CGE_TEXTURE_START GL_TEXTURE2
44  #ifndef CGE_TEXTURE_PREMULTIPLIED
45  #define CGE_TEXTURE_PREMULTIPLIED 0
46  #endif
47  #ifdef _CGE_SHADER_VERSION_
48  #define CGE_GLES_ATTACH_STRING_L "#version " CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n"
49  #define CGE_GLES_ATTACH_STRING_M "#version " CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n"
50  #define CGE_GLES_ATTACH_STRING_H "#version " CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) "\n#ifdef GL_ES\nprecision highp float;\n#endif\n"
51  #else
52  #define CGE_GLES_ATTACH_STRING_L "#ifdef GL_ES\nprecision lowp float;\n#endif\n"
53  #define CGE_GLES_ATTACH_STRING_M "#ifdef GL_ES\nprecision mediump float;\n#endif\n"
54  #define CGE_GLES_ATTACH_STRING_H "#ifdef GL_ES\nprecision highp float;\n#endif\n"
55  #endif
56  #if defined(_MSC_VER) && _MSC_VER < 1600
57  #define CGE_SHADER_STRING_PRECISION_L(string) CGE_GLES_ATTACH_STRING_L #string
58  #define CGE_SHADER_STRING_PRECISION_M(string) CGE_GLES_ATTACH_STRING_M #string
59  #define CGE_SHADER_STRING_PRECISION_H(string) CGE_GLES_ATTACH_STRING_H #string
60  #ifndef CGE_SHADER_STRING
61  #define CGE_SHADER_STRING(string) #string
62  #endif
63  #else
64  #define CGE_SHADER_STRING_PRECISION_L(...) CGE_GLES_ATTACH_STRING_L #__VA_ARGS__
65  #define CGE_SHADER_STRING_PRECISION_M(...) CGE_GLES_ATTACH_STRING_M #__VA_ARGS__
66  #define CGE_SHADER_STRING_PRECISION_H(...) CGE_GLES_ATTACH_STRING_H #__VA_ARGS__
67  #ifndef CGE_SHADER_STRING
68  #define CGE_SHADER_STRING(...) #__VA_ARGS__
69  #endif
70  #endif
71  #define CGE_COMMON_CREATE_FUNC(cls, funcName)         \
72      static inline cls* create()                       \
73      {                                                 \
74          cls* instance = new cls();                    \
75          if (!instance->funcName())                    \
76          {                                             \
77              delete instance;                          \
78              instance = nullptr;                       \
79              CGE_LOG_ERROR("create %s failed!", #cls); \
80          }                                             \
81          return instance;                              \
82      }
83  #define CGE_COMMON_CREATE_FUNC_WITH_PARAM(cls, funcName, paramName, ...) \
84      static inline cls* create(paramName param __VA_ARGS__)               \
85      {                                                                    \
86          cls* instance = new cls();                                       \
87          if (!instance->funcName(param))                                  \
88          {                                                                \
89              delete instance;                                             \
90              instance = nullptr;                                          \
91              CGE_LOG_ERROR("create %s failed!", #cls);                    \
92          }                                                                \
93          return instance;                                                 \
94      }
95  #define CGE_ARRAY_LEN(x) (sizeof(x) / sizeof(*x))
96  #ifdef __cplusplus
97  template <class T, int Len>
98  static inline int cgeArrLen(const T (&v)[Len])
99  {
100      return Len;
101  }
102  template <typename T>
103  static inline void cgeResetValue(T& t)
104  {
105      t = T();
106  }
107  template <typename T, typename... ARGS>
108  static inline void cgeResetValue(T& t, ARGS&... args)
109  {
110      t = T();
111      cgeResetValue(args...);
112  }
113  #define CGE_DELETE_GL_OBJS(func, ...)    \
114      do                                   \
115      {                                    \
116          GLuint objs[] = { __VA_ARGS__ }; \
117          func(cgeArrLen(objs), objs);     \
118          cgeResetValue(__VA_ARGS__);      \
119      } while (0)
120  template <class T>
121  class CGEBlockLimit
122  {
123      CGEBlockLimit& operator=(const CGEBlockLimit& other) { return *this; }
124  public:
125      explicit CGEBlockLimit(const T& _func) :
126          func(_func) {}
127      ~CGEBlockLimit() { func(); }
128  private:
129      const T& func;
130  };
131  template <class T>
132  inline CGEBlockLimit<const T&> ___cgeMakeBlockLimit(const T& f)
133  {
134      return CGEBlockLimit<const T&>(f);
135  }
136  #define __cgeMakeBlockLimit(ARG, ANYSIGN)            \
137      const auto& ANYSIGN = ___cgeMakeBlockLimit(ARG); \
138      (void)ANYSIGN; 
139  #define _cgeMakeBlockLimit(ARG, VAR, LINE) __cgeMakeBlockLimit(ARG, VAR##LINE)
140  #define _cgeMakeBlockLimit_(ARG, VAR, LINE) _cgeMakeBlockLimit(ARG, VAR, LINE)
141  #define cgeMakeBlockLimit(...) _cgeMakeBlockLimit_(__VA_ARGS__, _blockVar, __LINE__)
142  namespace CGE
143  {
144  #ifndef CGE_MIN
145  template <typename Type>
146  inline Type CGE_MIN(Type a, Type b)
147  {
148      return a < b ? a : b;
149  }
150  #endif
151  #ifndef CGE_MAX
152  template <typename Type>
153  inline Type CGE_MAX(Type a, Type b)
154  {
155      return a > b ? a : b;
156  }
157  #endif
158  #ifndef CGE_MID
159  template <typename Type>
160  inline Type CGE_MID(Type n, Type vMin, Type vMax)
161  {
162      if (n < vMin)
163          n = vMin;
164      else if (n > vMax)
165          n = vMax;
166      return n;
167  }
168  #endif
169  #ifndef CGE_MIX
170  template <typename OpType, typename MixType>
171  inline auto CGE_MIX(OpType a, OpType b, MixType value) -> decltype(a - a * value + b * value)
172  {
173      return a - a * value + b * value;
174  }
175  #endif
176  } 
177  extern "C"
178  {
179  #endif
180  typedef const char* const CGEConstString;
181  typedef enum CGEBufferFormat
182  {
183      CGE_FORMAT_RGB_INT8,
184      CGE_FORMAT_RGB_INT16,
185      CGE_FORMAT_RGB_FLOAT32,
186      CGE_FORMAT_RGBA_INT8,
187      CGE_FORMAT_RGBA_INT16,
188      CGE_FORMAT_RGBA_FLOAT32,
189  #ifdef GL_BGR
190      CGE_FORMAT_BGR_INT8,
191      CGE_FORMAT_BGR_INT16,
192      CGE_FORMAT_BGR_FLOAT32,
193  #endif
194  #ifdef GL_BGRA
195      CGE_FORMAT_BGRA_INT8,
196      CGE_FORMAT_BGRA_INT16,
197      CGE_FORMAT_BGRA_FLOAT32,
198  #endif
199  #ifdef GL_LUMINANCE
200      CGE_FORMAT_LUMINANCE, 
201  #endif
202  #ifdef GL_LUMINANCE_ALPHA
203      CGE_FORMAT_LUMINANCE_ALPHA, 
204  #endif
205  } CGEBufferFormat;
206  typedef enum CGETextureBlendMode
207  {
208      CGE_BLEND_MIX,      
209      CGE_BLEND_DISSOLVE, 
210      CGE_BLEND_DARKEN,       
211      CGE_BLEND_MULTIPLY,     
212      CGE_BLEND_COLORBURN,    
213      CGE_BLEND_LINEARBURN,   
214      CGE_BLEND_DARKER_COLOR, 
215      CGE_BLEND_LIGHTEN,      
216      CGE_BLEND_SCREEN,       
<span onclick='openModal()' class='match'>217      CGE_BLEND_COLORDODGE,   
218      CGE_BLEND_LINEARDODGE,  
219      CGE_BLEND_LIGHTERCOLOR, 
220      CGE_BLEND_OVERLAY,     
221      CGE_BLEND_SOFTLIGHT,   
222      CGE_BLEND_HARDLIGHT,   
223      CGE_BLEND_VIVIDLIGHT,  
224      CGE_BLEND_LINEARLIGHT, 
</span>225      CGE_BLEND_PINLIGHT,    
226      CGE_BLEND_HARDMIX,     
227      CGE_BLEND_DIFFERENCE, 
228      CGE_BLEND_EXCLUDE,    
229      CGE_BLEND_SUBTRACT,   
230      CGE_BLEND_DIVIDE,     
231      CGE_BLEND_HUE,        
232      CGE_BLEND_SATURATION, 
233      CGE_BLEND_COLOR,      
234      CGE_BLEND_LUMINOSITY, 
235      CGE_BLEND_ADD,     
236      CGE_BLEND_ADDREV,  
237      CGE_BLEND_COLORBW, 
238      CGE_BLEND_TYPE_MAX_NUM 
239  } CGETextureBlendMode;
240  typedef enum CGEGlobalBlendMode
241  {
242      CGEGLOBAL_BLEND_NONE,
243      CGEGLOBAL_BLEND_ALPHA,
244      CGEGLOBAL_BLEND_ALPHA_SEPERATE,
245      CGEGLOBAL_BLEND_ADD,
246      CGEGLOBAL_BLEND_ADD_SEPARATE,
247      CGEGLOBAL_BLEND_ADD_SEPARATE_EXT, 
248      CGEGLOBAL_BLEND_MULTIPLY,
249      CGEGLOBAL_BLEND_MULTIPLY_SEPERATE,
250      CGEGLOBAL_BLEND_SCREEN,
251      CGEGLOBAL_BLEND_SCREEN_EXT,
252  } CGEGlobalBlendMode;
253  const char* cgeGetVersion();
254  void cgePrintGLString(const char*, GLenum);
255  bool _cgeCheckGLError(const char* name, const char* file, int line); 
256  void cgeSetGlobalBlendMode(const CGEGlobalBlendMode mode);
257  void cgeGetDataAndChannelByFormat(CGEBufferFormat fmt, GLenum* dataFmt, GLenum* channelFmt, GLint* channel);
258  #ifdef __cplusplus
259  const char* cgeGetBlendModeName(const CGETextureBlendMode mode, bool withChinese = false);
260  GLuint cgeGenTextureWithBuffer(const void* bufferData, GLint w, GLint h, GLenum channelFmt, GLenum dataFmt, GLint channels = 4, GLint bindID = 0, GLenum texFilter = GL_LINEAR, GLenum texWrap = GL_CLAMP_TO_EDGE);
261  #else
262  const char* cgeGetBlendModeName(const CGETextureBlendMode mode, bool withChinese);
263  GLuint cgeGenTextureWithBuffer(const void* bufferData, GLint w, GLint h, GLenum channelFmt, GLenum dataFmt, GLint channels, GLint bindID, GLenum texFilter, GLenum texWrap);
264  #endif
265  #ifdef __cplusplus
266  }
267  #endif
268  #endif &bsol;* _CGECOMMONDEFINE_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_sequence_flexi.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  static int s_new_element(ltc_asn1_list **l)
4  {
5     if (*l == NULL) {
6        *l = XCALLOC(1, sizeof(ltc_asn1_list));
7        if (*l == NULL) {
8           return CRYPT_MEM;
9        }
10     } else {
11        (*l)->next = XCALLOC(1, sizeof(ltc_asn1_list));
12        if ((*l)->next == NULL) {
13           return CRYPT_MEM;
14        }
15        (*l)->next->prev = *l;
16        *l = (*l)->next;
17     }
18     return CRYPT_OK;
19  }
<span onclick='openModal()' class='match'>20  static int s_der_decode_sequence_flexi(const unsigned char *in, unsigned long *inlen, ltc_asn1_list **out, unsigned long depth)
21  {
22     ltc_asn1_list *l;
23     unsigned long err, identifier, len, totlen, data_offset, id_len, len_len;
24     void          *realloc_tmp;
</span>25     LTC_ARGCHK(in    != NULL);
26     LTC_ARGCHK(inlen != NULL);
27     LTC_ARGCHK(out   != NULL);
28     l = NULL;
29     totlen = 0;
30     if (*inlen == 0) {
31        if ((err = s_new_element(&l)) != CRYPT_OK) {
32           goto error;
33        }
34     }
35     while (*inlen) {
36        if ((err = s_new_element(&l)) != CRYPT_OK) {
37           goto error;
38        }
39        id_len = *inlen;
40        if ((err = der_decode_asn1_identifier(in, &id_len, l)) != CRYPT_OK) {
41           goto error;
42        }
43        identifier = *in;
44        if (l->type != LTC_ASN1_EOL) {
45           len_len = *inlen - id_len;
46  #if defined(LTC_TEST_DBG)
47           data_offset = 666;
48           len = 0;
49  #endif
50           if ((err = der_decode_asn1_length(&in[id_len], &len_len, &len)) != CRYPT_OK) {
51  #if defined(LTC_TEST_DBG)
52              fprintf(stderr, "E1 %02lx: hl=%4lu l=%4lu - %s (%s)\n", identifier, data_offset, len, der_asn1_tag_to_string_map[l->tag], error_to_string(err));
53  #endif
54              goto error;
55           } else if (len > (*inlen - id_len - len_len)) {
56              err = CRYPT_INVALID_PACKET;
57  #if defined(LTC_TEST_DBG)
58              fprintf(stderr, "E2 %02lx: hl=%4lu l=%4lu - %s (%s)\n", identifier, data_offset, len, der_asn1_tag_to_string_map[l->tag], error_to_string(err));
59  #endif
60              goto error;
61           }
62           data_offset = id_len + len_len;
63  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 1
64           if (l->type == LTC_ASN1_CUSTOM_TYPE && l->klass == LTC_ASN1_CL_CONTEXT_SPECIFIC) {
65              fprintf(stderr, "OK %02lx: hl=%4lu l=%4lu - Context Specific[%s %llu]\n", identifier, data_offset, len, der_asn1_pc_to_string_map[l->pc], l->tag);
66           } else {
67              fprintf(stderr, "OK %02lx: hl=%4lu l=%4lu - %s\n", identifier, data_offset, len, der_asn1_tag_to_string_map[l->tag]);
68           }
69  #endif
70           len += data_offset;
71           if (l->type == LTC_ASN1_CUSTOM_TYPE) {
72              l->used = identifier;
73              if (l->pc == LTC_ASN1_PC_CONSTRUCTED) {
74                 identifier = 0x20;
75              } else {
76                 identifier = 0x80;
77              }
78           }
79        } else {
80           data_offset = 0;
81           len = 0;
82        }
83        switch (identifier) {
84           case 0x01: &bsol;* BOOLEAN */
85              if (l->type != LTC_ASN1_BOOLEAN) {
86                 err = CRYPT_PK_ASN1_ERROR;
87                 goto error;
88              }
89              l->size = 1;
90              l->data = XCALLOC(1, sizeof(int));
91              if ((err = der_decode_boolean(in, *inlen, l->data)) != CRYPT_OK) {
92                 goto error;
93              }
94              if ((err = der_length_boolean(&len)) != CRYPT_OK) {
95                 goto error;
96              }
97              break;
98           case 0x02: &bsol;* INTEGER */
99               if (l->type != LTC_ASN1_INTEGER) {
100                  err = CRYPT_PK_ASN1_ERROR;
101                  goto error;
102               }
103               l->size = 1;
104               if ((err = mp_init(&l->data)) != CRYPT_OK) {
105                   goto error;
106               }
107               if ((err = der_decode_integer(in, *inlen, l->data)) != CRYPT_OK) {
108                   goto error;
109               }
110               if ((err = der_length_integer(l->data, &len)) != CRYPT_OK) {
111                   goto error;
112               }
113               break;
114           case 0x03: &bsol;* BIT */
115              if (l->type != LTC_ASN1_BIT_STRING) {
116                 err = CRYPT_PK_ASN1_ERROR;
117                 goto error;
118              }
119              l->size = len * 8; &bsol;* *8 because we store decoded bits one per char and they are encoded 8 per char.  */
120              if ((l->data = XCALLOC(1, l->size)) == NULL) {
121                 err = CRYPT_MEM;
122                 goto error;
123              }
124              if ((err = der_decode_bit_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
125                 goto error;
126              }
127              if ((err = der_length_bit_string(l->size, &len)) != CRYPT_OK) {
128                 goto error;
129              }
130              break;
131           case 0x04: &bsol;* OCTET */
132              if (l->type != LTC_ASN1_OCTET_STRING) {
133                 err = CRYPT_PK_ASN1_ERROR;
134                 goto error;
135              }
136              l->size = len;
137              if ((l->data = XCALLOC(1, l->size)) == NULL) {
138                 err = CRYPT_MEM;
139                 goto error;
140              }
141              if ((err = der_decode_octet_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
142                 goto error;
143              }
144              if ((err = der_length_octet_string(l->size, &len)) != CRYPT_OK) {
145                 goto error;
146              }
147              break;
148           case 0x05: &bsol;* NULL */
149              if (l->type != LTC_ASN1_NULL) {
150                 err = CRYPT_PK_ASN1_ERROR;
151                 goto error;
152              }
153              if (in[0] != 0x05 || in[1] != 0x00) {
154                 err = CRYPT_INVALID_PACKET;
155                 goto error;
156              }
157              l->data = NULL;
158              l->size = 0;
159              len     = 2;
160              break;
161           case 0x06: &bsol;* OID */
162              if (l->type != LTC_ASN1_OBJECT_IDENTIFIER) {
163                 err = CRYPT_PK_ASN1_ERROR;
164                 goto error;
165              }
166              l->size = len;
167              if ((l->data = XCALLOC(len, sizeof(unsigned long))) == NULL) {
168                 err = CRYPT_MEM;
169                 goto error;
170              }
171              if ((err = der_decode_object_identifier(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
172                 goto error;
173              }
174              if ((err = der_length_object_identifier(l->data, l->size, &len)) != CRYPT_OK) {
175                 goto error;
176              }
177              if ((realloc_tmp = XREALLOC(l->data, l->size * sizeof(unsigned long))) == NULL) {
178                 break;
179              }
180              l->data = realloc_tmp;
181              break;
182           case 0x0C: &bsol;* UTF8 */
183              if (l->type != LTC_ASN1_UTF8_STRING) {
184                 err = CRYPT_PK_ASN1_ERROR;
185                 goto error;
186              }
187              l->size = len;
188              if ((l->data = XCALLOC(sizeof(wchar_t), l->size)) == NULL) {
189                 err = CRYPT_MEM;
190                 goto error;
191              }
192              if ((err = der_decode_utf8_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
193                 goto error;
194              }
195              if ((err = der_length_utf8_string(l->data, l->size, &len)) != CRYPT_OK) {
196                 goto error;
197              }
198              break;
199           case 0x13: &bsol;* PRINTABLE */
200              if (l->type != LTC_ASN1_PRINTABLE_STRING) {
201                 err = CRYPT_PK_ASN1_ERROR;
202                 goto error;
203              }
204              l->size = len;
205              if ((l->data = XCALLOC(1, l->size)) == NULL) {
206                 err = CRYPT_MEM;
207                 goto error;
208              }
209              if ((err = der_decode_printable_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
210                 goto error;
211              }
212              if ((err = der_length_printable_string(l->data, l->size, &len)) != CRYPT_OK) {
213                 goto error;
214              }
215              break;
216           case 0x14: &bsol;* TELETEXT */
217              if (l->type != LTC_ASN1_TELETEX_STRING) {
218                 err = CRYPT_PK_ASN1_ERROR;
219                 goto error;
220              }
221              l->size = len;
222              if ((l->data = XCALLOC(1, l->size)) == NULL) {
223                 err = CRYPT_MEM;
224                 goto error;
225              }
226              if ((err = der_decode_teletex_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
227                 goto error;
228              }
229              if ((err = der_length_teletex_string(l->data, l->size, &len)) != CRYPT_OK) {
230                 goto error;
231              }
232              break;
233           case 0x16: &bsol;* IA5 */
234              if (l->type != LTC_ASN1_IA5_STRING) {
235                 err = CRYPT_PK_ASN1_ERROR;
236                 goto error;
237              }
238              l->size = len;
239              if ((l->data = XCALLOC(1, l->size)) == NULL) {
240                 err = CRYPT_MEM;
241                 goto error;
242              }
243              if ((err = der_decode_ia5_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
244                 goto error;
245              }
246              if ((err = der_length_ia5_string(l->data, l->size, &len)) != CRYPT_OK) {
247                 goto error;
248              }
249              break;
250           case 0x17: &bsol;* UTC TIME */
251              if (l->type != LTC_ASN1_UTCTIME) {
252                 err = CRYPT_PK_ASN1_ERROR;
253                 goto error;
254              }
255              l->size = 1;
256              if ((l->data = XCALLOC(1, sizeof(ltc_utctime))) == NULL) {
257                 err = CRYPT_MEM;
258                 goto error;
259              }
260              len = *inlen;
261              if ((err = der_decode_utctime(in, &len, l->data)) != CRYPT_OK) {
262                 goto error;
263              }
264              if ((err = der_length_utctime(l->data, &len)) != CRYPT_OK) {
265                 goto error;
266              }
267              break;
268           case 0x18:
269              if (l->type != LTC_ASN1_GENERALIZEDTIME) {
270                 err = CRYPT_PK_ASN1_ERROR;
271                 goto error;
272              }
273              l->size = len;
274              if ((l->data = XCALLOC(1, sizeof(ltc_generalizedtime))) == NULL) {
275                 err = CRYPT_MEM;
276                 goto error;
277              }
278              if ((err = der_decode_generalizedtime(in, &len, l->data)) != CRYPT_OK) {
279                 goto error;
280              }
281              if ((err = der_length_generalizedtime(l->data, &len)) != CRYPT_OK) {
282                 goto error;
283              }
284              break;
285           case 0x20: &bsol;* Any CONSTRUCTED element that is neither SEQUENCE nor SET */
286           case 0x30: &bsol;* SEQUENCE */
287           case 0x31: &bsol;* SET */
288               if (identifier == 0x20) {
289                 if (l->type != LTC_ASN1_CUSTOM_TYPE) {
290                    err = CRYPT_PK_ASN1_ERROR;
291                    goto error;
292                 }
293               }
294               else if (identifier == 0x30) {
295                 if (l->type != LTC_ASN1_SEQUENCE) {
296                    err = CRYPT_PK_ASN1_ERROR;
297                    goto error;
298                 }
299               }
300               else {
301                 if (l->type != LTC_ASN1_SET) {
302                    err = CRYPT_PK_ASN1_ERROR;
303                    goto error;
304                 }
305               }
306               if (depth > LTC_DER_MAX_RECURSION) {
307                  err = CRYPT_PK_ASN1_ERROR;
308                  goto error;
309               }
310               if ((l->data = XMALLOC(len)) == NULL) {
311                  err = CRYPT_MEM;
312                  goto error;
313               }
314               XMEMCPY(l->data, in, len);
315               l->size = len;
316               in     += data_offset;
317               *inlen -= data_offset;
318               len    -= data_offset;
319               len_len = len;
320               if ((err = s_der_decode_sequence_flexi(in, &len, &(l->child), depth+1)) != CRYPT_OK) {
321                  goto error;
322               }
323               if (len_len != len) {
324                  err = CRYPT_PK_ASN1_ERROR;
325                  goto error;
326               }
327               totlen += data_offset;
328               if (l->child) {
329                  l->child->parent = l;
330               }
331               break;
332           case 0x80: &bsol;* Context-specific */
333               if (l->type != LTC_ASN1_CUSTOM_TYPE) {
334                  err = CRYPT_PK_ASN1_ERROR;
335                  goto error;
336               }
337               if ((l->data = XCALLOC(1, len - data_offset)) == NULL) {
338                  err = CRYPT_MEM;
339                  goto error;
340               }
341               XMEMCPY(l->data, in + data_offset, len - data_offset);
342               l->size = len - data_offset;
343               break;
344           default:
345             if (l->prev) {
346                l       = l->prev;
347                XFREE(l->next);
348                l->next = NULL;
349             }
350             goto outside;
351        }
352        totlen  += len;
353        in      += len;
354        *inlen  -= len;
355     }
356  outside:
357     if (totlen) {
358        while (l->prev != NULL || l->parent != NULL) {
359           if (l->parent != NULL) {
360              l = l->parent;
361           } else {
362              l = l->prev;
363           }
364        }
365     }
366     *out   = l;
367     *inlen = totlen;
368     return CRYPT_OK;
369  error:
370     der_sequence_free(l);
371     return err;
372  }
373  int der_decode_sequence_flexi(const unsigned char *in, unsigned long *inlen, ltc_asn1_list **out)
374  {
375     return s_der_decode_sequence_flexi(in, inlen, out, 0);
376  }
377  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeCommonDefine.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_sequence_flexi.c</div>
                </div>
                <div class="column column_space"><pre><code>217      CGE_BLEND_COLORDODGE,   
218      CGE_BLEND_LINEARDODGE,  
219      CGE_BLEND_LIGHTERCOLOR, 
220      CGE_BLEND_OVERLAY,     
221      CGE_BLEND_SOFTLIGHT,   
222      CGE_BLEND_HARDLIGHT,   
223      CGE_BLEND_VIVIDLIGHT,  
224      CGE_BLEND_LINEARLIGHT, 
</pre></code></div>
                <div class="column column_space"><pre><code>20  static int s_der_decode_sequence_flexi(const unsigned char *in, unsigned long *inlen, ltc_asn1_list **out, unsigned long depth)
21  {
22     ltc_asn1_list *l;
23     unsigned long err, identifier, len, totlen, data_offset, id_len, len_len;
24     void          *realloc_tmp;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    