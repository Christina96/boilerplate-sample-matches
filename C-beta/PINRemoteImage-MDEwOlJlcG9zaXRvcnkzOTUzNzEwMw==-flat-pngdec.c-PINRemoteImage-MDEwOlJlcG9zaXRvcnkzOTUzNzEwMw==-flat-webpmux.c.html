
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.702127659574469%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-pngdec.c</h3>
            <pre><code>1  #include "./pngdec.h"
2  #ifdef HAVE_CONFIG_H
3  #include "webp/config.h"
4  #endif
5  #include <stdio.h>
6  #ifdef WEBP_HAVE_PNG
7  #ifndef PNG_USER_MEM_SUPPORTED
8  #define PNG_USER_MEM_SUPPORTED  
9  #endif
10  #include <png.h>
11  #include <setjmp.h>   
12  #include <stdlib.h>
13  #include <string.h>
14  #include "webp/encode.h"
15  #include "./imageio_util.h"
16  #include "./metadata.h"
17  #define LOCAL_PNG_VERSION ((PNG_LIBPNG_VER_MAJOR << 8) | PNG_LIBPNG_VER_MINOR)
18  #define LOCAL_PNG_PREREQ(maj, min) \
19     (LOCAL_PNG_VERSION >= (((maj) << 8) | (min)))
20  static void PNGAPI error_function(png_structp png, png_const_charp error) {
21    if (error != NULL) fprintf(stderr, "libpng error: %s\n", error);
22    longjmp(png_jmpbuf(png), 1);
23  }
24  #if LOCAL_PNG_PREREQ(1,4)
25  typedef png_alloc_size_t LocalPngAllocSize;
26  #else
27  typedef png_size_t LocalPngAllocSize;
28  #endif
29  static png_voidp MallocFunc(png_structp png_ptr, LocalPngAllocSize size) {
30    (void)png_ptr;
31    if (size != (size_t)size) return NULL;
32    if (!ImgIoUtilCheckSizeArgumentsOverflow(size, 1)) return NULL;
33    return (png_voidp)malloc((size_t)size);
34  }
35  static void FreeFunc(png_structp png_ptr, png_voidp ptr) {
36    (void)png_ptr;
37    free(ptr);
38  }
39  static uint8_t* HexStringToBytes(const char* hexstring,
40                                   size_t expected_length) {
41    const char* src = hexstring;
42    size_t actual_length = 0;
43    uint8_t* const raw_data = (uint8_t*)malloc(expected_length);
44    uint8_t* dst;
45    if (raw_data == NULL) return NULL;
46    for (dst = raw_data; actual_length < expected_length && *src != '\0'; ++src) {
47      char* end;
48      char val[3];
49      if (*src == '\n') continue;
50      val[0] = *src++;
51      val[1] = *src;
52      val[2] = '\0';
53      *dst++ = (uint8_t)strtol(val, &end, 16);
54      if (end != val + 2) break;
55      ++actual_length;
56    }
57    if (actual_length != expected_length) {
58      free(raw_data);
59      return NULL;
<span onclick='openModal()' class='match'>60    }
61    return raw_data;
62  }
63  static int ProcessRawProfile(const char* profile, size_t profile_len,
64                               MetadataPayload* const payload) {
65    const char* src = profile;
</span>66    char* end;
67    int expected_length;
68    if (profile == NULL || profile_len == 0) return 0;
69    if (*src != '\n') {
70      fprintf(stderr, "Malformed raw profile, expected '\\n' got '\\x%.2X'\n",
71              *src);
72      return 0;
73    }
74    ++src;
75    while (*src != '\0' && *src++ != '\n') {}
76    expected_length = (int)strtol(src, &end, 10);
77    if (*end != '\n') {
78      fprintf(stderr, "Malformed raw profile, expected '\\n' got '\\x%.2X'\n",
79              *end);
80      return 0;
81    }
82    ++end;
83    payload->bytes = HexStringToBytes(end, expected_length);
84    if (payload->bytes == NULL) return 0;
85    payload->size = expected_length;
86    return 1;
87  }
88  static const struct {
89    const char* name;
90    int (*process)(const char* profile, size_t profile_len,
91                   MetadataPayload* const payload);
92    size_t storage_offset;
93  } kPNGMetadataMap[] = {
94    { "Raw profile type exif", ProcessRawProfile, METADATA_OFFSET(exif) },
95    { "Raw profile type xmp",  ProcessRawProfile, METADATA_OFFSET(xmp) },
96    { "Raw profile type APP1", ProcessRawProfile, METADATA_OFFSET(exif) },
97    { "XML:com.adobe.xmp",     MetadataCopy,      METADATA_OFFSET(xmp) },
98    { NULL, NULL, 0 },
99  };
100  static int ExtractMetadataFromPNG(png_structp png,
101                                    png_infop const head_info,
102                                    png_infop const end_info,
103                                    Metadata* const metadata) {
104    int p;
105    for (p = 0; p < 2; ++p)  {
106      png_infop const info = (p == 0) ? head_info : end_info;
107      png_textp text = NULL;
108      const png_uint_32 num = png_get_text(png, info, &text, NULL);
109      png_uint_32 i;
110      for (i = 0; i < num; ++i, ++text) {
111        int j;
112        for (j = 0; kPNGMetadataMap[j].name != NULL; ++j) {
113          if (!strcmp(text->key, kPNGMetadataMap[j].name)) {
114            MetadataPayload* const payload =
115                (MetadataPayload*)((uint8_t*)metadata +
116                                   kPNGMetadataMap[j].storage_offset);
117            png_size_t text_length;
118            switch (text->compression) {
119  #ifdef PNG_iTXt_SUPPORTED
120              case PNG_ITXT_COMPRESSION_NONE:
121              case PNG_ITXT_COMPRESSION_zTXt:
122                text_length = text->itxt_length;
123                break;
124  #endif
125              case PNG_TEXT_COMPRESSION_NONE:
126              case PNG_TEXT_COMPRESSION_zTXt:
127              default:
128                text_length = text->text_length;
129                break;
130            }
131            if (payload->bytes != NULL) {
132              fprintf(stderr, "Ignoring additional '%s'\n", text->key);
133            } else if (!kPNGMetadataMap[j].process(text->text, text_length,
134                                                   payload)) {
135              fprintf(stderr, "Failed to process: '%s'\n", text->key);
136              return 0;
137            }
138            break;
139          }
140        }
141      }
142      {
143        png_charp name;
144        int comp_type;
145  #if LOCAL_PNG_PREREQ(1,5)
146        png_bytep profile;
147  #else
148        png_charp profile;
149  #endif
150        png_uint_32 len;
151        if (png_get_iCCP(png, info,
152                         &name, &comp_type, &profile, &len) == PNG_INFO_iCCP) {
153          if (!MetadataCopy((const char*)profile, len, &metadata->iccp)) return 0;
154        }
155      }
156    }
157    return 1;
158  }
159  typedef struct {
160    const uint8_t* data;
161    size_t data_size;
162    png_size_t offset;
163  } PNGReadContext;
164  static void ReadFunc(png_structp png_ptr, png_bytep data, png_size_t length) {
165    PNGReadContext* const ctx = (PNGReadContext*)png_get_io_ptr(png_ptr);
166    if (ctx->data_size - ctx->offset < length) {
167      png_error(png_ptr, "ReadFunc: invalid read length (overflow)!");
168    }
169    memcpy(data, ctx->data + ctx->offset, length);
170    ctx->offset += length;
171  }
172  int ReadPNG(const uint8_t* const data, size_t data_size,
173              struct WebPPicture* const pic,
174              int keep_alpha, struct Metadata* const metadata) {
175    volatile png_structp png = NULL;
176    volatile png_infop info = NULL;
177    volatile png_infop end_info = NULL;
178    PNGReadContext context = { NULL, 0, 0 };
179    int color_type, bit_depth, interlaced;
180    int has_alpha;
181    int num_passes;
182    int p;
183    volatile int ok = 0;
184    png_uint_32 width, height, y;
185    int64_t stride;
186    uint8_t* volatile rgb = NULL;
187    if (data == NULL || data_size == 0 || pic == NULL) return 0;
188    context.data = data;
189    context.data_size = data_size;
190    png = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,
191                                   NULL, MallocFunc, FreeFunc);
192    if (png == NULL) goto End;
193    png_set_error_fn(png, 0, error_function, NULL);
194    if (setjmp(png_jmpbuf(png))) {
195   Error:
196      MetadataFree(metadata);
197      goto End;
198    }
199    info = png_create_info_struct(png);
200    if (info == NULL) goto Error;
201    end_info = png_create_info_struct(png);
202    if (end_info == NULL) goto Error;
203    png_set_read_fn(png, &context, ReadFunc);
204    png_read_info(png, info);
205    if (!png_get_IHDR(png, info,
206                      &width, &height, &bit_depth, &color_type, &interlaced,
207                      NULL, NULL)) goto Error;
208    png_set_strip_16(png);
209    png_set_packing(png);
210    if (color_type == PNG_COLOR_TYPE_PALETTE) {
211      png_set_palette_to_rgb(png);
212    }
213    if (color_type == PNG_COLOR_TYPE_GRAY ||
214        color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
215      if (bit_depth < 8) {
216        png_set_expand_gray_1_2_4_to_8(png);
217      }
218      png_set_gray_to_rgb(png);
219    }
220    if (png_get_valid(png, info, PNG_INFO_tRNS)) {
221      png_set_tRNS_to_alpha(png);
222      has_alpha = 1;
223    } else {
224      has_alpha = !!(color_type & PNG_COLOR_MASK_ALPHA);
225    }
226    {
227      double image_gamma = 1 / 2.2, screen_gamma = 2.2;
228      int srgb_intent;
229      if (png_get_sRGB(png, info, &srgb_intent) ||
230          png_get_gAMA(png, info, &image_gamma)) {
231        png_set_gamma(png, screen_gamma, image_gamma);
232      }
233    }
234    if (!keep_alpha) {
235      png_set_strip_alpha(png);
236      has_alpha = 0;
237    }
238    num_passes = png_set_interlace_handling(png);
239    png_read_update_info(png, info);
240    stride = (int64_t)(has_alpha ? 4 : 3) * width * sizeof(*rgb);
241    if (stride != (int)stride ||
242        !ImgIoUtilCheckSizeArgumentsOverflow(stride, height)) {
243      goto Error;
244    }
245    rgb = (uint8_t*)malloc((size_t)stride * height);
246    if (rgb == NULL) goto Error;
247    for (p = 0; p < num_passes; ++p) {
248      png_bytep row = rgb;
249      for (y = 0; y < height; ++y) {
250        png_read_rows(png, &row, NULL, 1);
251        row += stride;
252      }
253    }
254    png_read_end(png, end_info);
255    if (metadata != NULL &&
256        !ExtractMetadataFromPNG(png, info, end_info, metadata)) {
257      fprintf(stderr, "Error extracting PNG metadata!\n");
258      goto Error;
259    }
260    pic->width = (int)width;
261    pic->height = (int)height;
262    ok = has_alpha ? WebPPictureImportRGBA(pic, rgb, (int)stride)
263                   : WebPPictureImportRGB(pic, rgb, (int)stride);
264    if (!ok) {
265      goto Error;
266    }
267   End:
268    if (png != NULL) {
269      png_destroy_read_struct((png_structpp)&png,
270                              (png_infopp)&info, (png_infopp)&end_info);
271    }
272    free(rgb);
273    return ok;
274  }
275  #else  
276  int ReadPNG(const uint8_t* const data, size_t data_size,
277              struct WebPPicture* const pic,
278              int keep_alpha, struct Metadata* const metadata) {
279    (void)data;
280    (void)data_size;
281    (void)pic;
282    (void)keep_alpha;
283    (void)metadata;
284    fprintf(stderr, "PNG support not compiled. Please install the libpng "
285            "development package before building.\n");
286    return 0;
287  }
288  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpmux.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "webp/config.h"
3  #endif
4  #include <assert.h>
5  #include <stdio.h>
6  #include <stdlib.h>
7  #include <string.h>
8  #include "webp/decode.h"
9  #include "webp/mux.h"
10  #include "../examples/example_util.h"
11  #include "../imageio/imageio_util.h"
12  #include "./unicode.h"
13  typedef enum {
14    NIL_ACTION = 0,
15    ACTION_GET,
16    ACTION_SET,
17    ACTION_STRIP,
18    ACTION_INFO,
19    ACTION_HELP,
20    ACTION_DURATION
21  } ActionType;
22  typedef enum {
23    NIL_SUBTYPE = 0,
24    SUBTYPE_ANMF,
25    SUBTYPE_LOOP,
26    SUBTYPE_BGCOLOR
27  } FeatureSubType;
28  typedef struct {
29    FeatureSubType subtype_;
30    const char* filename_;
31    const char* params_;
32  } FeatureArg;
33  typedef enum {
34    NIL_FEATURE = 0,
35    FEATURE_EXIF,
36    FEATURE_XMP,
37    FEATURE_ICCP,
38    FEATURE_ANMF,
39    FEATURE_DURATION,
40    LAST_FEATURE
41  } FeatureType;
42  static const char* const kFourccList[LAST_FEATURE] = {
43    NULL, "EXIF", "XMP ", "ICCP", "ANMF"
44  };
45  static const char* const kDescriptions[LAST_FEATURE] = {
46    NULL, "EXIF metadata", "XMP metadata", "ICC profile",
47    "Animation frame"
48  };
49  typedef struct {
50    CommandLineArguments cmd_args_;
51    ActionType action_type_;
52    const char* input_;
53    const char* output_;
54    FeatureType type_;
55    FeatureArg* args_;
56    int arg_count_;
57  } Config;
58  static int CountOccurrences(const CommandLineArguments* const args,
59                              const char* const arg) {
60    int i;
61    int num_occurences = 0;
62    for (i = 0; i < args->argc_; ++i) {
63      if (!strcmp(args->argv_[i], arg)) {
64        ++num_occurences;
65      }
66    }
67    return num_occurences;
68  }
69  static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
70    "WEBP_MUX_NOT_FOUND", "WEBP_MUX_INVALID_ARGUMENT", "WEBP_MUX_BAD_DATA",
71    "WEBP_MUX_MEMORY_ERROR", "WEBP_MUX_NOT_ENOUGH_DATA"
72  };
73  static const char* ErrorString(WebPMuxError err) {
74    assert(err <= WEBP_MUX_NOT_FOUND && err >= WEBP_MUX_NOT_ENOUGH_DATA);
75    return kErrorMessages[-err];
76  }
77  #define RETURN_IF_ERROR(ERR_MSG)                                     \
78    if (err != WEBP_MUX_OK) {                                          \
79      fprintf(stderr, ERR_MSG);                                        \
80      return err;                                                      \
81    }
82  #define RETURN_IF_ERROR3(ERR_MSG, FORMAT_STR1, FORMAT_STR2)          \
83    if (err != WEBP_MUX_OK) {                                          \
84      fprintf(stderr, ERR_MSG, FORMAT_STR1, FORMAT_STR2);              \
85      return err;                                                      \
86    }
87  #define ERROR_GOTO1(ERR_MSG, LABEL)                                  \
88    do {                                                               \
89      fprintf(stderr, ERR_MSG);                                        \
90      ok = 0;                                                          \
91      goto LABEL;                                                      \
92    } while (0)
93  #define ERROR_GOTO2(ERR_MSG, FORMAT_STR, LABEL)                      \
94    do {                                                               \
95      fprintf(stderr, ERR_MSG, FORMAT_STR);                            \
96      ok = 0;                                                          \
97      goto LABEL;                                                      \
98    } while (0)
99  #define ERROR_GOTO3(ERR_MSG, FORMAT_STR1, FORMAT_STR2, LABEL)        \
100    do {                                                               \
101      fprintf(stderr, ERR_MSG, FORMAT_STR1, FORMAT_STR2);              \
102      ok = 0;                                                          \
103      goto LABEL;                                                      \
104    } while (0)
105  static WebPMuxError DisplayInfo(const WebPMux* mux) {
106    int width, height;
107    uint32_t flag;
108    WebPMuxError err = WebPMuxGetCanvasSize(mux, &width, &height);
109    assert(err == WEBP_MUX_OK);  
110    printf("Canvas size: %d x %d\n", width, height);
111    err = WebPMuxGetFeatures(mux, &flag);
112    RETURN_IF_ERROR("Failed to retrieve features\n");
113    if (flag == 0) {
114      printf("No features present.\n");
115      return err;
116    }
117    printf("Features present:");
118    if (flag & ANIMATION_FLAG) printf(" animation");
119    if (flag & ICCP_FLAG)      printf(" ICC profile");
120    if (flag & EXIF_FLAG)      printf(" EXIF metadata");
121    if (flag & XMP_FLAG)       printf(" XMP metadata");
122    if (flag & ALPHA_FLAG)     printf(" transparency");
123    printf("\n");
124    if (flag & ANIMATION_FLAG) {
125      const WebPChunkId id = WEBP_CHUNK_ANMF;
126      const char* const type_str = "frame";
127      int nFrames;
128      WebPMuxAnimParams params;
129      err = WebPMuxGetAnimationParams(mux, &params);
130      assert(err == WEBP_MUX_OK);
131      printf("Background color : 0x%.8X  Loop Count : %d\n",
132             params.bgcolor, params.loop_count);
133      err = WebPMuxNumChunks(mux, id, &nFrames);
134      assert(err == WEBP_MUX_OK);
135      printf("Number of %ss: %d\n", type_str, nFrames);
136      if (nFrames > 0) {
137        int i;
138        printf("No.: width height alpha x_offset y_offset ");
139        printf("duration   dispose blend ");
140        printf("image_size  compression\n");
141        for (i = 1; i <= nFrames; i++) {
142          WebPMuxFrameInfo frame;
143          err = WebPMuxGetFrame(mux, i, &frame);
144          if (err == WEBP_MUX_OK) {
145            WebPBitstreamFeatures features;
146            const VP8StatusCode status = WebPGetFeatures(
147                frame.bitstream.bytes, frame.bitstream.size, &features);
148            assert(status == VP8_STATUS_OK);  
149            (void)status;
150            printf("%3d: %5d %5d %5s %8d %8d ", i, features.width,
151                   features.height, features.has_alpha ? "yes" : "no",
152                   frame.x_offset, frame.y_offset);
153            {
154              const char* const dispose =
155                  (frame.dispose_method == WEBP_MUX_DISPOSE_NONE) ? "none"
156                                                                  : "background";
157              const char* const blend =
158                  (frame.blend_method == WEBP_MUX_BLEND) ? "yes" : "no";
159              printf("%8d %10s %5s ", frame.duration, dispose, blend);
160            }
161            printf("%10d %11s\n", (int)frame.bitstream.size,
162                   (features.format == 1) ? "lossy" :
163                   (features.format == 2) ? "lossless" :
164                                            "undefined");
165          }
166          WebPDataClear(&frame.bitstream);
167          RETURN_IF_ERROR3("Failed to retrieve %s#%d\n", type_str, i);
168        }
169      }
170    }
171    if (flag & ICCP_FLAG) {
172      WebPData icc_profile;
173      err = WebPMuxGetChunk(mux, "ICCP", &icc_profile);
174      assert(err == WEBP_MUX_OK);
175      printf("Size of the ICC profile data: %d\n", (int)icc_profile.size);
176    }
177    if (flag & EXIF_FLAG) {
178      WebPData exif;
179      err = WebPMuxGetChunk(mux, "EXIF", &exif);
180      assert(err == WEBP_MUX_OK);
181      printf("Size of the EXIF metadata: %d\n", (int)exif.size);
182    }
183    if (flag & XMP_FLAG) {
184      WebPData xmp;
185      err = WebPMuxGetChunk(mux, "XMP ", &xmp);
186      assert(err == WEBP_MUX_OK);
187      printf("Size of the XMP metadata: %d\n", (int)xmp.size);
188    }
189    if ((flag & ALPHA_FLAG) && !(flag & ANIMATION_FLAG)) {
190      WebPMuxFrameInfo image;
191      err = WebPMuxGetFrame(mux, 1, &image);
192      if (err == WEBP_MUX_OK) {
193        printf("Size of the image (with alpha): %d\n", (int)image.bitstream.size);
194      }
195      WebPDataClear(&image.bitstream);
196      RETURN_IF_ERROR("Failed to retrieve the image\n");
197    }
198    return WEBP_MUX_OK;
199  }
200  static void PrintHelp(void) {
201    printf("Usage: webpmux -get GET_OPTIONS INPUT -o OUTPUT\n");
202    printf("       webpmux -set SET_OPTIONS INPUT -o OUTPUT\n");
203    printf("       webpmux -duration DURATION_OPTIONS [-duration ...]\n");
204    printf("               INPUT -o OUTPUT\n");
205    printf("       webpmux -strip STRIP_OPTIONS INPUT -o OUTPUT\n");
206    printf("       webpmux -frame FRAME_OPTIONS [-frame...] [-loop LOOP_COUNT]"
207           "\n");
208    printf("               [-bgcolor BACKGROUND_COLOR] -o OUTPUT\n");
209    printf("       webpmux -info INPUT\n");
210    printf("       webpmux [-h|-help]\n");
211    printf("       webpmux -version\n");
212    printf("       webpmux argument_file_name\n");
213    printf("\n");
214    printf("GET_OPTIONS:\n");
215    printf(" Extract relevant data:\n");
216    printf("   icc       get ICC profile\n");
217    printf("   exif      get EXIF metadata\n");
218    printf("   xmp       get XMP metadata\n");
219    printf("   frame n   get nth frame\n");
220    printf("\n");
221    printf("SET_OPTIONS:\n");
222    printf(" Set color profile/metadata:\n");
223    printf("   icc  file.icc     set ICC profile\n");
224    printf("   exif file.exif    set EXIF metadata\n");
225    printf("   xmp  file.xmp     set XMP metadata\n");
226    printf("   where:    'file.icc' contains the ICC profile to be set,\n");
227    printf("             'file.exif' contains the EXIF metadata to be set\n");
228    printf("             'file.xmp' contains the XMP metadata to be set\n");
229    printf("\n");
230    printf("DURATION_OPTIONS:\n");
231    printf(" Set duration of selected frames:\n");
232    printf("   duration            set duration for each frames\n");
233    printf("   duration,frame      set duration of a particular frame\n");
234    printf("   duration,start,end  set duration of frames in the\n");
235    printf("                        interval [start,end])\n");
236    printf("   where: 'duration' is the duration in milliseconds\n");
237    printf("          'start' is the start frame index\n");
238    printf("          'end' is the inclusive end frame index\n");
239    printf("           The special 'end' value '0' means: last frame.\n");
240    printf("\n");
241    printf("STRIP_OPTIONS:\n");
242    printf(" Strip color profile/metadata:\n");
243    printf("   icc       strip ICC profile\n");
244    printf("   exif      strip EXIF metadata\n");
245    printf("   xmp       strip XMP metadata\n");
246    printf("\n");
247    printf("FRAME_OPTIONS(i):\n");
248    printf(" Create animation:\n");
249    printf("   file_i +di+[xi+yi[+mi[bi]]]\n");
250    printf("   where:    'file_i' is the i'th animation frame (WebP format),\n");
251    printf("             'di' is the pause duration before next frame,\n");
252    printf("             'xi','yi' specify the image offset for this frame,\n");
253    printf("             'mi' is the dispose method for this frame (0 or 1),\n");
254    printf("             'bi' is the blending method for this frame (+b or -b)"
255           "\n");
256    printf("\n");
257    printf("LOOP_COUNT:\n");
258    printf(" Number of times to repeat the animation.\n");
259    printf(" Valid range is 0 to 65535 [Default: 0 (infinite)].\n");
260    printf("\n");
261    printf("BACKGROUND_COLOR:\n");
262    printf(" Background color of the canvas.\n");
263    printf("  A,R,G,B\n");
264    printf("  where:    'A', 'R', 'G' and 'B' are integers in the range 0 to 255 "
265           "specifying\n");
266    printf("            the Alpha, Red, Green and Blue component values "
267           "respectively\n");
268    printf("            [Default: 255,255,255,255]\n");
269    printf("\nINPUT & OUTPUT are in WebP format.\n");
270    printf("\nNote: The nature of EXIF, XMP and ICC data is not checked");
271    printf(" and is assumed to be\nvalid.\n");
272    printf("\nNote: if a single file name is passed as the argument, the "
273           "arguments will be\n");
274    printf("tokenized from this file. The file name must not start with "
275           "the character '-'.\n");
276  }
277  static void WarnAboutOddOffset(const WebPMuxFrameInfo* const info) {
278    if ((info->x_offset | info->y_offset) & 1) {
279      fprintf(stderr, "Warning: odd offsets will be snapped to even values"
280              " (%d, %d) -> (%d, %d)\n", info->x_offset, info->y_offset,
281              info->x_offset & ~1, info->y_offset & ~1);
282    }
283  }
284  static int CreateMux(const char* const filename, WebPMux** mux) {
285    WebPData bitstream;
286    assert(mux != NULL);
287    if (!ExUtilReadFileToWebPData(filename, &bitstream)) return 0;
288    *mux = WebPMuxCreate(&bitstream, 1);
289    WebPDataClear(&bitstream);
290    if (*mux != NULL) return 1;
291    WFPRINTF(stderr, "Failed to create mux object from file %s.\n",
292             (const W_CHAR*)filename);
293    return 0;
294  }
295  static int WriteData(const char* filename, const WebPData* const webpdata) {
296    int ok = 0;
297    FILE* fout = WSTRCMP(filename, "-") ? WFOPEN(filename, "wb")
298                                        : ImgIoUtilSetBinaryMode(stdout);
299    if (fout == NULL) {
300      WFPRINTF(stderr, "Error opening output WebP file %s!\n",
301               (const W_CHAR*)filename);
302      return 0;
303    }
304    if (fwrite(webpdata->bytes, webpdata->size, 1, fout) != 1) {
305      WFPRINTF(stderr, "Error writing file %s!\n", (const W_CHAR*)filename);
306    } else {
307      WFPRINTF(stderr, "Saved file %s (%d bytes)\n",
308               (const W_CHAR*)filename, (int)webpdata->size);
309      ok = 1;
310    }
<span onclick='openModal()' class='match'>311    if (fout != stdout) fclose(fout);
312    return ok;
313  }
314  static int WriteWebP(WebPMux* const mux, const char* filename) {
315    int ok;
316    WebPData webp_data;
</span>317    const WebPMuxError err = WebPMuxAssemble(mux, &webp_data);
318    if (err != WEBP_MUX_OK) {
319      fprintf(stderr, "Error (%s) assembling the WebP file.\n", ErrorString(err));
320      return 0;
321    }
322    ok = WriteData(filename, &webp_data);
323    WebPDataClear(&webp_data);
324    return ok;
325  }
326  static WebPMux* DuplicateMuxHeader(const WebPMux* const mux) {
327    WebPMux* new_mux = WebPMuxNew();
328    WebPMuxAnimParams p;
329    WebPMuxError err;
330    int i;
331    int ok = 1;
332    if (new_mux == NULL) return NULL;
333    err = WebPMuxGetAnimationParams(mux, &p);
334    if (err == WEBP_MUX_OK) {
335      err = WebPMuxSetAnimationParams(new_mux, &p);
336      if (err != WEBP_MUX_OK) {
337        ERROR_GOTO2("Error (%s) handling animation params.\n",
338                    ErrorString(err), End);
339      }
340    } else {
341    }
342    for (i = 1; i <= 3; ++i) {
343      WebPData metadata;
344      err = WebPMuxGetChunk(mux, kFourccList[i], &metadata);
345      if (err == WEBP_MUX_OK && metadata.size > 0) {
346        err = WebPMuxSetChunk(new_mux, kFourccList[i], &metadata, 1);
347        if (err != WEBP_MUX_OK) {
348          ERROR_GOTO1("Error transferring metadata in DuplicateMux().", End);
349        }
350      }
351    }
352   End:
353    if (!ok) {
354      WebPMuxDelete(new_mux);
355      new_mux = NULL;
356    }
357    return new_mux;
358  }
359  static int ParseFrameArgs(const char* args, WebPMuxFrameInfo* const info) {
360    int dispose_method, dummy;
361    char plus_minus, blend_method;
362    const int num_args = sscanf(args, "+%d+%d+%d+%d%c%c+%d", &info->duration,
363                                &info->x_offset, &info->y_offset, &dispose_method,
364                                &plus_minus, &blend_method, &dummy);
365    switch (num_args) {
366      case 1:
367        info->x_offset = info->y_offset = 0;  
368      case 3:
369        dispose_method = 0;  
370      case 4:
371        plus_minus = '+';
372        blend_method = 'b';  
373      case 6:
374        break;
375      case 2:
376      case 5:
377      default:
378        return 0;
379    }
380    WarnAboutOddOffset(info);
381    info->dispose_method = (WebPMuxAnimDispose)dispose_method;
382    if (blend_method != 'b') return 0;
383    if (plus_minus != '-' && plus_minus != '+') return 0;
384    info->blend_method =
385        (plus_minus == '+') ? WEBP_MUX_BLEND : WEBP_MUX_NO_BLEND;
386    return 1;
387  }
388  static int ParseBgcolorArgs(const char* args, uint32_t* const bgcolor) {
389    uint32_t a, r, g, b;
390    if (sscanf(args, "%u,%u,%u,%u", &a, &r, &g, &b) != 4) return 0;
391    if (a >= 256 || r >= 256 || g >= 256 || b >= 256) return 0;
392    *bgcolor = (a << 24) | (r << 16) | (g << 8) | (b << 0);
393    return 1;
394  }
395  static void DeleteConfig(Config* const config) {
396    if (config != NULL) {
397      free(config->args_);
398      ExUtilDeleteCommandLineArguments(&config->cmd_args_);
399      memset(config, 0, sizeof(*config));
400    }
401  }
402  static int ValidateCommandLine(const CommandLineArguments* const cmd_args,
403                                 int* num_feature_args) {
404    int num_frame_args;
405    int num_loop_args;
406    int num_bgcolor_args;
407    int num_durations_args;
408    int ok = 1;
409    assert(num_feature_args != NULL);
410    *num_feature_args = 0;
411    if (CountOccurrences(cmd_args, "-get") > 1) {
412      ERROR_GOTO1("ERROR: Multiple '-get' arguments specified.\n", ErrValidate);
413    }
414    if (CountOccurrences(cmd_args, "-set") > 1) {
415      ERROR_GOTO1("ERROR: Multiple '-set' arguments specified.\n", ErrValidate);
416    }
417    if (CountOccurrences(cmd_args, "-strip") > 1) {
418      ERROR_GOTO1("ERROR: Multiple '-strip' arguments specified.\n", ErrValidate);
419    }
420    if (CountOccurrences(cmd_args, "-info") > 1) {
421      ERROR_GOTO1("ERROR: Multiple '-info' arguments specified.\n", ErrValidate);
422    }
423    if (CountOccurrences(cmd_args, "-o") > 1) {
424      ERROR_GOTO1("ERROR: Multiple output files specified.\n", ErrValidate);
425    }
426    num_frame_args = CountOccurrences(cmd_args, "-frame");
427    num_loop_args = CountOccurrences(cmd_args, "-loop");
428    num_bgcolor_args = CountOccurrences(cmd_args, "-bgcolor");
429    num_durations_args = CountOccurrences(cmd_args, "-duration");
430    if (num_loop_args > 1) {
431      ERROR_GOTO1("ERROR: Multiple loop counts specified.\n", ErrValidate);
432    }
433    if (num_bgcolor_args > 1) {
434      ERROR_GOTO1("ERROR: Multiple background colors specified.\n", ErrValidate);
435    }
436    if ((num_frame_args == 0) && (num_loop_args + num_bgcolor_args > 0)) {
437      ERROR_GOTO1("ERROR: Loop count and background color are relevant only in "
438                  "case of animation.\n", ErrValidate);
439    }
440    if (num_durations_args > 0 && num_frame_args != 0) {
441      ERROR_GOTO1("ERROR: Can not combine -duration and -frame commands.\n",
442                  ErrValidate);
443    }
444    assert(ok == 1);
445    if (num_durations_args > 0) {
446      *num_feature_args = num_durations_args;
447    } else if (num_frame_args == 0) {
448      *num_feature_args = 1;
449    } else {
450      *num_feature_args = num_frame_args + num_loop_args + num_bgcolor_args;
451    }
452   ErrValidate:
453    return ok;
454  }
455  #define ACTION_IS_NIL (config->action_type_ == NIL_ACTION)
456  #define FEATURETYPE_IS_NIL (config->type_ == NIL_FEATURE)
457  #define CHECK_NUM_ARGS_AT_LEAST(NUM, LABEL)                              \
458    if (argc < i + (NUM)) {                                                \
459      fprintf(stderr, "ERROR: Too few arguments for '%s'.\n", argv[i]);    \
460      goto LABEL;                                                          \
461    }
462  #define CHECK_NUM_ARGS_AT_MOST(NUM, LABEL)                               \
463    if (argc > i + (NUM)) {                                                \
464      fprintf(stderr, "ERROR: Too many arguments for '%s'.\n", argv[i]);   \
465      goto LABEL;                                                          \
466    }
467  #define CHECK_NUM_ARGS_EXACTLY(NUM, LABEL)                               \
468    CHECK_NUM_ARGS_AT_LEAST(NUM, LABEL);                                   \
469    CHECK_NUM_ARGS_AT_MOST(NUM, LABEL);
470  static int ParseCommandLine(Config* config, const W_CHAR** const unicode_argv) {
471    int i = 0;
472    int feature_arg_index = 0;
473    int ok = 1;
474    int argc = config->cmd_args_.argc_;
475    const char* const* argv = config->cmd_args_.argv_;
476    const char* const* wargv =
477        (unicode_argv != NULL) ? (const char**)(unicode_argv + 1) : argv;
478    while (i < argc) {
479      FeatureArg* const arg = &config->args_[feature_arg_index];
480      if (argv[i][0] == '-') {  
481        if (!strcmp(argv[i], "-set")) {
482          if (ACTION_IS_NIL) {
483            config->action_type_ = ACTION_SET;
484          } else {
485            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
486          }
487          ++i;
488        } else if (!strcmp(argv[i], "-duration")) {
489          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
490          if (ACTION_IS_NIL || config->action_type_ == ACTION_DURATION) {
491            config->action_type_ = ACTION_DURATION;
492          } else {
493            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
494          }
495          if (FEATURETYPE_IS_NIL || config->type_ == FEATURE_DURATION) {
496            config->type_ = FEATURE_DURATION;
497          } else {
498            ERROR_GOTO1("ERROR: Multiple features specified.\n", ErrParse);
499          }
500          arg->params_ = argv[i + 1];
501          ++feature_arg_index;
502          i += 2;
503        } else if (!strcmp(argv[i], "-get")) {
504          if (ACTION_IS_NIL) {
505            config->action_type_ = ACTION_GET;
506          } else {
507            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
508          }
509          ++i;
510        } else if (!strcmp(argv[i], "-strip")) {
511          if (ACTION_IS_NIL) {
512            config->action_type_ = ACTION_STRIP;
513            config->arg_count_ = 0;
514          } else {
515            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
516          }
517          ++i;
518        } else if (!strcmp(argv[i], "-frame")) {
519          CHECK_NUM_ARGS_AT_LEAST(3, ErrParse);
520          if (ACTION_IS_NIL || config->action_type_ == ACTION_SET) {
521            config->action_type_ = ACTION_SET;
522          } else {
523            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
524          }
525          if (FEATURETYPE_IS_NIL || config->type_ == FEATURE_ANMF) {
526            config->type_ = FEATURE_ANMF;
527          } else {
528            ERROR_GOTO1("ERROR: Multiple features specified.\n", ErrParse);
529          }
530          arg->subtype_ = SUBTYPE_ANMF;
531          arg->filename_ = argv[i + 1];
532          arg->params_ = argv[i + 2];
533          ++feature_arg_index;
534          i += 3;
535        } else if (!strcmp(argv[i], "-loop") || !strcmp(argv[i], "-bgcolor")) {
536          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
537          if (ACTION_IS_NIL || config->action_type_ == ACTION_SET) {
538            config->action_type_ = ACTION_SET;
539          } else {
540            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
541          }
542          if (FEATURETYPE_IS_NIL || config->type_ == FEATURE_ANMF) {
543            config->type_ = FEATURE_ANMF;
544          } else {
545            ERROR_GOTO1("ERROR: Multiple features specified.\n", ErrParse);
546          }
547          arg->subtype_ =
548              !strcmp(argv[i], "-loop") ? SUBTYPE_LOOP : SUBTYPE_BGCOLOR;
549          arg->params_ = argv[i + 1];
550          ++feature_arg_index;
551          i += 2;
552        } else if (!strcmp(argv[i], "-o")) {
553          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
554          config->output_ = wargv[i + 1];
555          i += 2;
556        } else if (!strcmp(argv[i], "-info")) {
557          CHECK_NUM_ARGS_EXACTLY(2, ErrParse);
558          if (config->action_type_ != NIL_ACTION) {
559            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
560          } else {
561            config->action_type_ = ACTION_INFO;
562            config->arg_count_ = 0;
563            config->input_ = wargv[i + 1];
564          }
565          i += 2;
566        } else if (!strcmp(argv[i], "-h") || !strcmp(argv[i], "-help")) {
567          PrintHelp();
568          DeleteConfig(config);
569          LOCAL_FREE((W_CHAR** const)unicode_argv);
570          exit(0);
571        } else if (!strcmp(argv[i], "-version")) {
572          const int version = WebPGetMuxVersion();
573          printf("%d.%d.%d\n",
574                 (version >> 16) & 0xff, (version >> 8) & 0xff, version & 0xff);
575          DeleteConfig(config);
576          LOCAL_FREE((W_CHAR** const)unicode_argv);
577          exit(0);
578        } else if (!strcmp(argv[i], "--")) {
579          if (i < argc - 1) {
580            ++i;
581            if (config->input_ == NULL) {
582              config->input_ = wargv[i];
583            } else {
584              ERROR_GOTO2("ERROR at '%s': Multiple input files specified.\n",
585                          argv[i], ErrParse);
586            }
587          }
588          break;
589        } else {
590          ERROR_GOTO2("ERROR: Unknown option: '%s'.\n", argv[i], ErrParse);
591        }
592      } else {  
593        if (ACTION_IS_NIL) {
594          ERROR_GOTO1("ERROR: Action must be specified before other arguments.\n",
595                      ErrParse);
596        }
597        if (!strcmp(argv[i], "icc") || !strcmp(argv[i], "exif") ||
598            !strcmp(argv[i], "xmp")) {
599          if (FEATURETYPE_IS_NIL) {
600            config->type_ = (!strcmp(argv[i], "icc")) ? FEATURE_ICCP :
601                (!strcmp(argv[i], "exif")) ? FEATURE_EXIF : FEATURE_XMP;
602          } else {
603            ERROR_GOTO1("ERROR: Multiple features specified.\n", ErrParse);
604          }
605          if (config->action_type_ == ACTION_SET) {
606            CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
607            arg->filename_ = wargv[i + 1];
608            ++feature_arg_index;
609            i += 2;
610          } else {
611            ++i;
612          }
613        } else if (!strcmp(argv[i], "frame") &&
614                   (config->action_type_ == ACTION_GET)) {
615          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
616          config->type_ = FEATURE_ANMF;
617          arg->params_ = argv[i + 1];
618          ++feature_arg_index;
619          i += 2;
620        } else {  
621          if (config->input_ == NULL) {
622            config->input_ = wargv[i];
623          } else {
624            ERROR_GOTO2("ERROR at '%s': Multiple input files specified.\n",
625                        argv[i], ErrParse);
626          }
627          ++i;
628        }
629      }
630    }
631   ErrParse:
632    return ok;
633  }
634  static int ValidateConfig(Config* const config) {
635    int ok = 1;
636    if (ACTION_IS_NIL) {
637      ERROR_GOTO1("ERROR: No action specified.\n", ErrValidate2);
638    }
639    if (FEATURETYPE_IS_NIL && config->action_type_ != ACTION_INFO) {
640      ERROR_GOTO1("ERROR: No feature specified.\n", ErrValidate2);
641    }
642    if (config->input_ == NULL) {
643      if (config->action_type_ != ACTION_SET) {
644        ERROR_GOTO1("ERROR: No input file specified.\n", ErrValidate2);
645      } else if (config->type_ != FEATURE_ANMF) {
646        ERROR_GOTO1("ERROR: No input file specified.\n", ErrValidate2);
647      }
648    }
649    if (config->output_ == NULL && config->action_type_ != ACTION_INFO) {
650      ERROR_GOTO1("ERROR: No output file specified.\n", ErrValidate2);
651    }
652   ErrValidate2:
653    return ok;
654  }
655  static int InitializeConfig(int argc, const char* argv[], Config* const config,
656                              const W_CHAR** const unicode_argv) {
657    int num_feature_args = 0;
658    int ok;
659    memset(config, 0, sizeof(*config));
660    ok = ExUtilInitCommandLineArguments(argc, argv, &config->cmd_args_);
661    if (!ok) return 0;
662    if (!ValidateCommandLine(&config->cmd_args_, &num_feature_args)) {
663      ERROR_GOTO1("Exiting due to command-line parsing error.\n", Err1);
664    }
665    config->arg_count_ = num_feature_args;
666    config->args_ = (FeatureArg*)calloc(num_feature_args, sizeof(*config->args_));
667    if (config->args_ == NULL) {
668      ERROR_GOTO1("ERROR: Memory allocation error.\n", Err1);
669    }
670    if (!ParseCommandLine(config, unicode_argv) || !ValidateConfig(config)) {
671      ERROR_GOTO1("Exiting due to command-line parsing error.\n", Err1);
672    }
673   Err1:
674    return ok;
675  }
676  #undef ACTION_IS_NIL
677  #undef FEATURETYPE_IS_NIL
678  #undef CHECK_NUM_ARGS_AT_LEAST
679  #undef CHECK_NUM_ARGS_AT_MOST
680  #undef CHECK_NUM_ARGS_EXACTLY
681  static int GetFrame(const WebPMux* mux, const Config* config) {
682    WebPMuxError err = WEBP_MUX_OK;
683    WebPMux* mux_single = NULL;
684    int num = 0;
685    int ok = 1;
686    int parse_error = 0;
687    const WebPChunkId id = WEBP_CHUNK_ANMF;
688    WebPMuxFrameInfo info;
689    WebPDataInit(&info.bitstream);
690    num = ExUtilGetInt(config->args_[0].params_, 10, &parse_error);
691    if (num < 0) {
692      ERROR_GOTO1("ERROR: Frame/Fragment index must be non-negative.\n", ErrGet);
693    }
694    if (parse_error) goto ErrGet;
695    err = WebPMuxGetFrame(mux, num, &info);
696    if (err == WEBP_MUX_OK && info.id != id) err = WEBP_MUX_NOT_FOUND;
697    if (err != WEBP_MUX_OK) {
698      ERROR_GOTO3("ERROR (%s): Could not get frame %d.\n",
699                  ErrorString(err), num, ErrGet);
700    }
701    mux_single = WebPMuxNew();
702    if (mux_single == NULL) {
703      err = WEBP_MUX_MEMORY_ERROR;
704      ERROR_GOTO2("ERROR (%s): Could not allocate a mux object.\n",
705                  ErrorString(err), ErrGet);
706    }
707    err = WebPMuxSetImage(mux_single, &info.bitstream, 1);
708    if (err != WEBP_MUX_OK) {
709      ERROR_GOTO2("ERROR (%s): Could not create single image mux object.\n",
710                  ErrorString(err), ErrGet);
711    }
712    ok = WriteWebP(mux_single, config->output_);
713   ErrGet:
714    WebPDataClear(&info.bitstream);
715    WebPMuxDelete(mux_single);
716    return ok && !parse_error;
717  }
718  static int Process(const Config* config) {
719    WebPMux* mux = NULL;
720    WebPData chunk;
721    WebPMuxError err = WEBP_MUX_OK;
722    int ok = 1;
723    switch (config->action_type_) {
724      case ACTION_GET: {
725        ok = CreateMux(config->input_, &mux);
726        if (!ok) goto Err2;
727        switch (config->type_) {
728          case FEATURE_ANMF:
729            ok = GetFrame(mux, config);
730            break;
731          case FEATURE_ICCP:
732          case FEATURE_EXIF:
733          case FEATURE_XMP:
734            err = WebPMuxGetChunk(mux, kFourccList[config->type_], &chunk);
735            if (err != WEBP_MUX_OK) {
736              ERROR_GOTO3("ERROR (%s): Could not get the %s.\n",
737                          ErrorString(err), kDescriptions[config->type_], Err2);
738            }
739            ok = WriteData(config->output_, &chunk);
740            break;
741          default:
742            ERROR_GOTO1("ERROR: Invalid feature for action 'get'.\n", Err2);
743            break;
744        }
745        break;
746      }
747      case ACTION_SET: {
748        switch (config->type_) {
749          case FEATURE_ANMF: {
750            int i;
751            WebPMuxAnimParams params = { 0xFFFFFFFF, 0 };
752            mux = WebPMuxNew();
753            if (mux == NULL) {
754              ERROR_GOTO2("ERROR (%s): Could not allocate a mux object.\n",
755                          ErrorString(WEBP_MUX_MEMORY_ERROR), Err2);
756            }
757            for (i = 0; i < config->arg_count_; ++i) {
758              switch (config->args_[i].subtype_) {
759                case SUBTYPE_BGCOLOR: {
760                  uint32_t bgcolor;
761                  ok = ParseBgcolorArgs(config->args_[i].params_, &bgcolor);
762                  if (!ok) {
763                    ERROR_GOTO1("ERROR: Could not parse the background color \n",
764                                Err2);
765                  }
766                  params.bgcolor = bgcolor;
767                  break;
768                }
769                case SUBTYPE_LOOP: {
770                  int parse_error = 0;
771                  const int loop_count =
772                      ExUtilGetInt(config->args_[i].params_, 10, &parse_error);
773                  if (loop_count < 0 || loop_count > 65535) {
774                    ERROR_GOTO1("ERROR: Loop count must be in the range 0 to "
775                                "65535.\n", Err2);
776                  }
777                  ok = !parse_error;
778                  if (!ok) goto Err2;
779                  params.loop_count = loop_count;
780                  break;
781                }
782                case SUBTYPE_ANMF: {
783                  WebPMuxFrameInfo frame;
784                  frame.id = WEBP_CHUNK_ANMF;
785                  ok = ExUtilReadFileToWebPData(config->args_[i].filename_,
786                                                &frame.bitstream);
787                  if (!ok) goto Err2;
788                  ok = ParseFrameArgs(config->args_[i].params_, &frame);
789                  if (!ok) {
790                    WebPDataClear(&frame.bitstream);
791                    ERROR_GOTO1("ERROR: Could not parse frame properties.\n",
792                                Err2);
793                  }
794                  err = WebPMuxPushFrame(mux, &frame, 1);
795                  WebPDataClear(&frame.bitstream);
796                  if (err != WEBP_MUX_OK) {
797                    ERROR_GOTO3("ERROR (%s): Could not add a frame at index %d."
798                                "\n", ErrorString(err), i, Err2);
799                  }
800                  break;
801                }
802                default: {
803                  ERROR_GOTO1("ERROR: Invalid subtype for 'frame'", Err2);
804                  break;
805                }
806              }
807            }
808            err = WebPMuxSetAnimationParams(mux, &params);
809            if (err != WEBP_MUX_OK) {
810              ERROR_GOTO2("ERROR (%s): Could not set animation parameters.\n",
811                          ErrorString(err), Err2);
812            }
813            break;
814          }
815          case FEATURE_ICCP:
816          case FEATURE_EXIF:
817          case FEATURE_XMP: {
818            ok = CreateMux(config->input_, &mux);
819            if (!ok) goto Err2;
820            ok = ExUtilReadFileToWebPData(config->args_[0].filename_, &chunk);
821            if (!ok) goto Err2;
822            err = WebPMuxSetChunk(mux, kFourccList[config->type_], &chunk, 1);
823            free((void*)chunk.bytes);
824            if (err != WEBP_MUX_OK) {
825              ERROR_GOTO3("ERROR (%s): Could not set the %s.\n",
826                          ErrorString(err), kDescriptions[config->type_], Err2);
827            }
828            break;
829          }
830          default: {
831            ERROR_GOTO1("ERROR: Invalid feature for action 'set'.\n", Err2);
832            break;
833          }
834        }
835        ok = WriteWebP(mux, config->output_);
836        break;
837      }
838      case ACTION_DURATION: {
839        int num_frames;
840        ok = CreateMux(config->input_, &mux);
841        if (!ok) goto Err2;
842        err = WebPMuxNumChunks(mux, WEBP_CHUNK_ANMF, &num_frames);
843        ok = (err == WEBP_MUX_OK);
844        if (!ok) {
845          ERROR_GOTO1("ERROR: can not parse the number of frames.\n", Err2);
846        }
847        if (num_frames == 0) {
848          fprintf(stderr, "Doesn't look like the source is animated. "
849                          "Skipping duration setting.\n");
850          ok = WriteWebP(mux, config->output_);
851          if (!ok) goto Err2;
852        } else {
853          int i;
854          int* durations = NULL;
855          WebPMux* new_mux = DuplicateMuxHeader(mux);
856          if (new_mux == NULL) goto Err2;
857          durations = (int*)WebPMalloc((size_t)num_frames * sizeof(*durations));
858          if (durations == NULL) goto Err2;
859          for (i = 0; i < num_frames; ++i) durations[i] = -1;
860          for (i = 0; i < config->arg_count_; ++i) {
861            int k;
862            int args[3];
863            int duration, start, end;
864            const int nb_args = ExUtilGetInts(config->args_[i].params_,
865                                              10, 3, args);
866            ok = (nb_args >= 1);
867            if (!ok) goto Err3;
868            duration = args[0];
869            if (duration < 0) {
870              ERROR_GOTO1("ERROR: duration must be strictly positive.\n", Err3);
871            }
872            if (nb_args == 1) {   
873              start = 1;
874              end = num_frames;
875            } else {
876              start = args[1];
877              if (start <= 0) {
878                start = 1;
879              } else if (start > num_frames) {
880                start = num_frames;
881              }
882              end = (nb_args >= 3) ? args[2] : start;
883              if (end == 0 || end > num_frames) end = num_frames;
884            }
885            for (k = start; k <= end; ++k) {
886              assert(k >= 1 && k <= num_frames);
887              durations[k - 1] = duration;
888            }
889          }
890          for (i = 1; i <= num_frames; ++i) {
891            WebPMuxFrameInfo frame;
892            err = WebPMuxGetFrame(mux, i, &frame);
893            if (err != WEBP_MUX_OK || frame.id != WEBP_CHUNK_ANMF) {
894              ERROR_GOTO2("ERROR: can not retrieve frame #%d.\n", i, Err3);
895            }
896            if (durations[i - 1] >= 0) frame.duration = durations[i - 1];
897            err = WebPMuxPushFrame(new_mux, &frame, 1);
898            if (err != WEBP_MUX_OK) {
899              ERROR_GOTO2("ERROR: error push frame data #%d\n", i, Err3);
900            }
901            WebPDataClear(&frame.bitstream);
902          }
903          WebPMuxDelete(mux);
904          ok = WriteWebP(new_mux, config->output_);
905          mux = new_mux;  
906          new_mux = NULL;
907   Err3:
908          WebPFree(durations);
909          WebPMuxDelete(new_mux);
910          if (!ok) goto Err2;
911        }
912        break;
913      }
914      case ACTION_STRIP: {
915        ok = CreateMux(config->input_, &mux);
916        if (!ok) goto Err2;
917        if (config->type_ == FEATURE_ICCP || config->type_ == FEATURE_EXIF ||
918            config->type_ == FEATURE_XMP) {
919          err = WebPMuxDeleteChunk(mux, kFourccList[config->type_]);
920          if (err != WEBP_MUX_OK) {
921            ERROR_GOTO3("ERROR (%s): Could not strip the %s.\n",
922                        ErrorString(err), kDescriptions[config->type_], Err2);
923          }
924        } else {
925          ERROR_GOTO1("ERROR: Invalid feature for action 'strip'.\n", Err2);
926          break;
927        }
928        ok = WriteWebP(mux, config->output_);
929        break;
930      }
931      case ACTION_INFO: {
932        ok = CreateMux(config->input_, &mux);
933        if (!ok) goto Err2;
934        ok = (DisplayInfo(mux) == WEBP_MUX_OK);
935        break;
936      }
937      default: {
938        assert(0);  
939        break;
940      }
941    }
942   Err2:
943    WebPMuxDelete(mux);
944    return ok;
945  }
946  int main(int argc, const char* argv[]) {
947    Config config;
948    int ok;
949    INIT_WARGV(argc, argv);
950    ok = InitializeConfig(argc - 1, argv + 1, &config, GET_WARGV_OR_NULL());
951    if (ok) {
952      ok = Process(&config);
953    } else {
954      PrintHelp();
955    }
956    DeleteConfig(&config);
957    FREE_WARGV_AND_RETURN(!ok);
958  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-pngdec.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpmux.c</div>
                </div>
                <div class="column column_space"><pre><code>60    }
61    return raw_data;
62  }
63  static int ProcessRawProfile(const char* profile, size_t profile_len,
64                               MetadataPayload* const payload) {
65    const char* src = profile;
</pre></code></div>
                <div class="column column_space"><pre><code>311    if (fout != stdout) fclose(fout);
312    return ok;
313  }
314  static int WriteWebP(WebPMux* const mux, const char* filename) {
315    int ok;
316    WebPData webp_data;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    