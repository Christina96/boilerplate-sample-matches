
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.896551724137931%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-demux_24.h</h3>
            <pre><code>1  #ifndef WEBP_WEBP_DEMUX_H_
2  #define WEBP_WEBP_DEMUX_H_
3  #include "./decode.h"     
4  #include "./mux_types.h"
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  #define WEBP_DEMUX_ABI_VERSION 0x0107    
9  typedef struct WebPDemuxer WebPDemuxer;
10  typedef struct WebPIterator WebPIterator;
11  typedef struct WebPChunkIterator WebPChunkIterator;
12  typedef struct WebPAnimInfo WebPAnimInfo;
13  typedef struct WebPAnimDecoderOptions WebPAnimDecoderOptions;
14  WEBP_EXTERN int WebPGetDemuxVersion(void);
15  typedef enum WebPDemuxState {
16    WEBP_DEMUX_PARSE_ERROR    = -1,  
17    WEBP_DEMUX_PARSING_HEADER =  0,  
18    WEBP_DEMUX_PARSED_HEADER  =  1,  
19    WEBP_DEMUX_DONE           =  2   
20  } WebPDemuxState;
21  WEBP_EXTERN WebPDemuxer* WebPDemuxInternal(
22      const WebPData*, int, WebPDemuxState*, int);
23  static WEBP_INLINE WebPDemuxer* WebPDemux(const WebPData* data) {
24    return WebPDemuxInternal(data, 0, NULL, WEBP_DEMUX_ABI_VERSION);
25  }
26  static WEBP_INLINE WebPDemuxer* WebPDemuxPartial(
27      const WebPData* data, WebPDemuxState* state) {
28    return WebPDemuxInternal(data, 1, state, WEBP_DEMUX_ABI_VERSION);
29  }
30  WEBP_EXTERN void WebPDemuxDelete(WebPDemuxer* dmux);
31  typedef enum WebPFormatFeature {
32    WEBP_FF_FORMAT_FLAGS,      
33    WEBP_FF_CANVAS_WIDTH,
34    WEBP_FF_CANVAS_HEIGHT,
35    WEBP_FF_LOOP_COUNT,        
36    WEBP_FF_BACKGROUND_COLOR,  
37    WEBP_FF_FRAME_COUNT        
38  } WebPFormatFeature;
39  WEBP_EXTERN uint32_t WebPDemuxGetI(
40      const WebPDemuxer* dmux, WebPFormatFeature feature);
41  struct WebPIterator {
<span onclick='openModal()' class='match'>42    int frame_num;
43    int num_frames;          
44    int x_offset, y_offset;  
45    int width, height;       
46    int duration;            
47    WebPMuxAnimDispose dispose_method;  
48    int complete;   
49    WebPData fragment;  
50    int has_alpha;      
51    WebPMuxAnimBlend blend_method;  
52    uint32_t pad[2];         
53    void* private_;          
</span>54  };
55  WEBP_EXTERN int WebPDemuxGetFrame(
56      const WebPDemuxer* dmux, int frame_number, WebPIterator* iter);
57  WEBP_EXTERN int WebPDemuxNextFrame(WebPIterator* iter);
58  WEBP_EXTERN int WebPDemuxPrevFrame(WebPIterator* iter);
59  WEBP_EXTERN void WebPDemuxReleaseIterator(WebPIterator* iter);
60  struct WebPChunkIterator {
61    int chunk_num;
62    int num_chunks;
63    WebPData chunk;    
64    uint32_t pad[6];   
65    void* private_;
66  };
67  WEBP_EXTERN int WebPDemuxGetChunk(const WebPDemuxer* dmux,
68                                    const char fourcc[4], int chunk_number,
69                                    WebPChunkIterator* iter);
70  WEBP_EXTERN int WebPDemuxNextChunk(WebPChunkIterator* iter);
71  WEBP_EXTERN int WebPDemuxPrevChunk(WebPChunkIterator* iter);
72  WEBP_EXTERN void WebPDemuxReleaseChunkIterator(WebPChunkIterator* iter);
73  typedef struct WebPAnimDecoder WebPAnimDecoder;  
74  struct WebPAnimDecoderOptions {
75    WEBP_CSP_MODE color_mode;
76    int use_threads;           
77    uint32_t padding[7];       
78  };
79  WEBP_EXTERN int WebPAnimDecoderOptionsInitInternal(
80      WebPAnimDecoderOptions*, int);
81  static WEBP_INLINE int WebPAnimDecoderOptionsInit(
82      WebPAnimDecoderOptions* dec_options) {
83    return WebPAnimDecoderOptionsInitInternal(dec_options,
84                                              WEBP_DEMUX_ABI_VERSION);
85  }
86  WEBP_EXTERN WebPAnimDecoder* WebPAnimDecoderNewInternal(
87      const WebPData*, const WebPAnimDecoderOptions*, int);
88  static WEBP_INLINE WebPAnimDecoder* WebPAnimDecoderNew(
89      const WebPData* webp_data, const WebPAnimDecoderOptions* dec_options) {
90    return WebPAnimDecoderNewInternal(webp_data, dec_options,
91                                      WEBP_DEMUX_ABI_VERSION);
92  }
93  struct WebPAnimInfo {
94    uint32_t canvas_width;
95    uint32_t canvas_height;
96    uint32_t loop_count;
97    uint32_t bgcolor;
98    uint32_t frame_count;
99    uint32_t pad[4];   
100  };
101  WEBP_EXTERN int WebPAnimDecoderGetInfo(const WebPAnimDecoder* dec,
102                                         WebPAnimInfo* info);
103  WEBP_EXTERN int WebPAnimDecoderGetNext(WebPAnimDecoder* dec,
104                                         uint8_t** buf, int* timestamp);
105  WEBP_EXTERN int WebPAnimDecoderHasMoreFrames(const WebPAnimDecoder* dec);
106  WEBP_EXTERN void WebPAnimDecoderReset(WebPAnimDecoder* dec);
107  WEBP_EXTERN const WebPDemuxer* WebPAnimDecoderGetDemuxer(
108      const WebPAnimDecoder* dec);
109  WEBP_EXTERN void WebPAnimDecoderDelete(WebPAnimDecoder* dec);
110  #ifdef __cplusplus
111  }    
112  #endif
113  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2b.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BLAKE2B
3  enum blake2b_constant {
4     BLAKE2B_BLOCKBYTES = 128,
5     BLAKE2B_OUTBYTES = 64,
6     BLAKE2B_KEYBYTES = 64,
7     BLAKE2B_SALTBYTES = 16,
8     BLAKE2B_PERSONALBYTES = 16,
9     BLAKE2B_PARAM_SIZE = 64
10  };
11  enum {
<span onclick='openModal()' class='match'>12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 16,
20     O_INNER_LENGTH = 17,
21     O_RESERVED = 18,
22     O_SALT = 32,
23     O_PERSONAL = 48
</span>24  };
25  const struct ltc_hash_descriptor blake2b_160_desc =
26  {
27      "blake2b-160",
28      25,
29      20,
30      128,
31      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 5 },
32      11,
33      &blake2b_160_init,
34      &blake2b_process,
35      &blake2b_done,
36      &blake2b_160_test,
37      NULL
38  };
39  const struct ltc_hash_descriptor blake2b_256_desc =
40  {
41      "blake2b-256",
42      26,
43      32,
44      128,
45      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 8 },
46      11,
47      &blake2b_256_init,
48      &blake2b_process,
49      &blake2b_done,
50      &blake2b_256_test,
51      NULL
52  };
53  const struct ltc_hash_descriptor blake2b_384_desc =
54  {
55      "blake2b-384",
56      27,
57      48,
58      128,
59      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 12 },
60      11,
61      &blake2b_384_init,
62      &blake2b_process,
63      &blake2b_done,
64      &blake2b_384_test,
65      NULL
66  };
67  const struct ltc_hash_descriptor blake2b_512_desc =
68  {
69      "blake2b-512",
70      28,
71      64,
72      128,
73      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 16 },
74      11,
75      &blake2b_512_init,
76      &blake2b_process,
77      &blake2b_done,
78      &blake2b_512_test,
79      NULL
80  };
81  static const ulong64 blake2b_IV[8] =
82  {
83    CONST64(0x6a09e667f3bcc908), CONST64(0xbb67ae8584caa73b),
84    CONST64(0x3c6ef372fe94f82b), CONST64(0xa54ff53a5f1d36f1),
85    CONST64(0x510e527fade682d1), CONST64(0x9b05688c2b3e6c1f),
86    CONST64(0x1f83d9abfb41bd6b), CONST64(0x5be0cd19137e2179)
87  };
88  static const unsigned char blake2b_sigma[12][16] =
89  {
90    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
91    { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,
92    { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,
93    {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,
94    {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,
95    {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,
96    { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,
97    { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,
98    {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,
99    { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,
100    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
101    { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }
102  };
103  static void s_blake2b_set_lastnode(hash_state *md) { md->blake2b.f[1] = CONST64(0xffffffffffffffff); }
104  static int s_blake2b_is_lastblock(const hash_state *md) { return md->blake2b.f[0] != 0; }
105  static void s_blake2b_set_lastblock(hash_state *md)
106  {
107     if (md->blake2b.last_node) {
108        s_blake2b_set_lastnode(md);
109     }
110     md->blake2b.f[0] = CONST64(0xffffffffffffffff);
111  }
112  static void s_blake2b_increment_counter(hash_state *md, ulong64 inc)
113  {
114     md->blake2b.t[0] += inc;
115     if (md->blake2b.t[0] < inc) md->blake2b.t[1]++;
116  }
117  static void s_blake2b_init0(hash_state *md)
118  {
119     unsigned long i;
120     XMEMSET(&md->blake2b, 0, sizeof(md->blake2b));
121     for (i = 0; i < 8; ++i) {
122        md->blake2b.h[i] = blake2b_IV[i];
123     }
124  }
125  static int s_blake2b_init_param(hash_state *md, const unsigned char *P)
126  {
127     unsigned long i;
128     s_blake2b_init0(md);
129     for (i = 0; i < 8; ++i) {
130        ulong64 tmp;
131        LOAD64L(tmp, P + i * 8);
132        md->blake2b.h[i] ^= tmp;
133     }
134     md->blake2b.outlen = P[O_DIGEST_LENGTH];
135     return CRYPT_OK;
136  }
137  int blake2b_init(hash_state *md, unsigned long outlen, const unsigned char *key, unsigned long keylen)
138  {
139     unsigned char P[BLAKE2B_PARAM_SIZE];
140     int err;
141     LTC_ARGCHK(md != NULL);
142     if ((!outlen) || (outlen > BLAKE2B_OUTBYTES)) {
143        return CRYPT_INVALID_ARG;
144     }
145     if ((key && !keylen) || (keylen && !key) || (keylen > BLAKE2B_KEYBYTES)) {
146        return CRYPT_INVALID_ARG;
147     }
148     XMEMSET(P, 0, sizeof(P));
149     P[O_DIGEST_LENGTH] = (unsigned char)outlen;
150     P[O_KEY_LENGTH] = (unsigned char)keylen;
151     P[O_FANOUT] = 1;
152     P[O_DEPTH] = 1;
153     err = s_blake2b_init_param(md, P);
154     if (err != CRYPT_OK) return err;
155     if (key) {
156        unsigned char block[BLAKE2B_BLOCKBYTES];
157        XMEMSET(block, 0, BLAKE2B_BLOCKBYTES);
158        XMEMCPY(block, key, keylen);
159        blake2b_process(md, block, BLAKE2B_BLOCKBYTES);
160  #ifdef LTC_CLEAN_STACK
161        zeromem(block, sizeof(block));
162  #endif
163     }
164     return CRYPT_OK;
165  }
166  int blake2b_160_init(hash_state *md) { return blake2b_init(md, 20, NULL, 0); }
167  int blake2b_256_init(hash_state *md) { return blake2b_init(md, 32, NULL, 0); }
168  int blake2b_384_init(hash_state *md) { return blake2b_init(md, 48, NULL, 0); }
169  int blake2b_512_init(hash_state *md) { return blake2b_init(md, 64, NULL, 0); }
170  #define G(r, i, a, b, c, d)                                                                                            \
171     do {                                                                                                                \
172        a = a + b + m[blake2b_sigma[r][2 * i + 0]];                                                                      \
173        d = ROR64(d ^ a, 32);                                                                                            \
174        c = c + d;                                                                                                       \
175        b = ROR64(b ^ c, 24);                                                                                            \
176        a = a + b + m[blake2b_sigma[r][2 * i + 1]];                                                                      \
177        d = ROR64(d ^ a, 16);                                                                                            \
178        c = c + d;                                                                                                       \
179        b = ROR64(b ^ c, 63);                                                                                            \
180     } while (0)
181  #define ROUND(r)                                                                                                       \
182     do {                                                                                                                \
183        G(r, 0, v[0], v[4], v[8], v[12]);                                                                                \
184        G(r, 1, v[1], v[5], v[9], v[13]);                                                                                \
185        G(r, 2, v[2], v[6], v[10], v[14]);                                                                               \
186        G(r, 3, v[3], v[7], v[11], v[15]);                                                                               \
187        G(r, 4, v[0], v[5], v[10], v[15]);                                                                               \
188        G(r, 5, v[1], v[6], v[11], v[12]);                                                                               \
189        G(r, 6, v[2], v[7], v[8], v[13]);                                                                                \
190        G(r, 7, v[3], v[4], v[9], v[14]);                                                                                \
191     } while (0)
192  #ifdef LTC_CLEAN_STACK
193  static int ss_blake2b_compress(hash_state *md, const unsigned char *buf)
194  #else
195  static int s_blake2b_compress(hash_state *md, const unsigned char *buf)
196  #endif
197  {
198     ulong64 m[16];
199     ulong64 v[16];
200     unsigned long i;
201     for (i = 0; i < 16; ++i) {
202        LOAD64L(m[i], buf + i * sizeof(m[i]));
203     }
204     for (i = 0; i < 8; ++i) {
205        v[i] = md->blake2b.h[i];
206     }
207     v[8] = blake2b_IV[0];
208     v[9] = blake2b_IV[1];
209     v[10] = blake2b_IV[2];
210     v[11] = blake2b_IV[3];
211     v[12] = blake2b_IV[4] ^ md->blake2b.t[0];
212     v[13] = blake2b_IV[5] ^ md->blake2b.t[1];
213     v[14] = blake2b_IV[6] ^ md->blake2b.f[0];
214     v[15] = blake2b_IV[7] ^ md->blake2b.f[1];
215     ROUND(0);
216     ROUND(1);
217     ROUND(2);
218     ROUND(3);
219     ROUND(4);
220     ROUND(5);
221     ROUND(6);
222     ROUND(7);
223     ROUND(8);
224     ROUND(9);
225     ROUND(10);
226     ROUND(11);
227     for (i = 0; i < 8; ++i) {
228        md->blake2b.h[i] = md->blake2b.h[i] ^ v[i] ^ v[i + 8];
229     }
230     return CRYPT_OK;
231  }
232  #undef G
233  #undef ROUND
234  #ifdef LTC_CLEAN_STACK
235  static int s_blake2b_compress(hash_state *md, const unsigned char *buf)
236  {
237     int err;
238     err = ss_blake2b_compress(md, buf);
239     burn_stack(sizeof(ulong64) * 32 + sizeof(unsigned long));
240     return err;
241  }
242  #endif
243  int blake2b_process(hash_state *md, const unsigned char *in, unsigned long inlen)
244  {
245     LTC_ARGCHK(md != NULL);
246     LTC_ARGCHK(in != NULL);
247     if (md->blake2b.curlen > sizeof(md->blake2b.buf)) {
248        return CRYPT_INVALID_ARG;
249     }
250     if (inlen > 0) {
251        unsigned long left = md->blake2b.curlen;
252        unsigned long fill = BLAKE2B_BLOCKBYTES - left;
253        if (inlen > fill) {
254           md->blake2b.curlen = 0;
255           XMEMCPY(md->blake2b.buf + (left % sizeof(md->blake2b.buf)), in, fill); &bsol;* Fill buffer */
256           s_blake2b_increment_counter(md, BLAKE2B_BLOCKBYTES);
257           s_blake2b_compress(md, md->blake2b.buf); &bsol;* Compress */
258           in += fill;
259           inlen -= fill;
260           while (inlen > BLAKE2B_BLOCKBYTES) {
261              s_blake2b_increment_counter(md, BLAKE2B_BLOCKBYTES);
262              s_blake2b_compress(md, in);
263              in += BLAKE2B_BLOCKBYTES;
264              inlen -= BLAKE2B_BLOCKBYTES;
265           }
266        }
267        XMEMCPY(md->blake2b.buf + md->blake2b.curlen, in, inlen);
268        md->blake2b.curlen += inlen;
269     }
270     return CRYPT_OK;
271  }
272  int blake2b_done(hash_state *md, unsigned char *out)
273  {
274     unsigned char buffer[BLAKE2B_OUTBYTES] = { 0 };
275     unsigned long i;
276     LTC_ARGCHK(md != NULL);
277     LTC_ARGCHK(out != NULL);
278     if (s_blake2b_is_lastblock(md)) {
279        return CRYPT_ERROR;
280     }
281     s_blake2b_increment_counter(md, md->blake2b.curlen);
282     s_blake2b_set_lastblock(md);
283     XMEMSET(md->blake2b.buf + md->blake2b.curlen, 0, BLAKE2B_BLOCKBYTES - md->blake2b.curlen); &bsol;* Padding */
284     s_blake2b_compress(md, md->blake2b.buf);
285     for (i = 0; i < 8; ++i) { &bsol;* Output full hash to temp buffer */
286        STORE64L(md->blake2b.h[i], buffer + i * 8);
287     }
288     XMEMCPY(out, buffer, md->blake2b.outlen);
289     zeromem(md, sizeof(hash_state));
290  #ifdef LTC_CLEAN_STACK
291     zeromem(buffer, sizeof(buffer));
292  #endif
293     return CRYPT_OK;
294  }
295  int blake2b_512_test(void)
296  {
297  #ifndef LTC_TEST
298     return CRYPT_NOP;
299  #else
300     static const struct {
301        const char *msg;
302        unsigned char hash[64];
303    } tests[] = {
304      { "",
305        { 0x78, 0x6a, 0x02, 0xf7, 0x42, 0x01, 0x59, 0x03,
306          0xc6, 0xc6, 0xfd, 0x85, 0x25, 0x52, 0xd2, 0x72,
307          0x91, 0x2f, 0x47, 0x40, 0xe1, 0x58, 0x47, 0x61,
308          0x8a, 0x86, 0xe2, 0x17, 0xf7, 0x1f, 0x54, 0x19,
309          0xd2, 0x5e, 0x10, 0x31, 0xaf, 0xee, 0x58, 0x53,
310          0x13, 0x89, 0x64, 0x44, 0x93, 0x4e, 0xb0, 0x4b,
311          0x90, 0x3a, 0x68, 0x5b, 0x14, 0x48, 0xb7, 0x55,
312          0xd5, 0x6f, 0x70, 0x1a, 0xfe, 0x9b, 0xe2, 0xce } },
313      { "abc",
314        { 0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d,
315          0x6a, 0x27, 0x97, 0xb6, 0x9f, 0x12, 0xf6, 0xe9,
316          0x4c, 0x21, 0x2f, 0x14, 0x68, 0x5a, 0xc4, 0xb7,
317          0x4b, 0x12, 0xbb, 0x6f, 0xdb, 0xff, 0xa2, 0xd1,
318          0x7d, 0x87, 0xc5, 0x39, 0x2a, 0xab, 0x79, 0x2d,
319          0xc2, 0x52, 0xd5, 0xde, 0x45, 0x33, 0xcc, 0x95,
320          0x18, 0xd3, 0x8a, 0xa8, 0xdb, 0xf1, 0x92, 0x5a,
321          0xb9, 0x23, 0x86, 0xed, 0xd4, 0x00, 0x99, 0x23 } },
322      { NULL, { 0 } }
323    };
324     int i;
325     unsigned char tmp[64];
326     hash_state md;
327     for (i = 0; tests[i].msg != NULL; i++) {
328        blake2b_512_init(&md);
329        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
330        blake2b_done(&md, tmp);
331        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_512", i)) {
332           return CRYPT_FAIL_TESTVECTOR;
333        }
334     }
335     return CRYPT_OK;
336  #endif
337  }
338  int blake2b_384_test(void)
339  {
340  #ifndef LTC_TEST
341     return CRYPT_NOP;
342  #else
343     static const struct {
344        const char *msg;
345        unsigned char hash[48];
346    } tests[] = {
347      { "",
348        { 0xb3, 0x28, 0x11, 0x42, 0x33, 0x77, 0xf5, 0x2d,
349          0x78, 0x62, 0x28, 0x6e, 0xe1, 0xa7, 0x2e, 0xe5,
350          0x40, 0x52, 0x43, 0x80, 0xfd, 0xa1, 0x72, 0x4a,
351          0x6f, 0x25, 0xd7, 0x97, 0x8c, 0x6f, 0xd3, 0x24,
352          0x4a, 0x6c, 0xaf, 0x04, 0x98, 0x81, 0x26, 0x73,
353          0xc5, 0xe0, 0x5e, 0xf5, 0x83, 0x82, 0x51, 0x00 } },
354      { "abc",
355        { 0x6f, 0x56, 0xa8, 0x2c, 0x8e, 0x7e, 0xf5, 0x26,
356          0xdf, 0xe1, 0x82, 0xeb, 0x52, 0x12, 0xf7, 0xdb,
357          0x9d, 0xf1, 0x31, 0x7e, 0x57, 0x81, 0x5d, 0xbd,
358          0xa4, 0x60, 0x83, 0xfc, 0x30, 0xf5, 0x4e, 0xe6,
359          0xc6, 0x6b, 0xa8, 0x3b, 0xe6, 0x4b, 0x30, 0x2d,
360          0x7c, 0xba, 0x6c, 0xe1, 0x5b, 0xb5, 0x56, 0xf4 } },
361      { NULL, { 0 } }
362    };
363     int i;
364     unsigned char tmp[48];
365     hash_state md;
366     for (i = 0; tests[i].msg != NULL; i++) {
367        blake2b_384_init(&md);
368        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
369        blake2b_done(&md, tmp);
370        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_384", i)) {
371           return CRYPT_FAIL_TESTVECTOR;
372        }
373     }
374     return CRYPT_OK;
375  #endif
376  }
377  int blake2b_256_test(void)
378  {
379  #ifndef LTC_TEST
380     return CRYPT_NOP;
381  #else
382     static const struct {
383        const char *msg;
384        unsigned char hash[32];
385    } tests[] = {
386      { "",
387        { 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2,
388          0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1,
389          0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87,
390          0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8 } },
391      { "abc",
392        { 0xbd, 0xdd, 0x81, 0x3c, 0x63, 0x42, 0x39, 0x72,
393          0x31, 0x71, 0xef, 0x3f, 0xee, 0x98, 0x57, 0x9b,
394          0x94, 0x96, 0x4e, 0x3b, 0xb1, 0xcb, 0x3e, 0x42,
395          0x72, 0x62, 0xc8, 0xc0, 0x68, 0xd5, 0x23, 0x19 } },
396      { "12345678901234567890123456789012345678901234567890"
397        "12345678901234567890123456789012345678901234567890"
398        "12345678901234567890123456789012345678901234567890"
399        "12345678901234567890123456789012345678901234567890"
400        "12345678901234567890123456789012345678901234567890"
401        "12345678901234567890123456789012345678901234567890",
402        { 0x0f, 0x6e, 0x01, 0x8d, 0x38, 0xd6, 0x3f, 0x08,
403          0x4d, 0x58, 0xe3, 0x0c, 0x90, 0xfb, 0xa2, 0x41,
404          0x5f, 0xca, 0x17, 0xfa, 0x66, 0x26, 0x49, 0xf3,
405          0x8a, 0x30, 0x41, 0x7c, 0x57, 0xcd, 0xa8, 0x14 } },
406      { NULL, { 0 } }
407    };
408     int i;
409     unsigned char tmp[32];
410     hash_state md;
411     for (i = 0; tests[i].msg != NULL; i++) {
412        blake2b_256_init(&md);
413        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
414        blake2b_done(&md, tmp);
415        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_256", i)) {
416           return CRYPT_FAIL_TESTVECTOR;
417        }
418     }
419     return CRYPT_OK;
420  #endif
421  }
422  int blake2b_160_test(void)
423  {
424  #ifndef LTC_TEST
425     return CRYPT_NOP;
426  #else
427     static const struct {
428        const char *msg;
429        unsigned char hash[20];
430    } tests[] = {
431      { "",
432        { 0x33, 0x45, 0x52, 0x4a, 0xbf, 0x6b, 0xbe, 0x18,
433          0x09, 0x44, 0x92, 0x24, 0xb5, 0x97, 0x2c, 0x41,
434          0x79, 0x0b, 0x6c, 0xf2 } },
435      { "abc",
436        { 0x38, 0x42, 0x64, 0xf6, 0x76, 0xf3, 0x95, 0x36,
437          0x84, 0x05, 0x23, 0xf2, 0x84, 0x92, 0x1c, 0xdc,
438          0x68, 0xb6, 0x84, 0x6b } },
439      { NULL, { 0 } }
440    };
441     int i;
442     unsigned char tmp[20];
443     hash_state md;
444     for (i = 0; tests[i].msg != NULL; i++) {
445        blake2b_160_init(&md);
446        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
447        blake2b_done(&md, tmp);
448        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_160", i)) {
449           return CRYPT_FAIL_TESTVECTOR;
450        }
451     }
452     return CRYPT_OK;
453  #endif
454  }
455  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-demux_24.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2b.c</div>
                </div>
                <div class="column column_space"><pre><code>42    int frame_num;
43    int num_frames;          
44    int x_offset, y_offset;  
45    int width, height;       
46    int duration;            
47    WebPMuxAnimDispose dispose_method;  
48    int complete;   
49    WebPData fragment;  
50    int has_alpha;      
51    WebPMuxAnimBlend blend_method;  
52    uint32_t pad[2];         
53    void* private_;          
</pre></code></div>
                <div class="column column_space"><pre><code>12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 16,
20     O_INNER_LENGTH = 17,
21     O_RESERVED = 18,
22     O_SALT = 32,
23     O_PERSONAL = 48
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    