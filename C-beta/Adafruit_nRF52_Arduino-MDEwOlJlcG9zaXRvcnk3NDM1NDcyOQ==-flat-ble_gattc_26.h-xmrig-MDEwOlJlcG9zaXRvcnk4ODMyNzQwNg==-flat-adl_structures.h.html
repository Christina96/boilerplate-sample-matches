
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 34.12140575079872%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_gattc_26.h</h3>
            <pre><code>1  #ifndef BLE_GATTC_H__
2  #define BLE_GATTC_H__
3  #include <stdint.h>
4  #include "nrf.h"
5  #include "nrf_svc.h"
6  #include "nrf_error.h"
7  #include "ble_ranges.h"
8  #include "ble_types.h"
9  #include "ble_err.h"
10  #include "ble_gatt.h"
11  #ifdef __cplusplus
12  extern "C" {
13  #endif
14  enum BLE_GATTC_SVCS
15  {
16    SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = BLE_GATTC_SVC_BASE, &bsol;**< Primary Service Discovery. */
17    SD_BLE_GATTC_RELATIONSHIPS_DISCOVER,                         &bsol;**< Relationship Discovery. */
18    SD_BLE_GATTC_CHARACTERISTICS_DISCOVER,                       &bsol;**< Characteristic Discovery. */
19    SD_BLE_GATTC_DESCRIPTORS_DISCOVER,                           &bsol;**< Characteristic Descriptor Discovery. */
20    SD_BLE_GATTC_ATTR_INFO_DISCOVER,                             &bsol;**< Attribute Information Discovery. */
21    SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ,                        &bsol;**< Read Characteristic Value by UUID. */
22    SD_BLE_GATTC_READ,                                           &bsol;**< Generic read. */
23    SD_BLE_GATTC_CHAR_VALUES_READ,                               &bsol;**< Read multiple Characteristic Values. */
24    SD_BLE_GATTC_WRITE,                                          &bsol;**< Generic write. */
25    SD_BLE_GATTC_HV_CONFIRM,                                     &bsol;**< Handle Value Confirmation. */
26    SD_BLE_GATTC_EXCHANGE_MTU_REQUEST,                           &bsol;**< Exchange MTU Request. */
27  };
28  enum BLE_GATTC_EVTS
29  {
30    BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = BLE_GATTC_EVT_BASE,  &bsol;**< Primary Service Discovery Response event.          \n See @ref ble_gattc_evt_prim_srvc_disc_rsp_t.          */
31    BLE_GATTC_EVT_REL_DISC_RSP,                             &bsol;**< Relationship Discovery Response event.             \n See @ref ble_gattc_evt_rel_disc_rsp_t.                */
32    BLE_GATTC_EVT_CHAR_DISC_RSP,                            &bsol;**< Characteristic Discovery Response event.           \n See @ref ble_gattc_evt_char_disc_rsp_t.               */
33    BLE_GATTC_EVT_DESC_DISC_RSP,                            &bsol;**< Descriptor Discovery Response event.               \n See @ref ble_gattc_evt_desc_disc_rsp_t.               */
34    BLE_GATTC_EVT_ATTR_INFO_DISC_RSP,                       &bsol;**< Attribute Information Response event.              \n See @ref ble_gattc_evt_attr_info_disc_rsp_t. */
35    BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP,                &bsol;**< Read By UUID Response event.                       \n See @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t.   */
36    BLE_GATTC_EVT_READ_RSP,                                 &bsol;**< Read Response event.                               \n See @ref ble_gattc_evt_read_rsp_t.                    */
37    BLE_GATTC_EVT_CHAR_VALS_READ_RSP,                       &bsol;**< Read multiple Response event.                      \n See @ref ble_gattc_evt_char_vals_read_rsp_t.          */
38    BLE_GATTC_EVT_WRITE_RSP,                                &bsol;**< Write Response event.                              \n See @ref ble_gattc_evt_write_rsp_t.                   */
39    BLE_GATTC_EVT_HVX,                                      &bsol;**< Handle Value Notification or Indication event.     \n Confirm indication with @ref sd_ble_gattc_hv_confirm.  \n See @ref ble_gattc_evt_hvx_t. */
40    BLE_GATTC_EVT_EXCHANGE_MTU_RSP,                         &bsol;**< Exchange MTU Response event.                       \n See @ref ble_gattc_evt_exchange_mtu_rsp_t.            */
41    BLE_GATTC_EVT_TIMEOUT,                                  &bsol;**< Timeout event.                                     \n See @ref ble_gattc_evt_timeout_t.                     */
42    BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE                     &bsol;**< Write without Response transmission complete.      \n See @ref ble_gattc_evt_write_cmd_tx_complete_t.       */
43  };
44  #define BLE_ERROR_GATTC_PROC_NOT_PERMITTED    (NRF_GATTC_ERR_BASE + 0x000) &bsol;**< Procedure not Permitted. */
45  #define BLE_GATTC_ATTR_INFO_FORMAT_16BIT    1 &bsol;**< 16-bit Attribute Information Format. */
46  #define BLE_GATTC_ATTR_INFO_FORMAT_128BIT   2 &bsol;**< 128-bit Attribute Information Format. */
47  #define BLE_GATTC_WRITE_CMD_TX_QUEUE_SIZE_DEFAULT  1 &bsol;**< Default number of Write without Response that can be queued for transmission. */
48  typedef struct
49  {
50    uint8_t  write_cmd_tx_queue_size; &bsol;**< The guaranteed minimum number of Write without Response that can be queued for transmission.
51                                            The default value is @ref BLE_GATTC_WRITE_CMD_TX_QUEUE_SIZE_DEFAULT */
52  } ble_gattc_conn_cfg_t;
53  typedef struct
54  {
55    uint16_t          start_handle; &bsol;**< Start Handle. */
56    uint16_t          end_handle;   &bsol;**< End Handle. */
57  } ble_gattc_handle_range_t;
58  typedef struct
59  {
60    ble_uuid_t               uuid;          &bsol;**< Service UUID. */
61    ble_gattc_handle_range_t handle_range;  &bsol;**< Service Handle Range. */
62  } ble_gattc_service_t;
63  typedef struct
64  {
65    uint16_t            handle;           &bsol;**< Include Handle. */
66    ble_gattc_service_t included_srvc;    &bsol;**< Handle of the included service. */
67  } ble_gattc_include_t;
68  typedef struct
69  {
70    ble_uuid_t              uuid;                 &bsol;**< Characteristic UUID. */
71    ble_gatt_char_props_t   char_props;           &bsol;**< Characteristic Properties. */
72    uint8_t                 char_ext_props : 1;   &bsol;**< Extended properties present. */
73    uint16_t                handle_decl;          &bsol;**< Handle of the Characteristic Declaration. */
74    uint16_t                handle_value;         &bsol;**< Handle of the Characteristic Value. */
75  } ble_gattc_char_t;
76  typedef struct
77  {
78    uint16_t          handle;         &bsol;**< Descriptor Handle. */
79    ble_uuid_t        uuid;           &bsol;**< Descriptor UUID. */
80  } ble_gattc_desc_t;
81  typedef struct
82  {
83    uint8_t        write_op;             &bsol;**< Write Operation to be performed, see @ref BLE_GATT_WRITE_OPS. */
84    uint8_t        flags;                &bsol;**< Flags, see @ref BLE_GATT_EXEC_WRITE_FLAGS. */
85    uint16_t       handle;               &bsol;**< Handle to the attribute to be written. */
86    uint16_t       offset;               &bsol;**< Offset in bytes. @note For WRITE_CMD and WRITE_REQ, offset must be 0. */
87    uint16_t       len;                  &bsol;**< Length of data in bytes. */
88    uint8_t const *p_value;              &bsol;**< Pointer to the value data. */
89  } ble_gattc_write_params_t;
90  typedef struct
91  {
92    uint16_t       handle;               &bsol;**< Attribute handle. */
93    ble_uuid_t     uuid;                 &bsol;**< 16-bit Attribute UUID. */
94  } ble_gattc_attr_info16_t;
95  typedef struct
96  {
97    uint16_t       handle;               &bsol;**< Attribute handle. */
98    ble_uuid128_t  uuid;                 &bsol;**< 128-bit Attribute UUID. */
99  } ble_gattc_attr_info128_t;
100  typedef struct
101  {
102    uint16_t             count;           &bsol;**< Service count. */
103    ble_gattc_service_t services[1];      &bsol;**< Service data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
104                                               See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
105  } ble_gattc_evt_prim_srvc_disc_rsp_t;
106  typedef struct
107  {
108    uint16_t             count;           &bsol;**< Include count. */
109    ble_gattc_include_t includes[1];      &bsol;**< Include data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
110                                               See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
111  } ble_gattc_evt_rel_disc_rsp_t;
112  typedef struct
113  {
114    uint16_t            count;          &bsol;**< Characteristic count. */
115    ble_gattc_char_t    chars[1];       &bsol;**< Characteristic data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
116                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
117  } ble_gattc_evt_char_disc_rsp_t;
118  typedef struct
119  {
120    uint16_t            count;          &bsol;**< Descriptor count. */
121    ble_gattc_desc_t    descs[1];       &bsol;**< Descriptor data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
122                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
123  } ble_gattc_evt_desc_disc_rsp_t;
124  typedef struct
125  {
126    uint16_t                     count;            &bsol;**< Attribute count. */
127    uint8_t                      format;           &bsol;**< Attribute information format, see @ref BLE_GATTC_ATTR_INFO_FORMAT. */
128    union {
129      ble_gattc_attr_info16_t  attr_info16[1];     &bsol;**< Attribute information for 16-bit Attribute UUID.
130                                                        @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
131                                                        See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
132      ble_gattc_attr_info128_t attr_info128[1];    &bsol;**< Attribute information for 128-bit Attribute UUID.
133                                                        @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
134                                                        See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
135    } info;                                        &bsol;**< Attribute information union. */
136  } ble_gattc_evt_attr_info_disc_rsp_t;
137  typedef struct
138  {
139    uint16_t            handle;          &bsol;**< Attribute Handle. */
140    uint8_t            *p_value;         &bsol;**< Pointer to the Attribute Value, length is available in @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t::value_len. */
141  } ble_gattc_handle_value_t;
142  typedef struct
143  {
144    uint16_t                  count;            &bsol;**< Handle-Value Pair Count. */
145    uint16_t                  value_len;        &bsol;**< Length of the value in Handle-Value(s) list. */
146    uint8_t                   handle_value[1];  &bsol;**< Handle-Value(s) list. To iterate through the list use @ref sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter.
147                                                     @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
148                                                     See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
149  } ble_gattc_evt_char_val_by_uuid_read_rsp_t;
150  typedef struct
151  {
152    uint16_t            handle;         &bsol;**< Attribute Handle. */
153    uint16_t            offset;         &bsol;**< Offset of the attribute data. */
154    uint16_t            len;            &bsol;**< Attribute data length. */
155    uint8_t             data[1];        &bsol;**< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
156                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
157  } ble_gattc_evt_read_rsp_t;
158  typedef struct
159  {
160    uint16_t            len;            &bsol;**< Concatenated Attribute values length. */
161    uint8_t             values[1];      &bsol;**< Attribute values. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
162                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
163  } ble_gattc_evt_char_vals_read_rsp_t;
164  typedef struct
165  {
166    uint16_t            handle;           &bsol;**< Attribute Handle. */
167    uint8_t             write_op;         &bsol;**< Type of write operation, see @ref BLE_GATT_WRITE_OPS. */
168    uint16_t            offset;           &bsol;**< Data offset. */
169    uint16_t            len;              &bsol;**< Data length. */
170    uint8_t             data[1];          &bsol;**< Data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
171                                               See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
172  } ble_gattc_evt_write_rsp_t;
173  typedef struct
174  {
175    uint16_t            handle;         &bsol;**< Handle to which the HVx operation applies. */
176    uint8_t             type;           &bsol;**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
177    uint16_t            len;            &bsol;**< Attribute data length. */
178    uint8_t             data[1];        &bsol;**< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
179                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
180  } ble_gattc_evt_hvx_t;
181  typedef struct
182  {
183    uint16_t          server_rx_mtu;            &bsol;**< Server RX MTU size. */
184  } ble_gattc_evt_exchange_mtu_rsp_t;
185  typedef struct
186  {
187    uint8_t          src;                       &bsol;**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
188  } ble_gattc_evt_timeout_t;
189  typedef struct
190  {
191    uint8_t             count;            &bsol;**< Number of write without response transmissions completed. */
192  } ble_gattc_evt_write_cmd_tx_complete_t;
193  typedef struct
194  {
195    uint16_t            conn_handle;                &bsol;**< Connection Handle on which event occurred. */
196    uint16_t            gatt_status;                &bsol;**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
<span onclick='openModal()' class='match'>197    uint16_t            error_handle;               &bsol;**< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID. */
197    uint16_t            error_handle;               &bsol;**< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID. */
</span>198    union
199    {
200      ble_gattc_evt_prim_srvc_disc_rsp_t          prim_srvc_disc_rsp;         &bsol;**< Primary Service Discovery Response Event Parameters. */
201      ble_gattc_evt_rel_disc_rsp_t                rel_disc_rsp;               &bsol;**< Relationship Discovery Response Event Parameters. */
202      ble_gattc_evt_char_disc_rsp_t               char_disc_rsp;              &bsol;**< Characteristic Discovery Response Event Parameters. */
203      ble_gattc_evt_desc_disc_rsp_t               desc_disc_rsp;              &bsol;**< Descriptor Discovery Response Event Parameters. */
204      ble_gattc_evt_char_val_by_uuid_read_rsp_t   char_val_by_uuid_read_rsp;  &bsol;**< Characteristic Value Read by UUID Response Event Parameters. */
205      ble_gattc_evt_read_rsp_t                    read_rsp;                   &bsol;**< Read Response Event Parameters. */
206      ble_gattc_evt_char_vals_read_rsp_t          char_vals_read_rsp;         &bsol;**< Characteristic Values Read Response Event Parameters. */
207      ble_gattc_evt_write_rsp_t                   write_rsp;                  &bsol;**< Write Response Event Parameters. */
208      ble_gattc_evt_hvx_t                         hvx;                        &bsol;**< Handle Value Notification/Indication Event Parameters. */
209      ble_gattc_evt_exchange_mtu_rsp_t            exchange_mtu_rsp;           &bsol;**< Exchange MTU Response Event Parameters. */
210      ble_gattc_evt_timeout_t                     timeout;                    &bsol;**< Timeout Event Parameters. */
211      ble_gattc_evt_attr_info_disc_rsp_t          attr_info_disc_rsp;         &bsol;**< Attribute Information Discovery Event Parameters. */
212      ble_gattc_evt_write_cmd_tx_complete_t       write_cmd_tx_complete;      &bsol;**< Write without Response transmission complete Event Parameters. */
213    } params;                                                                 &bsol;**< Event Parameters. @note Only valid if @ref gatt_status == @ref BLE_GATT_STATUS_SUCCESS. */
214  } ble_gattc_evt_t;
215  SVCALL(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER, uint32_t, sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const *p_srvc_uuid));
216  SVCALL(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER, uint32_t, sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
217  SVCALL(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER, uint32_t, sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
218  SVCALL(SD_BLE_GATTC_DESCRIPTORS_DISCOVER, uint32_t, sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
219  SVCALL(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ, uint32_t, sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const *p_uuid, ble_gattc_handle_range_t const *p_handle_range));
220  SVCALL(SD_BLE_GATTC_READ, uint32_t, sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset));
221  SVCALL(SD_BLE_GATTC_CHAR_VALUES_READ, uint32_t, sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const *p_handles, uint16_t handle_count));
222  SVCALL(SD_BLE_GATTC_WRITE, uint32_t, sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const *p_write_params));
223  SVCALL(SD_BLE_GATTC_HV_CONFIRM, uint32_t, sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle));
224  SVCALL(SD_BLE_GATTC_ATTR_INFO_DISCOVER, uint32_t, sd_ble_gattc_attr_info_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * p_handle_range));
225  SVCALL(SD_BLE_GATTC_EXCHANGE_MTU_REQUEST, uint32_t, sd_ble_gattc_exchange_mtu_request(uint16_t conn_handle, uint16_t client_rx_mtu));
226  __STATIC_INLINE uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(ble_gattc_evt_t *p_gattc_evt, ble_gattc_handle_value_t *p_iter);
227  #ifndef SUPPRESS_INLINE_IMPLEMENTATION
228  __STATIC_INLINE uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(ble_gattc_evt_t *p_gattc_evt, ble_gattc_handle_value_t *p_iter)
229  {
230    uint32_t value_len = p_gattc_evt->params.char_val_by_uuid_read_rsp.value_len;
231    uint8_t *p_first = p_gattc_evt->params.char_val_by_uuid_read_rsp.handle_value;
232    uint8_t *p_next = p_iter->p_value ? p_iter->p_value + value_len : p_first;
233    if ((p_next - p_first) / (sizeof(uint16_t) + value_len) < p_gattc_evt->params.char_val_by_uuid_read_rsp.count)
234    {
235      p_iter->handle = (uint16_t)p_next[1] << 8 | p_next[0];
236      p_iter->p_value = p_next + sizeof(uint16_t);
237      return NRF_SUCCESS;
238    }
239    else
240    {
241      return NRF_ERROR_NOT_FOUND;
242    }
243  }
244  #endif &bsol;* SUPPRESS_INLINE_IMPLEMENTATION */
245  #ifdef __cplusplus
246  }
247  #endif
248  #endif &bsol;* BLE_GATTC_H__ */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-adl_structures.h</h3>
            <pre><code>1  #ifndef ADL_STRUCTURES_H_
2  #define ADL_STRUCTURES_H_
3  #include "adl_defines.h"
4  typedef struct AdapterInfo
5  {
6      int iSize;
7      int iAdapterIndex;
8      char strUDID[ADL_MAX_PATH];
9      int iBusNumber;
10      int iDeviceNumber;
11      int iFunctionNumber;
12      int iVendorID;
13      char strAdapterName[ADL_MAX_PATH];
14      char strDisplayName[ADL_MAX_PATH];
15      int iPresent;
16  #if defined (_WIN32) || defined (_WIN64)
17      int iExist;
18      char strDriverPath[ADL_MAX_PATH];
19      char strDriverPathExt[ADL_MAX_PATH];
20      char strPNPString[ADL_MAX_PATH];
21      int iOSDisplayIndex;
22  #endif &bsol;* (_WIN32) || (_WIN64) */
23  #if defined (LINUX)
24      int iXScreenNum;
25      int iDrvIndex;
26      char strXScreenConfigName[ADL_MAX_PATH];
27  #endif &bsol;* (LINUX) */
28  } AdapterInfo, *LPAdapterInfo;
29  #if defined (LINUX)
30  typedef struct XScreenInfo
31  {
32      int iXScreenNum;
33      char strXScreenConfigName[ADL_MAX_PATH];
34  } XScreenInfo, *LPXScreenInfo;
35  #endif &bsol;* (LINUX) */
36  typedef struct ADLMemoryInfo
37  {
38      long long iMemorySize;
39      char strMemoryType[ADL_MAX_PATH];
40      long long iMemoryBandwidth;
41  } ADLMemoryInfo, *LPADLMemoryInfo;
42  typedef struct ADLMemoryRequired
43  {
44      long long iMemoryReq;        
45      int iType;                    
46      int iDisplayFeatureValue;   
47  } ADLMemoryRequired, *LPADLMemoryRequired;
48  typedef struct ADLMemoryDisplayFeatures
49  {
50      int iDisplayIndex;            
51      int iDisplayFeatureValue;    
52  } ADLMemoryDisplayFeatures, *LPADLMemoryDisplayFeatures;
53  typedef struct ADLDDCInfo
54  {
55      int  ulSize;
56      int  ulSupportsDDC;
57      int  ulManufacturerID;
58      int  ulProductID;
59      char cDisplayName[ADL_MAX_DISPLAY_NAME];
60      int  ulMaxHResolution;
61      int  ulMaxVResolution;
62      int  ulMaxRefresh;
63      int  ulPTMCx;
64      int  ulPTMCy;
65      int  ulPTMRefreshRate;
66      int  ulDDCInfoFlag;
67  } ADLDDCInfo, *LPADLDDCInfo;
68  typedef struct ADLDDCInfo2
69  {
70      int  ulSize;
71      int  ulSupportsDDC;
72      int  ulManufacturerID;
73      int  ulProductID;
74      char cDisplayName[ADL_MAX_DISPLAY_NAME];
75      int  ulMaxHResolution;
76      int  ulMaxVResolution;
77      int  ulMaxRefresh;
78      int  ulPTMCx;
79      int  ulPTMCy;
80      int  ulPTMRefreshRate;
81      int  ulDDCInfoFlag;
82      int bPackedPixelSupported;
83      int iPanelPixelFormat;
84      int  ulSerialID;
85      int ulMinLuminanceData;
86      int ulAvgLuminanceData;
87      int ulMaxLuminanceData;
88      int iSupportedTransferFunction;
89      int iSupportedColorSpace;
90      int iNativeDisplayChromaticityRedX;
91      int iNativeDisplayChromaticityRedY;
92      int iNativeDisplayChromaticityGreenX;
93      int iNativeDisplayChromaticityGreenY;
94      int iNativeDisplayChromaticityBlueX;
95      int iNativeDisplayChromaticityBlueY;
96      int iNativeDisplayChromaticityWhitePointX;
97      int iNativeDisplayChromaticityWhitePointY;
98      int iDiffuseScreenReflectance;
99      int iSpecularScreenReflectance;
100      int iSupportedHDR;
101      int iFreesyncFlags;
102      int ulMinLuminanceNoDimmingData;
103      int ulMaxBacklightMaxLuminanceData;
104      int ulMinBacklightMaxLuminanceData;
105      int ulMaxBacklightMinLuminanceData;
106      int ulMinBacklightMinLuminanceData;
107      int iReserved[4];
108  } ADLDDCInfo2, *LPADLDDCInfo2;
109  typedef struct ADLGamma
110  {
111      float fRed;
112      float fGreen;
113      float fBlue;
114  } ADLGamma, *LPADLGamma;
115  typedef struct ADLCustomMode
116  {
117      int iFlags;
118      int iModeWidth;
119      int iModeHeight;
120      int iBaseModeWidth;
121      int iBaseModeHeight;
122      int iRefreshRate;
123  } ADLCustomMode, *LPADLCustomMode;
124  typedef struct ADLGetClocksOUT
125  {
126      long ulHighCoreClock;
127      long ulHighMemoryClock;
128      long ulHighVddc;
129      long ulCoreMin;
130      long ulCoreMax;
131      long ulMemoryMin;
132      long ulMemoryMax;
133      long ulActivityPercent;
134      long ulCurrentCoreClock;
135      long ulCurrentMemoryClock;
136      long ulReserved;
137  } ADLGetClocksOUT;
138  typedef struct ADLDisplayConfig
139  {
140    long ulSize;
141    long ulConnectorType;
142    long ulDeviceData;
143    long ulOverridedDeviceData;
144    long ulReserved;
145  } ADLDisplayConfig;
146  typedef struct ADLDisplayID
147  {
148      int iDisplayLogicalIndex;
149      int iDisplayPhysicalIndex;
150      int iDisplayLogicalAdapterIndex;
151      int iDisplayPhysicalAdapterIndex;
152  } ADLDisplayID, *LPADLDisplayID;
153  typedef struct ADLDisplayInfo
154  {
155      ADLDisplayID displayID;
156      int  iDisplayControllerIndex;
157      char strDisplayName[ADL_MAX_PATH];
158      char strDisplayManufacturerName[ADL_MAX_PATH];
159      int  iDisplayType;
160      int  iDisplayOutputType;
161      int  iDisplayConnector;
162      int  iDisplayInfoMask;
163      int  iDisplayInfoValue;
164  } ADLDisplayInfo, *LPADLDisplayInfo;
165  typedef struct ADLDisplayDPMSTInfo
166  {
167      ADLDisplayID displayID;
168      int    iTotalAvailableBandwidthInMpbs;
169      int    iAllocatedBandwidthInMbps;
170      char    strGlobalUniqueIdentifier[ADL_MAX_PATH];
171      int        radLinkCount;
172      int        iPhysicalConnectorID;
173      char    rad[ADL_MAX_RAD_LINK_COUNT];
174  } ADLDisplayDPMSTInfo, *LPADLDisplayDPMSTInfo;
175  typedef struct ADLDisplayMode
176  {
177     int  iPelsHeight;
178     int  iPelsWidth;
179     int  iBitsPerPel;
180     int  iDisplayFrequency;
181  } ADLDisplayMode;
182  typedef struct ADLDetailedTiming
183  {
184       int   iSize;
185       short sTimingFlags;
186       short sHTotal;
187       short sHDisplay;
188       short sHSyncStart;
189       short sHSyncWidth;
190       short sVTotal;
191       short sVDisplay;
192       short sVSyncStart;
193       short sVSyncWidth;
194       short sPixelClock;
195       short sHOverscanRight;
196       short sHOverscanLeft;
197       short sVOverscanBottom;
198       short sVOverscanTop;
199       short sOverscan8B;
200       short sOverscanGR;
201  } ADLDetailedTiming;
202  typedef struct ADLDisplayModeInfo
203  {
204    int  iTimingStandard;
205    int  iPossibleStandard;
206    int  iRefreshRate;
207    int  iPelsWidth;
208    int  iPelsHeight;
209    ADLDetailedTiming  sDetailedTiming;
210  } ADLDisplayModeInfo;
211  typedef struct ADLDisplayProperty
212  {
213    int iSize;
214    int iPropertyType;
215    int iExpansionMode;
216    int iSupport;
217    int iCurrent;
218    int iDefault;
219  } ADLDisplayProperty;
220  typedef struct ADLClockInfo
221  {
222      int iCoreClock;
223      int iMemoryClock;
224  } ADLClockInfo, *LPADLClockInfo;
225  typedef struct ADLI2C
226  {
<span onclick='openModal()' class='match'>227      int iSize;
228      int iLine;
229      int iAddress;
230      int iOffset;
231      int iAction;
232      int iSpeed;
233      int iDataSize;
234      char *pcData;
</span>235  } ADLI2C;
236  typedef struct ADLDisplayEDIDData
237  {
238    int iSize;
239    int iFlag;
240    int iEDIDSize;
241    int iBlockIndex;
242    char cEDIDData[ADL_MAX_EDIDDATA_SIZE];
243    int iReserved[4];
244  }ADLDisplayEDIDData;
245  typedef struct ADLControllerOverlayInput
246  {
247    int  iSize;
248    int  iOverlayAdjust;
249    int  iValue;
250    int  iReserved;
251  } ADLControllerOverlayInput;
252  typedef struct ADLAdjustmentinfo
253  {
254    int iDefault;
255    int iMin;
256    int iMax;
257    int iStep;
258  } ADLAdjustmentinfo;
259  typedef struct ADLControllerOverlayInfo
260  {
261    int                    iSize;
262    ADLAdjustmentinfo        sOverlayInfo;
263    int                    iReserved[3];
264  } ADLControllerOverlayInfo;
265  typedef struct ADLGLSyncModuleID
266  {
267      int        iModuleID;
268      int        iGlSyncGPUPort;
269      int        iFWBootSectorVersion;
270      int        iFWUserSectorVersion;
271  } ADLGLSyncModuleID , *LPADLGLSyncModuleID;
272  typedef struct ADLGLSyncPortCaps
273  {
274      int        iPortType;
275      int        iNumOfLEDs;
276  }ADLGLSyncPortCaps, *LPADLGLSyncPortCaps;
277  typedef struct ADLGLSyncGenlockConfig
278  {
279      int        iValidMask;
280      int        iSyncDelay;
281      int        iFramelockCntlVector;
282      int        iSignalSource;
283      int        iSampleRate;
284      int        iSyncField;
285      int        iTriggerEdge;
286      int        iScanRateCoeff;
287  }ADLGLSyncGenlockConfig, *LPADLGLSyncGenlockConfig;
288  typedef struct ADLGlSyncPortInfo
289  {
290      int        iPortType;
291      int        iNumOfLEDs;
292      int        iPortState;
293      int        iFrequency;
294      int        iSignalType;
295      int        iSignalSource;
296  } ADLGlSyncPortInfo, *LPADLGlSyncPortInfo;
297  typedef struct ADLGlSyncPortControl
298  {
299      int        iPortType;
300      int        iControlVector;
301      int        iSignalSource;
302  } ADLGlSyncPortControl;
303  typedef struct ADLGlSyncMode
304  {
305      int        iControlVector;
306      int        iStatusVector;
307      int        iGLSyncConnectorIndex;
308  } ADLGlSyncMode, *LPADLGlSyncMode;
309  typedef struct ADLGlSyncMode2
310  {
311      int        iControlVector;
312      int        iStatusVector;
313      int        iGLSyncConnectorIndex;
314      int        iDisplayIndex;
315  } ADLGlSyncMode2, *LPADLGlSyncMode2;
316  typedef struct  ADLInfoPacket
317  {
318      char hb0;
319      char hb1;
320      char hb2;
321      char sb[28];
322  }ADLInfoPacket;
323  typedef struct ADLAVIInfoPacket  
324  {
325     char bPB3_ITC;
326     char bPB5;
327  }ADLAVIInfoPacket;
328  typedef struct ADLODClockSetting
329  {
330      int iDefaultClock;
331      int iCurrentClock;
332      int iMaxClock;
333      int iMinClock;
334      int iRequestedClock;
335      int iStepClock;
336  } ADLODClockSetting;
337  typedef struct ADLAdapterODClockInfo
338  {
339      int iSize;
340      int iFlags;
341      ADLODClockSetting sMemoryClock;
342      ADLODClockSetting sEngineClock;
343  } ADLAdapterODClockInfo;
344  typedef struct ADLAdapterODClockConfig
345  {
346    int iSize;
347    int iFlags;
348    int iMemoryClock;
349    int iEngineClock;
350  } ADLAdapterODClockConfig;
351  typedef struct ADLPMActivity
352  {
353      int iSize;
354      int iEngineClock;
355      int iMemoryClock;
356      int iVddc;
357      int iActivityPercent;
358      int iCurrentPerformanceLevel;
359      int iCurrentBusSpeed;
360      int iCurrentBusLanes;
361      int iMaximumBusLanes;
362      int iReserved;
363  } ADLPMActivity;
364  typedef struct ADLThermalControllerInfo
365  {
366    int iSize;
367    int iThermalDomain;
368    int iDomainIndex;
369    int iFlags;
370  } ADLThermalControllerInfo;
371  typedef struct ADLTemperature
372  {
373    int iSize;
374    int iTemperature;
375  } ADLTemperature;
376  typedef struct ADLFanSpeedInfo
377  {
378    int iSize;
379    int iFlags;
380    int iMinPercent;
381    int iMaxPercent;
382    int iMinRPM;
383    int iMaxRPM;
384  } ADLFanSpeedInfo;
385  typedef struct ADLFanSpeedValue
386  {
387    int iSize;
388    int iSpeedType;
389    int iFanSpeed;
390    int iFlags;
391  } ADLFanSpeedValue;
392  typedef struct ADLODParameterRange
393  {
394    int iMin;
395    int iMax;
396    int iStep;
397  } ADLODParameterRange;
398  typedef struct ADLODParameters
399  {
400    int iSize;
401    int iNumberOfPerformanceLevels;
402    int iActivityReportingSupported;
403    int iDiscretePerformanceLevels;
404    int iReserved;
405    ADLODParameterRange sEngineClock;
406    ADLODParameterRange sMemoryClock;
407    ADLODParameterRange sVddc;
408  } ADLODParameters;
409  typedef struct ADLODPerformanceLevel
410  {
411    int iEngineClock;
412    int iMemoryClock;
413    int iVddc;
414  } ADLODPerformanceLevel;
415  typedef struct ADLODPerformanceLevels
416  {
417    int iSize;
418    int iReserved;
419    ADLODPerformanceLevel aLevels [1];
420  } ADLODPerformanceLevels;
421  typedef struct ADLCrossfireComb
422  {
423    int iNumLinkAdapter;
424    int iAdaptLink[3];
425  } ADLCrossfireComb;
426  typedef struct ADLCrossfireInfo
427  {
428    int iErrorCode;
429    int iState;
430    int iSupported;
431  } ADLCrossfireInfo;
432  typedef struct ADLBiosInfo
433  {
434      char strPartNumber[ADL_MAX_PATH];    
435      char strVersion[ADL_MAX_PATH];        
436      char strDate[ADL_MAX_PATH];        
437  } ADLBiosInfo, *LPADLBiosInfo;
438  typedef struct ADLAdapterLocation
439  {
440      int iBus;
441      int iDevice;
442      int iFunction;
443  } ADLAdapterLocation,ADLBdf;
444  typedef struct ADLVersionsInfo
445  {
446      char strDriverVer[ADL_MAX_PATH];
447      char strCatalystVersion[ADL_MAX_PATH];
448      char strCatalystWebLink[ADL_MAX_PATH];
449  } ADLVersionsInfo, *LPADLVersionsInfo;
450  typedef struct ADLVersionsInfoX2
451  {
452      char strDriverVer[ADL_MAX_PATH];
453      char strCatalystVersion[ADL_MAX_PATH];
454      char strCrimsonVersion[ADL_MAX_PATH];
455      char strCatalystWebLink[ADL_MAX_PATH];
456  } ADLVersionsInfoX2, *LPADLVersionsInfoX2;
457  typedef struct ADLMVPUCaps
458  {
459    int iSize;
460    int iAdapterCount;
461    int iPossibleMVPUMasters;
462    int iPossibleMVPUSlaves;
463    char cAdapterPath[ADL_DL_MAX_MVPU_ADAPTERS][ADL_DL_MAX_REGISTRY_PATH];
464  } ADLMVPUCaps;
465  typedef struct ADLMVPUStatus
466  {
467    int iSize;
468    int iActiveAdapterCount;
469    int iStatus;
470    ADLAdapterLocation aAdapterLocation[ADL_DL_MAX_MVPU_ADAPTERS];
471  } ADLMVPUStatus;
472  typedef struct ADLActivatableSource
473  {
474      int iAdapterIndex;
475      int iNumActivatableSources;
476      int iActivatableSourceMask;
477      int iActivatableSourceValue;
478  } ADLActivatableSource, *LPADLActivatableSource;
479  typedef struct ADLMode
480  {
481      int iAdapterIndex;
482      ADLDisplayID displayID;
483      int iXPos;
484      int iYPos;
485      int iXRes;
486      int iYRes;
487      int iColourDepth;
488      float fRefreshRate;
489      int iOrientation;
490      int iModeFlag;
491      int iModeMask;
492      int iModeValue;
493  } ADLMode, *LPADLMode;
494  typedef struct ADLDisplayTarget
495  {
496      ADLDisplayID displayID;
497      int iDisplayMapIndex;
498      int  iDisplayTargetMask;
499      int  iDisplayTargetValue;
500  } ADLDisplayTarget, *LPADLDisplayTarget;
501  typedef struct tagADLBezelTransientMode
502  {
503      int iAdapterIndex;
504      int iSLSMapIndex;
505      int iSLSModeIndex;
506      ADLMode displayMode;
507      int  iNumBezelOffset;
508      int  iFirstBezelOffsetArrayIndex;
509      int  iSLSBezelTransientModeMask;
510      int  iSLSBezelTransientModeValue;
511  } ADLBezelTransientMode, *LPADLBezelTransientMode;
512  typedef struct ADLAdapterDisplayCap
513  {
514      int iAdapterIndex;
515      int  iAdapterDisplayCapMask;
516      int  iAdapterDisplayCapValue;
517  } ADLAdapterDisplayCap, *LPADLAdapterDisplayCap;
518  typedef struct ADLDisplayMap
519  {
520      int iDisplayMapIndex;
521      ADLMode displayMode;
522      int iNumDisplayTarget;
523      int iFirstDisplayTargetArrayIndex;
524       int  iDisplayMapMask;
525      int  iDisplayMapValue;
526  } ADLDisplayMap, *LPADLDisplayMap;
527  typedef struct ADLPossibleMap
528  {
529      int iIndex;
530      int iAdapterIndex;
531      int iNumDisplayMap;
532      ADLDisplayMap* displayMap;
533      int iNumDisplayTarget;
534      ADLDisplayTarget* displayTarget;
535  } ADLPossibleMap, *LPADLPossibleMap;
536  typedef struct ADLPossibleMapping
537  {
538      int iDisplayIndex;                
539      int iDisplayControllerIndex;    
540      int iDisplayMannerSupported;    
541  } ADLPossibleMapping, *LPADLPossibleMapping;
542  typedef struct ADLPossibleMapResult
543  {
544      int iIndex;
545      int iPossibleMapResultMask;
546      int iPossibleMapResultValue;
547  } ADLPossibleMapResult, *LPADLPossibleMapResult;
548  typedef struct ADLSLSGrid
549  {
550      int iAdapterIndex;
551      int  iSLSGridIndex;
552      int  iSLSGridRow;
553      int  iSLSGridColumn;
554      int  iSLSGridMask;
555      int  iSLSGridValue;
556  } ADLSLSGrid, *LPADLSLSGrid;
557  typedef struct    ADLSLSMap
558  {
559      int iAdapterIndex;
560      int iSLSMapIndex;
561      ADLSLSGrid grid;
562      int  iSurfaceMapIndex;
563       int iOrientation;
564      int  iNumSLSTarget;
565      int  iFirstSLSTargetArrayIndex;
566      int  iNumNativeMode;
567      int  iFirstNativeModeArrayIndex;
568      int  iNumBezelMode;
569      int  iFirstBezelModeArrayIndex;
570      int  iNumBezelOffset;
571      int  iFirstBezelOffsetArrayIndex;
572      int  iSLSMapMask;
573      int  iSLSMapValue;
574  } ADLSLSMap, *LPADLSLSMap;
575  typedef struct ADLSLSOffset
576  {
577      int iAdapterIndex;
578      int iSLSMapIndex;
579      ADLDisplayID displayID;
580      int iBezelModeIndex;
581      int iBezelOffsetX;
582      int iBezelOffsetY;
583      int iDisplayWidth;
584      int iDisplayHeight;
585      int iBezelOffsetMask;
586      int  iBezelffsetValue;
587  } ADLSLSOffset, *LPADLSLSOffset;
588  typedef struct ADLSLSMode
589  {
590      int iAdapterIndex;
591      int iSLSMapIndex;
592      int iSLSModeIndex;
593      ADLMode displayMode;
594      int iSLSNativeModeMask;
595      int iSLSNativeModeValue;
596  } ADLSLSMode, *LPADLSLSMode;
597  typedef struct ADLPossibleSLSMap
598  {
599      int iSLSMapIndex;
600      int iNumSLSMap;
601      ADLSLSMap* lpSLSMap;
602      int iNumSLSTarget;
603      ADLDisplayTarget* lpDisplayTarget;
604  } ADLPossibleSLSMap, *LPADLPossibleSLSMap;
605  typedef struct ADLSLSTarget
606  {
607      int iAdapterIndex;
608      int iSLSMapIndex;
609      ADLDisplayTarget displayTarget;
610      int iSLSGridPositionX;
611      int iSLSGridPositionY;
612      ADLMode viewSize;
613      int iSLSTargetMask;
614      int iSLSTargetValue;
615  } ADLSLSTarget, *LPADLSLSTarget;
616  typedef struct ADLBezelOffsetSteppingSize
617  {
618      int iAdapterIndex;
619      int iSLSMapIndex;
620      int iBezelOffsetSteppingSizeX;
621      int iBezelOffsetSteppingSizeY;
622      int iBezelOffsetSteppingSizeMask;
623      int iBezelOffsetSteppingSizeValue;
624  } ADLBezelOffsetSteppingSize, *LPADLBezelOffsetSteppingSize;
625  typedef struct ADLSLSOverlappedMode
626  {
627      ADLMode SLSMode;
628      int iNumSLSTarget;
629      int iFirstTargetArrayIndex;
630  }ADLSLSTargetOverlap, *LPADLSLSTargetOverlap;
631  typedef struct ADLPXConfigCaps
632  {
633      int iAdapterIndex;
634      int  iPXConfigCapMask;
635      int  iPXConfigCapValue;
636  } ADLPXConfigCaps, *LPADLPXConfigCaps;
637  enum ADLPxType
638  {
639  	ADL_PX_NONE = 0,
640  	ADL_SWITCHABLE_AMDAMD = 1,
641  	ADL_HG_AMDAMD = 2,
642  	ADL_SWITCHABLE_AMDOTHER = 3,
643  	ADL_HG_AMDOTHER = 4,
644  };
645  typedef struct _ADLApplicationData
646  {
647      char strPathName[ADL_MAX_PATH];
648      char strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
649      char strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
650      char strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
651  }ADLApplicationData;
652  typedef struct _ADLApplicationDataX2
653  {
654      wchar_t strPathName[ADL_MAX_PATH];
655      wchar_t strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
656      wchar_t strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
657      wchar_t strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
658  }ADLApplicationDataX2;
659  typedef struct _ADLApplicationDataX3
660  {
661      wchar_t strPathName[ADL_MAX_PATH];
662      wchar_t strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
663      wchar_t strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
664      wchar_t strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
665      unsigned int iProcessId;
666  }ADLApplicationDataX3;
667  typedef struct _PropertyRecord
668  {
669      char strName [ADL_APP_PROFILE_PROPERTY_LENGTH];
670      ADLProfilePropertyType eType;
671      int iDataSize;
672      unsigned char uData[1];
673  }PropertyRecord;
674  typedef struct _ADLApplicationProfile
675  {
676      int iCount;
677      PropertyRecord record[1];
678  }ADLApplicationProfile;
679  typedef struct ADLPowerControlInfo
680  {
681  int iMinValue;
682  int iMaxValue;
683  int iStepValue;
684   } ADLPowerControlInfo;
685  typedef struct _ADLControllerMode
686  {
687      int iModifiers;
688      int iViewPositionCx;
689      int iViewPositionCy;
690      int iViewPanLockLeft;
691      int iViewPanLockRight;
692      int iViewPanLockTop;
693      int iViewPanLockBottom;
694      int iViewResolutionCx;
695      int iViewResolutionCy;
696  }ADLControllerMode;
697  typedef struct ADLDisplayIdentifier
698  {
699      long ulDisplayIndex;
700      long ulManufacturerId;
701      long ulProductId;
702      long ulSerialNo;
703  } ADLDisplayIdentifier;
704  typedef struct _ADLOD6ParameterRange
705  {
706      int     iMin;
707      int     iMax;
708      int     iStep;
709  } ADLOD6ParameterRange;
710  typedef struct _ADLOD6Capabilities
711  {
712      int     iCapabilities;
713      int     iSupportedStates;
714      int     iNumberOfPerformanceLevels;
715      ADLOD6ParameterRange     sEngineClockRange;
716      ADLOD6ParameterRange     sMemoryClockRange;
717      int     iExtValue;
718      int     iExtMask;
719  } ADLOD6Capabilities;
720  typedef struct _ADLOD6PerformanceLevel
721  {
722      int iEngineClock;
723      int iMemoryClock;
724  } ADLOD6PerformanceLevel;
725  typedef struct _ADLOD6StateInfo
726  {
727      int     iNumberOfPerformanceLevels;
728      int     iExtValue;
729      int     iExtMask;
730      ADLOD6PerformanceLevel aLevels [1];
731  } ADLOD6StateInfo;
732  typedef struct _ADLOD6CurrentStatus
733  {
734      int     iEngineClock;
735      int     iMemoryClock;
736      int     iActivityPercent;
737      int     iCurrentPerformanceLevel;
738      int     iCurrentBusSpeed;
739      int     iCurrentBusLanes;
740      int     iMaximumBusLanes;
741      int     iExtValue;
742      int     iExtMask;
743  } ADLOD6CurrentStatus;
744  typedef struct _ADLOD6ThermalControllerCaps
745  {
746      int     iCapabilities;
747      int     iFanMinPercent;
748      int     iFanMaxPercent;
749      int     iFanMinRPM;
750      int     iFanMaxRPM;
751      int     iExtValue;
752      int     iExtMask;
753  } ADLOD6ThermalControllerCaps;
754  typedef struct _ADLOD6FanSpeedInfo
755  {
756      int     iSpeedType;
757      int     iFanSpeedPercent;
758      int        iFanSpeedRPM;
759      int     iExtValue;
760      int     iExtMask;
761  } ADLOD6FanSpeedInfo;
762  typedef struct _ADLOD6FanSpeedValue
763  {
764      int     iSpeedType;
765      int     iFanSpeed;
766      int     iExtValue;
767      int     iExtMask;
768  } ADLOD6FanSpeedValue;
769  typedef struct _ADLOD6PowerControlInfo
770  {
771      int     iMinValue;
772      int     iMaxValue;
773      int     iStepValue;
774      int     iExtValue;
775      int     iExtMask;
776  } ADLOD6PowerControlInfo;
777  typedef struct _ADLOD6VoltageControlInfo
778  {
779      int     iMinValue;
780      int     iMaxValue;
781      int     iStepValue;
782      int     iExtValue;
783      int     iExtMask;
784  } ADLOD6VoltageControlInfo;
785  typedef struct _ADLECCData
786  {
787      int iSec;
788      int iDed;
789  } ADLECCData;
790  typedef void *ADL_CONTEXT_HANDLE;
791  typedef struct ADLDisplayModeX2
792  {
793     int  iWidth;
794     int  iHeight;
795     int  iScanType;
796     int  iRefreshRate;
797     int  iTimingStandard;
798  } ADLDisplayModeX2;
799  typedef struct _ADLOD6CapabilitiesEx
800  {
801      int iCapabilities;
802      int iSupportedStates;
803      ADLOD6ParameterRange sEngineClockPercent;
804      ADLOD6ParameterRange sMemoryClockPercent;
805      ADLOD6ParameterRange sPowerControlPercent;
806      int iExtValue;
807      int iExtMask;
808  } ADLOD6CapabilitiesEx;
809  typedef struct _ADLOD6StateEx
810  {
811      int iEngineClockPercent;
812      int iMemoryClockPercent;
813      int iPowerControlPercent;
814      int iExtValue;
815      int iExtMask;
816  } ADLOD6StateEx;
817  typedef struct _ADLOD6MaxClockAdjust
818  {
819      int iEngineClockMax;
820      int iMemoryClockMax;
821      int iExtValue;
822      int iExtMask;
823  } ADLOD6MaxClockAdjust;
824  typedef struct ADLConnectorInfo
825  {
826      int iConnectorIndex;
827      int iConnectorId;
828      int iSlotIndex;
829      int iType;
830      int iOffset;
831      int iLength;
832  } ADLConnectorInfo;
833  typedef struct ADLBracketSlotInfo
834  {
835      int iSlotIndex;
836      int iLength;
837      int iWidth;
838  } ADLBracketSlotInfo;
839  typedef struct ADLMSTRad
840  {
841      int iLinkNumber;
842      char rad[ADL_MAX_RAD_LINK_COUNT];
843  } ADLMSTRad;
844  typedef struct ADLDevicePort
845  {
846      int iConnectorIndex;
847      ADLMSTRad aMSTRad;
848  } ADLDevicePort;
849  typedef struct ADLSupportedConnections
850  {
851      int iSupportedConnections;
852      int iSupportedProperties[ADL_MAX_CONNECTION_TYPES];
853  } ADLSupportedConnections;
854  typedef struct ADLConnectionState
855  {
856      int iEmulationStatus;
857      int iEmulationMode;
858      int iDisplayIndex;
859  } ADLConnectionState;
860  typedef struct ADLConnectionProperties
861  {
862      int iValidProperties;
863      int iBitrate;
864      int iNumberOfLanes;
865      int iColorDepth;
866      int iStereo3DCaps;
867      int iOutputBandwidth;
868  } ADLConnectionProperties;
869  typedef struct ADLConnectionData
870  {
871      int iConnectionType;
872      ADLConnectionProperties aConnectionProperties;
873      int iNumberofPorts;
874      int iActiveConnections;
875      int iDataSize;
876      char EdidData[ADL_MAX_DISPLAY_EDID_DATA_SIZE];
877  } ADLConnectionData;
878  typedef struct ADLAdapterCapsX2
879  {
880      int iAdapterID;
881      int iNumControllers;
882      int iNumDisplays;
883      int iNumOverlays;
884      int iNumOfGLSyncConnectors;
885      int iCapsMask;
886      int iCapsValue;
887      int iNumConnectors;
888  }ADLAdapterCapsX2;
889  typedef enum _ADL_ERROR_RECORD_SEVERITY
890  {
891      ADL_GLOBALLY_UNCORRECTED  = 1,
892      ADL_LOCALLY_UNCORRECTED   = 2,
893      ADL_DEFFERRED             = 3,
894      ADL_CORRECTED             = 4
895  }ADL_ERROR_RECORD_SEVERITY;
896  typedef union _ADL_ECC_EDC_FLAG
897  {
898      struct
899      {
900          unsigned int isEccAccessing        : 1;
901          unsigned int reserved              : 31;
902      }bits;
903      unsigned int u32All;
904  }ADL_ECC_EDC_FLAG;
905  typedef struct ADLErrorRecord
906  {
907      ADL_ERROR_RECORD_SEVERITY Severity;
908      int  countValid;
909      unsigned int count;
910      int locationValid;
911      unsigned int CU; 
912      char StructureName[32]; 
913      char tiestamp[32];
914      unsigned int padding[3];
915  }ADLErrorRecord;
916  typedef enum _ADL_EDC_BLOCK_ID
917  {
918      ADL_EDC_BLOCK_ID_SQCIS = 1,
919      ADL_EDC_BLOCK_ID_SQCDS = 2,
920      ADL_EDC_BLOCK_ID_SGPR  = 3,
921      ADL_EDC_BLOCK_ID_VGPR  = 4,
922      ADL_EDC_BLOCK_ID_LDS   = 5,
923      ADL_EDC_BLOCK_ID_GDS   = 6,
924      ADL_EDC_BLOCK_ID_TCL1  = 7,
925      ADL_EDC_BLOCK_ID_TCL2  = 8
926  }ADL_EDC_BLOCK_ID;
927  typedef enum _ADL_ERROR_INJECTION_MODE
928  {
929      ADL_ERROR_INJECTION_MODE_SINGLE      = 1,
930      ADL_ERROR_INJECTION_MODE_MULTIPLE    = 2,
931      ADL_ERROR_INJECTION_MODE_ADDRESS     = 3
932  }ADL_ERROR_INJECTION_MODE;
933  typedef union _ADL_ERROR_PATTERN
934  {
935      struct
936      {
937          unsigned long  EccInjVector         :  16;
938          unsigned long  EccInjEn             :  9;
939          unsigned long  EccBeatEn            :  4;
940          unsigned long  EccChEn              :  4;
941          unsigned long  reserved             :  31;
942      } bits;
943      unsigned long long u64Value;
944  } ADL_ERROR_PATTERN;
945  typedef struct _ADL_ERROR_INJECTION_DATA
946  {
947      unsigned long long errorAddress;
948      ADL_ERROR_PATTERN errorPattern;
949  }ADL_ERROR_INJECTION_DATA;
950  typedef struct ADLErrorInjection
951  {
952      ADL_EDC_BLOCK_ID blockId;
953      ADL_ERROR_INJECTION_MODE errorInjectionMode;
954  }ADLErrorInjection;
955  typedef struct ADLErrorInjectionX2
956  {
957      ADL_EDC_BLOCK_ID blockId;
958      ADL_ERROR_INJECTION_MODE errorInjectionMode;
959      ADL_ERROR_INJECTION_DATA errorInjectionData;
960  }ADLErrorInjectionX2;
961  typedef struct ADLFreeSyncCap
962  {
963      int iCaps;
964      int iMinRefreshRateInMicroHz;
965      int iMaxRefreshRateInMicroHz;
966      int iReserved[5];
967  } ADLFreeSyncCap;
968  typedef struct _ADLDceSettings
969  {
970      DceSettingsType type;                       
971      union
972      {
973          struct
974          {
975              bool qualityDetectionEnabled;
976          } HdmiLq;
977          struct
978          {
979              DpLinkRate linkRate;                
980              unsigned int numberOfActiveLanes;   
981              unsigned int numberofTotalLanes;    
982              int relativePreEmphasis;            
983              int relativeVoltageSwing;           
984              int persistFlag;
985          } DpLink;
986          struct
987          {
988              bool linkProtectionEnabled;         
989          } Protection;
990      } Settings;
991      int iReserved[15];
992  } ADLDceSettings;
993  typedef struct ADLGraphicCoreInfo
994  {
995      int iGCGen;
996      union
997      {
998          int iNumCUs;
999          int iNumWGPs;
1000      };
1001      union
1002      {
1003          int iNumPEsPerCU;
1004          int iNumPEsPerWGP;
1005      };
1006      int iNumSIMDs;
1007      int iNumROPs;
1008      int iReserved[11];
1009  }ADLGraphicCoreInfo;
1010  typedef struct _ADLODNParameterRange
1011  {
1012      int     iMode;
1013      int     iMin;
1014      int     iMax;
1015      int     iStep;
1016      int     iDefault;
1017  } ADLODNParameterRange;
1018  typedef struct _ADLODNCapabilities
1019  {
1020      int     iMaximumNumberOfPerformanceLevels;
1021      ADLODNParameterRange     sEngineClockRange;
1022      ADLODNParameterRange     sMemoryClockRange;
1023      ADLODNParameterRange     svddcRange;
1024      ADLODNParameterRange     power;
1025      ADLODNParameterRange     powerTuneTemperature;
1026      ADLODNParameterRange     fanTemperature;
1027      ADLODNParameterRange     fanSpeed;
1028      ADLODNParameterRange     minimumPerformanceClock;
1029  } ADLODNCapabilities;
1030  typedef struct _ADLODNCapabilitiesX2
1031  {
1032      int     iMaximumNumberOfPerformanceLevels;
1033      int iFlags;
1034      ADLODNParameterRange     sEngineClockRange;
1035      ADLODNParameterRange     sMemoryClockRange;
1036      ADLODNParameterRange     svddcRange;
1037      ADLODNParameterRange     power;
1038      ADLODNParameterRange     powerTuneTemperature;
1039      ADLODNParameterRange     fanTemperature;
1040      ADLODNParameterRange     fanSpeed;
1041      ADLODNParameterRange     minimumPerformanceClock;
1042      ADLODNParameterRange throttleNotificaion;
1043      ADLODNParameterRange autoSystemClock;
1044  } ADLODNCapabilitiesX2;
1045  typedef struct ADLODNPerformanceLevel
1046  {
1047      int iClock;
1048      int iVddc;
1049      int iEnabled;
1050  } ADLODNPerformanceLevel;
1051  typedef struct ADLODNPerformanceLevels
1052  {
1053      int iSize;
1054      int iMode;
1055      int iNumberOfPerformanceLevels;
1056      ADLODNPerformanceLevel aLevels[1];
1057  } ADLODNPerformanceLevels;
1058  typedef struct ADLODNFanControl
1059  {
1060      int iMode;
1061      int iFanControlMode;
1062      int iCurrentFanSpeedMode;
1063      int iCurrentFanSpeed;
1064      int iTargetFanSpeed;
1065      int iTargetTemperature;
1066      int iMinPerformanceClock;
1067      int iMinFanLimit;
1068  } ADLODNFanControl;
1069  typedef struct ADLODNPowerLimitSetting
1070  {
1071      int iMode;
1072      int iTDPLimit;
1073      int iMaxOperatingTemperature;
1074  } ADLODNPowerLimitSetting;
1075  typedef struct ADLODNPerformanceStatus
1076  {
1077      int iCoreClock;
1078      int iMemoryClock;
1079      int iDCEFClock;
1080      int iGFXClock;
1081      int iUVDClock;
1082      int iVCEClock;
1083      int iGPUActivityPercent;
1084      int iCurrentCorePerformanceLevel;
1085      int iCurrentMemoryPerformanceLevel;
1086      int iCurrentDCEFPerformanceLevel;
1087      int iCurrentGFXPerformanceLevel;
1088      int iUVDPerformanceLevel;
1089      int iVCEPerformanceLevel;
1090      int iCurrentBusSpeed;
1091      int iCurrentBusLanes;
1092      int iMaximumBusLanes;
1093      int iVDDC;
1094      int iVDDCI;
1095  } ADLODNPerformanceStatus;
1096  typedef struct ADLODNPerformanceLevelX2
1097  {
1098      int iClock;
1099      int iVddc;
1100      int iEnabled;
1101      int iControl;
1102  } ADLODNPerformanceLevelX2;
1103  typedef struct ADLODNPerformanceLevelsX2
1104  {
1105      int iSize;
1106      int iMode;
1107      int iNumberOfPerformanceLevels;
1108      ADLODNPerformanceLevelX2 aLevels[1];
1109  } ADLODNPerformanceLevelsX2;
1110  typedef enum _ADLODNCurrentPowerType
1111  {
1112      ODN_GPU_TOTAL_POWER = 0,
1113      ODN_GPU_PPT_POWER,
1114      ODN_GPU_SOCKET_POWER,
1115      ODN_GPU_CHIP_POWER
1116  } ADLODNCurrentPowerType;
1117  typedef struct _ADLODNCurrentPowerParameters
1118  {
1119      int   size;
1120      ADLODNCurrentPowerType   powerType;
1121      int  currentPower;
1122  } ADLODNCurrentPowerParameters;
1123  typedef struct _ADLODNExtSingleInitSetting
1124  {
1125  	int mode;
1126  	int minValue;
1127  	int maxValue;
1128  	int step;
1129  	int defaultValue;
1130  } ADLODNExtSingleInitSetting;
1131  typedef struct _ADLOD8SingleInitSetting
1132  {
1133      int featureID;
1134      int minValue;
1135      int maxValue;
1136      int defaultValue;
1137  } ADLOD8SingleInitSetting;
1138  typedef struct _ADLOD8InitSetting
1139  {
1140      int count;
1141      int overdrive8Capabilities;
1142      ADLOD8SingleInitSetting  od8SettingTable[OD8_COUNT];
1143  } ADLOD8InitSetting;
1144  typedef struct _ADLOD8CurrentSetting
1145  {
1146      int count;
1147      int Od8SettingTable[OD8_COUNT];
1148  } ADLOD8CurrentSetting;
1149  typedef struct _ADLOD8SingleSetSetting
1150  {
1151      int value;
1152      int requested;      
1153      int reset;          
1154  } ADLOD8SingleSetSetting;
1155  typedef struct _ADLOD8SetSetting
1156  {
1157      int count;
1158      ADLOD8SingleSetSetting  od8SettingTable[OD8_COUNT];
1159  } ADLOD8SetSetting;
1160  typedef struct _ADLSingleSensorData
1161  {
1162      int supported;
1163      int  value;
1164  } ADLSingleSensorData;
1165  typedef struct _ADLPMLogDataOutput
1166  {
1167      int size;
1168      ADLSingleSensorData sensors[ADL_PMLOG_MAX_SENSORS];
1169  }ADLPMLogDataOutput;
1170  typedef struct ADLPPLogSettings
1171  {
1172      int BreakOnAssert;
1173      int BreakOnWarn;
1174      int LogEnabled;
1175      int LogFieldMask;
1176      int LogDestinations;
1177      int LogSeverityEnabled;
1178      int LogSourceMask;
1179      int PowerProfilingEnabled;
1180      int PowerProfilingTimeInterval;
1181  }ADLPPLogSettings;
1182  typedef struct _ADLFPSSettingsOutput
1183  {
1184      int ulSize;
1185      int bACFPSEnabled;
1186      int bDCFPSEnabled;
1187      int ulACFPSCurrent;
1188      int ulDCFPSCurrent;
1189      int ulACFPSMaximum;
1190      int ulACFPSMinimum;
1191      int ulDCFPSMaximum;
1192      int ulDCFPSMinimum;
1193  } ADLFPSSettingsOutput;
1194  typedef struct _ADLFPSSettingsInput
1195  {
1196      int ulSize;
1197      int bGlobalSettings;
1198      int ulACFPSCurrent;
1199      int ulDCFPSCurrent;
1200      int ulReserved[6];
1201  } ADLFPSSettingsInput;
1202  enum { ADL_PMLOG_MAX_SUPPORTED_SENSORS = 256 };
1203  typedef struct _ADLPMLogSupportInfo
1204  {
1205      unsigned short usSensors[ADL_PMLOG_MAX_SUPPORTED_SENSORS];
1206      int ulReserved[16];
1207  } ADLPMLogSupportInfo;
1208  typedef struct _ADLPMLogStartInput
1209  {
1210      unsigned short usSensors[ADL_PMLOG_MAX_SUPPORTED_SENSORS];
1211      unsigned long ulSampleRate;
1212      int ulReserved[15];
1213  } ADLPMLogStartInput;
1214  typedef struct _ADLPMLogData
1215  {
1216      unsigned int ulVersion;
1217      unsigned int ulActiveSampleRate;
1218      unsigned long long ulLastUpdated;
1219      unsigned int ulValues[ADL_PMLOG_MAX_SUPPORTED_SENSORS][2];
1220      unsigned int ulReserved[256];
1221  } ADLPMLogData;
1222  typedef struct _ADLPMLogStartOutput
1223  {
1224      union
1225      {
1226          void* pLoggingAddress;
1227          unsigned long long ptr_LoggingAddress;
1228      };
1229      int ulReserved[14];
1230  } ADLPMLogStartOutput;
1231  typedef struct _ADLRASGetErrorCountsInput
1232  {
1233      unsigned int                Reserved[16];
1234  } ADLRASGetErrorCountsInput;
1235  typedef struct _ADLRASGetErrorCountsOutput
1236  {
1237      unsigned int                CorrectedErrors;    
1238      unsigned int                UnCorrectedErrors;  
1239      unsigned int                Reserved[14];
1240  } ADLRASGetErrorCountsOutput;
1241  typedef struct _ADLRASGetErrorCounts
1242  {
1243      unsigned int                InputSize;
1244      ADLRASGetErrorCountsInput   Input;
1245      unsigned int                OutputSize;
1246      ADLRASGetErrorCountsOutput  Output;
1247  } ADLRASGetErrorCounts;
1248  typedef struct _ADLRASResetErrorCountsInput
1249  {
1250      unsigned int                Reserved[8];
1251  } ADLRASResetErrorCountsInput;
1252  typedef struct _ADLRASResetErrorCountsOutput
1253  {
1254      unsigned int                Reserved[8];
1255  } ADLRASResetErrorCountsOutput;
1256  typedef struct _ADLRASResetErrorCounts
1257  {
1258      unsigned int                    InputSize;
1259      ADLRASResetErrorCountsInput     Input;
1260      unsigned int                    OutputSize;
1261      ADLRASResetErrorCountsOutput    Output;
1262  } ADLRASResetErrorCounts;
1263  typedef struct _ADLRASErrorInjectonInput
1264  {
1265      unsigned long long Address;
1266      ADL_RAS_INJECTION_METHOD Value;
1267      ADL_RAS_BLOCK_ID BlockId;
1268      ADL_RAS_ERROR_TYPE InjectErrorType;
1269      ADL_MEM_SUB_BLOCK_ID SubBlockIndex;
1270      unsigned int padding[9];
1271  } ADLRASErrorInjectonInput;
1272  typedef struct _ADLRASErrorInjectionOutput
1273  {
1274      unsigned int ErrorInjectionStatus;
1275      unsigned int padding[15];
1276  } ADLRASErrorInjectionOutput;
1277  typedef struct _ADLRASErrorInjection
1278  {
1279      unsigned int                           InputSize;
1280      ADLRASErrorInjectonInput               Input;
1281      unsigned int                           OutputSize;
1282      ADLRASErrorInjectionOutput             Output;
1283  } ADLRASErrorInjection;
1284  typedef struct _ADLSGApplicationInfo
1285  {
1286      wchar_t strFileName[ADL_MAX_PATH];
1287      wchar_t strFilePath[ADL_MAX_PATH];
1288      wchar_t strVersion[ADL_MAX_PATH];
1289      long long int timeStamp;
1290      unsigned int iProfileExists;
1291      unsigned int iGPUAffinity;
1292      ADLBdf GPUBdf;
1293  } ADLSGApplicationInfo;
1294  enum { ADLPreFlipPostProcessingInfoInvalidLUTIndex = 0xFFFFFFFF };
1295  enum ADLPreFlipPostProcessingLUTAlgorithm
1296  {
1297      ADLPreFlipPostProcessingLUTAlgorithm_Default = 0,
1298      ADLPreFlipPostProcessingLUTAlgorithm_Full,
1299      ADLPreFlipPostProcessingLUTAlgorithm_Approximation
1300  };
1301  typedef struct _ADLPreFlipPostProcessingInfo
1302  {
1303      int ulSize;
1304      int bEnabled;
1305      int ulSelectedLUTIndex;
1306      int ulSelectedLUTAlgorithm;
1307      int ulReserved[12];
1308  } ADLPreFlipPostProcessingInfo;
1309  typedef struct _ADL_ERROR_REASON
1310  {
1311  	int boost; 
1312  	int delag; 
1313  	int chill; 
1314  }ADL_ERROR_REASON;
1315  typedef struct _ADL_DELAG_NOTFICATION_REASON
1316  {
1317  	int HotkeyChanged; 
1318  	int GlobalEnableChanged; 
1319  	int GlobalLimitFPSChanged; 
1320  }ADL_DELAG_NOTFICATION_REASON;
1321  typedef struct _ADL_DELAG_SETTINGS
1322  {
1323  	int Hotkey; 
1324  	int GlobalEnable; 
1325  	int GlobalLimitFPS; 
1326  	int GlobalLimitFPS_MinLimit; 
1327  	int GlobalLimitFPS_MaxLimit; 
1328  	int GlobalLimitFPS_Step; 
1329  }ADL_DELAG_SETTINGS;
1330  typedef struct _ADL_BOOST_NOTFICATION_REASON
1331  {
1332  	int HotkeyChanged; 
1333  	int GlobalEnableChanged; 
1334  	int GlobalMinResChanged; 
1335  }ADL_BOOST_NOTFICATION_REASON;
1336  typedef struct _ADL_BOOST_SETTINGS
1337  {
1338  	int Hotkey; 
1339  	int GlobalEnable; 
1340  	int GlobalMinRes; 
1341  	int GlobalMinRes_MinLimit; 
1342  	int GlobalMinRes_MaxLimit; 
1343  	int GlobalMinRes_Step; 
1344  }ADL_BOOST_SETTINGS;
1345  typedef struct _ADL_RIS_NOTFICATION_REASON
1346  {
1347  	unsigned int GlobalEnableChanged; 
1348  	unsigned int GlobalSharpeningDegreeChanged; 
1349  }ADL_RIS_NOTFICATION_REASON;
1350  typedef struct _ADL_RIS_SETTINGS
1351  {
1352  	int GlobalEnable; 
1353  	int GlobalSharpeningDegree; 
1354  	int GlobalSharpeningDegree_MinLimit; 
1355  	int GlobalSharpeningDegree_MaxLimit; 
1356  	int GlobalSharpeningDegree_Step; 
1357  }ADL_RIS_SETTINGS;
1358  typedef struct _ADL_CHILL_NOTFICATION_REASON
1359  {
1360  	int HotkeyChanged; 
1361  	int GlobalEnableChanged; 
1362  	int GlobalMinFPSChanged; 
1363  	int GlobalMaxFPSChanged; 
1364  }ADL_CHILL_NOTFICATION_REASON;
1365  typedef struct _ADL_CHILL_SETTINGS
1366  {
1367  	int Hotkey; 
1368  	int GlobalEnable; 
1369  	int GlobalMinFPS; 
1370  	int GlobalMaxFPS; 
1371  	int GlobalFPS_MinLimit; 
1372  	int GlobalFPS_MaxLimit; 
1373  	int GlobalFPS_Step; 
1374  }ADL_CHILL_SETTINGS;
1375  #endif &bsol;* ADL_STRUCTURES_H_ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_gattc_26.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-adl_structures.h</div>
                </div>
                <div class="column column_space"><pre><code>197    uint16_t            error_handle;               &bsol;**< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID. */
197    uint16_t            error_handle;               &bsol;**< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID. */
</pre></code></div>
                <div class="column column_space"><pre><code>227      int iSize;
228      int iLine;
229      int iAddress;
230      int iOffset;
231      int iAction;
232      int iSpeed;
233      int iDataSize;
234      char *pcData;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    