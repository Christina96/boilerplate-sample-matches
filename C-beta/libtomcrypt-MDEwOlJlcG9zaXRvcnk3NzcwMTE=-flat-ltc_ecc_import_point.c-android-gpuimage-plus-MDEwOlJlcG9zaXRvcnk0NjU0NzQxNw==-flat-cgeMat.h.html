
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.2242817423540315%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltc_ecc_import_point.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MECC
<span onclick='openModal()' class='match'>3  int ltc_ecc_import_point(const unsigned char *in, unsigned long inlen, void *prime, void *a, void *b, void *x, void *y)
4  {
5     int err;
6     unsigned long size;
7     void *t1, *t2;
</span>8     if (mp_init_multi(&t1, &t2, LTC_NULL) != CRYPT_OK) {
9        return CRYPT_MEM;
10     }
11     size = mp_unsigned_bin_size(prime);
12     if (in[0] == 0x04 && (inlen&1) && ((inlen-1)>>1) == size) {
13        if ((err = mp_read_unsigned_bin(x, (unsigned char *)in+1, size)) != CRYPT_OK)      { goto cleanup; }
14        if ((err = mp_read_unsigned_bin(y, (unsigned char *)in+1+size, size)) != CRYPT_OK) { goto cleanup; }
15     }
16     else if ((in[0] == 0x02 || in[0] == 0x03) && (inlen-1) == size && ltc_mp.sqrtmod_prime != NULL) {
17        if ((err = mp_read_unsigned_bin(x, (unsigned char *)in+1, size)) != CRYPT_OK)      { goto cleanup; }
18        if ((err = mp_sqr(x, t1)) != CRYPT_OK)                                             { goto cleanup; }
19        if ((err = mp_mulmod(t1, x, prime, t1)) != CRYPT_OK)                               { goto cleanup; }
20        if ((err = mp_mulmod(a, x, prime, t2)) != CRYPT_OK)                                { goto cleanup; }
21        if ((err = mp_add(t1, t2, t1)) != CRYPT_OK)                                        { goto cleanup; }
22        if ((err = mp_add(t1, b, t1)) != CRYPT_OK)                                         { goto cleanup; }
23        if ((err = mp_sqrtmod_prime(t1, prime, t2)) != CRYPT_OK)                           { goto cleanup; }
24        if ((mp_isodd(t2) && in[0] == 0x03) || (!mp_isodd(t2) && in[0] == 0x02)) {
25           if ((err = mp_mod(t2, prime, y)) != CRYPT_OK)                                   { goto cleanup; }
26        }
27        else {
28           if ((err = mp_submod(prime, t2, prime, y)) != CRYPT_OK)                         { goto cleanup; }
29        }
30     }
31     else {
32        err = CRYPT_INVALID_PACKET;
33        goto cleanup;
34     }
35     err = CRYPT_OK;
36  cleanup:
37     mp_clear_multi(t1, t2, LTC_NULL);
38     return err;
39  }
40  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeMat.h</h3>
            <pre><code><span onclick='openModal()' class='match'>1  &bsol;*
2  Author: wysaid
3  Blog: blog.wysaid.org
4  Data: 2013-10-31
5  Description: Provide some cpu math algorithms like glsl shaders.
6  @             Some algorithms are from http:&bsol;&bsol;www.opengl.org/
</span>7  @Attention: I'm using radian, not degree!
8  */
9  #ifndef _CGE_MAT_H_
10  #define _CGE_MAT_H_
11  #include "cgeStaticAssert.h"
12  #include "cgeVec.h"
13  #include <algorithm>
14  #include <cmath>
15  #ifndef M_PI
16  #define M_PI 3.141592653589793f
17  #endif
18  namespace CGE
19  {
20  inline void normalize(float& x, float& y, float& z)
21  {
22      const float scale = 1.0f / sqrtf(x * x + y * y + z * z);
23      x *= scale;
24      y *= scale;
25      z *= scale;
26  }
27  inline void normalize(float& x, float& y, float& z, float& w)
28  {
29      const float scale = 1.0f / sqrtf(x * x + y * y + z * z + w * w);
30      x *= scale;
31      y *= scale;
32      z *= scale;
33      w *= scale;
34  }
35  struct Mat2
36  {
37      const static Mat2& makeIdentity()
38      {
39          const static Mat2 sIdentity = Mat2(1.0f, 0.0f,
40                                             0.0f, 1.0f);
41          return sIdentity;
42      }
43      static inline Mat2& makeMatrix(Mat2& m, float m00, float m01,
44                                     float m10, float m11)
45      {
46          m[0][0] = m00;
47          m[0][1] = m01;
48          m[1][0] = m10;
49          m[1][1] = m11;
50          return m;
51      }
52      static inline Mat2 makeRotation(float rad)
53      {
54          const float cosRad = cosf(rad);
55          const float sinRad = sinf(rad);
56          return Mat2(cosRad, sinRad, -sinRad, cosRad);
57      }
58      Mat2() {}
59      Mat2(float m00, float m01, float m10, float m11)
60      {
61          makeMatrix(*this, m00, m01, m10, m11);
62      }
63      inline void rotate(float rad)
64      {
65          *this *= makeRotation(rad);
66      }
67      inline float* operator[](int index)
68      {
69          return data[index];
70      }
71      inline const float* operator[](int index) const
72      {
73          return data[index];
74      }
75      inline Vec2f operator*(const Vec2f& v) const
76      {
77          return Vec2f(data[0][0] * v[0] + data[1][0] * v[1],
78                       data[0][1] * v[0] + data[1][1] * v[1]);
79      }
80      inline Mat2 operator*(const Mat2& m) const
81      {
82          return Mat2(data[0][0] * m[0][0] + data[1][0] * m[0][1],
83                      data[0][1] * m[0][0] + data[1][1] * m[0][1],
84                      data[0][0] * m[1][0] + data[1][0] * m[1][1],
85                      data[0][1] * m[1][0] + data[1][1] * m[1][1]);
86      }
87      inline Mat2& operator*=(const Mat2& m)
88      {
89          return *this = *this * m;
90      }
91      inline void loadIdentity()
92      {
93          *this = makeIdentity();
94      }
95      float data[2][2];
96  };
97  struct Mat3
98  {
99      const static Mat3& makeIdentity()
100      {
101          const static Mat3 sIdentity = Mat3(1.0f, 0.0f, 0.0f,
102                                             0.0f, 1.0f, 0.0f,
103                                             0.0f, 0.0f, 1.0f);
104          return sIdentity;
105      }
106      static inline Mat3& makeMatrix(Mat3& m, float m00, float m01, float m02,
107                                     float m10, float m11, float m12,
108                                     float m20, float m21, float m22)
109      {
110          m[0][0] = m00;
111          m[0][1] = m01;
112          m[0][2] = m02;
113          m[1][0] = m10;
114          m[1][1] = m11;
115          m[1][2] = m12;
116          m[2][0] = m20;
117          m[2][1] = m21;
118          m[2][2] = m22;
119          return m;
120      }
121      static inline Mat3 makeRotation(float rad, float x, float y, float z)
122      {
123          normalize(x, y, z);
124          const float cosRad = cosf(rad);
125          const float cosp = 1.0f - cosRad;
126          const float sinRad = sinf(rad);
127          return Mat3(cosRad + cosp * x * x,
128                      cosp * x * y + z * sinRad,
129                      cosp * x * z - y * sinRad,
130                      cosp * x * y - z * sinRad,
131                      cosRad + cosp * y * y,
132                      cosp * y * z + x * sinRad,
133                      cosp * x * z + y * sinRad,
134                      cosp * y * z - x * sinRad,
135                      cosRad + cosp * z * z);
136      }
137      static inline Mat3 makeXRotation(float rad)
138      {
139          const float cosRad = cosf(rad);
140          const float sinRad = sinf(rad);
141          return Mat3(1.0f, 0.0f, 0.0f,
142                      0.0f, cosRad, sinRad,
143                      0.0f, -sinRad, cosRad);
144      }
145      static inline Mat3 makeYRotation(float rad)
146      {
147          const float cosRad = cosf(rad);
148          const float sinRad = sinf(rad);
149          return Mat3(cosRad, 0.0f, -sinRad,
150                      0.0f, 1.0f, 0.0f,
151                      sinRad, 0.0f, cosRad);
152      }
153      static inline Mat3 makeZRotation(float rad)
154      {
155          const float cosRad = cosf(rad);
156          const float sinRad = sinf(rad);
157          return Mat3(cosRad, sinRad, 0.0f,
158                      -sinRad, cosRad, 0.0f,
159                      0.0f, 0.0f, 1.0f);
160      }
161      Mat3() {}
162      Mat3(float m00, float m01, float m02,
163           float m10, float m11, float m12,
164           float m20, float m21, float m22)
165      {
166          makeMatrix(*this, m00, m01, m02,
167                     m10, m11, m12,
168                     m20, m21, m22);
169      }
170      inline float* operator[](int index)
171      {
172          return data[index];
173      }
174      inline const float* operator[](int index) const
175      {
176          return data[index];
177      }
178      inline Vec3f operator*(const Vec3f& v) const
179      {
180          return Vec3f(data[0][0] * v[0] + data[1][0] * v[1] + data[2][0] * v[2],
181                       data[0][1] * v[0] + data[1][1] * v[1] + data[2][1] * v[2],
182                       data[0][2] * v[0] + data[1][2] * v[1] + data[2][2] * v[2]);
183      }
184      inline Mat3 operator*(const Mat3& m) const
185      {
186          return Mat3(data[0][0] * m[0][0] + data[1][0] * m[0][1] + data[2][0] * m[0][2],
187                      data[0][1] * m[0][0] + data[1][1] * m[0][1] + data[2][1] * m[0][2],
188                      data[0][2] * m[0][0] + data[1][2] * m[0][1] + data[2][2] * m[0][2],
189                      data[0][0] * m[1][0] + data[1][0] * m[1][1] + data[2][0] * m[1][2],
190                      data[0][1] * m[1][0] + data[1][1] * m[1][1] + data[2][1] * m[1][2],
191                      data[0][2] * m[1][0] + data[1][2] * m[1][1] + data[2][2] * m[1][2],
192                      data[0][0] * m[2][0] + data[1][0] * m[2][1] + data[2][0] * m[2][2],
193                      data[0][1] * m[2][0] + data[1][1] * m[2][1] + data[2][1] * m[2][2],
194                      data[0][2] * m[2][0] + data[1][2] * m[2][1] + data[2][2] * m[2][2]);
195      }
196      inline Mat3& operator*=(const Mat3& m)
197      {
198          return *this = *this * m;
199      }
200      inline void rotate(float rad, float x, float y, float z)
201      {
202          *this *= makeRotation(rad, x, y, z);
203      }
204      inline void rotateX(float rad)
205      {
206          *this *= makeXRotation(rad); 
207      }
208      inline void rotateY(float rad)
209      {
210          *this *= makeYRotation(rad); 
211      }
212      inline void rotateZ(float rad)
213      {
214          *this *= makeZRotation(rad); 
215      }
216      inline void loadIdentity()
217      {
218          *this = makeIdentity();
219      }
220      float data[3][3];
221  };
222  struct Mat4
223  {
224      const static inline Mat4& makeIdentity()
225      {
226          const static Mat4 sIdentity = Mat4(1.0f, 0.0f, 0.0f, 0.0f,
227                                             0.0f, 1.0f, 0.0f, 0.0f,
228                                             0.0f, 0.0f, 1.0f, 0.0f,
229                                             0.0f, 0.0f, 0.0f, 1.0f);
230          return sIdentity;
231      }
232      static inline Mat4& makeMatrix(Mat4& m, float m00, float m01, float m02, float m03,
233                                     float m10, float m11, float m12, float m13,
234                                     float m20, float m21, float m22, float m23,
235                                     float m30, float m31, float m32, float m33)
236      {
237          m[0][0] = m00;
238          m[0][1] = m01;
239          m[0][2] = m02;
240          m[0][3] = m03;
241          m[1][0] = m10;
242          m[1][1] = m11;
243          m[1][2] = m12;
244          m[1][3] = m13;
245          m[2][0] = m20;
246          m[2][1] = m21;
247          m[2][2] = m22;
248          m[2][3] = m23;
249          m[3][0] = m30;
250          m[3][1] = m31;
251          m[3][2] = m32;
252          m[3][3] = m33;
253          return m;
254      }
255      static inline Mat4& makeMatrixTranspose(Mat4& m, float m00, float m01, float m02, float m03,
256                                              float m10, float m11, float m12, float m13,
257                                              float m20, float m21, float m22, float m23,
258                                              float m30, float m31, float m32, float m33)
259      {
260          m[0][0] = m00;
261          m[0][1] = m10;
262          m[0][2] = m20;
263          m[0][3] = m30;
264          m[1][0] = m01;
265          m[1][1] = m11;
266          m[1][2] = m21;
267          m[1][3] = m31;
268          m[2][0] = m02;
269          m[2][1] = m12;
270          m[2][2] = m22;
271          m[2][3] = m32;
272          m[3][0] = m03;
273          m[3][1] = m13;
274          m[3][2] = m23;
275          m[3][3] = m33;
276          return m;
277      }
278      static inline Mat4 makeMatrix(float m00, float m01, float m02, float m03,
279                                    float m10, float m11, float m12, float m13,
280                                    float m20, float m21, float m22, float m23,
281                                    float m30, float m31, float m32, float m33)
282      {
283          return Mat4(m00, m01, m02, m03,
284                      m10, m11, m12, m13,
285                      m20, m21, m22, m23,
286                      m30, m31, m32, m33);
287      }
288      static inline Mat4 makeMatrixTranspose(float m00, float m01, float m02, float m03,
289                                             float m10, float m11, float m12, float m13,
290                                             float m20, float m21, float m22, float m23,
291                                             float m30, float m31, float m32, float m33)
292      {
293          return Mat4(m00, m10, m20, m30,
294                      m01, m11, m21, m31,
295                      m02, m12, m22, m32,
296                      m03, m13, m23, m33);
297      }
298      static inline Mat4 makeTranslation(float x, float y, float z)
299      {
300          return Mat4(1.0f, 0.0f, 0.0f, 0.0f,
301                      0.0f, 1.0f, 0.0f, 0.0f,
302                      0.0f, 0.0f, 1.0f, 0.0f,
303                      x, y, z, 1.0f);
304      }
305      static inline Mat4 makeScale(float x, float y, float z)
306      {
307          return Mat4(x, 0.0f, 0.0f, 0.0f,
308                      0.0f, y, 0.0f, 0.0f,
309                      0.0f, 0.0f, z, 0.0f,
310                      0.0f, 0.0f, 0.0f, 1.0f);
311      }
312      static inline Mat4 makeRotation(float rad, float x, float y, float z)
313      {
314          normalize(x, y, z);
315          const float cosRad = cosf(rad);
316          const float cosp = 1.0f - cosRad;
317          const float sinRad = sinf(rad);
318          return Mat4(cosRad + cosp * x * x,
319                      cosp * x * y + z * sinRad,
320                      cosp * x * z - y * sinRad,
321                      0.0f,
322                      cosp * x * y - z * sinRad,
323                      cosRad + cosp * y * y,
324                      cosp * y * z + x * sinRad,
325                      0.0f,
326                      cosp * x * z + y * sinRad,
327                      cosp * y * z - x * sinRad,
328                      cosRad + cosp * z * z,
329                      0.0f,
330                      0.0f,
331                      0.0f,
332                      0.0f,
333                      1.0f);
334      }
335      static inline Mat4 makeXRotation(float rad)
336      {
337          const float cosRad = cosf(rad);
338          const float sinRad = sinf(rad);
339          return Mat4(1.0f, 0.0f, 0.0f, 0.0f,
340                      0.0f, cosRad, sinRad, 0.0f,
341                      0.0f, -sinRad, cosRad, 0.0f,
342                      0.0f, 0.0f, 0.0f, 1.0f);
343      }
344      static inline Mat4 makeYRotation(float rad)
345      {
346          const float cosRad = cosf(rad);
347          const float sinRad = sinf(rad);
348          return Mat4(cosRad, 0.0f, -sinRad, 0.0f,
349                      0.0f, 1.0f, 0.0f, 0.0f,
350                      sinRad, 0.0f, cosRad, 0.0f,
351                      0.0f, 0.0f, 0.0f, 1.0f);
352      }
353      static inline Mat4 makeZRotation(float rad)
354      {
355          const float cosRad = cosf(rad);
356          const float sinRad = sinf(rad);
357          return Mat4(cosRad, sinRad, 0.0f, 0.0f,
358                      -sinRad, cosRad, 0.0f, 0.0f,
359                      0.0f, 0.0f, 1.0f, 0.0f,
360                      0.0f, 0.0f, 0.0f, 1.0f);
361      }
362      static inline Mat4 makePerspective(float fovyRad, float aspect, float nearZ, float farZ)
363      {
364          const float cotan = 1.0f / tanf(fovyRad / 2.0f);
365          return Mat4(cotan / aspect, 0.0f, 0.0f, 0.0f,
366                      0.0f, cotan, 0.0f, 0.0f,
367                      0.0f, 0.0f, (farZ + nearZ) / (nearZ - farZ), -1.0f,
368                      0.0f, 0.0f, (2.0f * farZ * nearZ) / (nearZ - farZ), 0.0f);
369      }
370      static inline Mat4 makeFrustum(float left, float right, float bottom, float top, float nearZ, float farZ)
371      {
372          const float ral = right + left;
373          const float rsl = right - left;
374          const float tsb = top - bottom;
375          const float tab = top + bottom;
376          const float fan = farZ + nearZ;
377          const float fsn = farZ - nearZ;
378          return Mat4(2.0f * nearZ / rsl, 0.0f, 0.0f, 0.0f,
379                      0.0f, 2.0f * nearZ / tsb, 0.0f, 0.0f,
380                      ral / rsl, tab / tsb, -fan / fsn, -1.0f,
381                      0.0f, 0.0f, (-2.0f * farZ * nearZ) / fsn, 0.0f);
382      }
383      static inline Mat4 makeOrtho(float left, float right, float bottom, float top, float nearZ, float farZ)
384      {
385          const float ral = right + left;
386          const float rsl = right - left;
387          const float tsb = top - bottom;
388          const float tab = top + bottom;
389          const float fan = farZ + nearZ;
390          const float fsn = farZ - nearZ;
391          return Mat4(2.0f / rsl, 0.0f, 0.0f, 0.0f,
392                      0.0f, 2.0f / tsb, 0.0f, 0.0f,
393                      0.0f, 0.0f, -2.0f / fsn, 0.0f,
394                      -ral / rsl, -tab / tsb, -fan / fsn, 1.0f);
395      }
396      static inline Mat4 makeLookAt(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ)
397      {
398          Vec3f ev(eyeX, eyeY, eyeZ);
399          Vec3f cv(centerX, centerY, centerZ);
400          Vec3f uv(upX, upY, upZ);
401          return makeLookAt(ev, cv, uv);
402      }
403      static inline Mat4 makeLookAt(const Vec3f& eye, const Vec3f& center, const Vec3f& up)
404      {
405          Vec3f forward((eye - center).normalize());
406          Vec3f side(crossV3f(up, forward).normalize());
407          Vec3f upVector(crossV3f(forward, side));
408          return Mat4(side[0], upVector[0], forward[0], 0.0f,
409                      side[1], upVector[1], forward[1], 0.0f,
410                      side[2], upVector[2], forward[2], 0.0f,
411                      -side.dot(eye),
412                      -upVector.dot(eye),
413                      -forward.dot(eye),
414                      1.0f);
415      }
416      static inline Mat4 mat4Rotate(Mat4& m, float rad, float x, float y, float z)
417      {
418          return m * makeRotation(rad, x, y, z);
419      }
420      static inline Mat4 mat4RotateX(Mat4& m, float rad)
421      {
422          return m * makeXRotation(rad);
423      }
424      static inline Mat4 mat4RotateY(Mat4& m, float rad)
425      {
426          return m * makeYRotation(rad);
427      }
428      static inline Mat4 mat4RotateZ(Mat4& m, float rad)
429      {
430          return m * makeZRotation(rad);
431      }
432      static inline Vec3f mat4MulVec3WithTranslation(Mat4& m, Vec3f& v)
433      {
434          return Vec3f(
435              m[0][0] * v[0] + m[0][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3],
436              m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3],
437              m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3]);
438      }
439      static inline Vec3f mat4MulAndProjVec3(Mat4& m, Vec3f& v3)
440      {
441          Vec4f v4 = m * Vec4f(v3[0], v3[1], v3[2], 1.0f);
442          return Vec3f(v4[0], v4[1], v4[2]) / v4[3];
443      }
444      static inline bool projectM4fPerspective(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewPort, Vec3f& winCoord)
445      {
446          float fTempo[8];
447          fTempo[0] = modelView[0][0] * obj[0] + modelView[1][0] * obj[1] + modelView[2][0] * obj[2] + modelView[3][0]; 
448          fTempo[1] = modelView[0][1] * obj[0] + modelView[1][1] * obj[1] + modelView[2][1] * obj[2] + modelView[3][1];
449          fTempo[2] = modelView[0][2] * obj[0] + modelView[1][2] * obj[1] + modelView[2][2] * obj[2] + modelView[3][2];
450          fTempo[3] = modelView[0][3] * obj[0] + modelView[1][3] * obj[1] + modelView[2][3] * obj[2] + modelView[3][3];
451          fTempo[4] = proj[0][0] * fTempo[0] + proj[1][0] * fTempo[1] + proj[2][0] * fTempo[2] + proj[3][0] * fTempo[3];
452          fTempo[5] = proj[0][1] * fTempo[0] + proj[1][1] * fTempo[1] + proj[2][1] * fTempo[2] + proj[3][1] * fTempo[3];
453          fTempo[6] = proj[0][2] * fTempo[0] + proj[1][2] * fTempo[1] + proj[2][2] * fTempo[2] + proj[3][2] * fTempo[3];
454          fTempo[7] = -fTempo[2];
455          if (fTempo[7] == 0.0f) 
456              return false;
457          fTempo[7] = 1.0f / fTempo[7];
458          fTempo[4] *= fTempo[7];
459          fTempo[5] *= fTempo[7];
460          fTempo[6] *= fTempo[7];
461          winCoord[0] = (fTempo[4] * 0.5f + 0.5f) * viewPort[2] + viewPort[0];
462          winCoord[1] = (fTempo[5] * 0.5f + 0.5f) * viewPort[3] + viewPort[1];
463          winCoord[2] = (1.0f + fTempo[6]) * 0.5f; 
464          return true;
465      }
466      static inline bool projectM4fPerspective(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewPort, Vec2f& winCoord)
467      {
468          float fTempo[8];
469          fTempo[0] = modelView[0][0] * obj[0] + modelView[1][0] * obj[1] + modelView[2][0] * obj[2] + modelView[3][0]; 
470          fTempo[1] = modelView[0][1] * obj[0] + modelView[1][1] * obj[1] + modelView[2][1] * obj[2] + modelView[3][1];
471          fTempo[2] = modelView[0][2] * obj[0] + modelView[1][2] * obj[1] + modelView[2][2] * obj[2] + modelView[3][2];
472          fTempo[3] = modelView[0][3] * obj[0] + modelView[1][3] * obj[1] + modelView[2][3] * obj[2] + modelView[3][3];
473          fTempo[4] = proj[0][0] * fTempo[0] + proj[1][0] * fTempo[1] + proj[2][0] * fTempo[2] + proj[3][0] * fTempo[3];
474          fTempo[5] = proj[0][1] * fTempo[0] + proj[1][1] * fTempo[1] + proj[2][1] * fTempo[2] + proj[3][1] * fTempo[3];
475          fTempo[6] = proj[0][2] * fTempo[0] + proj[1][2] * fTempo[1] + proj[2][2] * fTempo[2] + proj[3][2] * fTempo[3];
476          fTempo[7] = -fTempo[2];
477          if (fTempo[7] == 0.0f) 
478              return false;
479          fTempo[7] = 1.0f / fTempo[7];
480          fTempo[4] *= fTempo[7];
481          fTempo[5] *= fTempo[7];
482          fTempo[6] *= fTempo[7];
483          winCoord[0] = (fTempo[4] * 0.5f + 0.5f) * viewPort[2] + viewPort[0];
484          winCoord[1] = (fTempo[5] * 0.5f + 0.5f) * viewPort[3] + viewPort[1];
485          return true;
486      }
487      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewport, Vec3f& winCoord)
488      {
489          Vec4f result = (modelView * Vec4f(obj[0], obj[1], obj[2], 1.0f)) * proj;
490          if (result[3] == 0.0f)
491              return false;
492          result[0] /= result[3];
493          result[1] /= result[3];
494          result[2] /= result[3];
495          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
496          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
497          winCoord[2] = (1.0f + result[2]) / 2.0f;
498          return true;
499      }
500      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewport, Vec2f& winCoord)
501      {
502          Vec4f result = (modelView * Vec4f(obj[0], obj[1], obj[2], 1.0f)) * proj;
503          if (result[3] == 0.0f)
504              return false;
505          result[0] /= result[3];
506          result[1] /= result[3];
507          result[2] /= result[3];
508          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
509          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
510          return true;
511      }
512      static inline bool projectM4f(const Vec2f& obj, const Mat4& modelView, const Mat4& proj, const Vec4f& viewport, Vec2f& winCoord)
513      {
514          Vec4f result = (modelView * Vec4f(obj[0], obj[1], 0.0f, 1.0f)) * proj;
515          if (result[3] == 0.0f)
516              return false;
517          result[0] /= result[3];
518          result[1] /= result[3];
519          result[2] /= result[3];
520          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
521          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
522          return true;
523      }
524      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelViewProjection, const Vec4f& viewport, Vec3f& winCoord)
525      {
526          Vec4f result = modelViewProjection * Vec4f(obj[0], obj[1], obj[2], 1.0f);
527          if (result[3] == 0.0f)
528              return false;
529          result[0] /= result[3];
530          result[1] /= result[3];
531          result[2] /= result[3];
532          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
533          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
534          winCoord[2] = (1.0f + result[2]) / 2.0f;
535          return true;
536      }
537      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelViewProjection, const Vec4f& viewport, Vec2f& winCoord)
538      {
539          Vec4f result = modelViewProjection * Vec4f(obj[0], obj[1], obj[2], 1.0f);
540          if (result[3] == 0.0f)
541              return false;
542          result[0] /= result[3];
543          result[1] /= result[3];
544          result[2] /= result[3];
545          winCoord[0] = viewport[0] + (1.0f + result[0]) * viewport[2] / 2.0f;
546          winCoord[1] = viewport[1] + (1.0f + result[1]) * viewport[3] / 2.0f;
547          return true;
548      }
549      static inline bool projectM4f(const Vec3f& obj, const Mat4& modelView, const Mat4& proj, Vec2f& winCoord, float width = 1.0f, float height = 1.0f)
550      {
551          Vec4f result = (modelView * Vec4f(obj[0], obj[1], obj[2], 1.0f)) * proj;
552          if (result[3] == 0.0f)
553              return false;
554          result[0] /= result[3];
555          result[1] /= result[3];
556          winCoord[0] = (1.0f + result[0]) * width / 2.0f;
557          winCoord[1] = (1.0f + result[1]) * height / 2.0f;
558          return true;
559      }
560      static inline bool projectM4f(const Vec3f& obj, const Mat4& mvp, Vec2f& winCoord, float width = 1.0f, float height = 1.0f)
561      {
562          Vec4f result = mvp * Vec4f(obj[0], obj[1], obj[2], 1.0f);
563          if (result[3] == 0.0f)
564              return false;
565          result[0] /= result[3];
566          result[1] /= result[3];
567          winCoord[0] = (1.0f + result[0]) * width / 2.0f;
568          winCoord[1] = (1.0f + result[1]) * height / 2.0f;
569          return true;
570      }
571      inline float* operator[](int index)
572      {
573          return data[index];
574      }
575      inline const float* operator[](int index) const
576      {
577          return data[index];
578      }
579      Mat4() {}
580      Mat4(float m00, float m01, float m02, float m03,
581           float m10, float m11, float m12, float m13,
582           float m20, float m21, float m22, float m23,
583           float m30, float m31, float m32, float m33)
584      {
585          makeMatrix(*this, m00, m01, m02, m03,
586                     m10, m11, m12, m13,
587                     m20, m21, m22, m23,
588                     m30, m31, m32, m33);
589      }
590      Mat4(float values[16])
591      {
592          makeMatrix(*this, values[0], values[1], values[2], values[3],
593                     values[4], values[5], values[6], values[7],
594                     values[8], values[9], values[10], values[11],
595                     values[12], values[13], values[14], values[15]);
596      }
597      Mat4(Vec4f row0, Vec4f row1, Vec4f row2, Vec4f row3)
598      {
599          makeMatrix(*this, row0[0], row0[1], row0[2], row0[3],
600                     row1[0], row1[1], row1[2], row1[3],
601                     row2[0], row2[1], row2[2], row2[3],
602                     row3[0], row3[1], row3[2], row3[3]);
603      }
604      Mat4(Mat3& m, float v)
605      {
606          makeMatrix(*this, m[0][0], m[0][1], m[0][2], v,
607                     m[1][0], m[1][1], m[1][2], v,
608                     m[2][0], m[2][1], m[2][2], v,
609                     v, v, v, v);
610      }
611      inline const Mat4& transPose()
612      {
613          return makeMatrix(*this, data[0][0], data[1][0], data[2][0], data[3][0],
614                            data[0][1], data[1][1], data[2][1], data[3][1],
615                            data[0][2], data[1][2], data[2][2], data[3][2],
616                            data[0][3], data[1][3], data[2][3], data[3][3]);
617      }
618      inline void loadIdentity()
619      {
620          *this = makeIdentity();
621      }
622      inline const Mat4& initWithQuaternion(float x, float y, float z, float w)
623      {
624          normalize(x, y, z, w);
625          const float _2x = x + x;
626          const float _2y = y + y;
627          const float _2z = z + z;
628          const float _2w = w + w;
629          makeMatrix(*this, 1.0f - _2y * y - _2z * z,
630                     _2x * y + _2w * z,
631                     _2x * z - _2w * y,
632                     0.0f,
633                     _2x * y - _2w * z,
634                     1.0f - _2x * x - _2z * z,
635                     _2y * z + _2w * x,
636                     0.0f,
637                     _2x * z + _2w * y,
638                     _2y * z - _2w * x,
639                     1.0f - _2x * x - _2y * y,
640                     0.0f,
641                     0.0f,
642                     0.0f,
643                     0.0f,
644                     1.0f);
645          return *this;
646      }
647      inline Mat3 getMat3()
648      {
649          return Mat3(data[0][0], data[0][1], data[0][2],
650                      data[1][0], data[1][1], data[1][2],
651                      data[2][0], data[2][1], data[2][2]);
652      }
653      inline Mat2 getMat2()
654      {
655          return Mat2(data[0][0], data[0][1],
656                      data[1][0], data[1][1]);
657      }
658      inline Mat4 operator*(const Mat4& m) const
659      {
660          return Mat4(data[0][0] * m[0][0] + data[1][0] * m[0][1] + data[2][0] * m[0][2] + data[3][0] * m[0][3],
661                      data[0][1] * m[0][0] + data[1][1] * m[0][1] + data[2][1] * m[0][2] + data[3][1] * m[0][3],
662                      data[0][2] * m[0][0] + data[1][2] * m[0][1] + data[2][2] * m[0][2] + data[3][2] * m[0][3],
663                      data[0][3] * m[0][0] + data[1][3] * m[0][1] + data[2][3] * m[0][2] + data[3][3] * m[0][3],
664                      data[0][0] * m[1][0] + data[1][0] * m[1][1] + data[2][0] * m[1][2] + data[3][0] * m[1][3],
665                      data[0][1] * m[1][0] + data[1][1] * m[1][1] + data[2][1] * m[1][2] + data[3][1] * m[1][3],
666                      data[0][2] * m[1][0] + data[1][2] * m[1][1] + data[2][2] * m[1][2] + data[3][2] * m[1][3],
667                      data[0][3] * m[1][0] + data[1][3] * m[1][1] + data[2][3] * m[1][2] + data[3][3] * m[1][3],
668                      data[0][0] * m[2][0] + data[1][0] * m[2][1] + data[2][0] * m[2][2] + data[3][0] * m[2][3],
669                      data[0][1] * m[2][0] + data[1][1] * m[2][1] + data[2][1] * m[2][2] + data[3][1] * m[2][3],
670                      data[0][2] * m[2][0] + data[1][2] * m[2][1] + data[2][2] * m[2][2] + data[3][2] * m[2][3],
671                      data[0][3] * m[2][0] + data[1][3] * m[2][1] + data[2][3] * m[2][2] + data[3][3] * m[2][3],
672                      data[0][0] * m[3][0] + data[1][0] * m[3][1] + data[2][0] * m[3][2] + data[3][0] * m[3][3],
673                      data[0][1] * m[3][0] + data[1][1] * m[3][1] + data[2][1] * m[3][2] + data[3][1] * m[3][3],
674                      data[0][2] * m[3][0] + data[1][2] * m[3][1] + data[2][2] * m[3][2] + data[3][2] * m[3][3],
675                      data[0][3] * m[3][0] + data[1][3] * m[3][1] + data[2][3] * m[3][2] + data[3][3] * m[3][3]);
676      }
677      inline Mat4 operator*(const Mat3& m) const
678      {
679          return Mat4(data[0][0] * m[0][0] + data[1][0] * m[0][1] + data[2][0] * m[0][2],
680                      data[0][1] * m[0][0] + data[1][1] * m[0][1] + data[2][1] * m[0][2],
681                      data[0][2] * m[0][0] + data[1][2] * m[0][1] + data[2][2] * m[0][2],
682                      data[0][3] * m[0][0] + data[1][3] * m[0][1] + data[2][3] * m[0][2],
683                      data[0][0] * m[1][0] + data[1][0] * m[1][1] + data[2][0] * m[1][2],
684                      data[0][1] * m[1][0] + data[1][1] * m[1][1] + data[2][1] * m[1][2],
685                      data[0][2] * m[1][0] + data[1][2] * m[1][1] + data[2][2] * m[1][2],
686                      data[0][3] * m[1][0] + data[1][3] * m[1][1] + data[2][3] * m[1][2],
687                      data[0][0] * m[2][0] + data[1][0] * m[2][1] + data[2][0] * m[2][2],
688                      data[0][1] * m[2][0] + data[1][1] * m[2][1] + data[2][1] * m[2][2],
689                      data[0][2] * m[2][0] + data[1][2] * m[2][1] + data[2][2] * m[2][2],
690                      data[0][3] * m[2][0] + data[1][3] * m[2][1] + data[2][3] * m[2][2],
691                      data[3][0],
692                      data[3][1],
693                      data[3][2],
694                      data[3][3]);
695      }
696      inline Mat4& operator*=(const Mat4& m)
697      {
698          *this = *this * m;
699          return *this;
700      }
701      inline Vec4f operator*(const Vec4f& v) const
702      {
703          return Vec4f(
704              data[0][0] * v[0] + data[1][0] * v[1] + data[2][0] * v[2] + data[3][0] * v[3],
705              data[0][1] * v[0] + data[1][1] * v[1] + data[2][1] * v[2] + data[3][1] * v[3],
706              data[0][2] * v[0] + data[1][2] * v[1] + data[2][2] * v[2] + data[3][2] * v[3],
707              data[0][3] * v[0] + data[1][3] * v[1] + data[2][3] * v[2] + data[3][3] * v[3]);
708      }
709      inline Vec3f operator*(const Vec3f& v) const
710      {
711          return Vec3f(data[0][0] * v[0] + data[1][0] * v[1] + data[2][0] * v[2],
712                       data[0][1] * v[0] + data[1][1] * v[1] + data[2][1] * v[2],
713                       data[0][2] * v[0] + data[1][2] * v[1] + data[2][2] * v[2]);
714      }
715      friend inline Vec4f operator*(const Vec4f& v, const Mat4& m)
716      {
717          return m * v;
718      }
719      friend inline Vec3f operator*(const Vec3f& v, const Mat4& m)
720      {
721          return m * v;
722      }
723      inline Mat4 operator+(const Mat4& m) const
724      {
725          return Mat4(data[0][0] + m[0][0],
726                      data[0][1] + m[0][1],
727                      data[0][2] + m[0][2],
728                      data[0][3] + m[0][3],
729                      data[1][0] + m[1][0],
730                      data[1][1] + m[1][1],
731                      data[1][2] + m[1][2],
732                      data[1][3] + m[1][3],
733                      data[2][0] + m[2][0],
734                      data[2][1] + m[2][1],
735                      data[2][2] + m[2][2],
736                      data[2][3] + m[2][3],
737                      data[3][0] + m[3][0],
738                      data[3][1] + m[3][1],
739                      data[3][2] + m[3][2],
740                      data[3][3] + m[3][3]);
741      }
742      inline Mat4& operator+=(const Mat4& m)
743      {
744          *this = *this + m;
745          return *this;
746      }
747      inline Mat4 operator-(const Mat4& m) const
748      {
749          return Mat4(data[0][0] - m[0][0],
750                      data[0][1] - m[0][1],
751                      data[0][2] - m[0][2],
752                      data[0][3] - m[0][3],
753                      data[1][0] - m[1][0],
754                      data[1][1] - m[1][1],
755                      data[1][2] - m[1][2],
756                      data[1][3] - m[1][3],
757                      data[2][0] - m[2][0],
758                      data[2][1] - m[2][1],
759                      data[2][2] - m[2][2],
760                      data[2][3] - m[2][3],
761                      data[3][0] - m[3][0],
762                      data[3][1] - m[3][1],
763                      data[3][2] - m[3][2],
764                      data[3][3] - m[3][3]);
765      }
766      inline Mat4& operator-=(const Mat4& m)
767      {
768          *this = *this - m;
769          return *this;
770      }
771      inline void translateX(float x)
772      {
773          data[3][0] += data[0][0] * x;
774          data[3][1] += data[0][1] * x;
775          data[3][2] += data[0][2] * x;
776      }
777      inline void translateY(float y)
778      {
779          data[3][0] += data[1][0] * y;
780          data[3][1] += data[1][1] * y;
781          data[3][2] += data[1][2] * y;
782      }
783      inline void translateZ(float z)
784      {
785          data[3][0] += data[2][0] * z;
786          data[3][1] += data[2][1] * z;
787          data[3][2] += data[2][2] * z;
788      }
789      inline void translate(float x, float y, float z)
790      {
791          data[3][0] += data[0][0] * x + data[1][0] * y + data[2][0] * z;
792          data[3][1] += data[0][1] * x + data[1][1] * y + data[2][1] * z;
793          data[3][2] += data[0][2] * x + data[1][2] * y + data[2][2] * z;
794      }
795      inline void scaleX(float x)
796      {
797          data[0][0] *= x;
798          data[0][1] *= x;
799          data[0][2] *= x;
800          data[0][3] *= x;
801      }
802      inline void scaleY(float y)
803      {
804          data[1][0] *= y;
805          data[1][1] *= y;
806          data[1][2] *= y;
807          data[1][3] *= y;
808      }
809      inline void scaleZ(float z)
810      {
811          data[2][0] *= z;
812          data[2][1] *= z;
813          data[2][2] *= z;
814          data[2][3] *= z;
815      }
816      inline void scale(float x, float y, float z)
817      {
818          scaleX(x);
819          scaleY(y);
820          scaleZ(z);
821      }
822      inline void rotate(float rad, float x, float y, float z)
823      {
824          *this *= makeRotation(rad, x, y, z);
825      }
826      inline void rotateX(float rad)
827      {
828          *this *= makeXRotation(rad);
829      }
830      inline void rotateY(float rad)
831      {
832          *this *= makeYRotation(rad);
833      }
834      inline void rotateZ(float rad)
835      {
836          *this *= makeZRotation(rad);
837      }
838      inline Mat3 toMat3()
839      {
840          return Mat3(data[0][0], data[0][1], data[0][2],
841                      data[1][0], data[1][1], data[1][2],
842                      data[2][0], data[2][1], data[2][2]);
843      }
844      float data[4][4];
845  };
846  } 
847  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltc_ecc_import_point.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeMat.h</div>
                </div>
                <div class="column column_space"><pre><code>3  int ltc_ecc_import_point(const unsigned char *in, unsigned long inlen, void *prime, void *a, void *b, void *x, void *y)
4  {
5     int err;
6     unsigned long size;
7     void *t1, *t2;
</pre></code></div>
                <div class="column column_space"><pre><code>1  &bsol;*
2  Author: wysaid
3  Blog: blog.wysaid.org
4  Data: 2013-10-31
5  Description: Provide some cpu math algorithms like glsl shaders.
6  @             Some algorithms are from http:&bsol;&bsol;www.opengl.org/
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    