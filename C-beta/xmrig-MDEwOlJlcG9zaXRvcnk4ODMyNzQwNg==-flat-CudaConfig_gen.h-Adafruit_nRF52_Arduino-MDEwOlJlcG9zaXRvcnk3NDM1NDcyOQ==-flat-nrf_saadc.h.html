
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.756302521008404%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CudaConfig_gen.h</h3>
            <pre><code>1  #ifndef XMRIG_CUDACONFIG_GEN_H
2  #define XMRIG_CUDACONFIG_GEN_H
3  #include "backend/common/Threads.h"
4  #include "backend/cuda/CudaThreads.h"
5  #include "backend/cuda/wrappers/CudaDevice.h"
6  #include <algorithm>
7  namespace xmrig {
8  static inline size_t generate(const char *key, Threads<CudaThreads> &threads, const Algorithm &algorithm, const std::vector<CudaDevice> &devices)
9  {
10      if (threads.isExist(algorithm) || threads.has(key)) {
11          return 0;
12      }
13      return threads.move(key, CudaThreads(devices, algorithm));
14  }
15  template<Algorithm::Family FAMILY>
16  static inline size_t generate(Threads<CudaThreads> &, const std::vector<CudaDevice> &) { return 0; }
17  template<>
18  size_t inline generate<Algorithm::CN>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
19  {
20      size_t count = 0;
21      count += generate(Algorithm::kCN, threads, Algorithm::CN_1, devices);
22      count += generate(Algorithm::kCN_2, threads, Algorithm::CN_2, devices);
23      if (!threads.isExist(Algorithm::CN_0)) {
24          threads.disable(Algorithm::CN_0);
25          count++;
26      }
27      return count;
28  }
29  #ifdef XMRIG_ALGO_CN_LITE
30  template<>
31  size_t inline generate<Algorithm::CN_LITE>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
32  {
33      size_t count = generate(Algorithm::kCN_LITE, threads, Algorithm::CN_LITE_1, devices);
34      if (!threads.isExist(Algorithm::CN_LITE_0)) {
35          threads.disable(Algorithm::CN_LITE_0);
36          ++count;
37      }
38      return count;
<span onclick='openModal()' class='match'>39  }
40  #endif
41  #ifdef XMRIG_ALGO_CN_HEAVY
42  template<>
43  size_t inline generate<Algorithm::CN_HEAVY>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
44  {
45      return generate(Algorithm::kCN_HEAVY, threads, Algorithm::CN_HEAVY_0, devices);
46  }
47  #endif
48  #ifdef XMRIG_ALGO_CN_PICO
49  template<>
50  size_t inline generate<Algorithm::CN_PICO>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
51  {
52      return generate(Algorithm::kCN_PICO, threads, Algorithm::CN_PICO_0, devices);
</span>53  }
54  #endif
55  #ifdef XMRIG_ALGO_CN_FEMTO
56  template<>
57  size_t inline generate<Algorithm::CN_FEMTO>(Threads<CudaThreads>& threads, const std::vector<CudaDevice>& devices)
58  {
59      return generate(Algorithm::kCN_UPX2, threads, Algorithm::CN_UPX2, devices);
60  }
61  #endif
62  #ifdef XMRIG_ALGO_RANDOMX
63  template<>
64  size_t inline generate<Algorithm::RANDOM_X>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
65  {
66      size_t count = 0;
67      auto rx  = CudaThreads(devices, Algorithm::RX_0);
68      auto wow = CudaThreads(devices, Algorithm::RX_WOW);
69      auto arq = CudaThreads(devices, Algorithm::RX_ARQ);
70      auto kva = CudaThreads(devices, Algorithm::RX_KEVA);
71      if (!threads.isExist(Algorithm::RX_WOW) && wow != rx) {
72          count += threads.move(Algorithm::kRX_WOW, std::move(wow));
73      }
74      if (!threads.isExist(Algorithm::RX_ARQ) && arq != rx) {
75          count += threads.move(Algorithm::kRX_ARQ, std::move(arq));
76      }
77      if (!threads.isExist(Algorithm::RX_KEVA) && kva != rx) {
78          count += threads.move(Algorithm::kRX_KEVA, std::move(kva));
79      }
80      count += threads.move(Algorithm::kRX, std::move(rx));
81      return count;
82  }
83  #endif
84  #ifdef XMRIG_ALGO_KAWPOW
85  template<>
86  size_t inline generate<Algorithm::KAWPOW>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
87  {
88      return generate(Algorithm::kKAWPOW, threads, Algorithm::KAWPOW_RVN, devices);
89  }
90  #endif
91  } &bsol;* namespace xmrig */
92  #endif &bsol;* XMRIG_CUDACONFIG_GEN_H */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_saadc.h</h3>
            <pre><code>1  #ifndef NRF_SAADC_H_
2  #define NRF_SAADC_H_
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_SAADC_RESOLUTION_8BIT  = SAADC_RESOLUTION_VAL_8bit,  
10      NRF_SAADC_RESOLUTION_10BIT = SAADC_RESOLUTION_VAL_10bit, 
11      NRF_SAADC_RESOLUTION_12BIT = SAADC_RESOLUTION_VAL_12bit, 
12      NRF_SAADC_RESOLUTION_14BIT = SAADC_RESOLUTION_VAL_14bit  
13  } nrf_saadc_resolution_t;
14  typedef enum
15  {
16      NRF_SAADC_INPUT_DISABLED = SAADC_CH_PSELP_PSELP_NC,           
17      NRF_SAADC_INPUT_AIN0     = SAADC_CH_PSELP_PSELP_AnalogInput0, 
18      NRF_SAADC_INPUT_AIN1     = SAADC_CH_PSELP_PSELP_AnalogInput1, 
19      NRF_SAADC_INPUT_AIN2     = SAADC_CH_PSELP_PSELP_AnalogInput2, 
20      NRF_SAADC_INPUT_AIN3     = SAADC_CH_PSELP_PSELP_AnalogInput3, 
21      NRF_SAADC_INPUT_AIN4     = SAADC_CH_PSELP_PSELP_AnalogInput4, 
22      NRF_SAADC_INPUT_AIN5     = SAADC_CH_PSELP_PSELP_AnalogInput5, 
23      NRF_SAADC_INPUT_AIN6     = SAADC_CH_PSELP_PSELP_AnalogInput6, 
24      NRF_SAADC_INPUT_AIN7     = SAADC_CH_PSELP_PSELP_AnalogInput7, 
25      NRF_SAADC_INPUT_VDD      = SAADC_CH_PSELP_PSELP_VDD,          
26  #if defined(SAADC_CH_PSELP_PSELP_VDDHDIV5) || defined(__NRFX_DOXYGEN__)
27      NRF_SAADC_INPUT_VDDHDIV5 = SAADC_CH_PSELP_PSELP_VDDHDIV5      
28  #endif
29  } nrf_saadc_input_t;
30  typedef enum
31  {
32      NRF_SAADC_OVERSAMPLE_DISABLED = SAADC_OVERSAMPLE_OVERSAMPLE_Bypass,   
33      NRF_SAADC_OVERSAMPLE_2X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over2x,   
34      NRF_SAADC_OVERSAMPLE_4X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over4x,   
35      NRF_SAADC_OVERSAMPLE_8X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over8x,   
36      NRF_SAADC_OVERSAMPLE_16X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over16x,  
37      NRF_SAADC_OVERSAMPLE_32X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over32x,  
38      NRF_SAADC_OVERSAMPLE_64X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over64x,  
39      NRF_SAADC_OVERSAMPLE_128X     = SAADC_OVERSAMPLE_OVERSAMPLE_Over128x, 
40      NRF_SAADC_OVERSAMPLE_256X     = SAADC_OVERSAMPLE_OVERSAMPLE_Over256x  
41  } nrf_saadc_oversample_t;
42  typedef enum
43  {
44      NRF_SAADC_RESISTOR_DISABLED = SAADC_CH_CONFIG_RESP_Bypass,   
45      NRF_SAADC_RESISTOR_PULLDOWN = SAADC_CH_CONFIG_RESP_Pulldown, 
46      NRF_SAADC_RESISTOR_PULLUP   = SAADC_CH_CONFIG_RESP_Pullup,   
47      NRF_SAADC_RESISTOR_VDD1_2   = SAADC_CH_CONFIG_RESP_VDD1_2    
48  } nrf_saadc_resistor_t;
49  typedef enum
50  {
51      NRF_SAADC_GAIN1_6 = SAADC_CH_CONFIG_GAIN_Gain1_6, 
52      NRF_SAADC_GAIN1_5 = SAADC_CH_CONFIG_GAIN_Gain1_5, 
53      NRF_SAADC_GAIN1_4 = SAADC_CH_CONFIG_GAIN_Gain1_4, 
54      NRF_SAADC_GAIN1_3 = SAADC_CH_CONFIG_GAIN_Gain1_3, 
55      NRF_SAADC_GAIN1_2 = SAADC_CH_CONFIG_GAIN_Gain1_2, 
56      NRF_SAADC_GAIN1   = SAADC_CH_CONFIG_GAIN_Gain1,   
57      NRF_SAADC_GAIN2   = SAADC_CH_CONFIG_GAIN_Gain2,   
58      NRF_SAADC_GAIN4   = SAADC_CH_CONFIG_GAIN_Gain4,   
59  } nrf_saadc_gain_t;
60  typedef enum
61  {
62      NRF_SAADC_REFERENCE_INTERNAL = SAADC_CH_CONFIG_REFSEL_Internal, 
63      NRF_SAADC_REFERENCE_VDD4     = SAADC_CH_CONFIG_REFSEL_VDD1_4    
64  } nrf_saadc_reference_t;
65  typedef enum
66  {
67      NRF_SAADC_ACQTIME_3US  = SAADC_CH_CONFIG_TACQ_3us,  
68      NRF_SAADC_ACQTIME_5US  = SAADC_CH_CONFIG_TACQ_5us,  
69      NRF_SAADC_ACQTIME_10US = SAADC_CH_CONFIG_TACQ_10us, 
70      NRF_SAADC_ACQTIME_15US = SAADC_CH_CONFIG_TACQ_15us, 
71      NRF_SAADC_ACQTIME_20US = SAADC_CH_CONFIG_TACQ_20us, 
72      NRF_SAADC_ACQTIME_40US = SAADC_CH_CONFIG_TACQ_40us  
73  } nrf_saadc_acqtime_t;
74  typedef enum
75  {
76      NRF_SAADC_MODE_SINGLE_ENDED = SAADC_CH_CONFIG_MODE_SE,  
77      NRF_SAADC_MODE_DIFFERENTIAL = SAADC_CH_CONFIG_MODE_Diff 
78  } nrf_saadc_mode_t;
79  typedef enum
80  {
81      NRF_SAADC_BURST_DISABLED = SAADC_CH_CONFIG_BURST_Disabled, 
82      NRF_SAADC_BURST_ENABLED  = SAADC_CH_CONFIG_BURST_Enabled   
83  } nrf_saadc_burst_t;
84  typedef enum
85  {
86      NRF_SAADC_TASK_START           = offsetof(NRF_SAADC_Type, TASKS_START),           
87      NRF_SAADC_TASK_SAMPLE          = offsetof(NRF_SAADC_Type, TASKS_SAMPLE),          
88      NRF_SAADC_TASK_STOP            = offsetof(NRF_SAADC_Type, TASKS_STOP),            
89      NRF_SAADC_TASK_CALIBRATEOFFSET = offsetof(NRF_SAADC_Type, TASKS_CALIBRATEOFFSET), 
90  } nrf_saadc_task_t;
91  typedef enum
92  {
93      NRF_SAADC_EVENT_STARTED       = offsetof(NRF_SAADC_Type, EVENTS_STARTED),       
94      NRF_SAADC_EVENT_END           = offsetof(NRF_SAADC_Type, EVENTS_END),           
95      NRF_SAADC_EVENT_DONE          = offsetof(NRF_SAADC_Type, EVENTS_DONE),          
96      NRF_SAADC_EVENT_RESULTDONE    = offsetof(NRF_SAADC_Type, EVENTS_RESULTDONE),    
97      NRF_SAADC_EVENT_CALIBRATEDONE = offsetof(NRF_SAADC_Type, EVENTS_CALIBRATEDONE), 
98      NRF_SAADC_EVENT_STOPPED       = offsetof(NRF_SAADC_Type, EVENTS_STOPPED),       
99      NRF_SAADC_EVENT_CH0_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[0].LIMITH),  
100      NRF_SAADC_EVENT_CH0_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[0].LIMITL),  
101      NRF_SAADC_EVENT_CH1_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[1].LIMITH),  
102      NRF_SAADC_EVENT_CH1_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[1].LIMITL),  
103      NRF_SAADC_EVENT_CH2_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[2].LIMITH),  
104      NRF_SAADC_EVENT_CH2_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[2].LIMITL),  
105      NRF_SAADC_EVENT_CH3_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[3].LIMITH),  
106      NRF_SAADC_EVENT_CH3_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[3].LIMITL),  
107      NRF_SAADC_EVENT_CH4_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[4].LIMITH),  
108      NRF_SAADC_EVENT_CH4_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[4].LIMITL),  
109      NRF_SAADC_EVENT_CH5_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[5].LIMITH),  
110      NRF_SAADC_EVENT_CH5_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[5].LIMITL),  
111      NRF_SAADC_EVENT_CH6_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[6].LIMITH),  
112      NRF_SAADC_EVENT_CH6_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[6].LIMITL),  
113      NRF_SAADC_EVENT_CH7_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[7].LIMITH),  
114      NRF_SAADC_EVENT_CH7_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[7].LIMITL)   
115  } nrf_saadc_event_t;
116  typedef enum
117  {
118      NRF_SAADC_INT_STARTED       = SAADC_INTENSET_STARTED_Msk,       
119      NRF_SAADC_INT_END           = SAADC_INTENSET_END_Msk,           
120      NRF_SAADC_INT_DONE          = SAADC_INTENSET_DONE_Msk,          
121      NRF_SAADC_INT_RESULTDONE    = SAADC_INTENSET_RESULTDONE_Msk,    
122      NRF_SAADC_INT_CALIBRATEDONE = SAADC_INTENSET_CALIBRATEDONE_Msk, 
123      NRF_SAADC_INT_STOPPED       = SAADC_INTENSET_STOPPED_Msk,       
124      NRF_SAADC_INT_CH0LIMITH     = SAADC_INTENSET_CH0LIMITH_Msk,     
125      NRF_SAADC_INT_CH0LIMITL     = SAADC_INTENSET_CH0LIMITL_Msk,     
126      NRF_SAADC_INT_CH1LIMITH     = SAADC_INTENSET_CH1LIMITH_Msk,     
127      NRF_SAADC_INT_CH1LIMITL     = SAADC_INTENSET_CH1LIMITL_Msk,     
128      NRF_SAADC_INT_CH2LIMITH     = SAADC_INTENSET_CH2LIMITH_Msk,     
129      NRF_SAADC_INT_CH2LIMITL     = SAADC_INTENSET_CH2LIMITL_Msk,     
130      NRF_SAADC_INT_CH3LIMITH     = SAADC_INTENSET_CH3LIMITH_Msk,     
131      NRF_SAADC_INT_CH3LIMITL     = SAADC_INTENSET_CH3LIMITL_Msk,     
132      NRF_SAADC_INT_CH4LIMITH     = SAADC_INTENSET_CH4LIMITH_Msk,     
133      NRF_SAADC_INT_CH4LIMITL     = SAADC_INTENSET_CH4LIMITL_Msk,     
134      NRF_SAADC_INT_CH5LIMITH     = SAADC_INTENSET_CH5LIMITH_Msk,     
135      NRF_SAADC_INT_CH5LIMITL     = SAADC_INTENSET_CH5LIMITL_Msk,     
136      NRF_SAADC_INT_CH6LIMITH     = SAADC_INTENSET_CH6LIMITH_Msk,     
137      NRF_SAADC_INT_CH6LIMITL     = SAADC_INTENSET_CH6LIMITL_Msk,     
138      NRF_SAADC_INT_CH7LIMITH     = SAADC_INTENSET_CH7LIMITH_Msk,     
139      NRF_SAADC_INT_CH7LIMITL     = SAADC_INTENSET_CH7LIMITL_Msk,     
140      NRF_SAADC_INT_ALL           = 0x7FFFFFFFUL                      
141  } nrf_saadc_int_mask_t;
142  typedef enum
143  {
144      NRF_SAADC_LIMIT_LOW  = 0, 
145      NRF_SAADC_LIMIT_HIGH = 1  
146  } nrf_saadc_limit_t;
147  typedef int16_t nrf_saadc_value_t;
148  typedef struct
149  {
150      nrf_saadc_resolution_t resolution;  
151      nrf_saadc_oversample_t oversample;  
152      nrf_saadc_value_t *    buffer;      
153      uint32_t               buffer_size; 
154  } nrf_saadc_config_t;
155  typedef struct
156  {
157      nrf_saadc_resistor_t  resistor_p; 
158      nrf_saadc_resistor_t  resistor_n; 
159      nrf_saadc_gain_t      gain;       
160      nrf_saadc_reference_t reference;  
161      nrf_saadc_acqtime_t   acq_time;   
162      nrf_saadc_mode_t      mode;       
163      nrf_saadc_burst_t     burst;      
164  } nrf_saadc_channel_config_t;
165  NRF_STATIC_INLINE void nrf_saadc_task_trigger(NRF_SAADC_Type * p_reg,
166                                                nrf_saadc_task_t task);
167  NRF_STATIC_INLINE uint32_t nrf_saadc_task_address_get(NRF_SAADC_Type const * p_reg,
168                                                        nrf_saadc_task_t       task);
169  NRF_STATIC_INLINE bool nrf_saadc_event_check(NRF_SAADC_Type const * p_reg,
170                                               nrf_saadc_event_t      event);
171  NRF_STATIC_INLINE void nrf_saadc_event_clear(NRF_SAADC_Type *  p_reg,
172                                               nrf_saadc_event_t event);
173  NRF_STATIC_INLINE uint32_t nrf_saadc_event_address_get(NRF_SAADC_Type const * p_reg,
174                                                         nrf_saadc_event_t      event);
175  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
176  NRF_STATIC_INLINE void nrf_saadc_subscribe_set(NRF_SAADC_Type * p_reg,
177                                                 nrf_saadc_task_t task,
178                                                 uint8_t          channel);
179  NRF_STATIC_INLINE void nrf_saadc_subscribe_clear(NRF_SAADC_Type * p_reg,
180                                                   nrf_saadc_task_t task);
181  NRF_STATIC_INLINE void nrf_saadc_publish_set(NRF_SAADC_Type *  p_reg,
182                                               nrf_saadc_event_t event,
183                                               uint8_t           channel);
184  NRF_STATIC_INLINE void nrf_saadc_publish_clear(NRF_SAADC_Type *  p_reg,
185                                                 nrf_saadc_event_t event);
186  #endif 
187  NRF_STATIC_INLINE nrf_saadc_event_t nrf_saadc_limit_event_get(uint8_t           channel,
188                                                                nrf_saadc_limit_t limit_type);
189  NRF_STATIC_INLINE void nrf_saadc_channel_input_set(NRF_SAADC_Type *  p_reg,
190                                                     uint8_t           channel,
191                                                     nrf_saadc_input_t pselp,
192                                                     nrf_saadc_input_t pseln);
193  NRF_STATIC_INLINE void nrf_saadc_channel_pos_input_set(NRF_SAADC_Type *  p_reg,
194                                                         uint8_t           channel,
195                                                         nrf_saadc_input_t pselp);
196  NRF_STATIC_INLINE void nrf_saadc_channel_limits_set(NRF_SAADC_Type * p_reg,
197                                                      uint8_t          channel,
198                                                      int16_t          low,
199                                                      int16_t          high);
200  NRF_STATIC_INLINE void nrf_saadc_int_set(NRF_SAADC_Type * p_reg, uint32_t mask);
201  NRF_STATIC_INLINE void nrf_saadc_int_enable(NRF_SAADC_Type * p_reg, uint32_t mask);
202  NRF_STATIC_INLINE uint32_t nrf_saadc_int_enable_check(NRF_SAADC_Type const * p_reg, uint32_t mask);
203  NRF_STATIC_INLINE void nrf_saadc_int_disable(NRF_SAADC_Type * p_reg, uint32_t mask);
204  NRF_STATIC_INLINE uint32_t nrf_saadc_limit_int_get(uint8_t           channel,
205                                                     nrf_saadc_limit_t limit_type);
206  NRF_STATIC_INLINE bool nrf_saadc_busy_check(NRF_SAADC_Type const * p_reg);
207  NRF_STATIC_INLINE void nrf_saadc_enable(NRF_SAADC_Type * p_reg);
208  NRF_STATIC_INLINE void nrf_saadc_disable(NRF_SAADC_Type * p_reg);
209  NRF_STATIC_INLINE bool nrf_saadc_enable_check(NRF_SAADC_Type const * p_reg);
210  NRF_STATIC_INLINE void nrf_saadc_buffer_init(NRF_SAADC_Type *    p_reg,
211                                               nrf_saadc_value_t * p_buffer,
212                                               uint32_t            size);
213  NRF_STATIC_INLINE void nrf_saadc_buffer_pointer_set(NRF_SAADC_Type *    p_reg,
214                                                      nrf_saadc_value_t * p_buffer);
215  NRF_STATIC_INLINE nrf_saadc_value_t * nrf_saadc_buffer_pointer_get(NRF_SAADC_Type const * p_reg);
216  NRF_STATIC_INLINE uint16_t nrf_saadc_amount_get(NRF_SAADC_Type const * p_reg);
217  NRF_STATIC_INLINE void nrf_saadc_resolution_set(NRF_SAADC_Type *       p_reg,
218                                                  nrf_saadc_resolution_t resolution);
219  NRF_STATIC_INLINE nrf_saadc_resolution_t nrf_saadc_resolution_get(NRF_SAADC_Type const * p_reg);
220  NRF_STATIC_INLINE void nrf_saadc_oversample_set(NRF_SAADC_Type *       p_reg,
221                                                  nrf_saadc_oversample_t oversample);
222  NRF_STATIC_INLINE nrf_saadc_oversample_t nrf_saadc_oversample_get(NRF_SAADC_Type const * p_reg);
223  NRF_STATIC_INLINE uint32_t nrf_saadc_oversample_sample_count_get(nrf_saadc_oversample_t oversample);
224  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_enable(NRF_SAADC_Type * p_reg,
225                                                          uint16_t         cc);
226  NRF_STATIC_INLINE bool nrf_saadc_continuous_mode_enable_check(NRF_SAADC_Type const * p_reg);
227  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_disable(NRF_SAADC_Type * p_reg);
228  NRF_STATIC_INLINE void nrf_saadc_channel_init(NRF_SAADC_Type *                   p_reg,
229                                                uint8_t                            channel,
230                                                nrf_saadc_channel_config_t const * config);
231  NRF_STATIC_INLINE void nrf_saadc_burst_set(NRF_SAADC_Type *  p_reg,
232                                             uint8_t           channel,
233                                             nrf_saadc_burst_t burst);
234  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_min_get(nrf_saadc_resolution_t resolution);
235  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_max_get(nrf_saadc_resolution_t resolution);
236  #ifndef NRF_DECLARE_ONLY
237  NRF_STATIC_INLINE void nrf_saadc_task_trigger(NRF_SAADC_Type * p_reg, nrf_saadc_task_t task)
238  {
239      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
<span onclick='openModal()' class='match'>240  }
241  NRF_STATIC_INLINE uint32_t nrf_saadc_task_address_get(NRF_SAADC_Type const * p_reg,
242                                                        nrf_saadc_task_t       task)
243  {
244      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
245  }
246  NRF_STATIC_INLINE bool nrf_saadc_event_check(NRF_SAADC_Type const * p_reg, nrf_saadc_event_t event)
247  {
248      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
</span>249  }
250  NRF_STATIC_INLINE void nrf_saadc_event_clear(NRF_SAADC_Type * p_reg, nrf_saadc_event_t event)
251  {
252      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
253  #if __CORTEX_M == 0x04
254      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
255      (void)dummy;
256  #endif
257  }
258  NRF_STATIC_INLINE uint32_t  nrf_saadc_event_address_get(NRF_SAADC_Type const * p_reg,
259                                                          nrf_saadc_event_t      event)
260  {
261      return (uint32_t )((uint8_t *)p_reg + (uint32_t)event);
262  }
263  #if defined(DPPI_PRESENT)
264  NRF_STATIC_INLINE void nrf_saadc_subscribe_set(NRF_SAADC_Type * p_reg,
265                                                 nrf_saadc_task_t task,
266                                                 uint8_t          channel)
267  {
268      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
269              ((uint32_t)channel | SAADC_SUBSCRIBE_START_EN_Msk);
270  }
271  NRF_STATIC_INLINE void nrf_saadc_subscribe_clear(NRF_SAADC_Type * p_reg, nrf_saadc_task_t task)
272  {
273      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
274  }
275  NRF_STATIC_INLINE void nrf_saadc_publish_set(NRF_SAADC_Type *  p_reg,
276                                               nrf_saadc_event_t event,
277                                               uint8_t           channel)
278  {
279      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
280              ((uint32_t)channel | SAADC_PUBLISH_STARTED_EN_Msk);
281  }
282  NRF_STATIC_INLINE void nrf_saadc_publish_clear(NRF_SAADC_Type * p_reg, nrf_saadc_event_t event)
283  {
284      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
285  }
286  #endif 
287  NRF_STATIC_INLINE nrf_saadc_event_t nrf_saadc_limit_event_get(uint8_t           channel,
288                                                                nrf_saadc_limit_t limit_type)
289  {
290      if (limit_type == NRF_SAADC_LIMIT_HIGH)
291      {
292          return (nrf_saadc_event_t)NRFX_OFFSETOF(NRF_SAADC_Type, EVENTS_CH[channel].LIMITH);
293      }
294      else
295      {
296          return (nrf_saadc_event_t)NRFX_OFFSETOF(NRF_SAADC_Type, EVENTS_CH[channel].LIMITL);
297      }
298  }
299  NRF_STATIC_INLINE void nrf_saadc_channel_input_set(NRF_SAADC_Type *  p_reg,
300                                                     uint8_t           channel,
301                                                     nrf_saadc_input_t pselp,
302                                                     nrf_saadc_input_t pseln)
303  {
304      p_reg->CH[channel].PSELN = pseln;
305      p_reg->CH[channel].PSELP = pselp;
306  }
307  NRF_STATIC_INLINE void nrf_saadc_channel_pos_input_set(NRF_SAADC_Type *  p_reg,
308                                                         uint8_t           channel,
309                                                         nrf_saadc_input_t pselp)
310  {
311      p_reg->CH[channel].PSELP = pselp;
312  }
313  NRF_STATIC_INLINE void nrf_saadc_channel_limits_set(NRF_SAADC_Type * p_reg,
314                                                      uint8_t          channel,
315                                                      int16_t          low,
316                                                      int16_t          high)
317  {
318      p_reg->CH[channel].LIMIT = (
319              (((uint32_t) low << SAADC_CH_LIMIT_LOW_Pos) & SAADC_CH_LIMIT_LOW_Msk)
320            | (((uint32_t) high << SAADC_CH_LIMIT_HIGH_Pos) & SAADC_CH_LIMIT_HIGH_Msk));
321  }
322  NRF_STATIC_INLINE void nrf_saadc_int_set(NRF_SAADC_Type * p_reg, uint32_t mask)
323  {
324      p_reg->INTEN = mask;
325  }
326  NRF_STATIC_INLINE void nrf_saadc_int_enable(NRF_SAADC_Type * p_reg, uint32_t mask)
327  {
328      p_reg->INTENSET = mask;
329  }
330  NRF_STATIC_INLINE uint32_t nrf_saadc_int_enable_check(NRF_SAADC_Type const * p_reg, uint32_t mask)
331  {
332      return p_reg->INTENSET & mask;
333  }
334  NRF_STATIC_INLINE void nrf_saadc_int_disable(NRF_SAADC_Type * p_reg, uint32_t mask)
335  {
336      p_reg->INTENCLR = mask;
337  }
338  NRF_STATIC_INLINE uint32_t nrf_saadc_limit_int_get(uint8_t           channel,
339                                                     nrf_saadc_limit_t limit_type)
340  {
341      NRFX_ASSERT(channel < SAADC_CH_NUM);
342      uint32_t mask = (limit_type == NRF_SAADC_LIMIT_LOW) ?
343                       NRF_SAADC_INT_CH0LIMITL : NRF_SAADC_INT_CH0LIMITH;
344      return mask << (channel * 2);
345  }
346  NRF_STATIC_INLINE bool nrf_saadc_busy_check(NRF_SAADC_Type const * p_reg)
347  {
348      return (p_reg->STATUS == (SAADC_STATUS_STATUS_Busy << SAADC_STATUS_STATUS_Pos));
349  }
350  NRF_STATIC_INLINE void nrf_saadc_enable(NRF_SAADC_Type * p_reg)
351  {
352      p_reg->ENABLE = (SAADC_ENABLE_ENABLE_Enabled << SAADC_ENABLE_ENABLE_Pos);
353  }
354  NRF_STATIC_INLINE void nrf_saadc_disable(NRF_SAADC_Type * p_reg)
355  {
356      p_reg->ENABLE = (SAADC_ENABLE_ENABLE_Disabled << SAADC_ENABLE_ENABLE_Pos);
357  }
358  NRF_STATIC_INLINE bool nrf_saadc_enable_check(NRF_SAADC_Type const * p_reg)
359  {
360      return (p_reg->ENABLE == (SAADC_ENABLE_ENABLE_Enabled << SAADC_ENABLE_ENABLE_Pos));
361  }
362  NRF_STATIC_INLINE void nrf_saadc_buffer_init(NRF_SAADC_Type *    p_reg,
363                                               nrf_saadc_value_t * p_buffer,
364                                               uint32_t            size)
365  {
366      p_reg->RESULT.PTR = (uint32_t)p_buffer;
367      p_reg->RESULT.MAXCNT = size;
368  }
369  NRF_STATIC_INLINE void nrf_saadc_buffer_pointer_set(NRF_SAADC_Type *    p_reg,
370                                                      nrf_saadc_value_t * p_buffer)
371  {
372      p_reg->RESULT.PTR = (uint32_t)p_buffer;
373  }
374  NRF_STATIC_INLINE nrf_saadc_value_t * nrf_saadc_buffer_pointer_get(NRF_SAADC_Type const * p_reg)
375  {
376      return (nrf_saadc_value_t *)p_reg->RESULT.PTR;
377  }
378  NRF_STATIC_INLINE uint16_t nrf_saadc_amount_get(NRF_SAADC_Type const * p_reg)
379  {
380      return p_reg->RESULT.AMOUNT;
381  }
382  NRF_STATIC_INLINE void nrf_saadc_resolution_set(NRF_SAADC_Type *       p_reg,
383                                                  nrf_saadc_resolution_t resolution)
384  {
385      p_reg->RESOLUTION = resolution;
386  }
387  NRF_STATIC_INLINE nrf_saadc_resolution_t nrf_saadc_resolution_get(NRF_SAADC_Type const * p_reg)
388  {
389      return (nrf_saadc_resolution_t)p_reg->RESOLUTION;
390  }
391  NRF_STATIC_INLINE void nrf_saadc_oversample_set(NRF_SAADC_Type *       p_reg,
392                                                  nrf_saadc_oversample_t oversample)
393  {
394      p_reg->OVERSAMPLE = oversample;
395  }
396  NRF_STATIC_INLINE nrf_saadc_oversample_t nrf_saadc_oversample_get(NRF_SAADC_Type const * p_reg)
397  {
398      return (nrf_saadc_oversample_t)p_reg->OVERSAMPLE;
399  }
400  NRF_STATIC_INLINE uint32_t nrf_saadc_oversample_sample_count_get(nrf_saadc_oversample_t oversample)
401  {
402      return (1 << (uint32_t)oversample);
403  }
404  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_enable(NRF_SAADC_Type * p_reg, uint16_t cc)
405  {
406      NRFX_ASSERT((cc >= 80) && (cc <= 2047));
407      p_reg->SAMPLERATE = (SAADC_SAMPLERATE_MODE_Timers << SAADC_SAMPLERATE_MODE_Pos)
408                          | ((uint32_t)cc << SAADC_SAMPLERATE_CC_Pos);
409  }
410  NRF_STATIC_INLINE bool nrf_saadc_continuous_mode_enable_check(NRF_SAADC_Type const * p_reg)
411  {
412      return (bool)((p_reg->SAMPLERATE & SAADC_SAMPLERATE_MODE_Msk)
413                     == (SAADC_SAMPLERATE_MODE_Timers << SAADC_SAMPLERATE_MODE_Pos));
414  }
415  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_disable(NRF_SAADC_Type * p_reg)
416  {
417      p_reg->SAMPLERATE = SAADC_SAMPLERATE_MODE_Task << SAADC_SAMPLERATE_MODE_Pos;
418  }
419  NRF_STATIC_INLINE void nrf_saadc_channel_init(NRF_SAADC_Type *                   p_reg,
420                                                uint8_t                            channel,
421                                                nrf_saadc_channel_config_t const * config)
422  {
423      p_reg->CH[channel].CONFIG =
424              ((config->resistor_p   << SAADC_CH_CONFIG_RESP_Pos)   & SAADC_CH_CONFIG_RESP_Msk)
425              | ((config->resistor_n << SAADC_CH_CONFIG_RESN_Pos)   & SAADC_CH_CONFIG_RESN_Msk)
426              | ((config->gain       << SAADC_CH_CONFIG_GAIN_Pos)   & SAADC_CH_CONFIG_GAIN_Msk)
427              | ((config->reference  << SAADC_CH_CONFIG_REFSEL_Pos) & SAADC_CH_CONFIG_REFSEL_Msk)
428              | ((config->acq_time   << SAADC_CH_CONFIG_TACQ_Pos)   & SAADC_CH_CONFIG_TACQ_Msk)
429              | ((config->mode       << SAADC_CH_CONFIG_MODE_Pos)   & SAADC_CH_CONFIG_MODE_Msk)
430              | ((config->burst      << SAADC_CH_CONFIG_BURST_Pos)  & SAADC_CH_CONFIG_BURST_Msk);
431  }
432  NRF_STATIC_INLINE void nrf_saadc_burst_set(NRF_SAADC_Type *  p_reg,
433                                             uint8_t           channel,
434                                             nrf_saadc_burst_t burst)
435  {
436      p_reg->CH[channel].CONFIG = (p_reg->CH[channel].CONFIG & ~SAADC_CH_CONFIG_BURST_Msk) |
437                                  (burst << SAADC_CH_CONFIG_BURST_Pos);
438  }
439  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_min_get(nrf_saadc_resolution_t resolution)
440  {
441      uint8_t res_bits = 0;
442      switch (resolution)
443      {
444          case NRF_SAADC_RESOLUTION_8BIT:
445              res_bits = 8;
446              break;
447          case NRF_SAADC_RESOLUTION_10BIT:
448              res_bits = 10;
449              break;
450          case NRF_SAADC_RESOLUTION_12BIT:
451              res_bits = 12;
452              break;
453          case NRF_SAADC_RESOLUTION_14BIT:
454              res_bits = 14;
455              break;
456          default:
457              NRFX_ASSERT(false);
458      }
459      return (nrf_saadc_value_t)(-(1 << res_bits));
460  }
461  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_max_get(nrf_saadc_resolution_t resolution)
462  {
463      uint8_t res_bits = 0;
464      switch (resolution)
465      {
466          case NRF_SAADC_RESOLUTION_8BIT:
467              res_bits = 8;
468              break;
469          case NRF_SAADC_RESOLUTION_10BIT:
470              res_bits = 10;
471              break;
472          case NRF_SAADC_RESOLUTION_12BIT:
473              res_bits = 12;
474              break;
475          case NRF_SAADC_RESOLUTION_14BIT:
476              res_bits = 14;
477              break;
478          default:
479              NRFX_ASSERT(false);
480      }
481      return (nrf_saadc_value_t)((1 << res_bits) - 1);
482  }
483  #endif 
484  #ifdef __cplusplus
485  }
486  #endif
487  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CudaConfig_gen.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_saadc.h</div>
                </div>
                <div class="column column_space"><pre><code>39  }
40  #endif
41  #ifdef XMRIG_ALGO_CN_HEAVY
42  template<>
43  size_t inline generate<Algorithm::CN_HEAVY>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
44  {
45      return generate(Algorithm::kCN_HEAVY, threads, Algorithm::CN_HEAVY_0, devices);
46  }
47  #endif
48  #ifdef XMRIG_ALGO_CN_PICO
49  template<>
50  size_t inline generate<Algorithm::CN_PICO>(Threads<CudaThreads> &threads, const std::vector<CudaDevice> &devices)
51  {
52      return generate(Algorithm::kCN_PICO, threads, Algorithm::CN_PICO_0, devices);
</pre></code></div>
                <div class="column column_space"><pre><code>240  }
241  NRF_STATIC_INLINE uint32_t nrf_saadc_task_address_get(NRF_SAADC_Type const * p_reg,
242                                                        nrf_saadc_task_t       task)
243  {
244      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
245  }
246  NRF_STATIC_INLINE bool nrf_saadc_event_check(NRF_SAADC_Type const * p_reg, nrf_saadc_event_t event)
247  {
248      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    