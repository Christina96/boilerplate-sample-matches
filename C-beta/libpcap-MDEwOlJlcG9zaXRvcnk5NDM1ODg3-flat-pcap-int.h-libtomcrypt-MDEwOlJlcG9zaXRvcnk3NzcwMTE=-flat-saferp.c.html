
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.14141414141414%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-int.h</h3>
            <pre><code>1  #ifndef pcap_int_h
2  #define	pcap_int_h
3  #include <stddef.h>
4  #include <signal.h>
5  #include <pcap/pcap.h>
6  #ifdef MSDOS
7    #include <fcntl.h>
8    #include <io.h>
9  #endif
10  #include "varattrs.h"
11  #include "fmtutils.h"
12  #include <stdarg.h>
13  #include "portability.h"
14  #if defined(_MSC_VER)
15    #if _MSC_VER < 1900
16      #error "Building libpcap requires VS 2015 or later"
17    #endif
18  #endif
19  #define PCAP_VERSION_STRING "libpcap version " PACKAGE_VERSION
20  #ifdef __cplusplus
21  extern "C" {
22  #endif
23  extern int pcap_new_api;
24  extern int pcap_utf_8_mode;
25  extern int pcap_mmap_32bit;
26  #define SWAPLL(ull)  ((ull & 0xff00000000000000ULL) >> 56) | \
27                        ((ull & 0x00ff000000000000ULL) >> 40) | \
28                        ((ull & 0x0000ff0000000000ULL) >> 24) | \
29                        ((ull & 0x000000ff00000000ULL) >> 8)  | \
30                        ((ull & 0x00000000ff000000ULL) << 8)  | \
31                        ((ull & 0x0000000000ff0000ULL) << 24) | \
32                        ((ull & 0x000000000000ff00ULL) << 40) | \
33                        ((ull & 0x00000000000000ffULL) << 56)
34  #define MAXIMUM_SNAPLEN		262144
35  #define PCAP_ISDIGIT(c) \
36  	((c) >= '0' && (c) <= '9')
37  #define PCAP_ISXDIGIT(c) \
38  	(((c) >= '0' && (c) <= '9') || \
39  	 ((c) >= 'A' && (c) <= 'F') || \
40  	 ((c) >= 'a' && (c) <= 'f'))
41  struct pcap_opt {
42  	char	*device;
43  	int	timeout;	&bsol;* timeout for buffering */
44  	u_int	buffer_size;
45  	int	promisc;
46  	int	rfmon;		&bsol;* monitor mode */
47  	int	immediate;	&bsol;* immediate mode - deliver packets as soon as they arrive */
48  	int	nonblock;	&bsol;* non-blocking mode - don't wait for packets to be delivered, return "no packets available" */
49  	int	tstamp_type;
50  	int	tstamp_precision;
51  #ifdef __linux__
52  	int	protocol;	&bsol;* protocol to use when creating PF_PACKET socket */
53  #endif
54  #ifdef _WIN32
55  	int	nocapture_local;&bsol;* disable NPF loopback */
56  #endif
57  };
58  typedef int	(*activate_op_t)(pcap_t *);
59  typedef int	(*can_set_rfmon_op_t)(pcap_t *);
60  typedef int	(*read_op_t)(pcap_t *, int cnt, pcap_handler, u_char *);
61  typedef int	(*next_packet_op_t)(pcap_t *, struct pcap_pkthdr *, u_char **);
<span onclick='openModal()' class='match'>62  typedef int	(*inject_op_t)(pcap_t *, const void *, int);
63  typedef void	(*save_current_filter_op_t)(pcap_t *, const char *);
64  typedef int	(*setfilter_op_t)(pcap_t *, struct bpf_program *);
65  typedef int	(*setdirection_op_t)(pcap_t *, pcap_direction_t);
66  typedef int	(*set_datalink_op_t)(pcap_t *, int);
67  typedef int	(*getnonblock_op_t)(pcap_t *);
</span>68  typedef int	(*setnonblock_op_t)(pcap_t *, int);
69  typedef int	(*stats_op_t)(pcap_t *, struct pcap_stat *);
70  typedef void	(*breakloop_op_t)(pcap_t *);
71  #ifdef _WIN32
72  typedef struct pcap_stat *(*stats_ex_op_t)(pcap_t *, int *);
73  typedef int	(*setbuff_op_t)(pcap_t *, int);
74  typedef int	(*setmode_op_t)(pcap_t *, int);
75  typedef int	(*setmintocopy_op_t)(pcap_t *, int);
76  typedef HANDLE	(*getevent_op_t)(pcap_t *);
77  typedef int	(*oid_get_request_op_t)(pcap_t *, bpf_u_int32, void *, size_t *);
78  typedef int	(*oid_set_request_op_t)(pcap_t *, bpf_u_int32, const void *, size_t *);
79  typedef u_int	(*sendqueue_transmit_op_t)(pcap_t *, pcap_send_queue *, int);
80  typedef int	(*setuserbuffer_op_t)(pcap_t *, int);
81  typedef int	(*live_dump_op_t)(pcap_t *, char *, int, int);
82  typedef int	(*live_dump_ended_op_t)(pcap_t *, int);
83  typedef PAirpcapHandle	(*get_airpcap_handle_op_t)(pcap_t *);
84  #endif
85  typedef void	(*cleanup_op_t)(pcap_t *);
86  struct pcap {
87  	read_op_t read_op;
88  	next_packet_op_t next_packet_op;
89  #ifdef _WIN32
90  	HANDLE handle;
91  #else
92  	int fd;
93  #endif &bsol;* _WIN32 */
94  	u_int bufsize;
95  	u_char *buffer;
96  	u_char *bp;
97  	int cc;
98  	sig_atomic_t break_loop; &bsol;* flag set to force break from packet-reading loop */
99  	void *priv;		&bsol;* private data for methods */
100  #ifdef ENABLE_REMOTE
101  	struct pcap_samp rmt_samp;	&bsol;* parameters related to the sampling process. */
102  #endif
103  	int swapped;
104  	FILE *rfile;		&bsol;* null if live capture, non-null if savefile */
105  	u_int fddipad;
106  	struct pcap *next;	&bsol;* list of open pcaps that need stuff cleared on close */
107  	int version_major;
108  	int version_minor;
109  	int snapshot;
110  	int linktype;		&bsol;* Network linktype */
111  	int linktype_ext;	&bsol;* Extended information stored in the linktype field of a file */
112  	int offset;		&bsol;* offset for proper alignment */
113  	int activated;		&bsol;* true if the capture is really started */
114  	int oldstyle;		&bsol;* if we're opening with pcap_open_live() */
115  	struct pcap_opt opt;
116  	u_char *pkt;
117  #ifdef _WIN32
118  	struct pcap_stat stat;	&bsol;* used for pcap_stats_ex() */
119  #endif
120  	pcap_direction_t direction;
121  	int bpf_codegen_flags;
122  #if !defined(_WIN32) && !defined(MSDOS)
123  	int selectable_fd;	&bsol;* FD on which select()/poll()/epoll_wait()/kevent()/etc. can be done */
124  	const struct timeval *required_select_timeout;
125  #endif
126  	struct bpf_program fcode;
127  	char errbuf[PCAP_ERRBUF_SIZE + 1];
128  #ifdef _WIN32
129  	char acp_errbuf[PCAP_ERRBUF_SIZE + 1];	&bsol;* buffer for local code page error strings */
130  #endif
131  	int dlt_count;
132  	u_int *dlt_list;
133  	int tstamp_type_count;
134  	u_int *tstamp_type_list;
135  	int tstamp_precision_count;
136  	u_int *tstamp_precision_list;
137  	struct pcap_pkthdr pcap_header;	&bsol;* This is needed for the pcap_next_ex() to work */
138  	activate_op_t activate_op;
139  	can_set_rfmon_op_t can_set_rfmon_op;
140  	inject_op_t inject_op;
141  	save_current_filter_op_t save_current_filter_op;
142  	setfilter_op_t setfilter_op;
143  	setdirection_op_t setdirection_op;
144  	set_datalink_op_t set_datalink_op;
145  	getnonblock_op_t getnonblock_op;
146  	setnonblock_op_t setnonblock_op;
147  	stats_op_t stats_op;
148  	breakloop_op_t breakloop_op;
149  	pcap_handler oneshot_callback;
150  #ifdef _WIN32
151  	stats_ex_op_t stats_ex_op;
152  	setbuff_op_t setbuff_op;
153  	setmode_op_t setmode_op;
154  	setmintocopy_op_t setmintocopy_op;
155  	getevent_op_t getevent_op;
156  	oid_get_request_op_t oid_get_request_op;
157  	oid_set_request_op_t oid_set_request_op;
158  	sendqueue_transmit_op_t sendqueue_transmit_op;
159  	setuserbuffer_op_t setuserbuffer_op;
160  	live_dump_op_t live_dump_op;
161  	live_dump_ended_op_t live_dump_ended_op;
162  	get_airpcap_handle_op_t get_airpcap_handle_op;
163  #endif
164  	cleanup_op_t cleanup_op;
165  };
166  #define BPF_SPECIAL_VLAN_HANDLING	0x00000001	&bsol;* special VLAN handling for Linux */
167  struct pcap_timeval {
168      bpf_int32 tv_sec;		&bsol;* seconds */
169      bpf_int32 tv_usec;		&bsol;* microseconds */
170  };
171  struct pcap_sf_pkthdr {
172      struct pcap_timeval ts;	&bsol;* time stamp */
173      bpf_u_int32 caplen;		&bsol;* length of portion present */
174      bpf_u_int32 len;		&bsol;* length of this packet (off wire) */
175  };
176  struct pcap_sf_patched_pkthdr {
177      struct pcap_timeval ts;	&bsol;* time stamp */
178      bpf_u_int32 caplen;		&bsol;* length of portion present */
179      bpf_u_int32 len;		&bsol;* length of this packet (off wire) */
180      int		index;
181      unsigned short protocol;
182      unsigned char pkt_type;
183  };
184  struct oneshot_userdata {
185  	struct pcap_pkthdr *hdr;
186  	const u_char **pkt;
187  	pcap_t *pd;
188  };
189  #ifndef min
190  #define min(a, b) ((a) > (b) ? (b) : (a))
191  #endif
192  int	pcap_offline_read(pcap_t *, int, pcap_handler, u_char *);
193  #define PACKET_COUNT_IS_UNLIMITED(count)	((count) <= 0)
194  #if !defined(_WIN32) && !defined(MSDOS)
195  int	pcap_getnonblock_fd(pcap_t *);
196  int	pcap_setnonblock_fd(pcap_t *p, int);
197  #endif
198  pcap_t	*pcap_create_interface(const char *, char *);
199  #define PCAP_CREATE_COMMON(ebuf, type) \
200  	pcap_create_common(ebuf, \
201  	    sizeof (struct { pcap_t __common; type __private; }), \
202  	    offsetof (struct { pcap_t __common; type __private; }, __private))
203  pcap_t	*pcap_create_common(char *, size_t, size_t);
204  int	pcap_do_addexit(pcap_t *);
205  void	pcap_add_to_pcaps_to_close(pcap_t *);
206  void	pcap_remove_from_pcaps_to_close(pcap_t *);
207  void	pcap_cleanup_live_common(pcap_t *);
208  int	pcap_check_activated(pcap_t *);
209  void	pcap_breakloop_common(pcap_t *);
210  struct pcap_if_list;
211  typedef struct pcap_if_list pcap_if_list_t;
212  typedef int (*get_if_flags_func)(const char *, bpf_u_int32 *, char *);
213  int	pcap_platform_finddevs(pcap_if_list_t *, char *);
214  #if !defined(_WIN32) && !defined(MSDOS)
215  int	pcap_findalldevs_interfaces(pcap_if_list_t *, char *,
216  	    int (*)(const char *), get_if_flags_func);
217  #endif
218  pcap_if_t *pcap_find_or_add_dev(pcap_if_list_t *, const char *, bpf_u_int32,
219  	    get_if_flags_func, const char *, char *);
220  pcap_if_t *pcap_find_dev(pcap_if_list_t *, const char *);
221  pcap_if_t *pcap_add_dev(pcap_if_list_t *, const char *, bpf_u_int32,
222  	    const char *, char *);
223  pcap_if_t *pcap_add_any_dev(pcap_if_list_t *, char *);
224  int	pcap_add_addr_to_dev(pcap_if_t *, struct sockaddr *, size_t,
225  	    struct sockaddr *, size_t, struct sockaddr *, size_t,
226  	    struct sockaddr *dstaddr, size_t, char *errbuf);
227  #ifndef _WIN32
228  pcap_if_t *pcap_find_or_add_if(pcap_if_list_t *, const char *, bpf_u_int32,
229  	    get_if_flags_func, char *);
230  int	pcap_add_addr_to_if(pcap_if_list_t *, const char *, bpf_u_int32,
231  	    get_if_flags_func,
232  	    struct sockaddr *, size_t, struct sockaddr *, size_t,
233  	    struct sockaddr *, size_t, struct sockaddr *, size_t, char *);
234  #endif
235  #define PCAP_OPEN_OFFLINE_COMMON(ebuf, type) \
236  	pcap_open_offline_common(ebuf, \
237  	    sizeof (struct { pcap_t __common; type __private; }), \
238  	    offsetof (struct { pcap_t __common; type __private; }, __private))
239  pcap_t	*pcap_open_offline_common(char *ebuf, size_t total_size,
240      size_t private_data);
241  bpf_u_int32 pcap_adjust_snapshot(bpf_u_int32 linktype, bpf_u_int32 snaplen);
242  void	pcap_sf_cleanup(pcap_t *p);
243  #ifdef _WIN32
244  FILE	*pcap_charset_fopen(const char *path, const char *mode);
245  #else
246  #define pcap_charset_fopen(path, mode)	fopen((path), (mode))
247  #endif
248  #ifdef _WIN32
249  #define pcap_code_handle_t	HMODULE
250  #define pcap_funcptr_t		FARPROC
251  pcap_code_handle_t	pcap_load_code(const char *);
252  pcap_funcptr_t		pcap_find_function(pcap_code_handle_t, const char *);
253  #endif
254  struct pcap_bpf_aux_data {
255  	u_short vlan_tag_present;
256  	u_short vlan_tag;
257  };
258  u_int	pcap_filter_with_aux_data(const struct bpf_insn *,
259      const u_char *, u_int, u_int, const struct pcap_bpf_aux_data *);
260  u_int	pcap_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
261  int	pcap_validate_filter(const struct bpf_insn *, int);
262  void	pcap_oneshot(u_char *, const struct pcap_pkthdr *, const u_char *);
263  int	pcap_install_bpf_program(pcap_t *, struct bpf_program *);
264  int	pcap_strcasecmp(const char *, const char *);
265  int	pcap_createsrcstr_ex(char *, int, const char *, const char *,
266      const char *, const char *, unsigned char, char *);
267  int	pcap_parsesrcstr_ex(const char *, int *, char *, char *,
268      char *, char *, unsigned char *, char *);
269  #ifdef YYDEBUG
270  extern int pcap_debug;
271  #endif
272  #ifdef __cplusplus
273  }
274  #endif
275  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-saferp.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SAFERP
3  #define LTC_SAFER_TAB_C
4  #include "safer_tab.c"
5  const struct ltc_cipher_descriptor saferp_desc =
6  {
7      "safer+",
8      4,
9      16, 32, 16, 8,
10      &saferp_setup,
11      &saferp_ecb_encrypt,
12      &saferp_ecb_decrypt,
13      &saferp_test,
14      &saferp_done,
15      &saferp_keysize,
16      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
17  };
18  #define ROUND(b, i) do {                                                                         \
19      b[0]  = (safer_ebox[(b[0] ^ skey->saferp.K[i][0]) & 255] + skey->saferp.K[i+1][0]) & 255;    \
20      b[1]  = safer_lbox[(b[1] + skey->saferp.K[i][1]) & 255] ^ skey->saferp.K[i+1][1];            \
21      b[2]  = safer_lbox[(b[2] + skey->saferp.K[i][2]) & 255] ^ skey->saferp.K[i+1][2];            \
22      b[3]  = (safer_ebox[(b[3] ^ skey->saferp.K[i][3]) & 255] + skey->saferp.K[i+1][3]) & 255;    \
23      b[4]  = (safer_ebox[(b[4] ^ skey->saferp.K[i][4]) & 255] + skey->saferp.K[i+1][4]) & 255;    \
24      b[5]  = safer_lbox[(b[5] + skey->saferp.K[i][5]) & 255] ^ skey->saferp.K[i+1][5];            \
25      b[6]  = safer_lbox[(b[6] + skey->saferp.K[i][6]) & 255] ^ skey->saferp.K[i+1][6];            \
26      b[7]  = (safer_ebox[(b[7] ^ skey->saferp.K[i][7]) & 255] + skey->saferp.K[i+1][7]) & 255;    \
27      b[8]  = (safer_ebox[(b[8] ^ skey->saferp.K[i][8]) & 255] + skey->saferp.K[i+1][8]) & 255;    \
28      b[9]  = safer_lbox[(b[9] + skey->saferp.K[i][9]) & 255] ^ skey->saferp.K[i+1][9];            \
29      b[10] = safer_lbox[(b[10] + skey->saferp.K[i][10]) & 255] ^ skey->saferp.K[i+1][10];         \
30      b[11] = (safer_ebox[(b[11] ^ skey->saferp.K[i][11]) & 255] + skey->saferp.K[i+1][11]) & 255; \
31      b[12] = (safer_ebox[(b[12] ^ skey->saferp.K[i][12]) & 255] + skey->saferp.K[i+1][12]) & 255; \
32      b[13] = safer_lbox[(b[13] + skey->saferp.K[i][13]) & 255] ^ skey->saferp.K[i+1][13];         \
33      b[14] = safer_lbox[(b[14] + skey->saferp.K[i][14]) & 255] ^ skey->saferp.K[i+1][14];         \
34      b[15] = (safer_ebox[(b[15] ^ skey->saferp.K[i][15]) & 255] + skey->saferp.K[i+1][15]) & 255; \
35  } while (0)
36  #define iROUND(b, i) do {                                                                        \
37      b[0]  = safer_lbox[(b[0] - skey->saferp.K[i+1][0]) & 255] ^ skey->saferp.K[i][0];            \
38      b[1]  = (safer_ebox[(b[1] ^ skey->saferp.K[i+1][1]) & 255] - skey->saferp.K[i][1]) & 255;    \
39      b[2]  = (safer_ebox[(b[2] ^ skey->saferp.K[i+1][2]) & 255] - skey->saferp.K[i][2]) & 255;    \
40      b[3]  = safer_lbox[(b[3] - skey->saferp.K[i+1][3]) & 255] ^ skey->saferp.K[i][3];            \
41      b[4]  = safer_lbox[(b[4] - skey->saferp.K[i+1][4]) & 255] ^ skey->saferp.K[i][4];            \
42      b[5]  = (safer_ebox[(b[5] ^ skey->saferp.K[i+1][5]) & 255] - skey->saferp.K[i][5]) & 255;    \
43      b[6]  = (safer_ebox[(b[6] ^ skey->saferp.K[i+1][6]) & 255] - skey->saferp.K[i][6]) & 255;    \
44      b[7]  = safer_lbox[(b[7] - skey->saferp.K[i+1][7]) & 255] ^ skey->saferp.K[i][7];            \
45      b[8]  = safer_lbox[(b[8] - skey->saferp.K[i+1][8]) & 255] ^ skey->saferp.K[i][8];            \
46      b[9]  = (safer_ebox[(b[9] ^ skey->saferp.K[i+1][9]) & 255] - skey->saferp.K[i][9]) & 255;    \
47      b[10] = (safer_ebox[(b[10] ^ skey->saferp.K[i+1][10]) & 255] - skey->saferp.K[i][10]) & 255; \
48      b[11] = safer_lbox[(b[11] - skey->saferp.K[i+1][11]) & 255] ^ skey->saferp.K[i][11];         \
49      b[12] = safer_lbox[(b[12] - skey->saferp.K[i+1][12]) & 255] ^ skey->saferp.K[i][12];         \
50      b[13] = (safer_ebox[(b[13] ^ skey->saferp.K[i+1][13]) & 255] - skey->saferp.K[i][13]) & 255; \
51      b[14] = (safer_ebox[(b[14] ^ skey->saferp.K[i+1][14]) & 255] - skey->saferp.K[i][14]) & 255; \
52      b[15] = safer_lbox[(b[15] - skey->saferp.K[i+1][15]) & 255] ^ skey->saferp.K[i][15];         \
53  } while (0)
54  #define PHT(b) do {                                          \
55      b[0]  = (b[0] + (b[1] = (b[0] + b[1]) & 255)) & 255;     \
56      b[2]  = (b[2] + (b[3] = (b[3] + b[2]) & 255)) & 255;     \
57      b[4]  = (b[4] + (b[5] = (b[5] + b[4]) & 255)) & 255;     \
58      b[6]  = (b[6] + (b[7] = (b[7] + b[6]) & 255)) & 255;     \
59      b[8]  = (b[8] + (b[9] = (b[9] + b[8]) & 255)) & 255;     \
60      b[10] = (b[10] + (b[11] = (b[11] + b[10]) & 255)) & 255; \
61      b[12] = (b[12] + (b[13] = (b[13] + b[12]) & 255)) & 255; \
62      b[14] = (b[14] + (b[15] = (b[15] + b[14]) & 255)) & 255; \
63  } while (0)
64  #define iPHT(b) do {                                          \
65      b[15] = (b[15] - (b[14] = (b[14] - b[15]) & 255)) & 255;  \
66      b[13] = (b[13] - (b[12] = (b[12] - b[13]) & 255)) & 255;  \
67      b[11] = (b[11] - (b[10] = (b[10] - b[11]) & 255)) & 255;  \
68      b[9]  = (b[9] - (b[8] = (b[8] - b[9]) & 255)) & 255;      \
69      b[7]  = (b[7] - (b[6] = (b[6] - b[7]) & 255)) & 255;      \
70      b[5]  = (b[5] - (b[4] = (b[4] - b[5]) & 255)) & 255;      \
71      b[3]  = (b[3] - (b[2] = (b[2] - b[3]) & 255)) & 255;      \
72      b[1]  = (b[1] - (b[0] = (b[0] - b[1]) & 255)) & 255;      \
73   } while (0)
74  #define SHUF(b, b2) do {                                         \
75      b2[0] = b[8]; b2[1] = b[11]; b2[2] = b[12]; b2[3] = b[15];   \
76      b2[4] = b[2]; b2[5] = b[1]; b2[6] = b[6]; b2[7] = b[5];      \
77      b2[8] = b[10]; b2[9] = b[9]; b2[10] = b[14]; b2[11] = b[13]; \
78      b2[12] = b[0]; b2[13] = b[7]; b2[14] = b[4]; b2[15] = b[3];  \
79  } while (0)
80  #define iSHUF(b, b2) do {                                          \
81      b2[0] = b[12]; b2[1] = b[5]; b2[2] = b[4]; b2[3] = b[15];      \
82      b2[4] = b[14]; b2[5] = b[7]; b2[6] = b[6]; b2[7] = b[13];      \
83      b2[8] = b[0]; b2[9] = b[9]; b2[10] = b[8]; b2[11] = b[1];      \
84      b2[12] = b[2]; b2[13] = b[11]; b2[14] = b[10]; b2[15] = b[3];  \
85  } while (0)
86  #define LT(b, b2) do {        \
87      PHT(b);  SHUF(b, b2);     \
88      PHT(b2); SHUF(b2, b);     \
89      PHT(b);  SHUF(b, b2);     \
90      PHT(b2);                  \
91  } while (0)
92  #define iLT(b, b2) do {       \
93      iPHT(b);                  \
94      iSHUF(b, b2); iPHT(b2);   \
95      iSHUF(b2, b); iPHT(b);    \
96      iSHUF(b, b2); iPHT(b2);   \
97  } while (0)
98  #ifdef LTC_SMALL_CODE
99  static void s_round(unsigned char *b, int i, const symmetric_key *skey)
100  {
101     ROUND(b, i);
102  }
103  static void s_iround(unsigned char *b, int i, const symmetric_key *skey)
104  {
105     iROUND(b, i);
106  }
107  static void s_lt(unsigned char *b, unsigned char *b2)
108  {
109     LT(b, b2);
110  }
111  static void s_ilt(unsigned char *b, unsigned char *b2)
112  {
113     iLT(b, b2);
114  }
115  #undef ROUND
116  #define ROUND(b, i) s_round(b, i, skey)
117  #undef iROUND
118  #define iROUND(b, i) s_iround(b, i, skey)
119  #undef LT
120  #define LT(b, b2) s_lt(b, b2)
121  #undef iLT
122  #define iLT(b, b2) s_ilt(b, b2)
123  #endif
124  static const unsigned char safer_bias[33][16] = {
125  {  70, 151, 177, 186, 163, 183,  16,  10, 197,  55, 179, 201,  90,  40, 172, 100},
126  { 236, 171, 170, 198, 103, 149,  88,  13, 248, 154, 246, 110, 102, 220,   5,  61},
127  { 138, 195, 216, 137, 106, 233,  54,  73,  67, 191, 235, 212, 150, 155, 104, 160},
128  {  93,  87, 146,  31, 213, 113,  92, 187,  34, 193, 190, 123, 188, 153,  99, 148},
129  {  42,  97, 184,  52,  50,  25, 253, 251,  23,  64, 230,  81,  29,  65,  68, 143},
130  { 221,   4, 128, 222, 231,  49, 214, 127,   1, 162, 247,  57, 218, 111,  35, 202},
131  {  58, 208,  28, 209,  48,  62,  18, 161, 205,  15, 224, 168, 175, 130,  89,  44},
132  { 125, 173, 178, 239, 194, 135, 206, 117,   6,  19,   2, 144,  79,  46, 114,  51},
133  { 192, 141, 207, 169, 129, 226, 196,  39,  47, 108, 122, 159,  82, 225,  21,  56},
134  { 252,  32,  66, 199,   8, 228,   9,  85,  94, 140,  20, 118,  96, 255, 223, 215},
135  { 250,  11,  33,   0,  26, 249, 166, 185, 232, 158,  98,  76, 217, 145,  80, 210},
136  {  24, 180,   7, 132, 234,  91, 164, 200,  14, 203,  72, 105,  75,  78, 156,  53},
137  {  69,  77,  84, 229,  37,  60,  12,  74, 139,  63, 204, 167, 219, 107, 174, 244},
138  {  45, 243, 124, 109, 157, 181,  38, 116, 242, 147,  83, 176, 240,  17, 237, 131},
139  { 182,   3,  22, 115,  59,  30, 142, 112, 189, 134,  27,  71, 126,  36,  86, 241},
140  { 136,  70, 151, 177, 186, 163, 183,  16,  10, 197,  55, 179, 201,  90,  40, 172},
141  { 220, 134, 119, 215, 166,  17, 251, 244, 186, 146, 145, 100, 131, 241,  51, 239},
142  {  44, 181, 178,  43, 136, 209, 153, 203, 140, 132,  29,  20, 129, 151, 113, 202},
143  { 163, 139,  87,  60, 130, 196,  82,  92,  28, 232, 160,   4, 180, 133,  74, 246},
144  {  84, 182, 223,  12,  26, 142, 222, 224,  57, 252,  32, 155,  36,  78, 169, 152},
145  { 171, 242,  96, 208, 108, 234, 250, 199, 217,   0, 212,  31, 110,  67, 188, 236},
146  { 137, 254, 122,  93,  73, 201,  50, 194, 249, 154, 248, 109,  22, 219,  89, 150},
147  { 233, 205, 230,  70,  66, 143,  10, 193, 204, 185, 101, 176, 210, 198, 172,  30},
148  {  98,  41,  46,  14, 116,  80,   2,  90, 195,  37, 123, 138,  42,  91, 240,   6},
149  {  71, 111, 112, 157, 126,  16, 206,  18,  39, 213,  76,  79, 214, 121,  48, 104},
150  { 117, 125, 228, 237, 128, 106, 144,  55, 162,  94, 118, 170, 197, 127,  61, 175},
151  { 229,  25,  97, 253,  77, 124, 183,  11, 238, 173,  75,  34, 245, 231, 115,  35},
152  { 200,   5, 225, 102, 221, 179,  88, 105,  99,  86,  15, 161,  49, 149,  23,   7},
153  {  40,   1,  45, 226, 147, 190,  69,  21, 174, 120,   3, 135, 164, 184,  56, 207},
154  {   8, 103,   9, 148, 235,  38, 168, 107, 189,  24,  52,  27, 187, 191, 114, 247},
155  {  53,  72, 156,  81,  47,  59,  85, 227, 192, 159, 216, 211, 243, 141, 177, 255},
156  {  62, 220, 134, 119, 215, 166,  17, 251, 244, 186, 146, 145, 100, 131, 241,  51}};
157  int saferp_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
158  {
159     unsigned x, y, z;
160     unsigned char t[33];
161     static const int rounds[3] = { 8, 12, 16 };
162     LTC_ARGCHK(key  != NULL);
163     LTC_ARGCHK(skey != NULL);
164     if (keylen != 16 && keylen != 24 && keylen != 32) {
165        return CRYPT_INVALID_KEYSIZE;
166     }
167     if (num_rounds != 0 && num_rounds != rounds[(keylen/8)-2]) {
168        return CRYPT_INVALID_ROUNDS;
169     }
170     if (keylen == 16) {
171         for (x = y = 0; x < 16; x++) {
172             t[x] = key[x];
173             y ^= key[x];
174         }
175         t[16] = y;
176         for (x = 0; x < 16; x++) {
177             skey->saferp.K[0][x] = t[x];
178         }
179         for (x = 1; x < 17; x++) {
180             for (y = 0; y < 17; y++) {
181                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
182             }
183             z = x;
184             for (y = 0; y < 16; y++) {
185                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
186                 if (++z == 17) { z = 0; }
187             }
188         }
189         skey->saferp.rounds = 8;
190     } else if (keylen == 24) {
191         for (x = y = 0; x < 24; x++) {
192             t[x] = key[x];
193             y ^= key[x];
194         }
195         t[24] = y;
196         for (x = 0; x < 16; x++) {
197             skey->saferp.K[0][x] = t[x];
198         }
199         for (x = 1; x < 25; x++) {
200             for (y = 0; y < 25; y++) {
201                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
202             }
203             z = x;
204             for (y = 0; y < 16; y++) {
205                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
206                 if (++z == 25) { z = 0; }
207             }
208         }
209         skey->saferp.rounds = 12;
210     } else {
211         for (x = y = 0; x < 32; x++) {
212             t[x] = key[x];
213             y ^= key[x];
214         }
215         t[32] = y;
216         for (x = 0; x < 16; x++) {
217             skey->saferp.K[0][x] = t[x];
218         }
219         for (x = 1; x < 33; x++) {
220             for (y = 0; y < 33; y++) {
221                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
222             }
223             z = x;
224             for (y = 0; y < 16; y++) {
225                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
226                 if (++z == 33) { z = 0; }
227             }
228         }
229         skey->saferp.rounds = 16;
230     }
231  #ifdef LTC_CLEAN_STACK
232     zeromem(t, sizeof(t));
233  #endif
234     return CRYPT_OK;
235  }
236  int saferp_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
237  {
238     unsigned char b[16];
239     int x;
240     LTC_ARGCHK(pt   != NULL);
241     LTC_ARGCHK(ct   != NULL);
242     LTC_ARGCHK(skey != NULL);
243     if (skey->saferp.rounds < 8 || skey->saferp.rounds > 16) {
244         return CRYPT_INVALID_ROUNDS;
245     }
246     for (x = 0; x < 16; x++) {
247         b[x] = pt[x];
248     }
<span onclick='openModal()' class='match'>249     ROUND(b,  0);  LT(b, ct);
250     ROUND(ct, 2);  LT(ct, b);
251     ROUND(b,  4);  LT(b, ct);
252     ROUND(ct, 6);  LT(ct, b);
253     ROUND(b,  8);  LT(b, ct);
254     ROUND(ct, 10); LT(ct, b);
</span>255     ROUND(b,  12); LT(b, ct);
256     ROUND(ct, 14); LT(ct, b);
257     if (skey->saferp.rounds > 8) {
258        ROUND(b, 16);  LT(b, ct);
259        ROUND(ct, 18); LT(ct, b);
260        ROUND(b, 20);  LT(b, ct);
261        ROUND(ct, 22); LT(ct, b);
262     }
263     if (skey->saferp.rounds > 12) {
264        ROUND(b, 24);  LT(b, ct);
265        ROUND(ct, 26); LT(ct, b);
266        ROUND(b, 28);  LT(b, ct);
267        ROUND(ct, 30); LT(ct, b);
268     }
269     ct[0] = b[0] ^ skey->saferp.K[skey->saferp.rounds*2][0];
270     ct[1] = (b[1] + skey->saferp.K[skey->saferp.rounds*2][1]) & 255;
271     ct[2] = (b[2] + skey->saferp.K[skey->saferp.rounds*2][2]) & 255;
272     ct[3] = b[3] ^ skey->saferp.K[skey->saferp.rounds*2][3];
273     ct[4] = b[4] ^ skey->saferp.K[skey->saferp.rounds*2][4];
274     ct[5] = (b[5] + skey->saferp.K[skey->saferp.rounds*2][5]) & 255;
275     ct[6] = (b[6] + skey->saferp.K[skey->saferp.rounds*2][6]) & 255;
276     ct[7] = b[7] ^ skey->saferp.K[skey->saferp.rounds*2][7];
277     ct[8] = b[8] ^ skey->saferp.K[skey->saferp.rounds*2][8];
278     ct[9] = (b[9] + skey->saferp.K[skey->saferp.rounds*2][9]) & 255;
279     ct[10] = (b[10] + skey->saferp.K[skey->saferp.rounds*2][10]) & 255;
280     ct[11] = b[11] ^ skey->saferp.K[skey->saferp.rounds*2][11];
281     ct[12] = b[12] ^ skey->saferp.K[skey->saferp.rounds*2][12];
282     ct[13] = (b[13] + skey->saferp.K[skey->saferp.rounds*2][13]) & 255;
283     ct[14] = (b[14] + skey->saferp.K[skey->saferp.rounds*2][14]) & 255;
284     ct[15] = b[15] ^ skey->saferp.K[skey->saferp.rounds*2][15];
285  #ifdef LTC_CLEAN_STACK
286     zeromem(b, sizeof(b));
287  #endif
288     return CRYPT_OK;
289  }
290  int saferp_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
291  {
292     unsigned char b[16];
293     int x;
294     LTC_ARGCHK(pt   != NULL);
295     LTC_ARGCHK(ct   != NULL);
296     LTC_ARGCHK(skey != NULL);
297     if (skey->saferp.rounds < 8 || skey->saferp.rounds > 16) {
298         return CRYPT_INVALID_ROUNDS;
299     }
300     b[0] = ct[0] ^ skey->saferp.K[skey->saferp.rounds*2][0];
301     b[1] = (ct[1] - skey->saferp.K[skey->saferp.rounds*2][1]) & 255;
302     b[2] = (ct[2] - skey->saferp.K[skey->saferp.rounds*2][2]) & 255;
303     b[3] = ct[3] ^ skey->saferp.K[skey->saferp.rounds*2][3];
304     b[4] = ct[4] ^ skey->saferp.K[skey->saferp.rounds*2][4];
305     b[5] = (ct[5] - skey->saferp.K[skey->saferp.rounds*2][5]) & 255;
306     b[6] = (ct[6] - skey->saferp.K[skey->saferp.rounds*2][6]) & 255;
307     b[7] = ct[7] ^ skey->saferp.K[skey->saferp.rounds*2][7];
308     b[8] = ct[8] ^ skey->saferp.K[skey->saferp.rounds*2][8];
309     b[9] = (ct[9] - skey->saferp.K[skey->saferp.rounds*2][9]) & 255;
310     b[10] = (ct[10] - skey->saferp.K[skey->saferp.rounds*2][10]) & 255;
311     b[11] = ct[11] ^ skey->saferp.K[skey->saferp.rounds*2][11];
312     b[12] = ct[12] ^ skey->saferp.K[skey->saferp.rounds*2][12];
313     b[13] = (ct[13] - skey->saferp.K[skey->saferp.rounds*2][13]) & 255;
314     b[14] = (ct[14] - skey->saferp.K[skey->saferp.rounds*2][14]) & 255;
315     b[15] = ct[15] ^ skey->saferp.K[skey->saferp.rounds*2][15];
316     if (skey->saferp.rounds > 12) {
317        iLT(b, pt); iROUND(pt, 30);
318        iLT(pt, b); iROUND(b, 28);
319        iLT(b, pt); iROUND(pt, 26);
320        iLT(pt, b); iROUND(b, 24);
321     }
322     if (skey->saferp.rounds > 8) {
323        iLT(b, pt); iROUND(pt, 22);
324        iLT(pt, b); iROUND(b, 20);
325        iLT(b, pt); iROUND(pt, 18);
326        iLT(pt, b); iROUND(b, 16);
327     }
328     iLT(b, pt); iROUND(pt, 14);
329     iLT(pt, b); iROUND(b, 12);
330     iLT(b, pt); iROUND(pt,10);
331     iLT(pt, b); iROUND(b, 8);
332     iLT(b, pt); iROUND(pt,6);
333     iLT(pt, b); iROUND(b, 4);
334     iLT(b, pt); iROUND(pt,2);
335     iLT(pt, b); iROUND(b, 0);
336     for (x = 0; x < 16; x++) {
337         pt[x] = b[x];
338     }
339  #ifdef LTC_CLEAN_STACK
340     zeromem(b, sizeof(b));
341  #endif
342     return CRYPT_OK;
343  }
344  int saferp_test(void)
345  {
346   #ifndef LTC_TEST
347      return CRYPT_NOP;
348   #else
349     static const struct {
350         int keylen;
351         unsigned char key[32], pt[16], ct[16];
352     } tests[] = {
353         {
354             16,
355             { 41, 35, 190, 132, 225, 108, 214, 174,
356               82, 144, 73, 241, 241, 187, 233, 235 },
357             { 179, 166, 219, 60, 135, 12, 62, 153,
358               36, 94, 13, 28, 6, 183, 71, 222 },
359             { 224, 31, 182, 10, 12, 255, 84, 70,
360               127, 13, 89, 249, 9, 57, 165, 220 }
361         }, {
362             24,
363             { 72, 211, 143, 117, 230, 217, 29, 42,
364               229, 192, 247, 43, 120, 129, 135, 68,
365               14, 95, 80, 0, 212, 97, 141, 190 },
366             { 123, 5, 21, 7, 59, 51, 130, 31,
367               24, 112, 146, 218, 100, 84, 206, 177 },
368             { 92, 136, 4, 63, 57, 95, 100, 0,
369               150, 130, 130, 16, 193, 111, 219, 133 }
370         }, {
371             32,
372             { 243, 168, 141, 254, 190, 242, 235, 113,
373               255, 160, 208, 59, 117, 6, 140, 126,
374               135, 120, 115, 77, 208, 190, 130, 190,
375               219, 194, 70, 65, 43, 140, 250, 48 },
376             { 127, 112, 240, 167, 84, 134, 50, 149,
377               170, 91, 104, 19, 11, 230, 252, 245 },
378             { 88, 11, 25, 36, 172, 229, 202, 213,
379               170, 65, 105, 153, 220, 104, 153, 138 }
380         }
381      };
382     unsigned char tmp[2][16];
383     symmetric_key skey;
384     int err, i, y;
385     for (i = 0; i < (int)(sizeof(tests) / sizeof(tests[0])); i++) {
386        if ((err = saferp_setup(tests[i].key, tests[i].keylen, 0, &skey)) != CRYPT_OK)  {
387           return err;
388        }
389        saferp_ecb_encrypt(tests[i].pt, tmp[0], &skey);
390        saferp_ecb_decrypt(tmp[0], tmp[1], &skey);
391        if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "Safer+ Encrypt", i) ||
392              compare_testvector(tmp[1], 16, tests[i].pt, 16, "Safer+ Decrypt", i)) {
393           return CRYPT_FAIL_TESTVECTOR;
394        }
395        for (y = 0; y < 16; y++) tmp[0][y] = 0;
396        for (y = 0; y < 1000; y++) saferp_ecb_encrypt(tmp[0], tmp[0], &skey);
397        for (y = 0; y < 1000; y++) saferp_ecb_decrypt(tmp[0], tmp[0], &skey);
398        for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
399     }
400     return CRYPT_OK;
401   #endif
402  }
403  void saferp_done(symmetric_key *skey)
404  {
405    LTC_UNUSED_PARAM(skey);
406  }
407  int saferp_keysize(int *keysize)
408  {
409     LTC_ARGCHK(keysize != NULL);
410     if (*keysize < 16) {
411        return CRYPT_INVALID_KEYSIZE;
412     }
413     if (*keysize < 24) {
414        *keysize = 16;
415     } else if (*keysize < 32) {
416        *keysize = 24;
417     } else {
418        *keysize = 32;
419     }
420     return CRYPT_OK;
421  }
422  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-int.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-saferp.c</div>
                </div>
                <div class="column column_space"><pre><code>62  typedef int	(*inject_op_t)(pcap_t *, const void *, int);
63  typedef void	(*save_current_filter_op_t)(pcap_t *, const char *);
64  typedef int	(*setfilter_op_t)(pcap_t *, struct bpf_program *);
65  typedef int	(*setdirection_op_t)(pcap_t *, pcap_direction_t);
66  typedef int	(*set_datalink_op_t)(pcap_t *, int);
67  typedef int	(*getnonblock_op_t)(pcap_t *);
</pre></code></div>
                <div class="column column_space"><pre><code>249     ROUND(b,  0);  LT(b, ct);
250     ROUND(ct, 2);  LT(ct, b);
251     ROUND(b,  4);  LT(b, ct);
252     ROUND(ct, 6);  LT(ct, b);
253     ROUND(b,  8);  LT(b, ct);
254     ROUND(ct, 10); LT(ct, b);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    