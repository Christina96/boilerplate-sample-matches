
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.079365079365079%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-whirl.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_WHIRLPOOL
3  const struct ltc_hash_descriptor whirlpool_desc =
4  {
5      "whirlpool",
6      11,
7      64,
8      64,
9     { 1, 0, 10118, 3, 0, 55 },
10     6,
11      &whirlpool_init,
12      &whirlpool_process,
13      &whirlpool_done,
14      &whirlpool_test,
15      NULL
16  };
17  #define LTC_WHIRLTAB_C
18  #include "whirltab.c"
19  #define GB(a,i,j) ((a[(i) & 7] >> (8 * (j))) & 255)
20  #define theta_pi_gamma(a, i)             \
21     (SB0(GB(a, i-0, 7)) ^                 \
22      SB1(GB(a, i-1, 6)) ^                 \
23      SB2(GB(a, i-2, 5)) ^                 \
24      SB3(GB(a, i-3, 4)) ^                 \
25      SB4(GB(a, i-4, 3)) ^                 \
26      SB5(GB(a, i-5, 2)) ^                 \
27      SB6(GB(a, i-6, 1)) ^                 \
28      SB7(GB(a, i-7, 0)))
29  #ifdef LTC_CLEAN_STACK
30  static int ss_whirlpool_compress(hash_state *md, const unsigned char *buf)
31  #else
32  static int s_whirlpool_compress(hash_state *md, const unsigned char *buf)
33  #endif
34  {
35     ulong64 K[2][8], T[3][8];
36     int x, y;
37     for (x = 0; x < 8; x++) {
38        K[0][x] = md->whirlpool.state[x];
39        LOAD64H(T[0][x], buf + (8 * x));
40        T[2][x]  = T[0][x];
41        T[0][x] ^= K[0][x];
42     }
43     for (x = 0; x < 10; x += 2) {
44         for (y = 0; y < 8; y++) {
45             K[1][y] = theta_pi_gamma(K[0], y);
46         }
47         K[1][0] ^= cont[x];
48         for (y = 0; y < 8; y++) {
49             T[1][y] = theta_pi_gamma(T[0], y) ^ K[1][y];
50         }
51         for (y = 0; y < 8; y++) {
52             K[0][y] = theta_pi_gamma(K[1], y);
53         }
54         K[0][0] ^= cont[x+1];
55         for (y = 0; y < 8; y++) {
56             T[0][y] = theta_pi_gamma(T[1], y) ^ K[0][y];
57         }
58     }
59     for (x = 0; x < 8; x++) {
60        md->whirlpool.state[x] ^= T[0][x] ^ T[2][x];
61     }
62     return CRYPT_OK;
63  }
64  #ifdef LTC_CLEAN_STACK
65  static int s_whirlpool_compress(hash_state *md, const unsigned char *buf)
66  {
67     int err;
68     err = ss_whirlpool_compress(md, buf);
69     burn_stack((5 * 8 * sizeof(ulong64)) + (2 * sizeof(int)));
70     return err;
71  }
72  #endif
73  int whirlpool_init(hash_state * md)
74  {
75     LTC_ARGCHK(md != NULL);
76     zeromem(&md->whirlpool, sizeof(md->whirlpool));
77     return CRYPT_OK;
78  }
79  HASH_PROCESS(whirlpool_process, s_whirlpool_compress, whirlpool, 64)
80  int whirlpool_done(hash_state * md, unsigned char *out)
81  {
82      int i;
83      LTC_ARGCHK(md  != NULL);
84      LTC_ARGCHK(out != NULL);
85      if (md->whirlpool.curlen >= sizeof(md->whirlpool.buf)) {
86         return CRYPT_INVALID_ARG;
87      }
88      md->whirlpool.length += md->whirlpool.curlen * 8;
89      md->whirlpool.buf[md->whirlpool.curlen++] = (unsigned char)0x80;
90      if (md->whirlpool.curlen > 32) {
91          while (md->whirlpool.curlen < 64) {
92              md->whirlpool.buf[md->whirlpool.curlen++] = (unsigned char)0;
93          }
94          s_whirlpool_compress(md, md->whirlpool.buf);
95          md->whirlpool.curlen = 0;
96      }
97      while (md->whirlpool.curlen < 56) {
98          md->whirlpool.buf[md->whirlpool.curlen++] = (unsigned char)0;
99      }
100      STORE64H(md->whirlpool.length, md->whirlpool.buf+56);
101      s_whirlpool_compress(md, md->whirlpool.buf);
102      for (i = 0; i < 8; i++) {
103          STORE64H(md->whirlpool.state[i], out+(8*i));
104      }
105  #ifdef LTC_CLEAN_STACK
106      zeromem(md, sizeof(*md));
107  #endif
108      return CRYPT_OK;
109  }
110  int  whirlpool_test(void)
111  {
112   #ifndef LTC_TEST
113      return CRYPT_NOP;
114   #else
115    static const struct {
116        int len;
117        unsigned char msg[128], hash[64];
118    } tests[] = {
119  {
120    0,
121    { 0x00 },
122    { 0x19, 0xFA, 0x61, 0xD7, 0x55, 0x22, 0xA4, 0x66, 0x9B, 0x44, 0xE3, 0x9C, 0x1D, 0x2E, 0x17, 0x26,
123      0xC5, 0x30, 0x23, 0x21, 0x30, 0xD4, 0x07, 0xF8, 0x9A, 0xFE, 0xE0, 0x96, 0x49, 0x97, 0xF7, 0xA7,
124      0x3E, 0x83, 0xBE, 0x69, 0x8B, 0x28, 0x8F, 0xEB, 0xCF, 0x88, 0xE3, 0xE0, 0x3C, 0x4F, 0x07, 0x57,
125      0xEA, 0x89, 0x64, 0xE5, 0x9B, 0x63, 0xD9, 0x37, 0x08, 0xB1, 0x38, 0xCC, 0x42, 0xA6, 0x6E, 0xB3 }
126  },
127  {
128    56,
129    { 0x00 },
130    { 0x0B, 0x3F, 0x53, 0x78, 0xEB, 0xED, 0x2B, 0xF4, 0xD7, 0xBE, 0x3C, 0xFD, 0x81, 0x8C, 0x1B, 0x03,
131      0xB6, 0xBB, 0x03, 0xD3, 0x46, 0x94, 0x8B, 0x04, 0xF4, 0xF4, 0x0C, 0x72, 0x6F, 0x07, 0x58, 0x70,
132      0x2A, 0x0F, 0x1E, 0x22, 0x58, 0x80, 0xE3, 0x8D, 0xD5, 0xF6, 0xED, 0x6D, 0xE9, 0xB1, 0xE9, 0x61,
133      0xE4, 0x9F, 0xC1, 0x31, 0x8D, 0x7C, 0xB7, 0x48, 0x22, 0xF3, 0xD0, 0xE2, 0xE9, 0xA7, 0xE7, 0xB0 }
134  },
135  {
136    65,
137    { 0x00 },
138    { 0x85, 0xE1, 0x24, 0xC4, 0x41, 0x5B, 0xCF, 0x43, 0x19, 0x54, 0x3E, 0x3A, 0x63, 0xFF, 0x57, 0x1D,
139      0x09, 0x35, 0x4C, 0xEE, 0xBE, 0xE1, 0xE3, 0x25, 0x30, 0x8C, 0x90, 0x69, 0xF4, 0x3E, 0x2A, 0xE4,
140      0xD0, 0xE5, 0x1D, 0x4E, 0xB1, 0xE8, 0x64, 0x28, 0x70, 0x19, 0x4E, 0x95, 0x30, 0xD8, 0xD8, 0xAF,
141      0x65, 0x89, 0xD1, 0xBF, 0x69, 0x49, 0xDD, 0xF9, 0x0A, 0x7F, 0x12, 0x08, 0x62, 0x37, 0x95, 0xB9 }
142  },
143  {
144    64,
145    { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
146      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
147      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
148      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
149    { 0x10, 0x3E, 0x00, 0x55, 0xA9, 0xB0, 0x90, 0xE1, 0x1C, 0x8F, 0xDD, 0xEB, 0xBA, 0x06, 0xC0, 0x5A,
150      0xCE, 0x8B, 0x64, 0xB8, 0x96, 0x12, 0x8F, 0x6E, 0xED, 0x30, 0x71, 0xFC, 0xF3, 0xDC, 0x16, 0x94,
151      0x67, 0x78, 0xE0, 0x72, 0x23, 0x23, 0x3F, 0xD1, 0x80, 0xFC, 0x40, 0xCC, 0xDB, 0x84, 0x30, 0xA6,
152      0x40, 0xE3, 0x76, 0x34, 0x27, 0x1E, 0x65, 0x5C, 0xA1, 0x67, 0x4E, 0xBF, 0xF5, 0x07, 0xF8, 0xCB }
153  },
154  {
155    64,
156    { 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
157      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
158      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
159      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
160    { 0x35, 0x7B, 0x42, 0xEA, 0x79, 0xBC, 0x97, 0x86, 0x97, 0x5A, 0x3C, 0x44, 0x70, 0xAA, 0xB2, 0x3E,
161      0x62, 0x29, 0x79, 0x7B, 0xAD, 0xBD, 0x54, 0x36, 0x5B, 0x54, 0x96, 0xE5, 0x5D, 0x9D, 0xD7, 0x9F,
162      0xE9, 0x62, 0x4F, 0xB4, 0x22, 0x66, 0x93, 0x0A, 0x62, 0x8E, 0xD4, 0xDB, 0x08, 0xF9, 0xDD, 0x35,
163      0xEF, 0x1B, 0xE1, 0x04, 0x53, 0xFC, 0x18, 0xF4, 0x2C, 0x7F, 0x5E, 0x1F, 0x9B, 0xAE, 0x55, 0xE0 }
164  },
165  {
166    64,
167    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
168      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
169      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
170      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
171    { 0x8B, 0x39, 0x04, 0xDD, 0x19, 0x81, 0x41, 0x26, 0xFD, 0x02, 0x74, 0xAB, 0x49, 0xC5, 0x97, 0xF6,
172      0xD7, 0x75, 0x33, 0x52, 0xA2, 0xDD, 0x91, 0xFD, 0x8F, 0x9F, 0x54, 0x05, 0x4C, 0x54, 0xBF, 0x0F,
173      0x06, 0xDB, 0x4F, 0xF7, 0x08, 0xA3, 0xA2, 0x8B, 0xC3, 0x7A, 0x92, 0x1E, 0xEE, 0x11, 0xED, 0x7B,
174      0x6A, 0x53, 0x79, 0x32, 0xCC, 0x5E, 0x94, 0xEE, 0x1E, 0xA6, 0x57, 0x60, 0x7E, 0x36, 0xC9, 0xF7 }
175  },
176  };
177    int i;
178    unsigned char tmp[64];
179    hash_state md;
<span onclick='openModal()' class='match'>180    for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
181        whirlpool_init(&md);
182        whirlpool_process(&md, (unsigned char *)tests[i].msg, tests[i].len);
183        whirlpool_done(&md, tmp);
184        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "WHIRLPOOL", i)) {
185           return CRYPT_FAIL_TESTVECTOR;
186        }
</span>187    }
188    return CRYPT_OK;
189   #endif
190  }
191  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_inlines_b.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_ARENA_INLINES_B_H
2  #define JEMALLOC_INTERNAL_ARENA_INLINES_B_H
3  #include "jemalloc/internal/jemalloc_internal_types.h"
4  #include "jemalloc/internal/mutex.h"
5  #include "jemalloc/internal/rtree.h"
6  #include "jemalloc/internal/sc.h"
7  #include "jemalloc/internal/sz.h"
8  #include "jemalloc/internal/ticker.h"
9  JEMALLOC_ALWAYS_INLINE bool
10  arena_has_default_hooks(arena_t *arena) {
11  	return (extent_hooks_get(arena) == &extent_hooks_default);
12  }
13  JEMALLOC_ALWAYS_INLINE arena_t *
14  arena_choose_maybe_huge(tsd_t *tsd, arena_t *arena, size_t size) {
15  	if (arena != NULL) {
16  		return arena;
17  	}
18  	if (unlikely(size >= oversize_threshold)) {
19  		arena_t *tsd_arena = tsd_arena_get(tsd);
20  		if (tsd_arena == NULL || arena_is_auto(tsd_arena)) {
21  			return arena_choose_huge(tsd);
22  		}
23  	}
24  	return arena_choose(tsd, NULL);
25  }
26  JEMALLOC_ALWAYS_INLINE prof_tctx_t *
27  arena_prof_tctx_get(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx) {
28  	cassert(config_prof);
29  	assert(ptr != NULL);
30  	if (alloc_ctx == NULL) {
31  		const extent_t *extent = iealloc(tsdn, ptr);
32  		if (unlikely(!extent_slab_get(extent))) {
33  			return large_prof_tctx_get(tsdn, extent);
34  		}
35  	} else {
36  		if (unlikely(!alloc_ctx->slab)) {
37  			return large_prof_tctx_get(tsdn, iealloc(tsdn, ptr));
38  		}
39  	}
40  	return (prof_tctx_t *)(uintptr_t)1U;
41  }
42  JEMALLOC_ALWAYS_INLINE void
43  arena_prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize,
44      alloc_ctx_t *alloc_ctx, prof_tctx_t *tctx) {
45  	cassert(config_prof);
46  	assert(ptr != NULL);
47  	if (alloc_ctx == NULL) {
48  		extent_t *extent = iealloc(tsdn, ptr);
49  		if (unlikely(!extent_slab_get(extent))) {
50  			large_prof_tctx_set(tsdn, extent, tctx);
51  		}
52  	} else {
53  		if (unlikely(!alloc_ctx->slab)) {
54  			large_prof_tctx_set(tsdn, iealloc(tsdn, ptr), tctx);
55  		}
56  	}
57  }
58  static inline void
59  arena_prof_tctx_reset(tsdn_t *tsdn, const void *ptr, prof_tctx_t *tctx) {
60  	cassert(config_prof);
61  	assert(ptr != NULL);
62  	extent_t *extent = iealloc(tsdn, ptr);
63  	assert(!extent_slab_get(extent));
64  	large_prof_tctx_reset(tsdn, extent);
65  }
66  JEMALLOC_ALWAYS_INLINE nstime_t
67  arena_prof_alloc_time_get(tsdn_t *tsdn, const void *ptr,
68      alloc_ctx_t *alloc_ctx) {
69  	cassert(config_prof);
70  	assert(ptr != NULL);
71  	extent_t *extent = iealloc(tsdn, ptr);
72  	assert(!extent_slab_get(extent));
73  	return large_prof_alloc_time_get(extent);
74  }
75  JEMALLOC_ALWAYS_INLINE void
76  arena_prof_alloc_time_set(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx,
77      nstime_t t) {
78  	cassert(config_prof);
79  	assert(ptr != NULL);
80  	extent_t *extent = iealloc(tsdn, ptr);
81  	assert(!extent_slab_get(extent));
82  	large_prof_alloc_time_set(extent, t);
83  }
84  JEMALLOC_ALWAYS_INLINE void
85  arena_decay_ticks(tsdn_t *tsdn, arena_t *arena, unsigned nticks) {
86  	tsd_t *tsd;
87  	ticker_t *decay_ticker;
88  	if (unlikely(tsdn_null(tsdn))) {
89  		return;
90  	}
91  	tsd = tsdn_tsd(tsdn);
92  	decay_ticker = decay_ticker_get(tsd, arena_ind_get(arena));
93  	if (unlikely(decay_ticker == NULL)) {
94  		return;
95  	}
96  	if (unlikely(ticker_ticks(decay_ticker, nticks))) {
97  		arena_decay(tsdn, arena, false, false);
98  	}
99  }
100  JEMALLOC_ALWAYS_INLINE void
101  arena_decay_tick(tsdn_t *tsdn, arena_t *arena) {
102  	malloc_mutex_assert_not_owner(tsdn, &arena->decay_dirty.mtx);
103  	malloc_mutex_assert_not_owner(tsdn, &arena->decay_muzzy.mtx);
104  	arena_decay_ticks(tsdn, arena, 1);
105  }
106  JEMALLOC_ALWAYS_INLINE void
107  arena_decay_extent(tsdn_t *tsdn,arena_t *arena, extent_hooks_t **r_extent_hooks,
108      extent_t *extent) {
109  	size_t extent_size = extent_size_get(extent);
110  	extent_dalloc_wrapper(tsdn, arena,
111  	    r_extent_hooks, extent);
112  	if (config_stats) {
113  		arena_stats_lock(tsdn, &arena->stats);
114  		arena_stats_add_u64(tsdn, &arena->stats,
115  		    &arena->decay_dirty.stats->nmadvise, 1);
116  		arena_stats_add_u64(tsdn, &arena->stats,
117  		    &arena->decay_dirty.stats->purged, extent_size >> LG_PAGE);
118  		arena_stats_sub_zu(tsdn, &arena->stats, &arena->stats.mapped,
119  		    extent_size);
120  		arena_stats_unlock(tsdn, &arena->stats);
121  	}
122  }
123  JEMALLOC_ALWAYS_INLINE void *
124  arena_malloc(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind, bool zero,
125      tcache_t *tcache, bool slow_path) {
126  	assert(!tsdn_null(tsdn) || tcache == NULL);
127  	if (likely(tcache != NULL)) {
128  		if (likely(size <= SC_SMALL_MAXCLASS)) {
129  			return tcache_alloc_small(tsdn_tsd(tsdn), arena,
130  			    tcache, size, ind, zero, slow_path);
131  		}
132  		if (likely(size <= tcache_maxclass)) {
133  			return tcache_alloc_large(tsdn_tsd(tsdn), arena,
134  			    tcache, size, ind, zero, slow_path);
135  		}
136  		assert(size > tcache_maxclass);
137  	}
138  	return arena_malloc_hard(tsdn, arena, size, ind, zero);
139  }
140  JEMALLOC_ALWAYS_INLINE arena_t *
141  arena_aalloc(tsdn_t *tsdn, const void *ptr) {
142  	return extent_arena_get(iealloc(tsdn, ptr));
143  }
144  JEMALLOC_ALWAYS_INLINE size_t
145  arena_salloc(tsdn_t *tsdn, const void *ptr) {
146  	assert(ptr != NULL);
147  	rtree_ctx_t rtree_ctx_fallback;
148  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
149  	szind_t szind = rtree_szind_read(tsdn, &extents_rtree, rtree_ctx,
150  	    (uintptr_t)ptr, true);
151  	assert(szind != SC_NSIZES);
152  	return sz_index2size(szind);
153  }
154  JEMALLOC_ALWAYS_INLINE size_t
155  arena_vsalloc(tsdn_t *tsdn, const void *ptr) {
156  	rtree_ctx_t rtree_ctx_fallback;
<span onclick='openModal()' class='match'>157  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
158  	extent_t *extent;
159  	szind_t szind;
160  	if (rtree_extent_szind_read(tsdn, &extents_rtree, rtree_ctx,
161  	    (uintptr_t)ptr, false, &extent, &szind)) {
162  		return 0;
163  	}
</span>164  	if (extent == NULL) {
165  		return 0;
166  	}
167  	assert(extent_state_get(extent) == extent_state_active);
168  	assert(extent_addr_get(extent) == ptr || extent_slab_get(extent));
169  	assert(szind != SC_NSIZES);
170  	return sz_index2size(szind);
171  }
172  static inline void
173  arena_dalloc_large_no_tcache(tsdn_t *tsdn, void *ptr, szind_t szind) {
174  	if (config_prof && unlikely(szind < SC_NBINS)) {
175  		arena_dalloc_promoted(tsdn, ptr, NULL, true);
176  	} else {
177  		extent_t *extent = iealloc(tsdn, ptr);
178  		large_dalloc(tsdn, extent);
179  	}
180  }
181  static inline void
182  arena_dalloc_no_tcache(tsdn_t *tsdn, void *ptr) {
183  	assert(ptr != NULL);
184  	rtree_ctx_t rtree_ctx_fallback;
185  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
186  	szind_t szind;
187  	bool slab;
188  	rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx, (uintptr_t)ptr,
189  	    true, &szind, &slab);
190  	if (config_debug) {
191  		extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
192  		    rtree_ctx, (uintptr_t)ptr, true);
193  		assert(szind == extent_szind_get(extent));
194  		assert(szind < SC_NSIZES);
195  		assert(slab == extent_slab_get(extent));
196  	}
197  	if (likely(slab)) {
198  		arena_dalloc_small(tsdn, ptr);
199  	} else {
200  		arena_dalloc_large_no_tcache(tsdn, ptr, szind);
201  	}
202  }
203  JEMALLOC_ALWAYS_INLINE void
204  arena_dalloc_large(tsdn_t *tsdn, void *ptr, tcache_t *tcache, szind_t szind,
205      bool slow_path) {
206  	if (szind < nhbins) {
207  		if (config_prof && unlikely(szind < SC_NBINS)) {
208  			arena_dalloc_promoted(tsdn, ptr, tcache, slow_path);
209  		} else {
210  			tcache_dalloc_large(tsdn_tsd(tsdn), tcache, ptr, szind,
211  			    slow_path);
212  		}
213  	} else {
214  		extent_t *extent = iealloc(tsdn, ptr);
215  		large_dalloc(tsdn, extent);
216  	}
217  }
218  JEMALLOC_ALWAYS_INLINE void
219  arena_dalloc(tsdn_t *tsdn, void *ptr, tcache_t *tcache,
220      alloc_ctx_t *alloc_ctx, bool slow_path) {
221  	assert(!tsdn_null(tsdn) || tcache == NULL);
222  	assert(ptr != NULL);
223  	if (unlikely(tcache == NULL)) {
224  		arena_dalloc_no_tcache(tsdn, ptr);
225  		return;
226  	}
227  	szind_t szind;
228  	bool slab;
229  	rtree_ctx_t *rtree_ctx;
230  	if (alloc_ctx != NULL) {
231  		szind = alloc_ctx->szind;
232  		slab = alloc_ctx->slab;
233  		assert(szind != SC_NSIZES);
234  	} else {
235  		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
236  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
237  		    (uintptr_t)ptr, true, &szind, &slab);
238  	}
239  	if (config_debug) {
240  		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
241  		extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
242  		    rtree_ctx, (uintptr_t)ptr, true);
243  		assert(szind == extent_szind_get(extent));
244  		assert(szind < SC_NSIZES);
245  		assert(slab == extent_slab_get(extent));
246  	}
247  	if (likely(slab)) {
248  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,
249  		    slow_path);
250  	} else {
251  		arena_dalloc_large(tsdn, ptr, tcache, szind, slow_path);
252  	}
253  }
254  static inline void
255  arena_sdalloc_no_tcache(tsdn_t *tsdn, void *ptr, size_t size) {
256  	assert(ptr != NULL);
257  	assert(size <= SC_LARGE_MAXCLASS);
258  	szind_t szind;
259  	bool slab;
260  	if (!config_prof || !opt_prof) {
261  		szind = sz_size2index(size);
262  		slab = (szind < SC_NBINS);
263  	}
264  	if ((config_prof && opt_prof) || config_debug) {
265  		rtree_ctx_t rtree_ctx_fallback;
266  		rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,
267  		    &rtree_ctx_fallback);
268  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
269  		    (uintptr_t)ptr, true, &szind, &slab);
270  		assert(szind == sz_size2index(size));
271  		assert((config_prof && opt_prof) || slab == (szind < SC_NBINS));
272  		if (config_debug) {
273  			extent_t *extent = rtree_extent_read(tsdn,
274  			    &extents_rtree, rtree_ctx, (uintptr_t)ptr, true);
275  			assert(szind == extent_szind_get(extent));
276  			assert(slab == extent_slab_get(extent));
277  		}
278  	}
279  	if (likely(slab)) {
280  		arena_dalloc_small(tsdn, ptr);
281  	} else {
282  		arena_dalloc_large_no_tcache(tsdn, ptr, szind);
283  	}
284  }
285  JEMALLOC_ALWAYS_INLINE void
286  arena_sdalloc(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
287      alloc_ctx_t *alloc_ctx, bool slow_path) {
288  	assert(!tsdn_null(tsdn) || tcache == NULL);
289  	assert(ptr != NULL);
290  	assert(size <= SC_LARGE_MAXCLASS);
291  	if (unlikely(tcache == NULL)) {
292  		arena_sdalloc_no_tcache(tsdn, ptr, size);
293  		return;
294  	}
295  	szind_t szind;
296  	bool slab;
297  	alloc_ctx_t local_ctx;
298  	if (config_prof && opt_prof) {
299  		if (alloc_ctx == NULL) {
300  			rtree_ctx_t rtree_ctx_fallback;
301  			rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,
302  			    &rtree_ctx_fallback);
303  			rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
304  			    (uintptr_t)ptr, true, &local_ctx.szind,
305  			    &local_ctx.slab);
306  			assert(local_ctx.szind == sz_size2index(size));
307  			alloc_ctx = &local_ctx;
308  		}
309  		slab = alloc_ctx->slab;
310  		szind = alloc_ctx->szind;
311  	} else {
312  		szind = sz_size2index(size);
313  		slab = (szind < SC_NBINS);
314  	}
315  	if (config_debug) {
316  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
317  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
318  		    (uintptr_t)ptr, true, &szind, &slab);
319  		extent_t *extent = rtree_extent_read(tsdn,
320  		    &extents_rtree, rtree_ctx, (uintptr_t)ptr, true);
321  		assert(szind == extent_szind_get(extent));
322  		assert(slab == extent_slab_get(extent));
323  	}
324  	if (likely(slab)) {
325  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,
326  		    slow_path);
327  	} else {
328  		arena_dalloc_large(tsdn, ptr, tcache, szind, slow_path);
329  	}
330  }
331  #endif &bsol;* JEMALLOC_INTERNAL_ARENA_INLINES_B_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-whirl.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_inlines_b.h</div>
                </div>
                <div class="column column_space"><pre><code>180    for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
181        whirlpool_init(&md);
182        whirlpool_process(&md, (unsigned char *)tests[i].msg, tests[i].len);
183        whirlpool_done(&md, tmp);
184        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "WHIRLPOOL", i)) {
185           return CRYPT_FAIL_TESTVECTOR;
186        }
</pre></code></div>
                <div class="column column_space"><pre><code>157  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
158  	extent_t *extent;
159  	szind_t szind;
160  	if (rtree_extent_szind_read(tsdn, &extents_rtree, rtree_ctx,
161  	    (uintptr_t)ptr, false, &extent, &szind)) {
162  		return 0;
163  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    