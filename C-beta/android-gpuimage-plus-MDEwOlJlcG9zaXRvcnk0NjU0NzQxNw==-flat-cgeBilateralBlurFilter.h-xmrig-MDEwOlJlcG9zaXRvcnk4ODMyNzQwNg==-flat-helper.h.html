
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.736842105263158%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeBilateralBlurFilter.h</h3>
            <pre><code>1  &bsol;*
2   * cgeBilateralBlurFilter.h
3   *
4   *  Created on: 2014-4-1
5   *      Author: Wang Yang
6   */
7  #ifndef _CGE_BLIATERALBLUR_H_
8  #define _CGE_BLIATERALBLUR_H_
9  #include "cgeAdvancedEffectsCommon.h"
10  namespace CGE
11  {
12  class CGEBilateralBlurFilter : public CGEAdvancedEffectTwoStepFilterHelper
13  {
14  public:
15      CGEBilateralBlurFilter() {}
16      ~CGEBilateralBlurFilter() {}
<span onclick='openModal()' class='match'>17      bool init();
18      virtual void setBlurScale(float value);
19      void setDistanceNormalizationFactor(float value);
20  protected:
21      static CGEConstString paramDistanceFactorName;
22      static CGEConstString paramBlurSamplerScaleName;
23      static CGEConstString paramBlurFactorsName;
</span>24  };
25  class CGEBilateralBlurBetterFilter : public CGEBilateralBlurFilter
26  {
27  public:
28      bool init();
29      void setSamplerRadiusLimit(int limit);
30      virtual void setBlurScale(float value);
31  protected:
32      static CGEConstString paramBlurRadiusName;
33      int m_limit;
34  };
35  class CGEBilateralWrapperFilter : public CGEImageFilterInterface
36  {
37  public:
38      CGEBilateralWrapperFilter() :
39          m_repeatTimes(1) {}
40      ~CGEBilateralWrapperFilter() { delete m_proc; }
41      bool init();
42      void render2Texture(CGEImageHandlerInterface* handler, GLuint srcTexture, GLuint vertexBufferID);
43      void setBlurScale(float value)
44      {
45          m_blurScale = value;
46      }
47      void setDistanceNormalizationFactor(float value)
48      {
49          m_proc->setDistanceNormalizationFactor(value);
50      }
51      void setRepeatTimes(int n)
52      {
53          m_repeatTimes = n;
54      }
55      CGEBilateralBlurFilter* m_proc;
56      float m_blurScale;
57      int m_repeatTimes;
58  };
59  } 
60  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-helper.h</h3>
            <pre><code>1  #ifndef HWLOC_HELPER_H
2  #define HWLOC_HELPER_H
3  #ifndef HWLOC_H
4  #error Please include the main hwloc.h instead
5  #endif
6  #include <stdlib.h>
7  #include <errno.h>
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
11  static __hwloc_inline hwloc_obj_t
12  hwloc_get_first_largest_obj_inside_cpuset(hwloc_topology_t topology, hwloc_const_cpuset_t set)
13  {
14    hwloc_obj_t obj = hwloc_get_root_obj(topology);
15    if (!hwloc_bitmap_intersects(obj->cpuset, set))
16      return NULL;
17    while (!hwloc_bitmap_isincluded(obj->cpuset, set)) {
18      hwloc_obj_t child = obj->first_child;
19      while (child) {
20        if (hwloc_bitmap_intersects(child->cpuset, set))
21  	break;
22        child = child->next_sibling;
23      }
24      if (!child)
25        return obj;
26      obj = child;
27    }
28    return obj;
29  }
30  HWLOC_DECLSPEC int hwloc_get_largest_objs_inside_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set,
31  						 hwloc_obj_t * __hwloc_restrict objs, int max);
32  static __hwloc_inline hwloc_obj_t
33  hwloc_get_next_obj_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
34  					   int depth, hwloc_obj_t prev)
35  {
36    hwloc_obj_t next = hwloc_get_next_obj_by_depth(topology, depth, prev);
37    if (!next)
38      return NULL;
39    while (next && (hwloc_bitmap_iszero(next->cpuset) || !hwloc_bitmap_isincluded(next->cpuset, set)))
40      next = next->next_cousin;
41    return next;
42  }
43  static __hwloc_inline hwloc_obj_t
44  hwloc_get_next_obj_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
45  					  hwloc_obj_type_t type, hwloc_obj_t prev)
46  {
47    int depth = hwloc_get_type_depth(topology, type);
48    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
49      return NULL;
50    return hwloc_get_next_obj_inside_cpuset_by_depth(topology, set, depth, prev);
51  }
52  static __hwloc_inline hwloc_obj_t
53  hwloc_get_obj_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
54  				      int depth, unsigned idx) __hwloc_attribute_pure;
55  static __hwloc_inline hwloc_obj_t
56  hwloc_get_obj_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
57  				      int depth, unsigned idx)
58  {
59    hwloc_obj_t obj = hwloc_get_obj_by_depth (topology, depth, 0);
60    unsigned count = 0;
61    if (!obj)
62      return NULL;
63    while (obj) {
64      if (!hwloc_bitmap_iszero(obj->cpuset) && hwloc_bitmap_isincluded(obj->cpuset, set)) {
65        if (count == idx)
66  	return obj;
67        count++;
68      }
69      obj = obj->next_cousin;
70    }
71    return NULL;
72  }
73  static __hwloc_inline hwloc_obj_t
74  hwloc_get_obj_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
75  				     hwloc_obj_type_t type, unsigned idx) __hwloc_attribute_pure;
76  static __hwloc_inline hwloc_obj_t
77  hwloc_get_obj_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
78  				     hwloc_obj_type_t type, unsigned idx)
79  {
80    int depth = hwloc_get_type_depth(topology, type);
81    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
82      return NULL;
83    return hwloc_get_obj_inside_cpuset_by_depth(topology, set, depth, idx);
84  }
85  static __hwloc_inline unsigned
86  hwloc_get_nbobjs_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
87  					 int depth) __hwloc_attribute_pure;
88  static __hwloc_inline unsigned
89  hwloc_get_nbobjs_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
90  					 int depth)
91  {
92    hwloc_obj_t obj = hwloc_get_obj_by_depth (topology, depth, 0);
93    unsigned count = 0;
94    if (!obj)
95      return 0;
96    while (obj) {
97      if (!hwloc_bitmap_iszero(obj->cpuset) && hwloc_bitmap_isincluded(obj->cpuset, set))
98        count++;
99      obj = obj->next_cousin;
100    }
101    return count;
102  }
103  static __hwloc_inline int
104  hwloc_get_nbobjs_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
105  					hwloc_obj_type_t type) __hwloc_attribute_pure;
106  static __hwloc_inline int
107  hwloc_get_nbobjs_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
108  					hwloc_obj_type_t type)
109  {
110    int depth = hwloc_get_type_depth(topology, type);
111    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN)
112      return 0;
113    if (depth == HWLOC_TYPE_DEPTH_MULTIPLE)
114      return -1; &bsol;* FIXME: agregate nbobjs from different levels? */
115    return (int) hwloc_get_nbobjs_inside_cpuset_by_depth(topology, set, depth);
116  }
117  static __hwloc_inline int
118  hwloc_get_obj_index_inside_cpuset (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_cpuset_t set,
119  				   hwloc_obj_t obj) __hwloc_attribute_pure;
120  static __hwloc_inline int
121  hwloc_get_obj_index_inside_cpuset (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_cpuset_t set,
122  				   hwloc_obj_t obj)
123  {
124    int idx = 0;
125    if (!hwloc_bitmap_isincluded(obj->cpuset, set))
126      return -1;
127    while ((obj = obj->prev_cousin) != NULL)
128      if (!hwloc_bitmap_iszero(obj->cpuset) && hwloc_bitmap_isincluded(obj->cpuset, set))
129        idx++;
130    return idx;
131  }
132  static __hwloc_inline hwloc_obj_t
133  hwloc_get_child_covering_cpuset (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_cpuset_t set,
134  				hwloc_obj_t parent) __hwloc_attribute_pure;
135  static __hwloc_inline hwloc_obj_t
136  hwloc_get_child_covering_cpuset (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_cpuset_t set,
137  				hwloc_obj_t parent)
138  {
139    hwloc_obj_t child;
140    if (hwloc_bitmap_iszero(set))
141      return NULL;
142    child = parent->first_child;
143    while (child) {
144      if (child->cpuset && hwloc_bitmap_isincluded(set, child->cpuset))
145        return child;
146      child = child->next_sibling;
147    }
148    return NULL;
149  }
150  static __hwloc_inline hwloc_obj_t
151  hwloc_get_obj_covering_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set) __hwloc_attribute_pure;
152  static __hwloc_inline hwloc_obj_t
153  hwloc_get_obj_covering_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set)
154  {
155    struct hwloc_obj *current = hwloc_get_root_obj(topology);
156    if (hwloc_bitmap_iszero(set) || !hwloc_bitmap_isincluded(set, current->cpuset))
157      return NULL;
158    while (1) {
159      hwloc_obj_t child = hwloc_get_child_covering_cpuset(topology, set, current);
160      if (!child)
161        return current;
162      current = child;
163    }
164  }
165  static __hwloc_inline hwloc_obj_t
166  hwloc_get_next_obj_covering_cpuset_by_depth(hwloc_topology_t topology, hwloc_const_cpuset_t set,
167  					    int depth, hwloc_obj_t prev)
168  {
169    hwloc_obj_t next = hwloc_get_next_obj_by_depth(topology, depth, prev);
170    if (!next)
171      return NULL;
172    while (next && !hwloc_bitmap_intersects(set, next->cpuset))
173      next = next->next_cousin;
174    return next;
175  }
176  static __hwloc_inline hwloc_obj_t
177  hwloc_get_next_obj_covering_cpuset_by_type(hwloc_topology_t topology, hwloc_const_cpuset_t set,
178  					   hwloc_obj_type_t type, hwloc_obj_t prev)
179  {
180    int depth = hwloc_get_type_depth(topology, type);
181    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
182      return NULL;
183    return hwloc_get_next_obj_covering_cpuset_by_depth(topology, set, depth, prev);
184  }
185  static __hwloc_inline hwloc_obj_t
186  hwloc_get_ancestor_obj_by_depth (hwloc_topology_t topology __hwloc_attribute_unused, int depth, hwloc_obj_t obj) __hwloc_attribute_pure;
187  static __hwloc_inline hwloc_obj_t
188  hwloc_get_ancestor_obj_by_depth (hwloc_topology_t topology __hwloc_attribute_unused, int depth, hwloc_obj_t obj)
189  {
190    hwloc_obj_t ancestor = obj;
191    if (obj->depth < depth)
192      return NULL;
193    while (ancestor && ancestor->depth > depth)
194      ancestor = ancestor->parent;
195    return ancestor;
196  }
197  static __hwloc_inline hwloc_obj_t
198  hwloc_get_ancestor_obj_by_type (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_type_t type, hwloc_obj_t obj) __hwloc_attribute_pure;
199  static __hwloc_inline hwloc_obj_t
200  hwloc_get_ancestor_obj_by_type (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_type_t type, hwloc_obj_t obj)
201  {
202    hwloc_obj_t ancestor = obj->parent;
203    while (ancestor && ancestor->type != type)
204      ancestor = ancestor->parent;
205    return ancestor;
206  }
207  static __hwloc_inline hwloc_obj_t
208  hwloc_get_common_ancestor_obj (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj1, hwloc_obj_t obj2) __hwloc_attribute_pure;
209  static __hwloc_inline hwloc_obj_t
210  hwloc_get_common_ancestor_obj (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj1, hwloc_obj_t obj2)
211  {
212    while (obj1 != obj2) {
213      while (obj1->depth > obj2->depth)
214        obj1 = obj1->parent;
215      while (obj2->depth > obj1->depth)
216        obj2 = obj2->parent;
217      if (obj1 != obj2 && obj1->depth == obj2->depth) {
218        obj1 = obj1->parent;
219        obj2 = obj2->parent;
220      }
221    }
222    return obj1;
223  }
224  static __hwloc_inline int
225  hwloc_obj_is_in_subtree (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj, hwloc_obj_t subtree_root) __hwloc_attribute_pure;
226  static __hwloc_inline int
227  hwloc_obj_is_in_subtree (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj, hwloc_obj_t subtree_root)
228  {
229    return obj->cpuset && subtree_root->cpuset && hwloc_bitmap_isincluded(obj->cpuset, subtree_root->cpuset);
230  }
231  static __hwloc_inline hwloc_obj_t
232  hwloc_get_next_child (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t parent, hwloc_obj_t prev)
233  {
234    hwloc_obj_t obj;
235    int state = 0;
236    if (prev) {
237      if (prev->type == HWLOC_OBJ_MISC)
238        state = 3;
239      else if (prev->type == HWLOC_OBJ_BRIDGE || prev->type == HWLOC_OBJ_PCI_DEVICE || prev->type == HWLOC_OBJ_OS_DEVICE)
240        state = 2;
241      else if (prev->type == HWLOC_OBJ_NUMANODE)
242        state = 1;
243      obj = prev->next_sibling;
244    } else {
245      obj = parent->first_child;
246    }
247    if (!obj && state == 0) {
248      obj = parent->memory_first_child;
249      state = 1;
250    }
251    if (!obj && state == 1) {
252      obj = parent->io_first_child;
253      state = 2;
254    }
255    if (!obj && state == 2) {
256      obj = parent->misc_first_child;
257      state = 3;
258    }
259    return obj;
260  }
261  HWLOC_DECLSPEC int
262  hwloc_obj_type_is_normal(hwloc_obj_type_t type);
263  HWLOC_DECLSPEC int
264  hwloc_obj_type_is_io(hwloc_obj_type_t type);
265  HWLOC_DECLSPEC int
266  hwloc_obj_type_is_memory(hwloc_obj_type_t type);
267  HWLOC_DECLSPEC int
268  hwloc_obj_type_is_cache(hwloc_obj_type_t type);
269  HWLOC_DECLSPEC int
270  hwloc_obj_type_is_dcache(hwloc_obj_type_t type);
271  HWLOC_DECLSPEC int
272  hwloc_obj_type_is_icache(hwloc_obj_type_t type);
273  static __hwloc_inline int
274  hwloc_get_cache_type_depth (hwloc_topology_t topology,
275  			    unsigned cachelevel, hwloc_obj_cache_type_t cachetype)
276  {
277    int depth;
278    int found = HWLOC_TYPE_DEPTH_UNKNOWN;
279    for (depth=0; ; depth++) {
280      hwloc_obj_t obj = hwloc_get_obj_by_depth(topology, depth, 0);
281      if (!obj)
282        break;
283      if (!hwloc_obj_type_is_dcache(obj->type) || obj->attr->cache.depth != cachelevel)
284        continue;
285      if (cachetype == (hwloc_obj_cache_type_t) -1) {
286        if (found != HWLOC_TYPE_DEPTH_UNKNOWN) {
287          return HWLOC_TYPE_DEPTH_MULTIPLE;
288        }
289        found = depth;
290        continue;
291      }
292      if (obj->attr->cache.type == cachetype || obj->attr->cache.type == HWLOC_OBJ_CACHE_UNIFIED)
293        return depth;
294    }
295    return found;
296  }
297  static __hwloc_inline hwloc_obj_t
298  hwloc_get_cache_covering_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set) __hwloc_attribute_pure;
299  static __hwloc_inline hwloc_obj_t
300  hwloc_get_cache_covering_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set)
301  {
302    hwloc_obj_t current = hwloc_get_obj_covering_cpuset(topology, set);
303    while (current) {
304      if (hwloc_obj_type_is_dcache(current->type))
305        return current;
306      current = current->parent;
307    }
308    return NULL;
309  }
310  static __hwloc_inline hwloc_obj_t
311  hwloc_get_shared_cache_covering_obj (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj) __hwloc_attribute_pure;
312  static __hwloc_inline hwloc_obj_t
313  hwloc_get_shared_cache_covering_obj (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj)
314  {
315    hwloc_obj_t current = obj->parent;
316    if (!obj->cpuset)
317      return NULL;
318    while (current) {
319      if (!hwloc_bitmap_isequal(current->cpuset, obj->cpuset)
320          && hwloc_obj_type_is_dcache(current->type))
321        return current;
322      current = current->parent;
323    }
324    return NULL;
325  }
326  HWLOC_DECLSPEC int hwloc_bitmap_singlify_per_core(hwloc_topology_t topology, hwloc_bitmap_t cpuset, unsigned which);
327  static __hwloc_inline hwloc_obj_t
328  hwloc_get_pu_obj_by_os_index(hwloc_topology_t topology, unsigned os_index) __hwloc_attribute_pure;
329  static __hwloc_inline hwloc_obj_t
330  hwloc_get_pu_obj_by_os_index(hwloc_topology_t topology, unsigned os_index)
331  {
332    hwloc_obj_t obj = NULL;
333    while ((obj = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_PU, obj)) != NULL)
334      if (obj->os_index == os_index)
335        return obj;
336    return NULL;
337  }
338  static __hwloc_inline hwloc_obj_t
339  hwloc_get_numanode_obj_by_os_index(hwloc_topology_t topology, unsigned os_index) __hwloc_attribute_pure;
340  static __hwloc_inline hwloc_obj_t
341  hwloc_get_numanode_obj_by_os_index(hwloc_topology_t topology, unsigned os_index)
342  {
343    hwloc_obj_t obj = NULL;
344    while ((obj = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_NUMANODE, obj)) != NULL)
345      if (obj->os_index == os_index)
346        return obj;
347    return NULL;
348  }
349  HWLOC_DECLSPEC unsigned hwloc_get_closest_objs (hwloc_topology_t topology, hwloc_obj_t src, hwloc_obj_t * __hwloc_restrict objs, unsigned max);
350  static __hwloc_inline hwloc_obj_t
351  hwloc_get_obj_below_by_type (hwloc_topology_t topology,
352  			     hwloc_obj_type_t type1, unsigned idx1,
353  			     hwloc_obj_type_t type2, unsigned idx2) __hwloc_attribute_pure;
354  static __hwloc_inline hwloc_obj_t
355  hwloc_get_obj_below_by_type (hwloc_topology_t topology,
356  			     hwloc_obj_type_t type1, unsigned idx1,
357  			     hwloc_obj_type_t type2, unsigned idx2)
358  {
359    hwloc_obj_t obj;
360    obj = hwloc_get_obj_by_type (topology, type1, idx1);
361    if (!obj)
362      return NULL;
363    return hwloc_get_obj_inside_cpuset_by_type(topology, obj->cpuset, type2, idx2);
364  }
365  static __hwloc_inline hwloc_obj_t
366  hwloc_get_obj_below_array_by_type (hwloc_topology_t topology, int nr, hwloc_obj_type_t *typev, unsigned *idxv) __hwloc_attribute_pure;
367  static __hwloc_inline hwloc_obj_t
368  hwloc_get_obj_below_array_by_type (hwloc_topology_t topology, int nr, hwloc_obj_type_t *typev, unsigned *idxv)
369  {
370    hwloc_obj_t obj = hwloc_get_root_obj(topology);
371    int i;
372    for(i=0; i<nr; i++) {
373      if (!obj)
374        return NULL;
375      obj = hwloc_get_obj_inside_cpuset_by_type(topology, obj->cpuset, typev[i], idxv[i]);
376    }
377    return obj;
378  }
379  HWLOC_DECLSPEC hwloc_obj_t
380  hwloc_get_obj_with_same_locality(hwloc_topology_t topology, hwloc_obj_t src,
381                                   hwloc_obj_type_t type, const char *subtype, const char *nameprefix,
382                                   unsigned long flags);
383  enum hwloc_distrib_flags_e {
384    HWLOC_DISTRIB_FLAG_REVERSE = (1UL<<0)
385  };
386  static __hwloc_inline int
<span onclick='openModal()' class='match'>387  hwloc_distrib(hwloc_topology_t topology,
388  	      hwloc_obj_t *roots, unsigned n_roots,
389  	      hwloc_cpuset_t *set,
390  	      unsigned n,
391  	      int until, unsigned long flags)
392  {
393    unsigned i;
394    unsigned tot_weight;
395    unsigned given, givenweight;
</span>396    hwloc_cpuset_t *cpusetp = set;
397    if (flags & ~HWLOC_DISTRIB_FLAG_REVERSE) {
398      errno = EINVAL;
399      return -1;
400    }
401    tot_weight = 0;
402    for (i = 0; i < n_roots; i++)
403      tot_weight += (unsigned) hwloc_bitmap_weight(roots[i]->cpuset);
404    for (i = 0, given = 0, givenweight = 0; i < n_roots; i++) {
405      unsigned chunk, weight;
406      hwloc_obj_t root = roots[flags & HWLOC_DISTRIB_FLAG_REVERSE ? n_roots-1-i : i];
407      hwloc_cpuset_t cpuset = root->cpuset;
408      while (!hwloc_obj_type_is_normal(root->type))
409        root = root->parent;
410      weight = (unsigned) hwloc_bitmap_weight(cpuset);
411      if (!weight)
412        continue;
413      chunk = (( (givenweight+weight) * n  + tot_weight-1) / tot_weight)
414            - ((  givenweight         * n  + tot_weight-1) / tot_weight);
415      if (!root->arity || chunk <= 1 || root->depth >= until) {
416        if (chunk) {
417  	unsigned j;
418  	for (j=0; j < chunk; j++)
419  	  cpusetp[j] = hwloc_bitmap_dup(cpuset);
420        } else {
421  	assert(given);
422  	hwloc_bitmap_or(cpusetp[-1], cpusetp[-1], cpuset);
423        }
424      } else {
425        hwloc_distrib(topology, root->children, root->arity, cpusetp, chunk, until, flags);
426      }
427      cpusetp += chunk;
428      given += chunk;
429      givenweight += weight;
430    }
431    return 0;
432  }
433  HWLOC_DECLSPEC hwloc_const_cpuset_t
434  hwloc_topology_get_complete_cpuset(hwloc_topology_t topology) __hwloc_attribute_pure;
435  HWLOC_DECLSPEC hwloc_const_cpuset_t
436  hwloc_topology_get_topology_cpuset(hwloc_topology_t topology) __hwloc_attribute_pure;
437  HWLOC_DECLSPEC hwloc_const_cpuset_t
438  hwloc_topology_get_allowed_cpuset(hwloc_topology_t topology) __hwloc_attribute_pure;
439  HWLOC_DECLSPEC hwloc_const_nodeset_t
440  hwloc_topology_get_complete_nodeset(hwloc_topology_t topology) __hwloc_attribute_pure;
441  HWLOC_DECLSPEC hwloc_const_nodeset_t
442  hwloc_topology_get_topology_nodeset(hwloc_topology_t topology) __hwloc_attribute_pure;
443  HWLOC_DECLSPEC hwloc_const_nodeset_t
444  hwloc_topology_get_allowed_nodeset(hwloc_topology_t topology) __hwloc_attribute_pure;
445  static __hwloc_inline int
446  hwloc_cpuset_to_nodeset(hwloc_topology_t topology, hwloc_const_cpuset_t _cpuset, hwloc_nodeset_t nodeset)
447  {
448  	int depth = hwloc_get_type_depth(topology, HWLOC_OBJ_NUMANODE);
449  	hwloc_obj_t obj = NULL;
450  	assert(depth != HWLOC_TYPE_DEPTH_UNKNOWN);
451  	hwloc_bitmap_zero(nodeset);
452  	while ((obj = hwloc_get_next_obj_covering_cpuset_by_depth(topology, _cpuset, depth, obj)) != NULL)
453  		if (hwloc_bitmap_set(nodeset, obj->os_index) < 0)
454  			return -1;
455  	return 0;
456  }
457  static __hwloc_inline int
458  hwloc_cpuset_from_nodeset(hwloc_topology_t topology, hwloc_cpuset_t _cpuset, hwloc_const_nodeset_t nodeset)
459  {
460  	int depth = hwloc_get_type_depth(topology, HWLOC_OBJ_NUMANODE);
461  	hwloc_obj_t obj = NULL;
462  	assert(depth != HWLOC_TYPE_DEPTH_UNKNOWN);
463  	hwloc_bitmap_zero(_cpuset);
464  	while ((obj = hwloc_get_next_obj_by_depth(topology, depth, obj)) != NULL) {
465  		if (hwloc_bitmap_isset(nodeset, obj->os_index))
466  			if (hwloc_bitmap_or(_cpuset, _cpuset, obj->cpuset) < 0)
467  				return -1;
468  	}
469  	return 0;
470  }
471  static __hwloc_inline hwloc_obj_t
472  hwloc_get_non_io_ancestor_obj(hwloc_topology_t topology __hwloc_attribute_unused,
473  			      hwloc_obj_t ioobj)
474  {
475    hwloc_obj_t obj = ioobj;
476    while (obj && !obj->cpuset) {
477      obj = obj->parent;
478    }
479    return obj;
480  }
481  static __hwloc_inline hwloc_obj_t
482  hwloc_get_next_pcidev(hwloc_topology_t topology, hwloc_obj_t prev)
483  {
484    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_PCI_DEVICE, prev);
485  }
486  static __hwloc_inline hwloc_obj_t
487  hwloc_get_pcidev_by_busid(hwloc_topology_t topology,
488  			  unsigned domain, unsigned bus, unsigned dev, unsigned func)
489  {
490    hwloc_obj_t obj = NULL;
491    while ((obj = hwloc_get_next_pcidev(topology, obj)) != NULL) {
492      if (obj->attr->pcidev.domain == domain
493  	&& obj->attr->pcidev.bus == bus
494  	&& obj->attr->pcidev.dev == dev
495  	&& obj->attr->pcidev.func == func)
496        return obj;
497    }
498    return NULL;
499  }
500  static __hwloc_inline hwloc_obj_t
501  hwloc_get_pcidev_by_busidstring(hwloc_topology_t topology, const char *busid)
502  {
503    unsigned domain = 0; &bsol;* default */
504    unsigned bus, dev, func;
505    if (sscanf(busid, "%x:%x.%x", &bus, &dev, &func) != 3
506        && sscanf(busid, "%x:%x:%x.%x", &domain, &bus, &dev, &func) != 4) {
507      errno = EINVAL;
508      return NULL;
509    }
510    return hwloc_get_pcidev_by_busid(topology, domain, bus, dev, func);
511  }
512  static __hwloc_inline hwloc_obj_t
513  hwloc_get_next_osdev(hwloc_topology_t topology, hwloc_obj_t prev)
514  {
515    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_OS_DEVICE, prev);
516  }
517  static __hwloc_inline hwloc_obj_t
518  hwloc_get_next_bridge(hwloc_topology_t topology, hwloc_obj_t prev)
519  {
520    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_BRIDGE, prev);
521  }
522  static __hwloc_inline int
523  hwloc_bridge_covers_pcibus(hwloc_obj_t bridge,
524  			   unsigned domain, unsigned bus)
525  {
526    return bridge->type == HWLOC_OBJ_BRIDGE
527      && bridge->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
528      && bridge->attr->bridge.downstream.pci.domain == domain
529      && bridge->attr->bridge.downstream.pci.secondary_bus <= bus
530      && bridge->attr->bridge.downstream.pci.subordinate_bus >= bus;
531  }
532  #ifdef __cplusplus
533  } &bsol;* extern "C" */
534  #endif
535  #endif &bsol;* HWLOC_HELPER_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeBilateralBlurFilter.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-helper.h</div>
                </div>
                <div class="column column_space"><pre><code>17      bool init();
18      virtual void setBlurScale(float value);
19      void setDistanceNormalizationFactor(float value);
20  protected:
21      static CGEConstString paramDistanceFactorName;
22      static CGEConstString paramBlurSamplerScaleName;
23      static CGEConstString paramBlurFactorsName;
</pre></code></div>
                <div class="column column_space"><pre><code>387  hwloc_distrib(hwloc_topology_t topology,
388  	      hwloc_obj_t *roots, unsigned n_roots,
389  	      hwloc_cpuset_t *set,
390  	      unsigned n,
391  	      int until, unsigned long flags)
392  {
393    unsigned i;
394    unsigned tot_weight;
395    unsigned given, givenweight;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    