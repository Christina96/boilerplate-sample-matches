
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.349206349206349%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_shared_secret.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MECC
3  int ecc_shared_secret(const ecc_key *private_key, const ecc_key *public_key,
4                        unsigned char *out, unsigned long *outlen)
5  {
<span onclick='openModal()' class='match'>6     unsigned long  x;
7     ecc_point     *result;
8     void          *prime, *a;
9     int            err;
10     LTC_ARGCHK(private_key != NULL);
11     LTC_ARGCHK(public_key  != NULL);
12     LTC_ARGCHK(out         != NULL);
13     LTC_ARGCHK(outlen      != NULL);
14     if (private_key->type != PK_PRIVATE) {
15        return CRYPT_PK_NOT_PRIVATE;
16     }
</span>17     result = ltc_ecc_new_point();
18     if (result == NULL) {
19        return CRYPT_MEM;
20     }
21     prime = private_key->dp.prime;
22     a     = private_key->dp.A;
23     if ((err = ltc_mp.ecc_ptmul(private_key->k, &public_key->pubkey, result, a, prime, 1)) != CRYPT_OK)   { goto done; }
24     x = (unsigned long)mp_unsigned_bin_size(prime);
25     if (*outlen < x) {
26        *outlen = x;
27        err = CRYPT_BUFFER_OVERFLOW;
28        goto done;
29     }
30     zeromem(out, x);
31     if ((err = mp_to_unsigned_bin(result->x, out + (x - mp_unsigned_bin_size(result->x))))   != CRYPT_OK) { goto done; }
32     err     = CRYPT_OK;
33     *outlen = x;
34  done:
35     ltc_ecc_del_point(result);
36     return err;
37  }
38  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-noekeon.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_NOEKEON
3  const struct ltc_cipher_descriptor noekeon_desc =
4  {
5      "noekeon",
6      16,
7      16, 16, 16, 16,
8      &noekeon_setup,
9      &noekeon_ecb_encrypt,
10      &noekeon_ecb_decrypt,
11      &noekeon_test,
12      &noekeon_done,
13      &noekeon_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  static const ulong32 RC[] = {
17     0x00000080UL, 0x0000001bUL, 0x00000036UL, 0x0000006cUL,
18     0x000000d8UL, 0x000000abUL, 0x0000004dUL, 0x0000009aUL,
19     0x0000002fUL, 0x0000005eUL, 0x000000bcUL, 0x00000063UL,
20     0x000000c6UL, 0x00000097UL, 0x00000035UL, 0x0000006aUL,
21     0x000000d4UL
22  };
23  #define kTHETA(a, b, c, d)                                 \
24      temp = a^c; temp = temp ^ ROLc(temp, 8) ^ RORc(temp, 8); \
25      b ^= temp; d ^= temp;                                  \
26      temp = b^d; temp = temp ^ ROLc(temp, 8) ^ RORc(temp, 8); \
27      a ^= temp; c ^= temp;
28  #define THETA(k, a, b, c, d)                               \
29      temp = a^c; temp = temp ^ ROLc(temp, 8) ^ RORc(temp, 8); \
30      b ^= temp ^ k[1]; d ^= temp ^ k[3];                    \
31      temp = b^d; temp = temp ^ ROLc(temp, 8) ^ RORc(temp, 8); \
32      a ^= temp ^ k[0]; c ^= temp ^ k[2];
33  #define GAMMA(a, b, c, d)     \
34      b ^= ~(d|c);              \
35      a ^= c&b;                 \
36      temp = d; d = a; a = temp;\
37      c ^= a ^ b ^ d;           \
38      b ^= ~(d|c);              \
39      a ^= c&b;
40  #define PI1(a, b, c, d) \
41      b = ROLc(b, 1); c = ROLc(c, 5); d = ROLc(d, 2);
42  #define PI2(a, b, c, d) \
43      b = RORc(b, 1); c = RORc(c, 5); d = RORc(d, 2);
<span onclick='openModal()' class='match'>44  int noekeon_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
45  {
46     ulong32 temp;
47     LTC_ARGCHK(key != NULL);
48     LTC_ARGCHK(skey != NULL);
49     if (keylen != 16) {
50        return CRYPT_INVALID_KEYSIZE;
51     }
</span>52     if (num_rounds != 16 && num_rounds != 0) {
53        return CRYPT_INVALID_ROUNDS;
54     }
55     LOAD32H(skey->noekeon.K[0],&key[0]);
56     LOAD32H(skey->noekeon.K[1],&key[4]);
57     LOAD32H(skey->noekeon.K[2],&key[8]);
58     LOAD32H(skey->noekeon.K[3],&key[12]);
59     LOAD32H(skey->noekeon.dK[0],&key[0]);
60     LOAD32H(skey->noekeon.dK[1],&key[4]);
61     LOAD32H(skey->noekeon.dK[2],&key[8]);
62     LOAD32H(skey->noekeon.dK[3],&key[12]);
63     kTHETA(skey->noekeon.dK[0], skey->noekeon.dK[1], skey->noekeon.dK[2], skey->noekeon.dK[3]);
64     return CRYPT_OK;
65  }
66  #ifdef LTC_CLEAN_STACK
67  static int s_noekeon_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
68  #else
69  int noekeon_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
70  #endif
71  {
72     ulong32 a,b,c,d,temp;
73     int r;
74     LTC_ARGCHK(skey != NULL);
75     LTC_ARGCHK(pt   != NULL);
76     LTC_ARGCHK(ct   != NULL);
77     LOAD32H(a,&pt[0]); LOAD32H(b,&pt[4]);
78     LOAD32H(c,&pt[8]); LOAD32H(d,&pt[12]);
79  #define ROUND(i) \
80         a ^= RC[i]; \
81         THETA(skey->noekeon.K, a,b,c,d); \
82         PI1(a,b,c,d); \
83         GAMMA(a,b,c,d); \
84         PI2(a,b,c,d);
85     for (r = 0; r < 16; ++r) {
86         ROUND(r);
87     }
88  #undef ROUND
89     a ^= RC[16];
90     THETA(skey->noekeon.K, a, b, c, d);
91     STORE32H(a,&ct[0]); STORE32H(b,&ct[4]);
92     STORE32H(c,&ct[8]); STORE32H(d,&ct[12]);
93     return CRYPT_OK;
94  }
95  #ifdef LTC_CLEAN_STACK
96  int noekeon_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
97  {
98     int err = s_noekeon_ecb_encrypt(pt, ct, skey);
99     burn_stack(sizeof(ulong32) * 5 + sizeof(int));
100     return err;
101  }
102  #endif
103  #ifdef LTC_CLEAN_STACK
104  static int s_noekeon_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
105  #else
106  int noekeon_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
107  #endif
108  {
109     ulong32 a,b,c,d, temp;
110     int r;
111     LTC_ARGCHK(skey != NULL);
112     LTC_ARGCHK(pt   != NULL);
113     LTC_ARGCHK(ct   != NULL);
114     LOAD32H(a,&ct[0]); LOAD32H(b,&ct[4]);
115     LOAD32H(c,&ct[8]); LOAD32H(d,&ct[12]);
116  #define ROUND(i) \
117         THETA(skey->noekeon.dK, a,b,c,d); \
118         a ^= RC[i]; \
119         PI1(a,b,c,d); \
120         GAMMA(a,b,c,d); \
121         PI2(a,b,c,d);
122     for (r = 16; r > 0; --r) {
123         ROUND(r);
124     }
125  #undef ROUND
126     THETA(skey->noekeon.dK, a,b,c,d);
127     a ^= RC[0];
128     STORE32H(a,&pt[0]); STORE32H(b, &pt[4]);
129     STORE32H(c,&pt[8]); STORE32H(d, &pt[12]);
130     return CRYPT_OK;
131  }
132  #ifdef LTC_CLEAN_STACK
133  int noekeon_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
134  {
135     int err = s_noekeon_ecb_decrypt(ct, pt, skey);
136     burn_stack(sizeof(ulong32) * 5 + sizeof(int));
137     return err;
138  }
139  #endif
140  int noekeon_test(void)
141  {
142   #ifndef LTC_TEST
143      return CRYPT_NOP;
144   #else
145   static const struct {
146       int keylen;
147       unsigned char key[16], pt[16], ct[16];
148   } tests[] = {
149     {
150        16,
151        { 0xAA, 0x3C, 0x8C, 0x86, 0xD9, 0x8B, 0xF8, 0xBE, 0x21, 0xE0, 0x36, 0x09, 0x78, 0xFB, 0xE4, 0x90 },
152        { 0xE4, 0x96, 0x6C, 0xD3, 0x13, 0xA0, 0x6C, 0xAF, 0xD0, 0x23, 0xC9, 0xFD, 0x45, 0x32, 0x23, 0x16 },
153        { 0xA6, 0xEC, 0xB8, 0xA8, 0x61, 0xFD, 0x62, 0xD9, 0x13, 0x02, 0xFE, 0x9E, 0x47, 0x01, 0x3F, 0xC3 }
154     },
155     {
156        16,
157        { 0xED, 0x43, 0xD1, 0x87, 0x21, 0x7E, 0xE0, 0x97, 0x3D, 0x76, 0xC3, 0x37, 0x2E, 0x7D, 0xAE, 0xD3 },
158        { 0xE3, 0x38, 0x32, 0xCC, 0xF2, 0x2F, 0x2F, 0x0A, 0x4A, 0x8B, 0x8F, 0x18, 0x12, 0x20, 0x17, 0xD3 },
159        { 0x94, 0xA5, 0xDF, 0xF5, 0xAE, 0x1C, 0xBB, 0x22, 0xAD, 0xEB, 0xA7, 0x0D, 0xB7, 0x82, 0x90, 0xA0 }
160     },
161     {
162        16,
163        { 0x6F, 0xDC, 0x23, 0x38, 0xF2, 0x10, 0xFB, 0xD3, 0xC1, 0x8C, 0x02, 0xF6, 0xB4, 0x6A, 0xD5, 0xA8 },
164        { 0xDB, 0x29, 0xED, 0xB5, 0x5F, 0xB3, 0x60, 0x3A, 0x92, 0xA8, 0xEB, 0x9C, 0x6D, 0x9D, 0x3E, 0x8F },
165        { 0x78, 0xF3, 0x6F, 0xF8, 0x9E, 0xBB, 0x8C, 0x6A, 0xE8, 0x10, 0xF7, 0x00, 0x22, 0x15, 0x30, 0x3D }
166     },
167     {
168        16,
169        { 0x2C, 0x0C, 0x02, 0xEF, 0x6B, 0xC4, 0xF2, 0x0B, 0x2E, 0xB9, 0xE0, 0xBF, 0xD9, 0x36, 0xC2, 0x4E },
170        { 0x84, 0xE2, 0xFE, 0x64, 0xB1, 0xB9, 0xFE, 0x76, 0xA8, 0x3F, 0x45, 0xC7, 0x40, 0x7A, 0xAF, 0xEE },
171        { 0x2A, 0x08, 0xD6, 0xA2, 0x1C, 0x63, 0x08, 0xB0, 0xF8, 0xBC, 0xB3, 0xA1, 0x66, 0xF7, 0xAE, 0xCF }
172     },
173     {
174        16,
175        { 0x6F, 0x30, 0xF8, 0x9F, 0xDA, 0x6E, 0xA0, 0x91, 0x04, 0x0F, 0x6C, 0x8B, 0x7D, 0xF7, 0x2A, 0x4B },
176        { 0x65, 0xB6, 0xA6, 0xD0, 0x42, 0x14, 0x08, 0x60, 0x34, 0x8D, 0x37, 0x2F, 0x01, 0xF0, 0x46, 0xBE },
177        { 0x66, 0xAC, 0x0B, 0x62, 0x1D, 0x68, 0x11, 0xF5, 0x27, 0xB1, 0x13, 0x5D, 0xF3, 0x2A, 0xE9, 0x18 }
178     },
179     {
180        16,
181        { 0xCA, 0xA4, 0x16, 0xB7, 0x1C, 0x92, 0x2E, 0xAD, 0xEB, 0xA7, 0xDB, 0x69, 0x92, 0xCB, 0x35, 0xEF },
182        { 0x81, 0x6F, 0x8E, 0x4D, 0x96, 0xC6, 0xB3, 0x67, 0x83, 0xF5, 0x63, 0xC7, 0x20, 0x6D, 0x40, 0x23 },
183        { 0x44, 0xF7, 0x63, 0x62, 0xF0, 0x43, 0xBB, 0x67, 0x4A, 0x75, 0x12, 0x42, 0x46, 0x29, 0x28, 0x19 }
184     },
185     {
186        16,
187        { 0x6B, 0xCF, 0x22, 0x2F, 0xE0, 0x1B, 0xB0, 0xAA, 0xD8, 0x3C, 0x91, 0x99, 0x18, 0xB2, 0x28, 0xE8 },
188        { 0x7C, 0x37, 0xC7, 0xD0, 0xAC, 0x92, 0x29, 0xF1, 0x60, 0x82, 0x93, 0x89, 0xAA, 0x61, 0xAA, 0xA9 },
189        { 0xE5, 0x89, 0x1B, 0xB3, 0xFE, 0x8B, 0x0C, 0xA1, 0xA6, 0xC7, 0xBE, 0x12, 0x73, 0x0F, 0xC1, 0x19 }
190     },
191     {
192        16,
193        { 0xE6, 0xD0, 0xF1, 0x03, 0x2E, 0xDE, 0x70, 0x8D, 0xD8, 0x9E, 0x36, 0x5C, 0x05, 0x52, 0xE7, 0x0D },
194        { 0xE2, 0x42, 0xE7, 0x92, 0x0E, 0xF7, 0x82, 0xA2, 0xB8, 0x21, 0x8D, 0x26, 0xBA, 0x2D, 0xE6, 0x32 },
195        { 0x1E, 0xDD, 0x75, 0x22, 0xB9, 0x36, 0x8A, 0x0F, 0x32, 0xFD, 0xD4, 0x48, 0x65, 0x12, 0x5A, 0x2F }
196     }
197   };
198   symmetric_key key;
199   unsigned char tmp[2][16];
200   int err, i, y;
201   for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
202      zeromem(&key, sizeof(key));
203      if ((err = noekeon_setup(tests[i].key, tests[i].keylen, 0, &key)) != CRYPT_OK) {
204         return err;
205      }
206      noekeon_ecb_encrypt(tests[i].pt, tmp[0], &key);
207      noekeon_ecb_decrypt(tmp[0], tmp[1], &key);
208      if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "Noekeon Encrypt", i) ||
209            compare_testvector(tmp[1], 16, tests[i].pt, 16, "Noekeon Decrypt", i)) {
210          return CRYPT_FAIL_TESTVECTOR;
211      }
212      for (y = 0; y < 16; y++) tmp[0][y] = 0;
213      for (y = 0; y < 1000; y++) noekeon_ecb_encrypt(tmp[0], tmp[0], &key);
214      for (y = 0; y < 1000; y++) noekeon_ecb_decrypt(tmp[0], tmp[0], &key);
215      for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
216   }
217   return CRYPT_OK;
218   #endif
219  }
220  void noekeon_done(symmetric_key *skey)
221  {
222    LTC_UNUSED_PARAM(skey);
223  }
224  int noekeon_keysize(int *keysize)
225  {
226     LTC_ARGCHK(keysize != NULL);
227     if (*keysize < 16) {
228        return CRYPT_INVALID_KEYSIZE;
229     }
230     *keysize = 16;
231     return CRYPT_OK;
232  }
233  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_shared_secret.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-noekeon.c</div>
                </div>
                <div class="column column_space"><pre><code>6     unsigned long  x;
7     ecc_point     *result;
8     void          *prime, *a;
9     int            err;
10     LTC_ARGCHK(private_key != NULL);
11     LTC_ARGCHK(public_key  != NULL);
12     LTC_ARGCHK(out         != NULL);
13     LTC_ARGCHK(outlen      != NULL);
14     if (private_key->type != PK_PRIVATE) {
15        return CRYPT_PK_NOT_PRIVATE;
16     }
</pre></code></div>
                <div class="column column_space"><pre><code>44  int noekeon_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
45  {
46     ulong32 temp;
47     LTC_ARGCHK(key != NULL);
48     LTC_ARGCHK(skey != NULL);
49     if (keylen != 16) {
50        return CRYPT_INVALID_KEYSIZE;
51     }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    