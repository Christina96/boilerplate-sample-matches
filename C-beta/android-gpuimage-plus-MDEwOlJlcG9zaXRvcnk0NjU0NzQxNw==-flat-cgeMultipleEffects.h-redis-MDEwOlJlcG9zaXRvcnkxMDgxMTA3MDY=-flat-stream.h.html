
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 25.32299741602067%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeMultipleEffects.h</h3>
            <pre><code>1  &bsol;*
2   * cgeMultipleEffects.h
3   *
4   *  Created on: 2013-12-13
5   *      Author: Wang Yang
6   *        Blog: http:&bsol;&bsol;wysaid.org
7   */
8  #ifndef _CGEMUTIPLEEFFECTS_H_
9  #define _CGEMUTIPLEEFFECTS_H_
10  #include "cgeGLFunctions.h"
11  namespace CGE
12  {
13  class CGEMutipleMixFilter : protected CGEImageFilterInterface
14  {
15  public:
16      CGEMutipleMixFilter() {}
<span onclick='openModal()' class='match'>17      void setIntensity(float value);
18      bool init();
19      void render2Texture(CGEImageHandlerInterface* handler, GLuint srcTexture, GLuint vertexBufferID);
20      bool needToMix();
21      bool noIntensity();
22  protected:
23      static CGEConstString paramIntensityName;
24      static CGEConstString paramOriginImageName;
25  private:
26      float m_intensity;
</span>27  };
28  class CGEMutipleEffectFilter : public CGEImageFilterInterfaceAbstract
29  {
30  public:
31      CGEMutipleEffectFilter();
32      ~CGEMutipleEffectFilter();
33      void setBufferLoadFunction(CGEBufferLoadFun fLoad, void* loadParam, CGEBufferUnloadFun fUnload, void* unloadParam);
34      void setTextureLoadFunction(CGETextureLoadFun texLoader, void* arg);
35      bool initWithEffectString(const char* pstr);
36      bool initCustomize(); 
37      void setIntensity(float value); 
38      bool isEmpty() { return m_vecFilters.empty(); }
39      void clearFilters();
40      bool isWrapper() { return m_isWrapper; }
41      std::vector<CGEImageFilterInterface*> getFilters(bool bMove = true);
42      std::vector<CGEImageFilterInterface*>& vecFilters()
43      {
44          return m_vecFilters;
45      }
46      void render2Texture(CGEImageHandlerInterface* handler, GLuint srcTexture, GLuint vertexBufferID);
47      void addFilter(CGEImageFilterInterface* proc)
48      {
49          if (proc != nullptr) m_vecFilters.push_back(proc);
50      }
51      GLuint loadResources(const char* textureName, int* w = nullptr, int* h = nullptr);
52      CGEBufferLoadFun getLoadFunc() { return m_loadFunc; };
53      CGEBufferUnloadFun getUnloadFunc() { return m_unloadFunc; }
54      CGETextureLoadFun getTexLoadFunc() { return m_texLoadFunc; }
55      void* getLoadParam() { return m_loadParam; }
56      void* getUnloadParam() { return m_unloadParam; }
57      void* getTexLoadParam() { return m_texLoadParam; }
58  protected:
59      CGEBufferLoadFun m_loadFunc;
60      CGEBufferUnloadFun m_unloadFunc;
61      CGETextureLoadFun m_texLoadFunc;
62      void* m_loadParam;
63      void* m_unloadParam;
64      void* m_texLoadParam;
65      std::vector<CGEImageFilterInterface*> m_vecFilters;
66      CGEMutipleMixFilter m_mixFilter;
67      CGESizei m_currentSize;
68      GLuint m_texCache;
69      bool m_isWrapper;
70  };
71  } 
72  #endif &bsol;* _CGEMUTIPLEEFFECTS_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stream.h</h3>
            <pre><code>1  #ifndef STREAM_H
2  #define STREAM_H
3  #include "rax.h"
4  #include "listpack.h"
5  typedef struct streamID {
6      uint64_t ms;        &bsol;* Unix time in milliseconds. */
7      uint64_t seq;       &bsol;* Sequence number. */
8  } streamID;
9  typedef struct stream {
10      rax *rax;               &bsol;* The radix tree holding the stream. */
11      uint64_t length;        &bsol;* Number of elements inside this stream. */
12      streamID last_id;       &bsol;* Zero if there are yet no items. */
13      rax *cgroups;           &bsol;* Consumer groups dictionary: name -> streamCG */
14  } stream;
15  typedef struct streamIterator {
16      stream *stream;         &bsol;* The stream we are iterating. */
17      streamID master_id;     &bsol;* ID of the master entry at listpack head. */
18      uint64_t master_fields_count;       &bsol;* Master entries # of fields. */
19      unsigned char *master_fields_start; &bsol;* Master entries start in listpack. */
20      unsigned char *master_fields_ptr;   &bsol;* Master field to emit next. */
21      int entry_flags;                    &bsol;* Flags of entry we are emitting. */
22      int rev;                &bsol;* True if iterating end to start (reverse). */
<span onclick='openModal()' class='match'>23      uint64_t start_key[2];  &bsol;* Start key as 128 bit big endian. */
24      uint64_t end_key[2];    &bsol;* End key as 128 bit big endian. */
25      raxIterator ri;         &bsol;* Rax iterator. */
26      unsigned char *lp;      &bsol;* Current listpack. */
27      unsigned char *lp_ele;  &bsol;* Current listpack cursor. */
</span>28      unsigned char *lp_flags; &bsol;* Current entry flags pointer. */
29      unsigned char field_buf[LP_INTBUF_SIZE];
30      unsigned char value_buf[LP_INTBUF_SIZE];
31  } streamIterator;
32  typedef struct streamCG {
33      streamID last_id;       &bsol;* Last delivered (not acknowledged) ID for this
34                                 group. Consumers that will just ask for more
35                                 messages will served with IDs > than this. */
36      rax *pel;               &bsol;* Pending entries list. This is a radix tree that
37                                 has every message delivered to consumers (without
38                                 the NOACK option) that was yet not acknowledged
39                                 as processed. The key of the radix tree is the
40                                 ID as a 64 bit big endian number, while the
41                                 associated value is a streamNACK structure.*/
42      rax *consumers;         &bsol;* A radix tree representing the consumers by name
43                                 and their associated representation in the form
44                                 of streamConsumer structures. */
45  } streamCG;
46  typedef struct streamConsumer {
47      mstime_t seen_time;         &bsol;* Last time this consumer was active. */
48      sds name;                   &bsol;* Consumer name. This is how the consumer
49                                     will be identified in the consumer group
50                                     protocol. Case sensitive. */
51      rax *pel;                   &bsol;* Consumer specific pending entries list: all
52                                     the pending messages delivered to this
53                                     consumer not yet acknowledged. Keys are
54                                     big endian message IDs, while values are
55                                     the same streamNACK structure referenced
56                                     in the "pel" of the conumser group structure
57                                     itself, so the value is shared. */
58  } streamConsumer;
59  typedef struct streamNACK {
60      mstime_t delivery_time;     &bsol;* Last time this message was delivered. */
61      uint64_t delivery_count;    &bsol;* Number of times this message was delivered.*/
62      streamConsumer *consumer;   &bsol;* The consumer this message was delivered to
63                                     in the last delivery. */
64  } streamNACK;
65  typedef struct sreamPropInfo {
66      robj *keyname;
67      robj *groupname;
68  } streamPropInfo;
69  struct client;
70  #define SLC_NONE      0
71  #define SLC_NOCREAT   (1<<0) &bsol;* Do not create the consumer if it doesn't exist */
72  #define SLC_NOREFRESH (1<<1) &bsol;* Do not update consumer's seen-time */
73  stream *streamNew(void);
74  void freeStream(stream *s);
75  PORT_ULONG streamLength(const robj *subject);
76  size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi);
77  void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev);
78  int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields);
79  void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen);
80  void streamIteratorStop(streamIterator *si);
81  streamCG *streamLookupCG(stream *s, sds groupname);
82  streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags);
83  streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id);
84  streamNACK *streamCreateNACK(streamConsumer *consumer);
85  void streamDecodeID(void *buf, streamID *id);
86  int streamCompareID(streamID *a, streamID *b);
87  void streamIncrID(streamID *id);
88  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeMultipleEffects.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stream.h</div>
                </div>
                <div class="column column_space"><pre><code>17      void setIntensity(float value);
18      bool init();
19      void render2Texture(CGEImageHandlerInterface* handler, GLuint srcTexture, GLuint vertexBufferID);
20      bool needToMix();
21      bool noIntensity();
22  protected:
23      static CGEConstString paramIntensityName;
24      static CGEConstString paramOriginImageName;
25  private:
26      float m_intensity;
</pre></code></div>
                <div class="column column_space"><pre><code>23      uint64_t start_key[2];  &bsol;* Start key as 128 bit big endian. */
24      uint64_t end_key[2];    &bsol;* End key as 128 bit big endian. */
25      raxIterator ri;         &bsol;* Rax iterator. */
26      unsigned char *lp;      &bsol;* Current listpack. */
27      unsigned char *lp_ele;  &bsol;* Current listpack cursor. */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    