
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.4682080924855487%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ifftw-mpi.h</h3>
            <pre><code>1  #ifndef __IFFTW_MPI_H__
2  #define __IFFTW_MPI_H__
3  #include "kernel/ifftw.h"
4  #include "rdft/rdft.h"
5  #include <mpi.h>
6  #define SCRAMBLED_IN (1 << 0)
7  #define SCRAMBLED_OUT (1 << 1)
8  #define TRANSPOSED_IN (1 << 2)
9  #define TRANSPOSED_OUT (1 << 3)
10  #define RANK1_BIGVEC_ONLY (1 << 4) &bsol;* for rank=1, allow only bigvec solver */
11  #define ONLY_SCRAMBLEDP(flags) (!((flags) & ~(SCRAMBLED_IN|SCRAMBLED_OUT)))
12  #define ONLY_TRANSPOSEDP(flags) (!((flags) & ~(TRANSPOSED_IN|TRANSPOSED_OUT)))
13  #if defined(FFTW_SINGLE)
14  #  define FFTW_MPI_TYPE MPI_FLOAT
15  #elif defined(FFTW_LDOUBLE)
16  #  define FFTW_MPI_TYPE MPI_LONG_DOUBLE
17  #elif defined(FFTW_QUAD)
18  #  error MPI quad-precision type is unknown
19  #else
20  #  define FFTW_MPI_TYPE MPI_DOUBLE
21  #endif
22  #define XM(name) X(CONCAT(mpi_, name))
23  typedef enum { IB = 0, OB } block_kind;
24  typedef struct {
25       INT n;
26       INT b[2]; &bsol;* b[IB], b[OB] */
27  } ddim;
28  #define FORALL_BLOCK_KIND(k) for (k = IB; k <= OB; k = (block_kind) (((int) k) + 1))
29  typedef struct {
30       int rnk;
31  #if defined(STRUCT_HACK_KR)
32       ddim dims[1];
33  #elif defined(STRUCT_HACK_C99)
34       ddim dims[];
35  #else
36       ddim *dims;
37  #endif
38  } dtensor;
39  dtensor *XM(mkdtensor)(int rnk);
40  void XM(dtensor_destroy)(dtensor *sz);
41  dtensor *XM(dtensor_copy)(const dtensor *sz);
42  dtensor *XM(dtensor_canonical)(const dtensor *sz, int compress);
43  int XM(dtensor_validp)(const dtensor *sz);
44  void XM(dtensor_md5)(md5 *p, const dtensor *t);
45  void XM(dtensor_print)(const dtensor *t, printer *p);
46  INT XM(num_blocks)(INT n, INT block);
47  int XM(num_blocks_ok)(INT n, INT block, MPI_Comm comm);
48  INT XM(default_block)(INT n, int n_pes);
49  INT XM(block)(INT n, INT block, int which_block);
50  INT XM(num_blocks_total)(const dtensor *sz, block_kind k);
51  int XM(idle_process)(const dtensor *sz, block_kind k, int which_pe);
52  void XM(block_coords)(const dtensor *sz, block_kind k, int which_pe, 
53  		     INT *coords);
54  INT XM(total_block)(const dtensor *sz, block_kind k, int which_pe);
55  int XM(is_local_after)(int dim, const dtensor *sz, block_kind k);
56  int XM(is_local)(const dtensor *sz, block_kind k);
57  int XM(is_block1d)(const dtensor *sz, block_kind k);
58  INT XM(choose_radix)(ddim d, int n_pes, unsigned flags, int sign,
59                       INT rblock[2], INT mblock[2]);
<span onclick='openModal()' class='match'>60  int XM(any_true)(int condition, MPI_Comm comm);
61  int XM(md5_equal)(md5 m, MPI_Comm comm);
62  void XM(conf_standard)(planner *p);
63  typedef enum {
64       CONTIG = 0, &bsol;* vn x 1: make subsequent DFTs contiguous */
65       DISCONTIG, &bsol;* P x (vn/P) for P processes */
66       SQUARE_BEFORE, &bsol;* try to get square transpose at beginning */
67       SQUARE_MIDDLE, &bsol;* try to get square transpose in the middle */
68       SQUARE_AFTER &bsol;* try to get square transpose at end */
</span>69  } rearrangement;
70  #define FORALL_REARRANGE(rearrange) for (rearrange = CONTIG; rearrange <= SQUARE_MIDDLE; rearrange = (rearrangement) (((int) rearrange) + 1))
71  int XM(rearrange_applicable)(rearrangement rearrange, 
72  			     ddim dim0, INT vn, int n_pes);
73  INT XM(rearrange_ny)(rearrangement rearrange, ddim dim0, INT vn, int n_pes);
74  #endif &bsol;* __IFFTW_MPI_H__ */
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-writecaptest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include <stdarg.h>
11  #include <limits.h>
12  #ifdef _WIN32
13    #include "getopt.h"
14  #else
15    #include <unistd.h>
16  #endif
17  #include <errno.h>
18  #ifndef _WIN32
19    #include <signal.h>
20  #endif
21  #include <sys/types.h>
22  #include <pcap.h>
23  #include "pcap/funcattrs.h"
24  #ifdef _WIN32
25    #include "portability.h"
26  #endif
27  static char *program_name;
28  static void PCAP_NORETURN usage(void);
29  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
30  static void warning(const char *, ...) PCAP_PRINTFLIKE(1, 2);
31  static char *copy_argv(char **);
32  static pcap_t *pd;
33  #ifdef _WIN32
34  static BOOL WINAPI
35  stop_capture(DWORD ctrltype _U_)
36  {
37  	pcap_breakloop(pd);
38  	return TRUE;
39  }
40  #else
41  static void
42  stop_capture(int signum _U_)
43  {
44  	pcap_breakloop(pd);
45  }
46  #endif
47  static long
48  parse_interface_number(const char *device)
49  {
50  	const char *p;
51  	long devnum;
52  	char *end;
53  	p = strchr(device, ':');
54  	if (p != NULL) {
55  		p++;	&bsol;* skip the : */
56  		if (strncmp(p, "&bsol;&bsol;", 2) == 0) {
57  			p += 2;	&bsol;* skip the 
58  			p = strchr(p, '/');
59  			if (p != NULL) {
60  				device = p + 1;
61  			}
62  		}
63  	}
64  	devnum = strtol(device, &end, 10);
65  	if (device != end && *end == '\0') {
66  		if (devnum <= 0) {
67  			error("Invalid adapter index");
68  		}
69  		return (devnum);
70  	} else {
71  		return (-1);
72  	}
73  }
74  static char *
75  find_interface_by_number(long devnum)
76  {
77  	pcap_if_t *dev, *devlist;
78  	long i;
79  	char ebuf[PCAP_ERRBUF_SIZE];
80  	char *device;
81  	int status;
82  	status = pcap_findalldevs(&devlist, ebuf);
83  	if (status < 0)
84  		error("%s", ebuf);
85  	for (i = 0, dev = devlist; i < devnum-1 && dev != NULL;
86  	    i++, dev = dev->next)
87  		;
88  	if (dev == NULL)
89  		error("Invalid adapter index");
90  	device = strdup(dev->name);
91  	pcap_freealldevs(devlist);
92  	return (device);
93  }
94  static pcap_t *
95  open_interface(const char *device, int snaplen_set, int snaplen, char *ebuf)
96  {
97  	pcap_t *pc;
98  	int status;
99  	char *cp;
100  	pc = pcap_create(device, ebuf);
101  	if (pc == NULL) {
102  		if (strstr(ebuf, "No such device") != NULL)
103  			return (NULL);
104  		error("%s", ebuf);
105  	}
106  	if (snaplen_set) {
107  		status = pcap_set_snaplen(pc, snaplen);
108  		if (status != 0)
109  			error("%s: pcap_set_snaplen failed: %s",
110  			    device, pcap_statustostr(status));
111  	}
112  	status = pcap_set_timeout(pc, 100);
113  	if (status != 0)
114  		error("%s: pcap_set_timeout failed: %s",
115  		    device, pcap_statustostr(status));
116  	status = pcap_activate(pc);
117  	if (status < 0) {
118  		cp = pcap_geterr(pc);
119  		if (status == PCAP_ERROR)
120  			error("%s", cp);
121  		else if (status == PCAP_ERROR_NO_SUCH_DEVICE) {
122  			snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s: %s\n(%s)",
123  			    device, pcap_statustostr(status), cp);
124  		} else if (status == PCAP_ERROR_PERM_DENIED && *cp != '\0')
125  			error("%s: %s\n(%s)", device,
126  			    pcap_statustostr(status), cp);
127  		else
128  			error("%s: %s", device,
129  			    pcap_statustostr(status));
130  		pcap_close(pc);
131  		return (NULL);
132  	} else if (status > 0) {
133  		cp = pcap_geterr(pc);
134  		if (status == PCAP_WARNING)
135  			warning("%s", cp);
136  		else if (status == PCAP_WARNING_PROMISC_NOTSUP &&
137  		         *cp != '\0')
138  			warning("%s: %s\n(%s)", device,
139  			    pcap_statustostr(status), cp);
140  		else
141  			warning("%s: %s", device,
142  			    pcap_statustostr(status));
143  	}
144  	return (pc);
145  }
146  #define COMMAND_OPTIONS	"DLi:s:w:y:"
147  int
148  main(int argc, char **argv)
149  {
150  	int op;
151  	char *cp, *cmdbuf = NULL, *device, *end, *savefile = NULL;
152  	int snaplen = 0;
153  	int snaplen_set = 0;
154  	pcap_if_t *devlist;
155  	long devnum;
156  	int show_interfaces = 0;
157  	int show_dlt_types = 0;
<span onclick='openModal()' class='match'>158  	int ndlts;
159  	int *dlts;
160  	bpf_u_int32 localnet, netmask;
161  	struct bpf_program fcode;
162  	char ebuf[PCAP_ERRBUF_SIZE];
163  #ifndef _WIN32
164  	struct sigaction action;
165  #endif
166  	int dlt;
167  	const char *dlt_name = NULL;
168  	int status;
169  	pcap_dumper_t *pdd;
</span>170  	device = NULL;
171  	if ((cp = strrchr(argv[0], '/')) != NULL)
172  		program_name = cp + 1;
173  	else
174  		program_name = argv[0];
175  	opterr = 0;
176  	while ((op = getopt(argc, argv, COMMAND_OPTIONS)) != -1) {
177  		switch (op) {
178  		case 'D':
179  			show_interfaces = 1;
180  			break;
181  		case 'L':
182  			show_dlt_types = 1;
183  			break;
184  		case 'i':
185  			device = optarg;
186  			break;
187  		case 's':
188  			snaplen = (int)strtol(optarg, &end, 0);
189  			if (optarg == end || *end != '\0' || snaplen < 0)
190  				error("invalid snaplen %s (must be >= 0)",
191  				    optarg);
192  			snaplen_set = 1;
193  			break;
194  		case 'w':
195  			savefile = optarg;
196  			break;
197  		case 'y':
198  			dlt_name = optarg;
199  			break;
200  		default:
201  			usage();
202  		}
203  	}
204  	if (show_interfaces) {
205  		pcap_if_t *dev;
206  		int i;
207  		if (pcap_findalldevs(&devlist, ebuf) < 0)
208  			error("%s", ebuf);
209  		for (i = 0, dev = devlist; dev != NULL; i++, dev = dev->next) {
210  			printf("%d.%s", i+1, dev->name);
211  			if (dev->description != NULL)
212  				printf(" (%s)", dev->description);
213  			printf("\n");
214  		}
215  		pcap_freealldevs(devlist);
216  		return (0);
217  	}
218  	if (device == NULL) {
219  		if (pcap_findalldevs(&devlist, ebuf) == -1)
220  			error("%s", ebuf);
221  		if (devlist == NULL)
222  			error("no interfaces available for capture");
223  		device = strdup(devlist->name);
224  		pcap_freealldevs(devlist);
225  	}
226  	if (show_dlt_types) {
227  		pd = pcap_create(device, ebuf);
228  		if (pd == NULL)
229  			error("%s", ebuf);
230  		status = pcap_activate(pd);
231  		if (status < 0) {
232  			error("%s: %s\n(%s)", device,
233  			    pcap_statustostr(status), pcap_geterr(pd));
234  		}
235  		ndlts = pcap_list_datalinks(pd, &dlts);
236  		if (ndlts < 0) {
237  			error("%s: %s\n(%s)", device,
238  			    pcap_statustostr(status), pcap_geterr(pd));
239  		}
240  		for (int i = 0; i < ndlts; i++) {
241  			dlt_name = pcap_datalink_val_to_name(dlts[i]);
242  			if (dlt_name == NULL)
243  				printf("DLT %d", dlts[i]);
244  			else
245  				printf("%s", dlt_name);
246  			printf("\n");
247  		}
248  		pcap_free_datalinks(dlts);
249  		pcap_close(pd);
250  		return 0;
251  	}
252  	if (savefile == NULL)
253  		error("no savefile specified");
254  	*ebuf = '\0';
255  	pd = open_interface(device, snaplen_set, snaplen, ebuf);
256  	if (pd == NULL) {
257  		devnum = parse_interface_number(device);
258  		if (devnum == -1) {
259  			error("%s", ebuf);
260  		}
261  		device = find_interface_by_number(devnum);
262  		pd = open_interface(device, snaplen_set, snaplen, ebuf);
263  		if (pd == NULL)
264  			error("%s", ebuf);
265  	}
266  	if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
267  		localnet = 0;
268  		netmask = 0;
269  		warning("%s", ebuf);
270  	}
271  	if (dlt_name != NULL) {
272  		dlt = pcap_datalink_name_to_val(dlt_name);
273  		if (dlt == PCAP_ERROR)
274  			error("%s isn't a valid DLT name", dlt_name);
275  		if (pcap_set_datalink(pd, dlt) == PCAP_ERROR)
276  			error("%s: %s", device, pcap_geterr(pd));
277  	}
278  	if (optind < argc) {
279  		cmdbuf = copy_argv(&argv[optind]);
280  		if (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)
281  			error("%s", pcap_geterr(pd));
282  		if (pcap_setfilter(pd, &fcode) < 0)
283  			error("%s", pcap_geterr(pd));
284  	}
285  	pdd = pcap_dump_open(pd, savefile);
286  	if (pdd == NULL)
287  		error("%s", pcap_geterr(pd));
288  #ifdef _WIN32
289  	SetConsoleCtrlHandler(stop_capture, TRUE);
290  #else
291  	action.sa_handler = stop_capture;
292  	sigemptyset(&action.sa_mask);
293  	action.sa_flags = 0;
294  	if (sigaction(SIGINT, &action, NULL) == -1)
295  		error("Can't catch SIGINT: %s\n", strerror(errno));
296  #endif
297  	printf("Listening on %s, link-type ", device);
298  	dlt = pcap_datalink(pd);
299  	dlt_name = pcap_datalink_val_to_name(dlt);
300  	if (dlt_name == NULL)
301  		printf("DLT %d", dlt);
302  	else
303  		printf("%s", dlt_name);
304  	printf("\n");
305  	for (;;) {
306  		status = pcap_dispatch(pd, -1, pcap_dump, (u_char *)pdd);
307  		if (status < 0)
308  			break;
309  		if (status != 0) {
310  			printf("%d packets seen\n", status);
311  			struct pcap_stat ps;
312  			pcap_stats(pd, &ps);
313  			printf("%d ps_recv, %d ps_drop, %d ps_ifdrop\n",
314  			    ps.ps_recv, ps.ps_drop, ps.ps_ifdrop);
315  		}
316  	}
317  	if (status == -2) {
318  		putchar('\n');
319  		printf("Broken out of loop from SIGINT handler\n");
320  	}
321  	(void)fflush(stdout);
322  	if (status == -1) {
323  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
324  		    program_name, pcap_geterr(pd));
325  	}
326  	pcap_close(pd);
327  	if (cmdbuf != NULL) {
328  		pcap_freecode(&fcode);
329  		free(cmdbuf);
330  	}
331  	exit(status == -1 ? 1 : 0);
332  }
333  static void
334  usage(void)
335  {
336  	(void)fprintf(stderr, "Usage: %s -D -L [ -i interface ] [ -s snaplen ] [ -w file ] [ -y dlt ] [expression]\n",
337  	    program_name);
338  	exit(1);
339  }
340  static void
341  error(const char *fmt, ...)
342  {
343  	va_list ap;
344  	(void)fprintf(stderr, "%s: ", program_name);
345  	va_start(ap, fmt);
346  	(void)vfprintf(stderr, fmt, ap);
347  	va_end(ap);
348  	if (*fmt) {
349  		fmt += strlen(fmt);
350  		if (fmt[-1] != '\n')
351  			(void)fputc('\n', stderr);
352  	}
353  	exit(1);
354  }
355  static void
356  warning(const char *fmt, ...)
357  {
358  	va_list ap;
359  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
360  	va_start(ap, fmt);
361  	(void)vfprintf(stderr, fmt, ap);
362  	va_end(ap);
363  	if (*fmt) {
364  		fmt += strlen(fmt);
365  		if (fmt[-1] != '\n')
366  			(void)fputc('\n', stderr);
367  	}
368  }
369  static char *
370  copy_argv(register char **argv)
371  {
372  	register char **p;
373  	register size_t len = 0;
374  	char *buf;
375  	char *src, *dst;
376  	p = argv;
377  	if (*p == 0)
378  		return 0;
379  	while (*p)
380  		len += strlen(*p++) + 1;
381  	buf = (char *)malloc(len);
382  	if (buf == NULL)
383  		error("copy_argv: malloc");
384  	p = argv;
385  	dst = buf;
386  	while ((src = *p++) != NULL) {
387  		while ((*dst++ = *src++) != '\0')
388  			;
389  		dst[-1] = ' ';
390  	}
391  	dst[-1] = '\0';
392  	return buf;
393  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ifftw-mpi.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-writecaptest.c</div>
                </div>
                <div class="column column_space"><pre><code>60  int XM(any_true)(int condition, MPI_Comm comm);
61  int XM(md5_equal)(md5 m, MPI_Comm comm);
62  void XM(conf_standard)(planner *p);
63  typedef enum {
64       CONTIG = 0, &bsol;* vn x 1: make subsequent DFTs contiguous */
65       DISCONTIG, &bsol;* P x (vn/P) for P processes */
66       SQUARE_BEFORE, &bsol;* try to get square transpose at beginning */
67       SQUARE_MIDDLE, &bsol;* try to get square transpose in the middle */
68       SQUARE_AFTER &bsol;* try to get square transpose at end */
</pre></code></div>
                <div class="column column_space"><pre><code>158  	int ndlts;
159  	int *dlts;
160  	bpf_u_int32 localnet, netmask;
161  	struct bpf_program fcode;
162  	char ebuf[PCAP_ERRBUF_SIZE];
163  #ifndef _WIN32
164  	struct sigaction action;
165  #endif
166  	int dlt;
167  	const char *dlt_name = NULL;
168  	int status;
169  	pcap_dumper_t *pdd;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    