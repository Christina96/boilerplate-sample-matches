
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.330874604847207%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_types.h</h3>
            <pre><code>1  #ifndef SPH_TYPES_H__
2  #define SPH_TYPES_H__
3  #include <limits.h>
4  #if CHAR_BIT != 8
5  #error This code requires 8-bit bytes
6  #endif
7  #ifdef DOXYGEN_IGNORE
8  typedef __arch_dependant__ sph_u32;
9  typedef __arch_dependant__ sph_s32;
10  typedef __arch_dependant__ sph_u64;
11  typedef __arch_dependant__ sph_s64;
12  #define SPH_C32(x)
13  #define SPH_T32(x)
14  #define SPH_ROTL32(x, n)
15  #define SPH_ROTR32(x, n)
16  #define SPH_64
17  #define SPH_64_TRUE
18  #define SPH_C64(x)
19  #define SPH_T64(x)
20  #define SPH_ROTL64(x, n)
21  #define SPH_ROTR64(x, n)
22  #define SPH_INLINE
23  #define SPH_LITTLE_ENDIAN
24  #define SPH_BIG_ENDIAN
25  #define SPH_LITTLE_FAST
26  #define SPH_BIG_FAST
27  #define SPH_UPTR
28  #define SPH_UNALIGNED
29  static inline sph_u32 sph_bswap32(sph_u32 x);
30  static inline sph_u64 sph_bswap64(sph_u64 x);
31  static inline unsigned sph_dec16le(const void *src);
32  static inline void sph_enc16le(void *dst, unsigned val);
33  static inline unsigned sph_dec16be(const void *src);
34  static inline void sph_enc16be(void *dst, unsigned val);
35  static inline sph_u32 sph_dec32le(const void *src);
36  static inline sph_u32 sph_dec32le_aligned(const void *src);
37  static inline void sph_enc32le(void *dst, sph_u32 val);
38  static inline void sph_enc32le_aligned(void *dst, sph_u32 val);
39  static inline sph_u32 sph_dec32be(const void *src);
40  static inline sph_u32 sph_dec32be_aligned(const void *src);
41  static inline void sph_enc32be(void *dst, sph_u32 val);
42  static inline void sph_enc32be_aligned(void *dst, sph_u32 val);
43  static inline sph_u64 sph_dec64le(const void *src);
44  static inline sph_u64 sph_dec64le_aligned(const void *src);
45  static inline void sph_enc64le(void *dst, sph_u64 val);
46  static inline void sph_enc64le_aligned(void *dst, sph_u64 val);
47  static inline sph_u64 sph_dec64be(const void *src);
48  static inline sph_u64 sph_dec64be_aligned(const void *src);
49  static inline void sph_enc64be(void *dst, sph_u64 val);
50  static inline void sph_enc64be_aligned(void *dst, sph_u64 val);
51  #endif
52  #ifndef DOXYGEN_IGNORE
53  #undef SPH_64
54  #undef SPH_64_TRUE
55  #if defined __STDC__ && __STDC_VERSION__ >= 199901L
56  #include <stdint.h>
57  #ifdef UINT32_MAX
58  typedef uint32_t sph_u32;
59  typedef int32_t sph_s32;
60  #else
61  typedef uint_fast32_t sph_u32;
62  typedef int_fast32_t sph_s32;
63  #endif
64  #if !SPH_NO_64
65  #ifdef UINT64_MAX
66  typedef uint64_t sph_u64;
67  typedef int64_t sph_s64;
68  #else
69  typedef uint_fast64_t sph_u64;
70  typedef int_fast64_t sph_s64;
71  #endif
72  #endif
73  #define SPH_C32(x)    ((sph_u32)(x))
74  #if !SPH_NO_64
75  #define SPH_C64(x)    ((sph_u64)(x))
76  #define SPH_64  1
77  #endif
78  #else
79  #if ((UINT_MAX >> 11) >> 11) >= 0x3FF
80  typedef unsigned int sph_u32;
81  typedef int sph_s32;
82  #define SPH_C32(x)    ((sph_u32)(x ## U))
83  #else
84  typedef unsigned long sph_u32;
85  typedef long sph_s32;
86  #define SPH_C32(x)    ((sph_u32)(x ## UL))
87  #endif
88  #if !SPH_NO_64
89  #if ((ULONG_MAX >> 31) >> 31) >= 3
90  typedef unsigned long sph_u64;
91  typedef long sph_s64;
92  #define SPH_C64(x)    ((sph_u64)(x ## UL))
93  #define SPH_64  1
94  #elif ((ULLONG_MAX >> 31) >> 31) >= 3 || defined __GNUC__
95  typedef unsigned long long sph_u64;
96  typedef long long sph_s64;
97  #define SPH_C64(x)    ((sph_u64)(x ## ULL))
98  #define SPH_64  1
99  #else
100  #endif
101  #endif
102  #endif
103  #if SPH_64 && (((ULONG_MAX >> 31) >> 31) >= 3 || defined _M_X64)
104  #define SPH_64_TRUE   1
105  #endif
106  #define SPH_T32(x)    ((x) & SPH_C32(0xFFFFFFFF))
107  #define SPH_ROTL32(x, n)   SPH_T32(((x) << (n)) | ((x) >> (32 - (n))))
108  #define SPH_ROTR32(x, n)   SPH_ROTL32(x, (32 - (n)))
109  #if SPH_64
110  #define SPH_T64(x)    ((x) & SPH_C64(0xFFFFFFFFFFFFFFFF))
111  #define SPH_ROTL64(x, n)   SPH_T64(((x) << (n)) | ((x) >> (64 - (n))))
112  #define SPH_ROTR64(x, n)   SPH_ROTL64(x, (64 - (n)))
113  #endif
114  #ifndef DOXYGEN_IGNORE
115  #if (defined __STDC__ && __STDC_VERSION__ >= 199901L) || defined __GNUC__
116  #define SPH_INLINE inline
117  #elif defined _MSC_VER
118  #define SPH_INLINE __inline
119  #else
120  #define SPH_INLINE
121  #endif
122  #endif
123  #if defined __i386__ || defined _M_IX86
124  #define SPH_DETECT_UNALIGNED         1
125  #define SPH_DETECT_LITTLE_ENDIAN     1
126  #define SPH_DETECT_UPTR              sph_u32
127  #ifdef __GNUC__
128  #define SPH_DETECT_I386_GCC          1
129  #endif
130  #ifdef _MSC_VER
131  #define SPH_DETECT_I386_MSVC         1
132  #endif
133  #elif defined __x86_64 || defined _M_X64
134  #define SPH_DETECT_UNALIGNED         1
135  #define SPH_DETECT_LITTLE_ENDIAN     1
136  #define SPH_DETECT_UPTR              sph_u64
137  #ifdef __GNUC__
138  #define SPH_DETECT_AMD64_GCC         1
139  #endif
140  #ifdef _MSC_VER
141  #define SPH_DETECT_AMD64_MSVC        1
142  #endif
143  #elif ((defined __sparc__ || defined __sparc) && defined __arch64__) \
144  	|| defined __sparcv9
145  #define SPH_DETECT_BIG_ENDIAN        1
146  #define SPH_DETECT_UPTR              sph_u64
147  #ifdef __GNUC__
148  #define SPH_DETECT_SPARCV9_GCC_64    1
149  #define SPH_DETECT_LITTLE_FAST       1
150  #endif
151  #elif (defined __sparc__ || defined __sparc) \
152  	&& !(defined __sparcv9 || defined __arch64__)
153  #define SPH_DETECT_BIG_ENDIAN        1
154  #define SPH_DETECT_UPTR              sph_u32
155  #if defined __GNUC__ && defined __sparc_v9__
156  #define SPH_DETECT_SPARCV9_GCC_32    1
157  #define SPH_DETECT_LITTLE_FAST       1
158  #endif
159  #elif defined __arm__ && __ARMEL__
160  #define SPH_DETECT_LITTLE_ENDIAN     1
161  #elif MIPSEL || _MIPSEL || __MIPSEL || __MIPSEL__
162  #define SPH_DETECT_LITTLE_ENDIAN     1
163  #elif MIPSEB || _MIPSEB || __MIPSEB || __MIPSEB__
164  #define SPH_DETECT_BIG_ENDIAN        1
165  #elif defined __powerpc__ || defined __POWERPC__ || defined __ppc__ \
166  	|| defined _ARCH_PPC
167  #if defined __GNUC__
168  #if SPH_64_TRUE
169  #define SPH_DETECT_PPC64_GCC         1
170  #else
171  #define SPH_DETECT_PPC32_GCC         1
172  #endif
173  #endif
174  #if defined __BIG_ENDIAN__ || defined _BIG_ENDIAN
175  #define SPH_DETECT_BIG_ENDIAN        1
176  #elif defined __LITTLE_ENDIAN__ || defined _LITTLE_ENDIAN
177  #define SPH_DETECT_LITTLE_ENDIAN     1
178  #endif
179  #elif defined __ia64 || defined __ia64__ \
180  	|| defined __itanium__ || defined _M_IA64
181  #if defined __BIG_ENDIAN__ || defined _BIG_ENDIAN
182  #define SPH_DETECT_BIG_ENDIAN        1
183  #else
184  #define SPH_DETECT_LITTLE_ENDIAN     1
185  #endif
186  #if defined __LP64__ || defined _LP64
187  #define SPH_DETECT_UPTR              sph_u64
188  #else
189  #define SPH_DETECT_UPTR              sph_u32
190  #endif
191  #endif
192  #if defined SPH_DETECT_SPARCV9_GCC_32 || defined SPH_DETECT_SPARCV9_GCC_64
193  #define SPH_DETECT_SPARCV9_GCC       1
194  #endif
195  #if defined SPH_DETECT_UNALIGNED && !defined SPH_UNALIGNED
196  #define SPH_UNALIGNED         SPH_DETECT_UNALIGNED
197  #endif
198  #if defined SPH_DETECT_UPTR && !defined SPH_UPTR
199  #define SPH_UPTR              SPH_DETECT_UPTR
200  #endif
201  #if defined SPH_DETECT_LITTLE_ENDIAN && !defined SPH_LITTLE_ENDIAN
202  #define SPH_LITTLE_ENDIAN     SPH_DETECT_LITTLE_ENDIAN
203  #endif
204  #if defined SPH_DETECT_BIG_ENDIAN && !defined SPH_BIG_ENDIAN
205  #define SPH_BIG_ENDIAN        SPH_DETECT_BIG_ENDIAN
206  #endif
207  #if defined SPH_DETECT_LITTLE_FAST && !defined SPH_LITTLE_FAST
208  #define SPH_LITTLE_FAST       SPH_DETECT_LITTLE_FAST
209  #endif
210  #if defined SPH_DETECT_BIG_FAST && !defined SPH_BIG_FAST
211  #define SPH_BIG_FAST    SPH_DETECT_BIG_FAST
212  #endif
213  #if defined SPH_DETECT_SPARCV9_GCC_32 && !defined SPH_SPARCV9_GCC_32
214  #define SPH_SPARCV9_GCC_32    SPH_DETECT_SPARCV9_GCC_32
215  #endif
216  #if defined SPH_DETECT_SPARCV9_GCC_64 && !defined SPH_SPARCV9_GCC_64
217  #define SPH_SPARCV9_GCC_64    SPH_DETECT_SPARCV9_GCC_64
218  #endif
219  #if defined SPH_DETECT_SPARCV9_GCC && !defined SPH_SPARCV9_GCC
220  #define SPH_SPARCV9_GCC       SPH_DETECT_SPARCV9_GCC
221  #endif
222  #if defined SPH_DETECT_I386_GCC && !defined SPH_I386_GCC
223  #define SPH_I386_GCC          SPH_DETECT_I386_GCC
224  #endif
225  #if defined SPH_DETECT_I386_MSVC && !defined SPH_I386_MSVC
226  #define SPH_I386_MSVC         SPH_DETECT_I386_MSVC
227  #endif
228  #if defined SPH_DETECT_AMD64_GCC && !defined SPH_AMD64_GCC
229  #define SPH_AMD64_GCC         SPH_DETECT_AMD64_GCC
230  #endif
231  #if defined SPH_DETECT_AMD64_MSVC && !defined SPH_AMD64_MSVC
232  #define SPH_AMD64_MSVC        SPH_DETECT_AMD64_MSVC
233  #endif
234  #if defined SPH_DETECT_PPC32_GCC && !defined SPH_PPC32_GCC
235  #define SPH_PPC32_GCC         SPH_DETECT_PPC32_GCC
236  #endif
237  #if defined SPH_DETECT_PPC64_GCC && !defined SPH_PPC64_GCC
238  #define SPH_PPC64_GCC         SPH_DETECT_PPC64_GCC
239  #endif
240  #if SPH_LITTLE_ENDIAN && !defined SPH_LITTLE_FAST
241  #define SPH_LITTLE_FAST              1
242  #endif
243  #if SPH_BIG_ENDIAN && !defined SPH_BIG_FAST
244  #define SPH_BIG_FAST                 1
245  #endif
246  #if defined SPH_UPTR && !(SPH_LITTLE_ENDIAN || SPH_BIG_ENDIAN)
247  #error SPH_UPTR defined, but endianness is not known.
248  #endif
249  #if SPH_I386_GCC && !SPH_NO_ASM
250  static SPH_INLINE sph_u32
251  sph_bswap32(sph_u32 x)
252  {
253  	__asm__ __volatile__ ("bswapl %0" : "=r" (x) : "0" (x));
254  	return x;
255  }
256  #if SPH_64
257  static SPH_INLINE sph_u64
258  sph_bswap64(sph_u64 x)
259  {
260  	return ((sph_u64)sph_bswap32((sph_u32)x) << 32)
261  		| (sph_u64)sph_bswap32((sph_u32)(x >> 32));
262  }
263  #endif
264  #elif SPH_AMD64_GCC && !SPH_NO_ASM
265  static SPH_INLINE sph_u32
266  sph_bswap32(sph_u32 x)
267  {
268  	__asm__ __volatile__ ("bswapl %0" : "=r" (x) : "0" (x));
269  	return x;
270  }
271  #if SPH_64
272  static SPH_INLINE sph_u64
273  sph_bswap64(sph_u64 x)
274  {
275  	__asm__ __volatile__ ("bswapq %0" : "=r" (x) : "0" (x));
276  	return x;
277  }
278  #endif
279  #else
280  static SPH_INLINE sph_u32
281  sph_bswap32(sph_u32 x)
282  {
283  	x = SPH_T32((x << 16) | (x >> 16));
284  	x = ((x & SPH_C32(0xFF00FF00)) >> 8)
285  		| ((x & SPH_C32(0x00FF00FF)) << 8);
286  	return x;
287  }
288  #if SPH_64
289  static SPH_INLINE sph_u64
290  sph_bswap64(sph_u64 x)
291  {
292  	x = SPH_T64((x << 32) | (x >> 32));
293  	x = ((x & SPH_C64(0xFFFF0000FFFF0000)) >> 16)
294  		| ((x & SPH_C64(0x0000FFFF0000FFFF)) << 16);
295  	x = ((x & SPH_C64(0xFF00FF00FF00FF00)) >> 8)
296  		| ((x & SPH_C64(0x00FF00FF00FF00FF)) << 8);
297  	return x;
298  }
299  #endif
300  #endif
301  #if SPH_SPARCV9_GCC && !SPH_NO_ASM
302  #define SPH_SPARCV9_SET_ASI   \
303  	sph_u32 sph_sparcv9_asi; \
304  	__asm__ __volatile__ ( \
305  		"rd %%asi,%0\n\twr %%g0,0x88,%%asi" : "=r" (sph_sparcv9_asi));
306  #define SPH_SPARCV9_RESET_ASI  \
307  	__asm__ __volatile__ ("wr %%g0,%0,%%asi" : : "r" (sph_sparcv9_asi));
308  #define SPH_SPARCV9_DEC32LE(base, idx)   ({ \
309  		sph_u32 sph_sparcv9_tmp; \
310  		__asm__ __volatile__ ("lda [%1+" #idx "*4]%%asi,%0" \
311  			: "=r" (sph_sparcv9_tmp) : "r" (base)); \
312  		sph_sparcv9_tmp; \
313  	})
314  #endif
315  static SPH_INLINE void
316  sph_enc16be(void *dst, unsigned val)
317  {
318  	((unsigned char *)dst)[0] = (val >> 8);
319  	((unsigned char *)dst)[1] = val;
<span onclick='openModal()' class='match'>320  }
321  static SPH_INLINE unsigned
322  sph_dec16be(const void *src)
323  {
324  	return ((unsigned)(((const unsigned char *)src)[0]) << 8)
325  		| (unsigned)(((const unsigned char *)src)[1]);
326  }
327  static SPH_INLINE void
328  sph_enc16le(void *dst, unsigned val)
329  {
330  	((unsigned char *)dst)[0] = val;
</span>331  	((unsigned char *)dst)[1] = val >> 8;
332  }
333  static SPH_INLINE unsigned
334  sph_dec16le(const void *src)
335  {
336  	return (unsigned)(((const unsigned char *)src)[0])
337  		| ((unsigned)(((const unsigned char *)src)[1]) << 8);
338  }
339  static SPH_INLINE void
340  sph_enc32be(void *dst, sph_u32 val)
341  {
342  #if defined SPH_UPTR
343  #if SPH_UNALIGNED
344  #if SPH_LITTLE_ENDIAN
345  	val = sph_bswap32(val);
346  #endif
347  	*(sph_u32 *)dst = val;
348  #else
349  	if (((SPH_UPTR)dst & 3) == 0) {
350  #if SPH_LITTLE_ENDIAN
351  		val = sph_bswap32(val);
352  #endif
353  		*(sph_u32 *)dst = val;
354  	} else {
355  		((unsigned char *)dst)[0] = (val >> 24);
356  		((unsigned char *)dst)[1] = (val >> 16);
357  		((unsigned char *)dst)[2] = (val >> 8);
358  		((unsigned char *)dst)[3] = val;
359  	}
360  #endif
361  #else
362  	((unsigned char *)dst)[0] = (val >> 24);
363  	((unsigned char *)dst)[1] = (val >> 16);
364  	((unsigned char *)dst)[2] = (val >> 8);
365  	((unsigned char *)dst)[3] = val;
366  #endif
367  }
368  static SPH_INLINE void
369  sph_enc32be_aligned(void *dst, sph_u32 val)
370  {
371  #if SPH_LITTLE_ENDIAN
372  	*(sph_u32 *)dst = sph_bswap32(val);
373  #elif SPH_BIG_ENDIAN
374  	*(sph_u32 *)dst = val;
375  #else
376  	((unsigned char *)dst)[0] = (val >> 24);
377  	((unsigned char *)dst)[1] = (val >> 16);
378  	((unsigned char *)dst)[2] = (val >> 8);
379  	((unsigned char *)dst)[3] = val;
380  #endif
381  }
382  static SPH_INLINE sph_u32
383  sph_dec32be(const void *src)
384  {
385  #if defined SPH_UPTR
386  #if SPH_UNALIGNED
387  #if SPH_LITTLE_ENDIAN
388  	return sph_bswap32(*(const sph_u32 *)src);
389  #else
390  	return *(const sph_u32 *)src;
391  #endif
392  #else
393  	if (((SPH_UPTR)src & 3) == 0) {
394  #if SPH_LITTLE_ENDIAN
395  		return sph_bswap32(*(const sph_u32 *)src);
396  #else
397  		return *(const sph_u32 *)src;
398  #endif
399  	} else {
400  		return ((sph_u32)(((const unsigned char *)src)[0]) << 24)
401  			| ((sph_u32)(((const unsigned char *)src)[1]) << 16)
402  			| ((sph_u32)(((const unsigned char *)src)[2]) << 8)
403  			| (sph_u32)(((const unsigned char *)src)[3]);
404  	}
405  #endif
406  #else
407  	return ((sph_u32)(((const unsigned char *)src)[0]) << 24)
408  		| ((sph_u32)(((const unsigned char *)src)[1]) << 16)
409  		| ((sph_u32)(((const unsigned char *)src)[2]) << 8)
410  		| (sph_u32)(((const unsigned char *)src)[3]);
411  #endif
412  }
413  static SPH_INLINE sph_u32
414  sph_dec32be_aligned(const void *src)
415  {
416  #if SPH_LITTLE_ENDIAN
417  	return sph_bswap32(*(const sph_u32 *)src);
418  #elif SPH_BIG_ENDIAN
419  	return *(const sph_u32 *)src;
420  #else
421  	return ((sph_u32)(((const unsigned char *)src)[0]) << 24)
422  		| ((sph_u32)(((const unsigned char *)src)[1]) << 16)
423  		| ((sph_u32)(((const unsigned char *)src)[2]) << 8)
424  		| (sph_u32)(((const unsigned char *)src)[3]);
425  #endif
426  }
427  static SPH_INLINE void
428  sph_enc32le(void *dst, sph_u32 val)
429  {
430  #if defined SPH_UPTR
431  #if SPH_UNALIGNED
432  #if SPH_BIG_ENDIAN
433  	val = sph_bswap32(val);
434  #endif
435  	*(sph_u32 *)dst = val;
436  #else
437  	if (((SPH_UPTR)dst & 3) == 0) {
438  #if SPH_BIG_ENDIAN
439  		val = sph_bswap32(val);
440  #endif
441  		*(sph_u32 *)dst = val;
442  	} else {
443  		((unsigned char *)dst)[0] = val;
444  		((unsigned char *)dst)[1] = (val >> 8);
445  		((unsigned char *)dst)[2] = (val >> 16);
446  		((unsigned char *)dst)[3] = (val >> 24);
447  	}
448  #endif
449  #else
450  	((unsigned char *)dst)[0] = val;
451  	((unsigned char *)dst)[1] = (val >> 8);
452  	((unsigned char *)dst)[2] = (val >> 16);
453  	((unsigned char *)dst)[3] = (val >> 24);
454  #endif
455  }
456  static SPH_INLINE void
457  sph_enc32le_aligned(void *dst, sph_u32 val)
458  {
459  #if SPH_LITTLE_ENDIAN
460  	*(sph_u32 *)dst = val;
461  #elif SPH_BIG_ENDIAN
462  	*(sph_u32 *)dst = sph_bswap32(val);
463  #else
464  	((unsigned char *)dst)[0] = val;
465  	((unsigned char *)dst)[1] = (val >> 8);
466  	((unsigned char *)dst)[2] = (val >> 16);
467  	((unsigned char *)dst)[3] = (val >> 24);
468  #endif
469  }
470  static SPH_INLINE sph_u32
471  sph_dec32le(const void *src)
472  {
473  #if defined SPH_UPTR
474  #if SPH_UNALIGNED
475  #if SPH_BIG_ENDIAN
476  	return sph_bswap32(*(const sph_u32 *)src);
477  #else
478  	return *(const sph_u32 *)src;
479  #endif
480  #else
481  	if (((SPH_UPTR)src & 3) == 0) {
482  #if SPH_BIG_ENDIAN
483  #if SPH_SPARCV9_GCC && !SPH_NO_ASM
484  		sph_u32 tmp;
485  		__asm__ __volatile__ (
486  			"lda [%1]0x88,%0" : "=r" (tmp) : "r" (src));
487  		return tmp;
488  #else
489  		return sph_bswap32(*(const sph_u32 *)src);
490  #endif
491  #else
492  		return *(const sph_u32 *)src;
493  #endif
494  	} else {
495  		return (sph_u32)(((const unsigned char *)src)[0])
496  			| ((sph_u32)(((const unsigned char *)src)[1]) << 8)
497  			| ((sph_u32)(((const unsigned char *)src)[2]) << 16)
498  			| ((sph_u32)(((const unsigned char *)src)[3]) << 24);
499  	}
500  #endif
501  #else
502  	return (sph_u32)(((const unsigned char *)src)[0])
503  		| ((sph_u32)(((const unsigned char *)src)[1]) << 8)
504  		| ((sph_u32)(((const unsigned char *)src)[2]) << 16)
505  		| ((sph_u32)(((const unsigned char *)src)[3]) << 24);
506  #endif
507  }
508  static SPH_INLINE sph_u32
509  sph_dec32le_aligned(const void *src)
510  {
511  #if SPH_LITTLE_ENDIAN
512  	return *(const sph_u32 *)src;
513  #elif SPH_BIG_ENDIAN
514  #if SPH_SPARCV9_GCC && !SPH_NO_ASM
515  	sph_u32 tmp;
516  	__asm__ __volatile__ ("lda [%1]0x88,%0" : "=r" (tmp) : "r" (src));
517  	return tmp;
518  #else
519  	return sph_bswap32(*(const sph_u32 *)src);
520  #endif
521  #else
522  	return (sph_u32)(((const unsigned char *)src)[0])
523  		| ((sph_u32)(((const unsigned char *)src)[1]) << 8)
524  		| ((sph_u32)(((const unsigned char *)src)[2]) << 16)
525  		| ((sph_u32)(((const unsigned char *)src)[3]) << 24);
526  #endif
527  }
528  #if SPH_64
529  static SPH_INLINE void
530  sph_enc64be(void *dst, sph_u64 val)
531  {
532  #if defined SPH_UPTR
533  #if SPH_UNALIGNED
534  #if SPH_LITTLE_ENDIAN
535  	val = sph_bswap64(val);
536  #endif
537  	*(sph_u64 *)dst = val;
538  #else
539  	if (((SPH_UPTR)dst & 7) == 0) {
540  #if SPH_LITTLE_ENDIAN
541  		val = sph_bswap64(val);
542  #endif
543  		*(sph_u64 *)dst = val;
544  	} else {
545  		((unsigned char *)dst)[0] = (val >> 56);
546  		((unsigned char *)dst)[1] = (val >> 48);
547  		((unsigned char *)dst)[2] = (val >> 40);
548  		((unsigned char *)dst)[3] = (val >> 32);
549  		((unsigned char *)dst)[4] = (val >> 24);
550  		((unsigned char *)dst)[5] = (val >> 16);
551  		((unsigned char *)dst)[6] = (val >> 8);
552  		((unsigned char *)dst)[7] = val;
553  	}
554  #endif
555  #else
556  	((unsigned char *)dst)[0] = (val >> 56);
557  	((unsigned char *)dst)[1] = (val >> 48);
558  	((unsigned char *)dst)[2] = (val >> 40);
559  	((unsigned char *)dst)[3] = (val >> 32);
560  	((unsigned char *)dst)[4] = (val >> 24);
561  	((unsigned char *)dst)[5] = (val >> 16);
562  	((unsigned char *)dst)[6] = (val >> 8);
563  	((unsigned char *)dst)[7] = val;
564  #endif
565  }
566  static SPH_INLINE void
567  sph_enc64be_aligned(void *dst, sph_u64 val)
568  {
569  #if SPH_LITTLE_ENDIAN
570  	*(sph_u64 *)dst = sph_bswap64(val);
571  #elif SPH_BIG_ENDIAN
572  	*(sph_u64 *)dst = val;
573  #else
574  	((unsigned char *)dst)[0] = (val >> 56);
575  	((unsigned char *)dst)[1] = (val >> 48);
576  	((unsigned char *)dst)[2] = (val >> 40);
577  	((unsigned char *)dst)[3] = (val >> 32);
578  	((unsigned char *)dst)[4] = (val >> 24);
579  	((unsigned char *)dst)[5] = (val >> 16);
580  	((unsigned char *)dst)[6] = (val >> 8);
581  	((unsigned char *)dst)[7] = val;
582  #endif
583  }
584  static SPH_INLINE sph_u64
585  sph_dec64be(const void *src)
586  {
587  #if defined SPH_UPTR
588  #if SPH_UNALIGNED
589  #if SPH_LITTLE_ENDIAN
590  	return sph_bswap64(*(const sph_u64 *)src);
591  #else
592  	return *(const sph_u64 *)src;
593  #endif
594  #else
595  	if (((SPH_UPTR)src & 7) == 0) {
596  #if SPH_LITTLE_ENDIAN
597  		return sph_bswap64(*(const sph_u64 *)src);
598  #else
599  		return *(const sph_u64 *)src;
600  #endif
601  	} else {
602  		return ((sph_u64)(((const unsigned char *)src)[0]) << 56)
603  			| ((sph_u64)(((const unsigned char *)src)[1]) << 48)
604  			| ((sph_u64)(((const unsigned char *)src)[2]) << 40)
605  			| ((sph_u64)(((const unsigned char *)src)[3]) << 32)
606  			| ((sph_u64)(((const unsigned char *)src)[4]) << 24)
607  			| ((sph_u64)(((const unsigned char *)src)[5]) << 16)
608  			| ((sph_u64)(((const unsigned char *)src)[6]) << 8)
609  			| (sph_u64)(((const unsigned char *)src)[7]);
610  	}
611  #endif
612  #else
613  	return ((sph_u64)(((const unsigned char *)src)[0]) << 56)
614  		| ((sph_u64)(((const unsigned char *)src)[1]) << 48)
615  		| ((sph_u64)(((const unsigned char *)src)[2]) << 40)
616  		| ((sph_u64)(((const unsigned char *)src)[3]) << 32)
617  		| ((sph_u64)(((const unsigned char *)src)[4]) << 24)
618  		| ((sph_u64)(((const unsigned char *)src)[5]) << 16)
619  		| ((sph_u64)(((const unsigned char *)src)[6]) << 8)
620  		| (sph_u64)(((const unsigned char *)src)[7]);
621  #endif
622  }
623  static SPH_INLINE sph_u64
624  sph_dec64be_aligned(const void *src)
625  {
626  #if SPH_LITTLE_ENDIAN
627  	return sph_bswap64(*(const sph_u64 *)src);
628  #elif SPH_BIG_ENDIAN
629  	return *(const sph_u64 *)src;
630  #else
631  	return ((sph_u64)(((const unsigned char *)src)[0]) << 56)
632  		| ((sph_u64)(((const unsigned char *)src)[1]) << 48)
633  		| ((sph_u64)(((const unsigned char *)src)[2]) << 40)
634  		| ((sph_u64)(((const unsigned char *)src)[3]) << 32)
635  		| ((sph_u64)(((const unsigned char *)src)[4]) << 24)
636  		| ((sph_u64)(((const unsigned char *)src)[5]) << 16)
637  		| ((sph_u64)(((const unsigned char *)src)[6]) << 8)
638  		| (sph_u64)(((const unsigned char *)src)[7]);
639  #endif
640  }
641  static SPH_INLINE void
642  sph_enc64le(void *dst, sph_u64 val)
643  {
644  #if defined SPH_UPTR
645  #if SPH_UNALIGNED
646  #if SPH_BIG_ENDIAN
647  	val = sph_bswap64(val);
648  #endif
649  	*(sph_u64 *)dst = val;
650  #else
651  	if (((SPH_UPTR)dst & 7) == 0) {
652  #if SPH_BIG_ENDIAN
653  		val = sph_bswap64(val);
654  #endif
655  		*(sph_u64 *)dst = val;
656  	} else {
657  		((unsigned char *)dst)[0] = val;
658  		((unsigned char *)dst)[1] = (val >> 8);
659  		((unsigned char *)dst)[2] = (val >> 16);
660  		((unsigned char *)dst)[3] = (val >> 24);
661  		((unsigned char *)dst)[4] = (val >> 32);
662  		((unsigned char *)dst)[5] = (val >> 40);
663  		((unsigned char *)dst)[6] = (val >> 48);
664  		((unsigned char *)dst)[7] = (val >> 56);
665  	}
666  #endif
667  #else
668  	((unsigned char *)dst)[0] = val;
669  	((unsigned char *)dst)[1] = (val >> 8);
670  	((unsigned char *)dst)[2] = (val >> 16);
671  	((unsigned char *)dst)[3] = (val >> 24);
672  	((unsigned char *)dst)[4] = (val >> 32);
673  	((unsigned char *)dst)[5] = (val >> 40);
674  	((unsigned char *)dst)[6] = (val >> 48);
675  	((unsigned char *)dst)[7] = (val >> 56);
676  #endif
677  }
678  static SPH_INLINE void
679  sph_enc64le_aligned(void *dst, sph_u64 val)
680  {
681  #if SPH_LITTLE_ENDIAN
682  	*(sph_u64 *)dst = val;
683  #elif SPH_BIG_ENDIAN
684  	*(sph_u64 *)dst = sph_bswap64(val);
685  #else
686  	((unsigned char *)dst)[0] = val;
687  	((unsigned char *)dst)[1] = (val >> 8);
688  	((unsigned char *)dst)[2] = (val >> 16);
689  	((unsigned char *)dst)[3] = (val >> 24);
690  	((unsigned char *)dst)[4] = (val >> 32);
691  	((unsigned char *)dst)[5] = (val >> 40);
692  	((unsigned char *)dst)[6] = (val >> 48);
693  	((unsigned char *)dst)[7] = (val >> 56);
694  #endif
695  }
696  static SPH_INLINE sph_u64
697  sph_dec64le(const void *src)
698  {
699  #if defined SPH_UPTR
700  #if SPH_UNALIGNED
701  #if SPH_BIG_ENDIAN
702  	return sph_bswap64(*(const sph_u64 *)src);
703  #else
704  	return *(const sph_u64 *)src;
705  #endif
706  #else
707  	if (((SPH_UPTR)src & 7) == 0) {
708  #if SPH_BIG_ENDIAN
709  #if SPH_SPARCV9_GCC_64 && !SPH_NO_ASM
710  		sph_u64 tmp;
711  		__asm__ __volatile__ (
712  			"ldxa [%1]0x88,%0" : "=r" (tmp) : "r" (src));
713  		return tmp;
714  #else
715  		return sph_bswap64(*(const sph_u64 *)src);
716  #endif
717  #else
718  		return *(const sph_u64 *)src;
719  #endif
720  	} else {
721  		return (sph_u64)(((const unsigned char *)src)[0])
722  			| ((sph_u64)(((const unsigned char *)src)[1]) << 8)
723  			| ((sph_u64)(((const unsigned char *)src)[2]) << 16)
724  			| ((sph_u64)(((const unsigned char *)src)[3]) << 24)
725  			| ((sph_u64)(((const unsigned char *)src)[4]) << 32)
726  			| ((sph_u64)(((const unsigned char *)src)[5]) << 40)
727  			| ((sph_u64)(((const unsigned char *)src)[6]) << 48)
728  			| ((sph_u64)(((const unsigned char *)src)[7]) << 56);
729  	}
730  #endif
731  #else
732  	return (sph_u64)(((const unsigned char *)src)[0])
733  		| ((sph_u64)(((const unsigned char *)src)[1]) << 8)
734  		| ((sph_u64)(((const unsigned char *)src)[2]) << 16)
735  		| ((sph_u64)(((const unsigned char *)src)[3]) << 24)
736  		| ((sph_u64)(((const unsigned char *)src)[4]) << 32)
737  		| ((sph_u64)(((const unsigned char *)src)[5]) << 40)
738  		| ((sph_u64)(((const unsigned char *)src)[6]) << 48)
739  		| ((sph_u64)(((const unsigned char *)src)[7]) << 56);
740  #endif
741  }
742  static SPH_INLINE sph_u64
743  sph_dec64le_aligned(const void *src)
744  {
745  #if SPH_LITTLE_ENDIAN
746  	return *(const sph_u64 *)src;
747  #elif SPH_BIG_ENDIAN
748  #if SPH_SPARCV9_GCC_64 && !SPH_NO_ASM
749  	sph_u64 tmp;
750  	__asm__ __volatile__ ("ldxa [%1]0x88,%0" : "=r" (tmp) : "r" (src));
751  	return tmp;
752  #else
753  	return sph_bswap64(*(const sph_u64 *)src);
754  #endif
755  #else
756  	return (sph_u64)(((const unsigned char *)src)[0])
757  		| ((sph_u64)(((const unsigned char *)src)[1]) << 8)
758  		| ((sph_u64)(((const unsigned char *)src)[2]) << 16)
759  		| ((sph_u64)(((const unsigned char *)src)[3]) << 24)
760  		| ((sph_u64)(((const unsigned char *)src)[4]) << 32)
761  		| ((sph_u64)(((const unsigned char *)src)[5]) << 40)
762  		| ((sph_u64)(((const unsigned char *)src)[6]) << 48)
763  		| ((sph_u64)(((const unsigned char *)src)[7]) << 56);
764  #endif
765  }
766  #endif
767  #endif &bsol;* Doxygen excluded block */
768  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-stream_buffer.c</h3>
            <pre><code>1  #include <stdint.h>
2  #include <string.h>
3  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
4  #include "FreeRTOS.h"
5  #include "task.h"
6  #include "stream_buffer.h"
7  #if( configUSE_TASK_NOTIFICATIONS != 1 )
8  	#error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c
9  #endif
10  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE &bsol;*lint !e961 !e750. */
11  #ifndef sbRECEIVE_COMPLETED
12  	#define sbRECEIVE_COMPLETED( pxStreamBuffer )										\
13  		vTaskSuspendAll();																\
14  		{																				\
15  			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
16  			{																			\
17  				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend,			\
18  									  ( uint32_t ) 0,									\
19  									  eNoAction );										\
20  				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
21  			}																			\
22  		}																				\
23  		( void ) xTaskResumeAll();
24  #endif &bsol;* sbRECEIVE_COMPLETED */
25  #ifndef sbRECEIVE_COMPLETED_FROM_ISR
26  	#define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,								\
27  										  pxHigherPriorityTaskWoken )					\
28  	{																					\
29  	UBaseType_t uxSavedInterruptStatus;													\
30  																						\
31  		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
32  		{																				\
33  			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
34  			{																			\
35  				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,	\
36  											 ( uint32_t ) 0,							\
37  											 eNoAction,									\
38  											 pxHigherPriorityTaskWoken );				\
39  				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
40  			}																			\
41  		}																				\
42  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
43  	}
44  #endif &bsol;* sbRECEIVE_COMPLETED_FROM_ISR */
45  #ifndef sbSEND_COMPLETED
46  	#define sbSEND_COMPLETED( pxStreamBuffer )											\
47  		vTaskSuspendAll();																\
48  		{																				\
49  			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
50  			{																			\
51  				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive,		\
52  									  ( uint32_t ) 0,									\
53  									  eNoAction );										\
54  				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
55  			}																			\
56  		}																				\
57  		( void ) xTaskResumeAll();
58  #endif &bsol;* sbSEND_COMPLETED */
59  #ifndef sbSEND_COMPLETE_FROM_ISR
60  	#define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )		\
61  	{																					\
62  	UBaseType_t uxSavedInterruptStatus;													\
63  																						\
64  		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
65  		{																				\
66  			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
67  			{																			\
68  				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,	\
69  											 ( uint32_t ) 0,							\
70  											 eNoAction,									\
71  											 pxHigherPriorityTaskWoken );				\
72  				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
73  			}																			\
74  		}																				\
75  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
76  	}
77  #endif &bsol;* sbSEND_COMPLETE_FROM_ISR */
78  #define sbBYTES_TO_STORE_MESSAGE_LENGTH ( sizeof( size_t ) )
79  #define sbFLAGS_IS_MESSAGE_BUFFER		( ( uint8_t ) 1 ) &bsol;* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */
80  #define sbFLAGS_IS_STATICALLY_ALLOCATED ( ( uint8_t ) 2 ) &bsol;* Set if the stream buffer was created using statically allocated memory. */
81  typedef struct xSTREAM_BUFFER &bsol;*lint !e9058 Style convention uses tag. */
82  {
83  	volatile size_t xTail;				&bsol;* Index to the next item to read within the buffer. */
84  	volatile size_t xHead;				&bsol;* Index to the next item to write within the buffer. */
85  	size_t xLength;						&bsol;* The length of the buffer pointed to by pucBuffer. */
86  	size_t xTriggerLevelBytes;			&bsol;* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */
87  	volatile TaskHandle_t xTaskWaitingToReceive; &bsol;* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */
88  	volatile TaskHandle_t xTaskWaitingToSend;	&bsol;* Holds the handle of a task waiting to send data to a message buffer that is full. */
89  	uint8_t *pucBuffer;					&bsol;* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */
90  	uint8_t ucFlags;
91  	#if ( configUSE_TRACE_FACILITY == 1 )
92  		UBaseType_t uxStreamBufferNumber;		&bsol;* Used for tracing purposes. */
93  	#endif
94  } StreamBuffer_t;
95  static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;
96  static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount ) PRIVILEGED_FUNCTION;
97  static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
98  										void *pvRxData,
99  										size_t xBufferLengthBytes,
100  										size_t xBytesAvailable,
101  										size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;
102  static size_t prvWriteMessageToBuffer(  StreamBuffer_t * const pxStreamBuffer,
103  										const void * pvTxData,
104  										size_t xDataLengthBytes,
105  										size_t xSpace,
106  										size_t xRequiredSpace ) PRIVILEGED_FUNCTION;
107  static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer,
108  									  uint8_t *pucData,
109  									  size_t xMaxCount,
110  									  size_t xBytesAvailable ); PRIVILEGED_FUNCTION
111  static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
112  										  uint8_t * const pucBuffer,
113  										  size_t xBufferSizeBytes,
114  										  size_t xTriggerLevelBytes,
115  										  BaseType_t xIsMessageBuffer ) PRIVILEGED_FUNCTION;
116  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
117  	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
118  	{
119  	uint8_t *pucAllocatedMemory;
120  		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
121  		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
122  		if( xTriggerLevelBytes == ( size_t ) 0 )
123  		{
124  			xTriggerLevelBytes = ( size_t ) 1; &bsol;*lint !e9044 Parameter modified to ensure it doesn't have a dangerous value. */
125  		}
126  		xBufferSizeBytes++;
127  		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); &bsol;*lint !e9079 malloc() only returns void*. */
128  		if( pucAllocatedMemory != NULL )
129  		{
130  			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, &bsol;* Structure at the start of the allocated memory. */ &bsol;*lint !e9087 Safe cast as allocated memory is aligned. */ &bsol;*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
131  										   pucAllocatedMemory + sizeof( StreamBuffer_t ),  &bsol;* Storage area follows. */ &bsol;*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
132  										   xBufferSizeBytes,
133  										   xTriggerLevelBytes,
134  										   xIsMessageBuffer );
135  			traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
136  		}
137  		else
138  		{
139  			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
140  		}
141  		return ( StreamBufferHandle_t * ) pucAllocatedMemory; &bsol;*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
142  	}
143  #endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
144  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
145  	StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
146  														   size_t xTriggerLevelBytes,
147  														   BaseType_t xIsMessageBuffer,
148  														   uint8_t * const pucStreamBufferStorageArea,
149  														   StaticStreamBuffer_t * const pxStaticStreamBuffer )
150  	{
151  	StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; &bsol;*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */
152  	StreamBufferHandle_t xReturn;
153  		configASSERT( pucStreamBufferStorageArea );
154  		configASSERT( pxStaticStreamBuffer );
155  		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
156  		if( xTriggerLevelBytes == ( size_t ) 0 )
157  		{
158  			xTriggerLevelBytes = ( size_t ) 1; &bsol;*lint !e9044 Function parameter deliberately modified to ensure it is in range. */
159  		}
160  		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
161  		#if( configASSERT_DEFINED == 1 )
162  		{
163  			volatile size_t xSize = sizeof( StaticStreamBuffer_t );
164  			configASSERT( xSize == sizeof( StreamBuffer_t ) );
165  		}
166  		#endif &bsol;* configASSERT_DEFINED */
167  		if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
168  		{
169  			prvInitialiseNewStreamBuffer( pxStreamBuffer,
170  										  pucStreamBufferStorageArea,
171  										  xBufferSizeBytes,
172  										  xTriggerLevelBytes,
173  										  xIsMessageBuffer );
174  			pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
175  			traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
176  			xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; &bsol;*lint !e9087 Data hiding requires cast to opaque type. */
177  		}
178  		else
179  		{
180  			xReturn = NULL;
181  			traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
182  		}
183  		return xReturn;
184  	}
185  #endif &bsol;* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
186  void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
187  {
188  StreamBuffer_t * pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
189  	configASSERT( pxStreamBuffer );
190  	traceSTREAM_BUFFER_DELETE( xStreamBuffer );
191  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
192  	{
193  		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
194  		{
195  			vPortFree( ( void * ) pxStreamBuffer ); &bsol;*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
196  		}
197  		#else
198  		{
199  			configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
200  		}
201  		#endif
202  	}
203  	else
204  	{
205  		memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
206  	}
207  }
208  BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
209  {
210  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
211  BaseType_t xReturn = pdFAIL, xIsMessageBuffer;
212  #if( configUSE_TRACE_FACILITY == 1 )
213  	UBaseType_t uxStreamBufferNumber;
214  #endif
215  	configASSERT( pxStreamBuffer );
216  	#if( configUSE_TRACE_FACILITY == 1 )
217  	{
218  		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
219  	}
220  	#endif
221  	if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
222  	{
223  		if( pxStreamBuffer->xTaskWaitingToSend == NULL )
224  		{
225  			if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
226  			{
227  				xIsMessageBuffer = pdTRUE;
228  			}
229  			else
230  			{
231  				xIsMessageBuffer = pdFALSE;
232  			}
233  			prvInitialiseNewStreamBuffer( pxStreamBuffer,
234  										  pxStreamBuffer->pucBuffer,
235  										  pxStreamBuffer->xLength,
236  										  pxStreamBuffer->xTriggerLevelBytes,
237  										  xIsMessageBuffer );
238  			xReturn = pdPASS;
239  			#if( configUSE_TRACE_FACILITY == 1 )
240  			{
241  				pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
242  			}
243  			#endif
244  			traceSTREAM_BUFFER_RESET( xStreamBuffer );
245  		}
246  	}
247  	return xReturn;
248  }
249  BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
250  {
251  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
252  BaseType_t xReturn;
253  	configASSERT( pxStreamBuffer );
254  	if( xTriggerLevel == ( size_t ) 0 )
255  	{
256  		xTriggerLevel = ( size_t ) 1; &bsol;*lint !e9044 Parameter modified to ensure it doesn't have a dangerous value. */
257  	}
258  	if( xTriggerLevel <= pxStreamBuffer->xLength )
259  	{
260  		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
261  		xReturn = pdPASS;
262  	}
263  	else
264  	{
265  		xReturn = pdFALSE;
266  	}
267  	return xReturn;
268  }
269  size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
270  {
271  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
272  size_t xSpace;
273  	configASSERT( pxStreamBuffer );
274  	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
275  	xSpace -= pxStreamBuffer->xHead;
276  	xSpace -= ( size_t ) 1;
277  	if( xSpace >= pxStreamBuffer->xLength )
278  	{
279  		xSpace -= pxStreamBuffer->xLength;
280  	}
281  	else
282  	{
283  		mtCOVERAGE_TEST_MARKER();
284  	}
285  	return xSpace;
286  }
287  size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
288  {
289  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
290  size_t xReturn;
291  	configASSERT( pxStreamBuffer );
292  	xReturn = prvBytesInBuffer( pxStreamBuffer );
293  	return xReturn;
294  }
295  size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
296  						  const void *pvTxData,
297  						  size_t xDataLengthBytes,
298  						  TickType_t xTicksToWait )
299  {
300  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
301  size_t xReturn, xSpace = 0;
302  size_t xRequiredSpace = xDataLengthBytes;
303  TimeOut_t xTimeOut;
304  	configASSERT( pvTxData );
305  	configASSERT( pxStreamBuffer );
306  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
307  	{
308  		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
309  	}
310  	else
311  	{
312  		mtCOVERAGE_TEST_MARKER();
313  	}
314  	if( xTicksToWait != ( TickType_t ) 0 )
315  	{
316  		vTaskSetTimeOutState( &xTimeOut );
317  		do
318  		{
319  			taskENTER_CRITICAL();
320  			{
321  				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
322  				if( xSpace < xRequiredSpace )
323  				{
324  					( void ) xTaskNotifyStateClear( NULL );
325  					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
326  					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
327  				}
328  				else
329  				{
330  					taskEXIT_CRITICAL();
331  					break;
332  				}
333  			}
334  			taskEXIT_CRITICAL();
335  			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
336  			( void ) xTaskNotifyWait( ( uint32_t ) 0, UINT32_MAX, NULL, xTicksToWait );
337  			pxStreamBuffer->xTaskWaitingToSend = NULL;
338  		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
339  	}
340  	else
341  	{
342  		mtCOVERAGE_TEST_MARKER();
343  	}
344  	if( xSpace == ( size_t ) 0 )
345  	{
346  		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
347  	}
348  	else
349  	{
350  		mtCOVERAGE_TEST_MARKER();
351  	}
352  	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
353  	if( xReturn > ( size_t ) 0 )
354  	{
355  		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
356  		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
357  		{
358  			sbSEND_COMPLETED( pxStreamBuffer );
359  		}
360  		else
361  		{
362  			mtCOVERAGE_TEST_MARKER();
363  		}
364  	}
365  	else
366  	{
367  		mtCOVERAGE_TEST_MARKER();
368  		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
369  	}
370  	return xReturn;
371  }
372  size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
373  								 const void *pvTxData,
374  								 size_t xDataLengthBytes,
375  								 BaseType_t * const pxHigherPriorityTaskWoken )
376  {
377  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
378  size_t xReturn, xSpace;
379  size_t xRequiredSpace = xDataLengthBytes;
380  	configASSERT( pvTxData );
381  	configASSERT( pxStreamBuffer );
382  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
383  	{
384  		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
385  	}
386  	else
387  	{
388  		mtCOVERAGE_TEST_MARKER();
389  	}
390  	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
391  	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
392  	if( xReturn > ( size_t ) 0 )
393  	{
394  		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
395  		{
396  			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
397  		}
398  		else
399  		{
400  			mtCOVERAGE_TEST_MARKER();
401  		}
402  	}
403  	else
404  	{
405  		mtCOVERAGE_TEST_MARKER();
406  	}
407  	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
408  	return xReturn;
409  }
410  static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
411  									   const void * pvTxData,
412  									   size_t xDataLengthBytes,
413  									   size_t xSpace,
414  									   size_t xRequiredSpace )
415  {
416  	BaseType_t xShouldWrite;
417  	size_t xReturn;
418  	if( xSpace == ( size_t ) 0 )
419  	{
420  		xShouldWrite = pdFALSE;
421  	}
422  	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
423  	{
424  		xShouldWrite = pdTRUE;
425  		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace ); &bsol;*lint !e9044 Function parameter modified to ensure it is capped to available space. */
426  	}
427  	else if( xSpace >= xRequiredSpace )
428  	{
429  		xShouldWrite = pdTRUE;
430  		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
431  	}
432  	else
433  	{
434  		xShouldWrite = pdFALSE;
435  	}
436  	if( xShouldWrite != pdFALSE )
437  	{
438  		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); &bsol;*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
439  	}
440  	else
441  	{
442  		xReturn = 0;
443  	}
444  	return xReturn;
445  }
446  size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
447  							 void *pvRxData,
448  							 size_t xBufferLengthBytes,
449  							 TickType_t xTicksToWait )
450  {
451  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
452  size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
453  	configASSERT( pvRxData );
454  	configASSERT( pxStreamBuffer );
455  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
456  	{
457  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
458  	}
459  	else
460  	{
461  		xBytesToStoreMessageLength = 0;
462  	}
463  	if( xTicksToWait != ( TickType_t ) 0 )
464  	{
465  		taskENTER_CRITICAL();
466  		{
467  			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
468  			if( xBytesAvailable <= xBytesToStoreMessageLength )
469  			{
470  				( void ) xTaskNotifyStateClear( NULL );
471  				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
472  				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
473  			}
474  			else
475  			{
476  				mtCOVERAGE_TEST_MARKER();
477  			}
478  		}
479  		taskEXIT_CRITICAL();
480  		if( xBytesAvailable <= xBytesToStoreMessageLength )
481  		{
482  			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
483  			( void ) xTaskNotifyWait( ( uint32_t ) 0, UINT32_MAX, NULL, xTicksToWait );
484  			pxStreamBuffer->xTaskWaitingToReceive = NULL;
485  			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
486  		}
487  		else
488  		{
489  			mtCOVERAGE_TEST_MARKER();
490  		}
491  	}
492  	else
493  	{
494  		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
495  	}
496  	if( xBytesAvailable > xBytesToStoreMessageLength )
497  	{
498  		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
499  		if( xReceivedLength != ( size_t ) 0 )
500  		{
501  			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
502  			sbRECEIVE_COMPLETED( pxStreamBuffer );
503  		}
504  		else
505  		{
506  			mtCOVERAGE_TEST_MARKER();
507  		}
508  	}
509  	else
510  	{
511  		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
512  		mtCOVERAGE_TEST_MARKER();
513  	}
514  	return xReceivedLength;
515  }
516  size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
517  									void *pvRxData,
518  									size_t xBufferLengthBytes,
519  									BaseType_t * const pxHigherPriorityTaskWoken )
520  {
521  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
522  size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
523  	configASSERT( pvRxData );
524  	configASSERT( pxStreamBuffer );
525  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
526  	{
527  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
528  	}
529  	else
530  	{
531  		xBytesToStoreMessageLength = 0;
532  	}
533  	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
534  	if( xBytesAvailable > xBytesToStoreMessageLength )
535  	{
536  		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
537  		if( xReceivedLength != ( size_t ) 0 )
538  		{
539  			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
540  		}
541  		else
542  		{
543  			mtCOVERAGE_TEST_MARKER();
544  		}
545  	}
546  	else
547  	{
548  		mtCOVERAGE_TEST_MARKER();
549  	}
550  	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
551  	return xReceivedLength;
552  }
553  static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
554  										void *pvRxData,
555  										size_t xBufferLengthBytes,
556  										size_t xBytesAvailable,
557  										size_t xBytesToStoreMessageLength )
558  {
559  size_t xOriginalTail, xReceivedLength, xNextMessageLength;
560  	if( xBytesToStoreMessageLength != ( size_t ) 0 )
561  	{
562  		xOriginalTail = pxStreamBuffer->xTail;
563  		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
564  		xBytesAvailable -= xBytesToStoreMessageLength;
565  		if( xNextMessageLength > xBufferLengthBytes )
566  		{
567  			pxStreamBuffer->xTail = xOriginalTail;
568  			xNextMessageLength = 0;
569  		}
570  		else
571  		{
572  			mtCOVERAGE_TEST_MARKER();
573  		}
574  	}
575  	else
576  	{
577  		xNextMessageLength = xBufferLengthBytes;
578  	}
579  	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); &bsol;*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
580  	return xReceivedLength;
581  }
582  BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
583  {
584  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
585  BaseType_t xReturn;
586  size_t xTail;
587  	configASSERT( pxStreamBuffer );
588  	xTail = pxStreamBuffer->xTail;
589  	if( pxStreamBuffer->xHead == xTail )
590  	{
591  		xReturn = pdTRUE;
592  	}
593  	else
594  	{
595  		xReturn = pdFALSE;
596  	}
597  	return xReturn;
598  }
599  BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
600  {
601  BaseType_t xReturn;
602  size_t xBytesToStoreMessageLength;
603  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
604  	configASSERT( pxStreamBuffer );
605  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
606  	{
607  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
608  	}
609  	else
610  	{
611  		xBytesToStoreMessageLength = 0;
612  	}
613  	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
614  	{
615  		xReturn = pdTRUE;
616  	}
617  	else
618  	{
619  		xReturn = pdFALSE;
620  	}
621  	return xReturn;
622  }
623  BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
624  {
625  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
626  BaseType_t xReturn;
627  UBaseType_t uxSavedInterruptStatus;
628  	configASSERT( pxStreamBuffer );
629  	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
630  	{
631  		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
632  		{
633  			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
634  										 ( uint32_t ) 0,
635  										 eNoAction,
636  										 pxHigherPriorityTaskWoken );
637  			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
638  			xReturn = pdTRUE;
639  		}
640  		else
641  		{
642  			xReturn = pdFALSE;
643  		}
644  	}
645  	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
646  	return xReturn;
647  }
648  BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
649  {
650  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
651  BaseType_t xReturn;
652  UBaseType_t uxSavedInterruptStatus;
653  	configASSERT( pxStreamBuffer );
654  	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
655  	{
656  		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
657  		{
658  			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
659  										 ( uint32_t ) 0,
660  										 eNoAction,
661  										 pxHigherPriorityTaskWoken );
662  			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
663  			xReturn = pdTRUE;
664  		}
665  		else
666  		{
667  			xReturn = pdFALSE;
668  		}
669  	}
670  	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
671  	return xReturn;
672  }
673  static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
674  {
675  size_t xNextHead, xFirstLength;
676  	configASSERT( xCount > ( size_t ) 0 );
677  	xNextHead = pxStreamBuffer->xHead;
678  	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
679  	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
680  	memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
681  	if( xCount > xFirstLength )
682  	{
683  		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
684  		memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
685  	}
686  	else
687  	{
688  		mtCOVERAGE_TEST_MARKER();
689  	}
690  	xNextHead += xCount;
691  	if( xNextHead >= pxStreamBuffer->xLength )
692  	{
693  		xNextHead -= pxStreamBuffer->xLength;
694  	}
695  	else
696  	{
697  		mtCOVERAGE_TEST_MARKER();
698  	}
699  	pxStreamBuffer->xHead = xNextHead;
700  	return xCount;
701  }
702  static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
703  {
704  size_t xCount, xFirstLength, xNextTail;
705  	xCount = configMIN( xBytesAvailable, xMaxCount );
706  	if( xCount > ( size_t ) 0 )
707  	{
708  		xNextTail = pxStreamBuffer->xTail;
709  		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
710  		configASSERT( xFirstLength <= xMaxCount );
711  		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
712  		memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
713  		if( xCount > xFirstLength )
714  		{
715  			configASSERT( xCount <= xMaxCount );
716  			memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
717  		}
718  		else
719  		{
720  			mtCOVERAGE_TEST_MARKER();
721  		}
722  		xNextTail += xCount;
723  		if( xNextTail >= pxStreamBuffer->xLength )
724  		{
725  			xNextTail -= pxStreamBuffer->xLength;
726  		}
727  		pxStreamBuffer->xTail = xNextTail;
728  	}
729  	else
730  	{
731  		mtCOVERAGE_TEST_MARKER();
732  	}
733  	return xCount;
734  }
735  static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
736  {
737  size_t xCount;
738  	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
739  	xCount -= pxStreamBuffer->xTail;
740  	if ( xCount >= pxStreamBuffer->xLength )
741  	{
742  		xCount -= pxStreamBuffer->xLength;
743  	}
744  	else
745  	{
746  		mtCOVERAGE_TEST_MARKER();
747  	}
748  	return xCount;
749  }
750  static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
751  										  uint8_t * const pucBuffer,
752  										  size_t xBufferSizeBytes,
753  										  size_t xTriggerLevelBytes,
754  										  BaseType_t xIsMessageBuffer )
755  {
756  	#if( configASSERT_DEFINED == 1 )
757  	{
758  		const BaseType_t xWriteValue = 0x55;
759  		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
760  	}
761  	#endif
762  	memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); &bsol;*lint !e9087 memset() requires void *. */
763  	pxStreamBuffer->pucBuffer = pucBuffer;
764  	pxStreamBuffer->xLength = xBufferSizeBytes;
765  	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
766  	if( xIsMessageBuffer != pdFALSE )
767  	{
768  		pxStreamBuffer->ucFlags |= sbFLAGS_IS_MESSAGE_BUFFER;
769  	}
<span onclick='openModal()' class='match'>770  }
771  #if ( configUSE_TRACE_FACILITY == 1 )
772  	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
773  	{
774  		return ( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber;
775  	}
776  #endif &bsol;* configUSE_TRACE_FACILITY */
777  #if ( configUSE_TRACE_FACILITY == 1 )
778  	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
779  	{
780  		( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber = uxStreamBufferNumber;
</span>781  	}
782  #endif &bsol;* configUSE_TRACE_FACILITY */
783  #if ( configUSE_TRACE_FACILITY == 1 )
784  	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
785  	{
786  		return ( ( StreamBuffer_t * )xStreamBuffer )->ucFlags | sbFLAGS_IS_MESSAGE_BUFFER;
787  	}
788  #endif &bsol;* configUSE_TRACE_FACILITY */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_types.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-stream_buffer.c</div>
                </div>
                <div class="column column_space"><pre><code>320  }
321  static SPH_INLINE unsigned
322  sph_dec16be(const void *src)
323  {
324  	return ((unsigned)(((const unsigned char *)src)[0]) << 8)
325  		| (unsigned)(((const unsigned char *)src)[1]);
326  }
327  static SPH_INLINE void
328  sph_enc16le(void *dst, unsigned val)
329  {
330  	((unsigned char *)dst)[0] = val;
</pre></code></div>
                <div class="column column_space"><pre><code>770  }
771  #if ( configUSE_TRACE_FACILITY == 1 )
772  	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
773  	{
774  		return ( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber;
775  	}
776  #endif &bsol;* configUSE_TRACE_FACILITY */
777  #if ( configUSE_TRACE_FACILITY == 1 )
778  	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
779  	{
780  		( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber = uxStreamBufferNumber;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    