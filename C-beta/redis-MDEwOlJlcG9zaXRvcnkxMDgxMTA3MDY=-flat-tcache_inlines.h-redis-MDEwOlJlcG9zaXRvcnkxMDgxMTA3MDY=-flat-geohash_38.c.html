
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.015625%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-tcache_inlines.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_TCACHE_INLINES_H
2  #define JEMALLOC_INTERNAL_TCACHE_INLINES_H
3  #include "jemalloc/internal/bin.h"
4  #include "jemalloc/internal/jemalloc_internal_types.h"
5  #include "jemalloc/internal/sc.h"
6  #include "jemalloc/internal/sz.h"
7  #include "jemalloc/internal/ticker.h"
8  #include "jemalloc/internal/util.h"
9  static inline bool
<span onclick='openModal()' class='match'>10  tcache_enabled_get(tsd_t *tsd) {
11  	return tsd_tcache_enabled_get(tsd);
12  }
13  static inline void
14  tcache_enabled_set(tsd_t *tsd, bool enabled) {
15  	bool was_enabled = tsd_tcache_enabled_get(tsd);
</span>16  	if (!was_enabled && enabled) {
17  		tsd_tcache_data_init(tsd);
18  	} else if (was_enabled && !enabled) {
19  		tcache_cleanup(tsd);
20  	}
21  	tsd_tcache_enabled_set(tsd, enabled);
22  	tsd_slow_update(tsd);
23  }
24  JEMALLOC_ALWAYS_INLINE void
25  tcache_event(tsd_t *tsd, tcache_t *tcache) {
26  	if (TCACHE_GC_INCR == 0) {
27  		return;
28  	}
29  	if (unlikely(ticker_tick(&tcache->gc_ticker))) {
30  		tcache_event_hard(tsd, tcache);
31  	}
32  }
33  JEMALLOC_ALWAYS_INLINE void *
34  tcache_alloc_small(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
35      size_t size, szind_t binind, bool zero, bool slow_path) {
36  	void *ret;
37  	cache_bin_t *bin;
38  	bool tcache_success;
39  	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
40  	assert(binind < SC_NBINS);
41  	bin = tcache_small_bin_get(tcache, binind);
42  	ret = cache_bin_alloc_easy(bin, &tcache_success);
43  	assert(tcache_success == (ret != NULL));
44  	if (unlikely(!tcache_success)) {
45  		bool tcache_hard_success;
46  		arena = arena_choose(tsd, arena);
47  		if (unlikely(arena == NULL)) {
48  			return NULL;
49  		}
50  		ret = tcache_alloc_small_hard(tsd_tsdn(tsd), arena, tcache,
51  		    bin, binind, &tcache_hard_success);
52  		if (tcache_hard_success == false) {
53  			return NULL;
54  		}
55  	}
56  	assert(ret);
57  	if (config_prof || (slow_path && config_fill) || unlikely(zero)) {
58  		usize = sz_index2size(binind);
59  		assert(tcache_salloc(tsd_tsdn(tsd), ret) == usize);
60  	}
61  	if (likely(!zero)) {
62  		if (slow_path && config_fill) {
63  			if (unlikely(opt_junk_alloc)) {
64  				arena_alloc_junk_small(ret, &bin_infos[binind],
65  				    false);
66  			} else if (unlikely(opt_zero)) {
67  				memset(ret, 0, usize);
68  			}
69  		}
70  	} else {
71  		if (slow_path && config_fill && unlikely(opt_junk_alloc)) {
72  			arena_alloc_junk_small(ret, &bin_infos[binind], true);
73  		}
74  		memset(ret, 0, usize);
75  	}
76  	if (config_stats) {
77  		bin->tstats.nrequests++;
78  	}
79  	if (config_prof) {
80  		tcache->prof_accumbytes += usize;
81  	}
82  	tcache_event(tsd, tcache);
83  	return ret;
84  }
85  JEMALLOC_ALWAYS_INLINE void *
86  tcache_alloc_large(tsd_t *tsd, arena_t *arena, tcache_t *tcache, size_t size,
87      szind_t binind, bool zero, bool slow_path) {
88  	void *ret;
89  	cache_bin_t *bin;
90  	bool tcache_success;
91  	assert(binind >= SC_NBINS &&binind < nhbins);
92  	bin = tcache_large_bin_get(tcache, binind);
93  	ret = cache_bin_alloc_easy(bin, &tcache_success);
94  	assert(tcache_success == (ret != NULL));
95  	if (unlikely(!tcache_success)) {
96  		arena = arena_choose(tsd, arena);
97  		if (unlikely(arena == NULL)) {
98  			return NULL;
99  		}
100  		ret = large_malloc(tsd_tsdn(tsd), arena, sz_s2u(size), zero);
101  		if (ret == NULL) {
102  			return NULL;
103  		}
104  	} else {
105  		size_t usize JEMALLOC_CC_SILENCE_INIT(0);
106  		if (config_prof || (slow_path && config_fill) ||
107  		    unlikely(zero)) {
108  			usize = sz_index2size(binind);
109  			assert(usize <= tcache_maxclass);
110  		}
111  		if (likely(!zero)) {
112  			if (slow_path && config_fill) {
113  				if (unlikely(opt_junk_alloc)) {
114  					memset(ret, JEMALLOC_ALLOC_JUNK,
115  					    usize);
116  				} else if (unlikely(opt_zero)) {
117  					memset(ret, 0, usize);
118  				}
119  			}
120  		} else {
121  			memset(ret, 0, usize);
122  		}
123  		if (config_stats) {
124  			bin->tstats.nrequests++;
125  		}
126  		if (config_prof) {
127  			tcache->prof_accumbytes += usize;
128  		}
129  	}
130  	tcache_event(tsd, tcache);
131  	return ret;
132  }
133  JEMALLOC_ALWAYS_INLINE void
134  tcache_dalloc_small(tsd_t *tsd, tcache_t *tcache, void *ptr, szind_t binind,
135      bool slow_path) {
136  	cache_bin_t *bin;
137  	cache_bin_info_t *bin_info;
138  	assert(tcache_salloc(tsd_tsdn(tsd), ptr)
139  	    <= SC_SMALL_MAXCLASS);
140  	if (slow_path && config_fill && unlikely(opt_junk_free)) {
141  		arena_dalloc_junk_small(ptr, &bin_infos[binind]);
142  	}
143  	bin = tcache_small_bin_get(tcache, binind);
144  	bin_info = &tcache_bin_info[binind];
145  	if (unlikely(!cache_bin_dalloc_easy(bin, bin_info, ptr))) {
146  		tcache_bin_flush_small(tsd, tcache, bin, binind,
147  		    (bin_info->ncached_max >> 1));
148  		bool ret = cache_bin_dalloc_easy(bin, bin_info, ptr);
149  		assert(ret);
150  	}
151  	tcache_event(tsd, tcache);
152  }
153  JEMALLOC_ALWAYS_INLINE void
154  tcache_dalloc_large(tsd_t *tsd, tcache_t *tcache, void *ptr, szind_t binind,
155      bool slow_path) {
156  	cache_bin_t *bin;
157  	cache_bin_info_t *bin_info;
158  	assert(tcache_salloc(tsd_tsdn(tsd), ptr)
159  	    > SC_SMALL_MAXCLASS);
160  	assert(tcache_salloc(tsd_tsdn(tsd), ptr) <= tcache_maxclass);
161  	if (slow_path && config_fill && unlikely(opt_junk_free)) {
162  		large_dalloc_junk(ptr, sz_index2size(binind));
163  	}
164  	bin = tcache_large_bin_get(tcache, binind);
165  	bin_info = &tcache_bin_info[binind];
166  	if (unlikely(bin->ncached == bin_info->ncached_max)) {
167  		tcache_bin_flush_large(tsd, bin, binind,
168  		    (bin_info->ncached_max >> 1), tcache);
169  	}
170  	assert(bin->ncached < bin_info->ncached_max);
171  	bin->ncached++;
172  	*(bin->avail - bin->ncached) = ptr;
173  	tcache_event(tsd, tcache);
174  }
175  JEMALLOC_ALWAYS_INLINE tcache_t *
176  tcaches_get(tsd_t *tsd, unsigned ind) {
177  	tcaches_t *elm = &tcaches[ind];
178  	if (unlikely(elm->tcache == NULL)) {
179  		malloc_printf("<jemalloc>: invalid tcache id (%u).\n", ind);
180  		abort();
181  	} else if (unlikely(elm->tcache == TCACHES_ELM_NEED_REINIT)) {
182  		elm->tcache = tcache_create_explicit(tsd);
183  	}
184  	return elm->tcache;
185  }
186  #endif &bsol;* JEMALLOC_INTERNAL_TCACHE_INLINES_H */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-geohash_38.c</h3>
            <pre><code>1  #include "geohash.h"
2  static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {
3      static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
4                                   0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
5                                   0x0000FFFF0000FFFFULL};
6      static const unsigned int S[] = {1, 2, 4, 8, 16};
7      uint64_t x = xlo;
8      uint64_t y = ylo;
9      x = (x | (x << S[4])) & B[4];
10      y = (y | (y << S[4])) & B[4];
11      x = (x | (x << S[3])) & B[3];
12      y = (y | (y << S[3])) & B[3];
13      x = (x | (x << S[2])) & B[2];
14      y = (y | (y << S[2])) & B[2];
15      x = (x | (x << S[1])) & B[1];
16      y = (y | (y << S[1])) & B[1];
17      x = (x | (x << S[0])) & B[0];
18      y = (y | (y << S[0])) & B[0];
19      return x | (y << 1);
20  }
21  static inline uint64_t deinterleave64(uint64_t interleaved) {
22      static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
23                                   0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
24                                   0x0000FFFF0000FFFFULL, 0x00000000FFFFFFFFULL};
25      static const unsigned int S[] = {0, 1, 2, 4, 8, 16};
26      uint64_t x = interleaved;
27      uint64_t y = interleaved >> 1;
28      x = (x | (x >> S[0])) & B[0];
29      y = (y | (y >> S[0])) & B[0];
30      x = (x | (x >> S[1])) & B[1];
31      y = (y | (y >> S[1])) & B[1];
32      x = (x | (x >> S[2])) & B[2];
33      y = (y | (y >> S[2])) & B[2];
34      x = (x | (x >> S[3])) & B[3];
35      y = (y | (y >> S[3])) & B[3];
36      x = (x | (x >> S[4])) & B[4];
37      y = (y | (y >> S[4])) & B[4];
38      x = (x | (x >> S[5])) & B[5];
39      y = (y | (y >> S[5])) & B[5];
40      return x | (y << 32);
41  }
42  void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range) {
43      long_range->max = GEO_LONG_MAX;
44      long_range->min = GEO_LONG_MIN;
45      lat_range->max = GEO_LAT_MAX;
46      lat_range->min = GEO_LAT_MIN;
47  }
48  int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
49                    double longitude, double latitude, uint8_t step,
50                    GeoHashBits *hash) {
51      if (hash == NULL || step > 32 || step == 0 ||
52          RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) return 0;
53      if (longitude > GEO_LONG_MAX || longitude < GEO_LONG_MIN ||
54          latitude > GEO_LAT_MAX || latitude < GEO_LAT_MIN) return 0;
55      hash->bits = 0;
56      hash->step = step;
57      if (latitude < lat_range->min || latitude > lat_range->max ||
58          longitude < long_range->min || longitude > long_range->max) {
59          return 0;
60      }
61      double lat_offset =
62          (latitude - lat_range->min) / (lat_range->max - lat_range->min);
63      double long_offset =
64          (longitude - long_range->min) / (long_range->max - long_range->min);
65      lat_offset *= (1ULL << step);
66      long_offset *= (1ULL << step);
67      hash->bits = interleave64(lat_offset, long_offset);
68      return 1;
69  }
70  int geohashEncodeType(double longitude, double latitude, uint8_t step, GeoHashBits *hash) {
71      GeoHashRange r[2] = {{0}};
72      geohashGetCoordRange(&r[0], &r[1]);
73      return geohashEncode(&r[0], &r[1], longitude, latitude, step, hash);
74  }
75  int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,
<span onclick='openModal()' class='match'>76                         GeoHashBits *hash) {
77      return geohashEncodeType(longitude, latitude, step, hash);
78  }
79  int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
80                     const GeoHashBits hash, GeoHashArea *area) {
</span>81      if (HASHISZERO(hash) || NULL == area || RANGEISZERO(lat_range) ||
82          RANGEISZERO(long_range)) {
83          return 0;
84      }
85      area->hash = hash;
86      uint8_t step = hash.step;
87      uint64_t hash_sep = deinterleave64(hash.bits); &bsol;* hash = [LAT][LONG] */
88      double lat_scale = lat_range.max - lat_range.min;
89      double long_scale = long_range.max - long_range.min;
90      uint32_t ilato = hash_sep;       &bsol;* get lat part of deinterleaved hash */
91      uint32_t ilono = hash_sep >> 32; &bsol;* shift over to get long part of hash */
92      area->latitude.min =
93          lat_range.min + (ilato * 1.0 / (1ull << step)) * lat_scale;
94      area->latitude.max =
95          lat_range.min + ((ilato + 1) * 1.0 / (1ull << step)) * lat_scale;
96      area->longitude.min =
97          long_range.min + (ilono * 1.0 / (1ull << step)) * long_scale;
98      area->longitude.max =
99          long_range.min + ((ilono + 1) * 1.0 / (1ull << step)) * long_scale;
100      return 1;
101  }
102  int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area) {
103      GeoHashRange r[2] = {{0}};
104      geohashGetCoordRange(&r[0], &r[1]);
105      return geohashDecode(r[0], r[1], hash, area);
106  }
107  int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area) {
108      return geohashDecodeType(hash, area);
109  }
110  int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy) {
111      if (!xy) return 0;
112      xy[0] = (area->longitude.min + area->longitude.max) / 2;
113      xy[1] = (area->latitude.min + area->latitude.max) / 2;
114      return 1;
115  }
116  int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy) {
117      GeoHashArea area = {{0}};
118      if (!xy || !geohashDecodeType(hash, &area))
119          return 0;
120      return geohashDecodeAreaToLongLat(&area, xy);
121  }
122  int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy) {
123      return geohashDecodeToLongLatType(hash, xy);
124  }
125  static void geohash_move_x(GeoHashBits *hash, int8_t d) {
126      if (d == 0)
127          return;
128      uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
129      uint64_t y = hash->bits & 0x5555555555555555ULL;
130      uint64_t zz = 0x5555555555555555ULL >> (64 - hash->step * 2);
131      if (d > 0) {
132          x = x + (zz + 1);
133      } else {
134          x = x | zz;
135          x = x - (zz + 1);
136      }
137      x &= (0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2));
138      hash->bits = (x | y);
139  }
140  static void geohash_move_y(GeoHashBits *hash, int8_t d) {
141      if (d == 0)
142          return;
143      uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
144      uint64_t y = hash->bits & 0x5555555555555555ULL;
145      uint64_t zz = 0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2);
146      if (d > 0) {
147          y = y + (zz + 1);
148      } else {
149          y = y | zz;
150          y = y - (zz + 1);
151      }
152      y &= (0x5555555555555555ULL >> (64 - hash->step * 2));
153      hash->bits = (x | y);
154  }
155  void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {
156      neighbors->east = *hash;
157      neighbors->west = *hash;
158      neighbors->north = *hash;
159      neighbors->south = *hash;
160      neighbors->south_east = *hash;
161      neighbors->south_west = *hash;
162      neighbors->north_east = *hash;
163      neighbors->north_west = *hash;
164      geohash_move_x(&neighbors->east, 1);
165      geohash_move_y(&neighbors->east, 0);
166      geohash_move_x(&neighbors->west, -1);
167      geohash_move_y(&neighbors->west, 0);
168      geohash_move_x(&neighbors->south, 0);
169      geohash_move_y(&neighbors->south, -1);
170      geohash_move_x(&neighbors->north, 0);
171      geohash_move_y(&neighbors->north, 1);
172      geohash_move_x(&neighbors->north_west, -1);
173      geohash_move_y(&neighbors->north_west, 1);
174      geohash_move_x(&neighbors->north_east, 1);
175      geohash_move_y(&neighbors->north_east, 1);
176      geohash_move_x(&neighbors->south_east, 1);
177      geohash_move_y(&neighbors->south_east, -1);
178      geohash_move_x(&neighbors->south_west, -1);
179      geohash_move_y(&neighbors->south_west, -1);
180  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-tcache_inlines.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-geohash_38.c</div>
                </div>
                <div class="column column_space"><pre><code>10  tcache_enabled_get(tsd_t *tsd) {
11  	return tsd_tcache_enabled_get(tsd);
12  }
13  static inline void
14  tcache_enabled_set(tsd_t *tsd, bool enabled) {
15  	bool was_enabled = tsd_tcache_enabled_get(tsd);
</pre></code></div>
                <div class="column column_space"><pre><code>76                         GeoHashBits *hash) {
77      return geohashEncodeType(longitude, latitude, step, hash);
78  }
79  int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
80                     const GeoHashBits hash, GeoHashArea *area) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    