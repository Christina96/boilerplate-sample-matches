
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.5%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ae_epoll.c</h3>
            <pre><code>1  #include <sys/epoll.h>
2  typedef struct aeApiState {
3      int epfd;
4      struct epoll_event *events;
5  } aeApiState;
6  static int aeApiCreate(aeEventLoop *eventLoop) {
7      aeApiState *state = zmalloc(sizeof(aeApiState));
8      if (!state) return -1;
9      state->events = zmalloc(sizeof(struct epoll_event)*eventLoop->setsize);
10      if (!state->events) {
11          zfree(state);
12          return -1;
13      }
14      state->epfd = epoll_create(1024); &bsol;* 1024 is just a hint for the kernel */
15      if (state->epfd == -1) {
16          zfree(state->events);
17          zfree(state);
18          return -1;
19      }
20      eventLoop->apidata = state;
21      return 0;
22  }
23  static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
24      aeApiState *state = eventLoop->apidata;
25      state->events = zrealloc(state->events, sizeof(struct epoll_event)*setsize);
26      return 0;
27  }
28  static void aeApiFree(aeEventLoop *eventLoop) {
29      aeApiState *state = eventLoop->apidata;
30      close(state->epfd);
31      zfree(state->events);
32      zfree(state);
33  }
34  static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
35      aeApiState *state = eventLoop->apidata;
36      struct epoll_event ee = {0}; &bsol;* avoid valgrind warning */
37      int op = eventLoop->events[fd].mask == AE_NONE ?
38              EPOLL_CTL_ADD : EPOLL_CTL_MOD;
39      ee.events = 0;
40      mask |= eventLoop->events[fd].mask; &bsol;* Merge old events */
41      if (mask & AE_READABLE) ee.events |= EPOLLIN;
42      if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
43      ee.data.fd = fd;
<span onclick='openModal()' class='match'>44      if (epoll_ctl(state->epfd,op,fd,&ee) == -1) return -1;
45      return 0;
46  }
47  static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {
48      aeApiState *state = eventLoop->apidata;
</span>49      struct epoll_event ee = {0}; &bsol;* avoid valgrind warning */
50      int mask = eventLoop->events[fd].mask & (~delmask);
51      ee.events = 0;
52      if (mask & AE_READABLE) ee.events |= EPOLLIN;
53      if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
54      ee.data.fd = fd;
55      if (mask != AE_NONE) {
56          epoll_ctl(state->epfd,EPOLL_CTL_MOD,fd,&ee);
57      } else {
58          epoll_ctl(state->epfd,EPOLL_CTL_DEL,fd,&ee);
59      }
60  }
61  static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
62      aeApiState *state = eventLoop->apidata;
63      int retval, numevents = 0;
64      retval = epoll_wait(state->epfd,state->events,eventLoop->setsize,
65              tvp ? (tvp->tv_sec*1000 + tvp->tv_usec/1000) : -1);
66      if (retval > 0) {
67          int j;
68          numevents = retval;
69          for (j = 0; j < numevents; j++) {
70              int mask = 0;
71              struct epoll_event *e = state->events+j;
72              if (e->events & EPOLLIN) mask |= AE_READABLE;
73              if (e->events & EPOLLOUT) mask |= AE_WRITABLE;
74              if (e->events & EPOLLERR) mask |= AE_WRITABLE;
75              if (e->events & EPOLLHUP) mask |= AE_WRITABLE;
76              eventLoop->fired[j].fd = e->data.fd;
77              eventLoop->fired[j].mask = mask;
78          }
79      }
80      return numevents;
81  }
82  static char *aeApiName(void) {
83      return "epoll";
84  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-saferp.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SAFERP
3  #define LTC_SAFER_TAB_C
4  #include "safer_tab.c"
5  const struct ltc_cipher_descriptor saferp_desc =
6  {
7      "safer+",
8      4,
9      16, 32, 16, 8,
10      &saferp_setup,
11      &saferp_ecb_encrypt,
12      &saferp_ecb_decrypt,
13      &saferp_test,
14      &saferp_done,
15      &saferp_keysize,
16      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
17  };
18  #define ROUND(b, i) do {                                                                         \
19      b[0]  = (safer_ebox[(b[0] ^ skey->saferp.K[i][0]) & 255] + skey->saferp.K[i+1][0]) & 255;    \
20      b[1]  = safer_lbox[(b[1] + skey->saferp.K[i][1]) & 255] ^ skey->saferp.K[i+1][1];            \
21      b[2]  = safer_lbox[(b[2] + skey->saferp.K[i][2]) & 255] ^ skey->saferp.K[i+1][2];            \
22      b[3]  = (safer_ebox[(b[3] ^ skey->saferp.K[i][3]) & 255] + skey->saferp.K[i+1][3]) & 255;    \
23      b[4]  = (safer_ebox[(b[4] ^ skey->saferp.K[i][4]) & 255] + skey->saferp.K[i+1][4]) & 255;    \
24      b[5]  = safer_lbox[(b[5] + skey->saferp.K[i][5]) & 255] ^ skey->saferp.K[i+1][5];            \
25      b[6]  = safer_lbox[(b[6] + skey->saferp.K[i][6]) & 255] ^ skey->saferp.K[i+1][6];            \
26      b[7]  = (safer_ebox[(b[7] ^ skey->saferp.K[i][7]) & 255] + skey->saferp.K[i+1][7]) & 255;    \
27      b[8]  = (safer_ebox[(b[8] ^ skey->saferp.K[i][8]) & 255] + skey->saferp.K[i+1][8]) & 255;    \
28      b[9]  = safer_lbox[(b[9] + skey->saferp.K[i][9]) & 255] ^ skey->saferp.K[i+1][9];            \
29      b[10] = safer_lbox[(b[10] + skey->saferp.K[i][10]) & 255] ^ skey->saferp.K[i+1][10];         \
30      b[11] = (safer_ebox[(b[11] ^ skey->saferp.K[i][11]) & 255] + skey->saferp.K[i+1][11]) & 255; \
31      b[12] = (safer_ebox[(b[12] ^ skey->saferp.K[i][12]) & 255] + skey->saferp.K[i+1][12]) & 255; \
32      b[13] = safer_lbox[(b[13] + skey->saferp.K[i][13]) & 255] ^ skey->saferp.K[i+1][13];         \
33      b[14] = safer_lbox[(b[14] + skey->saferp.K[i][14]) & 255] ^ skey->saferp.K[i+1][14];         \
34      b[15] = (safer_ebox[(b[15] ^ skey->saferp.K[i][15]) & 255] + skey->saferp.K[i+1][15]) & 255; \
35  } while (0)
36  #define iROUND(b, i) do {                                                                        \
37      b[0]  = safer_lbox[(b[0] - skey->saferp.K[i+1][0]) & 255] ^ skey->saferp.K[i][0];            \
38      b[1]  = (safer_ebox[(b[1] ^ skey->saferp.K[i+1][1]) & 255] - skey->saferp.K[i][1]) & 255;    \
39      b[2]  = (safer_ebox[(b[2] ^ skey->saferp.K[i+1][2]) & 255] - skey->saferp.K[i][2]) & 255;    \
40      b[3]  = safer_lbox[(b[3] - skey->saferp.K[i+1][3]) & 255] ^ skey->saferp.K[i][3];            \
41      b[4]  = safer_lbox[(b[4] - skey->saferp.K[i+1][4]) & 255] ^ skey->saferp.K[i][4];            \
42      b[5]  = (safer_ebox[(b[5] ^ skey->saferp.K[i+1][5]) & 255] - skey->saferp.K[i][5]) & 255;    \
43      b[6]  = (safer_ebox[(b[6] ^ skey->saferp.K[i+1][6]) & 255] - skey->saferp.K[i][6]) & 255;    \
44      b[7]  = safer_lbox[(b[7] - skey->saferp.K[i+1][7]) & 255] ^ skey->saferp.K[i][7];            \
45      b[8]  = safer_lbox[(b[8] - skey->saferp.K[i+1][8]) & 255] ^ skey->saferp.K[i][8];            \
46      b[9]  = (safer_ebox[(b[9] ^ skey->saferp.K[i+1][9]) & 255] - skey->saferp.K[i][9]) & 255;    \
47      b[10] = (safer_ebox[(b[10] ^ skey->saferp.K[i+1][10]) & 255] - skey->saferp.K[i][10]) & 255; \
48      b[11] = safer_lbox[(b[11] - skey->saferp.K[i+1][11]) & 255] ^ skey->saferp.K[i][11];         \
49      b[12] = safer_lbox[(b[12] - skey->saferp.K[i+1][12]) & 255] ^ skey->saferp.K[i][12];         \
50      b[13] = (safer_ebox[(b[13] ^ skey->saferp.K[i+1][13]) & 255] - skey->saferp.K[i][13]) & 255; \
51      b[14] = (safer_ebox[(b[14] ^ skey->saferp.K[i+1][14]) & 255] - skey->saferp.K[i][14]) & 255; \
52      b[15] = safer_lbox[(b[15] - skey->saferp.K[i+1][15]) & 255] ^ skey->saferp.K[i][15];         \
53  } while (0)
54  #define PHT(b) do {                                          \
55      b[0]  = (b[0] + (b[1] = (b[0] + b[1]) & 255)) & 255;     \
56      b[2]  = (b[2] + (b[3] = (b[3] + b[2]) & 255)) & 255;     \
57      b[4]  = (b[4] + (b[5] = (b[5] + b[4]) & 255)) & 255;     \
58      b[6]  = (b[6] + (b[7] = (b[7] + b[6]) & 255)) & 255;     \
59      b[8]  = (b[8] + (b[9] = (b[9] + b[8]) & 255)) & 255;     \
60      b[10] = (b[10] + (b[11] = (b[11] + b[10]) & 255)) & 255; \
61      b[12] = (b[12] + (b[13] = (b[13] + b[12]) & 255)) & 255; \
62      b[14] = (b[14] + (b[15] = (b[15] + b[14]) & 255)) & 255; \
63  } while (0)
64  #define iPHT(b) do {                                          \
65      b[15] = (b[15] - (b[14] = (b[14] - b[15]) & 255)) & 255;  \
66      b[13] = (b[13] - (b[12] = (b[12] - b[13]) & 255)) & 255;  \
67      b[11] = (b[11] - (b[10] = (b[10] - b[11]) & 255)) & 255;  \
68      b[9]  = (b[9] - (b[8] = (b[8] - b[9]) & 255)) & 255;      \
69      b[7]  = (b[7] - (b[6] = (b[6] - b[7]) & 255)) & 255;      \
70      b[5]  = (b[5] - (b[4] = (b[4] - b[5]) & 255)) & 255;      \
71      b[3]  = (b[3] - (b[2] = (b[2] - b[3]) & 255)) & 255;      \
72      b[1]  = (b[1] - (b[0] = (b[0] - b[1]) & 255)) & 255;      \
73   } while (0)
74  #define SHUF(b, b2) do {                                         \
75      b2[0] = b[8]; b2[1] = b[11]; b2[2] = b[12]; b2[3] = b[15];   \
76      b2[4] = b[2]; b2[5] = b[1]; b2[6] = b[6]; b2[7] = b[5];      \
77      b2[8] = b[10]; b2[9] = b[9]; b2[10] = b[14]; b2[11] = b[13]; \
78      b2[12] = b[0]; b2[13] = b[7]; b2[14] = b[4]; b2[15] = b[3];  \
79  } while (0)
80  #define iSHUF(b, b2) do {                                          \
81      b2[0] = b[12]; b2[1] = b[5]; b2[2] = b[4]; b2[3] = b[15];      \
82      b2[4] = b[14]; b2[5] = b[7]; b2[6] = b[6]; b2[7] = b[13];      \
83      b2[8] = b[0]; b2[9] = b[9]; b2[10] = b[8]; b2[11] = b[1];      \
84      b2[12] = b[2]; b2[13] = b[11]; b2[14] = b[10]; b2[15] = b[3];  \
85  } while (0)
86  #define LT(b, b2) do {        \
87      PHT(b);  SHUF(b, b2);     \
88      PHT(b2); SHUF(b2, b);     \
89      PHT(b);  SHUF(b, b2);     \
90      PHT(b2);                  \
91  } while (0)
92  #define iLT(b, b2) do {       \
93      iPHT(b);                  \
94      iSHUF(b, b2); iPHT(b2);   \
95      iSHUF(b2, b); iPHT(b);    \
96      iSHUF(b, b2); iPHT(b2);   \
97  } while (0)
98  #ifdef LTC_SMALL_CODE
99  static void s_round(unsigned char *b, int i, const symmetric_key *skey)
100  {
101     ROUND(b, i);
102  }
103  static void s_iround(unsigned char *b, int i, const symmetric_key *skey)
104  {
105     iROUND(b, i);
106  }
107  static void s_lt(unsigned char *b, unsigned char *b2)
108  {
109     LT(b, b2);
110  }
111  static void s_ilt(unsigned char *b, unsigned char *b2)
112  {
113     iLT(b, b2);
114  }
115  #undef ROUND
116  #define ROUND(b, i) s_round(b, i, skey)
117  #undef iROUND
118  #define iROUND(b, i) s_iround(b, i, skey)
119  #undef LT
120  #define LT(b, b2) s_lt(b, b2)
121  #undef iLT
122  #define iLT(b, b2) s_ilt(b, b2)
123  #endif
124  static const unsigned char safer_bias[33][16] = {
125  {  70, 151, 177, 186, 163, 183,  16,  10, 197,  55, 179, 201,  90,  40, 172, 100},
126  { 236, 171, 170, 198, 103, 149,  88,  13, 248, 154, 246, 110, 102, 220,   5,  61},
127  { 138, 195, 216, 137, 106, 233,  54,  73,  67, 191, 235, 212, 150, 155, 104, 160},
128  {  93,  87, 146,  31, 213, 113,  92, 187,  34, 193, 190, 123, 188, 153,  99, 148},
129  {  42,  97, 184,  52,  50,  25, 253, 251,  23,  64, 230,  81,  29,  65,  68, 143},
130  { 221,   4, 128, 222, 231,  49, 214, 127,   1, 162, 247,  57, 218, 111,  35, 202},
131  {  58, 208,  28, 209,  48,  62,  18, 161, 205,  15, 224, 168, 175, 130,  89,  44},
132  { 125, 173, 178, 239, 194, 135, 206, 117,   6,  19,   2, 144,  79,  46, 114,  51},
133  { 192, 141, 207, 169, 129, 226, 196,  39,  47, 108, 122, 159,  82, 225,  21,  56},
134  { 252,  32,  66, 199,   8, 228,   9,  85,  94, 140,  20, 118,  96, 255, 223, 215},
135  { 250,  11,  33,   0,  26, 249, 166, 185, 232, 158,  98,  76, 217, 145,  80, 210},
136  {  24, 180,   7, 132, 234,  91, 164, 200,  14, 203,  72, 105,  75,  78, 156,  53},
137  {  69,  77,  84, 229,  37,  60,  12,  74, 139,  63, 204, 167, 219, 107, 174, 244},
138  {  45, 243, 124, 109, 157, 181,  38, 116, 242, 147,  83, 176, 240,  17, 237, 131},
139  { 182,   3,  22, 115,  59,  30, 142, 112, 189, 134,  27,  71, 126,  36,  86, 241},
140  { 136,  70, 151, 177, 186, 163, 183,  16,  10, 197,  55, 179, 201,  90,  40, 172},
141  { 220, 134, 119, 215, 166,  17, 251, 244, 186, 146, 145, 100, 131, 241,  51, 239},
142  {  44, 181, 178,  43, 136, 209, 153, 203, 140, 132,  29,  20, 129, 151, 113, 202},
143  { 163, 139,  87,  60, 130, 196,  82,  92,  28, 232, 160,   4, 180, 133,  74, 246},
144  {  84, 182, 223,  12,  26, 142, 222, 224,  57, 252,  32, 155,  36,  78, 169, 152},
145  { 171, 242,  96, 208, 108, 234, 250, 199, 217,   0, 212,  31, 110,  67, 188, 236},
146  { 137, 254, 122,  93,  73, 201,  50, 194, 249, 154, 248, 109,  22, 219,  89, 150},
147  { 233, 205, 230,  70,  66, 143,  10, 193, 204, 185, 101, 176, 210, 198, 172,  30},
148  {  98,  41,  46,  14, 116,  80,   2,  90, 195,  37, 123, 138,  42,  91, 240,   6},
149  {  71, 111, 112, 157, 126,  16, 206,  18,  39, 213,  76,  79, 214, 121,  48, 104},
150  { 117, 125, 228, 237, 128, 106, 144,  55, 162,  94, 118, 170, 197, 127,  61, 175},
151  { 229,  25,  97, 253,  77, 124, 183,  11, 238, 173,  75,  34, 245, 231, 115,  35},
152  { 200,   5, 225, 102, 221, 179,  88, 105,  99,  86,  15, 161,  49, 149,  23,   7},
153  {  40,   1,  45, 226, 147, 190,  69,  21, 174, 120,   3, 135, 164, 184,  56, 207},
154  {   8, 103,   9, 148, 235,  38, 168, 107, 189,  24,  52,  27, 187, 191, 114, 247},
155  {  53,  72, 156,  81,  47,  59,  85, 227, 192, 159, 216, 211, 243, 141, 177, 255},
156  {  62, 220, 134, 119, 215, 166,  17, 251, 244, 186, 146, 145, 100, 131, 241,  51}};
157  int saferp_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
158  {
159     unsigned x, y, z;
160     unsigned char t[33];
161     static const int rounds[3] = { 8, 12, 16 };
162     LTC_ARGCHK(key  != NULL);
163     LTC_ARGCHK(skey != NULL);
164     if (keylen != 16 && keylen != 24 && keylen != 32) {
165        return CRYPT_INVALID_KEYSIZE;
166     }
167     if (num_rounds != 0 && num_rounds != rounds[(keylen/8)-2]) {
168        return CRYPT_INVALID_ROUNDS;
169     }
170     if (keylen == 16) {
171         for (x = y = 0; x < 16; x++) {
172             t[x] = key[x];
173             y ^= key[x];
174         }
175         t[16] = y;
176         for (x = 0; x < 16; x++) {
177             skey->saferp.K[0][x] = t[x];
178         }
179         for (x = 1; x < 17; x++) {
180             for (y = 0; y < 17; y++) {
181                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
182             }
183             z = x;
184             for (y = 0; y < 16; y++) {
185                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
186                 if (++z == 17) { z = 0; }
187             }
188         }
189         skey->saferp.rounds = 8;
190     } else if (keylen == 24) {
191         for (x = y = 0; x < 24; x++) {
192             t[x] = key[x];
193             y ^= key[x];
194         }
195         t[24] = y;
196         for (x = 0; x < 16; x++) {
197             skey->saferp.K[0][x] = t[x];
198         }
199         for (x = 1; x < 25; x++) {
200             for (y = 0; y < 25; y++) {
201                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
202             }
203             z = x;
204             for (y = 0; y < 16; y++) {
205                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
206                 if (++z == 25) { z = 0; }
207             }
208         }
209         skey->saferp.rounds = 12;
210     } else {
211         for (x = y = 0; x < 32; x++) {
212             t[x] = key[x];
213             y ^= key[x];
214         }
215         t[32] = y;
216         for (x = 0; x < 16; x++) {
217             skey->saferp.K[0][x] = t[x];
218         }
219         for (x = 1; x < 33; x++) {
220             for (y = 0; y < 33; y++) {
221                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
222             }
223             z = x;
224             for (y = 0; y < 16; y++) {
225                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
226                 if (++z == 33) { z = 0; }
227             }
228         }
229         skey->saferp.rounds = 16;
<span onclick='openModal()' class='match'>230     }
231  #ifdef LTC_CLEAN_STACK
232     zeromem(t, sizeof(t));
233  #endif
234     return CRYPT_OK;
235  }
236  int saferp_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
237  {
238     unsigned char b[16];
</span>239     int x;
240     LTC_ARGCHK(pt   != NULL);
241     LTC_ARGCHK(ct   != NULL);
242     LTC_ARGCHK(skey != NULL);
243     if (skey->saferp.rounds < 8 || skey->saferp.rounds > 16) {
244         return CRYPT_INVALID_ROUNDS;
245     }
246     for (x = 0; x < 16; x++) {
247         b[x] = pt[x];
248     }
249     ROUND(b,  0);  LT(b, ct);
250     ROUND(ct, 2);  LT(ct, b);
251     ROUND(b,  4);  LT(b, ct);
252     ROUND(ct, 6);  LT(ct, b);
253     ROUND(b,  8);  LT(b, ct);
254     ROUND(ct, 10); LT(ct, b);
255     ROUND(b,  12); LT(b, ct);
256     ROUND(ct, 14); LT(ct, b);
257     if (skey->saferp.rounds > 8) {
258        ROUND(b, 16);  LT(b, ct);
259        ROUND(ct, 18); LT(ct, b);
260        ROUND(b, 20);  LT(b, ct);
261        ROUND(ct, 22); LT(ct, b);
262     }
263     if (skey->saferp.rounds > 12) {
264        ROUND(b, 24);  LT(b, ct);
265        ROUND(ct, 26); LT(ct, b);
266        ROUND(b, 28);  LT(b, ct);
267        ROUND(ct, 30); LT(ct, b);
268     }
269     ct[0] = b[0] ^ skey->saferp.K[skey->saferp.rounds*2][0];
270     ct[1] = (b[1] + skey->saferp.K[skey->saferp.rounds*2][1]) & 255;
271     ct[2] = (b[2] + skey->saferp.K[skey->saferp.rounds*2][2]) & 255;
272     ct[3] = b[3] ^ skey->saferp.K[skey->saferp.rounds*2][3];
273     ct[4] = b[4] ^ skey->saferp.K[skey->saferp.rounds*2][4];
274     ct[5] = (b[5] + skey->saferp.K[skey->saferp.rounds*2][5]) & 255;
275     ct[6] = (b[6] + skey->saferp.K[skey->saferp.rounds*2][6]) & 255;
276     ct[7] = b[7] ^ skey->saferp.K[skey->saferp.rounds*2][7];
277     ct[8] = b[8] ^ skey->saferp.K[skey->saferp.rounds*2][8];
278     ct[9] = (b[9] + skey->saferp.K[skey->saferp.rounds*2][9]) & 255;
279     ct[10] = (b[10] + skey->saferp.K[skey->saferp.rounds*2][10]) & 255;
280     ct[11] = b[11] ^ skey->saferp.K[skey->saferp.rounds*2][11];
281     ct[12] = b[12] ^ skey->saferp.K[skey->saferp.rounds*2][12];
282     ct[13] = (b[13] + skey->saferp.K[skey->saferp.rounds*2][13]) & 255;
283     ct[14] = (b[14] + skey->saferp.K[skey->saferp.rounds*2][14]) & 255;
284     ct[15] = b[15] ^ skey->saferp.K[skey->saferp.rounds*2][15];
285  #ifdef LTC_CLEAN_STACK
286     zeromem(b, sizeof(b));
287  #endif
288     return CRYPT_OK;
289  }
290  int saferp_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
291  {
292     unsigned char b[16];
293     int x;
294     LTC_ARGCHK(pt   != NULL);
295     LTC_ARGCHK(ct   != NULL);
296     LTC_ARGCHK(skey != NULL);
297     if (skey->saferp.rounds < 8 || skey->saferp.rounds > 16) {
298         return CRYPT_INVALID_ROUNDS;
299     }
300     b[0] = ct[0] ^ skey->saferp.K[skey->saferp.rounds*2][0];
301     b[1] = (ct[1] - skey->saferp.K[skey->saferp.rounds*2][1]) & 255;
302     b[2] = (ct[2] - skey->saferp.K[skey->saferp.rounds*2][2]) & 255;
303     b[3] = ct[3] ^ skey->saferp.K[skey->saferp.rounds*2][3];
304     b[4] = ct[4] ^ skey->saferp.K[skey->saferp.rounds*2][4];
305     b[5] = (ct[5] - skey->saferp.K[skey->saferp.rounds*2][5]) & 255;
306     b[6] = (ct[6] - skey->saferp.K[skey->saferp.rounds*2][6]) & 255;
307     b[7] = ct[7] ^ skey->saferp.K[skey->saferp.rounds*2][7];
308     b[8] = ct[8] ^ skey->saferp.K[skey->saferp.rounds*2][8];
309     b[9] = (ct[9] - skey->saferp.K[skey->saferp.rounds*2][9]) & 255;
310     b[10] = (ct[10] - skey->saferp.K[skey->saferp.rounds*2][10]) & 255;
311     b[11] = ct[11] ^ skey->saferp.K[skey->saferp.rounds*2][11];
312     b[12] = ct[12] ^ skey->saferp.K[skey->saferp.rounds*2][12];
313     b[13] = (ct[13] - skey->saferp.K[skey->saferp.rounds*2][13]) & 255;
314     b[14] = (ct[14] - skey->saferp.K[skey->saferp.rounds*2][14]) & 255;
315     b[15] = ct[15] ^ skey->saferp.K[skey->saferp.rounds*2][15];
316     if (skey->saferp.rounds > 12) {
317        iLT(b, pt); iROUND(pt, 30);
318        iLT(pt, b); iROUND(b, 28);
319        iLT(b, pt); iROUND(pt, 26);
320        iLT(pt, b); iROUND(b, 24);
321     }
322     if (skey->saferp.rounds > 8) {
323        iLT(b, pt); iROUND(pt, 22);
324        iLT(pt, b); iROUND(b, 20);
325        iLT(b, pt); iROUND(pt, 18);
326        iLT(pt, b); iROUND(b, 16);
327     }
328     iLT(b, pt); iROUND(pt, 14);
329     iLT(pt, b); iROUND(b, 12);
330     iLT(b, pt); iROUND(pt,10);
331     iLT(pt, b); iROUND(b, 8);
332     iLT(b, pt); iROUND(pt,6);
333     iLT(pt, b); iROUND(b, 4);
334     iLT(b, pt); iROUND(pt,2);
335     iLT(pt, b); iROUND(b, 0);
336     for (x = 0; x < 16; x++) {
337         pt[x] = b[x];
338     }
339  #ifdef LTC_CLEAN_STACK
340     zeromem(b, sizeof(b));
341  #endif
342     return CRYPT_OK;
343  }
344  int saferp_test(void)
345  {
346   #ifndef LTC_TEST
347      return CRYPT_NOP;
348   #else
349     static const struct {
350         int keylen;
351         unsigned char key[32], pt[16], ct[16];
352     } tests[] = {
353         {
354             16,
355             { 41, 35, 190, 132, 225, 108, 214, 174,
356               82, 144, 73, 241, 241, 187, 233, 235 },
357             { 179, 166, 219, 60, 135, 12, 62, 153,
358               36, 94, 13, 28, 6, 183, 71, 222 },
359             { 224, 31, 182, 10, 12, 255, 84, 70,
360               127, 13, 89, 249, 9, 57, 165, 220 }
361         }, {
362             24,
363             { 72, 211, 143, 117, 230, 217, 29, 42,
364               229, 192, 247, 43, 120, 129, 135, 68,
365               14, 95, 80, 0, 212, 97, 141, 190 },
366             { 123, 5, 21, 7, 59, 51, 130, 31,
367               24, 112, 146, 218, 100, 84, 206, 177 },
368             { 92, 136, 4, 63, 57, 95, 100, 0,
369               150, 130, 130, 16, 193, 111, 219, 133 }
370         }, {
371             32,
372             { 243, 168, 141, 254, 190, 242, 235, 113,
373               255, 160, 208, 59, 117, 6, 140, 126,
374               135, 120, 115, 77, 208, 190, 130, 190,
375               219, 194, 70, 65, 43, 140, 250, 48 },
376             { 127, 112, 240, 167, 84, 134, 50, 149,
377               170, 91, 104, 19, 11, 230, 252, 245 },
378             { 88, 11, 25, 36, 172, 229, 202, 213,
379               170, 65, 105, 153, 220, 104, 153, 138 }
380         }
381      };
382     unsigned char tmp[2][16];
383     symmetric_key skey;
384     int err, i, y;
385     for (i = 0; i < (int)(sizeof(tests) / sizeof(tests[0])); i++) {
386        if ((err = saferp_setup(tests[i].key, tests[i].keylen, 0, &skey)) != CRYPT_OK)  {
387           return err;
388        }
389        saferp_ecb_encrypt(tests[i].pt, tmp[0], &skey);
390        saferp_ecb_decrypt(tmp[0], tmp[1], &skey);
391        if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "Safer+ Encrypt", i) ||
392              compare_testvector(tmp[1], 16, tests[i].pt, 16, "Safer+ Decrypt", i)) {
393           return CRYPT_FAIL_TESTVECTOR;
394        }
395        for (y = 0; y < 16; y++) tmp[0][y] = 0;
396        for (y = 0; y < 1000; y++) saferp_ecb_encrypt(tmp[0], tmp[0], &skey);
397        for (y = 0; y < 1000; y++) saferp_ecb_decrypt(tmp[0], tmp[0], &skey);
398        for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
399     }
400     return CRYPT_OK;
401   #endif
402  }
403  void saferp_done(symmetric_key *skey)
404  {
405    LTC_UNUSED_PARAM(skey);
406  }
407  int saferp_keysize(int *keysize)
408  {
409     LTC_ARGCHK(keysize != NULL);
410     if (*keysize < 16) {
411        return CRYPT_INVALID_KEYSIZE;
412     }
413     if (*keysize < 24) {
414        *keysize = 16;
415     } else if (*keysize < 32) {
416        *keysize = 24;
417     } else {
418        *keysize = 32;
419     }
420     return CRYPT_OK;
421  }
422  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ae_epoll.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-saferp.c</div>
                </div>
                <div class="column column_space"><pre><code>44      if (epoll_ctl(state->epfd,op,fd,&ee) == -1) return -1;
45      return 0;
46  }
47  static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {
48      aeApiState *state = eventLoop->apidata;
</pre></code></div>
                <div class="column column_space"><pre><code>230     }
231  #ifdef LTC_CLEAN_STACK
232     zeromem(t, sizeof(t));
233  #endif
234     return CRYPT_OK;
235  }
236  int saferp_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
237  {
238     unsigned char b[16];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    