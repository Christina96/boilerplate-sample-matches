
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 40.390879478827365%, Tokens: 36, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-read.h</h3>
            <pre><code>1  #ifndef __HIREDIS_READ_H
2  #define __HIREDIS_READ_H
3  #include <stdio.h> &bsol;* for size_t */
4  #ifdef _WIN32
5  #include "../../src/Win32_Interop/win32_types_hiredis.h"
6  #endif
7  #define REDIS_ERR -1
8  #define REDIS_OK 0
9  #define REDIS_ERR_IO 1 &bsol;* Error in read or write */
10  #define REDIS_ERR_EOF 3 &bsol;* End of file */
11  #define REDIS_ERR_PROTOCOL 4 &bsol;* Protocol error */
12  #define REDIS_ERR_OOM 5 &bsol;* Out of memory */
13  #define REDIS_ERR_OTHER 2 &bsol;* Everything else... */
14  #define REDIS_REPLY_STRING 1
15  #define REDIS_REPLY_ARRAY 2
16  #define REDIS_REPLY_INTEGER 3
17  #define REDIS_REPLY_NIL 4
18  #define REDIS_REPLY_STATUS 5
19  #define REDIS_REPLY_ERROR 6
20  #define REDIS_READER_MAX_BUF (1024*16)  &bsol;* Default max unused reader buffer. */
21  #ifdef __cplusplus
22  extern "C" {
23  #endif
24  typedef struct redisReadTask {
25      int type;
26      int elements; &bsol;* number of elements in multibulk container */
27      int idx; &bsol;* index in parent (array) object */
28      void *obj; &bsol;* holds user-generated value for a read task */
29      struct redisReadTask *parent; &bsol;* parent task */
30      void *privdata; &bsol;* user-settable arbitrary field */
31  } redisReadTask;
32  typedef struct redisReplyObjectFunctions {
33      void *(*createString)(const redisReadTask*, char*, size_t);
34      void *(*createArray)(const redisReadTask*, int);
35      void *(*createInteger)(const redisReadTask*, PORT_LONGLONG);
36      void *(*createNil)(const redisReadTask*);
37      void (*freeObject)(void*);
38  } redisReplyObjectFunctions;
39  typedef struct redisReader {
<span onclick='openModal()' class='match'>40      int err; &bsol;* Error flags, 0 when there is no error */
41      char errstr[128]; &bsol;* String representation of error when applicable */
42      char *buf; &bsol;* Read buffer */
43      size_t pos; &bsol;* Buffer cursor */
44      size_t len; &bsol;* Buffer length */
45      size_t maxbuf; &bsol;* Max length of unused buffer */
46      redisReadTask rstack[9];
47      int ridx; &bsol;* Index of current read task */
48      void *reply; &bsol;* Temporary reply pointer */
49      redisReplyObjectFunctions *fn;
50      void *privdata;
</span>51  } redisReader;
52  redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn);
53  void redisReaderFree(redisReader *r);
54  int redisReaderFeed(redisReader *r, const char *buf, size_t len);
55  int redisReaderGetReply(redisReader *r, void **reply);
56  #define redisReaderSetPrivdata(_r, _p) (int)(((redisReader*)(_r))->privdata = (_p))
57  #define redisReaderGetObject(_r) (((redisReader*)(_r))->reply)
58  #define redisReaderGetError(_r) (((redisReader*)(_r))->errstr)
59  #ifdef __cplusplus
60  }
61  #endif
62  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spu.h</h3>
            <pre><code>1  #ifndef NRF_SPU_H__
2  #define NRF_SPU_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_SPU_EVENT_RAMACCERR    = offsetof(NRF_SPU_Type, EVENTS_RAMACCERR),   
10      NRF_SPU_EVENT_FLASHACCERR  = offsetof(NRF_SPU_Type, EVENTS_FLASHACCERR), 
11      NRF_SPU_EVENT_PERIPHACCERR = offsetof(NRF_SPU_Type, EVENTS_PERIPHACCERR) 
12  } nrf_spu_event_t;
13  typedef enum
14  {
15      NRF_SPU_INT_RAMACCERR_MASK     = SPU_INTENSET_RAMACCERR_Msk,   
16      NRF_SPU_INT_FLASHACCERR_MASK   = SPU_INTENSET_FLASHACCERR_Msk, 
17      NRF_SPU_INT_PERIPHACCERR_MASK  = SPU_INTENSET_PERIPHACCERR_Msk 
18  } nrf_spu_int_mask_t;
19  typedef enum
20  {
21      NRF_SPU_NSC_SIZE_DISABLED = 0, 
22      NRF_SPU_NSC_SIZE_32B      = 1, 
23      NRF_SPU_NSC_SIZE_64B      = 2, 
24      NRF_SPU_NSC_SIZE_128B     = 3, 
25      NRF_SPU_NSC_SIZE_256B     = 4, 
26      NRF_SPU_NSC_SIZE_512B     = 5, 
27      NRF_SPU_NSC_SIZE_1024B    = 6, 
28      NRF_SPU_NSC_SIZE_2048B    = 7, 
29      NRF_SPU_NSC_SIZE_4096B    = 8  
30  } nrf_spu_nsc_size_t;
31  typedef enum
32  {
33      NRF_SPU_MEM_PERM_EXECUTE = SPU_FLASHREGION_PERM_EXECUTE_Msk, 
34      NRF_SPU_MEM_PERM_WRITE   = SPU_FLASHREGION_PERM_WRITE_Msk,   
35      NRF_SPU_MEM_PERM_READ    = SPU_FLASHREGION_PERM_READ_Msk     
36  } nrf_spu_mem_perm_t;
<span onclick='openModal()' class='match'>37  NRF_STATIC_INLINE void nrf_spu_event_clear(NRF_SPU_Type *  p_reg,
38                                             nrf_spu_event_t event);
39  NRF_STATIC_INLINE bool nrf_spu_event_check(NRF_SPU_Type const * p_reg,
40                                             nrf_spu_event_t      event);
41  NRF_STATIC_INLINE void nrf_spu_int_enable(NRF_SPU_Type * p_reg,
42                                            uint32_t       mask);
43  NRF_STATIC_INLINE void nrf_spu_int_disable(NRF_SPU_Type * p_reg,
44                                             uint32_t       mask);
45  NRF_STATIC_INLINE uint32_t nrf_spu_int_enable_check(NRF_SPU_Type const * p_reg, uint32_t mask);
46  NRF_STATIC_INLINE void nrf_spu_publish_set(NRF_SPU_Type *  p_reg,
47                                             nrf_spu_event_t event,
48                                             uint32_t        channel);
49  NRF_STATIC_INLINE void nrf_spu_publish_clear(NRF_SPU_Type *  p_reg,
50                                               nrf_spu_event_t event);
51  NRF_STATIC_INLINE bool nrf_spu_tz_is_available(NRF_SPU_Type const * p_reg);
52  NRF_STATIC_INLINE void nrf_spu_dppi_config_set(NRF_SPU_Type * p_reg,
53                                                 uint8_t        dppi_id,
54                                                 uint32_t       channels_mask,
55                                                 bool           lock_conf);
56  NRF_STATIC_INLINE void nrf_spu_gpio_config_set(NRF_SPU_Type * p_reg,
57                                                 uint8_t        gpio_port,
58                                                 uint32_t       gpio_mask,
59                                                 bool           lock_conf);
60  NRF_STATIC_INLINE void nrf_spu_flashnsc_set(NRF_SPU_Type *     p_reg,
61                                              uint8_t            flash_nsc_id,
62                                              nrf_spu_nsc_size_t flash_nsc_size,
63                                              uint8_t            region_number,
64                                              bool               lock_conf);
65  NRF_STATIC_INLINE void nrf_spu_ramnsc_set(NRF_SPU_Type *     p_reg,
66                                            uint8_t            ram_nsc_id,
67                                            nrf_spu_nsc_size_t ram_nsc_size,
68                                            uint8_t            region_number,
69                                            bool               lock_conf);
70  NRF_STATIC_INLINE void nrf_spu_flashregion_set(NRF_SPU_Type * p_reg,
71                                                 uint8_t        region_id,
</span>72                                                 bool           secure_attr,
73                                                 uint32_t       permissions,
74                                                 bool           lock_conf);
75  NRF_STATIC_INLINE void nrf_spu_ramregion_set(NRF_SPU_Type * p_reg,
76                                               uint8_t        region_id,
77                                               bool           secure_attr,
78                                               uint32_t       permissions,
79                                               bool           lock_conf);
80  NRF_STATIC_INLINE void nrf_spu_peripheral_set(NRF_SPU_Type * p_reg,
81                                                uint32_t       peripheral_id,
82                                                bool           secure_attr,
83                                                bool           secure_dma,
84                                                bool           lock_conf);
85  NRF_STATIC_INLINE void nrf_spu_extdomain_set(NRF_SPU_Type * p_reg,
86                                               uint32_t       domain_id,
87                                               bool           secure_attr,
88                                               bool           lock_conf);
89  #ifndef NRF_DECLARE_ONLY
90  NRF_STATIC_INLINE void nrf_spu_event_clear(NRF_SPU_Type *  p_reg,
91                                             nrf_spu_event_t event)
92  {
93      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
94      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
95      (void)dummy;
96  }
97  NRF_STATIC_INLINE bool nrf_spu_event_check(NRF_SPU_Type const * p_reg,
98                                             nrf_spu_event_t      event)
99  {
100      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
101  }
102  NRF_STATIC_INLINE void nrf_spu_int_enable(NRF_SPU_Type * p_reg,
103                                            uint32_t       mask)
104  {
105      p_reg->INTENSET = mask;
106  }
107  NRF_STATIC_INLINE void nrf_spu_int_disable(NRF_SPU_Type * p_reg,
108                                             uint32_t       mask)
109  {
110      p_reg->INTENCLR = mask;
111  }
112  NRF_STATIC_INLINE uint32_t nrf_spu_int_enable_check(NRF_SPU_Type const * p_reg, uint32_t mask)
113  {
114      return p_reg->INTENSET & mask;
115  }
116  NRF_STATIC_INLINE void nrf_spu_publish_set(NRF_SPU_Type *  p_reg,
117                                             nrf_spu_event_t event,
118                                             uint32_t        channel)
119  {
120      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
121          (channel | (SPU_PUBLISH_RAMACCERR_EN_Msk));
122  }
123  NRF_STATIC_INLINE void nrf_spu_publish_clear(NRF_SPU_Type *  p_reg,
124                                               nrf_spu_event_t event)
125  {
126      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
127  }
128  NRF_STATIC_INLINE bool nrf_spu_tz_is_available(NRF_SPU_Type const * p_reg)
129  {
130      return (p_reg->CAP & SPU_CAP_TZM_Msk ? true : false);
131  }
132  NRF_STATIC_INLINE void nrf_spu_dppi_config_set(NRF_SPU_Type * p_reg,
133                                                 uint8_t        dppi_id,
134                                                 uint32_t       channels_mask,
135                                                 bool           lock_conf)
136  {
137      NRFX_ASSERT(!(p_reg->DPPI[dppi_id].LOCK & SPU_DPPI_LOCK_LOCK_Msk));
138      p_reg->DPPI[dppi_id].PERM = channels_mask;
139      if (lock_conf)
140      {
141          p_reg->DPPI[dppi_id].LOCK = (SPU_DPPI_LOCK_LOCK_Msk);
142      }
143  }
144  NRF_STATIC_INLINE void nrf_spu_gpio_config_set(NRF_SPU_Type * p_reg,
145                                                 uint8_t        gpio_port,
146                                                 uint32_t       gpio_mask,
147                                                 bool           lock_conf)
148  {
149      NRFX_ASSERT(!(p_reg->GPIOPORT[gpio_port].LOCK & SPU_GPIOPORT_LOCK_LOCK_Msk));
150      p_reg->GPIOPORT[gpio_port].PERM = gpio_mask;
151      if (lock_conf)
152      {
153          p_reg->GPIOPORT[gpio_port].LOCK = (SPU_GPIOPORT_LOCK_LOCK_Msk);
154      }
155  }
156  NRF_STATIC_INLINE void nrf_spu_flashnsc_set(NRF_SPU_Type *     p_reg,
157                                              uint8_t            flash_nsc_id,
158                                              nrf_spu_nsc_size_t flash_nsc_size,
159                                              uint8_t            region_number,
160                                              bool               lock_conf)
161  {
162      NRFX_ASSERT(!(p_reg->FLASHNSC[flash_nsc_id].REGION & SPU_FLASHNSC_REGION_LOCK_Msk));
163      NRFX_ASSERT(!(p_reg->FLASHNSC[flash_nsc_id].SIZE & SPU_FLASHNSC_SIZE_LOCK_Msk));
164      p_reg->FLASHNSC[flash_nsc_id].REGION = (uint32_t)region_number |
165          (lock_conf ? SPU_FLASHNSC_REGION_LOCK_Msk : 0);
166      p_reg->FLASHNSC[flash_nsc_id].SIZE = (uint32_t)flash_nsc_size |
167          (lock_conf ? SPU_FLASHNSC_SIZE_LOCK_Msk : 0);
168  }
169  NRF_STATIC_INLINE void nrf_spu_ramnsc_set(NRF_SPU_Type *     p_reg,
170                                            uint8_t            ram_nsc_id,
171                                            nrf_spu_nsc_size_t ram_nsc_size,
172                                            uint8_t            region_number,
173                                            bool               lock_conf)
174  {
175      NRFX_ASSERT(!(p_reg->RAMNSC[ram_nsc_id].REGION & SPU_RAMNSC_REGION_LOCK_Msk));
176      NRFX_ASSERT(!(p_reg->RAMNSC[ram_nsc_id].SIZE & SPU_RAMNSC_SIZE_LOCK_Msk));
177      p_reg->RAMNSC[ram_nsc_id].REGION = (uint32_t)region_number |
178          (lock_conf ? SPU_RAMNSC_REGION_LOCK_Msk : 0);
179      p_reg->RAMNSC[ram_nsc_id].SIZE = (uint32_t)ram_nsc_size |
180          (lock_conf ? SPU_RAMNSC_SIZE_LOCK_Msk : 0);
181  }
182  NRF_STATIC_INLINE void nrf_spu_flashregion_set(NRF_SPU_Type * p_reg,
183                                                 uint8_t        region_id,
184                                                 bool           secure_attr,
185                                                 uint32_t       permissions,
186                                                 bool           lock_conf)
187  {
188      NRFX_ASSERT(!(p_reg->FLASHREGION[region_id].PERM & SPU_FLASHREGION_PERM_LOCK_Msk));
189      p_reg->FLASHREGION[region_id].PERM = permissions         |
190          (secure_attr ? SPU_FLASHREGION_PERM_SECATTR_Msk : 0) |
191          (lock_conf   ? SPU_FLASHREGION_PERM_LOCK_Msk    : 0);
192  }
193  NRF_STATIC_INLINE void nrf_spu_ramregion_set(NRF_SPU_Type * p_reg,
194                                               uint8_t        region_id,
195                                               bool           secure_attr,
196                                               uint32_t       permissions,
197                                               bool           lock_conf)
198  {
199      NRFX_ASSERT(!(p_reg->RAMREGION[region_id].PERM & SPU_RAMREGION_PERM_LOCK_Msk));
200      p_reg->RAMREGION[region_id].PERM = permissions         |
201          (secure_attr ? SPU_RAMREGION_PERM_SECATTR_Msk : 0) |
202          (lock_conf   ? SPU_RAMREGION_PERM_LOCK_Msk    : 0);
203  }
204  NRF_STATIC_INLINE void nrf_spu_peripheral_set(NRF_SPU_Type * p_reg,
205                                                uint32_t       peripheral_id,
206                                                bool           secure_attr,
207                                                bool           secure_dma,
208                                                bool           lock_conf)
209  {
210      NRFX_ASSERT(p_reg->PERIPHID[peripheral_id].PERM & SPU_PERIPHID_PERM_PRESENT_Msk);
211      NRFX_ASSERT(!(p_reg->PERIPHID[peripheral_id].PERM & SPU_PERIPHID_PERM_LOCK_Msk));
212      p_reg->PERIPHID[peripheral_id].PERM =
213           (secure_attr ? SPU_PERIPHID_PERM_SECATTR_Msk : 0) |
214           (secure_dma  ? SPU_PERIPHID_PERM_DMASEC_Msk  : 0) |
215           (lock_conf   ? SPU_PERIPHID_PERM_LOCK_Msk    : 0);
216  }
217  NRF_STATIC_INLINE void nrf_spu_extdomain_set(NRF_SPU_Type * p_reg,
218                                               uint32_t       domain_id,
219                                               bool           secure_attr,
220                                               bool           lock_conf)
221  {
222      NRFX_ASSERT(!(p_reg->EXTDOMAIN[domain_id].PERM & SPU_EXTDOMAIN_PERM_LOCK_Msk));
223      p_reg->EXTDOMAIN[domain_id].PERM =
224          (secure_attr ? SPU_EXTDOMAIN_PERM_SECATTR_Msk : 0) |
225          (lock_conf   ? SPU_EXTDOMAIN_PERM_LOCK_Msk    : 0);
226  }
227  #endif 
228  #ifdef __cplusplus
229  }
230  #endif
231  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-read.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spu.h</div>
                </div>
                <div class="column column_space"><pre><code>40      int err; &bsol;* Error flags, 0 when there is no error */
41      char errstr[128]; &bsol;* String representation of error when applicable */
42      char *buf; &bsol;* Read buffer */
43      size_t pos; &bsol;* Buffer cursor */
44      size_t len; &bsol;* Buffer length */
45      size_t maxbuf; &bsol;* Max length of unused buffer */
46      redisReadTask rstack[9];
47      int ridx; &bsol;* Index of current read task */
48      void *reply; &bsol;* Temporary reply pointer */
49      redisReplyObjectFunctions *fn;
50      void *privdata;
</pre></code></div>
                <div class="column column_space"><pre><code>37  NRF_STATIC_INLINE void nrf_spu_event_clear(NRF_SPU_Type *  p_reg,
38                                             nrf_spu_event_t event);
39  NRF_STATIC_INLINE bool nrf_spu_event_check(NRF_SPU_Type const * p_reg,
40                                             nrf_spu_event_t      event);
41  NRF_STATIC_INLINE void nrf_spu_int_enable(NRF_SPU_Type * p_reg,
42                                            uint32_t       mask);
43  NRF_STATIC_INLINE void nrf_spu_int_disable(NRF_SPU_Type * p_reg,
44                                             uint32_t       mask);
45  NRF_STATIC_INLINE uint32_t nrf_spu_int_enable_check(NRF_SPU_Type const * p_reg, uint32_t mask);
46  NRF_STATIC_INLINE void nrf_spu_publish_set(NRF_SPU_Type *  p_reg,
47                                             nrf_spu_event_t event,
48                                             uint32_t        channel);
49  NRF_STATIC_INLINE void nrf_spu_publish_clear(NRF_SPU_Type *  p_reg,
50                                               nrf_spu_event_t event);
51  NRF_STATIC_INLINE bool nrf_spu_tz_is_available(NRF_SPU_Type const * p_reg);
52  NRF_STATIC_INLINE void nrf_spu_dppi_config_set(NRF_SPU_Type * p_reg,
53                                                 uint8_t        dppi_id,
54                                                 uint32_t       channels_mask,
55                                                 bool           lock_conf);
56  NRF_STATIC_INLINE void nrf_spu_gpio_config_set(NRF_SPU_Type * p_reg,
57                                                 uint8_t        gpio_port,
58                                                 uint32_t       gpio_mask,
59                                                 bool           lock_conf);
60  NRF_STATIC_INLINE void nrf_spu_flashnsc_set(NRF_SPU_Type *     p_reg,
61                                              uint8_t            flash_nsc_id,
62                                              nrf_spu_nsc_size_t flash_nsc_size,
63                                              uint8_t            region_number,
64                                              bool               lock_conf);
65  NRF_STATIC_INLINE void nrf_spu_ramnsc_set(NRF_SPU_Type *     p_reg,
66                                            uint8_t            ram_nsc_id,
67                                            nrf_spu_nsc_size_t ram_nsc_size,
68                                            uint8_t            region_number,
69                                            bool               lock_conf);
70  NRF_STATIC_INLINE void nrf_spu_flashregion_set(NRF_SPU_Type * p_reg,
71                                                 uint8_t        region_id,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    