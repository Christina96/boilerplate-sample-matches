
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.640066500415628%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_skein.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include "sph_skein.h"
4  #ifdef __cplusplus
5  extern "C"{
6  #endif
7  #if SPH_SMALL_FOOTPRINT && !defined SPH_SMALL_FOOTPRINT_SKEIN
8  #define SPH_SMALL_FOOTPRINT_SKEIN   1
9  #endif
10  #ifdef _MSC_VER
11  #pragma warning (disable: 4146)
12  #endif
13  #if SPH_64
14  #if 0
15  #define M5_0_0    0
16  #define M5_0_1    1
17  #define M5_0_2    2
18  #define M5_0_3    3
19  #define M5_1_0    1
20  #define M5_1_1    2
21  #define M5_1_2    3
22  #define M5_1_3    4
23  #define M5_2_0    2
24  #define M5_2_1    3
25  #define M5_2_2    4
26  #define M5_2_3    0
27  #define M5_3_0    3
28  #define M5_3_1    4
29  #define M5_3_2    0
30  #define M5_3_3    1
31  #define M5_4_0    4
32  #define M5_4_1    0
33  #define M5_4_2    1
34  #define M5_4_3    2
35  #define M5_5_0    0
36  #define M5_5_1    1
37  #define M5_5_2    2
38  #define M5_5_3    3
39  #define M5_6_0    1
40  #define M5_6_1    2
41  #define M5_6_2    3
42  #define M5_6_3    4
43  #define M5_7_0    2
44  #define M5_7_1    3
45  #define M5_7_2    4
46  #define M5_7_3    0
47  #define M5_8_0    3
48  #define M5_8_1    4
49  #define M5_8_2    0
50  #define M5_8_3    1
51  #define M5_9_0    4
52  #define M5_9_1    0
53  #define M5_9_2    1
54  #define M5_9_3    2
55  #define M5_10_0   0
56  #define M5_10_1   1
57  #define M5_10_2   2
58  #define M5_10_3   3
59  #define M5_11_0   1
60  #define M5_11_1   2
61  #define M5_11_2   3
62  #define M5_11_3   4
63  #define M5_12_0   2
64  #define M5_12_1   3
65  #define M5_12_2   4
66  #define M5_12_3   0
67  #define M5_13_0   3
68  #define M5_13_1   4
69  #define M5_13_2   0
70  #define M5_13_3   1
71  #define M5_14_0   4
72  #define M5_14_1   0
73  #define M5_14_2   1
74  #define M5_14_3   2
75  #define M5_15_0   0
76  #define M5_15_1   1
77  #define M5_15_2   2
78  #define M5_15_3   3
79  #define M5_16_0   1
80  #define M5_16_1   2
81  #define M5_16_2   3
82  #define M5_16_3   4
83  #define M5_17_0   2
84  #define M5_17_1   3
85  #define M5_17_2   4
86  #define M5_17_3   0
87  #define M5_18_0   3
88  #define M5_18_1   4
89  #define M5_18_2   0
90  #define M5_18_3   1
91  #endif
92  #define M9_0_0    0
93  #define M9_0_1    1
94  #define M9_0_2    2
95  #define M9_0_3    3
96  #define M9_0_4    4
97  #define M9_0_5    5
98  #define M9_0_6    6
99  #define M9_0_7    7
100  #define M9_1_0    1
101  #define M9_1_1    2
102  #define M9_1_2    3
103  #define M9_1_3    4
104  #define M9_1_4    5
105  #define M9_1_5    6
106  #define M9_1_6    7
107  #define M9_1_7    8
108  #define M9_2_0    2
109  #define M9_2_1    3
110  #define M9_2_2    4
111  #define M9_2_3    5
112  #define M9_2_4    6
113  #define M9_2_5    7
114  #define M9_2_6    8
115  #define M9_2_7    0
116  #define M9_3_0    3
117  #define M9_3_1    4
118  #define M9_3_2    5
119  #define M9_3_3    6
120  #define M9_3_4    7
121  #define M9_3_5    8
122  #define M9_3_6    0
123  #define M9_3_7    1
124  #define M9_4_0    4
125  #define M9_4_1    5
126  #define M9_4_2    6
127  #define M9_4_3    7
128  #define M9_4_4    8
129  #define M9_4_5    0
130  #define M9_4_6    1
131  #define M9_4_7    2
132  #define M9_5_0    5
133  #define M9_5_1    6
134  #define M9_5_2    7
135  #define M9_5_3    8
136  #define M9_5_4    0
137  #define M9_5_5    1
138  #define M9_5_6    2
139  #define M9_5_7    3
140  #define M9_6_0    6
141  #define M9_6_1    7
142  #define M9_6_2    8
143  #define M9_6_3    0
144  #define M9_6_4    1
145  #define M9_6_5    2
146  #define M9_6_6    3
147  #define M9_6_7    4
148  #define M9_7_0    7
149  #define M9_7_1    8
150  #define M9_7_2    0
151  #define M9_7_3    1
152  #define M9_7_4    2
153  #define M9_7_5    3
154  #define M9_7_6    4
155  #define M9_7_7    5
156  #define M9_8_0    8
157  #define M9_8_1    0
158  #define M9_8_2    1
159  #define M9_8_3    2
160  #define M9_8_4    3
161  #define M9_8_5    4
162  #define M9_8_6    5
163  #define M9_8_7    6
164  #define M9_9_0    0
165  #define M9_9_1    1
166  #define M9_9_2    2
167  #define M9_9_3    3
168  #define M9_9_4    4
169  #define M9_9_5    5
170  #define M9_9_6    6
171  #define M9_9_7    7
172  #define M9_10_0   1
173  #define M9_10_1   2
174  #define M9_10_2   3
175  #define M9_10_3   4
176  #define M9_10_4   5
177  #define M9_10_5   6
178  #define M9_10_6   7
179  #define M9_10_7   8
180  #define M9_11_0   2
181  #define M9_11_1   3
182  #define M9_11_2   4
183  #define M9_11_3   5
184  #define M9_11_4   6
185  #define M9_11_5   7
186  #define M9_11_6   8
187  #define M9_11_7   0
188  #define M9_12_0   3
189  #define M9_12_1   4
190  #define M9_12_2   5
191  #define M9_12_3   6
192  #define M9_12_4   7
193  #define M9_12_5   8
194  #define M9_12_6   0
195  #define M9_12_7   1
196  #define M9_13_0   4
197  #define M9_13_1   5
198  #define M9_13_2   6
199  #define M9_13_3   7
200  #define M9_13_4   8
201  #define M9_13_5   0
202  #define M9_13_6   1
203  #define M9_13_7   2
204  #define M9_14_0   5
205  #define M9_14_1   6
206  #define M9_14_2   7
207  #define M9_14_3   8
208  #define M9_14_4   0
209  #define M9_14_5   1
210  #define M9_14_6   2
211  #define M9_14_7   3
212  #define M9_15_0   6
213  #define M9_15_1   7
214  #define M9_15_2   8
215  #define M9_15_3   0
216  #define M9_15_4   1
217  #define M9_15_5   2
218  #define M9_15_6   3
219  #define M9_15_7   4
220  #define M9_16_0   7
221  #define M9_16_1   8
222  #define M9_16_2   0
223  #define M9_16_3   1
224  #define M9_16_4   2
225  #define M9_16_5   3
226  #define M9_16_6   4
227  #define M9_16_7   5
228  #define M9_17_0   8
229  #define M9_17_1   0
230  #define M9_17_2   1
231  #define M9_17_3   2
232  #define M9_17_4   3
233  #define M9_17_5   4
234  #define M9_17_6   5
235  #define M9_17_7   6
236  #define M9_18_0   0
237  #define M9_18_1   1
238  #define M9_18_2   2
239  #define M9_18_3   3
240  #define M9_18_4   4
241  #define M9_18_5   5
242  #define M9_18_6   6
243  #define M9_18_7   7
244  #define M3_0_0    0
245  #define M3_0_1    1
246  #define M3_1_0    1
247  #define M3_1_1    2
248  #define M3_2_0    2
249  #define M3_2_1    0
250  #define M3_3_0    0
251  #define M3_3_1    1
252  #define M3_4_0    1
253  #define M3_4_1    2
254  #define M3_5_0    2
255  #define M3_5_1    0
256  #define M3_6_0    0
257  #define M3_6_1    1
258  #define M3_7_0    1
259  #define M3_7_1    2
260  #define M3_8_0    2
261  #define M3_8_1    0
262  #define M3_9_0    0
263  #define M3_9_1    1
264  #define M3_10_0   1
265  #define M3_10_1   2
266  #define M3_11_0   2
267  #define M3_11_1   0
268  #define M3_12_0   0
269  #define M3_12_1   1
270  #define M3_13_0   1
271  #define M3_13_1   2
272  #define M3_14_0   2
273  #define M3_14_1   0
274  #define M3_15_0   0
275  #define M3_15_1   1
276  #define M3_16_0   1
277  #define M3_16_1   2
278  #define M3_17_0   2
279  #define M3_17_1   0
280  #define M3_18_0   0
281  #define M3_18_1   1
282  #define XCAT(x, y)     XCAT_(x, y)
283  #define XCAT_(x, y)    x ## y
284  #if 0
285  #define SKSI(k, s, i)   XCAT(k, XCAT(XCAT(XCAT(M5_, s), _), i))
286  #define SKST(t, s, v)   XCAT(t, XCAT(XCAT(XCAT(M3_, s), _), v))
287  #endif
288  #define SKBI(k, s, i)   XCAT(k, XCAT(XCAT(XCAT(M9_, s), _), i))
289  #define SKBT(t, s, v)   XCAT(t, XCAT(XCAT(XCAT(M3_, s), _), v))
290  #if 0
291  #define TFSMALL_KINIT(k0, k1, k2, k3, k4, t0, t1, t2)   do { \
292  		k4 = (k0 ^ k1) ^ (k2 ^ k3) ^ SPH_C64(0x1BD11BDAA9FC1A22); \
293  		t2 = t0 ^ t1; \
294  	} while (0)
295  #endif
296  #define TFBIG_KINIT(k0, k1, k2, k3, k4, k5, k6, k7, k8, t0, t1, t2)   do { \
297  		k8 = ((k0 ^ k1) ^ (k2 ^ k3)) ^ ((k4 ^ k5) ^ (k6 ^ k7)) \
298  			^ SPH_C64(0x1BD11BDAA9FC1A22); \
299  		t2 = t0 ^ t1; \
300  	} while (0)
301  #if 0
302  #define TFSMALL_ADDKEY(w0, w1, w2, w3, k, t, s)   do { \
303  		w0 = SPH_T64(w0 + SKSI(k, s, 0)); \
304  		w1 = SPH_T64(w1 + SKSI(k, s, 1) + SKST(t, s, 0)); \
305  		w2 = SPH_T64(w2 + SKSI(k, s, 2) + SKST(t, s, 1)); \
306  		w3 = SPH_T64(w3 + SKSI(k, s, 3) + (sph_u64)s); \
307  	} while (0)
308  #endif
309  #if SPH_SMALL_FOOTPRINT_SKEIN
310  #define TFBIG_ADDKEY(s, tt0, tt1)   do { \
311  		p0 = SPH_T64(p0 + h[s + 0]); \
312  		p1 = SPH_T64(p1 + h[s + 1]); \
313  		p2 = SPH_T64(p2 + h[s + 2]); \
314  		p3 = SPH_T64(p3 + h[s + 3]); \
315  		p4 = SPH_T64(p4 + h[s + 4]); \
316  		p5 = SPH_T64(p5 + h[s + 5] + tt0); \
317  		p6 = SPH_T64(p6 + h[s + 6] + tt1); \
318  		p7 = SPH_T64(p7 + h[s + 7] + (sph_u64)s); \
319  	} while (0)
320  #else
321  #define TFBIG_ADDKEY(w0, w1, w2, w3, w4, w5, w6, w7, k, t, s)   do { \
322  		w0 = SPH_T64(w0 + SKBI(k, s, 0)); \
323  		w1 = SPH_T64(w1 + SKBI(k, s, 1)); \
324  		w2 = SPH_T64(w2 + SKBI(k, s, 2)); \
325  		w3 = SPH_T64(w3 + SKBI(k, s, 3)); \
326  		w4 = SPH_T64(w4 + SKBI(k, s, 4)); \
327  		w5 = SPH_T64(w5 + SKBI(k, s, 5) + SKBT(t, s, 0)); \
328  		w6 = SPH_T64(w6 + SKBI(k, s, 6) + SKBT(t, s, 1)); \
329  		w7 = SPH_T64(w7 + SKBI(k, s, 7) + (sph_u64)s); \
330  	} while (0)
331  #endif
332  #if 0
333  #define TFSMALL_MIX(x0, x1, rc)   do { \
334  		x0 = SPH_T64(x0 + x1); \
335  		x1 = SPH_ROTL64(x1, rc) ^ x0; \
336  	} while (0)
337  #endif
338  #define TFBIG_MIX(x0, x1, rc)   do { \
339  		x0 = SPH_T64(x0 + x1); \
340  		x1 = SPH_ROTL64(x1, rc) ^ x0; \
341  	} while (0)
342  #if 0
343  #define TFSMALL_MIX4(w0, w1, w2, w3, rc0, rc1)  do { \
344  		TFSMALL_MIX(w0, w1, rc0); \
345  		TFSMALL_MIX(w2, w3, rc1); \
346  	} while (0)
347  #endif
348  #define TFBIG_MIX8(w0, w1, w2, w3, w4, w5, w6, w7, rc0, rc1, rc2, rc3)  do { \
349  		TFBIG_MIX(w0, w1, rc0); \
350  		TFBIG_MIX(w2, w3, rc1); \
351  		TFBIG_MIX(w4, w5, rc2); \
352  		TFBIG_MIX(w6, w7, rc3); \
353  	} while (0)
354  #if 0
355  #define TFSMALL_4e(s)   do { \
356  		TFSMALL_ADDKEY(p0, p1, p2, p3, h, t, s); \
357  		TFSMALL_MIX4(p0, p1, p2, p3, 14, 16); \
358  		TFSMALL_MIX4(p0, p3, p2, p1, 52, 57); \
359  		TFSMALL_MIX4(p0, p1, p2, p3, 23, 40); \
360  		TFSMALL_MIX4(p0, p3, p2, p1,  5, 37); \
361  	} while (0)
362  #define TFSMALL_4o(s)   do { \
363  		TFSMALL_ADDKEY(p0, p1, p2, p3, h, t, s); \
364  		TFSMALL_MIX4(p0, p1, p2, p3, 25, 33); \
365  		TFSMALL_MIX4(p0, p3, p2, p1, 46, 12); \
366  		TFSMALL_MIX4(p0, p1, p2, p3, 58, 22); \
367  		TFSMALL_MIX4(p0, p3, p2, p1, 32, 32); \
368  	} while (0)
369  #endif
370  #if SPH_SMALL_FOOTPRINT_SKEIN
371  #define TFBIG_4e(s)   do { \
372  		TFBIG_ADDKEY(s, t0, t1); \
373  		TFBIG_MIX8(p0, p1, p2, p3, p4, p5, p6, p7, 46, 36, 19, 37); \
374  		TFBIG_MIX8(p2, p1, p4, p7, p6, p5, p0, p3, 33, 27, 14, 42); \
375  		TFBIG_MIX8(p4, p1, p6, p3, p0, p5, p2, p7, 17, 49, 36, 39); \
376  		TFBIG_MIX8(p6, p1, p0, p7, p2, p5, p4, p3, 44,  9, 54, 56); \
377  	} while (0)
378  #define TFBIG_4o(s)   do { \
379  		TFBIG_ADDKEY(s, t1, t2); \
380  		TFBIG_MIX8(p0, p1, p2, p3, p4, p5, p6, p7, 39, 30, 34, 24); \
381  		TFBIG_MIX8(p2, p1, p4, p7, p6, p5, p0, p3, 13, 50, 10, 17); \
382  		TFBIG_MIX8(p4, p1, p6, p3, p0, p5, p2, p7, 25, 29, 39, 43); \
383  		TFBIG_MIX8(p6, p1, p0, p7, p2, p5, p4, p3,  8, 35, 56, 22); \
384  	} while (0)
385  #else
386  #define TFBIG_4e(s)   do { \
387  		TFBIG_ADDKEY(p0, p1, p2, p3, p4, p5, p6, p7, h, t, s); \
388  		TFBIG_MIX8(p0, p1, p2, p3, p4, p5, p6, p7, 46, 36, 19, 37); \
389  		TFBIG_MIX8(p2, p1, p4, p7, p6, p5, p0, p3, 33, 27, 14, 42); \
390  		TFBIG_MIX8(p4, p1, p6, p3, p0, p5, p2, p7, 17, 49, 36, 39); \
391  		TFBIG_MIX8(p6, p1, p0, p7, p2, p5, p4, p3, 44,  9, 54, 56); \
392  	} while (0)
393  #define TFBIG_4o(s)   do { \
394  		TFBIG_ADDKEY(p0, p1, p2, p3, p4, p5, p6, p7, h, t, s); \
395  		TFBIG_MIX8(p0, p1, p2, p3, p4, p5, p6, p7, 39, 30, 34, 24); \
396  		TFBIG_MIX8(p2, p1, p4, p7, p6, p5, p0, p3, 13, 50, 10, 17); \
397  		TFBIG_MIX8(p4, p1, p6, p3, p0, p5, p2, p7, 25, 29, 39, 43); \
398  		TFBIG_MIX8(p6, p1, p0, p7, p2, p5, p4, p3,  8, 35, 56, 22); \
399  	} while (0)
400  #endif
401  #if 0
402  #define UBI_SMALL(etype, extra)  do { \
403  		sph_u64 h4, t0, t1, t2; \
404  		sph_u64 m0 = sph_dec64le(buf +  0); \
405  		sph_u64 m1 = sph_dec64le(buf +  8); \
406  		sph_u64 m2 = sph_dec64le(buf + 16); \
407  		sph_u64 m3 = sph_dec64le(buf + 24); \
408  		sph_u64 p0 = m0; \
409  		sph_u64 p1 = m1; \
410  		sph_u64 p2 = m2; \
411  		sph_u64 p3 = m3; \
412  		t0 = SPH_T64(bcount << 5) + (sph_u64)(extra); \
413  		t1 = (bcount >> 59) + ((sph_u64)(etype) << 55); \
414  		TFSMALL_KINIT(h0, h1, h2, h3, h4, t0, t1, t2); \
415  		TFSMALL_4e(0); \
416  		TFSMALL_4o(1); \
417  		TFSMALL_4e(2); \
418  		TFSMALL_4o(3); \
419  		TFSMALL_4e(4); \
420  		TFSMALL_4o(5); \
421  		TFSMALL_4e(6); \
422  		TFSMALL_4o(7); \
423  		TFSMALL_4e(8); \
424  		TFSMALL_4o(9); \
425  		TFSMALL_4e(10); \
426  		TFSMALL_4o(11); \
427  		TFSMALL_4e(12); \
428  		TFSMALL_4o(13); \
429  		TFSMALL_4e(14); \
430  		TFSMALL_4o(15); \
431  		TFSMALL_4e(16); \
432  		TFSMALL_4o(17); \
433  		TFSMALL_ADDKEY(p0, p1, p2, p3, h, t, 18); \
434  		h0 = m0 ^ p0; \
435  		h1 = m1 ^ p1; \
436  		h2 = m2 ^ p2; \
437  		h3 = m3 ^ p3; \
438  	} while (0)
439  #endif
440  #if SPH_SMALL_FOOTPRINT_SKEIN
441  #define UBI_BIG(etype, extra)  do { \
442  		sph_u64 t0, t1, t2; \
443  		unsigned u; \
444  		sph_u64 m0 = sph_dec64le_aligned(buf +  0); \
445  		sph_u64 m1 = sph_dec64le_aligned(buf +  8); \
446  		sph_u64 m2 = sph_dec64le_aligned(buf + 16); \
447  		sph_u64 m3 = sph_dec64le_aligned(buf + 24); \
448  		sph_u64 m4 = sph_dec64le_aligned(buf + 32); \
449  		sph_u64 m5 = sph_dec64le_aligned(buf + 40); \
450  		sph_u64 m6 = sph_dec64le_aligned(buf + 48); \
451  		sph_u64 m7 = sph_dec64le_aligned(buf + 56); \
452  		sph_u64 p0 = m0; \
453  		sph_u64 p1 = m1; \
454  		sph_u64 p2 = m2; \
455  		sph_u64 p3 = m3; \
456  		sph_u64 p4 = m4; \
457  		sph_u64 p5 = m5; \
458  		sph_u64 p6 = m6; \
459  		sph_u64 p7 = m7; \
460  		t0 = SPH_T64(bcount << 6) + (sph_u64)(extra); \
461  		t1 = (bcount >> 58) + ((sph_u64)(etype) << 55); \
462  		TFBIG_KINIT(h[0], h[1], h[2], h[3], h[4], h[5], \
463  			h[6], h[7], h[8], t0, t1, t2); \
464  		for (u = 0; u <= 15; u += 3) { \
465  			h[u +  9] = h[u + 0]; \
466  			h[u + 10] = h[u + 1]; \
467  			h[u + 11] = h[u + 2]; \
468  		} \
469  		for (u = 0; u < 9; u ++) { \
470  			sph_u64 s = u << 1; \
471  			sph_u64 tmp; \
472  			TFBIG_4e(s); \
473  			TFBIG_4o(s + 1); \
474  			tmp = t2; \
475  			t2 = t1; \
476  			t1 = t0; \
477  			t0 = tmp; \
478  		} \
479  		TFBIG_ADDKEY(18, t0, t1); \
480  		h[0] = m0 ^ p0; \
481  		h[1] = m1 ^ p1; \
482  		h[2] = m2 ^ p2; \
483  		h[3] = m3 ^ p3; \
484  		h[4] = m4 ^ p4; \
485  		h[5] = m5 ^ p5; \
486  		h[6] = m6 ^ p6; \
487  		h[7] = m7 ^ p7; \
488  	} while (0)
489  #else
490  #define UBI_BIG(etype, extra)  do { \
491  		sph_u64 h8, t0, t1, t2; \
492  		sph_u64 m0 = sph_dec64le_aligned(buf +  0); \
493  		sph_u64 m1 = sph_dec64le_aligned(buf +  8); \
494  		sph_u64 m2 = sph_dec64le_aligned(buf + 16); \
495  		sph_u64 m3 = sph_dec64le_aligned(buf + 24); \
496  		sph_u64 m4 = sph_dec64le_aligned(buf + 32); \
497  		sph_u64 m5 = sph_dec64le_aligned(buf + 40); \
498  		sph_u64 m6 = sph_dec64le_aligned(buf + 48); \
499  		sph_u64 m7 = sph_dec64le_aligned(buf + 56); \
500  		sph_u64 p0 = m0; \
501  		sph_u64 p1 = m1; \
502  		sph_u64 p2 = m2; \
503  		sph_u64 p3 = m3; \
504  		sph_u64 p4 = m4; \
505  		sph_u64 p5 = m5; \
506  		sph_u64 p6 = m6; \
507  		sph_u64 p7 = m7; \
508  		t0 = SPH_T64(bcount << 6) + (sph_u64)(extra); \
509  		t1 = (bcount >> 58) + ((sph_u64)(etype) << 55); \
510  		TFBIG_KINIT(h0, h1, h2, h3, h4, h5, h6, h7, h8, t0, t1, t2); \
511  		TFBIG_4e(0); \
512  		TFBIG_4o(1); \
513  		TFBIG_4e(2); \
514  		TFBIG_4o(3); \
515  		TFBIG_4e(4); \
516  		TFBIG_4o(5); \
517  		TFBIG_4e(6); \
518  		TFBIG_4o(7); \
519  		TFBIG_4e(8); \
520  		TFBIG_4o(9); \
521  		TFBIG_4e(10); \
522  		TFBIG_4o(11); \
523  		TFBIG_4e(12); \
524  		TFBIG_4o(13); \
525  		TFBIG_4e(14); \
526  		TFBIG_4o(15); \
527  		TFBIG_4e(16); \
528  		TFBIG_4o(17); \
529  		TFBIG_ADDKEY(p0, p1, p2, p3, p4, p5, p6, p7, h, t, 18); \
530  		h0 = m0 ^ p0; \
531  		h1 = m1 ^ p1; \
532  		h2 = m2 ^ p2; \
533  		h3 = m3 ^ p3; \
534  		h4 = m4 ^ p4; \
535  		h5 = m5 ^ p5; \
536  		h6 = m6 ^ p6; \
537  		h7 = m7 ^ p7; \
538  	} while (0)
539  #endif
540  #if 0
541  #define DECL_STATE_SMALL \
542  	sph_u64 h0, h1, h2, h3; \
543  	sph_u64 bcount;
544  #define READ_STATE_SMALL(sc)   do { \
545  		h0 = (sc)->h0; \
546  		h1 = (sc)->h1; \
547  		h2 = (sc)->h2; \
548  		h3 = (sc)->h3; \
549  		bcount = sc->bcount; \
550  	} while (0)
551  #define WRITE_STATE_SMALL(sc)   do { \
552  		(sc)->h0 = h0; \
553  		(sc)->h1 = h1; \
554  		(sc)->h2 = h2; \
555  		(sc)->h3 = h3; \
556  		sc->bcount = bcount; \
557  	} while (0)
558  #endif
559  #if SPH_SMALL_FOOTPRINT_SKEIN
560  #define DECL_STATE_BIG \
561  	sph_u64 h[27]; \
562  	sph_u64 bcount;
563  #define READ_STATE_BIG(sc)   do { \
564  		h[0] = (sc)->h0; \
565  		h[1] = (sc)->h1; \
566  		h[2] = (sc)->h2; \
567  		h[3] = (sc)->h3; \
568  		h[4] = (sc)->h4; \
569  		h[5] = (sc)->h5; \
570  		h[6] = (sc)->h6; \
571  		h[7] = (sc)->h7; \
572  		bcount = sc->bcount; \
573  	} while (0)
574  #define WRITE_STATE_BIG(sc)   do { \
575  		(sc)->h0 = h[0]; \
576  		(sc)->h1 = h[1]; \
577  		(sc)->h2 = h[2]; \
578  		(sc)->h3 = h[3]; \
579  		(sc)->h4 = h[4]; \
580  		(sc)->h5 = h[5]; \
581  		(sc)->h6 = h[6]; \
582  		(sc)->h7 = h[7]; \
583  		sc->bcount = bcount; \
584  	} while (0)
585  #else
586  #define DECL_STATE_BIG \
587  	sph_u64 h0, h1, h2, h3, h4, h5, h6, h7; \
588  	sph_u64 bcount;
589  #define READ_STATE_BIG(sc)   do { \
590  		h0 = (sc)->h0; \
591  		h1 = (sc)->h1; \
592  		h2 = (sc)->h2; \
593  		h3 = (sc)->h3; \
594  		h4 = (sc)->h4; \
595  		h5 = (sc)->h5; \
596  		h6 = (sc)->h6; \
597  		h7 = (sc)->h7; \
598  		bcount = sc->bcount; \
599  	} while (0)
600  #define WRITE_STATE_BIG(sc)   do { \
601  		(sc)->h0 = h0; \
602  		(sc)->h1 = h1; \
603  		(sc)->h2 = h2; \
604  		(sc)->h3 = h3; \
605  		(sc)->h4 = h4; \
606  		(sc)->h5 = h5; \
607  		(sc)->h6 = h6; \
608  		(sc)->h7 = h7; \
609  		sc->bcount = bcount; \
610  	} while (0)
611  #endif
612  #if 0
613  static void
614  skein_small_init(sph_skein_small_context *sc, const sph_u64 *iv)
615  {
616  	sc->h0 = iv[0];
617  	sc->h1 = iv[1];
618  	sc->h2 = iv[2];
619  	sc->h3 = iv[3];
620  	sc->bcount = 0;
621  	sc->ptr = 0;
622  }
623  #endif
624  static void
625  skein_big_init(sph_skein_big_context *sc, const sph_u64 *iv)
626  {
627  	sc->h0 = iv[0];
628  	sc->h1 = iv[1];
629  	sc->h2 = iv[2];
630  	sc->h3 = iv[3];
631  	sc->h4 = iv[4];
632  	sc->h5 = iv[5];
633  	sc->h6 = iv[6];
634  	sc->h7 = iv[7];
635  	sc->bcount = 0;
636  	sc->ptr = 0;
637  }
638  #if 0
639  static void
640  skein_small_core(sph_skein_small_context *sc, const void *data, size_t len)
641  {
642  	unsigned char *buf;
643  	size_t ptr, clen;
644  	unsigned first;
645  	DECL_STATE_SMALL
646  	buf = sc->buf;
647  	ptr = sc->ptr;
648  	clen = (sizeof sc->buf) - ptr;
649  	if (len <= clen) {
650  		memcpy(buf + ptr, data, len);
651  		sc->ptr = ptr + len;
652  		return;
653  	}
654  	if (clen != 0) {
655  		memcpy(buf + ptr, data, clen);
656  		data = (const unsigned char *)data + clen;
657  		len -= clen;
658  	}
659  #if SPH_SMALL_FOOTPRINT_SKEIN
660  	READ_STATE_SMALL(sc);
661  	first = (bcount == 0) << 7;
662  	for (;;) {
663  		bcount ++;
664  		UBI_SMALL(96 + first, 0);
665  		if (len <= sizeof sc->buf)
666  			break;
667  		first = 0;
668  		memcpy(buf, data, sizeof sc->buf);
669  		data = (const unsigned char *)data + sizeof sc->buf;
670  		len -= sizeof sc->buf;
671  	}
672  	WRITE_STATE_SMALL(sc);
673  	sc->ptr = len;
674  	memcpy(buf, data, len);
675  #else
676  	READ_STATE_SMALL(sc);
677  	first = (bcount == 0) << 7;
678  	for (;;) {
679  		bcount ++;
680  		UBI_SMALL(96 + first, 0);
681  		if (len <= sizeof sc->buf)
682  			break;
683  		buf = (unsigned char *)data;
684  		bcount ++;
685  		UBI_SMALL(96, 0);
686  		if (len <= 2 * sizeof sc->buf) {
687  			data = buf + sizeof sc->buf;
688  			len -= sizeof sc->buf;
689  			break;
690  		}
691  		buf += sizeof sc->buf;
692  		data = buf + sizeof sc->buf;
693  		first = 0;
694  		len -= 2 * sizeof sc->buf;
695  	}
696  	WRITE_STATE_SMALL(sc);
697  	sc->ptr = len;
698  	memcpy(sc->buf, data, len);
699  #endif
<span onclick='openModal()' class='match'>700  }
701  #endif
702  static void
703  skein_big_core(sph_skein_big_context *sc, const void *data, size_t len)
704  {
705  	unsigned char *buf;
706  	size_t ptr;
707  	unsigned first;
708  	DECL_STATE_BIG
</span>709  	buf = sc->buf;
710  	ptr = sc->ptr;
711  	if (len <= (sizeof sc->buf) - ptr) {
712  		memcpy(buf + ptr, data, len);
713  		ptr += len;
714  		sc->ptr = ptr;
715  		return;
716  	}
717  	READ_STATE_BIG(sc);
718  	first = (bcount == 0) << 7;
719  	do {
720  		size_t clen;
721  		if (ptr == sizeof sc->buf) {
722  			bcount ++;
723  			UBI_BIG(96 + first, 0);
724  			first = 0;
725  			ptr = 0;
726  		}
727  		clen = (sizeof sc->buf) - ptr;
728  		if (clen > len)
729  			clen = len;
730  		memcpy(buf + ptr, data, clen);
731  		ptr += clen;
732  		data = (const unsigned char *)data + clen;
733  		len -= clen;
734  	} while (len > 0);
735  	WRITE_STATE_BIG(sc);
736  	sc->ptr = ptr;
737  }
738  #if 0
739  static void
740  skein_small_close(sph_skein_small_context *sc, unsigned ub, unsigned n,
741  	void *dst, size_t out_len)
742  {
743  	unsigned char *buf;
744  	size_t ptr;
745  	unsigned et;
746  	int i;
747  	DECL_STATE_SMALL
748  	if (n != 0) {
749  		unsigned z;
750  		unsigned char x;
751  		z = 0x80 >> n;
752  		x = ((ub & -z) | z) & 0xFF;
753  		skein_small_core(sc, &x, 1);
754  	}
755  	buf = sc->buf;
756  	ptr = sc->ptr;
757  	READ_STATE_SMALL(sc);
758  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
759  	et = 352 + ((bcount == 0) << 7) + (n != 0);
760  	for (i = 0; i < 2; i ++) {
761  		UBI_SMALL(et, ptr);
762  		if (i == 0) {
763  			memset(buf, 0, sizeof sc->buf);
764  			bcount = 0;
765  			et = 510;
766  			ptr = 8;
767  		}
768  	}
769  	sph_enc64le_aligned(buf +  0, h0);
770  	sph_enc64le_aligned(buf +  8, h1);
771  	sph_enc64le_aligned(buf + 16, h2);
772  	sph_enc64le_aligned(buf + 24, h3);
773  	memcpy(dst, buf, out_len);
774  }
775  #endif
776  static void
777  skein_big_close(sph_skein_big_context *sc, unsigned ub, unsigned n,
778  	void *dst, size_t out_len)
779  {
780  	unsigned char *buf;
781  	size_t ptr;
782  	unsigned et;
783  	int i;
784  #if SPH_SMALL_FOOTPRINT_SKEIN
785  	size_t u;
786  #endif
787  	DECL_STATE_BIG
788  	if (n != 0) {
789  		unsigned z;
790  		unsigned char x;
791  		z = 0x80 >> n;
792  		x = ((ub & -z) | z) & 0xFF;
793  		skein_big_core(sc, &x, 1);
794  	}
795  	buf = sc->buf;
796  	ptr = sc->ptr;
797  	READ_STATE_BIG(sc);
798  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
799  	et = 352 + ((bcount == 0) << 7) + (n != 0);
800  	for (i = 0; i < 2; i ++) {
801  		UBI_BIG(et, ptr);
802  		if (i == 0) {
803  			memset(buf, 0, sizeof sc->buf);
804  			bcount = 0;
805  			et = 510;
806  			ptr = 8;
807  		}
808  	}
809  #if SPH_SMALL_FOOTPRINT_SKEIN
810  	for (u = 0; u < out_len; u += 8)
811  		sph_enc64le_aligned(buf + u, h[u >> 3]);
812  	memcpy(dst, buf, out_len);
813  #else
814  	sph_enc64le_aligned(buf +  0, h0);
815  	sph_enc64le_aligned(buf +  8, h1);
816  	sph_enc64le_aligned(buf + 16, h2);
817  	sph_enc64le_aligned(buf + 24, h3);
818  	sph_enc64le_aligned(buf + 32, h4);
819  	sph_enc64le_aligned(buf + 40, h5);
820  	sph_enc64le_aligned(buf + 48, h6);
821  	sph_enc64le_aligned(buf + 56, h7);
822  	memcpy(dst, buf, out_len);
823  #endif
824  }
825  #if 0
826  static const sph_u64 IV224[] = {
827  	SPH_C64(0xC6098A8C9AE5EA0B), SPH_C64(0x876D568608C5191C),
828  	SPH_C64(0x99CB88D7D7F53884), SPH_C64(0x384BDDB1AEDDB5DE)
829  };
830  static const sph_u64 IV256[] = {
831  	SPH_C64(0xFC9DA860D048B449), SPH_C64(0x2FCA66479FA7D833),
832  	SPH_C64(0xB33BC3896656840F), SPH_C64(0x6A54E920FDE8DA69)
833  };
834  #endif
835  static const sph_u64 IV224[] = {
836  	SPH_C64(0xCCD0616248677224), SPH_C64(0xCBA65CF3A92339EF),
837  	SPH_C64(0x8CCD69D652FF4B64), SPH_C64(0x398AED7B3AB890B4),
838  	SPH_C64(0x0F59D1B1457D2BD0), SPH_C64(0x6776FE6575D4EB3D),
839  	SPH_C64(0x99FBC70E997413E9), SPH_C64(0x9E2CFCCFE1C41EF7)
840  };
841  static const sph_u64 IV256[] = {
842  	SPH_C64(0xCCD044A12FDB3E13), SPH_C64(0xE83590301A79A9EB),
843  	SPH_C64(0x55AEA0614F816E6F), SPH_C64(0x2A2767A4AE9B94DB),
844  	SPH_C64(0xEC06025E74DD7683), SPH_C64(0xE7A436CDC4746251),
845  	SPH_C64(0xC36FBAF9393AD185), SPH_C64(0x3EEDBA1833EDFC13)
846  };
847  static const sph_u64 IV384[] = {
848  	SPH_C64(0xA3F6C6BF3A75EF5F), SPH_C64(0xB0FEF9CCFD84FAA4),
849  	SPH_C64(0x9D77DD663D770CFE), SPH_C64(0xD798CBF3B468FDDA),
850  	SPH_C64(0x1BC4A6668A0E4465), SPH_C64(0x7ED7D434E5807407),
851  	SPH_C64(0x548FC1ACD4EC44D6), SPH_C64(0x266E17546AA18FF8)
852  };
853  static const sph_u64 IV512[] = {
854  	SPH_C64(0x4903ADFF749C51CE), SPH_C64(0x0D95DE399746DF03),
855  	SPH_C64(0x8FD1934127C79BCE), SPH_C64(0x9A255629FF352CB1),
856  	SPH_C64(0x5DB62599DF6CA7B0), SPH_C64(0xEABE394CA9D5C3F4),
857  	SPH_C64(0x991112C71A75B523), SPH_C64(0xAE18A40B660FCC33)
858  };
859  #if 0
860  void
861  sph_skein224_init(void *cc)
862  {
863  	skein_small_init(cc, IV224);
864  }
865  void
866  sph_skein224(void *cc, const void *data, size_t len)
867  {
868  	skein_small_core(cc, data, len);
869  }
870  void
871  sph_skein224_close(void *cc, void *dst)
872  {
873  	sph_skein224_addbits_and_close(cc, 0, 0, dst);
874  }
875  void
876  sph_skein224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
877  {
878  	skein_small_close(cc, ub, n, dst, 28);
879  	sph_skein224_init(cc);
880  }
881  void
882  sph_skein256_init(void *cc)
883  {
884  	skein_small_init(cc, IV256);
885  }
886  void
887  sph_skein256(void *cc, const void *data, size_t len)
888  {
889  	skein_small_core(cc, data, len);
890  }
891  void
892  sph_skein256_close(void *cc, void *dst)
893  {
894  	sph_skein256_addbits_and_close(cc, 0, 0, dst);
895  }
896  void
897  sph_skein256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
898  {
899  	skein_small_close(cc, ub, n, dst, 32);
900  	sph_skein256_init(cc);
901  }
902  #endif
903  void
904  sph_skein224_init(void *cc)
905  {
906  	skein_big_init(cc, IV224);
907  }
908  void
909  sph_skein224(void *cc, const void *data, size_t len)
910  {
911  	skein_big_core(cc, data, len);
912  }
913  void
914  sph_skein224_close(void *cc, void *dst)
915  {
916  	sph_skein224_addbits_and_close(cc, 0, 0, dst);
917  }
918  void
919  sph_skein224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
920  {
921  	skein_big_close(cc, ub, n, dst, 28);
922  }
923  void
924  sph_skein256_init(void *cc)
925  {
926  	skein_big_init(cc, IV256);
927  }
928  void
929  sph_skein256(void *cc, const void *data, size_t len)
930  {
931  	skein_big_core(cc, data, len);
932  }
933  void
934  sph_skein256_close(void *cc, void *dst)
935  {
936  	sph_skein256_addbits_and_close(cc, 0, 0, dst);
937  }
938  void
939  sph_skein256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
940  {
941  	skein_big_close(cc, ub, n, dst, 32);
942  }
943  void
944  sph_skein384_init(void *cc)
945  {
946  	skein_big_init(cc, IV384);
947  }
948  void
949  sph_skein384(void *cc, const void *data, size_t len)
950  {
951  	skein_big_core(cc, data, len);
952  }
953  void
954  sph_skein384_close(void *cc, void *dst)
955  {
956  	sph_skein384_addbits_and_close(cc, 0, 0, dst);
957  }
958  void
959  sph_skein384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
960  {
961  	skein_big_close(cc, ub, n, dst, 48);
962  }
963  void
964  sph_skein512_init(void *cc)
965  {
966  	skein_big_init(cc, IV512);
967  }
968  void
969  sph_skein512(void *cc, const void *data, size_t len)
970  {
971  	skein_big_core(cc, data, len);
972  }
973  void
974  sph_skein512_close(void *cc, void *dst)
975  {
976  	sph_skein512_addbits_and_close(cc, 0, 0, dst);
977  }
978  void
979  sph_skein512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
980  {
981  	skein_big_close(cc, ub, n, dst, 64);
982  }
983  #endif
984  #ifdef __cplusplus
985  }
986  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_soc_21.h</h3>
            <pre><code>1  #ifndef NRF_SOC_H__
2  #define NRF_SOC_H__
3  #include <stdint.h>
4  #include "nrf.h"
5  #include "nrf_svc.h"
6  #include "nrf_error.h"
7  #include "nrf_error_soc.h"
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
11  #define SOC_SVC_BASE               (0x20)                   &bsol;**< Base value for SVCs that are available when the SoftDevice is disabled. */
12  #define SOC_SVC_BASE_NOT_AVAILABLE (0x2C)                   &bsol;**< Base value for SVCs that are not available when the SoftDevice is disabled. */
13  #define NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US  (62)
14  #define NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US (200)
15  #define NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US           (17)
16  #define NRF_RADIO_MIN_EXTENSION_MARGIN_US                    (79)
17  #define SOC_ECB_KEY_LENGTH                (16)                       &bsol;**< ECB key length. */
18  #define SOC_ECB_CLEARTEXT_LENGTH          (16)                       &bsol;**< ECB cleartext length. */
19  #define SOC_ECB_CIPHERTEXT_LENGTH         (SOC_ECB_CLEARTEXT_LENGTH) &bsol;**< ECB ciphertext length. */
20  #define SD_EVT_IRQn                       (SWI2_IRQn)        &bsol;**< SoftDevice Event IRQ number. Used for both protocol events and SoC events. */
21  #define SD_EVT_IRQHandler                 (SWI2_IRQHandler)  &bsol;**< SoftDevice Event IRQ handler. Used for both protocol events and SoC events.
22                                                                         The default interrupt priority for this handler is set to 6 */
23  #define RADIO_NOTIFICATION_IRQn           (SWI1_IRQn)        &bsol;**< The radio notification IRQ number. */
24  #define RADIO_NOTIFICATION_IRQHandler     (SWI1_IRQHandler)  &bsol;**< The radio notification IRQ handler.
25                                                                         The default interrupt priority for this handler is set to 6 */
26  #define NRF_RADIO_LENGTH_MIN_US           (100)               &bsol;**< The shortest allowed radio timeslot, in microseconds. */
27  #define NRF_RADIO_LENGTH_MAX_US           (100000)            &bsol;**< The longest allowed radio timeslot, in microseconds. */
28  #define NRF_RADIO_DISTANCE_MAX_US         (128000000UL - 1UL) &bsol;**< The longest timeslot distance, in microseconds, allowed for the distance parameter (see @ref nrf_radio_request_normal_t) in the request. */
29  #define NRF_RADIO_EARLIEST_TIMEOUT_MAX_US (128000000UL - 1UL) &bsol;**< The longest timeout, in microseconds, allowed when requesting the earliest possible timeslot. */
30  #define NRF_RADIO_START_JITTER_US         (2)                 &bsol;**< The maximum jitter in @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START relative to the requested start time. */
31  #define NRF_SOC_SD_PPI_CHANNELS_SD_DISABLED_MSK ((uint32_t)(0))
32  #define NRF_SOC_SD_PPI_CHANNELS_SD_ENABLED_MSK  ((uint32_t)( \
33        (1U << 17) \
34      | (1U << 18) \
35      | (1U << 19) \
36      | (1U << 20) \
37      | (1U << 21) \
38      | (1U << 22) \
39      | (1U << 23) \
40      | (1U << 24) \
41      | (1U << 25) \
42      | (1U << 26) \
43      | (1U << 27) \
44      | (1U << 28) \
45      | (1U << 29) \
46      | (1U << 30) \
47      | (1U << 31) \
48    ))
49  #define NRF_SOC_APP_PPI_CHANNELS_SD_DISABLED_MSK (~NRF_SOC_SD_PPI_CHANNELS_SD_DISABLED_MSK)
50  #define NRF_SOC_APP_PPI_CHANNELS_SD_ENABLED_MSK  (~NRF_SOC_SD_PPI_CHANNELS_SD_ENABLED_MSK)
51  #define NRF_SOC_SD_PPI_GROUPS_SD_DISABLED_MSK    ((uint32_t)(0))
52  #define NRF_SOC_SD_PPI_GROUPS_SD_ENABLED_MSK     ((uint32_t)( \
53        (1U << 4) \
54      | (1U << 5) \
55    ))
56  #define NRF_SOC_APP_PPI_GROUPS_SD_DISABLED_MSK   (~NRF_SOC_SD_PPI_GROUPS_SD_DISABLED_MSK)
57  #define NRF_SOC_APP_PPI_GROUPS_SD_ENABLED_MSK    (~NRF_SOC_SD_PPI_GROUPS_SD_ENABLED_MSK)
58  enum NRF_SOC_SVCS
59  {
60    SD_PPI_CHANNEL_ENABLE_GET   = SOC_SVC_BASE,
61    SD_PPI_CHANNEL_ENABLE_SET   = SOC_SVC_BASE + 1,
62    SD_PPI_CHANNEL_ENABLE_CLR   = SOC_SVC_BASE + 2,
63    SD_PPI_CHANNEL_ASSIGN       = SOC_SVC_BASE + 3,
64    SD_PPI_GROUP_TASK_ENABLE    = SOC_SVC_BASE + 4,
65    SD_PPI_GROUP_TASK_DISABLE   = SOC_SVC_BASE + 5,
66    SD_PPI_GROUP_ASSIGN         = SOC_SVC_BASE + 6,
67    SD_PPI_GROUP_GET            = SOC_SVC_BASE + 7,
68    SD_FLASH_PAGE_ERASE         = SOC_SVC_BASE + 8,
69    SD_FLASH_WRITE              = SOC_SVC_BASE + 9,
70    SD_FLASH_PROTECT            = SOC_SVC_BASE + 10,
71    SD_PROTECTED_REGISTER_WRITE = SOC_SVC_BASE + 11,
72    SD_MUTEX_NEW                            = SOC_SVC_BASE_NOT_AVAILABLE,
73    SD_MUTEX_ACQUIRE                        = SOC_SVC_BASE_NOT_AVAILABLE + 1,
74    SD_MUTEX_RELEASE                        = SOC_SVC_BASE_NOT_AVAILABLE + 2,
75    SD_RAND_APPLICATION_POOL_CAPACITY_GET   = SOC_SVC_BASE_NOT_AVAILABLE + 3,
76    SD_RAND_APPLICATION_BYTES_AVAILABLE_GET = SOC_SVC_BASE_NOT_AVAILABLE + 4,
77    SD_RAND_APPLICATION_VECTOR_GET          = SOC_SVC_BASE_NOT_AVAILABLE + 5,
78    SD_POWER_MODE_SET                       = SOC_SVC_BASE_NOT_AVAILABLE + 6,
79    SD_POWER_SYSTEM_OFF                     = SOC_SVC_BASE_NOT_AVAILABLE + 7,
80    SD_POWER_RESET_REASON_GET               = SOC_SVC_BASE_NOT_AVAILABLE + 8,
81    SD_POWER_RESET_REASON_CLR               = SOC_SVC_BASE_NOT_AVAILABLE + 9,
82    SD_POWER_POF_ENABLE                     = SOC_SVC_BASE_NOT_AVAILABLE + 10,
83    SD_POWER_POF_THRESHOLD_SET              = SOC_SVC_BASE_NOT_AVAILABLE + 11,
84    SD_POWER_RAM_POWER_SET                  = SOC_SVC_BASE_NOT_AVAILABLE + 13,
85    SD_POWER_RAM_POWER_CLR                  = SOC_SVC_BASE_NOT_AVAILABLE + 14,
86    SD_POWER_RAM_POWER_GET                  = SOC_SVC_BASE_NOT_AVAILABLE + 15,
87    SD_POWER_GPREGRET_SET                   = SOC_SVC_BASE_NOT_AVAILABLE + 16,
88    SD_POWER_GPREGRET_CLR                   = SOC_SVC_BASE_NOT_AVAILABLE + 17,
89    SD_POWER_GPREGRET_GET                   = SOC_SVC_BASE_NOT_AVAILABLE + 18,
90    SD_POWER_DCDC_MODE_SET                  = SOC_SVC_BASE_NOT_AVAILABLE + 19,
91    SD_APP_EVT_WAIT                         = SOC_SVC_BASE_NOT_AVAILABLE + 21,
92    SD_CLOCK_HFCLK_REQUEST                  = SOC_SVC_BASE_NOT_AVAILABLE + 22,
93    SD_CLOCK_HFCLK_RELEASE                  = SOC_SVC_BASE_NOT_AVAILABLE + 23,
94    SD_CLOCK_HFCLK_IS_RUNNING               = SOC_SVC_BASE_NOT_AVAILABLE + 24,
95    SD_RADIO_NOTIFICATION_CFG_SET           = SOC_SVC_BASE_NOT_AVAILABLE + 25,
96    SD_ECB_BLOCK_ENCRYPT                    = SOC_SVC_BASE_NOT_AVAILABLE + 26,
97    SD_ECB_BLOCKS_ENCRYPT                   = SOC_SVC_BASE_NOT_AVAILABLE + 27,
98    SD_RADIO_SESSION_OPEN                   = SOC_SVC_BASE_NOT_AVAILABLE + 28,
99    SD_RADIO_SESSION_CLOSE                  = SOC_SVC_BASE_NOT_AVAILABLE + 29,
100    SD_RADIO_REQUEST                        = SOC_SVC_BASE_NOT_AVAILABLE + 30,
101    SD_EVT_GET                              = SOC_SVC_BASE_NOT_AVAILABLE + 31,
102    SD_TEMP_GET                             = SOC_SVC_BASE_NOT_AVAILABLE + 32,
103    SVC_SOC_LAST                            = SOC_SVC_BASE_NOT_AVAILABLE + 37
104  };
105  enum NRF_MUTEX_VALUES
106  {
107    NRF_MUTEX_FREE,
108    NRF_MUTEX_TAKEN
109  };
110  enum NRF_POWER_MODES
111  {
112    NRF_POWER_MODE_CONSTLAT,  &bsol;**< Constant latency mode. See power management in the reference manual. */
113    NRF_POWER_MODE_LOWPWR     &bsol;**< Low power mode. See power management in the reference manual. */
114  };
115  enum NRF_POWER_THRESHOLDS
116  {
117    NRF_POWER_THRESHOLD_V17 = 4UL, &bsol;**< 1.7 Volts power failure threshold. */
118    NRF_POWER_THRESHOLD_V18,       &bsol;**< 1.8 Volts power failure threshold. */
119    NRF_POWER_THRESHOLD_V19,       &bsol;**< 1.9 Volts power failure threshold. */
120    NRF_POWER_THRESHOLD_V20,       &bsol;**< 2.0 Volts power failure threshold. */
121    NRF_POWER_THRESHOLD_V21,       &bsol;**< 2.1 Volts power failure threshold. */
122    NRF_POWER_THRESHOLD_V22,       &bsol;**< 2.2 Volts power failure threshold. */
123    NRF_POWER_THRESHOLD_V23,       &bsol;**< 2.3 Volts power failure threshold. */
124    NRF_POWER_THRESHOLD_V24,       &bsol;**< 2.4 Volts power failure threshold. */
125    NRF_POWER_THRESHOLD_V25,       &bsol;**< 2.5 Volts power failure threshold. */
126    NRF_POWER_THRESHOLD_V26,       &bsol;**< 2.6 Volts power failure threshold. */
127    NRF_POWER_THRESHOLD_V27,       &bsol;**< 2.7 Volts power failure threshold. */
128    NRF_POWER_THRESHOLD_V28        &bsol;**< 2.8 Volts power failure threshold. */
129  };
130  enum NRF_POWER_DCDC_MODES
131  {
132    NRF_POWER_DCDC_DISABLE,          &bsol;**< The DCDC is disabled. */
133    NRF_POWER_DCDC_ENABLE            &bsol;**< The DCDC is enabled.  */
134  };
135  enum NRF_RADIO_NOTIFICATION_DISTANCES
136  {
137    NRF_RADIO_NOTIFICATION_DISTANCE_NONE = 0, &bsol;**< The event does not have a notification. */
138    NRF_RADIO_NOTIFICATION_DISTANCE_800US,    &bsol;**< The distance from the active notification to start of radio activity. */
139    NRF_RADIO_NOTIFICATION_DISTANCE_1740US,   &bsol;**< The distance from the active notification to start of radio activity. */
140    NRF_RADIO_NOTIFICATION_DISTANCE_2680US,   &bsol;**< The distance from the active notification to start of radio activity. */
141    NRF_RADIO_NOTIFICATION_DISTANCE_3620US,   &bsol;**< The distance from the active notification to start of radio activity. */
142    NRF_RADIO_NOTIFICATION_DISTANCE_4560US,   &bsol;**< The distance from the active notification to start of radio activity. */
143    NRF_RADIO_NOTIFICATION_DISTANCE_5500US    &bsol;**< The distance from the active notification to start of radio activity. */
144  };
145  enum NRF_RADIO_NOTIFICATION_TYPES
146  {
147    NRF_RADIO_NOTIFICATION_TYPE_NONE = 0,        &bsol;**< The event does not have a radio notification signal. */
148    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE,   &bsol;**< Using interrupt for notification when the radio will be enabled. */
149    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE, &bsol;**< Using interrupt for notification when the radio has been disabled. */
150    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH,     &bsol;**< Using interrupt for notification both when the radio will be enabled and disabled. */
151  };
152  enum NRF_RADIO_CALLBACK_SIGNAL_TYPE
153  {
154    NRF_RADIO_CALLBACK_SIGNAL_TYPE_START,             &bsol;**< This signal indicates the start of the radio timeslot. */
155    NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0,            &bsol;**< This signal indicates the NRF_TIMER0 interrupt. */
156    NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO,             &bsol;**< This signal indicates the NRF_RADIO interrupt. */
157    NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_FAILED,     &bsol;**< This signal indicates extend action failed. */
158    NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_SUCCEEDED   &bsol;**< This signal indicates extend action succeeded. */
159  };
160  enum NRF_RADIO_SIGNAL_CALLBACK_ACTION
161  {
162    NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE,            &bsol;**< Return without action. */
163    NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND,          &bsol;**< Request an extension of the current
164                                                           timeslot. Maximum execution time for this action:
165                                                           @ref NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US.
166                                                           This action must be started at least
167                                                           @ref NRF_RADIO_MIN_EXTENSION_MARGIN_US before
168                                                           the end of the timeslot. */
169    NRF_RADIO_SIGNAL_CALLBACK_ACTION_END,             &bsol;**< End the current radio timeslot. */
170    NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END  &bsol;**< Request a new radio timeslot and end the current timeslot. */
171  };
172  enum NRF_RADIO_HFCLK_CFG
173  {
174    NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED, &bsol;**< The SoftDevice will guarantee that the high frequency clock source is the
175                                             external crystal for the whole duration of the timeslot. This should be the
176                                             preferred option for events that use the radio or require high timing accuracy.
177                                             @note The SoftDevice will automatically turn on and off the external crystal,
178                                             at the beginning and end of the timeslot, respectively. The crystal may also
179                                             intentionally be left running after the timeslot, in cases where it is needed
180                                             by the SoftDevice shortly after the end of the timeslot. */
181    NRF_RADIO_HFCLK_CFG_NO_GUARANTEE    &bsol;**< This configuration allows for earlier and tighter scheduling of timeslots.
182                                             The RC oscillator may be the clock source in part or for the whole duration of the timeslot.
183                                             The RC oscillator's accuracy must therefore be taken into consideration.
184                                             @note If the application will use the radio peripheral in timeslots with this configuration,
185                                             it must make sure that the crystal is running and stable before starting the radio. */
186  };
187  enum NRF_RADIO_PRIORITY
188  {
189    NRF_RADIO_PRIORITY_HIGH,                          &bsol;**< High (equal priority as the normal connection priority of the SoftDevice stack(s)). */
190    NRF_RADIO_PRIORITY_NORMAL,                        &bsol;**< Normal (equal priority as the priority of secondary activities of the SoftDevice stack(s)). */
<span onclick='openModal()' class='match'>191  };
192  enum NRF_RADIO_REQUEST_TYPE
193  {
194    NRF_RADIO_REQ_TYPE_EARLIEST,                      &bsol;**< Request radio timeslot as early as possible. This should always be used for the first request in a session. */
</span>195    NRF_RADIO_REQ_TYPE_NORMAL                         &bsol;**< Normal radio timeslot request. */
196  };
197  enum NRF_SOC_EVTS
198  {
199    NRF_EVT_HFCLKSTARTED,                         &bsol;**< Event indicating that the HFCLK has started. */
200    NRF_EVT_POWER_FAILURE_WARNING,                &bsol;**< Event indicating that a power failure warning has occurred. */
201    NRF_EVT_FLASH_OPERATION_SUCCESS,              &bsol;**< Event indicating that the ongoing flash operation has completed successfully. */
202    NRF_EVT_FLASH_OPERATION_ERROR,                &bsol;**< Event indicating that the ongoing flash operation has timed out with an error. */
203    NRF_EVT_RADIO_BLOCKED,                        &bsol;**< Event indicating that a radio timeslot was blocked. */
204    NRF_EVT_RADIO_CANCELED,                       &bsol;**< Event indicating that a radio timeslot was canceled by SoftDevice. */
205    NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN, &bsol;**< Event indicating that a radio timeslot signal callback handler return was invalid. */
206    NRF_EVT_RADIO_SESSION_IDLE,                   &bsol;**< Event indicating that a radio timeslot session is idle. */
207    NRF_EVT_RADIO_SESSION_CLOSED,                 &bsol;**< Event indicating that a radio timeslot session is closed. */
208    NRF_EVT_NUMBER_OF_EVTS
209  };
210  typedef volatile uint8_t nrf_mutex_t;
211  typedef struct
212  {
213    uint8_t       hfclk;                              &bsol;**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
214    uint8_t       priority;                           &bsol;**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
215    uint32_t      length_us;                          &bsol;**< The radio timeslot length (in the range 100 to 100,000] microseconds). */
216    uint32_t      timeout_us;                         &bsol;**< Longest acceptable delay until the start of the requested timeslot (up to @ref NRF_RADIO_EARLIEST_TIMEOUT_MAX_US microseconds). */
217  } nrf_radio_request_earliest_t;
218  typedef struct
219  {
220    uint8_t       hfclk;                              &bsol;**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
221    uint8_t       priority;                           &bsol;**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
222    uint32_t      distance_us;                        &bsol;**< Distance from the start of the previous radio timeslot (up to @ref NRF_RADIO_DISTANCE_MAX_US microseconds). */
223    uint32_t      length_us;                          &bsol;**< The radio timeslot length (in the range [100..100,000] microseconds). */
224  } nrf_radio_request_normal_t;
225  typedef struct
226  {
227    uint8_t                         request_type;     &bsol;**< Type of request, see @ref NRF_RADIO_REQUEST_TYPE. */
228    union
229    {
230      nrf_radio_request_earliest_t  earliest;         &bsol;**< Parameters for requesting a radio timeslot as early as possible. */
231      nrf_radio_request_normal_t    normal;           &bsol;**< Parameters for requesting a normal radio timeslot. */
232    } params;                                         &bsol;**< Parameter union. */
233  } nrf_radio_request_t;
234  typedef struct
235  {
236    uint8_t               callback_action;            &bsol;**< The action requested by the application when returning from the signal callback, see @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION. */
237    union
238    {
239      struct
240      {
241        nrf_radio_request_t * p_next;                 &bsol;**< The request parameters for the next radio timeslot. */
242      } request;                                      &bsol;**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END. */
243      struct
244      {
245        uint32_t              length_us;              &bsol;**< Requested extension of the radio timeslot duration (microseconds) (for minimum time see @ref NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US). */
246      } extend;                                       &bsol;**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND. */
247    } params;                                         &bsol;**< Parameter union. */
248  } nrf_radio_signal_callback_return_param_t;
249  typedef nrf_radio_signal_callback_return_param_t * (*nrf_radio_signal_callback_t) (uint8_t signal_type);
250  typedef uint8_t soc_ecb_key_t[SOC_ECB_KEY_LENGTH];                &bsol;**< Encryption key type. */
251  typedef uint8_t soc_ecb_cleartext_t[SOC_ECB_CLEARTEXT_LENGTH];    &bsol;**< Cleartext data type. */
252  typedef uint8_t soc_ecb_ciphertext_t[SOC_ECB_CIPHERTEXT_LENGTH];  &bsol;**< Ciphertext data type. */
253  typedef struct
254  {
255    soc_ecb_key_t        key;            &bsol;**< Encryption key. */
256    soc_ecb_cleartext_t  cleartext;      &bsol;**< Cleartext data. */
257    soc_ecb_ciphertext_t ciphertext;     &bsol;**< Ciphertext data. */
258  } nrf_ecb_hal_data_t;
259  typedef struct
260  {
261    soc_ecb_key_t const *       p_key;           &bsol;**< Pointer to the Encryption key. */
262    soc_ecb_cleartext_t const * p_cleartext;     &bsol;**< Pointer to the Cleartext data. */
263    soc_ecb_ciphertext_t *      p_ciphertext;    &bsol;**< Pointer to the Ciphertext data. */
264  } nrf_ecb_hal_data_block_t;
265  SVCALL(SD_MUTEX_NEW, uint32_t, sd_mutex_new(nrf_mutex_t * p_mutex));
266  SVCALL(SD_MUTEX_ACQUIRE, uint32_t, sd_mutex_acquire(nrf_mutex_t * p_mutex));
267  SVCALL(SD_MUTEX_RELEASE, uint32_t, sd_mutex_release(nrf_mutex_t * p_mutex));
268  SVCALL(SD_RAND_APPLICATION_POOL_CAPACITY_GET, uint32_t, sd_rand_application_pool_capacity_get(uint8_t * p_pool_capacity));
269  SVCALL(SD_RAND_APPLICATION_BYTES_AVAILABLE_GET, uint32_t, sd_rand_application_bytes_available_get(uint8_t * p_bytes_available));
270  SVCALL(SD_RAND_APPLICATION_VECTOR_GET, uint32_t, sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length));
271  SVCALL(SD_POWER_RESET_REASON_GET, uint32_t, sd_power_reset_reason_get(uint32_t * p_reset_reason));
272  SVCALL(SD_POWER_RESET_REASON_CLR, uint32_t, sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk));
273  SVCALL(SD_POWER_MODE_SET, uint32_t, sd_power_mode_set(uint8_t power_mode));
274  SVCALL(SD_POWER_SYSTEM_OFF, uint32_t, sd_power_system_off(void));
275  SVCALL(SD_POWER_POF_ENABLE, uint32_t, sd_power_pof_enable(uint8_t pof_enable));
276  SVCALL(SD_POWER_POF_THRESHOLD_SET, uint32_t, sd_power_pof_threshold_set(uint8_t threshold));
277  SVCALL(SD_POWER_RAM_POWER_SET, uint32_t, sd_power_ram_power_set(uint8_t index, uint32_t ram_powerset));
278  SVCALL(SD_POWER_RAM_POWER_CLR, uint32_t, sd_power_ram_power_clr(uint8_t index, uint32_t ram_powerclr));
279  SVCALL(SD_POWER_RAM_POWER_GET, uint32_t, sd_power_ram_power_get(uint8_t index, uint32_t * p_ram_power));
280  SVCALL(SD_POWER_GPREGRET_SET, uint32_t, sd_power_gpregret_set(uint32_t gpregret_id, uint32_t gpregret_msk));
281  SVCALL(SD_POWER_GPREGRET_CLR, uint32_t, sd_power_gpregret_clr(uint32_t gpregret_id, uint32_t gpregret_msk));
282  SVCALL(SD_POWER_GPREGRET_GET, uint32_t, sd_power_gpregret_get(uint32_t gpregret_id, uint32_t *p_gpregret));
283  SVCALL(SD_POWER_DCDC_MODE_SET, uint32_t, sd_power_dcdc_mode_set(uint8_t dcdc_mode));
284  SVCALL(SD_CLOCK_HFCLK_REQUEST, uint32_t, sd_clock_hfclk_request(void));
285  SVCALL(SD_CLOCK_HFCLK_RELEASE, uint32_t, sd_clock_hfclk_release(void));
286  SVCALL(SD_CLOCK_HFCLK_IS_RUNNING, uint32_t, sd_clock_hfclk_is_running(uint32_t * p_is_running));
287  SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
288  SVCALL(SD_PPI_CHANNEL_ENABLE_GET, uint32_t, sd_ppi_channel_enable_get(uint32_t * p_channel_enable));
289  SVCALL(SD_PPI_CHANNEL_ENABLE_SET, uint32_t, sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk));
290  SVCALL(SD_PPI_CHANNEL_ENABLE_CLR, uint32_t, sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk));
291  SVCALL(SD_PPI_CHANNEL_ASSIGN, uint32_t, sd_ppi_channel_assign(uint8_t channel_num, const volatile void * evt_endpoint, const volatile void * task_endpoint));
292  SVCALL(SD_PPI_GROUP_TASK_ENABLE, uint32_t, sd_ppi_group_task_enable(uint8_t group_num));
293  SVCALL(SD_PPI_GROUP_TASK_DISABLE, uint32_t, sd_ppi_group_task_disable(uint8_t group_num));
294  SVCALL(SD_PPI_GROUP_ASSIGN, uint32_t, sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk));
295  SVCALL(SD_PPI_GROUP_GET, uint32_t, sd_ppi_group_get(uint8_t group_num, uint32_t * p_channel_msk));
296  SVCALL(SD_RADIO_NOTIFICATION_CFG_SET, uint32_t, sd_radio_notification_cfg_set(uint8_t type, uint8_t distance));
297  SVCALL(SD_ECB_BLOCK_ENCRYPT, uint32_t, sd_ecb_block_encrypt(nrf_ecb_hal_data_t * p_ecb_data));
298  SVCALL(SD_ECB_BLOCKS_ENCRYPT, uint32_t, sd_ecb_blocks_encrypt(uint8_t block_count, nrf_ecb_hal_data_block_t * p_data_blocks));
299  SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
300  SVCALL(SD_TEMP_GET, uint32_t, sd_temp_get(int32_t * p_temp));
301  SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * p_dst, uint32_t const * p_src, uint32_t size));
302  SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
303  SVCALL(SD_FLASH_PROTECT, uint32_t, sd_flash_protect(uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3));
304   SVCALL(SD_RADIO_SESSION_OPEN, uint32_t, sd_radio_session_open(nrf_radio_signal_callback_t p_radio_signal_callback));
305   SVCALL(SD_RADIO_SESSION_CLOSE, uint32_t, sd_radio_session_close(void));
306   SVCALL(SD_RADIO_REQUEST, uint32_t, sd_radio_request(nrf_radio_request_t const * p_request));
307  SVCALL(SD_PROTECTED_REGISTER_WRITE, uint32_t, sd_protected_register_write(volatile uint32_t * p_register, uint32_t value));
308  #ifdef __cplusplus
309  }
310  #endif
311  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_skein.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_soc_21.h</div>
                </div>
                <div class="column column_space"><pre><code>700  }
701  #endif
702  static void
703  skein_big_core(sph_skein_big_context *sc, const void *data, size_t len)
704  {
705  	unsigned char *buf;
706  	size_t ptr;
707  	unsigned first;
708  	DECL_STATE_BIG
</pre></code></div>
                <div class="column column_space"><pre><code>191  };
192  enum NRF_RADIO_REQUEST_TYPE
193  {
194    NRF_RADIO_REQ_TYPE_EARLIEST,                      &bsol;**< Request radio timeslot as early as possible. This should always be used for the first request in a session. */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    