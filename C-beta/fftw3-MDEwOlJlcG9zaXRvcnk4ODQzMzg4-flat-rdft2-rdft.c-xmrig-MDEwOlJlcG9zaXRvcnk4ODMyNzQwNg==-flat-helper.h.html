
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.8923766816143495%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft2 super;
7       plan *cld, *cldrest;
8       INT n, vl, nbuf, bufdist;
9       INT cs, ivs, ovs;
10  } P;
11  static void hc2c(INT n, R *r, R *rio, R *iio, INT os)
12  {
13       INT i;
14       rio[0] = r[0];
15       iio[0] = 0;
16       for (i = 1; i + i < n; ++i) {
17  	  rio[i * os] = r[i];
18  	  iio[i * os] = r[n - i];
19       }
20       if (i + i == n) {	&bsol;* store the Nyquist frequency */
21  	  rio[i * os] = r[i];
22  	  iio[i * os] = K(0.0);
23       }
24  }
<span onclick='openModal()' class='match'>25  static void c2hc(INT n, R *rio, R *iio, INT is, R *r)
26  {
27       INT i;
28       r[0] = rio[0];
29       for (i = 1; i + i < n; ++i) {
</span>30  	  r[i] = rio[i * is];
31  	  r[n - i] = iio[i * is];
32       }
33       if (i + i == n)		&bsol;* store the Nyquist frequency */
34  	  r[i] = rio[i * is];
35  }
36  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
37  {
38       const P *ego = (const P *) ego_;
39       plan_rdft *cld = (plan_rdft *) ego->cld;
40       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
41       INT n = ego->n;
42       INT ivs = ego->ivs, ovs = ego->ovs, os = ego->cs;
43       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
44       plan_rdft2 *cldrest;
45       for (i = nbuf; i <= vl; i += nbuf) {
46            cld->apply((plan *) cld, r0, bufs);
47  	  r0 += ivs * nbuf; r1 += ivs * nbuf;
48  	  for (j = 0; j < nbuf; ++j, cr += ovs, ci += ovs)
49  	       hc2c(n, bufs + j*bufdist, cr, ci, os);
50       }
51       X(ifree)(bufs);
52       cldrest = (plan_rdft2 *) ego->cldrest;
53       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
54  }
55  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
56  {
57       const P *ego = (const P *) ego_;
58       plan_rdft *cld = (plan_rdft *) ego->cld;
59       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
60       INT n = ego->n;
61       INT ivs = ego->ivs, ovs = ego->ovs, is = ego->cs;
62       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
63       plan_rdft2 *cldrest;
64       for (i = nbuf; i <= vl; i += nbuf) {
65  	  for (j = 0; j < nbuf; ++j, cr += ivs, ci += ivs)
66  	       c2hc(n, cr, ci, is, bufs + j*bufdist);
67            cld->apply((plan *) cld, bufs, r0);
68  	  r0 += ovs * nbuf; r1 += ovs * nbuf;
69       }
70       X(ifree)(bufs);
71       cldrest = (plan_rdft2 *) ego->cldrest;
72       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
73  }
74  static void awake(plan *ego_, enum wakefulness wakefulness)
75  {
76       P *ego = (P *) ego_;
77       X(plan_awake)(ego->cld, wakefulness);
78       X(plan_awake)(ego->cldrest, wakefulness);
79  }
80  static void destroy(plan *ego_)
81  {
82       P *ego = (P *) ego_;
83       X(plan_destroy_internal)(ego->cldrest);
84       X(plan_destroy_internal)(ego->cld);
85  }
86  static void print(const plan *ego_, printer *p)
87  {
88       const P *ego = (const P *) ego_;
89       p->print(p, "(rdft2-rdft-%s-%D%v/%D-%D%(%p%)%(%p%))",
90  	      ego->super.apply == apply_r2hc ? "r2hc" : "hc2r",
91                ego->n, ego->nbuf,
92                ego->vl, ego->bufdist % ego->n,
93                ego->cld, ego->cldrest);
94  }
95  static INT min_nbuf(const problem_rdft2 *p, INT n, INT vl)
96  {
97       INT is, os, ivs, ovs;
98       if (p->r0 != p->cr)
99  	  return 1;
100       if (X(rdft2_inplace_strides(p, RNK_MINFTY)))
101  	  return 1;
102       A(p->vecsz->rnk == 1); &bsol;*  rank 0 and MINFTY are inplace */
103       X(rdft2_strides)(p->kind, p->sz->dims, &is, &os);
104       X(rdft2_strides)(p->kind, p->vecsz->dims, &ivs, &ovs);
105       if (n * X(iabs)(is) <= X(iabs)(ivs)
106  	 && (n/2 + 1) * X(iabs)(os) <= X(iabs)(ovs)
107  	 && ( ((p->cr - p->ci) <= X(iabs)(os)) || 
108  	      ((p->ci - p->cr) <= X(iabs)(os)) )
109  	 && ivs > 0 && ovs > 0) {
110  	  INT vsmin = X(imin)(ivs, ovs);
111  	  INT vsmax = X(imax)(ivs, ovs);
112  	  return(((vsmax - vsmin) * vl + vsmin - 1) / vsmin);
113       }
114       return vl; &bsol;* punt: just buffer the whole vector */
115  }
116  static int applicable0(const problem *p_, const S *ego, const planner *plnr)
117  {
118       const problem_rdft2 *p = (const problem_rdft2 *) p_;
119       UNUSED(ego);
120       return(1
121  	    && p->vecsz->rnk <= 1
122  	    && p->sz->rnk == 1
123  	    && (p->kind == R2HC || p->kind == HC2R)
124  	    && (2 * (p->r1 - p->r0) ==
125  		(((p->kind == R2HC) ? p->sz->dims[0].is : p->sz->dims[0].os)))
126  	    && !(X(toobig)(p->sz->dims[0].n) && CONSERVE_MEMORYP(plnr))
127  	  );
128  }
129  static int applicable(const problem *p_, const S *ego, const planner *plnr)
130  {
131       const problem_rdft2 *p;
132       if (NO_BUFFERINGP(plnr)) return 0;
133       if (!applicable0(p_, ego, plnr)) return 0;
134       p = (const problem_rdft2 *) p_;
135       if (NO_UGLYP(plnr)) {
136  	  if (p->r0 != p->cr) return 0;
137  	  if (X(toobig)(p->sz->dims[0].n)) return 0;
138       }
139       return 1;
140  }
141  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
142  {
143       const S *ego = (const S *) ego_;
144       P *pln;
145       plan *cld = (plan *) 0;
146       plan *cldrest = (plan *) 0;
147       const problem_rdft2 *p = (const problem_rdft2 *) p_;
148       R *bufs = (R *) 0;
149       INT nbuf = 0, bufdist, n, vl;
150       INT ivs, ovs, rs, id, od;
151       static const plan_adt padt = {
152  	  X(rdft2_solve), awake, print, destroy
153       };
154       if (!applicable(p_, ego, plnr))
155            goto nada;
156       n = p->sz->dims[0].n;
157       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
158       nbuf = X(imax)(X(nbuf)(n, vl, 0), min_nbuf(p, n, vl));
159       bufdist = X(bufdist)(n, vl);
160       A(nbuf > 0);
161       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
162       id = ivs * (nbuf * (vl / nbuf));
163       od = ovs * (nbuf * (vl / nbuf));
164       if (p->kind == R2HC) {
165  	  cld = X(mkplan_f_d)(
166  	       plnr,
167  	       X(mkproblem_rdft_d)(
168  		    X(mktensor_1d)(n, p->sz->dims[0].is/2, 1),
169  		    X(mktensor_1d)(nbuf, ivs, bufdist),
170  		    TAINT(p->r0, ivs * nbuf), bufs, &p->kind),
171  	       0, 0, (p->r0 == p->cr) ? NO_DESTROY_INPUT : 0);
172  	  if (!cld) goto nada;
173  	  X(ifree)(bufs); bufs = 0;
174  	  cldrest = X(mkplan_d)(plnr, 
175  				X(mkproblem_rdft2_d)(
176  				     X(tensor_copy)(p->sz),
177  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
178  				     p->r0 + id, p->r1 + id, 
179  				     p->cr + od, p->ci + od,
180  				     p->kind));
181  	  if (!cldrest) goto nada;
182  	  pln = MKPLAN_RDFT2(P, &padt, apply_r2hc);
183       } else {
184  	  A(p->kind == HC2R);
185  	  cld = X(mkplan_f_d)(
186  	       plnr,
187  	       X(mkproblem_rdft_d)(
188  		    X(mktensor_1d)(n, 1, p->sz->dims[0].os/2),
189  		    X(mktensor_1d)(nbuf, bufdist, ovs),
190  		    bufs, TAINT(p->r0, ovs * nbuf), &p->kind),
191  	       0, 0, NO_DESTROY_INPUT); &bsol;* always ok to destroy bufs */
192  	  if (!cld) goto nada;
193  	  X(ifree)(bufs); bufs = 0;
194  	  cldrest = X(mkplan_d)(plnr, 
195  				X(mkproblem_rdft2_d)(
196  				     X(tensor_copy)(p->sz),
197  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
198  				     p->r0 + od, p->r1 + od, 
199  				     p->cr + id, p->ci + id,
200  				     p->kind));
201  	  if (!cldrest) goto nada;
202  	  pln = MKPLAN_RDFT2(P, &padt, apply_hc2r);
203       }
204       pln->cld = cld;
205       pln->cldrest = cldrest;
206       pln->n = n;
207       pln->vl = vl;
208       pln->ivs = ivs;
209       pln->ovs = ovs;
210       X(rdft2_strides)(p->kind, &p->sz->dims[0], &rs, &pln->cs);
211       pln->nbuf = nbuf;
212       pln->bufdist = bufdist;
213       X(ops_madd)(vl / nbuf, &cld->ops, &cldrest->ops,
214  		 &pln->super.super.ops);
215       pln->super.super.ops.other += (p->kind == R2HC ? (n + 2) : n) * vl;
216       return &(pln->super.super);
217   nada:
218       X(ifree0)(bufs);
219       X(plan_destroy_internal)(cldrest);
220       X(plan_destroy_internal)(cld);
221       return (plan *) 0;
222  }
223  static solver *mksolver(void)
224  {
225       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
226       S *slv = MKSOLVER(S, &sadt);
227       return &(slv->super);
228  }
229  void X(rdft2_rdft_register)(planner *p)
230  {
231       REGISTER_SOLVER(p, mksolver());
232  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-helper.h</h3>
            <pre><code>1  #ifndef HWLOC_HELPER_H
2  #define HWLOC_HELPER_H
3  #ifndef HWLOC_H
4  #error Please include the main hwloc.h instead
5  #endif
6  #include <stdlib.h>
7  #include <errno.h>
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
11  static __hwloc_inline hwloc_obj_t
12  hwloc_get_first_largest_obj_inside_cpuset(hwloc_topology_t topology, hwloc_const_cpuset_t set)
13  {
14    hwloc_obj_t obj = hwloc_get_root_obj(topology);
15    if (!hwloc_bitmap_intersects(obj->cpuset, set))
16      return NULL;
17    while (!hwloc_bitmap_isincluded(obj->cpuset, set)) {
18      hwloc_obj_t child = obj->first_child;
19      while (child) {
20        if (hwloc_bitmap_intersects(child->cpuset, set))
21  	break;
22        child = child->next_sibling;
23      }
24      if (!child)
25        return obj;
26      obj = child;
27    }
28    return obj;
29  }
30  HWLOC_DECLSPEC int hwloc_get_largest_objs_inside_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set,
31  						 hwloc_obj_t * __hwloc_restrict objs, int max);
32  static __hwloc_inline hwloc_obj_t
33  hwloc_get_next_obj_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
34  					   int depth, hwloc_obj_t prev)
35  {
36    hwloc_obj_t next = hwloc_get_next_obj_by_depth(topology, depth, prev);
37    if (!next)
38      return NULL;
39    while (next && (hwloc_bitmap_iszero(next->cpuset) || !hwloc_bitmap_isincluded(next->cpuset, set)))
40      next = next->next_cousin;
41    return next;
42  }
43  static __hwloc_inline hwloc_obj_t
44  hwloc_get_next_obj_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
45  					  hwloc_obj_type_t type, hwloc_obj_t prev)
46  {
47    int depth = hwloc_get_type_depth(topology, type);
48    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
49      return NULL;
50    return hwloc_get_next_obj_inside_cpuset_by_depth(topology, set, depth, prev);
51  }
52  static __hwloc_inline hwloc_obj_t
53  hwloc_get_obj_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
54  				      int depth, unsigned idx) __hwloc_attribute_pure;
55  static __hwloc_inline hwloc_obj_t
56  hwloc_get_obj_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
57  				      int depth, unsigned idx)
58  {
59    hwloc_obj_t obj = hwloc_get_obj_by_depth (topology, depth, 0);
60    unsigned count = 0;
61    if (!obj)
62      return NULL;
63    while (obj) {
64      if (!hwloc_bitmap_iszero(obj->cpuset) && hwloc_bitmap_isincluded(obj->cpuset, set)) {
65        if (count == idx)
66  	return obj;
67        count++;
68      }
69      obj = obj->next_cousin;
70    }
71    return NULL;
72  }
73  static __hwloc_inline hwloc_obj_t
74  hwloc_get_obj_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
75  				     hwloc_obj_type_t type, unsigned idx) __hwloc_attribute_pure;
76  static __hwloc_inline hwloc_obj_t
77  hwloc_get_obj_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
78  				     hwloc_obj_type_t type, unsigned idx)
79  {
80    int depth = hwloc_get_type_depth(topology, type);
81    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
82      return NULL;
83    return hwloc_get_obj_inside_cpuset_by_depth(topology, set, depth, idx);
84  }
85  static __hwloc_inline unsigned
86  hwloc_get_nbobjs_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
87  					 int depth) __hwloc_attribute_pure;
88  static __hwloc_inline unsigned
89  hwloc_get_nbobjs_inside_cpuset_by_depth (hwloc_topology_t topology, hwloc_const_cpuset_t set,
90  					 int depth)
91  {
92    hwloc_obj_t obj = hwloc_get_obj_by_depth (topology, depth, 0);
93    unsigned count = 0;
94    if (!obj)
95      return 0;
96    while (obj) {
97      if (!hwloc_bitmap_iszero(obj->cpuset) && hwloc_bitmap_isincluded(obj->cpuset, set))
98        count++;
99      obj = obj->next_cousin;
100    }
101    return count;
102  }
103  static __hwloc_inline int
104  hwloc_get_nbobjs_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
105  					hwloc_obj_type_t type) __hwloc_attribute_pure;
106  static __hwloc_inline int
107  hwloc_get_nbobjs_inside_cpuset_by_type (hwloc_topology_t topology, hwloc_const_cpuset_t set,
108  					hwloc_obj_type_t type)
109  {
110    int depth = hwloc_get_type_depth(topology, type);
111    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN)
112      return 0;
113    if (depth == HWLOC_TYPE_DEPTH_MULTIPLE)
114      return -1; &bsol;* FIXME: agregate nbobjs from different levels? */
115    return (int) hwloc_get_nbobjs_inside_cpuset_by_depth(topology, set, depth);
116  }
117  static __hwloc_inline int
118  hwloc_get_obj_index_inside_cpuset (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_cpuset_t set,
119  				   hwloc_obj_t obj) __hwloc_attribute_pure;
120  static __hwloc_inline int
121  hwloc_get_obj_index_inside_cpuset (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_cpuset_t set,
122  				   hwloc_obj_t obj)
123  {
124    int idx = 0;
125    if (!hwloc_bitmap_isincluded(obj->cpuset, set))
126      return -1;
127    while ((obj = obj->prev_cousin) != NULL)
128      if (!hwloc_bitmap_iszero(obj->cpuset) && hwloc_bitmap_isincluded(obj->cpuset, set))
129        idx++;
130    return idx;
131  }
132  static __hwloc_inline hwloc_obj_t
133  hwloc_get_child_covering_cpuset (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_cpuset_t set,
134  				hwloc_obj_t parent) __hwloc_attribute_pure;
135  static __hwloc_inline hwloc_obj_t
136  hwloc_get_child_covering_cpuset (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_cpuset_t set,
137  				hwloc_obj_t parent)
138  {
139    hwloc_obj_t child;
140    if (hwloc_bitmap_iszero(set))
141      return NULL;
142    child = parent->first_child;
143    while (child) {
144      if (child->cpuset && hwloc_bitmap_isincluded(set, child->cpuset))
145        return child;
146      child = child->next_sibling;
147    }
148    return NULL;
149  }
150  static __hwloc_inline hwloc_obj_t
151  hwloc_get_obj_covering_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set) __hwloc_attribute_pure;
152  static __hwloc_inline hwloc_obj_t
153  hwloc_get_obj_covering_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set)
154  {
155    struct hwloc_obj *current = hwloc_get_root_obj(topology);
156    if (hwloc_bitmap_iszero(set) || !hwloc_bitmap_isincluded(set, current->cpuset))
157      return NULL;
158    while (1) {
159      hwloc_obj_t child = hwloc_get_child_covering_cpuset(topology, set, current);
160      if (!child)
161        return current;
162      current = child;
163    }
164  }
165  static __hwloc_inline hwloc_obj_t
166  hwloc_get_next_obj_covering_cpuset_by_depth(hwloc_topology_t topology, hwloc_const_cpuset_t set,
167  					    int depth, hwloc_obj_t prev)
168  {
169    hwloc_obj_t next = hwloc_get_next_obj_by_depth(topology, depth, prev);
170    if (!next)
171      return NULL;
172    while (next && !hwloc_bitmap_intersects(set, next->cpuset))
173      next = next->next_cousin;
174    return next;
175  }
176  static __hwloc_inline hwloc_obj_t
177  hwloc_get_next_obj_covering_cpuset_by_type(hwloc_topology_t topology, hwloc_const_cpuset_t set,
178  					   hwloc_obj_type_t type, hwloc_obj_t prev)
179  {
180    int depth = hwloc_get_type_depth(topology, type);
181    if (depth == HWLOC_TYPE_DEPTH_UNKNOWN || depth == HWLOC_TYPE_DEPTH_MULTIPLE)
182      return NULL;
183    return hwloc_get_next_obj_covering_cpuset_by_depth(topology, set, depth, prev);
184  }
185  static __hwloc_inline hwloc_obj_t
186  hwloc_get_ancestor_obj_by_depth (hwloc_topology_t topology __hwloc_attribute_unused, int depth, hwloc_obj_t obj) __hwloc_attribute_pure;
187  static __hwloc_inline hwloc_obj_t
188  hwloc_get_ancestor_obj_by_depth (hwloc_topology_t topology __hwloc_attribute_unused, int depth, hwloc_obj_t obj)
189  {
190    hwloc_obj_t ancestor = obj;
191    if (obj->depth < depth)
192      return NULL;
193    while (ancestor && ancestor->depth > depth)
194      ancestor = ancestor->parent;
195    return ancestor;
196  }
197  static __hwloc_inline hwloc_obj_t
198  hwloc_get_ancestor_obj_by_type (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_type_t type, hwloc_obj_t obj) __hwloc_attribute_pure;
199  static __hwloc_inline hwloc_obj_t
200  hwloc_get_ancestor_obj_by_type (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_type_t type, hwloc_obj_t obj)
201  {
202    hwloc_obj_t ancestor = obj->parent;
203    while (ancestor && ancestor->type != type)
204      ancestor = ancestor->parent;
205    return ancestor;
206  }
207  static __hwloc_inline hwloc_obj_t
208  hwloc_get_common_ancestor_obj (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj1, hwloc_obj_t obj2) __hwloc_attribute_pure;
209  static __hwloc_inline hwloc_obj_t
210  hwloc_get_common_ancestor_obj (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj1, hwloc_obj_t obj2)
211  {
212    while (obj1 != obj2) {
213      while (obj1->depth > obj2->depth)
214        obj1 = obj1->parent;
215      while (obj2->depth > obj1->depth)
216        obj2 = obj2->parent;
217      if (obj1 != obj2 && obj1->depth == obj2->depth) {
218        obj1 = obj1->parent;
219        obj2 = obj2->parent;
220      }
221    }
222    return obj1;
223  }
224  static __hwloc_inline int
225  hwloc_obj_is_in_subtree (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj, hwloc_obj_t subtree_root) __hwloc_attribute_pure;
226  static __hwloc_inline int
227  hwloc_obj_is_in_subtree (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj, hwloc_obj_t subtree_root)
228  {
229    return obj->cpuset && subtree_root->cpuset && hwloc_bitmap_isincluded(obj->cpuset, subtree_root->cpuset);
230  }
231  static __hwloc_inline hwloc_obj_t
232  hwloc_get_next_child (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t parent, hwloc_obj_t prev)
233  {
234    hwloc_obj_t obj;
235    int state = 0;
236    if (prev) {
237      if (prev->type == HWLOC_OBJ_MISC)
238        state = 3;
239      else if (prev->type == HWLOC_OBJ_BRIDGE || prev->type == HWLOC_OBJ_PCI_DEVICE || prev->type == HWLOC_OBJ_OS_DEVICE)
240        state = 2;
241      else if (prev->type == HWLOC_OBJ_NUMANODE)
242        state = 1;
243      obj = prev->next_sibling;
244    } else {
245      obj = parent->first_child;
246    }
247    if (!obj && state == 0) {
248      obj = parent->memory_first_child;
249      state = 1;
250    }
251    if (!obj && state == 1) {
252      obj = parent->io_first_child;
253      state = 2;
254    }
255    if (!obj && state == 2) {
256      obj = parent->misc_first_child;
257      state = 3;
258    }
259    return obj;
260  }
261  HWLOC_DECLSPEC int
262  hwloc_obj_type_is_normal(hwloc_obj_type_t type);
263  HWLOC_DECLSPEC int
264  hwloc_obj_type_is_io(hwloc_obj_type_t type);
265  HWLOC_DECLSPEC int
266  hwloc_obj_type_is_memory(hwloc_obj_type_t type);
267  HWLOC_DECLSPEC int
268  hwloc_obj_type_is_cache(hwloc_obj_type_t type);
269  HWLOC_DECLSPEC int
270  hwloc_obj_type_is_dcache(hwloc_obj_type_t type);
271  HWLOC_DECLSPEC int
272  hwloc_obj_type_is_icache(hwloc_obj_type_t type);
273  static __hwloc_inline int
<span onclick='openModal()' class='match'>274  hwloc_get_cache_type_depth (hwloc_topology_t topology,
275  			    unsigned cachelevel, hwloc_obj_cache_type_t cachetype)
276  {
277    int depth;
278    int found = HWLOC_TYPE_DEPTH_UNKNOWN;
279    for (depth=0; ; depth++) {
</span>280      hwloc_obj_t obj = hwloc_get_obj_by_depth(topology, depth, 0);
281      if (!obj)
282        break;
283      if (!hwloc_obj_type_is_dcache(obj->type) || obj->attr->cache.depth != cachelevel)
284        continue;
285      if (cachetype == (hwloc_obj_cache_type_t) -1) {
286        if (found != HWLOC_TYPE_DEPTH_UNKNOWN) {
287          return HWLOC_TYPE_DEPTH_MULTIPLE;
288        }
289        found = depth;
290        continue;
291      }
292      if (obj->attr->cache.type == cachetype || obj->attr->cache.type == HWLOC_OBJ_CACHE_UNIFIED)
293        return depth;
294    }
295    return found;
296  }
297  static __hwloc_inline hwloc_obj_t
298  hwloc_get_cache_covering_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set) __hwloc_attribute_pure;
299  static __hwloc_inline hwloc_obj_t
300  hwloc_get_cache_covering_cpuset (hwloc_topology_t topology, hwloc_const_cpuset_t set)
301  {
302    hwloc_obj_t current = hwloc_get_obj_covering_cpuset(topology, set);
303    while (current) {
304      if (hwloc_obj_type_is_dcache(current->type))
305        return current;
306      current = current->parent;
307    }
308    return NULL;
309  }
310  static __hwloc_inline hwloc_obj_t
311  hwloc_get_shared_cache_covering_obj (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj) __hwloc_attribute_pure;
312  static __hwloc_inline hwloc_obj_t
313  hwloc_get_shared_cache_covering_obj (hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj)
314  {
315    hwloc_obj_t current = obj->parent;
316    if (!obj->cpuset)
317      return NULL;
318    while (current) {
319      if (!hwloc_bitmap_isequal(current->cpuset, obj->cpuset)
320          && hwloc_obj_type_is_dcache(current->type))
321        return current;
322      current = current->parent;
323    }
324    return NULL;
325  }
326  HWLOC_DECLSPEC int hwloc_bitmap_singlify_per_core(hwloc_topology_t topology, hwloc_bitmap_t cpuset, unsigned which);
327  static __hwloc_inline hwloc_obj_t
328  hwloc_get_pu_obj_by_os_index(hwloc_topology_t topology, unsigned os_index) __hwloc_attribute_pure;
329  static __hwloc_inline hwloc_obj_t
330  hwloc_get_pu_obj_by_os_index(hwloc_topology_t topology, unsigned os_index)
331  {
332    hwloc_obj_t obj = NULL;
333    while ((obj = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_PU, obj)) != NULL)
334      if (obj->os_index == os_index)
335        return obj;
336    return NULL;
337  }
338  static __hwloc_inline hwloc_obj_t
339  hwloc_get_numanode_obj_by_os_index(hwloc_topology_t topology, unsigned os_index) __hwloc_attribute_pure;
340  static __hwloc_inline hwloc_obj_t
341  hwloc_get_numanode_obj_by_os_index(hwloc_topology_t topology, unsigned os_index)
342  {
343    hwloc_obj_t obj = NULL;
344    while ((obj = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_NUMANODE, obj)) != NULL)
345      if (obj->os_index == os_index)
346        return obj;
347    return NULL;
348  }
349  HWLOC_DECLSPEC unsigned hwloc_get_closest_objs (hwloc_topology_t topology, hwloc_obj_t src, hwloc_obj_t * __hwloc_restrict objs, unsigned max);
350  static __hwloc_inline hwloc_obj_t
351  hwloc_get_obj_below_by_type (hwloc_topology_t topology,
352  			     hwloc_obj_type_t type1, unsigned idx1,
353  			     hwloc_obj_type_t type2, unsigned idx2) __hwloc_attribute_pure;
354  static __hwloc_inline hwloc_obj_t
355  hwloc_get_obj_below_by_type (hwloc_topology_t topology,
356  			     hwloc_obj_type_t type1, unsigned idx1,
357  			     hwloc_obj_type_t type2, unsigned idx2)
358  {
359    hwloc_obj_t obj;
360    obj = hwloc_get_obj_by_type (topology, type1, idx1);
361    if (!obj)
362      return NULL;
363    return hwloc_get_obj_inside_cpuset_by_type(topology, obj->cpuset, type2, idx2);
364  }
365  static __hwloc_inline hwloc_obj_t
366  hwloc_get_obj_below_array_by_type (hwloc_topology_t topology, int nr, hwloc_obj_type_t *typev, unsigned *idxv) __hwloc_attribute_pure;
367  static __hwloc_inline hwloc_obj_t
368  hwloc_get_obj_below_array_by_type (hwloc_topology_t topology, int nr, hwloc_obj_type_t *typev, unsigned *idxv)
369  {
370    hwloc_obj_t obj = hwloc_get_root_obj(topology);
371    int i;
372    for(i=0; i<nr; i++) {
373      if (!obj)
374        return NULL;
375      obj = hwloc_get_obj_inside_cpuset_by_type(topology, obj->cpuset, typev[i], idxv[i]);
376    }
377    return obj;
378  }
379  HWLOC_DECLSPEC hwloc_obj_t
380  hwloc_get_obj_with_same_locality(hwloc_topology_t topology, hwloc_obj_t src,
381                                   hwloc_obj_type_t type, const char *subtype, const char *nameprefix,
382                                   unsigned long flags);
383  enum hwloc_distrib_flags_e {
384    HWLOC_DISTRIB_FLAG_REVERSE = (1UL<<0)
385  };
386  static __hwloc_inline int
387  hwloc_distrib(hwloc_topology_t topology,
388  	      hwloc_obj_t *roots, unsigned n_roots,
389  	      hwloc_cpuset_t *set,
390  	      unsigned n,
391  	      int until, unsigned long flags)
392  {
393    unsigned i;
394    unsigned tot_weight;
395    unsigned given, givenweight;
396    hwloc_cpuset_t *cpusetp = set;
397    if (flags & ~HWLOC_DISTRIB_FLAG_REVERSE) {
398      errno = EINVAL;
399      return -1;
400    }
401    tot_weight = 0;
402    for (i = 0; i < n_roots; i++)
403      tot_weight += (unsigned) hwloc_bitmap_weight(roots[i]->cpuset);
404    for (i = 0, given = 0, givenweight = 0; i < n_roots; i++) {
405      unsigned chunk, weight;
406      hwloc_obj_t root = roots[flags & HWLOC_DISTRIB_FLAG_REVERSE ? n_roots-1-i : i];
407      hwloc_cpuset_t cpuset = root->cpuset;
408      while (!hwloc_obj_type_is_normal(root->type))
409        root = root->parent;
410      weight = (unsigned) hwloc_bitmap_weight(cpuset);
411      if (!weight)
412        continue;
413      chunk = (( (givenweight+weight) * n  + tot_weight-1) / tot_weight)
414            - ((  givenweight         * n  + tot_weight-1) / tot_weight);
415      if (!root->arity || chunk <= 1 || root->depth >= until) {
416        if (chunk) {
417  	unsigned j;
418  	for (j=0; j < chunk; j++)
419  	  cpusetp[j] = hwloc_bitmap_dup(cpuset);
420        } else {
421  	assert(given);
422  	hwloc_bitmap_or(cpusetp[-1], cpusetp[-1], cpuset);
423        }
424      } else {
425        hwloc_distrib(topology, root->children, root->arity, cpusetp, chunk, until, flags);
426      }
427      cpusetp += chunk;
428      given += chunk;
429      givenweight += weight;
430    }
431    return 0;
432  }
433  HWLOC_DECLSPEC hwloc_const_cpuset_t
434  hwloc_topology_get_complete_cpuset(hwloc_topology_t topology) __hwloc_attribute_pure;
435  HWLOC_DECLSPEC hwloc_const_cpuset_t
436  hwloc_topology_get_topology_cpuset(hwloc_topology_t topology) __hwloc_attribute_pure;
437  HWLOC_DECLSPEC hwloc_const_cpuset_t
438  hwloc_topology_get_allowed_cpuset(hwloc_topology_t topology) __hwloc_attribute_pure;
439  HWLOC_DECLSPEC hwloc_const_nodeset_t
440  hwloc_topology_get_complete_nodeset(hwloc_topology_t topology) __hwloc_attribute_pure;
441  HWLOC_DECLSPEC hwloc_const_nodeset_t
442  hwloc_topology_get_topology_nodeset(hwloc_topology_t topology) __hwloc_attribute_pure;
443  HWLOC_DECLSPEC hwloc_const_nodeset_t
444  hwloc_topology_get_allowed_nodeset(hwloc_topology_t topology) __hwloc_attribute_pure;
445  static __hwloc_inline int
446  hwloc_cpuset_to_nodeset(hwloc_topology_t topology, hwloc_const_cpuset_t _cpuset, hwloc_nodeset_t nodeset)
447  {
448  	int depth = hwloc_get_type_depth(topology, HWLOC_OBJ_NUMANODE);
449  	hwloc_obj_t obj = NULL;
450  	assert(depth != HWLOC_TYPE_DEPTH_UNKNOWN);
451  	hwloc_bitmap_zero(nodeset);
452  	while ((obj = hwloc_get_next_obj_covering_cpuset_by_depth(topology, _cpuset, depth, obj)) != NULL)
453  		if (hwloc_bitmap_set(nodeset, obj->os_index) < 0)
454  			return -1;
455  	return 0;
456  }
457  static __hwloc_inline int
458  hwloc_cpuset_from_nodeset(hwloc_topology_t topology, hwloc_cpuset_t _cpuset, hwloc_const_nodeset_t nodeset)
459  {
460  	int depth = hwloc_get_type_depth(topology, HWLOC_OBJ_NUMANODE);
461  	hwloc_obj_t obj = NULL;
462  	assert(depth != HWLOC_TYPE_DEPTH_UNKNOWN);
463  	hwloc_bitmap_zero(_cpuset);
464  	while ((obj = hwloc_get_next_obj_by_depth(topology, depth, obj)) != NULL) {
465  		if (hwloc_bitmap_isset(nodeset, obj->os_index))
466  			if (hwloc_bitmap_or(_cpuset, _cpuset, obj->cpuset) < 0)
467  				return -1;
468  	}
469  	return 0;
470  }
471  static __hwloc_inline hwloc_obj_t
472  hwloc_get_non_io_ancestor_obj(hwloc_topology_t topology __hwloc_attribute_unused,
473  			      hwloc_obj_t ioobj)
474  {
475    hwloc_obj_t obj = ioobj;
476    while (obj && !obj->cpuset) {
477      obj = obj->parent;
478    }
479    return obj;
480  }
481  static __hwloc_inline hwloc_obj_t
482  hwloc_get_next_pcidev(hwloc_topology_t topology, hwloc_obj_t prev)
483  {
484    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_PCI_DEVICE, prev);
485  }
486  static __hwloc_inline hwloc_obj_t
487  hwloc_get_pcidev_by_busid(hwloc_topology_t topology,
488  			  unsigned domain, unsigned bus, unsigned dev, unsigned func)
489  {
490    hwloc_obj_t obj = NULL;
491    while ((obj = hwloc_get_next_pcidev(topology, obj)) != NULL) {
492      if (obj->attr->pcidev.domain == domain
493  	&& obj->attr->pcidev.bus == bus
494  	&& obj->attr->pcidev.dev == dev
495  	&& obj->attr->pcidev.func == func)
496        return obj;
497    }
498    return NULL;
499  }
500  static __hwloc_inline hwloc_obj_t
501  hwloc_get_pcidev_by_busidstring(hwloc_topology_t topology, const char *busid)
502  {
503    unsigned domain = 0; &bsol;* default */
504    unsigned bus, dev, func;
505    if (sscanf(busid, "%x:%x.%x", &bus, &dev, &func) != 3
506        && sscanf(busid, "%x:%x:%x.%x", &domain, &bus, &dev, &func) != 4) {
507      errno = EINVAL;
508      return NULL;
509    }
510    return hwloc_get_pcidev_by_busid(topology, domain, bus, dev, func);
511  }
512  static __hwloc_inline hwloc_obj_t
513  hwloc_get_next_osdev(hwloc_topology_t topology, hwloc_obj_t prev)
514  {
515    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_OS_DEVICE, prev);
516  }
517  static __hwloc_inline hwloc_obj_t
518  hwloc_get_next_bridge(hwloc_topology_t topology, hwloc_obj_t prev)
519  {
520    return hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_BRIDGE, prev);
521  }
522  static __hwloc_inline int
523  hwloc_bridge_covers_pcibus(hwloc_obj_t bridge,
524  			   unsigned domain, unsigned bus)
525  {
526    return bridge->type == HWLOC_OBJ_BRIDGE
527      && bridge->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
528      && bridge->attr->bridge.downstream.pci.domain == domain
529      && bridge->attr->bridge.downstream.pci.secondary_bus <= bus
530      && bridge->attr->bridge.downstream.pci.subordinate_bus >= bus;
531  }
532  #ifdef __cplusplus
533  } &bsol;* extern "C" */
534  #endif
535  #endif &bsol;* HWLOC_HELPER_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-helper.h</div>
                </div>
                <div class="column column_space"><pre><code>25  static void c2hc(INT n, R *rio, R *iio, INT is, R *r)
26  {
27       INT i;
28       r[0] = rio[0];
29       for (i = 1; i + i < n; ++i) {
</pre></code></div>
                <div class="column column_space"><pre><code>274  hwloc_get_cache_type_depth (hwloc_topology_t topology,
275  			    unsigned cachelevel, hwloc_obj_cache_type_t cachetype)
276  {
277    int depth;
278    int found = HWLOC_TYPE_DEPTH_UNKNOWN;
279    for (depth=0; ; depth++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    