
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.0%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-scan.c</h3>
            <pre><code>1  #include "kernel/ifftw.h"
2  #include <string.h>
3  #include <stddef.h>
4  #include <stdarg.h>
5  #include <stdio.h>
6  #ifdef USE_CTYPE
7  #include <ctype.h>
8  #else
9  #undef isspace
10  #define isspace(x) ((x) >= 0 && (x) <= ' ')
11  #undef isdigit
12  #define isdigit(x) ((x) >= '0' && (x) <= '9')
13  #undef isupper
14  #define isupper(x) ((x) >= 'A' && (x) <= 'Z')
15  #undef islower
16  #define islower(x) ((x) >= 'a' && (x) <= 'z')
17  #endif
18  static int mygetc(scanner *sc)
19  {
20       if (sc->ungotc != EOF) {
21  	  int c = sc->ungotc;
22  	  sc->ungotc = EOF;
<span onclick='openModal()' class='match'>23  	  return c;
24       }
25       return(sc->getchr(sc));
26  }
27  #define GETCHR(sc) mygetc(sc)
28  static void myungetc(scanner *sc, int c)
</span>29  {
30       sc->ungotc = c;
31  }
32  #define UNGETCHR(sc, c) myungetc(sc, c)
33  static void eat_blanks(scanner *sc)
34  {
35       int ch;
36       while (ch = GETCHR(sc), isspace(ch))
37            ;
38       UNGETCHR(sc, ch);
39  }
40  static void mygets(scanner *sc, char *s, int maxlen)
41  {
42       char *s0 = s;
43       int ch;
44       A(maxlen > 0);
45       while ((ch = GETCHR(sc)) != EOF && !isspace(ch)
46  	    && ch != ')' && ch != '(' && s < s0 + maxlen)
47  	  *s++ = (char)(ch & 0xFF);
48       *s = 0;
49       UNGETCHR(sc, ch);
50  }
51  static long getlong(scanner *sc, int base, int *ret)
52  {
53       int sign = 1, ch, count;
54       long x = 0;     
55       ch = GETCHR(sc);
56       if (ch == '-' || ch == '+') {
57  	  sign = ch == '-' ? -1 : 1;
58  	  ch = GETCHR(sc);
59       }
60       for (count = 0; ; ++count) {
61  	  if (isdigit(ch)) 
62  	       ch -= '0';
63  	  else if (isupper(ch))
64  	       ch -= 'A' - 10;
65  	  else if (islower(ch))
66  	       ch -= 'a' - 10;
67  	  else
68  	       break;
69  	  x = x * base + ch;
70  	  ch = GETCHR(sc);
71       }
72       x *= sign;
73       UNGETCHR(sc, ch);
74       *ret = count > 0;
75       return x;
76  }
77  static int vscan(scanner *sc, const char *format, va_list ap)
78  {
79       const char *s = format;
80       char c;
81       int ch = 0;
82       int fmt_len;
83       while ((c = *s++)) {
84  	  fmt_len = 0;
85            switch (c) {
86  	      case '%':
87  	  getformat:
88  		   switch ((c = *s++)) {
89  		       case 's': {
90  			    char *x = va_arg(ap, char *);
91  			    mygets(sc, x, fmt_len);
92  			    break;
93  		       }
94  		       case 'd': {
95  			    int *x = va_arg(ap, int *);
96  			    *x = (int) getlong(sc, 10, &ch);
97  			    if (!ch) return 0;
98  			    break;
99  		       }
100  		       case 'x': {
101  			    int *x = va_arg(ap, int *);
102  			    *x = (int) getlong(sc, 16, &ch);
103  			    if (!ch) return 0;
104  			    break;
105  		       }
106  		       case 'M': {
107  			    md5uint *x = va_arg(ap, md5uint *);
108  			    *x = (md5uint)
109  				    (0xFFFFFFFF & getlong(sc, 16, &ch));
110  			    if (!ch) return 0;
111  			    break;
112  		       }
113  		       case '*': {
114  			    if ((fmt_len = va_arg(ap, int)) <= 0) return 0;
115  			    goto getformat;
116  		       }
117  		       default:
118  			    A(0 &bsol;* unknown format */);
119  			    break;
120  		   }
121  		   break;
122  	      default:
123  		   if (isspace(c) || c == '(' || c == ')')
124  			eat_blanks(sc);
125  		   if (!isspace(c) && (ch = GETCHR(sc)) != c) {
126  			UNGETCHR(sc, ch);
127  			return 0;
128  		   }
129  		   break;
130            }
131       }
132       return 1;
133  }
134  static int scan(scanner *sc, const char *format, ...)
135  {
136       int ret;
137       va_list ap;
138       va_start(ap, format);
139       ret = vscan(sc, format, ap);
140       va_end(ap);
141       return ret;
142  }
143  scanner *X(mkscanner)(size_t size, int (*getchr)(scanner *sc))
144  {
145       scanner *s = (scanner *)MALLOC(size, OTHER);
146       s->scan = scan;
147       s->vscan = vscan;
148       s->getchr = getchr;
149       s->ungotc = EOF;
150       return s;
151  }
152  void X(scanner_destroy)(scanner *sc)
153  {
154       X(ifree)(sc);
155  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-zone.c</h3>
            <pre><code>1  #include "jemalloc/internal/jemalloc_preamble.h"
2  #include "jemalloc/internal/jemalloc_internal_includes.h"
3  #include "jemalloc/internal/assert.h"
4  #ifndef JEMALLOC_ZONE
5  #  error "This source file is for zones on Darwin (OS X)."
6  #endif
7  typedef struct _malloc_zone_t {
8  	void *reserved1;
9  	void *reserved2;
10  	size_t (*size)(struct _malloc_zone_t *, const void *);
11  	void *(*malloc)(struct _malloc_zone_t *, size_t);
12  	void *(*calloc)(struct _malloc_zone_t *, size_t, size_t);
13  	void *(*valloc)(struct _malloc_zone_t *, size_t);
14  	void (*free)(struct _malloc_zone_t *, void *);
15  	void *(*realloc)(struct _malloc_zone_t *, void *, size_t);
16  	void (*destroy)(struct _malloc_zone_t *);
17  	const char *zone_name;
18  	unsigned (*batch_malloc)(struct _malloc_zone_t *, size_t, void **, unsigned);
19  	void (*batch_free)(struct _malloc_zone_t *, void **, unsigned);
20  	struct malloc_introspection_t *introspect;
21  	unsigned version;
22  	void *(*memalign)(struct _malloc_zone_t *, size_t, size_t);
23  	void (*free_definite_size)(struct _malloc_zone_t *, void *, size_t);
24  	size_t (*pressure_relief)(struct _malloc_zone_t *, size_t);
25  } malloc_zone_t;
26  typedef struct {
27  	vm_address_t address;
28  	vm_size_t size;
29  } vm_range_t;
30  typedef struct malloc_statistics_t {
31  	unsigned blocks_in_use;
32  	size_t size_in_use;
33  	size_t max_size_in_use;
34  	size_t size_allocated;
35  } malloc_statistics_t;
36  typedef kern_return_t memory_reader_t(task_t, vm_address_t, vm_size_t, void **);
37  typedef void vm_range_recorder_t(task_t, void *, unsigned type, vm_range_t *, unsigned);
38  typedef struct malloc_introspection_t {
39  	kern_return_t (*enumerator)(task_t, void *, unsigned, vm_address_t, memory_reader_t, vm_range_recorder_t);
40  	size_t (*good_size)(malloc_zone_t *, size_t);
41  	boolean_t (*check)(malloc_zone_t *);
42  	void (*print)(malloc_zone_t *, boolean_t);
43  	void (*log)(malloc_zone_t *, void *);
44  	void (*force_lock)(malloc_zone_t *);
45  	void (*force_unlock)(malloc_zone_t *);
46  	void (*statistics)(malloc_zone_t *, malloc_statistics_t *);
47  	boolean_t (*zone_locked)(malloc_zone_t *);
48  	boolean_t (*enable_discharge_checking)(malloc_zone_t *);
49  	boolean_t (*disable_discharge_checking)(malloc_zone_t *);
50  	void (*discharge)(malloc_zone_t *, void *);
51  #ifdef __BLOCKS__
52  	void (*enumerate_discharged_pointers)(malloc_zone_t *, void (^)(void *, void *));
53  #else
54  	void *enumerate_unavailable_without_blocks;
55  #endif
56  	void (*reinit_lock)(malloc_zone_t *);
57  } malloc_introspection_t;
58  extern kern_return_t malloc_get_all_zones(task_t, memory_reader_t, vm_address_t **, unsigned *);
59  extern malloc_zone_t *malloc_default_zone(void);
60  extern void malloc_zone_register(malloc_zone_t *zone);
61  extern void malloc_zone_unregister(malloc_zone_t *zone);
62  extern malloc_zone_t *malloc_default_purgeable_zone(void)
63  JEMALLOC_ATTR(weak_import);
64  static malloc_zone_t *default_zone, *purgeable_zone;
65  static malloc_zone_t jemalloc_zone;
66  static struct malloc_introspection_t jemalloc_zone_introspect;
67  static pid_t zone_force_lock_pid = -1;
68  static size_t	zone_size(malloc_zone_t *zone, const void *ptr);
69  static void	*zone_malloc(malloc_zone_t *zone, size_t size);
70  static void	*zone_calloc(malloc_zone_t *zone, size_t num, size_t size);
71  static void	*zone_valloc(malloc_zone_t *zone, size_t size);
72  static void	zone_free(malloc_zone_t *zone, void *ptr);
73  static void	*zone_realloc(malloc_zone_t *zone, void *ptr, size_t size);
74  static void	*zone_memalign(malloc_zone_t *zone, size_t alignment,
75      size_t size);
76  static void	zone_free_definite_size(malloc_zone_t *zone, void *ptr,
77      size_t size);
78  static void	zone_destroy(malloc_zone_t *zone);
79  static unsigned	zone_batch_malloc(struct _malloc_zone_t *zone, size_t size,
80      void **results, unsigned num_requested);
81  static void	zone_batch_free(struct _malloc_zone_t *zone,
82      void **to_be_freed, unsigned num_to_be_freed);
83  static size_t	zone_pressure_relief(struct _malloc_zone_t *zone, size_t goal);
84  static size_t	zone_good_size(malloc_zone_t *zone, size_t size);
85  static kern_return_t	zone_enumerator(task_t task, void *data, unsigned type_mask,
86      vm_address_t zone_address, memory_reader_t reader,
87      vm_range_recorder_t recorder);
88  static boolean_t	zone_check(malloc_zone_t *zone);
89  static void	zone_print(malloc_zone_t *zone, boolean_t verbose);
90  static void	zone_log(malloc_zone_t *zone, void *address);
91  static void	zone_force_lock(malloc_zone_t *zone);
92  static void	zone_force_unlock(malloc_zone_t *zone);
93  static void	zone_statistics(malloc_zone_t *zone,
94      malloc_statistics_t *stats);
95  static boolean_t	zone_locked(malloc_zone_t *zone);
96  static void	zone_reinit_lock(malloc_zone_t *zone);
97  static size_t
98  zone_size(malloc_zone_t *zone, const void *ptr) {
99  	return ivsalloc(tsdn_fetch(), ptr);
100  }
101  static void *
102  zone_malloc(malloc_zone_t *zone, size_t size) {
103  	return je_malloc(size);
104  }
105  static void *
106  zone_calloc(malloc_zone_t *zone, size_t num, size_t size) {
107  	return je_calloc(num, size);
108  }
109  static void *
110  zone_valloc(malloc_zone_t *zone, size_t size) {
111  	void *ret = NULL; &bsol;* Assignment avoids useless compiler warning. */
112  	je_posix_memalign(&ret, PAGE, size);
113  	return ret;
114  }
115  static void
116  zone_free(malloc_zone_t *zone, void *ptr) {
117  	if (ivsalloc(tsdn_fetch(), ptr) != 0) {
118  		je_free(ptr);
119  		return;
120  	}
121  	free(ptr);
122  }
123  static void *
124  zone_realloc(malloc_zone_t *zone, void *ptr, size_t size) {
125  	if (ivsalloc(tsdn_fetch(), ptr) != 0) {
126  		return je_realloc(ptr, size);
127  	}
128  	return realloc(ptr, size);
129  }
130  static void *
131  zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size) {
132  	void *ret = NULL; &bsol;* Assignment avoids useless compiler warning. */
133  	je_posix_memalign(&ret, alignment, size);
134  	return ret;
135  }
136  static void
137  zone_free_definite_size(malloc_zone_t *zone, void *ptr, size_t size) {
138  	size_t alloc_size;
139  	alloc_size = ivsalloc(tsdn_fetch(), ptr);
140  	if (alloc_size != 0) {
141  		assert(alloc_size == size);
142  		je_free(ptr);
143  		return;
144  	}
145  	free(ptr);
146  }
147  static void
148  zone_destroy(malloc_zone_t *zone) {
149  	not_reached();
150  }
151  static unsigned
152  zone_batch_malloc(struct _malloc_zone_t *zone, size_t size, void **results,
153      unsigned num_requested) {
154  	unsigned i;
155  	for (i = 0; i < num_requested; i++) {
156  		results[i] = je_malloc(size);
157  		if (!results[i])
158  			break;
159  	}
160  	return i;
161  }
162  static void
163  zone_batch_free(struct _malloc_zone_t *zone, void **to_be_freed,
164      unsigned num_to_be_freed) {
165  	unsigned i;
166  	for (i = 0; i < num_to_be_freed; i++) {
167  		zone_free(zone, to_be_freed[i]);
168  		to_be_freed[i] = NULL;
169  	}
170  }
171  static size_t
172  zone_pressure_relief(struct _malloc_zone_t *zone, size_t goal) {
173  	return 0;
174  }
175  static size_t
176  zone_good_size(malloc_zone_t *zone, size_t size) {
177  	if (size == 0) {
178  		size = 1;
179  	}
180  	return sz_s2u(size);
181  }
182  static kern_return_t
183  zone_enumerator(task_t task, void *data, unsigned type_mask,
184      vm_address_t zone_address, memory_reader_t reader,
185      vm_range_recorder_t recorder) {
186  	return KERN_SUCCESS;
187  }
188  static boolean_t
189  zone_check(malloc_zone_t *zone) {
190  	return true;
191  }
192  static void
193  zone_print(malloc_zone_t *zone, boolean_t verbose) {
194  }
195  static void
196  zone_log(malloc_zone_t *zone, void *address) {
197  }
198  static void
199  zone_force_lock(malloc_zone_t *zone) {
200  	if (isthreaded) {
201  		assert(zone_force_lock_pid == -1);
202  		zone_force_lock_pid = getpid();
203  		jemalloc_prefork();
204  	}
205  }
206  static void
207  zone_force_unlock(malloc_zone_t *zone) {
208  	if (isthreaded) {
209  		assert(zone_force_lock_pid != -1);
210  		if (getpid() == zone_force_lock_pid) {
211  			jemalloc_postfork_parent();
212  		} else {
213  			jemalloc_postfork_child();
214  		}
215  		zone_force_lock_pid = -1;
216  	}
217  }
218  static void
219  zone_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {
220  	stats->blocks_in_use = 0;
221  	stats->size_in_use = 0;
222  	stats->max_size_in_use = 0;
223  	stats->size_allocated = 0;
224  }
225  static boolean_t
226  zone_locked(malloc_zone_t *zone) {
227  	return false;
228  }
229  static void
230  zone_reinit_lock(malloc_zone_t *zone) {
231  	zone_force_unlock(zone);
232  }
233  static void
234  zone_init(void) {
235  	jemalloc_zone.size = zone_size;
236  	jemalloc_zone.malloc = zone_malloc;
237  	jemalloc_zone.calloc = zone_calloc;
238  	jemalloc_zone.valloc = zone_valloc;
239  	jemalloc_zone.free = zone_free;
240  	jemalloc_zone.realloc = zone_realloc;
241  	jemalloc_zone.destroy = zone_destroy;
242  	jemalloc_zone.zone_name = "jemalloc_zone";
243  	jemalloc_zone.batch_malloc = zone_batch_malloc;
244  	jemalloc_zone.batch_free = zone_batch_free;
245  	jemalloc_zone.introspect = &jemalloc_zone_introspect;
246  	jemalloc_zone.version = 9;
247  	jemalloc_zone.memalign = zone_memalign;
248  	jemalloc_zone.free_definite_size = zone_free_definite_size;
249  	jemalloc_zone.pressure_relief = zone_pressure_relief;
250  	jemalloc_zone_introspect.enumerator = zone_enumerator;
251  	jemalloc_zone_introspect.good_size = zone_good_size;
252  	jemalloc_zone_introspect.check = zone_check;
253  	jemalloc_zone_introspect.print = zone_print;
254  	jemalloc_zone_introspect.log = zone_log;
255  	jemalloc_zone_introspect.force_lock = zone_force_lock;
256  	jemalloc_zone_introspect.force_unlock = zone_force_unlock;
257  	jemalloc_zone_introspect.statistics = zone_statistics;
258  	jemalloc_zone_introspect.zone_locked = zone_locked;
259  	jemalloc_zone_introspect.enable_discharge_checking = NULL;
260  	jemalloc_zone_introspect.disable_discharge_checking = NULL;
261  	jemalloc_zone_introspect.discharge = NULL;
262  #ifdef __BLOCKS__
263  	jemalloc_zone_introspect.enumerate_discharged_pointers = NULL;
264  #else
265  	jemalloc_zone_introspect.enumerate_unavailable_without_blocks = NULL;
266  #endif
267  	jemalloc_zone_introspect.reinit_lock = zone_reinit_lock;
268  }
269  static malloc_zone_t *
270  zone_default_get(void) {
271  	malloc_zone_t **zones = NULL;
272  	unsigned int num_zones = 0;
273  	if (KERN_SUCCESS != malloc_get_all_zones(0, NULL,
274  	    (vm_address_t**)&zones, &num_zones)) {
275  		num_zones = 0;
276  	}
277  	if (num_zones) {
<span onclick='openModal()' class='match'>278  		return zones[0];
279  	}
280  	return malloc_default_zone();
281  }
282  static void
283  zone_promote(void) {
284  	malloc_zone_t *zone;
</span>285  	do {
286  		malloc_zone_unregister(default_zone);
287  		malloc_zone_register(default_zone);
288  		if (purgeable_zone != NULL) {
289  			malloc_zone_unregister(purgeable_zone);
290  			malloc_zone_register(purgeable_zone);
291  		}
292  		zone = zone_default_get();
293  	} while (zone != &jemalloc_zone);
294  }
295  JEMALLOC_ATTR(constructor)
296  void
297  zone_register(void) {
298  	default_zone = zone_default_get();
299  	if (!default_zone->zone_name || strcmp(default_zone->zone_name,
300  	    "DefaultMallocZone") != 0) {
301  		return;
302  	}
303  	purgeable_zone = (malloc_default_purgeable_zone == NULL) ? NULL :
304  	    malloc_default_purgeable_zone();
305  	zone_init();
306  	malloc_zone_register(&jemalloc_zone);
307  	zone_promote();
308  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-scan.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-zone.c</div>
                </div>
                <div class="column column_space"><pre><code>23  	  return c;
24       }
25       return(sc->getchr(sc));
26  }
27  #define GETCHR(sc) mygetc(sc)
28  static void myungetc(scanner *sc, int c)
</pre></code></div>
                <div class="column column_space"><pre><code>278  		return zones[0];
279  	}
280  	return malloc_default_zone();
281  }
282  static void
283  zone_promote(void) {
284  	malloc_zone_t *zone;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    