
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.338028169014084%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_utils.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include "src/dsp/dsp.h"
5  #include "src/utils/rescaler_utils.h"
6  void WebPRescalerInit(WebPRescaler* const wrk, int src_width, int src_height,
7                        uint8_t* const dst,
8                        int dst_width, int dst_height, int dst_stride,
9                        int num_channels, rescaler_t* const work) {
10    const int x_add = src_width, x_sub = dst_width;
11    const int y_add = src_height, y_sub = dst_height;
12    wrk->x_expand = (src_width < dst_width);
13    wrk->y_expand = (src_height < dst_height);
14    wrk->src_width = src_width;
15    wrk->src_height = src_height;
16    wrk->dst_width = dst_width;
17    wrk->dst_height = dst_height;
18    wrk->src_y = 0;
19    wrk->dst_y = 0;
20    wrk->dst = dst;
21    wrk->dst_stride = dst_stride;
22    wrk->num_channels = num_channels;
23    wrk->x_add = wrk->x_expand ? (x_sub - 1) : x_add;
24    wrk->x_sub = wrk->x_expand ? (x_add - 1) : x_sub;
25    if (!wrk->x_expand) {  
26      wrk->fx_scale = WEBP_RESCALER_FRAC(1, wrk->x_sub);
27    }
28    wrk->y_add = wrk->y_expand ? y_add - 1 : y_add;
29    wrk->y_sub = wrk->y_expand ? y_sub - 1 : y_sub;
30    wrk->y_accum = wrk->y_expand ? wrk->y_sub : wrk->y_add;
31    if (!wrk->y_expand) {
32      const uint64_t ratio =
33          (uint64_t)dst_height * WEBP_RESCALER_ONE / (wrk->x_add * wrk->y_add);
34      if (ratio != (uint32_t)ratio) {
35        wrk->fxy_scale = 0;
36      } else {
37        wrk->fxy_scale = (uint32_t)ratio;
38      }
39      wrk->fy_scale = WEBP_RESCALER_FRAC(1, wrk->y_sub);
40    } else {
41      wrk->fy_scale = WEBP_RESCALER_FRAC(1, wrk->x_add);
42    }
43    wrk->irow = work;
<span onclick='openModal()' class='match'>44    wrk->frow = work + num_channels * dst_width;
45    memset(work, 0, 2 * dst_width * num_channels * sizeof(*work));
46    WebPRescalerDspInit();
47  }
48  int WebPRescalerGetScaledDimensions(int src_width, int src_height,
49                                      int* const scaled_width,
50                                      int* const scaled_height) {
51    assert(scaled_width != NULL);
52    assert(scaled_height != NULL);
53    {
54      int width = *scaled_width;
</span>55      int height = *scaled_height;
56      if (width == 0 && src_height > 0) {
57        width =
58            (int)(((uint64_t)src_width * height + src_height - 1) / src_height);
59      }
60      if (height == 0 && src_width > 0) {
61        height =
62            (int)(((uint64_t)src_height * width + src_width - 1) / src_width);
63      }
64      if (width <= 0 || height <= 0) {
65        return 0;
66      }
67      *scaled_width = width;
68      *scaled_height = height;
69      return 1;
70    }
71  }
72  int WebPRescaleNeededLines(const WebPRescaler* const wrk, int max_num_lines) {
73    const int num_lines = (wrk->y_accum + wrk->y_sub - 1) / wrk->y_sub;
74    return (num_lines > max_num_lines) ? max_num_lines : num_lines;
75  }
76  int WebPRescalerImport(WebPRescaler* const wrk, int num_lines,
77                         const uint8_t* src, int src_stride) {
78    int total_imported = 0;
79    while (total_imported < num_lines && !WebPRescalerHasPendingOutput(wrk)) {
80      if (wrk->y_expand) {
81        rescaler_t* const tmp = wrk->irow;
82        wrk->irow = wrk->frow;
83        wrk->frow = tmp;
84      }
85      WebPRescalerImportRow(wrk, src);
86      if (!wrk->y_expand) {     
87        int x;
88        for (x = 0; x < wrk->num_channels * wrk->dst_width; ++x) {
89          wrk->irow[x] += wrk->frow[x];
90        }
91      }
92      ++wrk->src_y;
93      src += src_stride;
94      ++total_imported;
95      wrk->y_accum -= wrk->y_sub;
96    }
97    return total_imported;
98  }
99  int WebPRescalerExport(WebPRescaler* const rescaler) {
100    int total_exported = 0;
101    while (WebPRescalerHasPendingOutput(rescaler)) {
102      WebPRescalerExportRow(rescaler);
103      ++total_exported;
104    }
105    return total_exported;
106  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv.h</h3>
            <pre><code>1  #ifndef WEBP_DSP_YUV_H_
2  #define WEBP_DSP_YUV_H_
3  #include "src/dsp/dsp.h"
4  #include "src/dec/vp8_dec.h"
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  enum {
9    YUV_FIX = 16,                    
10    YUV_HALF = 1 << (YUV_FIX - 1),
11    YUV_FIX2 = 6,                   
12    YUV_MASK2 = (256 << YUV_FIX2) - 1
13  };
14  static WEBP_INLINE int MultHi(int v, int coeff) {   
15    return (v * coeff) >> 8;
16  }
17  static WEBP_INLINE int VP8Clip8(int v) {
18    return ((v & ~YUV_MASK2) == 0) ? (v >> YUV_FIX2) : (v < 0) ? 0 : 255;
19  }
20  static WEBP_INLINE int VP8YUVToR(int y, int v) {
21    return VP8Clip8(MultHi(y, 19077) + MultHi(v, 26149) - 14234);
22  }
23  static WEBP_INLINE int VP8YUVToG(int y, int u, int v) {
24    return VP8Clip8(MultHi(y, 19077) - MultHi(u, 6419) - MultHi(v, 13320) + 8708);
25  }
26  static WEBP_INLINE int VP8YUVToB(int y, int u) {
27    return VP8Clip8(MultHi(y, 19077) + MultHi(u, 33050) - 17685);
28  }
29  static WEBP_INLINE void VP8YuvToRgb(int y, int u, int v,
30                                      uint8_t* const rgb) {
31    rgb[0] = VP8YUVToR(y, v);
32    rgb[1] = VP8YUVToG(y, u, v);
33    rgb[2] = VP8YUVToB(y, u);
34  }
35  static WEBP_INLINE void VP8YuvToBgr(int y, int u, int v,
36                                      uint8_t* const bgr) {
37    bgr[0] = VP8YUVToB(y, u);
38    bgr[1] = VP8YUVToG(y, u, v);
<span onclick='openModal()' class='match'>39    bgr[2] = VP8YUVToR(y, v);
40  }
41  static WEBP_INLINE void VP8YuvToRgb565(int y, int u, int v,
42                                         uint8_t* const rgb) {
43    const int r = VP8YUVToR(y, v);      
</span>44    const int g = VP8YUVToG(y, u, v);   
45    const int b = VP8YUVToB(y, u);      
46    const int rg = (r & 0xf8) | (g >> 5);
47    const int gb = ((g << 3) & 0xe0) | (b >> 3);
48  #if (WEBP_SWAP_16BIT_CSP == 1)
49    rgb[0] = gb;
50    rgb[1] = rg;
51  #else
52    rgb[0] = rg;
53    rgb[1] = gb;
54  #endif
55  }
56  static WEBP_INLINE void VP8YuvToRgba4444(int y, int u, int v,
57                                           uint8_t* const argb) {
58    const int r = VP8YUVToR(y, v);        
59    const int g = VP8YUVToG(y, u, v);     
60    const int b = VP8YUVToB(y, u);        
61    const int rg = (r & 0xf0) | (g >> 4);
62    const int ba = (b & 0xf0) | 0x0f;     
63  #if (WEBP_SWAP_16BIT_CSP == 1)
64    argb[0] = ba;
65    argb[1] = rg;
66  #else
67    argb[0] = rg;
68    argb[1] = ba;
69  #endif
70  }
71  static WEBP_INLINE void VP8YuvToArgb(uint8_t y, uint8_t u, uint8_t v,
72                                       uint8_t* const argb) {
73    argb[0] = 0xff;
74    VP8YuvToRgb(y, u, v, argb + 1);
75  }
76  static WEBP_INLINE void VP8YuvToBgra(uint8_t y, uint8_t u, uint8_t v,
77                                       uint8_t* const bgra) {
78    VP8YuvToBgr(y, u, v, bgra);
79    bgra[3] = 0xff;
80  }
81  static WEBP_INLINE void VP8YuvToRgba(uint8_t y, uint8_t u, uint8_t v,
82                                       uint8_t* const rgba) {
83    VP8YuvToRgb(y, u, v, rgba);
84    rgba[3] = 0xff;
85  }
86  #if defined(WEBP_USE_SSE2)
87  void VP8YuvToRgba32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
88                           uint8_t* dst);
89  void VP8YuvToRgb32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
90                          uint8_t* dst);
91  void VP8YuvToBgra32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
92                           uint8_t* dst);
93  void VP8YuvToBgr32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
94                          uint8_t* dst);
95  void VP8YuvToArgb32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
96                           uint8_t* dst);
97  void VP8YuvToRgba444432_SSE2(const uint8_t* y, const uint8_t* u,
98                               const uint8_t* v, uint8_t* dst);
99  void VP8YuvToRgb56532_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
100                             uint8_t* dst);
101  #endif    
102  #if defined(WEBP_USE_SSE41)
103  void VP8YuvToRgb32_SSE41(const uint8_t* y, const uint8_t* u, const uint8_t* v,
104                           uint8_t* dst);
105  void VP8YuvToBgr32_SSE41(const uint8_t* y, const uint8_t* u, const uint8_t* v,
106                           uint8_t* dst);
107  #endif    
108  static WEBP_INLINE int VP8ClipUV(int uv, int rounding) {
109    uv = (uv + rounding + (128 << (YUV_FIX + 2))) >> (YUV_FIX + 2);
110    return ((uv & ~0xff) == 0) ? uv : (uv < 0) ? 0 : 255;
111  }
112  static WEBP_INLINE int VP8RGBToY(int r, int g, int b, int rounding) {
113    const int luma = 16839 * r + 33059 * g + 6420 * b;
114    return (luma + rounding + (16 << YUV_FIX)) >> YUV_FIX;  
115  }
116  static WEBP_INLINE int VP8RGBToU(int r, int g, int b, int rounding) {
117    const int u = -9719 * r - 19081 * g + 28800 * b;
118    return VP8ClipUV(u, rounding);
119  }
120  static WEBP_INLINE int VP8RGBToV(int r, int g, int b, int rounding) {
121    const int v = +28800 * r - 24116 * g - 4684 * b;
122    return VP8ClipUV(v, rounding);
123  }
124  #ifdef __cplusplus
125  }    
126  #endif
127  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_utils.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv.h</div>
                </div>
                <div class="column column_space"><pre><code>44    wrk->frow = work + num_channels * dst_width;
45    memset(work, 0, 2 * dst_width * num_channels * sizeof(*work));
46    WebPRescalerDspInit();
47  }
48  int WebPRescalerGetScaledDimensions(int src_width, int src_height,
49                                      int* const scaled_width,
50                                      int* const scaled_height) {
51    assert(scaled_width != NULL);
52    assert(scaled_height != NULL);
53    {
54      int width = *scaled_width;
</pre></code></div>
                <div class="column column_space"><pre><code>39    bgr[2] = VP8YUVToR(y, v);
40  }
41  static WEBP_INLINE void VP8YuvToRgb565(int y, int u, int v,
42                                         uint8_t* const rgb) {
43    const int r = VP8YUVToR(y, v);      
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    