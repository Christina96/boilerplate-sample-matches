
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.79020979020979%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_mips32.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MIPS32) && !defined(WEBP_REDUCE_SIZE)
3  #include <assert.h>
4  #include "src/utils/rescaler_utils.h"
5  static void ImportRowShrink_MIPS32(WebPRescaler* const wrk,
6                                     const uint8_t* src) {
7    const int x_stride = wrk->num_channels;
8    const int x_out_max = wrk->dst_width * wrk->num_channels;
9    const int fx_scale = wrk->fx_scale;
10    const int x_add = wrk->x_add;
11    const int x_sub = wrk->x_sub;
12    const int x_stride1 = x_stride << 2;
13    int channel;
14    assert(!wrk->x_expand);
15    assert(!WebPRescalerInputDone(wrk));
16    for (channel = 0; channel < x_stride; ++channel) {
17      const uint8_t* src1 = src + channel;
18      rescaler_t* frow = wrk->frow + channel;
19      int temp1, temp2, temp3;
20      int base, frac, sum;
21      int accum, accum1;
22      int loop_c = x_out_max - channel;
23      __asm__ volatile (
24        "li     %[temp1],   0x8000                    \n\t"
25        "li     %[temp2],   0x10000                   \n\t"
26        "li     %[sum],     0                         \n\t"
27        "li     %[accum],   0                         \n\t"
28      "1:                                             \n\t"
29        "addu   %[accum],   %[accum],   %[x_add]      \n\t"
30        "li     %[base],    0                         \n\t"
31        "blez   %[accum],   3f                        \n\t"
32      "2:                                             \n\t"
33        "lbu    %[base],    0(%[src1])                \n\t"
34        "subu   %[accum],   %[accum],   %[x_sub]      \n\t"
35        "addu   %[src1],    %[src1],    %[x_stride]   \n\t"
36        "addu   %[sum],     %[sum],     %[base]       \n\t"
37        "bgtz   %[accum],   2b                        \n\t"
38      "3:                                             \n\t"
39        "negu   %[accum1],  %[accum]                  \n\t"
40        "mul    %[frac],    %[base],    %[accum1]     \n\t"
41        "mul    %[temp3],   %[sum],     %[x_sub]      \n\t"
42        "subu   %[loop_c],  %[loop_c],  %[x_stride]   \n\t"
43        "mult   %[temp1],   %[temp2]                  \n\t"
44        "maddu  %[frac],    %[fx_scale]               \n\t"
45        "mfhi   %[sum]                                \n\t"
46        "subu   %[temp3],   %[temp3],   %[frac]       \n\t"
47        "sw     %[temp3],   0(%[frow])                \n\t"
48        "addu   %[frow],    %[frow],    %[x_stride1]  \n\t"
49        "bgtz   %[loop_c],  1b                        \n\t"
50        : [accum]"=&r"(accum), [src1]"+r"(src1), [temp3]"=&r"(temp3),
51          [sum]"=&r"(sum), [base]"=&r"(base), [frac]"=&r"(frac),
52          [frow]"+r"(frow), [accum1]"=&r"(accum1),
53          [temp2]"=&r"(temp2), [temp1]"=&r"(temp1)
54        : [x_stride]"r"(x_stride), [fx_scale]"r"(fx_scale),
55          [x_sub]"r"(x_sub), [x_add]"r"(x_add),
56          [loop_c]"r"(loop_c), [x_stride1]"r"(x_stride1)
57        : "memory", "hi", "lo"
58      );
59      assert(accum == 0);
60    }
61  }
62  static void ImportRowExpand_MIPS32(WebPRescaler* const wrk,
<span onclick='openModal()' class='match'>63                                     const uint8_t* src) {
64    const int x_stride = wrk->num_channels;
65    const int x_out_max = wrk->dst_width * wrk->num_channels;
66    const int x_add = wrk->x_add;
67    const int x_sub = wrk->x_sub;
</span>68    const int src_width = wrk->src_width;
69    const int x_stride1 = x_stride << 2;
70    int channel;
71    assert(wrk->x_expand);
72    assert(!WebPRescalerInputDone(wrk));
73    for (channel = 0; channel < x_stride; ++channel) {
74      const uint8_t* src1 = src + channel;
75      rescaler_t* frow = wrk->frow + channel;
76      int temp1, temp2, temp3, temp4;
77      int frac;
78      int accum;
79      int x_out = channel;
80      __asm__ volatile (
81        "addiu  %[temp3],   %[src_width], -1            \n\t"
82        "lbu    %[temp2],   0(%[src1])                  \n\t"
83        "addu   %[src1],    %[src1],      %[x_stride]   \n\t"
84        "bgtz   %[temp3],   0f                          \n\t"
85        "addiu  %[temp1],   %[temp2],     0             \n\t"
86        "b      3f                                      \n\t"
87      "0:                                               \n\t"
88        "lbu    %[temp1],   0(%[src1])                  \n\t"
89      "3:                                               \n\t"
90        "addiu  %[accum],   %[x_add],     0             \n\t"
91      "1:                                               \n\t"
92        "subu   %[temp3],   %[temp2],     %[temp1]      \n\t"
93        "mul    %[temp3],   %[temp3],     %[accum]      \n\t"
94        "mul    %[temp4],   %[temp1],     %[x_add]      \n\t"
95        "addu   %[temp3],   %[temp4],     %[temp3]      \n\t"
96        "sw     %[temp3],   0(%[frow])                  \n\t"
97        "addu   %[frow],    %[frow],      %[x_stride1]  \n\t"
98        "addu   %[x_out],   %[x_out],     %[x_stride]   \n\t"
99        "subu   %[temp3],   %[x_out],     %[x_out_max]  \n\t"
100        "bgez   %[temp3],   2f                          \n\t"
101        "subu   %[accum],   %[accum],     %[x_sub]      \n\t"
102        "bgez   %[accum],   4f                          \n\t"
103        "addiu  %[temp2],   %[temp1],     0             \n\t"
104        "addu   %[src1],    %[src1],      %[x_stride]   \n\t"
105        "lbu    %[temp1],   0(%[src1])                  \n\t"
106        "addu   %[accum],   %[accum],     %[x_add]      \n\t"
107      "4:                                               \n\t"
108        "b      1b                                      \n\t"
109      "2:                                               \n\t"
110        : [src1]"+r"(src1), [accum]"=&r"(accum), [temp1]"=&r"(temp1),
111          [temp2]"=&r"(temp2), [temp3]"=&r"(temp3), [temp4]"=&r"(temp4),
112          [x_out]"+r"(x_out), [frac]"=&r"(frac), [frow]"+r"(frow)
113        : [x_stride]"r"(x_stride), [x_add]"r"(x_add), [x_sub]"r"(x_sub),
114          [x_stride1]"r"(x_stride1), [src_width]"r"(src_width),
115          [x_out_max]"r"(x_out_max)
116        : "memory", "hi", "lo"
117      );
118      assert(wrk->x_sub == 0 &bsol;* <- special case for src_width=1 */ || accum == 0);
119    }
120  }
121  static void ExportRowExpand_MIPS32(WebPRescaler* const wrk) {
122    uint8_t* dst = wrk->dst;
123    rescaler_t* irow = wrk->irow;
124    const int x_out_max = wrk->dst_width * wrk->num_channels;
125    const rescaler_t* frow = wrk->frow;
126    int temp0, temp1, temp3, temp4, temp5, loop_end;
127    const int temp2 = (int)wrk->fy_scale;
128    const int temp6 = x_out_max << 2;
129    assert(!WebPRescalerOutputDone(wrk));
130    assert(wrk->y_accum <= 0);
131    assert(wrk->y_expand);
132    assert(wrk->y_sub != 0);
133    if (wrk->y_accum == 0) {
134      __asm__ volatile (
135        "li       %[temp3],    0x10000                    \n\t"
136        "li       %[temp4],    0x8000                     \n\t"
137        "addu     %[loop_end], %[frow],     %[temp6]      \n\t"
138      "1:                                                 \n\t"
139        "lw       %[temp0],    0(%[frow])                 \n\t"
140        "addiu    %[dst],      %[dst],      1             \n\t"
141        "addiu    %[frow],     %[frow],     4             \n\t"
142        "mult     %[temp3],    %[temp4]                   \n\t"
143        "maddu    %[temp0],    %[temp2]                   \n\t"
144        "mfhi     %[temp5]                                \n\t"
145        "sb       %[temp5],    -1(%[dst])                 \n\t"
146        "bne      %[frow],     %[loop_end], 1b            \n\t"
147        : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp3]"=&r"(temp3),
148          [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [frow]"+r"(frow),
149          [dst]"+r"(dst), [loop_end]"=&r"(loop_end)
150        : [temp2]"r"(temp2), [temp6]"r"(temp6)
151        : "memory", "hi", "lo"
152      );
153    } else {
154      const uint32_t B = WEBP_RESCALER_FRAC(-wrk->y_accum, wrk->y_sub);
155      const uint32_t A = (uint32_t)(WEBP_RESCALER_ONE - B);
156      __asm__ volatile (
157        "li       %[temp3],    0x10000                    \n\t"
158        "li       %[temp4],    0x8000                     \n\t"
159        "addu     %[loop_end], %[frow],     %[temp6]      \n\t"
160      "1:                                                 \n\t"
161        "lw       %[temp0],    0(%[frow])                 \n\t"
162        "lw       %[temp1],    0(%[irow])                 \n\t"
163        "addiu    %[dst],      %[dst],      1             \n\t"
164        "mult     %[temp3],    %[temp4]                   \n\t"
165        "maddu    %[A],        %[temp0]                   \n\t"
166        "maddu    %[B],        %[temp1]                   \n\t"
167        "addiu    %[frow],     %[frow],     4             \n\t"
168        "addiu    %[irow],     %[irow],     4             \n\t"
169        "mfhi     %[temp5]                                \n\t"
170        "mult     %[temp3],    %[temp4]                   \n\t"
171        "maddu    %[temp5],    %[temp2]                   \n\t"
172        "mfhi     %[temp5]                                \n\t"
173        "sb       %[temp5],    -1(%[dst])                 \n\t"
174        "bne      %[frow],     %[loop_end], 1b            \n\t"
175        : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp3]"=&r"(temp3),
176          [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [frow]"+r"(frow),
177          [irow]"+r"(irow), [dst]"+r"(dst), [loop_end]"=&r"(loop_end)
178        : [temp2]"r"(temp2), [temp6]"r"(temp6), [A]"r"(A), [B]"r"(B)
179        : "memory", "hi", "lo"
180      );
181    }
182  }
183  #if 0  
184  static void ExportRowShrink_MIPS32(WebPRescaler* const wrk) {
185    const int x_out_max = wrk->dst_width * wrk->num_channels;
186    uint8_t* dst = wrk->dst;
187    rescaler_t* irow = wrk->irow;
188    const rescaler_t* frow = wrk->frow;
189    const int yscale = wrk->fy_scale * (-wrk->y_accum);
190    int temp0, temp1, temp3, temp4, temp5, loop_end;
191    const int temp2 = (int)wrk->fxy_scale;
192    const int temp6 = x_out_max << 2;
193    assert(!WebPRescalerOutputDone(wrk));
194    assert(wrk->y_accum <= 0);
195    assert(!wrk->y_expand);
196    assert(wrk->fxy_scale != 0);
197    if (yscale) {
198      __asm__ volatile (
199        "li       %[temp3],    0x10000                    \n\t"
200        "li       %[temp4],    0x8000                     \n\t"
201        "addu     %[loop_end], %[frow],     %[temp6]      \n\t"
202      "1:                                                 \n\t"
203        "lw       %[temp0],    0(%[frow])                 \n\t"
204        "mult     %[temp3],    %[temp4]                   \n\t"
205        "addiu    %[frow],     %[frow],     4             \n\t"
206        "maddu    %[temp0],    %[yscale]                  \n\t"
207        "mfhi     %[temp1]                                \n\t"
208        "lw       %[temp0],    0(%[irow])                 \n\t"
209        "addiu    %[dst],      %[dst],      1             \n\t"
210        "addiu    %[irow],     %[irow],     4             \n\t"
211        "subu     %[temp0],    %[temp0],    %[temp1]      \n\t"
212        "mult     %[temp3],    %[temp4]                   \n\t"
213        "maddu    %[temp0],    %[temp2]                   \n\t"
214        "mfhi     %[temp5]                                \n\t"
215        "sw       %[temp1],    -4(%[irow])                \n\t"
216        "sb       %[temp5],    -1(%[dst])                 \n\t"
217        "bne      %[frow],     %[loop_end], 1b            \n\t"
218        : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp3]"=&r"(temp3),
219          [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [frow]"+r"(frow),
220          [irow]"+r"(irow), [dst]"+r"(dst), [loop_end]"=&r"(loop_end)
221        : [temp2]"r"(temp2), [yscale]"r"(yscale), [temp6]"r"(temp6)
222        : "memory", "hi", "lo"
223      );
224    } else {
225      __asm__ volatile (
226        "li       %[temp3],    0x10000                    \n\t"
227        "li       %[temp4],    0x8000                     \n\t"
228        "addu     %[loop_end], %[irow],     %[temp6]      \n\t"
229      "1:                                                 \n\t"
230        "lw       %[temp0],    0(%[irow])                 \n\t"
231        "addiu    %[dst],      %[dst],      1             \n\t"
232        "addiu    %[irow],     %[irow],     4             \n\t"
233        "mult     %[temp3],    %[temp4]                   \n\t"
234        "maddu    %[temp0],    %[temp2]                   \n\t"
235        "mfhi     %[temp5]                                \n\t"
236        "sw       $zero,       -4(%[irow])                \n\t"
237        "sb       %[temp5],    -1(%[dst])                 \n\t"
238        "bne      %[irow],     %[loop_end], 1b            \n\t"
239        : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp3]"=&r"(temp3),
240          [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [irow]"+r"(irow),
241          [dst]"+r"(dst), [loop_end]"=&r"(loop_end)
242        : [temp2]"r"(temp2), [temp6]"r"(temp6)
243        : "memory", "hi", "lo"
244      );
245    }
246  }
247  #endif  
248  extern void WebPRescalerDspInitMIPS32(void);
249  WEBP_TSAN_IGNORE_FUNCTION void WebPRescalerDspInitMIPS32(void) {
250    WebPRescalerImportRowExpand = ImportRowExpand_MIPS32;
251    WebPRescalerImportRowShrink = ImportRowShrink_MIPS32;
252    WebPRescalerExportRowExpand = ExportRowExpand_MIPS32;
253  }
254  #else  
255  WEBP_DSP_INIT_STUB(WebPRescalerDspInitMIPS32)
256  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-verify-rdft2.c</h3>
            <pre><code>1  #include "verify.h"
2  typedef struct {
3       dotens2_closure k;
4       R *ra;
5       R *rb;
6  } cpyr_closure;
7  static void cpyr0(dotens2_closure *k_,
8                    int indxa, int ondxa, int indxb, int ondxb)
9  {
10       cpyr_closure *k = (cpyr_closure *)k_;
11       k->rb[indxb] = k->ra[ondxa];
12       UNUSED(indxa); UNUSED(ondxb);
13  }
14  static void cpyr(R *ra, const bench_tensor *sza, 
15  		 R *rb, const bench_tensor *szb)
16  {
17       cpyr_closure k;
18       k.k.apply = cpyr0;
19       k.ra = ra; k.rb = rb;
20       bench_dotens2(sza, szb, &k.k);
21  }
22  typedef struct {
23       dotens2_closure k;
24       int n;
25       int as;
26       int scalea;
27       R *ra, *ia;
28       R *rb, *ib;
29  } cpyhc2_closure;
30  static void cpyhc20(dotens2_closure *k_, 
31  		    int indxa, int ondxa, int indxb, int ondxb)
32  {
33       cpyhc2_closure *k = (cpyhc2_closure *)k_;
34       int i, n = k->n;
35       int scalea = k->scalea;
36       int as = k->as * scalea;
37       R *ra = k->ra + ondxa * scalea, *ia = k->ia + ondxa * scalea;
38       R *rb = k->rb + indxb, *ib = k->ib + indxb;
39       UNUSED(indxa); UNUSED(ondxb);
40       for (i = 0; i < n/2 + 1; ++i) {
41  	  rb[2*i] = ra[as*i];
42  	  ib[2*i] = ia[as*i];
43       }
44  }
45  static void cpyhc2(R *ra, R *ia,
46  		   const bench_tensor *sza, const bench_tensor *vecsza,
47  		   int scalea,
48  		   R *rb, R *ib, const bench_tensor *szb)
49  {
50       cpyhc2_closure k;
51       BENCH_ASSERT(sza->rnk <= 1);
52       k.k.apply = cpyhc20;
53       k.n = tensor_sz(sza);
54       k.scalea = scalea;
55       if (!BENCH_FINITE_RNK(sza->rnk) || sza->rnk == 0)
56  	  k.as = 0;
57       else
58  	  k.as = sza->dims[0].os;
59       k.ra = ra; k.ia = ia; k.rb = rb; k.ib = ib;
60       bench_dotens2(vecsza, szb, &k.k);
61  }
62  static void icpyhc20(dotens2_closure *k_, 
63  		     int indxa, int ondxa, int indxb, int ondxb)
64  {
<span onclick='openModal()' class='match'>65       cpyhc2_closure *k = (cpyhc2_closure *)k_;
66       int i, n = k->n;
67       int scalea = k->scalea;
68       int as = k->as * scalea;
69       R *ra = k->ra + indxa * scalea, *ia = k->ia + indxa * scalea;
</span>70       R *rb = k->rb + ondxb, *ib = k->ib + ondxb;
71       UNUSED(ondxa); UNUSED(indxb);
72       for (i = 0; i < n/2 + 1; ++i) {
73  	  ra[as*i] = rb[2*i];
74  	  ia[as*i] = ib[2*i];
75       }
76  }
77  static void icpyhc2(R *ra, R *ia, 
78  		    const bench_tensor *sza, const bench_tensor *vecsza,
79  		    int scalea,
80  		    R *rb, R *ib, const bench_tensor *szb)
81  {
82       cpyhc2_closure k;
83       BENCH_ASSERT(sza->rnk <= 1);
84       k.k.apply = icpyhc20;
85       k.n = tensor_sz(sza);
86       k.scalea = scalea;
87       if (!BENCH_FINITE_RNK(sza->rnk) || sza->rnk == 0)
88  	  k.as = 0;
89       else
90  	  k.as = sza->dims[0].is;
91       k.ra = ra; k.ia = ia; k.rb = rb; k.ib = ib;
92       bench_dotens2(vecsza, szb, &k.k);
93  }
94  typedef struct {
95       dofft_closure k;
96       bench_problem *p;
97  } dofft_rdft2_closure;
98  static void rdft2_apply(dofft_closure *k_, 
99  			bench_complex *in, bench_complex *out)
100  {
101       dofft_rdft2_closure *k = (dofft_rdft2_closure *)k_;
102       bench_problem *p = k->p;
103       bench_tensor *totalsz, *pckdsz, *totalsz_swap, *pckdsz_swap;
104       bench_tensor *probsz2, *totalsz2, *pckdsz2;
105       bench_tensor *probsz2_swap, *totalsz2_swap, *pckdsz2_swap;
106       bench_real *ri, *ii, *ro, *io;
107       int n2, totalscale;
108       totalsz = tensor_append(p->vecsz, p->sz);
109       pckdsz = verify_pack(totalsz, 2);
110       n2 = tensor_sz(totalsz);
111       if (BENCH_FINITE_RNK(p->sz->rnk) && p->sz->rnk > 0)
112  	  n2 = (n2 / p->sz->dims[p->sz->rnk - 1].n) * 
113  	       (p->sz->dims[p->sz->rnk - 1].n / 2 + 1);
114       ri = (bench_real *) p->in;
115       ro = (bench_real *) p->out;
116       if (BENCH_FINITE_RNK(p->sz->rnk) && p->sz->rnk > 0 && n2 > 0) {
117  	  probsz2 = tensor_copy_sub(p->sz, p->sz->rnk - 1, 1);
118  	  totalsz2 = tensor_copy_sub(totalsz, 0, totalsz->rnk - 1);
119  	  pckdsz2 = tensor_copy_sub(pckdsz, 0, pckdsz->rnk - 1);
120       }
121       else {
122  	  probsz2 = mktensor(0);
123  	  totalsz2 = tensor_copy(totalsz);
124  	  pckdsz2 = tensor_copy(pckdsz);
125       }
126       totalsz_swap = tensor_copy_swapio(totalsz);
127       pckdsz_swap = tensor_copy_swapio(pckdsz);
128       totalsz2_swap = tensor_copy_swapio(totalsz2);
129       pckdsz2_swap = tensor_copy_swapio(pckdsz2);
130       probsz2_swap = tensor_copy_swapio(probsz2);
131       if (p->split) {
132  	  ii = p->ini ? (bench_real *) p->ini : ri + n2;
133  	  io = p->outi ? (bench_real *) p->outi : ro + n2;
134  	  totalscale = 1;
135       } else {
136  	  ii = p->ini ? (bench_real *) p->ini : ri + 1;
137  	  io = p->outi ? (bench_real *) p->outi : ro + 1;
138  	  totalscale = 2;
139       }
140       if (p->sign < 0) { &bsol;* R2HC */
141  	  int N, vN, i;
142  	  cpyr(&c_re(in[0]), pckdsz, ri, totalsz);
143  	  after_problem_rcopy_from(p, ri);
144  	  doit(1, p);
145  	  after_problem_hccopy_to(p, ro, io);
146  	  if (k->k.recopy_input)
147  	       cpyr(ri, totalsz_swap, &c_re(in[0]), pckdsz_swap);
148  	  cpyhc2(ro, io, probsz2, totalsz2, totalscale,
149  		 &c_re(out[0]), &c_im(out[0]), pckdsz2);
150  	  N = tensor_sz(p->sz);
151  	  vN = tensor_sz(p->vecsz);
152  	  for (i = 0; i < vN; ++i)
153  	       mkhermitian(out + i*N, p->sz->rnk, p->sz->dims, 1);
154       }
155       else { &bsol;* HC2R */
156  	  icpyhc2(ri, ii, probsz2, totalsz2, totalscale,
157  		  &c_re(in[0]), &c_im(in[0]), pckdsz2);
158  	  after_problem_hccopy_from(p, ri, ii);
159  	  doit(1, p);
160  	  after_problem_rcopy_to(p, ro);
161  	  if (k->k.recopy_input)
162  	       cpyhc2(ri, ii, probsz2_swap, totalsz2_swap, totalscale,
163  		      &c_re(in[0]), &c_im(in[0]), pckdsz2_swap);
164  	  mkreal(out, tensor_sz(pckdsz));
165  	  cpyr(ro, totalsz, &c_re(out[0]), pckdsz);
166       }
167       tensor_destroy(totalsz);
168       tensor_destroy(pckdsz);
169       tensor_destroy(totalsz_swap);
170       tensor_destroy(pckdsz_swap);
171       tensor_destroy(probsz2);
172       tensor_destroy(totalsz2);
173       tensor_destroy(pckdsz2);
174       tensor_destroy(probsz2_swap);
175       tensor_destroy(totalsz2_swap);
176       tensor_destroy(pckdsz2_swap);
177  }
178  void verify_rdft2(bench_problem *p, int rounds, double tol, errors *e)
179  {
180       C *inA, *inB, *inC, *outA, *outB, *outC, *tmp;
181       int n, vecn, N;
182       dofft_rdft2_closure k;
183       BENCH_ASSERT(p->kind == PROBLEM_REAL);
184       if (!BENCH_FINITE_RNK(p->sz->rnk) || !BENCH_FINITE_RNK(p->vecsz->rnk))
185  	  return;      &bsol;* give up */
186       k.k.apply = rdft2_apply;
187       k.k.recopy_input = 0;
188       k.p = p;
189       if (rounds == 0)
190  	  rounds = 20;  &bsol;* default value */
191       n = tensor_sz(p->sz);
192       vecn = tensor_sz(p->vecsz);
193       N = n * vecn;
194       inA = (C *) bench_malloc(N * sizeof(C));
195       inB = (C *) bench_malloc(N * sizeof(C));
196       inC = (C *) bench_malloc(N * sizeof(C));
197       outA = (C *) bench_malloc(N * sizeof(C));
198       outB = (C *) bench_malloc(N * sizeof(C));
199       outC = (C *) bench_malloc(N * sizeof(C));
200       tmp = (C *) bench_malloc(N * sizeof(C));
201       e->i = impulse(&k.k, n, vecn, inA, inB, inC, outA, outB, outC, 
202  		    tmp, rounds, tol);
203       e->l = linear(&k.k, 1, N, inA, inB, inC, outA, outB, outC,
204  		   tmp, rounds, tol);
205       e->s = 0.0;
206       if (p->sign < 0)
207  	  e->s = dmax(e->s, tf_shift(&k.k, 1, p->sz, n, vecn, p->sign,
208  				     inA, inB, outA, outB, 
209  				     tmp, rounds, tol, TIME_SHIFT));
210       else
211  	  e->s = dmax(e->s, tf_shift(&k.k, 1, p->sz, n, vecn, p->sign,
212  				     inA, inB, outA, outB, 
213  				     tmp, rounds, tol, FREQ_SHIFT));
214       if (!p->in_place && !p->destroy_input)
215  	  preserves_input(&k.k, p->sign < 0 ? mkreal : mkhermitian1,
216  			  N, inA, inB, outB, rounds);
217       bench_free(tmp);
218       bench_free(outC);
219       bench_free(outB);
220       bench_free(outA);
221       bench_free(inC);
222       bench_free(inB);
223       bench_free(inA);
224  }
225  void accuracy_rdft2(bench_problem *p, int rounds, int impulse_rounds,
226  		    double t[6])
227  {
228       dofft_rdft2_closure k;
229       int n;
230       C *a, *b;
231       BENCH_ASSERT(p->kind == PROBLEM_REAL);
232       BENCH_ASSERT(p->sz->rnk == 1);
233       BENCH_ASSERT(p->vecsz->rnk == 0);
234       k.k.apply = rdft2_apply;
235       k.k.recopy_input = 0;
236       k.p = p;
237       n = tensor_sz(p->sz);
238       a = (C *) bench_malloc(n * sizeof(C));
239       b = (C *) bench_malloc(n * sizeof(C));
240       accuracy_test(&k.k, p->sign < 0 ? mkreal : mkhermitian1, p->sign, 
241  		   n, a, b, rounds, impulse_rounds, t);
242       bench_free(b);
243       bench_free(a);
244  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_mips32.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-verify-rdft2.c</div>
                </div>
                <div class="column column_space"><pre><code>63                                     const uint8_t* src) {
64    const int x_stride = wrk->num_channels;
65    const int x_out_max = wrk->dst_width * wrk->num_channels;
66    const int x_add = wrk->x_add;
67    const int x_sub = wrk->x_sub;
</pre></code></div>
                <div class="column column_space"><pre><code>65       cpyhc2_closure *k = (cpyhc2_closure *)k_;
66       int i, n = k->n;
67       int scalea = k->scalea;
68       int as = k->as * scalea;
69       R *ra = k->ra + indxa * scalea, *ia = k->ia + indxa * scalea;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    