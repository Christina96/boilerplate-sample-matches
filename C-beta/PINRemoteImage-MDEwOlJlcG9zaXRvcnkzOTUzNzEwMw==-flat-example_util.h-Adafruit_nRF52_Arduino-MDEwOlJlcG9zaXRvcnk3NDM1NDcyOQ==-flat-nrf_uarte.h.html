
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.675213675213676%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-example_util.h</h3>
            <pre><code>1  #ifndef WEBP_EXAMPLES_EXAMPLE_UTIL_H_
2  #define WEBP_EXAMPLES_EXAMPLE_UTIL_H_
3  #include "webp/types.h"
4  #include "webp/mux_types.h"
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  uint32_t ExUtilGetUInt(const char* const v, int base, int* const error);
9  int ExUtilGetInt(const char* const v, int base, int* const error);
10  float ExUtilGetFloat(const char* const v, int* const error);
11  int ExUtilGetInts(const char* v, int base, int max_output, int output[]);
12  int ExUtilReadFileToWebPData(const char* const filename,
13                               WebPData* const webp_data);
<span onclick='openModal()' class='match'>14  typedef struct {
15    int argc_;
16    const char** argv_;
17    WebPData argv_data_;
18    int own_argv_;
19  } CommandLineArguments;
20  int ExUtilInitCommandLineArguments(int argc, const char* argv[],
21                                     CommandLineArguments* const args);
22  void ExUtilDeleteCommandLineArguments(CommandLineArguments* const args);
</span>23  #ifdef __cplusplus
24  }    
25  #endif
26  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_uarte.h</h3>
            <pre><code>1  #ifndef NRF_UARTE_H__
2  #define NRF_UARTE_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_UARTE_PSEL_DISCONNECTED 0xFFFFFFFF
8  typedef enum
9  {
10      NRF_UARTE_TASK_STARTRX   = offsetof(NRF_UARTE_Type, TASKS_STARTRX), 
11      NRF_UARTE_TASK_STOPRX    = offsetof(NRF_UARTE_Type, TASKS_STOPRX),  
12      NRF_UARTE_TASK_STARTTX   = offsetof(NRF_UARTE_Type, TASKS_STARTTX), 
13      NRF_UARTE_TASK_STOPTX    = offsetof(NRF_UARTE_Type, TASKS_STOPTX),  
14      NRF_UARTE_TASK_FLUSHRX   = offsetof(NRF_UARTE_Type, TASKS_FLUSHRX)  
15  } nrf_uarte_task_t;
16  typedef enum
17  {
18      NRF_UARTE_EVENT_CTS       = offsetof(NRF_UARTE_Type, EVENTS_CTS),       
19      NRF_UARTE_EVENT_NCTS      = offsetof(NRF_UARTE_Type, EVENTS_NCTS),      
20      NRF_UARTE_EVENT_RXDRDY    = offsetof(NRF_UARTE_Type, EVENTS_RXDRDY),    
21      NRF_UARTE_EVENT_ENDRX     = offsetof(NRF_UARTE_Type, EVENTS_ENDRX),     
22      NRF_UARTE_EVENT_TXDRDY    = offsetof(NRF_UARTE_Type, EVENTS_TXDRDY),    
23      NRF_UARTE_EVENT_ENDTX     = offsetof(NRF_UARTE_Type, EVENTS_ENDTX),     
24      NRF_UARTE_EVENT_ERROR     = offsetof(NRF_UARTE_Type, EVENTS_ERROR),     
25      NRF_UARTE_EVENT_RXTO      = offsetof(NRF_UARTE_Type, EVENTS_RXTO),      
26      NRF_UARTE_EVENT_RXSTARTED = offsetof(NRF_UARTE_Type, EVENTS_RXSTARTED), 
27      NRF_UARTE_EVENT_TXSTARTED = offsetof(NRF_UARTE_Type, EVENTS_TXSTARTED), 
28      NRF_UARTE_EVENT_TXSTOPPED = offsetof(NRF_UARTE_Type, EVENTS_TXSTOPPED)  
29  } nrf_uarte_event_t;
30  typedef enum
31  {
32      NRF_UARTE_SHORT_ENDRX_STARTRX = UARTE_SHORTS_ENDRX_STARTRX_Msk, 
33      NRF_UARTE_SHORT_ENDRX_STOPRX  = UARTE_SHORTS_ENDRX_STOPRX_Msk   
34  } nrf_uarte_short_t;
35  typedef enum
36  {
37      NRF_UARTE_INT_CTS_MASK       = UARTE_INTENSET_CTS_Msk,       
38      NRF_UARTE_INT_NCTS_MASK      = UARTE_INTENSET_NCTS_Msk,      
39      NRF_UARTE_INT_RXDRDY_MASK    = UARTE_INTENSET_RXDRDY_Msk,    
40      NRF_UARTE_INT_ENDRX_MASK     = UARTE_INTENSET_ENDRX_Msk,     
41      NRF_UARTE_INT_TXDRDY_MASK    = UARTE_INTENSET_TXDRDY_Msk,    
42      NRF_UARTE_INT_ENDTX_MASK     = UARTE_INTENSET_ENDTX_Msk,     
43      NRF_UARTE_INT_ERROR_MASK     = UARTE_INTENSET_ERROR_Msk,     
44      NRF_UARTE_INT_RXTO_MASK      = UARTE_INTENSET_RXTO_Msk,      
45      NRF_UARTE_INT_RXSTARTED_MASK = UARTE_INTENSET_RXSTARTED_Msk, 
46      NRF_UARTE_INT_TXSTARTED_MASK = UARTE_INTENSET_TXSTARTED_Msk, 
47      NRF_UARTE_INT_TXSTOPPED_MASK = UARTE_INTENSET_TXSTOPPED_Msk  
48  } nrf_uarte_int_mask_t;
49  typedef enum
50  {
51      NRF_UARTE_BAUDRATE_1200    = UARTE_BAUDRATE_BAUDRATE_Baud1200,   
52      NRF_UARTE_BAUDRATE_2400    = UARTE_BAUDRATE_BAUDRATE_Baud2400,   
53      NRF_UARTE_BAUDRATE_4800    = UARTE_BAUDRATE_BAUDRATE_Baud4800,   
54      NRF_UARTE_BAUDRATE_9600    = UARTE_BAUDRATE_BAUDRATE_Baud9600,   
55      NRF_UARTE_BAUDRATE_14400   = UARTE_BAUDRATE_BAUDRATE_Baud14400,  
56      NRF_UARTE_BAUDRATE_19200   = UARTE_BAUDRATE_BAUDRATE_Baud19200,  
57      NRF_UARTE_BAUDRATE_28800   = UARTE_BAUDRATE_BAUDRATE_Baud28800,  
58      NRF_UARTE_BAUDRATE_31250   = UARTE_BAUDRATE_BAUDRATE_Baud31250,  
59      NRF_UARTE_BAUDRATE_38400   = UARTE_BAUDRATE_BAUDRATE_Baud38400,  
60      NRF_UARTE_BAUDRATE_56000   = UARTE_BAUDRATE_BAUDRATE_Baud56000,  
61      NRF_UARTE_BAUDRATE_57600   = UARTE_BAUDRATE_BAUDRATE_Baud57600,  
62      NRF_UARTE_BAUDRATE_76800   = UARTE_BAUDRATE_BAUDRATE_Baud76800,  
63      NRF_UARTE_BAUDRATE_115200  = UARTE_BAUDRATE_BAUDRATE_Baud115200, 
64      NRF_UARTE_BAUDRATE_230400  = UARTE_BAUDRATE_BAUDRATE_Baud230400, 
65      NRF_UARTE_BAUDRATE_250000  = UARTE_BAUDRATE_BAUDRATE_Baud250000, 
66      NRF_UARTE_BAUDRATE_460800  = UARTE_BAUDRATE_BAUDRATE_Baud460800, 
67      NRF_UARTE_BAUDRATE_921600  = UARTE_BAUDRATE_BAUDRATE_Baud921600, 
68      NRF_UARTE_BAUDRATE_1000000 = UARTE_BAUDRATE_BAUDRATE_Baud1M      
69  } nrf_uarte_baudrate_t;
70  typedef enum
71  {
72      NRF_UARTE_ERROR_OVERRUN_MASK = UARTE_ERRORSRC_OVERRUN_Msk, 
73      NRF_UARTE_ERROR_PARITY_MASK  = UARTE_ERRORSRC_PARITY_Msk,  
74      NRF_UARTE_ERROR_FRAMING_MASK = UARTE_ERRORSRC_FRAMING_Msk, 
75      NRF_UARTE_ERROR_BREAK_MASK   = UARTE_ERRORSRC_BREAK_Msk    
76  } nrf_uarte_error_mask_t;
77  typedef enum
78  {
79      NRF_UARTE_PARITY_EXCLUDED = UARTE_CONFIG_PARITY_Excluded << UARTE_CONFIG_PARITY_Pos, 
80      NRF_UARTE_PARITY_INCLUDED = UARTE_CONFIG_PARITY_Included << UARTE_CONFIG_PARITY_Pos  
81  } nrf_uarte_parity_t;
82  typedef enum
83  {
84      NRF_UARTE_HWFC_DISABLED = UARTE_CONFIG_HWFC_Disabled << UARTE_CONFIG_HWFC_Pos, 
85      NRF_UARTE_HWFC_ENABLED  = UARTE_CONFIG_HWFC_Enabled  << UARTE_CONFIG_HWFC_Pos  
86  } nrf_uarte_hwfc_t;
87  #if defined(UARTE_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
88  typedef enum
89  {
90      NRF_UARTE_STOP_ONE = UARTE_CONFIG_STOP_One << UARTE_CONFIG_STOP_Pos, 
91      NRF_UARTE_STOP_TWO = UARTE_CONFIG_STOP_Two << UARTE_CONFIG_STOP_Pos  
92  } nrf_uarte_stop_t;
93  #endif
94  #if defined(UARTE_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
95  typedef enum
96  {
97      NRF_UARTE_PARITYTYPE_EVEN = UARTE_CONFIG_PARITYTYPE_Even << UARTE_CONFIG_PARITYTYPE_Pos, 
98      NRF_UARTE_PARITYTYPE_ODD  = UARTE_CONFIG_PARITYTYPE_Odd << UARTE_CONFIG_PARITYTYPE_Pos,  
99  } nrf_uarte_paritytype_t;
100  #endif
<span onclick='openModal()' class='match'>101  typedef struct
102  {
103      nrf_uarte_hwfc_t       hwfc;       
104      nrf_uarte_parity_t     parity;     
105  #if defined(UARTE_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
106      nrf_uarte_stop_t       stop;       
107  #endif
108  #if defined(UARTE_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
109      nrf_uarte_paritytype_t paritytype; 
110  #endif
111  } nrf_uarte_config_t;
112  NRF_STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event);
113  NRF_STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type const * p_reg,
114                                               nrf_uarte_event_t      event);
</span>115  NRF_STATIC_INLINE uint32_t nrf_uarte_event_address_get(NRF_UARTE_Type const * p_reg,
116                                                         nrf_uarte_event_t      event);
117  NRF_STATIC_INLINE void nrf_uarte_shorts_enable(NRF_UARTE_Type * p_reg, uint32_t mask);
118  NRF_STATIC_INLINE void nrf_uarte_shorts_disable(NRF_UARTE_Type * p_reg, uint32_t mask);
119  NRF_STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type * p_reg, uint32_t mask);
120  NRF_STATIC_INLINE uint32_t nrf_uarte_int_enable_check(NRF_UARTE_Type const * p_reg, uint32_t mask);
121  NRF_STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type * p_reg, uint32_t mask);
122  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
123  NRF_STATIC_INLINE void nrf_uarte_subscribe_set(NRF_UARTE_Type * p_reg,
124                                                 nrf_uarte_task_t task,
125                                                 uint8_t          channel);
126  NRF_STATIC_INLINE void nrf_uarte_subscribe_clear(NRF_UARTE_Type * p_reg,
127                                                   nrf_uarte_task_t task);
128  NRF_STATIC_INLINE void nrf_uarte_publish_set(NRF_UARTE_Type *  p_reg,
129                                               nrf_uarte_event_t event,
130                                               uint8_t           channel);
131  NRF_STATIC_INLINE void nrf_uarte_publish_clear(NRF_UARTE_Type *  p_reg,
132                                                 nrf_uarte_event_t event);
133  #endif 
134  NRF_STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type * p_reg);
135  NRF_STATIC_INLINE void nrf_uarte_enable(NRF_UARTE_Type * p_reg);
136  NRF_STATIC_INLINE void nrf_uarte_disable(NRF_UARTE_Type * p_reg);
137  NRF_STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type * p_reg,
138                                                 uint32_t         pseltxd,
139                                                 uint32_t         pselrxd);
140  NRF_STATIC_INLINE void nrf_uarte_txrx_pins_disconnect(NRF_UARTE_Type * p_reg);
141  NRF_STATIC_INLINE uint32_t nrf_uarte_tx_pin_get(NRF_UARTE_Type const * p_reg);
142  NRF_STATIC_INLINE uint32_t nrf_uarte_rx_pin_get(NRF_UARTE_Type const * p_reg);
143  NRF_STATIC_INLINE uint32_t nrf_uarte_rts_pin_get(NRF_UARTE_Type const * p_reg);
144  NRF_STATIC_INLINE uint32_t nrf_uarte_cts_pin_get(NRF_UARTE_Type const * p_reg);
145  NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type * p_reg,
146                                                 uint32_t         pselrts,
147                                                 uint32_t         pselcts);
148  NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_disconnect(NRF_UARTE_Type * p_reg);
149  NRF_STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type * p_reg, nrf_uarte_task_t task);
150  NRF_STATIC_INLINE uint32_t nrf_uarte_task_address_get(NRF_UARTE_Type const * p_reg,
151                                                        nrf_uarte_task_t       task);
152  NRF_STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type           * p_reg,
153                                             nrf_uarte_config_t const * p_cfg);
154  NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type *     p_reg,
155                                                nrf_uarte_baudrate_t baudrate);
156  NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
157                                                 uint8_t  const * p_buffer,
158                                                 size_t           length);
159  NRF_STATIC_INLINE uint32_t nrf_uarte_tx_amount_get(NRF_UARTE_Type const * p_reg);
160  NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
161                                                 uint8_t *        p_buffer,
162                                                 size_t           length);
163  NRF_STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type const * p_reg);
164  #ifndef NRF_DECLARE_ONLY
165  NRF_STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event)
166  {
167      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
168  #if __CORTEX_M == 0x04
169      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
170      (void)dummy;
171  #endif
172  }
173  NRF_STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type const * p_reg,
174                                               nrf_uarte_event_t      event)
175  {
176      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
177  }
178  NRF_STATIC_INLINE uint32_t nrf_uarte_event_address_get(NRF_UARTE_Type const * p_reg,
179                                                         nrf_uarte_event_t      event)
180  {
181      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
182  }
183  NRF_STATIC_INLINE void nrf_uarte_shorts_enable(NRF_UARTE_Type * p_reg, uint32_t mask)
184  {
185      p_reg->SHORTS |= mask;
186  }
187  NRF_STATIC_INLINE void nrf_uarte_shorts_disable(NRF_UARTE_Type * p_reg, uint32_t mask)
188  {
189      p_reg->SHORTS &= ~(mask);
190  }
191  NRF_STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type * p_reg, uint32_t mask)
192  {
193      p_reg->INTENSET = mask;
194  }
195  NRF_STATIC_INLINE uint32_t nrf_uarte_int_enable_check(NRF_UARTE_Type const * p_reg, uint32_t mask)
196  {
197      return p_reg->INTENSET & mask;
198  }
199  NRF_STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type * p_reg, uint32_t mask)
200  {
201      p_reg->INTENCLR = mask;
202  }
203  #if defined(DPPI_PRESENT)
204  NRF_STATIC_INLINE void nrf_uarte_subscribe_set(NRF_UARTE_Type * p_reg,
205                                                 nrf_uarte_task_t task,
206                                                 uint8_t          channel)
207  {
208      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
209              ((uint32_t)channel | UARTE_SUBSCRIBE_STARTRX_EN_Msk);
210  }
211  NRF_STATIC_INLINE void nrf_uarte_subscribe_clear(NRF_UARTE_Type * p_reg,
212                                                   nrf_uarte_task_t task)
213  {
214      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
215  }
216  NRF_STATIC_INLINE void nrf_uarte_publish_set(NRF_UARTE_Type *  p_reg,
217                                               nrf_uarte_event_t event,
218                                               uint8_t           channel)
219  {
220      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
221              ((uint32_t)channel | UARTE_PUBLISH_CTS_EN_Msk);
222  }
223  NRF_STATIC_INLINE void nrf_uarte_publish_clear(NRF_UARTE_Type *  p_reg,
224                                                 nrf_uarte_event_t event)
225  {
226      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
227  }
228  #endif 
229  NRF_STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type * p_reg)
230  {
231      uint32_t errsrc_mask = p_reg->ERRORSRC;
232      p_reg->ERRORSRC = errsrc_mask;
233      return errsrc_mask;
234  }
235  NRF_STATIC_INLINE void nrf_uarte_enable(NRF_UARTE_Type * p_reg)
236  {
237      p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
238  }
239  NRF_STATIC_INLINE void nrf_uarte_disable(NRF_UARTE_Type * p_reg)
240  {
241      p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
242  }
243  NRF_STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type * p_reg,
244                                                 uint32_t         pseltxd,
245                                                 uint32_t         pselrxd)
246  {
247      p_reg->PSEL.TXD = pseltxd;
248      p_reg->PSEL.RXD = pselrxd;
249  }
250  NRF_STATIC_INLINE void nrf_uarte_txrx_pins_disconnect(NRF_UARTE_Type * p_reg)
251  {
252      nrf_uarte_txrx_pins_set(p_reg, NRF_UARTE_PSEL_DISCONNECTED, NRF_UARTE_PSEL_DISCONNECTED);
253  }
254  NRF_STATIC_INLINE uint32_t nrf_uarte_tx_pin_get(NRF_UARTE_Type const * p_reg)
255  {
256      return p_reg->PSEL.TXD;
257  }
258  NRF_STATIC_INLINE uint32_t nrf_uarte_rx_pin_get(NRF_UARTE_Type const * p_reg)
259  {
260      return p_reg->PSEL.RXD;
261  }
262  NRF_STATIC_INLINE uint32_t nrf_uarte_rts_pin_get(NRF_UARTE_Type const * p_reg)
263  {
264      return p_reg->PSEL.RTS;
265  }
266  NRF_STATIC_INLINE uint32_t nrf_uarte_cts_pin_get(NRF_UARTE_Type const * p_reg)
267  {
268      return p_reg->PSEL.CTS;
269  }
270  NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type * p_reg,
271                                                 uint32_t         pselrts,
272                                                 uint32_t         pselcts)
273  {
274      p_reg->PSEL.RTS = pselrts;
275      p_reg->PSEL.CTS = pselcts;
276  }
277  NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_disconnect(NRF_UARTE_Type * p_reg)
278  {
279      nrf_uarte_hwfc_pins_set(p_reg, NRF_UARTE_PSEL_DISCONNECTED, NRF_UARTE_PSEL_DISCONNECTED);
280  }
281  NRF_STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type * p_reg, nrf_uarte_task_t task)
282  {
283      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
284  }
285  NRF_STATIC_INLINE uint32_t nrf_uarte_task_address_get(NRF_UARTE_Type const * p_reg,
286                                                        nrf_uarte_task_t       task)
287  {
288      return (uint32_t)p_reg + (uint32_t)task;
289  }
290  NRF_STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type           * p_reg,
291                                             nrf_uarte_config_t const * p_cfg)
292  {
293      p_reg->CONFIG = (uint32_t)p_cfg->parity
294  #if defined(UARTE_CONFIG_STOP_Msk)
295                      | (uint32_t)p_cfg->stop
296  #endif
297  #if defined(UARTE_CONFIG_PARITYTYPE_Msk)
298                      | (uint32_t)p_cfg->paritytype
299  #endif
300                      | (uint32_t)p_cfg->hwfc;
301  }
302  NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
303  {
304      p_reg->BAUDRATE = baudrate;
305  }
306  NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
307                                                 uint8_t  const * p_buffer,
308                                                 size_t           length)
309  {
310      p_reg->TXD.PTR    = (uint32_t)p_buffer;
311      p_reg->TXD.MAXCNT = length;
312  }
313  NRF_STATIC_INLINE uint32_t nrf_uarte_tx_amount_get(NRF_UARTE_Type const * p_reg)
314  {
315      return p_reg->TXD.AMOUNT;
316  }
317  NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
318                                                 uint8_t *        p_buffer,
319                                                 size_t           length)
320  {
321      p_reg->RXD.PTR    = (uint32_t)p_buffer;
322      p_reg->RXD.MAXCNT = length;
323  }
324  NRF_STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type const * p_reg)
325  {
326      return p_reg->RXD.AMOUNT;
327  }
328  #endif 
329  #ifdef __cplusplus
330  }
331  #endif
332  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-example_util.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_uarte.h</div>
                </div>
                <div class="column column_space"><pre><code>14  typedef struct {
15    int argc_;
16    const char** argv_;
17    WebPData argv_data_;
18    int own_argv_;
19  } CommandLineArguments;
20  int ExUtilInitCommandLineArguments(int argc, const char* argv[],
21                                     CommandLineArguments* const args);
22  void ExUtilDeleteCommandLineArguments(CommandLineArguments* const args);
</pre></code></div>
                <div class="column column_space"><pre><code>101  typedef struct
102  {
103      nrf_uarte_hwfc_t       hwfc;       
104      nrf_uarte_parity_t     parity;     
105  #if defined(UARTE_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
106      nrf_uarte_stop_t       stop;       
107  #endif
108  #if defined(UARTE_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
109      nrf_uarte_paritytype_t paritytype; 
110  #endif
111  } nrf_uarte_config_t;
112  NRF_STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event);
113  NRF_STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type const * p_reg,
114                                               nrf_uarte_event_t      event);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    