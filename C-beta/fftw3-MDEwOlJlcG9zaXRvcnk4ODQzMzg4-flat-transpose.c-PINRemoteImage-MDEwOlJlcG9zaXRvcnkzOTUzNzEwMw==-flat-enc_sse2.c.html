
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.592045920459205%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-transpose.c</h3>
            <pre><code>1  #include "kernel/ifftw.h"
2  void X(transpose)(R *I, INT n, INT s0, INT s1, INT vl)
3  {
4       INT i0, i1, v;
5       switch (vl) {
6  	 case 1:
7  	      for (i1 = 1; i1 < n; ++i1) {
8  		   for (i0 = 0; i0 < i1; ++i0) {
9  			R x0 = I[i1 * s0 + i0 * s1];
10  			R y0 = I[i1 * s1 + i0 * s0];
11  			I[i1 * s1 + i0 * s0] = x0;
12  			I[i1 * s0 + i0 * s1] = y0;
13  		   }
14  	      }
15  	      break;
16  	 case 2:
17  	      for (i1 = 1; i1 < n; ++i1) {
18  		   for (i0 = 0; i0 < i1; ++i0) {
19  			R x0 = I[i1 * s0 + i0 * s1];
20  			R x1 = I[i1 * s0 + i0 * s1 + 1];
21  			R y0 = I[i1 * s1 + i0 * s0];
22  			R y1 = I[i1 * s1 + i0 * s0 + 1];
23  			I[i1 * s1 + i0 * s0] = x0;
24  			I[i1 * s1 + i0 * s0 + 1] = x1;
25  			I[i1 * s0 + i0 * s1] = y0;
26  			I[i1 * s0 + i0 * s1 + 1] = y1;
27  		   }
28  	      }
29  	      break;
30  	 default:
31  	      for (i1 = 1; i1 < n; ++i1) {
32  		   for (i0 = 0; i0 < i1; ++i0) {
33  			for (v = 0; v < vl; ++v) {
34  			     R x0 = I[i1 * s0 + i0 * s1 + v];
35  			     R y0 = I[i1 * s1 + i0 * s0 + v];
36  			     I[i1 * s1 + i0 * s0 + v] = x0;
37  			     I[i1 * s0 + i0 * s1 + v] = y0;
38  			}
39  		   }
40  	      }
41  	      break;
42       }
43  }
44  struct transpose_closure {
45       R *I;
46       INT s0, s1, vl, tilesz;
47       R *buf0, *buf1; 
48  };
<span onclick='openModal()' class='match'>49  static void dotile(INT n0l, INT n0u, INT n1l, INT n1u, void *args)
50  {
51       struct transpose_closure *k = (struct transpose_closure *)args;
52       R *I = k->I;
53       INT s0 = k->s0, s1 = k->s1, vl = k->vl;
</span>54       INT i0, i1, v;
55       switch (vl) {
56  	 case 1:
57  	      for (i1 = n1l; i1 < n1u; ++i1) {
58  		   for (i0 = n0l; i0 < n0u; ++i0) {
59  			R x0 = I[i1 * s0 + i0 * s1];
60  			R y0 = I[i1 * s1 + i0 * s0];
61  			I[i1 * s1 + i0 * s0] = x0;
62  			I[i1 * s0 + i0 * s1] = y0;
63  		   }
64  	      }
65  	      break;
66  	 case 2:
67  	      for (i1 = n1l; i1 < n1u; ++i1) {
68  		   for (i0 = n0l; i0 < n0u; ++i0) {
69  			R x0 = I[i1 * s0 + i0 * s1];
70  			R x1 = I[i1 * s0 + i0 * s1 + 1];
71  			R y0 = I[i1 * s1 + i0 * s0];
72  			R y1 = I[i1 * s1 + i0 * s0 + 1];
73  			I[i1 * s1 + i0 * s0] = x0;
74  			I[i1 * s1 + i0 * s0 + 1] = x1;
75  			I[i1 * s0 + i0 * s1] = y0;
76  			I[i1 * s0 + i0 * s1 + 1] = y1;
77  		   }
78  	      }
79  	      break;
80  	 default:
81  	      for (i1 = n1l; i1 < n1u; ++i1) {
82  		   for (i0 = n0l; i0 < n0u; ++i0) {
83  			for (v = 0; v < vl; ++v) {
84  			     R x0 = I[i1 * s0 + i0 * s1 + v];
85  			     R y0 = I[i1 * s1 + i0 * s0 + v];
86  			     I[i1 * s1 + i0 * s0 + v] = x0;
87  			     I[i1 * s0 + i0 * s1 + v] = y0;
88  			}
89  		   }
90  	      }
91       }
92  }
93  static void dotile_buf(INT n0l, INT n0u, INT n1l, INT n1u, void *args)
94  {
95       struct transpose_closure *k = (struct transpose_closure *)args;
96       X(cpy2d_ci)(k->I + n0l * k->s0 + n1l * k->s1,
97  		 k->buf0,
98  		 n0u - n0l, k->s0, k->vl,
99  		 n1u - n1l, k->s1, k->vl * (n0u - n0l),
100  		 k->vl);
101       X(cpy2d_ci)(k->I + n0l * k->s1 + n1l * k->s0,
102  		 k->buf1,
103  		 n0u - n0l, k->s1, k->vl,
104  		 n1u - n1l, k->s0, k->vl * (n0u - n0l),
105  		 k->vl);
106       X(cpy2d_co)(k->buf1,
107  		 k->I + n0l * k->s0 + n1l * k->s1,
108  		 n0u - n0l, k->vl, k->s0,
109  		 n1u - n1l, k->vl * (n0u - n0l), k->s1,
110  		 k->vl);
111       X(cpy2d_co)(k->buf0,
112  		 k->I + n0l * k->s1 + n1l * k->s0,
113  		 n0u - n0l, k->vl, k->s1,
114  		 n1u - n1l, k->vl * (n0u - n0l), k->s0,
115  		 k->vl);
116  }
117  static void transpose_rec(R *I, INT n,
118  			  void (*f)(INT n0l, INT n0u, INT n1l, INT n1u,
119  				    void *args),
120  			  struct transpose_closure *k)
121  {
122     tail:
123       if (n > 1) {
124  	  INT n2 = n / 2;
125  	  k->I = I;
126  	  X(tile2d)(0, n2, n2, n, k->tilesz, f, k);
127  	  transpose_rec(I, n2, f, k);
128  	  I += n2 * (k->s0 + k->s1); n -= n2; goto tail;
129       }
130  }
131  void X(transpose_tiled)(R *I, INT n, INT s0, INT s1, INT vl) 
132  {
133       struct transpose_closure k;
134       k.s0 = s0;
135       k.s1 = s1;
136       k.vl = vl;
137       k.tilesz = X(compute_tilesz)(vl, 2);
138       k.buf0 = k.buf1 = 0; &bsol;* unused */
139       transpose_rec(I, n, dotile, &k);
140  }
141  void X(transpose_tiledbuf)(R *I, INT n, INT s0, INT s1, INT vl) 
142  {
143       struct transpose_closure k;
144       R buf0[CACHESIZE / (2 * sizeof(R))];
145       R buf1[CACHESIZE / (2 * sizeof(R))];
146       k.s0 = s0;
147       k.s1 = s1;
148       k.vl = vl;
149       k.tilesz = X(compute_tilesz)(vl, 2);
150       k.buf0 = buf0;
151       k.buf1 = buf1;
152       A(k.tilesz * k.tilesz * vl * sizeof(R) <= sizeof(buf0));
153       A(k.tilesz * k.tilesz * vl * sizeof(R) <= sizeof(buf1));
154       transpose_rec(I, n, dotile_buf, &k);
155  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #include <assert.h>
4  #include <stdlib.h>  
5  #include <emmintrin.h>
6  #include "src/dsp/common_sse2.h"
7  #include "src/enc/cost_enc.h"
8  #include "src/enc/vp8i_enc.h"
9  static void ITransform_SSE2(const uint8_t* ref, const int16_t* in, uint8_t* dst,
10                              int do_two) {
11    const __m128i k1 = _mm_set1_epi16(20091);
12    const __m128i k2 = _mm_set1_epi16(-30068);
13    __m128i T0, T1, T2, T3;
14    __m128i in0, in1, in2, in3;
15    {
16      in0 = _mm_loadl_epi64((const __m128i*)&in[0]);
17      in1 = _mm_loadl_epi64((const __m128i*)&in[4]);
18      in2 = _mm_loadl_epi64((const __m128i*)&in[8]);
19      in3 = _mm_loadl_epi64((const __m128i*)&in[12]);
20      if (do_two) {
21        const __m128i inB0 = _mm_loadl_epi64((const __m128i*)&in[16]);
22        const __m128i inB1 = _mm_loadl_epi64((const __m128i*)&in[20]);
23        const __m128i inB2 = _mm_loadl_epi64((const __m128i*)&in[24]);
24        const __m128i inB3 = _mm_loadl_epi64((const __m128i*)&in[28]);
25        in0 = _mm_unpacklo_epi64(in0, inB0);
26        in1 = _mm_unpacklo_epi64(in1, inB1);
27        in2 = _mm_unpacklo_epi64(in2, inB2);
28        in3 = _mm_unpacklo_epi64(in3, inB3);
29      }
30    }
31    {
32      const __m128i a = _mm_add_epi16(in0, in2);
33      const __m128i b = _mm_sub_epi16(in0, in2);
34      const __m128i c1 = _mm_mulhi_epi16(in1, k2);
35      const __m128i c2 = _mm_mulhi_epi16(in3, k1);
36      const __m128i c3 = _mm_sub_epi16(in1, in3);
37      const __m128i c4 = _mm_sub_epi16(c1, c2);
38      const __m128i c = _mm_add_epi16(c3, c4);
39      const __m128i d1 = _mm_mulhi_epi16(in1, k1);
40      const __m128i d2 = _mm_mulhi_epi16(in3, k2);
41      const __m128i d3 = _mm_add_epi16(in1, in3);
42      const __m128i d4 = _mm_add_epi16(d1, d2);
43      const __m128i d = _mm_add_epi16(d3, d4);
44      const __m128i tmp0 = _mm_add_epi16(a, d);
45      const __m128i tmp1 = _mm_add_epi16(b, c);
46      const __m128i tmp2 = _mm_sub_epi16(b, c);
47      const __m128i tmp3 = _mm_sub_epi16(a, d);
48      VP8Transpose_2_4x4_16b(&tmp0, &tmp1, &tmp2, &tmp3, &T0, &T1, &T2, &T3);
49    }
50    {
51      const __m128i four = _mm_set1_epi16(4);
52      const __m128i dc = _mm_add_epi16(T0, four);
53      const __m128i a =  _mm_add_epi16(dc, T2);
54      const __m128i b =  _mm_sub_epi16(dc, T2);
55      const __m128i c1 = _mm_mulhi_epi16(T1, k2);
56      const __m128i c2 = _mm_mulhi_epi16(T3, k1);
57      const __m128i c3 = _mm_sub_epi16(T1, T3);
58      const __m128i c4 = _mm_sub_epi16(c1, c2);
59      const __m128i c = _mm_add_epi16(c3, c4);
60      const __m128i d1 = _mm_mulhi_epi16(T1, k1);
61      const __m128i d2 = _mm_mulhi_epi16(T3, k2);
62      const __m128i d3 = _mm_add_epi16(T1, T3);
63      const __m128i d4 = _mm_add_epi16(d1, d2);
64      const __m128i d = _mm_add_epi16(d3, d4);
65      const __m128i tmp0 = _mm_add_epi16(a, d);
66      const __m128i tmp1 = _mm_add_epi16(b, c);
67      const __m128i tmp2 = _mm_sub_epi16(b, c);
68      const __m128i tmp3 = _mm_sub_epi16(a, d);
69      const __m128i shifted0 = _mm_srai_epi16(tmp0, 3);
70      const __m128i shifted1 = _mm_srai_epi16(tmp1, 3);
71      const __m128i shifted2 = _mm_srai_epi16(tmp2, 3);
72      const __m128i shifted3 = _mm_srai_epi16(tmp3, 3);
73      VP8Transpose_2_4x4_16b(&shifted0, &shifted1, &shifted2, &shifted3, &T0, &T1,
74                             &T2, &T3);
75    }
76    {
77      const __m128i zero = _mm_setzero_si128();
78      __m128i ref0, ref1, ref2, ref3;
79      if (do_two) {
80        ref0 = _mm_loadl_epi64((const __m128i*)&ref[0 * BPS]);
81        ref1 = _mm_loadl_epi64((const __m128i*)&ref[1 * BPS]);
82        ref2 = _mm_loadl_epi64((const __m128i*)&ref[2 * BPS]);
83        ref3 = _mm_loadl_epi64((const __m128i*)&ref[3 * BPS]);
84      } else {
85        ref0 = _mm_cvtsi32_si128(WebPMemToUint32(&ref[0 * BPS]));
86        ref1 = _mm_cvtsi32_si128(WebPMemToUint32(&ref[1 * BPS]));
87        ref2 = _mm_cvtsi32_si128(WebPMemToUint32(&ref[2 * BPS]));
88        ref3 = _mm_cvtsi32_si128(WebPMemToUint32(&ref[3 * BPS]));
89      }
90      ref0 = _mm_unpacklo_epi8(ref0, zero);
91      ref1 = _mm_unpacklo_epi8(ref1, zero);
92      ref2 = _mm_unpacklo_epi8(ref2, zero);
93      ref3 = _mm_unpacklo_epi8(ref3, zero);
94      ref0 = _mm_add_epi16(ref0, T0);
95      ref1 = _mm_add_epi16(ref1, T1);
96      ref2 = _mm_add_epi16(ref2, T2);
97      ref3 = _mm_add_epi16(ref3, T3);
98      ref0 = _mm_packus_epi16(ref0, ref0);
99      ref1 = _mm_packus_epi16(ref1, ref1);
100      ref2 = _mm_packus_epi16(ref2, ref2);
101      ref3 = _mm_packus_epi16(ref3, ref3);
102      if (do_two) {
103        _mm_storel_epi64((__m128i*)&dst[0 * BPS], ref0);
104        _mm_storel_epi64((__m128i*)&dst[1 * BPS], ref1);
105        _mm_storel_epi64((__m128i*)&dst[2 * BPS], ref2);
106        _mm_storel_epi64((__m128i*)&dst[3 * BPS], ref3);
107      } else {
108        WebPUint32ToMem(&dst[0 * BPS], _mm_cvtsi128_si32(ref0));
109        WebPUint32ToMem(&dst[1 * BPS], _mm_cvtsi128_si32(ref1));
110        WebPUint32ToMem(&dst[2 * BPS], _mm_cvtsi128_si32(ref2));
111        WebPUint32ToMem(&dst[3 * BPS], _mm_cvtsi128_si32(ref3));
112      }
113    }
114  }
115  static void FTransformPass1_SSE2(const __m128i* const in01,
116                                   const __m128i* const in23,
117                                   __m128i* const out01,
118                                   __m128i* const out32) {
119    const __m128i k937 = _mm_set1_epi32(937);
120    const __m128i k1812 = _mm_set1_epi32(1812);
121    const __m128i k88p = _mm_set_epi16(8, 8, 8, 8, 8, 8, 8, 8);
122    const __m128i k88m = _mm_set_epi16(-8, 8, -8, 8, -8, 8, -8, 8);
123    const __m128i k5352_2217p = _mm_set_epi16(2217, 5352, 2217, 5352,
124                                              2217, 5352, 2217, 5352);
125    const __m128i k5352_2217m = _mm_set_epi16(-5352, 2217, -5352, 2217,
126                                              -5352, 2217, -5352, 2217);
127    const __m128i shuf01_p = _mm_shufflehi_epi16(*in01, _MM_SHUFFLE(2, 3, 0, 1));
128    const __m128i shuf23_p = _mm_shufflehi_epi16(*in23, _MM_SHUFFLE(2, 3, 0, 1));
129    const __m128i s01 = _mm_unpacklo_epi64(shuf01_p, shuf23_p);
130    const __m128i s32 = _mm_unpackhi_epi64(shuf01_p, shuf23_p);
131    const __m128i a01 = _mm_add_epi16(s01, s32);
132    const __m128i a32 = _mm_sub_epi16(s01, s32);
133    const __m128i tmp0   = _mm_madd_epi16(a01, k88p);  
134    const __m128i tmp2   = _mm_madd_epi16(a01, k88m);  
135    const __m128i tmp1_1 = _mm_madd_epi16(a32, k5352_2217p);
136    const __m128i tmp3_1 = _mm_madd_epi16(a32, k5352_2217m);
137    const __m128i tmp1_2 = _mm_add_epi32(tmp1_1, k1812);
138    const __m128i tmp3_2 = _mm_add_epi32(tmp3_1, k937);
139    const __m128i tmp1   = _mm_srai_epi32(tmp1_2, 9);
140    const __m128i tmp3   = _mm_srai_epi32(tmp3_2, 9);
141    const __m128i s03    = _mm_packs_epi32(tmp0, tmp2);
142    const __m128i s12    = _mm_packs_epi32(tmp1, tmp3);
143    const __m128i s_lo   = _mm_unpacklo_epi16(s03, s12);   
144    const __m128i s_hi   = _mm_unpackhi_epi16(s03, s12);   
145    const __m128i v23    = _mm_unpackhi_epi32(s_lo, s_hi);
146    *out01 = _mm_unpacklo_epi32(s_lo, s_hi);
147    *out32 = _mm_shuffle_epi32(v23, _MM_SHUFFLE(1, 0, 3, 2));  
148  }
149  static void FTransformPass2_SSE2(const __m128i* const v01,
150                                   const __m128i* const v32,
151                                   int16_t* out) {
152    const __m128i zero = _mm_setzero_si128();
153    const __m128i seven = _mm_set1_epi16(7);
154    const __m128i k5352_2217 = _mm_set_epi16(5352,  2217, 5352,  2217,
155                                             5352,  2217, 5352,  2217);
156    const __m128i k2217_5352 = _mm_set_epi16(2217, -5352, 2217, -5352,
157                                             2217, -5352, 2217, -5352);
158    const __m128i k12000_plus_one = _mm_set1_epi32(12000 + (1 << 16));
159    const __m128i k51000 = _mm_set1_epi32(51000);
160    const __m128i a32 = _mm_sub_epi16(*v01, *v32);
161    const __m128i a22 = _mm_unpackhi_epi64(a32, a32);
162    const __m128i b23 = _mm_unpacklo_epi16(a22, a32);
163    const __m128i c1 = _mm_madd_epi16(b23, k5352_2217);
164    const __m128i c3 = _mm_madd_epi16(b23, k2217_5352);
165    const __m128i d1 = _mm_add_epi32(c1, k12000_plus_one);
166    const __m128i d3 = _mm_add_epi32(c3, k51000);
167    const __m128i e1 = _mm_srai_epi32(d1, 16);
168    const __m128i e3 = _mm_srai_epi32(d3, 16);
169    const __m128i f1 = _mm_packs_epi32(e1, e1);
170    const __m128i f3 = _mm_packs_epi32(e3, e3);
171    const __m128i g1 = _mm_add_epi16(f1, _mm_cmpeq_epi16(a32, zero));
172    const __m128i a01 = _mm_add_epi16(*v01, *v32);
173    const __m128i a01_plus_7 = _mm_add_epi16(a01, seven);
174    const __m128i a11 = _mm_unpackhi_epi64(a01, a01);
175    const __m128i c0 = _mm_add_epi16(a01_plus_7, a11);
176    const __m128i c2 = _mm_sub_epi16(a01_plus_7, a11);
177    const __m128i d0 = _mm_srai_epi16(c0, 4);
178    const __m128i d2 = _mm_srai_epi16(c2, 4);
179    const __m128i d0_g1 = _mm_unpacklo_epi64(d0, g1);
180    const __m128i d2_f3 = _mm_unpacklo_epi64(d2, f3);
181    _mm_storeu_si128((__m128i*)&out[0], d0_g1);
182    _mm_storeu_si128((__m128i*)&out[8], d2_f3);
183  }
184  static void FTransform_SSE2(const uint8_t* src, const uint8_t* ref,
185                              int16_t* out) {
186    const __m128i zero = _mm_setzero_si128();
187    const __m128i src0 = _mm_loadl_epi64((const __m128i*)&src[0 * BPS]);
188    const __m128i src1 = _mm_loadl_epi64((const __m128i*)&src[1 * BPS]);
189    const __m128i src2 = _mm_loadl_epi64((const __m128i*)&src[2 * BPS]);
190    const __m128i src3 = _mm_loadl_epi64((const __m128i*)&src[3 * BPS]);
191    const __m128i src_0 = _mm_unpacklo_epi16(src0, src1);
192    const __m128i src_1 = _mm_unpacklo_epi16(src2, src3);
193    const __m128i ref0 = _mm_loadl_epi64((const __m128i*)&ref[0 * BPS]);
194    const __m128i ref1 = _mm_loadl_epi64((const __m128i*)&ref[1 * BPS]);
195    const __m128i ref2 = _mm_loadl_epi64((const __m128i*)&ref[2 * BPS]);
196    const __m128i ref3 = _mm_loadl_epi64((const __m128i*)&ref[3 * BPS]);
197    const __m128i ref_0 = _mm_unpacklo_epi16(ref0, ref1);
198    const __m128i ref_1 = _mm_unpacklo_epi16(ref2, ref3);
199    const __m128i src_0_16b = _mm_unpacklo_epi8(src_0, zero);
200    const __m128i src_1_16b = _mm_unpacklo_epi8(src_1, zero);
201    const __m128i ref_0_16b = _mm_unpacklo_epi8(ref_0, zero);
202    const __m128i ref_1_16b = _mm_unpacklo_epi8(ref_1, zero);
203    const __m128i row01 = _mm_sub_epi16(src_0_16b, ref_0_16b);
204    const __m128i row23 = _mm_sub_epi16(src_1_16b, ref_1_16b);
205    __m128i v01, v32;
206    FTransformPass1_SSE2(&row01, &row23, &v01, &v32);
207    FTransformPass2_SSE2(&v01, &v32, out);
208  }
209  static void FTransform2_SSE2(const uint8_t* src, const uint8_t* ref,
210                               int16_t* out) {
211    const __m128i zero = _mm_setzero_si128();
212    const __m128i src0 = _mm_loadl_epi64((const __m128i*)&src[0 * BPS]);
213    const __m128i src1 = _mm_loadl_epi64((const __m128i*)&src[1 * BPS]);
214    const __m128i src2 = _mm_loadl_epi64((const __m128i*)&src[2 * BPS]);
215    const __m128i src3 = _mm_loadl_epi64((const __m128i*)&src[3 * BPS]);
216    const __m128i src_0 = _mm_unpacklo_epi8(src0, zero);
217    const __m128i src_1 = _mm_unpacklo_epi8(src1, zero);
218    const __m128i src_2 = _mm_unpacklo_epi8(src2, zero);
219    const __m128i src_3 = _mm_unpacklo_epi8(src3, zero);
220    const __m128i ref0 = _mm_loadl_epi64((const __m128i*)&ref[0 * BPS]);
221    const __m128i ref1 = _mm_loadl_epi64((const __m128i*)&ref[1 * BPS]);
222    const __m128i ref2 = _mm_loadl_epi64((const __m128i*)&ref[2 * BPS]);
223    const __m128i ref3 = _mm_loadl_epi64((const __m128i*)&ref[3 * BPS]);
224    const __m128i ref_0 = _mm_unpacklo_epi8(ref0, zero);
225    const __m128i ref_1 = _mm_unpacklo_epi8(ref1, zero);
226    const __m128i ref_2 = _mm_unpacklo_epi8(ref2, zero);
227    const __m128i ref_3 = _mm_unpacklo_epi8(ref3, zero);
228    const __m128i diff0 = _mm_sub_epi16(src_0, ref_0);
229    const __m128i diff1 = _mm_sub_epi16(src_1, ref_1);
230    const __m128i diff2 = _mm_sub_epi16(src_2, ref_2);
231    const __m128i diff3 = _mm_sub_epi16(src_3, ref_3);
232    const __m128i shuf01l = _mm_unpacklo_epi32(diff0, diff1);
233    const __m128i shuf23l = _mm_unpacklo_epi32(diff2, diff3);
234    const __m128i shuf01h = _mm_unpackhi_epi32(diff0, diff1);
235    const __m128i shuf23h = _mm_unpackhi_epi32(diff2, diff3);
236    __m128i v01l, v32l;
237    __m128i v01h, v32h;
238    FTransformPass1_SSE2(&shuf01l, &shuf23l, &v01l, &v32l);
239    FTransformPass1_SSE2(&shuf01h, &shuf23h, &v01h, &v32h);
240    FTransformPass2_SSE2(&v01l, &v32l, out + 0);
241    FTransformPass2_SSE2(&v01h, &v32h, out + 16);
242  }
243  static void FTransformWHTRow_SSE2(const int16_t* const in, __m128i* const out) {
244    const __m128i kMult = _mm_set_epi16(-1, 1, -1, 1, 1, 1, 1, 1);
245    const __m128i src0 = _mm_loadl_epi64((__m128i*)&in[0 * 16]);
246    const __m128i src1 = _mm_loadl_epi64((__m128i*)&in[1 * 16]);
247    const __m128i src2 = _mm_loadl_epi64((__m128i*)&in[2 * 16]);
248    const __m128i src3 = _mm_loadl_epi64((__m128i*)&in[3 * 16]);
249    const __m128i A01 = _mm_unpacklo_epi16(src0, src1);  
250    const __m128i A23 = _mm_unpacklo_epi16(src2, src3);  
251    const __m128i B0 = _mm_adds_epi16(A01, A23);    
252    const __m128i B1 = _mm_subs_epi16(A01, A23);    
253    const __m128i C0 = _mm_unpacklo_epi32(B0, B1);  
254    const __m128i C1 = _mm_unpacklo_epi32(B1, B0);  
255    const __m128i D = _mm_unpacklo_epi64(C0, C1);   
256    *out = _mm_madd_epi16(D, kMult);
257  }
258  static void FTransformWHT_SSE2(const int16_t* in, int16_t* out) {
259    __m128i row0, row1, row2, row3;
260    FTransformWHTRow_SSE2(in + 0 * 64, &row0);
261    FTransformWHTRow_SSE2(in + 1 * 64, &row1);
262    FTransformWHTRow_SSE2(in + 2 * 64, &row2);
263    FTransformWHTRow_SSE2(in + 3 * 64, &row3);
264    {
265      const __m128i a0 = _mm_add_epi32(row0, row2);
266      const __m128i a1 = _mm_add_epi32(row1, row3);
267      const __m128i a2 = _mm_sub_epi32(row1, row3);
268      const __m128i a3 = _mm_sub_epi32(row0, row2);
269      const __m128i a0a3 = _mm_packs_epi32(a0, a3);
270      const __m128i a1a2 = _mm_packs_epi32(a1, a2);
271      const __m128i b0b1 = _mm_add_epi16(a0a3, a1a2);
272      const __m128i b3b2 = _mm_sub_epi16(a0a3, a1a2);
273      const __m128i tmp_b2b3 = _mm_unpackhi_epi64(b3b2, b3b2);
274      const __m128i b2b3 = _mm_unpacklo_epi64(tmp_b2b3, b3b2);
275      _mm_storeu_si128((__m128i*)&out[0], _mm_srai_epi16(b0b1, 1));
276      _mm_storeu_si128((__m128i*)&out[8], _mm_srai_epi16(b2b3, 1));
277    }
278  }
279  static void CollectHistogram_SSE2(const uint8_t* ref, const uint8_t* pred,
280                                    int start_block, int end_block,
281                                    VP8Histogram* const histo) {
282    const __m128i zero = _mm_setzero_si128();
283    const __m128i max_coeff_thresh = _mm_set1_epi16(MAX_COEFF_THRESH);
284    int j;
285    int distribution[MAX_COEFF_THRESH + 1] = { 0 };
286    for (j = start_block; j < end_block; ++j) {
287      int16_t out[16];
288      int k;
289      FTransform_SSE2(ref + VP8DspScan[j], pred + VP8DspScan[j], out);
290      {
291        const __m128i out0 = _mm_loadu_si128((__m128i*)&out[0]);
292        const __m128i out1 = _mm_loadu_si128((__m128i*)&out[8]);
293        const __m128i d0 = _mm_sub_epi16(zero, out0);
294        const __m128i d1 = _mm_sub_epi16(zero, out1);
295        const __m128i abs0 = _mm_max_epi16(out0, d0);   
296        const __m128i abs1 = _mm_max_epi16(out1, d1);
297        const __m128i v0 = _mm_srai_epi16(abs0, 3);
298        const __m128i v1 = _mm_srai_epi16(abs1, 3);
299        const __m128i bin0 = _mm_min_epi16(v0, max_coeff_thresh);
300        const __m128i bin1 = _mm_min_epi16(v1, max_coeff_thresh);
301        _mm_storeu_si128((__m128i*)&out[0], bin0);
302        _mm_storeu_si128((__m128i*)&out[8], bin1);
303      }
304      for (k = 0; k < 16; ++k) {
305        ++distribution[out[k]];
306      }
307    }
308    VP8SetHistogramData(distribution, histo);
309  }
310  static WEBP_INLINE void Put8x8uv_SSE2(uint8_t v, uint8_t* dst) {
311    int j;
312    const __m128i values = _mm_set1_epi8(v);
313    for (j = 0; j < 8; ++j) {
314      _mm_storel_epi64((__m128i*)(dst + j * BPS), values);
315    }
316  }
317  static WEBP_INLINE void Put16_SSE2(uint8_t v, uint8_t* dst) {
318    int j;
319    const __m128i values = _mm_set1_epi8(v);
320    for (j = 0; j < 16; ++j) {
321      _mm_store_si128((__m128i*)(dst + j * BPS), values);
322    }
323  }
324  static WEBP_INLINE void Fill_SSE2(uint8_t* dst, int value, int size) {
325    if (size == 4) {
326      int j;
327      for (j = 0; j < 4; ++j) {
328        memset(dst + j * BPS, value, 4);
329      }
330    } else if (size == 8) {
331      Put8x8uv_SSE2(value, dst);
332    } else {
333      Put16_SSE2(value, dst);
334    }
335  }
336  static WEBP_INLINE void VE8uv_SSE2(uint8_t* dst, const uint8_t* top) {
337    int j;
338    const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
339    for (j = 0; j < 8; ++j) {
340      _mm_storel_epi64((__m128i*)(dst + j * BPS), top_values);
341    }
342  }
343  static WEBP_INLINE void VE16_SSE2(uint8_t* dst, const uint8_t* top) {
344    const __m128i top_values = _mm_load_si128((const __m128i*)top);
345    int j;
346    for (j = 0; j < 16; ++j) {
347      _mm_store_si128((__m128i*)(dst + j * BPS), top_values);
348    }
349  }
350  static WEBP_INLINE void VerticalPred_SSE2(uint8_t* dst,
351                                            const uint8_t* top, int size) {
352    if (top != NULL) {
353      if (size == 8) {
354        VE8uv_SSE2(dst, top);
355      } else {
356        VE16_SSE2(dst, top);
357      }
358    } else {
359      Fill_SSE2(dst, 127, size);
360    }
361  }
362  static WEBP_INLINE void HE8uv_SSE2(uint8_t* dst, const uint8_t* left) {
363    int j;
364    for (j = 0; j < 8; ++j) {
365      const __m128i values = _mm_set1_epi8(left[j]);
366      _mm_storel_epi64((__m128i*)dst, values);
367      dst += BPS;
368    }
369  }
370  static WEBP_INLINE void HE16_SSE2(uint8_t* dst, const uint8_t* left) {
371    int j;
372    for (j = 0; j < 16; ++j) {
373      const __m128i values = _mm_set1_epi8(left[j]);
374      _mm_store_si128((__m128i*)dst, values);
375      dst += BPS;
376    }
377  }
378  static WEBP_INLINE void HorizontalPred_SSE2(uint8_t* dst,
379                                              const uint8_t* left, int size) {
380    if (left != NULL) {
381      if (size == 8) {
382        HE8uv_SSE2(dst, left);
383      } else {
384        HE16_SSE2(dst, left);
385      }
386    } else {
387      Fill_SSE2(dst, 129, size);
388    }
389  }
390  static WEBP_INLINE void TM_SSE2(uint8_t* dst, const uint8_t* left,
391                                  const uint8_t* top, int size) {
392    const __m128i zero = _mm_setzero_si128();
393    int y;
394    if (size == 8) {
395      const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
396      const __m128i top_base = _mm_unpacklo_epi8(top_values, zero);
397      for (y = 0; y < 8; ++y, dst += BPS) {
398        const int val = left[y] - left[-1];
399        const __m128i base = _mm_set1_epi16(val);
400        const __m128i out = _mm_packus_epi16(_mm_add_epi16(base, top_base), zero);
401        _mm_storel_epi64((__m128i*)dst, out);
402      }
403    } else {
404      const __m128i top_values = _mm_load_si128((const __m128i*)top);
405      const __m128i top_base_0 = _mm_unpacklo_epi8(top_values, zero);
406      const __m128i top_base_1 = _mm_unpackhi_epi8(top_values, zero);
407      for (y = 0; y < 16; ++y, dst += BPS) {
408        const int val = left[y] - left[-1];
409        const __m128i base = _mm_set1_epi16(val);
410        const __m128i out_0 = _mm_add_epi16(base, top_base_0);
411        const __m128i out_1 = _mm_add_epi16(base, top_base_1);
412        const __m128i out = _mm_packus_epi16(out_0, out_1);
413        _mm_store_si128((__m128i*)dst, out);
414      }
415    }
416  }
417  static WEBP_INLINE void TrueMotion_SSE2(uint8_t* dst, const uint8_t* left,
418                                          const uint8_t* top, int size) {
419    if (left != NULL) {
420      if (top != NULL) {
421        TM_SSE2(dst, left, top, size);
422      } else {
423        HorizontalPred_SSE2(dst, left, size);
424      }
425    } else {
426      if (top != NULL) {
427        VerticalPred_SSE2(dst, top, size);
428      } else {
429        Fill_SSE2(dst, 129, size);
430      }
431    }
432  }
433  static WEBP_INLINE void DC8uv_SSE2(uint8_t* dst, const uint8_t* left,
434                                     const uint8_t* top) {
435    const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
436    const __m128i left_values = _mm_loadl_epi64((const __m128i*)left);
437    const __m128i combined = _mm_unpacklo_epi64(top_values, left_values);
438    const int DC = VP8HorizontalAdd8b(&combined) + 8;
439    Put8x8uv_SSE2(DC >> 4, dst);
440  }
441  static WEBP_INLINE void DC8uvNoLeft_SSE2(uint8_t* dst, const uint8_t* top) {
442    const __m128i zero = _mm_setzero_si128();
443    const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
444    const __m128i sum = _mm_sad_epu8(top_values, zero);
445    const int DC = _mm_cvtsi128_si32(sum) + 4;
446    Put8x8uv_SSE2(DC >> 3, dst);
447  }
448  static WEBP_INLINE void DC8uvNoTop_SSE2(uint8_t* dst, const uint8_t* left) {
449    DC8uvNoLeft_SSE2(dst, left);
450  }
451  static WEBP_INLINE void DC8uvNoTopLeft_SSE2(uint8_t* dst) {
452    Put8x8uv_SSE2(0x80, dst);
453  }
454  static WEBP_INLINE void DC8uvMode_SSE2(uint8_t* dst, const uint8_t* left,
455                                         const uint8_t* top) {
456    if (top != NULL) {
457      if (left != NULL) {  
458        DC8uv_SSE2(dst, left, top);
459      } else {  
460        DC8uvNoLeft_SSE2(dst, top);
461      }
462    } else if (left != NULL) {  
463      DC8uvNoTop_SSE2(dst, left);
464    } else {  
465      DC8uvNoTopLeft_SSE2(dst);
466    }
467  }
468  static WEBP_INLINE void DC16_SSE2(uint8_t* dst, const uint8_t* left,
469                                    const uint8_t* top) {
470    const __m128i top_row = _mm_load_si128((const __m128i*)top);
471    const __m128i left_row = _mm_load_si128((const __m128i*)left);
472    const int DC =
473        VP8HorizontalAdd8b(&top_row) + VP8HorizontalAdd8b(&left_row) + 16;
474    Put16_SSE2(DC >> 5, dst);
475  }
476  static WEBP_INLINE void DC16NoLeft_SSE2(uint8_t* dst, const uint8_t* top) {
477    const __m128i top_row = _mm_load_si128((const __m128i*)top);
478    const int DC = VP8HorizontalAdd8b(&top_row) + 8;
479    Put16_SSE2(DC >> 4, dst);
480  }
481  static WEBP_INLINE void DC16NoTop_SSE2(uint8_t* dst, const uint8_t* left) {
482    DC16NoLeft_SSE2(dst, left);
483  }
484  static WEBP_INLINE void DC16NoTopLeft_SSE2(uint8_t* dst) {
485    Put16_SSE2(0x80, dst);
486  }
487  static WEBP_INLINE void DC16Mode_SSE2(uint8_t* dst, const uint8_t* left,
488                                        const uint8_t* top) {
489    if (top != NULL) {
490      if (left != NULL) {  
491        DC16_SSE2(dst, left, top);
492      } else {  
493        DC16NoLeft_SSE2(dst, top);
494      }
495    } else if (left != NULL) {  
496      DC16NoTop_SSE2(dst, left);
497    } else {  
498      DC16NoTopLeft_SSE2(dst);
499    }
500  }
501  #define DST(x, y) dst[(x) + (y) * BPS]
502  #define AVG3(a, b, c) (((a) + 2 * (b) + (c) + 2) >> 2)
503  #define AVG2(a, b) (((a) + (b) + 1) >> 1)
504  static WEBP_INLINE void VE4_SSE2(uint8_t* dst,
505                                   const uint8_t* top) {  
506    const __m128i one = _mm_set1_epi8(1);
507    const __m128i ABCDEFGH = _mm_loadl_epi64((__m128i*)(top - 1));
508    const __m128i BCDEFGH0 = _mm_srli_si128(ABCDEFGH, 1);
509    const __m128i CDEFGH00 = _mm_srli_si128(ABCDEFGH, 2);
510    const __m128i a = _mm_avg_epu8(ABCDEFGH, CDEFGH00);
511    const __m128i lsb = _mm_and_si128(_mm_xor_si128(ABCDEFGH, CDEFGH00), one);
512    const __m128i b = _mm_subs_epu8(a, lsb);
513    const __m128i avg = _mm_avg_epu8(b, BCDEFGH0);
514    const uint32_t vals = _mm_cvtsi128_si32(avg);
515    int i;
516    for (i = 0; i < 4; ++i) {
517      WebPUint32ToMem(dst + i * BPS, vals);
518    }
519  }
<span onclick='openModal()' class='match'>520  static WEBP_INLINE void HE4_SSE2(uint8_t* dst,
521                                   const uint8_t* top) {  
522    const int X = top[-1];
523    const int I = top[-2];
524    const int J = top[-3];
</span>525    const int K = top[-4];
526    const int L = top[-5];
527    WebPUint32ToMem(dst + 0 * BPS, 0x01010101U * AVG3(X, I, J));
528    WebPUint32ToMem(dst + 1 * BPS, 0x01010101U * AVG3(I, J, K));
529    WebPUint32ToMem(dst + 2 * BPS, 0x01010101U * AVG3(J, K, L));
530    WebPUint32ToMem(dst + 3 * BPS, 0x01010101U * AVG3(K, L, L));
531  }
532  static WEBP_INLINE void DC4_SSE2(uint8_t* dst, const uint8_t* top) {
533    uint32_t dc = 4;
534    int i;
535    for (i = 0; i < 4; ++i) dc += top[i] + top[-5 + i];
536    Fill_SSE2(dst, dc >> 3, 4);
537  }
538  static WEBP_INLINE void LD4_SSE2(uint8_t* dst,
539                                   const uint8_t* top) {  
540    const __m128i one = _mm_set1_epi8(1);
541    const __m128i ABCDEFGH = _mm_loadl_epi64((const __m128i*)top);
542    const __m128i BCDEFGH0 = _mm_srli_si128(ABCDEFGH, 1);
543    const __m128i CDEFGH00 = _mm_srli_si128(ABCDEFGH, 2);
544    const __m128i CDEFGHH0 = _mm_insert_epi16(CDEFGH00, top[7], 3);
545    const __m128i avg1 = _mm_avg_epu8(ABCDEFGH, CDEFGHH0);
546    const __m128i lsb = _mm_and_si128(_mm_xor_si128(ABCDEFGH, CDEFGHH0), one);
547    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
548    const __m128i abcdefg = _mm_avg_epu8(avg2, BCDEFGH0);
549    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               abcdefg    ));
550    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 1)));
551    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 2)));
552    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 3)));
553  }
554  static WEBP_INLINE void VR4_SSE2(uint8_t* dst,
555                                   const uint8_t* top) {  
556    const __m128i one = _mm_set1_epi8(1);
557    const int I = top[-2];
558    const int J = top[-3];
559    const int K = top[-4];
560    const int X = top[-1];
561    const __m128i XABCD = _mm_loadl_epi64((const __m128i*)(top - 1));
562    const __m128i ABCD0 = _mm_srli_si128(XABCD, 1);
563    const __m128i abcd = _mm_avg_epu8(XABCD, ABCD0);
564    const __m128i _XABCD = _mm_slli_si128(XABCD, 1);
565    const __m128i IXABCD = _mm_insert_epi16(_XABCD, (short)(I | (X << 8)), 0);
566    const __m128i avg1 = _mm_avg_epu8(IXABCD, ABCD0);
567    const __m128i lsb = _mm_and_si128(_mm_xor_si128(IXABCD, ABCD0), one);
568    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
569    const __m128i efgh = _mm_avg_epu8(avg2, XABCD);
570    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               abcd    ));
571    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(               efgh    ));
572    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_slli_si128(abcd, 1)));
573    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_slli_si128(efgh, 1)));
574    DST(0, 2) = AVG3(J, I, X);
575    DST(0, 3) = AVG3(K, J, I);
576  }
577  static WEBP_INLINE void VL4_SSE2(uint8_t* dst,
578                                   const uint8_t* top) {  
579    const __m128i one = _mm_set1_epi8(1);
580    const __m128i ABCDEFGH = _mm_loadl_epi64((const __m128i*)top);
581    const __m128i BCDEFGH_ = _mm_srli_si128(ABCDEFGH, 1);
582    const __m128i CDEFGH__ = _mm_srli_si128(ABCDEFGH, 2);
583    const __m128i avg1 = _mm_avg_epu8(ABCDEFGH, BCDEFGH_);
584    const __m128i avg2 = _mm_avg_epu8(CDEFGH__, BCDEFGH_);
585    const __m128i avg3 = _mm_avg_epu8(avg1, avg2);
586    const __m128i lsb1 = _mm_and_si128(_mm_xor_si128(avg1, avg2), one);
587    const __m128i ab = _mm_xor_si128(ABCDEFGH, BCDEFGH_);
588    const __m128i bc = _mm_xor_si128(CDEFGH__, BCDEFGH_);
589    const __m128i abbc = _mm_or_si128(ab, bc);
590    const __m128i lsb2 = _mm_and_si128(abbc, lsb1);
591    const __m128i avg4 = _mm_subs_epu8(avg3, lsb2);
592    const uint32_t extra_out = _mm_cvtsi128_si32(_mm_srli_si128(avg4, 4));
593    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               avg1    ));
594    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(               avg4    ));
595    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(avg1, 1)));
596    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(avg4, 1)));
597    DST(3, 2) = (extra_out >> 0) & 0xff;
598    DST(3, 3) = (extra_out >> 8) & 0xff;
599  }
600  static WEBP_INLINE void RD4_SSE2(uint8_t* dst,
601                                   const uint8_t* top) {  
602    const __m128i one = _mm_set1_epi8(1);
603    const __m128i LKJIXABC = _mm_loadl_epi64((const __m128i*)(top - 5));
604    const __m128i LKJIXABCD = _mm_insert_epi16(LKJIXABC, top[3], 4);
605    const __m128i KJIXABCD_ = _mm_srli_si128(LKJIXABCD, 1);
606    const __m128i JIXABCD__ = _mm_srli_si128(LKJIXABCD, 2);
607    const __m128i avg1 = _mm_avg_epu8(JIXABCD__, LKJIXABCD);
608    const __m128i lsb = _mm_and_si128(_mm_xor_si128(JIXABCD__, LKJIXABCD), one);
609    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
610    const __m128i abcdefg = _mm_avg_epu8(avg2, KJIXABCD_);
611    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(               abcdefg    ));
612    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 1)));
613    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 2)));
614    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 3)));
615  }
616  static WEBP_INLINE void HU4_SSE2(uint8_t* dst, const uint8_t* top) {
617    const int I = top[-2];
618    const int J = top[-3];
619    const int K = top[-4];
620    const int L = top[-5];
621    DST(0, 0) =             AVG2(I, J);
622    DST(2, 0) = DST(0, 1) = AVG2(J, K);
623    DST(2, 1) = DST(0, 2) = AVG2(K, L);
624    DST(1, 0) =             AVG3(I, J, K);
625    DST(3, 0) = DST(1, 1) = AVG3(J, K, L);
626    DST(3, 1) = DST(1, 2) = AVG3(K, L, L);
627    DST(3, 2) = DST(2, 2) =
628    DST(0, 3) = DST(1, 3) = DST(2, 3) = DST(3, 3) = L;
629  }
630  static WEBP_INLINE void HD4_SSE2(uint8_t* dst, const uint8_t* top) {
631    const int X = top[-1];
632    const int I = top[-2];
633    const int J = top[-3];
634    const int K = top[-4];
635    const int L = top[-5];
636    const int A = top[0];
637    const int B = top[1];
638    const int C = top[2];
639    DST(0, 0) = DST(2, 1) = AVG2(I, X);
640    DST(0, 1) = DST(2, 2) = AVG2(J, I);
641    DST(0, 2) = DST(2, 3) = AVG2(K, J);
642    DST(0, 3)             = AVG2(L, K);
643    DST(3, 0)             = AVG3(A, B, C);
644    DST(2, 0)             = AVG3(X, A, B);
645    DST(1, 0) = DST(3, 1) = AVG3(I, X, A);
646    DST(1, 1) = DST(3, 2) = AVG3(J, I, X);
647    DST(1, 2) = DST(3, 3) = AVG3(K, J, I);
648    DST(1, 3)             = AVG3(L, K, J);
649  }
650  static WEBP_INLINE void TM4_SSE2(uint8_t* dst, const uint8_t* top) {
651    const __m128i zero = _mm_setzero_si128();
652    const __m128i top_values = _mm_cvtsi32_si128(WebPMemToUint32(top));
653    const __m128i top_base = _mm_unpacklo_epi8(top_values, zero);
654    int y;
655    for (y = 0; y < 4; ++y, dst += BPS) {
656      const int val = top[-2 - y] - top[-1];
657      const __m128i base = _mm_set1_epi16(val);
658      const __m128i out = _mm_packus_epi16(_mm_add_epi16(base, top_base), zero);
659      WebPUint32ToMem(dst, _mm_cvtsi128_si32(out));
660    }
661  }
662  #undef DST
663  #undef AVG3
664  #undef AVG2
665  static void Intra4Preds_SSE2(uint8_t* dst, const uint8_t* top) {
666    DC4_SSE2(I4DC4 + dst, top);
667    TM4_SSE2(I4TM4 + dst, top);
668    VE4_SSE2(I4VE4 + dst, top);
669    HE4_SSE2(I4HE4 + dst, top);
670    RD4_SSE2(I4RD4 + dst, top);
671    VR4_SSE2(I4VR4 + dst, top);
672    LD4_SSE2(I4LD4 + dst, top);
673    VL4_SSE2(I4VL4 + dst, top);
674    HD4_SSE2(I4HD4 + dst, top);
675    HU4_SSE2(I4HU4 + dst, top);
676  }
677  static void IntraChromaPreds_SSE2(uint8_t* dst, const uint8_t* left,
678                                    const uint8_t* top) {
679    DC8uvMode_SSE2(C8DC8 + dst, left, top);
680    VerticalPred_SSE2(C8VE8 + dst, top, 8);
681    HorizontalPred_SSE2(C8HE8 + dst, left, 8);
682    TrueMotion_SSE2(C8TM8 + dst, left, top, 8);
683    dst += 8;
684    if (top != NULL) top += 8;
685    if (left != NULL) left += 16;
686    DC8uvMode_SSE2(C8DC8 + dst, left, top);
687    VerticalPred_SSE2(C8VE8 + dst, top, 8);
688    HorizontalPred_SSE2(C8HE8 + dst, left, 8);
689    TrueMotion_SSE2(C8TM8 + dst, left, top, 8);
690  }
691  static void Intra16Preds_SSE2(uint8_t* dst,
692                                const uint8_t* left, const uint8_t* top) {
693    DC16Mode_SSE2(I16DC16 + dst, left, top);
694    VerticalPred_SSE2(I16VE16 + dst, top, 16);
695    HorizontalPred_SSE2(I16HE16 + dst, left, 16);
696    TrueMotion_SSE2(I16TM16 + dst, left, top, 16);
697  }
698  static WEBP_INLINE void SubtractAndAccumulate_SSE2(const __m128i a,
699                                                     const __m128i b,
700                                                     __m128i* const sum) {
701    const __m128i a_b = _mm_subs_epu8(a, b);
702    const __m128i b_a = _mm_subs_epu8(b, a);
703    const __m128i abs_a_b = _mm_or_si128(a_b, b_a);
704    const __m128i zero = _mm_setzero_si128();
705    const __m128i C0 = _mm_unpacklo_epi8(abs_a_b, zero);
706    const __m128i C1 = _mm_unpackhi_epi8(abs_a_b, zero);
707    const __m128i sum1 = _mm_madd_epi16(C0, C0);
708    const __m128i sum2 = _mm_madd_epi16(C1, C1);
709    *sum = _mm_add_epi32(sum1, sum2);
710  }
711  static WEBP_INLINE int SSE_16xN_SSE2(const uint8_t* a, const uint8_t* b,
712                                       int num_pairs) {
713    __m128i sum = _mm_setzero_si128();
714    int32_t tmp[4];
715    int i;
716    for (i = 0; i < num_pairs; ++i) {
717      const __m128i a0 = _mm_loadu_si128((const __m128i*)&a[BPS * 0]);
718      const __m128i b0 = _mm_loadu_si128((const __m128i*)&b[BPS * 0]);
719      const __m128i a1 = _mm_loadu_si128((const __m128i*)&a[BPS * 1]);
720      const __m128i b1 = _mm_loadu_si128((const __m128i*)&b[BPS * 1]);
721      __m128i sum1, sum2;
722      SubtractAndAccumulate_SSE2(a0, b0, &sum1);
723      SubtractAndAccumulate_SSE2(a1, b1, &sum2);
724      sum = _mm_add_epi32(sum, _mm_add_epi32(sum1, sum2));
725      a += 2 * BPS;
726      b += 2 * BPS;
727    }
728    _mm_storeu_si128((__m128i*)tmp, sum);
729    return (tmp[3] + tmp[2] + tmp[1] + tmp[0]);
730  }
731  static int SSE16x16_SSE2(const uint8_t* a, const uint8_t* b) {
732    return SSE_16xN_SSE2(a, b, 8);
733  }
734  static int SSE16x8_SSE2(const uint8_t* a, const uint8_t* b) {
735    return SSE_16xN_SSE2(a, b, 4);
736  }
737  #define LOAD_8x16b(ptr) \
738    _mm_unpacklo_epi8(_mm_loadl_epi64((const __m128i*)(ptr)), zero)
739  static int SSE8x8_SSE2(const uint8_t* a, const uint8_t* b) {
740    const __m128i zero = _mm_setzero_si128();
741    int num_pairs = 4;
742    __m128i sum = zero;
743    int32_t tmp[4];
744    while (num_pairs-- > 0) {
745      const __m128i a0 = LOAD_8x16b(&a[BPS * 0]);
746      const __m128i a1 = LOAD_8x16b(&a[BPS * 1]);
747      const __m128i b0 = LOAD_8x16b(&b[BPS * 0]);
748      const __m128i b1 = LOAD_8x16b(&b[BPS * 1]);
749      const __m128i c0 = _mm_subs_epi16(a0, b0);
750      const __m128i c1 = _mm_subs_epi16(a1, b1);
751      const __m128i d0 = _mm_madd_epi16(c0, c0);
752      const __m128i d1 = _mm_madd_epi16(c1, c1);
753      const __m128i sum01 = _mm_add_epi32(d0, d1);
754      sum = _mm_add_epi32(sum, sum01);
755      a += 2 * BPS;
756      b += 2 * BPS;
757    }
758    _mm_storeu_si128((__m128i*)tmp, sum);
759    return (tmp[3] + tmp[2] + tmp[1] + tmp[0]);
760  }
761  #undef LOAD_8x16b
762  static int SSE4x4_SSE2(const uint8_t* a, const uint8_t* b) {
763    const __m128i zero = _mm_setzero_si128();
764    const __m128i a0 = _mm_loadl_epi64((const __m128i*)&a[BPS * 0]);
765    const __m128i a1 = _mm_loadl_epi64((const __m128i*)&a[BPS * 1]);
766    const __m128i a2 = _mm_loadl_epi64((const __m128i*)&a[BPS * 2]);
767    const __m128i a3 = _mm_loadl_epi64((const __m128i*)&a[BPS * 3]);
768    const __m128i b0 = _mm_loadl_epi64((const __m128i*)&b[BPS * 0]);
769    const __m128i b1 = _mm_loadl_epi64((const __m128i*)&b[BPS * 1]);
770    const __m128i b2 = _mm_loadl_epi64((const __m128i*)&b[BPS * 2]);
771    const __m128i b3 = _mm_loadl_epi64((const __m128i*)&b[BPS * 3]);
772    const __m128i a01 = _mm_unpacklo_epi32(a0, a1);
773    const __m128i a23 = _mm_unpacklo_epi32(a2, a3);
774    const __m128i b01 = _mm_unpacklo_epi32(b0, b1);
775    const __m128i b23 = _mm_unpacklo_epi32(b2, b3);
776    const __m128i a01s = _mm_unpacklo_epi8(a01, zero);
777    const __m128i a23s = _mm_unpacklo_epi8(a23, zero);
778    const __m128i b01s = _mm_unpacklo_epi8(b01, zero);
779    const __m128i b23s = _mm_unpacklo_epi8(b23, zero);
780    const __m128i d0 = _mm_subs_epi16(a01s, b01s);
781    const __m128i d1 = _mm_subs_epi16(a23s, b23s);
782    const __m128i e0 = _mm_madd_epi16(d0, d0);
783    const __m128i e1 = _mm_madd_epi16(d1, d1);
784    const __m128i sum = _mm_add_epi32(e0, e1);
785    int32_t tmp[4];
786    _mm_storeu_si128((__m128i*)tmp, sum);
787    return (tmp[3] + tmp[2] + tmp[1] + tmp[0]);
788  }
789  static void Mean16x4_SSE2(const uint8_t* ref, uint32_t dc[4]) {
790    const __m128i mask = _mm_set1_epi16(0x00ff);
791    const __m128i a0 = _mm_loadu_si128((const __m128i*)&ref[BPS * 0]);
792    const __m128i a1 = _mm_loadu_si128((const __m128i*)&ref[BPS * 1]);
793    const __m128i a2 = _mm_loadu_si128((const __m128i*)&ref[BPS * 2]);
794    const __m128i a3 = _mm_loadu_si128((const __m128i*)&ref[BPS * 3]);
795    const __m128i b0 = _mm_srli_epi16(a0, 8);     
796    const __m128i b1 = _mm_srli_epi16(a1, 8);
797    const __m128i b2 = _mm_srli_epi16(a2, 8);
798    const __m128i b3 = _mm_srli_epi16(a3, 8);
799    const __m128i c0 = _mm_and_si128(a0, mask);   
800    const __m128i c1 = _mm_and_si128(a1, mask);
801    const __m128i c2 = _mm_and_si128(a2, mask);
802    const __m128i c3 = _mm_and_si128(a3, mask);
803    const __m128i d0 = _mm_add_epi32(b0, c0);
804    const __m128i d1 = _mm_add_epi32(b1, c1);
805    const __m128i d2 = _mm_add_epi32(b2, c2);
806    const __m128i d3 = _mm_add_epi32(b3, c3);
807    const __m128i e0 = _mm_add_epi32(d0, d1);
808    const __m128i e1 = _mm_add_epi32(d2, d3);
809    const __m128i f0 = _mm_add_epi32(e0, e1);
810    uint16_t tmp[8];
811    _mm_storeu_si128((__m128i*)tmp, f0);
812    dc[0] = tmp[0] + tmp[1];
813    dc[1] = tmp[2] + tmp[3];
814    dc[2] = tmp[4] + tmp[5];
815    dc[3] = tmp[6] + tmp[7];
816  }
817  static int TTransform_SSE2(const uint8_t* inA, const uint8_t* inB,
818                             const uint16_t* const w) {
819    int32_t sum[4];
820    __m128i tmp_0, tmp_1, tmp_2, tmp_3;
821    const __m128i zero = _mm_setzero_si128();
822    {
823      const __m128i inA_0 = _mm_loadl_epi64((const __m128i*)&inA[BPS * 0]);
824      const __m128i inA_1 = _mm_loadl_epi64((const __m128i*)&inA[BPS * 1]);
825      const __m128i inA_2 = _mm_loadl_epi64((const __m128i*)&inA[BPS * 2]);
826      const __m128i inA_3 = _mm_loadl_epi64((const __m128i*)&inA[BPS * 3]);
827      const __m128i inB_0 = _mm_loadl_epi64((const __m128i*)&inB[BPS * 0]);
828      const __m128i inB_1 = _mm_loadl_epi64((const __m128i*)&inB[BPS * 1]);
829      const __m128i inB_2 = _mm_loadl_epi64((const __m128i*)&inB[BPS * 2]);
830      const __m128i inB_3 = _mm_loadl_epi64((const __m128i*)&inB[BPS * 3]);
831      const __m128i inAB_0 = _mm_unpacklo_epi32(inA_0, inB_0);
832      const __m128i inAB_1 = _mm_unpacklo_epi32(inA_1, inB_1);
833      const __m128i inAB_2 = _mm_unpacklo_epi32(inA_2, inB_2);
834      const __m128i inAB_3 = _mm_unpacklo_epi32(inA_3, inB_3);
835      tmp_0 = _mm_unpacklo_epi8(inAB_0, zero);
836      tmp_1 = _mm_unpacklo_epi8(inAB_1, zero);
837      tmp_2 = _mm_unpacklo_epi8(inAB_2, zero);
838      tmp_3 = _mm_unpacklo_epi8(inAB_3, zero);
839    }
840    {
841      const __m128i a0 = _mm_add_epi16(tmp_0, tmp_2);
842      const __m128i a1 = _mm_add_epi16(tmp_1, tmp_3);
843      const __m128i a2 = _mm_sub_epi16(tmp_1, tmp_3);
844      const __m128i a3 = _mm_sub_epi16(tmp_0, tmp_2);
845      const __m128i b0 = _mm_add_epi16(a0, a1);
846      const __m128i b1 = _mm_add_epi16(a3, a2);
847      const __m128i b2 = _mm_sub_epi16(a3, a2);
848      const __m128i b3 = _mm_sub_epi16(a0, a1);
849      VP8Transpose_2_4x4_16b(&b0, &b1, &b2, &b3, &tmp_0, &tmp_1, &tmp_2, &tmp_3);
850    }
851    {
852      const __m128i w_0 = _mm_loadu_si128((const __m128i*)&w[0]);
853      const __m128i w_8 = _mm_loadu_si128((const __m128i*)&w[8]);
854      const __m128i a0 = _mm_add_epi16(tmp_0, tmp_2);
855      const __m128i a1 = _mm_add_epi16(tmp_1, tmp_3);
856      const __m128i a2 = _mm_sub_epi16(tmp_1, tmp_3);
857      const __m128i a3 = _mm_sub_epi16(tmp_0, tmp_2);
858      const __m128i b0 = _mm_add_epi16(a0, a1);
859      const __m128i b1 = _mm_add_epi16(a3, a2);
860      const __m128i b2 = _mm_sub_epi16(a3, a2);
861      const __m128i b3 = _mm_sub_epi16(a0, a1);
862      __m128i A_b0 = _mm_unpacklo_epi64(b0, b1);
863      __m128i A_b2 = _mm_unpacklo_epi64(b2, b3);
864      __m128i B_b0 = _mm_unpackhi_epi64(b0, b1);
865      __m128i B_b2 = _mm_unpackhi_epi64(b2, b3);
866      {
867        const __m128i d0 = _mm_sub_epi16(zero, A_b0);
868        const __m128i d1 = _mm_sub_epi16(zero, A_b2);
869        const __m128i d2 = _mm_sub_epi16(zero, B_b0);
870        const __m128i d3 = _mm_sub_epi16(zero, B_b2);
871        A_b0 = _mm_max_epi16(A_b0, d0);   
872        A_b2 = _mm_max_epi16(A_b2, d1);
873        B_b0 = _mm_max_epi16(B_b0, d2);
874        B_b2 = _mm_max_epi16(B_b2, d3);
875      }
876      A_b0 = _mm_madd_epi16(A_b0, w_0);
877      A_b2 = _mm_madd_epi16(A_b2, w_8);
878      B_b0 = _mm_madd_epi16(B_b0, w_0);
879      B_b2 = _mm_madd_epi16(B_b2, w_8);
880      A_b0 = _mm_add_epi32(A_b0, A_b2);
881      B_b0 = _mm_add_epi32(B_b0, B_b2);
882      A_b0 = _mm_sub_epi32(A_b0, B_b0);
883      _mm_storeu_si128((__m128i*)&sum[0], A_b0);
884    }
885    return sum[0] + sum[1] + sum[2] + sum[3];
886  }
887  static int Disto4x4_SSE2(const uint8_t* const a, const uint8_t* const b,
888                           const uint16_t* const w) {
889    const int diff_sum = TTransform_SSE2(a, b, w);
890    return abs(diff_sum) >> 5;
891  }
892  static int Disto16x16_SSE2(const uint8_t* const a, const uint8_t* const b,
893                             const uint16_t* const w) {
894    int D = 0;
895    int x, y;
896    for (y = 0; y < 16 * BPS; y += 4 * BPS) {
897      for (x = 0; x < 16; x += 4) {
898        D += Disto4x4_SSE2(a + x + y, b + x + y, w);
899      }
900    }
901    return D;
902  }
903  static WEBP_INLINE int DoQuantizeBlock_SSE2(int16_t in[16], int16_t out[16],
904                                              const uint16_t* const sharpen,
905                                              const VP8Matrix* const mtx) {
906    const __m128i max_coeff_2047 = _mm_set1_epi16(MAX_LEVEL);
907    const __m128i zero = _mm_setzero_si128();
908    __m128i coeff0, coeff8;
909    __m128i out0, out8;
910    __m128i packed_out;
911    __m128i in0 = _mm_loadu_si128((__m128i*)&in[0]);
912    __m128i in8 = _mm_loadu_si128((__m128i*)&in[8]);
913    const __m128i iq0 = _mm_loadu_si128((const __m128i*)&mtx->iq_[0]);
914    const __m128i iq8 = _mm_loadu_si128((const __m128i*)&mtx->iq_[8]);
915    const __m128i q0 = _mm_loadu_si128((const __m128i*)&mtx->q_[0]);
916    const __m128i q8 = _mm_loadu_si128((const __m128i*)&mtx->q_[8]);
917    const __m128i sign0 = _mm_cmpgt_epi16(zero, in0);
918    const __m128i sign8 = _mm_cmpgt_epi16(zero, in8);
919    coeff0 = _mm_xor_si128(in0, sign0);
920    coeff8 = _mm_xor_si128(in8, sign8);
921    coeff0 = _mm_sub_epi16(coeff0, sign0);
922    coeff8 = _mm_sub_epi16(coeff8, sign8);
923    if (sharpen != NULL) {
924      const __m128i sharpen0 = _mm_loadu_si128((const __m128i*)&sharpen[0]);
925      const __m128i sharpen8 = _mm_loadu_si128((const __m128i*)&sharpen[8]);
926      coeff0 = _mm_add_epi16(coeff0, sharpen0);
927      coeff8 = _mm_add_epi16(coeff8, sharpen8);
928    }
929    {
930      const __m128i coeff_iQ0H = _mm_mulhi_epu16(coeff0, iq0);
931      const __m128i coeff_iQ0L = _mm_mullo_epi16(coeff0, iq0);
932      const __m128i coeff_iQ8H = _mm_mulhi_epu16(coeff8, iq8);
933      const __m128i coeff_iQ8L = _mm_mullo_epi16(coeff8, iq8);
934      __m128i out_00 = _mm_unpacklo_epi16(coeff_iQ0L, coeff_iQ0H);
935      __m128i out_04 = _mm_unpackhi_epi16(coeff_iQ0L, coeff_iQ0H);
936      __m128i out_08 = _mm_unpacklo_epi16(coeff_iQ8L, coeff_iQ8H);
937      __m128i out_12 = _mm_unpackhi_epi16(coeff_iQ8L, coeff_iQ8H);
938      const __m128i bias_00 = _mm_loadu_si128((const __m128i*)&mtx->bias_[0]);
939      const __m128i bias_04 = _mm_loadu_si128((const __m128i*)&mtx->bias_[4]);
940      const __m128i bias_08 = _mm_loadu_si128((const __m128i*)&mtx->bias_[8]);
941      const __m128i bias_12 = _mm_loadu_si128((const __m128i*)&mtx->bias_[12]);
942      out_00 = _mm_add_epi32(out_00, bias_00);
943      out_04 = _mm_add_epi32(out_04, bias_04);
944      out_08 = _mm_add_epi32(out_08, bias_08);
945      out_12 = _mm_add_epi32(out_12, bias_12);
946      out_00 = _mm_srai_epi32(out_00, QFIX);
947      out_04 = _mm_srai_epi32(out_04, QFIX);
948      out_08 = _mm_srai_epi32(out_08, QFIX);
949      out_12 = _mm_srai_epi32(out_12, QFIX);
950      out0 = _mm_packs_epi32(out_00, out_04);
951      out8 = _mm_packs_epi32(out_08, out_12);
952      out0 = _mm_min_epi16(out0, max_coeff_2047);
953      out8 = _mm_min_epi16(out8, max_coeff_2047);
954    }
955    out0 = _mm_xor_si128(out0, sign0);
956    out8 = _mm_xor_si128(out8, sign8);
957    out0 = _mm_sub_epi16(out0, sign0);
958    out8 = _mm_sub_epi16(out8, sign8);
959    in0 = _mm_mullo_epi16(out0, q0);
960    in8 = _mm_mullo_epi16(out8, q8);
961    _mm_storeu_si128((__m128i*)&in[0], in0);
962    _mm_storeu_si128((__m128i*)&in[8], in8);
963    {
964      __m128i outZ0, outZ8;
965      outZ0 = _mm_shufflehi_epi16(out0,  _MM_SHUFFLE(2, 1, 3, 0));
966      outZ0 = _mm_shuffle_epi32  (outZ0, _MM_SHUFFLE(3, 1, 2, 0));
967      outZ0 = _mm_shufflehi_epi16(outZ0, _MM_SHUFFLE(3, 1, 0, 2));
968      outZ8 = _mm_shufflelo_epi16(out8,  _MM_SHUFFLE(3, 0, 2, 1));
969      outZ8 = _mm_shuffle_epi32  (outZ8, _MM_SHUFFLE(3, 1, 2, 0));
970      outZ8 = _mm_shufflelo_epi16(outZ8, _MM_SHUFFLE(1, 3, 2, 0));
971      _mm_storeu_si128((__m128i*)&out[0], outZ0);
972      _mm_storeu_si128((__m128i*)&out[8], outZ8);
973      packed_out = _mm_packs_epi16(outZ0, outZ8);
974    }
975    {
976      const int16_t outZ_12 = out[12];
977      const int16_t outZ_3 = out[3];
978      out[3] = outZ_12;
979      out[12] = outZ_3;
980    }
981    return (_mm_movemask_epi8(_mm_cmpeq_epi8(packed_out, zero)) != 0xffff);
982  }
983  static int QuantizeBlock_SSE2(int16_t in[16], int16_t out[16],
984                                const VP8Matrix* const mtx) {
985    return DoQuantizeBlock_SSE2(in, out, &mtx->sharpen_[0], mtx);
986  }
987  static int QuantizeBlockWHT_SSE2(int16_t in[16], int16_t out[16],
988                                   const VP8Matrix* const mtx) {
989    return DoQuantizeBlock_SSE2(in, out, NULL, mtx);
990  }
991  static int Quantize2Blocks_SSE2(int16_t in[32], int16_t out[32],
992                                  const VP8Matrix* const mtx) {
993    int nz;
994    const uint16_t* const sharpen = &mtx->sharpen_[0];
995    nz  = DoQuantizeBlock_SSE2(in + 0 * 16, out + 0 * 16, sharpen, mtx) << 0;
996    nz |= DoQuantizeBlock_SSE2(in + 1 * 16, out + 1 * 16, sharpen, mtx) << 1;
997    return nz;
998  }
999  extern void VP8EncDspInitSSE2(void);
1000  WEBP_TSAN_IGNORE_FUNCTION void VP8EncDspInitSSE2(void) {
1001    VP8CollectHistogram = CollectHistogram_SSE2;
1002    VP8EncPredLuma16 = Intra16Preds_SSE2;
1003    VP8EncPredChroma8 = IntraChromaPreds_SSE2;
1004    VP8EncPredLuma4 = Intra4Preds_SSE2;
1005    VP8EncQuantizeBlock = QuantizeBlock_SSE2;
1006    VP8EncQuantize2Blocks = Quantize2Blocks_SSE2;
1007    VP8EncQuantizeBlockWHT = QuantizeBlockWHT_SSE2;
1008    VP8ITransform = ITransform_SSE2;
1009    VP8FTransform = FTransform_SSE2;
1010    VP8FTransform2 = FTransform2_SSE2;
1011    VP8FTransformWHT = FTransformWHT_SSE2;
1012    VP8SSE16x16 = SSE16x16_SSE2;
1013    VP8SSE16x8 = SSE16x8_SSE2;
1014    VP8SSE8x8 = SSE8x8_SSE2;
1015    VP8SSE4x4 = SSE4x4_SSE2;
1016    VP8TDisto4x4 = Disto4x4_SSE2;
1017    VP8TDisto16x16 = Disto16x16_SSE2;
1018    VP8Mean16x4 = Mean16x4_SSE2;
1019  }
1020  #else  
1021  WEBP_DSP_INIT_STUB(VP8EncDspInitSSE2)
1022  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-transpose.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_sse2.c</div>
                </div>
                <div class="column column_space"><pre><code>49  static void dotile(INT n0l, INT n0u, INT n1l, INT n1u, void *args)
50  {
51       struct transpose_closure *k = (struct transpose_closure *)args;
52       R *I = k->I;
53       INT s0 = k->s0, s1 = k->s1, vl = k->vl;
</pre></code></div>
                <div class="column column_space"><pre><code>520  static WEBP_INLINE void HE4_SSE2(uint8_t* dst,
521                                   const uint8_t* top) {  
522    const int X = top[-1];
523    const int I = top[-2];
524    const int J = top[-3];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    